function getCounts ( langs = [ ] ) { return { langs : langs . length , modelLangs : langs . filter ( ( { models } ) => models && ! ! models . length ) . length , models : langs . map ( ( { models } ) => ( models ? models . length : 0 ) ) . reduce ( ( a , b ) => a + b , 0 ) , } } 
function ( type , _ , __ ) { var types = [ '#([\\s\\S])+?' , 
function ( ) { var realValue = this . value ; realValue = isNaN ( realValue ) ? 0 : realValue ; realValue = realValue < options . min ? options . min : realValue ; realValue = realValue > options . max ? options . max : realValue ; this . value = realValue ; var inputScale = ( realValue - options . min ) / ( options . max - options . min ) * 100 / step ; change ( inputScale , 0 ) ; } 
function ( e , index , liElem , options ) { options = options || { } ; var othis = liElem || $ ( this ) , index = index || othis . parent ( ) . children ( 'li' ) . index ( othis ) , parents = options . headerElem ? othis . parent ( ) : othis . parents ( '.layui-tab' ) . eq ( 0 ) , item = options . bodyElem ? $ ( options . bodyElem ) : parents . children ( '.layui-tab-content' ) . children ( '.layui-tab-item' ) , elemA = othis . find ( 'a' ) , filter = parents . attr ( 'lay-filter' ) ; if ( ! ( elemA . attr ( 'href' ) !== 'javascript:;' && elemA . attr ( 'target' ) === '_blank' ) ) { othis . addClass ( THIS ) . siblings ( ) . removeClass ( THIS ) ; item . eq ( index ) . addClass ( SHOW ) . siblings ( ) . removeClass ( SHOW ) ; } layui . event . call ( this , MOD_NAME , 'tab(' + filter + ')' , { elem : parents , index : index } ) ; } 
function ( ver ) { ver = ver === 'open' ; 
function ( req , res , next ) { if ( req . url . indexOf ( '/api/mock' ) === - 1 ) { return next ( ) ; } var data = url . parse ( req . url , true ) . query ; setTimeout ( function ( ) { res . statusCode = data . statusCode || 200 ; res . setHeader ( 'content-type' , data . contentType || 'json' ) ; res . end ( data . response || '{}' ) ; } , data . timeout || 0 ) ; } 
function ( node , name ) { var style = node . currentStyle ? node . currentStyle : window . getComputedStyle ( node , null ) ; return style [ style . getPropertyValue ? 'getPropertyValue' : 'getAttribute' ] ( name ) ; } 
function ( callback ) { var cssname = 'layer' , ver = '' , path = ( isLayui ? 'modules/layer/' : 'theme/' ) + 'default/layer.css?v=' + layer . v + ver ; isLayui ? layui . addcss ( path , callback , cssname ) : ready . link ( path , callback , cssname ) ; return this ; } 
function ( content , options , yes ) { var type = typeof options === 'function' ; if ( type ) yes = options ; return layer . open ( $ . extend ( { content : content , yes : yes } , type ? { } : options ) ) ; } 
function cancel ( ) { var close = config . cancel && config . cancel ( that . index , layero ) ; close === false || layer . close ( that . index ) ; } 
function ( ) { data = [ ] ; parent . find ( options . img ) . each ( function ( index ) { var othis = $ ( this ) ; othis . attr ( 'layer-index' , index ) ; data . push ( { alt : othis . attr ( 'alt' ) , pid : othis . attr ( 'layer-pid' ) , src : othis . attr ( 'layer-src' ) || othis . attr ( 'src' ) , thumb : othis . attr ( 'src' ) } ) ; } ) } 
function loadImage ( url , callback , error ) { var img = new Image ( ) ; img . src = url ; if ( img . complete ) { return callback ( img ) ; } img . onload = function ( ) { img . onload = null ; callback ( img ) ; } ; img . onerror = function ( e ) { img . onerror = null ; error ( e ) ; } ; } 
function ( sets ) { var othis = $ ( this ) , index = othis . parents ( 'tr' ) . eq ( 0 ) . data ( 'index' ) , tr = that . layBody . find ( 'tr[data-index="' + index + '"]' ) , data = table . cache [ that . key ] [ index ] ; return $ . extend ( { tr : tr 
function ( eventType ) { var othis = $ ( this ) ; layui . event . call ( this , MOD_NAME , eventType + '(' + filter + ')' , commonMember . call ( othis . children ( 'td' ) [ 0 ] ) ) ; } 
function ( hide ) { var othis = $ ( this ) , elemCell = othis . children ( ELEM_CELL ) ; if ( hide ) { othis . find ( '.layui-table-grid-down' ) . remove ( ) ; } else if ( elemCell . prop ( 'scrollWidth' ) > elemCell . outerWidth ( ) ) { if ( elemCell . find ( '.' + ELEM_GRID_DOWN ) [ 0 ] ) return ; othis . append ( '<div class="' + ELEM_GRID_DOWN + '"><i class="layui-icon layui-icon-down"></i></div>' ) ; } } 
function ( obj ) { layui . each ( obj || arrs , function ( i , item ) { if ( item . CHILD_COLS ) return eachArrs ( item . CHILD_COLS ) ; typeof callback === 'function' && callback ( i , item ) ; } ) ; } 
function ( ) { var TIPS = '请选择', CLAS S = 'la u -form-select', TITL E = 'la u -select-title' , NONE = 'layui-select-none' , initValue = '' , thatInput , selects = elemForm . find ( 'select' ) 
function ( ) { var top = reElem . offset ( ) . top + reElem . outerHeight ( ) + 5 - $win . scrollTop ( ) , dlHeight = dl . outerHeight ( ) ; index = select [ 0 ] . selectedIndex ; 
function ( choose ) { reElem . removeClass ( CLASS + 'ed ' + CLASS + 'up' ) ; input . blur ( ) ; nearElem = null ; if ( choose ) return ; notOption ( input . val ( ) , function ( none ) { var selectedIndex = select [ 0 ] . selectedIndex ; 
function ( ) { var thisDd = dl . children ( 'dd.' + THIS ) ; if ( ! thisDd [ 0 ] ) return ; var posTop = thisDd . position ( ) . top , dlHeight = dl . height ( ) , ddHeight = thisDd . height ( ) ; 
function ( value , callback , origin ) { var num = 0 ; layui . each ( dds , function ( ) { var othis = $ ( this ) , text = othis . text ( ) , not = text . indexOf ( value ) === - 1 ; if ( value === '' || ( origin === 'blur' ) ? value !== text : not ) num ++ ; origin === 'keyup' && othis [ not ? 'addClass' : 'removeClass' ] ( HIDE ) ; } ) ; var none = num === dds . length ; return callback ( none ) , none ; } 
function ( e ) { var value = this . value , keyCode = e . keyCode ; if ( keyCode === 9 || keyCode === 13 || keyCode === 37 || keyCode === 38 || keyCode === 39 || keyCode === 40 ) { return false ; } notOption ( value , function ( none ) { if ( none ) { dl . find ( '.' + NONE ) [ 0 ] || dl . append ( '<p class="' + NONE + '">无匹配项</p>'); } else { dl . find ( '.' + NONE ) . remove ( ) ; } } , 'keyup' ) ; if ( value === '' ) { dl . find ( '.' + NONE ) . remove ( ) ; } followScroll ( ) ; 
function ( ) { var button = $ ( this ) , verify = form . config . verify , stop = null , DANGER = 'layui-form-danger' , field = { } , elem = button . parents ( ELEM ) , verifyElem = elem . find ( '*[lay-verify]' ) 
function ( ) { lay ( ul ) . find ( 'ol' ) . each ( function ( i , ol ) { lay ( ol ) . find ( 'li' ) . each ( function ( ii , li ) { that . limit ( lay ( li ) , [ { hours : ii } , { hours : that [ startEnd ] . hours , minutes : ii } , { hours : that [ startEnd ] . hours , minutes : that [ startEnd ] . minutes , seconds : ii } ] [ i ] , index , [ [ 'hours' ] , [ 'hours' , 'minutes' ] , [ 'hours' , 'minutes' , 'seconds' ] ] [ i ] ) ; } ) ; } ) ; if ( ! options . range ) that . limit ( lay ( that . footer ) . find ( ELEM_CONFIRM ) , that [ startEnd ] , 0 , [ 'hours' , 'minutes' , 'seconds' ] ) ; } 
function ( ) { if ( lay ( btn ) . hasClass ( DISABLED ) ) return ; that . list ( 'time' , 0 ) ; options . range && that . list ( 'time' , 1 ) ; lay ( btn ) . attr ( 'lay-type' , 'date' ) . html ( that . lang ( ) . dateTips ) ; } 
function ( html , over ) { html = $ ( html ) ; more . before ( html ) ; over = over == 0 ? true : null ; over ? more . html ( end ) : more . find ( 'a' ) . html ( ELEM_TEXT ) ; isOver = over ; lock = null ; lazyimg && lazyimg ( ) ; } 
function ( ) { lock = true ; more . find ( 'a' ) . html ( ELEM_LOAD ) ; typeof options . done === 'function' && options . done ( ++ page , next ) ; } 
function ( item , height ) { var start = scrollElem . scrollTop ( ) , end = start + height ; var elemTop = notDocment ? function ( ) { return item . offset ( ) . top - scrollElem . offset ( ) . top + start ; } ( ) : item . offset ( ) . top ; if ( elemTop >= start && elemTop <= end ) { if ( ! item . attr ( 'src' ) ) { var src = item . attr ( 'lay-src' ) ; layui . img ( src , function ( ) { var next = that . lazyimg . elem . eq ( index ) ; item . attr ( 'src' , src ) . removeAttr ( 'lay-src' ) ; next [ 0 ] && render ( next ) ; index ++ ; } ) ; } } } 
function ( othis , scroll ) { 
function ( othis ) { elemColorBoxSpan [ 0 ] . style . background = '' ; that . elemColorBox . find ( '.' + PICKER_TRIG_I ) . removeClass ( ICON_PICKER_DOWN ) . addClass ( ICON_PICKER_CLOSE ) ; that . color = '' ; options . done && options . done ( '' ) ; that . removePicker ( ) ; } 
function className ( node , value ) { var klass = node . className || '' , svg = klass && klass . baseVal !== undefined if ( value === undefined ) return svg ? klass . baseVal : klass svg ? ( klass . baseVal = value ) : ( node . className = value ) } 
function deserializeValue ( value ) { try { return value ? value == "true" || ( value == "false" ? false : value == "null" ? null : + value + "" == value ? + value : / ^[\[\{] / . test ( value ) ? $ . parseJSON ( value ) : value ) : value } catch ( e ) { return value } } 
function ajaxComplete ( status , xhr , settings ) { var context = settings . context settings . complete . call ( context , xhr , status ) triggerGlobal ( settings , context , 'ajaxComplete' , [ xhr , settings ] ) ajaxStop ( settings ) } 
function parseArguments ( url , data , success , dataType ) { if ( $ . isFunction ( data ) ) dataType = success , success = data , data = undefined if ( ! $ . isFunction ( success ) ) dataType = success , success = undefined return { url : url , data : data , success : success , dataType : dataType } } 
function ( editor , textArea , set ) { var that = this , iframe = editor . find ( 'iframe' ) ; iframe . css ( { height : set . height } ) . on ( 'load' , function ( ) { var conts = iframe . contents ( ) , iframeWin = iframe . prop ( 'contentWindow' ) , head = conts . find ( 'head' ) , style = $ ( [ '<style>' , '*{margin: 0; padding: 0;}' , 'body{padding: 10px; line-height: 20px; overflow-x: hidden; word-wrap: break-word; font: 14px Helvetica Neue,Helvetica,PingFang SC,Microsoft YaHei,Tahoma,Arial,sans-serif; -webkit-box-sizing: border-box !important; -moz-box-sizing: border-box !important; box-sizing: border-box !important;}' , 'a{color:#01AAED; text-decoration:none;}a:hover{color:#c00}' , 'p{margin-bottom: 10px;}' , 'img{display: inline-block; border: none; vertical-align: middle;}' , 'pre{margin: 10px 0; padding: 10px; line-height: 20px; border: 1px solid #ddd; border-left-width: 6px; background-color: #F2F2F2; color: #333; font-family: Courier New; font-size: 12px;}' , '</style>' ] . join ( '' ) ) , body = conts . find ( 'body' ) ; head . append ( style ) ; body . attr ( 'contenteditable' , 'true' ) . css ( { 'min-height' : set . height } ) . html ( textArea . value || '' ) ; hotkey . apply ( that , [ iframeWin , iframe , textArea , set ] ) ; 
function ( html ) { if ( device . ie == 8 ) { html = html . replace ( / <.+> / g , function ( str ) { return str . toLowerCase ( ) ; } ) ; } return html ; } 
function ( iframeWin , iframe , textArea , set ) { var iframeDOM = iframeWin . document , body = $ ( iframeDOM . body ) ; body . on ( 'keydown' , function ( e ) { var keycode = e . keyCode ; 
function ( body ) { var iframeWin = this , iframeDOM = iframeWin . document ; 
function ( tagName , attr , range ) { var iframeDOM = this . document , elem = document . createElement ( tagName ) for ( var key in attr ) { elem . setAttribute ( key , attr [ key ] ) ; } elem . removeAttribute ( 'text' ) ; if ( iframeDOM . selection ) { 
function ( tools , othis ) { var iframeDOM = this . document , CHECK = 'layedit-tool-active' , container = getContainer ( Range ( iframeDOM ) ) , item = function ( type ) { return tools . find ( '.layedit-tool-' + type ) } if ( othis ) { othis [ othis . hasClass ( CHECK ) ? 'removeClass' : 'addClass' ] ( CHECK ) ; } tools . find ( '>i' ) . removeClass ( CHECK ) ; item ( 'unlink' ) . addClass ( ABLED ) ; $ ( container ) . parents ( ) . each ( function ( ) { var tagName = this . tagName . toLowerCase ( ) , textAlign = this . style . textAlign ; 
function ( iframeWin , editor , set ) { var iframeDOM = iframeWin . document , body = $ ( iframeDOM . body ) , toolEvent = { 
function ( range ) { var container = getContainer ( range ) , parentNode = $ ( container ) . parent ( ) ; link . call ( body , { href : parentNode . attr ( 'href' ) , target : parentNode . attr ( 'target' ) } , function ( field ) { var parent = parentNode [ 0 ] ; if ( parent . tagName === 'A' ) { parent . href = field . url ; } else { insertInline . call ( iframeWin , 'a' , { target : field . target , href : field . url , text : field . url } , range ) ; } } ) ; } 
function ( callback ) { 
function ( callback ) { var body = this , index = layer . open ( { type : 1 , id : 'LAY_layedit_code' , area : '550px' , shade : 0.05 , shadeClose : true , moveType : 1 , title : '插入代码' , skin : 'layui-layer-msg' , content : [ '<ul class="layui-form layui-form-pane" style="margin: 15px;">' , '<li class="layui-form-item">' , '<label class="layui-form-label">请选择语言</label>' , '<div class="layui-input-block">' , '<select name="lang">' , '<option value="JavaScript">JavaScript</option>' , '<option value="HTML">HTML</option>' , '<option value="CSS">CSS</option>' , '<option value="Java">Java</option>' , '<option value="PHP">PHP</option>' , '<option value="C#">C#</option>' , '<option value="Python">Python</option>' , '<option value="Ruby">Ruby</option>' , '<option value="Go">Go</option>' , '</select>' , '</div>' , '</li>' , '<li class="layui-form-item layui-form-text">' , '<label class="layui-form-label">代码</label>' , '<div class="layui-input-block">' , '<textarea name="code" lay-verify="required" autofocus="true" class="layui-textarea" style="height: 200px;"></textarea>' , '</div>' , '</li>' , '<li class="layui-form-item" style="text-align: center;">' , '<button type="button" lay-submit lay-filter="layedit-code-yes" class="layui-btn"> 确定 </button>' , '<button style="margin-left: 20px;" type="button" class="layui-btn layui-btn-primary"> 取消 </button>' , '</li>' , '</ul>' ] . join ( '' ) , success : function ( layero , index ) { var eventFilter = 'submit(layedit-code-yes)' ; form . render ( 'select' ) ; layero . find ( '.layui-btn-primary' ) . on ( 'click' , function ( ) { layer . close ( index ) ; body . focus ( ) ; } ) ; form . on ( eventFilter , function ( data ) { layer . close ( code . index ) ; callback && callback ( data . field ) ; } ) ; } } ) ; code . index = index ; } 
function ( options ) { var ELEM = 'layui-fixbar' , TOP_BAR = 'layui-fixbar-top' , dom = $ ( document ) , body = $ ( 'body' ) , is , timer ; options = $ . extend ( { showHeight : 200 
function onScriptLoad ( e , url ) { var readyRegExp = navigator . platform === 'PLaySTATION 3' ? / ^complete$ / : / ^(complete|loaded)$ / if ( e . type === 'load' || ( readyRegExp . test ( ( e . currentTarget || e . srcElement ) . readyState ) ) ) { config . modules [ item ] = url ; head . removeChild ( node ) ; ( function poll ( ) { if ( ++ timeout > config . timeout * 1000 / 4 ) { return error ( item + ' is not a valid module' ) ; } ; config . status [ item ] ? onCallback ( ) : setTimeout ( poll , 4 ) ; } ( ) ) ; } } 
function onCallback ( ) { exports . push ( layui [ item ] ) ; apps . length > 1 ? that . use ( apps . slice ( 1 ) , callback , exports ) : ( typeof callback === 'function' && callback . apply ( layui , exports ) ) ; } 
function ( ) { if ( elem . data ( 'spread' ) ) { elem . data ( 'spread' , null ) ul . removeClass ( 'layui-show' ) ; arrow . html ( icon . arrow [ 0 ] ) ; a . find ( '.layui-icon' ) . html ( icon . branch [ 0 ] ) ; } else { elem . data ( 'spread' , true ) ; ul . addClass ( 'layui-show' ) ; arrow . html ( icon . arrow [ 1 ] ) ; a . find ( '.layui-icon' ) . html ( icon . branch [ 1 ] ) ; } } 
function once ( fn ) { let called = false return function ( ... args ) { if ( called ) return called = true return fn . apply ( this , args ) } } 
function guardRoute ( to , from , next ) { if ( window . confirm ( ` ${ to . path } ` ) ) { next ( ) } else if ( window . confirm ( ` ` ) ) { next ( '/baz' ) } else { next ( false ) } } 
function jsfiddleTag ( args , content ) { const id = args [ 0 ] ; const tabs = args [ 1 ] && args [ 1 ] !== 'default' ? args [ 1 ] : 'js,resources,html,css,result' ; const skin = args [ 2 ] && args [ 2 ] !== 'default' ? args [ 2 ] : 'light' ; const width = args [ 3 ] && args [ 3 ] !== 'default' ? args [ 3 ] : '100%' ; const height = args [ 4 ] && args [ 4 ] !== 'default' ? args [ 4 ] : '300' ; return ` ${ width } ${ height } ${ id } ${ tabs } ${ skin } ` ; } 
function linkTag ( args , content ) { let url = '' ; const text = [ ] ; let external = false ; let title = '' ; let i = 0 ; const len = args . length ; 
function getHighlightOptions ( config , arg ) { let lang = '' ; if ( rLang . test ( arg ) ) { arg = arg . replace ( rLang , ( match , _lang ) => { lang = _lang ; return '' ; } ) ; } let line_number = config . line_number ; if ( rLineNumber . test ( arg ) ) { arg = arg . replace ( rLineNumber , ( match , _line_number ) => { line_number = _line_number === 'true' ; return '' ; } ) ; } let first_line = 1 ; if ( rFirstLine . test ( arg ) ) { arg = arg . replace ( rFirstLine , ( match , _first_line ) => { first_line = _first_line ; return '' ; } ) ; } let mark = [ ] ; if ( rMark . test ( arg ) ) { arg = arg . replace ( rMark , ( match , _mark ) => { mark = _mark . split ( ',' ) . reduce ( function getMarkedLines ( prev , cur ) { if ( / - / . test ( cur ) ) { let a = Number ( cur . substr ( 0 , cur . indexOf ( '-' ) ) ) ; let b = Number ( cur . substr ( cur . indexOf ( '-' ) + 1 ) ) ; if ( b < a ) { 
function pipeStream ( ... args ) { const src = args . shift ( ) ; return new Promise ( ( resolve , reject ) => { let stream = src . on ( 'error' , reject ) ; let target ; while ( ( target = args . shift ( ) ) != null ) { stream = stream . pipe ( target ) . on ( 'error' , reject ) ; } stream . on ( 'finish' , resolve ) ; stream . on ( 'end' , resolve ) ; stream . on ( 'close' , resolve ) ; } ) ; } 
function gistTag ( args , content ) { const id = args . shift ( ) ; const file = args . length ? ` ${ args [ 0 ] } ` : '' ; return ` ${ id } ${ file } ` ; } 
function iframeTag ( args , content ) { const url = args [ 0 ] ; const width = args [ 1 ] && args [ 1 ] !== 'default' ? args [ 1 ] : '100%' ; const height = args [ 2 ] && args [ 2 ] !== 'default' ? args [ 2 ] : '300' ; return ` ${ url } ${ width } ${ height } ` ; } 
function formatNunjucksError ( err , input ) { const match = err . message . match ( / Line (\d+), Column \d+ / ) ; if ( ! match ) return err ; const errLine = parseInt ( match [ 1 ] , 10 ) ; if ( isNaN ( errLine ) ) return err ; 
function ( event , context , responseStatus , physicalResourceId , responseData , reason ) { return new Promise ( ( resolve , reject ) => { const https = require ( 'https' ) ; const { URL } = require ( 'url' ) ; var responseBody = JSON . stringify ( { Status : responseStatus , Reason : reason , PhysicalResourceId : physicalResourceId || context . logStreamName , StackId : event . StackId , RequestId : event . RequestId , LogicalResourceId : event . LogicalResourceId , Data : responseData } ) ; const parsedUrl = new URL ( event . ResponseURL || defaultResponseURL ) ; const options = { hostname : parsedUrl . hostname , port : 443 , path : parsedUrl . pathname + parsedUrl . search , method : 'PUT' , headers : { 'Content-Type' : '' , 'Content-Length' : responseBody . length } } ; https . request ( options ) . on ( 'error' , reject ) . on ( 'response' , res => { res . resume ( ) ; if ( res . statusCode >= 400 ) { reject ( new Error ( ` ${ res . statusCode } ${ res . statusMessage } ` ) ) ; } else { resolve ( ) ; } } ) . end ( responseBody , 'utf8' ) ; } ) ; } 
async function ( requestId , domainName , subjectAlternativeNames , hostedZoneId ) { const crypto = require ( 'crypto' ) ; const acm = new aws . ACM ( ) ; const route53 = new aws . Route53 ( ) ; if ( waiter ) { 
async function ( arn ) { const acm = new aws . ACM ( ) ; console . log ( ` ${ arn } ` ) ; try { await acm . deleteCertificate ( { CertificateArn : arn } ) . promise ( ) ; } catch ( err ) { if ( err . name !== 'ResourceNotFoundException' ) { throw err ; } } } 
async function getAdopter ( name ) { try { const policyResponse = await ecr . getRepositoryPolicy ( { repositoryName : name } ) . promise ( ) ; const policy = JSON . parse ( policyResponse . policyText ) ; 
function calculateLineHeight ( model , columnWidths ) { var padding = this . internal . __cell__ . padding ; var fontSize = this . internal . __cell__ . table_font_size ; var scaleFactor = this . internal . scaleFactor ; return Object . keys ( model ) . map ( function ( value ) { return typeof value === 'object' ? value . text : value } ) . map ( function ( value ) { return this . splitTextToSize ( value , columnWidths [ value ] - padding - padding ) } , this ) . map ( function ( value ) { return this . getLineHeightFactor ( ) * value . length * fontSize / scaleFactor + padding + padding } , this ) . reduce ( function ( pv , cv ) { return Math . max ( pv , cv ) } , 0 ) ; } 
function makeWorker ( script ) { var URL = window . URL || window . webkitURL ; var Blob = window . Blob ; var Worker = window . Worker ; if ( ! URL || ! Blob || ! Worker || ! script ) { return null ; } var blob = new Blob ( [ script ] ) ; var worker = new Worker ( URL . createObjectURL ( blob ) ) ; return worker ; } 
function setupClipboard ( element , opts ) { if ( ! FileReaderJS . enabled ) { return ; } var instanceOptions = extend ( extend ( { } , FileReaderJS . opts ) , opts ) ; element . addEventListener ( "paste" , onpaste , false ) ; function onpaste ( e ) { var files = [ ] ; var clipboardData = e . clipboardData || { } ; var items = clipboardData . items || [ ] ; for ( var i = 0 ; i < items . length ; i ++ ) { var file = items [ i ] . getAsFile ( ) ; if ( file ) { 
function setupInput ( input , opts ) { if ( ! FileReaderJS . enabled ) { return ; } var instanceOptions = extend ( extend ( { } , FileReaderJS . opts ) , opts ) ; input . addEventListener ( "change" , inputChange , false ) ; input . addEventListener ( "drop" , inputDrop , false ) ; function inputChange ( e ) { processFileList ( e , input . files , instanceOptions ) ; } function inputDrop ( e ) { e . stopPropagation ( ) ; e . preventDefault ( ) ; processFileList ( e , e . dataTransfer . files , instanceOptions ) ; } } 
function setupDrop ( dropbox , opts ) { if ( ! FileReaderJS . enabled ) { return ; } var instanceOptions = extend ( extend ( { } , FileReaderJS . opts ) , opts ) ; var dragClass = instanceOptions . dragClass ; var initializedOnBody = false ; 
function setupCustomFileProperties ( files , groupID ) { for ( var i = 0 ; i < files . length ; i ++ ) { var file = files [ i ] ; file . extra = { nameNoExtension : file . name . substring ( 0 , file . name . lastIndexOf ( '.' ) ) , extension : file . name . substring ( file . name . lastIndexOf ( '.' ) + 1 ) , fileID : i , uniqueID : getUniqueID ( ) , groupID : groupID , prettySize : prettySize ( file . size ) } ; } } 
function getReadAsMethod ( type , readAsMap , readAsDefault ) { for ( var r in readAsMap ) { if ( type . match ( new RegExp ( r ) ) ) { return 'readAs' + readAsMap [ r ] ; } } return 'readAs' + readAsDefault ; } 
function processFileList ( e , files , opts ) { var filesLeft = files . length ; var group = { groupID : getGroupID ( ) , files : files , started : new Date ( ) } ; function groupEnd ( ) { group . ended = new Date ( ) ; opts . on . groupend ( group ) ; } function groupFileDone ( ) { if ( -- filesLeft === 0 ) { groupEnd ( ) ; } } FileReaderJS . output . push ( group ) ; setupCustomFileProperties ( files , group . groupID ) ; opts . on . groupstart ( group ) ; 
function checkFileReaderSyncSupport ( ) { var worker = makeWorker ( syncDetectionScript ) ; if ( worker ) { worker . onmessage = function ( e ) { FileReaderSyncSupport = e . data ; } ; worker . postMessage ( { } ) ; } } 
function addClass ( el , name ) { if ( ! hasClass ( el , name ) ) { el . className = el . className ? [ el . className , name ] . join ( ' ' ) : name ; } } 
function removeClass ( el , name ) { if ( hasClass ( el , name ) ) { var c = el . className ; el . className = c . replace ( new RegExp ( "(?:^|\\s+)" + name + "(?:\\s+|$)" , "g" ) , " " ) . replace ( / ^\s\s* / , '' ) . replace ( / \s\s*$ / , '' ) ; } } 
function prettySize ( bytes ) { var s = [ 'bytes' , 'kb' , 'MB' , 'GB' , 'TB' , 'PB' ] ; var e = Math . floor ( Math . log ( bytes ) / Math . log ( 1024 ) ) ; return ( bytes / Math . pow ( 1024 , Math . floor ( e ) ) ) . toFixed ( 2 ) + " " + s [ e ] ; } 
function monkeyPatch ( ) { return { transform : ( code , id ) => { var file = id . split ( '/' ) . pop ( ) // Only one define call per module is allowed by requirejs so // we have to remove calls that other libraries make if ( file === 'FileSaver.js' ) { code = code . replace ( / define !== null\) && \(define.amd != null / g , '0' ) } else if ( file === 'html2canvas.js' ) { code = code . replace ( / &&\s+define.amd / g , '&& define.amd && false' ) } return code } } } 
function rawjs ( opts ) { opts = opts || { } return { transform : ( code , id ) => { var variable = opts [ id . split ( '/' ) . pop ( ) ] if ( ! variable ) return code var keepStr = '/*rollup-keeper-start*/window.tmp=' + variable + ';/*rollup-keeper-end*/' return code + keepStr } , transformBundle : ( code ) => { for ( var file in opts ) { var r = new RegExp ( opts [ file ] + '\\$\\d+' , 'g' ) code = code . replace ( r , opts [ file ] ) } var re = / \/\*rollup-keeper-start\*\/.*\/\*rollup-keeper-end\*\/ / g return code . replace ( re , '' ) } } } 
function ( imgData ) { var width , height , numcomponents ; var blockLength = imgData . charCodeAt ( 4 ) * 256 + imgData . charCodeAt ( 5 ) ; var len = imgData . length ; var result = { width : 0 , height : 0 , numcomponents : 1 } ; for ( var i = 4 ; i < len ; i += 2 ) { i += blockLength ; if ( markers . indexOf ( imgData . charCodeAt ( i + 1 ) ) !== - 1 ) { height = imgData . charCodeAt ( i + 5 ) * 256 + imgData . charCodeAt ( i + 6 ) ; width = imgData . charCodeAt ( i + 7 ) * 256 + imgData . charCodeAt ( i + 8 ) ; numcomponents = imgData . charCodeAt ( i + 9 ) ; result = { width : width , height : height , numcomponents : numcomponents } ; break ; } else { blockLength = imgData . charCodeAt ( i + 2 ) * 256 + imgData . charCodeAt ( i + 3 ) ; } } return result ; } 
function BmpDecoder ( buffer , is_with_alpha ) { this . pos = 0 ; this . buffer = buffer ; this . datav = new DataView ( buffer . buffer ) ; this . is_with_alpha = ! ! is_with_alpha ; this . bottom_up = true ; this . flag = String . fromCharCode ( this . buffer [ 0 ] ) + String . fromCharCode ( this . buffer [ 1 ] ) ; this . pos += 2 ; if ( [ "BM" , "BA" , "CI" , "CP" , "IC" , "PT" ] . indexOf ( this . flag ) === - 1 ) throw new Error ( "Invalid BMP File" ) ; this . parseHeader ( ) ; this . parseBGR ( ) ; } 
function ( tagName , opt ) { var el = document . createElement ( tagName ) ; if ( opt . className ) el . className = opt . className ; if ( opt . innerHTML ) { el . innerHTML = opt . innerHTML ; var scripts = el . getElementsByTagName ( 'script' ) ; for ( var i = scripts . length ; i -- > 0 ; ) { scripts [ i ] . parentNode . removeChild ( scripts [ i ] ) ; } } for ( var key in opt . style ) { el . style [ key ] = opt . style [ key ] ; } return el ; } 
function ( node , javascriptEnabled ) { 
function Worker ( opt ) { 
function StaticTree ( static_tree , extra_bits , extra_base , elems , max_length ) { var that = this ; that . static_tree = static_tree ; that . extra_bits = extra_bits ; that . extra_base = extra_base ; that . elems = elems ; that . max_length = max_length ; } 
function tr_init ( ) { l_desc . dyn_tree = dyn_ltree ; l_desc . stat_desc = StaticTree . static_l_desc ; d_desc . dyn_tree = dyn_dtree ; d_desc . stat_desc = StaticTree . static_d_desc ; bl_desc . dyn_tree = bl_tree ; bl_desc . stat_desc = StaticTree . static_bl_desc ; bi_buf = 0 ; bi_valid = 0 ; last_eob_len = 8 ; 
function _tr_align ( ) { send_bits ( STATIC_TREES << 1 , 3 ) ; send_code ( END_BLOCK , StaticTree . static_ltree ) ; bi_flush ( ) ; 
function _tr_tally ( dist , 
function compress_block ( ltree , dtree ) { var dist ; 
function copy_block ( buf , 
function _tr_stored_block ( buf , 
function deflate_stored ( flush ) { 
function ZStream ( ) { var that = this ; that . next_in_index = 0 ; that . next_out_index = 0 ; 
function ( buf , start , size ) { var that = this ; var len = that . avail_in ; if ( len > size ) len = size ; if ( len === 0 ) return 0 ; that . avail_in -= len ; buf . set ( that . next_in . subarray ( that . next_in_index , that . next_in_index + len ) , start ) ; that . next_in_index += len ; that . total_in += len ; return len ; } 
function ( ) { var that = this ; var len = that . dstate . pending ; if ( len > that . avail_out ) len = that . avail_out ; if ( len === 0 ) return ; 
function Deflater ( options ) { var that = this ; var z = new ZStream ( ) ; var bufsize = 512 ; var flush = Z_NO_FLUSH ; var buf = new Uint8Array ( bufsize ) ; var level = options ? options . level : Z_DEFAULT_COMPRESSION ; if ( typeof level === "undefined" ) level = Z_DEFAULT_COMPRESSION ; z . deflateInit ( level ) ; z . next_out = buf ; that . append = function ( data , onprogress ) { var err , buffers = [ ] , lastIndex = 0 , bufferIndex = 0 , bufferSize = 0 , array ; if ( ! data . length ) return ; z . next_in_index = 0 ; z . next_in = data ; z . avail_in = data . length ; do { z . next_out_index = 0 ; z . avail_out = bufsize ; err = z . deflate ( flush ) ; if ( err !== Z_OK ) throw new Error ( "deflating: " + z . msg ) ; if ( z . next_out_index ) if ( z . next_out_index === bufsize ) buffers . push ( new Uint8Array ( buf ) ) ; else buffers . push ( new Uint8Array ( buf . subarray ( 0 , z . next_out_index ) ) ) ; bufferSize += z . next_out_index ; if ( onprogress && z . next_in_index > 0 && z . next_in_index !== lastIndex ) { onprogress ( z . next_in_index ) ; lastIndex = z . next_in_index ; } } while ( z . avail_in > 0 || z . avail_out === 0 ) ; array = new Uint8Array ( bufferSize ) ; buffers . forEach ( function ( chunk ) { array . set ( chunk , bufferIndex ) ; bufferIndex += chunk . length ; } ) ; return array ; } ; that . flush = function ( ) { var err , buffers = [ ] , bufferIndex = 0 , bufferSize = 0 , array ; do { z . next_out_index = 0 ; z . avail_out = bufsize ; err = z . deflate ( Z_FINISH ) ; if ( err !== Z_STREAM_END && err !== Z_OK ) throw new Error ( "deflating: " + z . msg ) ; if ( bufsize - z . avail_out > 0 ) buffers . push ( new Uint8Array ( buf . subarray ( 0 , z . next_out_index ) ) ) ; bufferSize += z . next_out_index ; } while ( z . avail_in > 0 || z . avail_out === 0 ) ; z . deflateEnd ( ) ; array = new Uint8Array ( bufferSize ) ; buffers . forEach ( function ( chunk ) { array . set ( chunk , bufferIndex ) ; bufferIndex += chunk . length ; } ) ; return array ; } ; } 
function ( style ) { var rxRgb = / rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\) / ; var rxRgba = / rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\) / ; var rxTransparent = / transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\) / ; var r , g , b , a ; if ( style . isCanvasGradient === true ) { style = style . getColor ( ) ; } if ( ! style ) { return { r : 0 , g : 0 , b : 0 , a : 0 , style : style } ; } if ( rxTransparent . test ( style ) ) { r = 0 ; g = 0 ; b = 0 ; a = 0 ; } else { var matches = rxRgb . exec ( style ) ; if ( matches !== null ) { r = parseInt ( matches [ 1 ] ) ; g = parseInt ( matches [ 2 ] ) ; b = parseInt ( matches [ 3 ] ) ; a = 1 ; } else { matches = rxRgba . exec ( style ) ; if ( matches !== null ) { r = parseInt ( matches [ 1 ] ) ; g = parseInt ( matches [ 2 ] ) ; b = parseInt ( matches [ 3 ] ) ; a = parseFloat ( matches [ 4 ] ) ; } else { a = 1 ; if ( typeof style === "string" && style . charAt ( 0 ) !== '#' ) { var rgbColor = new RGBColor ( style ) ; if ( rgbColor . ok ) { style = rgbColor . toHex ( ) ; } else { style = '#000000' ; } } if ( style . length === 4 ) { r = style . substring ( 1 , 2 ) ; r += r ; g = style . substring ( 2 , 3 ) ; g += g ; b = style . substring ( 3 , 4 ) ; b += b ; } else { r = style . substring ( 1 , 3 ) ; g = style . substring ( 3 , 5 ) ; b = style . substring ( 5 , 7 ) ; } r = parseInt ( r , 16 ) ; g = parseInt ( g , 16 ) ; b = parseInt ( b , 16 ) ; } } } return { r : r , g : g , b : b , a : a , style : style } ; } 
function ( y ) { if ( this . pageWrapYEnabled ) { this . lastBreak = 0 ; var manualBreaks = 0 ; var autoBreaks = 0 ; for ( var i = 0 ; i < this . pageBreaks . length ; i ++ ) { if ( y >= this . pageBreaks [ i ] ) { manualBreaks ++ ; if ( this . lastBreak === 0 ) { autoBreaks ++ ; } var spaceBetweenLastBreak = this . pageBreaks [ i ] - this . lastBreak ; this . lastBreak = this . pageBreaks [ i ] ; var pagesSinceLastBreak = Math . floor ( spaceBetweenLastBreak / this . pageWrapY ) ; autoBreaks += pagesSinceLastBreak ; } } if ( this . lastBreak === 0 ) { var pagesSinceLastBreak = Math . floor ( y / this . pageWrapY ) + 1 ; autoBreaks += pagesSinceLastBreak ; } return autoBreaks + manualBreaks ; } else { return this . pdf . internal . getCurrentPageInfo ( ) . pageNumber ; } } 
function ( rule , isClip ) { if ( ( rule === 'stroke' ) && ! isClip && isStrokeTransparent . call ( this ) ) { return ; } if ( ( rule !== 'stroke' ) && ! isClip && isFillTransparent . call ( this ) ) { return ; } var moves = [ ] ; 
function ( radius , startAngle , endAngle , anticlockwise ) { var EPSILON = 0.00001 ; 
function ( ax , ay , bx , by , cx , cy , dx , dy ) { var tobx = bx - ax ; var toby = by - ay ; var tocx = cx - bx ; var tocy = cy - by ; var todx = dx - cx ; var tody = dy - cy ; var precision = 40 ; var d , i , px , py , qx , qy , rx , ry , tx , ty , sx , sy , x , y , minx , miny , maxx , maxy , toqx , toqy , torx , tory , totx , toty ; for ( i = 0 ; i < ( precision + 1 ) ; i ++ ) { d = i / precision ; px = ax + d * tobx ; py = ay + d * toby ; qx = bx + d * tocx ; qy = by + d * tocy ; rx = cx + d * todx ; ry = cy + d * tody ; toqx = qx - px ; toqy = qy - py ; torx = rx - qx ; tory = ry - qy ; sx = px + d * toqx ; sy = py + d * toqy ; tx = qx + d * torx ; ty = qy + d * tory ; totx = tx - sx ; toty = ty - sy ; x = sx + d * totx ; y = sy + d * toty ; if ( i == 0 ) { minx = x ; miny = y ; maxx = x ; maxy = y ; } else { minx = Math . min ( minx , x ) ; miny = Math . min ( miny , y ) ; maxx = Math . max ( maxx , x ) ; maxy = Math . max ( maxy , y ) ; } } return new Rectangle ( Math . round ( minx ) , Math . round ( miny ) , Math . round ( maxx - minx ) , Math . round ( maxy - miny ) ) ; } 
function click ( node ) { try { node . dispatchEvent ( new MouseEvent ( 'click' ) ) ; } catch ( e ) { var evt = document . createEvent ( 'MouseEvents' ) ; evt . initMouseEvent ( 'click' , true , true , window , 0 , 0 , 0 , 80 , 20 , false , false , false , false , 0 , null ) ; node . dispatchEvent ( evt ) ; } } 
function ( buffer1 , buffer2 ) { var combinedBuffer = new Uint8Array ( buffer1 . byteLength + buffer2 . byteLength ) ; combinedBuffer . set ( new Uint8Array ( buffer1 ) , 0 ) ; combinedBuffer . set ( new Uint8Array ( buffer2 ) , buffer1 . byteLength ) ; return combinedBuffer ; } 
function ( pageInfo ) { var pageNumber = pageInfo !== undefined ? pageInfo . pageNumber : 1 ; 
function PubSub ( context ) { if ( _typeof ( context ) !== 'object' ) { throw new Error ( 'Invalid Context passed to initialize PubSub (jsPDF-module)' ) ; } var topics = { } ; this . subscribe = function ( topic , callback , once ) { once = once || false ; if ( typeof topic !== 'string' || typeof callback !== 'function' || typeof once !== 'boolean' ) { throw new Error ( 'Invalid arguments passed to PubSub.subscribe (jsPDF-module)' ) ; } if ( ! topics . hasOwnProperty ( topic ) ) { topics [ topic ] = { } ; } var token = Math . random ( ) . toString ( 35 ) ; topics [ topic ] [ token ] = [ callback , ! ! once ] ; return token ; } ; this . unsubscribe = function ( token ) { for ( var topic in topics ) { if ( topics [ topic ] [ token ] ) { delete topics [ topic ] [ token ] ; if ( Object . keys ( topics [ topic ] ) . length === 0 ) { delete topics [ topic ] ; } return true ; } } return false ; } ; this . publish = function ( topic ) { if ( topics . hasOwnProperty ( topic ) ) { var args = Array . prototype . slice . call ( arguments , 1 ) , tokens = [ ] ; for ( var token in topics [ topic ] ) { var sub = topics [ topic ] [ token ] ; try { sub [ 0 ] . apply ( context , args ) ; } catch ( ex ) { if ( global . console ) { console . error ( 'jsPDF PubSub Error' , ex . message , ex ) ; } } if ( sub [ 1 ] ) tokens . push ( token ) ; } if ( tokens . length ) tokens . forEach ( this . unsubscribe ) ; } } ; this . getTopics = function ( ) { return topics ; } ; } 
function getFont ( fontName , fontStyle , options ) { var key = undefined , fontNameLowerCase ; options = options || { } ; fontName = fontName !== undefined ? fontName : fonts [ activeFontKey ] . fontName ; fontStyle = fontStyle !== undefined ? fontStyle : fonts [ activeFontKey ] . fontStyle ; fontNameLowerCase = fontName . toLowerCase ( ) ; if ( fontmap [ fontNameLowerCase ] !== undefined && fontmap [ fontNameLowerCase ] [ fontStyle ] !== undefined ) { key = fontmap [ fontNameLowerCase ] [ fontStyle ] ; } else if ( fontmap [ fontName ] !== undefined && fontmap [ fontName ] [ fontStyle ] !== undefined ) { key = fontmap [ fontName ] [ fontStyle ] ; } else { if ( options . disableWarning === false ) { console . warn ( "Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts." ) ; } } if ( ! key && ! options . noFallback ) { key = fontmap [ 'times' ] [ fontStyle ] ; if ( key == null ) { key = fontmap [ 'times' ] [ 'normal' ] ; } } return key ; } 
function calculateFontSpace ( text , formObject , fontSize ) { var font = scope . internal . getFont ( formObject . fontName , formObject . fontStyle ) ; var width = scope . getStringUnitWidth ( text , { font : font , fontSize : parseFloat ( fontSize ) , charSpace : 0 } ) * parseFloat ( fontSize ) ; var height = scope . getStringUnitWidth ( "3" , { font : font , fontSize : parseFloat ( fontSize ) , charSpace : 0 } ) * parseFloat ( fontSize ) * 1.5 ; return { height : height , width : width } ; } 
function createAnnotationReference ( object ) { var options = { type : 'reference' , object : object } ; var findEntry = function findEntry ( entry ) { return entry . type === options . type && entry . object === options . object ; } ; if ( scope . internal . getPageInfo ( object . page ) . pageContext . annotations . find ( findEntry ) === undefined ) { scope . internal . getPageInfo ( object . page ) . pageContext . annotations . push ( options ) ; } } 
function putCatalogCallback ( ) { 
function AcroFormDictionaryCallback ( ) { 
function createFieldCallback ( fieldArray ) { var standardFields = ! fieldArray ; if ( ! fieldArray ) { 
function AcroFormPDFObject ( ) { var _objId ; Object . defineProperty ( this , 'objId' , { configurable : true , get : function get ( ) { if ( ! _objId ) { _objId = scope . internal . newObjectDeferred ( ) ; } if ( ! _objId ) { throw new Error ( "AcroFormPDFObject: Couldn't create Object ID" ) ; } return _objId ; } , set : function set ( value ) { _objId = value ; } } ) ; } 
function AcroFormField ( ) { AcroFormPDFObject . call ( this ) ; * (PDF 1.2) If set, print the annotation when the page is printed. If clear, never print the annotation, regardless of wether is is displayed on the screen. * NOTE 2 This can be useful for annotations representing interactive pushbuttons, which would serve no meaningful purpose on the printed page. * * @name AcroFormField#showWhenPrinted * @default true * @type {boolean} */ Object . defineProperty ( this , 'showWhenPrinted' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( getBitForPdf ( _F , 3 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) === true ) { this . F = setBitForPdf ( _F , 3 ) ; } else { this . F = clearBitForPdf ( _F , 3 ) ; } } } ) ; var _Ff = 0 ; Object . defineProperty ( this , 'Ff' , { enumerable : false , configurable : false , get : function get ( ) { return _Ff ; } , set : function set ( value ) { if ( ! isNaN ( value ) ) { _Ff = value ; } else { throw new Error ( 'Invalid value "' + value + '" for attribute Ff supplied.' ) ; } } } ) ; var _Rect = [ ] ; Object . defineProperty ( this , 'Rect' , { enumerable : false , configurable : false , get : function get ( ) { if ( _Rect . length === 0 ) { return ; } return _Rect ; } , set : function set ( value ) { if ( typeof value !== "undefined" ) { _Rect = value ; } else { _Rect = [ ] ; } } } ) ; Object . defineProperty ( this , 'x' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect || isNaN ( _Rect [ 0 ] ) ) { return 0 ; } return antiScale ( _Rect [ 0 ] ) ; } , set : function set ( value ) { _Rect [ 0 ] = scale ( value ) ; } } ) ; Object . defineProperty ( this , 'y' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect || isNaN ( _Rect [ 1 ] ) ) { return 0 ; } return antiScale ( _Rect [ 1 ] ) ; } , set : function set ( value ) { _Rect [ 1 ] = scale ( value ) ; } } ) ; Object . defineProperty ( this , 'width' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect || isNaN ( _Rect [ 2 ] ) ) { return 0 ; } return antiScale ( _Rect [ 2 ] ) ; } , set : function set ( value ) { _Rect [ 2 ] = scale ( value ) ; } } ) ; Object . defineProperty ( this , 'height' , { enumerable : true , configurable : true , get : function get ( ) { if ( ! _Rect || isNaN ( _Rect [ 3 ] ) ) { return 0 ; } return antiScale ( _Rect [ 3 ] ) ; } , set : function set ( value ) { _Rect [ 3 ] = scale ( value ) ; } } ) ; var _FT = "" ; Object . defineProperty ( this , 'FT' , { enumerable : true , configurable : false , get : function get ( ) { return _FT ; } , set : function set ( value ) { switch ( value ) { case '/Btn' : case '/Tx' : case '/Ch' : case '/Sig' : _FT = value ; break ; default : throw new Error ( 'Invalid value "' + value + '" for attribute FT supplied.' ) ; } } } ) ; var _T = null ; Object . defineProperty ( this , 'T' , { enumerable : true , configurable : false , get : function get ( ) { if ( ! _T || _T . length < 1 ) { * (Optional) The partial field name (see 12.7.3.2, “Field Names”). * * @name AcroFormField#fieldName * @default null * @type {string} */ Object . defineProperty ( this , 'fieldName' , { configurable : true , enumerable : true , get : function get ( ) { return _T ; } , set : function set ( value ) { _T = value ; } } ) ; var _fontName = 'helvetica' ; Object . defineProperty ( this , 'fontName' , { enumerable : true , configurable : true , get : function get ( ) { return _fontName ; } , set : function set ( value ) { _fontName = value ; } } ) ; var _fontStyle = 'normal' ; Object . defineProperty ( this , 'fontStyle' , { enumerable : true , configurable : true , get : function get ( ) { return _fontStyle ; } , set : function set ( value ) { _fontStyle = value ; } } ) ; var _fontSize = 0 ; Object . defineProperty ( this , 'fontSize' , { enumerable : true , configurable : true , get : function get ( ) { return antiScale ( _fontSize ) ; } , set : function set ( value ) { _fontSize = scale ( value ) ; } } ) ; var _maxFontSize = 50 ; Object . defineProperty ( this , 'maxFontSize' , { enumerable : true , configurable : true , get : function get ( ) { return antiScale ( _maxFontSize ) ; } , set : function set ( value ) { _maxFontSize = scale ( value ) ; } } ) ; var _color = 'black' ; Object . defineProperty ( this , 'color' , { enumerable : true , configurable : true , get : function get ( ) { return _color ; } , set : function set ( value ) { _color = value ; } } ) ; var _DA = '/F1 0 Tf 0 g' ; * (Optional; inheritable) The default value to which the field reverts when a reset-form action is executed (see 12.7.5.3, “Reset-Form Action”). The format of this value is the same as that of value. * * @name AcroFormField#defaultValue * @default null * @type {any} */ Object . defineProperty ( this , 'defaultValue' , { enumerable : true , configurable : true , get : function get ( ) { if ( this instanceof AcroFormButton === true ) { return pdfUnescape ( _DV . substr ( 1 , _DV . length - 1 ) ) ; } else { return _DV ; } } , set : function set ( value ) { value = value . toString ( ) ; if ( this instanceof AcroFormButton === true ) { _DV = '/' + value ; } else { _DV = value ; } } } ) ; var _V = null ; Object . defineProperty ( this , 'V' , { enumerable : false , configurable : false , get : function get ( ) { if ( ! _V ) { return ; } if ( this instanceof AcroFormButton === false ) { return toPdfString ( _V ) ; } return _V ; } , set : function set ( value ) { value = value . toString ( ) ; if ( this instanceof AcroFormButton === false ) { if ( value . substr ( 0 , 1 ) === '(' ) { _V = pdfUnescape ( value . substr ( 1 , value . length - 2 ) ) ; } else { _V = pdfUnescape ( value ) ; } } else { _V = value ; } } } ) ; Object . defineProperty ( this , 'value' , { enumerable : true , configurable : true , get : function get ( ) { if ( this instanceof AcroFormButton === true ) { return pdfUnescape ( _V . substr ( 1 , _V . length - 1 ) ) ; } else { return _V ; } } , set : function set ( value ) { value = value . toString ( ) ; if ( this instanceof AcroFormButton === true ) { _V = '/' + value ; } else { _V = value ; } } } ) ; Object . defineProperty ( this , 'hasAnnotation' , { enumerable : true , configurable : true , get : function get ( ) { return this . Rect ; } } ) ; Object . defineProperty ( this , 'Type' , { enumerable : true , configurable : false , get : function get ( ) { return this . hasAnnotation ? "/Annot" : null ; } } ) ; Object . defineProperty ( this , 'Subtype' , { enumerable : true , configurable : false , get : function get ( ) { return this . hasAnnotation ? "/Widget" : null ; } } ) ; var _hasAppearanceStream = false ; Object . defineProperty ( this , 'hasAppearanceStream' , { enumerable : true , configurable : true , writeable : true , get : function get ( ) { return _hasAppearanceStream ; } , set : function set ( value ) { value = Boolean ( value ) ; _hasAppearanceStream = value ; } } ) ; var _page ; Object . defineProperty ( this , 'page' , { enumerable : true , configurable : true , writeable : true , get : function get ( ) { if ( ! _page ) { return ; } return _page ; } , set : function set ( value ) { _page = value ; } } ) ; Object . defineProperty ( this , 'readOnly' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( getBitForPdf ( this . Ff , 1 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) === true ) { this . Ff = setBitForPdf ( this . Ff , 1 ) ; } else { this . Ff = clearBitForPdf ( this . Ff , 1 ) ; } } } ) ; Object . defineProperty ( this , 'required' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( getBitForPdf ( this . Ff , 2 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) === true ) { this . Ff = setBitForPdf ( this . Ff , 2 ) ; } else { this . Ff = clearBitForPdf ( this . Ff , 2 ) ; } } } ) ; Object . defineProperty ( this , 'noExport' , { enumerable : true , configurable : true , get : function get ( ) { return Boolean ( getBitForPdf ( this . Ff , 3 ) ) ; } , set : function set ( value ) { if ( Boolean ( value ) === true ) { this . Ff = setBitForPdf ( this . Ff , 3 ) ; } else { this . Ff = clearBitForPdf ( this . Ff , 3 ) ; } } } ) ; var _Q = null ; Object . defineProperty ( this , 'Q' , { enumerable : true , configurable : false , get : function get ( ) { if ( _Q === null ) { return ; } return _Q ; } , set : function set ( value ) { if ( [ 0 , 1 , 2 ] . indexOf ( value ) !== - 1 ) { _Q = value ; } else { throw new Error ( 'Invalid value "' + value + '" for attribute Q supplied.' ) ; } } } ) ; Object . defineProperty ( this , 'textAlign' , { get : function get ( ) { var result = 'left' ; switch ( _Q ) { case 0 : default : result = 'left' ; break ; case 1 : result = 'center' ; break ; case 2 : result = 'right' ; break ; } return result ; } , configurable : true , enumerable : true , set : function set ( value ) { switch ( value ) { case 'right' : case 2 : _Q = 2 ; break ; case 'center' : case 1 : _Q = 1 ; break ; case 'left' : case 0 : default : _Q = 0 ; } } } ) ; } 
function AcroFormChildClass ( ) { AcroFormField . call ( this ) ; var _parent ; Object . defineProperty ( this , 'Parent' , { enumerable : false , configurable : false , get : function get ( ) { return _parent ; } , set : function set ( value ) { _parent = value ; } } ) ; var _optionName ; Object . defineProperty ( this , 'optionName' , { enumerable : false , configurable : true , get : function get ( ) { return _optionName ; } , set : function set ( value ) { _optionName = value ; } } ) ; var _MK = { } ; Object . defineProperty ( this , 'MK' , { enumerable : false , configurable : false , get : function get ( ) { var result = [ ] ; result . push ( '<<' ) ; var key ; for ( key in _MK ) { result . push ( '/' + key + ' (' + _MK [ key ] + ')' ) ; } result . push ( '>>' ) ; return result . join ( '\n' ) ; } , set : function set ( value ) { if ( _typeof ( value ) === "object" ) { _MK = value ; } } } ) ; Object . defineProperty ( this , 'caption' , { enumerable : true , configurable : true , get : function get ( ) { return _MK . CA || '' ; } , set : function set ( value ) { if ( typeof value === "string" ) { _MK . CA = value ; } } } ) ; var _AS ; Object . defineProperty ( this , 'AS' , { enumerable : false , configurable : false , get : function get ( ) { return _AS ; } , set : function set ( value ) { _AS = value ; } } ) ; Object . defineProperty ( this , 'appearanceState' , { enumerable : true , configurable : true , get : function get ( ) { return _AS . substr ( 1 , _AS . length - 1 ) ; } , set : function set ( value ) { _AS = '/' + value ; } } ) ; this . optionName = name ; this . caption = 'l' ; this . appearanceState = 'Off' ; 
function YesPushDown ( formObject ) { var xobj = createFormXObject ( formObject ) ; var stream = [ ] ; var fontKey = scope . internal . getFont ( formObject . fontName , formObject . fontStyle ) . id ; var encodedColor = scope . __private__ . encodeColorString ( formObject . color ) ; var calcRes = calculateX ( formObject , formObject . caption ) ; stream . push ( "0.749023 g" ) ; stream . push ( "0 0 " + f2 ( AcroFormAppearance . internal . getWidth ( formObject ) ) + " " + f2 ( AcroFormAppearance . internal . getHeight ( formObject ) ) + " re" ) ; stream . push ( "f" ) ; stream . push ( "BMC" ) ; stream . push ( "q" ) ; stream . push ( "0 0 1 rg" ) ; stream . push ( "/" + fontKey + " " + f2 ( calcRes . fontSize ) + " Tf " + encodedColor ) ; stream . push ( "BT" ) ; stream . push ( calcRes . text ) ; stream . push ( "ET" ) ; stream . push ( "Q" ) ; stream . push ( "EMC" ) ; xobj . stream = stream . join ( "\n" ) ; return xobj ; } 
function OffPushDown ( formObject ) { var xobj = createFormXObject ( formObject ) ; var stream = [ ] ; stream . push ( "0.749023 g" ) ; stream . push ( "0 0 " + f2 ( AcroFormAppearance . internal . getWidth ( formObject ) ) + " " + f2 ( AcroFormAppearance . internal . getHeight ( formObject ) ) + " re" ) ; stream . push ( "f" ) ; xobj . stream = stream . join ( "\n" ) ; return xobj ; } 
function createDefaultAppearanceStream ( formObject ) { 
function putImage ( img ) { var objectNumber = this . internal . newObject ( ) , out = this . internal . write , putStream = this . internal . putStream , getFilters = this . internal . getFilters ; var filters = getFilters ( ) ; while ( filters . indexOf ( 'FlateEncode' ) !== - 1 ) { filters . splice ( filters . indexOf ( 'FlateEncode' ) , 1 ) ; } img [ 'n' ] = objectNumber ; var additionalKeyValues = [ ] ; additionalKeyValues . push ( { key : 'Type' , value : '/XObject' } ) ; additionalKeyValues . push ( { key : 'Subtype' , value : '/Image' } ) ; additionalKeyValues . push ( { key : 'Width' , value : img [ 'w' ] } ) ; additionalKeyValues . push ( { key : 'Height' , value : img [ 'h' ] } ) ; if ( img [ 'cs' ] === this . color_spaces . INDEXED ) { additionalKeyValues . push ( { key : 'ColorSpace' , value : '[/Indexed /DeviceRGB ' 
function putXObjectsDictCallback ( ) { var images = this . internal . collections [ namespace + 'images' ] , out = this . internal . write , image ; for ( var i in images ) { image = images [ i ] ; out ( '/I' + image [ 'i' ] , image [ 'n' ] , '0' , 'R' ) ; } } 
function getImages ( ) { var images = this . internal . collections [ namespace + 'images' ] ; 
function getImageIndex ( images ) { var imageIndex = 0 ; if ( images ) { 
function generateAliasFromImageData ( imageData ) { if ( typeof imageData === 'string' ) { return jsPDFAPI . sHashCode ( imageData ) ; } if ( jsPDFAPI . isArrayBufferView ( imageData ) ) { return jsPDFAPI . sHashCode ( jsPDFAPI . arrayBufferToBinaryString ( imageData ) ) ; } return null ; } 
function createDataURIFromElement ( element , format ) { 
function checkImagesForAlias ( alias , images ) { var cached_info ; if ( images ) { for ( var e in images ) { if ( alias === images [ e ] . alias ) { cached_info = images [ e ] ; break ; } } } return cached_info ; } 
function determineWidthAndHeight ( w , h , info ) { if ( ! w && ! h ) { w = - 96 ; h = - 96 ; } if ( w < 0 ) { w = - 1 * info [ 'w' ] * 72 / w / this . internal . scaleFactor ; } if ( h < 0 ) { h = - 1 * info [ 'h' ] * 72 / h / this . internal . scaleFactor ; } if ( w === 0 ) { w = h * info [ 'w' ] / info [ 'h' ] ; } if ( h === 0 ) { h = w * info [ 'h' ] / info [ 'w' ] ; } return [ w , h ] ; } 
function writeImageToPDF ( x , y , w , h , info , index , images , rotation ) { var dims = determineWidthAndHeight . call ( this , w , h , info ) , coord = this . internal . getCoordinateString , vcoord = this . internal . getVerticalCoordinateString ; w = dims [ 0 ] ; h = dims [ 1 ] ; images [ index ] = info ; if ( rotation ) { rotation *= Math . PI / 180 ; var c = Math . cos ( rotation ) ; var s = Math . sin ( rotation ) ; 
function getJpegSize ( imgData ) { var width , height , numcomponents ; 
function getJpegSizeFromBytes ( data ) { var hdr = data [ 0 ] << 8 | data [ 1 ] ; if ( hdr !== 0xFFD8 ) throw new Error ( 'Supplied data is not a JPEG' ) ; var len = data . length , block = ( data [ 4 ] << 8 ) + data [ 5 ] , pos = 4 , bytes , width , height , numcomponents ; while ( pos < len ) { pos += block ; bytes = readBytes ( data , pos ) ; block = ( bytes [ 2 ] << 8 ) + bytes [ 3 ] ; if ( ( bytes [ 1 ] === 0xC0 || bytes [ 1 ] === 0xC2 ) && bytes [ 0 ] === 0xFF && block > 7 ) { bytes = readBytes ( data , pos + 5 ) ; width = ( bytes [ 2 ] << 8 ) + bytes [ 3 ] ; height = ( bytes [ 0 ] << 8 ) + bytes [ 1 ] ; numcomponents = bytes [ 4 ] ; return { width : width , height : height , numcomponents : numcomponents } ; } pos += 2 ; } throw new Error ( 'getJpegSizeFromBytes could not find the size of the image' ) ; } 
function setLastCellPosition ( x , y , w , h , ln ) { lastCellPos = { 'x' : x , 'y' : y , 'w' : w , 'h' : h , 'ln' : ln } ; } 
function drawPaths ( rule , isClip ) { if ( rule === 'stroke' && ! isClip && isStrokeTransparent . call ( this ) ) { return ; } if ( rule !== 'stroke' && ! isClip && isFillTransparent . call ( this ) ) { return ; } var moves = [ ] ; var alpha = this . ctx . globalAlpha ; if ( this . ctx . fillOpacity < 1 ) { alpha = this . ctx . fillOpacity ; } var xPath = this . path ; for ( var i = 0 ; i < xPath . length ; i ++ ) { var pt = xPath [ i ] ; switch ( pt . type ) { case 'begin' : moves . push ( { begin : true } ) ; break ; case 'close' : moves . push ( { close : true } ) ; break ; case 'mt' : moves . push ( { start : pt , deltas : [ ] , abs : [ ] } ) ; break ; case 'lt' : var iii = moves . length ; if ( ! isNaN ( xPath [ i - 1 ] . x ) ) { var delta = [ pt . x - xPath [ i - 1 ] . x , pt . y - xPath [ i - 1 ] . y ] ; if ( iii > 0 ) { for ( iii ; iii >= 0 ; iii -- ) { if ( moves [ iii - 1 ] . close !== true && moves [ iii - 1 ] . begin !== true ) { moves [ iii - 1 ] . deltas . push ( delta ) ; moves [ iii - 1 ] . abs . push ( pt ) ; break ; } } } } break ; case 'bct' : var delta = [ pt . x1 - xPath [ i - 1 ] . x , pt . y1 - xPath [ i - 1 ] . y , pt . x2 - xPath [ i - 1 ] . x , pt . y2 - xPath [ i - 1 ] . y , pt . x - xPath [ i - 1 ] . x , pt . y - xPath [ i - 1 ] . y ] ; moves [ moves . length - 1 ] . deltas . push ( delta ) ; break ; case 'qct' : var x1 = xPath [ i - 1 ] . x + 2.0 / 3.0 * ( pt . x1 - xPath [ i - 1 ] . x ) ; var y1 = xPath [ i - 1 ] . y + 2.0 / 3.0 * ( pt . y1 - xPath [ i - 1 ] . y ) ; var x2 = pt . x + 2.0 / 3.0 * ( pt . x1 - pt . x ) ; var y2 = pt . y + 2.0 / 3.0 * ( pt . y1 - pt . y ) ; var x3 = pt . x ; var y3 = pt . y ; var delta = [ x1 - xPath [ i - 1 ] . x , y1 - xPath [ i - 1 ] . y , x2 - xPath [ i - 1 ] . x , y2 - xPath [ i - 1 ] . y , x3 - xPath [ i - 1 ] . x , y3 - xPath [ i - 1 ] . y ] ; moves [ moves . length - 1 ] . deltas . push ( delta ) ; break ; case 'arc' : moves . push ( { deltas : [ ] , abs : [ ] , arc : true } ) ; if ( Array . isArray ( moves [ moves . length - 1 ] . abs ) ) { moves [ moves . length - 1 ] . abs . push ( pt ) ; } break ; } } var style ; if ( ! isClip ) { if ( rule === 'stroke' ) { style = 'stroke' ; } else { style = 'fill' ; } } else { style = null ; } for ( var i = 0 ; i < moves . length ; i ++ ) { if ( moves [ i ] . arc ) { var arcs = moves [ i ] . abs ; for ( var ii = 0 ; ii < arcs . length ; ii ++ ) { var arc = arcs [ ii ] ; if ( typeof arc . startAngle !== 'undefined' ) { var start = rad2deg ( arc . startAngle ) ; var end = rad2deg ( arc . endAngle ) ; var x = arc . x ; var y = arc . y ; drawArc . call ( this , x , y , arc . radius , start , end , arc . counterclockwise , style , isClip ) ; } else { drawLine . call ( this , arc . x , arc . y ) ; } } } if ( ! moves [ i ] . arc ) { if ( moves [ i ] . close !== true && moves [ i ] . begin !== true ) { var x = moves [ i ] . start . x ; var y = moves [ i ] . start . y ; drawLines . call ( this , moves [ i ] . deltas , x , y , null , null ) ; } } } if ( style ) { putStyle . call ( this , style ) ; } if ( isClip ) { doClip . call ( this ) ; } } 
function createArc ( radius , startAngle , endAngle , anticlockwise ) { var EPSILON = 0.00001 ; 
function createSmallArc ( r , a1 , a2 ) { var a = ( a2 - a1 ) / 2.0 ; var x4 = r * Math . cos ( a ) ; var y4 = r * Math . sin ( a ) ; var x1 = x4 ; var y1 = - y4 ; var q1 = x1 * x1 + y1 * y1 ; var q2 = q1 + x1 * x4 + y1 * y4 ; var k2 = 4 / 3 * ( Math . sqrt ( 2 * q1 * q2 ) - q2 ) / ( x1 * y4 - y1 * x4 ) ; var x2 = x1 - k2 * y1 ; var y2 = y1 + k2 * x1 ; var x3 = x2 ; var y3 = - y2 ; var ar = a + a1 ; var cos_ar = Math . cos ( ar ) ; var sin_ar = Math . sin ( ar ) ; return { x1 : r * Math . cos ( a1 ) , y1 : r * Math . sin ( a1 ) , x2 : x2 * cos_ar - y2 * sin_ar , y2 : x2 * sin_ar + y2 * cos_ar , x3 : x3 * cos_ar - y3 * sin_ar , y3 : x3 * sin_ar + y3 * cos_ar , x4 : r * Math . cos ( a2 ) , y4 : r * Math . sin ( a2 ) } ; } 
function ASCIIHexEncode ( value ) { var result = '' ; var i ; for ( var i = 0 ; i < value . length ; i += 1 ) { result += ( "0" + value . charCodeAt ( i ) . toString ( 16 ) ) . slice ( - 2 ) ; } result += '>' ; return result ; } 
function compressBytes ( bytes , lineLength , colorsPerPixel , compression ) { var level = 5 , filter_method = filterUp ; switch ( compression ) { case jsPDFAPI . image_compression . FAST : level = 3 ; filter_method = filterSub ; break ; case jsPDFAPI . image_compression . MEDIUM : level = 6 ; filter_method = filterAverage ; break ; case jsPDFAPI . image_compression . SLOW : level = 9 ; filter_method = filterPaeth ; 
function createZlibHeader ( bytes , level ) { var cm = 8 ; var cinfo = Math . LOG2E * Math . log ( 0x8000 ) - 8 ; var cmf = cinfo << 4 | cm ; var hdr = cmf << 8 ; var flevel = Math . min ( 3 , ( level - 1 & 0xff ) >> 1 ) ; hdr |= flevel << 6 ; hdr |= 0 ; 
function adler32 ( array , param ) { var adler = 1 ; var s1 = adler & 0xffff , s2 = adler >>> 16 & 0xffff ; var len = array . length ; var tlen ; var i = 0 ; while ( len > 0 ) { tlen = len > param ? param : len ; len -= tlen ; do { s1 += array [ i ++ ] ; s2 += s1 ; } while ( -- tlen ) ; s1 %= 65521 ; s2 %= 65521 ; } return ( s2 << 16 | s1 ) >>> 0 ; } 
function applyPngFilterMethod ( bytes , lineLength , colorsPerPixel , filter_method ) { var lines = bytes . length / lineLength , result = new Uint8Array ( bytes . length + lines ) , filter_methods = getFilterMethods ( ) , i = 0 , line , prevLine , offset ; for ( ; i < lines ; i ++ ) { offset = i * lineLength ; line = bytes . subarray ( offset , offset + lineLength ) ; if ( filter_method ) { result . set ( filter_method ( line , colorsPerPixel , prevLine ) , offset + i ) ; } else { var j = 0 , len = filter_methods . length , results = [ ] ; for ( ; j < len ; j ++ ) { results [ j ] = filter_methods [ j ] ( line , colorsPerPixel , prevLine ) ; } var ind = getIndexOfSmallestSum ( results . concat ( ) ) ; result . set ( results [ ind ] , offset + i ) ; } prevLine = line ; } return result ; } 
function filterNone ( line , colorsPerPixel , prevLine ) { var result = Array . apply ( [ ] , line ) ; result . unshift ( 0 ) ; return result ; } 
function paethPredictor ( left , up , upLeft ) { var p = left + up - upLeft , pLeft = Math . abs ( p - left ) , pUp = Math . abs ( p - up ) , pUpLeft = Math . abs ( p - upLeft ) ; return pLeft <= pUp && pLeft <= pUpLeft ? left : pUp <= pUpLeft ? up : upLeft ; } 
function getIndexOfSmallestSum ( arrays ) { var i = 0 , len = arrays . length , sum , min , ind ; while ( i < len ) { sum = absSum ( arrays [ i ] . slice ( 1 ) ) ; if ( sum < min || ! min ) { min = sum ; ind = i ; } i ++ ; } return ind ; } 
function absSum ( array ) { var i = 0 , len = array . length , sum = 0 ; while ( i < len ) { sum += Math . abs ( array [ i ++ ] ) ; } return sum ; } 
function getPredictorFromCompression ( compression ) { var predictor ; switch ( compression ) { case jsPDFAPI . image_compression . FAST : predictor = 11 ; break ; case jsPDFAPI . image_compression . MEDIUM : predictor = 13 ; break ; case jsPDFAPI . image_compression . SLOW : predictor = 14 ; break ; default : predictor = 12 ; break ; } return predictor ; } 
function splitLongWord ( word , widths_array , firstLineMaxLen , maxLen ) { var answer = [ ] ; 
function splitParagraphIntoLines ( text , maxlen , options ) { 
function uncompress ( data ) { var decoded = '0123456789abcdef' , encoded = 'klmnopqrstuvwxyz' , mapping = { } ; for ( var i = 0 ; i < encoded . length ; i ++ ) { mapping [ encoded [ i ] ] = decoded [ i ] ; } var undef , output = { } , sign = 1 , stringparts 
function _getCharType ( ch ) { var charCode = ch . charCodeAt ( ) , range = charCode >> 8 , rangeIdx = _UNICODE_RANGES_MAP [ range ] ; if ( rangeIdx !== undefined ) { return _UNICODE_TYPES [ rangeIdx * 256 + ( charCode & 0xFF ) ] ; } else if ( range === 0xFC || range === 0xFD ) { return "AL" ; } else if ( _LTR_RANGES_REG_EXPR . test ( range ) ) { 
function _resolveCharType ( chars , types , resolvedTypes , index ) { var cType = types [ index ] , wType , nType , i , len ; switch ( cType ) { case "L" : case "R" : _lastArabic = false ; break ; case "N" : case "AN" : break ; case "EN" : if ( _lastArabic ) { cType = "AN" ; } break ; case "AL" : _lastArabic = true ; cType = "R" ; break ; case "WS" : cType = "N" ; break ; case "CS" : if ( index < 1 || index + 1 >= types . length || ( wType = resolvedTypes [ index - 1 ] ) !== "EN" && wType !== "AN" || ( nType = types [ index + 1 ] ) !== "EN" && nType !== "AN" ) { cType = "N" ; } else if ( _lastArabic ) { nType = "AN" ; } cType = nType === wType ? nType : "N" ; break ; case "ES" : wType = index > 0 ? resolvedTypes [ index - 1 ] : "B" ; cType = wType === "EN" && index + 1 < types . length && types [ index + 1 ] === "EN" ? "EN" : "N" ; break ; case "ET" : if ( index > 0 && resolvedTypes [ index - 1 ] === "EN" ) { cType = "EN" ; break ; } else if ( _lastArabic ) { cType = "N" ; break ; } i = index + 1 ; len = types . length ; while ( i < len && types [ i ] === "ET" ) { i ++ ; } if ( i < len && types [ i ] === "EN" ) { cType = "EN" ; } else { cType = "N" ; } break ; case "NSM" : if ( _isInVisual && ! _isInRtl ) { 
function _computeLevels ( chars , levels , params ) { var action , condition , i , index , newLevel , prevState , condPos = - 1 , len = chars . length , newState = 0 , resolvedTypes = [ ] , stateTable = _dir ? _STATE_TABLE_RTL : _STATE_TABLE_LTR , types = [ ] ; _lastArabic = false ; _hasUbatB = false ; _hasUbatS = false ; for ( i = 0 ; i < len ; i ++ ) { types [ i ] = _getCharType ( chars [ i ] ) ; } for ( index = 0 ; index < len ; index ++ ) { prevState = newState ; resolvedTypes [ index ] = _resolveCharType ( chars , types , resolvedTypes , index ) ; newState = stateTable [ prevState ] [ _TYPE_NAMES_MAP [ resolvedTypes [ index ] ] ] ; action = newState & 0xF0 ; newState &= 0x0F ; levels [ index ] = newLevel = stateTable [ newState ] [ 5 ] ; if ( action > 0 ) { if ( action === 0x10 ) { for ( i = condPos ; i < index ; i ++ ) { levels [ i ] = 1 ; } condPos = - 1 ; } else { condPos = - 1 ; } } condition = stateTable [ newState ] [ 6 ] ; if ( condition ) { if ( condPos === - 1 ) { condPos = index ; } } else { if ( condPos > - 1 ) { for ( i = condPos ; i < index ; i ++ ) { levels [ i ] = newLevel ; } condPos = - 1 ; } } if ( types [ index ] === "B" ) { levels [ index ] = 0 ; } params . hiLevel |= newLevel ; } if ( _hasUbatS ) { _handleUbatS ( types , levels , len ) ; } } 
function _invertByLevel ( level , charArray , sourceToTargetMap , levels , params ) { if ( params . hiLevel < level ) { return ; } if ( level === 1 && _dir === DIR_RTL && ! _hasUbatB ) { charArray . reverse ( ) ; sourceToTargetMap && sourceToTargetMap . reverse ( ) ; return ; } var ch , high , end , low , len = charArray . length , start = 0 ; while ( start < len ) { if ( levels [ start ] >= level ) { end = start + 1 ; while ( end < len && levels [ end ] >= level ) { end ++ ; } for ( low = start , high = end - 1 ; low < high ; low ++ , high -- ) { ch = charArray [ low ] ; charArray [ low ] = charArray [ high ] ; charArray [ high ] = ch ; if ( sourceToTargetMap ) { ch = sourceToTargetMap [ low ] ; sourceToTargetMap [ low ] = sourceToTargetMap [ high ] ; sourceToTargetMap [ high ] = ch ; } } start = end ; } start ++ ; } } 
function _symmetricSwap ( charArray , levels , params ) { if ( params . hiLevel !== 0 && _isSymmetricSwapping ) { for ( var i = 0 , index ; i < charArray . length ; i ++ ) { if ( levels [ i ] === 1 ) { index = _SWAP_TABLE . indexOf ( charArray [ i ] ) ; if ( index >= 0 ) { charArray [ i ] = _SWAP_TABLE [ index + 1 ] ; } } } } } 
function JPEGEncoder ( quality ) { var ffloor = Math . floor ; var YTable = new Array ( 64 ) ; var UVTable = new Array ( 64 ) ; var fdtbl_Y = new Array ( 64 ) ; var fdtbl_UV = new Array ( 64 ) ; var YDC_HT ; var UVDC_HT ; var YAC_HT ; var UVAC_HT ; var bitcode = new Array ( 65535 ) ; var category = new Array ( 65535 ) ; var outputfDCTQuant = new Array ( 64 ) ; var DU = new Array ( 64 ) ; var byteout = [ ] ; var bytenew = 0 ; var bytepos = 7 ; var YDU = new Array ( 64 ) ; var UDU = new Array ( 64 ) ; var VDU = new Array ( 64 ) ; var clt = new Array ( 256 ) ; var RGB_YUV_TABLE = new Array ( 2048 ) ; var currentQuality ; var ZigZag = [ 0 , 1 , 5 , 6 , 14 , 15 , 27 , 28 , 2 , 4 , 7 , 13 , 16 , 26 , 29 , 42 , 3 , 8 , 12 , 17 , 25 , 30 , 41 , 43 , 9 , 11 , 18 , 24 , 31 , 40 , 44 , 53 , 10 , 19 , 23 , 32 , 39 , 45 , 52 , 54 , 20 , 22 , 33 , 38 , 46 , 51 , 55 , 60 , 21 , 34 , 37 , 47 , 50 , 56 , 59 , 61 , 35 , 36 , 48 , 49 , 57 , 58 , 62 , 63 ] ; var std_dc_luminance_nrcodes = [ 0 , 0 , 1 , 5 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; var std_dc_luminance_values = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] ; var std_ac_luminance_nrcodes = [ 0 , 0 , 2 , 1 , 3 , 3 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 0 , 0 , 1 , 0x7d ] ; var std_ac_luminance_values = [ 0x01 , 0x02 , 0x03 , 0x00 , 0x04 , 0x11 , 0x05 , 0x12 , 0x21 , 0x31 , 0x41 , 0x06 , 0x13 , 0x51 , 0x61 , 0x07 , 0x22 , 0x71 , 0x14 , 0x32 , 0x81 , 0x91 , 0xa1 , 0x08 , 0x23 , 0x42 , 0xb1 , 0xc1 , 0x15 , 0x52 , 0xd1 , 0xf0 , 0x24 , 0x33 , 0x62 , 0x72 , 0x82 , 0x09 , 0x0a , 0x16 , 0x17 , 0x18 , 0x19 , 0x1a , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 , 0x48 , 0x49 , 0x4a , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 , 0x58 , 0x59 , 0x5a , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 , 0x68 , 0x69 , 0x6a , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 , 0x78 , 0x79 , 0x7a , 0x83 , 0x84 , 0x85 , 0x86 , 0x87 , 0x88 , 0x89 , 0x8a , 0x92 , 0x93 , 0x94 , 0x95 , 0x96 , 0x97 , 0x98 , 0x99 , 0x9a , 0xa2 , 0xa3 , 0xa4 , 0xa5 , 0xa6 , 0xa7 , 0xa8 , 0xa9 , 0xaa , 0xb2 , 0xb3 , 0xb4 , 0xb5 , 0xb6 , 0xb7 , 0xb8 , 0xb9 , 0xba , 0xc2 , 0xc3 , 0xc4 , 0xc5 , 0xc6 , 0xc7 , 0xc8 , 0xc9 , 0xca , 0xd2 , 0xd3 , 0xd4 , 0xd5 , 0xd6 , 0xd7 , 0xd8 , 0xd9 , 0xda , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xf1 , 0xf2 , 0xf3 , 0xf4 , 0xf5 , 0xf6 , 0xf7 , 0xf8 , 0xf9 , 0xfa ] ; var std_dc_chrominance_nrcodes = [ 0 , 0 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ; var std_dc_chrominance_values = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] ; var std_ac_chrominance_nrcodes = [ 0 , 0 , 2 , 1 , 2 , 4 , 4 , 3 , 4 , 7 , 5 , 4 , 4 , 0 , 1 , 2 , 0x77 ] ; var std_ac_chrominance_values = [ 0x00 , 0x01 , 0x02 , 0x03 , 0x11 , 0x04 , 0x05 , 0x21 , 0x31 , 0x06 , 0x12 , 0x41 , 0x51 , 0x07 , 0x61 , 0x71 , 0x13 , 0x22 , 0x32 , 0x81 , 0x08 , 0x14 , 0x42 , 0x91 , 0xa1 , 0xb1 , 0xc1 , 0x09 , 0x23 , 0x33 , 0x52 , 0xf0 , 0x15 , 0x62 , 0x72 , 0xd1 , 0x0a , 0x16 , 0x24 , 0x34 , 0xe1 , 0x25 , 0xf1 , 0x17 , 0x18 , 0x19 , 0x1a , 0x26 , 0x27 , 0x28 , 0x29 , 0x2a , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3a , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 , 0x48 , 0x49 , 0x4a , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 , 0x58 , 0x59 , 0x5a , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 , 0x68 , 0x69 , 0x6a , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 , 0x78 , 0x79 , 0x7a , 0x82 , 0x83 , 0x84 , 0x85 , 0x86 , 0x87 , 0x88 , 0x89 , 0x8a , 0x92 , 0x93 , 0x94 , 0x95 , 0x96 , 0x97 , 0x98 , 0x99 , 0x9a , 0xa2 , 0xa3 , 0xa4 , 0xa5 , 0xa6 , 0xa7 , 0xa8 , 0xa9 , 0xaa , 0xb2 , 0xb3 , 0xb4 , 0xb5 , 0xb6 , 0xb7 , 0xb8 , 0xb9 , 0xba , 0xc2 , 0xc3 , 0xc4 , 0xc5 , 0xc6 , 0xc7 , 0xc8 , 0xc9 , 0xca , 0xd2 , 0xd3 , 0xd4 , 0xd5 , 0xd6 , 0xd7 , 0xd8 , 0xd9 , 0xda , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xf2 , 0xf3 , 0xf4 , 0xf5 , 0xf6 , 0xf7 , 0xf8 , 0xf9 , 0xfa ] ; function initQuantTables ( sf ) { var YQT = [ 16 , 11 , 10 , 16 , 24 , 40 , 51 , 61 , 12 , 12 , 14 , 19 , 26 , 58 , 60 , 55 , 14 , 13 , 16 , 24 , 40 , 57 , 69 , 56 , 14 , 17 , 22 , 29 , 51 , 87 , 80 , 62 , 18 , 22 , 37 , 56 , 68 , 109 , 103 , 77 , 24 , 35 , 55 , 64 , 81 , 104 , 113 , 92 , 49 , 64 , 78 , 87 , 103 , 121 , 120 , 101 , 72 , 92 , 95 , 98 , 112 , 100 , 103 , 99 ] ; for ( var i = 0 ; i < 64 ; i ++ ) { var t = ffloor ( ( YQT [ i ] * sf + 50 ) / 100 ) ; if ( t < 1 ) { t = 1 ; } else if ( t > 255 ) { t = 255 ; } YTable [ ZigZag [ i ] ] = t ; } var UVQT = [ 17 , 18 , 24 , 47 , 99 , 99 , 99 , 99 , 18 , 21 , 26 , 66 , 99 , 99 , 99 , 99 , 24 , 26 , 56 , 99 , 99 , 99 , 99 , 99 , 47 , 66 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 , 99 ] ; for ( var j = 0 ; j < 64 ; j ++ ) { var u = ffloor ( ( UVQT [ j ] * sf + 50 ) / 100 ) ; if ( u < 1 ) { u = 1 ; } else if ( u > 255 ) { u = 255 ; } UVTable [ ZigZag [ j ] ] = u ; } var aasf = [ 1.0 , 1.387039845 , 1.306562965 , 1.175875602 , 1.0 , 0.785694958 , 0.541196100 , 0.275899379 ] ; var k = 0 ; for ( var row = 0 ; row < 8 ; row ++ ) { for ( var col = 0 ; col < 8 ; col ++ ) { fdtbl_Y [ k ] = 1.0 / ( YTable [ ZigZag [ k ] ] * aasf [ row ] * aasf [ col ] * 8.0 ) ; fdtbl_UV [ k ] = 1.0 / ( UVTable [ ZigZag [ k ] ] * aasf [ row ] * aasf [ col ] * 8.0 ) ; k ++ ; } } } function computeHuffmanTbl ( nrcodes , std_table ) { var codevalue = 0 ; var pos_in_table = 0 ; var HT = new Array ( ) ; for ( var k = 1 ; k <= 16 ; k ++ ) { for ( var j = 1 ; j <= nrcodes [ k ] ; j ++ ) { HT [ std_table [ pos_in_table ] ] = [ ] ; HT [ std_table [ pos_in_table ] ] [ 0 ] = codevalue ; HT [ std_table [ pos_in_table ] ] [ 1 ] = k ; pos_in_table ++ ; codevalue ++ ; } codevalue *= 2 ; } return HT ; } function initHuffmanTbl ( ) { YDC_HT = computeHuffmanTbl ( std_dc_luminance_nrcodes , std_dc_luminance_values ) ; UVDC_HT = computeHuffmanTbl ( std_dc_chrominance_nrcodes , std_dc_chrominance_values ) ; YAC_HT = computeHuffmanTbl ( std_ac_luminance_nrcodes , std_ac_luminance_values ) ; UVAC_HT = computeHuffmanTbl ( std_ac_chrominance_nrcodes , std_ac_chrominance_values ) ; } function initCategoryNumber ( ) { var nrlower = 1 ; var nrupper = 2 ; for ( var cat = 1 ; cat <= 15 ; cat ++ ) { YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b)); VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b)); */ 
function fDCTQuant ( data , fdtbl ) { var d0 , d1 , d2 , d3 , d4 , d5 , d6 , d7 ; var dataOff = 0 ; var i ; var I8 = 8 ; var I64 = 64 ; for ( i = 0 ; i < I8 ; ++ i ) { d0 = data [ dataOff ] ; d1 = data [ dataOff + 1 ] ; d2 = data [ dataOff + 2 ] ; d3 = data [ dataOff + 3 ] ; d4 = data [ dataOff + 4 ] ; d5 = data [ dataOff + 5 ] ; d6 = data [ dataOff + 6 ] ; d7 = data [ dataOff + 7 ] ; var tmp0 = d0 + d7 ; var tmp7 = d0 - d7 ; var tmp1 = d1 + d6 ; var tmp6 = d1 - d6 ; var tmp2 = d2 + d5 ; var tmp5 = d2 - d5 ; var tmp3 = d3 + d4 ; var tmp4 = d3 - d4 ; var tmp10 = tmp0 + tmp3 ; var tmp13 = tmp0 - tmp3 ; var tmp11 = tmp1 + tmp2 ; var tmp12 = tmp1 - tmp2 ; data [ dataOff ] = tmp10 + tmp11 ; data [ dataOff + 4 ] = tmp10 - tmp11 ; var z1 = ( tmp12 + tmp13 ) * 0.707106781 ; data [ dataOff + 2 ] = tmp13 + z1 ; data [ dataOff + 6 ] = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ; var z5 = ( tmp10 - tmp12 ) * 0.382683433 ; var z2 = 0.541196100 * tmp10 + z5 ; var z4 = 1.306562965 * tmp12 + z5 ; var z3 = tmp11 * 0.707106781 ; var z11 = tmp7 + z3 ; var z13 = tmp7 - z3 ; data [ dataOff + 5 ] = z13 + z2 ; data [ dataOff + 3 ] = z13 - z2 ; data [ dataOff + 1 ] = z11 + z4 ; data [ dataOff + 7 ] = z11 - z4 ; dataOff += 8 ; } dataOff = 0 ; for ( i = 0 ; i < I8 ; ++ i ) { d0 = data [ dataOff ] ; d1 = data [ dataOff + 8 ] ; d2 = data [ dataOff + 16 ] ; d3 = data [ dataOff + 24 ] ; d4 = data [ dataOff + 32 ] ; d5 = data [ dataOff + 40 ] ; d6 = data [ dataOff + 48 ] ; d7 = data [ dataOff + 56 ] ; var tmp0p2 = d0 + d7 ; var tmp7p2 = d0 - d7 ; var tmp1p2 = d1 + d6 ; var tmp6p2 = d1 - d6 ; var tmp2p2 = d2 + d5 ; var tmp5p2 = d2 - d5 ; var tmp3p2 = d3 + d4 ; var tmp4p2 = d3 - d4 ; var tmp10p2 = tmp0p2 + tmp3p2 ; var tmp13p2 = tmp0p2 - tmp3p2 ; var tmp11p2 = tmp1p2 + tmp2p2 ; var tmp12p2 = tmp1p2 - tmp2p2 ; data [ dataOff ] = tmp10p2 + tmp11p2 ; data [ dataOff + 32 ] = tmp10p2 - tmp11p2 ; var z1p2 = ( tmp12p2 + tmp13p2 ) * 0.707106781 ; data [ dataOff + 16 ] = tmp13p2 + z1p2 ; data [ dataOff + 48 ] = tmp13p2 - z1p2 ; tmp10p2 = tmp4p2 + tmp5p2 ; tmp11p2 = tmp5p2 + tmp6p2 ; tmp12p2 = tmp6p2 + tmp7p2 ; var z5p2 = ( tmp10p2 - tmp12p2 ) * 0.382683433 ; var z2p2 = 0.541196100 * tmp10p2 + z5p2 ; var z4p2 = 1.306562965 * tmp12p2 + z5p2 ; var z3p2 = tmp11p2 * 0.707106781 ; var z11p2 = tmp7p2 + z3p2 ; var z13p2 = tmp7p2 - z3p2 ; data [ dataOff + 40 ] = z13p2 + z2p2 ; data [ dataOff + 24 ] = z13p2 - z2p2 ; data [ dataOff + 8 ] = z11p2 + z4p2 ; data [ dataOff + 56 ] = z11p2 - z4p2 ; dataOff ++ ; } 
function bi_flush ( ) { if ( bi_valid == 16 ) { put_short ( bi_buf ) ; bi_buf = 0 ; bi_valid = 0 ; } else if ( bi_valid >= 8 ) { put_byte ( bi_buf & 0xff ) ; bi_buf >>>= 8 ; bi_valid -= 8 ; } } 
function _tr_flush_block ( buf , 
function fill_window ( ) { var n , m ; var p ; var more ; 
function deflate_slow ( flush ) { 
function TTFFont ( rawData , name , encoding ) { var data ; this . rawData = rawData ; data = this . contents = new Data ( rawData ) ; this . contents . pos = 4 ; if ( data . readString ( 4 ) === 'ttcf' ) { if ( ! name ) { throw new Error ( "Must specify a font name for TTC files." ) ; } throw new Error ( "Font " + name + " not found in TTC file." ) ; } else { data . pos = 0 ; this . parse ( ) ; this . subset = new Subset ( this ) ; this . registerTTF ( ) ; } } 
function Directory ( data ) { var entry , i , _i , _ref ; this . scalarType = data . readInt ( ) ; this . tableCount = data . readShort ( ) ; this . searchRange = data . readShort ( ) ; this . entrySelector = data . readShort ( ) ; this . rangeShift = data . readShort ( ) ; this . tables = { } ; for ( i = _i = 0 , _ref = this . tableCount ; 0 <= _ref ? _i < _ref : _i > _ref ; i = 0 <= _ref ? ++ _i : -- _i ) { entry = { tag : data . readString ( 4 ) , checksum : data . readInt ( ) , offset : data . readInt ( ) , length : data . readInt ( ) } ; this . tables [ entry . tag ] = entry ; } } 
function SimpleGlyph ( raw , numberOfContours , xMin , yMin , xMax , yMax ) { this . raw = raw ; this . numberOfContours = numberOfContours ; this . xMin = xMin ; this . yMin = yMin ; this . xMax = xMax ; this . yMax = yMax ; this . compound = false ; } 
function CompoundGlyph ( raw , xMin , yMin , xMax , yMax ) { var data , flags ; this . raw = raw ; this . xMin = xMin ; this . yMin = yMin ; this . xMax = xMax ; this . yMax = yMax ; this . compound = true ; this . glyphIDs = [ ] ; this . glyphOffsets = [ ] ; data = this . raw ; while ( true ) { flags = data . readShort ( ) ; this . glyphOffsets . push ( data . pos ) ; this . glyphIDs . push ( data . readShort ( ) ) ; if ( ! ( flags & MORE_COMPONENTS ) ) { break ; } if ( flags & ARG_1_AND_2_ARE_WORDS ) { data . pos += 4 ; } else { data . pos += 2 ; } if ( flags & WE_HAVE_A_TWO_BY_TWO ) { data . pos += 8 ; } else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) { data . pos += 4 ; } else if ( flags & WE_HAVE_A_SCALE ) { data . pos += 2 ; } } } 
function invert ( object ) { var key , ret , val ; ret = { } ; for ( key in object ) { val = object [ key ] ; ret [ val ] = key ; } return ret ; } 
function ( image ) { var out = this . internal . write ; var putStream = this . internal . putStream ; var getFilters = this . internal . getFilters ; var filter = getFilters ( ) ; while ( filter . indexOf ( 'FlateEncode' ) !== - 1 ) { filter . splice ( filter . indexOf ( 'FlateEncode' ) , 1 ) ; } image . objectId = this . internal . newObject ( ) ; var additionalKeyValues = [ ] ; additionalKeyValues . push ( { key : 'Type' , value : '/XObject' } ) ; additionalKeyValues . push ( { key : 'Subtype' , value : '/Image' } ) ; additionalKeyValues . push ( { key : 'Width' , value : image . width } ) ; additionalKeyValues . push ( { key : 'Height' , value : image . height } ) ; if ( image . colorSpace === color_spaces . INDEXED ) { additionalKeyValues . push ( { key : 'ColorSpace' , value : '[/Indexed /DeviceRGB ' 
function GifWriterOutputLZWCodeStream ( buf , p , min_code_size , index_stream ) { buf [ p ++ ] = min_code_size ; var cur_subblock = p ++ ; 
function mapArrayBufferViews ( ary ) { return ary . map ( function ( chunk ) { if ( chunk . buffer instanceof ArrayBuffer ) { var buf = chunk . buffer ; 
function Blob ( chunks , opts ) { chunks = chunks || [ ] for ( var i = 0 , len = chunks . length ; i < len ; i ++ ) { var chunk = chunks [ i ] if ( chunk instanceof Blob ) { chunks [ i ] = chunk . _buffer } else if ( typeof chunk === 'string' ) { chunks [ i ] = toUTF8Array ( chunk ) } else if ( arrayBufferSupported && ( ArrayBuffer . prototype . isPrototypeOf ( chunk ) || isArrayBufferView ( chunk ) ) ) { chunks [ i ] = bufferClone ( chunk ) } else if ( arrayBufferSupported && isDataView ( chunk ) ) { chunks [ i ] = bufferClone ( chunk . buffer ) } else { chunks [ i ] = toUTF8Array ( String ( chunk ) ) } } this . _buffer = [ ] . concat . apply ( [ ] , chunks ) this . size = this . _buffer . length this . type = opts ? opts . type || '' : '' } 
function File ( chunks , name , opts ) { opts = opts || { } var a = Blob . call ( this , chunks , opts ) || this a . name = name a . lastModifiedDate = opts . lastModified ? new Date ( opts . lastModified ) : new Date a . lastModified = + a . lastModifiedDate return a } 
function FileReader ( ) { if ( ! ( this instanceof FileReader ) ) throw new TypeError ( "Failed to construct 'FileReader': Please use the 'new' operator, this DOM object constructor cannot be called as a function." ) var delegate = document . createDocumentFragment ( ) this . addEventListener = delegate . addEventListener this . dispatchEvent = function ( evt ) { var local = this [ 'on' + evt . type ] if ( typeof local === 'function' ) local ( evt ) delegate . dispatchEvent ( evt ) } this . removeEventListener = delegate . removeEventListener } 
function promptUser ( ) { return inquirer . prompt ( [ { type : "list" , name : "env" , message : "Where does your code run?" , default : [ "browser" ] , choices : [ { name : "Browser" , value : "browser" } , { name : "Node" , value : "node" } ] } , { type : "checkbox" , name : "images" , message : "Which ImageTypes should be supported?" , default : [ "jpeg_support" , 'bmp_support' , 'gif_support' , 'webp_support' ] , choices : [ { name : "Jpeg" , value : "jpeg_support" } , { name : "Bmp" , value : "bmp_support" } , { name : "Gif" , value : "gif_support" } , { name : "WebP" , value : "webp_support" } ] } , { type : "checkbox" , name : "modules" , message : "Additional Modules" , default : [ 'acroform' , 'annotations' , 'arabic' , 'autoprint' , 'context2d' , 'fileloading' , 'filters' , 'html' , 'javascript' , 'outline' , 'setlanguage' , 'svg' , 'total_pages' , 'utf8' , 'viewerpreferences' , 'xmp_metadata' ] , choices : [ { name : "Acroform" , value : "acroform" } , { name : "Annotations" , value : "annotations" } , { name : "Arabic Parser" , value : "arabic" } , { name : "Autoprint" , value : "autoprint" } , { name : "Context2d" , value : "context2d" } , { name : "File Loading" , value : "fileloading" } , { name : "Filters" , value : "filters" } , { name : "HTML" , value : "html" } , { name : "Javascript" , value : "javascript" } , { name : "Outline" , value : "outline" } , { name : "Language-Tagging" , value : "setlanguage" } , { name : "SVG" , value : "svg" } , { name : "TotalPages" , value : "total_pages" } , { name : "Unicode" , value : "utf8" } , { name : "ViewerPreferences" , value : "viewerpreferences" } , { name : "XMP Metadata" , value : "xmp_metadata" } ] } ] ) . then ( result => { console . log ( generateFileList ( [ ... result . images , ... result . modules ] ) ) ; } ) ; } 
function memcmp ( data , data_off , str , size ) { for ( var i = 0 ; i < size ; i ++ ) if ( data [ data_off + i ] != str . charCodeAt ( i ) ) return true ; return false ; } 
function demoTwoPageDocument ( ) { var doc = new jsPDF ( ) ; doc . text ( 20 , 20 , 'Hello world!' ) ; doc . text ( 20 , 30 , 'This is client-side Javascript, pumping out a PDF.' ) ; doc . addPage ( ) ; doc . text ( 20 , 20 , 'Do you like that?' ) ; 
function ( url , callback ) { var img = new Image ( ) , data , ret = { data : null , pending : true } ; img . onError = function ( ) { throw new Error ( 'Cannot load image: "' + url + '"' ) ; } ; img . onload = function ( ) { var canvas = document . createElement ( 'canvas' ) ; document . body . appendChild ( canvas ) ; canvas . width = img . width ; canvas . height = img . height ; var ctx = canvas . getContext ( '2d' ) ; ctx . drawImage ( img , 0 , 0 ) ; 
function ( imgData ) { var doc = new jsPDF ( ) ; doc . addImage ( imgData , 'JPEG' , 10 , 10 , 50 , 50 ) ; doc . addImage ( imgData , 'JPEG' , 70 , 10 , 100 , 120 ) ; doc . save ( 'output.pdf' ) ; } 
function parseId ( url ) { if ( is . empty ( url ) ) { return null ; } const regex = / ^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).* / ; return url . match ( regex ) ? RegExp . $2 : url ; } 
function assurePlaybackState ( play ) { if ( play && ! this . embed . hasPlayed ) { this . embed . hasPlayed = true ; } if ( this . media . paused === play ) { this . media . paused = ! play ; triggerEvent . call ( this , this . media , play ? 'play' : 'pause' ) ; } } 
function stringifyError ( value ) { var err = { 
function isError ( value ) { switch ( Object . prototype . toString . call ( value ) ) { case '[object Error]' : return true ; case '[object Exception]' : return true ; case '[object DOMException]' : return true ; default : return value instanceof Error ; } } 
function parseUrl ( url ) { if ( typeof url !== 'string' ) return { } ; var match = url . match ( / ^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$ / ) ; 
function isSameException ( ex1 , ex2 ) { if ( isOnlyOneTruthy ( ex1 , ex2 ) ) return false ; ex1 = ex1 . values [ 0 ] ; ex2 = ex2 . values [ 0 ] ; if ( ex1 . type !== ex2 . type || ex1 . value !== ex2 . value ) return false ; 
function isSameStacktrace ( stack1 , stack2 ) { if ( isOnlyOneTruthy ( stack1 , stack2 ) ) return false ; var frames1 = stack1 . frames ; var frames2 = stack2 . frames ; 
function fill ( obj , name , replacement , track ) { if ( obj == null ) return ; var orig = obj [ name ] ; obj [ name ] = replacement ( orig ) ; obj [ name ] . __raven__ = true ; obj [ name ] . __orig__ = orig ; if ( track ) { track . push ( [ obj , name , orig ] ) ; } } 
function safeJoin ( input , delimiter ) { if ( ! isArray ( input ) ) return '' ; var output = [ ] ; for ( var i = 0 ; i < input . length ; i ++ ) { try { output . push ( String ( input [ i ] ) ) ; } catch ( e ) { output . push ( '[value cannot be serialized]' ) ; } } return output . join ( delimiter ) ; } 
function notifyHandlers ( stack , isWindowError ) { var exception = null ; if ( isWindowError && ! TraceKit . collectWindowErrors ) { return ; } for ( var i in handlers ) { if ( handlers . hasOwnProperty ( i ) ) { try { handlers [ i ] . apply ( null , [ stack ] . concat ( _slice . call ( arguments , 2 ) ) ) ; } catch ( inner ) { exception = inner ; } } } if ( exception ) { throw exception ; } } 
function traceKitWindowOnError ( msg , url , lineNo , colNo , ex ) { var stack = null ; 
function report ( ex , rethrow ) { var args = _slice . call ( arguments , 1 ) ; if ( lastExceptionStack ) { if ( lastException === ex ) { return ; 
function computeStackTraceFromStackProp ( ex ) { if ( typeof ex . stack === 'undefined' || ! ex . stack ) return ; var chrome = / ^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$ / i ; var winjs = / ^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$ / i ; 
function augmentStackTraceWithInitialElement ( stackInfo , url , lineNo , message ) { var initial = { url : url , line : lineNo } ; if ( initial . url && initial . line ) { stackInfo . incomplete = false ; if ( ! initial . func ) { initial . func = UNKNOWN_FUNCTION ; } if ( stackInfo . stack . length > 0 ) { if ( stackInfo . stack [ 0 ] . url === initial . url ) { if ( stackInfo . stack [ 0 ] . line === initial . line ) { return false ; 
function computeStackTrace ( ex , depth ) { var stack = null ; depth = depth == null ? 0 : + depth ; try { stack = computeStackTraceFromStackProp ( ex ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( TraceKit . debug ) { throw e ; } } try { stack = computeStackTraceByWalkingCallerChain ( ex , depth + 1 ) ; if ( stack ) { return stack ; } } catch ( e ) { if ( TraceKit . debug ) { throw e ; } } return { name : ex . name , message : ex . message , url : getLocationHref ( ) } ; } 
function rstrHMACMD5 ( key , data ) { var i ; var bkey = rstr2binl ( key ) ; var ipad = [ ] ; var opad = [ ] ; var hash ; ipad [ 15 ] = opad [ 15 ] = undefined ; if ( bkey . length > 16 ) { bkey = binlMD5 ( bkey , key . length * 8 ) ; } for ( i = 0 ; i < 16 ; i += 1 ) { ipad [ i ] = bkey [ i ] ^ 0x36363636 ; opad [ i ] = bkey [ i ] ^ 0x5c5c5c5c ; } hash = binlMD5 ( ipad . concat ( rstr2binl ( data ) ) , 512 + data . length * 8 ) ; return binl2rstr ( binlMD5 ( opad . concat ( hash ) , 512 + 128 ) ) ; } 
function rstr2hex ( input ) { var hexTab = '0123456789abcdef' ; var output = '' ; var x ; var i ; for ( i = 0 ; i < input . length ; i += 1 ) { x = input . charCodeAt ( i ) ; output += hexTab . charAt ( x >>> 4 & 0x0f ) + hexTab . charAt ( x & 0x0f ) ; } return output ; } 
function install ( ) { var self = this ; if ( self . isSetup ( ) && ! self . _isRavenInstalled ) { tracekit . report . subscribe ( function ( ) { self . _handleOnErrorStackInfo . apply ( self , arguments ) ; } ) ; if ( self . _globalOptions . captureUnhandledRejections ) { self . _attachPromiseRejectionHandler ( ) ; } self . _patchFunctionToString ( ) ; if ( self . _globalOptions . instrument && self . _globalOptions . instrument . tryCatch ) { self . _instrumentTryCatch ( ) ; } if ( self . _globalOptions . autoBreadcrumbs ) self . _instrumentBreadcrumbs ( ) ; 
function setDSN ( dsn ) { var self = this , uri = self . _parseDSN ( dsn ) , lastSlash = uri . path . lastIndexOf ( '/' ) , path = uri . path . substr ( 1 , lastSlash ) ; self . _dsn = dsn ; self . _globalKey = uri . user ; self . _globalSecret = uri . pass && uri . pass . substr ( 1 ) ; self . _globalProject = uri . path . substr ( lastSlash + 1 ) ; self . _globalServer = self . _getGlobalServer ( uri ) ; self . _globalEndpoint = self . _globalServer + '/' + path + 'api/' + self . _globalProject + '/store/' ; 
function context ( options , func , args ) { if ( isFunction$1 ( options ) ) { args = func || [ ] ; func = options ; options = { } ; } return this . wrap ( options , func ) . apply ( this , args ) ; } 
function wrap ( options , func , _before ) { var self = this ; 
function _promiseRejectionHandler ( event ) { this . _logDebug ( 'debug' , 'Raven caught unhandled promise rejection:' , event ) ; this . captureException ( event . reason , { mechanism : { type : 'onunhandledrejection' , handled : false } } ) ; } 
function captureException ( ex , options ) { options = objectMerge$1 ( { trimHeadFrames : 0 } , options ? options : { } ) ; if ( isErrorEvent$1 ( ex ) && ex . error ) { 
function captureMessage ( msg , options ) { 
function setDataCallback ( callback ) { var original = this . _globalOptions . dataCallback ; this . _globalOptions . dataCallback = keepOriginalCallback ( original , callback ) ; return this ; } 
function setBreadcrumbCallback ( callback ) { var original = this . _globalOptions . breadcrumbCallback ; this . _globalOptions . breadcrumbCallback = keepOriginalCallback ( original , callback ) ; return this ; } 
function setShouldSendCallback ( callback ) { var original = this . _globalOptions . shouldSendCallback ; this . _globalOptions . shouldSendCallback = keepOriginalCallback ( original , callback ) ; return this ; } 
function isSetup ( ) { if ( ! this . _hasJSON ) return false ; 
function _breadcrumbEventHandler ( evtName ) { var self = this ; return function ( evt ) { 
function _captureUrlChange ( from , to ) { var parsedLoc = parseUrl$1 ( this . _location . href ) ; var parsedTo = parseUrl$1 ( to ) ; var parsedFrom = parseUrl$1 ( from ) ; 
function _trimBreadcrumbs ( breadcrumbs ) { 
function _isRepeatData ( current ) { var last = this . _lastData ; if ( ! last || current . message !== last . message || 
function trigger ( element , type ) { if ( ! element || ! type ) { return ; } 
function getDecimalPlaces ( value ) { var match = "" . concat ( value ) . match ( / (?:\.(\d+))?(?:[eE]([+-]?\d+))?$ / ) ; if ( ! match ) { return 0 ; } return Math . max ( 0 , 
function round ( number , step ) { if ( step < 1 ) { var places = getDecimalPlaces ( step ) ; return parseFloat ( number . toFixed ( places ) ) ; } return Math . round ( number / step ) * step ; } 
function RangeTouch ( target , options ) { _classCallCheck ( this , RangeTouch ) ; if ( is . element ( target ) ) { 
function setup ( target ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var targets = null ; if ( is . empty ( target ) || is . string ( target ) ) { targets = Array . from ( document . querySelectorAll ( is . string ( target ) ? target : 'input[type="range"]' ) ) ; } else if ( is . element ( target ) ) { targets = [ target ] ; } else if ( is . nodeList ( target ) ) { targets = Array . from ( target ) ; } else if ( is . array ( target ) ) { targets = target . filter ( is . element ) ; } if ( is . empty ( targets ) ) { return null ; } var config = Object . assign ( { } , defaults , options ) ; if ( is . string ( target ) && config . watch ) { 
function toggleListener ( element , event , callback ) { var _this = this ; var toggle = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var passive = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : true ; var capture = arguments . length > 5 && arguments [ 5 ] !== undefined ? arguments [ 5 ] : false ; 
function on ( element ) { var events = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; toggleListener . call ( this , element , events , callback , true , passive , capture ) ; } 
function once ( element ) { var _this2 = this ; var events = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var callback = arguments . length > 2 ? arguments [ 2 ] : undefined ; var passive = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : true ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; var onceCallback = function onceCallback ( ) { off ( element , events , onceCallback , passive , capture ) ; for ( var _len = arguments . length , args = new Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } callback . apply ( _this2 , args ) ; } ; toggleListener . call ( this , element , events , onceCallback , true , passive , capture ) ; } 
function triggerEvent ( element ) { var type = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var bubbles = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : false ; var detail = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; 
function unbindListeners ( ) { if ( this && this . eventListeners ) { this . eventListeners . forEach ( function ( item ) { var element = item . element , type = item . type , callback = item . callback , options = item . options ; element . removeEventListener ( type , callback , options ) ; } ) ; this . eventListeners = [ ] ; } } 
function ready ( ) { var _this3 = this ; return new Promise ( function ( resolve ) { return _this3 . ready ? setTimeout ( resolve , 0 ) : on . call ( _this3 , _this3 . elements . container , 'ready' , resolve ) ; } ) . then ( function ( ) { } ) ; } 
function getDeep ( object , path ) { return path . split ( '.' ) . reduce ( function ( obj , key ) { return obj && obj [ key ] ; } , object ) ; } 
function extend ( ) { var target = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; for ( var _len = arguments . length , sources = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { sources [ _key - 1 ] = arguments [ _key ] ; } if ( ! sources . length ) { return target ; } var source = sources . shift ( ) ; if ( ! is$1 . object ( source ) ) { return target ; } Object . keys ( source ) . forEach ( function ( key ) { if ( is$1 . object ( source [ key ] ) ) { if ( ! Object . keys ( target ) . includes ( key ) ) { Object . assign ( target , _defineProperty ( { } , key , { } ) ) ; } extend ( target [ key ] , source [ key ] ) ; } else { Object . assign ( target , _defineProperty ( { } , key , source [ key ] ) ) ; } } ) ; return extend . apply ( void 0 , [ target ] . concat ( sources ) ) ; } 
function setAttributes ( element , attributes ) { if ( ! is$1 . element ( element ) || is$1 . empty ( attributes ) ) { return ; } 
function createElement ( type , attributes , text ) { 
function insertAfter ( element , target ) { if ( ! is$1 . element ( element ) || ! is$1 . element ( target ) ) { return ; } target . parentNode . insertBefore ( element , target . nextSibling ) ; } 
function insertElement ( type , parent , attributes , text ) { if ( ! is$1 . element ( parent ) ) { return ; } parent . appendChild ( createElement ( type , attributes , text ) ) ; } 
function removeElement ( element ) { if ( is$1 . nodeList ( element ) || is$1 . array ( element ) ) { Array . from ( element ) . forEach ( removeElement ) ; return ; } if ( ! is$1 . element ( element ) || ! is$1 . element ( element . parentNode ) ) { return ; } element . parentNode . removeChild ( element ) ; } 
function emptyElement ( element ) { if ( ! is$1 . element ( element ) ) { return ; } var length = element . childNodes . length ; while ( length > 0 ) { element . removeChild ( element . lastChild ) ; length -= 1 ; } } 
function replaceElement ( newChild , oldChild ) { if ( ! is$1 . element ( oldChild ) || ! is$1 . element ( oldChild . parentNode ) || ! is$1 . element ( newChild ) ) { return null ; } oldChild . parentNode . replaceChild ( newChild , oldChild ) ; return newChild ; } 
function getAttributesFromSelector ( sel , existingAttributes ) { 
function toggleHidden ( element , hidden ) { if ( ! is$1 . element ( element ) ) { return ; } var hide = hidden ; if ( ! is$1 . boolean ( hide ) ) { hide = ! element . hidden ; } if ( hide ) { element . setAttribute ( 'hidden' , '' ) ; } else { element . removeAttribute ( 'hidden' ) ; } } 
function toggleClass ( element , className , force ) { if ( is$1 . nodeList ( element ) ) { return Array . from ( element ) . map ( function ( e ) { return toggleClass ( e , className , force ) ; } ) ; } if ( is$1 . element ( element ) ) { var method = 'toggle' ; if ( typeof force !== 'undefined' ) { method = force ? 'add' : 'remove' ; } element . classList [ method ] ( className ) ; return element . classList . contains ( className ) ; } return false ; } 
function hasClass ( element , className ) { return is$1 . element ( element ) && element . classList . contains ( className ) ; } 
function matches$1 ( element , selector ) { function match ( ) { return Array . from ( document . querySelectorAll ( selector ) ) . includes ( this ) ; } var matches = match ; return matches . call ( element , selector ) ; } 
function trapFocus ( ) { var element = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var toggle = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! is$1 . element ( element ) ) { return ; } var focusable = getElements . call ( this , 'button:not(:disabled), input:not(:disabled), [tabindex]' ) ; var first = focusable [ 0 ] ; var last = focusable [ focusable . length - 1 ] ; var trap = function trap ( event ) { 
function setFocus ( ) { var element = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var tabFocus = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! is$1 . element ( element ) ) { return ; } 
function repaint ( element ) { setTimeout ( function ( ) { try { toggleHidden ( element , true ) ; element . offsetHeight ; 
function check ( type , provider , playsinline ) { var canPlayInline = browser . isIPhone && playsinline && support . playsinline ; var api = support [ type ] || provider !== 'html5' ; var ui = api && support . rangeInput && ( type !== 'video' || ! browser . isIPhone || canPlayInline ) ; return { api : api , ui : ui } ; } 
function mime ( input ) { if ( is$1 . empty ( input ) ) { return false ; } var _input$split = input . split ( '/' ) , _input$split2 = _slicedToArray ( _input$split , 1 ) , mediaType = _input$split2 [ 0 ] ; var type = input ; 
function setAspectRatio ( input ) { if ( ! this . isVideo ) { return { } ; } var ratio = getAspectRatio . call ( this , input ) ; var _ref = is$1 . array ( ratio ) ? ratio : [ 0 , 0 ] , _ref2 = _slicedToArray ( _ref , 2 ) , w = _ref2 [ 0 ] , h = _ref2 [ 1 ] ; var padding = 100 / w * h ; this . elements . wrapper . style . paddingBottom = "" . concat ( padding , "%" ) ; 
function getQualityOptions ( ) { 
function cancelRequests ( ) { if ( ! this . isHTML5 ) { return ; } 
function dedupe ( array ) { if ( ! is$1 . array ( array ) ) { return array ; } return array . filter ( function ( item , index ) { return array . indexOf ( item ) === index ; } ) ; } 
function closest ( array , value ) { if ( ! is$1 . array ( array ) || ! array . length ) { return null ; } return array . reduce ( function ( prev , curr ) { return Math . abs ( curr - value ) < Math . abs ( prev - value ) ? curr : prev ; } ) ; } 
function format ( input ) { for ( var _len = arguments . length , args = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { args [ _key - 1 ] = arguments [ _key ] ; } if ( is$1 . empty ( input ) ) { return input ; } return input . toString ( ) . replace ( / {(\d+)} / g , function ( match , i ) { return args [ i ] . toString ( ) ; } ) ; } 
function getPercentage ( current , max ) { if ( current === 0 || max === 0 || Number . isNaN ( current ) || Number . isNaN ( max ) ) { return 0 ; } return ( current / max * 100 ) . toFixed ( 2 ) ; } 
function replaceAll ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var find = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : '' ; var replace = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : '' ; return input . replace ( new RegExp ( find . toString ( ) . replace ( / ([.*+?^=!:${}()|[\]/\\]) / g , '\\$1' ) , 'g' ) , replace . toString ( ) ) ; } 
function toTitleCase ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; return input . toString ( ) . replace ( / \w\S* / g , function ( text ) { return text . charAt ( 0 ) . toUpperCase ( ) + text . substr ( 1 ) . toLowerCase ( ) ; } ) ; } 
function toPascalCase ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var string = input . toString ( ) ; 
function toCamelCase ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var string = input . toString ( ) ; 
function stripHTML ( source ) { var fragment = document . createDocumentFragment ( ) ; var element = document . createElement ( 'div' ) ; fragment . appendChild ( element ) ; element . innerHTML = source ; return fragment . firstChild . innerText ; } 
function getHTML ( element ) { var wrapper = document . createElement ( 'div' ) ; wrapper . appendChild ( element ) ; return wrapper . innerHTML ; } 
function fetch ( url ) { var responseType = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 'text' ; return new Promise ( function ( resolve , reject ) { try { var request = new XMLHttpRequest ( ) ; 
function loadSprite ( url , id ) { if ( ! is$1 . string ( url ) ) { return ; } var prefix = 'cache' ; var hasId = is$1 . string ( id ) ; var isCached = false ; var exists = function exists ( ) { return document . getElementById ( id ) !== null ; } ; var update = function update ( container , data ) { container . innerHTML = data ; 
function formatTime ( ) { var time = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var displayHours = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var inverted = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : false ; 
function getIconUrl ( ) { var url = new URL ( this . config . iconUrl , window . location ) ; var cors = url . host !== window . location . host || browser . isIE && ! window . svg4everybody ; return { url : this . config . iconUrl , cors : cors } ; } 
function findElements ( ) { try { this . elements . controls = getElement . call ( this , this . config . selectors . controls . wrapper ) ; 
function createIcon ( type , attributes ) { var namespace = 'http://www.w3.org/2000/svg' ; var iconUrl = controls . getIconUrl . call ( this ) ; var iconPath = "" . concat ( ! iconUrl . cors ? iconUrl . url : '' , "#" ) . concat ( this . config . iconPrefix ) ; 
function createLabel ( key ) { var attr = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var text = i18n . get ( key , this . config ) ; var attributes = Object . assign ( { } , attr , { class : [ attr . class , this . config . classNames . hidden ] . filter ( Boolean ) . join ( ' ' ) } ) ; return createElement ( 'span' , attributes , text ) ; } 
function createBadge ( text ) { if ( is$1 . empty ( text ) ) { return null ; } var badge = createElement ( 'span' , { class : this . config . classNames . menu . value } ) ; badge . appendChild ( createElement ( 'span' , { class : this . config . classNames . menu . badge } , text ) ) ; return badge ; } 
function createButton ( buttonType , attr ) { var _this = this ; var attributes = extend ( { } , attr ) ; var type = toCamelCase ( buttonType ) ; var props = { element : 'button' , toggle : false , label : null , icon : null , labelPressed : null , iconPressed : null } ; [ 'element' , 'icon' , 'label' ] . forEach ( function ( key ) { if ( Object . keys ( attributes ) . includes ( key ) ) { props [ key ] = attributes [ key ] ; delete attributes [ key ] ; } } ) ; 
function createRange ( type , attributes ) { 
function createProgress ( type , attributes ) { var progress = createElement ( 'progress' , extend ( getAttributesFromSelector ( this . config . selectors . display [ type ] ) , { min : 0 , max : 100 , value : 0 , role : 'progressbar' , 'aria-hidden' : true } , attributes ) ) ; 
function createTime ( type , attrs ) { var attributes = getAttributesFromSelector ( this . config . selectors . display [ type ] , attrs ) ; var container = createElement ( 'div' , extend ( attributes , { class : "" . concat ( attributes . class ? attributes . class : '' , " " ) . concat ( this . config . classNames . display . time , " " ) . trim ( ) , 'aria-label' : i18n . get ( type , this . config ) } ) , '00:00' ) ; 
function bindMenuItemShortcuts ( menuItem , type ) { var _this2 = this ; 
function createMenuItem ( _ref ) { var _this3 = this ; var value = _ref . value , list = _ref . list , type = _ref . type , title = _ref . title , _ref$badge = _ref . badge , badge = _ref$badge === void 0 ? null : _ref$badge , _ref$checked = _ref . checked , checked = _ref$checked === void 0 ? false : _ref$checked ; var attributes = getAttributesFromSelector ( this . config . selectors . inputs [ type ] ) ; var menuItem = createElement ( 'button' , extend ( attributes , { type : 'button' , role : 'menuitemradio' , class : "" . concat ( this . config . classNames . control , " " ) . concat ( attributes . class ? attributes . class : '' ) . trim ( ) , 'aria-checked' : checked , value : value } ) ) ; var flex = createElement ( 'span' ) ; 
function formatTime$1 ( ) { var time = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var inverted = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; 
function updateTimeDisplay ( ) { var target = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : null ; var time = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var inverted = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : false ; 
function updateVolume ( ) { if ( ! this . supported . ui ) { return ; } 
function setRange ( target ) { var value = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; if ( ! is$1 . element ( target ) ) { return ; } 
function updateProgress ( event ) { var _this4 = this ; if ( ! this . supported . ui || ! is$1 . event ( event ) ) { return ; } var value = 0 ; var setProgress = function setProgress ( target , input ) { var value = is$1 . number ( input ) ? input : 0 ; var progress = is$1 . element ( target ) ? target : _this4 . elements . display . buffer ; 
function updateRangeFill ( target ) { 
function updateSeekTooltip ( event ) { var _this5 = this ; 
function timeUpdate ( event ) { 
function durationUpdate ( ) { 
function updateSetting ( setting , container , input ) { var pane = this . elements . settings . panels [ setting ] ; var value = null ; var list = container ; if ( setting === 'captions' ) { value = this . currentTrack ; } else { value = ! is$1 . empty ( input ) ? input : this [ setting ] ; 
function getLabel ( setting , value ) { switch ( setting ) { case 'speed' : return value === 1 ? i18n . get ( 'normal' , this . config ) : "" . concat ( value , "&times;" ) ; case 'quality' : if ( is$1 . number ( value ) ) { var label = i18n . get ( "qualityLabel." . concat ( value ) , this . config ) ; if ( ! label . length ) { return "" . concat ( value , "p" ) ; } return label ; } return toTitleCase ( value ) ; case 'captions' : return captions . getLabel . call ( this ) ; default : return null ; } } 
function setQualityMenu ( options ) { var _this6 = this ; 
function getBadge ( quality ) { var label = i18n . get ( "qualityBadge." . concat ( quality ) , _this6 . config ) ; if ( ! label . length ) { return null ; } return controls . createBadge . call ( _this6 , label ) ; } 
function setCaptionsMenu ( ) { var _this7 = this ; 
function setSpeedMenu ( options ) { var _this8 = this ; 
function checkMenu ( ) { var buttons = this . elements . settings . buttons ; var visible = ! is$1 . empty ( buttons ) && Object . values ( buttons ) . some ( function ( button ) { return ! button . hidden ; } ) ; toggleHidden ( this . elements . settings . menu , ! visible ) ; } 
function focusFirstMenuItem ( pane ) { var tabFocus = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( this . elements . settings . popup . hidden ) { return ; } var target = pane ; if ( ! is$1 . element ( target ) ) { target = Object . values ( this . elements . settings . panels ) . find ( function ( pane ) { return ! pane . hidden ; } ) ; } var firstItem = target . querySelector ( '[role^="menuitem"]' ) ; setFocus . call ( this , firstItem , tabFocus ) ; } 
function toggleMenu ( input ) { var popup = this . elements . settings . popup ; var button = this . elements . buttons . settings ; 
function getMenuSize ( tab ) { var clone = tab . cloneNode ( true ) ; clone . style . position = 'absolute' ; clone . style . opacity = 0 ; clone . removeAttribute ( 'hidden' ) ; 
function showMenuPanel ( ) { var _this9 = this ; var type = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : '' ; var tabFocus = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var target = this . elements . container . querySelector ( "#plyr-settings-" . concat ( this . id , "-" ) . concat ( type ) ) ; 
function restore ( event ) { 
function setDownloadUrl ( ) { var button = this . elements . buttons . download ; 
function create ( data ) { var _this10 = this ; var bindMenuItemShortcuts = controls . bindMenuItemShortcuts , createButton = controls . createButton , createProgress = controls . createProgress , createRange = controls . createRange , createTime = controls . createTime , setQualityMenu = controls . setQualityMenu , setSpeedMenu = controls . setSpeedMenu , showMenuPanel = controls . showMenuPanel ; this . elements . controls = null ; 
function inject ( ) { var _this11 = this ; 
function replace ( input ) { var result = input ; Object . entries ( props ) . forEach ( function ( _ref2 ) { var _ref3 = _slicedToArray ( _ref2 , 2 ) , key = _ref3 [ 0 ] , value = _ref3 [ 1 ] ; result = replaceAll ( result , "{" . concat ( key , "}" ) , value ) ; } ) ; return result ; } 
function parseUrl$2 ( input ) { var safe = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; var url = input ; if ( safe ) { var parser = document . createElement ( 'a' ) ; parser . href = url ; url = parser . href ; } try { return new URL ( url ) ; } catch ( e ) { return null ; } } 
function buildUrlParams ( input ) { var params = new URLSearchParams ( ) ; if ( is$1 . object ( input ) ) { Object . entries ( input ) . forEach ( function ( _ref ) { var _ref2 = _slicedToArray ( _ref , 2 ) , key = _ref2 [ 0 ] , value = _ref2 [ 1 ] ; params . set ( key , value ) ; } ) ; } return params ; } 
function setup ( ) { 
function update ( ) { var _this = this ; var tracks = captions . getTracks . call ( this , true ) ; 
function toggle ( input ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; 
function set ( index ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; var tracks = captions . getTracks . call ( this ) ; 
function setLanguage ( input ) { var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( ! is$1 . string ( input ) ) { this . debug . warn ( 'Invalid language argument' , input ) ; return ; } 
function getTracks ( ) { var _this2 = this ; var update = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; 
function findTrack ( languages ) { var _this3 = this ; var force = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var tracks = captions . getTracks . call ( this ) ; var sortIsDefault = function sortIsDefault ( track ) { return Number ( ( _this3 . captions . meta . get ( track ) || { } ) . default ) ; } ; var sorted = Array . from ( tracks ) . sort ( function ( a , b ) { return sortIsDefault ( b ) - sortIsDefault ( a ) ; } ) ; var track ; languages . every ( function ( language ) { track = sorted . find ( function ( track ) { return track . language === language ; } ) ; return ! track ; 
function getLabel ( track ) { var currentTrack = track ; if ( ! is$1 . track ( currentTrack ) && support . textTracks && this . captions . toggled ) { currentTrack = captions . getCurrentTrack . call ( this ) ; } if ( is$1 . track ( currentTrack ) ) { if ( ! is$1 . empty ( currentTrack . label ) ) { return currentTrack . label ; } if ( ! is$1 . empty ( currentTrack . language ) ) { return track . language . toUpperCase ( ) ; } return i18n . get ( 'enabled' , this . config ) ; } return i18n . get ( 'disabled' , this . config ) ; } 
function updateCues ( input ) { 
function getProviderByUrl ( url ) { 
function update ( ) { if ( this . enabled ) { var mode ; if ( this . forceFallback ) { mode = 'Fallback (forced)' ; } else if ( Fullscreen . native ) { mode = 'Native' ; } else { mode = 'Fallback' ; } this . player . debug . log ( "" . concat ( mode , " fullscreen enabled" ) ) ; } else { this . player . debug . log ( 'Fullscreen not supported and fallback disabled' ) ; } 
function get ( ) { return ( Fullscreen . native || this . player . config . fullscreen . fallback ) && this . player . config . fullscreen . enabled && this . player . supported . ui && this . player . isVideo ; } 
function loadImage ( src ) { var minWidth = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 1 ; return new Promise ( function ( resolve , reject ) { var image = new Image ( ) ; var handler = function handler ( ) { delete image . onload ; delete image . onerror ; ( image . naturalWidth >= minWidth ? resolve : reject ) ( image ) ; } ; Object . assign ( image , { onload : handler , onerror : handler , src : src } ) ; } ) ; } 
function toggleNativeControls ( ) { var toggle = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; if ( toggle && this . isHTML5 ) { this . media . setAttribute ( 'controls' , '' ) ; } else { this . media . removeAttribute ( 'controls' ) ; } } 
function build ( ) { var _this = this ; 
function setTitle ( ) { 
function setPoster ( poster ) { var _this2 = this ; var passive = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; 
function checkPlaying ( event ) { var _this3 = this ; 
function checkLoading ( event ) { var _this4 = this ; this . loading = [ 'stalled' , 'waiting' ] . includes ( event . type ) ; 
function toggleControls ( force ) { var controls = this . elements . controls ; if ( controls && this . config . hideControls ) { 
function removeCurrent ( ) { var className = player . config . classNames . tabFocus ; var current = getElements . call ( player , "." . concat ( className ) ) ; toggleClass ( current , className , false ) ; } 
function setGutter ( ratio , padding , toggle ) { if ( ! player . isVimeo ) { return ; } var target = player . elements . wrapper . firstChild ; var _ratio = _slicedToArray ( ratio , 2 ) , y = _ratio [ 1 ] ; var _getAspectRatio$call = getAspectRatio . call ( player ) , _getAspectRatio$call2 = _slicedToArray ( _getAspectRatio$call , 2 ) , videoX = _getAspectRatio$call2 [ 0 ] , videoY = _getAspectRatio$call2 [ 1 ] ; target . style . maxWidth = toggle ? "" . concat ( y / videoY * videoX , "px" ) : null ; target . style . margin = toggle ? '0 auto' : null ; } 
function setPlayerSize ( measure ) { 
function subscribe ( bundleIds , callbackFn ) { 
function publish ( bundleId , pathsNotFound ) { 
function executeCallbacks ( args , depsNotFound ) { 
function loadFile ( path , callbackFn , args , numTries ) { var doc = document , async = args . async , maxTries = ( args . numRetries || 0 ) + 1 , beforeCallbackFn = args . before || devnull , pathStripped = path . replace ( / ^(css|img)! / , '' ) , isLegacyIECss , e ; numTries = numTries || 0 ; if ( / (^css!|\.css$) / . test ( path ) ) { 
function loadjs ( paths , arg1 , arg2 ) { var bundleId , args ; 
function loadScript ( url ) { return new Promise ( function ( resolve , reject ) { loadjs_umd ( url , { success : resolve , error : reject } ) ; } ) ; } 
function ready ( ) { var _this2 = this ; var player = this ; var config = player . config . vimeo ; 
function parseId$1 ( url ) { if ( is$1 . empty ( url ) ) { return null ; } var regex = / ^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).* / ; return url . match ( regex ) ? RegExp . $2 : url ; } 
function getTitle ( videoId ) { var _this2 = this ; var url = format ( this . config . urls . youtube . api , videoId ) ; fetch ( url ) . then ( function ( data ) { if ( is$1 . object ( data ) ) { var title = data . title , height = data . height , width = data . width ; 
function ready ( ) { var player = this ; 
function setup ( ) { 
function Ads ( player ) { var _this = this ; _classCallCheck ( this , Ads ) ; this . player = player ; this . config = player . config . ads ; this . playing = false ; this . initialized = false ; this . elements = { container : null , displayContainer : null } ; this . manager = null ; this . loader = null ; this . cuePoints = null ; this . events = { } ; this . safetyTimer = null ; this . countdownTimer = null ; 
function load ( ) { var _this2 = this ; if ( ! this . enabled ) { return ; } 
function setupIMA ( ) { 
function dispatchEvent ( type ) { var event = "ads" . concat ( type . replace ( / _ / g , '' ) . toLowerCase ( ) ) ; triggerEvent . call ( _this8 . player , _this8 . player . media , event ) ; } 
function PreviewThumbnails ( player ) { _classCallCheck ( this , PreviewThumbnails ) ; this . player = player ; this . thumbnails = [ ] ; this . loaded = false ; this . lastMouseMoveTime = Date . now ( ) ; this . mouseDown = false ; this . loadedImages = [ ] ; this . elements = { thumb : { } , scrubbing : { } } ; this . load ( ) ; } 
function insertElements ( type , attributes ) { var _this = this ; if ( is$1 . string ( attributes ) ) { insertElement ( type , this . media , { src : attributes } ) ; } else if ( is$1 . array ( attributes ) ) { attributes . forEach ( function ( attribute ) { insertElement ( type , _this . media , attribute ) ; } ) ; } } 
function change ( input ) { var _this2 = this ; if ( ! getDeep ( input , 'sources.length' ) ) { this . debug . warn ( 'Invalid source format' ) ; return ; } 
function clamp ( ) { var input = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var min = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var max = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 255 ; return Math . min ( Math . max ( input , min ) , max ) ; } 
function play ( ) { var _this2 = this ; if ( ! is$1 . function ( this . media . play ) ) { return null ; } 
function togglePlay ( input ) { 
function increaseVolume ( step ) { var volume = this . media . muted ? 0 : this . volume ; this . volume = volume + ( is$1 . number ( step ) ? step : 0 ) ; } 
function newSource ( type , init ) { 
function ( str ) { const args = arguments let flag = true let i = 1 str = str . replace ( / %s / g , ( ) => { const arg = args [ i ++ ] if ( typeof arg === 'undefined' ) { flag = false return '' } return arg } ) return flag ? str : '' } 
function filterFn ( ) { if ( ! Array . prototype . filter ) { Array . prototype . filter = function ( fun ) { 'use strict' ; if ( this === void 0 || this === null ) { throw new TypeError ( ) ; } var t = Object ( this ) ; var len = t . length >>> 0 ; if ( typeof fun !== 'function' ) { throw new TypeError ( ) ; } var res = [ ] ; var thisArg = arguments . length >= 2 ? arguments [ 1 ] : void 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( i in t ) { var val = t [ i ] ; 
function _GET ( key ) { var url = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : window . location . search ; var reg = new RegExp ( '(^|&)' + key + '=([^&]*)(&|$)' ) ; var result = url . substr ( 1 ) . match ( reg ) ; if ( result ) { return decodeURIComponent ( result [ 2 ] ) ; } return null ; } 
function _buildUrl ( dict ) { var url = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : window . location . search ; for ( var _iterator = function ( target ) { return Object . keys ( target ) . map ( function ( key ) { return [ key , target [ key ] ] ; } ) ; } ( dict ) , _isArray = Array . isArray ( _iterator ) , _i = 0 , _iterator = _isArray ? _iterator : _iterator [ Symbol . iterator ] ( ) ; ; ) { var _ref ; if ( _isArray ) { if ( _i >= _iterator . length ) break ; _ref = _iterator [ _i ++ ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var _ref2 = _ref , _ref3 = _slicedToArray ( _ref2 , 2 ) , key = _ref3 [ 0 ] , val = _ref3 [ 1 ] ; * 如果目标url中包含了key键, 我们需要将它替换成我们自己的val * 不然就直接添加好了. */ if ( url . match ( pattern ) ) { var tmp = new RegExp ( '(' + key + '=)([^&]*)' , 'gi' ) ; url = url . replace ( tmp , targetStr ) ; } else { var seperator = url . match ( '[?]' ) ? '&' : '?' ; url = url + seperator + targetStr ; } } if ( location . hash ) { url += location . hash ; } return url ; } 
function alphanum ( a , b ) { function chunkify ( t ) { const tz = [ ] let y = - 1 let n = 0 for ( let i = 0 ; i <= t . length ; i ++ ) { const char = t . charAt ( i ) const charCode = char . charCodeAt ( 0 ) const m = ( charCode === 46 || ( charCode >= 48 && charCode <= 57 ) ) if ( m !== n ) { tz [ ++ y ] = '' n = m } tz [ y ] += char } return tz } function stringfy ( v ) { if ( typeof ( v ) === 'number' ) { v = ` ${ v } ` } if ( ! v ) { v = '' } return v } const aa = chunkify ( stringfy ( a ) ) const bb = chunkify ( stringfy ( b ) ) for ( let x = 0 ; aa [ x ] && bb [ x ] ; x ++ ) { if ( aa [ x ] !== bb [ x ] ) { const c = Number ( aa [ x ] ) const d = Number ( bb [ x ] ) if ( c === aa [ x ] && d === bb [ x ] ) { return c - d } return ( aa [ x ] > bb [ x ] ) ? 1 : - 1 } } return aa . length - bb . length } 
function listPackages ( ) { return getPackages ( ) . filter ( path => ! blacklist . includes ( basename ( path ) ) ) . map ( dir => dir . replace ( process . cwd ( ) + "/" , "" ) ) ; } 
function jumpToPast ( history , index ) { if ( index < 0 || index >= history . past . length ) return history ; const { past , future , _latestUnfiltered } = history ; const newPast = past . slice ( 0 , index ) ; const newFuture = [ ... past . slice ( index + 1 ) , _latestUnfiltered , ... future ] ; const newPresent = past [ index ] ; return newHistory ( newPast , newPresent , newFuture ) ; } 
function jump ( history , n ) { if ( n > 0 ) return jumpToFuture ( history , n - 1 ) ; if ( n < 0 ) return jumpToPast ( history , history . past . length + n ) ; return history ; } 
function updateDeps ( deps , packages , version ) { const lib = { } ; _ . each ( packages , pkg => { lib [ pkg . name ] = version ; } ) ; _ . each ( deps , ( v , dep ) => { if ( dep in lib ) { deps [ dep ] = "^" + version ; } } ) ; } 
function updateDeps ( deps , packages ) { const lib = { } ; _ . each ( packages , pkg => { lib [ pkg . name ] = _ . get ( pkg , "nextRelease.version" , _ . get ( pkg , "lastRelease.version" ) ) ; } ) ; _ . each ( deps , ( version , dep ) => { if ( dep in lib ) { deps [ dep ] = "^" + lib [ dep ] ; } } ) ; } 
function updateFiles ( currentVersion , nextVersion ) { process . stdout . write ( ` ${ currentVersion } ne xtVersion}: \ `) ; return Promise . all ( filesToUpdate . map ( relativePath => updateVersionInFile ( currentVersion , nextVersion , relativePath ) ) ) ; } 
function preprocessCartForServer ( { coupon , is_coupon_applied , is_coupon_removed , currency , temporary , extra , products , tax , } ) { const needsUrlCoupon = ! ( coupon || is_coupon_applied || is_coupon_removed || typeof document === 'undefined' ) ; const urlCoupon = needsUrlCoupon ? url . parse ( document . URL , true ) . query . coupon : '' ; return Object . assign ( { coupon , is_coupon_applied , is_coupon_removed , currency , tax , temporary , extra , products : products . map ( ( { product_id , meta , free_trial , volume , extra : productExtra } ) => ( { product_id , meta , free_trial , volume , extra : productExtra , } ) ) , } , needsUrlCoupon && urlCoupon && { coupon : urlCoupon , is_coupon_applied : false , } ) ; } 
function getNewMessages ( previousCartValue , nextCartValue ) { previousCartValue = previousCartValue || { } ; nextCartValue = nextCartValue || { } ; const nextCartMessages = nextCartValue . messages || [ ] ; 
function getRefundPolicy ( cart ) { if ( cartItems . hasDomainRegistration ( cart ) && cartItems . hasPlan ( cart ) ) { return 'planWithDomainRefund' ; } if ( cartItems . hasDomainRegistration ( cart ) ) { return 'domainRefund' ; } return 'genericRefund' ; } 
function paymentMethodName ( method ) { const paymentMethodsNames = { alipay : 'Alipay' , bancontact : 'Bancontact' , 'credit-card' : i18n . translate ( 'Credit or debit card' ) , eps : 'EPS' , giropay : 'Giropay' , ideal : 'iDEAL' , netbanking : 'Net Banking' , paypal : 'PayPal' , p24 : 'Przelewy24' , 'brazil-tef' : 'Transferência bancária', wechat : i18n . translate ( 'WeChat Pay' , { comment : 'Name for WeChat Pay - https://pay.weixin.qq.com/' , } ) , 'web-payment' : i18n . translate ( 'Wallet' ) , sofort : 'Sofort' , } ; return paymentMethodsNames [ method ] || method ; } 
function isRedirectToValidForSsr ( redirectToQueryValue ) { if ( 'undefined' === typeof redirectToQueryValue ) { return true ; } const redirectToDecoded = decodeURIComponent ( redirectToQueryValue ) ; return ( redirectToDecoded . startsWith ( 'https://wordpress.com/theme' ) || redirectToDecoded . startsWith ( 'https://wordpress.com/go' ) ) ; } 
function highlight ( term , html , wrapperNode ) { debug ( 'Starting highlight' ) ; if ( ! wrapperNode ) { wrapperNode = document . createElement ( 'mark' ) ; } if ( ! term || ! html ) { return html ; } const root = document . createElement ( 'div' ) ; root . innerHTML = html ; walk ( root , term , wrapperNode ) ; return root . innerHTML ; } 
function MailingList ( category , wpcom ) { if ( ! ( this instanceof MailingList ) ) { return new MailingList ( category , wpcom ) ; } this . _category = category ; this . wpcom = wpcom ; } 
function embed ( editor ) { let embedDialogContainer ; const render = ( visible = true ) => { const selectedEmbedNode = editor . selection . getNode ( ) ; const store = editor . getParam ( 'redux_store' ) ; const embedDialogProps = { embedUrl : selectedEmbedNode . innerText || selectedEmbedNode . textContent , isVisible : visible , onCancel : ( ) => render ( false ) , onUpdate : newUrl => { editor . execCommand ( 'mceInsertContent' , false , newUrl ) ; render ( false ) ; } , } ; renderWithReduxStore ( React . createElement ( EmbedDialog , embedDialogProps ) , embedDialogContainer , store ) ; 
function getWebpackConfig ( env = { } , argv = { } ) { env . WP = true ; if ( 'theme' === argv . source ) { argv . entry = path . join ( __dirname , 'blank-theme' ) ; argv [ 'output-path' ] = path . join ( __dirname , 'blank-theme' , 'dist' ) ; argv [ 'output-filename' ] = 'blank-theme.js' ; } else { argv . entry = path . join ( __dirname , 'full-site-editing-plugin' ) ; argv [ 'output-path' ] = path . join ( __dirname , 'full-site-editing-plugin' , 'dist' ) ; argv [ 'output-filename' ] = 'full-site-editing-plugin.js' ; } const webpackConfig = getBaseWebpackConfig ( env , argv ) ; return { ... webpackConfig , watch : isDevelopment , devtool : isDevelopment ? 'inline-cheap-source-map' : false , } ; } 
function addModuleImportToSections ( { sections , shouldSplit , onlyIsomorphic } ) { sections . forEach ( section => { if ( onlyIsomorphic && ! section . isomorphic ) { return ; } const loaderFunction = ` ${ section . name } ${ section . module } ` ; section . load = shouldSplit ? loaderFunction . replace ( 'require' , 'import' ) : loaderFunction ; } ) ; 
function setup ( io ) { const SCSS_PATHS = [ path . join ( '.' , 'assets' , 'stylesheets' ) , path . join ( '.' , 'client' ) ] ; const ROOT_DIR = path . resolve ( __dirname , '..' , '..' ) ; const PUBLIC_DIR = path . join ( ROOT_DIR , 'public' ) ; let cssMake = null , errors = '' , scheduleBuild = false ; const publicCssFiles = { } ; * Handle 'make build-css' success or failure * @param {Number} code The exit code */ function onexit ( code ) { let changedFiles ; cssMake . stderr . removeListener ( 'data' , onstderr ) ; cssMake . stdout . removeListener ( 'data' , onstdout ) ; cssMake = null ; if ( scheduleBuild ) { * Updates the MD5 hash of the public CSS files and returns the changed ones * in a list. * @returns {Array} an array of changed files (string) */ function updateChangedCssFiles ( ) { let hash , filePath ; const changedFiles = [ ] ; for ( filePath in publicCssFiles ) { hash = md5File . sync ( filePath ) ; if ( hash !== publicCssFiles [ filePath ] ) { publicCssFiles [ filePath ] = hash ; changedFiles . push ( path . basename ( filePath ) ) ; } } return changedFiles ; } 
function spawnMake ( ) { 
function onexit ( code ) { let changedFiles ; cssMake . stderr . removeListener ( 'data' , onstderr ) ; cssMake . stdout . removeListener ( 'data' , onstdout ) ; cssMake = null ; if ( scheduleBuild ) { 
function updateChangedCssFiles ( ) { let hash , filePath ; const changedFiles = [ ] ; for ( filePath in publicCssFiles ) { hash = md5File . sync ( filePath ) ; if ( hash !== publicCssFiles [ filePath ] ) { publicCssFiles [ filePath ] = hash ; changedFiles . push ( path . basename ( filePath ) ) ; } } return changedFiles ; } 
function addSeenGuidedTour ( getState , tourName , finished = false ) { return savePreference ( 'guided-tours-history' , [ ... getPreference ( getState ( ) , 'guided-tours-history' ) , { timestamp : Date . now ( ) , tourName , finished , } , ] ) ; } 
function updateSiteState ( state , siteId , attributes ) { return Object . assign ( { } , state , { [ siteId ] : Object . assign ( { } , initialSiteState , state [ siteId ] , attributes ) , } ) ; } 
function pathStartsWith ( fullPath , pathPrefix ) { return ( fullPath === pathPrefix || ( fullPath . slice ( 0 , pathPrefix . length ) === pathPrefix && includes ( '/?' , fullPath [ pathPrefix . length ] ) ) ) ; } 
function isValidCategoriesArray ( categories ) { for ( let i = 0 ; i < categories . length ; i ++ ) { if ( ! isValidProductCategory ( categories [ i ] ) ) { 
function isValidProductCategory ( category ) { return ( category && category . id && 'number' === typeof category . id && category . name && 'string' === typeof category . name && category . slug && 'string' === typeof category . slug ) ; } 
function decodeUserSettingsEntities ( data ) { const decodedValues = { display_name : data . display_name && decodeEntities ( data . display_name ) , description : data . description && decodeEntities ( data . description ) , user_URL : data . user_URL && decodeEntities ( data . user_URL ) , } ; return assign ( { } , data , decodedValues ) ; } 
function deleteUnsavedSetting ( settings , settingName ) { unset ( settings , settingName ) ; const settingKeys = settingName . split ( '.' ) ; if ( settingKeys . length > 1 ) { settingKeys . pop ( ) ; const parentKey = settingKeys . join ( '.' ) ; 
function hasLanguageChanged ( languageSettingValue , settings = { } ) { if ( ! languageSettingValue ) { return false ; } 
function UserSettings ( ) { if ( ! ( this instanceof UserSettings ) ) { return new UserSettings ( ) ; } this . settings = false ; this . initialized = false ; this . reAuthRequired = false ; this . fetchingSettings = false ; this . unsavedSettings = { } ; } 
function getDomainNameFromReceiptOrCart ( receipt , cart ) { let domainRegistration ; if ( receipt && ! isEmpty ( receipt . purchases ) ) { domainRegistration = find ( values ( receipt . purchases ) , isDomainRegistration ) ; } if ( cartItems . hasDomainRegistration ( cart ) ) { domainRegistration = cartItems . getDomainRegistrations ( cart ) [ 0 ] ; } if ( domainRegistration ) { return domainRegistration . meta ; } return null ; } 
function bustHashForHrefs ( { name , oldValue } ) { 
function getModulesWithDependencies ( root , fileList ) { const filePromises = fileList . map ( async fileWithPath => { const fileSource = await readFileAsync ( fspath . join ( root , fileWithPath ) , 'utf8' ) ; const deps = getDependencies ( fileSource ) ; return [ fileWithPath , deps ] ; } ) ; return Promise . all ( filePromises ) . then ( _ . fromPairs ) ; } 
function getDependencies ( code ) { var cache = Object . create ( null ) ; var deps = [ ] ; function addDependency ( dep ) { if ( ! cache [ dep ] ) { cache [ dep ] = true ; deps . push ( dep ) ; } } code . replace ( replacePatterns . BLOCK_COMMENT_RE , '' ) . replace ( replacePatterns . LINE_COMMENT_RE , '' ) . replace ( replacePatterns . IMPORT_RE , function ( match , pre , quot , dep ) { addDependency ( dep ) ; return match ; } ) . replace ( replacePatterns . EXPORT_RE , function ( match , pre , quot , dep ) { addDependency ( dep ) ; return match ; } ) . replace ( replacePatterns . REQUIRE_RE , function ( match , pre , quot , dep ) { addDependency ( dep ) ; } ) ; return deps ; } 
function generateUsageStats ( modules ) { function getCamelCasedDepName ( dep ) { return dep . split ( '/' ) . map ( function ( part ) { return _ . camelCase ( part ) ; } ) . join ( '/' ) ; } return Object . keys ( modules ) . reduce ( function ( target , moduleName ) { var deps = modules [ moduleName ] ; deps . forEach ( function ( dependency ) { const camelCasedDepName = getCamelCasedDepName ( dependency ) ; if ( ! target [ camelCasedDepName ] ) { target [ camelCasedDepName ] = { count : 0 } ; } target [ camelCasedDepName ] . count += 1 ; } ) ; return target ; } , { } ) ; } 
function updateCachedProduct ( products , product ) { let found = false ; const updatedProduct = { ... product , name : decodeEntities ( product . name ) } ; const newProducts = products . map ( p => { if ( p . id === product . id ) { found = true ; return updatedProduct ; } return p ; } ) ; if ( ! found ) { newProducts . push ( updatedProduct ) ; } return newProducts ; } 
function setLoading ( state , params , newStatus ) { const queries = ( state . queries && { ... state . queries } ) || { } ; const key = getSerializedProductsQuery ( params ) ; queries [ key ] = { ... ( queries [ key ] || { } ) , isLoading : newStatus } ; return queries ; } 
function getInitialServerState ( serializedServerState ) { 
function isUAInBrowserslist ( userAgentString , environment = 'defaults' ) { return matchesUA ( userAgentString , { env : environment , ignorePatch : true , ignoreMinor : true , allowHigherVersions : true , } ) ; } 
function generateStaticUrls ( target ) { const urls = { ... staticFilesUrls } ; const assets = getAssets ( target ) . assetsByChunkName ; forEach ( assets , ( asset , name ) => { urls [ name ] = asset ; } ) ; return urls ; } 
function getAcceptedLanguagesFromHeader ( header ) { if ( ! header ) { return [ ] ; } return header . split ( ',' ) . map ( lang => { const match = lang . match ( / ^[A-Z]{2,3}(-[A-Z]{2,3})? / i ) ; if ( ! match ) { return false ; } return match [ 0 ] . toLowerCase ( ) ; } ) . filter ( lang => lang ) ; } 
function setupLoggedInContext ( req , res , next ) { const isSupportSession = ! ! req . get ( 'x-support-session' ) ; const isLoggedIn = ! ! req . cookies . wordpress_logged_in ; req . context = { ... req . context , isSupportSession , isLoggedIn , } ; next ( ) ; } 
function setUpCSP ( req , res , next ) { const originalUrlPathname = req . originalUrl . split ( '?' ) [ 0 ] ; 
function renderServerError ( err , req , res , next ) { if ( process . env . NODE_ENV !== 'production' ) { console . error ( err ) ; } const target = getBuildTargetFromRequest ( req ) ; res . status ( err . status || 500 ) ; const ctx = { urls : generateStaticUrls ( target ) , faviconURL : config ( 'favicon_url' ) , } ; res . send ( renderJsx ( '500' , ctx ) ) ; } 
function handleLocaleSubdomains ( req , res , next ) { const langSlug = endsWith ( req . hostname , config ( 'hostname' ) ) ? split ( req . hostname , '.' ) [ 0 ] : null ; if ( langSlug && includes ( config ( 'magnificent_non_en_locales' ) , langSlug ) ) { 
function getOffsetItem ( state , currentItem , offset ) { const streamKey = getCurrentStream ( state ) ; if ( ! streamKey || ! state . reader . streams [ streamKey ] ) { return null ; } const stream = state . reader . streams [ streamKey ] ; let index = findIndex ( stream . items , item => keysAreEqual ( item , currentItem ) ) ; 
function ( post ) { let latitude , longitude ; if ( ! post ) { return ; } latitude = parseFloat ( getValueByKey ( post . metadata , 'geo_latitude' ) ) ; longitude = parseFloat ( getValueByKey ( post . metadata , 'geo_longitude' ) ) ; if ( latitude && longitude ) { return [ latitude , longitude ] ; } } 
function ( post ) { if ( ! post ) { return null ; } const isSharedPublicly = getValueByKey ( post . metadata , 'geo_public' ) ; if ( parseInt ( isSharedPublicly , 10 ) ) { return true ; } if ( undefined === isSharedPublicly ) { 
function sanitizeExtra ( data ) { const path = data . _contactDetailsCache ? [ '_contactDetailsCache' , 'extra' ] : 'extra' ; return data && isArray ( get ( data , path ) ) ? omit ( data , path ) : data ; } 
function transmitDraftId ( calypsoPort ) { 
function handlePressThis ( calypsoPort ) { calypsoPort . addEventListener ( 'message' , onPressThis , false ) ; calypsoPort . start ( ) ; function onPressThis ( message ) { const action = get ( message , 'data.action' ) ; const payload = get ( message , 'data.payload' ) ; if ( action !== 'pressThis' || ! payload ) { return ; } calypsoPort . removeEventListener ( 'message' , onPressThis , false ) ; const unsubscribe = subscribe ( ( ) => { 
function handlePostLocked ( calypsoPort ) { const unsubscribe = subscribe ( ( ) => { const isLocked = select ( 'core/editor' ) . isPostLocked ( ) ; const isLockTakeover = select ( 'core/editor' ) . isPostLockTakeover ( ) ; const lockedDialogButtons = document . querySelectorAll ( 'div.editor-post-locked-modal__buttons > a' ) ; const isPostTakeoverDialog = isLocked && ! isLockTakeover && lockedDialogButtons . length === 3 ; if ( isPostTakeoverDialog ) { 
function handlePostLockTakeover ( calypsoPort ) { const unsubscribe = subscribe ( ( ) => { const isLocked = select ( 'core/editor' ) . isPostLocked ( ) ; const isLockTakeover = select ( 'core/editor' ) . isPostLockTakeover ( ) ; const allPostsButton = document . querySelector ( 'div.editor-post-locked-modal__buttons > a' ) ; const isPostTakeoverDialog = isLocked && isLockTakeover && allPostsButton ; if ( isPostTakeoverDialog ) { 
function handleUpdateImageBlocks ( calypsoPort ) { calypsoPort . addEventListener ( 'message' , onUpdateImageBlocks , false ) ; calypsoPort . start ( ) ; const imageBlocks = { 'core/cover' : updateSingeImageBlock , 'core/image' : updateSingeImageBlock , 'core/file' : partialRight ( updateSingeImageBlock , { url : 'href' } ) , 'core/gallery' : updateMultipleImagesBlock , 'core/media-text' : partialRight ( updateSingeImageBlock , { id : 'mediaId' , url : 'mediaUrl' , } ) , 'jetpack/tiled-gallery' : updateMultipleImagesBlock , } ; function updateImageBlocks ( blocks , image ) { forEach ( blocks , block => { if ( imageBlocks [ block . name ] ) { imageBlocks [ block . name ] ( block , image ) ; } if ( block . innerBlocks . length ) { updateImageBlocks ( block . innerBlocks , image ) ; } } ) ; } function preloadImage ( imageUrl ) { return new Promise ( ( resolve , reject ) => { const preloadedImage = new Image ( ) ; preloadedImage . src = imageUrl ; preloadedImage . onload = resolve ; preloadedImage . onerror = reject ; } ) ; } function updateSingeImageBlock ( block , image , attrNames ) { const blockImageId = get ( block , 'attributes.id' ) ; if ( blockImageId !== image . id && blockImageId !== image . transientId ) { return ; } attrNames = { ... attrNames , id : 'id' , url : 'url' } ; if ( 'deleted' === image . status ) { dispatch ( 'core/editor' ) . updateBlockAttributes ( block . clientId , { [ attrNames . id ] : undefined , [ attrNames . url ] : undefined , } ) ; return ; } preloadImage ( image . url ) . then ( ( ) => { dispatch ( 'core/editor' ) . updateBlockAttributes ( block . clientId , { [ attrNames . id ] : image . id , [ attrNames . url ] : image . url , } ) ; } ) ; } function updateMultipleImagesBlock ( block , image , attrNames ) { attrNames = { ... attrNames , id : 'id' , url : 'url' , images : 'images' } ; const currentImages = get ( block , [ 'attributes' , attrNames . images ] ) ; let updatedImages = [ ] ; if ( 'deleted' === image . status ) { updatedImages = filter ( currentImages , currentImage => { return currentImage . id !== image . id && currentImage . id !== image . transientId ; } ) ; dispatch ( 'core/editor' ) . updateBlockAttributes ( block . clientId , { [ attrNames . images ] : updatedImages , } ) ; return ; } preloadImage ( image . url ) . then ( ( ) => { updatedImages = map ( currentImages , currentImage => { const currentImageId = parseInt ( currentImage . id , 10 ) ; if ( currentImageId !== image . id && currentImageId !== image . transientId ) { return currentImage ; } return { [ attrNames . id ] : image . id , [ attrNames . url ] : image . url , } ; } ) ; dispatch ( 'core/editor' ) . updateBlockAttributes ( block . clientId , { [ attrNames . images ] : updatedImages , } ) ; } ) ; } 
function updateImageBlocks ( blocks , image ) { forEach ( blocks , block => { if ( imageBlocks [ block . name ] ) { imageBlocks [ block . name ] ( block , image ) ; } if ( block . innerBlocks . length ) { updateImageBlocks ( block . innerBlocks , image ) ; } } ) ; } 
function updateFeaturedImagePreview ( image ) { const currentImageId = select ( 'core/editor' ) . getEditedPostAttribute ( 'featured_media' ) ; if ( currentImageId !== image . id ) { return ; } preloadImage ( image . url ) . then ( ( ) => { const currentImage = select ( 'core' ) . getMedia ( currentImageId ) ; const updatedImage = { ... currentImage , media_details : { height : image . height , width : image . width , } , source_url : image . url , } ; dispatch ( 'core' ) . receiveEntityRecords ( 'root' , 'media' , [ updatedImage ] , null , true ) ; } ) ; } 
function handlePreview ( calypsoPort ) { $ ( '#editor' ) . on ( 'click' , '.editor-post-preview' , e => { e . preventDefault ( ) ; e . stopPropagation ( ) ; const postUrl = select ( 'core/editor' ) . getCurrentPostAttribute ( 'link' ) ; const previewChannel = new MessageChannel ( ) ; calypsoPort . postMessage ( { action : 'previewPost' , payload : { postUrl : postUrl , } , } , [ previewChannel . port2 ] ) ; const isAutosaveable = select ( 'core/editor' ) . isEditedPostAutosaveable ( ) ; 
function handleInsertClassicBlockMedia ( calypsoPort ) { calypsoPort . addEventListener ( 'message' , onInsertClassicBlockMedia , false ) ; calypsoPort . start ( ) ; function onInsertClassicBlockMedia ( message ) { const action = get ( message , 'data.action' ) ; if ( action !== 'insertClassicBlockMedia' ) { return ; } const editorId = get ( message , 'data.payload.editorId' ) ; const media = get ( message , 'data.payload.media' ) ; tinymce . editors [ editorId ] . execCommand ( 'mceInsertContent' , false , media ) ; } } 
function handleGoToAllPosts ( calypsoPort ) { $ ( '#editor' ) . on ( 'click' , '.edit-post-fullscreen-mode-close__toolbar a' , e => { e . preventDefault ( ) ; calypsoPort . postMessage ( { action : 'goToAllPosts' , payload : { unsavedChanges : select ( 'core/editor' ) . isEditedPostDirty ( ) , } , } ) ; } ) ; } 
function openLinksInParentFrame ( ) { const viewPostLinkSelectors = [ '.components-notice-list .is-success .components-notice__action.is-link' , 
function toolbarPin ( editor ) { let isMonitoringScroll = false , isPinned = false , container ; function setContainer ( ) { container = editor . getContainer ( ) ; } function togglePinned ( toBePinned ) { isPinned = toBePinned ; editor . dom . toggleClass ( container , 'is-pinned' , isPinned ) ; } const pinToolbarOnScroll = throttle ( ( ) => { if ( ! container ) { return ; } if ( isPinned && window . pageYOffset < container . offsetTop ) { * Binds or unbinds the scroll event from the global window object, since * pinning behavior is restricted to larger viewports whilst the visual * editing mode is active. */ const maybeBindScroll = throttle ( event => { const isVisual = ! editor . isHidden ( ) ; const shouldBind = 'remove' !== event . type && isVisual && isWithinBreakpoint ( '>660px' ) ; if ( shouldBind === isMonitoringScroll ) { 
function TwoStepAuthorization ( ) { if ( ! ( this instanceof TwoStepAuthorization ) ) { return new TwoStepAuthorization ( ) ; } this . data = null ; this . initialized = false ; this . smsResendThrottled = false ; this . bumpMCStat = function ( eventAction ) { analytics . mc . bumpStat ( '2fa' , eventAction ) ; analytics . tracks . recordEvent ( 'calypso_login_twostep_authorize' , { event_action : eventAction , } ) ; } ; this . fetch ( ) ; } 
function _initStorage ( options ) { const dbInfo = { } ; if ( options ) { for ( const i in options ) { dbInfo [ i ] = options [ i ] ; } } dbInfo . db = { } ; dummyStorage [ dbInfo . name ] = dbInfo . db ; this . _dbInfo = dbInfo ; return Promise . resolve ( ) ; } 
function trackBodyClick ( event ) { if ( editorEventAncestor ( event , '.mce-colorbutton' ) && ! editorEventAncestor ( event , '.mce-open' ) ) { 
function getQueryManager ( state , siteId ) { if ( ! siteId ) { return state . posts . allSitesQueries ; } return state . posts . queries [ siteId ] || null ; } 
function ( state , action ) { if ( typeof state [ action . siteId ] !== 'undefined' ) { return Object . assign ( { } , state , { [ action . siteId ] : pluginsForSite ( state [ action . siteId ] , action ) , } ) ; } return state ; } 
function pluginsForSite ( state = [ ] , action ) { switch ( action . type ) { case PLUGIN_ACTIVATE_REQUEST_SUCCESS : case PLUGIN_DEACTIVATE_REQUEST_SUCCESS : case PLUGIN_UPDATE_REQUEST_SUCCESS : case PLUGIN_AUTOUPDATE_ENABLE_REQUEST_SUCCESS : case PLUGIN_AUTOUPDATE_DISABLE_REQUEST_SUCCESS : return state . map ( p => plugin ( p , action ) ) ; case PLUGIN_INSTALL_REQUEST_SUCCESS : return [ ... state , action . data ] ; case PLUGIN_REMOVE_REQUEST_SUCCESS : const index = findIndex ( state , { id : action . pluginId } ) ; return [ ... state . slice ( 0 , index ) , ... state . slice ( index + 1 ) ] ; default : return state ; } } 
function plugin ( state , action ) { switch ( action . type ) { case PLUGIN_ACTIVATE_REQUEST_SUCCESS : case PLUGIN_DEACTIVATE_REQUEST_SUCCESS : case PLUGIN_AUTOUPDATE_ENABLE_REQUEST_SUCCESS : case PLUGIN_AUTOUPDATE_DISABLE_REQUEST_SUCCESS : if ( state . id !== action . data . id ) { return state ; } return Object . assign ( { } , state , action . data ) ; case PLUGIN_UPDATE_REQUEST_SUCCESS : if ( state . id !== action . data . id ) { return state ; } return Object . assign ( { } , omit ( state , 'update' ) , action . data ) ; default : return state ; } } 
function initAtDCore ( ) { atdCore = new AtDCore ( ) ; atdCore . map = each ; atdCore . _isTinyMCE = true ; atdCore . getAttrib = function ( node , key ) { return dom . getAttrib ( node , key ) ; } ; atdCore . findSpans = function ( parent ) { if ( parent === undefined ) { return dom . select ( 'span' ) ; } return dom . select ( 'span' , parent ) ; } ; atdCore . hasClass = function ( node , className ) { return dom . hasClass ( node , className ) ; } ; atdCore . contents = function ( node ) { return node . childNodes ; } ; atdCore . replaceWith = function ( old_node , new_node ) { return dom . replace ( new_node , old_node ) ; } ; atdCore . create = function ( node_html ) { return dom . create ( 'span' , { class : 'mceItemHidden' , 'data-mce-bogus' : 1 } , node_html ) ; } ; atdCore . removeParent = function ( node ) { dom . remove ( node , true ) ; return node ; } ; atdCore . remove = function ( node ) { dom . remove ( node ) ; } ; atdCore . setIgnoreStrings ( editor . getParam ( 'atd_ignore_strings' , [ ] ) . join ( ',' ) ) ; atdCore . showTypes ( editor . getParam ( 'atd_show_types' , '' ) ) ; } 
function finish ( ) { let node , regex = new RegExp ( 'mceItemHidden|hidden(((Grammar|Spell)Error)|Suggestion)' ) , nodes = editor . dom . select ( 'span' ) , i = nodes . length ; while ( i -- ) { 
function showSuggestions ( target ) { let items = [ ] , text = target . innerText || target . textContent , errorDescription = atdCore . findSuggestion ( target ) ; if ( ! errorDescription ) { items . push ( { text : translate ( 'No suggestions' , { comment : 'Editor proofreading no suggestions' } ) , classes : 'atd-menu-title' , disabled : true , } ) ; } else { items . push ( { text : errorDescription . description , classes : 'atd-menu-title' , disabled : true , } ) ; if ( errorDescription . suggestions . length ) { items . push ( { text : '-' } ) ; 
function render_range ( new_sub_text , new_sub_range , range_info , range_data , options ) { 
function build_chunks ( sub_text , sub_ranges , range_data , container , options ) { let text_start = null , text_stop = null , i , remove_r_id , r_id , sr_id , range_id , range_info , new_i , new_sub_text , new_sub_range ; 
function find_largest_range ( rs ) { let r_id = - 1 , r_size = 0 , i ; if ( rs . length < 1 ) { return null ; } for ( i = 0 ; i < rs . length ; i ++ ) { if ( null === rs [ i ] ) { continue ; } 
function parseImage ( node , _parsed ) { _parsed . type = MediaTypes . IMAGE ; _parsed . media . URL = node . getAttribute ( 'src' ) ; _parsed . media . alt = node . getAttribute ( 'alt' ) ; 
function createProgressHandler ( ) { const startTime = Date . now ( ) ; let lastShownBuildingMessageTime = null ; let lastUnshownBuildingMessage = null ; return ( percentage , msg , ... details ) => { const nowTime = Date . now ( ) ; const timeString = ( ( nowTime - startTime ) / 1000 ) . toFixed ( 1 ) + 's' ; const percentageString = ` ${ Math . floor ( percentage * 100 ) } ` ; const detailsString = details . map ( detail => { if ( ! detail ) { return '' ; } if ( detail . length > 40 ) { return ` d tail.s u bstr( d tail.l e ngth - 3 ) } ; } return detail ; } ) . join ( ' ' ) ; const message = ` ${ timeString } ${ percentageString } ${ msg } ${ detailsString } ` ; 
function shouldTranspileDependency ( filepath ) { 
function getNodeAsString ( node ) { if ( undefined === node ) { return '' ; } switch ( node . type ) { case 'BinaryExpression' : return getNodeAsString ( node . left ) + getNodeAsString ( node . right ) ; case 'StringLiteral' : return node . value ; default : return '' ; } } 
function setUpLocale ( context , next ) { const language = getLanguage ( context . params . lang ) ; if ( language ) { context . lang = context . params . lang ; if ( language . rtl ) { context . isRTL = true ; } } next ( ) ; } 
function customPostMetadataToProductAttributes ( metadata ) { const productAttributes = { } ; metadata . forEach ( ( { key , value } ) => { const schemaKey = metaKeyToSchemaKeyMap [ key ] ; if ( ! schemaKey ) { return ; } 
function splitTextNode ( textnode , regexp , replacement ) { let text = textnode . nodeValue , index = text . search ( regexp ) , match = text . match ( regexp ) , captured = [ ] , cursor ; if ( index < 0 || ! match . length ) { return [ textnode ] ; } if ( index > 0 ) { 
function bringTheHurt ( node ) { let span , splitNodes ; if ( node . nodeType === 3 ) { ecount ++ ; if ( parent . isIE ( ) && node . nodeValue . length > 0 && node . nodeValue . substr ( 0 , 1 ) === ' ' ) { return parent . create ( emptySpan + node . nodeValue . substr ( 1 , node . nodeValue . length - 1 ) . replace ( regexp , result ) , false ) ; } if ( textOnlyMode ) { return parent . create ( node . nodeValue . replace ( regexp , result ) , false ) ; } span = parent . create ( '<span />' ) ; if ( typeof textOnlyMode === 'undefined' ) { 
function firstElementIsBreakline ( dom ) { if ( dom . childNodes . length === 0 ) { return dom . nodeName === 'BR' && dom ; } return firstElementIsBreakline ( dom . firstChild ) ; } 
function parseAsShortcode ( node , _parsed ) { 
function parseAsElement ( node , _parsed ) { 
function isDefaultOrNullQueryValue ( value , key ) { return value === undefined || value === null || DEFAULT_THEME_QUERY [ key ] === value ; } 
function getWebpackConfig ( env = { } , { entry = path . join ( __dirname , 'src' , 'standalone' ) , 'output-path' : outputPath = path . join ( __dirname , 'dist' ) , 'output-filename' : outputFilename = 'build.min.js' , } ) { const webpackConfig = getBaseWebpackConfig ( env , { entry , 'output-filename' : outputFilename , 'output-path' : outputPath , } ) ; const pageMeta = { nodePlatform : process . platform , nodeVersion : process . version , gitDescribe : spawnSync ( 'git' , [ 'describe' , '--always' , '--dirty' , '--long' ] , { encoding : 'utf8' , } ) . stdout . replace ( '\n' , '' ) , } ; return { ... webpackConfig , plugins : [ ... webpackConfig . plugins , new HtmlWebpackPlugin ( { filename : path . join ( outputPath , 'index.html' ) , template : path . join ( __dirname , 'src' , 'index.ejs' ) , title : 'Notifications' , hash : true , inject : false , isRTL : false , ... pageMeta , } ) , new HtmlWebpackPlugin ( { filename : path . join ( outputPath , 'rtl.html' ) , template : path . join ( __dirname , 'src' , 'index.ejs' ) , title : 'Notifications' , hash : true , inject : false , isRTL : true , ... pageMeta , } ) , new HtmlWebpackPlugin ( { filename : path . join ( outputPath , 'cache-buster.txt' ) , templateContent : ( ) => pageMeta . gitDescribe , inject : false , } ) , ] , } ; } 
function settings ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_CAMPAIGN_DEFAULTS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : return Object . assign ( { } , state , action . settings ) ; case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : const data = { mailchimp_lists : action . lists } ; const listKeys = keys ( action . lists ) ; if ( ! state . mailchimp_list && listKeys . length > 0 ) { 
function settingsRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST === type ; } return state ; } 
function settingsRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_SETTINGS_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function syncStatus ( state = { } , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_SUCCESS : return Object . assign ( { } , action . syncStatus ) ; } return state ; } 
function syncStatusRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST : case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST === type ; } return state ; } 
function syncStatusRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_SYNC_STATUS_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function resyncRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST === type ; } return state ; } 
function resyncRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_RESYNC_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function apiKeySubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT === type ; } return state ; } 
function apiKeySubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_API_KEY_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function storeInfoSubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT === type ; } return state ; } 
function storeInfoSubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_STORE_INFO_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function listsRequest ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE : return WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST === type ; } return state ; } 
function listsRequestError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_SUCCESS : case WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_LISTS_REQUEST_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function newsletterSettingsSubmit ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE : return WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT === type ; } return state ; } 
function newsletterSettingsSubmitError ( state = false , action ) { switch ( action . type ) { case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE : const error = WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE === action . type ? action . error : false ; return error ; } return state ; } 
function saveSettings ( state = false , { type } ) { switch ( type ) { case WOOCOMMERCE_MAILCHIMP_SAVE_SETTINGS : return true ; case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_SUCCESS : case WOOCOMMERCE_MAILCHIMP_NEWSLETTER_SETTINGS_SUBMIT_FAILURE : return false ; } return state ; } 
function deleteInvites ( siteInvites , invitesToDelete ) { return siteInvites . filter ( siteInvite => ! includes ( invitesToDelete , siteInvite . key ) ) ; } 
function StatsDataLocalList ( options ) { if ( ! ( this instanceof StatsDataLocalList ) ) { return new StatsDataLocalList ( options ) ; } if ( 'string' !== typeof options . localStoreKey ) { throw new TypeError ( 'a options.localStoreKey must be passed in' ) ; } debug ( 'creating new local list' ) ; this . localStoreKey = options . localStoreKey ; this . limit = options . limit || 10 ; return this ; } 
function getAliasesForExtensions ( { extensionsDirectory } ) { const extensionsNames = fs . readdirSync ( extensionsDirectory ) . filter ( filename => filename . indexOf ( '.' ) === - 1 ) ; 
function updatedAction ( siteId , originatingAction , successAction , sentData ) { return ( dispatch , getState , { data : receivedData } ) => { dispatch ( productUpdated ( siteId , receivedData , originatingAction ) ) ; const props = { sentData , receivedData } ; dispatchWithProps ( dispatch , getState , successAction , props ) ; } ; } 
function markdown ( editor ) { function allowMarkdownAttribute ( event ) { const ed = event . target ; Object . keys ( ed . schema . elements ) . forEach ( function ( key ) { ed . schema . elements [ key ] . attributes . markdown = { } ; ed . schema . elements [ key ] . attributesOrder . push ( 'markdown' ) ; } ) ; } editor . on ( 'preinit' , allowMarkdownAttribute ) ; } 
function getPurchasesBySite ( purchases , sites ) { return purchases . reduce ( ( result , currentValue ) => { const site = find ( result , { id : currentValue . siteId } ) ; if ( site ) { site . purchases = site . purchases . concat ( currentValue ) ; } else { const siteObject = find ( sites , { ID : currentValue . siteId } ) ; result = result . concat ( { id : currentValue . siteId , name : currentValue . siteName , slug : siteObject ? siteObject . slug : currentValue . domain , isDomainOnly : siteObject ? siteObject . options . is_domain_only : false , title : currentValue . siteName || currentValue . domain || '' , purchases : [ currentValue ] , domain : siteObject ? siteObject . domain : currentValue . domain , } ) ; } return result ; } , [ ] ) . sort ( ( a , b ) => ( a . title . toLowerCase ( ) > b . title . toLowerCase ( ) ? 1 : - 1 ) ) ; } 
function handleRenewNowClick ( purchase , siteSlug ) { const renewItem = cartItems . getRenewalItemFromProduct ( purchase , { domain : purchase . meta , } ) ; const renewItems = [ renewItem ] ; 
function isCancelable ( purchase ) { if ( isIncludedWithPlan ( purchase ) ) { return false ; } if ( isPendingTransfer ( purchase ) ) { return false ; } if ( isExpired ( purchase ) ) { return false ; } if ( isRefundable ( purchase ) ) { return true ; } return purchase . canDisableAutoRenew ; } 
function maybeWithinRefundPeriod ( purchase ) { if ( isRefundable ( purchase ) ) { return true ; } 
function isRemovable ( purchase ) { if ( isIncludedWithPlan ( purchase ) ) { return false ; } if ( isConciergeSession ( purchase ) ) { return false ; } return ( isJetpackPlan ( purchase ) || isExpiring ( purchase ) || isExpired ( purchase ) || ( isDomainTransfer ( purchase ) && ! isRefundable ( purchase ) && isPurchaseCancelable ( purchase ) ) ) ; } 
function paymentLogoType ( purchase ) { if ( isPaidWithCreditCard ( purchase ) ) { return purchase . payment . creditCard . type ; } if ( isPaidWithPayPalDirect ( purchase ) ) { return 'placeholder' ; } return purchase . payment . type || null ; } 
function imageHasMinWidthAndHeight ( width , height ) { return function ( image ) { return image . width >= width && image . height >= height ; } ; } 
function cssNameFromFilename ( name ) { if ( name ) { const [ cssChunkFilename , chunkQueryString ] = name . split ( '?' , 2 ) ; return cssChunkFilename . replace ( / \.js$ / i , '.css' + ( chunkQueryString ? ` ${ chunkQueryString } ` : '' ) ) ; } } 
function verifyHTML ( caption ) { if ( ! caption || ( caption . indexOf ( '<' ) === - 1 && caption . indexOf ( '>' ) === - 1 ) ) { return caption ; } if ( ! serializer ) { serializer = new tinymce . html . Serializer ( { } , editor . schema ) ; } return serializer . serialize ( editor . parser . parse ( caption , { forced_root_block : false } ) ) ; } 
function init ( { customEnhancer , customMiddleware = { } } = { } ) { const middle = withMiddleware ( customMiddleware ) ; const create = customEnhancer ? customEnhancer ( middle ) : middle ; store = create ( reducer , reducer ( undefined , { type : '@@INIT' } ) ) ; return store ; } 
function PopupMonitor ( ) { this . intervals = { } ; this . monitorInterval = null ; this . windowInstance = null ; this . onMessage = messageEvent => { if ( messageEvent . source === this . windowInstance ) { this . emit ( 'message' , messageEvent . data ) ; } } ; } 
function pluginsForSite ( state = [ ] , action ) { switch ( action . type ) { case PLUGIN_SETUP_INSTRUCTIONS_RECEIVE : return action . data ; case PLUGIN_SETUP_INSTALL : case PLUGIN_SETUP_ACTIVATE : case PLUGIN_SETUP_CONFIGURE : case PLUGIN_SETUP_FINISH : case PLUGIN_SETUP_ERROR : return state . map ( p => plugin ( p , action ) ) ; default : return state ; } } 
function plugin ( state , action ) { switch ( action . type ) { case PLUGIN_SETUP_INSTALL : case PLUGIN_SETUP_ACTIVATE : case PLUGIN_SETUP_CONFIGURE : case PLUGIN_SETUP_FINISH : if ( state . slug !== action . slug ) { return state ; } return Object . assign ( { } , state , { status : pluginStatus ( state . status , action ) , } ) ; case PLUGIN_SETUP_ERROR : if ( state . slug !== action . slug ) { return state ; } return Object . assign ( { } , state , { status : pluginStatus ( state . status , action ) , error : action . error , } ) ; default : return state ; } } 
function pluginStatus ( state , action ) { switch ( action . type ) { case PLUGIN_SETUP_INSTALL : return 'install' ; case PLUGIN_SETUP_ACTIVATE : return 'activate' ; case PLUGIN_SETUP_CONFIGURE : return 'configure' ; case PLUGIN_SETUP_FINISH : return 'done' ; default : return state || 'wait' ; } } 
function wpcomPlugin ( editor ) { var DOM = tinymce . DOM , each = tinymce . each , style ; editor . on ( 'focus' , function ( ) { window . wpActiveEditor = editor . id ; } ) ; * Experimental: create a floating toolbar. * This functionality will change in the next releases. Not recommended for use by plugins. */ editor . on ( 'preinit' , function ( ) { var Factory = tinymce . ui . Factory , settings = editor . settings , activeToolbar , currentSelection , timeout , container = editor . getContainer ( ) , wpAdminbar = document . getElementById ( 'wpadminbar' ) , mceIframe = document . getElementById ( editor . id + '_ifr' ) , mceToolbar , mceStatusbar , wpStatusbar , isChromeRtl = editor . getParam ( 'directionality' ) === 'rtl' && / Chrome / . test ( navigator . userAgent ) ; if ( container ) { mceToolbar = tinymce . $ ( '.mce-toolbar-grp' , container ) [ 0 ] ; mceStatusbar = tinymce . $ ( '.mce-statusbar' , container ) [ 0 ] ; } if ( editor . id === 'content' ) { wpStatusbar = document . getElementById ( 'post-status-info' ) ; } function create ( buttons , bottom ) { var toolbar , toolbarItems = [ ] , buttonGroup ; each ( buttons , function ( item ) { var itemName ; function bindSelectorChanged ( ) { var selection = editor . selection ; if ( itemName === 'bullist' ) { selection . selectorChanged ( 'ul > li' , function ( state , args ) { var i = args . parents . length , nodeName ; while ( i -- ) { nodeName = args . parents [ i ] . nodeName ; if ( nodeName === 'OL' || nodeName === 'UL' ) { break ; } } item . active ( state && nodeName === 'UL' ) ; } ) ; } if ( itemName === 'numlist' ) { selection . selectorChanged ( 'ol > li' , function ( state , args ) { var i = args . parents . length , nodeName ; while ( i -- ) { nodeName = args . parents [ i ] . nodeName ; if ( nodeName === 'OL' || nodeName === 'UL' ) { break ; } } item . active ( state && nodeName === 'OL' ) ; } ) ; } if ( item . settings . stateSelector ) { selection . selectorChanged ( item . settings . stateSelector , function ( state ) { item . active ( state ) ; } , true ) ; } if ( item . settings . disabledStateSelector ) { selection . selectorChanged ( item . settings . disabledStateSelector , function ( state ) { item . disabled ( state ) ; } ) ; } } if ( item === '|' ) { buttonGroup = null ; } else { if ( Factory . has ( item ) ) { item = { type : item , } ; if ( settings . toolbar_items_size ) { item . size = settings . toolbar_items_size ; } toolbarItems . push ( item ) ; buttonGroup = null ; } else { if ( ! buttonGroup ) { buttonGroup = { type : 'buttongroup' , items : [ ] , } ; toolbarItems . push ( buttonGroup ) ; } if ( editor . buttons [ item ] ) { itemName = item ; item = editor . buttons [ itemName ] ; if ( typeof item === 'function' ) { item = item ( ) ; } item . type = item . type || 'button' ; if ( settings . toolbar_items_size ) { item . size = settings . toolbar_items_size ; } item = Factory . create ( item ) ; buttonGroup . items . push ( item ) ; if ( editor . initialized ) { bindSelectorChanged ( ) ; } else { editor . on ( 'init' , bindSelectorChanged ) ; } } } } } ) ; toolbar = Factory . create ( { type : 'panel' , layout : 'stack' , classes : 'toolbar-grp inline-toolbar-grp' , ariaRoot : true , ariaRemember : true , items : [ { type : 'toolbar' , layout : 'flow' , items : toolbarItems , } , ] , } ) ; toolbar . bottom = bottom ; function reposition ( ) { if ( ! currentSelection ) { return this ; } var scrollX = window . pageXOffset || document . documentElement . scrollLeft , scrollY = window . pageYOffset || document . documentElement . scrollTop , windowWidth = window . innerWidth , windowHeight = window . innerHeight , iframeRect = mceIframe ? mceIframe . getBoundingClientRect ( ) : { top : 0 , right : windowWidth , bottom : windowHeight , left : 0 , width : windowWidth , height : windowHeight , } , toolbar = this . getEl ( ) , toolbarWidth = toolbar . offsetWidth , toolbarHeight = toolbar . offsetHeight , selection = currentSelection . getBoundingClientRect ( ) , selectionMiddle = ( selection . left + selection . right ) / 2 , buffer = 5 , margin = 8 , spaceNeeded = toolbarHeight + margin + buffer , wpAdminbarBottom = wpAdminbar ? wpAdminbar . getBoundingClientRect ( ) . bottom : 0 , mceToolbarBottom = mceToolbar ? mceToolbar . getBoundingClientRect ( ) . bottom : 0 , mceStatusbarTop = mceStatusbar ? windowHeight - mceStatusbar . getBoundingClientRect ( ) . top : 0 , wpStatusbarTop = wpStatusbar ? windowHeight - wpStatusbar . getBoundingClientRect ( ) . top : 0 , blockedTop = Math . max ( 0 , wpAdminbarBottom , mceToolbarBottom , iframeRect . top ) , blockedBottom = Math . max ( 0 , mceStatusbarTop , wpStatusbarTop , windowHeight - iframeRect . bottom ) , spaceTop = selection . top + iframeRect . top - blockedTop , spaceBottom = windowHeight - iframeRect . top - selection . bottom - blockedBottom , editorHeight = windowHeight - blockedTop - blockedBottom , className = '' , top , left ; if ( spaceTop >= editorHeight || spaceBottom >= editorHeight ) { return this . hide ( ) ; } if ( this . bottom ) { if ( spaceBottom >= spaceNeeded ) { className = ' mce-arrow-up' ; top = selection . bottom + iframeRect . top + scrollY ; } else if ( spaceTop >= spaceNeeded ) { className = ' mce-arrow-down' ; top = selection . top + iframeRect . top + scrollY - toolbarHeight - margin ; } } else { if ( spaceTop >= spaceNeeded ) { className = ' mce-arrow-down' ; top = selection . top + iframeRect . top + scrollY - toolbarHeight - margin ; } else if ( spaceBottom >= spaceNeeded && editorHeight / 2 > selection . bottom + iframeRect . top - blockedTop ) { className = ' mce-arrow-up' ; top = selection . bottom + iframeRect . top + scrollY ; } } if ( typeof top === 'undefined' ) { top = scrollY + blockedTop + buffer ; } left = selectionMiddle - toolbarWidth / 2 + iframeRect . left + scrollX ; if ( selection . left < 0 || selection . right > iframeRect . width ) { left = iframeRect . left + scrollX + ( iframeRect . width - toolbarWidth ) / 2 ; } else if ( toolbarWidth >= windowWidth ) { className += ' mce-arrow-full' ; left = 0 ; } else if ( ( left < 0 && selection . left + toolbarWidth > windowWidth ) || ( left + toolbarWidth > windowWidth && selection . right - toolbarWidth < 0 ) ) { left = ( windowWidth - toolbarWidth ) / 2 ; } else if ( left < iframeRect . left + scrollX ) { className += ' mce-arrow-left' ; left = selection . left + iframeRect . left + scrollX ; } else if ( left + toolbarWidth > iframeRect . width + iframeRect . left + scrollX ) { className += ' mce-arrow-right' ; left = selection . right - toolbarWidth + iframeRect . left + scrollX ; } toolbar . className = toolbar . className . replace ( / ?mce-arrow-[\w]+ / g , '' ) + className ; DOM . setStyles ( toolbar , { left : left , top : top , } ) ; return this ; } toolbar . on ( 'show' , function ( ) { this . reposition ( ) ; if ( isChromeRtl ) { editor . $ ( '.mce-widget.mce-tooltip' , document . body ) . addClass ( 'wp-hide-mce-tooltip' ) ; } } ) ; toolbar . on ( 'keydown' , function ( event ) { if ( event . keyCode === 27 ) { this . hide ( ) ; editor . focus ( ) ; } } ) ; editor . on ( 'remove' , function ( ) { toolbar . remove ( ) ; } ) ; toolbar . reposition = reposition ; toolbar . hide ( ) . renderTo ( document . body ) ; return toolbar ; } editor . shortcuts . add ( 'alt+119' , '' , function ( ) { var node ; if ( activeToolbar ) { node = activeToolbar . find ( 'toolbar' ) [ 0 ] ; node && node . focus ( true ) ; } } ) ; editor . on ( 'nodechange' , function ( event ) { var collapsed = editor . selection . isCollapsed ( ) ; var args = { element : event . element , parents : event . parents , collapsed : collapsed , } ; editor . fire ( 'wptoolbar' , args ) ; currentSelection = args . selection || args . element ; if ( activeToolbar ) { activeToolbar . hide ( ) ; } if ( args . toolbar ) { activeToolbar = args . toolbar ; activeToolbar . show ( ) ; } else { activeToolbar = false ; } } ) ; editor . on ( 'focus' , function ( ) { if ( activeToolbar ) { activeToolbar . show ( ) ; } } ) ; function hide ( event ) { if ( activeToolbar ) { activeToolbar . hide ( ) ; if ( event . type === 'hide' || event . type === 'blur' ) { activeToolbar = false ; } else if ( event . type === 'resizewindow' || event . type === 'scrollwindow' ) { clearTimeout ( timeout ) ; timeout = setTimeout ( function ( ) { if ( activeToolbar && typeof activeToolbar . show === 'function' ) { activeToolbar . show ( ) ; } } , 250 ) ; } } } DOM . bind ( window , 'resize scroll' , hide ) ; editor . on ( 'remove' , function ( ) { DOM . unbind ( window , 'resize scroll' , hide ) ; } ) ; editor . on ( 'blur hide' , hide ) ; editor . wp = editor . wp || { } ; editor . wp . _createToolbar = create ; } , true ) ; } 
function FollowListSite ( args ) { if ( ! ( this instanceof FollowListSite ) ) { return new FollowListSite ( args ) ; } this . site_id = args . site_id ; this . is_following = args . is_following ; this . blog_domain = args . blog_domain ; } 
function setRTLFlagOnCSSLink ( url , isRTL ) { if ( isRTL ) { return url . endsWith ( '.rtl.css' ) ? url : url . replace ( / \.css$ / , '.rtl.css' ) ; } return ! url . endsWith ( '.rtl.css' ) ? url : url . replace ( / \.rtl.css$ / , '.css' ) ; } 
function loadCSS ( cssUrl , currentLink ) { return new Promise ( resolve => { const link = document . createElement ( 'link' ) ; link . rel = 'stylesheet' ; link . type = 'text/css' ; link . href = cssUrl ; if ( 'onload' in link ) { link . onload = ( ) => { link . onload = null ; resolve ( link ) ; } ; } else { 
function overwriteExistingPurchases ( existingPurchases , newPurchases ) { let purchases = newPurchases ; existingPurchases . forEach ( purchase => { if ( ! find ( purchases , { ID : purchase . ID } ) ) { purchases = purchases . concat ( purchase ) ; } } ) ; return purchases ; } 
function removeMissingPurchasesByPredicate ( existingPurchases , newPurchases , predicate ) { return existingPurchases . filter ( purchase => { if ( matches ( predicate ) ( purchase ) && find ( newPurchases , { ID : purchase . ID } ) ) { 
function insertDependentKey ( map , key , currentIndex , arr ) { const weakMapKey = key || STATIC_FALSY_KEY ; const existingMap = map . get ( weakMapKey ) ; if ( existingMap ) { return existingMap ; } const newMap = currentIndex === arr . length - 1 ? new Map ( ) : new WeakMap ( ) ; map . set ( weakMapKey , newMap ) ; return newMap ; } 
function ( fetchOptions ) { const namespace = getNamespace ( fetchOptions ) ; debug ( 'getPaginationData:' , namespace ) ; return { fetchInitialized : _followersFetchedByNamespace . hasOwnProperty ( namespace ) , totalFollowers : _totalFollowersByNamespace [ namespace ] || 0 , fetchingFollowers : _fetchingFollowersByNamespace [ namespace ] || false , followersCurrentPage : _pageByNamespace [ namespace ] , numFollowersFetched : _followersFetchedByNamespace [ namespace ] , fetchNameSpace : namespace , } ; } 
function sortProducts ( products ) { let planItems , includedItems , domainItems , creditItems , otherItems ; planItems = products . filter ( isPlan ) ; includedItems = products . filter ( isIncludedWithPlan ) ; domainItems = difference ( products , includedItems ) ; domainItems = domainItems . filter ( isDomainProduct ) ; domainItems = toPairs ( groupBy ( domainItems , 'meta' ) ) ; domainItems = sortBy ( domainItems , function ( pair ) { if ( pair [ 1 ] [ 0 ] && pair [ 1 ] [ 0 ] . cost === 0 ) { return - 1 ; } return pair [ 0 ] ; } ) ; domainItems = domainItems . map ( function ( pair ) { return sortBy ( pair [ 1 ] , getDomainProductRanking ) ; } ) ; domainItems = flatten ( domainItems ) ; creditItems = products . filter ( isCredits ) ; otherItems = difference ( products , planItems , domainItems , includedItems , creditItems ) ; return planItems . concat ( includedItems ) . concat ( domainItems ) . concat ( otherItems ) . concat ( creditItems ) ; } 
function proxyOAuth ( request , response ) { 
function UndocumentedSite ( id , wpcom ) { debug ( 'UndocumentedSite' , id ) ; if ( ! ( this instanceof UndocumentedSite ) ) { return new UndocumentedSite ( id , wpcom ) ; } this . wpcom = wpcom ; this . _id = id ; } 
function addOrEditProduct ( list = [ ] , newProduct ) { let found = 0 ; const products = list . map ( product => { if ( product . ID === newProduct . ID ) { found = 1 ; return newProduct ; } return product ; } ) ; if ( ! found ) { return [ newProduct , ... products ] ; } return products ; } 
function createNavigation ( context ) { const siteFragment = getSiteFragment ( context . pathname ) ; let basePath = context . pathname ; if ( siteFragment ) { basePath = sectionify ( context . pathname ) ; } return ( < NavigationComponent path = { context . path } allSitesPath = { basePath } siteBasePath = { basePath } / > ) ; } 
function createSitesComponent ( context ) { const contextPath = sectionify ( context . path ) ; 
function updateState ( state , domainName , data ) { const command = { [ domainName ] : { $set : Object . assign ( { } , state [ domainName ] || initialDomainState , data ) , } , } ; return update ( state , command ) ; } 
function ( siteId ) { return { totalViewers : _totalViewers [ siteId ] || 0 , fetchingViewers : _fetchingViewers [ siteId ] , currentViewersPage : _viewersCurrentPage [ siteId ] , numViewersFetched : _numViewersFetched [ siteId ] , } ; } 
function updateReceiptState ( state , receiptId , attributes ) { return Object . assign ( { } , state , { [ receiptId ] : Object . assign ( { } , initialReceiptState , state [ receiptId ] , attributes ) , } ) ; } 
function isTrackingPixel ( image ) { if ( ! image || ! image . src ) { return false ; } const edgeLength = image . height + image . width ; return edgeLength === 1 || edgeLength === 2 ; } 
function isCandidateForContentImage ( image ) { if ( ! image || ! image . getAttribute ( 'src' ) ) { return false ; } const ineligibleCandidateUrlParts = [ 'gravatar.com' , '/wpcom-smileys/' ] ; const imageUrl = image . getAttribute ( 'src' ) ; const imageShouldBeExcludedFromCandidacy = some ( ineligibleCandidateUrlParts , urlPart => includes ( imageUrl . toLowerCase ( ) , urlPart ) ) ; return ! ( isTrackingPixel ( image ) || imageShouldBeExcludedFromCandidacy ) ; } 
function getProductCategoryLabel ( state , categoryId , siteId = getSelectedSiteId ( state ) ) { const categoryState = getRawCategoryState ( state , siteId ) ; const categories = categoryState . items || { } ; const category = categories [ categoryId ] ; if ( ! category ) { return '' ; } if ( ! Number ( category . parent ) ) { return category . name ; } return getProductCategoryLabel ( state , category . parent , siteId ) + ` ${ category . name } ` ; } 
function getEnhancedContext ( req , res ) { return Object . assign ( { } , req . context , { isServerSide : true , originalUrl : req . originalUrl , path : req . url , pathname : req . path , params : req . params , query : req . query , redirect : res . redirect . bind ( res ) , res , } ) ; } 
function ready ( ) { const notes = getAllNotes ( store . getState ( ) ) ; const timestamps = notes . map ( property ( 'timestamp' ) ) . map ( timestamp => Date . parse ( timestamp ) / 1000 ) ; let newNoteCount = timestamps . filter ( time => time > this . lastSeenTime ) . length ; if ( ! this . firstRender && this . lastSeenTime === 0 ) { newNoteCount = 0 ; } const latestType = get ( notes . slice ( - 1 ) [ 0 ] , 'type' , null ) ; store . dispatch ( { type : 'APP_RENDER_NOTES' , newNoteCount , latestType } ) ; this . hasNewNoteData = false ; this . firstRender = false ; } 
function updateLastSeenTime ( proposedTime , fromStorage ) { let fromNote = false ; let mostRecentNoteTime = 0 ; 
function castProductIDsToNumbers ( cartItems ) { return cartItems . map ( function ( item ) { return assign ( { } , item , { product_id : parseInt ( item . product_id , 10 ) } ) ; } ) ; } 
function updateViewport ( ) { const viewport = { } ; viewport . top = window . scrollY ; viewport . left = window . scrollX ; viewport . width = window . innerWidth ; viewport . height = window . innerHeight ; viewport . right = viewport . left + viewport . width ; viewport . bottom = viewport . top + viewport . height ; debug ( 'viewport: %o' , viewport ) ; return viewport ; } 
function _offset ( box , doc ) { const body = doc . body || doc . getElementsByTagName ( 'body' ) [ 0 ] ; const docEl = doc . documentElement || body . parentNode ; const clientTop = docEl . clientTop || body . clientTop || 0 ; const clientLeft = docEl . clientLeft || body . clientLeft || 0 ; const scrollTop = window . pageYOffset || docEl . scrollTop ; const scrollLeft = window . pageXOffset || docEl . scrollLeft ; return { top : box . top + scrollTop - clientTop , left : box . left + scrollLeft - clientLeft , } ; } 
function ( off , el ) { const ew = getBoundingClientRect ( el ) . width ; off . left = Math . max ( 0 , Math . min ( off . left , viewport . width - ew ) ) ; return off ; } 
function accessibleFocus ( ) { document . addEventListener ( 'keydown' , function ( event ) { if ( keyboardNavigation ) { return ; } if ( keyboardNavigationKeycodes . indexOf ( event . keyCode ) !== - 1 ) { keyboardNavigation = true ; document . documentElement . classList . add ( 'accessible-focus' ) ; } } ) ; document . addEventListener ( 'mouseup' , function ( ) { if ( ! keyboardNavigation ) { return ; } keyboardNavigation = false ; document . documentElement . classList . remove ( 'accessible-focus' ) ; } ) ; } 
function filterNoticesBy ( site , pluginSlug , log ) { if ( ! site && ! pluginSlug ) { return true ; } if ( isSameSiteNotice ( site , log ) && isSamePluginNotice ( pluginSlug , log ) ) { return true ; } else if ( ! pluginSlug && isSameSiteNotice ( site , log ) ) { return true ; } else if ( ! site && isSamePluginNotice ( pluginSlug , log ) ) { return true ; } return false ; } 
function isInViewportRange ( elementStart , elementEnd ) { let viewportStart = window . scrollY , viewportEnd = document . documentElement . clientHeight + window . scrollY ; return elementStart > viewportStart && elementEnd < viewportEnd ; } 
function scrollIntoViewport ( element ) { const elementStartY = recursivelyWalkAndSum ( element , 'offsetTop' , 'offsetParent' ) , elementEndY = elementStartY + element . offsetHeight ; if ( isInViewportRange ( elementStartY , elementEndY ) ) { return ; } try { window . scroll ( { top : elementStartY , left : 0 , behavior : 'smooth' , } ) ; } catch ( e ) { window . scrollTo ( 0 , elementStartY ) ; } } 
function setup ( ) { var build = null , errors = '' , rootdir = path . resolve ( __dirname , '..' , '..' ) ; function spawnMake ( ) { debug ( 'spawning %o' , 'npm run build-css' ) ; build = spawn ( 'npm' , [ 'run' , 'build-css' ] , { shell : true , cwd : rootdir , stdio : [ 'ignore' , 'pipe' , 'pipe' ] , } ) ; errors = '' ; build . once ( 'exit' , onexit ) ; build . stdout . setEncoding ( 'utf8' ) ; build . stdout . on ( 'data' , onstdout ) ; build . stderr . on ( 'data' , onstderr ) ; } function onstdout ( d ) { debug ( 'stdout %o' , d . trim ( ) ) ; } function onexit ( ) { build . stderr . removeListener ( 'data' , onstderr ) ; build . stdout . removeListener ( 'data' , onstdout ) ; build = null ; } function onstderr ( stderr ) { process . stderr . write ( stderr . toString ( 'utf8' ) ) ; errors += stderr . toString ( 'utf8' ) ; } return function ( req , res , next ) { if ( ! build ) { spawnMake ( ) ; } build . once ( 'exit' , function ( code ) { if ( 0 === code ) { 
function parseCaption ( node , _parsed ) { 
function applyMetadataEdit ( metadata , edit ) { switch ( edit . operation ) { case 'update' : { 
function KeyboardShortcuts ( keyBindings ) { if ( ! ( this instanceof KeyboardShortcuts ) ) { return new KeyboardShortcuts ( keyBindings ) ; } 
function ( ) { return flatten ( compact ( map ( this . _flow . steps , function ( step ) { return steps [ step ] . providesDependencies ; } ) ) ) . concat ( this . _flow . providesDependenciesInQuery ) ; } 
function isPendingSyncStart ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) ; const fullSyncRequest = getFullSyncRequest ( state , siteId ) ; 
function isFullSyncing ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) ; if ( ! syncStatus ) { return false ; } const isStarted = get ( syncStatus , 'started' ) ; const isFinished = get ( syncStatus , 'finished' ) ; return isStarted && ! isFinished ; } 
function getSyncProgressPercentage ( state , siteId ) { const syncStatus = getSyncStatus ( state , siteId ) , queued = get ( syncStatus , 'queue' ) , sent = get ( syncStatus , 'sent' ) , total = get ( syncStatus , 'total' ) , queuedMultiplier = 0.1 , sentMultiplier = 0.9 ; if ( isPendingSyncStart ( state , siteId ) || ! queued || ! sent || ! total ) { return 0 ; } const countQueued = reduce ( queued , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const countSent = reduce ( sent , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const countTotal = reduce ( total , ( sum , value ) => { return ( sum += value ) ; } , 0 ) ; const percentQueued = ( countQueued / countTotal ) * queuedMultiplier * 100 ; const percentSent = ( countSent / countTotal ) * sentMultiplier * 100 ; return Math . ceil ( percentQueued + percentSent ) ; } 
function ( pageUrl , eventType , duration ) { 
function mergeDomainRegistrantContactDetails ( domainState , registrantContactDetails ) { return isArray ( domainState . data ) ? domainState . data . map ( item => { if ( item . type === whoisType . REGISTRANT ) { return { ... item , ... registrantContactDetails , } ; } return item ; } ) : [ { ... registrantContactDetails , type : whoisType . REGISTRANT , } , ] ; } 
function maybeRefreshCountryCodeCookieGdpr ( callback ) { const cookieMaxAgeSeconds = 6 * 60 * 60 ; const cookies = cookie . parse ( document . cookie ) ; if ( ! cookies . country_code ) { 
function setupQuoraGlobal ( ) { if ( window . qp ) { return ; } const quoraPixel = ( window . qp = function ( ) { quoraPixel . qp ? quoraPixel . qp . apply ( quoraPixel , arguments ) : quoraPixel . queue . push ( arguments ) ; } ) ; quoraPixel . queue = [ ] ; } 
function setupFacebookGlobal ( ) { if ( window . fbq ) { return ; } const facebookEvents = ( window . fbq = function ( ) { if ( facebookEvents . callMethod ) { facebookEvents . callMethod . apply ( facebookEvents , arguments ) ; } else { facebookEvents . queue . push ( arguments ) ; } } ) ; if ( ! window . _fbq ) { window . _fbq = facebookEvents ; } window . _fbq . disablePushState = true ; facebookEvents . push = facebookEvents ; facebookEvents . loaded = true ; facebookEvents . version = '2.0' ; facebookEvents . queue = [ ] ; } 
function setupTwitterGlobal ( ) { if ( window . twq ) { return ; } const twq = ( window . twq = function ( ) { twq . exe ? twq . exe . apply ( twq , arguments ) : twq . queue . push ( arguments ) ; } ) ; twq . version = '1.1' ; twq . queue = [ ] ; } 
function setupNanigansGlobal ( ) { const normalizedHashedEmail = getNormalizedHashedUserEmail ( user ) ; window . NaN_api = [ [ TRACKING_IDS . nanigansAppId , normalizedHashedEmail ? normalizedHashedEmail : '' ] , ] ; isNanigansConfigured = true ; debug ( 'Nanigans setup: ' , window . NaN_api ) ; } 
function recordProduct ( product , orderId ) { if ( ! isAdTrackingAllowed ( ) ) { debug ( 'recordProduct: [Skipping] ad tracking is not allowed' ) ; return ; } if ( TRACKING_STATE_VALUES . LOADED !== trackingState ) { loadTrackingScripts ( recordProduct . bind ( null , product , orderId ) ) ; return ; } const isJetpackPlan = productsValues . isJetpackPlan ( product ) ; if ( isJetpackPlan ) { debug ( 'Recording Jetpack purchase' , product ) ; } else { debug ( 'Recording purchase' , product ) ; } const currentUser = user . get ( ) ; const userId = currentUser ? hashPii ( currentUser . ID ) : 0 ; try { 
function recordOrderInQuantcast ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isQuantcastEnabled ) { return ; } if ( wpcomJetpackCartInfo . containsWpcomProducts ) { if ( null !== wpcomJetpackCartInfo . wpcomCostUSD ) { 
function recordOrderInFloodlight ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isFloodlightEnabled ) { return ; } debug ( 'recordOrderInFloodlight: record purchase' ) ; debug ( 'recordOrderInFloodlight:' ) ; recordParamsInFloodlightGtag ( { value : cart . total_cost , transaction_id : orderId , u1 : cart . total_cost , u2 : cart . products . map ( product => product . product_name ) . join ( ', ' ) , u3 : cart . currency , send_to : 'DC-6355556/wpsal0/wpsale+transactions' , } ) ; 
function recordOrderInNanigans ( cart , orderId ) { if ( ! isAdTrackingAllowed ( ) || ! isNanigansEnabled ) { return ; } const paidProducts = cart . products . filter ( product => product . cost >= 0.01 ) ; if ( paidProducts . length === 0 ) { debug ( 'recordOrderInNanigans: Skip cart because it has ONLY <0.01 products' ) ; return ; } debug ( 'recordOrderInNanigans: Record purchase' ) ; const productPrices = paidProducts . map ( product => product . cost * 100 ) ; 
function recordOrderInFacebook ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) || ! isFacebookEnabled ) { return ; } if ( cart . total_cost < 0.01 ) { debug ( 'recordOrderInFacebook: skipping due to a 0-value cart.' ) ; return ; } const currentUser = user . get ( ) ; const userId = currentUser ? hashPii ( currentUser . ID ) : 0 ; 
function recordOrderInBing ( cart , orderId , wpcomJetpackCartInfo ) { 
function floodlightSessionId ( ) { const cookies = cookie . parse ( document . cookie ) ; const existingSessionId = cookies [ DCM_FLOODLIGHT_SESSION_COOKIE_NAME ] ; if ( existingSessionId ) { debug ( 'Floodlight: Existing session: ' + existingSessionId ) ; return existingSessionId ; } 
function floodlightUserParams ( ) { const params = { } ; const currentUser = user . get ( ) ; if ( currentUser ) { params . u4 = hashPii ( currentUser . ID ) ; } const anonymousUserId = tracksAnonymousUserId ( ) ; if ( anonymousUserId ) { params . u5 = anonymousUserId ; } return params ; } 
function recordParamsInFloodlightGtag ( params ) { if ( ! isAdTrackingAllowed ( ) || ! isFloodlightEnabled ) { return ; } 
function recordOrderInCriteo ( cart , orderId ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { return ; } const params = [ 'trackTransaction' , { id : orderId , currency : cart . currency , item : cartToCriteoItems ( cart ) , } , ] ; debug ( 'recordOrderInCriteo:' , params ) ; recordInCriteo ( ... params ) ; } 
function recordViewCheckoutInCriteo ( cart ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { return ; } if ( cart . is_signup ) { return ; } 
function cartToCriteoItems ( cart ) { return cart . products . map ( product => { return { id : product . product_id , price : product . cost , quantity : product . volume , } ; } ) ; } 
function recordInCriteo ( eventName , eventProps ) { if ( ! isAdTrackingAllowed ( ) || ! isCriteoEnabled ) { debug ( 'recordInCriteo: [Skipping] ad tracking is not allowed' ) ; return ; } if ( TRACKING_STATE_VALUES . LOADED !== trackingState ) { loadTrackingScripts ( recordInCriteo . bind ( null , eventName , eventProps ) ) ; return ; } const events = [ ] ; events . push ( { event : 'setAccount' , account : TRACKING_IDS . criteo } ) ; events . push ( { event : 'setSiteType' , type : criteoSiteType ( ) } ) ; const normalizedHashedEmail = getNormalizedHashedUserEmail ( user ) ; if ( normalizedHashedEmail ) { events . push ( { event : 'setEmail' , email : [ normalizedHashedEmail ] } ) ; } const conversionEvent = clone ( eventProps ) ; conversionEvent . event = eventName ; events . push ( conversionEvent ) ; 
function recordOrderInGoogleAnalytics ( cart , orderId ) { if ( ! isAdTrackingAllowed ( ) ) { debug ( 'recordOrderInGoogleAnalytics: skipping as ad tracking is disallowed' ) ; return ; } const transaction = { id : orderId , affiliation : 'WordPress.com' , revenue : cart . total_cost , currency : cart . currency , } ; debug ( 'recordOrderInGoogleAnalytics: ga ecommerce add transaction' , transaction ) ; window . ga ( 'ecommerce:addTransaction' , transaction ) ; } 
function recordOrderInGoogleAds ( cart , orderId , wpcomJetpackCartInfo ) { if ( ! isAdTrackingAllowed ( ) ) { debug ( 'recordOrderInGoogleAds: skipping as ad tracking is disallowed' ) ; return ; } if ( isJetpackGoogleAdsGtagEnabled ) { if ( wpcomJetpackCartInfo . containsJetpackProducts ) { const params = [ 'event' , 'conversion' , { send_to : TRACKING_IDS . jetpackGoogleAdsGtagPurchase , value : wpcomJetpackCartInfo . jetpackCost , currency : cart . currency , transaction_id : orderId , } , ] ; debug ( 'recordOrderInGoogleAds: Record Jetpack Purchase' , params ) ; window . gtag ( ... params ) ; } } if ( isWpcomGoogleAdsGtagEnabled ) { if ( wpcomJetpackCartInfo . containsWpcomProducts ) { const params = [ 'event' , 'conversion' , { send_to : TRACKING_IDS . wpcomGoogleAdsGtagPurchase , value : wpcomJetpackCartInfo . wpcomCost , currency : cart . currency , transaction_id : orderId , } , ] ; debug ( 'recordOrderInGoogleAds: Record WPCom Purchase' , params ) ; window . gtag ( ... params ) ; } } } 
function initFacebook ( ) { if ( user . get ( ) ) { initFacebookAdvancedMatching ( ) ; } else { window . fbq ( 'init' , TRACKING_IDS . facebookInit ) ; window . fbq ( 'set' , 'autoConfig' , false , TRACKING_IDS . facebookJetpackInit ) ; window . fbq ( 'init' , TRACKING_IDS . facebookJetpackInit ) ; } } 
function initFacebookAdvancedMatching ( ) { const normalizedHashedEmail = getNormalizedHashedUserEmail ( user ) ; const advancedMatching = normalizedHashedEmail ? { em : normalizedHashedEmail } : { } ; debug ( 'initFacebookAdvancedMatching:' , advancedMatching ) ; window . fbq ( 'init' , TRACKING_IDS . facebookInit , advancedMatching ) ; window . fbq ( 'set' , 'autoConfig' , false , TRACKING_IDS . facebookJetpackInit ) ; window . fbq ( 'init' , TRACKING_IDS . facebookJetpackInit , advancedMatching ) ; } 
function isServerSideRenderCompatible ( context ) { return Boolean ( isSectionIsomorphic ( context . store . getState ( ) ) && ! context . user && 
function setTabIndexOnEditorIframe ( tabindex ) { return function ( ) { 
function jsonp ( url , query , fn ) { let prefix = '__jp' , timeout = 60000 , enc = encodeURIComponent , target = document . getElementsByTagName ( 'script' ) [ 0 ] || document . head , script , timer , id ; 
function cleanupRepliesCache ( ) { const keysToRemove = [ ] ; try { for ( let i = 0 ; i < localStorage . length ; i ++ ) { const storedReplyKey = localStorage . key ( i ) ; 
function parseGitDiffToPathArray ( command ) { return execSync ( command , { encoding : 'utf8' } ) . split ( '\n' ) . map ( name => name . trim ( ) ) . filter ( name => / (?:\.json|\.[jt]sx?|\.scss)$ / . test ( name ) ) ; } 
function getCategoryForPluginsBrowser ( context ) { if ( context . params . plugin && includes ( allowedCategoryNames , context . params . plugin ) ) { return context . params . plugin ; } return context . params . category ; } 
function createSuccess ( siteId , { email } , { account_id } ) { return { type : WOOCOMMERCE_SETTINGS_STRIPE_CONNECT_ACCOUNT_CREATE_COMPLETE , connectedUserID : account_id , email , siteId , } ; } 
function fetchSuccess ( siteId , fetchAction , data ) { const { account_id , display_name , email , business_logo , legal_entity , payouts_enabled } = data ; return { type : WOOCOMMERCE_SETTINGS_STRIPE_CONNECT_ACCOUNT_DETAILS_UPDATE , connectedUserID : account_id , displayName : display_name , email , firstName : legal_entity . first_name , isActivated : payouts_enabled , logo : business_logo , lastName : legal_entity . last_name , siteId , } ; } 
function oauthConnectFailure ( siteId , action , { error , message } ) { return { type : WOOCOMMERCE_SETTINGS_STRIPE_CONNECT_ACCOUNT_OAUTH_CONNECT_COMPLETE , error : message || error , siteId , } ; } 
function requestPosts ( siteId , query = { } ) { return dispatch => { dispatch ( { type : POSTS_REQUEST , siteId , query , } ) ; const source = siteId ? wpcom . site ( siteId ) : wpcom . me ( ) ; return source . postsList ( { ... query } ) . then ( ( { found , posts } ) => { dispatch ( receivePosts ( posts ) ) ; dispatch ( { type : POSTS_REQUEST_SUCCESS , siteId , query , found , posts , } ) ; } ) . catch ( error => { dispatch ( { type : POSTS_REQUEST_FAILURE , siteId , query , error , } ) ; } ) ; } ; } 
function normalizeApiAttributes ( attributes ) { attributes = clone ( attributes ) ; attributes = normalizeTermsForApi ( attributes ) ; if ( attributes . author ) { attributes . author = attributes . author . ID ; } return attributes ; } 
function isImageLargeEnoughForFeature ( image ) { if ( ! image ) { return false ; } const imageIsTallEnough = 100 <= image . width ; const imageIsWideEnough = 75 <= image . height ; return imageIsTallEnough && imageIsWideEnough ; } 
function wpview ( editor ) { let $ = editor . $ , selected , Env = tinymce . Env , VK = tinymce . util . VK , TreeWalker = tinymce . dom . TreeWalker , toRemove = false , firstFocus = true , isios = / iPad|iPod|iPhone / . test ( navigator . userAgent ) , cursorInterval , lastKeyDownNode , setViewCursorTries , focus , execCommandView , execCommandBefore , toolbar ; function replaceMarkers ( ) { const markers = $ ( '.wpview-marker' ) ; if ( ! markers . length ) { return false ; } markers . each ( function ( index , node ) { let text = editor . dom . getAttrib ( node , 'data-wpview-text' ) , type = editor . dom . getAttrib ( node , 'data-wpview-type' ) ; editor . dom . replace ( editor . dom . createFragment ( '<div class="wpview-wrap" data-wpview-text="' + text + '" data-wpview-type="' + type + '">' + '<p class="wpview-selection-before">\u00a0</p>' + '<div class="wpview-body" contenteditable="false"></div>' + '<p class="wpview-selection-after">\u00a0</p>' + '</div>' ) , node ) ; } ) ; return true ; } function triggerNodeChanged ( ) { editor . nodeChanged ( ) ; } function renderViews ( ) { if ( ! replaceMarkers ( ) ) { return ; } const store = editor . getParam ( 'redux_store' ) ; const siteId = getSelectedSiteId ( store . getState ( ) ) ; $ ( '.wpview-wrap' ) . each ( function ( index , view ) { const $view = $ ( view ) ; if ( undefined !== $view . attr ( 'data-wpview-rendered' ) ) { return ; } const type = $view . attr ( 'data-wpview-type' ) ; renderWithReduxStore ( React . createElement ( views . components [ type ] , { content : getText ( view ) , siteId , onResize : debounce ( triggerNodeChanged , 500 ) , } ) , $view . find ( '.wpview-body' ) [ 0 ] , store ) ; $view . attr ( 'data-wpview-rendered' , '' ) ; } ) ; } function getText ( node ) { return decodeURIComponent ( $ ( node ) . attr ( 'data-wpview-text' ) || '' ) ; } function getView ( node ) { return getParent ( node , 'wpview-wrap' ) ; } function getParent ( node , className ) { while ( node && node . parentNode ) { if ( node . className && ( ' ' + node . className + ' ' ) . indexOf ( ' ' + className + ' ' ) !== - 1 ) { return node ; } node = node . parentNode ; } return false ; } function _stop ( event ) { event . stopPropagation ( ) ; } function setViewCursor ( before , view ) { let location = before ? 'before' : 'after' , offset = before ? 0 : 1 ; deselect ( ) ; editor . selection . setCursorLocation ( editor . dom . select ( '.wpview-selection-' + location , view ) [ 0 ] , offset ) ; editor . nodeChanged ( ) ; } function handleEnter ( view , before , key ) { let dom = editor . dom , padNode = dom . create ( 'p' ) ; if ( ! ( Env . ie && Env . ie < 11 ) ) { padNode . innerHTML = '<br data-mce-bogus="1">' ; } if ( before ) { view . parentNode . insertBefore ( padNode , view ) ; } else { dom . insertAfter ( padNode , view ) ; } deselect ( ) ; if ( before && key === VK . ENTER ) { setViewCursor ( before , view ) ; } else { editor . selection . setCursorLocation ( padNode , 0 ) ; } editor . nodeChanged ( ) ; } function removeView ( view ) { editor . undoManager . transact ( function ( ) { handleEnter ( view ) ; ReactDom . unmountComponentAtNode ( $ ( view ) . find ( '.wpview-body' ) [ 0 ] ) ; editor . dom . remove ( view ) ; editor . focus ( ) ; } ) ; } function select ( viewNode ) { let clipboard , dom = editor . dom ; if ( ! viewNode ) { return ; } if ( viewNode !== selected ) { * Deselect a selected view and remove clipboard */ function deselect ( ) { let clipboard , dom = editor . dom ; if ( selected ) { clipboard = editor . dom . select ( '.wpview-clipboard' , selected ) [ 0 ] ; dom . unbind ( clipboard ) ; dom . remove ( clipboard ) ; dom . unbind ( selected , 'beforedeactivate focusin focusout click mouseup' , _stop ) ; dom . setAttrib ( selected , 'data-mce-selected' , null ) ; } selected = null ; } function resetViewsCallback ( match , viewText ) { return '<p>' + window . decodeURIComponent ( viewText ) + '</p>' ; } 
function replaceMarkers ( ) { const markers = $ ( '.wpview-marker' ) ; if ( ! markers . length ) { return false ; } markers . each ( function ( index , node ) { let text = editor . dom . getAttrib ( node , 'data-wpview-text' ) , type = editor . dom . getAttrib ( node , 'data-wpview-type' ) ; editor . dom . replace ( editor . dom . createFragment ( '<div class="wpview-wrap" data-wpview-text="' + text + '" data-wpview-type="' + type + '">' + '<p class="wpview-selection-before">\u00a0</p>' + '<div class="wpview-body" contenteditable="false"></div>' + '<p class="wpview-selection-after">\u00a0</p>' + '</div>' ) , node ) ; } ) ; return true ; } 
function getParent ( node , className ) { while ( node && node . parentNode ) { if ( node . className && ( ' ' + node . className + ' ' ) . indexOf ( ' ' + className + ' ' ) !== - 1 ) { return node ; } node = node . parentNode ; } return false ; } 
function deselect ( ) { let clipboard , dom = editor . dom ; if ( selected ) { clipboard = editor . dom . select ( '.wpview-clipboard' , selected ) [ 0 ] ; dom . unbind ( clipboard ) ; dom . remove ( clipboard ) ; dom . unbind ( selected , 'beforedeactivate focusin focusout click mouseup' , _stop ) ; dom . setAttrib ( selected , 'data-mce-selected' , null ) ; } selected = null ; } 
function isSpecialKey ( key ) { return ( ( key <= 47 && key !== VK . SPACEBAR && key !== VK . ENTER && key !== VK . DELETE && key !== VK . BACKSPACE && ( key < 37 || key > 40 ) ) || key >= 224 || 
function deepRemoveUndefinedKeysFromObject ( obj ) { for ( let key in obj ) { if ( obj . hasOwnProperty ( key ) ) { if ( _ . isUndefined ( obj [ key ] ) ) { delete obj [ key ] ; } else if ( _ . isObject ( obj [ key ] ) ) { deepRemoveUndefinedKeysFromObject ( obj [ key ] ) ; } } } return obj ; } 
function processLibPhoneNumberMetadata ( libPhoneNumberData ) { const data = { } ; for ( let countryCode in libPhoneNumberData ) { if ( libPhoneNumberData . hasOwnProperty ( countryCode ) ) { const countryCodeUpper = countryCode . toUpperCase ( ) ; const country = libPhoneNumberData [ countryCode ] ; data [ countryCodeUpper ] = { isoCode : countryCodeUpper , dialCode : String ( country [ libPhoneNumberIndexes . COUNTRY_DIAL_CODE ] + ( country [ libPhoneNumberIndexes . REGION_AREA_CODE ] || '' ) ) , countryDialCode : String ( country [ libPhoneNumberIndexes . COUNTRY_DIAL_CODE ] ) , regionCode : country [ libPhoneNumberIndexes . REGION_AREA_CODE ] || '' , areaCodes : areaCodes [ countryCode ] , nationalPrefix : country [ libPhoneNumberIndexes . NATIONAL_PREFIX ] , patterns : ( country [ libPhoneNumberIndexes . NUMBER_FORMAT ] || [ ] ) . map ( processNumberFormat ) , internationalPatterns : ( country [ libPhoneNumberIndexes . INTERNATIONAL_NUMBER_FORMAT ] || [ ] ) . map ( processNumberFormat ) , priority : priorityData [ countryCodeUpper ] , } ; } } const noPattern = _ . filter ( data , _ . conforms ( { patterns : patterns => patterns . length === 0 } ) ) ; _ . forIn ( noPattern , function ( country ) { country . patternRegion = ( _ . maxBy ( _ . values ( _ . filter ( data , { dialCode : country . dialCode } ) ) , 'priority' ) || { } ) . isoCode ; console . log ( 'Info: ' + country . isoCode + " didn't have a pattern" + ( country . patternRegion ? ' so we use ' + country . patternRegion : '.' ) ) ; } ) ; return data ; } 
function injectHardCodedValues ( libPhoneNumberData ) { return Object . assign ( { } , { KV : { isoCode : 'KV' , dialCode : '383' , nationalPrefix : '0' , priority : priorityData . KV , } , UM : { isoCode : 'UM' , dialCode : '1' , nationalPrefix : '' , patternRegion : 'US' , priority : priorityData . UM , } , BV : { isoCode : 'BV' , dialCode : '47' , nationalPrefix : '' , priority : priorityData . BV , } , TF : { isoCode : 'TF' , dialCode : '262' , nationalPrefix : '0' , priority : priorityData . TF , } , HM : { isoCode : 'HM' , dialCode : '61' , nationalPrefix : '0' , priority : priorityData . HM , } , PN : { isoCode : 'PN' , dialCode : '64' , nationalPrefix : '0' , priority : priorityData . PN , } , GS : { isoCode : 'GS' , nationalPrefix : '' , dialCode : '500' , priority : priorityData . GS , } , } , libPhoneNumberData ) ; } 
function insertCountryAliases ( data ) { Object . keys ( aliases ) . forEach ( source => { data [ source ] = data [ aliases [ source ] ] ; } ) ; return data ; } 
function saveToFile ( data ) { const scriptStr = '/** @format */\n' + '// Generated by build-metadata.js\n' + '/* eslint-disable */\n' + Object . keys ( data ) . map ( key => ` ${ key } ${ JSON . stringify ( data [ key ] , null , '\t' ) } \n ` ) . join ( '\n' ) + '/* eslint-enable */\n' ; const filePath = path . resolve ( __dirname , '..' , 'client' , 'components' , 'phone-input' , 'data.js' ) ; fs . writeFileSync ( filePath , scriptStr ) ; } 
function getWebpackConfig ( env = { } , 
function WPCOMUndocumented ( token , reqHandler ) { if ( ! ( this instanceof WPCOMUndocumented ) ) { return new WPCOMUndocumented ( token , reqHandler ) ; } if ( 'function' === typeof token ) { reqHandler = token ; token = null ; } else if ( token ) { this . loadToken ( token ) ; } wpcomFactory . call ( this , token , function ( params , fn ) { if ( this . isTokenLoaded ( ) ) { 
function downloadAndPrint ( orderId , siteId , dispatch , getState , labels ) { 
function AccountPasswordData ( ) { this . validatedPassword = null ; this . charsets = { lowerChars : 'abcdefghjkmnpqrstuvwxyz' . split ( '' ) , upperChars : 'ABCDEFGHJKMNPQRSTUVWXYZ' . split ( '' ) , digitChars : '23456789' . split ( '' ) , specialChars : '!@#$%^&*' . split ( '' ) , } ; this . letterCharsets = pick ( this . charsets , [ 'lowerChars' , 'upperChars' ] ) ; } 
function transferStatus ( siteId , transferId , status , message , themeId ) { return { type : THEME_TRANSFER_STATUS_RECEIVE , siteId , transferId , status , message , themeId , } ; } 
function transferInitiateFailure ( siteId , error , plugin ) { const context = ! ! plugin ? 'plugin' : 'theme' ; return dispatch => { const themeInitiateFailureAction = { type : THEME_TRANSFER_INITIATE_FAILURE , siteId , error , } ; dispatch ( withAnalytics ( recordTracksEvent ( 'calypso_automated_transfer_initiate_failure' , { plugin , context } ) , themeInitiateFailureAction ) ) ; } ; } 
function suffixThemeIdForInstall ( state , siteId , themeId ) { 
function queryDocs ( query ) { return docsIndex . search ( query ) . map ( result => { const doc = documents [ result . ref ] , snippet = makeSnippet ( doc , query ) ; return { path : doc . path , title : doc . title , snippet : snippet , } ; } ) ; } 
function listDocs ( filePaths ) { return filePaths . map ( path => { const doc = find ( documents , entry => entry . path === path ) ; if ( doc ) { return { path : path , title : doc . title , snippet : defaultSnippet ( doc ) , } ; } return { path : path , title : 'Not found: ' + path , snippet : '' , } ; } ) ; } 
function makeSnippet ( doc , query ) { 
function escapeRegexString ( token ) { 
function reduceComponentsUsageStats ( modulesWithDependences ) { return Object . keys ( modulesWithDependences ) . filter ( moduleName => moduleName . indexOf ( 'components/' ) === 0 && moduleName . indexOf ( '/docs' ) === - 1 ) . reduce ( ( target , moduleName ) => { const name = moduleName . replace ( 'components/' , '' ) ; target [ name ] = modulesWithDependences [ moduleName ] ; return target ; } , { } ) ; } 
function ( fetchOptions ) { const namespace = getNamespace ( fetchOptions ) ; debug ( 'getPaginationData:' , namespace ) ; return { fetchInitialized : _usersFetchedByNamespace . hasOwnProperty ( namespace ) , totalUsers : _totalUsersByNamespace [ namespace ] || 0 , fetchingUsers : _fetchingUsersByNamespace [ namespace ] || false , usersCurrentOffset : _offsetByNamespace [ namespace ] , numUsersFetched : _usersFetchedByNamespace [ namespace ] , fetchNameSpace : namespace , } ; } 
function ( fetchOptions ) { let namespace = getNamespace ( fetchOptions ) , siteId = fetchOptions . siteId , users = [ ] ; debug ( 'getUsers:' , namespace ) ; if ( ! _usersBySite [ siteId ] ) { _usersBySite [ siteId ] = { } ; } if ( ! _userIDsByNamespace [ namespace ] ) { return users ; } _userIDsByNamespace [ namespace ] . forEach ( userId => { if ( _usersBySite [ siteId ] [ userId ] ) { users . push ( _usersBySite [ siteId ] [ userId ] ) ; } } ) ; return users ; } 
function getTld ( domainName ) { const lastIndexOfDot = domainName . lastIndexOf ( '.' ) ; if ( lastIndexOfDot === - 1 ) { return '' ; } let tld = parseDomainAgainstTldList ( domainName , wpcomMultiLevelTlds ) ; if ( ! tld ) { tld = domainName . substring ( lastIndexOfDot + 1 ) ; } return tld ; } 
function getDomainSuggestionSearch ( search , minLength = 2 ) { const cleanedSearch = getFixedDomainSearch ( search ) ; 
function ( site ) { if ( ! site ) { return [ ] ; } if ( ! _pluginsBySite [ site . ID ] && ! _fetching [ site . ID ] ) { PluginsActions . fetchSitePlugins ( site ) ; _fetching [ site . ID ] = true ; } if ( ! _pluginsBySite [ site . ID ] ) { return _pluginsBySite [ site . ID ] ; } return values ( _pluginsBySite [ site . ID ] ) ; } 
function ( sites , pluginSlug ) { let plugin , plugins = this . getPlugins ( sites ) , pluginSites ; if ( ! plugins ) { return ; } plugin = find ( plugins , _filters . isEqual . bind ( this , pluginSlug ) ) ; if ( ! plugin ) { return null ; } pluginSites = plugin . sites . filter ( site => site . visible ) . map ( site => { 
function ( sites , pluginSlug ) { const installedOnSites = this . getSites ( sites , pluginSlug ) || [ ] ; return sites . filter ( function ( site ) { if ( ! site . visible ) { return false ; } if ( site . jetpack && site . isSecondaryNetworkSite ) { return false ; } return installedOnSites . every ( function ( installedOnSite ) { return installedOnSite . slug !== site . slug ; } ) ; } ) ; } 
function productVariationUpdated ( state , action ) { const { data : productVariation , productId } = action ; const productVariations = state . productVariations || [ ] ; const index = findIndex ( productVariations , { id : productVariation . id } ) ; const newProductVariation = { ... productVariation , productId } ; const newProductVariations = [ ... productVariations ] ; if ( - 1 < index ) { newProductVariations [ index ] = newProductVariation ; } else { newProductVariations . push ( newProductVariation ) ; } const promotions = calculatePromotions ( state . coupons , state . products , newProductVariations ) ; return { ... state , productVariations : newProductVariations , promotions } ; } 
function urlSafeBase64DecodeString ( str ) { const decodeMap = { '-' : '+' , _ : '/' , '.' : '=' , } ; return atob ( str . replace ( / [-_.] / g , ch => decodeMap [ ch ] ) ) ; } 
function parseAmpEncodedParams ( value ) { value = value . split ( '*' ) . filter ( val => val . length ) . slice ( 2 ) ; 
function cartesian ( ... arrays ) { let i , j , l , m ; const o = [ ] ; if ( ! arrays || arrays . length === 0 ) { return arrays ; } const array1 = arrays . splice ( 0 , 1 ) [ 0 ] ; arrays = cartesian ( ... arrays ) ; for ( i = 0 , l = array1 . length ; i < l ; i ++ ) { if ( arrays && arrays . length ) { for ( j = 0 , m = arrays . length ; j < m ; j ++ ) { o . push ( [ array1 [ i ] ] . concat ( arrays [ j ] ) ) ; } } else { o . push ( [ array1 [ i ] ] ) ; } } return o ; } 
function disableToolbarTouchEvents ( ) { editor . $ ( '.mce-toolbar:not(.mce-menubar)' , document . body ) . each ( ( i , toolbar ) => { toolbar . addEventListener ( 'touchstart' , event => { event . stopImmediatePropagation ( ) ; } ) ; } ) ; } 
function hideToolbarFadeOnFullScroll ( ) { editor . $ ( [ editor . $ ( '.mce-inline-toolbar-grp .mce-container-body' , document . body ) , editor . $ ( '.mce-toolbar-grp' , editor . theme . panel . getEl ( ) ) , ] ) . each ( ( i , toolbar ) => { toolbar . on ( 'scroll' , throttle ( ( { target } ) => { let action ; if ( target . scrollLeft === target . scrollWidth - target . clientWidth ) { action = 'add' ; } else if ( tinymce . DOM . hasClass ( target , 'is-scrolled-full' ) ) { action = 'remove' ; } if ( action ) { const elements = editor . $ ( target ) ; if ( ! elements . hasClass ( 'mce-container-body' ) ) { elements . add ( tinymce . DOM . getParent ( target , '.mce-container-body' ) ) ; } elements [ action + 'Class' ] ( 'is-scrolled-full' ) ; } } , 200 ) ) ; } ) ; } 
function toggleToolbarsScrollableOnResize ( ) { function toggleToolbarsScrollableClass ( ) { editor . $ ( '.mce-toolbar-grp' , editor . theme . panel . getEl ( ) ) . each ( ( i , toolbar ) => { const isScrollable = toolbar . scrollWidth > toolbar . clientWidth ; editor . $ ( toolbar ) . toggleClass ( 'is-scrollable' , isScrollable ) ; } ) ; } window . addEventListener ( 'resize' , throttle ( toggleToolbarsScrollableClass , 200 ) ) ; toggleToolbarsScrollableClass ( ) ; 
function warn ( ) { if ( ! I18N . throwErrors ) { return ; } if ( 'undefined' !== typeof window && window . console && window . console . warn ) { window . console . warn . apply ( window . console , arguments ) ; } } 
function getJedArgs ( jedMethod , props ) { switch ( jedMethod ) { case 'gettext' : return [ props . original ] ; case 'ngettext' : return [ props . original , props . plural , props . count ] ; case 'npgettext' : return [ props . context , props . original , props . plural , props . count ] ; case 'pgettext' : return [ props . context , props . original ] ; } return [ ] ; } 
function getTranslationFromJed ( jed , options ) { let jedMethod = 'gettext' ; if ( options . context ) { jedMethod = 'p' + jedMethod ; } if ( typeof options . original === 'string' && typeof options . plural === 'string' ) { jedMethod = 'n' + jedMethod ; } const jedArgs = getJedArgs ( jedMethod , options ) ; return jed [ jedMethod ] . apply ( jed , jedArgs ) ; } 
function connectAccountCreate ( state = { } ) { return Object . assign ( { } , state , { error : '' , isCreating : true , notifyCompleted : false , } ) ; } 
function connectAccountCreateComplete ( state = { } , action ) { return Object . assign ( { } , state , { connectedUserID : action . connectedUserID || '' , displayName : '' , email : action . email || '' , error : action . error || '' , firstName : '' , isActivated : false , isCreating : false , isRequesting : false , lastName : '' , logo : '' , notifyCompleted : true , } ) ; } 
function connectAccountFetch ( state = { } ) { return Object . assign ( { } , state , { connectedUserID : '' , displayName : '' , email : '' , error : '' , firstName : '' , isActivated : false , isDeauthorizing : false , isRequesting : true , lastName : '' , logo : '' , } ) ; } 
function connectAccountFetchComplete ( state = { } , action ) { return Object . assign ( { } , state , { connectedUserID : action . connectedUserID || '' , displayName : action . displayName || '' , email : action . email || '' , error : action . error || '' , firstName : action . firstName || '' , isActivated : action . isActivated || false , isDeauthorizing : false , isRequesting : false , lastName : action . lastName || '' , logo : action . logo || '' , } ) ; } 
function connectAccountDeauthorizeComplete ( state = { } , action ) { return Object . assign ( { } , state , { connectedUserID : '' , displayName : '' , email : '' , error : action . error || '' , firstName : '' , isActivated : false , isDeauthorizing : false , isRequesting : false , lastName : '' , logo : '' , } ) ; } 
function connectAccountOAuthInitComplete ( state = { } , action ) { return Object . assign ( { } , state , { isOAuthInitializing : false , error : action . error || '' , oauthUrl : action . oauthUrl || '' , } ) ; } 
function connectAccountOAuthConnect ( state = { } ) { return Object . assign ( { } , state , { error : '' , isOAuthConnecting : true , notifyCompleted : false , } ) ; } 
function applyPrecision ( cost , precision ) { const exponent = Math . pow ( 10 , precision ) ; return Math . ceil ( cost * exponent ) / exponent ; } 
function canDomainAddGSuite ( domainName ) { const GOOGLE_APPS_INVALID_SUFFIXES = [ '.in' , '.wpcomstaging.com' ] ; const GOOGLE_APPS_BANNED_PHRASES = [ 'google' ] ; const includesBannedPhrase = some ( GOOGLE_APPS_BANNED_PHRASES , bannedPhrase => includes ( domainName , bannedPhrase ) ) ; const hasInvalidSuffix = some ( GOOGLE_APPS_INVALID_SUFFIXES , invalidSuffix => endsWith ( domainName , invalidSuffix ) ) ; return ! ( hasInvalidSuffix || includesBannedPhrase || isGSuiteRestricted ( ) ) ; } 
function formatPrice ( cost , currencyCode , options = { } ) { if ( undefined !== options . precision ) { cost = applyPrecision ( cost , options . precision ) ; } return formatCurrency ( cost , currencyCode , cost % 1 > 0 ? { } : { precision : 0 } ) ; } 
function getEligibleGSuiteDomain ( selectedDomainName , domains ) { if ( selectedDomainName && canDomainAddGSuite ( selectedDomainName ) ) { return selectedDomainName ; } const [ eligibleDomain ] = getGSuiteSupportedDomains ( domains ) ; return ( eligibleDomain && eligibleDomain . name ) || '' ; } 
function getGSuiteSupportedDomains ( domains ) { return domains . filter ( function ( domain ) { const wpcomHosted = includes ( [ domainTypes . REGISTERED ] , domain . type ) && ( domain . hasWpcomNameservers || hasGSuite ( domain ) ) ; const mapped = includes ( [ domainTypes . MAPPED ] , domain . type ) ; const notOtherProvidor = domain . googleAppsSubscription && domain . googleAppsSubscription . status !== 'other_provider' ; return ( wpcomHosted || mapped ) && canDomainAddGSuite ( domain . name ) && notOtherProvidor ; } ) ; } 
function setupReducerPersistence ( reducer ) { if ( reducer . hasCustomPersistence ) { return reducer ; } if ( reducer . schema ) { return withSchemaValidation ( reducer . schema , reducer ) ; } return withoutPersistence ( reducer ) ; } 
function serializeState ( reducers , state , action ) { if ( state === undefined ) { return undefined ; } return reduce ( reducers , ( result , reducer , reducerKey ) => { const serialized = reducer ( state [ reducerKey ] , action ) ; if ( serialized !== undefined ) { if ( ! result ) { 
function stopMutationObserver ( ) { if ( mutationObserver && mutationObserverActive ) { activePlaceholders = [ ] ; activePlaceholderEverDetected = false ; mutationObserver . disconnect ( ) ; mutationObserverActive = false ; } } 
function checkActivePlaceholders ( ) { const placeholdersCount = activePlaceholders . length ; debug ( ` ${ placeholdersCount } ` ) ; if ( placeholdersCount > 0 ) { activePlaceholderEverDetected = true ; } 
function shouldRequestRecs ( state , streamKey , recsStreamKey ) { if ( ! recsStreamKey ) { return false ; } const totalSubs = getReaderFollows ( state ) . length ; const items = getReaderStream ( state , streamKey ) . items ; const recsStream = getReaderStream ( state , recsStreamKey ) ; const recs = recsStream . items ; if ( recsStream . lastPage || recsStream . isRequesting ) { return false ; } if ( recs . length === 0 ) { return true ; } return recs . length < items . length * ( RECS_PER_BLOCK / getDistanceBetweenRecs ( totalSubs ) ) ; } 
function getDefaultOptions ( ) { const ids = config ( 'directly_rtm_widget_ids' ) ; const env = config ( 'directly_rtm_widget_environment' ) ; return { id : ids [ env ] , displayAskQuestion : false , } ; } 
function configureGlobals ( ) { 
function insertDOM ( ) { if ( null !== document . getElementById ( 'directlyRTMScript' ) ) { return ; } const d = document . createElement ( 'div' ) ; d . id = 'directlyRTMScript' ; d . src = DIRECTLY_ASSETS_BASE_URL ; document . body . appendChild ( d ) ; } 
function loadDirectlyScript ( ) { return new Promise ( ( resolve , reject ) => { loadScript ( DIRECTLY_RTM_SCRIPT_URL , function ( error ) { if ( error ) { return reject ( new Error ( ` ${ error . src } ` ) ) ; } resolve ( ) ; } ) ; } ) ; } 
function wpemoji ( editor ) { let typing = false ; const env = tinymce . Env , ua = window . navigator . userAgent , isWin = ua . indexOf ( 'Windows' ) > - 1 , isWin8 = ( function ( ) { const match = ua . match ( / Windows NT 6\.(\d) / ) ; if ( match && match [ 1 ] > 1 ) { return true ; } return false ; } ) ( ) ; function setImgAttr ( image ) { image . className = 'emoji' ; image . setAttribute ( 'data-mce-resize' , 'false' ) ; image . setAttribute ( 'data-mce-placeholder' , '1' ) ; image . setAttribute ( 'data-wp-emoji' , '1' ) ; } function replaceEmoji ( node ) { twemoji . parse ( node , { base : config ( 'twemoji_cdn_url' ) , size : '72x72' , attributes : ( ) => { return { 'data-mce-resize' : 'false' , 'data-mce-placeholder' : '1' , 'data-wp-emoji' : '1' , } ; } , callback : ( icon , options ) => { const ignored = [ 'a9' , 'ae' , '2122' , '2194' , '2660' , '2663' , '2665' , '2666' ] ; if ( - 1 !== ignored . indexOf ( icon ) ) { return false ; } return '' . concat ( options . base , options . size , '/' , icon , options . ext ) ; } , } ) ; } 
function parseNode ( node ) { let selection , bookmark ; if ( node && twemoji . test ( node . textContent || node . innerText ) ) { if ( env . webkit ) { selection = editor . selection ; bookmark = selection . getBookmark ( ) ; } replaceEmoji ( node ) ; if ( env . webkit ) { selection . moveToBookmark ( bookmark ) ; } } } 
function getInitialServerState ( initialReducer ) { if ( typeof window !== 'object' || ! window . initialReduxState || isSupportSession ( ) ) { return null ; } const serverState = deserialize ( window . initialReduxState , initialReducer ) ; return pick ( serverState , Object . keys ( window . initialReduxState ) ) ; } 
function shouldAddSympathy ( ) { 
function verifyStoredRootState ( state ) { const currentUserId = get ( user . get ( ) , 'ID' , null ) ; const storedUserId = get ( state , [ 'currentUser' , 'id' ] , null ) ; if ( currentUserId !== storedUserId ) { debug ( ` ${ currentUserId } ${ storedUserId } ` ) ; return false ; } return true ; } 
function toFixedFix ( n , prec ) { const k = Math . pow ( 10 , prec ) ; return '' + ( Math . round ( n * k ) / k ) . toFixed ( prec ) ; } 
function getWebpackConfig ( env = { } , { entry = { common : path . join ( __dirname , 'src' , 'common' ) , 'calypso-iframe-bridge-server' : path . join ( __dirname , 'src' , 'calypso' , 'iframe-bridge-server.js' ) , 'calypso-tinymce' : path . join ( __dirname , 'src' , 'calypso' , 'tinymce.js' ) , } , 'output-path' : outputPath = path . join ( __dirname , 'dist' ) , 'output-filename' : outputFilename = isDevelopment ? '[name].js' : '[name].min.js' , } ) { const webpackConfig = getBaseWebpackConfig ( env , { entry , 'output-filename' : outputFilename , 'output-path' : outputPath , } ) ; return { ... webpackConfig , devtool : isDevelopment ? 'inline-cheap-source-map' : false , } ; } 
function createRequestAction ( options , action ) { const { fetch = noop , onSuccess = noop , onError = noop , onProgress = noop , fromApi = identity , } = options ; const error = getError ( action ) ; if ( error ) { return onError ( action , error ) ; } const data = getData ( action ) ; if ( data ) { try { return onSuccess ( action , fromApi ( data ) ) ; } catch ( err ) { return onError ( action , err ) ; } } const progress = getProgress ( action ) ; if ( progress ) { return onProgress ( action , progress ) ; } return fetch ( action ) ; } 
function updateProductEdits ( edits , productId , doUpdate ) { const prevEdits = edits || [ ] ; let found = false ; const newEdits = prevEdits . map ( productEdits => { if ( isEqual ( productId , productEdits . productId ) ) { found = true ; return doUpdate ( productEdits ) ; } return productEdits ; } ) ; if ( ! found ) { newEdits . push ( doUpdate ( undefined ) ) ; } return newEdits ; } 
function doesNotNeedSandbox ( iframe ) { const trustedHosts = [ 'spotify.com' , 'kickstarter.com' , 'soundcloud.com' , 'embed.ted.com' , 'player.twitch.tv' , ] ; const hostName = iframe . src && url . parse ( iframe . src ) . hostname ; const iframeHost = hostName && hostName . toLowerCase ( ) ; return some ( trustedHosts , trustedHost => endsWith ( '.' + iframeHost , '.' + trustedHost ) ) ; } 
function getEligibleEmailForwardingDomain ( selectedDomainName , domains = [ ] ) { const eligibleDomains = getEmailForwardingSupportedDomains ( domains ) ; let selectedDomain ; if ( selectedDomainName ) { selectedDomain = eligibleDomains . reduce ( function ( selected , domain ) { return domain . name === selectedDomainName ? domain . name : selected ; } , '' ) ; } return selectedDomain || ( eligibleDomains . length && eligibleDomains [ 0 ] . name ) || '' ; } 
function getEmailForwardingSupportedDomains ( domains ) { return domains . filter ( function ( domain ) { const domainHasGSuite = hasGSuite ( domain ) ; const wpcomHosted = includes ( [ domainTypes . REGISTERED ] , domain . type ) && domain . hasWpcomNameservers ; const mapped = includes ( [ domainTypes . MAPPED ] , domain . type ) ; return ( wpcomHosted || mapped ) && ! domainHasGSuite ; } ) ; } 
function setup ( ) { const app = express ( ) ; 
function getExternals ( ) { const externals = { } ; 
function submitFreeTransaction ( partialCart , onComplete ) { const cart = fillInAllCartItemAttributes ( partialCart , productsList . get ( ) ) , transaction = { payment : fullCreditsPayment , } ; submitTransaction ( { cart , transaction } , onComplete ) ; } 
function replaceSearchUrl ( newValue , sort ) { let searchUrl = '/read/search' ; if ( newValue ) { searchUrl += '?' + stringify ( { q : newValue , sort } ) ; } page . replace ( searchUrl ) ; } 
function ( pluginSlug ) { const query = { fields : 'icons,banners,compatibility,ratings,-contributors' , locale : getWporgLocaleCode ( ) , } ; pluginSlug = pluginSlug . replace ( new RegExp ( '.php$' ) , '' ) ; const baseUrl = 'https://api.wordpress.org/plugins/info/1.0/' + pluginSlug + '.jsonp' ; return new Promise ( ( resolve , reject ) => { jsonp ( baseUrl , query , function ( error , data ) { if ( error ) { debug ( 'error downloading plugin details from .org: %s' , error ) ; reject ( error ) ; return ; } if ( ! data || ! data . slug ) { debug ( 'unrecognized format fetching plugin details from .org: %s' , data ) ; reject ( new Error ( 'Unrecognized response format' ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; } 
function ( themeId ) { const query = { action : 'theme_information' , 
function ( options = { } ) { const { search , page , number } = options ; const query = { action : 'query_themes' , 
function isPlainObject ( value ) { if ( ! isObject ( value ) ) { return false ; } try { var _constructor = value . constructor ; var prototype = _constructor . prototype ; return _constructor && prototype && hasOwnProperty . call ( prototype , 'isPrototypeOf' ) ; } catch ( error ) { return false ; } } 
function toArray ( value ) { return Array . from ? Array . from ( value ) : slice . call ( value ) ; } 
function forEach ( data , callback ) { if ( data && isFunction ( callback ) ) { if ( Array . isArray ( data ) || isNumber ( data . length ) ) { toArray ( data ) . forEach ( function ( value , key ) { callback . call ( data , value , key , data ) ; } ) ; } else if ( isObject ( data ) ) { Object . keys ( data ) . forEach ( function ( key ) { callback . call ( data , data [ key ] , key , data ) ; } ) ; } } return data ; } 
function normalizeDecimalNumber ( value ) { var times = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 100000000000 ; return REGEXP_DECIMALS . test ( value ) ? Math . round ( value * times ) / times : value ; } 
function hasClass ( element , value ) { return element . classList ? element . classList . contains ( value ) : element . className . indexOf ( value ) > - 1 ; } 
function addClass ( element , value ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { addClass ( elem , value ) ; } ) ; return ; } if ( element . classList ) { element . classList . add ( value ) ; return ; } var className = element . className . trim ( ) ; if ( ! className ) { element . className = value ; } else if ( className . indexOf ( value ) < 0 ) { element . className = "" . concat ( className , " " ) . concat ( value ) ; } } 
function removeClass ( element , value ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { removeClass ( elem , value ) ; } ) ; return ; } if ( element . classList ) { element . classList . remove ( value ) ; return ; } if ( element . className . indexOf ( value ) >= 0 ) { element . className = element . className . replace ( value , '' ) ; } } 
function toggleClass ( element , value , added ) { if ( ! value ) { return ; } if ( isNumber ( element . length ) ) { forEach ( element , function ( elem ) { toggleClass ( elem , value , added ) ; } ) ; return ; } 
function getData ( element , name ) { if ( isObject ( element [ name ] ) ) { return element [ name ] ; } if ( element . dataset ) { return element . dataset [ name ] ; } return element . getAttribute ( "data-" . concat ( toParamCase ( name ) ) ) ; } 
function setData ( element , name , data ) { if ( isObject ( data ) ) { element [ name ] = data ; } else if ( element . dataset ) { element . dataset [ name ] = data ; } else { element . setAttribute ( "data-" . concat ( toParamCase ( name ) ) , data ) ; } } 
function removeData ( element , name ) { if ( isObject ( element [ name ] ) ) { try { delete element [ name ] ; } catch ( error ) { element [ name ] = undefined ; } } else if ( element . dataset ) { 
function removeListener ( element , type , listener ) { var options = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; var handler = listener ; type . trim ( ) . split ( REGEXP_SPACES ) . forEach ( function ( event ) { if ( ! onceSupported ) { var listeners = element . listeners ; if ( listeners && listeners [ event ] && listeners [ event ] [ listener ] ) { handler = listeners [ event ] [ listener ] ; delete listeners [ event ] [ listener ] ; if ( Object . keys ( listeners [ event ] ) . length === 0 ) { delete listeners [ event ] ; } if ( Object . keys ( listeners ) . length === 0 ) { delete element . listeners ; } } } element . removeEventListener ( event , handler , options ) ; } ) ; } 
function addListener ( element , type , listener ) { var options = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; var _handler = listener ; type . trim ( ) . split ( REGEXP_SPACES ) . forEach ( function ( event ) { if ( options . once && ! onceSupported ) { var _element$listeners = element . listeners , listeners = _element$listeners === void 0 ? { } : _element$listeners ; _handler = function handler ( ) { delete listeners [ event ] [ listener ] ; element . removeEventListener ( event , _handler , options ) ; for ( var _len2 = arguments . length , args = new Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } listener . apply ( element , args ) ; } ; if ( ! listeners [ event ] ) { listeners [ event ] = { } ; } if ( listeners [ event ] [ listener ] ) { element . removeEventListener ( event , listeners [ event ] [ listener ] , options ) ; } listeners [ event ] [ listener ] = _handler ; element . listeners = listeners ; } element . addEventListener ( event , _handler , options ) ; } ) ; } 
function dispatchEvent ( element , type , data ) { var event ; 
function getOffset ( element ) { var box = element . getBoundingClientRect ( ) ; return { left : box . left + ( window . pageXOffset - document . documentElement . clientLeft ) , top : box . top + ( window . pageYOffset - document . documentElement . clientTop ) } ; } 
function addTimestamp ( url ) { var timestamp = "timestamp=" . concat ( new Date ( ) . getTime ( ) ) ; return url + ( url . indexOf ( '?' ) === - 1 ? '?' : '&' ) + timestamp ; } 
function getTransforms ( _ref ) { var rotate = _ref . rotate , scaleX = _ref . scaleX , scaleY = _ref . scaleY , translateX = _ref . translateX , translateY = _ref . translateY ; var values = [ ] ; if ( isNumber ( translateX ) && translateX !== 0 ) { values . push ( "translateX(" . concat ( translateX , "px)" ) ) ; } if ( isNumber ( translateY ) && translateY !== 0 ) { values . push ( "translateY(" . concat ( translateY , "px)" ) ) ; } 
function getMaxZoomRatio ( pointers ) { var pointers2 = assign ( { } , pointers ) ; var ratios = [ ] ; forEach ( pointers , function ( pointer , pointerId ) { delete pointers2 [ pointerId ] ; forEach ( pointers2 , function ( pointer2 ) { var x1 = Math . abs ( pointer . startX - pointer2 . startX ) ; var y1 = Math . abs ( pointer . startY - pointer2 . startY ) ; var x2 = Math . abs ( pointer . endX - pointer2 . endX ) ; var y2 = Math . abs ( pointer . endY - pointer2 . endY ) ; var z1 = Math . sqrt ( x1 * x1 + y1 * y1 ) ; var z2 = Math . sqrt ( x2 * x2 + y2 * y2 ) ; var ratio = ( z2 - z1 ) / z1 ; ratios . push ( ratio ) ; } ) ; } ) ; ratios . sort ( function ( a , b ) { return Math . abs ( a ) < Math . abs ( b ) ; } ) ; return ratios [ 0 ] ; } 
function getPointer ( _ref2 , endOnly ) { var pageX = _ref2 . pageX , pageY = _ref2 . pageY ; var end = { endX : pageX , endY : pageY } ; return endOnly ? end : assign ( { startX : pageX , startY : pageY } , end ) ; } 
function getPointersCenter ( pointers ) { var pageX = 0 ; var pageY = 0 ; var count = 0 ; forEach ( pointers , function ( _ref3 ) { var startX = _ref3 . startX , startY = _ref3 . startY ; pageX += startX ; pageY += startY ; count += 1 ; } ) ; pageX /= count ; pageY /= count ; return { pageX : pageX , pageY : pageY } ; } 
function getAdjustedSizes ( _ref4 ) 
function getRotatedSizes ( _ref5 ) { var width = _ref5 . width , height = _ref5 . height , degree = _ref5 . degree ; degree = Math . abs ( degree ) % 180 ; if ( degree === 90 ) { return { width : height , height : width } ; } var arc = degree % 90 * Math . PI / 180 ; var sinArc = Math . sin ( arc ) ; var cosArc = Math . cos ( arc ) ; var newWidth = width * cosArc + height * sinArc ; var newHeight = width * sinArc + height * cosArc ; return degree > 90 ? { width : newHeight , height : newWidth } : { width : newWidth , height : newHeight } ; } 
function getSourceCanvas ( image , _ref6 , _ref7 , _ref8 ) { var imageAspectRatio = _ref6 . aspectRatio , imageNaturalWidth = _ref6 . naturalWidth , imageNaturalHeight = _ref6 . naturalHeight , _ref6$rotate = _ref6 . rotate , rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate , _ref6$scaleX = _ref6 . scaleX , scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX , _ref6$scaleY = _ref6 . scaleY , scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY ; var aspectRatio = _ref7 . aspectRatio , naturalWidth = _ref7 . naturalWidth , naturalHeight = _ref7 . naturalHeight ; var _ref8$fillColor = _ref8 . fillColor , fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor , _ref8$imageSmoothingE = _ref8 . imageSmoothingEnabled , imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE , _ref8$imageSmoothingQ = _ref8 . imageSmoothingQuality , imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ , _ref8$maxWidth = _ref8 . maxWidth , maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth , _ref8$maxHeight = _ref8 . maxHeight , maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight , _ref8$minWidth = _ref8 . minWidth , minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth , _ref8$minHeight = _ref8 . minHeight , minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight ; var canvas = document . createElement ( 'canvas' ) ; var context = canvas . getContext ( '2d' ) ; var maxSizes = getAdjustedSizes ( { aspectRatio : aspectRatio , width : maxWidth , height : maxHeight } ) ; var minSizes = getAdjustedSizes ( { aspectRatio : aspectRatio , width : minWidth , height : minHeight } , 'cover' ) ; var width = Math . min ( maxSizes . width , Math . max ( minSizes . width , naturalWidth ) ) ; var height = Math . min ( maxSizes . height , Math . max ( minSizes . height , naturalHeight ) ) ; 
function dataURLToArrayBuffer ( dataURL ) { var base64 = dataURL . replace ( REGEXP_DATA_URL_HEAD , '' ) ; var binary = atob ( base64 ) ; var arrayBuffer = new ArrayBuffer ( binary . length ) ; var uint8 = new Uint8Array ( arrayBuffer ) ; forEach ( uint8 , function ( value , i ) { uint8 [ i ] = binary . charCodeAt ( i ) ; } ) ; return arrayBuffer ; } 
function arrayBufferToDataURL ( arrayBuffer , mimeType ) { var chunks = [ ] ; 
function parseOrientation ( orientation ) { var rotate = 0 ; var scaleX = 1 ; var scaleY = 1 ; switch ( orientation ) { 
function initCanvas ( ) { var containerData = this . containerData , imageData = this . imageData ; var viewMode = this . options . viewMode ; var rotated = Math . abs ( imageData . rotate ) % 180 === 90 ; var naturalWidth = rotated ? imageData . naturalHeight : imageData . naturalWidth ; var naturalHeight = rotated ? imageData . naturalWidth : imageData . naturalHeight ; var aspectRatio = naturalWidth / naturalHeight ; var canvasWidth = containerData . width ; var canvasHeight = containerData . height ; if ( containerData . height * aspectRatio > containerData . width ) { if ( viewMode === 3 ) { canvasWidth = containerData . height * aspectRatio ; } else { canvasHeight = containerData . width / aspectRatio ; } } else if ( viewMode === 3 ) { canvasHeight = containerData . width / aspectRatio ; } else { canvasWidth = containerData . height * aspectRatio ; } var canvasData = { aspectRatio : aspectRatio , naturalWidth : naturalWidth , naturalHeight : naturalHeight , width : canvasWidth , height : canvasHeight } ; canvasData . left = ( containerData . width - canvasWidth ) / 2 ; canvasData . top = ( containerData . height - canvasHeight ) / 2 ; canvasData . oldLeft = canvasData . left ; canvasData . oldTop = canvasData . top ; this . canvasData = canvasData ; this . limited = viewMode === 1 || viewMode === 2 ; this . limitCanvas ( true , true ) ; this . initialImageData = assign ( { } , imageData ) ; this . initialCanvasData = assign ( { } , canvasData ) ; } 
function crop ( ) { if ( this . ready && ! this . cropped && ! this . disabled ) { this . cropped = true ; this . limitCropBox ( true , true ) ; if ( this . options . modal ) { addClass ( this . dragBox , CLASS_MODAL ) ; } removeClass ( this . cropBox , CLASS_HIDDEN ) ; this . setCropBoxData ( this . initialCropBoxData ) ; } return this ; } 
function reset ( ) { if ( this . ready && ! this . disabled ) { this . imageData = assign ( { } , this . initialImageData ) ; this . canvasData = assign ( { } , this . initialCanvasData ) ; this . cropBoxData = assign ( { } , this . initialCropBoxData ) ; this . renderCanvas ( ) ; if ( this . cropped ) { this . renderCropBox ( ) ; } } return this ; } 
function clear ( ) { if ( this . cropped && ! this . disabled ) { assign ( this . cropBoxData , { left : 0 , top : 0 , width : 0 , height : 0 } ) ; this . cropped = false ; this . renderCropBox ( ) ; this . limitCanvas ( true , true ) ; 
function replace ( url ) { var hasSameSize = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; if ( ! this . disabled && url ) { if ( this . isImg ) { this . element . src = url ; } if ( hasSameSize ) { this . url = url ; this . image . src = url ; if ( this . ready ) { this . viewBoxImage . src = url ; forEach ( this . previews , function ( element ) { element . getElementsByTagName ( 'img' ) [ 0 ] . src = url ; } ) ; } } else { if ( this . isImg ) { this . replaced = true ; } this . options . data = null ; this . uncreate ( ) ; this . load ( url ) ; } } return this ; } 
function destroy ( ) { var element = this . element ; if ( ! element [ NAMESPACE ] ) { return this ; } element [ NAMESPACE ] = undefined ; if ( this . isImg && this . replaced ) { element . src = this . originalUrl ; } this . uncreate ( ) ; return this ; } 
function move ( offsetX ) { var offsetY = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : offsetX ; var _this$canvasData = this . canvasData , left = _this$canvasData . left , top = _this$canvasData . top ; return this . moveTo ( isUndefined ( offsetX ) ? offsetX : left + Number ( offsetX ) , isUndefined ( offsetY ) ? offsetY : top + Number ( offsetY ) ) ; } 
function moveTo ( x ) { var y = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : x ; var canvasData = this . canvasData ; var changed = false ; x = Number ( x ) ; y = Number ( y ) ; if ( this . ready && ! this . disabled && this . options . movable ) { if ( isNumber ( x ) ) { canvasData . left = x ; changed = true ; } if ( isNumber ( y ) ) { canvasData . top = y ; changed = true ; } if ( changed ) { this . renderCanvas ( true ) ; } } return this ; } 
function zoom ( ratio , _originalEvent ) { var canvasData = this . canvasData ; ratio = Number ( ratio ) ; if ( ratio < 0 ) { ratio = 1 / ( 1 - ratio ) ; } else { ratio = 1 + ratio ; } return this . zoomTo ( canvasData . width * ratio / canvasData . naturalWidth , null , _originalEvent ) ; } 
function rotateTo ( degree ) { degree = Number ( degree ) ; if ( isNumber ( degree ) && this . ready && ! this . disabled && this . options . rotatable ) { this . imageData . rotate = degree % 360 ; this . renderCanvas ( true , true ) ; } return this ; } 
function scaleX ( _scaleX ) { var scaleY = this . imageData . scaleY ; return this . scale ( _scaleX , isNumber ( scaleY ) ? scaleY : 1 ) ; } 
function scaleY ( _scaleY ) { var scaleX = this . imageData . scaleX ; return this . scale ( isNumber ( scaleX ) ? scaleX : 1 , _scaleY ) ; } 
function scale ( scaleX ) { var scaleY = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : scaleX ; var imageData = this . imageData ; var transformed = false ; scaleX = Number ( scaleX ) ; scaleY = Number ( scaleY ) ; if ( this . ready && ! this . disabled && this . options . scalable ) { if ( isNumber ( scaleX ) ) { imageData . scaleX = scaleX ; transformed = true ; } if ( isNumber ( scaleY ) ) { imageData . scaleY = scaleY ; transformed = true ; } if ( transformed ) { this . renderCanvas ( true , true ) ; } } return this ; } 
function getData ( ) { var rounded = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : false ; var options = this . options , imageData = this . imageData , canvasData = this . canvasData , cropBoxData = this . cropBoxData ; var data ; if ( this . ready && this . cropped ) { data = { x : cropBoxData . left - canvasData . left , y : cropBoxData . top - canvasData . top , width : cropBoxData . width , height : cropBoxData . height } ; var ratio = imageData . width / imageData . naturalWidth ; forEach ( data , function ( n , i ) { data [ i ] = n / ratio ; } ) ; if ( rounded ) { 
function getCanvasData ( ) { var canvasData = this . canvasData ; var data = { } ; if ( this . ready ) { forEach ( [ 'left' , 'top' , 'width' , 'height' , 'naturalWidth' , 'naturalHeight' ] , function ( n ) { data [ n ] = canvasData [ n ] ; } ) ; } return data ; } 
function setCanvasData ( data ) { var canvasData = this . canvasData ; var aspectRatio = canvasData . aspectRatio ; if ( this . ready && ! this . disabled && isPlainObject ( data ) ) { if ( isNumber ( data . left ) ) { canvasData . left = data . left ; } if ( isNumber ( data . top ) ) { canvasData . top = data . top ; } if ( isNumber ( data . width ) ) { canvasData . width = data . width ; canvasData . height = data . width / aspectRatio ; } else if ( isNumber ( data . height ) ) { canvasData . height = data . height ; canvasData . width = data . height * aspectRatio ; } this . renderCanvas ( true ) ; } return this ; } 
function setAspectRatio ( aspectRatio ) { var options = this . options ; if ( ! this . disabled && ! isUndefined ( aspectRatio ) ) { 
function setDragMode ( mode ) { var options = this . options , dragBox = this . dragBox , face = this . face ; if ( this . ready && ! this . disabled ) { var croppable = mode === DRAG_MODE_CROP ; var movable = options . movable && mode === DRAG_MODE_MOVE ; mode = croppable || movable ? mode : DRAG_MODE_NONE ; options . dragMode = mode ; setData ( dragBox , DATA_ACTION , mode ) ; toggleClass ( dragBox , CLASS_CROP , croppable ) ; toggleClass ( dragBox , CLASS_MOVE , movable ) ; if ( ! options . cropBoxMovable ) { 
function appendNodeFactory ( Node ) { function AppendNode ( editor ) { this . editor = editor ; this . dom = { } ; } AppendNode . prototype = new Node ( ) ; AppendNode . prototype . getDom = function ( ) { * Append node doesn't have a path * @returns {null} */ AppendNode . prototype . getPath = function ( ) { return null ; } ; /** * Append node doesn't have an index * @returns {null} */ AppendNode . prototype . getIndex = function ( ) { return null ; } ; AppendNode . prototype . updateDom = function ( options ) { var dom = this . dom ; var tdAppend = dom . td ; if ( tdAppend ) { tdAppend . style . paddingLeft = ( this . getLevel ( ) * 24 + 26 ) + 'px' ; * Check whether the AppendNode is currently visible. * the AppendNode is visible when its parent has no childs (i.e. is empty). * @return {boolean} isVisible */ AppendNode . prototype . isVisible = function ( ) { return ( this . parent . childs . length == 0 ) ; } ; AppendNode . prototype . showContextMenu = function ( anchor , onClose ) { var node = this ; var titles = Node . TYPE_TITLES ; var appendSubmenu = [ { text : translate ( 'auto' ) , className : 'jsoneditor-type-auto' , title : titles . auto , click : function ( ) { node . _onAppend ( '' , '' , 'auto' ) ; } } , { text : translate ( 'array' ) , className : 'jsoneditor-type-array' , title : titles . array , click : function ( ) { node . _onAppend ( '' , [ ] ) ; } } , { text : translate ( 'object' ) , className : 'jsoneditor-type-object' , title : titles . object , click : function ( ) { node . _onAppend ( '' , { } ) ; } } , { text : translate ( 'string' ) , className : 'jsoneditor-type-string' , title : titles . string , click : function ( ) { node . _onAppend ( '' , '' , 'string' ) ; } } ] ; node . addTemplates ( appendSubmenu , true ) ; var items = [ * Handle an event. The event is caught centrally by the editor * @param {Event} event */ AppendNode . prototype . onEvent = function ( event ) { var type = event . type ; var target = event . target || event . srcElement ; var dom = this . dom ; 
function ( event , func ) { this . _events = this . _events || { } ; this . _events [ event ] = this . _events [ event ] || [ ] ; this . _events [ event ] . push ( func ) ; } 
function ( event , func ) { this . _events = this . _events || { } ; if ( event in this . _events === false ) return ; this . _events [ event ] . splice ( this . _events [ event ] . indexOf ( func ) , 1 ) ; } 
function appendItem ( item , parent , custom ) { if ( item . parentNode ) { if ( ! item . parentNode . parentNode ) { parent . appendChild ( item . parentNode ) ; } } else { parent . appendChild ( item ) ; } util . removeClass ( item , "excluded" ) ; if ( ! custom ) { item . innerHTML = item . textContent ; } } 
function ( ) { if ( this . items . length ) { var f = document . createDocumentFragment ( ) ; if ( this . config . pagination ) { var pages = this . pages . slice ( 0 , this . pageIndex ) ; util . each ( pages , function ( i , items ) { util . each ( items , function ( j , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; } , this ) ; } else { util . each ( this . items , function ( i , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; } if ( f . childElementCount ) { util . removeClass ( this . items [ this . navIndex ] , "active" ) ; this . navIndex = f . querySelector ( ".selectr-option" ) . idx ; util . addClass ( this . items [ this . navIndex ] , "active" ) ; } this . tree . appendChild ( f ) ; } } 
function ( e ) { var target = e . target ; if ( ! this . container . contains ( target ) && ( this . opened || util . hasClass ( this . container , "notice" ) ) ) { this . close ( ) ; } } 
function ( option , data ) { data = data || option ; var content = this . customOption ? this . config . renderOption ( data ) : option . textContent ; var opt = util . createElement ( "li" , { class : "selectr-option" , html : content , role : "treeitem" , "aria-selected" : false } ) ; opt . idx = option . idx ; this . items . push ( opt ) ; if ( option . defaultSelected ) { this . defaultSelected . push ( option . idx ) ; } if ( option . disabled ) { opt . disabled = true ; util . addClass ( opt , "disabled" ) ; } return opt ; } 
function ( ) { this . requiresPagination = this . config . pagination && this . config . pagination > 0 ; 
function ( e ) { e = e || window . event ; 
function ( item ) { var that = this , r ; var docFrag = document . createDocumentFragment ( ) ; var option = this . options [ item . idx ] ; var data = this . data ? this . data [ item . idx ] : option ; var content = this . customSelected ? this . config . renderSelection ( data ) : option . textContent ; var tag = util . createElement ( "li" , { class : "selectr-tag" , html : content } ) ; var btn = util . createElement ( "button" , { class : "selectr-tag-remove" , type : "button" } ) ; tag . appendChild ( btn ) ; 
function ( item ) { var tag = false ; util . each ( this . tags , function ( i , t ) { if ( t . idx === item . idx ) { tag = t ; } } , this ) ; if ( tag ) { this . label . removeChild ( tag ) ; this . tags . splice ( this . tags . indexOf ( tag ) , 1 ) ; } } 
function ( ) { var tree = this . tree ; var scrollTop = tree . scrollTop ; var scrollHeight = tree . scrollHeight ; var offsetHeight = tree . offsetHeight ; var atBottom = scrollTop >= ( scrollHeight - offsetHeight ) ; if ( ( atBottom && this . pageIndex < this . pages . length ) ) { var f = document . createDocumentFragment ( ) ; util . each ( this . pages [ this . pageIndex ] , function ( i , item ) { appendItem ( item , f , this . customOption ) ; } , this ) ; tree . appendChild ( f ) ; this . pageIndex ++ ; this . emit ( "selectr.paginate" , { items : this . items . length , total : this . data . length , page : this . pageIndex , pages : this . pages . length } ) ; } } 
function ( ) { if ( this . config . searchable || this . config . taggable ) { this . input . value = null ; this . searching = false ; if ( this . config . searchable ) { util . removeClass ( this . inputContainer , "active" ) ; } if ( util . hasClass ( this . container , "notice" ) ) { util . removeClass ( this . container , "notice" ) ; util . addClass ( this . container , "open" ) ; this . input . focus ( ) ; } util . each ( this . items , function ( i , item ) { 
function ( query , option ) { var result = new RegExp ( query , "i" ) . exec ( option . textContent ) ; if ( result ) { return option . textContent . replace ( result [ 0 ] , "<span class='selectr-match'>" + result [ 0 ] + "</span>" ) ; } return false ; } 
function ( el , config ) { config = config || { } ; if ( ! el ) { throw new Error ( "You must supply either a HTMLSelectElement or a CSS3 selector string." ) ; } this . el = el ; 
function showTransformModal ( node , container ) { var value = node . getValue ( ) ; var content = '<label class="pico-modal-contents">' + '<div class="pico-modal-header">' + translate ( 'transform' ) + '</div>' + '<p>' + 'Enter a <a href="http://jmespath.org" target="_blank">JMESPath</a> query to filter, sort, or transform the JSON data.<br/>' + 'To learn JMESPath, go to <a href="http://jmespath.org/tutorial.html" target="_blank">the interactive tutorial</a>.' + '</p>' + '<div class="jsoneditor-jmespath-label">' + translate ( 'transformWizardLabel' ) + ' </div>' + '<div id="wizard" class="jsoneditor-jmespath-block jsoneditor-jmespath-wizard">' + ' <table class="jsoneditor-jmespath-wizard-table">' + ' <tbody>' + ' <tr>' + ' <th>' + translate ( 'transformWizardFilter' ) + '</th>' + ' <td class="jsoneditor-jmespath-filter">' + ' <div class="jsoneditor-inline jsoneditor-jmespath-filter-field" >' + ' <select id="filterField">' + ' </select>' + ' </div>' + ' <div class="jsoneditor-inline jsoneditor-jmespath-filter-relation" >' + ' <select id="filterRelation">' + ' <option value="==">==</option>' + ' <option value="!=">!=</option>' + ' <option value="<">&lt;</option>' + ' <option value="<=">&lt;=</option>' + ' <option value=">">&gt;</option>' + ' <option value=">=">&gt;=</option>' + ' </select>' + ' </div>' + ' <div class="jsoneditor-inline jsoneditor-jmespath-filter-value" >' + ' <input placeholder="value..." id="filterValue" />' + ' </div>' + ' </td>' + ' </tr>' + ' <tr>' + ' <th>' + translate ( 'transformWizardSortBy' ) + '</th>' + ' <td class="jsoneditor-jmespath-filter">' + ' <div class="jsoneditor-inline jsoneditor-jmespath-sort-field">' + ' <select id="sortField">' + ' </select>' + ' </div>' + ' <div class="jsoneditor-inline jsoneditor-jmespath-sort-order" >' + ' <select id="sortOrder">' + ' <option value="asc">Ascending</option>' + ' <option value="desc">Descending</option>' + ' </select>' + ' </div>' + ' </td>' + ' </tr>' + ' <tr id="selectFieldsPart">' + ' <th>' + translate ( 'transformWizardSelectFields' ) + '</th>' + ' <td class="jsoneditor-jmespath-filter">' + ' <select class="jsoneditor-jmespath-select-fields" id="selectFields" multiple></select>' + ' </td>' + ' </tr>' + ' </tbody>' + ' </table>' + '</div>' + '<div class="jsoneditor-jmespath-label">' + translate ( 'transformQueryLabel' ) + ' </div>' + '<div class="jsoneditor-jmespath-block">' + ' <textarea id="query" ' + ' rows="4" ' + ' autocomplete="off" ' + ' autocorrect="off" ' + ' autocapitalize="off" ' + ' spellcheck="false"' + ' title="' + translate ( 'transformQueryTitle' ) + '">[*]</textarea>' + '</div>' + '<div class="jsoneditor-jmespath-label">' + translate ( 'transformPreviewLabel' ) + ' </div>' + '<div class="jsoneditor-jmespath-block">' + ' <textarea id="preview" ' + ' class="jsoneditor-transform-preview"' + ' readonly> </textarea>' + '</div>' + '<div class="jsoneditor-jmespath-block jsoneditor-modal-actions">' + ' <input type="submit" id="ok" value="' + translate ( 'ok' ) + '" autofocus />' + '</div>' + '</div>' ; picoModal ( { parent : container , content : content , overlayClass : 'jsoneditor-modal-overlay' , modalClass : 'jsoneditor-modal jsoneditor-modal-transform' , focus : false } ) . afterCreate ( function ( modal ) { var elem = modal . modalElem ( ) ; var wizard = elem . querySelector ( '#wizard' ) ; var ok = elem . querySelector ( '#ok' ) ; var filterField = elem . querySelector ( '#filterField' ) ; var filterRelation = elem . querySelector ( '#filterRelation' ) ; var filterValue = elem . querySelector ( '#filterValue' ) ; var sortField = elem . querySelector ( '#sortField' ) ; var sortOrder = elem . querySelector ( '#sortOrder' ) ; var selectFields = elem . querySelector ( '#selectFields' ) ; var query = elem . querySelector ( '#query' ) ; var preview = elem . querySelector ( '#preview' ) ; if ( ! Array . isArray ( value ) ) { wizard . style . fontStyle = 'italic' ; wizard . innerHTML = '(wizard not available for objects, only for arrays)' } var paths = node . getChildPaths ( ) ; paths . forEach ( function ( path ) { var formattedPath = preprocessPath ( path ) ; var filterOption = document . createElement ( 'option' ) ; filterOption . text = formattedPath ; filterOption . value = formattedPath ; filterField . appendChild ( filterOption ) ; var sortOption = document . createElement ( 'option' ) ; sortOption . text = formattedPath ; sortOption . value = formattedPath ; sortField . appendChild ( sortOption ) ; } ) ; var allPaths = node . getChildPaths ( true ) . filter ( function ( path ) { return path !== '.' ; } ) ; if ( allPaths . length > 0 ) { allPaths . forEach ( function ( path ) { var formattedPath = preprocessPath ( path ) ; var option = document . createElement ( 'option' ) ; option . text = formattedPath ; option . value = formattedPath ; selectFields . appendChild ( option ) ; } ) ; } else { var selectFieldsPart = elem . querySelector ( '#selectFieldsPart' ) ; if ( selectFieldsPart ) { selectFieldsPart . style . display = 'none' ; } } var selectrFilterField = new Selectr ( filterField , { defaultSelected : false , clearable : true , allowDeselect : true , placeholder : 'field...' } ) ; var selectrFilterRelation = new Selectr ( filterRelation , { defaultSelected : false , clearable : true , allowDeselect : true , placeholder : 'compare...' } ) ; var selectrSortField = new Selectr ( sortField , { defaultSelected : false , clearable : true , allowDeselect : true , placeholder : 'field...' } ) ; var selectrSortOrder = new Selectr ( sortOrder , { defaultSelected : false , clearable : true , allowDeselect : true , placeholder : 'order...' } ) ; var selectrSelectFields = new Selectr ( selectFields , { multiple : true , clearable : true , defaultSelected : false , placeholder : 'select fields...' } ) ; selectrFilterField . on ( 'selectr.change' , generateQueryFromWizard ) ; selectrFilterRelation . on ( 'selectr.change' , generateQueryFromWizard ) ; filterValue . oninput = generateQueryFromWizard ; selectrSortField . on ( 'selectr.change' , generateQueryFromWizard ) ; selectrSortOrder . on ( 'selectr.change' , generateQueryFromWizard ) ; selectrSelectFields . on ( 'selectr.change' , generateQueryFromWizard ) ; elem . querySelector ( '.pico-modal-contents' ) . onclick = function ( event ) { 
function showMoreNodeFactory ( Node ) { function ShowMoreNode ( editor , parent ) { this . editor = editor ; this . parent = parent ; this . dom = { } ; } ShowMoreNode . prototype = new Node ( ) ; ShowMoreNode . prototype . getDom = function ( ) { if ( this . dom . tr ) { return this . dom . tr ; } this . _updateEditability ( ) ; * Update the HTML dom of the Node */ ShowMoreNode . prototype . updateDom = function ( options ) { if ( this . isVisible ( ) ) { * Check whether the ShowMoreNode is currently visible. * the ShowMoreNode is visible when it's parent has more childs than * the current visibleChilds * @return {boolean} isVisible */ ShowMoreNode . prototype . isVisible = function ( ) { return this . parent . expanded && this . parent . childs . length > this . parent . visibleChilds ; } ; /** * Handle an event. The event is caught centrally by the editor * @param {Event} event */ ShowMoreNode . prototype . onEvent = function ( event ) { var type = event . type ; if ( type === 'keydown' ) { this . onKeyDown ( event ) ; } } ; return ShowMoreNode ; } 
function showSortModal ( node , container ) { var content = '<div class="pico-modal-contents">' + '<div class="pico-modal-header">' + translate ( 'sort' ) + '</div>' + '<form>' + '<table>' + '<tbody>' + '<tr>' + ' <td>' + translate ( 'sortFieldLabel' ) + ' </td>' + ' <td class="jsoneditor-modal-input">' + ' <div class="jsoneditor-select-wrapper">' + ' <select id="field" title="' + translate ( 'sortFieldTitle' ) + '">' + ' </select>' + ' </div>' + ' </td>' + '</tr>' + '<tr>' + ' <td>' + translate ( 'sortDirectionLabel' ) + ' </td>' + ' <td class="jsoneditor-modal-input">' + ' <div id="direction" class="jsoneditor-button-group">' + '<input type="button" ' + 'value="' + translate ( 'sortAscending' ) + '" ' + 'title="' + translate ( 'sortAscendingTitle' ) + '" ' + 'data-value="asc" ' + 'class="jsoneditor-button-first jsoneditor-button-asc"/>' + '<input type="button" ' + 'value="' + translate ( 'sortDescending' ) + '" ' + 'title="' + translate ( 'sortDescendingTitle' ) + '" ' + 'data-value="desc" ' + 'class="jsoneditor-button-last jsoneditor-button-desc"/>' + ' </div>' + ' </td>' + '</tr>' + '<tr>' + '<td colspan="2" class="jsoneditor-modal-input jsoneditor-modal-actions">' + ' <input type="submit" id="ok" value="' + translate ( 'ok' ) + '" />' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</form>' + '</div>' ; picoModal ( { parent : container , content : content , overlayClass : 'jsoneditor-modal-overlay' , modalClass : 'jsoneditor-modal jsoneditor-modal-sort' } ) . afterCreate ( function ( modal ) { var form = modal . modalElem ( ) . querySelector ( 'form' ) ; var ok = modal . modalElem ( ) . querySelector ( '#ok' ) ; var field = modal . modalElem ( ) . querySelector ( '#field' ) ; var direction = modal . modalElem ( ) . querySelector ( '#direction' ) ; var paths = node . type === 'array' ? node . getChildPaths ( ) : [ '.' ] ; paths . forEach ( function ( path ) { var option = document . createElement ( 'option' ) ; option . text = path ; option . value = path ; field . appendChild ( option ) ; } ) ; function setDirection ( value ) { direction . value = value ; direction . className = 'jsoneditor-button-group jsoneditor-button-group-value-' + direction . value ; } field . value = node . sortedBy ? node . sortedBy . path : paths [ 0 ] ; setDirection ( node . sortedBy ? node . sortedBy . direction : 'asc' ) ; direction . onclick = function ( event ) { setDirection ( event . target . getAttribute ( 'data-value' ) ) ; } ; ok . onclick = function ( event ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; modal . close ( ) ; var path = field . value ; var pathArray = ( path === '.' ) ? [ ] : path . split ( '.' ) . slice ( 1 ) ; node . sortedBy = { path : path , direction : direction . value } ; node . sort ( pathArray , direction . value ) } ; if ( form ) { 
function TreePath ( container , root ) { if ( container ) { this . root = root ; this . path = document . createElement ( 'div' ) ; this . path . className = 'jsoneditor-treepath' ; this . path . setAttribute ( 'tabindex' , 0 ) ; this . contentMenuClicked ; container . appendChild ( this . path ) ; this . reset ( ) ; } } 
function ContextMenu ( items , options ) { this . dom = { } ; var me = this ; var dom = this . dom ; this . anchor = undefined ; this . items = items ; this . eventListeners = { } ; this . selection = undefined ; 
function ModeSwitcher ( container , modes , current , onSwitch ) { 
function lastNonWhitespace ( ) { var p = chars . length - 1 ; while ( p >= 0 ) { var pp = chars [ p ] ; if ( ! isWhiteSpace ( pp ) ) { return pp ; } p -- ; } return '' ; } 
function nextNonWhiteSpace ( ) { var iNext = i + 1 ; while ( iNext < jsString . length && isWhiteSpace ( jsString [ iNext ] ) ) { iNext ++ ; } return jsString [ iNext ] ; } 
function parseString ( endQuote ) { chars . push ( '"' ) ; i ++ ; var c = curr ( ) ; while ( i < jsString . length && c !== endQuote ) { if ( c === '"' && prev ( ) !== '\\' ) { 
function parseKey ( ) { var specialValues = [ 'null' , 'true' , 'false' ] ; var key = '' ; var c = curr ( ) ; var regexp = / [a-zA-Z_$\d] / ; 
function _positionForIndex ( index ) { var textTillIndex = el . value . substring ( 0 , index ) ; var row = ( textTillIndex . match ( / \n / g ) || [ ] ) . length + 1 ; var col = textTillIndex . length - textTillIndex . lastIndexOf ( "\n" ) ; return { row : row , column : col } } 
function JSONEditor ( container , options , json ) { if ( ! ( this instanceof JSONEditor ) ) { throw new Error ( 'JSONEditor constructor called without "new".' ) ; } 
function ( ) { var scrollTop = content . scrollTop ; var diff = ( finalScrollTop - scrollTop ) ; if ( Math . abs ( diff ) > 3 ) { content . scrollTop += diff / 3 ; editor . animateCallback = callback ; editor . animateTimeout = setTimeout ( animate , 50 ) ; } else { 
function ( event ) { var target = event . target ; if ( ( target !== absoluteAnchor ) && ! util . isChildOf ( target , absoluteAnchor ) ) { destroy ( ) ; } } 
function ( elem , rs ) { var rows = [ ] ; var ix = 0 ; var oldIndex = - 1 ; var onMouseOver = function ( ) { this . style . outline = '1px solid #ddd' ; } var onMouseOut = function ( ) { this . style . outline = '0' ; } var onMouseDown = function ( ) { p . hide ( ) ; p . onmouseselection ( this . __hint , p . rs ) ; } var p = { rs : rs , hide : function ( ) { elem . style . visibility = 'hidden' ; 
function ( element , startPos , options ) { this . startFrom = startPos ; this . wrapper . remove ( ) ; if ( this . elementHint ) { this . elementHint . remove ( ) ; this . elementHint = null ; } if ( fontSize == '' ) { fontSize = window . getComputedStyle ( element ) . getPropertyValue ( 'font-size' ) ; } if ( fontFamily == '' ) { fontFamily = window . getComputedStyle ( element ) . getPropertyValue ( 'font-family' ) ; } var w = element . getBoundingClientRect ( ) . right - element . getBoundingClientRect ( ) . left ; dropDown . style . marginLeft = '0' ; dropDown . style . marginTop = element . getBoundingClientRect ( ) . height + 'px' ; this . options = options ; if ( this . element != element ) { this . element = element ; this . elementStyle = { zIndex : this . element . style . zIndex , position : this . element . style . position , backgroundColor : this . element . style . backgroundColor , borderColor : this . element . style . borderColor } } this . element . style . zIndex = 3 ; this . element . style . position = 'relative' ; this . element . style . backgroundColor = 'transparent' ; this . element . style . borderColor = 'transparent' ; this . elementHint = element . cloneNode ( ) ; this . elementHint . className = 'autocomplete hint' ; this . elementHint . style . zIndex = 2 ; this . elementHint . style . position = 'absolute' ; this . elementHint . onfocus = function ( ) { this . element . focus ( ) ; } . bind ( this ) ; if ( this . element . addEventListener ) { this . element . removeEventListener ( "keydown" , keyDownHandler ) ; this . element . addEventListener ( "keydown" , keyDownHandler , false ) ; this . element . removeEventListener ( "blur" , onBlurHandler ) ; this . element . addEventListener ( "blur" , onBlurHandler , false ) ; } wrapper . appendChild ( this . elementHint ) ; wrapper . appendChild ( dropDown ) ; element . parentElement . appendChild ( wrapper ) ; this . repaint ( element ) ; } 
function ( id ) { for ( let parent = module . parent ; parent ; parent = parent . parent ) { try { return parent . require ( id ) ; } catch ( e ) { } } throw new Error ( "Cannot find module '" + id + "' from parent" ) ; } 
function render ( element ) { connectDevtools ( DesktopRenderer ) ; ROOT_NODE = createElement ( 'ROOT' ) ; const container = ROOT_NODE ; 
function createElement ( type , props ) { const COMPONENTS = { ROOT : ( ) => new Root ( ) , TEXT : ( ) => new Text ( ROOT_NODE , props ) , APP : ( ) => new App ( ROOT_NODE , props ) , WINDOW : ( ) => new Window ( ROOT_NODE , props ) , BUTTON : ( ) => new Button ( ROOT_NODE , props ) , VERTICALBOX : ( ) => new VerticalBox ( ROOT_NODE , props ) , HORIZONTALBOX : ( ) => new HorizontalBox ( ROOT_NODE , props ) , ENTRY : ( ) => new Entry ( ROOT_NODE , props ) , PASSWORDENTRY : ( ) => new PasswordEntry ( ROOT_NODE , props ) , MULTILINEENTRY : ( ) => new MultilineEntry ( ROOT_NODE , props ) , COLORBUTTON : ( ) => new ColorButton ( ROOT_NODE , props ) , FORM : ( ) => new Form ( ROOT_NODE , props ) , TAB : ( ) => new Tab ( ROOT_NODE , props ) , GROUP : ( ) => new Group ( ROOT_NODE , props ) , GRID : ( ) => new Grid ( ROOT_NODE , props ) , CHECKBOX : ( ) => new Checkbox ( ROOT_NODE , props ) , SPINBOX : ( ) => new Spinbox ( ROOT_NODE , props ) , SLIDER : ( ) => new Slider ( ROOT_NODE , props ) , COMBOBOX : ( ) => new Combobox ( ROOT_NODE , props ) , COMBOBOXITEM : ( ) => new Combobox . Item ( ROOT_NODE , props ) , RADIOBUTTON : ( ) => new RadioButton ( ROOT_NODE , props ) , RADIOBUTTONITEM : ( ) => new RadioButton . Item ( ROOT_NODE , props ) , EDITABLECOMBOBOX : ( ) => new EditableCombobox ( ROOT_NODE , props ) , HORIZONTALSEPARATOR : ( ) => new HorizontalSeparator ( ROOT_NODE , props ) , VERTICALSEPARATOR : ( ) => new VerticalSeparator ( ROOT_NODE , props ) , PROGRESSBAR : ( ) => new ProgressBar ( ROOT_NODE , props ) , MENUBAR : ( ) => new MenuBar ( ROOT_NODE , props ) , MENUBARITEM : ( ) => new MenuBar . Item ( ROOT_NODE , props ) , FONTBUTTON : ( ) => new FontButton ( ROOT_NODE , props ) , AREA : ( ) => new Area ( ROOT_NODE , props ) , AREARECTANGLE : ( ) => new Area . Rectangle ( ROOT_NODE , props ) , AREALINE : ( ) => new Area . Line ( ROOT_NODE , props ) , AREAARC : ( ) => new Area . Arc ( ROOT_NODE , props ) , AREABEZIER : ( ) => new Area . Bezier ( ROOT_NODE , props ) , AREAPATH : ( ) => new Area . Path ( ROOT_NODE , props ) , AREAGROUP : ( ) => new Area . Group ( ROOT_NODE , props ) , AREACIRCLE : ( ) => new Area . Circle ( ROOT_NODE , props ) , AREATEXT : ( ) => new Area . Text ( ROOT_NODE , props ) , default : undefined , } ; return COMPONENTS [ type ] ( ) || COMPONENTS . default ; } 
function caml_open_sync_raw ( fileName , onSuccess , onFailure ) { var f = caml_js_from_string ( fileName ) ; var data = new joo_global_object . Uint8Array ( [ 17 , 211 , 2 ] ) ; var result = null ; function onSuccess ( ) { var res = new joo_global_object . Uint8Array ( oReq . response ) ; var ba = caml_ba_create_from ( res , null , 0 , 0 , 0 , [ res . length ] ) onSuccess ( ba ) ; } ; function onFailure ( ) { onFailure ( caml_js_to_string ( "failed to load file: " + f ) ) ; } ; var oReq = new XMLHttpRequest ( ) ; oReq . addEventListener ( "load" , onSuccess , onFailure ) ; oReq . responseType = "arraybuffer" oReq . open ( "GET" , fileName , true ) ; oReq . send ( ) ; } 
function whitespace ( rule , value , source , errors , options ) { if ( / ^\s+$ / . test ( value ) || value === '' ) { errors . push ( util . format ( options . messages . whitespace , rule . fullField ) ) ; } } 
function enumerable ( rule , value , source , errors , options ) { rule [ ENUM ] = Array . isArray ( rule [ ENUM ] ) ? rule [ ENUM ] : [ ] ; if ( rule [ ENUM ] . indexOf ( value ) === - 1 ) { errors . push ( util . format ( options . messages [ ENUM ] , rule . fullField , rule [ ENUM ] . join ( ', ' ) ) ) ; } } 
function range ( rule , value , source , errors , options ) { const len = typeof rule . len === 'number' ; const min = typeof rule . min === 'number' ; const max = typeof rule . max === 'number' ; 
function required ( rule , value , source , errors , options , type ) { if ( rule . required && ( ! source . hasOwnProperty ( rule . field ) || util . isEmptyValue ( value , type || rule . type ) ) ) { errors . push ( util . format ( options . messages . required , rule . fullField ) ) ; } } 
function string ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required || ( ! rule . required && source . hasOwnProperty ( rule . field ) ) ; if ( validate ) { if ( isEmptyValue ( value , 'string' ) && ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options , 'string' ) ; if ( ! isEmptyValue ( value , 'string' ) ) { rules . type ( rule , value , source , errors , options ) ; rules . range ( rule , value , source , errors , options ) ; rules . pattern ( rule , value , source , errors , options ) ; if ( rule . whitespace === true ) { rules . whitespace ( rule , value , source , errors , options ) ; } } } callback ( errors ) ; } 
function regexp ( rule , value , callback , source , options ) { const errors = [ ] ; const validate = rule . required || ( ! rule . required && source . hasOwnProperty ( rule . field ) ) ; if ( validate ) { if ( isEmptyValue ( value ) && ! rule . required ) { return callback ( ) ; } rules . required ( rule , value , source , errors , options ) ; if ( ! isEmptyValue ( value ) ) { rules . type ( rule , value , source , errors , options ) ; } } callback ( errors ) ; } 
function pattern ( rule , value , source , errors , options ) { if ( rule . pattern ) { if ( rule . pattern instanceof RegExp ) { 
function type ( rule , value , source , errors , options ) { if ( rule . required && value === undefined ) { required ( rule , value , source , errors , options ) ; return ; } const custom = [ 'integer' , 'float' , 'array' , 'regexp' , 'object' , 'method' , 'email' , 'number' , 'date' , 'url' , 'hex' ] ; const ruleType = rule . type ; if ( custom . indexOf ( ruleType ) > - 1 ) { if ( ! types [ ruleType ] ( value ) ) { errors . push ( util . format ( options . messages . types [ ruleType ] , rule . fullField , rule . type ) ) ; } 
function getStyleComputedProperty ( element , property ) { if ( element . nodeType !== 1 ) { return [ ] ; } 
function getBoundingClientRect ( element ) { var rect = { } ; 
function isFixed ( element ) { var nodeName = element . nodeName ; if ( nodeName === 'BODY' || nodeName === 'HTML' ) { return false ; } if ( getStyleComputedProperty ( element , 'position' ) === 'fixed' ) { return true ; } var parentNode = getParentNode ( element ) ; if ( ! parentNode ) { return false ; } return isFixed ( parentNode ) ; } 
function getBoundaries ( popper , reference , padding , boundariesElement ) { var fixedPosition = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; 
function isModifierEnabled ( modifiers , modifierName ) { return modifiers . some ( function ( _ref ) { var name = _ref . name , enabled = _ref . enabled ; return enabled && name === modifierName ; } ) ; } 
function Popper ( reference , popper ) { var _this = this ; var options = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; classCallCheck ( this , Popper ) ; this . scheduleUpdate = function ( ) { return requestAnimationFrame ( _this . update ) ; } ; 
function writeOutputHTML ( dir , html ) { const outputPath = pathJoin ( dir , 'index.html' ) ; mkdirp . sync ( path . dirname ( outputPath ) ) ; writeFileSync ( outputPath , serialize ( html ) ) ; } 
function needsTemplatePolyfill ( ) { 
function createConfig ( options , legacy ) { return { entry : Array . isArray ( options . entry ) ? options . entry : [ options . entry ] , output : { filename : ` ${ legacy ? 'legacy/' : '' } ` , chunkFilename : ` ${ legacy ? 'legacy/' : '' } ` , path : path . resolve ( process . cwd ( ) , ` ` ) , } , devtool : development ? 'inline-source-map' : 'source-map' , resolve : { mainFields : [ 
function getOutputHTML ( dir ) { if ( existsSync ( ` ${ dir } ` ) ) { return readHTML ( ` ${ dir } ` ) ; } const outputHTML = readHTML ( inputIndexHTMLPath ) ; const scripts = queryAll ( outputHTML , predicates . hasTagName ( 'script' ) ) ; const moduleScripts = scripts . filter ( script => getAttribute ( script , 'type' ) === 'module' ) ; moduleScripts . forEach ( moduleScript => { remove ( moduleScript ) ; } ) ; writeOutputHTML ( dir , outputHTML ) ; return outputHTML ; } 
function copyPolyfills ( pluginConfig , outputConfig ) { if ( ! pluginConfig . polyfillDynamicImports && ! pluginConfig . polyfillWebcomponents && ! pluginConfig . polyfillBabel ) { return ; } const polyfillsDir = ` ${ outputConfig . dir . replace ( '/legacy' , '' ) } ` ; mkdirp . sync ( polyfillsDir ) ; if ( pluginConfig . polyfillDynamicImports ) { copyFileSync ( path . resolve ( pathJoin ( __dirname , '../../src/dynamic-import-polyfill.js' ) ) , ` ${ polyfillsDir } ` , ) ; } if ( pluginConfig . polyfillWebcomponents ) { copyFileSync ( require . resolve ( '@webcomponents/webcomponentsjs/webcomponents-bundle.js' ) , ` ${ polyfillsDir } ` , ) ; } if ( pluginConfig . polyfillBabel ) { copyFileSync ( require . resolve ( '@babel/polyfill/browser.js' ) , ` ${ polyfillsDir } ` , ) ; } } 
function writeModules ( pluginConfig , outputConfig , entryModules ) { const indexHTML = getOutputHTML ( outputConfig . dir ) ; const head = query ( indexHTML , predicates . hasTagName ( 'head' ) ) ; const body = query ( indexHTML , predicates . hasTagName ( 'body' ) ) ; 
function writeLegacyModules ( pluginConfig , outputConfig , entryModules ) { const legacyOutputDir = outputConfig . dir ; const outputDir = legacyOutputDir . replace ( '/legacy' , '' ) ; const indexHTML = getOutputHTML ( outputDir ) ; const body = query ( indexHTML , predicates . hasTagName ( 'body' ) ) ; const polyfillsDir = ` ${ outputDir } ` ; mkdirp . sync ( polyfillsDir ) ; if ( pluginConfig . polyfillBabel ) { append ( body , createScript ( { src : ` ` , nomodule : '' , } ) , ) ; } if ( pluginConfig . polyfillWebcomponents ) { append ( body , createScript ( { src : ` ` , nomodule : '' , } ) , ) ; } copyFileSync ( require . resolve ( 'systemjs/dist/s.min.js' ) , ` ${ polyfillsDir } ` ) ; append ( body , createScript ( { src : ` ` , nomodule : '' , } ) , ) ; const loadScript = createScript ( { nomodule : '' } , entryModules . map ( src => ` ${ pathJoin ( 'legacy' , src ) } ` ) . join ( '' ) , ) ; append ( body , loadScript ) ; writeOutputHTML ( outputDir , indexHTML ) ; } 
function karmaEsmFramework ( karmaConfig , karmaEmitter ) { if ( ! karmaConfig . files . some ( file => file . type === 'module' ) ) { throw new Error ( "Did not find any test files with type='module'." + "Follow this format: { pattern: config.grep ? config.grep : 'test/**/*.test.js', type: 'module' }" , ) ; } initialize ( karmaConfig , karmaEmitter ) ; } 
function createCompiler ( config , karmaEmitter ) { const cache = new Map ( ) ; const watcher = chokidar . watch ( [ ] ) ; watcher . on ( 'change' , filePath => { if ( ! filePath . endsWith ( '.test.js' ) && ! filePath . endsWith ( '.spec.js' ) ) { karmaEmitter . refreshFiles ( ) ; } cache . delete ( filePath ) ; } ) ; function addToCache ( filePath , code ) { cache . set ( filePath , code ) ; watcher . add ( filePath ) ; } function babelCompile ( filePath , code ) { return babel . transform ( code , { filename : filePath , ... config . babelOptions , } ) . code ; } function compile ( filePath , code ) { 
function karmaEsmPreprocessor ( logger ) { const log = logger . create ( 'preprocessor.esm' ) ; function preprocess ( code , file , done ) { try { let compiledCode = esm . compiler . getCached ( file . originalPath ) ; if ( ! compiledCode ) { compiledCode = esm . compiler . compile ( file . originalPath , code ) ; } done ( null , compiledCode ) ; } catch ( e ) { const message = ` \n \n ${ e . message } \n ${ file . originalPath } \n \n ` ; log . error ( message ) ; done ( null , code ) ; } } return preprocess ; } 
function toAbsoluteURL ( url ) { const a = document . createElement ( 'a' ) ; a . setAttribute ( 'href' , url ) ; 
function hasMatchingTagName ( regex ) { return function ( node ) { if ( ! node . tagName ) { return false ; } return regex . test ( node . tagName . toLowerCase ( ) ) ; } ; } 
function normalize ( node ) { if ( ! ( isElement ( node ) || isDocument ( node ) || isDocumentFragment ( node ) ) ) { return ; } if ( ! node . childNodes ) { return ; } var textRangeStart = - 1 ; for ( var i = node . childNodes . length - 1 , n = void 0 ; i >= 0 ; i -- ) { n = node . childNodes [ i ] ; if ( isTextNode ( n ) ) { if ( textRangeStart === - 1 ) { textRangeStart = i ; } if ( i === 0 ) { 
function getTextContent ( node ) { if ( isCommentNode ( node ) ) { return node . data || '' ; } if ( isTextNode ( node ) ) { return node . value || '' ; } var subtree = nodeWalkAll ( node , isTextNode ) ; return subtree . map ( getTextContent ) . join ( '' ) ; } 
function setTextContent ( node , value ) { if ( isCommentNode ( node ) ) { node . data = value ; } else if ( isTextNode ( node ) ) { node . value = value ; } else { var tn = newTextNode ( value ) ; tn . parentNode = node ; node . childNodes = [ tn ] ; } } 
function treeMap ( node , mapfn ) { var results = [ ] ; nodeWalk ( node , function ( node ) { results = results . concat ( mapfn ( node ) ) ; return false ; } ) ; return results ; } 
function nodeWalk ( node , predicate , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } if ( predicate ( node ) ) { return node ; } var match = null ; var childNodes = getChildNodes ( node ) ; if ( childNodes ) { for ( var i = 0 ; i < childNodes . length ; i ++ ) { match = nodeWalk ( childNodes [ i ] , predicate , getChildNodes ) ; if ( match ) { break ; } } } return match ; } 
function nodeWalkAll ( node , predicate , matches , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } if ( ! matches ) { matches = [ ] ; } if ( predicate ( node ) ) { matches . push ( node ) ; } var childNodes = getChildNodes ( node ) ; if ( childNodes ) { for ( var i = 0 ; i < childNodes . length ; i ++ ) { nodeWalkAll ( childNodes [ i ] , predicate , matches , getChildNodes ) ; } } return matches ; } 
function nodeWalkPrior ( node , predicate ) { 
function nodeWalkAncestors ( node , predicate ) { var parent = node . parentNode ; if ( ! parent ) { return undefined ; } if ( predicate ( parent ) ) { return parent ; } return nodeWalkAncestors ( parent , predicate ) ; } 
function nodeWalkAllPrior ( node , predicate , matches ) { if ( ! matches ) { matches = [ ] ; } if ( predicate ( node ) ) { matches . push ( node ) ; } 
function query ( node , predicate , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } var elementPredicate = AND ( isElement , predicate ) ; return nodeWalk ( node , elementPredicate , getChildNodes ) ; } 
function queryAll ( node , predicate , matches , getChildNodes ) { if ( getChildNodes === void 0 ) { getChildNodes = module . exports . defaultChildNodes ; } var elementPredicate = AND ( isElement , predicate ) ; return nodeWalkAll ( node , elementPredicate , matches , getChildNodes ) ; } 
function insertNode ( parent , index , newNode , replace ) { if ( ! parent . childNodes ) { parent . childNodes = [ ] ; } var newNodes = [ ] ; var removedNode = replace ? parent . childNodes [ index ] : null ; if ( newNode ) { if ( isDocumentFragment ( newNode ) ) { if ( newNode . childNodes ) { newNodes = Array . from ( newNode . childNodes ) ; newNode . childNodes . length = 0 ; } } else { newNodes = [ newNode ] ; remove ( newNode ) ; } } if ( replace ) { removedNode = parent . childNodes [ index ] ; } Array . prototype . splice . apply ( parent . childNodes , [ index , replace ? 1 : 0 ] . concat ( newNodes ) ) ; newNodes . forEach ( function ( n ) { n . parentNode = parent ; } ) ; if ( removedNode ) { removedNode . parentNode = undefined ; } } 
function removeNodeSaveChildren ( node ) { 
function removeFakeRootElements ( ast ) { var injectedNodes = queryAll ( ast , AND ( function ( node ) { return ! node . __location ; } , hasMatchingTagName ( / ^(html|head|body)$ / i ) ) , undefined , 
function getCode ( filePath ) { 
function wrapTransitioningContext ( Comp ) { return props => { return ( < TransitioningContext . Consumer > { context => < Comp context = { context } { ... props } / > } < / TransitioningContext . Consumer > ) ; } ; } 
function friction ( value ) { const MAX_FRICTION = 5 ; const MAX_VALUE = 100 ; return max ( 1 , min ( MAX_FRICTION , add ( 1 , multiply ( value , ( MAX_FRICTION - 1 ) / MAX_VALUE ) ) ) ) ; } 
function findShallowIntersectingRange ( date1 , date2 ) { const thisRange = date1 . toRange ( ) ; const otherRange = date2 . toRange ( ) ; 
function dateShallowIncludesDate ( date1 , date2 ) { 
function dateShallowIntersectsDate ( date1 , date2 ) { if ( date1 . isDate ) return date2 . isDate ? date1 . dateTime === date2 . dateTime : dateShallowIncludesDate ( date2 , date1 ) ; if ( date2 . isDate ) return dateShallowIncludesDate ( date1 , date2 ) ; 
function split_linebreaks ( s ) { 
function processInputSync ( filepath ) { var data = null , config = this . cfg , outfile = config . outfile , input ; 
function onOutputError ( err ) { if ( err . code === 'EACCES' ) { console . error ( err . path + " is not writable. Skipping!" ) ; } else { console . error ( err ) ; process . exit ( 0 ) ; } } 
function dasherizeShorthands ( hash ) { 
function _mergeOpts ( allOptions , childFieldName ) { var finalOpts = { } ; allOptions = _normalizeOpts ( allOptions ) ; var name ; for ( name in allOptions ) { if ( name !== childFieldName ) { finalOpts [ name ] = allOptions [ name ] ; } } 
function TemplatablePattern ( input_scanner , parent ) { Pattern . call ( this , input_scanner , parent ) ; this . __template_pattern = null ; this . _disabled = Object . assign ( { } , template_names ) ; this . _excluded = Object . assign ( { } , template_names ) ; if ( parent ) { this . __template_pattern = this . _input . get_regexp ( parent . __template_pattern ) ; this . _excluded = Object . assign ( this . _excluded , parent . _excluded ) ; this . _disabled = Object . assign ( this . _disabled , parent . _disabled ) ; } var pattern = new Pattern ( input_scanner ) ; this . __patterns = { handlebars_comment : pattern . starting_with ( / {{!-- / ) . until_after ( / --}} / ) , handlebars : pattern . starting_with ( / {{ / ) . until_after ( / }} / ) , php : pattern . starting_with ( / <\?(?:[=]|php) / ) . until_after ( / \?> / ) , erb : pattern . starting_with ( / <%[^%] / ) . until_after ( / [^%]%> / ) , 
function filterUnusedSelectors ( selectors , ignore , usedSelectors ) { return selectors . filter ( ( selector ) => { selector = dePseudify ( selector ) ; if ( selector [ 0 ] === '@' ) { return true ; } for ( let i = 0 , len = ignore . length ; i < len ; ++ i ) { if ( _ . isRegExp ( ignore [ i ] ) && ignore [ i ] . test ( selector ) ) { return true ; } if ( ignore [ i ] === selector ) { return true ; } } return usedSelectors . indexOf ( selector ) !== - 1 ; } ) ; } 
function filterKeyframes ( css , unusedRules ) { const usedAnimations = [ ] ; css . walkDecls ( ( decl ) => { if ( _ . endsWith ( decl . prop , 'animation-name' ) ) { usedAnimations . push ( ... postcss . list . comma ( decl . value ) ) ; } else if ( _ . endsWith ( decl . prop , 'animation' ) ) { postcss . list . comma ( decl . value ) . forEach ( ( anim ) => { usedAnimations . push ( ... postcss . list . space ( anim ) ) ; } ) ; } } ) ; const usedAnimationsSet = new Set ( usedAnimations ) ; css . walkAtRules ( / keyframes$ / , ( atRule ) => { if ( ! usedAnimationsSet . has ( atRule . params ) ) { unusedRules . push ( atRule ) ; atRule . remove ( ) ; } } ) ; } 
function filterEmptyAtRules ( css ) { css . walkAtRules ( ( atRule ) => { if ( atRule . name === 'media' && atRule . nodes . length === 0 ) { atRule . remove ( ) ; } } ) ; } 
function getUsedSelectors ( page , css ) { let usedSelectors = [ ] ; css . walkRules ( ( rule ) => { usedSelectors = _ . concat ( usedSelectors , rule . selectors . map ( dePseudify ) ) ; } ) ; return jsdom . findAll ( page , usedSelectors ) ; } 
function getAllSelectors ( css ) { let selectors = [ ] ; css . walkRules ( ( rule ) => { selectors = _ . concat ( selectors , rule . selector ) ; } ) ; return selectors ; } 
function filterUnusedRules ( pages , css , ignore , usedSelectors ) { let ignoreNextRule = false , ignoreNextRulesStart = false , unusedRules = [ ] , unusedRuleSelectors , usedRuleSelectors ; ignoreNextRule = false ; css . walk ( ( rule ) => { if ( rule . type === 'comment' ) { if ( / ^!?\s?uncss:ignore start\s?$ / . test ( rule . text ) ) { 
function parseUncssrc ( filename ) { let options = JSON . parse ( fs . readFileSync ( filename , 'utf-8' ) ) ; options . ignore = options . ignore ? options . ignore . map ( strToRegExp ) : undefined ; options . ignoreSheets = options . ignoreSheets ? options . ignoreSheets . map ( strToRegExp ) : undefined ; return options ; } 
function parsePaths ( source , stylesheets , options ) { return stylesheets . map ( ( sheet ) => { let sourceProtocol ; const isLocalFile = sheet . substr ( 0 , 5 ) === 'file:' ; if ( sheet . substr ( 0 , 4 ) === 'http' ) { return sheet ; } if ( isURL ( source ) && ! isLocalFile ) { sourceProtocol = url . parse ( source ) . protocol ; if ( sheet . substr ( 0 , 2 ) === '//' ) { return sourceProtocol ? sourceProtocol + sheet : 'http:' + sheet ; } return url . resolve ( source , sheet ) ; } sheet = sheet . split ( '?' ) [ 0 ] . split ( '#' ) [ 0 ] ; if ( isLocalFile ) { sheet = url . parse ( sheet ) . path . replace ( '%20' , ' ' ) ; sheet = isWindows ( ) ? sheet . substring ( 1 ) : sheet ; if ( options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } sheet = path . relative ( path . join ( path . dirname ( source ) ) , sheet ) ; } if ( sheet [ 0 ] === '/' && options . htmlroot ) { return path . join ( options . htmlroot , sheet ) ; } else if ( isHTML ( source ) ) { return path . join ( options . csspath , sheet ) ; } return path . join ( path . dirname ( source ) , options . csspath , sheet ) ; } ) ; } 
function readStylesheets ( files , outputBanner ) { return Promise . all ( files . map ( ( filename ) => { if ( isURL ( filename ) ) { return new Promise ( ( resolve , reject ) => { request ( { url : filename , headers : { 'User-Agent' : 'UnCSS' } } , ( err , response , body ) => { if ( err ) { return reject ( err ) ; } return resolve ( body ) ; } ) ; } ) ; } else if ( fs . existsSync ( filename ) ) { return new Promise ( ( resolve , reject ) => { fs . readFile ( filename , 'utf-8' , ( err , contents ) => { if ( err ) { return reject ( err ) ; } return resolve ( contents ) ; } ) ; } ) ; } throw new Error ( ` ${ path . join ( process . cwd ( ) , filename ) } ` ) ; } ) ) . then ( ( res ) => { 
function getHTML ( files , options ) { if ( _ . isString ( files ) ) { files = [ files ] ; } files = _ . flatten ( files . map ( ( file ) => { if ( ! isURL ( file ) && ! isHTML ( file ) ) { return glob . sync ( file ) ; } return file ; } ) ) ; if ( ! files . length ) { return Promise . reject ( new Error ( 'UnCSS: no HTML files found' ) ) ; } 
function getStylesheets ( files , options , pages ) { if ( options . stylesheets && options . stylesheets . length ) { return Promise . resolve ( [ files , options , pages , [ options . stylesheets ] ] ) ; } return Promise . all ( pages . map ( ( page ) => jsdom . getStylesheets ( page , options ) ) ) . then ( ( stylesheets ) => [ files , options , pages , stylesheets ] ) ; } 
function getCSS ( [ files , options , pages , stylesheets ] ) { if ( options . ignoreSheets . length ) { stylesheets = stylesheets . map ( ( arr ) => { return arr . filter ( ( sheet ) => { return _ . every ( options . ignoreSheets , ( ignore ) => { if ( _ . isRegExp ( ignore ) ) { return ! ignore . test ( sheet ) ; } return sheet !== ignore ; } ) ; } ) ; } ) ; } if ( _ . flatten ( stylesheets ) . length ) { stylesheets = _ . chain ( stylesheets ) . map ( ( sheets , i ) => utility . parsePaths ( files [ i ] , sheets , options ) ) . flatten ( ) . uniq ( ) . value ( ) ; } else { stylesheets = [ ] ; } return Promise . all ( [ options , pages , utility . readStylesheets ( stylesheets , options . banner ) ] ) ; } 
function processWithTextApi ( [ options , pages , stylesheets ] ) { if ( options . raw ) { if ( _ . isString ( options . raw ) ) { stylesheets . push ( options . raw ) ; } else { throw new Error ( 'UnCSS: options.raw - expected a string' ) ; } } if ( ! _ . flatten ( stylesheets ) . length ) { throw new Error ( 'UnCSS: no stylesheets found' ) ; } const cssStr = stylesheets . join ( ' \n' ) ; let pcss , report ; try { pcss = postcss . parse ( cssStr ) ; } catch ( err ) { throw utility . parseErrorMessage ( err , cssStr ) ; } return uncss ( pages , pcss , options . ignore ) . then ( ( [ css , rep ] ) => { let newCssStr = '' ; postcss . stringify ( css , ( result ) => { newCssStr += result ; } ) ; if ( options . report ) { report = { original : cssStr , selectors : rep } ; } return [ newCssStr , report ] ; } ) ; } 
function init ( files , options , callback ) { if ( _ . isFunction ( options ) ) { callback = options ; options = { } ; } else if ( ! _ . isFunction ( callback ) ) { throw new TypeError ( 'UnCSS: expected a callback' ) ; } if ( options . uncssrc ) { try { options = _ . merge ( utility . parseUncssrc ( options . uncssrc ) , options ) ; } catch ( err ) { if ( err instanceof SyntaxError ) { callback ( new SyntaxError ( 'UnCSS: uncssrc file is invalid JSON.' ) ) ; return ; } callback ( err ) ; return ; } } options = _ . defaults ( options , { csspath : '' , ignore : [ ] , media : [ ] , timeout : 0 , report : false , ignoreSheets : [ ] , html : files , banner : true , 
function fromSource ( src , options ) { const config = { features : { FetchExternalResources : [ 'script' ] , ProcessExternalResources : [ 'script' ] } , virtualConsole : jsdom . createVirtualConsole ( ) . sendTo ( console ) , userAgent : options . userAgent } ; 
function getStylesheets ( window , options ) { if ( Array . isArray ( options . media ) === false ) { options . media = [ options . media ] ; } const media = _ . union ( [ '' , 'all' , 'screen' ] , options . media ) ; const elements = window . document . querySelectorAll ( 'link[rel="stylesheet"]' ) ; return Array . prototype . map . call ( elements , ( link ) => ( { href : link . getAttribute ( 'href' ) , media : link . getAttribute ( 'media' ) || '' } ) ) . filter ( ( sheet ) => media . indexOf ( sheet . media ) !== - 1 ) . map ( ( sheet ) => sheet . href ) ; } 
function findAll ( window , sels ) { const document = window . document ; 
function openDB ( name , version , { blocked , upgrade , blocking } = { } ) { const request = indexedDB . open ( name , version ) ; const openPromise = wrap ( request ) ; if ( upgrade ) { request . addEventListener ( 'upgradeneeded' , ( event ) => { upgrade ( wrap ( request . result ) , event . oldVersion , event . newVersion , wrap ( request . transaction ) ) ; } ) ; } if ( blocked ) request . addEventListener ( 'blocked' , ( ) => blocked ( ) ) ; if ( blocking ) openPromise . then ( db => db . addEventListener ( 'versionchange' , blocking ) ) ; return openPromise ; } 
function deleteDB ( name , { blocked } = { } ) { const request = indexedDB . deleteDatabase ( name ) ; if ( blocked ) request . addEventListener ( 'blocked' , ( ) => blocked ( ) ) ; return wrap ( request ) . then ( ( ) => undefined ) ; } 
function getCursorAdvanceMethods ( ) { return cursorAdvanceMethods || ( cursorAdvanceMethods = [ IDBCursor . prototype . advance , IDBCursor . prototype . continue , IDBCursor . prototype . continuePrimaryKey , ] ) ; } 
function resolveOrReject ( data ) { if ( data . filename ) { console . warn ( data ) ; } if ( ! options . async ) { head . removeChild ( style ) ; } } 
function ( t ) { return function ( ) { var obj = Object . create ( t . prototype ) ; t . apply ( obj , Array . prototype . slice . call ( arguments , 0 ) ) ; return obj ; } ; } 
function addReplacementIntoPath ( beginningPath , addPath , replacedElement , originalSelector ) { var newSelectorPath , lastSelector , newJoinedSelector ; 
function addAllReplacementsIntoPath ( beginningPath , addPaths , replacedElement , originalSelector , result ) { var j ; for ( j = 0 ; j < beginningPath . length ; j ++ ) { var newSelectorPath = addReplacementIntoPath ( beginningPath [ j ] , addPaths , replacedElement , originalSelector ) ; result . push ( newSelectorPath ) ; } return result ; } 
function replaceParentSelector ( paths , context , inSelector ) { 
function ( value , unit ) { this . value = parseFloat ( value ) ; if ( isNaN ( this . value ) ) { throw new Error ( 'Dimension is not a number.' ) ; } this . unit = ( unit && unit instanceof Unit ) ? unit : new Unit ( unit ? [ unit ] : undefined ) ; this . setParent ( this . unit , this ) ; } 
function Parser ( context , imports , fileInfo ) { var parsers , parserInput = getParserInput ( ) ; function error ( msg , type ) { throw new LessError ( { index : parserInput . i , filename : fileInfo . filename , type : type || 'Syntax' , message : msg } , imports ) ; } function expect ( arg , msg ) { * Used after initial parsing to create nodes on the fly * * @param {String} str - string to parse * @param {Array} parseList - array of parsers to run input through e.g. ["value", "important"] * @param {Number} currentIndex - start number to begin indexing * @param {Object} fileInfo - fileInfo to attach to created nodes */ function parseNode ( str , parseList , currentIndex , fileInfo , callback ) { var result , returnNodes = [ ] ; var parser = parserInput ; try { parser . start ( str , false , function fail ( msg , index ) { callback ( { message : msg , index : index + currentIndex } ) ; } ) ; for ( var x = 0 , p , i ; ( p = parseList [ x ] ) ; x ++ ) { i = parser . i ; result = parsers [ p ] ( ) ; if ( result ) { result . _index = i + currentIndex ; result . _fileInfo = fileInfo ; returnNodes . push ( result ) ; } else { returnNodes . push ( null ) ; } } var endInfo = parser . end ( ) ; if ( endInfo . isFinished ) { callback ( null , returnNodes ) ; } else { callback ( true , null ) ; } } catch ( e ) { throw new LessError ( { index : e . index + currentIndex , message : e . message } , imports , fileInfo . filename ) ; } } but it's quite tricky since it relies on all these `parsers` and `expect` available only here */ return { alpha : f ( parsers . ieAlpha , true ) , boolean : f ( condition ) , 'if' : f ( condition ) } [ name . toLowerCase ( ) ] ; function f ( parse , stop ) { return { parse : parse , // parsing function stop : stop // when true - stop after parse() and return its result, // otherwise continue for plain args } ; } function condition ( ) { return [ expect ( parsers . condition , 'expected condition' ) ] ; } } , arguments : function ( prevArgs ) { var argsComma = prevArgs || [ ] , argsSemiColon = [ ] , isSemiColonSeparated , value ; parserInput . save ( ) ; while ( true ) { if ( prevArgs ) { prevArgs = false ; } else { value = parsers . detachedRuleset ( ) || this . assignment ( ) || parsers . expression ( ) ; if ( ! value ) { break ; } if ( value . value && value . value . length == 1 ) { value = value . value [ 0 ] ; } argsComma . push ( value ) ; } if ( parserInput . $char ( ',' ) ) { continue ; } if ( parserInput . $char ( ';' ) || isSemiColonSeparated ) { isSemiColonSeparated = true ; value = ( argsComma . length < 1 ) ? argsComma [ 0 ] : new tree . Value ( argsComma ) ; argsSemiColon . push ( value ) ; argsComma = [ ] ; } } parserInput . forget ( ) ; return isSemiColonSeparated ? argsSemiColon : argsComma ; } , literal : function ( ) { return this . dimension ( ) || this . color ( ) || this . quoted ( ) || this . unicodeDescriptor ( ) ; } , // Assignments are argument entities for calls. // They are present in ie filter properties as shown below. // // filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* ) // assignment : function ( ) { var key , value ; parserInput . save ( ) ; key = parserInput . $re ( / ^\w+(?=\s?=) / i ) ; if ( ! key ) { parserInput . restore ( ) ; return ; } if ( ! parserInput . $char ( '=' ) ) { parserInput . restore ( ) ; return ; } value = parsers . entity ( ) ; if ( value ) { parserInput . forget ( ) ; return new ( tree . Assignment ) ( key , value ) ; } else { parserInput . restore ( ) ; } } , // // Parse url() tokens // // We use a specific rule for urls, because they don't really behave like * Matching elements for mixins * (Start with . or # and can have > ) */ elements : function ( ) { var elements , e , c , elem , elemIndex , re = / ^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+ / ; while ( true ) { elemIndex = parserInput . i ; e = parserInput . $re ( re ) ; if ( ! e ) { break ; } elem = new ( tree . Element ) ( c , e , false , elemIndex , fileInfo ) ; if ( elements ) { elements . push ( elem ) ; } else { elements = [ elem ] ; } c = parserInput . $char ( '>' ) ; } return elements ; } , args : function ( isCall ) { var entities = parsers . entities , returner = { args : null , variadic : false } , expressions = [ ] , argsSemiColon = [ ] , argsComma = [ ] , isSemiColonSeparated , expressionContainsNamed , name , nameLoop , value , arg , expand , hasSep = true ; parserInput . save ( ) ; while ( true ) { if ( isCall ) { arg = parsers . detachedRuleset ( ) || parsers . expression ( ) ; } else { parserInput . commentStore . length = 0 ; if ( parserInput . $str ( '...' ) ) { returner . variadic = true ; if ( parserInput . $char ( ';' ) && ! isSemiColonSeparated ) { isSemiColonSeparated = true ; } ( isSemiColonSeparated ? argsSemiColon : argsComma ) . push ( { variadic : true } ) ; break ; } arg = entities . variable ( ) || entities . property ( ) || entities . literal ( ) || entities . keyword ( ) || this . call ( true ) ; } if ( ! arg || ! hasSep ) { break ; } nameLoop = null ; if ( arg . throwAwayComments ) { arg . throwAwayComments ( ) ; } value = arg ; var val = null ; if ( isCall ) { * DR args currently only implemented for each() function, and not * yet settable as `@dr: #(@arg) {}` * This should be done when DRs are merged with mixins. * See: https: */ argInfo = this . mixin . args ( false ) ; params = argInfo . args ; variadic = argInfo . variadic ; if ( ! parserInput . $char ( ')' ) ) { parserInput . restore ( ) ; return ; } } var blockRuleset = this . blockRuleset ( ) ; if ( blockRuleset ) { parserInput . forget ( ) ; if ( params ) { return new tree . mixin . Definition ( null , params , blockRuleset , null , variadic ) ; } return new tree . DetachedRuleset ( blockRuleset ) ; } parserInput . restore ( ) ; } , * Used for custom properties, at-rules, and variables (as fallback) * Parses almost anything inside of {} [] () "" blocks * until it reaches outer-most tokens. * * First, it will try to parse comments and entities to reach * the end. This is mostly like the Expression parser except no * math is allowed. */ permissiveValue : function ( untilTokens ) { var i , e , done , value , tok = untilTokens || ';' , index = parserInput . i , result = [ ] ; function testCurrentChar ( ) { var char = parserInput . currentChar ( ) ; if ( typeof tok === 'string' ) { return char === tok ; } else { return tok . test ( char ) ; } } if ( testCurrentChar ( ) ) { return ; } value = [ ] ; do { e = this . comment ( ) ; if ( e ) { value . push ( e ) ; continue ; } e = this . entity ( ) ; if ( e ) { value . push ( e ) ; } } while ( e ) ; done = testCurrentChar ( ) ; if ( value . length > 0 ) { value = new ( tree . Expression ) ( value ) ; if ( done ) { return value ; } else { result . push ( value ) ; } 
function expectChar ( arg , msg ) { if ( parserInput . $char ( arg ) ) { return arg ; } error ( msg || 'expected \'' + arg + '\' got \'' + parserInput . currentChar ( ) + '\'' ) ; } 
function parseNode ( str , parseList , currentIndex , fileInfo , callback ) { var result , returnNodes = [ ] ; var parser = parserInput ; try { parser . start ( str , false , function fail ( msg , index ) { callback ( { message : msg , index : index + currentIndex } ) ; } ) ; for ( var x = 0 , p , i ; ( p = parseList [ x ] ) ; x ++ ) { i = parser . i ; result = parsers [ p ] ( ) ; if ( result ) { result . _index = i + currentIndex ; result . _fileInfo = fileInfo ; returnNodes . push ( result ) ; } else { returnNodes . push ( null ) ; } } var endInfo = parser . end ( ) ; if ( endInfo . isFinished ) { callback ( null , returnNodes ) ; } else { callback ( true , null ) ; } } catch ( e ) { throw new LessError ( { index : e . index + currentIndex , message : e . message } , imports , fileInfo . filename ) ; } } 
function ( str , callback , additionalData ) { var root , error = null , globalVars , modifyVars , ignored , preText = '' ; globalVars = ( additionalData && additionalData . globalVars ) ? Parser . serializeVars ( additionalData . globalVars ) + '\n' : '' ; modifyVars = ( additionalData && additionalData . modifyVars ) ? '\n' + Parser . serializeVars ( additionalData . modifyVars ) : '' ; if ( context . pluginManager ) { var preProcessors = context . pluginManager . getPreProcessors ( ) ; for ( var i = 0 ; i < preProcessors . length ; i ++ ) { str = preProcessors [ i ] . process ( str , { context : context , imports : imports , fileInfo : fileInfo } ) ; } } if ( globalVars || ( additionalData && additionalData . banner ) ) { preText = ( ( additionalData && additionalData . banner ) ? additionalData . banner : '' ) + globalVars ; ignored = imports . contentsIgnoredChars ; ignored [ fileInfo . filename ] = ignored [ fileInfo . filename ] || 0 ; ignored [ fileInfo . filename ] += preText . length ; } str = str . replace ( / \r\n? / g , '\n' ) ; 
function ( ) { var mixin = this . mixin , root = [ ] , node ; while ( true ) { while ( true ) { node = this . comment ( ) ; if ( ! node ) { break ; } root . push ( node ) ; } 
function ( ) { if ( parserInput . commentStore . length ) { var comment = parserInput . commentStore . shift ( ) ; return new ( tree . Comment ) ( comment . text , comment . isLineComment , comment . index , fileInfo ) ; } } 
function ( forceEscaped ) { var str , index = parserInput . i , isEscaped = false ; parserInput . save ( ) ; if ( parserInput . $char ( '~' ) ) { isEscaped = true ; } else if ( forceEscaped ) { parserInput . restore ( ) ; return ; } str = parserInput . $quoted ( ) ; if ( ! str ) { parserInput . restore ( ) ; return ; } parserInput . forget ( ) ; return new ( tree . Quoted ) ( str . charAt ( 0 ) , str . substr ( 1 , str . length - 2 ) , isEscaped , index , fileInfo ) ; } 
function ( ) { var k = parserInput . $char ( '%' ) || parserInput . $re ( / ^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]? / ) ; if ( k ) { return tree . Color . fromKeyword ( k ) || new ( tree . Keyword ) ( k ) ; } } 
function ( ) { var name , args , func , index = parserInput . i ; 
function ( name ) { return { alpha : f ( parsers . ieAlpha , true ) , boolean : f ( condition ) , 'if' : f ( condition ) } [ name . toLowerCase ( ) ] ; function f ( parse , stop ) { return { parse : parse , 
function ( ) { var key , value ; parserInput . save ( ) ; key = parserInput . $re ( / ^\w+(?=\s?=) / i ) ; if ( ! key ) { parserInput . restore ( ) ; return ; } if ( ! parserInput . $char ( '=' ) ) { parserInput . restore ( ) ; return ; } value = parsers . entity ( ) ; if ( value ) { parserInput . forget ( ) ; return new ( tree . Assignment ) ( key , value ) ; } else { parserInput . restore ( ) ; } } 
function ( ) { var value , index = parserInput . i ; parserInput . autoCommentAbsorb = false ; if ( ! parserInput . $str ( 'url(' ) ) { parserInput . autoCommentAbsorb = true ; return ; } value = this . quoted ( ) || this . variable ( ) || this . property ( ) || parserInput . $re ( / ^(?:(?:\\[\(\)'"])|[^\(\)'"])+ / ) || '' ; parserInput . autoCommentAbsorb = true ; expectChar ( ')' ) ; return new ( tree . URL ) ( ( value . value != null || value instanceof tree . Variable || value instanceof tree . Property ) ? value : new ( tree . Anonymous ) ( value , index ) , index , fileInfo ) ; } 
function ( ) { var ch , name , index = parserInput . i ; parserInput . save ( ) ; if ( parserInput . currentChar ( ) === '@' && ( name = parserInput . $re ( / ^@@?[\w-]+ / ) ) ) { ch = parserInput . currentChar ( ) ; if ( ch === '(' || ch === '[' && ! parserInput . prevChar ( ) . match ( / ^\s / ) ) { 
function ( ) { var curly , index = parserInput . i ; if ( parserInput . currentChar ( ) === '@' && ( curly = parserInput . $re ( / ^@\{([\w-]+)\} / ) ) ) { return new ( tree . Variable ) ( '@' + curly [ 1 ] , index , fileInfo ) ; } } 
function ( ) { var name , index = parserInput . i ; if ( parserInput . currentChar ( ) === '$' && ( name = parserInput . $re ( / ^\$[\w-]+ / ) ) ) { return new ( tree . Property ) ( name , index , fileInfo ) ; } } 
function ( ) { var curly , index = parserInput . i ; if ( parserInput . currentChar ( ) === '$' && ( curly = parserInput . $re ( / ^\$\{([\w-]+)\} / ) ) ) { return new ( tree . Property ) ( '$' + curly [ 1 ] , index , fileInfo ) ; } } 
function ( ) { var rgb ; if ( parserInput . currentChar ( ) === '#' && ( rgb = parserInput . $re ( / ^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4}) / ) ) ) { return new ( tree . Color ) ( rgb [ 1 ] , undefined , rgb [ 0 ] ) ; } } 
function ( ) { if ( parserInput . peekNotNumeric ( ) ) { return ; } var value = parserInput . $re ( / ^([+-]?\d*\.?\d+)(%|[a-z_]+)? / i ) ; if ( value ) { return new ( tree . Dimension ) ( value [ 1 ] , value [ 2 ] ) ; } } 
function ( ) { var js , index = parserInput . i ; parserInput . save ( ) ; var escape = parserInput . $char ( '~' ) ; var jsQuote = parserInput . $char ( '`' ) ; if ( ! jsQuote ) { parserInput . restore ( ) ; return ; } js = parserInput . $re ( / ^[^`]*` / ) ; if ( js ) { parserInput . forget ( ) ; return new ( tree . JavaScript ) ( js . substr ( 0 , js . length - 1 ) , Boolean ( escape ) , index , fileInfo ) ; } parserInput . restore ( 'invalid javascript definition' ) ; } 
function ( parsedName ) { var lookups , important , i = parserInput . i , inValue = ! ! parsedName , name = parsedName ; parserInput . save ( ) ; if ( name || ( parserInput . currentChar ( ) === '@' && ( name = parserInput . $re ( / ^(@[\w-]+)(\(\s*\))? / ) ) ) ) { lookups = this . mixin . ruleLookups ( ) ; if ( ! lookups && ( ( inValue && parserInput . $str ( '()' ) !== '()' ) || ( name [ 2 ] !== '()' ) ) ) { parserInput . restore ( 'Missing \'[...]\' lookup in variable call' ) ; return ; } if ( ! inValue ) { name = name [ 1 ] ; } if ( lookups && parsers . important ( ) ) { important = true ; } var call = new tree . VariableCall ( name , i , fileInfo ) ; if ( ! inValue && parsers . end ( ) ) { parserInput . forget ( ) ; return call ; } else { parserInput . forget ( ) ; return new tree . NamespaceValue ( call , lookups , important , i , fileInfo ) ; } } parserInput . restore ( ) ; } 
function ( inValue , getLookup ) { var s = parserInput . currentChar ( ) , important = false , lookups , index = parserInput . i , elements , args , hasParens ; if ( s !== '.' && s !== '#' ) { return ; } parserInput . save ( ) ; 
function ( ) { var elements , e , c , elem , elemIndex , re = / ^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+ / ; while ( true ) { elemIndex = parserInput . i ; e = parserInput . $re ( re ) ; if ( ! e ) { break ; } elem = new ( tree . Element ) ( c , e , false , elemIndex , fileInfo ) ; if ( elements ) { elements . push ( elem ) ; } else { elements = [ elem ] ; } c = parserInput . $char ( '>' ) ; } return elements ; } 
function ( ) { var name , params = [ ] , match , ruleset , cond , variadic = false ; if ( ( parserInput . currentChar ( ) !== '.' && parserInput . currentChar ( ) !== '#' ) || parserInput . peek ( / ^[^{]*\} / ) ) { return ; } parserInput . save ( ) ; match = parserInput . $re ( / ^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\( / ) ; if ( match ) { name = match [ 1 ] ; var argInfo = this . args ( false ) ; params = argInfo . args ; variadic = argInfo . variadic ; 
function ( ) { var entities = this . entities ; return this . comment ( ) || entities . literal ( ) || entities . variable ( ) || entities . url ( ) || entities . property ( ) || entities . call ( ) || entities . keyword ( ) || this . mixin . call ( true ) || entities . javascript ( ) ; } 
function ( ) { var value ; 
function ( ) { var e , c , v , index = parserInput . i ; c = this . combinator ( ) ; e = parserInput . $re ( / ^(?:\d+\.\d+|\d+)% / ) || parserInput . $re ( / ^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+ / ) || parserInput . $char ( '*' ) || parserInput . $char ( '&' ) || this . attribute ( ) || parserInput . $re ( / ^\([^&()@]+\) / ) || parserInput . $re ( / ^[\.#:](?=@) / ) || this . entities . variableCurly ( ) ; if ( ! e ) { parserInput . save ( ) ; if ( parserInput . $char ( '(' ) ) { if ( ( v = this . selector ( false ) ) && parserInput . $char ( ')' ) ) { e = new ( tree . Paren ) ( v ) ; parserInput . forget ( ) ; } else { parserInput . restore ( 'Missing closing \')\'' ) ; } } else { parserInput . forget ( ) ; } } if ( e ) { return new ( tree . Element ) ( c , e , e instanceof tree . Variable , index , fileInfo ) ; } } 
function ( ) { var c = parserInput . currentChar ( ) ; if ( c === '/' ) { parserInput . save ( ) ; var slashedCombinator = parserInput . $re ( / ^\/[a-z]+\/ / i ) ; if ( slashedCombinator ) { parserInput . forget ( ) ; return new ( tree . Combinator ) ( slashedCombinator ) ; } parserInput . restore ( ) ; } if ( c === '>' || c === '+' || c === '~' || c === '|' || c === '^' ) { parserInput . i ++ ; if ( c === '^' && parserInput . currentChar ( ) === '^' ) { c = '^^' ; parserInput . i ++ ; } while ( parserInput . isWhitespace ( ) ) { parserInput . i ++ ; } return new ( tree . Combinator ) ( c ) ; } else if ( parserInput . isWhitespace ( - 1 ) ) { return new ( tree . Combinator ) ( ' ' ) ; } else { return new ( tree . Combinator ) ( null ) ; } } 
function ( isLess ) { var index = parserInput . i , elements , extendList , c , e , allExtends , when , condition ; isLess = isLess !== false ; while ( ( isLess && ( extendList = this . extend ( ) ) ) || ( isLess && ( when = parserInput . $str ( 'when' ) ) ) || ( e = this . element ( ) ) ) { if ( when ) { condition = expect ( this . conditions , 'expected condition' ) ; } else if ( condition ) { error ( 'CSS guard can only be used at the end of selector' ) ; } else if ( extendList ) { if ( allExtends ) { allExtends = allExtends . concat ( extendList ) ; } else { allExtends = extendList ; } } else { if ( allExtends ) { error ( 'Extend can only be used at the end of selector' ) ; } c = parserInput . currentChar ( ) ; if ( elements ) { elements . push ( e ) ; } else { elements = [ e ] ; } e = null ; } if ( c === '{' || c === '}' || c === ';' || c === ',' || c === ')' ) { break ; } } if ( elements ) { return new ( tree . Selector ) ( elements , allExtends , condition , index , fileInfo ) ; } if ( allExtends ) { error ( 'Extend must be used to extend a selector, it cannot be used on its own' ) ; } } 
function ( ) { var selectors , rules , debugInfo ; parserInput . save ( ) ; if ( context . dumpLineNumbers ) { debugInfo = getDebugInfo ( parserInput . i ) ; } selectors = this . selectors ( ) ; if ( selectors && ( rules = this . block ( ) ) ) { parserInput . forget ( ) ; var ruleset = new ( tree . Ruleset ) ( selectors , rules , context . strictImports ) ; if ( context . dumpLineNumbers ) { ruleset . debugInfo = debugInfo ; } return ruleset ; } else { parserInput . restore ( ) ; } } 
function ( untilTokens ) { var i , e , done , value , tok = untilTokens || ';' , index = parserInput . i , result = [ ] ; function testCurrentChar ( ) { var char = parserInput . currentChar ( ) ; if ( typeof tok === 'string' ) { return char === tok ; } else { return tok . test ( char ) ; } } if ( testCurrentChar ( ) ) { return ; } value = [ ] ; do { e = this . comment ( ) ; if ( e ) { value . push ( e ) ; continue ; } e = this . entity ( ) ; if ( e ) { value . push ( e ) ; } } while ( e ) ; done = testCurrentChar ( ) ; if ( value . length > 0 ) { value = new ( tree . Expression ) ( value ) ; if ( done ) { return value ; } else { result . push ( value ) ; } 
function ( ) { var path , features , index = parserInput . i ; var dir = parserInput . $re ( / ^@import?\s+ / ) ; if ( dir ) { var options = ( dir ? this . importOptions ( ) : null ) || { } ; if ( ( path = this . entities . quoted ( ) || this . entities . url ( ) ) ) { features = this . mediaFeatures ( ) ; if ( ! parserInput . $char ( ';' ) ) { parserInput . i = index ; error ( 'missing semi-colon or unrecognised media features on import' ) ; } features = features && new ( tree . Value ) ( features ) ; return new ( tree . Import ) ( path , features , options , index , fileInfo ) ; } else { parserInput . i = index ; error ( 'malformed import statement' ) ; } } } 
function ( ) { var path , args , options , index = parserInput . i , dir = parserInput . $re ( / ^@plugin?\s+ / ) ; if ( dir ) { args = this . pluginArgs ( ) ; if ( args ) { options = { pluginArgs : args , isPlugin : true } ; } else { options = { isPlugin : true } ; } if ( ( path = this . entities . quoted ( ) || this . entities . url ( ) ) ) { if ( ! parserInput . $char ( ';' ) ) { parserInput . i = index ; error ( 'missing semi-colon on @plugin' ) ; } return new ( tree . Import ) ( path , null , options , index , fileInfo ) ; } else { parserInput . i = index ; error ( 'malformed @plugin statement' ) ; } } } 
function ( ) { var index = parserInput . i , name , value , rules , nonVendorSpecificName , hasIdentifier , hasExpression , hasUnknown , hasBlock = true , isRooted = true ; if ( parserInput . currentChar ( ) !== '@' ) { return ; } value = this [ 'import' ] ( ) || this . plugin ( ) || this . media ( ) ; if ( value ) { return value ; } parserInput . save ( ) ; name = parserInput . $re ( / ^@[a-z-]+ / ) ; if ( ! name ) { return ; } nonVendorSpecificName = name ; if ( name . charAt ( 1 ) == '-' && name . indexOf ( '-' , 2 ) > 0 ) { nonVendorSpecificName = '@' + name . slice ( name . indexOf ( '-' , 2 ) + 1 ) ; } switch ( nonVendorSpecificName ) { case '@charset' : hasIdentifier = true ; hasBlock = false ; break ; case '@namespace' : hasExpression = true ; hasBlock = false ; break ; case '@keyframes' : case '@counter-style' : hasIdentifier = true ; break ; case '@document' : case '@supports' : hasUnknown = true ; isRooted = false ; break ; default : hasUnknown = true ; break ; } parserInput . commentStore . length = 0 ; if ( hasIdentifier ) { value = this . entity ( ) ; if ( ! value ) { error ( 'expected ' + name + ' identifier' ) ; } } else if ( hasExpression ) { value = this . expression ( ) ; if ( ! value ) { error ( 'expected ' + name + ' expression' ) ; } } else if ( hasUnknown ) { value = this . permissiveValue ( / ^[{;] / ) ; hasBlock = ( parserInput . currentChar ( ) === '{' ) ; if ( ! value ) { if ( ! hasBlock && parserInput . currentChar ( ) !== ';' ) { error ( name + ' rule is missing block or ending semi-colon' ) ; } } else if ( ! value . value ) { value = null ; } } if ( hasBlock ) { rules = this . blockRuleset ( ) ; } if ( rules || ( ! hasBlock && value && parserInput . $char ( ';' ) ) ) { parserInput . forget ( ) ; return new ( tree . AtRule ) ( name , value , rules , index , fileInfo , context . dumpLineNumbers ? getDebugInfo ( index ) : null , isRooted ) ; } parserInput . restore ( 'at-rule options not recognised' ) ; } 
function ( ) { var e , expressions = [ ] , index = parserInput . i ; do { e = this . expression ( ) ; if ( e ) { expressions . push ( e ) ; if ( ! parserInput . $char ( ',' ) ) { break ; } } } while ( e ) ; if ( expressions . length > 0 ) { return new ( tree . Value ) ( expressions , index ) ; } } 
function ( ) { var entities = this . entities , negate ; if ( parserInput . peek ( / ^-[@\$\(] / ) ) { negate = parserInput . $char ( '-' ) ; } var o = this . sub ( ) || entities . dimension ( ) || entities . color ( ) || entities . variable ( ) || entities . property ( ) || entities . call ( ) || entities . quoted ( true ) || entities . colorKeyword ( ) || entities . mixinLookup ( ) ; if ( negate ) { o . parensInOp = true ; o = new ( tree . Negative ) ( o ) ; } return o ; } 
function ( ) { var entities = [ ] , e , delim , index = parserInput . i ; do { e = this . comment ( ) ; if ( e ) { entities . push ( e ) ; continue ; } e = this . addition ( ) || this . entity ( ) ; if ( e ) { entities . push ( e ) ; 
function ( color1 , color2 , weight ) { if ( ! color1 . toHSL || ! color2 . toHSL ) { console . log ( color2 . type ) ; console . dir ( color2 ) ; } if ( ! weight ) { weight = new Dimension ( 50 ) ; } var p = weight . value / 100.0 ; var w = p * 2 - 1 ; var a = color1 . toHSL ( ) . a - color2 . toHSL ( ) . a ; var w1 = ( ( ( w * a == - 1 ) ? w : ( w + a ) / ( 1 + w * a ) ) + 1 ) / 2.0 ; var w2 = 1 - w1 ; var rgb = [ color1 . rgb [ 0 ] * w1 + color2 . rgb [ 0 ] * w2 , color1 . rgb [ 1 ] * w1 + color2 . rgb [ 1 ] * w2 , color1 . rgb [ 2 ] * w1 + color2 . rgb [ 2 ] * w2 ] ; var alpha = color1 . alpha * p + color2 . alpha * ( 1 - p ) ; return new Color ( rgb , alpha ) ; } 
function ( name , args , index , currentFileInfo ) { this . name = name ; this . args = args ; this . calc = name === 'calc' ; this . _index = index ; this . _fileInfo = currentFileInfo ; } 
function ( less ) { this . less = less ; this . require = function ( prefix ) { prefix = path . dirname ( prefix ) ; return function ( id ) { var str = id . substr ( 0 , 2 ) ; if ( str === '..' || str === './' ) { return require ( path . join ( prefix , id ) ) ; } else { return require ( id ) ; } } ; } ; } 
function ( path , features , options , index , currentFileInfo , visibilityInfo ) { this . options = options ; this . _index = index ; this . _fileInfo = currentFileInfo ; this . path = path ; this . features = features ; this . allowRoot = true ; if ( this . options . less !== undefined || this . options . inline ) { this . css = ! this . options . less || this . options . inline ; } else { var pathValue = this . getPath ( ) ; if ( pathValue && / [#\.\&\?]css([\?;].*)?$ / . test ( pathValue ) ) { this . css = true ; } } this . copyVisibilityInfo ( visibilityInfo ) ; this . setParent ( this . features , this ) ; this . setParent ( this . path , this ) ; } 
function ( less , context , rootFileInfo ) { this . less = less ; this . rootFilename = rootFileInfo . filename ; this . paths = context . paths || [ ] ; 
function hasFakeRuleset ( atRuleNode ) { var bodyRules = atRuleNode . rules ; return bodyRules . length === 1 && ( ! bodyRules [ 0 ] . paths || bodyRules [ 0 ] . paths . length === 0 ) ; } 
function bind ( func , thisArg ) { var curryArgs = Array . prototype . slice . call ( arguments , 2 ) ; return function ( ) { var args = curryArgs . concat ( Array . prototype . slice . call ( arguments , 0 ) ) ; return func . apply ( thisArg , args ) ; } ; } 
function ( less ) { this . less = less ; this . visitors = [ ] ; this . preProcessors = [ ] ; this . postProcessors = [ ] ; this . installedPlugins = [ ] ; this . fileManagers = [ ] ; this . iterator = - 1 ; this . pluginCache = { } ; this . Loader = new less . PluginLoader ( less ) ; } 
function ( rgb , a , originalForm ) { var self = this ; 
function getNodeTransitions ( oldData , nextData ) { const oldDataKeyed = oldData && getKeyedData ( oldData ) ; const nextDataKeyed = nextData && getKeyedData ( nextData ) ; return { entering : oldDataKeyed && getKeyedDataDifference ( nextDataKeyed , oldDataKeyed ) , exiting : nextDataKeyed && getKeyedDataDifference ( oldDataKeyed , nextDataKeyed ) } ; } 
function getInitialTransitionState ( oldChildren , nextChildren ) { let nodesWillExit = false ; let nodesWillEnter = false ; const getTransition = ( oldChild , newChild ) => { if ( ! newChild || oldChild . type !== newChild . type ) { return { } ; } const { entering , exiting } = getNodeTransitions ( getChildData ( oldChild ) , getChildData ( newChild ) ) || { } ; nodesWillExit = nodesWillExit || ! ! exiting ; nodesWillEnter = nodesWillEnter || ! ! entering ; return { entering : entering || false , exiting : exiting || false } ; } ; const getTransitionsFromChildren = ( old , next ) => { return old . map ( ( child , idx ) => { if ( child && child . props && child . props . children && next [ idx ] ) { return getTransitionsFromChildren ( React . Children . toArray ( old [ idx ] . props . children ) , React . Children . toArray ( next [ idx ] . props . children ) ) ; } 
function getChildBeforeLoad ( animate , child , data , cb ) { animate = assign ( { } , animate , { onEnd : cb } ) ; if ( animate && animate . onLoad && ! animate . onLoad . duration ) { return { animate , data } ; } const before = animate . onLoad && animate . onLoad . before ? animate . onLoad . before : identity ; 
function getChildOnLoad ( animate , data , cb ) { animate = assign ( { } , animate , { onEnd : cb } ) ; if ( animate && animate . onLoad && ! animate . onLoad . duration ) { return { animate , data } ; } const after = animate . onLoad && animate . onLoad . after ? animate . onLoad . after : identity ; 
function getChildPropsOnExit ( animate , child , data , exitingNodes , cb ) { 
function getChildPropsBeforeEnter ( animate , child , data , enteringNodes , cb ) { if ( enteringNodes ) { 
function getChildPropsOnEnter ( animate , data , enteringNodes , cb ) { 
function getTransitionPropsFactory ( props , state , setState ) { const nodesWillExit = state && state . nodesWillExit ; const nodesWillEnter = state && state . nodesWillEnter ; const nodesShouldEnter = state && state . nodesShouldEnter ; const nodesShouldLoad = state && state . nodesShouldLoad ; const nodesDoneLoad = state && state . nodesDoneLoad ; const childrenTransitions = ( state && state . childrenTransitions ) || [ ] ; const transitionDurations = { enter : props . animate && props . animate . onEnter && props . animate . onEnter . duration , exit : props . animate && props . animate . onExit && props . animate . onExit . duration , load : props . animate && props . animate . onLoad && props . animate . onLoad . duration , move : props . animate && props . animate . duration } ; const onLoad = ( child , data , animate ) => { if ( nodesShouldLoad ) { return getChildOnLoad ( animate , data , ( ) => { setState ( { nodesShouldLoad : false , nodesDoneLoad : true } ) ; } ) ; } return getChildBeforeLoad ( animate , child , data , ( ) => { setState ( { nodesDoneLoad : true } ) ; } ) ; } ; 
function getCartesianRange ( props , axis ) { 
function omit ( originalObject , keys = [ ] ) { 
function toNewName ( scale ) { 
function getCalculatedProps ( props , childComponents ) { const role = "group" ; props = Helpers . modifyProps ( props , fallbackProps , role ) ; const style = Wrapper . getStyle ( props . theme , props . style , role ) ; const { offset , colorScale , color , polar , horizontal } = props ; const categories = Wrapper . getCategories ( props , childComponents ) ; const datasets = Wrapper . getDataFromChildren ( props ) ; const domain = { x : Wrapper . getDomain ( assign ( { } , props , { categories } ) , "x" , childComponents ) , y : Wrapper . getDomain ( assign ( { } , props , { categories } ) , "y" , childComponents ) } ; const range = { x : Helpers . getRange ( props , "x" ) , y : Helpers . getRange ( props , "y" ) } ; const baseScale = { x : Scale . getScaleFromProps ( props , "x" ) || Wrapper . getScale ( props , "x" ) , y : Scale . getScaleFromProps ( props , "y" ) || Wrapper . getScale ( props , "y" ) } ; const scale = { x : baseScale . x . domain ( domain . x ) . range ( props . horizontal ? range . y : range . x ) , y : baseScale . y . domain ( domain . y ) . range ( props . horizontal ? range . x : range . y ) } ; const origin = polar ? props . origin : Helpers . getPolarOrigin ( props ) ; const padding = Helpers . getPadding ( props ) ; return { datasets , categories , range , domain , horizontal , scale , style , colorScale , color , offset , origin , padding } ; } 
function cleanDomain ( domain , props , axis ) { const scaleType = Scale . getScaleType ( props , axis ) ; if ( scaleType !== "log" ) { return domain ; } const rules = ( dom ) => { const almostZero = dom [ 0 ] < 0 || dom [ 1 ] < 0 ? - 1 / Number . MAX_SAFE_INTEGER : 1 / Number . MAX_SAFE_INTEGER ; const domainOne = dom [ 0 ] === 0 ? almostZero : dom [ 0 ] ; const domainTwo = dom [ 1 ] === 0 ? almostZero : dom [ 1 ] ; return [ domainOne , domainTwo ] ; } ; return rules ( domain ) ; } 
function padDomain ( domain , props , axis ) { if ( ! props . domainPadding ) { return domain ; } const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; const padding = getDomainPadding ( props , axis ) ; if ( ! padding . left && ! padding . right ) { return domain ; } const min = Collection . getMinValue ( domain ) ; const max = Collection . getMaxValue ( domain ) ; const currentAxis = Helpers . getCurrentAxis ( axis , props . horizontal ) ; const range = Helpers . getRange ( props , currentAxis ) ; const rangeExtent = Math . abs ( range [ 0 ] - range [ 1 ] ) ; 
function createDomainFunction ( getDomainFromDataFunction , formatDomainFunction ) { getDomainFromDataFunction = isFunction ( getDomainFromDataFunction ) ? getDomainFromDataFunction : getDomainFromData ; formatDomainFunction = isFunction ( formatDomainFunction ) ? formatDomainFunction : formatDomain ; return ( props , axis ) => { const propsDomain = getDomainFromProps ( props , axis ) ; if ( propsDomain ) { return formatDomainFunction ( propsDomain , props , axis ) ; } const categories = Data . getCategories ( props , axis ) ; const domain = categories ? getDomainFromCategories ( props , axis , categories ) : getDomainFromDataFunction ( props , axis ) ; return domain ? formatDomainFunction ( domain , props , axis ) : undefined ; } ; } 
function formatDomain ( domain , props , axis ) { return cleanDomain ( padDomain ( domain , props , axis ) , props , axis ) ; } 
function getDomainFromCategories ( props , axis , categories ) { categories = categories || Data . getCategories ( props , axis ) ; const { polar , startAngle = 0 , endAngle = 360 } = props ; if ( ! categories ) { return undefined ; } const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; const stringArray = Collection . containsStrings ( categories ) ? Data . getStringsFromCategories ( props , axis ) : [ ] ; const stringMap = stringArray . length === 0 ? null : stringArray . reduce ( ( memo , string , index ) => { memo [ string ] = index + 1 ; return memo ; } , { } ) ; const categoryValues = stringMap ? categories . map ( ( value ) => stringMap [ value ] ) : categories ; const min = minDomain !== undefined ? minDomain : Collection . getMinValue ( categoryValues ) ; const max = maxDomain !== undefined ? maxDomain : Collection . getMaxValue ( categoryValues ) ; const categoryDomain = getDomainFromMinMax ( min , max ) ; return polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? getSymmetricDomain ( categoryDomain , categoryValues ) : categoryDomain ; } 
function getDomainFromData ( props , axis , dataset ) { dataset = dataset || Data . getData ( props ) ; const { polar , startAngle = 0 , endAngle = 360 } = props ; const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; if ( dataset . length < 1 ) { return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax ( minDomain , maxDomain ) : undefined ; } const min = minDomain !== undefined ? minDomain : getExtremeFromData ( dataset , axis , "min" ) ; const max = maxDomain !== undefined ? maxDomain : getExtremeFromData ( dataset , axis , "max" ) ; const domain = getDomainFromMinMax ( min , max ) ; return polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? getSymmetricDomain ( domain , getFlatData ( dataset , axis ) ) : domain ; } 
function getDomainFromMinMax ( min , max ) { const getSinglePointDomain = ( val ) => { 
function getDomainFromProps ( props , axis ) { const minDomain = getMinFromProps ( props , axis ) ; const maxDomain = getMaxFromProps ( props , axis ) ; if ( isPlainObject ( props . domain ) && props . domain [ axis ] ) { return props . domain [ axis ] ; } else if ( Array . isArray ( props . domain ) ) { return props . domain ; } else if ( minDomain !== undefined && maxDomain !== undefined ) { return getDomainFromMinMax ( minDomain , maxDomain ) ; } return undefined ; } 
function getDomainWithZero ( props , axis ) { const propsDomain = getDomainFromProps ( props , axis ) ; if ( propsDomain ) { return propsDomain ; } const dataset = Data . getData ( props ) ; const y0Min = dataset . reduce ( ( min , datum ) => ( datum . _y0 < min ? datum . _y0 : min ) , Infinity ) ; const ensureZero = ( domain ) => { if ( axis === "x" ) { return domain ; } const defaultMin = y0Min !== Infinity ? y0Min : 0 ; const maxDomainProp = getMaxFromProps ( props , axis ) ; const minDomainProp = getMinFromProps ( props , axis ) ; const max = maxDomainProp !== undefined ? maxDomainProp : Collection . getMaxValue ( domain , defaultMin ) ; const min = minDomainProp !== undefined ? minDomainProp : Collection . getMinValue ( domain , defaultMin ) ; return getDomainFromMinMax ( min , max ) ; } ; const getDomainFunction = ( ) => { return getDomainFromData ( props , axis , dataset ) ; } ; const formatDomainFunction = ( domain ) => { return formatDomain ( ensureZero ( domain ) , props , axis ) ; } ; return createDomainFunction ( getDomainFunction , formatDomainFunction ) ( props , axis ) ; } 
function getMaxFromProps ( props , axis ) { if ( isPlainObject ( props . maxDomain ) && props . maxDomain [ axis ] !== undefined ) { return props . maxDomain [ axis ] ; } return typeof props . maxDomain === "number" ? props . maxDomain : undefined ; } 
function getMinFromProps ( props , axis ) { if ( isPlainObject ( props . minDomain ) && props . minDomain [ axis ] !== undefined ) { return props . minDomain [ axis ] ; } return typeof props . minDomain === "number" ? props . minDomain : undefined ; } 
function getSymmetricDomain ( domain , values ) { const processedData = sortedUniq ( values . sort ( ( a , b ) => a - b ) ) ; const step = processedData [ 1 ] - processedData [ 0 ] ; return [ domain [ 0 ] , domain [ 1 ] + step ] ; } 
function isDomainComponent ( component ) { const getRole = ( child ) => { return child && child . type ? child . type . role : "" ; } ; let role = getRole ( component ) ; if ( role === "portal" ) { const children = React . Children . toArray ( component . props . children ) ; role = children . length ? getRole ( children [ 0 ] ) : "" ; } const whitelist = [ "area" , "axis" , "bar" , "boxplot" , "candlestick" , "errorbar" , "group" , "line" , "pie" , "scatter" , "stack" , "voronoi" ] ; return includes ( whitelist , role ) ; } 
function parseDatum ( datum ) { const immutableDatumWhitelist = { errorX : true , errorY : true } ; return Immutable . isImmutable ( datum ) ? Immutable . shallowToJS ( datum , immutableDatumWhitelist ) : datum ; } 
function generateDataArray ( props , axis ) { const propsDomain = isPlainObject ( props . domain ) ? props . domain [ axis ] : props . domain ; const domain = propsDomain || Scale . getBaseScale ( props , axis ) . domain ( ) ; const samples = props . samples || 1 ; const domainMax = Math . max ( ... domain ) ; const domainMin = Math . min ( ... domain ) ; const step = ( domainMax - domainMin ) / samples ; const values = range ( domainMin , domainMax , step ) ; return last ( values ) === domainMax ? values : values . concat ( domainMax ) ; } 
function sortData ( dataset , sortKey , sortOrder = "ascending" ) { if ( ! sortKey ) { return dataset ; } 
function cleanData ( dataset , props ) { const smallNumber = 1 / Number . MAX_SAFE_INTEGER ; const scaleType = { x : Scale . getScaleType ( props , "x" ) , y : Scale . getScaleType ( props , "y" ) } ; if ( scaleType . x !== "log" && scaleType . y !== "log" ) { return dataset ; } const rules = ( datum , axis ) => { return scaleType [ axis ] === "log" ? datum [ ` ${ axis } ` ] !== 0 : true ; } ; const sanitize = ( datum ) => { const _x = rules ( datum , "x" ) ? datum . _x : smallNumber ; const _y = rules ( datum , "y" ) ? datum . _y : smallNumber ; const _y0 = rules ( datum , "y0" ) ? datum . _y0 : smallNumber ; return assign ( { } , datum , { _x , _y , _y0 } ) ; } ; return dataset . map ( ( datum ) => { if ( rules ( datum , "x" ) && rules ( datum , "y" ) && rules ( datum , "y0" ) ) { return datum ; } return sanitize ( datum ) ; } ) ; } 
function getEventKey ( key ) { 
function addEventKeys ( props , data ) { const hasEventKeyAccessor = ! ! props . eventKey ; const eventKeyAccessor = getEventKey ( props . eventKey ) ; return data . map ( ( datum ) => { if ( datum . eventKey !== undefined ) { return datum ; } else if ( hasEventKeyAccessor ) { const eventKey = eventKeyAccessor ( datum ) ; return eventKey !== undefined ? assign ( { eventKey } , datum ) : datum ; } else { return datum ; } } ) ; } 
function createStringMap ( props , axis ) { const stringsFromAxes = getStringsFromAxes ( props , axis ) ; const stringsFromCategories = getStringsFromCategories ( props , axis ) ; const stringsFromData = getStringsFromData ( props , axis ) ; const allStrings = uniq ( [ ... stringsFromAxes , ... stringsFromCategories , ... stringsFromData ] ) ; return allStrings . length === 0 ? null : allStrings . reduce ( ( memo , string , index ) => { memo [ string ] = index + 1 ; return memo ; } , { } ) ; } 
function downsample ( data , maxPoints , startingIndex = 0 ) { 
function formatData ( dataset , props , expectedKeys ) { const isArrayOrIterable = Array . isArray ( dataset ) || Immutable . isIterable ( dataset ) ; if ( ! isArrayOrIterable || getLength ( dataset ) < 1 ) { return [ ] ; } const defaultKeys = [ "x" , "y" , "y0" ] ; expectedKeys = Array . isArray ( expectedKeys ) ? expectedKeys : defaultKeys ; const stringMap = { x : expectedKeys . indexOf ( "x" ) !== - 1 ? createStringMap ( props , "x" ) : undefined , y : expectedKeys . indexOf ( "y" ) !== - 1 ? createStringMap ( props , "y" ) : undefined , y0 : expectedKeys . indexOf ( "y0" ) !== - 1 ? createStringMap ( props , "y" ) : undefined } ; const createAccessor = ( name ) => { return Helpers . createAccessor ( props [ name ] !== undefined ? props [ name ] : name ) ; } ; const accessor = expectedKeys . reduce ( ( memo , type ) => { memo [ type ] = createAccessor ( type ) ; return memo ; } , { } ) ; const preformattedData = isEqual ( expectedKeys , defaultKeys ) && props . x === "_x" && props . y === "_y" && props . y0 === "_y0" ; const data = preformattedData ? dataset : dataset . reduce ( ( dataArr , datum , index ) => { 
function generateData ( props ) { const xValues = generateDataArray ( props , "x" ) ; const yValues = generateDataArray ( props , "y" ) ; const values = xValues . map ( ( x , i ) => { return { x , y : yValues [ i ] } ; } ) ; return values ; } 
function getCategories ( props , axis ) { return props . categories && ! Array . isArray ( props . categories ) ? props . categories [ axis ] : props . categories ; } 
function getData ( props ) { return props . data ? formatData ( props . data , props ) : formatData ( generateData ( props ) , props ) ; } 
function getStringsFromAxes ( props , axis ) { const { tickValues , tickFormat } = props ; let tickValueArray ; if ( ! tickValues || ( ! Array . isArray ( tickValues ) && ! tickValues [ axis ] ) ) { tickValueArray = tickFormat && Array . isArray ( tickFormat ) ? tickFormat : [ ] ; } else { tickValueArray = tickValues [ axis ] || tickValues ; } return tickValueArray . filter ( ( val ) => typeof val === "string" ) ; } 
function getStringsFromCategories ( props , axis ) { if ( ! props . categories ) { return [ ] ; } const categories = getCategories ( props , axis ) ; const categoryStrings = categories && categories . filter ( ( val ) => typeof val === "string" ) ; return categoryStrings ? Collection . removeUndefined ( categoryStrings ) : [ ] ; } 
function getStringsFromData ( props , axis ) { const isArrayOrIterable = Array . isArray ( props . data ) || Immutable . isIterable ( props . data ) ; if ( ! isArrayOrIterable ) { return [ ] ; } const key = props [ axis ] === undefined ? axis : props [ axis ] ; const accessor = Helpers . createAccessor ( key ) ; 
function getText ( props , datum , index ) { datum = datum || { } ; if ( datum . label !== undefined ) { return datum . label ; } return Array . isArray ( props . labels ) ? props . labels [ index ] : props . labels ; } 
function findAxisComponents ( childComponents , predicate ) { predicate = predicate || identity ; const findAxes = ( children ) => { return children . reduce ( ( memo , child ) => { if ( child . type && child . type . role === "axis" && predicate ( child ) ) { return memo . concat ( child ) ; } else if ( child . props && child . props . children ) { return memo . concat ( findAxes ( React . Children . toArray ( child . props . children ) ) ) ; } return memo ; } , [ ] ) ; } ; return findAxes ( childComponents ) ; } 
function getAxisComponent ( childComponents , axis ) { const matchesAxis = ( component ) => { const type = component . type . getAxis ( component . props ) ; return type === axis ; } ; return findAxisComponents ( childComponents , matchesAxis ) [ 0 ] ; } 
function getAxisComponentsWithParent ( childComponents , type ) { const matchesType = ( child ) => { return type === "dependent" ? child . props . dependentAxis : ! child . props . dependentAxis ; } ; const findComponents = ( children ) => { return children . reduce ( ( memo , child ) => { if ( child . type && child . type . role === "axis" && matchesType ( child ) ) { return memo . concat ( child ) ; } else if ( child . props && child . props . children ) { const childAxis = findComponents ( React . Children . toArray ( child . props . children ) ) ; return childAxis . length > 0 ? memo . concat ( child ) : memo ; } return memo ; } , [ ] ) ; } ; return findComponents ( childComponents ) ; } 
function getDomainFromData ( props , axis ) { const { polar , startAngle = 0 , endAngle = 360 } = props ; const tickValues = getTickArray ( props ) ; if ( ! Array . isArray ( tickValues ) ) { return undefined ; } const minDomain = Domain . getMinFromProps ( props , axis ) ; const maxDomain = Domain . getMaxFromProps ( props , axis ) ; const tickStrings = stringTicks ( props ) ; const ticks = tickValues . map ( ( value ) => + value ) ; const defaultMin = tickStrings ? 1 : Collection . getMinValue ( ticks ) ; const defaultMax = tickStrings ? tickValues . length : Collection . getMaxValue ( ticks ) ; const min = minDomain !== undefined ? minDomain : defaultMin ; const max = maxDomain !== undefined ? maxDomain : defaultMax ; const initialDomain = Domain . getDomainFromMinMax ( min , max ) ; const domain = polar && axis === "x" && Math . abs ( startAngle - endAngle ) === 360 ? Domain . getSymmetricDomain ( initialDomain , ticks ) : initialDomain ; if ( isVertical ( props ) && ! polar ) { domain . reverse ( ) ; } return domain ; } 
function getDomain ( props , axis ) { const inherentAxis = getAxis ( props ) ; if ( axis && axis !== inherentAxis ) { return undefined ; } return Domain . createDomainFunction ( getDomainFromData ) ( props , inherentAxis ) ; } 
function transformTarget ( target , matrix , dimension ) { const { a , d , e , f } = matrix ; return dimension === "y" ? d * target + f : a * target + e ; } 
function getParentSVG ( evt ) { if ( evt . nativeEvent && evt . nativeEvent . identifier !== undefined ) { return undefined ; } const getParent = ( target ) => { if ( target . nodeName === "svg" ) { return target ; } else { return target . parentNode ? getParent ( target . parentNode ) : target ; } } ; return getParent ( evt . target ) ; } 
function getDataCoordinates ( props , scale , x , y ) { const { polar , horizontal } = props ; if ( ! polar ) { return { x : horizontal ? scale . x . invert ( y ) : scale . x . invert ( x ) , y : horizontal ? scale . y . invert ( x ) : scale . y . invert ( y ) } ; } else { const origin = props . origin || { x : 0 , y : 0 } ; const baseX = x - origin . x ; const baseY = y - origin . y ; const radius = Math . abs ( baseX * Math . sqrt ( 1 + Math . pow ( - baseY / baseX , 2 ) ) ) ; const angle = ( - Math . atan2 ( baseY , baseX ) + Math . PI * 2 ) % ( Math . PI * 2 ) ; return { x : scale . x . invert ( angle ) , y : scale . y . invert ( radius ) } ; } } 
function fillData ( props , datasets ) { const { fillInMissingData } = props ; const xMap = datasets . reduce ( ( prev , dataset ) => { dataset . forEach ( ( datum ) => { prev [ datum . _x instanceof Date ? datum . _x . getTime ( ) : datum . _x ] = true ; } ) ; return prev ; } , { } ) ; const xKeys = keys ( xMap ) . map ( ( k ) => + k ) ; const xArr = orderBy ( xKeys ) ; return datasets . map ( ( dataset ) => { let indexOffset = 0 ; const isDate = dataset [ 0 ] && dataset [ 0 ] . _x instanceof Date ; const filledInData = xArr . map ( ( x , index ) => { x = + x ; const datum = dataset [ index - indexOffset ] ; if ( datum ) { const x1 = isDate ? datum . _x . getTime ( ) : datum . _x ; if ( x1 === x ) { return datum ; } else { indexOffset ++ ; const y = fillInMissingData ? 0 : null ; x = isDate ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } else { const y = fillInMissingData ? 0 : null ; x = isDate ? new Date ( x ) : x ; return { x , y , _x : x , _y : y } ; } } ) ; return filledInData ; } ) ; } 
function addLayoutData ( props , datasets , index ) { const xOffset = props . xOffset || 0 ; return datasets [ index ] . map ( ( datum ) => { const yOffset = getY0 ( datum , index , datasets ) || 0 ; return assign ( { } , datum , { _y0 : ! ( datum . _y instanceof Date ) ? yOffset : yOffset ? new Date ( yOffset ) : datum . _y , _y1 : datum . _y === null ? null : datum . _y instanceof Date ? new Date ( + datum . _y + + yOffset ) : datum . _y + yOffset , _x1 : datum . _x === null ? null : datum . _x instanceof Date ? new Date ( + datum . _x + + xOffset ) : datum . _x + xOffset } ) ; } ) ; } 
function stackData ( props , childComponents ) { const dataFromChildren = Wrapper . getDataFromChildren ( props , childComponents ) ; const datasets = fillData ( props , dataFromChildren ) ; return datasets . map ( ( d , i ) => addLayoutData ( props , datasets , i ) ) ; } 
function updateState ( ) { history . replaceState ( { left_top : split_left . scrollTop , right_top : split_right . scrollTop } , document . title ) ; } 
function _applyRemainingDefaultOptions ( opts ) { opts . icon = opts . hasOwnProperty ( 'icon' ) ? opts . icon : '\ue9cb' ; 
function _getElements ( input ) { var elements ; if ( typeof input === 'string' || input instanceof String ) { 
function _addBaselineStyles ( ) { 
function getClaimValue ( entity , prop ) { if ( ! entity . claims ) return ; if ( ! entity . claims [ prop ] ) return ; let value , c ; for ( let i = 0 ; i < entity . claims [ prop ] . length ; i ++ ) { c = entity . claims [ prop ] [ i ] ; if ( c . rank === 'deprecated' ) continue ; if ( c . mainsnak . snaktype !== 'value' ) continue ; value = c . mainsnak . datavalue . value ; if ( c . rank === 'preferred' ) return value ; 
function checkTwitterRateLimit ( need ) { _twitterAPIIndex = ( _twitterAPIIndex + 1 ) % twitterAPIs . length ; let twitterAPI = twitterAPIs [ _twitterAPIIndex ] ; let which = twitterAPIs . length > 1 ? ( ' ' + ( _twitterAPIIndex + 1 ) ) : '' ; return twitterAPI . get ( 'application/rate_limit_status' , { resources : 'users' } ) . then ( result => { let now = Date . now ( ) / 1000 ; let stats = result . resources . users [ '/users/show/:id' ] ; let resetSec = Math . ceil ( stats . reset - now ) + 30 ; 
function fetchTwitterUserDetails ( qid , username ) { let target = _wikidata [ qid ] ; let twitterAPI = twitterAPIs [ _twitterAPIIndex ] ; return twitterAPI . get ( 'users/show' , { screen_name : username } ) . then ( user => { target . logos . twitter = user . profile_image_url_https . replace ( '_normal' , '_bigger' ) ; } ) . catch ( e => { let msg = ` ${ username } ${ qid } ` + JSON . stringify ( e ) ; _errors . push ( msg ) ; console . error ( colors . red ( msg ) ) ; } ) ; } 
function checkWikipedia ( brands ) { Object . keys ( brands ) . forEach ( k => { [ 'brand:wikipedia' , 'operator:wikipedia' ] . forEach ( t => { let wp = brands [ k ] . tags [ t ] ; if ( wp && ! / ^[a-z_]{2,}:[^_]*$ / . test ( wp ) ) { _wrongFormat . push ( [ k , wp , t ] ) ; } } ) ; } ) ; } 
function filterNames ( ) { console . log ( '\nfiltering names' ) ; console . time ( colors . green ( 'names filtered' ) ) ; 
function mergeBrands ( ) { buildReverseIndex ( brands ) ; checkBrands ( ) ; console . log ( '\nmerging brands' ) ; console . time ( colors . green ( 'brands merged' ) ) ; 
function checkAmbiguous ( k ) { let i = k . indexOf ( '~' ) ; if ( i !== - 1 ) { let stem = k . substring ( 0 , i ) ; ambiguous [ stem ] = true ; return true ; } return false ; } 
function buildReverseIndex ( obj ) { let warnCollisions = [ ] ; for ( let k in obj ) { checkAmbiguous ( k ) ; if ( obj [ k ] . match ) { for ( let i = obj [ k ] . match . length - 1 ; i >= 0 ; i -- ) { let match = obj [ k ] . match [ i ] ; checkAmbiguous ( match ) ; if ( rIndex [ match ] ) { warnCollisions . push ( [ rIndex [ match ] , match ] ) ; warnCollisions . push ( [ k , match ] ) ; } rIndex [ match ] = k ; } } } if ( warnCollisions . length ) { console . warn ( colors . yellow ( '\nWarning - match name collisions' ) ) ; console . warn ( 'To resolve these, make sure multiple entries do not contain the same "match" property.' ) ; warnCollisions . forEach ( w => console . warn ( colors . yellow ( ' "' + w [ 0 ] + '"' ) + ' -> match? -> ' + colors . yellow ( '"' + w [ 1 ] + '"' ) ) ) ; } } 
function checkBrands ( ) { let warnMatched = [ ] ; let warnDuplicate = [ ] ; let warnFormatWikidata = [ ] ; let warnFormatWikipedia = [ ] ; let warnMissingWikidata = [ ] ; let warnMissingWikipedia = [ ] ; let warnMissingLogos = [ ] ; let warnMissingTag = [ ] ; let seen = { } ; Object . keys ( brands ) . forEach ( k => { let obj = brands [ k ] ; let parts = k . split ( '|' , 2 ) ; let tag = parts [ 0 ] ; let name = parts [ 1 ] ; 
function ( KEY , exec ) { var fn = ( _core . Object || { } ) [ KEY ] || Object [ KEY ] ; var exp = { } ; exp [ KEY ] = exec ( fn ) ; _export ( _export . S + _export . F * _fails ( function ( ) { fn ( 1 ) ; } ) , 'Object' , exp ) ; } 
function ( TO_STRING ) { return function ( that , pos ) { var s = String ( _defined ( that ) ) ; var i = _toInteger ( pos ) ; var l = s . length ; var a , b ; if ( i < 0 || i >= l ) return TO_STRING ? '' : undefined ; a = s . charCodeAt ( i ) ; return a < 0xd800 || a > 0xdbff || i + 1 === l || ( b = s . charCodeAt ( i + 1 ) ) < 0xdc00 || b > 0xdfff ? TO_STRING ? s . charAt ( i ) : a : TO_STRING ? s . slice ( i , i + 2 ) : ( a - 0xd800 << 10 ) + ( b - 0xdc00 ) + 0x10000 ; } ; } 
function ( ) { 
function ( it ) { if ( FREEZE && meta . NEED && isExtensible ( it ) && ! _has ( it , META ) ) setMeta ( it ) ; return it ; } 
function ( O , proto ) { _anObject ( O ) ; if ( ! _isObject ( proto ) && proto !== null ) throw TypeError ( proto + ": can't set as prototype!" ) ; } 
function PromiseCapability ( C ) { var resolve , reject ; this . promise = new C ( function ( $$resolve , $$reject ) { if ( resolve !== undefined || reject !== undefined ) throw TypeError ( 'Bad Promise constructor' ) ; resolve = $$resolve ; reject = $$reject ; } ) ; this . resolve = _aFunction ( resolve ) ; this . reject = _aFunction ( reject ) ; } 
function then ( onFulfilled , onRejected ) { var reaction = newPromiseCapability ( _speciesConstructor ( this , $Promise ) ) ; reaction . ok = typeof onFulfilled == 'function' ? onFulfilled : true ; reaction . fail = typeof onRejected == 'function' && onRejected ; reaction . domain = isNode$1 ? process$2 . domain : undefined ; this . _c . push ( reaction ) ; if ( this . _a ) this . _a . push ( reaction ) ; if ( this . _s ) notify ( this , false ) ; return reaction . promise ; } 
function race ( iterable ) { var C = this ; var capability = newPromiseCapability ( C ) ; var reject = capability . reject ; var result = _perform ( function ( ) { _forOf ( iterable , false , function ( promise ) { C . resolve ( promise ) . then ( capability . resolve , reject ) ; } ) ; } ) ; if ( result . e ) reject ( result . v ) ; return capability . promise ; } 
function isObject ( obj ) { 
function isEmpty ( obj ) { if ( isArray ( obj ) ) { return obj . length === 0 ; } else if ( isObject ( obj ) ) { return _Object$keys ( obj ) . length === 0 ; } else { return ! obj ; } } 
function isPrimitive ( val ) { return isVoid ( val ) || isBoolean ( val ) || isString ( val ) || isNumber ( val ) ; } 
function isNode$2 ( obj ) { return ! ! ( ( typeof Node === 'undefined' ? 'undefined' : _typeof ( Node ) ) === 'object' ? obj instanceof Node : obj && ( typeof obj === 'undefined' ? 'undefined' : _typeof ( obj ) ) === 'object' && typeof obj . nodeType === 'number' && typeof obj . nodeName === 'string' ) ; } 
function isElement ( obj ) { return ! ! ( ( typeof HTMLElement === 'undefined' ? 'undefined' : _typeof ( HTMLElement ) ) === 'object' ? obj instanceof HTMLElement : obj && ( typeof obj === 'undefined' ? 'undefined' : _typeof ( obj ) ) === 'object' && obj !== null && obj . nodeType === 1 && typeof obj . nodeName === 'string' ) ; } 
function isPosterityNode ( parent , child ) { if ( ! isNode$2 ( parent ) || ! isNode$2 ( child ) ) { return false ; } while ( child . parentNode ) { child = child . parentNode ; if ( child === parent ) { return true ; } } return false ; } 
function from ( arrayLike ) { var O = _toObject ( arrayLike ) ; var C = typeof this == 'function' ? this : Array ; var aLen = arguments . length ; var mapfn = aLen > 1 ? arguments [ 1 ] : undefined ; var mapping = mapfn !== undefined ; var index = 0 ; var iterFn = core_getIteratorMethod ( O ) ; var length , result , step , iterator ; if ( mapping ) mapfn = _ctx ( mapfn , aLen > 2 ? arguments [ 2 ] : undefined , 2 ) ; 
function genTraversalHandler ( fn ) { var setter = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( target , key , value ) { target [ key ] = value ; } ; 
function recursiveFn ( source , target , key ) { if ( isArray ( source ) || isObject ( source ) ) { target = isPrimitive ( target ) ? isObject ( source ) ? { } : [ ] : target ; for ( var _key in source ) { 
function deepAssign ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key2 = 0 ; _key2 < _len ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } if ( args . length < 2 ) { throw new Error ( 'deepAssign accept two and more argument' ) ; } for ( var i = args . length - 1 ; i > - 1 ; i -- ) { if ( isPrimitive ( args [ i ] ) ) { throw new TypeError ( 'deepAssign only accept non primitive type' ) ; } } var target = args . shift ( ) ; args . forEach ( function ( source ) { return _deepAssign ( source , target ) ; } ) ; return target ; } 
function camelize ( str , isBig ) { return str . replace ( / (^|[^a-zA-Z]+)([a-zA-Z]) / g , function ( match , spilt , initials , index ) { return ! isBig && index === 0 ? initials . toLowerCase ( ) : initials . toUpperCase ( ) ; } ) ; } 
function getDeepProperty ( obj , keys ) { var _ref = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } , _ref$throwError = _ref . throwError , throwError = _ref$throwError === undefined ? false : _ref$throwError , backup = _ref . backup ; if ( isString ( keys ) ) { keys = keys . split ( '.' ) ; } if ( ! isArray ( keys ) ) { throw new TypeError ( 'keys of getDeepProperty must be string or Array<string>' ) ; } var read = [ ] ; var target = obj ; for ( var i = 0 , len = keys . length ; i < len ; i ++ ) { var key = keys [ i ] ; if ( isVoid ( target ) ) { if ( throwError ) { throw new Error ( 'obj' + ( read . length > 0 ? '.' + read . join ( '.' ) : ' itself' ) + ' is ' + target ) ; } else { return backup ; } } target = target [ key ] ; read . push ( key ) ; } return target ; } 
function transObjectAttrIntoArray ( obj ) { var fn = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( a , b ) { return + a - + b ; } ; return _Object$keys ( obj ) . sort ( fn ) . reduce ( function ( order , key ) { return order . concat ( obj [ key ] ) ; } , [ ] ) ; } 
function runRejectableQueue ( queue ) { for ( var _len = arguments . length , args = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { args [ _key - 1 ] = arguments [ _key ] ; } return new _Promise ( function ( resolve , reject ) { var step = function step ( index ) { if ( index >= queue . length ) { resolve ( ) ; return ; } var result = isFunction ( queue [ index ] ) ? queue [ index ] . apply ( queue , _toConsumableArray ( args ) ) : queue [ index ] ; if ( result === false ) return reject ( 'stop' ) ; return _Promise . resolve ( result ) . then ( function ( ) { return step ( index + 1 ) ; } ) . catch ( function ( err ) { return reject ( err || 'stop' ) ; } ) ; } ; step ( 0 ) ; } ) ; } 
function runStoppableQueue ( queue ) { for ( var _len2 = arguments . length , args = Array ( _len2 > 1 ? _len2 - 1 : 0 ) , _key2 = 1 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 - 1 ] = arguments [ _key2 ] ; } var step = function step ( index ) { if ( index >= queue . length ) { return true ; } var result = isFunction ( queue [ index ] ) ? queue [ index ] . apply ( queue , _toConsumableArray ( args ) ) : queue [ index ] ; if ( result === false ) return false ; return step ( ++ index ) ; } ; return step ( 0 ) ; } 
function getEvtTypeCache ( target , type ) { var evtId = target . __evt_id ; if ( ! evtId ) { Object . defineProperty ( target , '__evt_id' , { writable : true , enumerable : false , configurable : true } ) ; evtId = target . __evt_id = ++ _evtListenerCache . count ; } var typeCacheKey = evtId + '_' + type ; var evtTypeCache = _evtListenerCache [ typeCacheKey ] ; if ( ! evtTypeCache ) { evtTypeCache = _evtListenerCache [ typeCacheKey ] = [ ] ; } return evtTypeCache ; } 
function emitEventCache ( target , type , eventObj ) { var evt = _Object$create ( null ) ; evt . type = type ; evt . target = target ; if ( eventObj ) { _Object$assign ( evt , isObject ( eventObj ) ? eventObj : { data : eventObj } ) ; } getEvtTypeCache ( target , type ) . forEach ( function ( item ) { ( item [ 1 ] || item [ 0 ] ) . apply ( target , [ evt ] ) ; } ) ; } 
function addEventCache ( target , type , handler ) { var isOnce = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var handlerWrap = arguments [ 4 ] ; if ( isFunction ( isOnce ) && ! handlerWrap ) { handlerWrap = isOnce ; isOnce = undefined ; } var handlers = [ handler , undefined , isOnce ] ; if ( isOnce && ! handlerWrap ) { handlerWrap = function handlerWrap ( ) { removeEventCache ( target , type , handler , isOnce ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } handler . apply ( target , args ) ; } ; } if ( handlerWrap ) { handlers [ 1 ] = handlerWrap ; } getEvtTypeCache ( target , type ) . push ( handlers ) ; } 
function removeEventCache ( target , type , handler ) { var isOnce = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var typeCache = getEvtTypeCache ( target , type ) ; if ( handler || isOnce ) { var handlerId = - 1 ; var handlerWrap = void 0 ; typeCache . find ( function ( item , i ) { if ( ( ! handler || item [ 0 ] === handler ) && ( ! isOnce || item [ 2 ] ) ) { handlerId = i ; handlerWrap = item [ 1 ] ; return true ; } } ) ; if ( handlerId !== - 1 ) { typeCache . splice ( handlerId , 1 ) ; } return handlerWrap ; } else { typeCache . length = 0 ; } } 
function setAttr ( el , attrName , attrVal ) { if ( attrVal === undefined ) { el . removeAttribute ( attrName ) ; } else { el . setAttribute ( attrName , attrVal ) ; } } 
function addClassName ( el , cls ) { if ( ! cls || ! ( cls = cls . trim ( ) ) ) { return ; } var clsArr = cls . split ( / \s+ / ) ; if ( el . classList ) { clsArr . forEach ( function ( c ) { return el . classList . add ( c ) ; } ) ; } else { var curCls = ' ' + ( el . className || '' ) + ' ' ; clsArr . forEach ( function ( c ) { curCls . indexOf ( ' ' + c + ' ' ) === - 1 && ( curCls += ' ' + c ) ; } ) ; el . className = curCls . trim ( ) ; } } 
function removeClassName ( el , cls ) { if ( ! cls || ! ( cls = cls . trim ( ) ) ) { return ; } var clsArr = cls . split ( / \s+ / ) ; if ( el . classList ) { clsArr . forEach ( function ( c ) { return el . classList . remove ( c ) ; } ) ; } else { var curCls = ' ' + el . className + ' ' ; clsArr . forEach ( function ( c ) { var tar = ' ' + c + ' ' ; while ( curCls . indexOf ( tar ) !== - 1 ) { curCls = curCls . replace ( tar , ' ' ) ; } } ) ; el . className = curCls . trim ( ) ; } } 
function removeEvent ( el , type , handler ) { var once = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; if ( capture !== undefined && ! isBoolean ( capture ) && supportsPassive ) { capture = { passive : true } ; } if ( once ) { var handlerWrap = removeEventCache ( el , type + '_once' , handler ) ; if ( handlerWrap ) { handler = handlerWrap ; } } el . removeEventListener ( type , handler , capture ) ; } 
function addEvent ( el , type , handler ) { var once = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; if ( capture !== undefined && ! isBoolean ( capture ) && supportsPassive ) { capture = { passive : true } ; } if ( once ) { var oldHandler = handler ; handler = function ( ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } oldHandler . apply ( this , args ) ; removeEvent ( el , type , handler , once , capture ) ; } ; } ( ) ; addEventCache ( el , type + '_once' , oldHandler , handler ) ; } el . addEventListener ( type , handler , capture ) ; } 
function addDelegate ( el , selector , type , handler ) { var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; if ( capture !== undefined && ! isBoolean ( capture ) && supportsPassive ) { capture = { passive : true } ; } var handlerWrap = function handlerWrap ( e ) { var targetElsArr = findParents ( e . target || e . srcElement , el , true ) ; var targetElArr = query ( selector , el , true ) ; var retEl = void 0 ; if ( targetElArr . find ) { retEl = targetElArr . find ( function ( seEl ) { return targetElsArr . find ( function ( tgEl ) { return seEl === tgEl ; } ) ; } ) ; } else { 
function removeDelegate ( el , selector , type , handler ) { var capture = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : false ; if ( capture !== undefined && ! isBoolean ( capture ) && supportsPassive ) { capture = { passive : true } ; } var handlerWrap = removeEventCache ( el , type + '_delegate_' + selector , handler ) ; handlerWrap && el . removeEventListener ( type , handlerWrap , capture ) ; } 
function getStyle ( el , key ) { return ( el . currentStyle || document . defaultView . getComputedStyle ( el , null ) ) [ key ] || el . style [ key ] ; } 
function setStyle ( el , key , val ) { if ( isObject ( key ) ) { for ( var k in key ) { setStyle ( el , k , key [ k ] ) ; } } else { el . style [ key ] = val ; } } 
function query ( selector ) { var container = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : document ; var toArray = arguments [ 2 ] ; var retNodeList = container . querySelectorAll ( selector ) ; return toArray ? _Array$from ( retNodeList ) : retNodeList ; } 
function findParents ( el ) { var endEl = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : null ; var haveEl = arguments [ 2 ] ; var haveEndEl = arguments [ 3 ] ; var retEls = [ ] ; if ( haveEl ) { retEls . push ( el ) ; } while ( el && el . parentNode !== endEl ) { el = el . parentNode ; el && retEls . push ( el ) ; } if ( haveEndEl ) { retEls . push ( endEl ) ; } return retEls ; } 
function getLegalBox ( _ref ) { var src = _ref . src , box = _ref . box ; if ( isString ( box ) && box ) return box ; src = src . toLowerCase ( ) ; for ( var key in boxSuffixMap ) { var suffix = boxSuffixMap [ key ] ; if ( src . indexOf ( suffix ) > - 1 ) return key ; } return 'native' ; } 
function bind$1 ( fn , context ) { if ( fn . bind ) { return fn . bind ( context ) ; } else if ( fn . apply ) { return function __autobind__ ( ) { for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key3 = 0 ; _key3 < _len2 ; _key3 ++ ) { args [ _key3 ] = arguments [ _key3 ] ; } return fn . apply ( context , args ) ; } ; } else { return function __autobind__ ( ) { for ( var _len3 = arguments . length , args = Array ( _len3 ) , _key4 = 0 ; _key4 < _len3 ; _key4 ++ ) { args [ _key4 ] = arguments [ _key4 ] ; } return fn . call . apply ( fn , [ context ] . concat ( _toConsumableArray ( args ) ) ) ; } ; } } 
function ( key ) { if ( ! _isObject ( key ) ) return false ; var data = getWeak ( key ) ; if ( data === true ) return uncaughtFrozenStore ( _validateCollection ( this , NAME ) ) [ 'delete' ] ( key ) ; return data && _has ( data , this . _i ) && delete data [ this . _i ] ; } 
function get ( key ) { if ( _isObject ( key ) ) { var data = getWeak ( key ) ; if ( data === true ) return uncaughtFrozenStore ( _validateCollection ( this , WEAK_MAP ) ) . get ( key ) ; return data ? data [ this . _i ] : undefined ; } } 
function ( COLLECTION ) { _export ( _export . S , COLLECTION , { of : function of ( ) { var length = arguments . length ; var A = new Array ( length ) ; while ( length -- ) A [ length ] = arguments [ length ] ; return new this ( A ) ; } } ) ; } 
function isDescriptor ( desc ) { if ( ! desc || ! desc . hasOwnProperty ) { return false ; } var keys = [ 'value' , 'initializer' , 'get' , 'set' ] ; for ( var i = 0 , l = keys . length ; i < l ; i ++ ) { if ( desc . hasOwnProperty ( keys [ i ] ) ) { return true ; } } return false ; } 
function isAccessorDescriptor ( desc ) { return ! ! desc && ( isFunction ( desc . get ) || isFunction ( desc . set ) ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && desc . writable === undefined ; } 
function isDataDescriptor ( desc ) { return ! ! desc && desc . hasOwnProperty ( 'value' ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && isBoolean ( desc . writable ) ; } 
function isInitializerDescriptor ( desc ) { return ! ! desc && isFunction ( desc . initializer ) && isBoolean ( desc . configurable ) && isBoolean ( desc . enumerable ) && isBoolean ( desc . writable ) ; } 
function createDefaultSetter ( key ) { return function set ( newValue ) { _Object$defineProperty ( this , key , { configurable : true , writable : true , 
function compressOneArgFnArray ( fns ) { var errmsg = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 'You must pass me an array of function' ; if ( ! isArray ( fns ) || fns . length < 1 ) { throw new TypeError ( errmsg ) ; } if ( fns . length === 1 ) { if ( ! isFunction ( fns [ 0 ] ) ) { throw new TypeError ( errmsg ) ; } return fns [ 0 ] ; } return fns . reduce ( function ( prev , curr ) { if ( ! isFunction ( curr ) || ! isFunction ( prev ) ) throw new TypeError ( errmsg ) ; return function ( value ) { return bind$1 ( curr , this ) ( bind$1 ( prev , this ) ( value ) ) ; } ; } ) ; } 
function getBoundSuper ( obj , fn ) { if ( typeof _WeakMap === 'undefined' ) { throw new Error ( 'Using @autobind on ' + fn . name + '() requires WeakMap support due to its use of super.' + fn . name + '()' ) ; } if ( ! mapStore ) { mapStore = new _WeakMap ( ) ; } if ( mapStore . has ( obj ) === false ) { mapStore . set ( obj , new _WeakMap ( ) ) ; } var superStore = mapStore . get ( obj ) ; 
function autobind ( obj , prop , descriptor ) { if ( arguments . length === 1 ) return autobindClass ( ) ( obj ) ; var _ref = descriptor || { } , fn = _ref . value , configurable = _ref . configurable ; if ( ! isFunction ( fn ) ) { throw new TypeError ( '@autobind can only be used on functions, not "' + fn + '" in ' + ( typeof fn === 'undefined' ? 'undefined' : _typeof ( fn ) ) + ' on property "' + prop + '"' ) ; } var constructor = obj . constructor ; return { configurable : configurable , enumerable : false , get : function get ( ) { var _this = this ; var boundFn = function boundFn ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return fn . call . apply ( fn , [ _this ] . concat ( _toConsumableArray ( args ) ) ) ; } ; 
function frozen ( obj , prop , descriptor ) { if ( descriptor === undefined ) { warn ( 'You are using @frozen on an undefined property. This property will become a frozen undefined forever, which is meaningless' ) ; return { value : undefined , writable : false , enumerable : false , configurable : false } ; } descriptor . enumerable = false ; descriptor . configurable = false ; if ( isAccessorDescriptor ( descriptor ) ) { var _get = descriptor . get ; descriptor . set = undefined ; if ( ! isFunction ( _get ) ) { warn ( 'You are using @frozen on one accessor descriptor without getter. This property will become a frozen undefined finally.Which maybe meaningless.' ) ; return ; } return { get : function get ( ) { var value = bind$1 ( _get , this ) ( ) ; defineProperty$2$1 ( this , prop , { value : value , writable : false , configurable : false , enumerable : false } ) ; return value ; } , set : undefined , configurable : false , enumerable : false } ; } 
function set ( value ) { if ( value === true ) { while ( waitingQueue . length > 0 ) { waitingQueue [ 0 ] ( ) ; waitingQueue . shift ( ) ; } } return value ; } 
function attrAndStyleCheck ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } if ( args . length > 2 ) { return [ 'set' ] . concat ( args ) ; } if ( args . length === 2 ) { if ( [ 'video' , 'container' , 'wrapper' , 'videoElement' ] . indexOf ( args [ 0 ] ) > - 1 ) { return [ 'get' ] . concat ( args ) ; } return [ 'set' , 'container' ] . concat ( args ) ; } return [ 'get' , 'container' ] . concat ( args ) ; } 
function Plugin ( ) { var _ref = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } , id = _ref . id , name = _ref . name , _ref$level = _ref . level , level = _ref$level === undefined ? 0 : _ref$level , _ref$operable = _ref . operable , operable = _ref$operable === undefined ? true : _ref$operable , beforeCreate = _ref . beforeCreate , create = _ref . create , init = _ref . init , inited = _ref . inited , destroy = _ref . destroy , _ref$events = _ref . events , events = _ref$events === undefined ? { } : _ref$events , _ref$data = _ref . data , data = _ref$data === undefined ? { } : _ref$data , _ref$computed = _ref . computed , computed = _ref$computed === undefined ? { } : _ref$computed , _ref$methods = _ref . methods , methods = _ref$methods === undefined ? { } : _ref$methods , el = _ref . el , _ref$penetrate = _ref . penetrate , penetrate = _ref$penetrate === undefined ? false : _ref$penetrate , _ref$inner = _ref . inner , inner = _ref$inner === undefined ? true : _ref$inner , autoFocus = _ref . autoFocus , className = _ref . className ; var dispatcher = arguments [ 1 ] ; var option = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { name : name } ; _classCallCheck ( this , Plugin ) ; var _this = _possibleConstructorReturn ( this , ( Plugin . __proto__ || _Object$getPrototypeOf ( Plugin ) ) . call ( this ) ) ; _this . destroyed = false ; _this . VERSION = '0.11.0' ; _this . __operable = true ; _this . __level = 0 ; if ( isEmpty ( dispatcher ) ) { Log . error ( 'Dispatcher.plugin' , 'lack of dispatcher. Do you forget to pass arguments to super in plugin?' ) ; throw new TypeError ( 'lack of dispatcher' ) ; } if ( ! isString ( id ) ) { throw new TypeError ( 'id of PluginConfig must be string' ) ; } _this . __id = id ; _this . __dispatcher = dispatcher ; _this . $videoConfig = _this . __dispatcher . videoConfig ; _this . __wrapAsVideo ( _this . $videoConfig ) ; _this . beforeCreate = _this . beforeCreate || beforeCreate ; try { isFunction ( _this . beforeCreate ) && _this . beforeCreate ( { events : events , data : data , computed : computed , methods : methods } , option ) ; } catch ( error ) { _this . $throwError ( error ) ; } * the create Function of plugin * @type {Function} */ _this . create = _this . create || create ; _this . init = _this . init || init ; _this . inited = _this . inited || inited ; _this . destroy = _this . destroy || destroy ; _this . $dom = _this . __dispatcher . dom . insertPlugin ( _this . __id , el , { penetrate : penetrate , inner : inner , className : className } ) ; _this . $autoFocus = isBoolean ( autoFocus ) ? autoFocus : inner ; * to tell us if the plugin can be operable, can be dynamic change * @type {boolean} */ _this . $operable = isBoolean ( option . operable ) ? option . operable : operable ; _this . __level = isInteger$2 ( option . level ) ? option . level : level ; _this . $config = option ; try { isFunction ( _this . create ) && _this . create ( ) ; } catch ( error ) { _this . $throwError ( error ) ; } return _this ; } 
function Vessel ( dispatcher , target , config ) { var _this = this ; _classCallCheck ( this , Vessel ) ; this . __dispatcher = dispatcher ; this . __target = target ; [ 'width' , 'height' , 'position' , 'display' ] . forEach ( function ( key ) { _Object$defineProperty ( _this , key , { get : function get ( ) { return this . __dispatcher . dom . getStyle ( this . __target , key ) ; } , set : function set ( value ) { if ( isNumber ( value ) ) { value = value + 'px' ; } if ( ! isString ( value ) ) { throw new Error ( 'The value of ' + key + ' in ' + this . __target + 'Config must be string, but not ' + ( typeof value === 'undefined' ? 'undefined' : _typeof ( value ) ) + '.' ) ; } this . __dispatcher . dom . setStyle ( this . __target , key , value ) ; 
function clear ( ) { for ( var that = _validateCollection ( this , NAME ) , data = that . _i , entry = that . _f ; entry ; entry = entry . n ) { entry . r = true ; if ( entry . p ) entry . p = entry . p . n = undefined ; delete data [ entry . i ] ; } that . _f = that . _l = undefined ; that [ SIZE ] = 0 ; } 
function get ( key ) { var entry = _collectionStrong . getEntry ( _validateCollection ( this , MAP ) , key ) ; return entry && entry . v ; } 
function set ( key , value ) { return _collectionStrong . def ( _validateCollection ( this , MAP ) , key === 0 ? 0 : key , value ) ; } 
function getEventTargetByOldLogic ( oldName ) { var targetKeyReg = new RegExp ( '^(c|w)_' ) ; var matches = oldName . match ( targetKeyReg ) ; if ( matches ) { var _name = oldName . replace ( targetKeyReg , '' ) ; var _target = oldName . indexOf ( 'c' ) === 0 ? 'container' : 'wrapper' ; { Log . warn ( 'We no longer support event names like ' + oldName + '. Please use ' + _name + ' and options like { target: \'' + _target + '\' } instead' ) ; } return { name : _name , target : _target } ; } else if ( oldName === 'error' ) { return { name : 'error' , target : 'kernel' } ; } return false ; } 
function destroy ( ) { for ( var _key in this . plugins ) { this . unuse ( _key ) ; } this . binder . destroy ( ) ; delete this . binder ; this . dom . destroy ( ) ; delete this . dom ; this . kernel . destroy ( ) ; delete this . kernel ; delete this . vm ; delete this . plugins ; delete this . order ; } 
function getSDLiveUrl ( sn ) { const a = 've3.ji' ; const b = '60.c' ; return $ . ajax ( { url : 'https://li' + a + 'a.3' + b + 'n/public/getInfoAndPlayV2?from=mpc_ipcam_web&sn=36' + sn + '&taskid=' + + new Date ( ) , type : 'get' , dataType : 'jsonp' , } ) . then ( function ( data ) { let liveHLS = data && data . playInfo && data . playInfo . hls ; const ret = { } ; if ( liveHLS ) { if ( needFlv ) liveHLS = liveHLS . replace ( 'hls-live' , 'flv-live' ) . replace ( '/index.m3u8' , '.flv' ) ; ret . url = liveHLS ; ret . poster = data . publicInfo . thumbnail ; } return ret ; } ) ; } 
function rebuildPlayer ( { snow , river , city } ) { window . player && ! window . player . destroyed && window . player . destroy ( ) ; const Chimee = window . Chimee ; const snowSwitch = { name : 'snow-switch' , el : '<button>snow switch</button>' , create ( ) { this . $dom . addEventListener ( 'click' , ( ) => { this . $silentLoad ( snow , { repeatTimes : 5 , increment : 2 } ) ; } ) ; } , } ; const riverSwitch = { name : 'river-switch' , el : '<button>river switch</button>' , create ( ) { this . $dom . addEventListener ( 'click' , ( ) => { this . $silentLoad ( river , { repeatTimes : 5 , increment : 2 } ) ; } ) ; } , } ; const citySwitch = { name : 'city-switch' , el : '<button>city switch</button>' , create ( ) { this . $dom . addEventListener ( 'click' , ( ) => { this . $silentLoad ( city , { repeatTimes : 5 , increment : 2 } ) ; } ) ; } , } ; Chimee . install ( snowSwitch ) ; Chimee . install ( riverSwitch ) ; Chimee . install ( citySwitch ) ; Chimee . installKernel ( { flv : window . chimeeKernelFlv , hls : window . chimeeKernelHls , } ) ; const player = new Chimee ( { src : snow , box : needFlv ? 'flv' : 'hls' , wrapper : '#wrapper' , plugin : [ 'citySwitch' , 'riverSwitch' , 'snowSwitch' ] , volume : 0.1 , kernels : [ 'flv' , 'hls' ] , isLive : true , autoplay : true , controls : true , } ) ; window . player = player ; } 
function ChimeeKernel ( videoElement , config ) { _classCallCheck ( this , ChimeeKernel ) ; if ( ! chimeeHelper . isElement ( videoElement ) ) throw new Error ( 'You must pass in an video element to the chimee-kernel' ) ; this . config = config ; this . videoElement = videoElement ; this . initVideoKernel ( ) ; } 
function eventBinderCheck ( key , fn ) { if ( ! chimeeHelper . isString ( key ) ) throw new TypeError ( 'key parameter must be String' ) ; if ( ! chimeeHelper . isFunction ( fn ) ) throw new TypeError ( 'fn parameter must be Function' ) ; } 
function getEventTargetByOldLogic ( oldName ) { var targetKeyReg = new RegExp ( '^(c|w)_' ) ; var matches = oldName . match ( targetKeyReg ) ; if ( matches ) { var _name = oldName . replace ( targetKeyReg , '' ) ; var _target = oldName . indexOf ( 'c' ) === 0 ? 'container' : 'wrapper' ; if ( process . env . NODE_ENV !== 'production' ) { chimeeHelper . Log . warn ( 'We no longer support event names like ' + oldName + '. Please use ' + _name + ' and options like { target: \'' + _target + '\' } instead' ) ; } return { name : _name , target : _target } ; } else if ( oldName === 'error' ) { return { name : 'error' , target : 'kernel' } ; } return false ; } 
function Dispatcher ( config , vm ) { var _this = this ; _classCallCheck ( this , Dispatcher ) ; this . plugins = { } ; this . order = [ ] ; this . readySync = false ; this . zIndexMap = { inner : [ ] , outer : [ ] } ; this . changeWatchable = true ; this . kernelEventHandlerList = [ ] ; if ( ! chimeeHelper . isObject ( config ) ) throw new TypeError ( 'UserConfig must be an Object, but not "' + config + '" in ' + ( typeof config === 'undefined' ? 'undefined' : _typeof ( config ) ) ) ; this . dom = new Dom ( config , this ) ; this . vm = vm ; this . videoConfigReady = false ; * video kernel * @type {Kernel} */ this . kernel = this . _createKernel ( this . dom . videoElement , this . videoConfig ) ; this . binder . applyPendingEvents ( 'kernel' ) ; if ( config . noDefaultContextMenu ) { var noDefaultContextMenu = config . noDefaultContextMenu ; var target = noDefaultContextMenu === 'container' || noDefaultContextMenu === 'wrapper' ? noDefaultContextMenu : 'video-dom' ; this . binder . on ( { target : target , id : '_vm' , name : 'contextmenu' , fn : function fn ( evt ) { return evt . preventDefault ( ) ; } , stage : 'main' } ) ; } 
function oldVideoTimeupdate ( ) { var currentTime = _this2 . kernel . currentTime ; if ( bias <= 0 && currentTime >= idealTime || bias > 0 && ( Math . abs ( idealTime - currentTime ) <= bias && newVideoReady || currentTime - idealTime > bias ) ) { chimeeHelper . removeEvent ( _this2 . dom . videoElement , 'timeupdate' , oldVideoTimeupdate ) ; chimeeHelper . removeEvent ( video , 'error' , _videoError , true ) ; if ( ! newVideoReady ) { chimeeHelper . removeEvent ( video , 'canplay' , videoCanplay , true ) ; chimeeHelper . removeEvent ( video , 'loadedmetadata' , videoLoadedmetadata , true ) ; kernel . destroy ( ) ; return resolve ( ) ; } return reject ( { error : false , video : video , kernel : kernel } ) ; } } 
function registerEvents ( ) { var _ref = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } , name = _ref . name , target = _ref . target ; if ( ! name || ! chimeeHelper . isString ( name ) ) throw new Error ( 'The event name must be a string, but not ' + ( typeof name === 'undefined' ? 'undefined' : _typeof ( name ) ) ) ; if ( ! target || ! chimeeHelper . isString ( target ) ) throw new Error ( 'The event target must be a string, but not ' + ( typeof target === 'undefined' ? 'undefined' : _typeof ( target ) ) ) ; if ( target === 'kernel' ) { kernelEvents . push ( name ) ; } } 
function mkdirp ( dirpath , callback ) { fs . exists ( dirpath , function ( exists ) { if ( exists ) return callback ( dirpath ) ; mkdirp ( path . dirname ( dirpath ) , ( ) => fs . mkdir ( dirpath , callback ) ) ; } ) ; } 
function ( req , res , next ) { req . url = _ . replace ( req . url , / ^\/docsearch / , '' ) ; 
function ( runState ) { const [ a , b ] = runState . stack . popN ( 2 ) const r = new BN ( a . lt ( b ) ? 1 : 0 ) runState . stack . push ( r ) } 
function ( runState ) { const [ offset , length ] = runState . stack . popN ( 2 ) subMemUsage ( runState , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . isZero ( ) ) { data = runState . memory . read ( offset . toNumber ( ) , length . toNumber ( ) ) } 
function ( runState , cb ) { const number = runState . stack . pop ( ) var blockchain = runState . blockchain var diff = new BN ( runState . block . header . number ) . sub ( number ) 
function ( runState , done ) { if ( runState . static ) { trap ( ERROR . STATIC_STATE_CHANGE ) } const [ value , offset , length ] = runState . stack . popN ( 3 ) subMemUsage ( runState , offset , length ) let data = Buffer . alloc ( 0 ) if ( ! length . isZero ( ) ) { data = runState . memory . read ( offset . toNumber ( ) , length . toNumber ( ) ) } 
function ( runState , cb ) { let selfdestructToAddress = runState . stack . pop ( ) if ( runState . static ) { trap ( ERROR . STATIC_STATE_CHANGE ) } var stateManager = runState . stateManager var contract = runState . contract var contractAddress = runState . address selfdestructToAddress = addressToBuffer ( selfdestructToAddress ) stateManager . getAccount ( selfdestructToAddress , function ( err , toAccount ) { 
function subMemUsage ( runState , offset , length ) { 
function getDataSlice ( data , offset , length ) { let len = new BN ( data . length ) if ( offset . gt ( len ) ) { offset = len } let end = offset . add ( length ) if ( end . gt ( len ) ) { end = len } data = data . slice ( offset . toNumber ( ) , end . toNumber ( ) ) 
function checkCallMemCost ( runState , callOptions , localOpts ) { 
function makeCall ( runState , callOptions , localOpts , cb ) { var selfdestruct = Object . assign ( { } , runState . selfdestruct ) callOptions . caller = callOptions . caller || runState . address callOptions . origin = runState . origin callOptions . gasPrice = runState . gasPrice callOptions . block = runState . block callOptions . static = callOptions . static || false callOptions . selfdestruct = selfdestruct callOptions . storageReader = runState . storageReader 
function ( next ) { genesisBlock . header = new BlockHeader ( testData . genesisBlockHeader ) blockchain . putGenesis ( genesisBlock , next ) } 
function ( next ) { async . eachSeries ( testData . blocks , eachBlock , next ) function eachBlock ( raw , cb ) { try { var block = new Block ( Buffer . from ( raw . rlp . slice ( 2 ) , 'hex' ) ) 
function getHead ( next ) { vm . blockchain . getHead ( function ( err , block ) { 
function runVm ( err ) { 
function loadContract ( cb ) { stateManager . getAccount ( runState . address , function ( err , account ) { if ( err ) return cb ( err ) runState . contract = account cb ( ) } ) } 
function preprocessValidJumps ( runState ) { for ( var i = 0 ; i < runState . code . length ; i ++ ) { var curOpCode = lookupOpInfo ( runState . code [ i ] ) . name 
function getStartingState ( cb ) { 
function runBlock ( cb ) { self . runBlock ( { block : block , root : parentState } , function ( err , results ) { if ( err ) { 
function runCall ( cb ) { var options = { caller : tx . from , gasLimit : gasLimit , gasPrice : tx . gasPrice , to : tx . to , value : tx . value , data : tx . data , block : block , storageReader : storageReader } if ( tx . to . toString ( 'hex' ) === '' ) { delete options . to } 
function payOmmersAndMiner ( cb ) { var ommers = block . uncleHeaders 
function parseBlockResults ( err ) { if ( err ) { if ( checkpointedState ) { self . stateManager . revert ( function ( ) { cb ( err ) } ) } else { cb ( err ) } return } self . stateManager . commit ( function ( err ) { if ( err ) return cb ( err ) self . stateManager . getStateRoot ( function ( err , stateRoot ) { if ( err ) return cb ( err ) 
function setup ( cb ) { 
function runTx ( raw , cb ) { 
function checkResults ( cb ) { 
function readStorage ( cb ) { 
async function genSTS ( options ) { try { switch ( options . tplName ) { case 'swagger-list' : const st = await genSTBySTS ( options ) ; if ( st == null ) { console . warn ( ` ` ) ; } options . stUrl = options . extraArgs . swaggerPath ; options . stColumns = JSON . stringify ( st , null , 2 ) ; break ; case 'swagger-edit' : const sf = await genSFBySTS ( options ) ; if ( sf == null ) { console . warn ( ` ` ) ; } options . sfUrl = options . extraArgs . swaggerPath . replace ( / (\{[^\}]+\}) / g , '' ) ; options . sfSchema = JSON . stringify ( sf , null , 2 ) ; break ; default : throw new Error ( ` ${ options . tplName } ` ) } } catch ( err ) { throw new Error ( ` ${ err } ` ) ; } } 
function _handleKey ( character , modifiers , e ) { var self = this ; if ( ! self . recording ) { _origHandleKey . apply ( self , arguments ) ; return ; } 
function _recordKey ( key ) { var i ; 
function _normalizeSequence ( sequence ) { var i ; for ( i = 0 ; i < sequence . length ; ++ i ) { sequence [ i ] . sort ( function ( x , y ) { 
function _finishRecording ( ) { if ( _recordedSequenceCallback ) { _normalizeSequence ( _recordedSequence ) ; _recordedSequenceCallback ( _recordedSequence ) ; } 
function decorate ( decorators , target , propertyKey , attributes ) { if ( ! IsUndefined ( propertyKey ) ) { if ( ! IsArray ( decorators ) ) throw new TypeError ( ) ; if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsObject ( attributes ) && ! IsUndefined ( attributes ) && ! IsNull ( attributes ) ) throw new TypeError ( ) ; if ( IsNull ( attributes ) ) attributes = undefined ; propertyKey = ToPropertyKey ( propertyKey ) ; return DecorateProperty ( decorators , target , propertyKey , attributes ) ; } else { if ( ! IsArray ( decorators ) ) throw new TypeError ( ) ; if ( ! IsConstructor ( target ) ) throw new TypeError ( ) ; return DecorateConstructor ( decorators , target ) ; } } 
function metadata ( metadataKey , metadataValue ) { function decorator ( target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) && ! IsPropertyKey ( propertyKey ) ) throw new TypeError ( ) ; OrdinaryDefineOwnMetadata ( metadataKey , metadataValue , target , propertyKey ) ; } return decorator ; } 
function defineMetadata ( metadataKey , metadataValue , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryDefineOwnMetadata ( metadataKey , metadataValue , target , propertyKey ) ; } 
function hasMetadata ( metadataKey , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryHasMetadata ( metadataKey , target , propertyKey ) ; } 
function hasOwnMetadata ( metadataKey , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryHasOwnMetadata ( metadataKey , target , propertyKey ) ; } 
function getMetadata ( metadataKey , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryGetMetadata ( metadataKey , target , propertyKey ) ; } 
function getOwnMetadata ( metadataKey , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryGetOwnMetadata ( metadataKey , target , propertyKey ) ; } 
function getMetadataKeys ( target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryMetadataKeys ( target , propertyKey ) ; } 
function getOwnMetadataKeys ( target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; return OrdinaryOwnMetadataKeys ( target , propertyKey ) ; } 
function deleteMetadata ( metadataKey , target , propertyKey ) { if ( ! IsObject ( target ) ) throw new TypeError ( ) ; if ( ! IsUndefined ( propertyKey ) ) propertyKey = ToPropertyKey ( propertyKey ) ; var metadataMap = GetOrCreateMetadataMap ( target , propertyKey , false ) ; if ( IsUndefined ( metadataMap ) ) return false ; if ( ! metadataMap . delete ( metadataKey ) ) return false ; if ( metadataMap . size > 0 ) return true ; var targetMetadata = Metadata . get ( target ) ; targetMetadata . delete ( propertyKey ) ; if ( targetMetadata . size > 0 ) return true ; Metadata . delete ( target ) ; return true ; } 
function OrdinaryHasMetadata ( MetadataKey , O , P ) { var hasOwn = OrdinaryHasOwnMetadata ( MetadataKey , O , P ) ; if ( hasOwn ) return true ; var parent = OrdinaryGetPrototypeOf ( O ) ; if ( ! IsNull ( parent ) ) return OrdinaryHasMetadata ( MetadataKey , parent , P ) ; return false ; } 
function OrdinaryHasOwnMetadata ( MetadataKey , O , P ) { var metadataMap = GetOrCreateMetadataMap ( O , P , false ) ; if ( IsUndefined ( metadataMap ) ) return false ; return ToBoolean ( metadataMap . has ( MetadataKey ) ) ; } 
function OrdinaryGetMetadata ( MetadataKey , O , P ) { var hasOwn = OrdinaryHasOwnMetadata ( MetadataKey , O , P ) ; if ( hasOwn ) return OrdinaryGetOwnMetadata ( MetadataKey , O , P ) ; var parent = OrdinaryGetPrototypeOf ( O ) ; if ( ! IsNull ( parent ) ) return OrdinaryGetMetadata ( MetadataKey , parent , P ) ; return undefined ; } 
function OrdinaryGetOwnMetadata ( MetadataKey , O , P ) { var metadataMap = GetOrCreateMetadataMap ( O , P , false ) ; if ( IsUndefined ( metadataMap ) ) return undefined ; return metadataMap . get ( MetadataKey ) ; } 
function OrdinaryOwnMetadataKeys ( O , P ) { var keys = [ ] ; var metadataMap = GetOrCreateMetadataMap ( O , P , false ) ; if ( IsUndefined ( metadataMap ) ) return keys ; var keysObj = metadataMap . keys ( ) ; var iterator = GetIterator ( keysObj ) ; var k = 0 ; while ( true ) { var next = IteratorStep ( iterator ) ; if ( ! next ) { keys . length = k ; return keys ; } var nextValue = IteratorValue ( next ) ; try { keys [ k ] = nextValue ; } catch ( e ) { try { IteratorClose ( iterator ) ; } finally { throw e ; } } k ++ ; } } 
function ToPrimitive ( input , PreferredType ) { switch ( Type ( input ) ) { case 0 : return input ; case 1 : return input ; case 2 : return input ; case 3 : return input ; case 4 : return input ; case 5 : return input ; } var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default" ; var exoticToPrim = GetMethod ( input , toPrimitiveSymbol ) ; if ( exoticToPrim !== undefined ) { var result = exoticToPrim . call ( input , hint ) ; if ( IsObject ( result ) ) throw new TypeError ( ) ; return result ; } return OrdinaryToPrimitive ( input , hint === "default" ? "number" : hint ) ; } 
function OrdinaryToPrimitive ( O , hint ) { if ( hint === "string" ) { var toString_1 = O . toString ; if ( IsCallable ( toString_1 ) ) { var result = toString_1 . call ( O ) ; if ( ! IsObject ( result ) ) return result ; } var valueOf = O . valueOf ; if ( IsCallable ( valueOf ) ) { var result = valueOf . call ( O ) ; if ( ! IsObject ( result ) ) return result ; } } else { var valueOf = O . valueOf ; if ( IsCallable ( valueOf ) ) { var result = valueOf . call ( O ) ; if ( ! IsObject ( result ) ) return result ; } var toString_2 = O . toString ; if ( IsCallable ( toString_2 ) ) { var result = toString_2 . call ( O ) ; if ( ! IsObject ( result ) ) return result ; } } throw new TypeError ( ) ; } 
function ToPropertyKey ( argument ) { var key = ToPrimitive ( argument , 3 ) ; if ( IsSymbol ( key ) ) return key ; return ToString ( key ) ; } 
function IsArray ( argument ) { return Array . isArray ? Array . isArray ( argument ) : argument instanceof Object ? argument instanceof Array : Object . prototype . toString . call ( argument ) === "[object Array]" ; } 
function GetMethod ( V , P ) { var func = V [ P ] ; if ( func === undefined || func === null ) return undefined ; if ( ! IsCallable ( func ) ) throw new TypeError ( ) ; return func ; } 
function GetIterator ( obj ) { var method = GetMethod ( obj , iteratorSymbol ) ; if ( ! IsCallable ( method ) ) throw new TypeError ( ) ; 
function OrdinaryGetPrototypeOf ( O ) { var proto = Object . getPrototypeOf ( O ) ; if ( typeof O !== "function" || O === functionPrototype ) return proto ; 
function CreateMapPolyfill ( ) { var cacheSentinel = { } ; var arraySentinel = [ ] ; var MapIterator = ( function ( ) { function MapIterator ( keys , values , selector ) { this . _index = 0 ; this . _keys = keys ; this . _values = values ; this . _selector = selector ; } MapIterator . prototype [ "@@iterator" ] = function ( ) { return this ; } ; MapIterator . prototype [ iteratorSymbol ] = function ( ) { return this ; } ; MapIterator . prototype . next = function ( ) { var index = this . _index ; if ( index >= 0 && index < this . _keys . length ) { var result = this . _selector ( this . _keys [ index ] , this . _values [ index ] ) ; if ( index + 1 >= this . _keys . length ) { this . _index = - 1 ; this . _keys = arraySentinel ; this . _values = arraySentinel ; } else { this . _index ++ ; } return { value : result , done : false } ; } return { value : undefined , done : true } ; } ; MapIterator . prototype . throw = function ( error ) { if ( this . _index >= 0 ) { this . _index = - 1 ; this . _keys = arraySentinel ; this . _values = arraySentinel ; } throw error ; } ; MapIterator . prototype . return = function ( value ) { if ( this . _index >= 0 ) { this . _index = - 1 ; this . _keys = arraySentinel ; this . _values = arraySentinel ; } return { value : value , done : true } ; } ; return MapIterator ; } ( ) ) ; return ( function ( ) { function Map ( ) { this . _keys = [ ] ; this . _values = [ ] ; this . _cacheKey = cacheSentinel ; this . _cacheIndex = - 2 ; } Object . defineProperty ( Map . prototype , "size" , { get : function ( ) { return this . _keys . length ; } , enumerable : true , configurable : true } ) ; Map . prototype . has = function ( key ) { return this . _find ( key , false ) >= 0 ; } ; Map . prototype . get = function ( key ) { var index = this . _find ( key , false ) ; return index >= 0 ? this . _values [ index ] : undefined ; } ; Map . prototype . set = function ( key , value ) { var index = this . _find ( key , true ) ; this . _values [ index ] = value ; return this ; } ; Map . prototype . delete = function ( key ) { var index = this . _find ( key , false ) ; if ( index >= 0 ) { var size = this . _keys . length ; for ( var i = index + 1 ; i < size ; i ++ ) { this . _keys [ i - 1 ] = this . _keys [ i ] ; this . _values [ i - 1 ] = this . _values [ i ] ; } this . _keys . length -- ; this . _values . length -- ; if ( key === this . _cacheKey ) { this . _cacheKey = cacheSentinel ; this . _cacheIndex = - 2 ; } return true ; } return false ; } ; Map . prototype . clear = function ( ) { this . _keys . length = 0 ; this . _values . length = 0 ; this . _cacheKey = cacheSentinel ; this . _cacheIndex = - 2 ; } ; Map . prototype . keys = function ( ) { return new MapIterator ( this . _keys , this . _values , getKey ) ; } ; Map . prototype . values = function ( ) { return new MapIterator ( this . _keys , this . _values , getValue ) ; } ; Map . prototype . entries = function ( ) { return new MapIterator ( this . _keys , this . _values , getEntry ) ; } ; Map . prototype [ "@@iterator" ] = function ( ) { return this . entries ( ) ; } ; Map . prototype [ iteratorSymbol ] = function ( ) { return this . entries ( ) ; } ; Map . prototype . _find = function ( key , insert ) { if ( this . _cacheKey !== key ) { this . _cacheIndex = this . _keys . indexOf ( this . _cacheKey = key ) ; } if ( this . _cacheIndex < 0 && insert ) { this . _cacheIndex = this . _keys . length ; this . _keys . push ( key ) ; this . _values . push ( undefined ) ; } return this . _cacheIndex ; } ; return Map ; } ( ) ) ; function getKey ( key , _ ) { return key ; } function getValue ( _ , value ) { return value ; } function getEntry ( key , value ) { return [ key , value ] ; } } 
function CreateSetPolyfill ( ) { return ( function ( ) { function Set ( ) { this . _map = new _Map ( ) ; } Object . defineProperty ( Set . prototype , "size" , { get : function ( ) { return this . _map . size ; } , enumerable : true , configurable : true } ) ; Set . prototype . has = function ( value ) { return this . _map . has ( value ) ; } ; Set . prototype . add = function ( value ) { return this . _map . set ( value , value ) , this ; } ; Set . prototype . delete = function ( value ) { return this . _map . delete ( value ) ; } ; Set . prototype . clear = function ( ) { this . _map . clear ( ) ; } ; Set . prototype . keys = function ( ) { return this . _map . keys ( ) ; } ; Set . prototype . values = function ( ) { return this . _map . values ( ) ; } ; Set . prototype . entries = function ( ) { return this . _map . entries ( ) ; } ; Set . prototype [ "@@iterator" ] = function ( ) { return this . keys ( ) ; } ; Set . prototype [ iteratorSymbol ] = function ( ) { return this . keys ( ) ; } ; return Set ; } ( ) ) ; } 
function relevance ( result , searchString ) { var relevance = 0 ; relevance = Math . max ( 0 , 8 - result . match . chunks ) << 7 ; if ( result . match . caseMatch ) { relevance *= 2 ; } if ( result . match . prefix ) { relevance += 2048 } relevance += Math . max ( 0 , 255 - result . entry . key . length ) ; return relevance ; } 
function fuzzysearch ( searchString , haystack , caseInsensitive ) { var tlen = haystack . length ; var qlen = searchString . length ; var chunks = 1 ; var finding = false ; var prefix = true ; if ( qlen > tlen ) { return false ; } if ( qlen === tlen ) { if ( searchString === haystack ) { return { caseMatch : true , chunks : 1 , prefix : true } ; } else if ( searchString . toLowerCase ( ) === haystack . toLowerCase ( ) ) { return { caseMatch : false , chunks : 1 , prefix : true } ; } else { return false ; } } outer : for ( var i = 0 , j = 0 ; i < qlen ; i ++ ) { var nch = searchString [ i ] ; while ( j < tlen ) { var targetChar = haystack [ j ++ ] ; if ( targetChar === nch ) { finding = true ; continue outer ; } if ( finding ) { chunks ++ ; finding = false ; } } if ( caseInsensitive ) { return false } return fuzzysearch ( searchString . toLowerCase ( ) , haystack . toLowerCase ( ) , true ) ; } return { caseMatch : ! caseInsensitive , chunks : chunks , prefix : j <= qlen } ; } 
function getExternals ( api , pluginOptions ) { const nodeModulesPath = pluginOptions . nodeModulesPath || './node_modules' let nodeModulesPaths = [ ] if ( Array . isArray ( nodeModulesPath ) ) { 
function ( selectors , options ) { var self = this ; if ( ! selectors ) return _handleError ( '"selectors" is required. \nUsage: TableExport(selectors, options)' ) ; if ( ! self ) return new TableExport ( selectors , options ) ; self . settings = _extend ( { } , self . defaults , options ) ; self . selectors = _nodesArray ( selectors ) ; var settings = self . settings ; settings . ignoreRows = settings . ignoreRows instanceof Array ? settings . ignoreRows : [ settings . ignoreRows ] ; settings . ignoreCols = settings . ignoreCols instanceof Array ? settings . ignoreCols : [ settings . ignoreCols ] ; settings . ignoreCSS = self . ignoreCSS instanceof Array ? self . ignoreCSS : [ self . ignoreCSS ] ; settings . emptyCSS = self . emptyCSS instanceof Array ? self . emptyCSS : [ self . emptyCSS ] ; settings . formatValue = self . formatValue . bind ( this , settings . trimWhitespace ) ; settings . bootstrapSettings = _getBootstrapSettings ( settings . bootstrap , self . bootstrapConfig , self . defaultButton ) ; var _exportData = { } ; self . getExportData = function ( ) { return _exportData ; } ; self . selectors . forEach ( function ( el ) { var context = { } ; context . rows = _nodesArray ( el . querySelectorAll ( "tbody > tr" ) ) ; context . rows = settings . headers ? _nodesArray ( el . querySelectorAll ( "thead > tr" ) ) . concat ( context . rows ) : context . rows ; context . rows = settings . footers ? context . rows . concat ( _nodesArray ( el . querySelectorAll ( "tfoot > tr" ) ) ) : context . rows ; context . thAdj = settings . headers ? el . querySelectorAll ( "thead > tr" ) . length : 0 ; context . filename = settings . filename === "id" ? el . getAttribute ( "id" ) || self . defaultFilename : settings . filename || self . defaultFilename ; context . sheetname = settings . sheetname === "id" ? el . getAttribute ( "id" ) || self . defaultSheetname : settings . sheetname || self . defaultSheetname ; context . uuid = _uuid ( el ) ; context . checkCaption = function ( exportButton ) { var caption = el . querySelectorAll ( "caption." + self . defaultCaptionClass ) ; if ( caption . length ) { caption [ 0 ] . appendChild ( exportButton ) ; } else { caption = document . createElement ( "caption" ) ; caption . className = settings . bootstrapSettings . bootstrapSpacing + self . defaultCaptionClass ; caption . style . cssText = "caption-side: " + settings . position ; caption . appendChild ( exportButton ) ; el . insertBefore ( caption , el . firstChild ) ; } } ; context . setExportData = ( function ( ) { return function ( exporter ) { var data = Storage . getInstance ( ) . getItem ( exporter ) ; var type = exporter . substring ( exporter . indexOf ( "-" ) + 1 ) ; _exportData [ context . uuid ] = _exportData [ context . uuid ] || { } ; _exportData [ context . uuid ] [ type ] = JSON . parse ( data ) ; } ; } ) ( ) ; context . rcMap = new RowColMap ( ) . build ( context , settings ) ; var formatMap = _FORMAT_LIST . reduce ( function ( acc , cur ) { acc [ cur ] = 0 ; return acc ; } , { } ) ; settings . formats . forEach ( function ( key ) { if ( ! _isValidFormat ( key ) ) { return _handleError ( '"' + key + '" is not a valid format. \nFormats: ' + _FORMAT_LIST . join ( ", " ) ) ; } else if ( ! _hasDependencies ( key ) ) { 
function ( hashKey , dataObject , myContent , myClass , bootstrapSettings ) { var exportButton = document . createElement ( "button" ) ; exportButton . setAttribute ( "type" , "button" ) ; exportButton . setAttribute ( this . storageKey , hashKey ) ; exportButton . className = bootstrapSettings . bootstrapClass + bootstrapSettings . bootstrapTheme + myClass ; exportButton . textContent = myContent ; return exportButton ; } 
function ( string ) { var self = this ; return String ( string ) . replace ( / [&<>'\/] / g , function ( s ) { return self . entityMap [ s ] ; } ) ; } 
function ( string ) { var str = String ( string ) ; for ( var key in this . entityMap ) { str = str . replace ( RegExp ( this . entityMap [ key ] , "g" ) , key ) ; } return str ; } 
function ( string ) { if ( ! string ) return "" ; var types = this . typeConfig ; if ( ~ string . indexOf ( types . string . defaultClass ) ) { return _TYPE . STRING ; } else if ( ~ string . indexOf ( types . number . defaultClass ) ) { return _TYPE . NUMBER ; } else if ( ~ string . indexOf ( types . boolean . defaultClass ) ) { return _TYPE . BOOLEAN ; } else if ( ~ string . indexOf ( types . date . defaultClass ) ) { return _TYPE . DATE ; } else { return "" ; } } 
function ( v , date1904 ) { if ( date1904 ) v += 1462 ; var epoch = Date . parse ( v ) ; var result = ( epoch - new Date ( Date . UTC ( 1899 , 11 , 30 ) ) ) / ( 24 * 60 * 60 * 1000 ) ; return Math . floor ( result ) ; } 
function ( data , merges ) { var ws = { } ; var range = { s : { c : 10000000 , r : 10000000 } , e : { c : 0 , r : 0 } } ; var types = this . typeConfig ; for ( var R = 0 ; R !== data . length ; ++ R ) { for ( var C = 0 ; C !== data [ R ] . length ; ++ C ) { if ( range . s . r > R ) range . s . r = R ; if ( range . s . c > C ) range . s . c = C ; if ( range . e . r < R ) range . e . r = R ; if ( range . e . c < C ) range . e . c = C ; var cell = data [ R ] [ C ] ; if ( ! cell || ! cell . v ) continue ; var cell_ref = XLSX . utils . encode_cell ( { c : C , r : R } ) ; if ( ! cell . t ) { if ( types . number . assert ( cell . v ) ) cell . t = _TYPE . NUMBER ; else if ( types . boolean . assert ( cell . v ) ) cell . t = _TYPE . BOOLEAN ; else if ( types . date . assert ( cell . v ) ) cell . t = _TYPE . DATE ; else cell . t = _TYPE . STRING ; } if ( cell . t === _TYPE . DATE ) { cell . t = _TYPE . NUMBER ; cell . z = XLSX . SSF . _table [ 14 ] ; cell . v = this . dateNum ( cell . v ) ; } ws [ cell_ref ] = cell ; } } ws [ "!merges" ] = merges ; if ( range . s . c < 10000000 ) ws [ "!ref" ] = XLSX . utils . encode_range ( range ) ; return ws ; } 
function ( event ) { var target = event . target ; var object = JSON . parse ( Storage . getInstance ( ) . getItem ( target . getAttribute ( this . storageKey ) ) ) , data = object . data , filename = object . filename , mimeType = object . mimeType , fileExtension = object . fileExtension , merges = object . merges , RTL = object . RTL , sheetname = object . sheetname ; this . export2file ( data , mimeType , filename , fileExtension , merges , RTL , sheetname ) ; } 
function ( data , mime , name , extension , merges , RTL , sheetname ) { var format = extension . slice ( 1 ) ; data = this . getRawData ( data , extension , name , merges , RTL , sheetname ) ; if ( _isMobile && ( format === _FORMAT . CSV || format === _FORMAT . TXT ) ) { var dataURI = "data:" + mime + ";" + this . charset + "," + data ; this . downloadDataURI ( dataURI , name , extension ) ; } else { 
function ( ) { var self = this ; this . selectors . forEach ( function ( el ) { var caption = el . querySelector ( "caption." + self . defaultCaptionClass ) ; caption && el . removeChild ( caption ) ; } ) ; } 
function ( ) { this . _instance = null ; this . store = sessionStorage ; this . namespace = TableExport . prototype . defaultNamespace ; this . getKey = function ( key ) { return this . namespace + key ; } ; this . setItem = function ( _key , value , overwrite ) { var key = this . getKey ( _key ) ; if ( this . exists ( _key ) && ! overwrite ) { return ; } if ( typeof value !== "string" ) return _handleError ( '"value" must be a string.' ) ; this . store . setItem ( key , value ) ; return _key ; } ; this . getItem = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . getItem ( key ) ; } ; this . exists = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . getItem ( key ) !== null ; } ; this . removeItem = function ( _key ) { var key = this . getKey ( _key ) ; return this . store . removeItem ( key ) ; } ; } 
function ( ) { this . rcMap = [ ] ; this . merges = [ ] ; this . isIgnore = function ( ir , ic ) { var _ignore = RowColMap . prototype . TYPE . IGNORE ; return this . getRowColMapProp ( ir , ic , _ignore ) ; } ; this . isEmpty = function ( ir , ic ) { var _empty = RowColMap . prototype . TYPE . EMPTY ; return this . getRowColMapProp ( ir , ic , _empty ) ; } ; this . isRowSpan = function ( ir ) { var _rowspan = RowColMap . prototype . TYPE . ROWSPAN ; return this . getRowColMapProp ( ir , undefined , _rowspan ) ; } ; this . isColSpan = function ( ir ) { var _colspan = RowColMap . prototype . TYPE . COLSPAN ; return this . getRowColMapProp ( ir , undefined , _colspan ) ; } ; this . isSpan = function ( ir ) { return this . isRowSpan ( ir ) || this . isColSpan ( ir ) ; } ; this . isMerge = function ( ir ) { return this . merges . length > 0 ; } ; this . addMerge = function ( ir , mergeObj ) { var _merge = RowColMap . prototype . TYPE . MERGE ; this . merges . push ( mergeObj ) ; this . setRowColMapProp ( ir , undefined , _merge , this . merges ) ; } ; this . getRowColMapProp = function ( ir , ic , key ) { if ( this . rcMap [ ir ] ) { if ( typeof key === "undefined" ) { return this . rcMap [ ir ] [ ic ] ; } else if ( typeof ic === "undefined" ) { return this . rcMap [ ir ] [ key ] ; } else if ( this . rcMap [ ir ] [ ic ] ) { return this . rcMap [ ir ] [ ic ] [ key ] ; } } return undefined ; } ; this . setRowColMapProp = function ( ir , ic , key , value ) { this . rcMap [ ir ] = this . rcMap [ ir ] || [ ] ; if ( typeof key === "undefined" ) { return ( this . rcMap [ ir ] [ ic ] = value ) ; } else if ( typeof ic === "undefined" ) { return ( this . rcMap [ ir ] [ key ] = value ) ; } else { this . rcMap [ ir ] [ ic ] = this . rcMap [ ir ] [ ic ] || [ ] ; return ( this . rcMap [ ir ] [ ic ] [ key ] = value ) ; } } ; this . generateTotal = function ( ir , ic ) { var VALUE = RowColMap . prototype . TYPE . VALUE ; var _total = 0 ; if ( this . isRowSpan ( ir ) && this . isColSpan ( ir ) ) { _total = this . getRowColMapProp ( ir , ic , VALUE ) || 0 ; } else if ( this . getRowColMapProp ( ir , ic , VALUE ) ) { _total = this . getRowColMapProp ( ir , ic , VALUE ) ; } return _total ; } ; this . convertSpanToArray = function ( ir , ic , key , _return , colDel ) { if ( this . rcMap [ ir ] && this . isSpan ( ir ) ) { var total = this . generateTotal ( ir , ic ) ; if ( _isEnhanced ( key ) ) { return new Array ( total ) . concat ( _return ) ; } else { return new Array ( total ) . concat ( _return ) . join ( colDel ) ; } } return _return ; } ; this . handleRowColMapProp = function ( type , ir , ic , key , _return , colDel ) { switch ( type ) { case RowColMap . prototype . TYPE . IGNORE : return ; case RowColMap . prototype . TYPE . EMPTY : return " " ; case RowColMap . prototype . TYPE . DEFAULT : default : return this . convertSpanToArray ( ir , ic , key , _return , colDel ) ; } } ; } 
function ( ir , ic ) { self . setRowColMapProp ( ir , ic , self . TYPE . IGNORE , true ) ; } 
function formatMessage ( message , isError ) { var lines = message . split ( '\n' ) ; if ( lines . length > 2 && lines [ 1 ] === '' ) { 
function handleSuccess ( ) { clearOutdatedErrors ( ) var isHotUpdate = ! isFirstCompilation isFirstCompilation = false hasCompileErrors = false 
function copyFolder ( source , target ) { if ( ! fs . existsSync ( target ) ) { fs . mkdirSync ( target ) ; } ncp ( source , target , function ( err ) { if ( err ) { return console . error ( err ) ; } console . log ( ` ${ target } ` ) ; } ) ; } 
function getPlatformLibtensorflowUri ( ) { let targetUri = BASE_URI ; if ( platform === 'linux' ) { if ( os . arch ( ) === 'arm' ) { 
async function cleanDeps ( ) { if ( await exists ( depsPath ) ) { await rimrafPromise ( depsPath ) ; } await mkdir ( depsPath ) ; } 
async function downloadLibtensorflow ( callback ) { 
async function build ( ) { console . error ( '* Building TensorFlow Node.js bindings' ) ; cp . exec ( 'node-gyp rebuild' , ( err ) => { if ( err ) { throw new Error ( 'node-gyp rebuild failed with: ' + err ) ; } } ) ; } 
async function run ( ) { 
async function symlinkDepsLib ( ) { if ( destLibPath === undefined ) { throw new Error ( 'Destination path not supplied!' ) ; } try { await symlink ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await symlink ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } } catch ( e ) { console . error ( ` ${ destLibPath } ` ) ; await copy ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await copy ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } } } 
async function moveDepsLib ( ) { await rename ( depsLibTensorFlowPath , destLibPath ) ; if ( os . platform ( ) !== 'win32' ) { await rename ( depsLibTensorFlowFrameworkPath , destFrameworkLibPath ) ; } } 
async function run ( action ) { if ( action . endsWith ( 'symlink' ) ) { 
async function downloadAndUnpackResource ( uri , destPath , callback ) { 
function ( ast ) { let value = this . value ; ast . traverseByType ( 'space' , function ( space ) { space . content = space . content . replace ( / \t / , value ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node , index , parent ) { 
function ( ast ) { let value = this . value ; ast . traverse ( function ( node ) { 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node ) { if ( ! node . is ( 'block' ) && ! node . is ( 'atrulers' ) ) return ; if ( node . first ( ) . is ( 'space' ) ) { detected . push ( node . first ( ) . content ) ; } else { detected . push ( '' ) ; } } ) ; return detected ; } 
function ( ast ) { let detected = [ ] ; ast . traverseByType ( 'delimiter' , function ( delimiter , i , parent ) { if ( parent . is ( 'arguments' ) ) return ; var nextNode = parent . get ( i + 1 ) ; if ( nextNode && nextNode . is ( 'space' ) ) { detected . push ( nextNode . content ) ; } else if ( nextNode . first ( ) && nextNode . first ( ) . is ( 'space' ) ) { detected . push ( nextNode . first ( ) . content ) ; } else { detected . push ( '' ) ; } } ) ; return detected ; } 
function ( ast ) { let detected = [ ] ; ast . traverseByTypes ( [ 'block' , 'atrulers' ] , function ( node ) { 
function ( ast ) { var lastChild = ast . last ( ) ; if ( lastChild . is ( 'space' ) ) { lastChild . content = trim ( lastChild . content ) . replace ( / [ \t]+$ / , '' ) . replace ( / [\n]+ / g , '\n' ) ; } ast . traverseByType ( 'space' , function ( space ) { space . content = trim ( space . content ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; var lastChild = ast . last ( ) ; if ( lastChild . is ( 'space' ) && lastChild . content !== '\n' && lastChild . content . match ( / ^[ \n\t]+$ / ) ) { detected . push ( false ) ; } ast . traverseByType ( 'space' , function ( space ) { if ( space . content . match ( / [ \t]\n / ) ) detected . push ( false ) ; } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverseByType ( 'string' , function ( string ) { if ( string . content [ 0 ] === '"' && value === 'single' ) { string . content = string . content 
function ( ast ) { let detected = [ ] ; ast . traverseByType ( 'string' , function ( string ) { if ( string . content [ 0 ] === '"' ) { detected . push ( 'double' ) ; } else if ( string . content [ 0 ] === '\'' ) { detected . push ( 'single' ) ; } } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverseByType ( 'declarationDelimiter' , ( delimiter , i , parent ) => { 
function cssToAST ( text , syntax , filename ) { var string = JSON . stringify ; var fileInfo = filename ? ' at ' + filename : '' ; var tree ; try { tree = gonzales . parse ( text , { syntax : syntax } ) ; } catch ( e ) { throw new Error ( 'Parsing error' + fileInfo + ': ' + e . message ) ; } 
function detectInTree ( tree , handlers ) { var detectedOptions = { } ; 
function getDetectedOptions ( detected , handlers ) { var options = { } ; Object . keys ( detected ) . forEach ( function ( option ) { 
function getHandler ( optionName ) { var option = require ( './options/' + optionName ) ; if ( ! option . detect ) throw new Error ( 'Option does not have `detect()` method.' ) ; return { name : option . name , detect : option . detect , detectDefault : option . detectDefault } ; } 
function ( ast ) { let value = this . value ; ast . traverseByType ( 'number' , function ( number ) { if ( ! value ) { number . content = number . content . replace ( / ^0+(?=\.) / , '' ) ; } else if ( number . content [ 0 ] === '.' ) { number . content = '0' + number . content ; } } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverseByType ( 'number' , function ( number ) { if ( number . content . match ( / ^\.[0-9]+ / ) ) { detected . push ( false ) ; } else if ( number . content . match ( / ^0\.[0-9]+ / ) ) { detected . push ( true ) ; } } ) ; return detected ; } 
function ( ast ) { let value = this . value ; ast . traverseByType ( 'propertyDelimiter' , function ( delimiter , i , parent ) { if ( delimiter . syntax === 'sass' && ! parent . get ( i - 1 ) ) return null ; 
function ( ast ) { let detected = [ ] ; ast . traverseByType ( 'propertyDelimiter' , function ( delimiter , i , parent ) { var nextNode = parent . get ( i + 1 ) ; if ( nextNode . is ( 'space' ) ) { detected . push ( nextNode . content ) ; } else { detected . push ( '' ) ; } } ) ; return detected ; } 
function mergeAdjacentWhitespace ( node ) { var i = node . content . length - 1 ; while ( i -- > 0 ) { if ( node . get ( i ) . is ( 'space' ) && node . get ( i + 1 ) && node . get ( i + 1 ) . is ( 'space' ) ) { node . get ( i ) . content += node . get ( i + 1 ) . content ; node . removeChild ( i + 1 ) ; } } } 
function isEmptyBlock ( node ) { if ( ! node . length ) return true ; return ! node . content . some ( function ( node ) { return ! node . is ( 'space' ) ; } ) ; } 
function ( ast ) { let detected = [ ] ; ast . traverse ( function ( node ) { if ( ! node . is ( 'atrulers' ) && ! node . is ( 'block' ) ) return ; if ( node . length === 0 || ( node . length === 1 && node . first ( ) . is ( 'space' ) ) ) { detected . push ( false ) ; } } ) ; return detected ; } 
function getPrefixInfo ( propertyName , namespace , extraSymbols ) { var baseName = propertyName ; var prefixLength = 0 ; namespace = namespace || '' ; extraSymbols = extraSymbols || 0 ; if ( ! propertyName ) return ; PREFIXES . some ( function ( prefix ) { prefix = '-' + prefix + '-' ; if ( propertyName . indexOf ( prefix ) !== 0 ) return ; baseName = baseName . substr ( prefix . length ) ; prefixLength = prefix . length ; return true ; } ) ; return { id : namespace + baseName , baseName : baseName , prefixLength : prefixLength , extra : extraSymbols } ; } 
function extraIndent ( nodes ) { if ( ! nodes || ! nodes . length ) return ; var node ; var crPos ; var tabPos ; var result = 0 ; for ( var i = nodes . length ; i -- ; ) { node = nodes [ i ] ; if ( ! node . content ) { crPos = - 1 ; } else { crPos = node . content . lastIndexOf ( '\n' ) ; tabPos = node . content . lastIndexOf ( '\t' ) ; if ( tabPos > crPos ) crPos = tabPos ; } if ( crPos !== - 1 ) oneline = false ; if ( node . is ( 'space' ) ) { result += node . content . length - crPos - 1 ; if ( crPos !== - 1 ) break ; } if ( node . is ( 'multilineComment' ) ) { if ( crPos === - 1 ) { 
function extraIndentProperty ( nodes , i ) { var subset = [ ] ; while ( i -- ) { if ( ! nodes . get ( i ) || nodes . get ( i ) . is ( 'declarationDelimiter' ) ) break ; subset . unshift ( nodes . get ( i ) ) ; } return extraIndent ( subset ) ; } 
function extraIndentVal ( nodes , i ) { var subset = [ ] ; var declaration = nodes . get ( i ) ; if ( ! declaration . is ( 'declaration' ) ) return ; for ( var x = declaration . length ; x -- ; ) { if ( ! declaration . get ( x ) . is ( 'value' ) ) continue ; x -- ; while ( ! declaration . get ( x ) . is ( 'propertyDelimiter' ) ) { subset . push ( declaration . get ( x ) ) ; x -- ; } break ; } return extraIndent ( subset ) ; } 
function walk ( args ) { args . node . forEach ( function ( item , i ) { var name = args . selector ( item ) ; var namespace = args . namespaceSelector && makeNamespace ( args . namespaceSelector ( item ) ) ; var extraSymbols = args . getExtraSymbols ( args . node , i ) ; var info = name && getPrefixInfo ( name , namespace , extraSymbols ) ; if ( ! info ) return ; args . payload ( info , i ) ; } ) ; } 
function getValName ( node ) { if ( ! node . is ( 'declaration' ) ) return ; var value = node . first ( 'value' ) ; if ( value . get ( 0 ) . is ( 'ident' ) ) return value . get ( 0 ) . content ; if ( value . get ( 0 ) . is ( 'function' ) ) return value . get ( 0 ) . get ( 0 ) . content ; } 
function updateDict ( info , dict ) { if ( info . prefixLength === 0 && info . extra === 0 ) return ; var indent = dict [ info . id ] || { prefixLength : 0 , extra : 0 } ; let indentLength = indent . prefixLength + indent . extra ; let infoLength = info . prefixLength + info . extra ; if ( indentLength > infoLength ) { dict [ info . id ] = indent ; } else { dict [ info . id ] = { prefixLength : info . prefixLength , extra : info . extra } ; } } 
function updateIndent ( info , dict , whitespaceNode ) { var item = dict [ info . id ] ; if ( ! item ) return whitespaceNode ; var crPos = whitespaceNode . lastIndexOf ( '\n' ) ; var tabPos = whitespaceNode . lastIndexOf ( '\t' ) ; if ( tabPos > crPos ) crPos = tabPos ; var firstPart = whitespaceNode . substr ( 0 , crPos + 1 ) ; var extraIndent = new Array ( ( item . prefixLength - info . prefixLength ) + ( item . extra - info . extra ) + whitespaceNode . length - firstPart . length + 1 ) . join ( ' ' ) ; return firstPart . concat ( extraIndent ) ; } 
function ( ast ) { ast . traverseByType ( 'block' , function ( node ) { oneline = true ; var dict = { } ; 
function ( ast ) { let detected = [ ] ; ast . traverseByType ( 'block' , function ( node ) { var result = { true : 0 , false : 0 } ; var maybePrefix = false ; var prevPrefixLength = false ; var prevProp ; var prevSum ; var partialResult = null ; var getResult = function ( options ) { let { node , sum , info , i } = options ; var prop = info . baseName ; 
function ( ast ) { let value = this . value ; 
function ( ast ) { var detected = [ ] ; ast . traverseByTypes ( [ 'block' , 'value' ] , function ( block , i , parent ) { if ( block . is ( 'value' ) && ! block . first ( ) . is ( 'block' ) ) return ; var previousNode = parent . get ( i - 1 ) ; if ( ! previousNode ) return ; 
function onWindowResize ( ) { 
function gui ( ) { var gui = new dat . GUI ( { autoPlace : false } ) ; var customContainer = document . getElementById ( 'my-gui-container' ) ; customContainer . appendChild ( gui . domElement ) ; 
function animate ( ) { controls . update ( ) ; renderer . render ( scene , camera ) ; controls1 . update ( ) ; renderer1 . render ( scene1 , camera1 ) ; 
function init ( ) { 
function ( vertex , face ) { vertex . face = face ; if ( face . outside === null ) { this . assigned . append ( vertex ) ; } else { this . assigned . insertBefore ( face . outside , vertex ) ; } face . outside = vertex ; return this ; } 
function ( vertex , face ) { if ( vertex === face . outside ) { 
function ( face ) { if ( face . outside !== null ) { 
function ( face , absorbingFace ) { var faceVertices = this . removeAllVerticesFromFace ( face ) ; if ( faceVertices !== undefined ) { if ( absorbingFace === undefined ) { 
function ( newFaces ) { if ( this . unassigned . isEmpty ( ) === false ) { var vertex = this . unassigned . first ( ) ; do { 
function ( ) { var min = new THREE . Vector3 ( ) ; var max = new THREE . Vector3 ( ) ; var minVertices = [ ] ; var maxVertices = [ ] ; var i , l , j ; 
function ( ) { var activeFaces = [ ] ; for ( var i = 0 ; i < this . faces . length ; i ++ ) { var face = this . faces [ i ] ; if ( face . mark === Visible ) { activeFaces . push ( face ) ; } } this . faces = activeFaces ; return this ; } 
function ( ) { 
function ( eyePoint , crossEdge , face , horizon ) { 
function ( eyeVertex , horizonEdge ) { 
function ( eyeVertex , horizon ) { this . newFaces = [ ] ; var firstSideEdge = null ; var previousSideEdge = null ; for ( var i = 0 ; i < horizon . length ; i ++ ) { var horizonEdge = horizon [ i ] ; 
function ( eyeVertex ) { var horizon = [ ] ; this . unassigned . clear ( ) ; 
function HalfEdge ( vertex , face ) { this . vertex = vertex ; this . prev = null ; this . next = null ; this . twin = null ; this . face = face ; } 
function VertexNode ( point ) { this . point = point ; this . prev = null ; this . next = null ; this . face = null ; 
function ( target , vertex ) { vertex . prev = target . prev ; vertex . next = target ; if ( vertex . prev === null ) { this . head = vertex ; } else { vertex . prev . next = vertex ; } target . prev = vertex ; return this ; } 
function ( target , vertex ) { vertex . prev = target ; vertex . next = target . next ; if ( vertex . next === null ) { this . tail = vertex ; } else { vertex . next . prev = vertex ; } target . next = vertex ; return this ; } 
function ( vertex ) { if ( this . head === null ) { this . head = vertex ; } else { this . tail . next = vertex ; } vertex . prev = this . tail ; vertex . next = null ; 
function ( vertex ) { if ( vertex . prev === null ) { this . head = vertex . next ; } else { vertex . prev . next = vertex . next ; } if ( vertex . next === null ) { this . tail = vertex . prev ; } else { vertex . next . prev = vertex . prev ; } return this ; } 
function ( a , b ) { if ( a . prev === null ) { this . head = b . next ; } else { a . prev . next = b . next ; } if ( b . next === null ) { this . tail = a . prev ; } else { b . next . prev = a . prev ; } return this ; } 
function ( container ) { this . _container = container ; this . _modes = { load : { name : 'load' , color : '#FF0000' } , parse : { name : 'parse' , color : '#00FF00' } } ; this . _requestAnimationFrameID = null ; this . _mode = null ; this . _value = null ; this . _total = null ; this . init = function ( ) { var container = document . createElement ( 'div' ) ; container . classList . add ( 'progress' ) ; container . classList . add ( 'container' ) ; container . innerHTML = '<div class="progress load"></div><div class="progress parse">Parsing data <div class="beat">♥</div></div>'; this . _container . appendChild ( container ) ; 
function onWindowResize ( ) { camera . aspect = container . offsetWidth / container . offsetHeight ; camera . updateProjectionMatrix ( ) ; renderer . setSize ( container . offsetWidth , container . offsetHeight ) ; } 
function animate ( ) { 
function info ( msg ) { if ( PDFJS . verbosity >= PDFJS . VERBOSITY_LEVELS . infos ) { console . log ( 'Info: ' + msg ) ; } } 
function warn ( msg ) { if ( PDFJS . verbosity >= PDFJS . VERBOSITY_LEVELS . warnings ) { console . log ( 'Warning: ' + msg ) ; } } 
function error ( msg ) { 
function combineUrl ( baseUrl , url ) { if ( ! url ) { return baseUrl ; } if ( / ^[a-z][a-z0-9+\-.]*: / i . test ( url ) ) { return url ; } var i ; if ( url . charAt ( 0 ) === '/' ) { 
function isValidUrl ( url , allowRelative ) { if ( ! url ) { return false ; } 
function hasCanvasTypedArrays ( ) { var canvas = document . createElement ( 'canvas' ) ; canvas . width = canvas . height = 1 ; var ctx = canvas . getContext ( '2d' ) ; var imageData = ctx . createImageData ( 1 , 1 ) ; return ( typeof imageData . data . buffer !== 'undefined' ) ; } 
function PageViewPort_clone ( args ) { args = args || { } ; var scale = 'scale' in args ? args . scale : this . scale ; var rotation = 'rotation' in args ? args . rotation : this . rotation ; return new PageViewport ( this . viewBox . slice ( ) , scale , rotation , this . offsetX , this . offsetY , args . dontFlip ) ; } 
function PageViewport_convertToViewportRectangle ( rect ) { var tl = Util . applyTransform ( [ rect [ 0 ] , rect [ 1 ] ] , this . transform ) ; var br = Util . applyTransform ( [ rect [ 2 ] , rect [ 3 ] ] , this . transform ) ; return [ tl [ 0 ] , tl [ 1 ] , br [ 0 ] , br [ 1 ] ] ; } 
function createPromiseCapability ( ) { var capability = { } ; capability . promise = new Promise ( function ( resolve , reject ) { capability . resolve = resolve ; capability . reject = reject ; } ) ; return capability ; } 
function messageHandlerSend ( actionName , data , transfers ) { var message = { action : actionName , data : data } ; this . postMessage ( message , transfers ) ; } 
function messageHandlerSendWithPromise ( actionName , data , transfers ) { var callbackId = this . callbackIndex ++ ; var message = { action : actionName , data : data , callbackId : callbackId } ; var capability = createPromiseCapability ( ) ; this . callbacksCapabilities [ callbackId ] = capability ; try { this . postMessage ( message , transfers ) ; } catch ( e ) { capability . reject ( e ) ; } return capability . promise ; } 
function ( message , transfers ) { if ( transfers && this . postMessageTransfers ) { this . comObj . postMessage ( message , transfers ) ; } else { this . comObj . postMessage ( message ) ; } } 
function init ( ) { function animate ( ) { 
function hookCallbacks ( stackHelper ) { let stack = stackHelper . _stack ; * On window resize callback */ function onWindowResize ( ) { let threeD = document . getElementById ( 'r3d' ) ; camera . canvas = { width : threeD . clientWidth , height : threeD . clientHeight , } ; camera . fitBox ( 2 ) ; renderer . setSize ( threeD . clientWidth , threeD . clientHeight ) ; * On key pressed callback */ function onWindowKeyPressed ( event ) { ctrlDown = event . ctrlKey ; if ( ! ctrlDown ) { drag . start . x = null ; drag . start . y = null ; } } document . addEventListener ( 'keydown' , onWindowKeyPressed , false ) ; document . addEventListener ( 'keyup' , onWindowKeyPressed , false ) ; function onMouseMove ( event ) { if ( ctrlDown ) { if ( drag . start . x === null ) { drag . start . x = event . clientX ; drag . start . y = event . clientY ; } let threshold = 15 ; stackHelper . slice . intensityAuto = false ; let dynamicRange = stack . minMax [ 1 ] - stack . minMax [ 0 ] ; dynamicRange /= threeD . clientWidth ; if ( Math . abs ( event . clientX - drag . start . x ) > threshold ) { 
function onWindowResize ( ) { let threeD = document . getElementById ( 'r3d' ) ; camera . canvas = { width : threeD . clientWidth , height : threeD . clientHeight , } ; camera . fitBox ( 2 ) ; renderer . setSize ( threeD . clientWidth , threeD . clientHeight ) ; 
function onWindowKeyPressed ( event ) { ctrlDown = event . ctrlKey ; if ( ! ctrlDown ) { drag . start . x = null ; drag . start . y = null ; } } 
function onMouseMove ( event ) { if ( ctrlDown ) { if ( drag . start . x === null ) { drag . start . x = event . clientX ; drag . start . y = event . clientY ; } let threshold = 15 ; stackHelper . slice . intensityAuto = false ; let dynamicRange = stack . minMax [ 1 ] - stack . minMax [ 0 ] ; dynamicRange /= threeD . clientWidth ; if ( Math . abs ( event . clientX - drag . start . x ) > threshold ) { 
function handleSeries ( seriesContainer ) { 
function _filterByExtension ( extension , item ) { if ( item . extension . toUpperCase ( ) === extension . toUpperCase ( ) ) { return true ; } return false ; } 
function readMultipleFiles ( evt ) { * Load sequence */ function loadSequence ( index , files ) { return ( Promise . resolve ( ) * Load group sequence */ function loadSequenceGroup ( files ) { const fetchSequence = [ ] ; for ( let i = 0 ; i < files . length ; i ++ ) { fetchSequence . push ( new Promise ( ( resolve , reject ) => { const myReader = new FileReader ( ) ; 
function loadSequence ( index , files ) { return ( Promise . resolve ( ) 
function loadSequenceGroup ( files ) { const fetchSequence = [ ] ; for ( let i = 0 ; i < files . length ; i ++ ) { fetchSequence . push ( new Promise ( ( resolve , reject ) => { const myReader = new FileReader ( ) ; 
function rgbToHex ( r , g , b ) { return '#' + componentToHex ( r ) + componentToHex ( g ) + componentToHex ( b ) ; } 
function updateGeometries ( ) { if ( stackHelper ) { 
function init ( ) { function animate ( ) { updateGeometries ( ) ; render ( ) ; 
function init ( ) { function animate ( ) { 
function animate ( ) { 
function init ( ) { function animate ( ) { render ( ) ; 
function updateLocalizer ( refObj , targetLocalizersHelpers ) { let refHelper = refObj . stackHelper ; let localizerHelper = refObj . localizerHelper ; let plane = refHelper . slice . cartesianEquation ( ) ; localizerHelper . referencePlane = plane ; 
function ConvexGeometry ( points ) { THREE . Geometry . call ( this ) ; this . type = 'ConvexGeometry' ; this . fromBufferGeometry ( new ConvexBufferGeometry ( points ) ) ; this . mergeVertices ( ) ; } 
function ConvexBufferGeometry ( points ) { THREE . BufferGeometry . call ( this ) ; this . type = 'ConvexBufferGeometry' ; 
function animate ( ) { 
function setupEditor ( ) { function distanceBetween ( point1 , point2 ) { return Math . sqrt ( Math . pow ( point2 . x - point1 . x , 2 ) + Math . pow ( point2 . y - point1 . y , 2 ) ) ; } function angleBetween ( point1 , point2 ) { return Math . atan2 ( point2 . x - point1 . x , point2 . y - point1 . y ) ; } function initEditorStats ( ) { let nbVoxels = stack2 . _columns * stack2 . _rows * stack2 . _frame . length ; let textureSize = 4096 ; let textureDimension = textureSize * textureSize ; for ( let i = 0 ; i < nbVoxels ; i ++ ) { let rawDataIndex = ~ ~ ( i / textureDimension ) ; let inRawDataIndex = i % textureDimension ; let value = stack2 . rawData [ rawDataIndex ] [ inRawDataIndex ] ; editorStats [ value ] += 1 ; } updateEditorStatsDom ( ) ; } function updateEditorStatsDom ( ) { for ( let i = 0 ; i < 3 ; i ++ ) { document . getElementById ( ` ${ i } ` ) . innerHTML = segmentsList [ i ] ; document . getElementById ( ` ${ i } ` ) . innerHTML = editorStats [ i ] ; } } function mapCanvasToData ( ) { for ( let i = ijkBBox [ 0 ] ; i < ijkBBox [ 1 ] + 1 ; i ++ ) { for ( let j = ijkBBox [ 2 ] ; j < ijkBBox [ 3 ] + 1 ; j ++ ) { for ( let k = ijkBBox [ 4 ] ; k < ijkBBox [ 5 ] + 1 ; k ++ ) { * */ function drawCircle ( x , y ) { context . beginPath ( ) ; context . arc ( x , y , cursor . size , false , Math . PI * 2 , false ) ; context . closePath ( ) ; context . fill ( ) ; context . stroke ( ) ; } function clearCanvas ( ) { context . clearRect ( 0 , 0 , context . canvas . width , context . canvas . height ) ; } function addEventListeners ( ) { function onMouseDown ( e ) { if ( ! isEditing ) return ; isDrawing = true ; lastPoint = { x : e . pageX - canvasDiv . offsetLeft , y : e . pageY - canvasDiv . offsetTop , } ; } function onMouseMove ( e ) { if ( ! isEditing ) return ; currentPoint = { x : e . pageX - canvasDiv . offsetLeft , y : e . pageY - canvasDiv . offsetTop , } ; context . strokeStyle = cursor . color ; context . globalCompositeOperation = 'xor' ; context . globalAlpha = 0.5 ; context . fillStyle = cursor . color ; if ( isDrawing ) { let dist = distanceBetween ( lastPoint , currentPoint ) ; let angle = angleBetween ( lastPoint , currentPoint ) ; for ( let i = 0 ; i < dist ; i += 5 ) { let x = lastPoint . x + Math . sin ( angle ) * i ; let y = lastPoint . y + Math . cos ( angle ) * i ; drawCircle ( x , y ) ; } lastPoint = currentPoint ; } else { clearCanvas ( ) ; } * */ function onMouseUp ( e ) { if ( ! isEditing ) return ; isDrawing = false ; mapCanvasToData ( ) ; clearCanvas ( ) ; updateEditorStatsDom ( ) ; * */ function updateDOM ( ) { * */ function onKeyDown ( e ) { if ( e . keyCode === 17 ) { isEditing = true ; isDrawing = false ; updateDOM ( ) ; } } function onKeyUp ( e ) { if ( e . keyCode === 17 ) { isEditing = false ; isDrawing = false ; clearCanvas ( ) ; updateDOM ( ) ; } } function disableRightClick ( e ) { e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; } 
function mapCanvasToData ( ) { for ( let i = ijkBBox [ 0 ] ; i < ijkBBox [ 1 ] + 1 ; i ++ ) { for ( let j = ijkBBox [ 2 ] ; j < ijkBBox [ 3 ] + 1 ; j ++ ) { for ( let k = ijkBBox [ 4 ] ; k < ijkBBox [ 5 ] + 1 ; k ++ ) { 
function getShortlinker ( ) { if ( globalScope . yoast . shortlinker === null ) { globalScope . yoast . shortlinker = new Shortlinker ( ) ; } return globalScope . yoast . shortlinker ; } 
function ( sentencePartText , auxiliaries , locale ) { this . _sentencePartText = sentencePartText ; this . _auxiliaries = auxiliaries ; this . _locale = locale ; this . _isPassive = false ; } 
function ( i18n , options = { } ) { Assessor . call ( this , i18n , options ) ; this . type = "ContentAssessor" ; const locale = ( options . hasOwnProperty ( "locale" ) ) ? options . locale : "en_US" ; this . _assessments = [ new FleschReadingEase ( contentConfiguration ( locale ) . fleschReading ) , new SubheadingDistributionTooLong ( ) , paragraphTooLong , new SentenceLengthInText ( contentConfiguration ( locale ) . sentenceLength ) , transitionWords , passiveVoice , textPresence , sentenceBeginnings , 
function DeviationFragment ( options ) { this . _location = options . location ; this . _fragment = options . word ; this . _syllables = options . syllables ; this . _regex = null ; this . _options = pick ( options , [ "notFollowedBy" , "alsoFollowedBy" ] ) ; } 
function sortResults ( assessmentResults ) { return assessmentResults . sort ( ( a , b ) => { 
function mapResult ( result ) { result . id = result . getIdentifier ( ) ; result . rating = scoreToRating ( result . score ) ; result . hasMarks = result . hasMarks ( ) ; result . marker = result . getMarker ( ) ; 
function mapResults ( results ) { const mappedResults = [ ] ; for ( let i = 0 ; i < results . length ; i ++ ) { if ( ! results [ i ] . text ) { continue ; } mappedResults . push ( mapResult ( results [ i ] ) ) ; } return sortResults ( mappedResults ) ; } 
function ( participle , sentencePart , attributes ) { Participle . call ( this , participle , sentencePart , attributes ) ; this . setSentencePartPassiveness ( this . isPassive ( ) ) ; } 
function ( args ) { this . keyword = args . keyword ; this . assessor = args . assessor ; this . i18n = args . i18n ; this . output = args . targets . output ; this . overall = args . targets . overall || "overallScore" ; this . presenterConfig = createConfig ( args . i18n ) ; this . _disableMarkerButtons = false ; this . _activeMarker = false ; } 
function createTokenizer ( ) { tokens = [ ] ; htmlBlockTokenizer = core ( function ( token ) { tokens . push ( token ) ; } ) ; htmlBlockTokenizer . addRule ( contentRegex , "content" ) ; htmlBlockTokenizer . addRule ( greaterThanContentRegex , "greater-than-sign-content" ) ; htmlBlockTokenizer . addRule ( blockElementStartRegex , "block-start" ) ; htmlBlockTokenizer . addRule ( blockElementEndRegex , "block-end" ) ; htmlBlockTokenizer . addRule ( inlineElementStartRegex , "inline-start" ) ; htmlBlockTokenizer . addRule ( inlineElementEndRegex , "inline-end" ) ; htmlBlockTokenizer . addRule ( otherElementStartRegex , "other-element-start" ) ; htmlBlockTokenizer . addRule ( otherElementEndRegex , "other-element-end" ) ; } 
function getBlocks ( text ) { var blocks = [ ] , depth = 0 , blockStartTag = "" , currentBlock = "" , blockEndTag = "" ; * We try to match the most deep blocks so discard any other blocks that have been started but not * finished. */ if ( "" !== blockStartTag && "" !== blockEndTag ) { blocks . push ( blockStartTag + currentBlock + blockEndTag ) ; } else if ( "" !== currentBlock . trim ( ) ) { blocks . push ( currentBlock ) ; } blockStartTag = "" ; currentBlock = "" ; blockEndTag = "" ; break ; } 
function formatNumber ( number ) { if ( Math . round ( number ) === number ) { return number ; } return Math . round ( number * 10000 ) / 10000 ; } 
function ( participle , sentencePart , attributes ) { Participle . call ( this , participle , sentencePart , attributes ) ; checkException . call ( this ) ; } 
function ( participleExceptionRegexes ) { var participle = this . getParticiple ( ) ; var match = [ ] ; forEach ( participleExceptionRegexes , function ( participleExceptionRegex ) { var exceptionMatch = participle . match ( participleExceptionRegex ) ; if ( exceptionMatch ) { match . push ( exceptionMatch [ 0 ] ) ; } } ) ; if ( match . length > 0 ) { return true ; } return false ; } 
function getSentenceBeginning ( sentence , firstWordExceptions ) { const words = getWords ( stripTags ( stripSpaces ( sentence ) ) ) ; if ( words . length === 0 ) { return "" ; } let firstWord = words [ 0 ] . toLocaleLowerCase ( ) ; if ( firstWordExceptions . indexOf ( firstWord ) > - 1 && words . length > 1 ) { firstWord += " " + words [ 1 ] ; } return firstWord ; } 
function textPresenceAssessment ( paper , researcher , i18n ) { const text = stripHTMLTags ( paper . getText ( ) ) ; const urlTitle = createAnchorOpeningTag ( "https://yoa.st/35h" ) ; const urlCallToAction = createAnchorOpeningTag ( "https://yoa.st/35i" ) ; if ( text . length < 50 ) { const result = new AssessmentResult ( ) ; result . setText ( i18n . sprintf ( i18n . dgettext ( "js-text-analysis" , "%1$sNot enough content%2$s: %3$sPlease add some content to enable a good analysis%2$s." ) , urlTitle , "</a>" , urlCallToAction ) ) ; result . setScore ( 3 ) ; return result ; } return new AssessmentResult ( ) ; } 
function splitOnWords ( sentence , stopwords ) { const splitSentences = [ ] ; 
function createSentenceParts ( sentences , language ) { const auxiliaryRegex = languageVariables [ language ] . auxiliaryRegex ; const SentencePart = languageVariables [ language ] . SentencePart ; const sentenceParts = [ ] ; forEach ( sentences , function ( part ) { const foundAuxiliaries = sanitizeMatches ( part . match ( auxiliaryRegex || [ ] ) ) ; sentenceParts . push ( new SentencePart ( part , foundAuxiliaries , languageVariables [ language ] . locale ) ) ; } ) ; return sentenceParts ; } 
function splitSentence ( sentence , language ) { const stopwordRegex = languageVariables [ language ] . stopwordRegex ; const stopwords = sentence . match ( stopwordRegex ) || [ ] ; const splitSentences = splitOnWords ( sentence , stopwords ) ; return createSentenceParts ( splitSentences , language ) ; } 
function createDefaultSnippetPreview ( ) { var targetElement = document . getElementById ( this . config . targets . snippet ) ; return new SnippetPreview ( { analyzerApp : this , targetElement : targetElement , callbacks : { saveSnippetData : this . config . callbacks . saveSnippetData , } , } ) ; } 
function verifyArguments ( args ) { if ( ! isObject ( args . callbacks . getData ) ) { throw new MissingArgument ( "The app requires an object with a getdata callback." ) ; } if ( ! isObject ( args . targets ) ) { throw new MissingArgument ( "`targets` is a required App argument, `targets` is not an object." ) ; } 
function ( args ) { if ( ! isObject ( args ) ) { args = { } ; } defaultsDeep ( args , defaults ) ; verifyArguments ( args ) ; this . config = args ; if ( args . debouncedRefresh === true ) { this . refresh = debounce ( this . refresh . bind ( this ) , inputDebounceDelay ) ; } this . _pureRefresh = throttle ( this . _pureRefresh . bind ( this ) , this . config . typeDelay ) ; this . callbacks = this . config . callbacks ; this . i18n = this . constructI18n ( this . config . translations ) ; this . initializeAssessors ( args ) ; this . pluggable = new Pluggable ( this ) ; this . getData ( ) ; this . defaultOutputElement = this . getDefaultOutputElement ( args ) ; if ( this . defaultOutputElement !== "" ) { this . showLoadingDialog ( ) ; } if ( isValidSnippetPreview ( args . snippetPreview ) ) { this . snippetPreview = args . snippetPreview ; if ( this . snippetPreview . refObj !== this ) { this . snippetPreview . refObj = this ; this . snippetPreview . _i18n = this . i18n ; } } else if ( args . hasSnippetPreview ) { this . snippetPreview = createDefaultSnippetPreview . call ( this ) ; } this . _assessorOptions = { useCornerStone : false , useKeywordDistribution : false , } ; this . initSnippetPreview ( ) ; this . initAssessorPresenters ( ) ; } 
function getWordCombinations ( text , combinationSize , functionWords ) { const sentences = getSentences ( text ) ; let words , combination ; return flatMap ( sentences , function ( sentence ) { sentence = sentence . toLocaleLowerCase ( ) ; sentence = normalizeQuotes ( sentence ) ; words = getWords ( sentence ) ; return filter ( map ( words , function ( word , i ) { 
function calculateOccurrences ( wordCombinations ) { const occurrences = { } ; forEach ( wordCombinations , function ( wordCombination ) { const combination = wordCombination . getCombination ( ) ; if ( ! has ( occurrences , combination ) ) { occurrences [ combination ] = wordCombination ; } occurrences [ combination ] . incrementOccurrences ( ) ; } ) ; return values ( occurrences ) ; } 
function getRelevantCombinations ( wordCombinations ) { wordCombinations = wordCombinations . filter ( function ( combination ) { return combination . getOccurrences ( ) !== 1 && combination . getRelevance ( ) !== 0 ; } ) ; return wordCombinations ; } 
function sortCombinations ( wordCombinations ) { wordCombinations . sort ( function ( combinationA , combinationB ) { const difference = combinationB . getRelevance ( ) - combinationA . getRelevance ( ) ; 
function filterOneCharacterWordCombinations ( wordCombinations ) { return wordCombinations . filter ( function ( combination ) { return ! ( combination . getLength ( ) === 1 && combination . getWords ( ) [ 0 ] . length <= 1 ) ; } ) ; } 
function filterFunctionWordsAnywhere ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { return isEmpty ( intersection ( functionWords , combination . getWords ( ) ) ) ; } ) ; } 
function filterFunctionWordsAtBeginning ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { return ! includes ( functionWords , combination . getWords ( ) [ 0 ] ) ; } ) ; } 
function filterFunctionWordsAtEnding ( wordCombinations , functionWords ) { return wordCombinations . filter ( function ( combination ) { const words = combination . getWords ( ) ; const lastWordIndex = words . length - 1 ; return ! includes ( functionWords , words [ lastWordIndex ] ) ; } ) ; } 
function filterFunctionWordsAtBeginningAndEnding ( wordCombinations , functionWords ) { wordCombinations = filterFunctionWordsAtBeginning ( wordCombinations , functionWords ) ; wordCombinations = filterFunctionWordsAtEnding ( wordCombinations , functionWords ) ; return wordCombinations ; } 
function filterOnDensity ( wordCombinations , wordCount , lowerLimit , upperLimit ) { return wordCombinations . filter ( function ( combination ) { return ( combination . getDensity ( wordCount ) >= lowerLimit && combination . getDensity ( wordCount ) < upperLimit ) ; } ) ; } 
function filterEndingWith ( wordCombinations , str , exceptions ) { wordCombinations = wordCombinations . filter ( function ( combination ) { const combinationstr = combination . getCombination ( ) ; for ( let i = 0 ; i < exceptions . length ; i ++ ) { if ( combinationstr . endsWith ( exceptions [ i ] ) ) { return true ; } } return ! combinationstr . endsWith ( str ) ; } ) ; return wordCombinations ; } 
function filterFunctionWords ( combinations , functionWords ) { combinations = filterFunctionWordsAnywhere ( combinations , functionWords . filteredAnywhere ) ; combinations = filterFunctionWordsAtBeginningAndEnding ( combinations , functionWords . filteredAtBeginningAndEnding ) ; combinations = filterFunctionWordsAtEnding ( combinations , functionWords . filteredAtEnding ) ; combinations = filterFunctionWordsAtBeginning ( combinations , functionWords . filteredAtBeginning ) ; return combinations ; } 
function filterCombinations ( combinations , functionWords , language ) { combinations = filterFunctionWordsAnywhere ( combinations , specialCharacters ) ; combinations = filterOneCharacterWordCombinations ( combinations ) ; combinations = filterFunctionWords ( combinations , functionWords ) ; if ( language === "en" ) { combinations = filterEndingWith ( combinations , "'s" , [ ] ) ; } return combinations ; } 
function getRelevantWords ( text , locale ) { let language = getLanguage ( locale ) ; if ( ! functionWordLists . hasOwnProperty ( language ) ) { language = "en" ; } const functionWords = functionWordLists [ language ] ; const words = getWordCombinations ( text , 1 , functionWords . all ) ; const wordCount = words . length ; let oneWordCombinations = getRelevantCombinations ( calculateOccurrences ( words ) ) ; sortCombinations ( oneWordCombinations ) ; oneWordCombinations = take ( oneWordCombinations , 100 ) ; const oneWordRelevanceMap = { } ; forEach ( oneWordCombinations , function ( combination ) { oneWordRelevanceMap [ combination . getCombination ( ) ] = combination . getRelevance ( ) ; } ) ; const twoWordCombinations = calculateOccurrences ( getWordCombinations ( text , 2 , functionWords . all ) ) ; const threeWordCombinations = calculateOccurrences ( getWordCombinations ( text , 3 , functionWords . all ) ) ; const fourWordCombinations = calculateOccurrences ( getWordCombinations ( text , 4 , functionWords . all ) ) ; const fiveWordCombinations = calculateOccurrences ( getWordCombinations ( text , 5 , functionWords . all ) ) ; let combinations = oneWordCombinations . concat ( twoWordCombinations , threeWordCombinations , fourWordCombinations , fiveWordCombinations ) ; combinations = filterCombinations ( combinations , functionWords , language ) ; forEach ( combinations , function ( combination ) { combination . setRelevantWords ( oneWordRelevanceMap ) ; } ) ; combinations = getRelevantCombinations ( combinations ) ; sortCombinations ( combinations ) ; if ( wordCount >= wordCountLowerLimit ) { combinations = filterOnDensity ( combinations , wordCount , densityLowerLimit , densityUpperLimit ) ; } return take ( combinations , relevantWordLimit ) ; } 
function WordCombination ( words , occurrences , functionWords ) { this . _words = words ; this . _length = words . length ; this . _occurrences = occurrences || 0 ; this . _functionWords = functionWords ; } 
function createAssessment ( name , score = 9 , text = "Excellent" ) { const assessment = new Assessment ( ) ; assessment . identifier = name ; assessment . getResult = ( ) => { const result = new AssessmentResult ( ) ; result . setScore ( score ) ; result . setText ( text ) ; return result ; } ; return assessment ; } 
function MissingArgumentError ( message ) { Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; } 
function createTokenizer ( ) { tokens = [ ] ; urlTokenizer = core ( function ( token ) { tokens . push ( token ) ; } ) ; urlTokenizer . addRule ( staticRegex , "static" ) ; urlTokenizer . addRule ( variableRegex , "variable" ) ; } 
function ( participle , sentencePart , attributes ) { this . setParticiple ( participle ) ; this . setSentencePart ( sentencePart ) ; this . _determinesSentencePartIsPassive = false ; attributes = attributes || { } ; defaults ( attributes , defaultAttributes ) ; validateAttributes ( attributes ) ; this . _attributes = attributes ; } 
function baseToString ( value ) { 
function getSubheadingsTopLevel ( text ) { const subheadings = [ ] ; const regex = / <h([2-3])(?:[^>]+)?>(.*?)<\/h\1> / ig ; let match ; while ( ( match = regex . exec ( text ) ) !== null ) { subheadings . push ( match ) ; } return subheadings ; } 
function getSentencesFromBlock ( block ) { const sentenceTokenizer = new SentenceTokenizer ( ) ; const { tokenizer , tokens } = sentenceTokenizer . createTokenizer ( ) ; sentenceTokenizer . tokenize ( tokenizer , block ) ; return tokens . length === 0 ? [ ] : sentenceTokenizer . getSentencesFromTokens ( tokens ) ; } 
function createBlobURL ( url ) { const URL = window . URL || window . webkitURL ; const BlobBuilder = window . BlobBuilder || window . WebKitBlobBuilder || window . MozBlobBuilder ; let blob ; try { blob = new Blob ( [ "importScripts('" + url + "');" ] , { type : "application/javascript" } ) ; } catch ( e1 ) { const blobBuilder = new BlobBuilder ( ) ; blobBuilder . append ( "importScripts('" + url + "');" ) ; blob = blobBuilder . getBlob ( "application/javascript" ) ; } return URL . createObjectURL ( blob ) ; } 
function createWorker ( url ) { let worker = null ; try { worker = new Worker ( url ) ; } catch ( e ) { try { const blobUrl = createBlobURL ( url ) ; worker = new Worker ( blobUrl ) ; } catch ( e2 ) { throw e2 ; } } return worker ; } 
function ( i18n , options ) { this . type = "Assessor" ; this . setI18n ( i18n ) ; this . _assessments = [ ] ; this . _options = options || { } ; if ( ! isUndefined ( this . _options . researcher ) ) { this . _researcher = this . _options . researcher ; } } 
function configureStore ( preloadedState = { } , extraMiddleware = [ ] ) { const enhancers = configureEnhancers ( extraMiddleware ) ; return createStore ( rootReducer , preloadedState , enhancers ) ; } 
function removeLinksFromText ( text ) { const anchors = getAnchorsFromText ( text ) ; if ( anchors . length > 0 ) { anchors . forEach ( function ( anchor ) { text = text . replace ( anchor , "" ) ; } ) ; } return text ; } 
function removeImagesFromText ( text ) { const images = imageInText ( text ) ; const imageTags = matchStringWithRegex ( text , "</img>" ) ; if ( images . length > 0 ) { images . forEach ( function ( image ) { text = text . replace ( image , "" ) ; } ) ; imageTags . forEach ( function ( imageTag ) { text = text . replace ( imageTag , "" ) ; } ) ; } return text ; } 
function paragraphHasNoText ( text ) { 
function getRelevantWords ( text , locale ) { if ( ! isEqual ( text , previousRelevantWords . text ) || ! isEqual ( locale , previousRelevantWords . locale ) ) { previousRelevantWords = { text , locale , data : calculateRelevantWords ( text , locale ) , } ; } return previousRelevantWords . data ; } 
function ( ) { var baseURL = this . opts . baseURL ; if ( this . hasApp ( ) && ! isEmpty ( this . refObj . rawData . baseUrl ) && this . opts . baseURL === defaults . baseURL ) { baseURL = this . refObj . rawData . baseUrl ; } return baseURL ; } 
function updateUnformattedText ( key , value ) { this . element . input [ key ] . value = value ; this . data [ key ] = value ; } 
function rateTitleLength ( titleLength ) { var rating ; switch ( true ) { case titleLength > 0 && titleLength <= 399 : case titleLength > 600 : rating = "ok" ; break ; case titleLength >= 400 && titleLength <= 600 : rating = "good" ; break ; default : rating = "bad" ; break ; } return rating ; } 
function rateMetaDescLength ( metaDescLength ) { var rating ; switch ( true ) { case metaDescLength > 0 && metaDescLength < 120 : case metaDescLength > maximumMetaDescriptionLength : rating = "ok" ; break ; case metaDescLength >= 120 && metaDescLength <= maximumMetaDescriptionLength : rating = "good" ; break ; default : rating = "bad" ; break ; } return rating ; } 
function updateProgressBar ( element , value , maximum , rating ) { var barElement , progress , allClasses = [ "snippet-editor__progress--bad" , "snippet-editor__progress--ok" , "snippet-editor__progress--good" , ] ; element . value = value ; domManipulation . removeClasses ( element , allClasses ) ; domManipulation . addClass ( element , "snippet-editor__progress--" + rating ) ; if ( ! this . hasProgressSupport ) { barElement = element . getElementsByClassName ( "snippet-editor__progress-bar" ) [ 0 ] ; progress = ( value / maximum ) * 100 ; barElement . style . width = progress + "%" ; } } 
function ( opts ) { defaultsDeep ( opts , defaults ) ; this . data = opts . data ; if ( ! isUndefined ( opts . analyzerApp ) ) { this . refObj = opts . analyzerApp ; this . i18n = this . refObj . i18n ; this . data = { title : this . refObj . rawData . snippetTitle || "" , urlPath : this . refObj . rawData . snippetCite || "" , metaDesc : this . refObj . rawData . snippetMeta || "" , } ; 
function getAnalyzerTitle ( ) { var title = this . data . title ; if ( isEmpty ( title ) ) { title = this . opts . defaultValue . title ; } if ( this . hasPluggable ( ) ) { title = this . refObj . pluggable . _applyModifications ( "data_page_title" , title ) ; } return stripSpaces ( title ) ; } 
function ( ) { var metaDesc = this . data . metaDesc ; if ( isEmpty ( metaDesc ) ) { metaDesc = this . opts . defaultValue . metaDesc ; } if ( this . hasPluggable ( ) ) { metaDesc = this . refObj . pluggable . _applyModifications ( "data_meta_desc" , metaDesc ) ; } if ( ! isEmpty ( this . opts . metaDescriptionDate ) && ! isEmpty ( metaDesc ) ) { metaDesc = this . opts . metaDescriptionDate + " - " + this . data . metaDesc ; } return stripSpaces ( metaDesc ) ; } 
function showTrace ( errorMessage ) { if ( isUndefined ( errorMessage ) ) { errorMessage = "" ; } if ( ! isUndefined ( console ) && ! isUndefined ( console . trace ) ) { console . trace ( errorMessage ) ; } } 
function getIndicesByWord ( word , text ) { var startIndex = 0 ; var searchStringLength = word . length ; var index , indices = [ ] ; while ( ( index = text . indexOf ( word , startIndex ) ) > - 1 ) { 
function ( words , text ) { var matchedWords = [ ] ; forEach ( words , function ( word ) { word = stripSpaces ( word ) ; if ( ! matchWordInSentence ( word , text ) ) { return ; } matchedWords = matchedWords . concat ( getIndicesByWord ( word , text ) ) ; } ) ; return matchedWords ; } 
function ( indices ) { indices = sortIndices ( indices ) ; var filtered = [ ] ; for ( var i = 0 ; i < indices . length ; i ++ ) { 
function ( words , text ) { var matchedWords = [ ] ; forEach ( words , function ( word ) { word = stripSpaces ( word ) ; if ( ! matchWordInSentence ( word , text ) ) { return matchedWords ; } matchedWords = matchedWords . concat ( getIndicesByWord ( word , text ) ) ; } ) ; matchedWords = matchedWords . sort ( function ( a , b ) { if ( a . index < b . index ) { return - 1 ; } if ( a . index > b . index ) { return 1 ; } return 0 ; } ) ; return matchedWords ; } 
function createMeasurementElement ( ) { const hiddenElement = document . createElement ( "div" ) ; hiddenElement . id = elementId ; 
function ( app ) { this . app = app ; this . loaded = false ; this . preloadThreshold = 3000 ; this . plugins = { } ; this . modifications = { } ; this . customTests = [ ] ; 
function ( paper ) { this . setPaper ( paper ) ; this . defaultResearches = { urlLength : urlLength , wordCountInText : wordCountInText , findKeywordInPageTitle : findKeywordInPageTitle , calculateFleschReading : calculateFleschReading , getLinkStatistics : getLinkStatistics , getLinks : getLinks , linkCount : linkCount , imageCount : imageCount , altTagCount : altTagCount , matchKeywordInSubheadings : matchKeywordInSubheadings , keywordCount : keywordCount , getKeywordDensity : getKeywordDensity , stopWordsInKeyword : stopWordsInKeyword , stopWordsInUrl : stopWordsInUrl , metaDescriptionLength : metaDescriptionLength , keyphraseLength : keyphraseLength , keywordCountInUrl : keywordCountInUrl , firstParagraph : findKeywordInFirstParagraph , metaDescriptionKeyword : metaDescriptionKeyword , pageTitleWidth : pageTitleWidth , wordComplexity : wordComplexity , getParagraphLength : getParagraphLength , countSentencesFromText : countSentencesFromText , countSentencesFromDescription : countSentencesFromDescription , getSubheadingTextLengths : getSubheadingTextLengths , findTransitionWords : findTransitionWords , passiveVoice : passiveVoice , getSentenceBeginnings : getSentenceBeginnings , relevantWords : relevantWords , readingTime : readingTime , getTopicDensity : getTopicDensity , topicCount : topicCount , sentences , keyphraseDistribution : keyphraseDistribution , morphology : morphology , functionWordsInKeyphrase : functionWordsInKeyphrase , h1s : h1s , } ; this . _data = { } ; this . customResearches = { } ; } 
function areEqual ( urlA , urlB ) { 
function isInternalLink ( url , host ) { const parsedUrl = urlMethods . parse ( url , false , true ) ; 
function ( word , locale ) { var numberOfSyllables = 0 ; var vowelRegex = new RegExp ( "[^" + syllableMatchers ( locale ) . vowels + "]" , "ig" ) ; var foundVowels = word . split ( vowelRegex ) ; var filteredWords = filter ( foundVowels , function ( vowel ) { return vowel !== "" ; } ) ; numberOfSyllables += filteredWords . length ; return numberOfSyllables ; } 
function ( word , locale ) { var fullWordDeviations = syllableMatchers ( locale ) . deviations . words . full ; var deviation = find ( fullWordDeviations , function ( fullWordDeviation ) { return fullWordDeviation . word === word ; } ) ; if ( ! isUndefined ( deviation ) ) { return deviation . syllables ; } return 0 ; } 
function createDeviationFragments ( syllableConfig ) { var deviationFragments = [ ] ; var deviations = syllableConfig . deviations ; if ( ! isUndefined ( deviations . words ) && ! isUndefined ( deviations . words . fragments ) ) { deviationFragments = flatMap ( deviations . words . fragments , function ( fragments , fragmentLocation ) { return map ( fragments , function ( fragment ) { fragment . location = fragmentLocation ; return new DeviationFragment ( fragment ) ; } ) ; } ) ; } return deviationFragments ; } 
function ( word , locale ) { var deviationFragments = createDeviationFragmentsMemoized ( syllableMatchers ( locale ) ) ; var remainingParts = word ; var syllableCount = 0 ; forEach ( deviationFragments , function ( deviationFragment ) { if ( deviationFragment . occursIn ( remainingParts ) ) { remainingParts = deviationFragment . removeFrom ( remainingParts ) ; syllableCount += deviationFragment . getSyllables ( ) ; } } ) ; return { word : remainingParts , syllableCount : syllableCount } ; } 
function ( word , locale ) { var syllableCount = 0 ; syllableCount += countVowelGroups ( word , locale ) ; syllableCount += countVowelDeviations ( word , locale ) ; return syllableCount ; } 
function ( word , locale ) { var syllableCount = 0 ; var fullWordExclusion = countFullWordDeviations ( word , locale ) ; if ( fullWordExclusion !== 0 ) { return fullWordExclusion ; } var partialExclusions = countPartialWordDeviations ( word , locale ) ; word = partialExclusions . word ; syllableCount += partialExclusions . syllableCount ; syllableCount += countUsingVowels ( word , locale ) ; return syllableCount ; } 
function ( text , locale ) { text = text . toLocaleLowerCase ( ) ; var words = getWords ( text ) ; var syllableCounts = map ( words , function ( word ) { return countSyllablesInWord ( word , locale ) ; } ) ; return sum ( syllableCounts ) ; } 
function ( array , language ) { if ( isUndefined ( language ) || language === "" ) { language = "en" ; } const functionWords = get ( getFunctionWords , [ language ] , [ ] ) ; if ( array . length > 1 ) { const arrayFiltered = filter ( array , function ( word ) { return ( ! includes ( functionWords . all , word . trim ( ) . toLocaleLowerCase ( ) ) ) ; } ) ; if ( arrayFiltered . length > 0 ) { return arrayFiltered ; } } return array ; } 
function ( keyphrase , language , morphologyData ) { if ( isUndefined ( keyphrase ) || keyphrase === "" ) { return [ ] ; } const doubleQuotes = [ "“", " ", "〝 " "〞", 〟", " ‟ , "„" , "\"" ] if ( includes ( doubleQuotes , keyphrase [ 0 ] ) && includes ( doubleQuotes , keyphrase [ keyphrase . length - 1 ] ) ) { keyphrase = keyphrase . substring ( 1 , keyphrase . length - 1 ) ; return [ unique ( [ ] . concat ( escapeRegExp ( keyphrase ) , getVariationsApostrophe ( keyphrase ) ) ) ] ; } const words = filterFunctionWords ( getWords ( keyphrase ) , language ) ; const forms = [ ] ; const getForms = getFormsForLanguage [ language ] ; /* * Only returns the keyword and the keyword with apostrophe variations if morphological forms cannot be built. * Otherwise additionally returns the morphological forms. */ if ( morphologyData === false || isUndefined ( getForms ) ) { words . forEach ( function ( word ) { const wordToLowerCase = escapeRegExp ( word . toLocaleLowerCase ( language ) ) ; forms . push ( unique ( [ ] . concat ( wordToLowerCase , getVariationsApostrophe ( wordToLowerCase ) ) ) ) ; } ) ; } else { words . forEach ( function ( word ) { const wordToLowerCase = escapeRegExp ( word . toLocaleLowerCase ( ) ) ; const formsOfThisWord = language === "de" ? getForms ( wordToLowerCase , morphologyData ) . forms : getForms ( wordToLowerCase , morphologyData ) ; const variationsApostrophes = getVariationsApostropheInArray ( formsOfThisWord ) ; forms . push ( unique ( flatten ( formsOfThisWord . concat ( variationsApostrophes ) ) ) . filter ( Boolean ) ) ; } ) ; } return forms ; } 
function ( keyphrase , synonyms , language = "en" , morphologyData ) { const synonymsSplit = parseSynonyms ( synonyms ) ; const keyphraseForms = buildForms ( keyphrase , language , morphologyData ) ; const synonymsForms = synonymsSplit . map ( synonym => buildForms ( synonym , language , morphologyData ) ) ; return { keyphraseForms : keyphraseForms , synonymsForms : synonymsForms , } ; } 
function collectForms ( keyphrase , synonyms , language = "en" , morphologyData ) { const collectFormsWithMorphologyData = primeMorphologyData ( morphologyData ) ; return collectFormsWithMorphologyData ( keyphrase , synonyms , language ) ; } 
function research ( paper , researcher ) { const language = getLanguage ( paper . getLocale ( ) ) ; const morphologyData = get ( researcher . getData ( "morphology" ) , [ language ] , false ) ; return collectForms ( paper . getKeyword ( ) , paper . getSynonyms ( ) , language , morphologyData ) ; } 
function InvalidTypeError ( message ) { Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . message = message ; } 
function getRegexFromDoubleArray ( twoPartTransitionWords ) { const cacheKey = flattenDeep ( twoPartTransitionWords ) . join ( "" ) ; if ( regexFromDoubleArrayCacheKey !== cacheKey || regexFromDoubleArray === null ) { regexFromDoubleArrayCacheKey = cacheKey ; regexFromDoubleArray = createRegexFromDoubleArray ( twoPartTransitionWords ) ; } return regexFromDoubleArray ; } 
function ( sentence , twoPartTransitionWords ) { sentence = normalizeSingleQuotes ( sentence ) ; const twoPartTransitionWordsRegex = getRegexFromDoubleArray ( twoPartTransitionWords ) ; return sentence . match ( twoPartTransitionWordsRegex ) ; } 
function ( sentence , transitionWords ) { sentence = normalizeSingleQuotes ( sentence ) ; return transitionWords . filter ( word => matchWordInSentence ( word , sentence ) ) ; } 
function ( sentences , transitionWords ) { const results = [ ] ; sentences . forEach ( sentence => { const twoPartMatches = matchTwoPartTransitionWords ( sentence , transitionWords . twoPartTransitionWords ( ) ) ; if ( twoPartMatches !== null ) { results . push ( { sentence : sentence , transitionWords : twoPartMatches , } ) ; return ; } const transitionWordMatches = matchTransitionWords ( sentence , transitionWords . transitionWords ) ; if ( transitionWordMatches . length !== 0 ) { results . push ( { sentence : sentence , transitionWords : transitionWordMatches , } ) ; return ; } } ) ; return results ; } 
function Results ( { seo , readability , activeMarker , onMark } ) { return < Fragment > < HorizontalContainer marginTop = "0" > < ScoreIcon score = { readability . score / 10 } / > < H3 > Readability < / H3 > < / HorizontalContainer > < AnalysisList results = { readability . results } marksButtonActivatedResult = { activeMarker } marksButtonClassName = "yoast-text-mark" onMarksButtonClick = { onMark } / > < HorizontalContainer > < ScoreIcon score = { seo . score / 10 } / > < H3 > SEO < / H3 > < / HorizontalContainer > < AnalysisList results = { seo . results } marksButtonActivatedResult = { activeMarker } marksButtonClassName = "yoast-text-mark" onMarksButtonClick = { onMark } / > < / Fragment > ; } 
function getIndicesOfWords ( text ) { const indices = [ ] ; const words = getWords ( text ) ; let startSearchFrom = 0 ; words . forEach ( function ( word ) { const currentIndex = text . indexOf ( word , startSearchFrom ) ; indices . push ( currentIndex ) ; startSearchFrom = currentIndex + word . length ; } ) ; return indices ; } 
function getIndicesOfCharacter ( text , characterToFind ) { const indices = [ ] ; if ( text . indexOf ( characterToFind ) > - 1 ) { for ( let i = 0 ; i < text . length ; i ++ ) { if ( text [ i ] === characterToFind ) { indices . push ( i ) ; } } } return indices ; } 
function combinations ( collection ) { function acc ( xs , array ) { const x = xs [ 0 ] ; if ( typeof x === "undefined" ) { return array ; } for ( let i = 0 , l = array . length ; i < l ; ++ i ) { array . push ( array [ i ] . concat ( x ) ) ; } return acc ( xs . slice ( 1 ) , array ) ; } return acc ( collection , [ [ ] ] ) . slice ( 1 ) . concat ( [ [ ] ] ) ; } 
function replaceCharactersByIndex ( text , indices , substitute ) { const modifiedTextSplitByLetter = text . split ( "" ) ; indices . forEach ( function ( index ) { modifiedTextSplitByLetter . splice ( index , 1 , substitute ) ; } ) ; return modifiedTextSplitByLetter . join ( "" ) ; } 
function replaceTurkishIs ( text ) { 
function ( values ) { this . _hasScore = false ; this . _identifier = "" ; this . _hasMarks = false ; this . _marker = emptyMarker ; this . score = 0 ; this . text = "" ; this . marks = [ ] ; if ( isUndefined ( values ) ) { values = { } ; } if ( ! isUndefined ( values . score ) ) { this . setScore ( values . score ) ; } if ( ! isUndefined ( values . text ) ) { this . setText ( values . text ) ; } if ( ! isUndefined ( values . marks ) ) { this . setMarks ( values . marks ) ; } } 
function ( sentence , locale ) { this . _sentenceText = sentence || "" ; this . _locale = locale || defaultAttributes . locale ; this . _isPassive = false ; } 
function ( app ) { var elems = [ "content" , "focusKeyword" , "synonyms" ] ; for ( var i = 0 ; i < elems . length ; i ++ ) { document . getElementById ( elems [ i ] ) . addEventListener ( "input" , app . refresh . bind ( app ) ) ; } document . getElementById ( "locale" ) . addEventListener ( "input" , setLocale . bind ( app ) ) ; document . getElementById ( "premium" ) . addEventListener ( "input" , setPremium . bind ( app ) ) ; } 
async function main ( ) { const browserFile = document.getElementById("fileinput").files[0]; await uploadBrowserDataToAzureFile(Aborter.none, browserFile, fileURL, { rangeSize: 4 * 1024 * 1024, parallelism: 20, progress: ev => console.log(ev) }); */ 
async function main ( ) { 
async function main ( ) { 
async function streamToString ( readableStream ) { return new Promise ( ( resolve , reject ) => { const chunks = [ ] ; readableStream . on ( "data" , data => { chunks . push ( data . toString ( ) ) ; } ) ; readableStream . on ( "end" , ( ) => { resolve ( chunks . join ( "" ) ) ; } ) ; readableStream . on ( "error" , reject ) ; } ) ; } 
function determineFrequency ( fu ) { let qstate = new qubits . QState ( numInBits + numOutBits ) . hadamard ( inputBits ) ; qstate = qstate . applyFunction ( inputBits , outBits , fu ) ; 
function findPeriod ( ) { let bestSoFar = 1 ; for ( let attempts = 0 ; attempts < 2 * numOutBits ; attempts += 1 ) { 
function symlinkDependencies ( pkg ) { let name = pkg . name ; let modulesPath = path . join ( outputPath , name , 'node_modules' ) ; let dependencies = pkg . internalDependencies ; 
function start ( ) { Promise . resolve ( ) . delay ( 500 ) . then ( ( ) => checker . execute ( ) ) . catch ( console . error ) . then ( ( ) => broker . stop ( ) ) . then ( ( ) => checker . printTotal ( ) ) ; } 
function ( id , fileName ) { console . info ( ` ${ id } ${ fileName } ` ) ; 
function authenticate ( ) { const authPromtpts = [ { type : "text" , name : "username" , message : "Username" } , { type : "password" , name : "password" , message : "Password" } ] ; let session ; 
function searchForItems ( session ) { const searchPrompts = [ { type : "text" , name : "searchText" , message : "Search Query" } , { type : "list" , name : "itemTypes" , message : "Item Types" } , { type : "list" , name : "itemTags" , message : "Tags" } , { type : "number" , name : "number" , message : "How Many?" } ] ; 
async function deleteItems ( items , session ) { 
function ( ) { 
function ( query ) { 
function triageFriends ( s ) { outgoing = kb . each ( s , foaf ( 'knows' ) ) incoming = kb . each ( undefined , foaf ( 'knows' ) , s ) 
function ( kb , x , displayables ) { var t = kb . findTypeURIs ( subject ) for ( var k = 0 ; k < displayables . length ; k ++ ) { if ( $rdf . Util . mediaTypeClass ( displayables [ k ] ) . uri in t ) { return true } } return false } 
function ( newPaneOptions ) { var kb = UI . store var newInstance = newPaneOptions . newInstance if ( ! newInstance ) { let uri = newPaneOptions . newBase if ( uri . endsWith ( '/' ) ) { uri = uri . slice ( 0 , - 1 ) newPaneOptions . newBase = uri } newInstance = kb . sym ( uri ) } var contentType = mime . lookup ( newInstance . uri ) if ( ! contentType || ! contentType . includes ( 'html' ) ) { newInstance = $rdf . sym ( newInstance . uri + '.html' ) } newPaneOptions . newInstance = newInstance 
function ( subject , myDocument ) { var div = myDocument . createElement ( 'div' ) var kb = UI . store 
function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . findTypeURIs ( subject ) if ( t [ ns . ldp ( 'Resource' ) . uri ] ) return 'Sharing' 
function ( kb , x , contentTypes ) { var cts = kb . fetcher . getHeader ( x , 'content-type' ) if ( cts ) { for ( var j = 0 ; j < cts . length ; j ++ ) { for ( var k = 0 ; k < contentTypes . length ; k ++ ) { if ( cts [ j ] . indexOf ( contentTypes [ k ] ) >= 0 ) { return true } } } } return false } 
function ( subject ) { var n = UI . store . each ( subject , ns . wf ( 'message' ) ) . length if ( n > 0 ) return 'Chat (' + n + ')' 
function ( ) { var query = new $rdf . Query ( 'IRC log entries' ) var v = [ ] var vv = [ 'chan' , 'msg' , 'date' , 'list' , 'pred' , 'creator' , 'content' ] vv . map ( function ( x ) { query . vars . push ( v [ x ] = $rdf . variable ( x ) ) } ) query . pat . add ( v [ 'chan' ] , ns . foaf ( 'chatEventList' ) , v [ 'list' ] ) 
function addNewPredicateObject ( e ) { if ( UI . utils . getTarget ( e ) . className !== 'bottom-border-active' ) return var This = outline . UserInput var target = UI . utils . getTarget ( e ) 
function addNewObject ( e ) { var predicateTd = UI . utils . getTarget ( e ) . parentNode . parentNode 
function Click ( e ) { var target = UI . utils . getTarget ( e ) if ( UI . utils . getTerm ( target ) . termType !== 'Literal' ) return this . literalModification ( target ) 
function pasteFromClipboard ( address , selectedTd ) { function termFrom ( fromCode ) { var term = outline . clipboard [ fromCode ] . shift ( ) if ( term === null ) { UI . log . warn ( 'no more element in clipboard!' ) return } switch ( fromCode ) { case 'predicates' : case 'objects' : var allArray = outline . clipboard . all for ( var i = 0 ; true ; i ++ ) { if ( term . sameTerm ( allArray [ i ] ) ) { allArray . splice ( i , 1 ) break } } break case 'all' : throw new Error ( 'hostorical code not understood - what is theCollection?' ) } return term } var term switch ( selectedTd . className ) { case 'undetermined selected' : term = selectedTd . nextSibling ? termFrom ( 'predicates' ) : termFrom ( 'objects' ) if ( ! term ) return break case 'pred selected' : 
function startFillInText ( selectedTd ) { switch ( this . whatSortOfEditCell ( selectedTd ) ) { case 'DatatypeProperty-like' : emptyNode(selectedTd); this.lastModified=this.createInputBoxIn(selectedTd,""); this.lastModified.select(); this.lastModified.addEventListener('keypress',this.AutoComplete,false); this.AutoComplete(1); */ } } 
function performAutoCompleteEdit ( selectedTd , menu ) { UI . utils . emptyNode ( selectedTd ) qp ( 'perform AutoCompleteEdit. THIS IS=' + this ) this . lastModified = this . createInputBoxIn ( selectedTd , '' ) this . lastModified . select ( ) this . lastModified . addEventListener ( 'keypress' , this . getAutoCompleteHandler ( menu ) , false ) 
function clearInputAndSave ( e ) { if ( ! this . lastModified ) return if ( ! this . lastModified . isNew ) { try { var obj = this . getStatementAbout ( this . lastModified ) . object } catch ( e ) { return } } var s = this . lastModifiedStat if ((s.object.termType === 'BlankNode' && !this.statIsInverse) || s.subject.termType === 'BlankNode' && this.statIsInverse) { this.backOut() return */ if ( this . statIsInverse ) { if ( s . subject . termType === 'BlankNode' ) { this . backOut ( ) return } } else { if ( s . object . termType === 'BlankNode' ) { this . backOut ( ) return } } 
function deleteTriple ( selectedTd , isBackOut ) { 
function removefromview ( ) { var trIterator for ( trIterator = removedTr ; trIterator . childNodes . length === 1 ; trIterator = trIterator . previousSibling ) ; if ( trIterator === removedTr ) { var theNext = trIterator . nextSibling if ( theNext . nextSibling && theNext . childNodes . length === 1 ) { var predicateTd = trIterator . firstChild predicateTd . setAttribute ( 'rowspan' , parseInt ( predicateTd . getAttribute ( 'rowspan' ) ) - 1 ) theNext . insertBefore ( trIterator . firstChild , theNext . firstChild ) } removedTr . parentNode . removeChild ( removedTr ) } else { 
function clipboardInit ( ) { outline . clipboard = { } outline . clipboard . objects = [ ] outline . clipboard . predicates = [ ] outline . clipboard . all = [ ] } 
function getAutoCompleteHandler ( mode ) { qp ( '\n\n***** In getAutoCompleteHandler ****** mode = ' + mode ) if ( mode === 'PredicateAutoComplete' ) { mode = 'predicate' } else if ( mode !== 'JournalTAC' ) { 
function WildCardButtons ( ) { var menuDiv = myDocument . getElementById ( outline . UserInput . menuID ) var div = menuDiv . insertBefore ( myDocument . createElement ( 'div' ) , menuDiv . firstChild ) var input1 = div . appendChild ( myDocument . createElement ( 'input' ) ) var input2 = div . appendChild ( myDocument . createElement ( 'input' ) ) input1 . type = 'button' ; input1 . value = 'New...' input2 . type = 'button' ; input2 . value = 'Know its URI' function highlightInput ( e ) { 
function ( e ) { if ( e . keyCode === 13 ) { if ( outline . targetOf ( e ) . tagName !== 'TEXTAREA' ) { this . clearInputAndSave ( ) } else { 
function whatSortOfEditCell ( selectedTd ) { if ( selectedTd . nextSibling ) return 'predicate' var predicateTerm = this . getStatementAbout ( selectedTd ) . predicate 
function createNew ( e ) { outline . UserInput . clearMenu ( ) var selectedTd = outline . getSelection ( ) [ 0 ] var targetdoc = selectedTd . parentNode . AJAR_statement . why var newTerm = kb . nextSymbol ( targetdoc ) outline . UserInput . fillInRequest ( 'object' , selectedTd , newTerm ) 
function getOffset ( el ) { var _lf = 0 var _tp = 0 var oldlf = 0 var oldtp = 0 var newlf = 0 var newtp = 0 
function fillInRequest ( type , selectedTd , inputTerm ) { var tr = selectedTd . parentNode var stat ; var isInverse stat = tr . AJAR_statement ; isInverse = tr . AJAR_inverse var reqTerm = ( type === 'object' ) ? stat . object : stat . predicate var newStat var doNext = false eventhandler = function(subject) { return kb.any(reqTerm, UI.ns.link('onfillin')).value) } */ } if ( type === 'predicate' ) { 
function ( subject ) { var kb = UI . store var t = kb . findTypeURIs ( subject ) 
function renderTrip ( subject , thisDiv ) { var query = new $rdf . Query ( UI . utils . label ( subject ) ) var vars = [ 'date' , 'transaction' , 'comment' , 'type' , 'in_USD' ] var v = { } vars . map ( function ( x ) { query . vars . push ( v [ x ] = $rdf . variable ( x ) ) } ) 
function ( ) { var total = { } var trans = kb . each ( undefined , TRIP ( 'trip' ) , subject ) 
function ( subject ) { var target = kb . any ( subject , ns . meeting ( 'target' ) ) || subject var count = kb . each ( target , predicate ) . length if ( count > 0 ) { return UI . utils . label ( predicate ) + ' ' + count } return null } 
function ( subject ) { var kb = UI . store var t = kb . findTypeURIs ( subject ) var QU = $rdf . Namespace ( 'http://www.w3.org/2000/10/swap/pim/qif#' ) var WF = $rdf . Namespace ( 'http://www.w3.org/2005/01/wf/flow#' ) if ( t [ 'http://www.w3.org/ns/pim/trip#Trip' ] || 
function complain ( message ) { var pre = dom . createElement ( 'pre' ) pre . setAttribute ( 'style' , 'background-color: pink' ) div . appendChild ( pre ) pre . appendChild ( dom . createTextNode ( message ) ) } 
function ( kb , subject ) { if ( kb . updater . editable ( subject . doc ( ) , kb ) ) return subject . doc ( ) var store = kb . any ( subject . doc ( ) , QU ( 'annotationStore' ) ) return store } 
function ( c ) { var sortBy = kb . sym ( { 'http://www.w3.org/2005/01/wf/flow#Task' : 'http://purl.org/dc/elements/1.1/created' , 'http://www.w3.org/ns/pim/trip#Trip' : 
function ( uri , ok , body ) { if ( ok ) { 
function ( x , event , selected ) { if ( selected ) { currentSubject = x } else { currentSubject = null if ( currentMode === 1 ) deselectObject ( ) } 
function ( user ) { this . userlist = { } this . uris = { } var myFollows = kb . each ( kb . sym ( user ) , SIOC ( 'follows' ) ) for ( var mf in myFollows ) { this . add ( kb . any ( myFollows [ mf ] , SIOC ( 'id' ) ) , myFollows [ mf ] . uri ) } } 
function ( user ) { this . favorites = { } this . favoritesURI = '' if ( ! user ) { 
function ( kb ) { this . kb = kb 
function ( s , doc , microblogPane ) { var TabManager = function ( doc ) { this . tablist = { } this . doc = doc this . tabView = doc . createElement ( 'ul' ) this . tabView . className = 'tabslist' } TabManager . prototype . create = function ( id , caption , view , isDefault ) { var tab = this . doc . createElement ( 'li' ) tab . innerHTML = caption if ( isDefault ) { tab . className = 'active' } tab . id = id let change = this . change let tablist = this . tablist tab . addEventListener ( 'click' , function ( evt ) { change ( evt . target . id , tablist , doc ) } , false ) this . tablist [ id ] = { 'view' : view . id , 'tab' : tab } this . tabView . appendChild ( tab ) } TabManager . prototype . getTabView = function ( ) { return this . tabView } TabManager . prototype . change = function ( id , tablist , doc ) { for ( var tab in tablist ) { if ( tab === id ) { tablist [ id ] [ 'tab' ] . className = 'active' doc . getElementById ( tablist [ id ] [ 'view' ] ) . className += ' active' } else { var view = doc . getElementById ( tablist [ tab ] . view ) view . className = view . className . replace ( / \w*active\w* / , '' ) tablist [ tab ] . tab . className = tablist [ id ] . tab . className . replace ( / \w*active\w* / , '' ) } } } this . microblogPane = microblogPane var accounts = kb . each ( s , FOAF ( 'holdsAccount' ) ) for ( var a in accounts ) { if ( kb . whether ( accounts [ a ] , RDF ( 'type' ) , SIOC ( 'User' ) ) && kb . whether ( kb . any ( accounts [ a ] , SIOC ( 'creator_of' ) ) , RDF ( 'type' ) , SIOCt ( 'Microblog' ) ) ) { var account = accounts [ a ] break } } this . Ifollow = kb . whether ( kb . sym ( mb . getMyURI ( ) ) , SIOC ( 'follows' ) , account ) var resourceType = kb . any ( s , RDF ( 'type' ) ) if ( resourceType . uri === SIOCt ( 'Microblog' ) . uri || resourceType . uri === SIOCt ( 'MicroblogPost' ) . uri ) { this . thisIsMe = ( kb . any ( s , SIOC ( 'has_creator' ) ) . uri === mb . getMyURI ( ) ) } else if ( resourceType . uri === SIOC ( 'User' ) . uri ) { this . thisIsMe = ( s . uri === mb . getMyURI ( ) ) } else if ( resourceType . uri === FOAF ( 'Person' ) . uri ) { let me = UI . authn . currentUser ( ) let meUri = me && me . uri this . thisIsMe = ( s . uri === meUri ) } else { this . thisIsMe = false } this . Tab = new TabManager ( doc ) } 
function ( uri , success , responseText , d ) { if ( success === true ) { for ( var triple in d ) { kb . add ( d [ triple ] . subject , d [ triple ] . predicate , d [ triple ] . object , d [ triple ] . why ) } xupdateSubmit . disabled = false xupdateStatus . value = '' mbLetterCount ( ) notify ( 'Microblog Updated.' ) if ( that . thisIsMe ) { doc . getElementById ( 'postNotificationList' ) . insertBefore ( that . generatePost ( d [ 0 ] . subject ) , doc . getElementById ( 'postNotificationList' ) . childNodes [ 0 ] ) } } else { notify ( 'There was a problem submitting your post.' ) } } 
function ( ) { var id = mb . getUser ( Post . creator ) . id var xupdateStatus = doc . getElementById ( 'xupdateStatus' ) var xinReplyToContainer = doc . getElementById ( 'xinReplyToContainer' ) var xupdateSubmit = doc . getElementById ( 'xupdateSubmit' ) xupdateStatus . value = '@' + id + ' ' xupdateStatus . focus ( ) xinReplyToContainer . value = post . uri xupdateSubmit . value = 'Reply' } 
function ( a , success ) { if ( success ) { that . notify ( 'Post deleted.' ) 
function ( a , success ) { if ( success ) { var deleteContainer = kb . statementsMatching ( undefined , SIOC ( 'container_of' ) , kb . sym ( doc . getElementById ( 'post_' + evt . target . parentNode . id ) . getAttribute ( 'content' ) ) ) sparqlUpdater . batch_delete_statement ( deleteContainer , mbconfirmDeletePost ) } else { that . notify ( 'Oops, there was a problem, please try again' ) evt . target . disabled = false } } 
function ( subject ) { var ns = UI . ns var kb = UI . store var t = kb . findTypeURIs ( subject ) if ( t [ ns . rdfs ( 'Class' ) . uri ] ) return 'creation forms' 
function displayFormsForRelation ( pred , allowCreation ) { var sts = kb . statementsMatching ( subject , pred ) const outliner = panes . getOutliner ( dom ) if ( sts . length ) { for ( var i = 0 ; i < sts . length ; i ++ ) { outliner . appendPropertyTRs ( box , [ sts [ i ] ] ) var form = sts [ i ] . object var cell = dom . createElement ( 'td' ) box . lastChild . appendChild ( cell ) if ( allowCreation ) { cell . appendChild ( UI . widgets . newButton ( dom , kb , null , null , subject , form , store , function ( ok , body ) { if ( ok ) { 
function ( subject ) { var kb = UI . store var n = kb . each ( undefined , ns . rdf ( 'type' ) , subject ) . length if ( n > 0 ) return 'List (' + n + ')' 
function ConstraintEqualTo ( value ) { this . describe = function ( varstr ) { return varstr + ' = ' + value . toNT ( ) } this . test = function ( term ) { return value . sameTerm ( term ) } return this } 
function saveQuery ( selection , qs ) { 
function viewAndSaveQuery ( outline , selection ) { var qs = outline . qs UI . log . info ( 'outline.doucment is now ' + outline . document . location ) var q = saveQuery ( selection , qs ) for ( let i = 0 ; i < qs . listeners . length ; i ++ ) { qs . listeners [ i ] . getActiveView ( ) . view . drawQuery ( q ) qs . listeners [ i ] . updateQueryControls ( qs . listeners [ i ] . getActiveView ( ) ) } } 
function QuerySource ( ) { this . queries = [ ] this . listeners = [ ] this . addQuery = function ( q ) { var i if ( q . name === null || q . name === '' ) { q . name = 'Query #' + ( this . queries . length + 1 ) } q . id = this . queries . length this . queries . push ( q ) for ( i = 0 ; i < this . listeners . length ; i ++ ) { if ( this . listeners [ i ] !== null ) { this . listeners [ i ] . addQuery ( q ) } } } this . removeQuery = function ( q ) { var i for ( i = 0 ; i < this . listeners . length ; i ++ ) { if ( this . listeners [ i ] !== null ) { this . listeners [ i ] . removeQuery ( q ) } } if ( this . queries [ q . id ] !== null ) { delete this . queries [ q . id ] } } this . addListener = function ( listener ) { var i this . listeners . push ( listener ) for ( i = 0 ; i < this . queries . length ; i ++ ) { if ( this . queries [ i ] !== null ) { listener . addQuery ( this . queries [ i ] ) } } } this . removeListener = function ( listener ) { var i for ( i = 0 ; i < this . queries . length ; i ++ ) { if ( this . queries [ i ] !== null ) { listener . removeQuery ( this . queries [ i ] ) } } for ( i = 0 ; i < this . listeners . length ; i ++ ) { if ( this . listeners [ i ] === listener ) { delete this . listeners [ i ] } } } } 
function ( subject ) { var n = UI . widgets . formsFor ( subject ) . length UI . log . debug ( 'Form pane: forms for ' + subject + ': ' + n ) if ( ! n ) return null return '' + n + ' forms' } 
function ( store , subject ) { kb . fetcher . nowOrWhenFetched ( store . uri , subject , function ( ok , body ) { if ( ! ok ) return complain ( 'Cannot load store ' + store . uri + ': ' + body ) mention("Where will this information be stored?") var ele = dom.createElement('input'); box.appendChild(ele); ele.setAttribute('type', 'text'); ele.setAttribute('size', '72'); ele.setAttribute('maxlength', '1024'); ele.setAttribute('style', 'font-size: 80%; color:#222;'); ele.value = store.uri */ UI . widgets . appendForm ( dom , box , { } , subject , form , store , complainIfBad ) } } ) 
function ( kb , subject , path ) { if ( path . length === 0 ) return [ subject ] var oo = kb . each ( subject , path [ 0 ] ) var res = [ ] for ( var i = 0 ; i < oo . length ; i ++ ) { res = res . concat ( followeach ( kb , oo [ i ] , path . slice ( 1 ) ) ) } return res } 
function ( subject , dom ) { var outliner = panes . getOutliner ( dom ) var kb = UI . store var arg = UI . ns . arg subject = kb . canon ( subject ) 
function ( subject ) { var kb = UI . store var t = kb . findTypeURIs ( subject ) if ( t [ 'http://www.w3.org/2000/10/swap/pim/qif#Period' ] ) return 'period' return null 
function ( catTail ) { var cats = kb . findSubClassesNT ( ns . qu ( 'Transaction' ) ) for ( var cat in cats ) { if ( cats . hasOwnProperty ( cat ) ) { if ( cat . slice ( 1 , - 1 ) . split ( '#' ) [ 1 ] === catTail ) { return kb . sym ( cat . slice ( 1 , - 1 ) ) } } ; } ; return null } 
function statementsAsTables ( sts , myDocument , initialRoots ) { 
function propertyTree ( subject ) { 
function objectTree ( obj ) { var res switch ( obj . termType ) { case 'NamedNode' : let anchor = myDocument . createElement ( 'a' ) anchor . setAttribute ( 'href' , obj . uri ) anchor . addEventListener ( 'click' , UI . widgets . openHrefInOutlineMode , true ) anchor . appendChild ( myDocument . createTextNode ( UI . utils . label ( obj ) ) ) return anchor case 'Literal' : if ( ! obj . datatype || ! obj . datatype . uri ) { res = myDocument . createElement ( 'div' ) res . setAttribute ( 'style' , 'white-space: pre-wrap;' ) res . textContent = obj . value return res } else if ( obj . datatype . uri === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral' ) { res = myDocument . createElement ( 'div' ) res . setAttribute ( 'class' , 'embeddedXHTML' ) res . innerHTML = obj . value 
function ( subject , myDocument ) { function alternativeRendering ( ) { var sz = UI . rdf . Serializer ( UI . store ) var res = sz . rootSubjects ( sts ) var roots = res . roots var p = { } p . render = function ( s2 ) { var div = myDocument . createElement ( 'div' ) div . setAttribute ( 'class' , 'withinDocumentPane' ) var plist = kb . statementsMatching ( s2 , undefined , undefined , subject ) outliner . appendPropertyTRs ( div , plist , false , function ( pred , inverse ) { return true } ) return div } for ( var i = 0 ; i < roots . length ; i ++ ) { var tr = myDocument . createElement ( 'TR' ) var root = roots [ i ] tr . style . verticalAlign = 'top' var td = outliner . outlineObjectTD ( root , undefined , tr ) tr . appendChild ( td ) div . appendChild ( tr ) outliner . outlineExpand ( td , root , { 'pane' : p } ) } } function mainRendering ( ) { var initialRoots = [ ] 
function ( subject ) { var kb = UI . store var ns = UI . ns var typeURIs = kb . findTypeURIs ( subject ) if ( ns . meeting ( 'Cluster' ) . uri in typeURIs ) { return 'Tabbed' } return null } 
function ( subject ) { var kb = UI . store var ns = UI . ns var t = kb . findTypeURIs ( subject ) if ( t [ ns . ldp ( 'Container' ) . uri ] || t [ ns . ldp ( 'BasicContainer' ) . uri ] ) { var contents = kb . each ( subject , ns . ldp ( 'contains' ) ) var count = 0 contents . map ( function ( file ) { if ( UI . widgets . isImage ( file ) ) count ++ } ) return count > 0 ? 'Slideshow' : null } return null } 
function ( subject , dom ) { var styleSheet = 'https://leemark.github.io/better-simple-slideshow/css/simple-slideshow-styles.css' UI . widgets . addStyleSheet ( dom , styleSheet ) var kb = UI . store var ns = UI . ns var div = dom . createElement ( 'div' ) div . setAttribute ( 'class' , 'bss-slides' ) var t = kb . findTypeURIs ( subject ) var predicate if ( t [ ns . ldp ( 'BasicContainer' ) . uri ] || t [ ns . ldp ( 'Container' ) . uri ] ) { predicate = ns . ldp ( 'contains' ) } var images = kb . each ( subject , predicate ) 
function appendRemoveIcon ( node , subject , removeNode ) { var image = UI . utils . AJARImage ( outlineIcons . src . icon_remove_node , 'remove' , undefined , dom ) image . addEventListener ( 'click' , removeNodeIconMouseDownListener ) 
function removeAndRefresh ( d ) { var table = d . parentNode var par = table . parentNode var placeholder = dom . createElement ( 'table' ) placeholder . setAttribute ( 'style' , 'width: 100%;' ) par . replaceChild ( placeholder , table ) table . removeChild ( d ) par . replaceChild ( table , placeholder ) 
function appendPropertyTRs ( parent , plist , inverse , predicateFilter ) { ONLY in the case (currently) when all the values are tagged. Then we treat them as alternatives. */ if ( myLang > 0 && langTagged === dups + 1 ) { for ( let k = j ; k <= j + dups ; k ++ ) { if ( outline . labeller . LanguagePreference && sel ( plist [ k ] ) . lang . indexOf ( outline . labeller . LanguagePreference ) >= 0 ) { tr . appendChild ( thisOutline . outlineObjectTD ( sel ( plist [ k ] ) , defaultpropview , undefined , s ) ) break } } j += dups * This is to prevent the case where you have a long list of objects * shown, and dangling at the end is '1 more' (which is easily ignored) * Therefore more objects are shown than hidden. */ tr . showNobj = function ( n ) { var predDups = k - dups var show = ( ( 2 * n ) < predDups ) ? n : predDups var showLaterArray = [ ] if ( predDups !== 1 ) { predicateTD . setAttribute ( 'rowspan' , ( show === predDups ) ? predDups : n + 1 ) var l if ( ( show < predDups ) && ( show === 1 ) ) { 
function addButtonCallbacks ( target , fireOn ) { UI . log . debug ( 'Button callbacks for ' + fireOn + ' added' ) var makeIconCallback = function ( icon ) { return function IconCallback ( req ) { if ( req . indexOf ( '#' ) >= 0 ) { console . log ( '@@ makeIconCallback: Not expecting # in URI whose state changed: ' + req ) 
function selected ( node ) { var a = node . getAttribute ( 'class' ) if ( a && ( a . indexOf ( 'selected' ) >= 0 ) ) return true return false } 
function optOnIconMouseDownListener ( e ) { 
function expandMouseDownListener ( e ) { 
function outlineExpand ( p , subject1 , options ) { options = options || { } var pane = options . pane var already = ! ! options . already var immediate = options . immediate UI . log . info ( '@outlineExpand, dom is now ' + dom . location ) 
function render ( ) { subject = kb . canon ( subject ) if ( ! p || ! p . parentNode || ! p . parentNode . parentNode ) return false var newTable UI . log . info ( '@@ REPAINTING ' ) if ( ! already ) { 
function outlineCollapse ( p , subject ) { var row = UI . utils . ancestor ( p , 'TR' ) row = UI . utils . ancestor ( row . parentNode , 'TR' ) 
function viewsAddPropertyView ( property , pviewfunc , isDefault ) { if ( ! views . properties [ property ] ) { views . properties [ property ] = [ ] } views . properties [ property ] . push ( pviewfunc ) if ( isDefault ) { 
function viewAsBoringDefault ( obj ) { var tr = rep.appendChild(document.createElement('tr')); tr.appendChild(document.createTextNode( obj.elements.length ? '(' + obj.elements.length+')' : '(none)')); */ for ( var i = 0 ; i < obj . elements . length ; i ++ ) { var elt = obj . elements [ i ] var row = rep . appendChild ( dom . createElement ( 'tr' ) ) var numcell = row . appendChild ( dom . createElement ( 'td' ) ) numcell . setAttribute ( 'style' , 'margin: 0.2em; border: none; padding: 0; vertical-align: top;' ) numcell . setAttribute ( 'notSelectable' , 'false' ) numcell . setAttribute ( 'about' , obj . toNT ( ) ) numcell . innerHTML = ( i + 1 ) + ')' row . appendChild ( thisOutline . outlineObjectTD ( elt ) ) } } else if ( obj . termType === 'Graph' ) { rep = panes . dataContentPane . statementsAsTables ( obj . statements , dom ) rep . setAttribute ( 'class' , 'nestedFormula' ) } else { UI . log . error ( 'Object ' + obj + ' has unknown term type: ' + obj . termType ) rep = dom . createTextNode ( '[unknownTermType:' + obj . termType + ']' ) } 
function viewAsImage ( obj ) { var img = UI . utils . AJARImage ( obj . uri , UI . utils . label ( obj ) , UI . utils . label ( obj ) , dom ) img . setAttribute ( 'class' , 'outlineImage' ) return img } 
function readDicomDataSetImplicitUndefinedLength ( byteStream , vrCallback ) { const elements = { } ; while ( byteStream . position < byteStream . byteArray . length ) { const element = readDicomElementImplicit ( byteStream , undefined , vrCallback ) ; elements [ element . tag ] = element ; 
function handleFileSelect ( evt ) { evt . stopPropagation ( ) ; evt . preventDefault ( ) ; 
function readDicomDataSetExplicitUndefinedLength ( byteStream , warnings ) { const elements = { } ; while ( byteStream . position < byteStream . byteArray . length ) { const element = readDicomElementExplicit ( byteStream , warnings ) ; elements [ element . tag ] = element ; 
function sha1 ( buffer , offset , length ) { offset = offset || 0 ; length = length || buffer . length ; var subArray = dicomParser . sharedCopy ( buffer , offset , length ) ; var rusha = new Rusha ( ) ; return rusha . digest ( subArray ) ; } 
function getMarkdownToTextConverter ( ) { const remark = require ( 'remark' ) const strip = require ( 'strip-markdown' ) const converter = remark ( ) . use ( strip ) return ( md ) => String ( converter . processSync ( md ) ) } 
function ( password , privateKey ) { 
function ( password , count ) { 
function ( data ) { 
function ( privateKey , password ) { 
function ( senderPriv , recipientPub , msg , iv , salt ) { 
function ( senderPriv , recipientPub , msg ) { 
function ( recipientPrivate , senderPublic , _payload ) { 
function ( ua , uaLength ) { let temp = [ ] ; for ( let i = 0 ; i < uaLength ; i += 4 ) { let x = ua [ i ] * 0x1000000 + ( ua [ i + 1 ] || 0 ) * 0x10000 + ( ua [ i + 2 ] || 0 ) * 0x100 + ( ua [ i + 3 ] || 0 ) ; temp . push ( ( x > 0x7fffffff ) ? x - 0x100000000 : x ) ; } return CryptoJS . lib . WordArray . create ( temp , uaLength ) ; } 
function ( destUa , cryptowords ) { for ( let i = 0 ; i < destUa . length ; i += 4 ) { let v = cryptowords . words [ i / 4 ] ; if ( v < 0 ) v += 0x100000000 ; destUa [ i ] = ( v >>> 24 ) ; destUa [ i + 1 ] = ( v >>> 16 ) & 0xff ; destUa [ i + 2 ] = ( v >>> 8 ) & 0xff ; destUa [ i + 3 ] = v & 0xff ; } return destUa ; } 
function encodeBlock ( input , inputOffset , output , outputOffset ) { output [ outputOffset + 0 ] = Alphabet [ input [ inputOffset + 0 ] >> 3 ] ; output [ outputOffset + 1 ] = Alphabet [ ( ( input [ inputOffset + 0 ] & 0x07 ) << 2 ) | ( input [ inputOffset + 1 ] >> 6 ) ] ; output [ outputOffset + 2 ] = Alphabet [ ( input [ inputOffset + 1 ] & 0x3E ) >> 1 ] ; output [ outputOffset + 3 ] = Alphabet [ ( ( input [ inputOffset + 1 ] & 0x01 ) << 4 ) | ( input [ inputOffset + 2 ] >> 4 ) ] ; output [ outputOffset + 4 ] = Alphabet [ ( ( input [ inputOffset + 2 ] & 0x0F ) << 1 ) | ( input [ inputOffset + 3 ] >> 7 ) ] ; output [ outputOffset + 5 ] = Alphabet [ ( input [ inputOffset + 3 ] & 0x7F ) >> 2 ] ; output [ outputOffset + 6 ] = Alphabet [ ( ( input [ inputOffset + 3 ] & 0x03 ) << 3 ) | ( input [ inputOffset + 4 ] >> 5 ) ] ; output [ outputOffset + 7 ] = Alphabet [ input [ inputOffset + 4 ] & 0x1F ] ; } 
function ( p ) { var dx = p . x - this . x , dy = p . y - this . y ; return dx * dx + dy * dy ; } 
function ( x , y ) { return Math . atan2 ( this . x * y - this . y * x , this . x * x + this . y * y ) ; } 
function startCreateDefaultReExportEsms ( ) { return globby ( [ _path . resolve ( ` ${ inputLibOpenflPath } ` , ` ` ) ] ) . then ( paths => { for ( let path of paths ) { 
function ( str , $parent ) { if ( ! str ) { return 0 ; } if ( ! Selectize . $testInput ) { Selectize . $testInput = $ ( '<span />' ) . css ( { position : 'absolute' , top : - 99999 , left : - 99999 , width : 'auto' , padding : 0 , whiteSpace : 'pre' } ) . appendTo ( 'body' ) ; } Selectize . $testInput . text ( str ) ; transferStyles ( $parent , Selectize . $testInput , [ 'letterSpacing' , 'fontSize' , 'fontFamily' , 'fontWeight' , 'textTransform' ] ) ; return Selectize . $testInput . width ( ) ; } 
function ( $input , settings_element ) { var i , n , tagName , $children , order = 0 ; var options = settings_element . options ; var optionsMap = { } ; var readData = function ( $el ) { var data = attr_data && $el . attr ( attr_data ) ; if ( typeof data === 'string' && data . length ) { return JSON . parse ( data ) ; } return null ; } ; var addOption = function ( $option , group ) { $option = $ ( $option ) ; var value = hash_key ( $option . val ( ) ) ; if ( ! value && ! settings . allowEmptyOption ) return ; 
function ( ) { var self = this ; var settings = self . settings ; var eventNS = self . eventNS ; var $window = $ ( window ) ; var $document = $ ( document ) ; var $input = self . $input ; var $wrapper ; var $control ; var $control_input ; var $dropdown ; var $dropdown_content ; var $dropdown_parent ; var inputMode ; var timeout_blur ; var timeout_focus ; var classes ; var classes_plugins ; var inputId ; inputMode = self . settings . mode ; classes = $input . attr ( 'class' ) || '' ; $wrapper = $ ( '<div>' ) . addClass ( settings . wrapperClass ) . addClass ( classes ) . addClass ( inputMode ) ; $control = $ ( '<div>' ) . addClass ( settings . inputClass ) . addClass ( 'items' ) . appendTo ( $wrapper ) ; $control_input = $ ( '<input type="text" autocomplete="off" />' ) . appendTo ( $control ) . attr ( 'tabindex' , $input . is ( ':disabled' ) ? '-1' : self . tabIndex ) ; $dropdown_parent = $ ( settings . dropdownParent || $wrapper ) ; $dropdown = $ ( '<div>' ) . addClass ( settings . dropdownClass ) . addClass ( inputMode ) . hide ( ) . appendTo ( $dropdown_parent ) ; $dropdown_content = $ ( '<div>' ) . addClass ( settings . dropdownContentClass ) . appendTo ( $dropdown ) ; if ( inputId = $input . attr ( 'id' ) ) { $control_input . attr ( 'id' , inputId + '-selectized' ) ; $ ( "label[for='" + inputId + "']" ) . attr ( 'for' , inputId + '-selectized' ) ; } if ( self . settings . copyClassesToDropdown ) { $dropdown . addClass ( classes ) ; } $wrapper . css ( { width : $input [ 0 ] . style . width } ) ; if ( self . plugins . names . length ) { classes_plugins = 'plugin-' + self . plugins . names . join ( ' plugin-' ) ; $wrapper . addClass ( classes_plugins ) ; $dropdown . addClass ( classes_plugins ) ; } if ( ( settings . maxItems === null || settings . maxItems > 1 ) && self . tagType === TAG_SELECT ) { $input . attr ( 'multiple' , 'multiple' ) ; } if ( self . settings . placeholder ) { $control_input . attr ( 'placeholder' , settings . placeholder ) ; } 
function ( e ) { var self = this ; 
function ( triggerDropdown ) { var i , j , k , n , groups , groups_order , option , option_html , optgroup , optgroups , html , html_children , has_create_option ; var $active , $active_before , $create ; if ( typeof triggerDropdown === 'undefined' ) { triggerDropdown = true ; } var self = this ; var query = $ . trim ( self . $control_input . val ( ) ) ; var results = self . search ( query ) ; var $dropdown_content = self . $dropdown_content ; var active_before = self . $activeOption && hash_key ( self . $activeOption . attr ( 'data-value' ) ) ; 
function ( data ) { var key = hash_key ( data [ this . settings . valueField ] ) ; if ( typeof key === 'undefined' || key === null || this . options . hasOwnProperty ( key ) ) return false ; data . $order = data . $order || ++ this . order ; this . options [ key ] = data ; return key ; } 
function ( ) { var self = this ; self . loadedSearches = { } ; self . userOptions = { } ; self . renderCache = { } ; var options = self . options ; $ . each ( self . options , function ( key , value ) { if ( self . items . indexOf ( key ) == - 1 ) { delete options [ key ] ; } } ) ; self . options = self . sifter . items = options ; self . lastQuery = null ; self . trigger ( 'option_clear' ) ; } 
function ( values , silent ) { this . buffer = document . createDocumentFragment ( ) ; var childNodes = this . $control [ 0 ] . childNodes ; for ( var i = 0 ; i < childNodes . length ; i ++ ) { this . buffer . appendChild ( childNodes [ i ] ) ; } var items = $ . isArray ( values ) ? values : [ values ] ; for ( var i = 0 , n = items . length ; i < n ; i ++ ) { this . isPending = ( i < n - 1 ) ; this . addItem ( items [ i ] , silent ) ; } var control = this . $control [ 0 ] ; control . insertBefore ( this . buffer , control . firstChild ) ; this . buffer = null ; } 
function ( value , silent ) { var self = this ; var $item , i , idx ; $item = ( value instanceof $ ) ? value : self . getItem ( value ) ; value = hash_key ( $item . attr ( 'data-value' ) ) ; i = self . items . indexOf ( value ) ; if ( i !== - 1 ) { $item . remove ( ) ; if ( $item . hasClass ( 'active' ) ) { idx = self . $activeItems . indexOf ( $item [ 0 ] ) ; self . $activeItems . splice ( idx , 1 ) ; } self . items . splice ( i , 1 ) ; self . lastQuery = null ; if ( ! self . settings . persist && self . userOptions . hasOwnProperty ( value ) ) { self . removeOption ( value , silent ) ; } if ( i < self . caretPos ) { self . setCaret ( self . caretPos - 1 ) ; } self . refreshState ( ) ; self . updatePlaceholder ( ) ; self . updateOriginalInput ( { silent : silent } ) ; self . positionDropdown ( ) ; self . trigger ( 'item_remove' , value , $item ) ; } } 
function ( ) { if ( ! this . isRequired ) return false ; var invalid = ! this . items . length ; this . isInvalid = invalid ; this . $control_input . prop ( 'required' , invalid ) ; this . $input . prop ( 'required' , ! invalid ) ; } 
function ( ) { var self = this ; var trigger = self . isOpen ; if ( self . settings . mode === 'single' && self . items . length ) { self . hideInput ( ) ; 
function ( $el ) { var caret = Math . min ( this . caretPos , this . items . length ) ; var el = $el [ 0 ] ; var target = this . buffer || this . $control [ 0 ] ; if ( caret === 0 ) { target . insertBefore ( el , target . firstChild ) ; } else { target . insertBefore ( el , target . childNodes [ caret ] ) ; } this . setCaret ( caret + 1 ) ; } 
function ( templateName , data ) { var value , id , label ; var html = '' ; var cache = false ; var self = this ; var regex_tag = / ^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?) / i ; if ( templateName === 'option' || templateName === 'item' ) { value = hash_key ( data [ self . settings . valueField ] ) ; cache = ! ! value ; } 
function ( ) { var center = - this . y + this . wrapperHeight / 2 ; var minorPhase = Math . max ( Math . floor ( - this . y / this . infiniteElementHeight ) - this . infiniteUpperBufferSize , 0 ) , majorPhase = Math . floor ( minorPhase / this . infiniteLength ) , phase = minorPhase - majorPhase * this . infiniteLength ; var top = 0 ; var i = 0 ; var update = [ ] ; 
function isPassive ( ) { var supportsPassiveOption = false ; try { addEventListener ( "test" , null , Object . defineProperty ( { } , 'passive' , { get : function ( ) { supportsPassiveOption = true ; } } ) ) ; } catch ( e ) { } return supportsPassiveOption ; } 
function _indicatorsMap ( fn ) { if ( that . indicators ) { for ( var i = that . indicators . length ; i -- ; ) { fn . call ( that . indicators [ i ] ) ; } } } 
function ( fn ) { var cache = { } ; return function ( input ) { if ( ! ( input in cache ) ) { cache [ input ] = fn ( input ) ; } return cache [ input ] ; } ; } 
function updateMetrics ( ) { isVwDirty = false ; DPR = window . devicePixelRatio ; cssCache = { } ; sizeLengthCache = { } ; pf . DPR = DPR || 1 ; units . width = Math . max ( window . innerWidth || 0 , docElem . clientWidth ) ; units . height = Math . max ( window . innerHeight || 0 , docElem . clientHeight ) ; units . vw = units . width / 100 ; units . vh = units . height / 100 ; evalId = [ units . height , units . width , DPR ] . join ( "-" ) ; units . em = pf . getEmValue ( ) ; units . rem = units . em ; } 
function parseSrcset ( input , set ) { function collectCharacters ( regEx ) { var chars , match = regEx . exec ( input . substring ( pos ) ) ; if ( match ) { chars = match [ 0 ] ; pos += chars . length ; return chars ; } } var inputLength = input . length , url , descriptors , currentDescriptor , state , c , * Adds descriptor properties to a candidate, pushes to the candidates array * @return undefined */ * Tokenizes descriptor properties prior to parsing * Returns undefined. * (Again, this fn is defined before it is used, in order to pass JSHINT. * Unfortunately this breaks the logical sequencing of the spec comments. :/ ) */ function tokenize ( ) { 
function parseDescriptors ( ) { 
function tokenize ( ) { 
function parseSizes ( strValue ) { 
function parseComponentValues ( str ) { var chrctr ; var component = "" ; var componentArray = [ ] ; var listArray = [ ] ; var parenDepth = 0 ; var pos = 0 ; var inComment = false ; function pushComponent ( ) { if ( component ) { componentArray . push ( component ) ; component = "" ; } } function pushComponentArray ( ) { if ( componentArray [ 0 ] ) { listArray . push ( componentArray ) ; componentArray = [ ] ; } } 
function ( func , wait ) { var timeout , timestamp ; var later = function ( ) { var last = ( new Date ( ) ) - timestamp ; if ( last < wait ) { timeout = setTimeout ( later , wait - last ) ; } else { timeout = null ; func ( ) ; } } ; return function ( ) { timestamp = new Date ( ) ; if ( ! timeout ) { timeout = setTimeout ( later , wait ) ; } } ; } 
function Invocation ( job , fireDate , recurrenceRule , endDate ) { this . job = job ; this . fireDate = fireDate ; this . endDate = endDate ; this . recurrenceRule = recurrenceRule || DoesntRecur ; this . timerID = null ; } 
function Range ( start , end , step ) { this . start = start || 0 ; this . end = end || 60 ; this . step = step || 1 ; } 
function RecurrenceRule ( year , month , date , dayOfWeek , hour , minute , second ) { this . recurs = true ; this . year = ( year == null ) ? null : year ; this . month = ( month == null ) ? null : month ; this . date = ( date == null ) ? null : date ; this . dayOfWeek = ( dayOfWeek == null ) ? null : dayOfWeek ; this . hour = ( hour == null ) ? null : hour ; this . minute = ( minute == null ) ? null : minute ; this . second = ( second == null ) ? 0 : second ; } 
function runOnDate ( date , job ) { var now = Date . now ( ) ; var then = date . getTime ( ) ; return lt . setTimeout ( function ( ) { if ( then > Date . now ( ) ) runOnDate ( date , job ) ; else job ( ) ; } , ( then < now ? 0 : then - now ) ) ; } 
function scheduleNextRecurrence ( rule , job , prevDate , endDate ) { prevDate = ( prevDate instanceof CronDate ) ? prevDate : new CronDate ( ) ; var date = ( rule instanceof RecurrenceRule ) ? rule . _nextInvocationDate ( prevDate ) : rule . next ( ) ; if ( date === null ) { return null ; } if ( ( endDate instanceof CronDate ) && date . getTime ( ) > endDate . getTime ( ) ) { return null ; } var inv = new Invocation ( job , date , rule , endDate ) ; scheduleInvocation ( inv ) ; return inv ; } 
function scheduleJob ( ) { if ( arguments . length < 2 ) { return null ; } var name = ( arguments . length >= 3 && typeof arguments [ 0 ] === 'string' ) ? arguments [ 0 ] : null ; var spec = name ? arguments [ 1 ] : arguments [ 0 ] ; var method = name ? arguments [ 2 ] : arguments [ 1 ] ; var callback = name ? arguments [ 3 ] : arguments [ 2 ] ; var job = new Job ( name , method , callback ) ; if ( job . schedule ( spec ) ) { return job ; } return null ; } 
function getPropertyValue ( cssRule : HTMLElementWithStyleMap | CSSStyleRule | CSSKeyframeRule , prop : string ) : string { try { 
function indentStr ( str : string , indent : number ) : string { let result = '' for ( let index = 0 ; index < indent ; index ++ ) result += ' ' return result + str } 
function mapValuesByProp ( value : JssValue , prop : string , rule : StyleRule ) { return value . map ( item => objectToArray ( item , prop , rule , false , true ) ) } 
function extend ( style , rule , sheet , newStyle = { } ) { mergeExtend ( style , rule , sheet , newStyle ) mergeRest ( style , rule , sheet , newStyle ) return newStyle } 
function convertCase ( style ) { const converted = { } for ( const prop in style ) { const key = prop . indexOf ( '--' ) === 0 ? prop : hyphenate ( prop ) converted [ key ] = style [ prop ] } if ( style . fallbacks ) { if ( Array . isArray ( style . fallbacks ) ) converted . fallbacks = style . fallbacks . map ( convertCase ) else converted . fallbacks = convertCase ( style . fallbacks ) } return converted } 
function ResourceNamespace ( stripe , resources ) { for ( var name in resources ) { var camelCaseName = name [ 0 ] . toLowerCase ( ) + name . substring ( 1 ) ; var resource = new resources [ name ] ( stripe ) ; this [ camelCaseName ] = resource ; } } 
function ( data ) { return qs . stringify ( data , { serializeDate : function ( d ) { return Math . floor ( d . getTime ( ) / 1000 ) ; } } ) 
function ( args ) { if ( args . length < 1 || ! isPlainObject ( args [ 0 ] ) ) { return { } ; } if ( ! utils . isOptionsHash ( args [ 0 ] ) ) { return args . shift ( ) ; } var argKeys = Object . keys ( args [ 0 ] ) ; var optionKeysInArgs = argKeys . filter ( function ( key ) { return OPTIONS_KEYS . indexOf ( key ) > - 1 ; } ) ; 
function ( args ) { var opts = { auth : null , headers : { } , } ; if ( args . length > 0 ) { var arg = args [ args . length - 1 ] ; if ( utils . isAuthKey ( arg ) ) { opts . auth = args . pop ( ) ; } else if ( utils . isOptionsHash ( arg ) ) { var params = args . pop ( ) ; var extraKeys = Object . keys ( params ) . filter ( function ( key ) { return OPTIONS_KEYS . indexOf ( key ) == - 1 ; } ) ; if ( extraKeys . length ) { emitWarning ( 'Invalid options found (' + extraKeys . join ( ', ' ) + '); ignoring.' ) ; } if ( params . api_key ) { opts . auth = params . api_key ; } if ( params . idempotency_key ) { opts . headers [ 'Idempotency-Key' ] = params . idempotency_key ; } if ( params . stripe_account ) { opts . headers [ 'Stripe-Account' ] = params . stripe_account ; } if ( params . stripe_version ) { opts . headers [ 'Stripe-Version' ] = params . stripe_version ; } } } return opts ; } 
function ( sub ) { var Super = this ; var Constructor = hasOwn . call ( sub , 'constructor' ) ? sub . constructor : function ( ) { Super . apply ( this , arguments ) ; } ; 
function ( a , b ) { a = Buffer . from ( a ) ; b = Buffer . from ( b ) ; 
function ( obj ) { if ( typeof obj !== 'object' ) { throw new Error ( 'Argument must be an object' ) ; } Object . keys ( obj ) . forEach ( function ( key ) { if ( obj [ key ] === null || obj [ key ] === undefined ) { delete obj [ key ] ; } } ) ; return obj ; } 
function ( obj ) { if ( obj . file && obj . file . data ) { return obj . file . data instanceof EventEmitter ; } return false ; } 
function safeExec ( cmd , cb ) { try { utils . _exec ( cmd , cb ) ; } catch ( e ) { cb ( e , null ) ; } } 
function getItemCallback ( args ) { if ( args . length === 0 ) { return undefined ; } var onItem = args [ 0 ] ; if ( typeof onItem !== 'function' ) { throw Error ( 'The first argument to autoPagingEach, if present, must be a callback function; receieved ' + typeof onItem ) ; } 
function memoizedPromise ( promiseCache , cb ) { if ( promiseCache . currentPromise ) { return promiseCache . currentPromise ; } promiseCache . currentPromise = new Promise ( cb ) . then ( function ( ret ) { promiseCache . currentPromise = undefined ; return ret ; } ) ; return promiseCache . currentPromise ; } 
function ( payload , header , secret , tolerance ) { this . signature . verifyHeader ( payload , header , secret , tolerance || Webhook . DEFAULT_TOLERANCE ) ; var jsonPayload = JSON . parse ( payload ) ; return jsonPayload ; } 
function ( opts ) { if ( ! opts ) { throw new Error . StripeError ( { message : 'Options are required' , } ) ; } opts . timestamp = Math . floor ( opts . timestamp ) || Math . floor ( Date . now ( ) / 1000 ) ; opts . scheme = opts . scheme || signature . EXPECTED_SCHEME ; opts . signature = opts . signature || signature . _computeSignature ( opts . timestamp + '.' + opts . payload , opts . secret ) ; var generatedHeader = [ 't=' + opts . timestamp , opts . scheme + '=' + opts . signature , ] . join ( ',' ) ; return generatedHeader ; } 
function StripeResource ( stripe , urlData ) { this . _stripe = stripe ; this . _urlData = urlData || { } ; this . basePath = utils . makeURLInterpolator ( this . basePath || stripe . getApiField ( 'basePath' ) ) ; this . resourcePath = this . path ; this . path = utils . makeURLInterpolator ( this . path ) ; if ( this . includeBasic ) { this . includeBasic . forEach ( function ( methodName ) { this [ methodName ] = StripeResource . BASIC_METHODS [ methodName ] ; } , this ) ; } this . initialize . apply ( this , arguments ) ; } 
function stripeMethod ( spec ) { return function ( ) { var self = this ; var args = [ ] . slice . call ( arguments ) ; var callback = typeof args [ args . length - 1 ] == 'function' && args . pop ( ) ; var requestPromise = utils . callbackifyPromiseWithTimeout ( makeRequest ( self , args , spec , { } ) , callback ) if ( spec . methodType === 'list' ) { var autoPaginationMethods = makeAutoPaginationMethods ( self , args , spec , requestPromise ) ; Object . assign ( requestPromise , autoPaginationMethods ) ; } return requestPromise ; } ; } 
function multipartDataGenerator ( method , data , headers ) { var segno = ( Math . round ( Math . random ( ) * 1e16 ) + Math . round ( Math . random ( ) * 1e16 ) ) . toString ( ) ; headers [ 'Content-Type' ] = ( 'multipart/form-data; boundary=' + segno ) ; var buffer = Buffer . alloc ( 0 ) ; function push ( l ) { var prevBuffer = buffer ; var newBuffer = ( l instanceof Buffer ) ? l : Buffer . from ( l ) ; buffer = Buffer . alloc ( prevBuffer . length + newBuffer . length + 2 ) ; prevBuffer . copy ( buffer ) ; newBuffer . copy ( buffer , prevBuffer . length ) ; buffer . write ( '\r\n' , buffer . length - 2 ) ; } function q ( s ) { return '"' + s . replace ( / "|" / g , '%22' ) . replace ( / \r\n|\r|\n / g , ' ' ) + '"' ; } for ( var k in utils . flattenAndStringify ( data ) ) { var v = data [ k ] ; push ( '--' + segno ) ; if ( v . hasOwnProperty ( 'data' ) ) { push ( 'Content-Disposition: form-data; name=' + q ( k ) + '; filename=' + q ( v . name || 'blob' ) ) ; push ( 'Content-Type: ' + ( v . type || 'application/octet-stream' ) ) ; push ( '' ) ; push ( v . data ) ; } else { push ( 'Content-Disposition: form-data; name=' + q ( k ) ) ; push ( '' ) ; push ( v ) ; } } push ( '--' + segno + '--' ) ; return buffer ; } 
function ( cb ) { if ( Stripe . USER_AGENT_SERIALIZED ) { return cb ( Stripe . USER_AGENT_SERIALIZED ) ; } this . getClientUserAgentSeeded ( Stripe . USER_AGENT , function ( cua ) { Stripe . USER_AGENT_SERIALIZED = cua ; cb ( Stripe . USER_AGENT_SERIALIZED ) ; } ) } 
function ( seed , cb ) { var self = this ; utils . safeExec ( 'uname -a' , function ( err , uname ) { var userAgent = { } ; for ( var field in seed ) { userAgent [ field ] = encodeURIComponent ( seed [ field ] ) ; } 
function createSharingUrl ( network ) { return this . baseNetworks [ network ] . sharer . replace ( / @url / g , encodeURIComponent ( this . url ) ) . replace ( / @title / g , encodeURIComponent ( this . title ) ) . replace ( / @description / g , encodeURIComponent ( this . description ) ) . replace ( / @quote / g , encodeURIComponent ( this . quote ) ) . replace ( / @hashtags / g , this . generateHashtags ( network , this . hashtags ) ) . replace ( / @media / g , this . media ) . replace ( / @twitteruser / g , this . twitterUser ? '&via=' + this . twitterUser : '' ) ; } 
function share ( network ) { this . openSharer ( network , this . createSharingUrl ( network ) ) ; this . $root . $emit ( 'social_shares_open' , network , this . url ) ; this . $emit ( 'open' , network , this . url ) ; } 
function touch ( network ) { window . open ( this . createSharingUrl ( network ) , '_self' ) ; this . $root . $emit ( 'social_shares_open' , network , this . url ) ; this . $emit ( 'open' , network , this . url ) ; } 
function openSharer ( network , url ) { var this$1 = this ; 
function mounted ( ) { if ( ! inBrowser ) { return ; } var dualScreenLeft = $window . screenLeft !== undefined ? $window . screenLeft : screen . left ; var dualScreenTop = $window . screenTop !== undefined ? $window . screenTop : screen . top ; var width = $window . innerWidth ? $window . innerWidth : ( document . documentElement . clientWidth ? document . documentElement . clientWidth : screen . width ) ; var height = $window . innerHeight ? $window . innerHeight : ( document . documentElement . clientHeight ? document . documentElement . clientHeight : screen . height ) ; this . popup . left = ( ( width / 2 ) - ( this . popup . width / 2 ) ) + dualScreenLeft ; this . popup . top = ( ( height / 2 ) - ( this . popup . height / 2 ) ) + dualScreenTop ; } 
function loadAndParseFile ( filename , settings , nextFile ) { if ( settings . debug ) { debug ( 'loadAndParseFile(\'' + filename + '\')' ) ; debug ( 'totalFiles: ' + settings . totalFiles ) ; debug ( 'filesLoaded: ' + settings . filesLoaded ) ; } if ( filename !== null && typeof filename !== 'undefined' ) { $ . ajax ( { url : filename , async : settings . async , cache : settings . cache , dataType : 'text' , success : function ( data , status ) { if ( settings . debug ) { debug ( 'Succeeded in downloading ' + filename + '.' ) ; debug ( data ) ; } parseData ( data , settings ) ; nextFile ( ) ; } , error : function ( jqXHR , textStatus , errorThrown ) { if ( settings . debug ) { debug ( 'Failed to download or parse ' + filename + '. errorThrown: ' + errorThrown ) ; } if ( jqXHR . status === 404 ) { settings . totalFiles -= 1 ; } nextFile ( ) ; } } ) ; } } 
function parseData ( data , settings ) { var parsed = '' ; var lines = data . split ( / \n / ) ; var regPlaceHolder = / (\{\d+}) / g ; var regRepPlaceHolder = / \{(\d+)} / g ; var unicodeRE = / (\\u.{4}) / ig ; for ( var i = 0 , j = lines . length ; i < j ; i ++ ) { var line = lines [ i ] ; line = line . trim ( ) ; if ( line . length > 0 && line . match ( "^#" ) != "#" ) { 
function checkKeyNamespace ( key ) { var regDot = / \. / ; if ( regDot . test ( key ) ) { var fullname = '' ; var names = key . split ( / \. / ) ; for ( var i = 0 , j = names . length ; i < j ; i ++ ) { var name = names [ i ] ; if ( i > 0 ) { fullname += '.' ; } fullname += name ; if ( eval ( 'typeof ' + fullname + ' == "undefined"' ) ) { eval ( fullname + '={};' ) ; } } } } 
function unescapeUnicode ( str ) { 
function ( x , left , right ) { if ( x < left ) { return left - x ; } else if ( x > right ) { return x - right ; } else { return 0 ; } } 
function ( event , g ) { var chartPos = utils . findPos ( g . canvas_ ) ; var box = { left : chartPos . x , right : chartPos . x + g . canvas_ . offsetWidth , top : chartPos . y , bottom : chartPos . y + g . canvas_ . offsetHeight } ; var pt = { x : utils . pageX ( event ) , y : utils . pageY ( event ) } ; var dx = distanceFromInterval ( pt . x , box . left , box . right ) , dy = distanceFromInterval ( pt . y , box . top , box . bottom ) ; return Math . max ( dx , dy ) ; } 
function ( event , g , context ) { 
function ( event ) { if ( context . isZooming ) { 
function ( event , g , context ) { if ( context . cancelNextDblclick ) { context . cancelNextDblclick = false ; return ; } 
function getControlPoints ( p0 , p1 , p2 , opt_alpha , opt_allowFalseExtrema ) { var alpha = ( opt_alpha !== undefined ) ? opt_alpha : 1 / 3 ; 
function smoothPlotter ( e ) { var ctx = e . drawingContext , points = e . points ; ctx . beginPath ( ) ; ctx . moveTo ( points [ 0 ] . canvasx , points [ 0 ] . canvasy ) ; 
function ( dygraph ) { this . dygraph_ = dygraph ; this . yAxes_ = [ ] ; this . xAxis_ = { } ; this . series_ = { } ; * A list of series in columnar order. * @type {Array.<string>} */ this . labels_ = [ ] ; this . highlightSeries_ = this . get ( "highlightSeriesOpts" ) || { } ; this . reparseSeries ( ) ; } 
function ( opt_options ) { this . annotations_ = [ ] ; 
function ( dygraph ) { this . dygraph_ = dygraph ; this . points = [ ] ; this . setNames = [ ] ; this . annotations = [ ] ; this . yAxes_ = null ; 
function ( event , g , contextB ) { 
function ( idx ) { 
function validateNativeFormat ( data ) { const firstRow = data [ 0 ] ; const firstX = firstRow [ 0 ] ; if ( typeof firstX !== 'number' && ! utils . isDateLike ( firstX ) ) { throw new Error ( ` ${ typeof firstX } ${ firstX } ` ) ; } for ( let i = 1 ; i < firstRow . length ; i ++ ) { const val = firstRow [ i ] ; if ( val === null || val === undefined ) continue ; if ( typeof val === 'number' ) continue ; if ( utils . isArrayLike ( val ) ) continue ; 
function isNode ( o ) { return ( typeof Node === "object" ? o instanceof Node : typeof o === "object" && typeof o . nodeType === "number" && typeof o . nodeName === "string" ) ; } 
function ( options ) { for ( var property in options ) { if ( options . hasOwnProperty ( property ) && ! pixelSafeOptions [ property ] ) { return true ; } } return false ; } 
function parseRGBA ( rgbStr ) { var bits = RGBA_RE . exec ( rgbStr ) ; if ( ! bits ) return null ; var r = parseInt ( bits [ 1 ] , 10 ) , g = parseInt ( bits [ 2 ] , 10 ) , b = parseInt ( bits [ 3 ] , 10 ) ; if ( bits [ 4 ] ) { return { r : r , g : g , b : b , a : parseFloat ( bits [ 4 ] ) } ; } else { return { r : r , g : g , b : b } ; } } 
function ( dygraph , element , elementContext , layout ) { this . dygraph_ = dygraph ; this . layout = layout ; this . element = element ; this . elementContext = elementContext ; this . height = dygraph . height_ ; this . width = dygraph . width_ ; 
function ( opt_losslessOnly ) { if ( pendingActions . length <= 1 ) return ; 
function ( ctx , baselineX , baselineY , pathBack ) { ctx . lineTo ( baselineX , baselineY ) ; if ( stackedGraph ) { for ( var i = pathBack . length - 1 ; i >= 0 ; i -- ) { var pt = pathBack [ i ] ; ctx . lineTo ( pt [ 0 ] , pt [ 1 ] ) ; } } } 
function ( opt_options ) { this . canvas_ = document . createElement ( "canvas" ) ; opt_options = opt_options || { } ; this . direction_ = opt_options . direction || null ; } 
function ( r ) { var div = document . createElement ( 'div' ) ; div . style . position = 'absolute' ; div . style . left = r . x + 'px' ; div . style . top = r . y + 'px' ; div . style . width = r . w + 'px' ; div . style . height = r . h + 'px' ; return div ; } 
function ( div ) { var sizeSpan = document . createElement ( 'span' ) ; sizeSpan . setAttribute ( 'style' , 'margin: 0; padding: 0 0 0 1em; border: 0;' ) ; div . appendChild ( sizeSpan ) ; var oneEmWidth = sizeSpan . offsetWidth ; div . removeChild ( sizeSpan ) ; return oneEmWidth ; } 
function generateLegendDashHTML ( strokePattern , color , oneEmWidth ) { 
function Keycloak ( config , keycloakConfig ) { 
function GrantManager ( config ) { this . realmUrl = config . realmUrl ; this . clientId = config . clientId ; this . secret = config . secret ; this . publicKey = config . publicKey ; this . public = config . public ; this . bearerOnly = config . bearerOnly ; this . notBefore = 0 ; this . rotation = new Rotation ( config ) ; } 
function Rotation ( config ) { this . realmUrl = config . realmUrl ; this . minTimeBetweenJwksRequests = config . minTimeBetweenJwksRequests ; this . jwks = [ ] ; this . lastTimeRequesTime = 0 ; } 
function Config ( config ) { if ( ! config ) { config = path . join ( process . cwd ( ) , 'keycloak.json' ) ; } if ( typeof config === 'string' ) { this . loadConfiguration ( config ) ; } else { this . configure ( config ) ; } } 
function resolveValue ( value ) { if ( typeof value !== 'string' ) { return value ; } 
function Enforcer ( keycloak , config ) { this . keycloak = keycloak ; this . config = config || { } ; if ( ! this . config . response_mode ) { this . config . response_mode = 'permissions' ; } if ( ! this . config . resource_server_id ) { this . config . resource_server_id = this . keycloak . getConfig ( ) . clientId ; } } 
function Token ( token , clientId ) { this . token = token ; this . clientId = clientId ; if ( token ) { try { const parts = token . split ( '.' ) ; this . header = JSON . parse ( Buffer . from ( parts [ 0 ] , 'base64' ) . toString ( ) ) ; this . content = JSON . parse ( Buffer . from ( parts [ 1 ] , 'base64' ) . toString ( ) ) ; this . signature = Buffer . from ( parts [ 2 ] , 'base64' ) ; this . signed = parts [ 0 ] + '.' + parts [ 1 ] ; } catch ( err ) { this . content = { exp : 0 } ; } } } 
function filter ( a , cb ) { var n = [ ] ; each ( a , function ( v ) { if ( cb ( v ) ) { n . push ( v ) ; } } ) ; return n ; } 
function sanitizeHtml ( html , options , _recursing ) { var result = '' ; function Frame ( tag , attribs ) { var that = this ; this . tag = tag ; this . attribs = attribs || { } ; this . tagPosition = result . length ; this . text = '' ; * Filters user input css properties by whitelisted regex attributes. * * @param {object} abstractSyntaxTree - Object representation of CSS attributes. * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }. * @param {object} allowedStyles - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i). * @return {object} - Abstract Syntax Tree with filtered style attributes. */ function filterCss ( abstractSyntaxTree , allowedStyles ) { if ( ! allowedStyles ) { return abstractSyntaxTree ; } var filteredAST = cloneDeep ( abstractSyntaxTree ) ; var astRules = abstractSyntaxTree . nodes [ 0 ] ; var selectedRule ; * Extracts the style attribues from an AbstractSyntaxTree and formats those * values in the inline style attribute format. * * @param {AbstractSyntaxTree} filteredAST * @return {string} - Example: "color:yellow;text-align:center;font-family:helvetica;" */ function stringifyStyleAttributes ( filteredAST ) { return filteredAST . nodes [ 0 ] . nodes . reduce ( function ( extractedAttributes , attributeObject ) { extractedAttributes . push ( attributeObject . prop + ':' + attributeObject . value ) ; return extractedAttributes ; } , [ ] ) . join ( ';' ) ; } function filterDeclarations ( selectedRule ) { return function ( allowedDeclarationsList , attributeObject ) { 
function filterCss ( abstractSyntaxTree , allowedStyles ) { if ( ! allowedStyles ) { return abstractSyntaxTree ; } var filteredAST = cloneDeep ( abstractSyntaxTree ) ; var astRules = abstractSyntaxTree . nodes [ 0 ] ; var selectedRule ; 
function stringifyStyleAttributes ( filteredAST ) { return filteredAST . nodes [ 0 ] . nodes . reduce ( function ( extractedAttributes , attributeObject ) { extractedAttributes . push ( attributeObject . prop + ':' + attributeObject . value ) ; return extractedAttributes ; } , [ ] ) . join ( ';' ) ; } 
function filterDeclarations ( selectedRule ) { return function ( allowedDeclarationsList , attributeObject ) { 
function readUint64 ( buffer , offset ) { var hi = ( buffer [ offset ] << 24 | buffer [ offset + 1 ] << 16 | buffer [ offset + 2 ] << 8 | buffer [ offset + 3 ] << 0 ) >>> 0 ; var lo = ( buffer [ offset + 4 ] << 24 | buffer [ offset + 5 ] << 16 | buffer [ offset + 6 ] << 8 | buffer [ offset + 7 ] << 0 ) >>> 0 ; return hi * 0x100000000 + lo ; } 
function sync ( local , remote , ref , depth , callback ) { if ( typeof ref !== "string" ) throw new TypeError ( "ref must be string" ) ; if ( typeof depth !== "number" ) throw new TypeError ( "depth must be number" ) ; var hasCache = { } ; remote . readRef ( ref , function ( err , hash ) { if ( ! hash ) return callback ( err ) ; importCommit ( hash , depth , function ( err ) { if ( err ) return callback ( err ) ; callback ( null , hash ) ; } ) ; } ) ; 
function check ( type , hash , callback ) { if ( typeof type !== "string" ) throw new TypeError ( "type must be string" ) ; if ( typeof hash !== "string" ) throw new TypeError ( "hash must be string" ) ; if ( hasCache [ hash ] ) return callback ( null , true ) ; local . hasHash ( hash , function ( err , has ) { if ( err ) return callback ( err ) ; hasCache [ hash ] = has ; callback ( null , has ) ; } ) ; } 
function pack ( hashes , opts , callback ) { if ( ! callback ) return pack . bind ( this , hashes , opts ) ; var repo = this ; var i = 0 , first = true , done = false ; return callback ( null , applyParser ( { take : take } , encodePack ) ) ; function take ( callback ) { if ( done ) return callback ( ) ; if ( first ) return readFirst ( callback ) ; var hash = hashes [ i ++ ] ; if ( hash === undefined ) { return callback ( ) ; } repo . loadRaw ( hash , function ( err , buffer ) { if ( err ) return callback ( err ) ; if ( ! buffer ) return callback ( new Error ( "Missing hash: " + hash ) ) ; 
function readLength ( ) { var byte = delta [ deltaOffset ++ ] ; var length = byte & 0x7f ; var shift = 7 ; while ( byte & 0x80 ) { byte = delta [ deltaOffset ++ ] ; length |= ( byte & 0x7f ) << shift ; shift += 7 ; } return length ; } 
function $version ( byte ) { version = ( version << 8 ) | byte ; if ( ++ offset < 4 ) return $version ; if ( version >= 2 && version <= 3 ) { offset = 0 ; return $num ; } throw new Error ( "Invalid version number " + num ) ; } 
function $num ( byte ) { num = ( num << 8 ) | byte ; if ( ++ offset < 4 ) return $num ; offset = 0 ; emit ( { version : version , num : num } ) ; return $header ; } 
function $header ( byte ) { if ( start === 0 ) start = position ; type = byte >> 4 & 0x07 ; length = byte & 0x0f ; if ( byte & 0x80 ) { offset = 4 ; return $header2 ; } return afterHeader ( ) ; } 
function emitObject ( ) { var body = bodec . join ( parts ) ; if ( body . length !== length ) { throw new Error ( "Body length mismatch" ) ; } var item = { type : numToType [ type ] , size : length , body : body , offset : start } ; if ( ref ) item . ref = ref ; parts . length = 0 ; start = 0 ; offset = 0 ; type = 0 ; length = 0 ; ref = null ; emit ( item ) ; } 
function $body ( byte , i , chunk ) { if ( inf . write ( byte ) ) return $body ; var buf = inf . flush ( ) ; if ( buf . length !== length ) throw new Error ( "Length mismatch, expected " + length + " got " + buf . length ) ; inf . recycle ( ) ; if ( buf . length ) { parts . push ( buf ) ; } emitObject ( ) ; 
function $checksum ( byte ) { checksum += toHex ( byte ) ; if ( ++ offset < 20 ) return $checksum ; var actual = sha1sum . digest ( ) ; if ( checksum !== actual ) throw new Error ( "Checksum mismatch: " + actual + " != " + checksum ) ; } 
function ( ) { if ( p . currentSession . playerState === 'PLAYING' ) { p . pause ( ) ; } else if ( p . currentSession . playerState === 'PAUSED' ) { p . play ( ) ; } } 
function ( ) { if ( ! volume ) { return ; } else if ( volume . muted ) { p . unmute ( function ( err , status ) { if ( err ) return ; volume = status ; } ) ; } else { p . mute ( function ( err , status ) { if ( err ) return ; volume = status ; } ) ; } } 
function ( ) { if ( ! volume || volume . level >= 1 ) { return ; } var newVolume = Math . min ( volume . level + volumeStep , 1 ) ; p . setVolume ( newVolume , function ( err , status ) { if ( err ) { return ; } debug ( "volume up: %s" , status . level ) ; volume = status ; } ) ; } 
function ( elem ) { var pattern = new RegExp ( _filterValue , 'i' ) ; var element = elem ; if ( pattern . test ( element . textContent ) ) { element . style . display = '' ; } else { element . style . display = 'none' ; } } 
function ( ) { var collection = _logContainer . childNodes ; var i = collection . length ; if ( i === 0 ) { return ; } while ( i ) { _filterElement ( collection [ i - 1 ] ) ; i -= 1 ; } window . scrollTo ( 0 , document . body . scrollHeight ) ; } 
function ( filterInput , uri ) { var _url = new URL ( uri ) ; var _filterValueFromURL = _url . searchParams . get ( 'filter' ) ; if ( typeof _filterValueFromURL !== 'undefined' && _filterValueFromURL !== null ) { _filterValue = _filterValueFromURL ; filterInput . value = _filterValue ; 
function ( value , uri ) { var _url = new URL ( uri ) ; var _params = new URLSearchParams ( _url . search . slice ( 1 ) ) ; if ( value === '' ) { _params . delete ( 'filter' ) ; } else { _params . set ( 'filter' , value ) ; } _url . search = _params . toString ( ) ; window . history . replaceState ( null , document . title , _url . toString ( ) ) ; } 
function init ( opts ) { var self = this ; 
function log ( data ) { var wasScrolledBottom = _isScrolledBottom ( ) ; var div = document . createElement ( 'div' ) ; var p = document . createElement ( 'p' ) ; p . className = 'inner-line' ; 
function Stats ( enabled ) { this . timer = { } ; if ( enabled === true ) { const config = new Configstore ( pkg . name ) ; let clientID = uuidv4 ( ) ; if ( config . has ( 'clientID' ) ) { clientID = config . get ( 'clientID' ) ; } else { config . set ( 'clientID' , clientID ) ; } const tracker = ua ( trackingID , clientID ) ; tracker . set ( 'aip' , 1 ) ; 
function ( arity , count ) { if ( typeof ( arity ) == 'undefined' || typeof ( count ) == 'undefined' ) { throw 'Wrong arguments' ; } if ( count == 0 ) return 0 ; var byteLength = count * arity ; var imgSide = Math . ceil ( Math . sqrt ( byteLength / 4 ) ) ; 
function xModelHandle ( gl , model , fpt ) { if ( typeof ( gl ) == 'undefined' || typeof ( model ) == 'undefined' || typeof ( fpt ) == 'undefined' ) { throw 'WebGL context and geometry model must be specified' ; } this . _gl = gl ; this . _model = model ; this . _fpt = fpt ; this . id = xModelHandle . _instancesNum ++ ; this . stopped = false ; this . count = model . indices . length ; 
function xViewer ( canvas ) { if ( typeof ( canvas ) == 'undefined' ) { throw 'Canvas has to be defined' ; } this . _canvas = null ; if ( typeof ( canvas . nodeName ) != 'undefined' && canvas . nodeName == 'CANVAS' ) { this . _canvas = canvas ; } if ( typeof ( canvas ) == 'string' ) { this . _canvas = document . getElementById ( canvas ) ; } if ( this . _canvas == null ) { throw 'You have to specify canvas either as an ID of HTML element or the element itself' ; } this . perspectiveCamera = { fov : 45 , near : 0 , far : 0 } ; this . orthogonalCamera = { left : 0 , right : 0 , top : 0 , bottom : 0 , near : 0 , far : 0 } ; this . camera = 'perspective' ; this . background = [ 230 , 230 , 230 , 255 ] ; this . highlightingColour = [ 255 , 173 , 33 , 255 ] ; this . lightA = [ 0 , 1000000 , 200000 , 0.8 ] ; this . lightB = [ 0 , - 500000 , 50000 , 0.2 ] ; this . navigationMode = 'orbit' ; this . renderingMode = 'normal' ; this . clippingPlane = [ 0 , 0 , 0 , 0 ] ; this . _lastClippingPoint = [ 0 , 0 , 0 ] ; 
function ( bBox ) { var size = Math . max ( bBox [ 3 ] , bBox [ 4 ] , bBox [ 5 ] ) ; var ratio = Math . max ( viewer . _width , viewer . _height ) / Math . min ( viewer . _width , viewer . _height ) ; viewer . _distance = size / Math . tan ( viewer . perspectiveCamera . fov * Math . PI / 180.0 ) * ratio * 1.0 ; } 
function handleMouseDown ( event ) { mouseDown = true ; lastMouseX = event . clientX ; lastMouseY = event . clientY ; startX = event . clientX ; startY = event . clientY ; * Occurs when mousedown event happens on underlying canvas. * * @event xViewer#mouseDown * @type {object} * @param {Number} id - product ID of the element or null if there wasn't any product under mouse */ viewer . _fire ( 'mouseDown' , { id : id } ) ; //keep information about the mouse button switch ( event . button ) { case 0 : button = 'left' ; break ; case 1 : button = 'middle' ; break ; case 2 : button = 'right' ; break ; default : button = 'left' ; break ; } viewer . _disableTextSelection ( ) ; } 
function Cleaver ( document , options , includePath ) { this . document = document . toString ( ) ; this . options = clone ( options ) || { } ; this . path = path . resolve ( includePath || '.' ) ; if ( ! debugInited ) { if ( this . options . debug ) { debug . enable ( '*' ) ; } debug = debug ( 'cleaver' ) ; debugInited = true ; } helper = require ( './helper' ) ( this . path , this . options . debug ) ; this . templates = { layout : 'templates/layout.mustache' , author : 'templates/author.mustache' , slides : 'templates/default.mustache' } ; this . resources = { style : 'resources/default.css' , githubStyle : 'resources/github.css' , script : 'resources/script.js' } ; this . external = { style : [ ] } ; this . slides = [ ] ; this . override = false ; marked . setOptions ( { gfm : true , highlight : function ( code , lang ) { try { return hljs . highlight ( lang , code ) . value ; } catch ( e ) { return code ; } } } ) ; } 
function clone ( obj ) { var key , copy = { } ; if ( ! obj ) { return ; } for ( key in obj ) { copy [ key ] = obj [ key ] ; } return copy ; } 
function navigate ( n ) { var position = currentPosition ( ) ; var numSlides = document . getElementsByClassName ( 'slide' ) . length ; var nextPosition = ( position - 1 + n ) % numSlides + 1 ; nextPosition = ( nextPosition - 1 + numSlides ) % numSlides + 1 ; document . getElementById ( 'slide-' + position ) . classList . add ( 'hidden' ) ; document . getElementById ( 'slide-' + nextPosition ) . classList . remove ( 'hidden' ) ; updateProgress ( ) ; updateURL ( ) ; updateTabIndex ( ) ; } 
function updateURL ( ) { try { window . history . replaceState ( { } , null , '#' + currentPosition ( ) ) ; } catch ( e ) { window . location . hash = currentPosition ( ) ; } } 
function updateProgress ( ) { var progressBar = document . querySelector ( '.progress-bar' ) ; if ( progressBar !== null ) { var numSlides = document . getElementsByClassName ( 'slide' ) . length ; var position = currentPosition ( ) - 1 ; var percent = ( numSlides === 1 ) ? 100 : 100 * position / ( numSlides - 1 ) ; progressBar . style . width = percent . toString ( ) + '%' ; } } 
function updateTabIndex ( ) { var allLinks = document . querySelectorAll ( '.slide a' ) ; var position = currentPosition ( ) ; var currentPageLinks = document . getElementById ( 'slide-' + position ) . querySelectorAll ( 'a' ) ; var i ; for ( i = 0 ; i < allLinks . length ; i ++ ) { allLinks [ i ] . setAttribute ( 'tabindex' , - 1 ) ; } for ( i = 0 ; i < currentPageLinks . length ; i ++ ) { currentPageLinks [ i ] . removeAttribute ( 'tabindex' ) ; } } 
function toggleFullScreen ( ) { var docElem = document . documentElement ; var doc = document ; docElem . requestFullscreen = docElem . requestFullscreen || docElem . msRequestFullscreen || docElem . mozRequestFullScreen || docElem . webkitRequestFullscreen . bind ( docElem , Element . ALLOW_KEYBOARD_INPUT ) ; doc . exitFullscreen = doc . exitFullscreen || doc . msExitFullscreen || doc . mozCancelFullScreen || doc . webkitExitFullscreen ; isFullScreen ( ) ? doc . exitFullscreen ( ) : docElem . requestFullscreen ( ) ; } 
function pluck ( obj , fields ) { var plucked = { } ; if ( ! obj ) { return ; } fields . forEach ( function ( field ) { plucked [ field ] = obj [ field ] ; } ) ; return plucked ; } 
function loadSingle ( source ) { var promise ; if ( source . match ( / ^https?:\/\/ / ) ) { promise = httpGetPromise ( source ) ; } else { promise = readFilePromise ( normalizePath ( source ) ) ; } return promise ; } 
function populateSingle ( filename , destination , key ) { return loadSingle ( filename ) . then ( function ( data ) { if ( data ) { if ( Object . prototype . toString . call ( destination [ key ] ) === '[object Array]' ) { destination . loaded [ key ] = destination . loaded [ key ] || [ ] ; destination . loaded [ key ] . push ( data ) ; } else { destination . loaded [ key ] = data ; } } } ) ; } 
function load ( map , options ) { var promises = [ ] ; var loaded = { } ; var filename ; options = options || { } ; for ( var key in map ) { if ( map . hasOwnProperty ( key ) ) { if ( ! map [ key ] || map [ key ] . length === 0 ) { continue ; } filename = map [ key ] ; if ( ! options . external ) { filename = path . resolve ( ROOT_DIR , filename ) ; } promises . push ( loadSingle ( filename ) . then ( ( function ( _key ) { return function ( data ) { loaded [ _key ] = data ; } ; } ) ( key ) ) ) ; } } map . loaded = loaded ; return Q . all ( promises ) ; } 
function loadTheme ( source , ctx ) { var promises = [ ] ; if ( ! fs . existsSync ( source ) && source . match ( / ^[\w-]+\/[\w-]+$ / ) ) { source = 'https://raw.githubusercontent.com/' + source + '/master/' ; } if ( ! source . match ( / \/$ / ) ) { source += '/' ; } promises = [ loadSettings ( source + 'settings.json' , ctx ) , populateSingle ( source + 'style.css' , ctx . external , 'style' ) , populateSingle ( source + 'template.mustache' , ctx . templates , 'slides' ) , populateSingle ( source + 'layout.mustache' , ctx . templates , 'layout' ) , populateSingle ( source + 'script.js' , ctx . external , 'script' ) ] ; return Q . all ( promises ) ; } 
function loadSettings ( source , ctx ) { return loadSingle ( source ) . then ( function ( data ) { if ( data ) { data = JSON . parse ( data ) ; ctx . override = data . override ; } } ) ; } 
function readFilePromise ( filename ) { var deferred ; deferred = Q . defer ( ) ; fs . readFile ( filename , 'utf-8' , function ( err , contents ) { if ( err ) { if ( err . code === 'ENOENT' ) { debug ( err . code + ': ' + filename ) ; return deferred . resolve ( ) ; } debug ( err + ' ' + filename ) ; 
function httpGetPromise ( url ) { var deferred = Q . defer ( ) , get ; var cb = function ( res ) { var data = '' ; res . on ( 'data' , function ( chunk ) { data += chunk ; } ) ; res . on ( 'err' , function ( err ) { debug ( err + ' ' + url ) ; deferred . reject ( err ) ; } ) ; res . on ( 'end' , function ( ) { if ( res . statusCode !== 200 ) { debug ( res . statusCode + ': ' + url ) ; deferred . resolve ( ) ; } else { debug ( 'fetched ' + url ) ; deferred . resolve ( data ) ; } } ) ; } ; if ( url . match ( / ^https / ) ) { get = https . get ( url , cb ) ; } else { get = http . get ( url , cb ) ; } get . on ( 'error' , function ( err ) { deferred . resolve ( ) ; debug ( err + ': ' + url ) ; } ) ; return deferred . promise ; } 
function getUserHome ( ) { return process . env . HOME || process . env . HOMEPATH || process . env . USERPROFILE ; } 
function Request ( method , urlPath , cache ) { this . _method = method ; this . _urlPath = urlPath ; this . _cache = cache ; this . _queryParams = [ ] ; 
function applyRequestPlugins ( req ) { 
function responsePluginApplyingCallback ( cb ) { 
function buildSuperagentRequest ( ) { var req = superagent ( this . _method , this . _buildUrl ( ) ) ; if ( this . _agent ) { req . agent ( this . _agent ) ; } req . set ( this . _headers ) ; this . _queryParams . forEach ( params => req . query ( params ) ) ; var postParams = this . _postParams ; 
function logRequestError ( err ) { var { response } = err ; if ( ! response ) { logger . warning ( ` ${ this . _urlPath } ` , err ) ; } else if ( response . notFound ) { 
function ( fn , opts , trim , basePath , prefix ) { var slashPattern = isWindows ? / \\ / g : / \/ / g var name = fn . substring ( basePath . length + trim . length , fn . length ) . replace ( / \.jsx?$ / , '' ) . replace ( slashPattern , '.' ) if ( opts . label ) { name += '.' + opts . label } if ( prefix ) { name = prefix + name } return name ; } 
function ( r , g , b ) { return { server : 16 + r * 36 + g * 6 + b , client : "rgb(" + [ ( r * 42.5 ) | 0 , ( g * 42.5 ) | 0 , ( b * 42.5 ) | 0 , ] . join ( ',' ) + ")" , } } 
function writeBody ( req , res , context , start , page ) { 
function writeElements ( res , elements ) { 
function lazyMixinPageUtilMethods ( page ) { var proto = Object . getPrototypeOf ( page ) ; if ( proto . _haveMixedInPageUtilMethods ) return ; proto . _haveMixedInPageUtilMethods = true ; Object . keys ( PAGE_MIXIN ) . forEach ( method => { if ( proto [ method ] ) { throw new Error ( ` ${ ( proto . constructor || { } ) . name } ${ method } ` ) ; } proto [ method ] = PAGE_MIXIN [ method ] ; } ) ; } 
function standardizeElements ( elements ) { 
function logInvocation ( name , func ) { return function ( ) { logger . debug ( ` ${ name } ` ) ; return func . apply ( this , [ ] . slice . call ( arguments ) ) ; } } 
function makeStandard ( standardize , fn ) { return function ( ) { return standardize ( fn . apply ( null , [ ] . slice . call ( arguments ) ) ) ; } } 
function History ( options ) { this . win = ( options && options . win ) || window ; this . _hasPushState = ! ! ( this . win && this . win . history && this . win . history . pushState ) ; } 
function ( state , title , url ) { var win = this . win ; if ( this . canClientNavigate ( ) ) { win . history . pushState ( state , title , url ) ; } else { this . navigationWindow ( ) . location . href = url ; } } 
function ( state , title , url ) { var win = this . win ; if ( this . canClientNavigate ( ) ) { win . history . replaceState ( state , title , url ) ; } else if ( url !== this . currentUrl ( ) ) { 
function addOnClickHandler ( a , { reuseDom , bundleData } ) { a . onclick = function ( e ) { 
function getWebpackConfig ( userWebpackConfigOpt , wpAffectingOpts ) { let extend = ( data ) => { return data } if ( userWebpackConfigOpt ) { const userWebpackConfigPath = path . resolve ( process . cwd ( ) , userWebpackConfigOpt ) ; const userWebpackConfigFunc = require ( userWebpackConfigPath ) ; extend = userWebpackConfigFunc . default ; } const baseConfig = require ( path . join ( __dirname , "webpack/webpack4.config.fn.js" ) ) . default ( wpAffectingOpts ) ; return extend ( baseConfig ) ; } 
function statsToManifest ( stats ) { const jsChunksByName = { } ; const cssChunksByName = { } ; const jsChunksById = { } ; const cssChunksById = { } ; let file ; for ( const chunk of stats . compilation . chunks ) { for ( let i = 0 ; i < chunk . files . length ; i ++ ) { file = chunk . files [ i ] ; if ( / \.css$ / . test ( file ) ) { cssChunksById [ chunk . id ] = file ; if ( chunk . name ) { cssChunksByName [ chunk . name ] = file ; } } else if ( / ^((?!hot-update).)*\.js$ / . test ( file ) ) { 
function writeClientBootstrapFile ( outputDir , opts ) { const outputFile = outputDir + "/entry.js" ; fs . writeFileSync ( outputFile , ` ${ JSON . stringify ( opts . logLevel ) } ${ JSON . stringify ( opts . timingLogLevel ) } ${ JSON . stringify ( opts . gaugeLogLevel ) } ` ) ; return outputFile ; } 
function errorInterceptor ( level , msg , meta ) { if ( meta instanceof Error ) { meta = { error : meta } ; } else if ( meta && meta . status && meta . response ) { meta = { error : meta } ; } if ( _ . isPlainObject ( meta ) ) { 
function normalizeError ( err ) { if ( err instanceof Error ) { return _ . pickBy ( { message : err . message , stack : err . stack , } , val => ! _ . isEmpty ( val ) ) ; } if ( err && err . status && err . response ) { 
function wrapLogger ( getLoggerForConfig , opts ) { var mainLogger = getLoggerForConfig ( 'main' , opts ) , timeLogger = getLoggerForConfig ( 'time' , opts ) , gaugeLogger = getLoggerForConfig ( 'gauge' , opts ) , classifyTime = makeTimeClassifier ( opts ) , classifyGauge = makeGaugeClassifier ( opts ) 
function makeThresholdsSieve ( options , defaults ) { if ( ! options ) options = { } ; 
function canonical_uri ( src , base_path ) { var absolute_regex = / ^\w+\:\/\/ / ; 
function merge_objs ( source , target ) { for ( var k in source ) { if ( source . hasOwnProperty ( k ) ) { target [ k ] = source [ k ] ; 
function check_chain_group_scripts_ready ( chain_group ) { var any_scripts_ready = false ; for ( var i = 0 ; i < chain_group . scripts . length ; i ++ ) { if ( chain_group . scripts [ i ] . ready && chain_group . scripts [ i ] . exec_trigger ) { any_scripts_ready = true ; chain_group . scripts [ i ] . exec_trigger ( ) ; chain_group . scripts [ i ] . exec_trigger = null ; } } return any_scripts_ready ; } 
function create_script_load_listener ( elem , registry_item , flag , onload ) { elem . onload = elem . onreadystatechange = function ( ) { if ( ( elem . readyState && elem . readyState != "complete" && elem . readyState != "loaded" ) || registry_item [ flag ] ) return ; elem . onload = elem . onreadystatechange = null ; onload ( ) ; } ; } 
function script_executed ( registry_item ) { registry_item . ready = registry_item . finished = true ; for ( var i = 0 ; i < registry_item . finished_listeners . length ; i ++ ) { registry_item . finished_listeners [ i ] ( ) ; } registry_item . ready_listeners = [ ] ; registry_item . finished_listeners = [ ] ; } 
function request_script ( chain_opts , script_obj , registry_item , onload , preload_this_script ) { 
function create_sandbox ( ) { var global_defaults = { } , can_use_preloading = real_preloading || xhr_or_cache_preloading , queue = [ ] , registry = { } , instanceAPI ; 
function execute_preloaded_script ( chain_opts , script_obj , registry_item ) { var script ; function preload_execute_finished ( ) { if ( script != null ) { 
function do_script ( chain_opts , script_obj , chain_group , preload_this_script ) { var registry_item , registry_items , ready_cb = function ( ) { script_obj . ready_cb ( script_obj , function ( ) { execute_preloaded_script ( chain_opts , script_obj , registry_item ) ; } ) ; } , finished_cb = function ( ) { script_obj . finished_cb ( script_obj , chain_group ) ; } ; script_obj . src = canonical_uri ( script_obj . src , chain_opts [ _BasePath ] ) ; script_obj . real_src = script_obj . src + 
function ( ) { registry_item . ready = true ; for ( var i = 0 ; i < registry_item . ready_listeners . length ; i ++ ) { registry_item . ready_listeners [ i ] ( ) ; } registry_item . ready_listeners = [ ] ; } 
function create_chain ( ) { var chainedAPI , chain_opts = merge_objs ( global_defaults , { } ) , chain = [ ] , exec_cursor = 0 , scripts_currently_loading = false , chain_is_corked = false , group ; 
function chain_script_ready ( script_obj , exec_trigger ) { if ( chain_opts [ _Debug ] ) log_msg ( "script preload finished: " + script_obj . real_src ) ; script_obj . ready = true ; script_obj . exec_trigger = function ( ) { if ( chain_opts [ _Debug ] ) log_msg ( "script execute start: " + script_obj . real_src ) ; exec_trigger ( ) ; } advance_exec_cursor ( ) ; 
function chain_script_executed ( script_obj , chain_group ) { if ( chain_opts [ _Debug ] ) log_msg ( "script execution finished: " + script_obj . real_src ) ; script_obj . ready = script_obj . finished = true ; script_obj . exec_trigger = null ; 
function advance_exec_cursor ( ) { if ( chain_is_corked ) return ; while ( exec_cursor < chain . length ) { if ( is_func ( chain [ exec_cursor ] ) ) { if ( chain_opts [ _Debug ] ) log_msg ( "$LAB.wait() executing: " + chain [ exec_cursor ] ) ; try { chain [ exec_cursor ++ ] ( ) ; } catch ( err ) { if ( chain_opts [ _Debug ] ) log_error ( "$LAB.wait() error caught: " , err ) ; } continue ; } else if ( ! chain [ exec_cursor ] . finished ) { if ( check_chain_group_scripts_ready ( chain [ exec_cursor ] ) ) continue ; break ; } exec_cursor ++ ; } 
function init_script_chain_group ( ) { if ( ! group || ! group . scripts ) { chain . push ( group = { scripts : [ ] , finished : true } ) ; } } 
function ( ) { if ( arguments . length > 0 ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { chain . push ( arguments [ i ] ) ; } group = chain [ chain . length - 1 ] ; } else group = false ; advance_exec_cursor ( ) ; return chainedAPI ; } 
function build ( ) { console . log ( 'Creating an optimized production build...' ) ; webpack ( config ) . run ( ( err ) => { if ( err ) { console . error ( 'Failed to create a production build. Reason:' ) ; console . error ( err . message || err ) ; process . exit ( 1 ) ; } console . log ( chalk . green ( 'Compiled successfully.' ) ) ; console . log ( ` ${ chalk . cyan ( 'dist' ) } ` ) ; console . log ( ) ; } ) ; } 
function findLogPath ( appName , fileName ) { fileName = fileName || 'log.log' ; var userData = appName ? null : utils . getUserData ( ) ; appName = appName || getAppName ( ) ; var homeDir = os . homedir ? os . homedir ( ) : process . env . HOME ; var dir ; switch ( process . platform ) { case 'darwin' : { dir = prepareDir ( homeDir , 'Library' , 'Logs' , appName ) . or ( userData ) . or ( homeDir , 'Library' , 'Application Support' , appName ) . result ; break ; } case 'win32' : { dir = prepareDir ( userData ) . or ( process . env . APPDATA , appName ) . or ( homeDir , 'AppData' , 'Roaming' , appName ) . result ; break ; } default : { dir = prepareDir ( userData ) . or ( process . env . XDG_CONFIG_HOME , appName ) . or ( homeDir , '.config' , appName ) . or ( process . env . XDG_DATA_HOME , appName ) . or ( homeDir , '.local' , 'share' , appName ) . result ; break ; } } if ( dir ) { return path . join ( dir , fileName ) ; } return false ; } 
function format ( msg , formatter , electronLog , removeStyles ) { removeStyles = removeStyles !== undefined ? removeStyles : false ; if ( typeof formatter === 'function' ) { return formatter ( msg , electronLog ) ; } var date = new Date ( msg . date || Date . now ( ) ) ; var variables = msg . variables ; var result = formatter ; for ( var i in variables ) { if ( ! variables . hasOwnProperty ( i ) ) continue ; result = result . replace ( '{' + i + '}' , variables [ i ] ) ; } result = result . replace ( '{level}' , msg . level ) . replace ( '{text}' , stringifyArray ( msg . data ) ) . replace ( '{y}' , String ( date . getFullYear ( ) ) ) . replace ( '{m}' , pad ( date . getMonth ( ) + 1 ) ) . replace ( '{d}' , pad ( date . getDate ( ) ) ) . replace ( '{h}' , pad ( date . getHours ( ) ) ) . replace ( '{i}' , pad ( date . getMinutes ( ) ) ) . replace ( '{s}' , pad ( date . getSeconds ( ) ) ) . replace ( '{ms}' , pad ( date . getMilliseconds ( ) , 3 ) ) . replace ( '{z}' , formatTimeZone ( date . getTimezoneOffset ( ) ) ) ; if ( removeStyles ) { result = result . replace ( / %c / g , '' ) ; } return result ; } 
function loadPackageName ( ) { var packageFile ; try { if ( require . main . filename ) { packageFile = find ( path . dirname ( require . main . filename ) ) ; } } catch ( e ) { packageFile = null ; } if ( ! packageFile && process . resourcesPath ) { packageFile = find ( path . join ( process . resourcesPath , 'app.asar' ) ) ; var electronModule = path . join ( 'node_modules' , 'electron' , 'package.json' ) ; if ( packageFile && packageFile . indexOf ( electronModule ) !== - 1 ) { packageFile = null ; } } if ( ! packageFile ) { packageFile = find ( process . cwd ( ) ) ; } if ( ! packageFile ) { return null ; } var content = fs . readFileSync ( packageFile , 'utf-8' ) ; var packageData = JSON . parse ( content ) ; 
function generateTypedocDocs ( typedocDocsDir ) { const publicApiConfigFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.json' ) ; const publicApiConfig = JSON . parse ( fs . readFileSync ( publicApiConfigFile , { encoding : 'utf8' } ) ) ; const files = publicApiConfig . exports . map ( exportDef => path . resolve ( __dirname , ` ${ exportDef . file } ` ) ) ; const themeDir = path . resolve ( __dirname , '../typedoc-theme' ) ; 
function generateComponent ( typedocHtmlFile , relativeTypedocHtmlFile , demoAppDocsModuleDir ) { const directory = path . dirname ( relativeTypedocHtmlFile ) ; mkdirp . sync ( path . join ( demoAppDocsModuleDir , directory ) ) ; const fileName = path . basename ( relativeTypedocHtmlFile ) ; const componentHtmlFileName = fileName . replace ( / \.html$ / , '.component.html' ) ; const componentHtmlFile = path . join ( demoAppDocsModuleDir , directory , componentHtmlFileName ) ; const typedocHtmlFileContent = fs . readFileSync ( typedocHtmlFile , { encoding : 'utf8' } ) ; const escapedHtmlFileContent = fixRouterFragments ( fixReadmeMdLinks ( escapeHtmlForAngular ( typedocHtmlFileContent ) ) ) ; fs . writeFileSync ( componentHtmlFile , escapedHtmlFileContent , { encoding : 'utf8' } ) ; const componentFileName = fileName . replace ( / \.html$ / , '.component' ) ; const componentTsFileName = componentFileName + '.ts' ; const componentTsFile = path . join ( demoAppDocsModuleDir , directory , componentTsFileName ) ; const componentName = generateComponentName ( fileName ) ; const componentTsFileContent = ` ${ componentHtmlFileName } ${ componentName } ` ; fs . writeFileSync ( componentTsFile , componentTsFileContent , { encoding : 'utf8' } ) ; 
function generateComponentName ( fileName ) { const bareName = fileName . replace ( / \.html$ / , '' ) . replace ( / [._] / g , '' ) ; return bareName . charAt ( 0 ) . toUpperCase ( ) + bareName . substr ( 1 ) + 'Component' ; } 
function generateModuleFile ( componentsMetadata , demoAppDocsModuleDir ) { const imports = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . name } ${ componentMetadata . file } ` ) . join ( '\n' ) ; const components = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . name } ` ) . join ( '\n' ) ; const routes = componentsMetadata . map ( componentMetadata => ` ${ componentMetadata . route } ${ componentMetadata . name } ` ) . join ( '\n' ) ; const moduleTsFileContents = ` ${ imports } ${ routes } ${ components } ${ components } ` ; const moduleTsFile = path . join ( demoAppDocsModuleDir , 'docs.module.ts' ) ; fs . writeFileSync ( moduleTsFile , moduleTsFileContents , { encoding : 'utf8' } ) ; } 
function generatePackageJson ( ) { const mainFile = path . resolve ( __dirname , '../package.json' ) ; const libTemplateFile = path . resolve ( __dirname , '../src/ng5-slider/package.json.template' ) ; const libFile = path . resolve ( __dirname , '../src/ng5-slider/package.json' ) ; const libTemplateConfig = JSON . parse ( fs . readFileSync ( libTemplateFile , { encoding : 'utf8' } ) ) ; const mainConfig = JSON . parse ( fs . readFileSync ( mainFile , { encoding : 'utf8' } ) ) ; let libConfig = { } ; for ( let key of libTemplateConfig . keysToCopyFromMainPackageJson ) { libConfig [ key ] = mainConfig [ key ] ; } libConfig . dependencies = { } ; for ( let dependency of libTemplateConfig . dependenciesToCopyFromMainPackageJson ) { libConfig . dependencies [ dependency ] = mainConfig . dependencies [ dependency ] ; } libConfig . peerDependencies = { } ; for ( let dependency of libTemplateConfig . dependenciesToCopyAsPeerDependenciesFromMainPackageJson ) { libConfig . peerDependencies [ dependency ] = mainConfig . dependencies [ dependency ] ; } libConfig = Object . assign ( { } , libConfig , libTemplateConfig , libConfig ) ; delete libConfig . keysToCopyFromMainPackageJson ; delete libConfig . dependenciesToCopyFromMainPackageJson ; delete libConfig . dependenciesToCopyAsPeerDependenciesFromMainPackageJson ; for ( let dependency of libTemplateConfig . dependenciesToCopyFromMainPackageJson ) { libConfig . ngPackage . whitelistedNonPeerDependencies . push ( dependency ) ; } const prettyPrintedLibConfig = JSON . stringify ( libConfig , null , 2 ) ; fs . writeFileSync ( libFile , prettyPrintedLibConfig , { encoding : 'utf8' } ) ; } 
function generatePublicApiTs ( ) { const configFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.json' ) ; const tsFile = path . resolve ( __dirname , '../src/ng5-slider/lib/public_api.ts' ) ; const config = JSON . parse ( fs . readFileSync ( configFile , { encoding : 'utf8' } ) ) ; let tsFileContent = '' ; for ( let exportDef of config . exports ) { if ( exportDef . what instanceof Array ) { const whats = exportDef . what . join ( ', ' ) ; tsFileContent += ` ${ whats } ${ exportDef . file } \n ` ; } else { tsFileContent += ` ${ exportDef . what } ${ exportDef . file } \n ` ; } } fs . writeFileSync ( tsFile , tsFileContent , { encoding : 'utf8' } ) ; } 
function readdirRecursivelySync ( dir ) { let results = [ ] ; const list = fs . readdirSync ( dir ) ; for ( let file of list ) { file = path . resolve ( dir , file ) ; const stat = fs . statSync ( file ) ; if ( stat && stat . isDirectory ( ) ) { results = results . concat ( readdirRecursivelySync ( file ) ) ; } else { results . push ( file ) ; } } return results ; } 
function copyReadmeMd ( sourceReadmeMd ) { const libReadmeFile = path . resolve ( __dirname , '../src/ng5-slider/README.md' ) ; const sourceReadme = fs . readFileSync ( sourceReadmeMd , { encoding : 'utf8' } ) ; fs . writeFileSync ( libReadmeFile , sourceReadme , { encoding : 'utf8' } ) ; } 
function generateTemplate ( templateFile , snippetsDir ) { const titleTemplateFile = templateFile . replace ( '.template.html' , '.title-template.html' ) ; const outputTemplateFile = templateFile . replace ( '.template.html' , '.html' ) ; const codeFile = templateFile . replace ( '.template.html' , '.ts' ) ; const styleFile = templateFile . replace ( '.template.html' , '.scss' ) ; const titleTemplateFileContent = fs . readFileSync ( path . resolve ( snippetsDir , titleTemplateFile ) , { encoding : 'utf8' } ) ; const templateFileContent = fs . readFileSync ( path . resolve ( snippetsDir , templateFile ) , { encoding : 'utf8' } ) ; const templateTabHtml = tabHtml ( path . basename ( outputTemplateFile ) , templateFileContent , 'html' ) ; let codeFileContent = fs . readFileSync ( path . resolve ( snippetsDir , codeFile ) , { encoding : 'utf8' } ) ; 
function highlight ( code , lang ) { return prism . highlight ( code . trim ( ) , prism . languages [ lang ] ) ; } 
function tabHtml ( tabTitle , codeContent , codeLang ) { return ` ${ escape ( tabTitle ) } ${ codeLang } ${ codeLang } ${ escapeBraces ( highlight ( codeContent , codeLang ) ) } ` ; } 
function renderRule ( rule ) { const mark = ` ${ rule . recommended ? "⭐️" : " } {r u le .fix a ble ? " ️ : ""}` const link = ` ${ rule . id } ${ rule . name } ` const description = rule . description || "(no description)" return ` ${ link } ${ description } ${ mark } ` } 
function renderDeprecatedRule ( rule ) { const link = ` ${ rule . id } ${ rule . name } ` const replacedBy = rule . replacedBy . map ( name => ` ${ name } ${ name } ` ) . join ( " and " ) return ` ${ link } ${ replacedBy || "(nothing)" } ` } 
function parseOptions ( context ) { const raw = context . options [ 0 ] || { } const filePath = context . getFilename ( ) const version = getConfiguredNodeVersion ( raw . version , filePath ) const ignores = new Set ( raw . ignores || [ ] ) return Object . freeze ( { version , ignores } ) } 
function nomalizeScope ( initialScope , node ) { let scope = getInnermostScope ( initialScope , node ) while ( scope && scope . block === node ) { scope = scope . upper } return scope } 
function merge ( x , y ) { for ( const key of Object . keys ( y ) ) { if ( typeof x [ key ] === "function" ) { if ( x [ key ] . _handlers == null ) { const fs = [ x [ key ] , y [ key ] ] x [ key ] = dispatch . bind ( null , fs ) x [ key ] . _handlers = fs } else { x [ key ] . _handlers . push ( y [ key ] ) } } else { x [ key ] = y [ key ] } } return x } 
function defineVisitor ( context , options ) { const testInfoPrototype = { get isStrict ( ) { return nomalizeScope ( context . getScope ( ) , this . node ) . isStrict } , } function isNotSupportingVersion ( aCase ) { return ( ! aCase . supported || options . version . intersects ( getSemverRange ( ` ${ aCase . supported } ` ) ) ) } function isNotSupportingOn ( node ) { return aCase => isNotSupportingVersion ( aCase ) && ( ! aCase . test || aCase . test ( { node , __proto__ : testInfoPrototype } ) ) } return ( keywords 
function isNotSupportingVersion ( aCase ) { return ( ! aCase . supported || options . version . intersects ( getSemverRange ( ` ${ aCase . supported } ` ) ) ) } 
function isNotSupportingOn ( node ) { return aCase => isNotSupportingVersion ( aCase ) && ( ! aCase . test || aCase . test ( { node , __proto__ : testInfoPrototype } ) ) } 
function readPackageJson ( dir ) { const filePath = path . join ( dir , "package.json" ) try { const text = fs . readFileSync ( filePath , "utf8" ) const data = JSON . parse ( text ) if ( typeof data === "object" && data !== null ) { data . filePath = filePath return data } } catch ( _err ) { 
function get ( option ) { if ( option && option . allowModules && Array . isArray ( option . allowModules ) ) { return option . allowModules . map ( String ) } return null } 
function getStaticPropertyName ( node ) { let prop = null switch ( node && node . type ) { case "Property" : case "MethodDefinition" : prop = node . key break case "MemberExpression" : prop = node . property break 
function getTopAssignment ( leafNode ) { let node = leafNode 
function getModuleExportsNodes ( scope ) { const variable = scope . set . get ( "module" ) if ( variable == null ) { return [ ] } return variable . references . map ( reference => reference . identifier . parent ) . filter ( node => node . type === "MemberExpression" && getStaticPropertyName ( node ) === "exports" ) } 
function getExportsNodes ( scope ) { const variable = scope . set . get ( "exports" ) if ( variable == null ) { return [ ] } return variable . references . map ( reference => reference . identifier ) } 
function getLocation ( node ) { const token = sourceCode . getTokenAfter ( node ) return { start : node . loc . start , end : token . loc . end , } } 
function enforceModuleExports ( ) { const globalScope = context . getScope ( ) const exportsNodes = getExportsNodes ( globalScope ) const assignList = batchAssignAllowed ? createAssignmentList ( getModuleExportsNodes ( globalScope ) ) : [ ] for ( const node of exportsNodes ) { 
function enforceExports ( ) { const globalScope = context . getScope ( ) const exportsNodes = getExportsNodes ( globalScope ) const moduleExportsNodes = getModuleExportsNodes ( globalScope ) const assignList = batchAssignAllowed ? createAssignmentList ( exportsNodes ) : [ ] const batchAssignList = [ ] for ( const node of moduleExportsNodes ) { 
function filterNeverIgnoredFiles ( p ) { const basedir = path . dirname ( p . filePath ) const mainFilePath = typeof p . main === "string" ? path . join ( basedir , p . main ) : null return filePath => path . join ( basedir , filePath ) !== mainFilePath && filePath !== "package.json" && ! NEVER_IGNORED . test ( path . relative ( basedir , filePath ) ) } 
function parseWhiteList ( files ) { if ( ! files || ! Array . isArray ( files ) ) { return null } const ig = ignore ( ) const igN = ignore ( ) let hasN = false for ( const file of files ) { if ( typeof file === "string" && file ) { const body = file . replace ( SLASH_AT_BEGIN_AND_END , "" ) if ( file . startsWith ( "!" ) ) { igN . add ( ` ${ body } ` ) igN . add ( ` ${ body } ` ) hasN = true } else { ig . add ( ` ${ body } ` ) ig . add ( ` ${ body } ` ) } } } return hasN ? or ( ig . createFilter ( ) , not ( igN . createFilter ( ) ) ) : ig . createFilter ( ) } 
function parseNpmignore ( basedir , filesFieldExists ) { let filePath = path . join ( basedir , ".npmignore" ) if ( ! exists ( filePath ) ) { if ( filesFieldExists ) { return null } filePath = path . join ( basedir , ".gitignore" ) if ( ! exists ( filePath ) ) { return null } } const ig = ignore ( ) ig . add ( fs . readFileSync ( filePath , "utf8" ) ) return not ( ig . createFilter ( ) ) } 
function normalizeValue ( x ) { if ( Array . isArray ( x ) ) { return x } return Object . keys ( x ) . map ( pattern => ( { include : [ pattern ] , exclude : [ ] , replace : x [ pattern ] , } ) ) } 
function createMatch ( includePatterns , excludePatterns ) { const include = includePatterns . map ( pattern => new Minimatch ( pattern ) ) const exclude = excludePatterns . map ( pattern => new Minimatch ( pattern ) ) return filePath => include . some ( m => m . match ( filePath ) ) && ! exclude . some ( m => m . match ( filePath ) ) } 
function combine ( converters ) { return filePath => { for ( const converter of converters ) { if ( converter . match ( filePath ) ) { return converter . convert ( filePath ) } } return filePath } } 
function parse ( option ) { if ( ! option || ! option . convertPath || typeof option . convertPath !== "object" ) { return null } const converters = [ ] for ( const pattern of normalizeValue ( option . convertPath ) ) { const include = toStringArray ( pattern . include ) const exclude = toStringArray ( pattern . exclude ) const fromRegexp = new RegExp ( String ( pattern . replace [ 0 ] ) ) 
function toName ( type , path ) { const baseName = path . join ( "." ) return type === ReferenceTracker . CALL ? ` ${ baseName } ` : type === ReferenceTracker . CONSTRUCT ? ` ${ baseName } ` : baseName } 
function reportItem ( node , name , info ) { context . report ( { node , loc : node . loc , message : "{{name}} was deprecated since v{{version}}{{replace}}." , data : { name , version : info . since , replace : toReplaceMessage ( info . replacedBy ) , } , } ) } 
function renderFooter ( rule ) { const docsPath = path . dirname ( path . resolve ( docsRoot , ` ${ rule . name } ` ) ) const rulePath = path . relative ( docsPath , path . join ( ruleRoot , ` ${ rule . name } ` ) ) . replace ( / \\ / gu , "/" ) const testPath = path . relative ( docsPath , path . join ( testRoot , ` ${ rule . name } ` ) ) . replace ( / \\ / gu , "/" ) return ` \n \n n- [ ul ePath})\ n [ es tPath})` } 
function get ( option ) { if ( option && option . tryExtensions && Array . isArray ( option . tryExtensions ) ) { return option . tryExtensions . map ( String ) } return null } 
function getDefaultVersion ( filename ) { const info = getPackageJson ( filename ) const nodeVersion = info && info . engines && info . engines . node return semver . validRange ( nodeVersion ) || DEFAULT_VERSION } 
function getIgnoresEnum ( ) { return Object . keys ( OPTIONS . reduce ( ( retv , key ) => { for ( const alias of FEATURES [ key ] . alias ) { retv [ alias ] = true } retv [ key ] = true return retv } , Object . create ( null ) ) ) } 
function isIgnored ( key , ignores ) { return ( ignores . indexOf ( key ) !== - 1 || FEATURES [ key ] . alias . some ( alias => ignores . indexOf ( alias ) !== - 1 ) ) } 
function parseOptions ( options , defaultVersion ) { let version = null let range = null let ignores = [ ] if ( typeof options === "number" ) { version = VERSION_MAP . get ( options ) } else if ( typeof options === "string" ) { version = options } else if ( typeof options === "object" ) { version = typeof options . version === "number" ? VERSION_MAP . get ( options . version ) : options . version ignores = options . ignores || [ ] } range = semver . validRange ( version ? ` ${ version } ` : defaultVersion ) if ( ! version ) { version = defaultVersion } return Object . freeze ( { version , features : Object . freeze ( OPTIONS . reduce ( ( retv , key ) => { const feature = FEATURES [ key ] if ( isIgnored ( key , ignores ) ) { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : true , supportedInStrict : true , } ) } else if ( typeof feature . node === "string" ) { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : ! semver . intersects ( range , ` ${ feature . node } ` ) , supportedInStrict : ! semver . intersects ( range , ` ${ feature . node } ` ) , } ) } else { retv [ key ] = Object . freeze ( { name : feature . name , singular : Boolean ( feature . singular ) , supported : feature . node != null && feature . node . sloppy != null && ! semver . intersects ( range , ` ${ feature . node . sloppy } ` ) , supportedInStrict : feature . node != null && feature . node . strict != null && ! semver . intersects ( range , ` ${ feature . node . strict } ` ) , } ) } return retv } , Object . create ( null ) ) ) , } ) } 
function hasUnicodeCodePointEscape ( raw ) { let match = null UNICODE_ESC . lastIndex = 0 while ( ( match = UNICODE_ESC . exec ( raw ) ) != null ) { if ( match [ 1 ] . length % 2 === 1 ) { return true } } return false } 
function hasPattern ( s , pattern ) { const m = pattern . exec ( s ) return m != null && ( m [ 1 ] || "" ) . length % 2 === 0 } 
function hasTrailingCommaForFunction ( node ) { const length = node . params . length return ( length >= 1 && sourceCode . getTokenAfter ( node . params [ length - 1 ] ) . value === "," ) } 
function extendsNull ( node ) { return ( node . superClass != null && node . superClass . type === "Literal" && node . superClass . value === null ) } 
function report ( node , key ) { const version = supportInfo . version const feature = supportInfo . features [ key ] if ( feature . supported ) { return } if ( ! feature . supportedInStrict ) { context . report ( { node , message : "{{feature}} {{be}} not supported yet on Node {{version}}." , data : { feature : feature . name , be : feature . singular ? "is" : "are" , version , } , } ) } else if ( ! nomalizeScope ( context . getScope ( ) , node ) . isStrict ) { context . report ( { node , message : "{{feature}} {{be}} not supported yet on Node {{version}}." , data : { feature : ` ${ feature . name } ` , be : feature . singular ? "is" : "are" , version , } , } ) } } 
function validateRegExp ( pattern , flags , node ) { if ( typeof pattern === "string" ) { if ( hasPattern ( pattern , REGEXP_NAMED_GROUP ) ) { report ( node , "regexpNamedCaptureGroups" ) } if ( hasPattern ( pattern , REGEXP_LOOKBEHIND ) ) { report ( node , "regexpLookbehind" ) } if ( hasPattern ( pattern , REGEXP_UNICODE_PROPERTY ) ) { report ( node , "regexpUnicodeProperties" ) } } if ( typeof flags === "string" ) { if ( flags . indexOf ( "y" ) !== - 1 ) { report ( node , "regexpY" ) } if ( flags . indexOf ( "u" ) !== - 1 ) { report ( node , "regexpU" ) } if ( flags . indexOf ( "s" ) !== - 1 ) { report ( node , "regexpS" ) } } } 
function validateRegExpLiteral ( node ) { validateRegExp ( node . regex . pattern , node . regex . flags , node ) } 
function validateRegExpString ( node ) { const patternNode = node . arguments [ 0 ] const flagsNode = node . arguments [ 1 ] const pattern = patternNode && patternNode . type === "Literal" && typeof patternNode . value === "string" ? patternNode . value : null const flags = flagsNode && flagsNode . type === "Literal" && typeof flagsNode . value === "string" ? flagsNode . value : null validateRegExp ( pattern , flags , node ) } 
function getFilePath ( isModule , id , options ) { try { return resolve . sync ( id , options ) } catch ( _err ) { if ( isModule ) { return null } return path . resolve ( options . basedir , id ) } } 
function getModuleName ( nameOrPath ) { let end = nameOrPath . indexOf ( "/" ) if ( end !== - 1 && nameOrPath [ 0 ] === "@" ) { end = nameOrPath . indexOf ( "/" , 1 + end ) } return end === - 1 ? nameOrPath : nameOrPath . slice ( 0 , end ) } 
function isBinFile ( filePath , binField , basedir ) { if ( ! binField ) { return false } if ( typeof binField === "string" ) { return filePath === path . resolve ( basedir , binField ) } return Object . keys ( binField ) . some ( key => filePath === path . resolve ( basedir , binField [ key ] ) ) } 
function getShebangInfo ( sourceCode ) { const m = SHEBANG_PATTERN . exec ( sourceCode . text ) return { bom : sourceCode . hasBOM , cr : Boolean ( m && m [ 2 ] ) , length : ( m && m [ 0 ] . length ) || 0 , shebang : ( m && m [ 1 ] && ` ${ m [ 1 ] } \n ` ) || "" , } } 
function getExistingExtensions ( filePath ) { const basename = path . basename ( filePath , path . extname ( filePath ) ) try { return fs . readdirSync ( path . dirname ( filePath ) ) . filter ( filename => path . basename ( filename , path . extname ( filename ) ) === basename ) . map ( filename => path . extname ( filename ) ) } catch ( _error ) { return [ ] } } 
function forwardCurrentToHead ( analyzer , node ) { const codePath = analyzer . codePath const state = CodePath . getState ( codePath ) const currentSegments = state . currentSegments const headSegments = state . headSegments const end = Math . max ( currentSegments . length , headSegments . length ) let i = 0 let currentSegment = null let headSegment = null 
function isProcessExit ( node ) { return ( node . type === "CallExpression" && node . callee . type === "MemberExpression" && node . callee . computed === false && node . callee . object . type === "Identifier" && node . callee . object . name === "process" && node . callee . property . type === "Identifier" && node . callee . property . name === "exit" ) } 
function overrideLeaveNode ( node ) { if ( isProcessExit ( node ) ) { this . currentNode = node forwardCurrentToHead ( this , node ) CodePath . getState ( this . codePath ) . makeThrow ( ) this . original . leaveNode ( node ) this . currentNode = null } else { originalLeaveNode . call ( this , node ) } } 
function getEnginesNode ( filename ) { const info = getPackageJson ( filename ) return getSemverRange ( info && info . engines && info . engines . node ) } 
function existsCaseSensitive ( filePath ) { let dirPath = filePath while ( dirPath !== "" && ! ROOT . test ( dirPath ) ) { const fileName = path . basename ( dirPath ) dirPath = path . dirname ( dirPath ) if ( fs . readdirSync ( dirPath ) . indexOf ( fileName ) === - 1 ) { return false } } return true } 
function get ( option ) { if ( option && option . resolvePaths && Array . isArray ( option . resolvePaths ) ) { return option . resolvePaths . map ( String ) } return null } 
function checkFile ( path ) { const formatter = path . match ( / \.md$ / ) ? prettierFormat : clangFormat ; const source = fs . readFileSync ( path , 'utf8' ) ; const formatted = formatter ( path , source ) ; if ( source !== formatted ) { return formatted ; } return null ; } 
function Listener ( component , ... path ) { var assign ; this . component = component ; ( assign = path , this . key = assign [ 0 ] ) ; this . path = path . slice ( 1 , path . length ) ; this . depth = 0 ; this . attached = true ; this . processValue = value => value ; this . changeListener = ( ) => { } ; this . addedListeners = [ ] ; } 
function ( i ) { var nn = nodes [ i ] ; 
function Structure ( query , props , children , depth ) { if ( props === void 0 ) props = { } ; if ( depth === void 0 ) depth = 0 ; this . query = query ; this . props = Boolean !== props ? props : { } ; if ( isComponent ( query ) || query instanceof Component ) { this . $compChildren = flatten ( children || [ ] ) . map ( filterNode ) ; this . children = [ ] ; } else { this . children = flatten ( children || [ ] ) . map ( filterNode ) ; this . $compChildren = [ ] ; } this . html = null ; this . $attrListeners = [ ] ; this . $styleListeners = [ ] ; this . $pointer = null ; this . $component = null ; this . $listener = null ; this . $redirect = null ; this . $destroyed = false ; this . $isSvg = query === 'svg' ; this . $depth = depth ; } 
function serializeAttrs ( attributes , opts ) { if ( ! attributes ) { return ; } let output = '' ; let value ; Object . keys ( attributes ) . forEach ( key => { value = attributes [ key ] ; if ( output ) { output += ' ' ; } let isBoolAttr = value && typeof value === 'boolean' ; if ( isBoolAttr ) { output += key ; } else { output += key + '="' + ( opts . decodeEntities ? entities . encodeXML ( value ) : value ) + '"' ; } } ) ; return output ; } 
function serializeTag ( elem , opts ) { 
function serializeDom ( dom , opts ) { if ( ! Array . isArray ( dom ) ) { dom = [ dom ] ; } opts = opts || { } ; let output = '' ; for ( let i = 0 , len = dom . length ; i < len ; i ++ ) { let elem = dom [ i ] ; if ( elem . removed ) { 
function initRefs ( ) { this . $refs = { } ; let refInfo = this . props && this . props [ REF_DATA_ATTR ] ; let pageInstance = this . $page || this ; let refComponents = pageInstance . __refComponents || { } ; pageInstance . __refComponents = refComponents ; if ( refInfo ) { if ( refInfo . charAt ( 0 ) === '[' ) { refComponents [ refInfo ] || ( refComponents [ refInfo ] = [ ] ) ; refComponents [ refInfo ] . push ( this ) ; } else { refComponents [ refInfo ] = this ; } } let refs = this . $rawRefData ; if ( typeof refs === 'function' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; Object . keys ( refs ) . forEach ( id => { result [ id ] = { get ( ) { let value = refs [ id ] ; let isSelectAll = Array . isArray ( value ) ; isSelectAll && ( value = value [ 0 ] ) ; let key = isSelectAll ? ` ${ value } ` : value ; let result = refComponents [ key ] ; isSelectAll && ! result && ( result = [ ] ) ; return result ; } , enumerable : true } ; } ) ; Object . defineProperties ( this . $refs , result ) ; } 
function getRequireExpressionModuleId ( node , t ) { if ( t . isCallExpression ( node ) ) { let { arguments : args , callee } = node ; if ( t . isIdentifier ( callee ) && callee . name === 'require' && args . length === 1 && t . isLiteral ( args [ 0 ] ) ) { let id = args [ 0 ] . value ; return id ; } } } 
function removeVariableDeclaration ( t , bindVar , removeOpts ) { let refPaths = bindVar . referencePaths || [ ] ; let removed ; 
function getRequiredModulePath ( valuePath , moduleName , t , removeRequireDeclaration = false ) { let bindVar = valuePath . scope . bindings [ moduleName ] ; if ( ! bindVar ) { throw valuePath . buildCodeFrameError ( ` ${ moduleName } ` ) ; } let declareNodePath = bindVar . path ; let parentStatementPath = bindVar . path . getStatementParent ( ) ; 
function transformFilterInAttribute ( element , tplOpts , options ) { let attrs = element . attribs ; let filterAttrs = element . _hasFilterAttrs ; if ( ! filterAttrs || ! filterAttrs . length ) { return ; } let { logger , file } = tplOpts ; let { filters } = options ; filterAttrs . forEach ( k => { let value = attrs [ k ] ; attrs [ k ] = updateFilterCall ( filters , logger , file , value ) ; } ) ; } 
function processFile ( file , processor , buildManager ) { let { compileContext , logger } = buildManager ; let { handler , options : opts , rext } = processor ; logger . debug ( ` ${ file . path } ${ processor . name } ` , opts ) ; let result = handler ( file , Object . assign ( { config : opts } , compileContext ) ) ; if ( ! result ) { return ; } rext && ( file . rext = rext ) ; if ( isPromise ( result ) ) { buildManager . addAsyncTask ( file , result ) ; return ; } if ( result . isSfcComponent ) { compileComponent ( result , file , buildManager ) ; result = { content : file . content } ; } buildManager . updateFileCompileResult ( file , result ) ; } 
function compile ( file , buildManager ) { let { logger , rules } = buildManager ; let processors = findMatchProcessor ( file , rules , buildManager ) ; logger . debug ( 'compile file:' , file . path , processors . length ) ; file . allowRelease = true ; 
function getCustomComponentTags ( config ) { let { usingComponents } = config || { } ; if ( ! usingComponents ) { return ; } return Object . keys ( usingComponents ) . map ( k => toHyphen ( k ) ) ; } 
function getImportFilterModules ( usedFilters , scriptFile , buildManager ) { if ( ! usedFilters ) { return ; } let filterModules = [ ] ; let { file : filterFile , filterNames : definedFilters } = scriptFile . filters || { } ; let hasFilterUsed = definedFilters && usedFilters . some ( item => { if ( definedFilters . includes ( item ) ) { return true ; } return false ; } ) ; if ( ! hasFilterUsed ) { return filterModules ; } if ( filterFile ) { let src = relative ( filterFile . path , scriptFile . dirname ) ; if ( src . charAt ( 0 ) !== '.' ) { src = './' + src ; } filterModules . push ( { src , filters : definedFilters } ) ; } else { filterModules . push ( { filters : definedFilters } ) ; } return filterModules ; } 
function doRequest ( reqOpts ) { reqOpts = Object . assign ( { } , reqOpts ) ; if ( currRequestNum >= requestMaxNum ) { return new Promise ( ( resolve , reject ) => { waitingQueues . push ( { options : reqOpts , resolve , reject } ) ; } ) ; } currRequestNum ++ ; let rawComplete = reqOpts . complete ; reqOpts . complete = function ( ... args ) { currRequestNum -- ; rawComplete && rawComplete ( ... args ) ; if ( ! waitingQueues . length ) { return ; } let processReqInfo = waitingQueues . shift ( ) ; doRequest ( processReqInfo . options ) . then ( res => processReqInfo . resolve ( res ) , err => processReqInfo . reject ( err ) ) ; } ; return rawRequest ( reqOpts ) ; } 
function getIncludeTemplateElement ( tplFile ) { let ast = tplFile . ast ; if ( ! ast ) { ast = tplFile . ast = parseDom ( tplFile . content . toString ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i ++ ) { let node = children [ i ] ; if ( node . type === 'tag' && node . name === 'template' ) { return node ; } } } 
function normalizeProps ( props ) { Object . keys ( props ) . forEach ( k => { let propValue = props [ k ] ; if ( propValue && propValue . default !== undefined ) { propValue . value = propValue . default ; delete propValue . default ; } } ) ; return props ; } 
function processAppSpecifiedMediaRule ( allAppTypes , appType , rule ) { let result = matchAppMediaParams ( allAppTypes , appType , rule . params ) ; if ( ! result ) { return ; } let { removed , params } = result ; params && ( params = params . trim ( ) ) ; if ( removed ) { 
function removeUnUseDecl ( decl , toRemovePropName ) { let nodes = decl . parent . nodes ; let currIdx = nodes . indexOf ( decl ) ; for ( let i = currIdx - 1 ; i >= 0 ; i -- ) { let item = nodes [ i ] ; if ( item . type === 'decl' && item . prop === toRemovePropName ) { item . remove ( ) ; } } } 
function processAppSpecifiedDeclaration ( allAppTypes , appType , decl ) { let { prop , parent } = decl ; let result ; if ( ( result = SPECIFIED_APP_PROP_DECL_REGEXP . exec ( prop ) ) ) { let propApp = result [ 1 ] ; let isMatchApp = appType === propApp ; if ( allAppTypes . includes ( propApp ) && ! isMatchApp ) { 
function doMixin ( target , source , k , opts ) { let { mixinAttrName = MIXIN_ATTR_NAME , lifecycleHookMap , mixinStrategy } = opts ; if ( k === mixinAttrName ) { return ; } let mixinHandler = mixinStrategy && mixinStrategy [ k ] ; if ( mixinHandler ) { target [ k ] = mixinHandler ( target [ k ] , source [ k ] ) ; } else if ( lifecycleHookMap [ k ] ) { let child = target [ k ] ; let parent = source [ k ] ; if ( ! Array . isArray ( child ) ) { child = child ? [ child ] : [ ] ; } if ( ! Array . isArray ( parent ) ) { parent = parent ? [ parent ] : [ ] ; } child . unshift . apply ( child , parent ) ; target [ k ] = child ; } else if ( ! target . hasOwnProperty ( k ) ) { target [ k ] = source [ k ] ; } } 
function flattenMixins ( mixins , target , opts ) { mixins . forEach ( item => { if ( typeof item === 'function' ) { item = item ( true , opts ) ; 
function addBuiltinPlugin ( pluginName , appType , plugins , insertAtTop ) { let pluginInfo = BUILTIN_PLUGINS [ pluginName ] ; if ( typeof pluginInfo === 'object' ) { pluginInfo = pluginInfo [ appType ] || pluginInfo . default ; } pluginInfo = normalizeViewPlugins ( [ pluginInfo ] , appType ) [ 0 ] ; let plugin = Array . isArray ( pluginInfo ) ? pluginInfo [ 0 ] : pluginInfo ; let hasBuiltinPlugin = plugins . some ( item => ( plugin === ( Array . isArray ( item ) ? item [ 0 ] : item ) ) ) ; if ( ! hasBuiltinPlugin ) { plugins [ insertAtTop ? 'unshift' : 'push' ] ( pluginInfo ) ; } } 
function normalizeViewPlugins ( plugins , appType ) { return plugins . map ( pluginInfo => { let pluginItem = pluginInfo ; let pluginOptions ; if ( Array . isArray ( pluginInfo ) ) { pluginItem = pluginInfo [ 0 ] ; pluginOptions = pluginInfo [ 1 ] ; } if ( typeof pluginItem === 'string' ) { let pluginPath = BUILTIN_PLUGINS [ pluginItem ] ; if ( typeof pluginPath === 'function' ) { pluginPath = pluginPath ( appType ) ; } else if ( pluginPath && typeof pluginPath === 'object' ) { pluginPath = pluginPath [ appType ] || pluginPath . default ; } if ( pluginPath && Array . isArray ( pluginPath ) ) { pluginOptions = pluginPath [ 1 ] ; pluginPath = pluginPath [ 0 ] ; } pluginPath && ( pluginItem = pluginPath ) ; } if ( typeof pluginItem === 'string' ) { pluginItem = require ( pluginItem ) ; } return pluginOptions ? [ pluginItem , pluginOptions ] : pluginItem ; } ) ; } 
function handleOnTag ( file , tagName , replaceTagName ) { let tags = file . tags ; tags || ( tags = file . tags = { } ) ; if ( replaceTagName && tags . hasOwnProperty ( replaceTagName ) ) { delete tags [ replaceTagName ] ; } tags [ tagName ] = true ; } 
function handleOnFilter ( file , filterName ) { let usedFilters = file . filters ; usedFilters || ( usedFilters = file . filters = [ ] ) ; if ( ! usedFilters . includes ( filterName ) ) { usedFilters . push ( filterName ) ; } } 
function initViewTransformOptions ( file , processOpts , buildManager , isNativeView ) { let plugins = processOpts . plugins ; let { appType , componentConf , buildConf } = buildManager ; if ( isNativeView ) { return Object . assign ( { } , processOpts , { plugins : normalizeViewPlugins ( plugins , appType ) } ) ; } let templateConf = ( componentConf && componentConf . template ) || { } ; if ( ! plugins || ! plugins . length ) { plugins = [ 'syntax' ] ; if ( templateConf . transformTags ) { plugins . push ( 'tagTransform' ) ; } 
function navigateTo ( options ) { let { url , params } = options ; let queryIdx = url . indexOf ( '?' ) ; if ( queryIdx !== - 1 ) { let query = url . substr ( queryIdx + 1 ) ; url = url . substring ( 0 , queryIdx ) ; if ( query ) { query = parseQuery ( query ) ; params = Object . assign ( { } , query , params ) ; } } if ( url . charAt ( 0 ) === '/' ) { let urlParts = url . split ( '/' ) ; urlParts . pop ( ) ; 
function compile ( file , options ) { let config = options . config || { } ; let presets = config . presets || [ ] ; let tsPreset = '@babel/preset-typescript' ; if ( ! presets . includes ( tsPreset ) ) { config . presets = [ tsPreset ] . concat ( presets ) ; options . config = config ; } return parserHelper . compile ( file , options , 7 ) ; } 
function getCodeTraverseVisitors ( t , initConfig , opts ) { let { isPage , isComponent , isBehavior , enableMixinSupport , filterOptions } = opts ; let hasComponents = isPage || isComponent ; return { ObjectProperty ( path ) { let prop = path . node ; let key = prop . key ; let keyName = key && key . name ; if ( ! isBehavior && keyName === 'config' ) { 
function createInitCallArgs ( declarationPath , config , opts , t ) { let { isPage , isComponent , isApp , getInitOptions } = opts ; let callArgs = [ declarationPath . node ] ; let initOptions ; if ( opts . tplRefs ) { initOptions = { refs : opts . tplRefs } ; } let extraInitOpts = getInitOptions && getInitOptions ( config , { isPage , isComponent , isApp } ) ; if ( extraInitOpts ) { initOptions || ( initOptions = { } ) ; Object . assign ( initOptions , extraInitOpts ) ; } if ( initOptions ) { 
function transformMiniProgram ( t , path , declarationPath , config , opts ) { if ( t . isObjectExpression ( declarationPath ) ) { 
function getTransformOptions ( options , state ) { let transformOpts = Object . assign ( { } , options , state . opts ) ; transformOpts . baseId = options . extensionName ? getFrameworkExtendId ( transformOpts . appType , options . extensionName , true ) : getBaseId ( transformOpts . appType , transformOpts . baseName ) ; return transformOpts ; } 
function transformEventAttr ( attrs , name , tplOpts , opts , element ) { let value = attrs [ name ] ; let eventAttrName = name . replace ( EVENT_REGEXP , '' ) ; let [ eventType , ... eventModifiers ] = eventAttrName . split ( '.' ) ; let { logger , file } = tplOpts ; if ( eventModifiers . length ) { logger . warn ( ` ${ file . path } \` ${ name } \` ` , ` ${ eventModifiers . join ( '.' ) } ` ) ; } delete attrs [ name ] ; 
function removeArrayIndexAccessPath ( paths , requiredMinLen ) { let result = [ ] ; 
function getPageInfo ( pagePath , prefix ) { let parts = pagePath . split ( '/' ) ; let componentName = parts . pop ( ) ; let pageName = parts . join ( '/' ) ; prefix && ( pageName = ` ${ prefix } ${ pageName } ` ) ; return { pageName , componentName } ; } 
function normalizePages ( result , pages , prefix ) { let entryPageName ; pages . forEach ( ( item , idx ) => { let filter ; if ( typeof item === 'object' ) { let { path , filter : pageFilter } = item ; item = path ; filter = pageFilter ; } let { pageName , componentName } = getPageInfo ( item , prefix ) ; let pageInfo = { component : componentName } ; filter && ( pageInfo . filter = filter ) ; result [ pageName ] = pageInfo ; if ( idx === 0 ) { entryPageName = pageName ; } } ) ; return entryPageName ; } 
function normalizeRouteInfo ( pages , subPackages ) { let result = { } ; let entryPageName = normalizePages ( result , pages ) ; subPackages && subPackages . forEach ( item => { let { root , pages : subPages } = item ; normalizePages ( result , subPages , root ) ; } ) ; return { entry : entryPageName , pages : result } ; } 
function normalizeDisplayPages ( pages ) { if ( ! pages ) { return ; } let result = { } ; Object . keys ( pages ) . forEach ( k => { let item = pages [ k ] ; let { pageName } = getPageInfo ( k ) ; result [ pageName ] = item ; } ) ; return result ; } 
function addDisplayPageConfig ( pages , sourceDir , configFile ) { let path = relative ( configFile . fullPath , sourceDir ) ; let { pageName } = getPageInfo ( path ) ; let currPageDisplayInfo = pages [ pageName ] ; let pageConfig = JSON . parse ( configFile . content ) ; let result = { } ; 
function normalizeWindowConfig ( windowConfig ) { if ( ! windowConfig ) { return ; } let result = { } ; 
function addFeatureItem ( logger , existed , name , params ) { if ( ! existed [ name ] ) { existed [ name ] = true ; let feature = { name } ; params && ( feature . params = params ) ; return feature ; } logger . debug ( 'duplicated feature declaration' , name ) ; return false ; } 
function normalizeFeatureItem ( item , existed , result , logger ) { let addItem ; if ( typeof item === 'string' ) { addItem = addFeatureItem ( logger , existed , item ) ; } else if ( Array . isArray ( item ) ) { let [ name , params ] = item ; addItem = addFeatureItem ( logger , existed , name , params ) ; } else if ( item && typeof item === 'object' ) { let { name , params } = item ; addItem = addFeatureItem ( logger , existed , name , params ) ; } if ( addItem ) { result . push ( addItem ) ; } } 
function getUsedAPIFeatures ( features , options ) { let { logger , getAllUsedAPIFeatures } = options ; let result = [ ] ; let existed = { } ; features && features . forEach ( item => normalizeFeatureItem ( item , existed , result , logger ) ) ; let usedFeatures = getAllUsedAPIFeatures ( ) ; usedFeatures && usedFeatures . forEach ( item => { 
function normalizeDebugConfig ( info ) { if ( info . hasOwnProperty ( 'debug' ) ) { let debug = info . debug ; delete info . debug ; let value = debug ? 'debug' : 'off' ; let config = info . config ; if ( ! config ) { info . config = { logLevel : value } ; } else if ( ! config . logLevel ) { config . logLevel = value ; } } } 
function compile ( file , options ) { if ( ! file . compileReady && ! file . owner . processed ) { return { content : file . content } ; } let { getAllPageConfigFiles , sourceDir , designWidth } = options ; let obj = JSON . parse ( file . content . toString ( ) ) ; 
function generateSFC ( file , options ) { let { subFiles } = file ; if ( ! subFiles || ! subFiles . length ) { subFiles = [ file ] ; } let result = '' ; let componentConfig = file . isNativeComponent ? file . importComponents : getComponentConfig ( subFiles ) ; subFiles . forEach ( ( item , idx ) => { if ( item . isScript ) { result += wrapContent ( 'script' , item ) ; } else if ( item . isStyle ) { result += wrapContent ( 'style' , item ) ; } else if ( item . isTpl ) { result += wrapContent ( 'template' , item ) ; result = addImportComponents ( result , componentConfig ) ; } } ) ; return { content : result } ; } 
function normalizeQuickAppPage ( pageInfo ) { pageInfo = normalizePage ( pageInfo ) ; let { data , dataAccessType } = pageInfo ; if ( data && ! pageInfo [ dataAccessType ] ) { pageInfo [ dataAccessType ] = data ; delete pageInfo . data ; } 
function getImportTemplateElement ( tplFile , name ) { if ( ! name ) { return ; } let ast = tplFile . ast ; if ( ! ast ) { ast = tplFile . ast = parseDom ( tplFile . content . toString ( ) ) ; } let children = ast . children ; for ( let i = 0 , len = children . length ; i < len ; i ++ ) { let node = children [ i ] ; if ( node . type === 'tag' && node . name === 'template' ) { let { attribs : attrs } = node ; if ( attrs && attrs . name === name ) { return node ; } } } } 
function findImportElement ( node ) { let parent = node . parent ; if ( ! parent ) { return ; } let children = parent . children ; let found ; children . some ( item => { if ( item . type === 'tag' && item . name === 'import' ) { found = item ; return true ; } return false ; } ) ; if ( found ) { return found ; } return findImportElement ( parent ) ; } 
function parseTplDataInfo ( value ) { value = value . substring ( 1 , value . length - 1 ) ; let items = value . split ( ',' ) ; let dataObjAttrs = { } ; items . forEach ( item => { let colonIdx = item . indexOf ( ':' ) ; if ( colonIdx !== - 1 ) { let key = item . substring ( 0 , colonIdx ) . trim ( ) ; let value = item . substr ( colonIdx + 1 ) . trim ( ) ; key === value || ( dataObjAttrs [ key ] = value ) ; } } ) ; return Object . keys ( dataObjAttrs ) . length ? dataObjAttrs : null ; } 
function replaceTemplateVariable ( value , data ) { return value . replace ( / \{\{(.+)\}\} / g , ( match , varName ) => { varName = varName . trim ( ) ; let newVarName = data [ varName ] ; if ( newVarName ) { return ` ${ newVarName } ` ; } return match ; } ) ; } 
function replaceElementAttributeVariable ( attrs , data ) { let newAttrs = Object . assign ( { } , attrs ) ; attrs && Object . keys ( attrs ) . forEach ( k => { let value = attrs [ k ] ; if ( k . startsWith ( ':' ) ) { 
function updateTemplateDataVariableName ( element , data ) { let { children } = element ; let result = [ ] ; children && children . forEach ( item => { let { type } = item . type ; let newItem = Object . assign ( { } , item ) ; if ( type === 'tag' ) { let { attribs : attrs , children } = item ; newItem . attribs = replaceElementAttributeVariable ( attrs , data ) ; if ( children ) { let newChildren = updateTemplateDataVariableName ( item , data ) ; newChildren && ( newItem . children = newChildren ) ; } } else if ( type === 'text' ) { let { data : textValue } = item ; textValue = replaceTemplateVariable ( textValue , data ) ; newItem . data = textValue ; } result . push ( newItem ) ; } ) ; return result ; } 
function transformExtNameElement ( element ) { let { attribs : attrs } = element ; let src = attrs && attrs . src ; if ( src ) { attrs . src = src . replace ( / \.wxml$ / i , '.swan' ) ; } } 
function transformTemplateElement ( element ) { let { attribs : attrs } = element ; let data = attrs && attrs . data ; if ( data ) { attrs . data = ` ${ data } ` ; } } 
function bothForAndIFAttr ( attrs ) { if ( ! attrs ) { return false ; } let hasForAttr = FOR_DIRECTIVES . some ( item => attrs [ item ] ) ; let hasIf = CONDITION_DIRECTIVES . some ( item => attrs [ item ] ) ; return hasForAttr && hasIf ; } 
function shouldPolyfill ( importName , name , path ) { let result ; if ( Array . isArray ( importName ) ) { result = importName . some ( item => ( item === name ) ) ; } else { result = importName === name ; } 
function proxyDataGetter ( ctx , prop ) { let proxyProps = ctx . __proxyProps ; proxyProps || ( proxyProps = ctx . __proxyProps = { } ) ; if ( proxyProps [ prop ] ) { return ; } proxyProps [ prop ] = true ; let descriptor = Object . getOwnPropertyDescriptor ( ctx , prop ) ; if ( descriptor && descriptor . configurable ) { let newDescriptor = Object . assign ( { } , descriptor , { get ( ) { ctx . __deps && ctx . __deps . push ( prop ) ; return descriptor . get && descriptor . get . call ( ctx ) ; } } ) ; Object . defineProperty ( ctx , prop , newDescriptor ) ; } else { console . warn ( 'cannot configure the data prop descriptor info:' , prop ) ; } } 
function addDataChangeWatcher ( ctx , prop , deep ) { 
function collectComputedPropDeps ( ctx , prop , getter ) { ctx . __deps = [ ] ; let value = getter . call ( ctx ) ; ctx . __computedDeps [ prop ] = ctx . __deps ; ctx . __deps = null ; return value ; } 
function findChangeComputedProps ( allDeps , changeProp ) { let result = [ ] ; Object . keys ( allDeps ) . forEach ( k => { let depList = allDeps [ k ] ; if ( k !== changeProp && depList . indexOf ( changeProp ) !== - 1 ) { result . push ( k ) ; } } ) ; return result ; } 
function initGlobalComponents ( appType , componentConf , sourceDir ) { let { global : globalComponents } = componentConf ; if ( ! globalComponents ) { return ; } let result = { } ; Object . keys ( globalComponents ) . forEach ( k => { let value = globalComponents [ k ] ; value = value . replace ( / ^okam\/ / , BUILTIN_COMPONENTS_PACKAGE_ROOT + appType + '/' ) ; let isRelMod = value . charAt ( 0 ) === '.' ; if ( isRelMod ) { value = pathUtil . join ( sourceDir , value ) ; } result [ toHyphen ( k ) ] = { isNpmMod : ! isRelMod , modPath : value } ; } ) ; return result ; } 
function initDirFiles ( dir , cache ) { let cacheDirFiles = { } ; cache . setDirFileListInfo ( dir , cacheDirFiles ) ; let files = fs . readdirSync ( dir ) ; for ( let i = 0 , len = files . length ; i < len ; i ++ ) { let file = files [ i ] ; let fullPath = path . resolve ( dir , file ) ; let stat = getFileState ( fullPath ) ; if ( ! stat || stat . isDirectory ( ) ) { continue ; } let fileName = getFileName ( fullPath ) ; let fileList = cacheDirFiles [ fileName ] ; if ( ! fileList ) { fileList = cacheDirFiles [ fileName ] = [ ] ; } fileList . push ( fullPath ) ; } return cacheDirFiles ; } 
function getCompOriginFileInfoByType ( type , filePathNoExtname , options ) { const componentExtMap = COMPONENT_FILE_EXT_NAMES [ type ] || { } ; 
function getCompFilesInfoByAppType ( filePathNoExtname , options ) { let { appType , wx2swan , componentExtname } = options ; 
function getPageOriginFileExtnames ( pageFileNotExt , buildManager ) { let { files : allFiles , appType , buildConf , componentExtname } = buildManager ; 
function addProcessEntryPages ( pages , pageFileMap , allPageFiles , fileDirname , buildManager ) { let { files : allFiles , componentExtname , logger , appType , root } = buildManager ; pages . forEach ( p => { let pageFileNotExt = path . resolve ( fileDirname , p ) ; let pageFile = allFiles . getByFullPath ( ` ${ pageFileNotExt } ${ componentExtname } ` ) ; 
function buildProject ( timer , buildConf , buildManager ) { let { logger , output : outputOpts } = buildConf ; let { onBuildStart , onBuildDone } = buildConf . script || { } ; let hookResult = runBuildStartHook ( buildManager , onBuildStart ) ; let buildResult ; if ( hookResult instanceof Promise ) { buildResult = hookResult . then ( code => { logger . debug ( 'init build start done...' , code ) ; return buildManager . build ( timer ) ; } ) ; } else { buildResult = buildManager . build ( timer ) ; } let doneHandler = buildDone . bind ( null , timer , logger , outputOpts . dir ) ; return buildResult . then ( ( ) => buildManager . release ( ) ) . then ( doneHandler ) . then ( ( ) => { runBuildDoneHook ( buildManager , onBuildDone ) ; } ) . catch ( doneHandler ) ; } 
function runBuild ( buildConf , buildManager ) { let timer = new Timer ( ) ; timer . start ( ) ; let { appType , logger , root : rootDir , configPath } = buildConf ; logger . info ( 'build start...' ) ; logger . info ( 'build app type:' , colors . cyan ( appType ) ) ; logger . info ( 'load process files from' , colors . cyan ( getRelativePath ( rootDir ) ) ) ; if ( configPath ) { logger . info ( 'build by config' , colors . cyan ( getRelativePath ( configPath ) ) ) ; } else if ( buildConf . useDefaultConfig ) { logger . info ( 'build using default inner config' ) ; } 
function compile ( file , options ) { let obj = json5 . parse ( file . content . toString ( ) ) ; let result = JSON . stringify ( obj , null , 4 ) ; return { content : result } ; } 
function initPlatformInfo ( callback ) { api . getSystemInfo ( { success ( info ) { callback && callback ( null , info ) ; } , fail ( err ) { callback && callback ( err ) ; } } ) ; } 
function addSubFile ( file ) { if ( ! file ) { return ; } this . subFiles || ( this . subFiles = [ ] ) ; if ( ! this . subFiles . includes ( file ) ) { file . isSubFile = true ; file . owner = this ; this . subFiles . push ( file ) ; } } 
function createFile ( fileInfo , rootDir ) { let { path : relPath , fullPath , data , isVirtual , isScript , isStyle , isTemplate } = fileInfo ; if ( relPath && ! fullPath ) { fullPath = path . resolve ( rootDir , relPath ) ; } let extname = path . extname ( fullPath ) . slice ( 1 ) . toLowerCase ( ) ; let vf = { processor : FILE_EXT_PROCESSOR [ extname ] , dirname : path . dirname ( fullPath ) , extname , fullPath , path : relPath || relative ( fullPath , rootDir ) , rawContent : data , isVirtual , isScript : isScript == null ? isScriptType ( extname ) : isScript , isStyle : isStyle == null ? isStyleType ( extname ) : isStyle , isImg : isImgType ( extname ) , isTpl : isTemplate == null ? isTplType ( extname ) : isTemplate , isJson : isJsonType ( extname ) , addDeps , addSubFile , reset : resetFile , sourceMap : null } ; Object . defineProperties ( vf , { stream : { get : getFileStream } , content : { get : loadFileContent , set : updateFileContent } } ) ; return vf ; } 
function tryToResolveRequireModId ( t , path , state ) { let opts = state . opts || { } ; let resolveRequireId = opts . resolveDepRequireId ; let exportNode = path . node ; let source = exportNode . source ; if ( ! t . isStringLiteral ( source ) ) { return ; } let modId = source . value ; let newModId = resolveRequireId ( modId ) ; if ( newModId && newModId !== modId ) { let requireIdNode = path . get ( 'source' ) ; requireIdNode . replaceWith ( t . stringLiteral ( newModId ) ) ; } } 
function showEventNameLog ( name , newName , eventModifiers , attrs , tplOpts ) { let { logger , file , appType } = tplOpts ; NOT_SUPPORT_MODIFIERS . forEach ( item => { if ( eventModifiers . includes ( item ) ) { logger . warn ( ` ${ file . path } ${ name } ` , ` ${ item } ${ appType } ` ) ; } } ) ; if ( attrs . hasOwnProperty ( newName ) ) { logger . warn ( ` ${ file . path } ${ name } ${ newName } ` ) ; } } 
function parseHandlerByREGEXP ( handlerString ) { 
function getRandomStringNotIn ( string ) { const randomString = Math . random ( ) . toString ( 36 ) . substr ( 2 ) ; if ( string . indexOf ( randomString ) === - 1 ) { return randomString ; } return getRandomStringNotIn ( string ) ; } 
function sortDefaultProcessors ( processorNames , processors ) { if ( Array . isArray ( processorNames ) ) { processorNames . sort ( ( a , b ) => { a = processors [ a ] ; b = processors [ b ] ; return ( a . order || 0 ) - ( b . order || 0 ) ; } ) ; } } 
function addFileExtnameAssociatedProcessor ( extnames , processorName , existedMap ) { if ( ! extnames ) { return ; } if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } extnames . forEach ( k => { k = k . toLowerCase ( ) ; let processors = existedMap [ k ] ; if ( Array . isArray ( processors ) ) { processors . push ( processorName ) ; } else if ( processors ) { existedMap [ k ] = [ processors , processorName ] ; } else { existedMap [ k ] = processorName ; } } ) ; } 
function removeFileExtnameAssociatedProcessor ( extnames , processorName , existedMap ) { if ( ! extnames ) { return ; } if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } extnames . forEach ( k => { let currItems = existedMap [ k ] ; if ( Array . isArray ( currItems ) ) { let idx = currItems . indexOf ( processorName ) ; if ( idx !== - 1 ) { currItems . splice ( idx , 1 ) ; currItems . length === 0 && ( existedMap [ k ] = undefined ) ; } } else if ( currItems === processorName ) { existedMap [ k ] = undefined ; } } ) ; } 
function getFileExtnameAssociatedProcessor ( processors ) { let result = Object . keys ( processors ) . reduce ( ( lastValue , processorName ) => { let processor = processors [ processorName ] ; let extnames = processor . extnames || [ ] ; if ( ! Array . isArray ( extnames ) ) { extnames = [ extnames ] ; } addFileExtnameAssociatedProcessor ( extnames , processorName , lastValue ) ; return lastValue ; } , { } ) ; Object . keys ( result ) . forEach ( k => sortDefaultProcessors ( result [ k ] , processors ) ) ; return result ; } 
function initProcessorInfo ( name , info , existedProcessors ) { let processor = info . processor ; if ( ! processor ) { return info ; } if ( typeof processor === 'string' ) { 
function overrideObjectFunctions ( curr , old ) { if ( ! old ) { return curr ; } if ( ! curr && curr !== undefined ) { return old ; } let result = { } ; Object . keys ( curr ) . forEach ( k => { let v = curr [ k ] ; let oldV = old [ k ] ; if ( typeof v === 'function' && typeof oldV === 'function' ) { let currV = v ; v = function ( ... args ) { oldV . apply ( this , args ) ; currV . apply ( this , args ) ; } ; } result [ k ] = v ; } ) ; return result ; } 
function overrideProcessor ( existedProcessor , extnameProcessorMap , opts ) { let oldExtnames ; let newExtnames ; Object . keys ( opts ) . forEach ( k => { let v = opts [ k ] ; if ( ! v ) { return ; } if ( k === 'extnames' ) { oldExtnames = existedProcessor [ k ] ; newExtnames = v ; } if ( k === 'hook' ) { v = overrideObjectFunctions ( v , existedProcessor [ k ] ) ; } existedProcessor [ k ] = v ; } ) ; let processor = opts . processor ; if ( processor ) { existedProcessor . processor = resolveProcessor ( processor ) ; } let processorName = opts . name ; removeFileExtnameAssociatedProcessor ( oldExtnames , processorName , extnameProcessorMap ) ; addFileExtnameAssociatedProcessor ( newExtnames , processorName , extnameProcessorMap ) ; } 
function updateReferProcessorInfo ( existedProcessors , processorName , referProcessorName ) { let currProcessor = existedProcessors [ processorName ] ; if ( ! currProcessor || currProcessor . processor ) { return ; } let referProcessorInfo = existedProcessors [ referProcessorName ] ; if ( ! referProcessorInfo ) { return ; } let deps = referProcessorInfo . deps ; deps && ! Array . isArray ( deps ) && ( deps = [ deps ] ) ; let oldDeps = currProcessor . deps ; oldDeps && ! Array . isArray ( oldDeps ) && ( oldDeps = [ oldDeps ] ) ; let old = Object . assign ( { } , currProcessor ) ; Object . assign ( currProcessor , referProcessorInfo , old , { refer : referProcessorName , deps : merge ( deps || [ ] , oldDeps || [ ] ) , processor : referProcessorInfo . processor } ) ; } 
function registerProcessor ( existedProcessors , extnameProcessorMap , opts ) { let { name , processor , deps , rext , extnames , options , order , hook } = opts ; if ( ! name ) { throw new Error ( 'missing processor name to register' ) ; } if ( existedProcessors . hasOwnProperty ( name ) ) { 
function generateFilterCode ( filterObjAst , t , options ) { if ( ! filterObjAst . properties . length ) { return '' ; } let { format = 'es6' , usingBabel6 } = options || { } ; let ast ; if ( format === 'es6' ) { ast = generateES6ModuleFilterCode ( filterObjAst , t ) ; } else { ast = generateCommonJSModuleFilterCode ( filterObjAst , t ) ; } return generateCode ( ast , { auxiliaryCommentBefore : 'Auto generated filter code by okam' } , usingBabel6 ) . code ; } 
function createAPIDoneHook ( done , ctx ) { let hookInfo = { resData : null , resException : false , hook : null } ; hookInfo . hook = ( err , res , complete , shouldCatchException ) => { let result ; if ( err != null ) { result = err ; if ( shouldCatchException ) { try { let data = done ( result , null , ctx ) ; data == null || ( result = data ) ; } catch ( ex ) { 
function interceptAsyncAPIDone ( sync , args , doneHook ) { let callOpts = args [ 0 ] ; let { success , fail , complete } = callOpts || { } ; let hasIntercepted = false ; if ( ! sync && ( isFunction ( success ) || isFunction ( fail ) || isFunction ( complete ) ) ) { hasIntercepted = true ; let newCallOpts = Object . assign ( { } , callOpts ) ; newCallOpts . success = res => { let data = doneHook ( null , res , complete , true ) ; success && success ( data ) ; } ; newCallOpts . fail = err => { err = doneHook ( err || 'err' , null , complete , true ) ; fail && fail ( err ) ; } ; 
function interceptPromiseResponse ( hasIntercepted , promise , doneHookInfo ) { let { hook } = doneHookInfo ; return promise . then ( res => ( hasIntercepted ? doneHookInfo . resData : hook ( null , res ) ) , err => { 
function hookAPIInit ( init , args , ctx ) { 
function hookAPIDone ( done , sync , args , ctx ) { 
function executeAPI ( hookInfo , rawApi , args ) { 
function proxyAPI ( ctx , rawApi , apiOpts , ... args ) { let { init , done , sync } = apiOpts ; 
function getDefaultBuildConfig ( appType ) { if ( appType === 'base' ) { throw new Error ( 'illegal app type' , appType ) ; } let defaultConfPath = path . join ( __dirname , '..' , 'config' , ` ${ appType } ` ) ; if ( fileUtil . isFileExists ( defaultConfPath ) ) { return require ( defaultConfPath ) ; } else { return require ( '../config/base' ) ; } } 
function initBuildOptions ( appType , options , cliOpts = { } ) { appType = cliOpts . type || appType || 'swan' ; let userConfig = getUserBuildConfig ( options , appType , cliOpts . config ) ; let userOutputFile = userConfig . output && userConfig . output . file ; 
function queryComponentInstance ( ctx , id ) { let isSelectAll = Array . isArray ( id ) ; isSelectAll && ( id = id [ 0 ] ) ; 
function initRefs ( ) { this . $refs = { } ; let refs = this . $rawRefData ; if ( typeof refs === 'function' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; Object . keys ( refs ) . forEach ( id => { result [ id ] = { get : queryComponentInstance . bind ( null , this , refs [ id ] ) , enumerable : true } ; } ) ; Object . defineProperties ( this . $refs , result ) ; } 
function normalizeTagTransformInfo ( nativeTag , transformItem ) { if ( typeof transformItem === 'string' ) { return { transformTag : transformItem , transformOpts : nativeTag } ; } let transformOpts = Object . assign ( { } , transformItem ) ; transformOpts . tag = nativeTag ; return { transformTag : transformItem . tag , transformOpts } ; } 
function initRelations ( component , isPage ) { let relations = component . relations ; if ( ! relations || isPage ) { 
function createFrameworkExtendCallExpression ( t , calleeName , extendName , hasPluginOpt ) { let args = [ t . identifier ( extendName ) ] ; if ( hasPluginOpt ) { args . push ( t . objectExpression ( [ ] ) ) ; } return t . expressionStatement ( t . callExpression ( t . memberExpression ( t . identifier ( calleeName ) , t . identifier ( 'use' ) ) , args ) ) ; } 
function preparePolyfillSupport ( polyfill , rootDir , logger ) { if ( ! polyfill ) { return ; } if ( ! Array . isArray ( polyfill ) ) { polyfill = [ polyfill ] ; } polyfill . forEach ( info => { try { ensure ( info . desc , info . deps , rootDir ) ; } catch ( ex ) { logger . warn ( ex . toString ( ) ) ; } } ) ; } 
function getPlainObjectNodeValue ( node , path , t ) { let result ; if ( t . isObjectExpression ( node ) ) { result = { } ; let props = node . properties || [ ] ; for ( let i = 0 , len = props . length ; i < len ; i ++ ) { let subNode = props [ i ] ; let keyNode = subNode . key ; let key ; if ( t . isLiteral ( keyNode ) ) { key = keyNode . value ; } else if ( t . isIdentifier ( keyNode ) ) { key = keyNode . name ; } if ( ! key ) { continue ; } result [ key ] = getPlainObjectNodeValue ( subNode . value , path , t ) ; } } else if ( t . isArrayExpression ( node ) ) { result = [ ] ; node . elements . forEach ( item => { result . push ( getPlainObjectNodeValue ( item , path , t ) ) ; } ) ; } else if ( t . isNullLiteral ( node ) ) { result = null ; } else if ( t . isLiteral ( node ) ) { result = node . value ; } else { throw path . buildCodeFrameError ( 'only constant is supported' ) ; } return result ; } 
function createNode ( value , t ) { if ( t . isIdentifier ( value ) ) { return value ; } if ( Array . isArray ( value ) ) { let elements = [ ] ; value . forEach ( item => { let node = createNode ( item , t ) ; node && elements . push ( node ) ; } ) ; return t . arrayExpression ( elements ) ; } if ( Object . prototype . toString . call ( value ) === '[object Object]' ) { let props = [ ] ; Object . keys ( value ) . forEach ( k => { let node = createNode ( value [ k ] , t ) ; if ( node ) { props . push ( t . objectProperty ( t . identifier ( ` ${ k } ` ) , node ) ) ; } } ) ; return t . objectExpression ( props ) ; } if ( value == null ) { return t . nullLiteral ( ) ; } let valueType = typeof value ; switch ( valueType ) { case 'boolean' : return t . booleanLiteral ( value ) ; case 'string' : return t . stringLiteral ( value ) ; case 'number' : return t . numericLiteral ( value ) ; } } 
function removeComments ( t , path , type ) { let commentPaths = path . get ( type ) ; if ( ! commentPaths || ! commentPaths . length ) { return ; } let isLeadingType = type === LEADING_COMMENT_TYPE ; if ( isLeadingType ) { let parentPath = path . parentPath ; let isParentProgram = parentPath && t . isProgram ( parentPath . node ) ; 
function parse ( file , options ) { let result = sfcParser ( file , options ) ; let fileDir = path . dirname ( file . fullPath ) ; let { addFile } = options ; let importComponents = { } ; let { customBlocks } = result ; customBlocks && customBlocks . forEach ( item => { let { type , attrs } = item ; if ( attrs && type === 'import' ) { let { name , src } = attrs ; importComponents [ name ] = src ; src && addFile ( path . join ( fileDir , src + '.ux' ) ) ; } } ) ; file . importComponents = importComponents ; return result ; } 
function handleProxyEvent ( source , target , eventName , options ) { let { newEventName , prependSourceArg } = options || { } ; source . on ( eventName , function ( ... args ) { prependSourceArg && args . unshift ( source ) ; if ( typeof newEventName === 'function' ) { newEventName . apply ( target , args ) ; } else { newEventName || ( newEventName = eventName ) ; args . unshift ( newEventName ) ; target . emit . apply ( target , args ) ; } } ) ; } 
function makeComputedObservable ( ctx ) { let computedInfo = ctx . $rawComputed || { } ; if ( typeof computedInfo === 'function' ) { ctx . $rawComputed = computedInfo = computedInfo ( ) ; } let observer = new ComputedObserver ( ctx , computedInfo ) ; let ctxProps = { } ; Object . keys ( computedInfo ) . forEach ( k => { ctxProps [ k ] = { get : observer . getGetter ( k ) , set : observer . getSetter ( k ) , enumerable : true } ; } ) ; Object . defineProperties ( ctx , ctxProps ) ; return observer ; } 
function makePropsObservable ( ctx ) { let props = ctx . $rawProps ; if ( typeof props === 'function' ) { props = ctx . $rawProps = props ( ) ; } if ( ! props ) { return ; } let observer = new Observer ( ctx , ctx [ propDataKey ] || { } , null , true ) ; let propsObj = { } ; Object . keys ( props ) . reduce ( ( last , item ) => { last [ item ] = true ; return last ; } , propsObj ) ; Object . defineProperties ( ctx , proxyObject ( observer , propsObj ) ) ; return observer ; } 
function makeDataObservable ( ctx ) { const data = ctx . data ; if ( ! data ) { return ; } if ( isPlainObject ( data ) ) { let observer = new Observer ( ctx , data ) ; Object . defineProperties ( ctx , proxyObject ( observer , data , ctx ) ) ; return observer ; } let err = new Error ( 'data require plain object' ) ; err . isTypeError = true ; throw err ; } 
function initMixinFile ( mixins , buildManager , file ) { mixins && mixins . forEach ( modulePath => { let { resolvedModIds : cacheResolveModIds } = file ; let cacheInfo = cacheResolveModIds [ modulePath ] ; let mixinFile = cacheInfo && cacheInfo . file ; if ( mixinFile && ! mixinFile . isBehavior ) { mixinFile . isBehavior = true ; } } ) ; } 
function initConfigInfo ( buildManager , key , file , info ) { buildManager . logger . trace ( 'extract file config' , file . path , info ) ; let { components , config = { } } = info ; if ( file . isPageScript ) { initMixinFile ( info . mixins , buildManager , file ) ; initFilterConfig ( info . filters , buildManager , file ) ; config = normalPageConfig ( config , components , file , buildManager ) ; } else if ( file . isComponentScript ) { initMixinFile ( info . mixins , buildManager , file ) ; initFilterConfig ( info . filters , buildManager , file ) ; config = normalizeComponentConfig ( config , components , file , buildManager ) ; config . component = true ; } else { initMixinFile ( info . mixins , buildManager , file ) ; } file [ key ] = config ; } 
function initLocalPolyfillPlugins ( polyfills , plugins ) { polyfills . forEach ( item => { let pluginItem = polyfillPlugin [ item . type ] ; plugins . push ( [ pluginItem , { polyfill : item } ] ) ; } ) ; } 
function hasBabelDepPlugin ( plugins ) { return plugins . some ( item => { let pluginItem = item ; if ( Array . isArray ( item ) ) { pluginItem = item [ 0 ] ; } if ( typeof pluginItem === 'string' ) { return pluginItem === DEP_PLUGIN_NAME ; } return pluginItem === programPlugins . resolveDep ; } ) ; } 
function normalizeBabelPlugins ( plugins , file , buildManager ) { if ( typeof plugins === 'function' ) { plugins = plugins ( file ) ; } plugins = plugins ? [ ] . concat ( plugins ) : [ ] ; if ( ! hasBabelDepPlugin ( plugins ) ) { 
function initBabelProcessorOptions ( file , processorOpts , buildManager ) { processorOpts = Object . assign ( { } , buildManager . babelConfig , processorOpts ) ; 
function startBuild ( buildConf , clear ) { 
function transformMiniProgramEventType ( element , eventType , opts ) { let { customComponentTags } = opts || { } ; let tagName = element . name . toLowerCase ( ) ; let isClickEvent = eventType === 'click' ; if ( customComponentTags ) { let isCustomTag = customComponentTags . some ( item => item === tagName ) ; if ( isCustomTag ) { return eventType ; } } return isClickEvent ? 'tap' : eventType ; } 
function parseWxSwanEventName ( name , element , tplOpts , opts ) { let eventAttrName = name . replace ( EVENT_REGEXP , '' ) ; let [ eventType , ... eventModifiers ] = eventAttrName . split ( '.' ) ; let eventMode = 'bind' ; eventType = transformMiniProgramEventType ( element , eventType , opts ) ; const includesStop = eventModifiers . includes ( 'stop' ) ; const includesCapture = eventModifiers . includes ( 'capture' ) ; if ( includesCapture ) { eventMode = includesStop ? 'capture-catch:' : 'capture-bind:' ; } else if ( includesStop ) { eventMode = 'catch' ; } eventAttrName = eventMode + eventType ; return { eventType , eventAttrName , eventModifiers } ; } 
function parseEventName ( name , element , tplOpts , opts ) { let eventAttrName = name . replace ( EVENT_REGEXP , '' ) ; let [ eventType , ... eventModifiers ] = eventAttrName . split ( '.' ) ; let eventMode = 'on' ; eventType = transformMiniProgramEventType ( element , eventType , opts ) ; let { logger , file } = tplOpts ; antNotSupportModifier . forEach ( item => { if ( eventModifiers . includes ( item ) ) { logger . warn ( ` ${ file . path } ${ name } ` , ` ${ item } ` ) ; } } ) ; if ( eventModifiers . includes ( 'capture' ) ) { eventMode = 'catch' ; } let nativeEvent = NATIVE_EVENT_MAP [ eventType . toLowerCase ( ) ] ; if ( nativeEvent ) { eventType = nativeEvent ; } let formatEventType = eventType . charAt ( 0 ) . toUpperCase ( ) + eventType . substr ( 1 ) ; eventAttrName = eventMode + formatEventType ; return { eventType , eventAttrName , eventModifiers } ; } 
function registerApi ( apiConfig ) { let baseApi = base . $api ; apiConfig && Object . keys ( apiConfig ) . forEach ( k => { 
function getEventName ( appType , eventType ) { let eventName = eventType ; if ( appType === 'ant' ) { let formatEventType = eventType . charAt ( 0 ) . toUpperCase ( ) + eventType . substr ( 1 ) ; eventName = formatEventType ; } if ( appType === 'quick' ) { eventName = toHyphen ( eventType ) ; } return ` ${ EVENT_PREFIX [ appType ] } ${ eventName } ` ; } 
function Vue ( options ) { let instance = Object . assign ( { } , options , observableComp . methods , watchComp . methods ) ; instance . created = observableComp . created ; instance . $destroy = observableComp . detached ; 
function transformObjClass ( value , objToStr ) { value = value . replace ( / [\s*{}] / g , '' ) . split ( ',' ) . map ( item => { const arr = item . split ( ':' ) ; let key = arr [ 0 ] ; let firstChar = key . charAt ( 0 ) ; if ( firstChar !== '\'' && firstChar !== '\"' ) { key = ` ${ key } ` ; } // support object abbrev case: {a, b} let expression = arr . length === 1 ? arr [ 0 ] : arr [ 1 ] ; let result = ` ${ expression } ${ key } ` ; return objToStr ? ` ${ result } ` : result ; } ) ; return value . join ( objToStr ? ' + \' \' + ' : ',' ) ; } 
function transformArrayClass ( value , arrToStr ) { return value . replace ( / [\s*[\]] / g , '' ) . split ( ',' ) . map ( item => { if ( / ^{.*}$ / . test ( item ) ) { return transformObjClass ( item , arrToStr ) ; } else if ( arrToStr && / ^.+\?.+:.+$ / . test ( item ) ) { return ` ${ item } ` ; } return item ; } ) . join ( arrToStr ? ' + \' \' + ' : ',' ) ; } 
function compile ( file , options ) { let { envConfigKey } = options ; let obj = JSON . parse ( file . content . toString ( ) ) ; let result = { } ; Object . keys ( obj ) . forEach ( k => { if ( ! OKAM_ENV_KEY_REGEXP . test ( k ) ) { result [ k ] = obj [ k ] ; } } ) ; let appSpecConf = obj [ envConfigKey ] ; let isAppConfig = file . isAppConfig ; appSpecConf && Object . keys ( appSpecConf ) . forEach ( k => { let value = appSpecConf [ k ] ; if ( value == null ) { 
function initExtensions ( type , instance , base ) { let cache = pluginCache ; if ( process . env . APP_TYPE === 'quick' ) { if ( ! appGlobal . okamPluginCache ) { appGlobal . okamPluginCache = pluginCache ; } cache = appGlobal . okamPluginCache ; } let existedBase = cache . baseClasses [ type ] ; if ( ! existedBase ) { let plugins = cache . usedExtensions [ type ] ; let args = [ { } ] ; plugins && Array . prototype . push . apply ( args , plugins ) ; args . push ( base ) ; existedBase = mixin . apply ( this , args ) ; cache . baseClasses [ type ] = existedBase ; } return mixin . apply ( this , [ instance , existedBase ] ) ; } 
function addExtension ( type , extension ) { if ( ! extension ) { return ; } let cache = pluginCache ; if ( process . env . APP_TYPE === 'quick' ) { cache = appGlobal . okamPluginCache ; } let existedExtensions = cache . usedExtensions [ type ] ; if ( ! existedExtensions ) { existedExtensions = cache . usedExtensions [ type ] = [ ] ; } existedExtensions . push ( extension ) ; } 
function initComponentData ( instance , options , isPage ) { let data = instance . data ; if ( isFunction ( data ) ) { instance . data = instance . data ( ) ; } instance . $init && instance . $init ( isPage , options ) ; } 
function mergeVisitors ( plugins ) { let result = { } ; plugins . forEach ( item => { let transform = item ; let options ; if ( Array . isArray ( item ) ) { [ transform , options ] = item ; } typeof transform === 'string' && ( transform = require ( transform ) ) ; Object . keys ( transform ) . forEach ( type => { let visitor = transform [ type ] ; let list = result [ type ] ; list || ( list = result [ type ] = [ ] ) ; list . push ( [ visitor , options ] ) ; } ) ; } ) ; return result ; } 
function compileTpl ( file , options ) { let { config } = options ; let allowCache = ! config || config . cache == null || config . cache ; let content = file . content . toString ( ) ; const ast = file . ast || parseDom ( content ) ; allowCache && ( file . ast = ast ) ; let plugins = mergeVisitors ( ( config && config . plugins ) || [ ] ) ; transformAst ( ast , plugins , Object . assign ( { } , options , { file } ) ) ; let { keepOriginalContent } = config || { } ; if ( ! keepOriginalContent ) { 
function parse ( file , options ) { let { root , config } = options ; let parseOpts = Object . assign ( { } , { pad : 'line' } , config && config . parse ) ; let result = compiler . parseComponent ( file . content . toString ( ) , parseOpts ) ; let { customBlocks } = result ; let { fullPath : filePath } = file ; let tplFile = createPartFile ( file , result . template , { isTemplate : true , root , filePath } ) ; let scriptFile = createPartFile ( file , result . script , { isScript : true , root , filePath } ) ; let styleFiles = result . styles . map ( ( item , index ) => createPartFile ( file , item , { isStyle : true , index , root , filePath } ) ) ; 
function showMenu ( ) { const prompt = require ( '@system.prompt' ) const router = require ( '@system.router' ) const appInfo = require ( '@system.app' ) . getInfo ( ) prompt . showContextMenu ( { itemList : [ '保存桌面', '关于', ' 消'], success : function ( ret ) { switch ( ret . index ) { case 0 : 
function createShortcut ( ) { const prompt = require ( '@system.prompt' ) const shortcut = require ( '@system.shortcut' ) shortcut . hasInstalled ( { success : function ( ret ) { if ( ret ) { prompt . showToast ( { message : '已创建桌面图标' } ) } else { shortcut . install ( { success : function ( ) { prompt . showToast ( { message : '成功创建桌面图标' } ) } , fail : function ( errmsg , errcode ) { prompt . showToast ( { message : ` ${ errcode } ${ errmsg } ` } ) } } ) } } } ) } 
function normalizeProps ( props ) { Object . keys ( props ) . forEach ( k => { let propValue = props [ k ] ; let defaultValue = null ; if ( propValue && propValue . default !== undefined ) { defaultValue = propValue . default ; } props [ k ] = defaultValue ; } ) ; return props ; } 
function queryRefInstance ( selector ) { let isSelectAll = Array . isArray ( selector ) ; isSelectAll && ( selector = selector [ 0 ] ) ; let result ; if ( isSelectAll ) { if ( typeof this . selectAllComponents === 'function' ) { result = this . selectAllComponents ( selector ) ; } result || ( result = [ ] ) ; } else if ( typeof this . selectComponent === 'function' ) { result = this . selectComponent ( selector ) ; } return result ; } 
function initRefs ( ) { this . $refs = { } ; let refs = this . $rawRefData ; if ( typeof refs === 'function' ) { refs = refs ( ) ; } if ( ! refs ) { return ; } let result = { } ; const self = this ; Object . keys ( refs ) . forEach ( id => { result [ id ] = { get ( ) { let value = refs [ id ] ; return queryRefInstance . call ( self , value ) ; } , enumerable : true } ; } ) ; Object . defineProperties ( this . $refs , result ) ; } 
function fetchData ( url , options ) { let { method = 'GET' } = options || { } ; method = method . toUpperCase ( ) ; return httpApi . request ( Object . assign ( { url } , options , { method } ) ) ; } 
function findMatchTransformer ( transformers , value , matchItem ) { if ( ! value ) { return ; } let found ; transformers . some ( item => { let match = item . match ; let isMatch = false ; let type = typeof match ; if ( type === 'string' ) { isMatch = match === value ; } else if ( type === 'function' ) { isMatch = match ( matchItem ) ; } else { 
function normalizeTransformers ( transformerMap ) { let result = [ ] ; transformerMap && Object . keys ( transformerMap ) . forEach ( k => { let item = transformerMap [ k ] ; if ( item ) { item . transform . type = k ; result . push ( Object . assign ( { } , item , { name : k } ) ) ; } } ) ; return result ; } 
function transform ( transformers , element , tplOpts , options ) { let { config } = tplOpts ; let onTag = config . onTag ; if ( onTag ) { onTag ( element . name ) ; } 
function transformTextNode ( transformer , textNode , tplOpts , options ) { let handler = findMatchTransformer ( transformer , textNode . data , textNode ) ; handler && handler . call ( this , textNode , tplOpts , options ) ; } 
function getGitUser ( ) { try { let name = execSync ( 'git config --get user.name' ) ; let email = execSync ( 'git config --get user.email' ) ; name = name && name . toString ( ) . trim ( ) ; email = email && ( '<' + email . toString ( ) . trim ( ) + '>' ) ; return ( name || '' ) + ( email || '' ) ; } catch ( e ) { return '' ; } } 
function traverseFilesAndCb ( curDir , cb ) { let fileDirs = [ curDir ] ; while ( fileDirs . length ) { let currDir = fileDirs . pop ( ) ; let files = fs . readdirSync ( currDir ) ; for ( let i = 0 , len = files . length ; i < len ; i ++ ) { let fileName = files [ i ] ; if ( / ^\. / . test ( fileName ) ) { continue ; } let fullPath = path . resolve ( currDir , fileName ) ; let stat = getFileState ( fullPath ) ; if ( ! stat ) { continue ; } let isDir = stat . isDirectory ( ) ; if ( isDir ) { fileDirs . push ( fullPath ) ; continue ; } if ( typeof cb === 'function' ) { cb ( fullPath ) ; } } } } 
function addComponentSameNameFiles ( scriptFile , options ) { const { dirname : currDir , path : relPath } = scriptFile ; const scriptFileName = getFileName ( relPath ) ; 
function analyseNativeComponent ( scriptFile , options ) { 
function compile ( file , options ) { const { resolve : resolveDep , logger } = options ; try { let componentConf = JSON . parse ( file . content . toString ( ) ) ; let usingComponents = componentConf [ USING_COMPONENT_KEY ] ; if ( ! usingComponents || ! file . component ) { return { content : file . content } ; } let result = { } ; let scriptFile = file . component ; Object . keys ( usingComponents ) . forEach ( k => { let value = usingComponents [ k ] ; if ( ! value ) { return ; } let resolvePath = resolveDep ( scriptFile , value ) ; result [ toHyphen ( k ) ] = resolvePath || value ; let resolveModInfo = scriptFile . resolvedModIds [ value ] ; let componentFile = resolveModInfo && resolveModInfo . file ; componentFile && analyseNativeComponent ( componentFile , options ) ; } ) ; 
function updateArrayItem ( observer , idx , value ) { observer . set ( idx , value ) ; this [ idx ] = value ; } 
function makeArrayObservable ( arr , observer , proxyArrApis ) { 
function normalizeWatchItem ( value ) { let handlers ; let options = { } ; let valueType = typeof value ; if ( valueType === 'function' || valueType === 'string' ) { handlers = [ value ] ; } else if ( Array . isArray ( value ) ) { handlers = value ; } else { handlers = [ value . handler ] ; options . immediate = value . immediate ; } let watchHandler = function ( ... args ) { for ( let i = 0 , len = handlers . length ; i < len ; i ++ ) { let item = handlers [ i ] ; if ( typeof item === 'string' ) { item = this [ item ] ; } item . apply ( this , args ) ; } } ; return { handler : watchHandler , options } ; } 
function getAnonymousWatcherName ( ctx ) { let counter = ctx . __$watch_counter ; if ( ! counter ) { counter = ctx . __$watch_counter = 0 ; } let handler = createAnonymousWatcherName ( counter ) ; ctx . __$watch_counter = counter + 1 ; return handler ; } 
function watchDataChange ( expressOrFunc , callback , options ) { if ( typeof expressOrFunc === 'function' ) { expressOrFunc = this . __addComputedProp ( expressOrFunc ) ; } if ( typeof callback === 'function' ) { let handlerName = getAnonymousWatcherName ( this ) ; this [ handlerName ] = callback ; callback = handlerName ; } return this . __watchDataChange ( expressOrFunc , callback , options ) ; } 
function initJsProcessor ( opts , defaultBabelProcessorName ) { let plugins = ( opts && opts . plugins ) || [ jsPlugin ] ; registerProcessor ( { name : ( opts && opts . processor ) || defaultBabelProcessorName , 
function initTplProcessor ( opts ) { registerProcessor ( { name : 'wxml2swan' , 
function initStyleProcessor ( opts ) { registerProcessor ( { name : 'wxss2css' , 
function initWxsProcessor ( opts , defaultBabelProcessorName ) { registerProcessor ( { name : 'wxs2filter' , processor ( file , options ) { let content = file . content . toString ( ) ; return { content : wxs2filter ( content ) } ; } , extnames : [ 'wxs' ] , rext : 'filter.js' } ) ; } 
function initProcessor ( options = { } , defaultBabelProcessorName ) { let { js , css , tpl , wxs } = options ; if ( tpl !== false ) { initTplProcessor ( tpl ) ; } if ( css !== false ) { initStyleProcessor ( css ) ; } if ( js !== false ) { initJsProcessor ( js , defaultBabelProcessorName ) ; } if ( wxs !== false ) { initWxsProcessor ( js , defaultBabelProcessorName ) ; } } 
function process ( file , options ) { let content = file . content . toString ( ) ; let { config : rules , logger } = options ; let result = content ; try { result = doReplacement ( content , rules || [ ] , file ) ; } catch ( ex ) { let tip ; if ( ex === 'devServer' ) { tip = ', please execute `npm run dev:server` script or start with `--server` option' ; } logger . error ( 'unknown replacement variable:' , ex + ( tip || '' ) ) ; } return { content : result } ; } 
function transformNumberToArray ( newValue ) { newValue = newValue . trim ( ) ; const wordArray = newValue . split ( ' ' ) ; const number = wordArray [ wordArray . length - 1 ] ; const arr = [ ] ; if ( / ^\d+$ / . test ( number ) ) { for ( let i = 1 ; i < + number + 1 ; i ++ ) { arr . push ( i ) ; } newValue = newValue . replace ( number , ` ${ arr } ` ) ; } return newValue ; } 
function transformOfToIn ( newValue ) { const wordArray = newValue . trim ( ) . split ( ' ' ) ; const index = wordArray . indexOf ( 'of' ) ; if ( index !== - 1 && ! wordArray . includes ( 'in' ) ) { wordArray [ index ] = 'in' ; newValue = wordArray . join ( ' ' ) ; } return newValue ; } 
function removeBraces ( value ) { 
function convertMediaQueryToJSExpression ( tokens , allAppTypes , appType ) { let result = [ ] ; tokens . forEach ( item => { item = item . trim ( ) ; if ( allAppTypes . includes ( item ) ) { result . push ( ` ${ item } ${ appType } ` ) ; } else if ( item === 'and' ) { result . push ( '&&' ) ; } else if ( item === ',' || item === 'or' ) { result . push ( '||' ) ; } else if ( item === 'not' ) { result . push ( '!' ) ; } else if ( item === '(' || item === ')' ) { result . push ( item ) ; } } ) ; let lastItem = result [ result . length - 1 ] ; if ( lastItem === '&&' || lastItem === '||' ) { result . pop ( ) ; } 
function isAppMediaMatch ( params , tokens , allAppTypes , appType ) { let expression = convertMediaQueryToJSExpression ( tokens , allAppTypes , appType ) ; try { return { value : eval ( expression ) , expression } ; } catch ( ex ) { throw new Error ( 'illegal style env media rule:' + params ) ; } } 
function normalizeAppMediaQueryTokens ( tokens ) { for ( let i = tokens . length - 1 ; i >= 0 ; i -- ) { let item = tokens [ i ] . trim ( ) ; if ( item && item !== '(' ) { break ; } tokens . pop ( ) ; } } 
function initAppMediaTargetInfo ( ctx , currToken ) { let { allAppTypes , hasAppMediaType } = ctx ; let isAppMediaTarget = allAppTypes . includes ( currToken ) ; hasAppMediaType || ( ctx . hasAppMediaType = isAppMediaTarget ) ; if ( ! isAppMediaTarget && ! MEDIA_QUERY_OPERATORS . includes ( currToken ) ) { return true ; } return false ; } 
function initAppMediaQueryToken ( ctx , buffer , separator ) { let currToken = buffer . trim ( ) ; let { tokens } = ctx ; if ( currToken ) { if ( initAppMediaTargetInfo ( ctx , currToken ) ) { return true ; } tokens . push ( buffer ) ; tokens . push ( separator ) ; return '' ; } buffer += separator ; if ( buffer . trim ( ) ) { tokens . push ( buffer ) ; return '' ; } return buffer ; } 
function parseAppMediaQueryParam ( allAppTypes , params ) { let ctx = { allAppTypes , hasAppMediaType : false , tokens : [ ] } ; let buffer = '' ; for ( let i = 0 , len = params . length ; i < len ; i ++ ) { let c = params [ i ] ; if ( QUERY_PARAMS_SEPARATORS . includes ( c ) ) { buffer = initAppMediaQueryToken ( ctx , buffer , c ) ; if ( buffer === true ) { buffer = '' ; break ; } } else { buffer += c ; } } if ( buffer ) { let result = initAppMediaTargetInfo ( ctx , buffer . trim ( ) ) ; result || ( ctx . tokens . push ( buffer ) ) ; } return ctx ; } 
function compilePug ( file , options ) { let content = file . content . toString ( ) ; 
function initJsProcessor ( opts , defaultBabelProcessorName ) { let plugins = ( opts && opts . plugins ) || [ adapterPlugin ] ; registerProcessor ( { name : ( opts && opts . processor ) || defaultBabelProcessorName , 
function initProcessor ( options = { } , defaultBabelProcessorName ) { let { js } = options ; if ( js !== false ) { initJsProcessor ( js , defaultBabelProcessorName ) ; } } 
function arrToMap ( arr ) { return arr . reduce ( ( prev , curr ) => { prev [ curr ] = true ; return prev ; } , { } ) ; } 
function sizeToValueAndUnits ( sizeValue ) { var sizeUnits = 0 ; if ( sizeValue ) { for ( sizeUnits = 0 ; sizeUnits < 4 && parseInt ( sizeValue / 1024 , 10 ) * 1024 === sizeValue ; sizeUnits += 1 ) { sizeValue /= 1024 ; } } else { sizeValue = '' ; } return { sizeUnits : sizeUnits , sizeValue : sizeValue } ; } 
function valueAndUnitsToSize ( sizeValue , sizeUnits ) { var sizeBytes = sizeValue ; var match , i , suffixes = 'bkMGT' ; if ( parseFloat ( sizeValue ) > 0 ) { sizeBytes = parseFloat ( sizeValue ) ; match = sizeValue . match ( new RegExp ( '^\\s*[0-9.]+\\s*([' + suffixes + '])' , 'i' ) ) ; if ( match && match . length > 1 ) { for ( sizeUnits = 0 ; sizeUnits < suffixes . length ; sizeUnits += 1 ) { if ( match [ 1 ] . toLowerCase ( ) === suffixes [ sizeUnits ] . toLowerCase ( ) ) { break ; } } } for ( i = 0 ; i < parseInt ( sizeUnits , 10 ) ; i += 1 ) { sizeBytes *= 1024 ; } sizeBytes = parseInt ( sizeBytes , 10 ) ; } return sizeBytes ; } 
function confirm ( params ) { params = _ . extend ( { text : 'Are you sure?' , yesText : 'Yes' , yesClass : 'btn-danger' , noText : 'Cancel' , escapedHtml : false , msgConfirmation : false , additionalText : '' , name : '' } , params ) ; $ ( '#g-dialog-container' ) . html ( ConfirmDialogTemplate ( { params : params } ) ) . girderModal ( false ) . one ( 'hidden.bs.modal' , function ( ) { $ ( '#g-confirm-button' ) . off ( 'click' ) ; } ) ; const el = $ ( '#g-dialog-container' ) . find ( '.modal-body>p:first-child' ) ; if ( params . escapedHtml ) { el . html ( params . text ) ; } else { el . text ( params . text ) ; } if ( params [ 'msgConfirmation' ] ) { if ( params . escapedHtml ) { $ ( '.g-additional-text' ) . html ( params . additionalText ) ; } else { $ ( '.g-additional-text' ) . text ( params . additionalText ) ; } } $ ( '#g-confirm-button' ) . off ( 'click' ) . click ( function ( ) { if ( params [ 'msgConfirmation' ] ) { const key = ` ${ params . yesText . toUpperCase ( ) } ${ params . name } ` ; const msg = $ ( '#g-confirm-text' ) . val ( ) ; if ( msg . toUpperCase ( ) === key . toUpperCase ( ) ) { $ ( '#g-dialog-container' ) . modal ( 'hide' ) ; params . confirmCallback ( ) ; } else if ( msg . toUpperCase ( ) === '' ) { $ ( '.g-msg-error' ) . html ( ` ${ key } ` ) ; $ ( '.g-msg-error' ) . css ( 'color' , 'red' ) ; } else { $ ( '.g-msg-error' ) . html ( ` ${ msg } ${ key } ` ) ; $ ( '.g-msg-error' ) . css ( 'color' , 'red' ) ; } } else { $ ( '#g-dialog-container' ) . modal ( 'hide' ) ; params . confirmCallback ( ) ; } } ) ; } 
function login ( username , password , cors = corsAuth , otpToken = null ) { var auth = 'Basic ' + window . btoa ( username + ':' + password ) ; const headers = { 'Authorization' : auth } ; if ( _ . isString ( otpToken ) ) { 
function wrap ( obj , funcName , wrapper ) { obj . prototype [ funcName ] = _ . wrap ( obj . prototype [ funcName ] , wrapper ) ; } 
function ( opts ) { opts = opts || { } ; const defaults = { 
function numberOutstandingRestRequests ( category ) { if ( category ) { return _ . filter ( restXhrPool , function ( xhr ) { return xhr . girder && xhr . girder [ category ] ; } ) . length ; } return _ . size ( restXhrPool ) ; } 
function cancelRestRequests ( category ) { _ . each ( restXhrPool , function ( xhr ) { if ( category && ( ! xhr . girder || ! xhr . girder [ category ] ) ) { return ; } if ( xhr . abort ) { xhr . abort ( ) ; } } ) ; } 
function sortTasks ( obj ) { var nodes = _ . keys ( obj ) ; var edges = _ ( obj ) . chain ( ) . pairs ( ) . map ( function ( o ) { return _ . map ( o [ 1 ] . dependencies || [ ] , function ( d ) { return [ d , o [ 0 ] ] ; } ) ; } ) . flatten ( true ) . value ( ) ; var sorted = toposort . array ( nodes , edges ) ; return sorted ; } 
function sortOperations ( op1 , op2 ) { var pathCmp = op1 . path . localeCompare ( op2 . path ) ; if ( pathCmp !== 0 ) { return pathCmp ; } var index1 = methodOrder . indexOf ( op1 . method ) ; var index2 = methodOrder . indexOf ( op2 . method ) ; if ( index1 > - 1 && index2 > - 1 ) { return index1 > index2 ? 1 : ( index1 < index2 ? - 1 : 0 ) ; } if ( index1 > - 1 ) { return - 1 ; } if ( index2 > - 1 ) { return 1 ; } return op1 . method . localeCompare ( op2 . method ) ; } 
function EventStream ( settings ) { const defaults = { timeout : null , streamPath : '/notification/stream' } ; 
function formatDate ( datestr , resolution ) { datestr = datestr . replace ( ' ' , 'T' ) ; 
function formatSize ( sizeBytes ) { if ( sizeBytes < 1024 ) { return sizeBytes + ' B' ; } var i , sizeVal = sizeBytes , precision = 1 ; for ( i = 0 ; sizeVal >= 1024 ; i += 1 ) { sizeVal /= 1024 ; } 
function formatCount ( n , opts ) { n = n || 0 ; opts = opts || { } ; var i = 0 , base = opts . base || 1000 , sep = opts . sep || '' , maxLen = opts . maxLen || 3 , precision = maxLen - 1 ; for ( ; n > base ; i += 1 ) { n /= base ; } if ( ! i ) { precision = 0 ; } else if ( n > 100 ) { precision -= 2 ; } else if ( n > 10 ) { precision -= 1 ; } return n . toFixed ( Math . max ( 0 , precision ) ) + sep + [ '' , 'k' , 'M' , 'G' , 'T' ] [ Math . min ( i , 4 ) ] ; } 
function localeComparator ( model1 , model2 ) { var a1 = model1 . get ( this . sortField ) , a2 = model2 . get ( this . sortField ) ; if ( a1 !== undefined && a1 . localeCompare ) { var result = a1 . localeCompare ( a2 ) * this . sortDir ; if ( result || ! this . secondarySortField ) { return result ; } a1 = model1 . get ( this . secondarySortField ) ; a2 = model2 . get ( this . secondarySortField ) ; return a1 . localeCompare ( a2 ) * this . sortDir ; } return a1 > a2 ? this . sortDir : ( a1 < a2 ? - this . sortDir : 0 ) ; } 
function localeSort ( a1 , a2 ) { if ( a1 !== undefined && a1 . localeCompare ) { return a1 . localeCompare ( a2 ) ; } return a1 > a2 ? 1 : ( a1 < a2 ? - 1 : 0 ) ; } 
function defineFlags ( options , allOption ) { var i = 0 , obj = { } ; if ( allOption ) { obj [ allOption ] = 1 ; } _ . each ( options , function ( opt ) { obj [ opt ] = 1 << i ; if ( allOption ) { obj [ allOption ] |= obj [ opt ] ; } i += 1 ; } ) ; return obj ; } 
function Stream ( json ) { var properties = JSON . parse ( json ) ; var hasProp = { } . hasOwnProperty ; var key ; for ( key in properties ) { if ( hasProp . call ( properties , key ) ) { this [ key ] = properties [ key ] ; } } } 
function decodeSessionId ( sessionId ) { var fields ; 
function Archive ( config , properties ) { var hasProp = { } . hasOwnProperty ; var id = properties . id ; var key ; for ( key in properties ) { if ( hasProp . call ( properties , key ) ) { this [ key ] = properties [ key ] ; } } this . stop = function ( callback ) { exports . stopArchive ( config , id , callback ) ; } ; this . delete = function ( callback ) { exports . deleteArchive ( config , id , callback ) ; } ; } 
function Template ( style , fields ) { if ( ! ~ STYLES . indexOf ( style ) ) throw new Error ( "Unsupported pass style " + style ) ; this . style = style ; this . fields = { } ; for ( var key in fields ) this . fields [ key ] = fields [ key ] ; this . keysPath = "keys" ; this . images = { } ; } 
function Zip ( output ) { this . output = output ; 
function File ( zip , filename , modified ) { this . zip = zip ; this . filename = filename ; this . modified = modified || new Date ( ) ; 
function Pass ( template , fields , images ) { this . template = template ; this . fields = cloneObject ( fields ) ; 
function addFile ( filename ) { var file = zip . addFile ( filename ) ; var sha = new SHAWriteStream ( manifest , filename , file ) ; return sha ; } 
function signManifest ( template , manifest , callback ) { var identifier = template . passTypeIdentifier ( ) . replace ( / ^pass. / , "" ) ; var args = [ "smime" , "-sign" , "-binary" , "-signer" , Path . resolve ( template . keysPath , identifier + ".pem" ) , "-certfile" , Path . resolve ( template . keysPath , "wwdr.pem" ) , "-passin" , "pass:" + template . password ] ; var sign = execFile ( "openssl" , args , { stdio : "pipe" } , function ( error , stdout , stderr ) { var trimmedStderr = stderr . trim ( ) ; 
function cloneObject ( object ) { var clone = { } ; if ( object ) { for ( var key in object ) clone [ key ] = object [ key ] ; } return clone ; } 
function SHAWriteStream ( manifest , filename , output ) { this . output = output ; this . manifest = manifest ; this . filename = filename ; this . sha = Crypto . createHash ( "sha1" ) ; output . on ( "close" , this . emit . bind ( this , "close" ) ) ; output . on ( "error" , this . emit . bind ( this , "error" ) ) ; } 
function nanoRemainder ( msFloat ) { var modulo = 1e6 ; var remainder = ( msFloat * 1e6 ) % modulo ; var positiveRemainder = remainder < 0 ? remainder + modulo : remainder ; return Math . floor ( positiveRemainder ) ; } 
function getEpoch ( epoch ) { if ( ! epoch ) { return 0 ; } if ( typeof epoch . getTime === "function" ) { return epoch . getTime ( ) ; } if ( typeof epoch === "number" ) { return epoch ; } throw new TypeError ( "now should be milliseconds since UNIX epoch" ) ; } 
function compareTimers ( a , b ) { 
async function boot ( ) { 
async function boot ( ) { 
function ( naptime ) { var sleeping = true var now = new Date ( ) var alarm var startingMSeconds = now . getTime ( ) while ( sleeping ) { alarm = new Date ( ) var alarmMSeconds = alarm . getTime ( ) if ( alarmMSeconds - startingMSeconds > naptime ) { sleeping = false } } } 
async function boot ( ) { 
async function tryShutdown ( ) { if ( jobsToComplete === 0 ) { await new Promise ( ( resolve ) => { setTimeout ( resolve , 500 ) } ) await worker . end ( ) process . exit ( ) } } 
function transformMatchCall ( context : ConversionContext , path : NodePath ) { 
function transformPatternCall ( context : ConversionContext , path : NodePath ) { const args = path . get ( 'arguments' ) ; const collected = collectClauses ( context , args ) ; if ( ! collected ) { return ; } const [ collectedParams , collectedBlocks , errorClause ] = collected ; const pattern = makePattern ( context , path , collectedParams , collectedBlocks , errorClause ) ; if ( pattern ) { context . replacePath ( path , pattern ) ; } } 
function hasTypeAnnotation ( path : NodePath ) : boolean { if ( ! path . node ) { return false ; } else if ( path . node . typeAnnotation ) { return true ; } else if ( path . isAssignmentPattern ( ) ) { return hasTypeAnnotation ( path . get ( 'left' ) ) ; } else { return false ; } } 
function ensureConstructor ( path : NodePath ) { let lastProperty ; const [ existing ] = path . get ( 'body.body' ) . filter ( item => { if ( item . isClassProperty ( ) ) { lastProperty = item ; return false ; } return item . node . kind === 'constructor' ; } ) ; if ( existing ) { return existing ; } let constructorNode ; if ( path . has ( 'superClass' ) ) { const args = t . identifier ( 'args' ) ; constructorNode = t . classMethod ( 'constructor' , t . identifier ( 'constructor' ) , [ t . restElement ( args ) ] , t . blockStatement ( [ t . expressionStatement ( t . callExpression ( t . super ( ) , [ t . spreadElement ( args ) ] ) ) ] ) ) ; } else { constructorNode = t . classMethod ( 'constructor' , t . identifier ( 'constructor' ) , [ ] , t . blockStatement ( [ ] ) ) ; } if ( lastProperty ) { lastProperty . insertAfter ( constructorNode ) ; } else { path . get ( 'body' ) . unshiftContainer ( 'body' , constructorNode ) ; } } 
function getFunctionInnerChecks ( context : ConversionContext , path : NodePath , returnType : NodePath ) : ? Array < ? Node > { if ( ! path . node . async && ! path . node . generator ) { return ; } if ( ! returnType . isGenericTypeAnnotation ( ) ) { return ; } const returnTypeParameters = getTypeParameters ( returnType ) ; const id = returnType . get ( 'id' ) ; const name = id . node . name ; if ( returnTypeParameters . length === 0 ) { 
function ( itemData ) { var newItems = this . items . concat ( itemData ) , 
function ( newHeight , widowLayoutStyle ) { var itemWidthSum = this . left , rowWidthWithoutSpacing = this . width - ( this . items . length - 1 ) * this . spacing , clampedToNativeRatio , clampedHeight , errorWidthPerItem , roundedCumulativeErrors , singleItemGeometry , centerOffset ; 
function createNewRow ( layoutConfig , layoutData ) { var isBreakoutRow ; 
function addRow ( layoutConfig , layoutData , row ) { layoutData . _rows . push ( row ) ; layoutData . _layoutItems = layoutData . _layoutItems . concat ( row . getItems ( ) ) ; 
function computeLayout ( layoutConfig , layoutData , itemLayoutData ) { var laidOutItems = [ ] , itemAdded , currentRow , nextToLastRowHeight ; 
function ( path , strategy ) { if ( typeof path !== 'string' ) { throw new Error ( 'path should be a string' ) ; } if ( ! util . isFolder ( path ) ) { throw new Error ( 'path should be a folder' ) ; } if ( this . _remoteStorage && this . _remoteStorage . access && ! this . _remoteStorage . access . checkPathPermission ( path , 'r' ) ) { throw new Error ( 'No access to path "' + path + '". You have to claim access to it first.' ) ; } if ( ! strategy . match ( / ^(FLUSH|SEEN|ALL)$ / ) ) { throw new Error ( "strategy should be 'FLUSH', 'SEEN', or 'ALL'" ) ; } this . _rootPaths [ path ] = strategy ; if ( strategy === 'ALL' ) { if ( this . activateHandler ) { this . activateHandler ( path ) ; } else { this . pendingActivations . push ( path ) ; } } } 
function ( cb ) { var i ; log ( '[Caching] Setting activate handler' , cb , this . pendingActivations ) ; this . activateHandler = cb ; for ( i = 0 ; i < this . pendingActivations . length ; i ++ ) { cb ( this . pendingActivations [ i ] ) ; } delete this . pendingActivations ; } 
function ( path ) { if ( this . _rootPaths [ path ] !== undefined ) { return this . _rootPaths [ path ] ; } else if ( path === '/' ) { return 'SEEN' ; } else { return this . checkPath ( containingFolder ( path ) ) ; } } 
function ( scope , mode ) { if ( typeof ( scope ) !== 'string' || scope . indexOf ( '/' ) !== - 1 || scope . length === 0 ) { throw new Error ( 'Scope should be a non-empty string without forward slashes' ) ; } if ( ! mode . match ( / ^rw?$ / ) ) { throw new Error ( 'Mode should be either \'r\' or \'rw\'' ) ; } this . _adjustRootPaths ( scope ) ; this . scopeModeMap [ scope ] = mode ; } 
function ( scope ) { var savedMap = { } ; var name ; for ( name in this . scopeModeMap ) { savedMap [ name ] = this . scopeModeMap [ name ] ; } this . reset ( ) ; delete savedMap [ scope ] ; for ( name in savedMap ) { this . set ( name , savedMap [ name ] ) ; } } 
function ( newScope ) { if ( '*' in this . scopeModeMap || newScope === '*' ) { this . rootPaths = [ '/' ] ; } else if ( ! ( newScope in this . scopeModeMap ) ) { this . rootPaths . push ( '/' + newScope + '/' ) ; this . rootPaths . push ( '/public/' + newScope + '/' ) ; } } 
function ( scope ) { if ( scope . name === '*' && this . storageType ) { if ( this . storageType === '2012.04' ) { return '' ; } else if ( this . storageType . match ( / remotestorage-0[01] / ) ) { return 'root' ; } } return scope . name ; } 
function WireClient ( rs ) { this . rs = rs ; this . connected = false ; eventHandling ( this , 'connected' , 'not-connected' ) ; if ( hasLocalStorage ) { const settings = getJSONFromLocalStorage ( SETTINGS_KEY ) ; if ( settings ) { setTimeout ( function ( ) { this . configure ( settings ) ; } . bind ( this ) , 0 ) ; } } this . _revisionCache = { } ; if ( this . connected ) { setTimeout ( this . _emit . bind ( this ) , 0 , 'connected' ) ; } } 
function ( method , uri , token , headers , body , getEtag , fakeRevision ) { if ( ( method === 'PUT' || method === 'DELETE' ) && uri [ uri . length - 1 ] === '/' ) { return Promise . reject ( 'Don\'t ' + method + ' on directories!' ) ; } var revision ; var self = this ; if ( token !== Authorize . IMPLIED_FAKE_TOKEN ) { headers [ 'Authorization' ] = 'Bearer ' + token ; } this . rs . _emit ( 'wire-busy' , { method : method , isFolder : isFolder ( uri ) } ) ; return WireClient . request ( method , uri , { body : body , headers : headers , responseType : 'arraybuffer' } ) . then ( function ( response ) { if ( ! self . online ) { self . online = true ; self . rs . _emit ( 'network-online' ) ; } self . rs . _emit ( 'wire-done' , { method : method , isFolder : isFolder ( uri ) , success : true } ) ; if ( isErrorStatus ( response . status ) ) { log ( '[WireClient] Error response status' , response . status ) ; if ( getEtag ) { revision = stripQuotes ( response . getResponseHeader ( 'ETag' ) ) ; } else { revision = undefined ; } if ( response . status === 401 ) { self . rs . _emit ( 'error' , new Authorize . Unauthorized ( ) ) ; } return Promise . resolve ( { statusCode : response . status , revision : revision } ) ; } else if ( isSuccessStatus ( response . status ) || ( response . status === 200 && method !== 'GET' ) ) { revision = stripQuotes ( response . getResponseHeader ( 'ETag' ) ) ; log ( '[WireClient] Successful request' , revision ) ; return Promise . resolve ( { statusCode : response . status , revision : revision } ) ; } else { var mimeType = response . getResponseHeader ( 'Content-Type' ) ; if ( getEtag ) { revision = stripQuotes ( response . getResponseHeader ( 'ETag' ) ) ; } else { revision = response . status === 200 ? fakeRevision : undefined ; } var charset = determineCharset ( mimeType ) ; if ( shouldBeTreatedAsBinary ( response . response , mimeType ) ) { log ( '[WireClient] Successful request with unknown or binary mime-type' , revision ) ; return Promise . resolve ( { statusCode : response . status , body : response . response , contentType : mimeType , revision : revision } ) ; } else { return getTextFromArrayBuffer ( response . response , charset ) . then ( function ( textContent ) { log ( '[WireClient] Successful request' , revision ) ; return Promise . resolve ( { statusCode : response . status , body : textContent , contentType : mimeType , revision : revision } ) ; } ) ; } } } , function ( error ) { if ( self . online ) { self . online = false ; self . rs . _emit ( 'network-offline' ) ; } self . rs . _emit ( 'wire-done' , { method : method , isFolder : isFolder ( uri ) , success : false } ) ; return Promise . reject ( error ) ; } ) ; } 
function ( path , maxAge , queueGetRequest ) { var self = this ; if ( typeof ( maxAge ) === 'number' ) { return self . getNodes ( pathsFromRoot ( path ) ) . then ( function ( objs ) { var node = getLatest ( objs [ path ] ) ; if ( isOutdated ( objs , maxAge ) ) { return queueGetRequest ( path ) ; } else if ( node ) { return { statusCode : 200 , body : node . body || node . itemsMap , contentType : node . contentType } ; } else { return { statusCode : 404 } ; } } ) ; } else { return self . getNodes ( [ path ] ) . then ( function ( objs ) { var node = getLatest ( objs [ path ] ) ; if ( node ) { if ( isFolder ( path ) ) { for ( var i in node . itemsMap ) { 
function metaTitleFromFileName ( filename ) { if ( filename . substr ( - 1 ) === '/' ) { filename = filename . substr ( 0 , filename . length - 1 ) ; } return decodeURIComponent ( filename ) ; } 
function baseName ( path ) { const parts = path . split ( '/' ) ; if ( path . substr ( - 1 ) === '/' ) { return parts [ parts . length - 2 ] + '/' ; } else { return parts [ parts . length - 1 ] ; } } 
function ( ) { this . rs . setBackend ( 'googledrive' ) ; this . rs . authorize ( { authURL : AUTH_URL , scope : AUTH_SCOPE , clientId : this . clientId } ) ; } 
function ( path , options ) { if ( path . substr ( - 1 ) === '/' ) { return this . _getFolder ( googleDrivePath ( path ) , options ) ; } else { return this . _getFile ( googleDrivePath ( path ) , options ) ; } } 
function ( path , body , contentType , options ) { const fullPath = googleDrivePath ( path ) ; function putDone ( response ) { if ( response . status >= 200 && response . status < 300 ) { const meta = JSON . parse ( response . responseText ) ; const etagWithoutQuotes = removeQuotes ( meta . etag ) ; return Promise . resolve ( { statusCode : 200 , contentType : meta . mimeType , revision : etagWithoutQuotes } ) ; } else if ( response . status === 412 ) { return Promise . resolve ( { statusCode : 412 , revision : 'conflict' } ) ; } else { return Promise . reject ( "PUT failed with status " + response . status + " (" + response . responseText + ")" ) ; } } return this . _getFileId ( fullPath ) . then ( ( id ) => { if ( id ) { if ( options && ( options . ifNoneMatch === '*' ) ) { return putDone ( { status : 412 } ) ; } return this . _updateFile ( id , fullPath , body , contentType , options ) . then ( putDone ) ; } else { return this . _createFile ( fullPath , body , contentType , options ) . then ( putDone ) ; } } ) ; } 
function ( path , options ) { const fullPath = googleDrivePath ( path ) ; return this . _getFileId ( fullPath ) . then ( ( id ) => { if ( ! id ) { 
function ( ) { const url = BASE_URL + '/drive/v2/about?fields=user' ; 
function ( id , path , body , contentType , options ) { const metadata = { mimeType : contentType } ; const headers = { 'Content-Type' : 'application/json; charset=UTF-8' } ; if ( options && options . ifMatch ) { headers [ 'If-Match' ] = '"' + options . ifMatch + '"' ; } return this . _request ( 'PUT' , BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable' , { body : JSON . stringify ( metadata ) , headers : headers } ) . then ( ( response ) => { if ( response . status === 412 ) { return ( response ) ; } else { return this . _request ( 'PUT' , response . getResponseHeader ( 'Location' ) , { body : contentType . match ( / ^application\/json / ) ? JSON . stringify ( body ) : body } ) ; } } ) ; } 
function ( path , body , contentType ) { return this . _getParentId ( path ) . then ( ( parentId ) => { const fileName = baseName ( path ) ; const metadata = { title : metaTitleFromFileName ( fileName ) , mimeType : contentType , parents : [ { kind : "drive#fileLink" , id : parentId } ] } ; return this . _request ( 'POST' , BASE_URL + '/upload/drive/v2/files?uploadType=resumable' , { body : JSON . stringify ( metadata ) , headers : { 'Content-Type' : 'application/json; charset=UTF-8' } } ) . then ( ( response ) => { return this . _request ( 'POST' , response . getResponseHeader ( 'Location' ) , { body : contentType . match ( / ^application\/json / ) ? JSON . stringify ( body ) : body } ) ; } ) ; } ) ; } 
function ( path , options ) { return this . _getFileId ( path ) . then ( ( id ) => { return this . _getMeta ( id ) . then ( ( meta ) => { let etagWithoutQuotes ; if ( typeof ( meta ) === 'object' && typeof ( meta . etag ) === 'string' ) { etagWithoutQuotes = removeQuotes ( meta . etag ) ; } if ( options && options . ifNoneMatch && ( etagWithoutQuotes === options . ifNoneMatch ) ) { return Promise . resolve ( { statusCode : 304 } ) ; } if ( ! meta . downloadUrl ) { if ( meta . exportLinks && meta . exportLinks [ 'text/html' ] ) { 
function ( path ) { return this . _getFileId ( path ) . then ( ( id ) => { let query , fields , data , etagWithoutQuotes , itemsMap ; if ( ! id ) { return Promise . resolve ( { statusCode : 404 } ) ; } query = '\'' + id + '\' in parents' ; fields = 'items(downloadUrl,etag,fileSize,id,mimeType,title)' ; return this . _request ( 'GET' , BASE_URL + '/drive/v2/files?' + 'q=' + encodeURIComponent ( query ) + '&fields=' + encodeURIComponent ( fields ) + '&maxResults=1000' , { } ) . then ( ( response ) => { if ( response . status !== 200 ) { return Promise . reject ( 'request failed or something: ' + response . status ) ; } try { data = JSON . parse ( response . responseText ) ; } catch ( e ) { return Promise . reject ( 'non-JSON response from GoogleDrive' ) ; } itemsMap = { } ; for ( const item of data . items ) { etagWithoutQuotes = removeQuotes ( item . etag ) ; if ( item . mimeType === GD_DIR_MIME_TYPE ) { this . _fileIdCache . set ( path + item . title + '/' , item . id ) ; itemsMap [ item . title + '/' ] = { ETag : etagWithoutQuotes } ; } else { this . _fileIdCache . set ( path + item . title , item . id ) ; itemsMap [ item . title ] = { ETag : etagWithoutQuotes , 'Content-Type' : item . mimeType , 'Content-Length' : item . fileSize } ; } } 
function ( path ) { const foldername = parentPath ( path ) ; return this . _getFileId ( foldername ) . then ( ( parentId ) => { if ( parentId ) { return Promise . resolve ( parentId ) ; } else { return this . _createFolder ( foldername ) ; } } ) ; } 
function ( path ) { return this . _getParentId ( path ) . then ( ( parentId ) => { return this . _request ( 'POST' , BASE_URL + '/drive/v2/files' , { body : JSON . stringify ( { title : metaTitleFromFileName ( baseName ( path ) ) , mimeType : GD_DIR_MIME_TYPE , parents : [ { id : parentId } ] } ) , headers : { 'Content-Type' : 'application/json; charset=UTF-8' } } ) . then ( ( response ) => { const meta = JSON . parse ( response . responseText ) ; return Promise . resolve ( meta . id ) ; } ) ; } ) ; } 
function ( path ) { let id ; if ( path === '/' ) { 
function ( id ) { return this . _request ( 'GET' , BASE_URL + '/drive/v2/files/' + id , { } ) . then ( function ( response ) { if ( response . status === 200 ) { return Promise . resolve ( JSON . parse ( response . responseText ) ) ; } else { return Promise . reject ( "request (getting metadata for " + id + ") failed with status: " + response . status ) ; } } ) ; } 
function ( method , url , options ) { if ( ! options . headers ) { options . headers = { } ; } options . headers [ 'Authorization' ] = 'Bearer ' + this . token ; this . rs . _emit ( 'wire-busy' , { method : method , isFolder : isFolder ( url ) } ) ; return WireClient . request . call ( this , method , url , options ) . then ( ( xhr ) => { 
function unHookGetItemURL ( rs ) { if ( ! rs . _origBaseClientGetItemURL ) { return ; } BaseClient . prototype . getItemURL = rs . _origBaseClientGetItemURL ; delete rs . _origBaseClientGetItemURL ; } 
function ( eventName , handler ) { if ( typeof ( eventName ) !== 'string' ) { throw new Error ( 'Argument eventName should be a string' ) ; } if ( typeof ( handler ) !== 'function' ) { throw new Error ( 'Argument handler should be a function' ) ; } log ( '[Eventhandling] Adding event listener' , eventName ) ; this . _validateEvent ( eventName ) ; this . _handlers [ eventName ] . push ( handler ) ; } 
function ( eventName , handler ) { this . _validateEvent ( eventName ) ; var hl = this . _handlers [ eventName ] . length ; for ( var i = 0 ; i < hl ; i ++ ) { if ( this . _handlers [ eventName ] [ i ] === handler ) { this . _handlers [ eventName ] . splice ( i , 1 ) ; return ; } } } 
function Discover ( userAddress ) { return new Promise ( ( resolve , reject ) => { if ( userAddress in cachedInfo ) { return resolve ( cachedInfo [ userAddress ] ) ; } var webFinger = new WebFinger ( { tls_only : false , uri_fallback : true , request_timeout : 5000 } ) ; return webFinger . lookup ( userAddress , function ( err , response ) { if ( err ) { return reject ( err ) ; } else if ( ( typeof response . idx . links . remotestorage !== 'object' ) || ( typeof response . idx . links . remotestorage . length !== 'number' ) || ( response . idx . links . remotestorage . length <= 0 ) ) { log ( "[Discover] WebFinger record for " + userAddress + " does not have remotestorage defined in the links section " , JSON . stringify ( response . json ) ) ; return reject ( "WebFinger record for " + userAddress + " does not have remotestorage defined in the links section." ) ; } var rs = response . idx . links . remotestorage [ 0 ] ; var authURL = rs . properties [ 'http://tools.ietf.org/html/rfc6749#section-4.2' ] || rs . properties [ 'auth-endpoint' ] ; var storageApi = rs . properties [ 'http://remotestorage.io/spec/version' ] || rs . type ; 
function ( ) { 
function ( settings ) { 
function ( path ) { var url = 'https://api.dropboxapi.com/2/files/list_folder' ; var revCache = this . _revCache ; var self = this ; var processResponse = function ( resp ) { var body , listing ; if ( resp . status !== 200 && resp . status !== 409 ) { return Promise . reject ( 'Unexpected response status: ' + resp . status ) ; } try { body = JSON . parse ( resp . responseText ) ; } catch ( e ) { return Promise . reject ( e ) ; } if ( resp . status === 409 ) { if ( compareApiError ( body , [ 'path' , 'not_found' ] ) ) { 
function ( path , options ) { if ( ! this . connected ) { return Promise . reject ( "not connected (path: " + path + ")" ) ; } var url = 'https://content.dropboxapi.com/2/files/download' ; var self = this ; var savedRev = this . _revCache . get ( path ) ; if ( savedRev === null ) { 
function ( path , body , contentType , options ) { var self = this ; if ( ! this . connected ) { throw new Error ( "not connected (path: " + path + ")" ) ; } 
function ( path , options ) { if ( ! this . connected ) { throw new Error ( "not connected (path: " + path + ")" ) ; } 
function ( path ) { var url = 'https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings' ; var options = { body : { path : getDropboxPath ( path ) } } ; return this . _request ( 'POST' , url , options ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . reject ( new Error ( 'Invalid response status:' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . responseText ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + response . responseText ) ) ; } if ( response . status === 409 ) { if ( compareApiError ( body , [ 'shared_link_already_exists' ] ) ) { return this . _getSharedLink ( path ) ; } return Promise . reject ( new Error ( 'API error: ' + body . error_summary ) ) ; } return Promise . resolve ( body . url ) ; } ) . then ( ( link ) => { this . _itemRefs [ path ] = link ; if ( hasLocalStorage ) { localStorage . setItem ( SETTINGS_KEY + ':shares' , JSON . stringify ( this . _itemRefs ) ) ; } return Promise . resolve ( link ) ; } , ( error ) => { error . message = 'Sharing Dropbox file or folder ("' + path + '") failed: ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function ( ) { var url = 'https://api.dropboxapi.com/2/users/get_current_account' ; return this . _request ( 'POST' , url , { } ) . then ( function ( response ) { var info = response . responseText ; try { info = JSON . parse ( info ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Could not query current account info: Invalid API response: ' + info ) ) ; } return Promise . resolve ( { email : info . email } ) ; } ) ; } 
function ( method , url , options ) { var self = this ; if ( ! options . headers ) { options . headers = { } ; } options . headers [ 'Authorization' ] = 'Bearer ' + this . token ; if ( typeof options . body === 'object' && ! isBinaryData ( options . body ) ) { options . body = JSON . stringify ( options . body ) ; options . headers [ 'Content-Type' ] = 'application/json; charset=UTF-8' ; } this . rs . _emit ( 'wire-busy' , { method : method , isFolder : isFolder ( url ) } ) ; return WireClient . request . call ( this , method , url , options ) . then ( function ( xhr ) { 
function ( ) { 
function ( params ) { var url = 'https://content.dropboxapi.com/2/files/upload' ; var args = { path : getDropboxPath ( params . path ) , mode : { '.tag' : 'overwrite' } , mute : true } ; if ( params . ifMatch ) { args . mode = { '.tag' : 'update' , update : params . ifMatch } ; } return this . _request ( 'POST' , url , { body : params . body , headers : { 'Content-Type' : 'application/octet-stream' , 'Dropbox-API-Arg' : JSON . stringify ( args ) } } ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . resolve ( { statusCode : response . status } ) ; } var body = response . responseText ; try { body = JSON . parse ( body ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid API result: ' + body ) ) ; } if ( response . status === 409 ) { if ( compareApiError ( body , [ 'path' , 'conflict' ] ) ) { return this . _getMetadata ( params . path ) . then ( function ( metadata ) { return Promise . resolve ( { statusCode : 412 , revision : metadata . rev } ) ; } ) ; } return Promise . reject ( new Error ( 'API error: ' + body . error_summary ) ) ; } this . _revCache . set ( params . path , body . rev ) ; return Promise . resolve ( { statusCode : response . status , revision : body . rev } ) ; } ) ; } 
function ( path ) { const url = 'https://api.dropboxapi.com/2/files/delete' ; const requestBody = { path : getDropboxPath ( path ) } ; return this . _request ( 'POST' , url , { body : requestBody } ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . resolve ( { statusCode : response . status } ) ; } var responseBody = response . responseText ; try { responseBody = JSON . parse ( responseBody ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + responseBody ) ) ; } if ( response . status === 409 ) { if ( compareApiError ( responseBody , [ 'path_lookup' , 'not_found' ] ) ) { return Promise . resolve ( { statusCode : 404 } ) ; } return Promise . reject ( new Error ( 'API error: ' + responseBody . error_summary ) ) ; } return Promise . resolve ( { statusCode : 200 } ) ; } ) . then ( ( result ) => { if ( result . statusCode === 200 || result . statusCode === 404 ) { this . _revCache . delete ( path ) ; delete this . _itemRefs [ path ] ; } return Promise . resolve ( result ) ; } , ( error ) => { error . message = 'Could not delete Dropbox file or folder ("' + path + '"): ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function ( path ) { var url = 'https://api.dropbox.com/2/sharing/list_shared_links' ; var options = { body : { path : getDropboxPath ( path ) , direct_only : true } } ; return this . _request ( 'POST' , url , options ) . then ( ( response ) => { if ( response . status !== 200 && response . status !== 409 ) { return Promise . reject ( new Error ( 'Invalid response status: ' + response . status ) ) ; } var body ; try { body = JSON . parse ( response . responseText ) ; } catch ( e ) { return Promise . reject ( new Error ( 'Invalid response body: ' + response . responseText ) ) ; } if ( response . status === 409 ) { return Promise . reject ( new Error ( 'API error: ' + response . error_summary ) ) ; } if ( ! body . links . length ) { return Promise . reject ( new Error ( 'No links returned' ) ) ; } return Promise . resolve ( body . links [ 0 ] . url ) ; } , ( error ) => { error . message = 'Could not get link to a shared file or folder ("' + path + '"): ' + error . message ; return Promise . reject ( error ) ; } ) ; } 
function hookSync ( rs ) { if ( rs . _dropboxOrigSync ) { return ; } 
function unHookSync ( rs ) { if ( ! rs . _dropboxOrigSync ) { return ; } 
function hookSyncCycle ( rs ) { if ( rs . _dropboxOrigSyncCycle ) { return ; } 
function unHookSyncCycle ( rs ) { if ( ! rs . _dropboxOrigSyncCycle ) { return ; } 
function hookGetItemURL ( rs ) { if ( rs . _origBaseClientGetItemURL ) { return ; } rs . _origBaseClientGetItemURL = BaseClient . prototype . getItemURL ; BaseClient . prototype . getItemURL = function ( ) { throw new Error ( 'getItemURL is not implemented for Dropbox yet' ) ; } ; } 
function hookRemote ( rs ) { if ( rs . _origRemote ) { return ; } rs . _origRemote = rs . remote ; rs . remote = rs . dropbox ; } 
function unHookRemote ( rs ) { if ( rs . _origRemote ) { rs . remote = rs . _origRemote ; delete rs . _origRemote ; } } 
function hookIt ( rs ) { hookRemote ( rs ) ; if ( rs . sync ) { hookSync ( rs ) ; } else { 
function unHookIt ( rs ) { unHookRemote ( rs ) ; unHookSync ( rs ) ; unHookGetItemURL ( rs ) ; unHookSyncCycle ( rs ) ; } 
function ( paths ) { var misses = [ ] , fromCache = { } ; for ( let i = 0 , len = paths . length ; i < len ; i ++ ) { if ( this . changesQueued [ paths [ i ] ] !== undefined ) { fromCache [ paths [ i ] ] = util . deepClone ( this . changesQueued [ paths [ i ] ] || undefined ) ; } else if ( this . changesRunning [ paths [ i ] ] !== undefined ) { fromCache [ paths [ i ] ] = util . deepClone ( this . changesRunning [ paths [ i ] ] || undefined ) ; } else { misses . push ( paths [ i ] ) ; } } if ( misses . length > 0 ) { return this . getNodesFromDb ( misses ) . then ( function ( nodes ) { for ( let i in fromCache ) { nodes [ i ] = fromCache [ i ] ; } return nodes ; } ) ; } else { return Promise . resolve ( fromCache ) ; } } 
function ( nodes ) { for ( var i in nodes ) { this . changesQueued [ i ] = nodes [ i ] || false ; } this . maybeFlush ( ) ; return Promise . resolve ( ) ; } 
function ( ) { if ( this . commitSlownessWarning ) { clearInterval ( this . commitSlownessWarning ) ; this . commitSlownessWarning = null ; } if ( Object . keys ( this . changesQueued ) . length > 0 ) { this . changesRunning = this . changesQueued ; this . changesQueued = { } ; this . setNodesInDb ( this . changesRunning ) . then ( this . flushChangesQueued . bind ( this ) ) ; } } 
function ( paths ) { return new Promise ( ( resolve , reject ) => { let transaction = this . db . transaction ( [ 'nodes' ] , 'readonly' ) ; let nodes = transaction . objectStore ( 'nodes' ) ; let retrievedNodes = { } ; this . getsRunning ++ ; paths . map ( function ( path ) { nodes . get ( path ) . onsuccess = function ( evt ) { retrievedNodes [ path ] = evt . target . result ; } ; } ) ; transaction . oncomplete = function ( ) { resolve ( retrievedNodes ) ; this . getsRunning -- ; } . bind ( this ) ; transaction . onerror = transaction . onabort = function ( ) { reject ( 'get transaction error/abort' ) ; this . getsRunning -- ; } . bind ( this ) ; } ) ; } 
function ( nodes ) { return new Promise ( ( resolve , reject ) => { let transaction = this . db . transaction ( [ 'nodes' ] , 'readwrite' ) ; let nodesStore = transaction . objectStore ( 'nodes' ) ; let startTime = new Date ( ) . getTime ( ) ; this . putsRunning ++ ; log ( '[IndexedDB] Starting put' , nodes , this . putsRunning ) ; for ( var path in nodes ) { var node = nodes [ path ] ; if ( typeof ( node ) === 'object' ) { try { nodesStore . put ( node ) ; } catch ( e ) { log ( '[IndexedDB] Error while putting' , node , e ) ; throw e ; } } else { try { nodesStore . delete ( path ) ; } catch ( e ) { log ( '[IndexedDB] Error while removing' , nodesStore , node , e ) ; throw e ; } } } transaction . oncomplete = function ( ) { this . putsRunning -- ; log ( '[IndexedDB] Finished put' , nodes , this . putsRunning , ( new Date ( ) . getTime ( ) - startTime ) + 'ms' ) ; resolve ( ) ; } . bind ( this ) ; transaction . onerror = function ( ) { this . putsRunning -- ; reject ( 'transaction error' ) ; } . bind ( this ) ; transaction . onabort = function ( ) { reject ( 'transaction abort' ) ; this . putsRunning -- ; } . bind ( this ) ; } ) ; } 
function ( callback ) { let dbName = this . db . name ; this . db . close ( ) ; IndexedDB . clean ( this . db . name , ( ) => { IndexedDB . open ( dbName , ( err , other ) => { if ( err ) { log ( '[IndexedDB] Error while resetting local storage' , err ) ; } else { 
function ( cb ) { return new Promise ( ( resolve ) => { let transaction = this . db . transaction ( [ 'nodes' ] , 'readonly' ) ; let cursorReq = transaction . objectStore ( 'nodes' ) . openCursor ( ) ; cursorReq . onsuccess = ( evt ) => { let cursor = evt . target . result ; if ( cursor ) { cb ( this . migrate ( cursor . value ) ) ; cursor . continue ( ) ; } else { resolve ( ) ; } } ; } ) ; } 
function extractFeatures ( chunk ) { 
function ( ) { this . varName = "" ; this . type = "" ; this . options = { } ; this . next = null ; this . head = null ; this . compiled = null ; this . endian = "be" ; this . constructorFn = null ; this . alias = null ; } 
function ( ) { return { '/' : { page : '/' } , '/install' : { page : '/install' } , '/design-assets' : { page : '/design-assets' } , '/contribute' : { page : '/contribute' } , '/contribute/code' : { page : '/contribute/code' } , '/contribute/components' : { page : '/contribute/components' } , '/roadmap' : { page : '/roadmap' } , '/components/actionmenu' : { page : '/components/actionmenu' } , '/components/avatar' : { page : '/components/avatar' } , '/components/badge' : { page : '/components/badge' } , '/components/banner' : { page : '/components/banner' } , '/components/breadcrumb' : { page : '/components/breadcrumb' } , '/components/button' : { page : '/components/button' } , '/components/card' : { page : '/components/card' } , '/components/checkbox' : { page : '/components/checkbox' } , '/components/circularprogress' : { page : '/components/circularprogress' } , '/components/code' : { page : '/components/code' } , '/components/datepicker' : { page : '/components/datepicker' } , '/components/dialog' : { page : '/components/dialog' } , '/components/dialog-modal-example' : { page : '/components/dialog-modal-example' } , '/components/drawer' : { page : '/components/drawer' } , '/components/dropdown' : { page : '/components/dropdown' } , '/components/emptystate' : { page : '/components/emptystate' } , '/components/errors' : { page : '/components/errors' } , '/components/form' : { page : '/components/form' } , '/components/icon' : { page : '/components/icon' } , '/components/layout' : { page : '/components/layout' } , '/components/linearprogress' : { page : '/components/linearprogress' } , '/components/link' : { page : '/components/link' } , '/components/radio' : { page : '/components/radio' } , '/components/row' : { page : '/components/row' } , '/components/starrating' : { page : '/components/starrating' } , '/components/switch' : { page : '/components/switch' } , '/components/tab' : { page : '/components/tab' } , '/components/table' : { page : '/components/table' } , '/components/tag' : { page : '/components/tag' } , '/components/text' : { page : '/components/text' } , '/components/textarea' : { page : '/components/textarea' } , '/components/textinput' : { page : '/components/textinput' } , '/components/theme' : { page : '/components/theme' } , '/components/tooltip' : { page : '/components/tooltip' } , '/components/viewtoggle' : { page : '/components/viewtoggle' } , '/core/build' : { page : '/core/build' } , '/core/usage' : { page : '/core/usage' } , '/core/color' : { page : '/core/color' } , '/core/motion' : { page : '/core/motion' } , '/core/spacing' : { page : '/core/spacing' } , '/core/typography' : { page : '/core/typography' } , '/patterns/iconography' : { page : '/patterns/iconography' } , '/patterns/voice-tone' : { page : '/patterns/voice-tone' } } } 
function getIdFromURL ( url ) { var id = url . replace ( youtubeRegexp , '$1' ) ; if ( id . includes ( ';' ) ) { var pieces = id . split ( ';' ) ; if ( pieces [ 1 ] . includes ( '%' ) ) { var uriComponent = decodeURIComponent ( pieces [ 1 ] ) ; id = ( "http://youtube.com" + uriComponent ) . replace ( youtubeRegexp , '$1' ) ; } else { id = pieces [ 0 ] ; } } else if ( id . includes ( '#' ) ) { id = id . split ( '#' ) [ 0 ] ; } return id } 
function getTimeFromURL ( url ) { if ( url === void 0 ) url = '' ; var times = url . match ( timeRegexp ) ; if ( ! times ) { return 0 } var full = times [ 0 ] ; var minutes = times [ 1 ] ; var seconds = times [ 2 ] ; if ( typeof seconds !== 'undefined' ) { seconds = parseInt ( seconds , 10 ) ; minutes = parseInt ( minutes , 10 ) ; } else if ( full . includes ( 'm' ) ) { minutes = parseInt ( minutes , 10 ) ; seconds = 0 ; } else { seconds = parseInt ( minutes , 10 ) ; minutes = 0 ; } return seconds + ( minutes * 60 ) } 
function onTablesSelected ( tables ) { 
function onTableDataCollected ( err , data ) { bailOnError ( err ) ; var tableName , models = { } , model ; for ( tableName in data . tableStructure ) { model = steps . tableToObject ( { name : tableName , columns : data . tableStructure [ tableName ] , comment : data . tableComments [ tableName ] } , opts ) ; models [ model . name ] = model ; } data . models = steps . findReferences ( models ) ; 
function onDataOutput ( ) { if ( ! opts . outputDir ) { return ; } if ( opts . interactive ) { console . log ( '\n\n\n' ) ; } var dir = path . resolve ( opts . outputDir ) ; console . log ( 'Demo app generated in ' + dir + '. To run:' ) ; console . log ( 'cd ' + dir ) ; console . log ( 'npm install' ) ; console . log ( 'npm start' ) ; console . log ( ) ; console . log ( 'Then point your browser at http://localhost:3000' ) ; } 
function getOffset ( cursor , defaultOffset ) { if ( typeof cursor === 'undefined' || cursor === null ) { return defaultOffset ; } let offset = cursorToOffset ( cursor ) ; if ( isNaN ( offset ) ) { return defaultOffset ; } return offset ; } 
function importSpecifier ( name , def ) { return { type : def === true ? 'ImportDefaultSpecifier' : 'ImportSpecifier' , id : { type : 'Identifier' , name : name } , name : null } ; } 
function ruleCodes ( flags , value ) { var flag = flags . FLAG var result = [ ] var length var index if ( ! value ) { return result } if ( flag === 'long' ) { index = 0 length = value . length while ( index < length ) { result . push ( value . substr ( index , 2 ) ) index += 2 } return result } return value . split ( flag === 'num' ? ',' : '' ) } 
function affix ( aff ) { var rules = { } var replacementTable = [ ] var conversion = { in : [ ] , out : [ ] } var compoundRuleCodes = { } var lines = [ ] var flags = { } var compoundRules = [ ] var index var length var parts var line var ruleType var entries var count var remove var add var source var entry var ruleLength var position var rule var last var value var offset var character flags [ keyType ] = [ ] 
function add ( buf ) { var self = this var flags = self . flags var lines = buf . toString ( 'utf8' ) . split ( '\n' ) var length = lines . length var index = - 1 var line var forbidden var word var model var flag 
function suggest ( value ) { var self = this var replacementTable = self . replacementTable var conversion = self . conversion var groups = self . flags . KEY var suggestions = [ ] var weighted = { } var memory var replacement var edits = [ ] var values var index var length var offset var position var count var otherOffset var otherCount var otherCharacter var character var group var before var after var upper var insensitive var firstLevel var prev var next var nextCharacter var max var distance var end var size var normalized var suggestion var currentCase value = normalize ( trim ( value ) , conversion . in ) if ( ! value || self . correct ( value ) ) { return [ ] } currentCase = casing ( value ) 
function generate ( context , memory , words , edits ) { var characters = context . flags . TRY var characterLength = characters . length var data = context . data var flags = context . flags var result = [ ] var upper var length var index var word var position var count var before var after var nextAfter var nextNextAfter var character var nextCharacter var inject var offset 
function check ( value , double ) { var state = memory . state [ value ] var corrected if ( state !== Boolean ( state ) ) { result . push ( value ) corrected = form ( context , value ) state = corrected && ! flag ( flags , noSuggestType , data [ corrected ] ) memory . state [ value ] = state if ( state ) { memory . weighted [ value ] = double ? 10 : 0 memory . suggestions . push ( value ) } } if ( state ) { memory . weighted [ value ] ++ } } 
function add ( word , rules ) { 
function flag ( values , value , flags ) { return flags && own . call ( values , value ) && flags . indexOf ( values [ value ] ) !== - 1 } 
function normalize ( value , patterns ) { var length = patterns . length var index = - 1 var pattern while ( ++ index < length ) { pattern = patterns [ index ] value = value . replace ( pattern [ 0 ] , pattern [ 1 ] ) } return value } 
function form ( context , value , all ) { var dict = context . data var flags = context . flags var alternative value = trim ( value ) if ( ! value ) { return null } value = normalize ( value , context . conversion . in ) if ( exact ( context , value ) ) { if ( ! all && flag ( flags , 'FORBIDDENWORD' , dict [ value ] ) ) { return null } return value } 
function NSpell ( aff , dic ) { var length var index var dictionaries if ( ! ( this instanceof NSpell ) ) { return new NSpell ( aff , dic ) } if ( typeof aff === 'string' || buffer ( aff ) ) { if ( typeof dic === 'string' || buffer ( dic ) ) { dictionaries = [ { dic : dic } ] } } else if ( aff ) { if ( 'length' in aff ) { dictionaries = aff aff = aff [ 0 ] && aff [ 0 ] . aff } else { if ( aff . dic ) { dictionaries = [ aff ] } aff = aff . aff } } if ( ! aff ) { throw new Error ( 'Missing `aff` in dictionary' ) } aff = affix ( aff ) this . data = { } this . compoundRuleCodes = aff . compoundRuleCodes this . replacementTable = aff . replacementTable this . conversion = aff . conversion this . compoundRules = aff . compoundRules this . rules = aff . rules this . flags = aff . flags length = dictionaries ? dictionaries . length : 0 index = - 1 while ( ++ index < length ) { dic = dictionaries [ index ] if ( dic && dic . dic ) { this . dictionary ( dic . dic ) } } } 
function add ( value , model ) { var self = this var dict = self . data var codes = model && own . call ( dict , model ) ? dict [ model ] . concat ( ) : [ ] push ( dict , value , codes , self ) return self } 
function parse ( buf , options , dict ) { var index var last var value 
function parseLine ( line , options , dict ) { var word var codes var result var hashOffset var slashOffset 
function casing ( value ) { var head = exact ( value . charAt ( 0 ) ) var rest = value . slice ( 1 ) if ( ! rest ) { return head } rest = exact ( rest ) if ( head === rest ) { return head } if ( head === 'u' && rest === 'l' ) { return 's' } return null } 
function apply ( value , rule , rules ) { var entries = rule . entries var words = [ ] var index = - 1 var length = entries . length var entry var next var continuationRule var continuation var position var count while ( ++ index < length ) { entry = entries [ index ] if ( ! entry . match || value . match ( entry . match ) ) { next = value if ( entry . remove ) { next = next . replace ( entry . remove , '' ) } if ( rule . type === 'SFX' ) { next += entry . add } else { next = entry . add + next } words . push ( next ) continuation = entry . continuation if ( continuation && continuation . length !== 0 ) { position = - 1 count = continuation . length while ( ++ position < count ) { continuationRule = rules [ continuation [ position ] ] if ( continuationRule ) { words = words . concat ( apply ( next , continuationRule , rules ) ) } } } } } return words } 
function spell ( word ) { var self = this var dict = self . data var flags = self . flags var value = form ( self , word , true ) 
function add ( buf ) { var self = this var compound = self . compoundRules var compoundCodes = self . compoundRuleCodes var index = - 1 var length = compound . length var rule var source var character var offset var count parse ( buf , self , self . data ) 
function exact ( context , value ) { var data = context . data var flags = context . flags var codes = own . call ( data , value ) ? data [ value ] : null var compound var index var length if ( codes ) { return ! flag ( flags , 'ONLYINCOMPOUND' , codes ) } compound = context . compoundRules length = compound . length index = - 1 
function ( entryPath , attributes ) { if ( this . options . templateAdapterInstance ) { this . templateAdapter = this . options . templateAdapterInstance ; } else { var templateAdapterModule = attributes . templateAdapter || this . defaults . templateAdapter , templateAdapterOptions = { entryPath : entryPath } , templateEngine = require ( attributes . templateEngine || this . defaults . templateEngine ) ; templateAdapterOptions = this . setTemplateFinder ( templateAdapterOptions ) ; this . templateAdapter = require ( templateAdapterModule ) ( templateAdapterOptions , templateEngine ) ; } } 
function ( ) { var retVal , parsedOptions ; if ( this . model ) { retVal = this . model . toJSON ( ) ; } else if ( this . collection ) { retVal = { models : this . collection . toJSON ( ) , meta : this . collection . meta , params : this . collection . params } ; } 
function ( data ) { if ( this . app ) { data . _app = this . app ; } if ( this . model ) { data . _model = this . model ; } if ( this . collection ) { data . _collection = this . collection ; } data . _view = this ; return data ; } 
function ( ) { var attributes = { } , fetchSummary = { } , modelUtils = this . app . modelUtils , nonAttributeOptions = this . nonAttributeOptions ; if ( this . attributes ) { _ . extend ( attributes , _ . result ( this , 'attributes' ) ) ; } if ( this . id ) { attributes . id = _ . result ( this , "id" ) ; } if ( this . className ) { attributes [ 'class' ] = _ . result ( this , "className" ) ; } 
function ( ) { var template = this . getTemplate ( ) , data ; this . _preRender ( ) ; data = this . getTemplateData ( ) ; data = this . decorateTemplateData ( data ) ; if ( template == null ) { throw new Error ( this . name + ": template \"" + this . getTemplateName ( ) + "\" not found." ) ; } return template ( data ) ; } 
function ( ) { var html = this . getInnerHtml ( ) , attributes = this . getAttributes ( ) , tagName = _ . result ( this , "tagName" ) , attrString ; attrString = _ . inject ( attributes , function ( memo , value , key ) { return memo += " " + key + "=\"" + _ . escape ( value ) + "\"" ; } , '' ) ; return "<" + tagName + attrString + ">" + html + "</" + tagName + ">" ; } 
function ( ) { var params = { } , fetchOptions , fetchSpec ; if ( this . options . fetch_params ) { if ( ! _ . isObject ( this . options . fetch_params ) ) { throw new Error ( 'fetch_params must be an object for lazy loaded views' ) ; } params = this . options . fetch_params ; } else if ( this . options . param_name ) { params [ this . options . param_name ] = this . options . param_value ; } if ( this . options . fetch_options ) { if ( ! _ . isObject ( this . options . fetch_options ) ) { throw new Error ( 'fetch_options must be an object for lazy loaded views' ) ; } fetchOptions = this . options . fetch_options ; } if ( this . options . model_id != null ) { params . id = this . options . model_id ; } if ( this . options . model_name != null ) { fetchSpec = { model : { model : this . options . model_name , params : params } } ; } else if ( this . options . collection_name != null ) { fetchSpec = { collection : { collection : this . options . collection_name , params : params } } ; } 
function ( callback ) { var _baseView = this ; 
function getAppAttributes ( attrs , req , res ) { if ( typeof attrs === 'function' ) { attrs = attrs ( req , res ) ; } return attrs || { } ; } 
function actionCall ( action , params ) { action . call ( router , params , router . getRenderCallback ( route ) ) ; } 
function ( pattern , controller , options ) { var realAction , action , handler , route , routeObj , routerContext = this ; route = parseRouteDefinitions ( [ controller , options ] ) ; realAction = this . getAction ( route ) ; if ( isServer ) { action = realAction ; } else { action = function ( params , callback ) { var self = this ; var myLoadNumber = ++ loadNumber ; function next ( ) { 
function ( viewPath , locals , route ) { if ( typeof viewPath !== 'string' ) { locals = viewPath ; viewPath = route . controller + '/' + route . action ; } return [ viewPath , locals ] ; } 
function marshalPublicKey ( jwk ) { const byteLen = curveLengths [ jwk . crv ] return Buffer . concat ( [ Buffer . from ( [ 4 ] ) , 
function unmarshalPublicKey ( curve , key ) { const byteLen = curveLengths [ curve ] if ( ! key . slice ( 0 , 1 ) . equals ( Buffer . from ( [ 4 ] ) ) ) { throw new Error ( 'Invalid key format' ) } const x = new BN ( key . slice ( 1 , byteLen + 1 ) ) const y = new BN ( key . slice ( 1 + byteLen ) ) return { kty : 'EC' , crv : curve , x : toBase64 ( x , byteLen ) , y : toBase64 ( y , byteLen ) , ext : true } } 
function pbkdf2 ( password , salt , iterations , keySize , hash ) { const hasher = hashName [ hash ] if ( ! hasher ) { throw new Error ( ` ${ hash } ` ) } const dek = forgePbkdf2 ( password , salt , iterations , keySize , hasher ) return forgeUtil . encode64 ( dek ) } 
function getRawHeader ( _block ) { if ( typeof _block . difficulty !== 'string' ) { _block . difficulty = '0x' + _block . difficulty . toString ( 16 ) } const block = new EthereumBlock ( _block ) return block . header } 
function initMatic ( ) { if ( ! matic ) { matic = new Matic ( { maticProvider : process . env . MATIC_PROVIDER , parentProvider : process . env . PARENT_PROVIDER , rootChainAddress : process . env . ROOTCHAIN_ADDRESS , maticWethAddress : process . env . MATIC_WETH_ADDRESS , syncerUrl : process . env . SYNCER_URL , watcherUrl : process . env . WATCHER_URL , withdrawManagerAddress : process . env . WITHDRAWMANAGER_ADDRESS , } ) matic . wallet = '<private-key>' 
function matchPath ( pathname , options = { } ) { if ( typeof options === 'string' ) options = { path : options } ; const { path , exact = false , strict = false , sensitive = false } = options ; const paths = [ ] . concat ( path ) ; return paths . reduce ( ( matched , p ) => { if ( matched ) return matched ; const { regexp , keys } = compilePath ( p , { end : exact , strict , sensitive } ) ; const match = regexp . exec ( pathname ) ; if ( ! match ) return null ; const [ url , ... values ] = match ; const isExact = pathname === url ; if ( exact && ! isExact ) return null ; return { path : p , 
function generatedReducer ( state = fn . defaultState , action ) { const builtinState = builtinReducer ( state , action , page ) ; if ( builtinState ) return builtinState ; if ( Object . hasOwnProperty . call ( fn , action . type ) && typeof fn [ action . type ] === 'function' ) { return produce ( state , ( draft ) => { try { return fn [ action . type ] ( draft , action ) ; } catch ( e ) { if ( process . env . NODE_ENV !== 'production' ) { throw e ; } console . error ( 'It"s called by rrc-loader-helper:' + e ) ; sendError ( e ) ; return state ; } } ) ; } return state ; } 
function Redirect ( { computedMatch , to , push = false } ) { return ( < RouterContext . Consumer > { ( context ) => { invariant ( context , 'You should not use <Redirect> outside a <Router>' ) ; const { history , staticContext } = context ; const method = push ? history . push : history . replace ; const location = createLocation ( computedMatch ? typeof to === 'string' ? generatePath ( to , computedMatch . params ) : { ... to , pathname : generatePath ( to . pathname , computedMatch . params ) } : to ) ; < / RouterContext . Consumer > ) ; } 
function getEffectLog ( effect ) { let data , log if ( effect . root ) { data = effect . effect log = getLogPrefix ( 'run' , effect ) log . formatter . addCall ( data . saga . name , data . args ) logResult ( effect , log . formatter ) } else if ( data = asEffect . take ( effect . effect ) ) { log = getLogPrefix ( 'take' , effect ) log . formatter . addValue ( data ) logResult ( effect , log . formatter ) } else if ( data = asEffect . put ( effect . effect ) ) { log = getLogPrefix ( 'put' , effect ) logResult ( Object . assign ( { } , effect , { result : data } ) , log . formatter ) } else if ( data = asEffect . call ( effect . effect ) ) { log = getLogPrefix ( 'call' , effect ) log . formatter . addCall ( data . fn . name , data . args ) logResult ( effect , log . formatter ) } else if ( data = asEffect . cps ( effect . effect ) ) { log = getLogPrefix ( 'cps' , effect ) log . formatter . addCall ( data . fn . name , data . args ) logResult ( effect , log . formatter ) } else if ( data = asEffect . fork ( effect . effect ) ) { if ( ! data . detached ) { log = getLogPrefix ( 'fork' , effect ) } else { log = getLogPrefix ( 'spawn' , effect ) } log . formatter . addCall ( data . fn . name , data . args ) logResult ( effect , log . formatter ) } else if ( data = asEffect . join ( effect . effect ) ) { log = getLogPrefix ( 'join' , effect ) logResult ( effect , log . formatter ) } else if ( data = asEffect . race ( effect . effect ) ) { log = getLogPrefix ( 'race' , effect ) logResult ( effect , log . formatter , true ) } else if ( data = asEffect . cancel ( effect . effect ) ) { log = getLogPrefix ( 'cancel' , effect ) log . formatter . appendData ( data . name ) } else if ( data = asEffect . select ( effect . effect ) ) { log = getLogPrefix ( 'select' , effect ) log . formatter . addCall ( data . selector . name , data . args ) logResult ( effect , log . formatter ) } else if ( is . array ( effect . effect ) ) { log = getLogPrefix ( 'parallel' , effect ) logResult ( effect , log . formatter , true ) } else if ( is . iterator ( effect . effect ) ) { log = getLogPrefix ( '' , effect ) log . formatter . addValue ( effect . effect . name ) logResult ( effect , log . formatter , true ) } else { log = getLogPrefix ( 'unkown' , effect ) logResult ( effect , log . formatter ) } return log } 
function objectIs ( x , y ) { if ( x === y ) { return x !== 0 || 1 / x === 1 / y ; } return x !== x && y !== y ; } 
function entities ( state = { users : { } , repos : { } } , action ) { if ( action . response && action . response . entities ) { return merge ( { } , state , action . response . entities ) } return state } 
function errorMessage ( state = null , action ) { const { type , error } = action if ( type === ActionTypes . RESET_ERROR_MESSAGE ) { return null } else if ( error ) { return action . error } return state } 
function forkQueue ( name , mainTask , cb ) { let tasks = [ ] , result , completed = false addTask ( mainTask ) function abort ( err ) { cancelAll ( ) cb ( err , true ) } function addTask ( task ) { tasks . push ( task ) task . cont = ( res , isErr ) => { if ( completed ) { return } remove ( tasks , task ) task . cont = noop if ( isErr ) { abort ( res ) } else { if ( task === mainTask ) { result = res } if ( ! tasks . length ) { completed = true cb ( result ) } } } 
function cancelMain ( ) { if ( mainTask . isRunning && ! mainTask . isCancelled ) { mainTask . isCancelled = true next ( TASK_CANCEL ) } } 
function cancel ( ) { if ( iterator . _isRunning && ! iterator . _isCancelled ) { iterator . _isCancelled = true taskQueue . cancelAll ( ) end ( TASK_CANCEL ) } } 
function next ( arg , isErr ) { getting TASK_CANCEL automatically cancels the main task We can get this value here - By cancelling the parent task manually - By joining a Cancelled task **/ mainTask . isCancelled = true next . cancel ( ) result = is . func ( iterator . return ) ? iterator . return ( TASK_CANCEL ) : { done : true , value : TASK_CANCEL } } else if ( arg === CHANNEL_END ) { This Generator has ended, terminate the main task and notify the fork queue **/ mainTask . isMainRunning = false mainTask . cont && mainTask . cont ( result . value ) } } catch ( error ) { if ( mainTask . isCancelled ) { logError ( error ) } mainTask . isMainRunning = false mainTask . cont ( error , true ) } } 
function currCb ( res , isErr ) { if ( effectSettled ) { return } effectSettled = true cb . cancel = noop 
function doSetAttribute ( el , props , propName ) { if ( propName === 'className' ) { el . setAttribute ( 'class' , props . className ) ; } else if ( props [ propName ] && props [ propName ] . constructor === Function ) { return ; } else { el . setAttribute ( propName , props [ propName ] ) ; } } 
function updateAttributes ( el , prevProps , props ) { var propName ; if ( ! props || prevProps === props ) { return ; } 
function componentDidUpdate ( prevProps , prevState ) { var el = this . el ; var props = this . props ; 
function updateEventListeners ( el , prevEvents , events ) { var eventName ; if ( ! prevEvents || ! events || prevEvents === events ) { return ; } for ( eventName in events ) { 
function addEventListeners ( el , eventName , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } 
function removeEventListeners ( el , eventName , handlers ) { var handler ; var i ; if ( ! handlers ) { return ; } 
function makeHooksSafe ( routes , store ) { if ( Array . isArray ( routes ) ) { return routes . map ( route => makeHooksSafe ( route , store ) ) ; } const onEnter = routes . onEnter ; if ( onEnter ) { routes . onEnter = function safeOnEnter ( ... args ) { try { store . getState ( ) ; } catch ( err ) { if ( onEnter . length === 3 ) { args [ 2 ] ( ) ; } 
function waitForPing ( ) { function pingListener ( evt ) { if ( evt . data . source === 'mobx-devtools-content-script' && evt . data . payload === 'backend:ping' ) { debugConnection ( '[contentScript -> BACKEND]' , evt ) ; const contentScriptId = evt . data . contentScriptId ; window . removeEventListener ( 'message' , pingListener ) ; clearTimeout ( handshakeFailedTimeout ) ; const payload = 'contentScript:pong' ; debugConnection ( '[contentScript -> BACKEND]' , payload ) ; window . postMessage ( { source : 'mobx-devtools-backend' , payload , contentScriptId , backendId } , '*' ) ; const helloListener = ( e ) => { if ( e . data . source === 'mobx-devtools-content-script' && e . data . payload === 'backend:hello' && e . data . contentScriptId === contentScriptId && e . data . backendId === backendId ) { debugConnection ( '[contentScript -> BACKEND]' , e ) ; window . removeEventListener ( 'message' , helloListener ) ; window . removeEventListener ( 'message' , failListener ) ; 
function auth ( req ) { if ( ! req ) { throw new TypeError ( 'argument req is required' ) } if ( typeof req !== 'object' ) { throw new TypeError ( 'argument req is required to be an object' ) } 
function getAuthorization ( req ) { if ( ! req . headers || typeof req . headers !== 'object' ) { throw new TypeError ( 'argument req is required to have headers property' ) } return req . headers . authorization } 
function parse ( string ) { if ( typeof string !== 'string' ) { return undefined } 
function install ( cef_version ) { downloadCef ( cef_version , function ( err ) { if ( err ) { util . log ( 'Failed to add dependencies' , 'error' ) ; throw err ; } copyDllWrapper ( function ( err ) { if ( err ) { util . log ( 'Failed to copy dll_wrapper.gyp' ) ; throw err ; } util . log ( 'Done!' ) ; } ) ; } ) ; } 
function downloadCef ( version , cb ) { var zlib = require ( 'zlib' ) , tar = require ( 'tar' ) , distUrl = 'https://github.com/downloads/appjs/appjs' , version = version , dirname = 'cef_binary_' + version + '_' + platform + '_' + arch , fileName = dirname + '.tar.gz' ; var tarballUrl = distUrl + '/' + fileName , gunzip = zlib . createGunzip ( ) , extracter = tar . Extract ( { path : depsDir } ) ; var errorHandler = function ( err , res ) { if ( err || res . statusCode != 200 ) { cb ( err || new Error ( res . statusCode + ' status code downloading tarball' ) ) ; } } ; var finish = function ( ) { if ( platform == 'win32' ) { try { fs . rmdirSync ( path . join ( depsDir , 'cef' ) ) ; } catch ( e ) { } ; fs . rename ( path . join ( depsDir , dirname ) , path . join ( depsDir , 'cef' ) , cb ) ; } else { try { fs . unlinkSync ( path . join ( depsDir , 'cef' ) ) ; } catch ( e ) { } ; fs . symlink ( path . join ( depsDir , dirname ) , path . join ( depsDir , 'cef' ) , cb ) ; } } ; gunzip . on ( 'error' , errorHandler ) extracter . on ( 'error' , errorHandler ) extracter . on ( 'end' , finish ) fs . exists ( path . join ( depsDir , dirname ) , function ( exists ) { if ( ! exists ) { download ( tarballUrl , errorHandler ) . pipe ( gunzip ) . pipe ( extracter ) ; } else { finish ( ) ; } } ) ; } 
function download ( url , onError ) { var request = require ( 'request' ) ; util . log ( 'Downloading cef tarball for ' + platform + '-' + arch + '...' ) ; var requestOpts = { uri : url , onResponse : true } 
function ( options ) { var noop = function ( ) { } ; this . isCordovaApp = options . isCordovaApp ; this . realUrl = options . realUrl ; this . file = options . file ; this . contentType = options . contentType || this . file . type || 'application/octet-stream' ; this . metadata = options . metadata || { 'title' : this . file . name , 'mimeType' : this . contentType } ; this . token = options . token ; this . onComplete = options . onComplete || noop ; this . onProgress = options . onProgress || noop ; this . onError = options . onError || noop ; this . offset = options . offset || 0 ; this . chunkSize = options . chunkSize || 0 ; this . retryHandler = new RetryHandler ( ) ; this . url = options . url ; if ( ! this . url ) { var params = options . params || { } ; 
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . carousel . defaults , options ) this . options . slide && this . slide ( this . options . slide ) this . options . pause == 'hover' && this . $element . on ( 'mouseenter' , $ . proxy ( this . pause , this ) ) . on ( 'mouseleave' , $ . proxy ( this . cycle , this ) ) } 
function checkGlob ( filename , globs ) { 
function getCORSRequest ( ) { var xhr = new root . XMLHttpRequest ( ) ; if ( 'withCredentials' in xhr ) { xhr . withCredentials = this . withCredentials ? true : false ; return xhr ; } else if ( ! ! root . XDomainRequest ) { return new XDomainRequest ( ) ; } else { throw new Error ( 'CORS is not supported by your browser' ) ; } } 
function getReplyMethod ( request ) { let target = findTargetFromParentInfo ( request ) ; if ( target ) { return ( ... a ) => { if ( 'isDestroyed' in target && target . isDestroyed ( ) ) return ; target . send ( ... a ) ; } ; } else { d ( "Using reply to main process" ) ; return ( ... a ) => ipc . send ( ... a ) ; } } 
function listenToIpc ( channel ) { return Observable . create ( ( subj ) => { let listener = ( event , ... args ) => { d ( ` ${ channel } ${ JSON . stringify ( args ) } ` ) ; subj . next ( args ) ; } ; d ( ` ${ channel } ` ) ; ipc . on ( channel , listener ) ; return new Subscription ( ( ) => ipc . removeListener ( channel , listener ) ) ; } ) ; } 
function getSendMethod ( windowOrWebView ) { if ( ! windowOrWebView ) return ( ... a ) => ipc . send ( ... a ) ; if ( 'webContents' in windowOrWebView ) { return ( ... a ) => { d ( ` ${ JSON . stringify ( a ) } ` ) ; if ( ! windowOrWebView . webContents . isDestroyed ( ) ) { windowOrWebView . webContents . send ( ... a ) ; } else { throw new Error ( ` ` ) ; } } ; } else { return ( ... a ) => { d ( ` ${ JSON . stringify ( a ) } ` ) ; windowOrWebView . send ( ... a ) ; } ; } } 
function listenerForId ( id , timeout ) { return listenToIpc ( responseChannel ) . do ( ( [ x ] ) => d ( ` ${ x . id } ${ id } ${ JSON . stringify ( x ) } ` ) ) . filter ( ( [ receive ] ) => receive . id === id && id ) . take ( 1 ) . mergeMap ( ( [ receive ] ) => { if ( receive . error ) { let e = new Error ( receive . error . message ) ; e . stack = receive . error . stack ; return Observable . throw ( e ) ; } return Observable . of ( receive . result ) ; } ) . timeout ( timeout ) ; } 
function findTargetFromParentInfo ( parentInfo = window . parentInfo ) { if ( ! parentInfo ) return null ; if ( 'guestInstanceId' in parentInfo ) { return require ( 'electron' ) . remote . getGuestWebContents ( parentInfo . guestInstanceId ) ; } if ( 'webContentsId' in parentInfo ) { return webContents . fromId ( parentInfo . webContentsId ) ; } return null ; } 
function objectAndParentGivenPath ( path ) { let obj = global || window ; let parent = obj ; for ( let part of path . split ( '.' ) ) { parent = obj ; obj = obj [ part ] ; } d ( ` ${ parent } ${ obj } ` ) ; if ( typeof ( parent ) !== 'object' ) { throw new Error ( ` ${ path } ` ) ; } return [ parent , obj ] ; } 
async function evalRemoteMethod ( path , args ) { let [ parent , obj ] = objectAndParentGivenPath ( path ) ; let result = obj ; if ( obj && typeof ( obj ) === 'function' ) { d ( "obj is function!" ) ; let res = obj . apply ( parent , args ) ; result = res ; if ( typeof ( res ) === 'object' && res && 'then' in res ) { d ( "result is Promise!" ) ; result = await res ; } } return result ; } 
function executeMainProcessMethod ( moduleName , methodChain , args ) { const theModule = electron [ moduleName ] ; const path = methodChain . join ( '.' ) ; return get ( theModule , path ) . apply ( theModule , args ) ; } 
function fix ( a , b ) { if ( ! a || ! b ) { return a ; } for ( let k in b ) { 
function ( str , gga ) { if ( gga . length !== 16 ) { throw new Error ( 'Invalid GGA length: ' + str ) ; } return { 'time' : parseTime ( gga [ 1 ] ) , 'lat' : parseCoord ( gga [ 2 ] , gga [ 3 ] ) , 'lon' : parseCoord ( gga [ 4 ] , gga [ 5 ] ) , 'alt' : parseDist ( gga [ 9 ] , gga [ 10 ] ) , 'quality' : parseGGAFix ( gga [ 6 ] ) , 'satellites' : parseNumber ( gga [ 7 ] ) , 'hdop' : parseNumber ( gga [ 8 ] ) , 
function ( str , gsa ) { if ( gsa . length !== 19 && gsa . length !== 20 ) { throw new Error ( 'Invalid GSA length: ' + str ) ; } var sats = [ ] ; for ( var i = 3 ; i < 15 ; i ++ ) { if ( gsa [ i ] !== '' ) { sats . push ( parseInt ( gsa [ i ] , 10 ) ) ; } } return { 'mode' : parseGSAMode ( gsa [ 1 ] ) , 'fix' : parseGSAFix ( gsa [ 2 ] ) , 'satellites' : sats , 'pdop' : parseNumber ( gsa [ 15 ] ) , 'hdop' : parseNumber ( gsa [ 16 ] ) , 'vdop' : parseNumber ( gsa [ 17 ] ) , 'systemId' : gsa . length > 19 ? parseNumber ( gsa [ 18 ] ) : null } ; } 
function ( str , rmc ) { if ( rmc . length !== 13 && rmc . length !== 14 && rmc . length !== 15 ) { throw new Error ( 'Invalid RMC length: ' + str ) ; } return { 'time' : parseTime ( rmc [ 1 ] , rmc [ 9 ] ) , 'status' : parseRMC_GLLStatus ( rmc [ 2 ] ) , 'lat' : parseCoord ( rmc [ 3 ] , rmc [ 4 ] ) , 'lon' : parseCoord ( rmc [ 5 ] , rmc [ 6 ] ) , 'speed' : parseKnots ( rmc [ 7 ] ) , 'track' : parseNumber ( rmc [ 8 ] ) , 
function ( str , vtg ) { if ( vtg . length !== 10 && vtg . length !== 11 ) { throw new Error ( 'Invalid VTG length: ' + str ) ; } if ( vtg [ 2 ] === '' && vtg [ 8 ] === '' && vtg [ 6 ] === '' ) { return { 'track' : null , 'trackMagetic' : null , 'speed' : null , 'faa' : null } ; } if ( vtg [ 2 ] !== 'T' ) { throw new Error ( 'Invalid VTG track mode: ' + str ) ; } if ( vtg [ 8 ] !== 'K' || vtg [ 6 ] !== 'N' ) { throw new Error ( 'Invalid VTG speed tag: ' + str ) ; } return { 'track' : parseNumber ( vtg [ 1 ] ) , 
function ( str , gsv ) { if ( gsv . length % 4 % 3 === 0 ) { throw new Error ( 'Invalid GSV length: ' + str ) ; } var sats = [ ] ; for ( var i = 4 ; i < gsv . length - 3 ; i += 4 ) { var prn = parseNumber ( gsv [ i ] ) ; var snr = parseNumber ( gsv [ i + 3 ] ) ; sats . push ( { 'prn' : prn , 'elevation' : parseNumber ( gsv [ i + 1 ] ) , 'azimuth' : parseNumber ( gsv [ i + 2 ] ) , 'snr' : snr , 'status' : prn !== null ? ( snr !== null ? 'tracking' : 'in view' ) : null } ) ; } return { 'msgNumber' : parseNumber ( gsv [ 2 ] ) , 'msgsTotal' : parseNumber ( gsv [ 1 ] ) , 
function ( str , gll ) { if ( gll . length !== 9 && gll . length !== 8 ) { throw new Error ( 'Invalid GLL length: ' + str ) ; } return { 'time' : parseTime ( gll [ 5 ] ) , 'status' : parseRMC_GLLStatus ( gll [ 6 ] ) , 'lat' : parseCoord ( gll [ 1 ] , gll [ 2 ] ) , 'lon' : parseCoord ( gll [ 3 ] , gll [ 4 ] ) , 'faa' : gll . length === 9 ? parseFAA ( gll [ 7 ] ) : null } ; } 
function typeAtOffset ( baseType : any , offsetFieldName : string ) : any { return jBinary . Template ( { baseType : baseType , read : function ( context ) { if ( + context [ offsetFieldName ] === 0 ) { return null ; } else { return this . binary . read ( this . baseType , + context [ offsetFieldName ] ) ; } } } ) ; } 
function tupleLessOrEqual ( t1 : Array < number > , t2 : Array < number > ) : boolean { if ( t1 . length != t2 . length ) throw new Error ( 'Comparing non-equal length tuples' ) ; for ( var i = 0 ; i < t1 . length ; i ++ ) { if ( t1 [ i ] > t2 [ i ] ) { return false ; } else if ( t1 [ i ] < t2 [ i ] ) { return true ; } } return true ; } 
function tupleRangeOverlaps ( tupleRange1 : Array < Array < number >> , tupleRange2 : Array < Array < number >> ) : boolean { return ( 
function concatArrayBuffers ( buffers : ArrayBuffer [ ] ) : ArrayBuffer { var totalBytes = buffers . map ( b => b . byteLength ) . reduce ( ( a , b ) => a + b , 0 ) ; var output = new Uint8Array ( totalBytes ) ; var position = 0 ; buffers . forEach ( buf => { output . set ( new Uint8Array ( buf ) , position ) ; position += buf . byteLength ; } ) ; return output . buffer ; } 
function parseBedFeature ( f ) : Gene { var position = new ContigInterval ( f . contig , f . start , f . stop ) , x = f . rest . split ( '\t' ) ; 
function isAlignmentInRange ( read : SamRead , idxRange : ContigInterval < number > , contained : boolean ) : boolean { 
function readAlignmentsToEnd ( buffer : ArrayBuffer , refName : string , idxRange : ContigInterval < number > , contained : boolean , offset : VirtualOffset , blocks : InflatedBlock [ ] , alignments : SamRead [ ] ) { 
function fetchAlignments ( remoteFile : RemoteFile , refName : string , idxRange : ContigInterval < number > , contained : boolean , chunks : Chunk [ ] ) : Q . Promise < SamRead [ ] > { var numRequests = 0 , alignments = [ ] , deferred = Q . defer ( ) ; function fetch ( chunks : Chunk [ ] ) { if ( chunks . length === 0 ) { deferred . resolve ( alignments ) ; return ; } 
function yForRow ( row : number , height : number = style . READ_HEIGHT , spacing : number = style . READ_SPACING ) : number { return ( row * ( height + spacing ) ) ; } 
function pileup ( reads : Interval [ ] ) : number [ ] { var rows = new Array ( reads . length ) , lastReads = [ ] ; 
function addToPileup ( read : Interval , pileup : Array < Interval [ ] > ) : number { var chosenRow = - 1 ; for ( var i = 0 ; i < pileup . length ; i ++ ) { var reads = pileup [ i ] ; var ok = true ; for ( var j = 0 ; j < reads . length ; j ++ ) { if ( reads [ j ] . intersects ( read ) ) { ok = false ; break ; } } if ( ok ) { chosenRow = i ; break ; } } if ( chosenRow == - 1 ) { chosenRow = pileup . length ; pileup [ chosenRow ] = [ ] ; 
function getArrowIndex ( read : Alignment ) : number { var i , op , ops = read . cigarOps ; if ( read . getStrand ( ) == '-' ) { for ( i = 0 ; i < ops . length ; i ++ ) { op = ops [ i ] ; if ( op . op == 'S' ) continue ; if ( op . op == 'M' ) return i ; return - 1 ; } } else { for ( i = ops . length - 1 ; i >= 0 ; i -- ) { op = ops [ i ] ; if ( op . op == 'S' ) continue ; if ( op . op == 'M' ) return i ; return - 1 ; } } return - 1 ; } 
function makeCigarString ( cigarOps : Array < CigarOp > ) { return cigarOps . map ( ( { op , length } ) => length + op ) . join ( '' ) ; } 
function computeIndexChunks ( buffer ) { var BLOCK_SIZE = 65536 ; var view = new jDataView ( buffer , 0 , buffer . byteLength , true ) ; var minBlockIndex = Infinity ; var contigStartOffsets = [ ] ; view . getInt32 ( ) ; 
function optimizeChunkList ( chunkList : Chunk [ ] , minimumOffset : VirtualOffset ) : Chunk [ ] { chunkList . sort ( ( a , b ) => { var result = a . chunk_beg . compareTo ( b . chunk_beg ) ; if ( result === 0 ) { result = a . chunk_end . compareTo ( b . chunk_end ) ; } return result ; } ) ; var newChunks = [ ] ; chunkList . forEach ( chunk => { if ( chunk . chunk_end . isLessThan ( minimumOffset ) ) { return ; 
function parseSequenceRecord ( buffer : ArrayBuffer , fileOffset : number ) : SequenceRecord { var jb = new jBinary ( buffer , twoBitTypes . TYPE_SET ) ; var header = jb . read ( 'SequenceRecord' ) ; var dnaOffset = jb . tell ( ) + 8 * header . maskBlockCount + 4 ; return { numBases : header . dnaSize , unknownBlockStarts : header . nBlockStarts , unknownBlockLengths : header . nBlockSizes , numMaskBlocks : header . maskBlockCount , maskBlockStarts : [ ] , maskBlockLengths : [ ] , dnaOffsetFromHeader : dnaOffset , offset : fileOffset } ; } 
function TEXT_STYLE ( mode : number , fontSize : number ) : string { if ( mode == DisplayMode . LOOSE ) { return ` ${ fontSize } ` ; } else if ( mode == DisplayMode . TIGHT ) { return ` ${ fontSize } ` ; } else { return ` ${ fontSize } ` ; } } 
function createDTrace ( name ) { 
function hasPropsAndVals ( obj , kv ) { if ( typeof ( obj ) !== 'object' || typeof ( kv ) !== 'object' ) { return ( false ) ; } if ( Object . keys ( kv ) . length === 0 ) { return ( true ) ; } return ( Object . keys ( kv ) . every ( function ( k ) { return ( obj [ k ] && obj [ k ] === kv [ k ] ) ; } ) ) ; } 
function registerRunner ( runner_id , active_at , callback ) { if ( typeof ( active_at ) === 'function' ) { callback = active_at ; active_at = new Date ( ) ; } if ( typeof ( active_at ) === 'string' ) { active_at = new Date ( active_at ) ; } runners [ runner_id ] = { runner_id : runner_id , active_at : active_at , idle : false } ; return callback ( null ) ; } 
function createWorkflow ( workflow , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( _wfNames ( ) . indexOf ( workflow . name ) !== - 1 ) { return callback ( new e . BackendInvalidArgumentError ( 'Workflow.name must be unique. A workflow with name "' + workflow . name + '" already exists' ) ) ; } else { workflows [ workflow . uuid ] = clone ( workflow ) ; return callback ( null , workflow ) ; } } 
function getWorkflow ( uuid , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( workflows [ uuid ] ) { return callback ( null , clone ( workflows [ uuid ] ) ) ; } else { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Workflow with uuid \'%s\' does not exist' , uuid ) ) ) ; } } 
function deleteWorkflow ( workflow , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( workflows [ workflow . uuid ] ) { return callback ( null , ( delete workflows [ workflow . uuid ] ) ) ; } else { return callback ( null , false ) ; } } 
function updateWorkflow ( workflow , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( workflows [ workflow . uuid ] ) { if ( _wfNames ( ) . indexOf ( workflow . name ) !== - 1 && workflows [ workflow . uuid ] . name !== workflow . name ) { return callback ( new e . BackendInvalidArgumentError ( 'Workflow.name must be unique. A workflow with name "' + workflow . name + '" already exists' ) ) ; } else { workflows [ workflow . uuid ] = clone ( workflow ) ; return callback ( null , workflow ) ; } } else { return callback ( new e . BackendResourceNotFoundError ( 'Workflow does not exist. Cannot Update.' ) ) ; } } 
function createJob ( job , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } job . created_at = job . created_at || new Date ( ) . toISOString ( ) ; jobs [ job . uuid ] = clone ( job ) ; queued_jobs . push ( job . uuid ) ; if ( typeof ( job . locks ) !== 'undefined' ) { locked_targets [ job . uuid ] = job . locks ; } return callback ( null , job ) ; } 
function ( uuid , prop , cb ) { if ( jobs [ uuid ] ) { return cb ( null , jobs [ uuid ] [ prop ] ) ; } else { return cb ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , uuid ) ) ) ; } } 
function validateJobTarget ( job , callback ) { 
function nextJob ( index , callback ) { if ( typeof ( index ) === 'function' ) { callback = index ; index = 0 ; } if ( queued_jobs . length === 0 ) { return callback ( null , null ) ; } var slice = queued_jobs . slice ( index , index + 1 ) ; if ( slice . length === 0 ) { return callback ( null , null ) ; } else { return getJob ( slice [ 0 ] , callback ) ; } } 
function runJob ( uuid , runner_id , callback ) { var idx = queued_jobs . indexOf ( uuid ) ; if ( idx === - 1 ) { return callback ( new e . BackendPreconditionFailedError ( 'Only queued jobs can be run' ) ) ; } else { queued_jobs . splice ( idx , 1 ) ; jobs [ uuid ] . runner_id = runner_id ; jobs [ uuid ] . execution = 'running' ; return callback ( null , clone ( jobs [ uuid ] ) ) ; } } 
function finishJob ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution !== 'running' && jobs [ job . uuid ] . execution !== 'canceled' ) { return callback ( new e . BackendPreconditionFailedError ( 'Only running jobs can be finished' ) ) ; } else { if ( job . execution === 'running' ) { job . execution = 'succeeded' ; } var info = jobs [ job . uuid ] . info ; job . runner_id = null ; jobs [ job . uuid ] = clone ( job ) ; if ( info ) { jobs [ job . uuid ] . info = info ; } if ( typeof ( job . locks ) !== 'undefined' ) { delete locked_targets [ job . uuid ] ; } return callback ( null , job ) ; } } 
function updateJob ( job , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( ! jobs [ job . uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , job . uuid ) ) ) ; } else { jobs [ job . uuid ] = clone ( job ) ; return callback ( null , job ) ; } } 
function cancelJob ( uuid , cb ) { if ( typeof ( uuid ) === 'undefined' ) { return cb ( new e . BackendInternalError ( 'cancelJob uuid(String) required' ) ) ; } jobs [ uuid ] . execution = 'canceled' ; delete jobs [ uuid ] . runner_id ; if ( typeof ( jobs [ uuid ] . locks ) !== 'undefined' ) { delete locked_targets [ uuid ] ; } return cb ( null , jobs [ uuid ] ) ; } 
function updateJobProperty ( uuid , prop , val , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , uuid ) ) ) ; } else { jobs [ uuid ] [ prop ] = val ; return callback ( null ) ; } } 
function queueJob ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution !== 'running' ) { return callback ( new e . BackendPreconditionFailedError ( 'Only running jobs can be queued again' ) ) ; } else { job . runner_id = null ; job . execution = 'queued' ; jobs [ job . uuid ] = clone ( job ) ; queued_jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function pauseJob ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution !== 'running' ) { return callback ( new e . BackendPreconditionFailedError ( 'Only running jobs can be paused' ) ) ; } else { job . runner_id = null ; job . execution = 'waiting' ; jobs [ job . uuid ] = clone ( job ) ; waiting_jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function resumeJob ( job , callback ) { if ( ! jobs [ job . uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Job with uuid \'%s\' does not exist' , job . uuid ) ) ) ; } else if ( jobs [ job . uuid ] . execution !== 'waiting' ) { return callback ( new e . BackendPreconditionFailedError ( 'Only waiting jobs can be resumed' ) ) ; } else { job . runner_id = null ; job . execution = 'queued' ; jobs [ job . uuid ] = clone ( job ) ; waiting_jobs = waiting_jobs . filter ( function ( j ) { return ( j !== job . uuid ) ; } ) ; queued_jobs . push ( job . uuid ) ; return callback ( null , job ) ; } } 
function nextJobs ( start , stop , callback ) { if ( queued_jobs . length === 0 ) { return callback ( null , null ) ; } var slice = queued_jobs . slice ( start , stop + 1 ) ; if ( slice . length === 0 ) { return callback ( null , null ) ; } else { return callback ( null , slice ) ; } } 
function getRunner ( runner_id , callback ) { if ( ! runners [ runner_id ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Runner with uuid \'%s\' does not exist' , runner_id ) ) ) ; } else { return callback ( null , runners [ runner_id ] . active_at ) ; } } 
function getRunners ( callback ) { var theRunners = { } ; Object . keys ( runners ) . forEach ( function ( uuid ) { theRunners [ uuid ] = runners [ uuid ] . active_at ; } ) ; return callback ( null , theRunners ) ; } 
function idleRunner ( runner_id , callback ) { if ( ! runners [ runner_id ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Runner with uuid \'%s\' does not exist' , runner_id ) ) ) ; } else { runners [ runner_id ] . idle = true ; return callback ( null ) ; } } 
function isRunnerIdle ( runner_id , callback ) { if ( ! runners [ runner_id ] || ( runners [ runner_id ] . idle === true ) ) { return callback ( true ) ; } else { return callback ( false ) ; } } 
function wakeUpRunner ( runner_id , callback ) { if ( ! runners [ runner_id ] ) { return callback ( new e . BackendResourceNotFoundError ( sprintf ( 'Runner with uuid \'%s\' does not exist' , runner_id ) ) ) ; } else { runners [ runner_id ] . idle = false ; return callback ( null ) ; } } 
function getRunnerJobs ( runner_id , callback ) { var wf_runner_jobs = Object . keys ( jobs ) . filter ( function ( uuid ) { return jobs [ uuid ] . runner_id === runner_id ; } ) ; return callback ( null , wf_runner_jobs ) ; } 
function getWorkflows ( params , callback ) { if ( typeof ( params ) === 'function' ) { callback = params ; params = { } ; } var wfs = [ ] ; var rWorkflows = Object . keys ( workflows ) . map ( function ( uuid ) { return clone ( workflows [ uuid ] ) ; } ) ; rWorkflows . forEach ( function ( wf ) { if ( hasPropsAndVals ( wf , params ) ) { wfs . push ( wf ) ; } } ) ; return callback ( null , wfs ) ; } 
function getJobs ( params , callback ) { var executions = [ 'queued' , 'failed' , 'succeeded' , 'canceled' , 'running' , 'retried' , 'waiting' ] ; var execution ; var offset ; var limit ; var rJobs = [ ] ; var theJobs = [ ] ; if ( typeof ( params ) === 'object' ) { execution = params . execution ; delete params . execution ; offset = params . offset ; delete params . offset ; limit = params . limit ; delete params . limit ; } if ( typeof ( params ) === 'function' ) { callback = params ; params = { } ; } if ( ( typeof ( execution ) !== 'undefined' ) && ( executions . indexOf ( execution ) === - 1 ) ) { return callback ( new e . BackendInvalidArgumentError ( 'excution is required and must be one of "' + executions . join ( '", "' ) + '"' ) ) ; } if ( typeof ( execution ) !== 'undefined' ) { rJobs = Object . keys ( jobs ) . filter ( function ( uuid ) { return ( jobs [ uuid ] . execution === execution ) ; } ) . map ( function ( uuid ) { return clone ( jobs [ uuid ] ) ; } ) ; } else { rJobs = Object . keys ( jobs ) . map ( function ( uuid ) { return clone ( jobs [ uuid ] ) ; } ) ; } rJobs . forEach ( function ( job ) { if ( hasPropsAndVals ( job . params , params ) ) { theJobs . push ( job ) ; } } ) ; if ( typeof ( offset ) !== 'undefined' && typeof ( limit ) !== 'undefined' ) { return callback ( null , theJobs . slice ( offset , limit ) ) ; } else { return callback ( null , theJobs ) ; } } 
function addInfo ( uuid , info , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( 'Job does not exist. Cannot Update.' ) ) ; } else { if ( ! util . isArray ( jobs [ uuid ] . info ) ) { jobs [ uuid ] . info = [ ] ; } jobs [ uuid ] . info . push ( info ) ; return callback ( null ) ; } } 
function getInfo ( uuid , meta , callback ) { if ( typeof ( meta ) === 'function' ) { callback = meta ; meta = { } ; } if ( ! jobs [ uuid ] ) { return callback ( new e . BackendResourceNotFoundError ( 'Job does not exist. Cannot get info.' ) ) ; } else { if ( ! util . isArray ( jobs [ uuid ] . info ) ) { jobs [ uuid ] . info = [ ] ; } return callback ( null , clone ( jobs [ uuid ] . info ) ) ; } } 
function ( el , ordinal ) { var $el = $ ( el ) ; if ( $el . data ( 'popup-visible' ) ) return ; // Initialize if not initialized. Required for: $('#popup').popup('show') if ( ! $el . data ( 'popup-initialized' ) ) { methods . _init ( el ) ; } $el . attr ( 'data-popup-initialized' , 'true' ) ; var $body = $ ( 'body' ) ; var options = $el . data ( 'popupoptions' ) ; var $wrapper = $ ( '#' + el . id + '_wrapper' ) ; var $background = $ ( '#' + el . id + '_background' ) ; // `beforeopen` callback event callback ( el , ordinal , options . beforeopen ) ; // Remember last clicked place lastclicked [ el . id ] = ordinal ; // Add popup id to visiblePopupsArray setTimeout ( function ( ) { visiblePopupsArray . push ( el . id ) ; } , 0 ) ; // Calculating maximum z-index if ( options . autozindex ) { var elements = document . getElementsByTagName ( '*' ) ; var len = elements . length ; var maxzindex = 0 ; for ( var i = 0 ; i < len ; i ++ ) { var elementzindex = $ ( elements [ i ] ) . css ( 'z-index' ) ; if ( elementzindex !== 'auto' ) { elementzindex = parseInt ( elementzindex , 10 ) ; if ( maxzindex < elementzindex ) { maxzindex = elementzindex ; } } } zindexvalues [ el . id ] = maxzindex ; // Add z-index to the background if ( options . background ) { if ( zindexvalues [ el . id ] >= 0 ) { $ ( '#' + el . id + '_background' ) . css ( { zIndex : ( zindexvalues [ el . id ] + 1 ) } ) ; } } // Add z-index to the wrapper if ( zindexvalues [ el . id ] >= 0 ) { $wrapper . css ( { zIndex : ( zindexvalues [ el . id ] + 2 ) } ) ; } } if ( options . detach ) { $wrapper . prepend ( el ) ; $el . show ( ) ; } else { $el . show ( ) ; } opentimer = setTimeout ( function ( ) { $wrapper . css ( { visibility : 'visible' , opacity : 1 } ) ; $ ( 'html' ) . addClass ( 'popup_visible' ) . addClass ( 'popup_visible_' + el . id ) ; $wrapper . addClass ( 'popup_wrapper_visible' ) ; } , 20 ) ; // 20ms required for opening animation to occur in FF // Disable background layer scrolling when popup is opened if ( options . scrolllock ) { $body . css ( 'overflow' , 'hidden' ) ; if ( $body . height ( ) > $window . height ( ) ) { $body . css ( 'margin-right' , bodymarginright + scrollbarwidth ) ; } } $el . css ( { 'visibility' : 'visible' , 'opacity' : 1 } ) ; // Show background if ( options . background ) { $background . css ( { 'visibility' : 'visible' , 'opacity' : options . opacity } ) ; // Fix IE8 issue with background not appearing setTimeout ( function ( ) { $background . css ( { 'opacity' : options . opacity } ) ; } , 0 ) ; } $el . data ( 'popup-visible' , true ) ; // Position popup methods . reposition ( el , ordinal ) ; // Remember which element had focus before opening a popup $el . data ( 'focusedelementbeforepopup' , document . activeElement ) ; // Make holder div programatically focusable with tabindex:-1 (tabindex:0 is keyboard focusable) $el . attr ( 'tabindex' , - 1 ) ; // Focus the popup or user specified element. // Initial timeout of 50ms is set to give some time to popup to show after clicking on // `open` element, and after animation is complete to prevent background scrolling. setTimeout ( function ( ) { if ( options . focuselement === 'closebutton' ) { // e.g. focuselement:'closebutton' $ ( '#' + el . id + ' .' + el . id + closesuffix + ':first' ) . focus ( ) ; } else if ( options . focuselement ) { // e.g. focuselement:'#my-close-button' $ ( options . focuselement ) . focus ( ) ; } else if ( options . focuselement === true || options . keepfocus ) { // e.g. focuselement:true OR keepfocus:true $el . focus ( ) ; } } , options . focusdelay ) ; // Hide main content from screen readers if ( options . keepfocus ) { $ ( options . pagecontainer ) . attr ( 'aria-hidden' , true ) ; } // Reveal popup content to screen readers $el . attr ( 'aria-hidden' , false ) ; callback ( el , ordinal , options . onopen ) ; if ( transitionsupport ) { $wrapper . one ( 'transitionend' , function ( ) { callback ( el , ordinal , options . opentransitionend ) ; } ) ; } else { callback ( el , ordinal , options . opentransitionend ) ; } // Handler: Reposition tooltip when window is resized if ( options . type == 'tooltip' ) { $ ( window ) . on ( 'resize.' + el . id , function ( ) { methods . reposition ( el , ordinal ) ; } ) ; } } 
function ( el , outerClick ) { // Get index of popup ID inside of visiblePopupsArray var popupIdIndex = $ . inArray ( el . id , visiblePopupsArray ) ; // If popup is not opened, ignore the rest of the function if ( popupIdIndex === - 1 ) { return ; } if ( opentimer ) clearTimeout ( opentimer ) ; var $body = $ ( 'body' ) ; var $el = $ ( el ) ; var options = $el . data ( 'popupoptions' ) ; var $wrapper = $ ( '#' + el . id + '_wrapper' ) ; var $background = $ ( '#' + el . id + '_background' ) ; $el . data ( 'popup-visible' , false ) ; if ( visiblePopupsArray . length === 1 ) { $ ( 'html' ) . removeClass ( 'popup_visible' ) . removeClass ( 'popup_visible_' + el . id ) ; } else { if ( $ ( 'html' ) . hasClass ( 'popup_visible_' + el . id ) ) { $ ( 'html' ) . removeClass ( 'popup_visible_' + el . id ) ; } } // Remove popup from the visiblePopupsArray visiblePopupsArray . splice ( popupIdIndex , 1 ) ; if ( $wrapper . hasClass ( 'popup_wrapper_visible' ) ) { $wrapper . removeClass ( 'popup_wrapper_visible' ) ; } // Focus back on saved element if ( options . keepfocus && ! outerClick ) { setTimeout ( function ( ) { if ( $ ( $el . data ( 'focusedelementbeforepopup' ) ) . is ( ':visible' ) ) { $el . data ( 'focusedelementbeforepopup' ) . focus ( ) ; } } , 0 ) ; } // Hide popup $wrapper . css ( { 'visibility' : 'hidden' , 'opacity' : 0 } ) ; $el . css ( { 'visibility' : 'hidden' , 'opacity' : 0 } ) ; // Hide background if ( options . background ) { $background . css ( { 'visibility' : 'hidden' , 'opacity' : 0 } ) ; } // Reveal main content to screen readers $ ( options . pagecontainer ) . attr ( 'aria-hidden' , false ) ; // Hide popup content from screen readers $el . attr ( 'aria-hidden' , true ) ; // `onclose` callback event callback ( el , lastclicked [ el . id ] , options . onclose ) ; if ( transitionsupport && $el . css ( 'transition-duration' ) !== '0s' ) { $el . one ( 'transitionend' , function ( ) { if ( ! ( $el . data ( 'popup-visible' ) ) ) { if ( options . detach ) { $el . detach ( ) ; } else { $el . hide ( ) ; } } // Re-enable scrolling of background layer, if needed if ( options . scrolllock ) { setTimeout ( function ( ) { if ( $ . grep ( visiblePopupsArray , function ( eid ) { return $ ( "#" + eid ) . data ( 'popupoptions' ) . scrolllock } ) . length ) { // Some "scolllock=true" popup is currently visible, leave scrolling disabled return ; } $body . css ( { overflow : 'visible' , 'margin-right' : bodymarginright } ) ; } , 10 ) ; // 10ms added for CSS transition in Firefox which doesn't like overflow:auto } callback ( el , lastclicked [ el . id ] , options . closetransitionend ) ; } ) ; } else { if ( options . detach ) { $el . detach ( ) ; } else { $el . hide ( ) ; } // Re-enable scrolling of background layer, if needed if ( options . scrolllock ) { setTimeout ( function ( ) { if ( $ . grep ( visiblePopupsArray , function ( eid ) { return $ ( "#" + eid ) . data ( 'popupoptions' ) . scrolllock } ) . length ) { // Some "scrolllock=true" popup is currently visible, leave scrolling disabled return ; } $body . css ( { overflow : 'visible' , 'margin-right' : bodymarginright } ) ; } , 10 ) ; // 10ms added for CSS transition in Firefox which doesn't like overflow:auto } callback ( el , lastclicked [ el . id ] , options . closetransitionend ) ; } if ( options . type == 'tooltip' ) { $ ( window ) . off ( 'resize.' + el . id ) ; } } 
function ( el , ordinal ) { if ( $ ( el ) . data ( 'popup-visible' ) ) { methods . hide ( el ) ; } else { setTimeout ( function ( ) { methods . show ( el , ordinal ) ; } , 0 ) ; } } 
function ( el , ordinal ) { var $el = $ ( el ) ; var options = $el . data ( 'popupoptions' ) ; var $wrapper = $ ( '#' + el . id + '_wrapper' ) ; ordinal = ordinal || 0 ; // Tooltip type if ( options . type == 'tooltip' ) { // TODO: this static assignments should probably be moved to init method $wrapper . css ( { 'position' : 'absolute' } ) ; var $tooltipanchor ; if ( options . tooltipanchor ) { $tooltipanchor = $ ( options . tooltipanchor ) ; } else if ( options . openelement ) { $tooltipanchor = $ ( options . openelement ) . filter ( '[data-popup-ordinal="' + ordinal + '"]' ) ; } else { $tooltipanchor = $ ( '.' + el . id + opensuffix + '[data-popup-ordinal="' + ordinal + '"]' ) ; } var linkOffset = $tooltipanchor . offset ( ) || { left : 0 , top : 0 } ; // Horizontal position for tooltip if ( options . horizontal == 'right' ) { $wrapper . css ( 'left' , linkOffset . left + $tooltipanchor . outerWidth ( ) + options . offsetleft ) ; } else if ( options . horizontal == 'leftedge' ) { $wrapper . css ( 'left' , linkOffset . left + options . offsetleft ) ; } else if ( options . horizontal == 'left' ) { $wrapper . css ( 'right' , $window . width ( ) - linkOffset . left - options . offsetleft ) ; } else if ( options . horizontal == 'rightedge' ) { $wrapper . css ( 'right' , $window . width ( ) - linkOffset . left - $tooltipanchor . outerWidth ( ) - options . offsetleft ) ; } else { $wrapper . css ( 'left' , linkOffset . left + ( $tooltipanchor . outerWidth ( ) / 2 ) - ( $el . outerWidth ( ) / 2 ) - parseFloat ( $el . css ( 'marginLeft' ) ) + options . offsetleft ) ; } // Vertical position for tooltip if ( options . vertical == 'bottom' ) { $wrapper . css ( 'top' , linkOffset . top + $tooltipanchor . outerHeight ( ) + options . offsettop ) ; } else if ( options . vertical == 'bottomedge' ) { $wrapper . css ( 'top' , linkOffset . top + $tooltipanchor . outerHeight ( ) - $el . outerHeight ( ) + options . offsettop ) ; } else if ( options . vertical == 'top' ) { $wrapper . css ( 'bottom' , $window . height ( ) - linkOffset . top - options . offsettop ) ; } else if ( options . vertical == 'topedge' ) { $wrapper . css ( 'bottom' , $window . height ( ) - linkOffset . top - $el . outerHeight ( ) - options . offsettop ) ; } else { $wrapper . css ( 'top' , linkOffset . top + ( $tooltipanchor . outerHeight ( ) / 2 ) - ( $el . outerHeight ( ) / 2 ) - parseFloat ( $el . css ( 'marginTop' ) ) + options . offsettop ) ; } // Overlay type } else if ( options . type == 'overlay' ) { // TODO all static assignments in this block should probably be moved to init method // Horizontal position for overlay if ( options . horizontal ) { $wrapper . css ( 'text-align' , options . horizontal ) ; } else { $wrapper . css ( 'text-align' , 'center' ) ; } // Vertical position for overlay if ( options . vertical ) { $el . css ( 'vertical-align' , options . vertical ) ; } else { $el . css ( 'vertical-align' , 'middle' ) ; } if ( options . absolute ) { $wrapper . css ( { position : 'absolute' , top : window . scrollY } ) ; } if ( ! options . background ) { $wrapper . css ( { 'pointer-events' : 'none' } ) ; // If popup doesnt fit the viewport, and if background doesn't exist, add scrollbar to popup div instead of wrapper if ( ! options . absolute && ! isInViewport ( el ) ) { $el . css ( 'overflow' , 'auto' ) ; $el [ 0 ] . style . WebkitOverflowScrolling = 'touch' ; // for smooth scrolling in overflow:auto divs in iOS $el . css ( 'max-height' , 'calc(100% - ' + $el . css ( 'margin-top' ) + ' - ' + $el . css ( 'margin-bottom' ) + ')' ) ; } } } } 
function ( el ) { var genericCloseButton ; if ( $ ( el ) . data ( 'popupoptions' ) . closebuttonmarkup ) { genericCloseButton = $ ( options . closebuttonmarkup ) . addClass ( el . id + '_close' ) ; } else { genericCloseButton = '<button class="popup_close ' + el . id + '_close" title="Close" aria-label="Close"><span aria-hidden="true">×</span></button>'; } if ( $ ( el ) . data ( 'popup-initialized' ) ) { $ ( el ) . append ( genericCloseButton ) ; } } 
function ( el , ordinal , func ) { var options = $ ( el ) . data ( 'popupoptions' ) ; var openelement ; var elementclicked ; if ( typeof options === 'undefined' ) return ; openelement = options . openelement ? options . openelement : ( '.' + el . id + opensuffix ) ; elementclicked = $ ( openelement + '[data-popup-ordinal="' + ordinal + '"]' ) ; if ( typeof func == 'function' ) { func . call ( $ ( el ) , el , elementclicked ) ; } } 
function ( el ) { var bounding = el . getBoundingClientRect ( ) ; return ( bounding . top >= 0 && bounding . left >= 0 && bounding . bottom <= ( window . innerHeight || document . documentElement . clientHeight ) && bounding . right <= ( window . innerWidth || document . documentElement . clientWidth ) ) ; } 
function CordovaAuth ( options ) { this . clientId = options . clientId ; this . domain = options . domain ; this . redirectUri = options . packageIdentifier + '://' + options . domain + '/cordova/' + options . packageIdentifier + '/callback' ; this . auth0 = new auth0 . WebAuth ( { clientID : this . clientId , domain : this . domain } ) ; this . client = new auth0 . Authentication ( this . auth0 , { clientID : this . clientId , domain : this . domain , _telemetryInfo : telemetry } ) ; } 
function main ( ) { var app = new App ( ) ; function intentHandler ( url ) { Auth0Cordova . onRedirectUri ( url ) ; } window . handleOpenURL = intentHandler ; app . run ( '#app' ) ; } 
function WebView ( ) { this . tab = null ; this . handler = null ; this . open = this . open . bind ( this ) ; this . handleFirstLoadEnd = this . handleFirstLoadEnd . bind ( this ) ; this . handleLoadError = this . handleLoadError . bind ( this ) ; this . handleExit = this . handleExit . bind ( this ) ; this . clearEvents = this . clearEvents . bind ( this ) ; this . close = this . close . bind ( this ) ; } 
function processProps ( props ) { const { title , label , key , value } = props ; const cloneProps = { ... props } ; 
function Reporter ( options ) { var _defaultOutputFile = path . resolve ( process . cwd ( ) , './_test-output' , 'protractor-results.txt' ) ; options . outputFile = options . outputFile || _defaultOutputFile ; initOutputFile ( options . outputFile ) ; options . appDir = options . appDir || './' ; var _root = { appDir : options . appDir , suites : [ ] } ; log ( 'AppDir: ' + options . appDir , + 1 ) ; var _currentSuite ; this . suiteStarted = function ( suite ) { _currentSuite = { description : suite . description , status : null , specs : [ ] } ; _root . suites . push ( _currentSuite ) ; log ( 'Suite: ' + suite . description , + 1 ) ; } ; this . suiteDone = function ( suite ) { var statuses = _currentSuite . specs . map ( function ( spec ) { return spec . status ; } ) ; statuses = _ . uniq ( statuses ) ; var status = statuses . indexOf ( 'failed' ) >= 0 ? 'failed' : statuses . join ( ', ' ) ; _currentSuite . status = status ; log ( 'Suite ' + _currentSuite . status + ': ' + suite . description , - 1 ) ; } ; this . specStarted = function ( spec ) { } ; this . specDone = function ( spec ) { var currentSpec = { description : spec . description , status : spec . status } ; if ( spec . failedExpectations . length > 0 ) { currentSpec . failedExpectations = spec . failedExpectations ; 
function regularExpressions ( ) { var regexFile = path . join ( process . cwd ( ) , 'regex_rules.json' ) var regex = require ( regexFile ) return regex } 
function parseHeaders ( filename , headerLines , only = null ) { const headers = Object . create ( null ) ; for ( let line of headerLines ) { if ( line === '' ) continue ; let [ name , value ] = line . match ( / ^(.*?)\:\s+(.*)$ / ) . slice ( 1 ) ; if ( only && ! match ( name , only ) ) continue ; const key = ( name || '' ) . toLowerCase ( ) ; value = ( value || '' ) . trim ( ) . replace ( / ^"(.*)"$ / , '$1' ) ; if ( Array . isArray ( headers [ key ] ) ) headers [ key ] . push ( value ) ; else if ( headers [ key ] ) headers [ key ] = [ headers [ key ] , value ] ; else headers [ key ] = value ; } return headers ; } 
function writeHeaders ( file , headers , only = null ) { for ( let name in headers ) { let value = headers [ name ] ; if ( only && ! match ( name , only ) ) continue ; if ( Array . isArray ( value ) ) for ( let item of value ) file . write ( ` ${ name } ${ item } \n ` ) ; else file . write ( ` ${ name } ${ value } \n ` ) ; } } 
function match ( name , regexps ) { for ( let regexp of regexps ) if ( regexp . test ( name ) ) return true ; return false ; } 
function parse ( buffer , headers ) { var params = getParsingParams ( headers ) ; var strategy = PARSING_STRATEGIES [ params . contentType ] || function ( ) { return null ; } ; try { return strategy ( buffer , params . charset ) ; } catch ( err ) { 
function showHelpAndDie ( message ) { if ( message ) { console . error ( message ) ; } console . error ( commander . helpInformation ( ) ) ; process . exit ( 1 ) ; } 
function renderPage ( res , templateName , config , userStash ) { var pageStash = extendObject ( { baseUrl : robohydraAdminBaseUrlPath , renderPartial : renderPartial } , userStash ) ; var templateString = templateData ( templateName ) ; var mainContent = ejs . render ( templateString , pageStash ) ; var layoutStash = extendObject ( { baseUrl : robohydraAdminBaseUrlPath , title : "RoboHydra Admin" , currentSection : "/" , hydraName : config . robohydra . name , startTime : config . robohydra . startTimestamp , renderPartial : renderPartial , content : mainContent } , userStash ) ; res . headers [ 'content-type' ] = 'text/html' ; res . send ( ejs . render ( mainLayoutTemplateString , layoutStash ) ) ; } 
function readBodyParams ( req ) { if ( req . headers [ 'content-type' ] !== 'application/x-www-form-urlencoded' ) { deprecationWarning ( "make sure you correctly set Content-Type to" + " application/x-www-form-urlencoded" ) ; try { return qs . parse ( req . rawBody . toString ( ) ) ; } catch ( e ) { return null ; } } return req . body ; } 
function AbstractRoboHydraHead ( props ) { 
function robohydraHeadType ( settings ) { var parentClass = settings . parentClass || RoboHydraHead ; var newConstructorFunction = function ( props ) { if ( ! props && settings . defaultProps ) { deprecationWarning ( "deprecated 'defaultProps', please use 'defaultPropertyObject' instead" ) ; props = settings . defaultProps ; } props = props || settings . defaultPropertyObject || { } ; 
function createRoboHydraServer ( config , extraVars ) { var summoner ; try { summoner = new RoboHydraSummoner ( config . plugins , config . summoner , { extraVars : extraVars , extraPluginLoadPaths : config . pluginLoadPaths } ) ; } catch ( e ) { console . error ( e . message || e ) ; process . exit ( 1 ) ; } 
function serveStaticFile ( path , res , opts ) { opts = opts || { } ; var fsObject = opts . fs || fs ; var mimeObject = opts . mime || mime ; var headers = opts . headers || { } ; var indexFiles = opts . indexFiles || [ 'index.html' , 'index.htm' , 'home.html' , 'home.htm' ] ; fsObject . stat ( path , function ( err , stats ) { if ( ! err ) { if ( stats . isFile ( ) ) { var mtime = stats . mtime , modifiedSince = headers [ 'if-modified-since' ] ; 
function proxyRequest ( req , res , proxyTo , opts ) { opts = opts || { } ; var httpRequestFunction = opts . httpRequestFunction || http . request ; var httpsRequestFunction = opts . httpsRequestFunction || https . request ; var setHostHeader = opts . setHostHeader ; var proxyUrl = proxyTo ; if ( typeof ( proxyTo ) === 'string' ) { proxyUrl = url . parse ( proxyTo , true ) ; } var proxyToHost = proxyUrl . hostname ; var proxyToPort = proxyUrl . port || ( proxyUrl . protocol === 'https:' ? 443 : 80 ) ; var proxyToPath = proxyUrl . pathname + ( proxyUrl . search === null ? "" : proxyUrl . search ) ; var requestFunction = ( proxyUrl . protocol === 'https:' ) ? httpsRequestFunction : httpRequestFunction ; var headers = { } ; for ( var h in req . headers ) { headers [ h ] = req . headers [ h ] ; } if ( setHostHeader ) { headers . host = proxyToHost + ( proxyUrl . port ? ":" + proxyUrl . port : "" ) ; } var proxyReq = requestFunction ( { host : proxyToHost , port : proxyToPort , method : req . method , path : proxyToPath , headers : headers } , function ( proxyRes ) { 
function extendObject ( obj ) { for ( var i = 1 , len = arguments . length ; i < len ; i ++ ) { for ( var p in arguments [ i ] ) { if ( arguments [ i ] . hasOwnProperty ( p ) ) { obj [ p ] = arguments [ i ] [ p ] ; } } } return obj ; } 
function Request ( props ) { 
function Response ( cb ) { this . body = new Buffer ( 0 ) ; this . statusCode = 200 ; this . headers = { } ; this . ended = false ; var endHandlers = [ ] ; if ( typeof cb === 'function' ) { endHandlers . push ( cb ) ; } this . _eventHandlers = { head : [ ] , data : [ ] , end : endHandlers } ; } 
function ( extraVars ) { this . extraVars = extendObject ( { } , extraVars || { } ) ; this . _plugins = [ ] ; this . _headMap = { } ; this . currentScenario = { plugin : '*default*' , scenario : '*default*' } ; this . testResults = { '*default*' : { '*default*' : { result : undefined , passes : [ ] , failures : [ ] } } } ; Object . defineProperty ( this , 'scenarioResults' , { get : function ( ) { deprecationWarning ( "scenarioResults is deprecated, please use testResults instead" ) ; return this . testResults ; } } ) ; 
function BigIq50LicenseProvider ( bigIp , options ) { const injectedLogger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; if ( injectedLogger ) { this . logger = injectedLogger ; util . setLogger ( injectedLogger ) ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; } logger = this . logger ; this . bigIp = bigIp ; } 
function listPrivateKey ( keyType , folder , name , noRetry ) { let privateKeyName ; 
function CloudProvider ( options ) { const logger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; this . options = { } ; if ( options ) { Object . keys ( options ) . forEach ( ( option ) => { this . options [ option ] = options [ option ] ; } ) ; } this . clOptions = { } ; if ( options && options . clOptions ) { Object . keys ( options . clOptions ) . forEach ( ( option ) => { this . clOptions [ option ] = options . clOptions [ option ] ; } ) ; } 
function createTrafficGroup ( bigIp , trafficGroup ) { let createGroup = true ; bigIp . list ( '/tm/cm/traffic-group' ) . then ( ( response ) => { response . forEach ( ( group ) => { if ( group . name === trafficGroup ) { createGroup = false ; } } ) ; if ( createGroup ) { return bigIp . create ( '/tm/cm/traffic-group' , { name : trafficGroup , partition : '/Common' } ) ; } return q ( ) ; } ) . catch ( ( err ) => { return q . reject ( err ) ; } ) ; } 
function handleJoin ( provider , bigIp , masterIid , options ) { const deferred = q . defer ( ) ; logger . info ( 'Cluster action JOIN' ) ; logger . info ( 'Initializing encryption' ) ; initEncryption . call ( this , provider , bigIp ) . then ( ( ) => { let promise ; 
function handleUpdate ( provider , bigIp , masterIid , masterBadOrNew , options ) { logger . info ( 'Cluster action UPDATE' ) ; if ( this . instance . isMaster && ! masterBadOrNew ) { return checkForDisconnectedDevices . call ( this , bigIp ) ; } else if ( ! this . instance . isMaster ) { 
function handleMessages ( provider , bigIp , options ) { const deferred = q . defer ( ) ; const instanceIdsBeingAdded = [ ] ; const actions = [ ] ; const actionPromises = [ ] ; let messageMetadata = [ ] ; if ( this . instance . isMaster && ! options . blockSync ) { actions . push ( CloudProvider . MESSAGE_ADD_TO_CLUSTER ) ; } if ( ! this . instance . isMaster ) { actions . push ( CloudProvider . MESSAGE_SYNC_COMPLETE ) ; } provider . getMessages ( actions , { toInstanceId : this . instanceId } ) . then ( ( messages ) => { const readPromises = [ ] ; const messagesArray = messages ? messages . slice ( ) : [ ] ; logger . debug ( 'Handling' , messages . length , 'message(s)' ) ; messagesArray . forEach ( ( message ) => { messageMetadata . push ( { action : message . action , toInstanceId : message . toInstanceId , fromInstanceId : message . fromInstanceId } ) ; readPromises . push ( readMessageData . call ( this , provider , bigIp , message . data ) ) ; } ) ; logger . silly ( 'number of messages to read:' , readPromises . length ) ; return q . all ( readPromises ) ; } ) . then ( ( readMessages ) => { let metadata ; let messageData ; const alreadyAdding = function ( instanceId ) { return instanceIdsBeingAdded . find ( ( element ) => { return instanceId === element . toInstanceId ; } ) ; } ; const readMessagesArray = readMessages ? readMessages . slice ( ) : [ ] ; logger . silly ( 'number of read messages:' , readMessagesArray . length ) ; for ( let i = 0 ; i < readMessagesArray . length ; ++ i ) { metadata = messageMetadata [ i ] ; logger . silly ( 'metadata:' , metadata ) ; try { messageData = JSON . parse ( readMessagesArray [ i ] ) ; } catch ( err ) { logger . warn ( 'JSON.parse error:' , err ) ; messageData = undefined ; deferred . reject ( new Error ( 'Unable to JSON parse message' ) ) ; } if ( messageData ) { let discard = false ; switch ( metadata . action ) { 
function becomeMaster ( provider , bigIp , options ) { let hasUcs = false ; logger . info ( 'Becoming master.' ) ; logger . info ( 'Checking for backup UCS.' ) ; return provider . getStoredUcs ( ) . then ( ( response ) => { if ( response ) { hasUcs = true ; return loadUcs ( provider , bigIp , response , options . cloud ) ; } return q ( ) ; } ) . then ( ( ) => { 
function joinCluster ( provider , bigIp , masterIid , options ) { const TEMP_USER_NAME_LENGHTH = 10 ; 
function getAutoscaleProcessCount ( ) { const actions = 'cluster-action update|-c update|cluster-action join|-c join' ; const grepCommand = ` ${ actions } ` ; return util . getProcessCount ( grepCommand ) . then ( ( response ) => { return q ( response ) ; } ) . catch ( ( err ) => { logger . error ( 'Could not determine if another autoscale script is running' ) ; return q . reject ( err ) ; } ) ; } 
function checkForDisconnectedDevices ( bigIp ) { return bigIp . cluster . getCmSyncStatus ( ) . then ( ( response ) => { logger . silly ( 'cmSyncStatus:' , response ) ; const disconnected = response ? response . disconnected : [ ] ; const hostnames = [ ] ; const hostnamesToRemove = [ ] ; 
function initEncryption ( provider , bigIp ) { const PRIVATE_KEY_OUT_FILE = '/tmp/tempPrivateKey.pem' ; let passphrase ; if ( provider . hasFeature ( CloudProvider . FEATURE_ENCRYPTION ) ) { logger . debug ( 'Generating public/private keys for autoscaling.' ) ; return cryptoUtil . generateRandomBytes ( PASSPHRASE_LENGTH , 'base64' ) . then ( ( response ) => { passphrase = response ; return cryptoUtil . generateKeyPair ( PRIVATE_KEY_OUT_FILE , { passphrase , keyLength : '3072' } ) ; } ) . then ( ( publicKey ) => { return provider . putPublicKey ( this . instanceId , publicKey ) ; } ) . then ( ( ) => { return bigIp . installPrivateKey ( PRIVATE_KEY_OUT_FILE , AUTOSCALE_PRIVATE_KEY_FOLDER , AUTOSCALE_PRIVATE_KEY , { passphrase } ) ; } ) . then ( ( ) => { return bigIp . save ( ) ; } ) . catch ( ( err ) => { logger . info ( 'initEncryption error' , err && err . message ? err . message : err ) ; return q . reject ( err ) ; } ) ; } return q ( ) ; } 
function getMasterInstance ( instances ) { let instanceId ; const instanceIds = Object . keys ( instances ) ; for ( let i = 0 ; i < instanceIds . length ; i ++ ) { instanceId = instanceIds [ i ] ; if ( instances [ instanceId ] . isMaster ) { return { id : instanceId , instance : instances [ instanceId ] } ; } } return null ; } 
function markVersions ( instances ) { let highestVersion = '0.0.0' ; let instance ; Object . keys ( instances ) . forEach ( ( instanceId ) => { instance = instances [ instanceId ] ; if ( instance . version && util . versionCompare ( instance . version , highestVersion ) > 0 ) { highestVersion = instance . version ; } } ) ; Object . keys ( instances ) . forEach ( ( instanceId ) => { instance = instances [ instanceId ] ; if ( ! instance . version || util . versionCompare ( instance . version , highestVersion ) === 0 ) { instance . versionOk = true ; } else { instance . versionOk = false ; } } ) ; } 
function isMasterExternalValueOk ( masterId , instances ) { const instanceIds = Object . keys ( instances ) ; let instance ; let hasExternal ; for ( let i = 0 ; i < instanceIds . length ; i ++ ) { instance = instances [ instanceIds [ i ] ] ; if ( instance . external ) { hasExternal = true ; break ; } } if ( hasExternal ) { return ! ! instances [ masterId ] . external ; } return true ; } 
function isMasterExpired ( instance ) { const masterStatus = instance . masterStatus || { } ; let isExpired = false ; let disconnectedMs ; if ( masterStatus . status !== CloudProvider . STATUS_OK ) { disconnectedMs = new Date ( ) - new Date ( masterStatus . lastStatusChange ) ; logger . silly ( 'master has been disconnected for' , disconnectedMs . toString ( ) , 'ms' ) ; if ( disconnectedMs > MAX_DISCONNECTED_MS ) { logger . info ( 'master has been disconnected for too long (' , disconnectedMs . toString ( ) , 'ms )' ) ; isExpired = true ; } } return isExpired ; } 
function loadUcs ( provider , bigIp , ucsData , cloudProvider ) { const timeStamp = Date . now ( ) ; const originalPath = ` ${ timeStamp } ` ; const updatedPath = ` ${ timeStamp } ` ; const updateScript = ` ${ __dirname } ` ; const deferred = q . defer ( ) ; let originalFile ; const preLoad = function ( ) { 
function GenericNodeProvider ( options ) { GenericNodeProvider . super_ . call ( this , options ) ; this . loggerOptions = options ? options . loggerOptions : undefined ; logger = options ? options . logger : undefined ; if ( logger ) { this . logger = logger ; cloudUtil . setLogger ( logger ) ; cryptoUtil . setLogger ( logger ) ; } else if ( this . loggerOptions ) { this . loggerOptions . module = module ; logger = Logger . getLogger ( this . loggerOptions ) ; cloudUtil . setLoggerOptions ( this . loggerOptions ) ; cryptoUtil . setLoggerOptions ( this . loggerOptions ) ; this . logger = logger ; } else { 
function getDataFromPropPath ( pathArray , obj ) { if ( pathArray . length === 0 ) { return undefined ; } return pathArray . reduce ( ( result , prop ) => { if ( typeof result !== 'object' || result === null ) { return { } ; } if ( prop === '' ) { return result ; } return result [ prop ] ; } , obj ) ; } 
function BigIpGtm ( bigIpCore , options ) { const logger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; if ( logger ) { this . logger = logger ; util . setLogger ( logger ) ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; } this . core = bigIpCore ; this . partition = 'Common' ; } 
function prepareArgsForReboot ( ) { const deferred = q . defer ( ) ; let startupScripts ; let startupCommands ; let startupCommandsChanged ; const STARTUP_DIR = '/config/' ; const STARTUP_FILE = ` ${ STARTUP_DIR } ` ; const REBOOT_SIGNAL = ipc . signalBasePath + signals . REBOOT ; if ( ! fs . existsSync ( STARTUP_DIR ) ) { logger . debug ( 'No /config directory. Skipping.' ) ; deferred . resolve ( ) ; return deferred . promise ; } try { startupCommands = fs . readFileSync ( STARTUP_FILE , 'utf8' ) ; } catch ( err ) { logger . warn ( 'Error reading starup file.' ) ; deferred . reject ( err ) ; return deferred . promise ; } try { startupScripts = fs . readdirSync ( REBOOT_SCRIPTS_DIR ) ; } catch ( err ) { logger . warn ( 'Error reading directory with reboot args.' ) ; deferred . reject ( err ) ; return deferred . promise ; } 
function BigIp ( options ) { const logger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; let dependentOptions = { } ; if ( logger ) { this . logger = logger ; util . setLogger ( logger ) ; cryptoUtil . setLogger ( logger ) ; localKeyUtil . setLogger ( logger ) ; authn . setLogger ( logger ) ; dependentOptions = { logger : this . logger } ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; cryptoUtil . setLoggerOptions ( loggerOptions ) ; localKeyUtil . setLoggerOptions ( loggerOptions ) ; authn . setLoggerOptions ( loggerOptions ) ; dependentOptions = { loggerOptions } ; } 
function checkTask ( taskPath , taskIdToCheck , options ) { const func = function ( ) { const deferred = q . defer ( ) ; this . list ( ` ${ taskPath } ${ taskIdToCheck } ` , undefined , util . NO_RETRY ) . then ( ( response ) => { const statusAttribute = ( options && options . statusAttribute ) ? options . statusAttribute : '_taskState' ; const taskState = response [ statusAttribute ] ; if ( taskState === 'VALIDATING' || taskState === 'STARTED' ) { 
function ( passwordsValue ) { const set = passwordsValue . split ( ',new:' ) ; if ( set . length === 2 ) { rootPasswords . old = set [ 0 ] . split ( 'old:' ) [ 1 ] ; rootPasswords . new = set [ 1 ] ; } } 
function GtmDnsProvider ( options ) { const logger = options ? options . logger : undefined ; const loggerOptions = options ? options . loggerOptions : undefined ; GtmDnsProvider . super_ . call ( this , options ) ; this . bigIp = new BigIp ( { logger , loggerOptions } ) ; } 
function getFirstAvailableAddress ( ) { let highestLastOctet = 0 ; usedAddresses . forEach ( ( address ) => { const octets = address . split ( '.' ) ; const thisLastOctet = parseInt ( octets [ 3 ] , 10 ) ; if ( thisLastOctet > highestLastOctet ) { highestLastOctet = thisLastOctet ; } } ) ; highestLastOctet += 1 ; if ( highestLastOctet > 255 ) { this . logger . error ( 'No available addresses for GTM server' ) ; return null ; } return ` ${ highestLastOctet } ` ; } 
function BigIq54LicenseProvider ( bigIp , options ) { const injectedLogger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; this . constructorOptions = { } ; if ( options ) { Object . keys ( options ) . forEach ( ( option ) => { this . constructorOptions [ option ] = options [ option ] ; } ) ; } if ( injectedLogger ) { this . logger = injectedLogger ; util . setLogger ( injectedLogger ) ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; util . setLoggerOptions ( loggerOptions ) ; } this . bigIp = bigIp ; } 
function IControl ( options ) { const opts = options || { } ; const logger = options ? options . logger : undefined ; let loggerOptions = options ? options . loggerOptions : undefined ; if ( logger ) { this . logger = logger ; } else { loggerOptions = loggerOptions || { logLevel : 'none' } ; loggerOptions . module = module ; this . logger = Logger . getLogger ( loggerOptions ) ; } 
function encrypt ( publicKeyDataOrFile , data ) { const deferred = q . defer ( ) ; let publicKeyPromise ; const getPublicKey = function getPublicKey ( publicKeyFile ) { const publicKeyDeferred = q . defer ( ) ; fs . readFile ( publicKeyFile , ( err , publicKey ) => { if ( err ) { logger . warn ( 'Error reading public key:' , err ) ; publicKeyDeferred . reject ( err ) ; } else { publicKeyDeferred . resolve ( publicKey ) ; } } ) ; return publicKeyDeferred . promise ; } ; if ( typeof data !== 'string' ) { deferred . reject ( new Error ( 'data must be a string' ) ) ; return deferred . promise ; } if ( publicKeyDataOrFile . startsWith ( '-----BEGIN PUBLIC KEY-----' ) ) { publicKeyPromise = q ( publicKeyDataOrFile ) ; } else { publicKeyPromise = getPublicKey ( publicKeyDataOrFile ) ; } publicKeyPromise . then ( ( publicKey ) => { let encrypted ; try { encrypted = crypto . publicEncrypt ( publicKey , util . createBufferFrom ( data ) ) ; deferred . resolve ( encrypted . toString ( 'base64' ) ) ; } catch ( err ) { logger . warn ( 'Error encrypting data:' , err ) ; deferred . reject ( err ) ; } } ) . catch ( ( err ) => { logger . warn ( 'Unable to get public key:' , err ) ; deferred . reject ( err ) ; } ) ; return deferred . promise ; } 
function getLabel ( logLevel , moduleLogging , verboseLabel ) { let parts ; let label = '' ; if ( moduleLogging ) { if ( logLevel === 'debug' || logLevel === 'silly' || verboseLabel ) { parts = moduleLogging . filename . split ( '/' ) ; label = ` ${ parts [ parts . length - 2 ] } ${ parts . pop ( ) } ` ; } } return label ; } 
function getLicenseProvider ( poolName , options ) { const methodOptions = { } ; Object . assign ( methodOptions , options ) ; const factoryOptions = { } ; Object . assign ( factoryOptions , this . constructorOptions ) ; let licenseProvider ; if ( methodOptions . autoApiType ) { return getApiType . call ( this , poolName , methodOptions ) . then ( ( apiType ) => { 
function forceResetUserPassword ( user ) { const deferred = q . defer ( ) ; cryptoUtil . generateRandomBytes ( 24 , 'hex' ) . then ( ( randomBytes ) => { util . runShellCommand ( ` ${ randomBytes } \n ${ randomBytes } ${ user } ` ) ; deferred . resolve ( randomBytes ) ; } ) . catch ( ( err ) => { deferred . reject ( err ) ; } ) ; return deferred . promise ; } 
function jscoverage_openWarningDialog ( ) { var id ; if ( jscoverage_isReport ) { id = 'reportWarningDialog' ; } else { id = 'warningDialog' ; } var dialog = document . getElementById ( id ) ; dialog . style . display = 'block' ; } 
function jscoverage_init ( w ) { try { // in Safari, "import" is a syntax error Components . utils [ 'import' ] ( 'resource://app/modules/jscoverage.jsm' ) ; jscoverage_isInvertedMode = true ; return ; } catch ( e ) { } // check if we are in inverted mode if ( w . opener ) { try { if ( w . opener . top . _$jscoverage ) { jscoverage_isInvertedMode = true ; if ( ! w . _$jscoverage ) { w . _$jscoverage = w . opener . top . _$jscoverage ; } } else { jscoverage_isInvertedMode = false ; } } catch ( e ) { try { if ( w . opener . _$jscoverage ) { jscoverage_isInvertedMode = true ; if ( ! w . _$jscoverage ) { w . _$jscoverage = w . opener . _$jscoverage ; } } else { jscoverage_isInvertedMode = false ; } } catch ( e2 ) { jscoverage_isInvertedMode = false ; } } } else { jscoverage_isInvertedMode = false ; } if ( ! jscoverage_isInvertedMode ) { if ( ! w . _$jscoverage ) { w . _$jscoverage = { } ; } } } 
function jscoverage_findPos ( obj ) { var result = 0 ; do { result += obj . offsetTop ; obj = obj . offsetParent ; } while ( obj ) ; return result ; } 
function jscoverage_getViewportHeight ( ) { //#JSCOVERAGE_IF /MSIE/.test(navigator.userAgent) if ( self . innerHeight ) { // all except Explorer return self . innerHeight ; } else if ( document . documentElement && document . documentElement . clientHeight ) { // Explorer 6 Strict Mode return document . documentElement . clientHeight ; } else if ( document . body ) { // other Explorers return document . body . clientHeight ; } else { throw "Couldn't calculate viewport height" ; } //#JSCOVERAGE_ENDIF } 
function jscoverage_beginLengthyOperation ( ) { jscoverage_inLengthyOperation = true ; var progressBar = document . getElementById ( 'progressBar' ) ; progressBar . style . visibility = 'visible' ; ProgressBar . setPercentage ( progressBar , 0 ) ; var progressLabel = document . getElementById ( 'progressLabel' ) ; progressLabel . style . visibility = 'visible' ; //#JSCOVERAGE_IF if ( ! / Opera|WebKit / . test ( navigator . userAgent ) ) { var tabs = document . getElementById ( 'tabs' ) . getElementsByTagName ( 'div' ) ; var i ; for ( i = 0 ; i < tabs . length ; i ++ ) { tabs . item ( i ) . style . cursor = 'wait' ; } } } 
function jscoverage_endLengthyOperation ( ) { var progressBar = document . getElementById ( 'progressBar' ) ; ProgressBar . setPercentage ( progressBar , 100 ) ; setTimeout ( function ( ) { jscoverage_inLengthyOperation = false ; progressBar . style . visibility = 'hidden' ; var progressLabel = document . getElementById ( 'progressLabel' ) ; progressLabel . style . visibility = 'hidden' ; progressLabel . innerHTML = '' ; var tabs = document . getElementById ( 'tabs' ) . getElementsByTagName ( 'div' ) ; var i ; for ( i = 0 ; i < tabs . length ; i ++ ) { tabs . item ( i ) . style . cursor = '' ; } } , 50 ) ; } 
function jscoverage_getBooleanValue ( s ) { s = s . toLowerCase ( ) ; if ( s === 'false' || s === 'f' || s === 'no' || s === 'n' || s === 'off' || s === '0' ) { return false ; } return true ; } 
function jscoverage_initTabContents ( queryString ) { var showMissingColumn = false ; var url = null ; var windowURL = null ; var parameters , parameter , i , index , name , value ; if ( queryString . length > 0 ) { // chop off the question mark queryString = queryString . substring ( 1 ) ; parameters = queryString . split ( / &|; / ) ; for ( i = 0 ; i < parameters . length ; i ++ ) { parameter = parameters [ i ] ; index = parameter . indexOf ( '=' ) ; if ( index === - 1 ) { // still works with old syntax url = decodeURIComponent ( parameter ) ; } else { name = parameter . substr ( 0 , index ) ; value = decodeURIComponent ( parameter . substr ( index + 1 ) ) ; if ( name === 'missing' || name === 'm' ) { showMissingColumn = jscoverage_getBooleanValue ( value ) ; } else if ( name === 'url' || name === 'u' || name === 'frame' || name === 'f' ) { url = value ; } else if ( name === 'window' || name === 'w' ) { windowURL = value ; } } } } var checkbox = document . getElementById ( 'checkbox' ) ; checkbox . checked = showMissingColumn ; if ( showMissingColumn ) { jscoverage_appendMissingColumn ( ) ; } var isValidURL = function ( url ) { var result = jscoverage_isValidURL ( url ) ; if ( ! result ) { alert ( 'Invalid URL: ' + url ) ; } return result ; } ; if ( url !== null && isValidURL ( url ) ) { // this will automatically propagate to the input field frames [ 0 ] . location = url ; } else if ( windowURL !== null && isValidURL ( windowURL ) ) { window . open ( windowURL ) ; } // if the browser tab is absent, we have to initialize the summary tab if ( ! document . getElementById ( 'browserTab' ) ) { jscoverage_recalculateSummaryTab ( ) ; } } 
function jscoverage_makeTable ( ) { var coverage = _$jscoverage [ jscoverage_currentFile ] ; var lines = coverage . source ; // this can happen if there is an error in the original JavaScript file if ( ! lines ) { lines = [ ] ; } var rows = [ '<table id="sourceTable">' ] ; var i = 0 ; var progressBar = document . getElementById ( 'progressBar' ) ; var tableHTML ; var currentConditionalEnd = 0 ; function joinTableRows ( ) { tableHTML = rows . join ( '' ) ; ProgressBar . setPercentage ( progressBar , 60 ) ; setTimeout ( appendTable , 100 ) ; } function appendTable ( ) { var sourceDiv = document . getElementById ( 'sourceDiv' ) ; sourceDiv . innerHTML = tableHTML ; ProgressBar . setPercentage ( progressBar , 80 ) ; setTimeout ( jscoverage_scrollToLine , 0 ) ; } while ( i < lines . length ) { var lineNumber = i + 1 ; if ( lineNumber === currentConditionalEnd ) { currentConditionalEnd = 0 ; } else if ( currentConditionalEnd === 0 && coverage . conditionals && coverage . conditionals [ lineNumber ] ) { currentConditionalEnd = coverage . conditionals [ lineNumber ] ; } var row = '<tr>' ; row += '<td class="numeric">' + lineNumber + '</td>' ; var timesExecuted = coverage [ lineNumber ] ; if ( timesExecuted !== undefined && timesExecuted !== null ) { if ( currentConditionalEnd !== 0 ) { row += '<td class="y numeric">' ; } else if ( timesExecuted === 0 ) { row += '<td class="r numeric" id="line-' + lineNumber + '">' ; } else { row += '<td class="g numeric">' ; } row += timesExecuted ; row += '</td>' ; } else { row += '<td></td>' ; } row += '<td><pre>' + lines [ i ] + '</pre></td>' ; row += '</tr>' ; row += '\n' ; rows [ lineNumber ] = row ; i ++ ; } rows [ i + 1 ] = '</table>' ; ProgressBar . setPercentage ( progressBar , 40 ) ; setTimeout ( joinTableRows , 0 ) ; } 
function jscoverage_recalculateSourceTab ( ) { if ( ! jscoverage_currentFile ) { jscoverage_endLengthyOperation ( ) ; return ; } var progressLabel = document . getElementById ( 'progressLabel' ) ; progressLabel . innerHTML = 'Calculating coverage ...' ; var progressBar = document . getElementById ( 'progressBar' ) ; ProgressBar . setPercentage ( progressBar , 20 ) ; setTimeout ( jscoverage_makeTable , 0 ) ; } 
function jscoverage_initTabControl ( ) { var tabs = document . getElementById ( 'tabs' ) ; var i ; var child ; var tabNum = 0 ; for ( i = 0 ; i < tabs . childNodes . length ; i ++ ) { child = tabs . childNodes . item ( i ) ; if ( child . nodeType === 1 ) { if ( child . className !== 'disabled' ) { child . onclick = jscoverage_tab_click ; } tabNum ++ ; } } jscoverage_selectTab ( 0 ) ; } 
function jscoverage_selectTab ( tab ) { if ( typeof tab !== 'number' ) { tab = jscoverage_tabIndexOf ( tab ) ; } var tabs = document . getElementById ( 'tabs' ) ; var tabPages = document . getElementById ( 'tabPages' ) ; var nodeList ; var tabNum ; var i ; var node ; nodeList = tabs . childNodes ; tabNum = 0 ; for ( i = 0 ; i < nodeList . length ; i ++ ) { node = nodeList . item ( i ) ; if ( node . nodeType !== 1 ) { continue ; } if ( node . className !== 'disabled' ) { if ( tabNum === tab ) { node . className = 'selected' ; } else { node . className = '' ; } } tabNum ++ ; } nodeList = tabPages . childNodes ; tabNum = 0 ; for ( i = 0 ; i < nodeList . length ; i ++ ) { node = nodeList . item ( i ) ; if ( node . nodeType !== 1 ) { continue ; } if ( tabNum === tab ) { node . className = 'selected TabPage' ; } else { node . className = 'TabPage' ; } tabNum ++ ; } } 
function jscoverage_tabIndexOf ( tab ) { if ( typeof tab === 'string' ) { tab = document . getElementById ( tab ) ; } var tabs = document . getElementById ( 'tabs' ) ; var i ; var child ; var tabNum = 0 ; for ( i = 0 ; i < tabs . childNodes . length ; i ++ ) { child = tabs . childNodes . item ( i ) ; if ( child . nodeType === 1 ) { if ( child === tab ) { return tabNum ; } tabNum ++ ; } } //#JSCOVERAGE_IF 0 throw "Tab not found" ; //#JSCOVERAGE_ENDIF } 
function compareAscending ( a , b ) { var ac = a . criteria , bc = b . criteria ; 
function baseClone ( value , deep , callback , stackA , stackB ) { if ( callback ) { var result = callback ( value ) ; if ( typeof result != 'undefined' ) { return result ; } } 
function baseFlatten ( array , isShallow , isArgArrays , fromIndex ) { var index = ( fromIndex || 0 ) - 1 , length = array ? array . length : 0 , result = [ ] ; while ( ++ index < length ) { var value = array [ index ] ; if ( value && typeof value == 'object' && typeof value . length == 'number' && ( isArray ( value ) || isArguments ( value ) ) ) { 
function baseIsEqual ( a , b , callback , isWhere , stackA , stackB ) { 
function createBound ( func , bitmask , partialArgs , partialRightArgs , thisArg , arity ) { var isBind = bitmask & 1 , isBindKey = bitmask & 2 , isCurry = bitmask & 4 , isCurryBound = bitmask & 8 , isPartial = bitmask & 16 , isPartialRight = bitmask & 32 , key = func ; if ( ! isBindKey && ! isFunction ( func ) ) { throw new TypeError ; } if ( isPartial && ! partialArgs . length ) { bitmask &= ~ 16 ; isPartial = partialArgs = false ; } if ( isPartialRight && ! partialRightArgs . length ) { bitmask &= ~ 32 ; isPartialRight = partialRightArgs = false ; } var bindData = func && func . __bindData__ ; if ( bindData ) { if ( isBind && ! ( bindData [ 1 ] & 1 ) ) { bindData [ 4 ] = thisArg ; } if ( ! isBind && bindData [ 1 ] & 1 ) { bitmask |= 8 ; } if ( isCurry && ! ( bindData [ 1 ] & 4 ) ) { bindData [ 5 ] = arity ; } if ( isPartial ) { push . apply ( bindData [ 2 ] || ( bindData [ 2 ] = [ ] ) , partialArgs ) ; } if ( isPartialRight ) { push . apply ( bindData [ 3 ] || ( bindData [ 3 ] = [ ] ) , partialRightArgs ) ; } bindData [ 1 ] |= bitmask ; return createBound . apply ( null , bindData ) ; } 
function clone ( value , deep , callback , thisArg ) { 
function merge ( object ) { var args = arguments , length = 2 ; if ( ! isObject ( object ) ) { return object ; } 
function omit ( object , callback , thisArg ) { var indexOf = getIndexOf ( ) , isFunc = typeof callback == 'function' , result = { } ; if ( isFunc ) { callback = lodash . createCallback ( callback , thisArg , 3 ) ; } else { var props = baseFlatten ( arguments , true , false , 1 ) ; } forIn ( object , function ( value , key , object ) { if ( isFunc ? ! callback ( value , key , object ) : indexOf ( props , key ) < 0 ) { result [ key ] = value ; } } ) ; return result ; } 
function transform ( object , callback , accumulator , thisArg ) { var isArr = isArray ( object ) ; callback = baseCreateCallback ( callback , thisArg , 4 ) ; if ( accumulator == null ) { if ( isArr ) { accumulator = [ ] ; } else { var ctor = object && object . constructor , proto = ctor && ctor . prototype ; accumulator = createObject ( proto ) ; } } ( isArr ? forEach : forOwn ) ( object , function ( value , index , object ) { return callback ( accumulator , value , index , object ) ; } ) ; return accumulator ; } 
function pluck ( collection , property ) { var index = - 1 , length = collection ? collection . length : 0 ; if ( typeof length == 'number' ) { var result = Array ( length ) ; while ( ++ index < length ) { result [ index ] = collection [ index ] [ property ] ; } } return result || map ( collection , property ) ; } 
function reduceRight ( collection , callback , accumulator , thisArg ) { var noaccum = arguments . length < 3 ; callback = baseCreateCallback ( callback , thisArg , 4 ) ; forEachRight ( collection , function ( value , index , collection ) { accumulator = noaccum ? ( noaccum = false , value ) : callback ( accumulator , value , index , collection ) ; } ) ; return accumulator ; } 
function sample ( collection , n , guard ) { var length = collection ? collection . length : 0 ; if ( typeof length != 'number' ) { collection = values ( collection ) ; } if ( n == null || guard ) { return collection ? collection [ random ( length - 1 ) ] : undefined ; } var result = shuffle ( collection ) ; result . length = nativeMin ( nativeMax ( 0 , n ) , result . length ) ; return result ; } 
function sortBy ( collection , callback , thisArg ) { var index = - 1 , length = collection ? collection . length : 0 , result = Array ( typeof length == 'number' ? length : 0 ) ; callback = lodash . createCallback ( callback , thisArg , 3 ) ; forEach ( collection , function ( value , key , collection ) { var object = result [ ++ index ] = getObject ( ) ; object . criteria = callback ( value , key , collection ) ; object . index = index ; object . value = value ; } ) ; length = result . length ; result . sort ( compareAscending ) ; while ( length -- ) { var object = result [ length ] ; result [ length ] = object . value ; releaseObject ( object ) ; } return result ; } 
function difference ( array ) { var index = - 1 , indexOf = getIndexOf ( ) , length = array ? array . length : 0 , seen = baseFlatten ( arguments , true , true , 1 ) , result = [ ] ; var isLarge = length >= largeArraySize && indexOf === baseIndexOf ; if ( isLarge ) { var cache = createCache ( seen ) ; if ( cache ) { indexOf = cacheIndexOf ; seen = cache ; } else { isLarge = false ; } } while ( ++ index < length ) { var value = array [ index ] ; if ( indexOf ( seen , value ) < 0 ) { result . push ( value ) ; } } if ( isLarge ) { releaseObject ( seen ) ; } return result ; } 
function flatten ( array , isShallow , callback , thisArg ) { 
function intersection ( array ) { var args = arguments , argsLength = args . length , argsIndex = - 1 , caches = getArray ( ) , index = - 1 , indexOf = getIndexOf ( ) , length = array ? array . length : 0 , result = [ ] , seen = getArray ( ) ; while ( ++ argsIndex < argsLength ) { var value = args [ argsIndex ] ; caches [ argsIndex ] = indexOf === baseIndexOf && ( value ? value . length : 0 ) >= largeArraySize && createCache ( argsIndex ? args [ argsIndex ] : seen ) ; } outer : while ( ++ index < length ) { var cache = caches [ 0 ] ; value = array [ index ] ; if ( ( cache ? cacheIndexOf ( cache , value ) : indexOf ( seen , value ) ) < 0 ) { argsIndex = argsLength ; ( cache || seen ) . push ( value ) ; while ( -- argsIndex ) { cache = caches [ argsIndex ] ; if ( ( cache ? cacheIndexOf ( cache , value ) : indexOf ( args [ argsIndex ] , value ) ) < 0 ) { continue outer ; } } result . push ( value ) ; } } while ( argsLength -- ) { cache = caches [ argsLength ] ; if ( cache ) { releaseObject ( cache ) ; } } releaseArray ( caches ) ; releaseArray ( seen ) ; return result ; } 
function uniq ( array , isSorted , callback , thisArg ) { 
function bind ( func , thisArg ) { return arguments . length > 2 ? createBound ( func , 17 , nativeSlice . call ( arguments , 2 ) , null , thisArg ) : createBound ( func , 1 , null , null , thisArg ) ; } 
function bindAll ( object ) { var funcs = arguments . length > 1 ? baseFlatten ( arguments , true , false , 1 ) : functions ( object ) , index = - 1 , length = funcs . length ; while ( ++ index < length ) { var key = funcs [ index ] ; object [ key ] = createBound ( object [ key ] , 1 , null , null , object ) ; } return object ; } 
function bindKey ( object , key ) { return arguments . length > 2 ? createBound ( key , 19 , nativeSlice . call ( arguments , 2 ) , null , object ) : createBound ( key , 3 , null , null , object ) ; } 
function curry ( func , arity ) { arity = typeof arity == 'number' ? arity : ( + arity || func . length ) ; return createBound ( func , 4 , null , null , null , arity ) ; } 
function wrap ( value , wrapper ) { if ( ! isFunction ( wrapper ) ) { throw new TypeError ; } return function ( ) { var args = [ value ] ; push . apply ( args , arguments ) ; return wrapper . apply ( this , args ) ; } ; } 
function mixin ( object , source ) { var ctor = object , isFunc = ! source || isFunction ( ctor ) ; if ( ! source ) { ctor = lodashWrapper ; source = object ; object = lodash ; } forEach ( functions ( source ) , function ( methodName ) { var func = object [ methodName ] = source [ methodName ] ; if ( isFunc ) { ctor . prototype [ methodName ] = function ( ) { var value = this . __wrapped__ , args = [ value ] ; push . apply ( args , arguments ) ; var result = func . apply ( object , args ) ; if ( value && typeof value == 'object' && value === result ) { return this ; } result = new ctor ( result ) ; result . __chain__ = this . __chain__ ; return result ; } ; } } ) ; } 
function ( ) { var target = arguments [ 0 ] ; for ( var i = 1 , l = arguments . length ; i < l ; i ++ ) { var extension = arguments [ i ] ; 
function ( ) { this . mixin . deep = this . mixin . supplement = true ; var ret = this . mixin . apply ( this , arguments ) ; this . mixin . deep = this . mixin . supplement = false ; return ret ; } 
function ( args ) { var x = _ . isFinite ( args . x ) ? args . x : 2 ; return _ . template ( '<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>' , { stdDeviation : _ . isFinite ( args . y ) ? [ x , args . y ] : x } ) ; } 
function ( args ) { return _ . template ( '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>' , { dx : args . dx || 0 , dy : args . dy || 0 , color : args . color || 'black' , blur : _ . isFinite ( args . blur ) ? args . blur : 4 } ) ; } 
function ( args ) { var amount = _ . isFinite ( args . amount ) ? args . amount : 1 ; return _ . template ( '<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>' , { a : 0.2126 + 0.7874 * ( 1 - amount ) , b : 0.7152 - 0.7152 * ( 1 - amount ) , c : 0.0722 - 0.0722 * ( 1 - amount ) , d : 0.2126 - 0.2126 * ( 1 - amount ) , e : 0.7152 + 0.2848 * ( 1 - amount ) , f : 0.0722 - 0.0722 * ( 1 - amount ) , g : 0.2126 - 0.2126 * ( 1 - amount ) , h : 0.0722 + 0.9278 * ( 1 - amount ) } ) ; } 
function ( args ) { var amount = _ . isFinite ( args . amount ) ? args . amount : 1 ; return _ . template ( '<filter><feColorMatrix type="saturate" values="${amount}"/></filter>' , { amount : 1 - amount } ) ; } 
function createElement ( el , attrs , children ) { if ( ! el ) return undefined ; 
function VElement ( el ) { this . node = el ; if ( ! this . node . id ) { this . node . id = _ . uniqueId ( 'v_' ) ; } } 
function ( sx , sy ) { sy = ( typeof sy === 'undefined' ) ? sx : sy ; var transformAttr = this . attr ( 'transform' ) || '' , transform = parseTransformString ( transformAttr ) ; 
function ( withoutTransformations , target ) { 
function ( x , y ) { var svg = this . svg ( ) . node ; var p = svg . createSVGPoint ( ) ; p . x = x ; p . y = y ; try { var globalPoint = p . matrixTransform ( svg . getScreenCTM ( ) . inverse ( ) ) ; var globalToLocalMatrix = this . node . getTransformToElement ( svg ) . inverse ( ) ; } catch ( e ) { 
function ( position , reference , target ) { 
function point ( x , y ) { if ( ! ( this instanceof point ) ) return new point ( x , y ) ; var xy ; if ( y === undefined && Object ( x ) !== x ) { xy = x . split ( _ . indexOf ( x , "@" ) === - 1 ? " " : "@" ) ; this . x = parseInt ( xy [ 0 ] , 10 ) ; this . y = parseInt ( xy [ 1 ] , 10 ) ; } else if ( Object ( x ) === x ) { this . x = x . x ; this . y = x . y ; } else { this . x = x ; this . y = y ; } } 
function ( r ) { if ( r . containsPoint ( this ) ) { return this ; } this . x = mmin ( mmax ( this . x , r . x ) , r . x + r . width ) ; this . y = mmin ( mmax ( this . y , r . y ) , r . y + r . height ) ; return this ; } 
function ( p ) { p = point ( p ) ; 
function ( len ) { var s = ( len || 1 ) / this . magnitude ( ) ; this . x = s * this . x ; this . y = s * this . y ; return this ; } 
function ( o ) { o = ( o && point ( o ) ) || point ( 0 , 0 ) ; var x = this . x ; var y = this . y ; this . x = sqrt ( ( x - o . x ) * ( x - o . x ) + ( y - o . y ) * ( y - o . y ) ) ; 
function ( o , angle ) { angle = ( angle + 360 ) % 360 ; this . toPolar ( o ) ; this . y += toRad ( angle ) ; var p = point . fromPolar ( this . x , this . y , o ) ; this . x = p . x ; this . y = p . y ; return this ; } 
function ( ref , distance ) { var theta = toRad ( point ( ref ) . theta ( this ) ) ; return this . offset ( cos ( theta ) * distance , - sin ( theta ) * distance ) ; } 
function ( dx , dy , ref ) { 
function line ( p1 , p2 ) { if ( ! ( this instanceof line ) ) return new line ( p1 , p2 ) ; this . start = point ( p1 ) ; this . end = point ( p2 ) ; } 
function rect ( x , y , w , h ) { if ( ! ( this instanceof rect ) ) return new rect ( x , y , w , h ) ; if ( y === undefined ) { y = x . y ; w = x . width ; h = x . height ; x = x . x ; } this . x = x ; this . y = y ; this . width = w ; this . height = h ; } 
function ( p , angle ) { p = point ( p ) ; var center = point ( this . x + this . width / 2 , this . y + this . height / 2 ) ; var result ; if ( angle ) p . rotate ( center , angle ) ; 
function ( r ) { this . x += r . x ; this . y += r . y ; this . width += r . width ; this . height += r . height ; return this ; } 
function ellipse ( c , a , b ) { if ( ! ( this instanceof ellipse ) ) return new ellipse ( c , a , b ) ; c = point ( c ) ; this . x = c . x ; this . y = c . y ; this . a = a ; this . b = b ; } 
function ( p , angle ) { p = point ( p ) ; if ( angle ) p . rotate ( point ( this . x , this . y ) , angle ) ; var dx = p . x - this . x ; var dy = p . y - this . y ; var result ; if ( dx === 0 ) { result = this . bbox ( ) . pointNearestToPoint ( p ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; } var m = dy / dx ; var mSquared = m * m ; var aSquared = this . a * this . a ; var bSquared = this . b * this . b ; var x = sqrt ( 1 / ( ( 1 / aSquared ) + ( mSquared / bSquared ) ) ) ; x = dx < 0 ? - x : x ; var y = m * x ; result = point ( this . x + x , this . y + y ) ; if ( angle ) return result . rotate ( point ( this . x , this . y ) , - angle ) ; return result ; } 
function ( points ) { var controlPoints = this . getCurveControlPoints ( points ) ; var path = [ 'M' , points [ 0 ] . x , points [ 0 ] . y ] ; for ( var i = 0 ; i < controlPoints [ 0 ] . length ; i ++ ) { path . push ( 'C' , controlPoints [ 0 ] [ i ] . x , controlPoints [ 0 ] [ i ] . y , controlPoints [ 1 ] [ i ] . x , controlPoints [ 1 ] [ i ] . y , points [ i + 1 ] . x , points [ i + 1 ] . y ) ; } return path ; } 
function ( knots ) { var firstControlPoints = [ ] ; var secondControlPoints = [ ] ; var n = knots . length - 1 ; var i ; 
function ( rhs ) { var n = rhs . length ; 
function ( model , opt ) { opt = opt || { } ; if ( _ . isUndefined ( opt . inbound ) && _ . isUndefined ( opt . outbound ) ) { opt . inbound = opt . outbound = true ; } var links = [ ] ; this . each ( function ( cell ) { var source = cell . get ( 'source' ) ; var target = cell . get ( 'target' ) ; if ( source && source . id === model . id && opt . outbound ) { links . push ( cell ) ; } if ( target && target . id === model . id && opt . inbound ) { links . push ( cell ) ; } } ) ; return links ; } 
function ( model ) { _ . each ( this . getConnectedLinks ( model ) , function ( link ) { link . set ( link . get ( 'source' ) . id === model . id ? 'source' : 'target' , g . point ( 0 , 0 ) ) ; } ) ; } 
function ( attrs , value , opt ) { var currentAttrs = this . get ( 'attrs' ) ; var delim = '/' ; if ( _ . isString ( attrs ) ) { 
function ( ) { var el ; if ( ! this . el ) { var attrs = _ . extend ( { id : this . id } , _ . result ( this , 'attributes' ) ) ; if ( this . className ) attrs [ 'class' ] = _ . result ( this , 'className' ) ; el = V ( _ . result ( this , 'tagName' ) , attrs ) . node ; } else { el = _ . result ( this , 'el' ) } this . setElement ( el , false ) ; } 
function ( el ) { var $el = this . $ ( el ) ; if ( $el . length === 0 || $el [ 0 ] === this . el ) { 
function ( selector , filter ) { var $selected = this . findBySelector ( selector ) ; 
function ( selector , attr , gradient ) { var $selected = this . findBySelector ( selector ) ; 
function ( el , selector ) { if ( el === this . el ) { return selector ; } var index = $ ( el ) . index ( ) ; selector = el . tagName + ':nth-child(' + ( index + 1 ) + ')' + ' ' + ( selector || '' ) ; return this . getSelector ( $ ( el ) . parent ( ) [ 0 ] , selector + ' ' ) ; } 
function ( cell , renderingOnlyAttrs ) { var allAttrs = this . model . get ( 'attrs' ) ; var rotatable = V ( this . $ ( '.rotatable' ) [ 0 ] ) ; if ( rotatable ) { var rotation = rotatable . attr ( 'transform' ) ; rotatable . attr ( 'transform' , '' ) ; } var relativelyPositioned = [ ] ; _ . each ( renderingOnlyAttrs || allAttrs , function ( attrs , selector ) { 
function ( ) { var markup = this . model . markup || this . model . get ( 'markup' ) ; if ( markup ) { var nodes = V ( markup ) ; V ( this . el ) . append ( nodes ) ; } else { throw new Error ( 'properties.markup is missing while the default render() implementation is used.' ) ; } this . update ( ) ; this . resize ( ) ; this . rotate ( ) ; this . translate ( ) ; return this ; } 
function ( evt , x , y ) { if ( 
function ( idx , value ) { idx = idx || 0 ; var labels = this . get ( 'labels' ) || [ ] ; 
function ( ) { this . $el . empty ( ) ; 
function ( ) { 
function ( endType ) { function watchEnd ( link , end ) { end = end || { } ; var previousEnd = link . previous ( endType ) || { } ; 
function ( vertex ) { this . model . set ( 'attrs' , this . model . get ( 'attrs' ) || { } ) ; var attrs = this . model . get ( 'attrs' ) ; 
function ( vertices ) { var sourcePoint = g . point ( this . _sourcePoint ) ; var targetPoint = g . point ( this . _targetPoint ) ; 
function ( end , selectorOrPoint , referenceSelectorOrPoint ) { var spot ; if ( this . _isPoint ( selectorOrPoint ) ) { 
function ( vertices ) { vertices = ( vertices || [ ] ) . slice ( ) ; var manhattanVertices = [ ] ; 
function findMiddleVertex ( p1 , p2 , preferredDirection ) { var direction = bestDirection ( p1 , p2 , preferredDirection ) ; if ( direction === 'down' || direction === 'up' ) { return { x : p1 . x , y : p2 . y , d : direction } ; } return { x : p2 . x , y : p1 . y , d : direction } ; } 
function ( ) { this . model . trigger ( 'batch:start' ) ; this . _z = this . model . get ( 'z' ) ; this . model . set ( 'z' , Number . MAX_VALUE ) ; 
function ( gridWidth , gridHeight , padding ) { gridWidth = gridWidth || 1 ; gridHeight = gridHeight || 1 ; padding = padding || 0 ; 
function ( cell ) { var id = _ . isString ( cell ) ? cell : cell . id ; var $view = this . $ ( '[model-id="' + id + '"]' ) ; if ( $view . length ) { return $view . data ( 'view' ) ; } return undefined ; } 
function ( p ) { p = g . point ( p ) ; var views = _ . map ( this . model . getElements ( ) , this . findViewByModel ) ; return _ . filter ( views , function ( view ) { return g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) . containsPoint ( p ) ; } , this ) ; } 
function ( r ) { r = g . rect ( r ) ; var views = _ . map ( this . model . getElements ( ) , this . findViewByModel ) ; return _ . filter ( views , function ( view ) { return r . intersect ( g . rect ( V ( view . el ) . bbox ( false , this . viewport ) ) ) ; } , this ) ; } 
function ( command ) { return _ . isArray ( command ) ? _ . find ( command , function ( singleCmd ) { return ! this . _validateCommand ( singleCmd ) ; } , this ) : this . _validateCommand ( command ) ; } 
function ( command ) { 
function ( selection , graph , opt ) { opt = opt || { } ; 
function ( graph , opt ) { opt = opt || { } ; if ( opt . useLocalStorage && this . length === 0 && window . localStorage ) { this . reset ( JSON . parse ( localStorage . getItem ( 'joint.ui.Clipboard.cells' ) ) ) ; } graph . trigger ( 'batch:start' ) ; this . each ( function ( cell ) { cell . unset ( 'z' ) ; if ( ( cell instanceof joint . dia . Link ) && opt . link ) { cell . set ( opt . link ) ; } graph . addCell ( cell . toJSON ( ) ) ; } ) ; graph . trigger ( 'batch:stop' ) ; } 
function ( ) { this . _magnets = [ ] ; var $link = this . $ ( '.link' ) ; var magnetElements = this . options . cellView . $ ( '[magnet="true"]' ) ; if ( this . options . magnetFilter ) { if ( _ . isFunction ( this . options . magnetFilter ) ) { 
function ( path , options ) { var cell = this . options . cellView . model ; var value = joint . util . getByPath ( cell . attributes , path , '/' ) ; if ( _ . isUndefined ( value ) && ! _ . isUndefined ( options . defaultValue ) ) { value = options . defaultValue ; } if ( options . valueRegExp ) { if ( _ . isUndefined ( value ) ) { throw new Error ( 'Inspector: defaultValue must be present when valueRegExp is used.' ) ; } var valueMatch = value . match ( new RegExp ( options . valueRegExp ) ) ; value = valueMatch && valueMatch [ 2 ] ; } return value ; } 
function ( type , value , targetElement ) { switch ( type ) { case 'number' : value = parseFloat ( value ) ; break ; case 'toggle' : value = targetElement . checked ; break ; default : value = value ; break ; } return value ; } 
function initLayoutGraph ( inputGraph ) { var g = new CDigraph ( ) ; inputGraph . eachNode ( function ( u , value ) { if ( value === undefined ) value = { } ; g . addNode ( u , { width : value . width , height : value . height } ) ; if ( value . hasOwnProperty ( 'rank' ) ) { g . node ( u ) . prefRank = value . rank ; } } ) ; 
function normalize ( g ) { var dummyCount = 0 ; g . eachEdge ( function ( e , s , t , a ) { var sourceRank = g . node ( s ) . rank ; var targetRank = g . node ( t ) . rank ; if ( sourceRank + 1 < targetRank ) { for ( var u = s , rank = sourceRank + 1 , i = 0 ; rank < targetRank ; ++ rank , ++ i ) { var v = '_D' + ( ++ dummyCount ) ; var node = { width : a . width , height : a . height , edge : { id : e , source : s , target : t , attrs : a } , rank : rank , dummy : true } ; 
function undoNormalize ( g ) { g . eachNode ( function ( u , a ) { if ( a . dummy ) { if ( 'index' in a ) { var edge = a . edge ; if ( ! g . hasEdge ( edge . id ) ) { g . addEdge ( edge . id , edge . source , edge . target , edge . attrs ) ; } var points = g . edge ( edge . id ) . points ; points [ a . index ] = { x : a . x , y : a . y , ul : a . ul , ur : a . ur , dl : a . dl , dr : a . dr } ; } g . delNode ( u ) ; } } ) ; } 
function fixupEdgePoints ( g ) { g . eachEdge ( function ( e , s , t , a ) { if ( a . reversed ) a . points . reverse ( ) ; } ) ; } 
function delegateProperty ( f ) { return function ( ) { if ( ! arguments . length ) return f ( ) ; f . apply ( null , arguments ) ; return self ; } ; } 
function order ( g , maxSweeps ) { if ( arguments . length < 2 ) { maxSweeps = DEFAULT_MAX_SWEEPS ; } var layerGraphs = initLayerGraphs ( g ) ; 
function saveBest ( g ) { var graph = g . graph ( ) ; var cc = crossCount ( g ) ; if ( ! ( 'orderCC' in graph ) || graph . orderCC > cc ) { graph . orderCC = cc ; graph . order = { } ; g . eachNode ( function ( u , value ) { if ( 'order' in value ) { graph . order [ u ] = value . order ; } } ) ; return true ; } return false ; } 
function crossCount ( g ) { var cc = 0 ; var ordering = util . ordering ( g ) ; for ( var i = 1 ; i < ordering . length ; ++ i ) { cc += twoLayerCrossCount ( g , ordering [ i - 1 ] , ordering [ i ] ) ; } return cc ; } 
function undirEdgeId ( u , v ) { return u < v ? u . toString ( ) . length + ':' + u + '-' + v : v . toString ( ) . length + ':' + v + '-' + u ; } 
function horizontalCompaction ( g , layering , pos , root , align ) { var sink = { } , 
function run ( g , useSimplex ) { var selfLoops = removeSelfLoops ( g ) ; 
function acyclic ( g ) { var onStack = { } , visited = { } , reverseCount = 0 ; function dfs ( u ) { if ( u in visited ) return ; visited [ u ] = onStack [ u ] = true ; g . outEdges ( u ) . forEach ( function ( e ) { var t = g . target ( e ) , value ; if ( u === t ) { console . error ( 'Warning: found self loop "' + e + '" for node "' + u + '"' ) ; } else if ( t in onStack ) { value = g . edge ( e ) ; g . delEdge ( e ) ; value . reversed = true ; ++ reverseCount ; g . addEdge ( e , t , u , value ) ; } else { dfs ( t ) ; } } ) ; delete onStack [ u ] ; } g . eachNode ( function ( u ) { dfs ( u ) ; } ) ; util . log ( 2 , 'Acyclic Phase: reversed ' + reverseCount + ' edge(s)' ) ; return reverseCount ; } 
function undo ( g ) { g . eachEdge ( function ( e , s , t , a ) { if ( a . reversed ) { delete a . reversed ; g . delEdge ( e ) ; g . addEdge ( e , t , s , a ) ; } } ) ; } 
function findMinSlack ( ) { var result , eSlack = Number . POSITIVE_INFINITY ; minLen . forEach ( function ( mle ) { if ( remaining . has ( mle . u ) !== remaining . has ( mle . v ) ) { var mleSlack = rankUtil . slack ( g , mle . u , mle . v , mle . len ) ; if ( mleSlack < eSlack ) { if ( ! remaining . has ( mle . u ) ) { result = { treeNode : mle . u , graphNode : mle . v , len : mle . len , reversed : false , weight : mle . weight } ; } else { result = { treeNode : mle . v , graphNode : mle . u , len : - mle . len , reversed : true , weight : mle . weight } ; } eSlack = mleSlack ; } } } ) ; return result ; } 
function incidenceId ( u , v ) { return u < v ? u . length + ':' + u + '-' + v : v . length + ':' + v + '-' + u ; } 
function slack ( graph , u , v , minLen ) { return Math . abs ( graph . node ( u ) . rank - graph . node ( v ) . rank ) - minLen ; } 
function initCutValues ( graph , spanningTree ) { computeLowLim ( spanningTree ) ; spanningTree . eachEdge ( function ( id , u , v , treeValue ) { treeValue . cutValue = 0 ; } ) ; 
function dfs ( n ) { var children = spanningTree . successors ( n ) ; for ( var c in children ) { var child = children [ c ] ; dfs ( child ) ; } if ( n !== spanningTree . graph ( ) . root ) { setCutValue ( graph , spanningTree , n ) ; } } 
function computeLowLim ( tree ) { var postOrderNum = 0 ; function dfs ( n ) { var children = tree . successors ( n ) ; var low = postOrderNum ; for ( var c in children ) { var child = children [ c ] ; dfs ( child ) ; low = Math . min ( low , tree . node ( child ) . low ) ; } tree . node ( n ) . low = low ; tree . node ( n ) . lim = postOrderNum ++ ; } dfs ( tree . graph ( ) . root ) ; } 
function setCutValue ( graph , tree , child ) { var parentEdge = tree . inEdges ( child ) [ 0 ] ; 
function inSubtree ( tree , n , root ) { return ( tree . node ( root ) . low <= tree . node ( n ) . lim && tree . node ( n ) . lim <= tree . node ( root ) . lim ) ; } 
function leaveEdge ( tree ) { var edges = tree . edges ( ) ; for ( var n in edges ) { var e = edges [ n ] ; var treeValue = tree . edge ( e ) ; if ( treeValue . cutValue < 0 ) { return e ; } } return null ; } 
function enterEdge ( graph , tree , e ) { var source = tree . source ( e ) ; var target = tree . target ( e ) ; var lower = tree . node ( target ) . lim < tree . node ( source ) . lim ? target : source ; 
function exchange ( graph , tree , e , f ) { tree . delEdge ( e ) ; var source = graph . source ( f ) ; var target = graph . target ( f ) ; 
function redirect ( v ) { var edges = tree . inEdges ( v ) ; for ( var i in edges ) { var e = edges [ i ] ; var u = tree . source ( e ) ; var value = tree . edge ( e ) ; redirect ( u ) ; tree . delEdge ( e ) ; value . reversed = ! value . reversed ; tree . addEdge ( e , v , u , value ) ; } } 
function adjustRanks ( graph , tree ) { function dfs ( p ) { var children = tree . successors ( p ) ; children . forEach ( function ( c ) { var minLen = minimumLength ( graph , p , c ) ; graph . node ( c ) . rank = graph . node ( p ) . rank + minLen ; dfs ( c ) ; } ) ; } dfs ( tree . graph ( ) . root ) ; } 
function minimumLength ( graph , u , v ) { var outEdges = graph . outEdges ( u , v ) ; if ( outEdges . length > 0 ) { return util . max ( outEdges . map ( function ( e ) { return graph . edge ( e ) . minLen ; } ) ) ; } var inEdges = graph . inEdges ( u , v ) ; if ( inEdges . length > 0 ) { return - util . max ( inEdges . map ( function ( e ) { return graph . edge ( e ) . minLen ; } ) ) ; } } 
function log ( level ) { if ( log . level >= level ) { console . log . apply ( console , Array . prototype . slice . call ( arguments , 1 ) ) ; } } 
function Set ( initialKeys ) { this . _size = 0 ; this . _keys = { } ; if ( initialKeys ) { for ( var i = 0 , il = initialKeys . length ; i < il ; ++ i ) { this . add ( initialKeys [ i ] ) ; } } } 
function values ( o ) { var ks = Object . keys ( o ) , len = ks . length , result = new Array ( len ) , i ; for ( i = 0 ; i < len ; ++ i ) { result [ i ] = o [ ks [ i ] ] ; } return result ; } 
function dijkstraAll ( g , weightFunc , incidentFunc ) { var results = { } ; g . nodes ( ) . forEach ( function ( u ) { results [ u ] = dijkstra ( g , u , weightFunc , incidentFunc ) ; } ) ; return results ; } 
function isAcyclic ( g ) { try { topsort ( g ) ; } catch ( e ) { if ( e instanceof topsort . CycleException ) return false ; throw e ; } return true ; } 
function topsort ( g ) { if ( ! g . isDirected ( ) ) { throw new Error ( "topsort can only be applied to a directed graph. Bad input: " + g ) ; } var visited = { } ; var stack = { } ; var results = [ ] ; function visit ( node ) { if ( node in stack ) { throw new CycleException ( ) ; } if ( ! ( node in visited ) ) { stack [ node ] = true ; visited [ node ] = true ; g . predecessors ( node ) . forEach ( function ( pred ) { visit ( pred ) ; } ) ; delete stack [ node ] ; results . push ( node ) ; } } var sinks = g . sinks ( ) ; if ( g . order ( ) !== 0 && sinks . length === 0 ) { throw new CycleException ( ) ; } g . sinks ( ) . forEach ( function ( sink ) { visit ( sink ) ; } ) ; return results ; } 
function ( elements , dimension ) { return _ . reduce ( elements , function ( max , el ) { return Math . max ( el . get ( 'size' ) [ dimension ] , max ) ; } , 0 ) ; } 
function createCanvas ( ) { canvas = document . createElement ( 'canvas' ) ; canvas . width = imageWidth ; canvas . height = imageHeight ; 
function on ( el , types , fn , context ) { types . split ( ' ' ) . forEach ( function ( type ) { L . DomEvent . on ( el , type , fn , context ) } ) } 
function ( eventaur , settings ) { var gith = this ; this . settings = settings || { } ; 
function ( eventaur , port ) { var gith = this ; 
function getUserMedia ( constraints ) { if ( props ( 'navigator.mediaDevices.getUserMedia' ) . hadBy ( window ) ) { let medias = props ( 'navigator.mediaDevices' ) . from ( window ) return medias . getUserMedia ( constraints ) } let userMediaGetter = navigator . getUserMedia || navigator . webkitGetUserMedia || navigator . mozGetUserMedia || navigator . msGetUserMedia if ( ! userMediaGetter ) { throw new Error ( 'getUserMedia is not supported by this browser' ) } return new Promise ( ( resolve , reject ) => { userMediaGetter ( constraints , resolve , reject ) } ) } 
function buildConfig ( wantedEnv ) { let isValid = wantedEnv && wantedEnv . length > 0 && allowedEnvs . indexOf ( wantedEnv ) !== - 1 ; let validEnv = isValid ? wantedEnv : 'dev' ; let config = require ( path . join ( __dirname , 'cfg/' + validEnv ) ) ; return config ; } 
async function barcodeDecoder ( image , options ) { 
function createImageData ( image ) { const canvas = document . createElement ( 'canvas' ) const ctx = canvas . getContext ( '2d' ) const width = image . naturalWidth const height = image . naturalHeight canvas . width = width canvas . height = height ctx . drawImage ( image , 0 , 0 ) return ctx . getImageData ( 0 , 0 , image . naturalWidth , image . naturalHeight ) } 
async function getImageDataFromSource ( source ) { const isStringSource = typeof source === 'string' const isURLSource = isStringSource ? isUrl ( source ) : false const { tagName } = source return new Promise ( ( resolve , reject ) => { 
function stdopts ( opts ) { opts = opts || { } opts . keys = opts . keys !== false 
function get_timeout_delay ( date , settings ) { var now = get_now ( ) ; var diff = ( ( now . getTime ( ) - date . getTime ( ) ) / 1000 ) ; var diff_abs = Math . abs ( diff ) ; if ( isNaN ( diff ) ) return ; var last_limit = 0 ; for ( var i in settings . units ) { var unit = settings . units [ i ] ; 
function get_date ( element , settings ) { var date = element . data ( "easydate.date" ) ; if ( isNaN ( date ) ) { var timestamp ; var time = Date . parse ( timestamp = element . attr ( "title" ) ) || Date . parse ( timestamp = element . html ( ) ) ; if ( ! isNaN ( time ) ) { date = new Date ( ) ; date . setTime ( time ) ; element . data ( "easydate.date" , date ) ; if ( settings . set_title && ! element . attr ( "title" ) ) element . attr ( "title" , timestamp ) ; } } return date ; } 
function update_time ( element ) { var settings = element . data ( "easydate.settings" ) ; var element_id = $ . data ( element [ 0 ] ) ; elements [ element_id ] = element ; delete updates [ element_id ] ; var date = get_date ( element , settings ) ; if ( isNaN ( date ) ) return ; element . html ( format_date ( date , settings ) ) ; if ( settings . live ) { var timeout = get_timeout_delay ( date , settings ) ; if ( ! isNaN ( timeout ) ) { if ( timeout > 2147483647 ) timeout = 2147483647 ; 
function parse ( s , buf , offset ) { var i = ( buf && offset ) || 0 , ii = 0 ; buf = buf || [ ] ; s . toLowerCase ( ) . replace ( / [0-9a-f]{2} / g , function ( oct ) { if ( ii < 16 ) { 
function ( req , res , next ) { var props = getProps ( req . query ) ; 
function ( type ) { var qp = { error : type , state : props . state } ; res . redirect ( props . redirect_uri + "?" + qs . stringify ( qp ) ) ; } 
function ( req , res , next ) { var props = getProps ( req . body ) ; 
function ( req , res , next ) { var props = getProps ( req . query ) ; 
function ( req , res , next ) { var props = getProps ( req . body ) ; var retry = function ( message ) { req . session . oauth2AuthcError = message ; res . redirect ( 303 , "/oauth2/authc?" + qs . stringify ( props ) ) ; } ; 
function ( props ) { var inst , cls = this , key = props [ cls . keyAttr ] ; if ( key && _ . has ( cls . cache , key ) ) { inst = cls . cache [ key ] ; 
function init ( ) { if ( api . initialized ) { return ; } var testRange ; var implementsDomRange = false , implementsTextRange = false ; 
function splitDataNode ( node , index ) { var newNode = node . cloneNode ( false ) ; newNode . deleteData ( 0 , index ) ; node . deleteData ( index , node . length - index ) ; insertAfter ( newNode , node ) ; return newNode ; } 
function isNonTextPartiallySelected ( node , range ) { return ( node . nodeType != 3 ) && ( dom . isAncestorOf ( node , range . startContainer , true ) || dom . isAncestorOf ( node , range . endContainer , true ) ) ; } 
function RangeIterator ( range , clonePartiallySelectedTextNodes ) { this . range = range ; this . clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes ; if ( ! range . collapsed ) { this . sc = range . startContainer ; this . so = range . startOffset ; this . ec = range . endContainer ; this . eo = range . endOffset ; var root = range . commonAncestorContainer ; if ( this . sc === this . ec && dom . isCharacterDataNode ( this . sc ) ) { this . isSingleCharacterDataNode = true ; this . _first = this . _last = this . _next = this . sc ; } else { this . _first = this . _next = ( this . sc === root && ! dom . isCharacterDataNode ( this . sc ) ) ? this . sc . childNodes [ this . so ] : dom . getClosestAncestorIn ( this . sc , root , true ) ; this . _last = ( this . ec === root && ! dom . isCharacterDataNode ( this . ec ) ) ? this . ec . childNodes [ this . eo - 1 ] : dom . getClosestAncestorIn ( this . ec , root , true ) ; } } } 
function RangeNodeIterator ( range , nodeTypes , filter ) { this . nodes = getNodesInRange ( range , nodeTypes , filter ) ; this . _next = this . nodes [ 0 ] ; this . _position = 0 ; } 
function ( fragmentStr ) { 
function ( fragmentStr ) { assertNotDetached ( this ) ; var doc = getRangeDocument ( this ) ; var el = doc . createElement ( "body" ) ; el . innerHTML = fragmentStr ; return dom . fragmentFromNodeChildren ( el ) ; } 
function ( range , touchingIsIntersecting ) { assertRangeValid ( this ) ; if ( getRangeDocument ( range ) != getRangeDocument ( this ) ) { throw new DOMException ( "WRONG_DOCUMENT_ERR" ) ; } var startComparison = dom . comparePoints ( this . startContainer , this . startOffset , range . endContainer , range . endOffset ) , endComparison = dom . comparePoints ( this . endContainer , this . endOffset , range . startContainer , range . startOffset ) ; return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0 ; } 
function getTextRangeBoundaryPosition ( textRange , wholeRangeContainerElement , isStart , isCollapsed ) { var workingRange = textRange . duplicate ( ) ; workingRange . collapse ( isStart ) ; var containerElement = workingRange . parentElement ( ) ; For the particular case of a boundary within a text node containing line breaks (within a <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in IE. The facts: - Each line break is represented as \r in the text node's data/nodeValue properties - Each line break is represented as \r\n in the TextRange's 'text' property - The 'text' property of the TextRange does not contain trailing line breaks To get round the problem presented by the final fact above, we can use the fact that TextRange's moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily the same as the number of characters it was instructed to move. The simplest approach is to use this to store the characters moved when moving both the start and end of the range to the start of the document body and subtracting the start offset from the end offset (the "move-negative-gazillion" method). However, this is extremely slow when the document is large and the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same problem. Another approach that works is to use moveStart() to move the start boundary of the range up to the end boundary one character at a time and incrementing a counter with the value returned by the moveStart() call. However, the check for whether the start boundary has reached the end boundary is expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected by the location of the range within the document). The method below is a hybrid of the two methods above. It uses the fact that a string containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot be longer than the text of the TextRange, so the start of the range is moved that length initially and then a character at a time to make up for any trailing line breaks not contained in the 'text' property. This has good performance in most situations compared to the previous two methods. */ var tempRange = workingRange . duplicate ( ) ; var rangeLength = tempRange . text . replace ( / \r\n / g , "\r" ) . length ; offset = tempRange . moveStart ( "character" , rangeLength ) ; while ( ( comparison = tempRange . compareEndPoints ( "StartToEnd" , tempRange ) ) == - 1 ) { offset ++ ; tempRange . moveStart ( "character" , 1 ) ; } } else { offset = workingRange . text . length ; } boundaryPosition = new DomPosition ( boundaryNode , offset ) ; } else { 
function createBoundaryTextRange ( boundaryPosition , isStart ) { var boundaryNode , boundaryParent , boundaryOffset = boundaryPosition . offset ; var doc = dom . getDocument ( boundaryPosition . node ) ; var workingNode , childNodes , workingRange = doc . body . createTextRange ( ) ; var nodeIsDataNode = dom . isCharacterDataNode ( boundaryPosition . node ) ; if ( nodeIsDataNode ) { boundaryNode = boundaryPosition . node ; boundaryParent = boundaryNode . parentNode ; } else { childNodes = boundaryPosition . node . childNodes ; boundaryNode = ( boundaryOffset < childNodes . length ) ? childNodes [ boundaryOffset ] : null ; boundaryParent = boundaryPosition . node ; } 
function ( sel , range ) { var ranges = sel . getAllRanges ( ) , removed = false ; sel . removeAllRanges ( ) ; for ( var i = 0 , len = ranges . length ; i < len ; ++ i ) { if ( removed || range !== ranges [ i ] ) { sel . addRange ( ranges [ i ] ) ; } else { 
function ( needle ) { if ( arr . indexOf ) { return arr . indexOf ( needle ) !== - 1 ; } else { for ( var i = 0 , length = arr . length ; i < length ; i ++ ) { if ( arr [ i ] === needle ) { return true ; } } return false ; } } 
function _wrapMatchesInNode ( textNode ) { var parentNode = textNode . parentNode , tempElement = _getTempElement ( parentNode . ownerDocument ) ; 
function parse ( elementOrHtml , rules , context , cleanUp ) { wysihtml5 . lang . object ( currentRules ) . merge ( defaultRules ) . merge ( rules ) . get ( ) ; context = context || elementOrHtml . ownerDocument || document ; var fragment = context . createDocumentFragment ( ) , isString = typeof ( elementOrHtml ) === "string" , element , newNode , firstChild ; if ( isString ) { element = wysihtml5 . dom . getAsDom ( elementOrHtml , context ) ; } else { element = elementOrHtml ; } while ( element . firstChild ) { firstChild = element . firstChild ; element . removeChild ( firstChild ) ; newNode = _convert ( firstChild , cleanUp ) ; if ( newNode ) { fragment . appendChild ( newNode ) ; } } 
function ( iframe ) { 
function ( method ) { var range = this . getRange ( ) , body = this . doc . body , newRange , firstNode , lastNode , textNodes , rangeBackup ; 
function ( html ) { var range = rangy . createRange ( this . doc ) , node = range . createContextualFragment ( html ) , lastChild = node . lastChild ; this . insertNode ( node ) ; if ( lastChild ) { this . setAfter ( lastChild ) ; } } 
function ( node ) { var range = this . getRange ( ) ; if ( ! range ) { return ; } try { 
function ( ) { var win = this . doc . defaultView , selection = win . getSelection ( ) ; selection . modify ( "extend" , "left" , "lineboundary" ) ; selection . modify ( "extend" , "right" , "lineboundary" ) ; } 
function ( textNodes , range ) { var firstNode = textNodes [ 0 ] , lastNode = textNodes [ textNodes . length - 1 ] ; var merges = [ ] , currentMerge ; var rangeStartNode = firstNode , rangeEndNode = lastNode ; var rangeStartOffset = 0 , rangeEndOffset = lastNode . length ; var textNode , precedingTextNode ; for ( var i = 0 , len = textNodes . length ; i < len ; ++ i ) { textNode = textNodes [ i ] ; precedingTextNode = this . getAdjacentMergeableTextNode ( textNode . parentNode , false ) ; if ( precedingTextNode ) { if ( ! currentMerge ) { currentMerge = new Merge ( precedingTextNode ) ; merges . push ( currentMerge ) ; } currentMerge . textNodes . push ( textNode ) ; if ( textNode === firstNode ) { rangeStartNode = currentMerge . firstTextNode ; rangeStartOffset = rangeStartNode . length ; } if ( textNode === lastNode ) { rangeEndNode = currentMerge . firstTextNode ; rangeEndOffset = currentMerge . getLength ( ) ; } } else { currentMerge = null ; } } 
function ( command ) { var obj = wysihtml5 . commands [ command ] , method = obj && obj . value ; if ( method ) { return method . call ( obj , this . composer , command ) ; } else { try { 
function ( composer , command , value ) { var anchors = this . state ( composer , command ) ; if ( anchors ) { 
function _addClass ( element , className , classRegExp ) { if ( element . className ) { _removeClass ( element , classRegExp ) ; element . className += " " + className ; } else { element . className = className ; } } 
function _isBlankTextNode ( node ) { return node . nodeType === wysihtml5 . TEXT_NODE && ! wysihtml5 . lang . string ( node . data ) . trim ( ) ; } 
function _getPreviousSiblingThatIsNotBlank ( node ) { var previousSibling = node . previousSibling ; while ( previousSibling && _isBlankTextNode ( previousSibling ) ) { previousSibling = previousSibling . previousSibling ; } return previousSibling ; } 
function _getNextSiblingThatIsNotBlank ( node ) { var nextSibling = node . nextSibling ; while ( nextSibling && _isBlankTextNode ( nextSibling ) ) { nextSibling = nextSibling . nextSibling ; } return nextSibling ; } 
function _addLineBreakBeforeAndAfter ( node ) { var doc = node . ownerDocument , nextSibling = _getNextSiblingThatIsNotBlank ( node ) , previousSibling = _getPreviousSiblingThatIsNotBlank ( node ) ; if ( nextSibling && ! _isLineBreakOrBlockElement ( nextSibling ) ) { node . parentNode . insertBefore ( doc . createElement ( "br" ) , nextSibling ) ; } if ( previousSibling && ! _isLineBreakOrBlockElement ( previousSibling ) ) { node . parentNode . insertBefore ( doc . createElement ( "br" ) , node ) ; } } 
function _removeLineBreakBeforeAndAfter ( node ) { var nextSibling = _getNextSiblingThatIsNotBlank ( node ) , previousSibling = _getPreviousSiblingThatIsNotBlank ( node ) ; if ( nextSibling && _isLineBreak ( nextSibling ) ) { nextSibling . parentNode . removeChild ( nextSibling ) ; } if ( previousSibling && _isLineBreak ( previousSibling ) ) { previousSibling . parentNode . removeChild ( previousSibling ) ; } } 
function _execCommand ( doc , command , nodeName , className ) { if ( className ) { var eventListener = dom . observe ( doc , "DOMNodeInserted" , function ( event ) { var target = event . target , displayStyle ; if ( target . nodeType !== wysihtml5 . ELEMENT_NODE ) { return ; } displayStyle = dom . getStyle ( "display" ) . from ( target ) ; if ( displayStyle . substr ( 0 , 6 ) !== "inline" ) { 
function ( composer , command , value ) { value = typeof ( value ) === "object" ? value : { src : value } ; var doc = composer . doc , image = this . state ( composer ) , textNode , i , parent ; if ( image ) { 
function ( avoidHiddenFields ) { var field , fieldName , newValue , focusedElement = document . querySelector ( ":focus" ) , fields = this . container . querySelectorAll ( SELECTOR_FIELDS ) , length = fields . length , i = 0 ; for ( ; i < length ; i ++ ) { field = fields [ i ] ; 
function ( elementToChange ) { var that = this , firstField = this . container . querySelector ( SELECTOR_FORM_ELEMENTS ) ; this . elementToChange = elementToChange ; this . _observe ( ) ; this . _interpolate ( ) ; if ( elementToChange ) { this . interval = setInterval ( function ( ) { that . _interpolate ( true ) ; } , 500 ) ; } dom . addClass ( this . link , CLASS_NAME_OPENED ) ; this . container . style . display = "" ; this . fire ( "show" ) ; if ( firstField && ! elementToChange ) { try { firstField . focus ( ) ; } catch ( e ) { } } } 
function ( ) { this . observe ( "paste:composer" , function ( ) { var keepScrollPosition = true , that = this ; that . composer . selection . executeAndRestore ( function ( ) { wysihtml5 . quirks . cleanPastedHTML ( that . composer . element ) ; that . parse ( that . composer . element ) ; } , keepScrollPosition ) ; } ) ; this . observe ( "paste:textarea" , function ( ) { var value = this . textarea . getValue ( ) , newValue ; newValue = this . parse ( value ) ; this . textarea . setValue ( newValue ) ; } ) ; } 
function getParameterList ( parameters ) { if ( parameters == null ) { return [ ] ; } if ( typeof parameters != "object" ) { return OAuth . decodeForm ( parameters + "" ) ; } if ( parameters instanceof Array ) { return parameters ; } var list = [ ] ; for ( var p in parameters ) { list . push ( [ p , parameters [ p ] ] ) ; } return list ; } 
function getParameterMap ( parameters ) { if ( parameters == null ) { return { } ; } if ( typeof parameters != "object" ) { return OAuth . getParameterMap ( OAuth . decodeForm ( parameters + "" ) ) ; } if ( parameters instanceof Array ) { var map = { } ; for ( var p = 0 ; p < parameters . length ; ++ p ) { var key = parameters [ p ] [ 0 ] ; if ( map [ key ] === undefined ) { 
function completeRequest ( message , accessor ) { if ( message . method == null ) { message . method = "GET" ; } var map = OAuth . getParameterMap ( message . parameters ) ; if ( map . oauth_consumer_key == null ) { OAuth . setParameter ( message , "oauth_consumer_key" , accessor . consumerKey || "" ) ; } if ( map . oauth_token == null && accessor . token != null ) { OAuth . setParameter ( message , "oauth_token" , accessor . token ) ; } if ( map . oauth_version == null ) { OAuth . setParameter ( message , "oauth_version" , "1.0" ) ; } if ( map . oauth_timestamp == null ) { OAuth . setParameter ( message , "oauth_timestamp" , OAuth . timestamp ( ) ) ; } if ( map . oauth_nonce == null ) { OAuth . setParameter ( message , "oauth_nonce" , OAuth . nonce ( 6 ) ) ; } OAuth . SignatureMethod . sign ( message , accessor ) ; } 
function getAuthorizationHeader ( realm , parameters ) { var header = 'OAuth realm="' + OAuth . percentEncode ( realm ) + '"' ; var list = OAuth . getParameterList ( parameters ) ; for ( var p = 0 ; p < list . length ; ++ p ) { var parameter = list [ p ] ; var name = parameter [ 0 ] ; if ( name . indexOf ( "oauth_" ) == 0 ) { header += ',' + OAuth . percentEncode ( name ) + '="' + OAuth . percentEncode ( parameter [ 1 ] ) + '"' ; } } return header ; } 
function correctTimestampFromSrc ( parameterName ) { parameterName = parameterName || "oauth_timestamp" ; var scripts = document . getElementsByTagName ( 'script' ) ; if ( scripts == null || ! scripts . length ) return ; var src = scripts [ scripts . length - 1 ] . src ; if ( ! src ) return ; var q = src . indexOf ( "?" ) ; if ( q < 0 ) return ; parameters = OAuth . getParameterMap ( OAuth . decodeForm ( src . substring ( q + 1 ) ) ) ; var t = parameters [ parameterName ] ; if ( t == null ) return ; OAuth . correctTimestamp ( t ) ; } 
function sign ( message ) { var baseString = OAuth . SignatureMethod . getBaseString ( message ) ; var signature = this . getSignature ( baseString ) ; OAuth . setParameter ( message , "oauth_signature" , signature ) ; return signature ; 
function initialize ( name , accessor ) { var consumerSecret ; if ( accessor . accessorSecret != null && name . length > 9 && name . substring ( name . length - 9 ) == "-Accessor" ) { consumerSecret = accessor . accessorSecret ; } else { consumerSecret = accessor . consumerSecret ; } this . key = OAuth . percentEncode ( consumerSecret ) + "&" + OAuth . percentEncode ( accessor . tokenSecret ) ; } 
function newMethod ( name , accessor ) { var impl = OAuth . SignatureMethod . REGISTERED [ name ] ; if ( impl != null ) { var method = new impl ( ) ; method . initialize ( name , accessor ) ; return method ; } var err = new Error ( "signature_method_rejected" ) ; var acceptable = "" ; for ( var r in OAuth . SignatureMethod . REGISTERED ) { if ( acceptable != "" ) acceptable += '&' ; acceptable += OAuth . percentEncode ( r ) ; } err . oauth_acceptable_signature_methods = acceptable ; throw err ; } 
function registerMethodClass ( names , classConstructor ) { for ( var n = 0 ; n < names . length ; ++ n ) { OAuth . SignatureMethod . REGISTERED [ names [ n ] ] = classConstructor ; } } 
function makeSubclass ( getSignatureFunction ) { var superClass = OAuth . SignatureMethod ; var subClass = function ( ) { superClass . call ( this ) ; } ; subClass . prototype = new superClass ( ) ; 
function processInitialData ( value , name ) { if ( name == View . prototype . modelName ) { options . model = def . models [ name ] . unique ( value ) ; } else if ( def . models [ name ] ) { options . data [ name ] = def . models [ name ] . unique ( value ) ; } else { options . data [ name ] = value ; } } 
function addAnimation ( alpha , trail , i , lines ) { var name = [ 'opacity' , trail , ~ ~ ( alpha * 100 ) , i , lines ] . join ( '-' ) , start = 0.01 + i / lines * 100 , z = Math . max ( 1 - ( 1 - alpha ) / trail * ( 100 - start ) , alpha ) , prefix = useCssAnimations . substring ( 0 , useCssAnimations . indexOf ( 'Animation' ) ) . toLowerCase ( ) , pre = prefix && '-' + prefix + '-' || '' if ( ! animations [ name ] ) { sheet . insertRule ( '@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + ( start + 0.01 ) + '%{opacity:1}' + ( start + trail ) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}' , sheet . cssRules . length ) animations [ name ] = 1 } return name } 
function vendor ( el , prop ) { var s = el . style , pp , i if ( s [ prop ] !== undefined ) return prop prop = prop . charAt ( 0 ) . toUpperCase ( ) + prop . slice ( 1 ) for ( i = 0 ; i < prefixes . length ; i ++ ) { pp = prefixes [ i ] + prop if ( s [ pp ] !== undefined ) return pp } } 
function css ( el , prop ) { for ( var n in prop ) el . style [ vendor ( el , n ) || n ] = prop [ n ] return el } 
function merge ( obj ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var def = arguments [ i ] for ( var n in def ) if ( obj [ n ] === undefined ) obj [ n ] = def [ n ] } return obj } 
function pos ( el ) { var o = { x : el . offsetLeft , y : el . offsetTop } while ( ( el = el . offsetParent ) ) o . x += el . offsetLeft , o . y += el . offsetTop return o } 
function Spinner ( o ) { if ( ! this . spin ) return new Spinner ( o ) this . opts = merge ( o || { } , Spinner . defaults , defaults ) } 
function ( c ) { var j = $ ( [ 0 ] ) , i = - 1 , l = this . length ; while ( ++ i < l && ( j . context = j [ 0 ] = this [ i ] ) && c . call ( j [ 0 ] , i , j ) !== false 
function splitVal ( string , separator ) { var val , i , l ; if ( string === null || string . length < 1 ) return [ ] ; val = string . split ( separator ) ; for ( i = 0 , l = val . length ; i < l ; i = i + 1 ) val [ i ] = $ . trim ( val [ i ] ) ; return val ; } 
function installFilteredMouseMove ( element ) { element . on ( "mousemove" , function ( e ) { var lastpos = lastMousePosition ; if ( lastpos === undefined || lastpos . x !== e . pageX || lastpos . y !== e . pageY ) { $ ( e . target ) . trigger ( "mousemove-filtered" , e ) ; } } ) ; } 
function thunk ( formula ) { var evaluated = false , value ; return function ( ) { if ( evaluated === false ) { value = formula ( ) ; evaluated = true ; } return value ; } ; } 
function checkFormatter ( formatter , formatterName ) { if ( $ . isFunction ( formatter ) ) return true ; if ( ! formatter ) return false ; throw new Error ( formatterName + " must be a function or a falsy value" ) ; } 
function defaultTokenizer ( input , selection , selectCallback , opts ) { var original = input , 
function clazz ( SuperClass , methods ) { var constructor = function ( ) { } ; constructor . prototype = new SuperClass ; constructor . prototype . constructor = constructor ; constructor . prototype . parent = SuperClass . prototype ; constructor . prototype = $ . extend ( constructor . prototype , methods ) ; return constructor ; } 
function ( ) { var element = this . opts . element , select2 = element . data ( "select2" ) ; if ( this . propertyObserver ) { delete this . propertyObserver ; this . propertyObserver = null ; } if ( select2 !== undefined ) { select2 . container . remove ( ) ; select2 . dropdown . remove ( ) ; element . removeClass ( "select2-offscreen" ) . removeData ( "select2" ) . off ( ".select2" ) . prop ( "autofocus" , this . autofocus || false ) ; if ( this . elementTabIndex ) { element . attr ( { tabindex : this . elementTabIndex } ) ; } else { element . removeAttr ( "tabindex" ) ; } element . show ( ) ; } } 
function ( element ) { if ( element . is ( "option" ) ) { return { id : element . prop ( "value" ) , text : element . text ( ) , element : element . get ( ) , css : element . attr ( "class" ) , disabled : element . prop ( "disabled" ) , locked : equal ( element . attr ( "locked" ) , "locked" ) || equal ( element . data ( "locked" ) , true ) } ; } else if ( element . is ( "optgroup" ) ) { return { text : element . attr ( "label" ) , children : [ ] , element : element . get ( ) , css : element . attr ( "class" ) } ; } } 
function ( opts ) { var element , select , idKey , ajaxUrl , self = this ; element = opts . element ; if ( element . get ( 0 ) . tagName . toLowerCase ( ) === "select" ) { this . select = select = opts . element ; } if ( select ) { 
function ( ) { var el = this . opts . element , sync ; el . on ( "change.select2" , this . bind ( function ( e ) { if ( this . opts . element . data ( "select2-change-triggered" ) !== true ) { this . initSelection ( ) ; } } ) ) ; sync = this . bind ( function ( ) { var enabled , readonly , self = this ; 
function ( ) { var enabled = this . _enabled && ! this . _readonly , disabled = ! enabled ; if ( enabled === this . enabledInterface ) return false ; this . container . toggleClass ( "select2-container-disabled" , disabled ) ; this . close ( ) ; this . enabledInterface = enabled ; return true ; } 
function ( ) { var $dropdown = this . dropdown , offset = this . container . offset ( ) , height = this . container . outerHeight ( false ) , width = this . container . outerWidth ( false ) , dropHeight = $dropdown . outerHeight ( false ) , viewPortRight = $ ( window ) . scrollLeft ( ) + $ ( window ) . width ( ) , viewportBottom = $ ( window ) . scrollTop ( ) + $ ( window ) . height ( ) , dropTop = offset . top + height , dropLeft = offset . left , enoughRoomBelow = dropTop + dropHeight <= viewportBottom , enoughRoomAbove = ( offset . top - dropHeight ) >= this . body ( ) . scrollTop ( ) , dropWidth = $dropdown . outerWidth ( false ) , enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight , aboveNow = $dropdown . hasClass ( "select2-drop-above" ) , bodyOffset , above , css , resultsListNode ; if ( this . opts . dropdownAutoWidth ) { resultsListNode = $ ( '.select2-results' , $dropdown ) [ 0 ] ; $dropdown . addClass ( 'select2-drop-auto-width' ) ; $dropdown . css ( 'width' , '' ) ; 
function ( ) { var event ; if ( this . opened ( ) ) return false ; if ( this . _enabled === false || this . _readonly === true ) return false ; event = $ . Event ( "select2-opening" ) ; this . opts . element . trigger ( event ) ; return ! event . isDefaultPrevented ( ) ; } 
function ( ) { var cid = this . containerId , scroll = "scroll." + cid , resize = "resize." + cid , orient = "orientationchange." + cid , mask , maskCss ; this . container . addClass ( "select2-dropdown-open" ) . addClass ( "select2-container-active" ) ; this . clearDropdownAlignmentPreference ( ) ; if ( this . dropdown [ 0 ] !== this . body ( ) . children ( ) . last ( ) [ 0 ] ) { this . dropdown . detach ( ) . appendTo ( this . body ( ) ) ; } 
function ( ) { if ( ! this . opened ( ) ) return ; var cid = this . containerId , scroll = "scroll." + cid , resize = "resize." + cid , orient = "orientationchange." + cid ; 
function ( delta ) { var choices = this . findHighlightableChoices ( ) , index = this . highlight ( ) ; while ( index > - 1 && index < choices . length ) { index += delta ; var choice = $ ( choices [ index ] ) ; if ( choice . hasClass ( "select2-result-selectable" ) && ! choice . hasClass ( "select2-disabled" ) && ! choice . hasClass ( "select2-selected" ) ) { this . highlight ( index ) ; break ; } } } 
function ( index ) { var choices = this . findHighlightableChoices ( ) , choice , data ; if ( arguments . length === 0 ) { return indexOf ( choices . filter ( ".select2-highlighted" ) [ 0 ] , choices . get ( ) ) ; } if ( index >= choices . length ) index = choices . length - 1 ; if ( index < 0 ) index = 0 ; this . results . find ( ".select2-highlighted" ) . removeClass ( "select2-highlighted" ) ; choice = $ ( choices [ index ] ) ; choice . addClass ( "select2-highlighted" ) ; this . ensureHighlightVisible ( ) ; data = choice . data ( "select2-data" ) ; if ( data ) { this . opts . element . trigger ( { type : "select2-highlight" , val : this . id ( data ) , choice : data } ) ; } } 
function ( event ) { var el = $ ( event . target ) . closest ( ".select2-result-selectable" ) ; if ( el . length > 0 && ! el . is ( ".select2-highlighted" ) ) { var choices = this . findHighlightableChoices ( ) ; this . highlight ( choices . index ( el ) ) ; } else if ( el . length == 0 ) { 
function ( options ) { var index = this . highlight ( ) , highlighted = this . results . find ( ".select2-highlighted" ) , data = highlighted . closest ( '.select2-result' ) . data ( "select2-data" ) ; if ( data ) { this . highlight ( index ) ; this . onSelect ( data , options ) ; } else if ( options && options . noFocus ) { this . close ( ) ; } } 
function ( ) { var placeholderOption ; return this . opts . element . attr ( "placeholder" ) || this . opts . element . attr ( "data-placeholder" ) || 
function ( ) { if ( this . select ) { var firstOption = this . select . children ( ) . first ( ) ; if ( this . opts . placeholderOption !== undefined ) { 
function ( triggerChange ) { var data = this . selection . data ( "select2-data" ) ; if ( data ) { 
function ( ) { var opts = this . parent . prepareOpts . apply ( this , arguments ) , self = this ; if ( opts . element . get ( 0 ) . tagName . toLowerCase ( ) === "select" ) { 
function ( ) { var placeholder = this . getPlaceholder ( ) ; if ( this . isPlaceholderOptionSelected ( ) && placeholder !== undefined ) { 
function ( data , initial , noHighlightUpdate ) { var selected = 0 , self = this , showSearchInput = true ; 
function ( showSearchInput ) { if ( this . showSearchInput === showSearchInput ) return ; this . showSearchInput = showSearchInput ; this . dropdown . find ( ".select2-search" ) . toggleClass ( "select2-search-hidden" , ! showSearchInput ) ; this . dropdown . find ( ".select2-search" ) . toggleClass ( "select2-offscreen" , ! showSearchInput ) ; 
function ( data , options ) { if ( ! this . triggerSelect ( data ) ) { return ; } var old = this . opts . element . val ( ) , oldData = this . data ( ) ; this . opts . element . val ( this . id ( data ) ) ; this . updateSelection ( data ) ; this . opts . element . trigger ( { type : "select2-selected" , val : this . id ( data ) , choice : data } ) ; this . close ( ) ; if ( ! options || ! options . noFocus ) this . selection . focus ( ) ; if ( ! equal ( old , this . id ( data ) ) ) { this . triggerChange ( { added : data , removed : oldData } ) ; } } 
function ( ) { var val , triggerChange = false , data = null , self = this , oldData = this . data ( ) ; if ( arguments . length === 0 ) { return this . opts . element . val ( ) ; } val = arguments [ 0 ] ; if ( arguments . length > 1 ) { triggerChange = arguments [ 1 ] ; } if ( this . select ) { this . select . val ( val ) . find ( ":selected" ) . each2 ( function ( i , elm ) { data = self . optionToData ( elm ) ; return false ; } ) ; this . updateSelection ( data ) ; this . setPlaceholder ( ) ; if ( triggerChange ) { this . triggerChange ( { added : data , removed : oldData } ) ; } } else { 
function ( value , triggerChange ) { var data ; if ( arguments . length === 0 ) { data = this . selection . data ( "select2-data" ) ; if ( data == undefined ) data = null ; return data ; } else { if ( ! value || value === "" ) { this . clear ( triggerChange ) ; } else { data = this . data ( ) ; this . opts . element . val ( ! value ? "" : this . id ( value ) ) ; this . updateSelection ( value ) ; if ( triggerChange ) { this . triggerChange ( { added : value , removed : data } ) ; } } } } 
function ( ) { var selector = ".select2-choices" , selection ; this . searchContainer = this . container . find ( ".select2-search-field" ) ; this . selection = selection = this . container . find ( selector ) ; var _this = this ; this . selection . on ( "mousedown" , ".select2-search-choice" , function ( e ) { 
function ( ) { var data ; if ( this . opts . element . val ( ) === "" && this . opts . element . text ( ) === "" ) { this . updateSelection ( [ ] ) ; this . close ( ) ; 
function ( ) { var placeholder = this . getPlaceholder ( ) , maxWidth = this . getMaxSearchWidth ( ) ; if ( placeholder !== undefined && this . getVal ( ) . length === 0 && this . search . hasClass ( "select2-focused" ) === false ) { this . search . val ( placeholder ) . addClass ( "select2-default" ) ; 
function ( ) { this . clearPlaceholder ( ) ; 
function ( data ) { var ids = [ ] , filtered = [ ] , self = this ; 
function ( data , options ) { if ( ! this . triggerSelect ( data ) ) { return ; } this . addSelectedChoice ( data ) ; this . opts . element . trigger ( { type : "selected" , val : this . id ( data ) , choice : data } ) ; if ( this . select || ! this . opts . closeOnSelect ) this . postprocessResults ( ) ; if ( this . opts . closeOnSelect ) { this . close ( ) ; this . search . width ( 10 ) ; } else { if ( this . countSelectableResults ( ) > 0 ) { this . search . width ( 10 ) ; this . resizeSearch ( ) ; if ( this . getMaximumSelectionSize ( ) > 0 && this . val ( ) . length >= this . getMaximumSelectionSize ( ) ) { 
function ( selected ) { var val = this . getVal ( ) , data , index ; selected = selected . closest ( ".select2-search-choice" ) ; if ( selected . length === 0 ) { throw "Invalid argument: " + selected + ". Must be .select2-search-choice" ; } data = selected . data ( "select2-data" ) ; if ( ! data ) { 
function ( ) { var val ; if ( this . select ) { val = this . select . val ( ) ; return val === null ? [ ] : val ; } else { val = this . opts . element . val ( ) ; return splitVal ( val , this . opts . separator ) ; } } 
function ( val ) { var unique ; if ( this . select ) { this . select . val ( val ) ; } else { unique = [ ] ; 
function ( val , triggerChange ) { var oldData , self = this , changeDetails ; if ( arguments . length === 0 ) { return this . getVal ( ) ; } oldData = this . data ( ) ; if ( ! oldData . length ) oldData = [ ] ; 
function ( ) { var val = [ ] , self = this ; 
function SubEmitterSocket ( ) { this . sock = new SubSocket ; this . sock . onmessage = this . onmessage . bind ( this ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; this . listeners = [ ] ; } 
function PubEmitterSocket ( ) { this . sock = new PubSocket ; this . emit = this . sock . send . bind ( this . sock ) ; this . bind = this . sock . bind . bind ( this . sock ) ; this . connect = this . sock . connect . bind ( this . sock ) ; this . close = this . sock . close . bind ( this . sock ) ; } 
function toRegExp ( str ) { if ( str instanceof RegExp ) return str ; str = escape ( str ) ; str = str . replace ( / \\\* / g , '(.+)' ) ; return new RegExp ( '^' + str + '$' ) ; } 
function ReqSocket ( ) { Socket . call ( this ) ; this . n = 0 ; this . ids = 0 ; this . callbacks = { } ; this . identity = this . get ( 'identity' ) ; this . use ( queue ( ) ) ; } 
function ( ) { let result , expr ; if ( this . token === "@" ) return this . node ( "silent" ) ( this . next ( ) . read_expr ( ) ) ; if ( this . token === "+" ) return this . node ( "unary" ) ( "+" , this . next ( ) . read_expr ( ) ) ; if ( this . token === "-" ) return this . node ( "unary" ) ( "-" , this . next ( ) . read_expr ( ) ) ; if ( this . token === "!" ) return this . node ( "unary" ) ( "!" , this . next ( ) . read_expr ( ) ) ; if ( this . token === "~" ) return this . node ( "unary" ) ( "~" , this . next ( ) . read_expr ( ) ) ; if ( this . token === "(" ) { expr = this . next ( ) . read_expr ( ) ; expr . parenthesizedExpression = true ; this . expect ( ")" ) && this . next ( ) ; return this . handleDereferencable ( expr ) ; } if ( this . token === "`" ) { 
function ( ) { const result = this . node ( "new" ) ; this . expect ( this . tok . T_NEW ) && this . next ( ) ; let args = [ ] ; if ( this . token === this . tok . T_CLASS ) { const what = this . node ( "class" ) ; 
function ( ) { if ( this . token === this . tok . T_NS_SEPARATOR || this . token === this . tok . T_STRING || this . token === this . tok . T_NAMESPACE ) { let result = this . read_namespace_name ( true ) ; if ( this . token === this . tok . T_DOUBLE_COLON ) { result = this . read_static_getter ( result ) ; } return result ; } else if ( this . is ( "VARIABLE" ) ) { return this . read_variable ( true , false , false ) ; } else { this . expect ( [ this . tok . T_STRING , "VARIABLE" ] ) ; } } 
function Node ( kind , docs , location ) { this . kind = kind ; if ( docs ) { this . leadingComments = docs ; } if ( location ) { this . loc = location ; } } 
function ( ) { let expect = null ; let shortForm = false ; const result = this . node ( ArrayExpr ) ; if ( this . token === this . tok . T_ARRAY ) { this . next ( ) . expect ( "(" ) ; expect = ")" ; } else { shortForm = true ; expect = "]" ; } let items = [ ] ; if ( this . next ( ) . token !== expect ) { items = this . read_array_pair_list ( shortForm ) ; } if (items[i] === null) { this.raiseError( "Cannot use empty array elements in arrays" ); } }*/ this . expect ( expect ) ; this . next ( ) ; return result ( shortForm , items ) ; } 
function ( shortForm ) { if ( this . token === "," || ( ! shortForm && this . token === ")" ) || ( shortForm && this . token === "]" ) ) { return null ; } if ( this . token === "&" ) { return this . next ( ) . read_variable ( true , false , true ) ; } else { const entry = this . node ( ArrayEntry ) ; const expr = this . read_expr ( ) ; if ( this . token === this . tok . T_DOUBLE_ARROW ) { if ( this . next ( ) . token === "&" ) { return entry ( expr , this . next ( ) . read_variable ( true , false , true ) ) ; } else { return entry ( expr , this . read_expr ( ) ) ; } } return expr ; } } 
function ( ) { let location = null ; const args = Array . prototype . slice . call ( arguments ) ; args . push ( docs ) ; if ( typeof result . preBuild === "function" ) { result . preBuild ( arguments ) ; } if ( self . withPositions || self . withSource ) { let src = null ; if ( self . withSource ) { src = parser . lexer . _input . substring ( start . offset , parser . prev [ 2 ] ) ; } if ( self . withPositions ) { location = new Location ( src , start , new Position ( parser . prev [ 0 ] , parser . prev [ 1 ] , parser . prev [ 2 ] ) ) ; } else { location = new Location ( src , null , null ) ; } 
function ( ) { const result = this . node ( "while" ) ; this . expect ( this . tok . T_WHILE ) && this . next ( ) ; let test = null ; let body = null ; let shortForm = false ; if ( this . expect ( "(" ) ) this . next ( ) ; test = this . read_expr ( ) ; if ( this . expect ( ")" ) ) this . next ( ) ; if ( this . token === ":" ) { shortForm = true ; body = this . read_short_form ( this . tok . T_ENDWHILE ) ; } else { body = this . read_statement ( ) ; } return result ( test , body , shortForm ) ; } 
function ( ) { const result = this . node ( "do" ) ; this . expect ( this . tok . T_DO ) && this . next ( ) ; let test = null ; let body = null ; body = this . read_statement ( ) ; if ( this . expect ( this . tok . T_WHILE ) ) { if ( this . next ( ) . expect ( "(" ) ) this . next ( ) ; test = this . read_expr ( ) ; if ( this . expect ( ")" ) ) this . next ( ) ; if ( this . expect ( ";" ) ) this . next ( ) ; } return result ( test , body ) ; } 
function ( ) { const result = this . node ( "for" ) ; this . expect ( this . tok . T_FOR ) && this . next ( ) ; let init = [ ] ; let test = [ ] ; let increment = [ ] ; let body = null ; let shortForm = false ; if ( this . expect ( "(" ) ) this . next ( ) ; if ( this . token !== ";" ) { init = this . read_list ( this . read_expr , "," ) ; if ( this . expect ( ";" ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token !== ";" ) { test = this . read_list ( this . read_expr , "," ) ; if ( this . expect ( ";" ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token !== ")" ) { increment = this . read_list ( this . read_expr , "," ) ; if ( this . expect ( ")" ) ) this . next ( ) ; } else { this . next ( ) ; } if ( this . token === ":" ) { shortForm = true ; body = this . read_short_form ( this . tok . T_ENDFOR ) ; } else { body = this . read_statement ( ) ; } return result ( init , test , increment , body , shortForm ) ; } 
function ( ) { const result = this . node ( "foreach" ) ; this . expect ( this . tok . T_FOREACH ) && this . next ( ) ; let source = null ; let key = null ; let value = null ; let body = null ; let shortForm = false ; if ( this . expect ( "(" ) ) this . next ( ) ; source = this . read_expr ( ) ; if ( this . expect ( this . tok . T_AS ) ) { this . next ( ) ; value = this . read_foreach_variable ( ) ; if ( this . token === this . tok . T_DOUBLE_ARROW ) { key = value ; value = this . next ( ) . read_foreach_variable ( ) ; } } 
function ( ) { if ( this . token === this . tok . T_LIST || this . token === "[" ) { const isShort = this . token === "[" ; const result = this . node ( "list" ) ; this . next ( ) ; if ( ! isShort && this . expect ( "(" ) ) this . next ( ) ; const assignList = this . read_array_pair_list ( isShort ) ; if ( this . expect ( isShort ? "]" : ")" ) ) this . next ( ) ; return result ( assignList , isShort ) ; } else { return this . read_variable ( false , false , false ) ; } } 
function ( ) { let ch ; while ( this . offset < this . size ) { ch = this . input ( ) ; if ( ch !== "0" && ch !== "1" ) { if ( ch ) this . unput ( 1 ) ; break ; } } return this . tok . T_LNUMBER ; } 
function ( ) { const ch = this . _input [ this . offset - 1 ] ; const fn = this . tokenTerminals [ ch ] ; if ( fn ) { return fn . apply ( this , [ ] ) ; } else { return this . yytext ; } } 
function ( text , doubleQuote ) { if ( ! doubleQuote ) { 
function ( ) { if ( this . is ( "T_MAGIC_CONST" ) ) { return this . get_magic_constant ( ) ; } else { let value , node ; switch ( this . token ) { 
function ( expr ) { let result , offset ; const node = this . node ( "offsetlookup" ) ; if ( this . token === "[" ) { offset = this . next ( ) . read_expr ( ) ; if ( this . expect ( "]" ) ) this . next ( ) ; result = node ( expr , offset ) ; } else if ( this . token === this . tok . T_DOLLAR_OPEN_CURLY_BRACES ) { offset = this . read_encapsed_string_item ( false ) ; result = node ( expr , offset ) ; } return result ; } 
function ( isDoubleQuote ) { const encapsedPart = this . node ( "encapsedpart" ) ; let curly = false ; let result = this . node ( ) , offset , node , name ; 
function ( expect , isBinary = false ) { let node = this . node ( "encapsed" ) ; this . next ( ) ; const start = this . lexer . yylloc . prev_offset - ( isBinary ? 1 : 0 ) ; const value = [ ] ; let type = null ; if ( expect === "`" ) { type = this . ast . encapsed . TYPE_SHELL ; } else if ( expect === '"' ) { type = this . ast . encapsed . TYPE_STRING ; } else { type = this . ast . encapsed . TYPE_HEREDOC ; } 
function ( ) { const revert = this . offset ; if ( this . _input [ this . offset - 1 ] === "<" && this . _input [ this . offset ] === "<" && this . _input [ this . offset + 1 ] === "<" ) { this . offset += 3 ; 
function ( ) { 
function ( ) { let ch = this . input ( ) ; if ( ch === "$" ) { ch = this . input ( ) ; if ( ch === "{" ) { this . begin ( "ST_LOOKING_FOR_VARNAME" ) ; return this . tok . T_DOLLAR_OPEN_CURLY_BRACES ; } else if ( this . is_LABEL_START ( ) ) { const tok = this . consume_VARIABLE ( ) ; return tok ; } } else if ( ch === "{" ) { if ( this . _input [ this . offset ] === "$" ) { this . begin ( "ST_IN_SCRIPTING" ) ; return this . tok . T_CURLY_OPEN ; } } else if ( ch === "`" ) { this . popState ( ) ; return "`" ; } 
function ( ) { let result = [ ] ; while ( this . token !== this . EOF && this . token !== "}" ) { const statement = this . read_top_statement ( ) ; if ( statement ) { if ( Array . isArray ( statement ) ) { result = result . concat ( statement ) ; } else { result . push ( statement ) ; } } } return result ; } 
function ( ) { switch ( this . token ) { case this . tok . T_FUNCTION : return this . read_function ( false , false ) ; 
function ( ) { return this . read_list ( function ( ) { this . expect ( this . tok . T_STRING ) ; const result = this . node ( "constant" ) ; let constName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; constName = constName ( name ) ; if ( this . expect ( "=" ) ) { return result ( constName , this . next ( ) . read_expr ( ) ) ; } else { 
function ( ) { const result = [ ] ; while ( this . token != this . EOF && this . token !== ")" ) { this . expect ( this . tok . T_STRING ) ; const directive = this . node ( "declaredirective" ) ; let key = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; key = key ( name ) ; let value = null ; if ( this . expect ( "=" ) ) { value = this . next ( ) . read_expr ( ) ; } result . push ( directive ( key , value ) ) ; if ( this . token !== "," ) break ; this . next ( ) ; } return result ; } 
function ( ) { switch ( this . token ) { case this . tok . T_FUNCTION : return this . read_function ( false , false ) ; 
function ( ) { switch ( this . token ) { case "{" : return this . read_code_block ( false ) ; case this . tok . T_IF : return this . read_if ( ) ; case this . tok . T_SWITCH : return this . read_switch ( ) ; case this . tok . T_FOR : return this . read_for ( ) ; case this . tok . T_FOREACH : return this . read_foreach ( ) ; case this . tok . T_WHILE : return this . read_while ( ) ; case this . tok . T_DO : return this . read_do ( ) ; case this . tok . T_COMMENT : return this . read_comment ( ) ; case this . tok . T_DOC_COMMENT : return this . read_doc_comment ( ) ; case this . tok . T_RETURN : { const result = this . node ( "return" ) ; let expr = null ; if ( ! this . next ( ) . is ( "EOS" ) ) { expr = this . read_expr ( ) ; } this . expectEndOfStatement ( ) ; return result ( expr ) ; } 
function ( top ) { const result = this . node ( "block" ) ; this . expect ( "{" ) && this . next ( ) ; const body = top ? this . read_top_statements ( ) : this . read_inner_statements ( ) ; this . expect ( "}" ) && this . next ( ) ; return result ( null , body ) ; } 
function ( lexer , ast ) { this . lexer = lexer ; this . ast = ast ; this . tok = lexer . tok ; this . EOF = lexer . EOF ; this . token = null ; this . prev = null ; this . debug = false ; this . php7 = true ; this . extractDoc = false ; this . extractTokens = false ; this . suppressErrors = false ; const mapIt = function ( item ) { return [ item , null ] ; } ; this . entries = { IDENTIFIER : new Map ( [ this . tok . T_ABSTRACT , this . tok . T_ARRAY , this . tok . T_AS , this . tok . T_BREAK , this . tok . T_CALLABLE , this . tok . T_CASE , this . tok . T_CATCH , this . tok . T_CLASS , this . tok . T_CLASS_C , this . tok . T_CLONE , this . tok . T_CONST , this . tok . T_CONTINUE , this . tok . T_DECLARE , this . tok . T_DEFAULT , this . tok . T_DIR , this . tok . T_DO , this . tok . T_ECHO , this . tok . T_ELSE , this . tok . T_ELSEIF , this . tok . T_EMPTY , this . tok . T_ENDDECLARE , this . tok . T_ENDFOR , this . tok . T_ENDFOREACH , this . tok . T_ENDIF , this . tok . T_ENDSWITCH , this . tok . T_ENDWHILE , this . tok . T_EVAL , this . tok . T_EXIT , this . tok . T_EXTENDS , this . tok . T_FILE , this . tok . T_FINAL , this . tok . T_FINALLY , this . tok . T_FUNC_C , this . tok . T_FOR , this . tok . T_FOREACH , this . tok . T_FUNCTION , this . tok . T_GLOBAL , this . tok . T_GOTO , this . tok . T_IF , this . tok . T_IMPLEMENTS , this . tok . T_INCLUDE , this . tok . T_INCLUDE_ONCE , this . tok . T_INSTANCEOF , this . tok . T_INSTEADOF , this . tok . T_INTERFACE , this . tok . T_ISSET , this . tok . T_LINE , this . tok . T_LIST , this . tok . T_LOGICAL_AND , this . tok . T_LOGICAL_OR , this . tok . T_LOGICAL_XOR , this . tok . T_METHOD_C , this . tok . T_NAMESPACE , this . tok . T_NEW , this . tok . T_NS_C , this . tok . T_PRINT , this . tok . T_PRIVATE , this . tok . T_PROTECTED , this . tok . T_PUBLIC , this . tok . T_REQUIRE , this . tok . T_REQUIRE_ONCE , this . tok . T_RETURN , this . tok . T_STATIC , this . tok . T_SWITCH , this . tok . T_THROW , this . tok . T_TRAIT , this . tok . T_TRY , this . tok . T_UNSET , this . tok . T_USE , this . tok . T_VAR , this . tok . T_WHILE , this . tok . T_YIELD ] . map ( mapIt ) ) , VARIABLE : new Map ( [ this . tok . T_VARIABLE , "$" , "&" , this . tok . T_NS_SEPARATOR , this . tok . T_STRING , this . tok . T_NAMESPACE , this . tok . T_STATIC ] . map ( mapIt ) ) , SCALAR : new Map ( [ this . tok . T_CONSTANT_ENCAPSED_STRING , this . tok . T_START_HEREDOC , this . tok . T_LNUMBER , this . tok . T_DNUMBER , this . tok . T_ARRAY , "[" , this . tok . T_CLASS_C , this . tok . T_TRAIT_C , this . tok . T_FUNC_C , this . tok . T_METHOD_C , this . tok . T_LINE , this . tok . T_FILE , this . tok . T_DIR , this . tok . T_NS_C , '"' , 'b"' , 'B"' , "-" , this . tok . T_NS_SEPARATOR ] . map ( mapIt ) ) , T_MAGIC_CONST : new Map ( [ this . tok . T_CLASS_C , this . tok . T_TRAIT_C , this . tok . T_FUNC_C , this . tok . T_METHOD_C , this . tok . T_LINE , this . tok . T_FILE , this . tok . T_DIR , this . tok . T_NS_C ] . map ( mapIt ) ) , T_MEMBER_FLAGS : new Map ( [ this . tok . T_PUBLIC , this . tok . T_PRIVATE , this . tok . T_PROTECTED , this . tok . T_STATIC , this . tok . T_ABSTRACT , this . tok . T_FINAL ] . map ( mapIt ) ) , EOS : new Map ( [ ";" , this . EOF , this . tok . T_INLINE_HTML ] . map ( mapIt ) ) , EXPR : new Map ( [ "@" , "-" , "+" , "!" , "~" , "(" , "`" , this . tok . T_LIST , this . tok . T_CLONE , this . tok . T_INC , this . tok . T_DEC , this . tok . T_NEW , this . tok . T_ISSET , this . tok . T_EMPTY , this . tok . T_INCLUDE , this . tok . T_INCLUDE_ONCE , this . tok . T_REQUIRE , this . tok . T_REQUIRE_ONCE , this . tok . T_EVAL , this . tok . T_INT_CAST , this . tok . T_DOUBLE_CAST , this . tok . T_STRING_CAST , this . tok . T_ARRAY_CAST , this . tok . T_OBJECT_CAST , this . tok . T_BOOL_CAST , this . tok . T_UNSET_CAST , this . tok . T_EXIT , this . tok . T_PRINT , this . tok . T_YIELD , this . tok . T_STATIC , this . tok . T_FUNCTION , 
function ( ) { const result = this . node ( "namespace" ) ; let body ; this . expect ( this . tok . T_NAMESPACE ) && this . next ( ) ; if ( this . token == "{" ) { this . currentNamespace = [ "" ] ; body = this . next ( ) . read_top_statements ( ) ; this . expect ( "}" ) && this . next ( ) ; return result ( [ "" ] , body , true ) ; } else { const name = this . read_namespace_name ( ) ; if ( this . token == ";" ) { this . currentNamespace = name ; body = this . next ( ) . read_top_statements ( ) ; this . expect ( this . EOF ) ; return result ( name . name , body , false ) ; } else if ( this . token == "{" ) { this . currentNamespace = name ; body = this . next ( ) . read_top_statements ( ) ; this . expect ( "}" ) && this . next ( ) ; return result ( name . name , body , true ) ; } else if ( this . token === "(" ) { 
function ( resolveReference ) { const result = this . node ( ) ; let relative = false ; if ( this . token === this . tok . T_NAMESPACE ) { this . next ( ) . expect ( this . tok . T_NS_SEPARATOR ) && this . next ( ) ; relative = true ; } const names = this . read_list ( this . tok . T_STRING , this . tok . T_NS_SEPARATOR , true ) ; if ( ! relative && names . length === 1 && ( resolveReference || this . token !== "(" ) ) { if ( names [ 0 ] . toLowerCase ( ) === "parent" ) { return result ( "parentreference" , names [ 0 ] ) ; } else if ( names [ 0 ] . toLowerCase ( ) === "self" ) { return result ( "selfreference" , names [ 0 ] ) ; } } return result ( "classreference" , names , relative ) ; } 
function ( ) { let result = this . node ( "usegroup" ) ; let items = [ ] ; let name = null ; this . expect ( this . tok . T_USE ) && this . next ( ) ; const type = this . read_use_type ( ) ; items . push ( this . read_use_declaration ( false ) ) ; if ( this . token === "," ) { items = items . concat ( this . next ( ) . read_use_declarations ( false ) ) ; } else if ( this . token === "{" ) { name = items [ 0 ] . name ; items = this . next ( ) . read_use_declarations ( type === null ) ; this . expect ( "}" ) && this . next ( ) ; } result = result ( name , type , items ) ; this . expect ( ";" ) && this . next ( ) ; return result ; } 
function ( typed ) { const result = this . node ( "useitem" ) ; let type = null ; if ( typed ) type = this . read_use_type ( ) ; const name = this . read_namespace_name ( ) ; const alias = this . read_use_alias ( ) ; return result ( name . name , alias , type ) ; } 
function ( typed ) { const result = [ this . read_use_declaration ( typed ) ] ; while ( this . token === "," ) { this . next ( ) ; if ( typed ) { if ( this . token !== this . tok . T_FUNCTION && this . token !== this . tok . T_CONST && this . token !== this . tok . T_STRING ) { break ; } } else if ( this . token !== this . tok . T_STRING && this . token !== this . tok . T_NS_SEPARATOR ) { break ; } result . push ( this . read_use_declaration ( typed ) ) ; } return result ; } 
function ( ) { let result = null ; if ( this . token === this . tok . T_AS ) { if ( this . next ( ) . expect ( this . tok . T_STRING ) ) { const aliasName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; result = aliasName ( name ) ; } } return result ; } 
function ( ) { if ( this . token === this . tok . T_FUNCTION ) { this . next ( ) ; return this . ast . useitem . TYPE_FUNCTION ; } else if ( this . token === this . tok . T_CONST ) { this . next ( ) ; return this . ast . useitem . TYPE_CONST ; } return null ; } 
function ( ) { const result = this . node ( "if" ) ; let body = null ; let alternate = null ; let shortForm = false ; let test = null ; test = this . next ( ) . read_if_expr ( ) ; if ( this . token === ":" ) { shortForm = true ; this . next ( ) ; body = this . node ( "block" ) ; const items = [ ] ; while ( this . token !== this . EOF && this . token !== this . tok . T_ENDIF ) { if ( this . token === this . tok . T_ELSEIF ) { alternate = this . read_elseif_short ( ) ; break ; } else if ( this . token === this . tok . T_ELSE ) { alternate = this . read_else_short ( ) ; break ; } items . push ( this . read_inner_statement ( ) ) ; } body = body ( null , items ) ; this . expect ( this . tok . T_ENDIF ) && this . next ( ) ; this . expectEndOfStatement ( ) ; } else { body = this . read_statement ( ) ; if ( this . token === this . tok . T_ELSEIF ) { alternate = this . read_if ( ) ; } else if ( this . token === this . tok . T_ELSE ) { alternate = this . next ( ) . read_statement ( ) ; } } return result ( test , body , alternate , shortForm ) ; } 
function ( ) { const result = this . node ( "if" ) ; let alternate = null ; let test = null ; let body = null ; const items = [ ] ; test = this . next ( ) . read_if_expr ( ) ; if ( this . expect ( ":" ) ) this . next ( ) ; body = this . node ( "block" ) ; while ( this . token != this . EOF && this . token !== this . tok . T_ENDIF ) { if ( this . token === this . tok . T_ELSEIF ) { alternate = this . read_elseif_short ( ) ; break ; } else if ( this . token === this . tok . T_ELSE ) { alternate = this . read_else_short ( ) ; break ; } items . push ( this . read_inner_statement ( ) ) ; } body = body ( null , items ) ; return result ( test , body , alternate , true ) ; } 
function ( engine ) { this . engine = engine ; this . tok = this . engine . tokens . names ; this . EOF = 1 ; this . debug = false ; this . all_tokens = true ; this . comment_tokens = false ; this . mode_eval = false ; this . asp_tags = false ; this . short_tags = true ; this . php7 = true ; this . yyprevcol = 0 ; this . keywords = { __class__ : this . tok . T_CLASS_C , __trait__ : this . tok . T_TRAIT_C , __function__ : this . tok . T_FUNC_C , __method__ : this . tok . T_METHOD_C , __line__ : this . tok . T_LINE , __file__ : this . tok . T_FILE , __dir__ : this . tok . T_DIR , __namespace__ : this . tok . T_NS_C , exit : this . tok . T_EXIT , die : this . tok . T_EXIT , function : this . tok . T_FUNCTION , const : this . tok . T_CONST , return : this . tok . T_RETURN , try : this . tok . T_TRY , catch : this . tok . T_CATCH , finally : this . tok . T_FINALLY , throw : this . tok . T_THROW , if : this . tok . T_IF , elseif : this . tok . T_ELSEIF , endif : this . tok . T_ENDIF , else : this . tok . T_ELSE , while : this . tok . T_WHILE , endwhile : this . tok . T_ENDWHILE , do : this . tok . T_DO , for : this . tok . T_FOR , endfor : this . tok . T_ENDFOR , foreach : this . tok . T_FOREACH , endforeach : this . tok . T_ENDFOREACH , declare : this . tok . T_DECLARE , enddeclare : this . tok . T_ENDDECLARE , instanceof : this . tok . T_INSTANCEOF , as : this . tok . T_AS , switch : this . tok . T_SWITCH , endswitch : this . tok . T_ENDSWITCH , case : this . tok . T_CASE , default : this . tok . T_DEFAULT , break : this . tok . T_BREAK , continue : this . tok . T_CONTINUE , goto : this . tok . T_GOTO , echo : this . tok . T_ECHO , print : this . tok . T_PRINT , class : this . tok . T_CLASS , interface : this . tok . T_INTERFACE , trait : this . tok . T_TRAIT , extends : this . tok . T_EXTENDS , implements : this . tok . T_IMPLEMENTS , new : this . tok . T_NEW , clone : this . tok . T_CLONE , var : this . tok . T_VAR , eval : this . tok . T_EVAL , include : this . tok . T_INCLUDE , include_once : this . tok . T_INCLUDE_ONCE , require : this . tok . T_REQUIRE , require_once : this . tok . T_REQUIRE_ONCE , namespace : this . tok . T_NAMESPACE , use : this . tok . T_USE , insteadof : this . tok . T_INSTEADOF , global : this . tok . T_GLOBAL , isset : this . tok . T_ISSET , empty : this . tok . T_EMPTY , __halt_compiler : this . tok . T_HALT_COMPILER , static : this . tok . T_STATIC , abstract : this . tok . T_ABSTRACT , final : this . tok . T_FINAL , private : this . tok . T_PRIVATE , protected : this . tok . T_PROTECTED , public : this . tok . T_PUBLIC , unset : this . tok . T_UNSET , list : this . tok . T_LIST , array : this . tok . T_ARRAY , callable : this . tok . T_CALLABLE , or : this . tok . T_LOGICAL_OR , and : this . tok . T_LOGICAL_AND , xor : this . tok . T_LOGICAL_XOR } ; this . castKeywords = { int : this . tok . T_INT_CAST , integer : this . tok . T_INT_CAST , real : this . tok . T_DOUBLE_CAST , double : this . tok . T_DOUBLE_CAST , float : this . tok . T_DOUBLE_CAST , string : this . tok . T_STRING_CAST , binary : this . tok . T_STRING_CAST , array : this . tok . T_ARRAY_CAST , object : this . tok . T_OBJECT_CAST , bool : this . tok . T_BOOL_CAST , boolean : this . tok . T_BOOL_CAST , unset : this . tok . T_UNSET_CAST } ; } 
function ( ) { const result = this . node ( "class" ) ; const flag = this . read_class_scope ( ) ; 
function ( ) { const result = this . token ; if ( result == this . tok . T_FINAL ) { this . next ( ) ; return [ 0 , 0 , 2 ] ; } else if ( result == this . tok . T_ABSTRACT ) { this . next ( ) ; return [ 0 , 0 , 1 ] ; } return [ 0 , 0 , 0 ] ; } 
function ( ) { let result = [ ] ; while ( this . token !== this . EOF && this . token !== "}" ) { if ( this . token === this . tok . T_COMMENT ) { result . push ( this . read_comment ( ) ) ; continue ; } if ( this . token === this . tok . T_DOC_COMMENT ) { result . push ( this . read_doc_comment ( ) ) ; continue ; } 
function ( flags ) { const result = this . node ( "propertystatement" ) ; const properties = this . read_list ( function read_variable_declaration ( ) { const result = this . node ( "property" ) ; this . expect ( this . tok . T_VARIABLE ) ; let propName = this . node ( "identifier" ) ; const name = this . text ( ) . substring ( 1 ) ; 
function ( flags ) { if ( this . expect ( this . tok . T_CONST ) ) { this . next ( ) ; } const result = this . node ( "classconstant" ) ; const items = this . read_list ( function read_constant_declaration ( ) { const result = this . node ( "constant" ) ; let constName = null ; let value = null ; if ( this . token === this . tok . T_STRING || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { constName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; constName = constName ( name ) ; } else { this . expect ( "IDENTIFIER" ) ; } if ( this . expect ( "=" ) ) { value = this . next ( ) . read_expr ( ) ; } return result ( constName , value ) ; } , "," ) ; return result ( null , items , flags ) ; } 
function read_constant_declaration ( ) { const result = this . node ( "constant" ) ; let constName = null ; let value = null ; if ( this . token === this . tok . T_STRING || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { constName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; constName = constName ( name ) ; } else { this . expect ( "IDENTIFIER" ) ; } if ( this . expect ( "=" ) ) { value = this . next ( ) . read_expr ( ) ; } return result ( constName , value ) ; } 
function ( asInterface ) { const result = [ - 1 , - 1 , - 1 ] ; if ( this . is ( "T_MEMBER_FLAGS" ) ) { let idx = 0 , val = 0 ; do { switch ( this . token ) { case this . tok . T_PUBLIC : idx = 0 ; val = 0 ; break ; case this . tok . T_PROTECTED : idx = 0 ; val = 1 ; break ; case this . tok . T_PRIVATE : idx = 0 ; val = 2 ; break ; case this . tok . T_STATIC : idx = 1 ; val = 1 ; break ; case this . tok . T_ABSTRACT : idx = 2 ; val = 1 ; break ; case this . tok . T_FINAL : idx = 2 ; val = 2 ; break ; } if ( asInterface ) { if ( idx == 0 && val == 2 ) { 
function ( ) { const result = this . node ( "interface" ) ; if ( this . token !== this . tok . T_INTERFACE ) { this . error ( this . tok . T_INTERFACE ) ; this . next ( ) ; return null ; } this . next ( ) . expect ( this . tok . T_STRING ) ; let propName = this . node ( "identifier" ) ; const name = this . text ( ) ; this . next ( ) ; propName = propName ( name ) ; let propExtends = null ; if ( this . token === this . tok . T_EXTENDS ) { propExtends = this . next ( ) . read_name_list ( ) ; } this . expect ( "{" ) ; const body = this . next ( ) . read_interface_body ( ) ; return result ( propName , propExtends , body ) ; } 
function ( ) { let result = [ ] ; while ( this . token !== this . EOF && this . token !== "}" ) { if ( this . token === this . tok . T_COMMENT ) { result . push ( this . read_comment ( ) ) ; continue ; } if ( this . token === this . tok . T_DOC_COMMENT ) { result . push ( this . read_doc_comment ( ) ) ; continue ; } 
function ( ) { const result = this . node ( "trait" ) ; 
function ( ) { 
function ( ) { const node = this . node ( ) ; let trait = null ; let method ; if ( this . is ( "IDENTIFIER" ) ) { method = this . node ( "identifier" ) ; const methodName = this . text ( ) ; this . next ( ) ; method = method ( methodName ) ; } else { method = this . read_namespace_name ( ) ; if ( this . token === this . tok . T_DOUBLE_COLON ) { this . next ( ) ; if ( this . token === this . tok . T_STRING || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { trait = method ; method = this . node ( "identifier" ) ; const methodName = this . text ( ) ; this . next ( ) ; method = method ( methodName ) ; } else { this . expect ( this . tok . T_STRING ) ; } } else { 
function ( ) { this . expect ( this . tok . T_TRY ) ; const result = this . node ( "try" ) ; let always = null ; const catches = [ ] ; const body = this . next ( ) . read_statement ( ) ; 
function ( read_only , encapsed , byref ) { let result ; 
function ( what , encapsed ) { const result = this . node ( "staticlookup" ) ; let offset , name ; if ( this . next ( ) . is ( [ this . tok . T_VARIABLE , "$" ] ) ) { offset = this . read_reference_variable ( encapsed , false ) ; } else if ( this . token === this . tok . T_STRING || this . token === this . tok . T_CLASS || ( this . php7 && this . is ( "IDENTIFIER" ) ) ) { offset = this . node ( "identifier" ) ; name = this . text ( ) ; this . next ( ) ; offset = offset ( name ) ; } else if ( this . token === "{" ) { offset = this . node ( "literal" ) ; name = this . next ( ) . read_expr ( ) ; this . expect ( "}" ) && this . next ( ) ; offset = offset ( "literal" , name , null ) ; this . expect ( "(" ) ; } else { this . error ( [ this . tok . T_VARIABLE , this . tok . T_STRING ] ) ; 
function ( ) { let offset = this . node ( ) ; if ( this . token === this . tok . T_STRING ) { const text = this . text ( ) ; this . next ( ) ; offset = offset ( "identifier" , text ) ; } else if ( this . token === this . tok . T_NUM_STRING ) { const num = this . text ( ) ; this . next ( ) ; offset = offset ( "number" , num , null ) ; } else if ( this . token === this . tok . T_VARIABLE ) { const name = this . text ( ) . substring ( 1 ) ; this . next ( ) ; offset = offset ( "variable" , name , false , false ) ; } else { this . expect ( [ this . tok . T_STRING , this . tok . T_NUM_STRING , this . tok . T_VARIABLE ] ) ; 
function ( encapsed , byref ) { let result = this . read_simple_variable ( byref ) ; let offset ; while ( this . token != this . EOF ) { const node = this . node ( ) ; if ( this . token == "{" && ! encapsed ) { 
function ( byref ) { let result = this . node ( "variable" ) ; let name ; if ( this . expect ( [ this . tok . T_VARIABLE , "$" ] ) && this . token === this . tok . T_VARIABLE ) { 
function ( options ) { if ( typeof this === "function" ) { return new this ( options ) ; } this . tokens = tokens ; this . lexer = new lexer ( this ) ; this . ast = new AST ( ) ; this . parser = new parser ( this . lexer , this . ast ) ; if ( options && typeof options === "object" ) { 
function ( ) { const result = this . node ( "switch" ) ; this . expect ( this . tok . T_SWITCH ) && this . next ( ) ; this . expect ( "(" ) && this . next ( ) ; const test = this . read_expr ( ) ; this . expect ( ")" ) && this . next ( ) ; const shortForm = this . token === ":" ; const body = this . read_switch_case_list ( ) ; return result ( test , body , shortForm ) ; } 
function ( ) { 
function ( stopToken ) { const result = this . node ( "case" ) ; let test = null ; let body = null ; const items = [ ] ; if ( this . token === this . tok . T_CASE ) { test = this . next ( ) . read_expr ( ) ; } else if ( this . token === this . tok . T_DEFAULT ) { 
function ( ) { while ( this . offset < this . size ) { const ch = this . input ( ) ; if ( ch === "\n" || ch === "\r" ) { return this . tok . T_COMMENT ; } else if ( ch === "?" && ! this . aspTagMode && this . _input [ this . offset ] === ">" ) { this . unput ( 1 ) ; return this . tok . T_COMMENT ; } else if ( ch === "%" && this . aspTagMode && this . _input [ this . offset ] === ">" ) { this . unput ( 1 ) ; return this . tok . T_COMMENT ; } } return this . tok . T_COMMENT ; } 
function ( ) { let ch = this . input ( ) ; let token = this . tok . T_COMMENT ; if ( ch === "*" ) { 
function ( token ) { const body = this . node ( "block" ) ; const items = [ ] ; if ( this . expect ( ":" ) ) this . next ( ) ; while ( this . token != this . EOF && this . token !== token ) { items . push ( this . read_inner_statement ( ) ) ; } if ( this . expect ( token ) ) this . next ( ) ; this . expectEndOfStatement ( ) ; return body ( null , items ) ; } 
function ( item , separator , preserveFirstSeparator ) { const result = [ ] ; if ( this . token == separator ) { if ( preserveFirstSeparator ) result . push ( null ) ; this . next ( ) ; } if ( typeof item === "function" ) { do { result . push ( item . apply ( this , [ ] ) ) ; if ( this . token != separator ) { break ; } } while ( this . next ( ) . token != this . EOF ) ; } else { if ( this . expect ( item ) ) { result . push ( this . text ( ) ) ; } else { return [ ] ; } while ( this . next ( ) . token != this . EOF ) { if ( this . token != separator ) break ; 
function ( ) { return this . read_list ( function ( ) { const node = this . node ( "staticvariable" ) ; let variable = this . node ( "variable" ) ; 
function ( ) { const text = this . text ( ) ; let result = this . ast . prepare ( text . substring ( 0 , 2 ) === "/*" ? "commentblock" : "commentline" , null , this ) ; const offset = this . lexer . yylloc . first_offset ; 
function findChunkFile ( chunk , chunkId , outputFilePath ) { for ( let i = 0 ; i < chunk . files . length ; i ++ ) { const chunkFile = chunk . files [ i ] ; let normalizedOutputFilePath = outputFilePath . replace ( / ^\.\/ / , '' ) ; if ( ! / \.js$ / . test ( chunkFile ) ) { normalizedOutputFilePath = normalizedOutputFilePath . substr ( 0 , normalizedOutputFilePath . length - 3 ) ; } if ( normalizedOutputFilePath === chunkFile ) { return chunkFile ; } } if ( chunk . id === chunkId ) { return chunk . files [ 0 ] ; } return undefined ; 
function findAncestorDistance ( src , target , currentDistance ) { if ( target === src ) { return currentDistance ; } const distances = [ ] ; src . getParents ( ) . forEach ( ( srcParentChunkGroup ) => { const distance = findAncestorDistance ( srcParentChunkGroup , target , currentDistance + 1 ) ; if ( distance >= 0 ) { distances . push ( distance ) ; } } ) ; if ( distances . length === 0 ) { return - 1 ; } return Math . min ( ... distances ) ; } 
function findNearestCommonParentChunk ( chunkGroups , currentDistance = 0 ) { 
function ( element ) { if ( ! element || ! element . getAttribute ) return { } ; var _params = { } , _dataparams = _queryToObject ( element . getAttribute ( "data-params" ) || '' ) ; 
function ( page , data ) { if ( page . flagAniBind == true ) return ; 
function ( string ) { var obj = { } ; if ( typeof string == "string" ) { string . split ( "&" ) . forEach ( function ( part ) { var arrPart = part . split ( "=" ) ; if ( arrPart . length > 1 ) { obj [ arrPart [ 0 ] ] = part . replace ( arrPart [ 0 ] + "=" , "" ) ; } } ) ; } return obj ; } 
function updateProps ( domNode , oldVirtualNode , oldProps , newVirtualNode , newProps ) { if ( oldProps ) { for ( var name in oldProps ) { if ( name === 'ref' || name === 'on' ) continue if ( name in EVENT_LISTENER_PROPS ) continue if ( ! newProps || ! ( name in newProps ) ) { if ( name === 'dataset' ) { updateProps ( domNode . dataset , null , oldProps && oldProps . dataset , null , null ) } else if ( name !== 'innerHTML' && oldVirtualNode && SVG_TAGS . has ( oldVirtualNode . tag ) ) { domNode . removeAttribute ( SVG_ATTRIBUTE_TRANSLATIONS . get ( name ) || name ) } else { 
function initialize ( component ) { if ( typeof component . update !== 'function' ) { throw new Error ( 'Etch components must implement `update(props, children)`.' ) } let virtualNode = component . render ( ) if ( ! isValidVirtualNode ( virtualNode ) ) { let namePart = component . constructor && component . constructor . name ? ' in ' + component . constructor . name : '' throw new Error ( 'invalid falsy value ' + virtualNode + ' returned from render()' + namePart ) } applyContext ( component , virtualNode ) component . refs = { } component . virtualNode = virtualNode component . element = render ( component . virtualNode , { refs : component . refs , listenerContext : component } ) } 
function update ( component , replaceNode = true ) { if ( syncUpdatesInProgressCounter > 0 ) { updateSync ( component , replaceNode ) return Promise . resolve ( ) } let scheduler = getScheduler ( ) if ( ! componentsWithPendingUpdates . has ( component ) ) { componentsWithPendingUpdates . add ( component ) scheduler . updateDocument ( function ( ) { componentsWithPendingUpdates . delete ( component ) updateSync ( component , replaceNode ) } ) } return scheduler . getNextUpdatePromise ( ) } 
function updateSync ( component , replaceNode = true ) { if ( ! isValidVirtualNode ( component . virtualNode ) ) { throw new Error ( ` ${ component . constructor ? component . constructor . name + ' instance' : component } ` ) } if ( component . element == null ) { throw new Error ( ` ${ component . constructor ? component . constructor . name + ' instance' : component } ` ) } let newVirtualNode = component . render ( ) if ( ! isValidVirtualNode ( newVirtualNode ) ) { const namePart = component . constructor && component . constructor . name ? ' in ' + component . constructor . name : '' throw new Error ( 'invalid falsy value ' + newVirtualNode + ' returned from render()' + namePart ) } applyContext ( component , newVirtualNode ) syncUpdatesInProgressCounter ++ let oldVirtualNode = component . virtualNode let oldDomNode = component . element let newDomNode = patch ( oldVirtualNode , newVirtualNode , { refs : component . refs , listenerContext : component } ) component . virtualNode = newVirtualNode if ( newDomNode !== oldDomNode && ! replaceNode ) { throw new Error ( 'The root node type changed on update, but the update was performed with the replaceNode option set to false' ) } else { component . element = newDomNode } 
function destroy ( component , removeNode = true ) { if ( syncUpdatesInProgressCounter > 0 || syncDestructionsInProgressCounter > 0 ) { destroySync ( component , removeNode ) return Promise . resolve ( ) } let scheduler = getScheduler ( ) scheduler . updateDocument ( function ( ) { destroySync ( component , removeNode ) } ) return scheduler . getNextUpdatePromise ( ) } 
function destroySync ( component , removeNode = true ) { syncDestructionsInProgressCounter ++ destroyChildComponents ( component . virtualNode ) if ( syncDestructionsInProgressCounter === 1 && removeNode ) component . element . remove ( ) syncDestructionsInProgressCounter -- } 
function makeOriginal ( userTheme = { } ) { 
function enlargeUUID ( shortId , translator ) { var uu1 = translator ( shortId ) ; var leftPad = "" ; var m ; 
function loadTasks ( grunt ) { grunt . loadNpmTasks ( 'grunt-simple-mocha' ) ; grunt . loadNpmTasks ( 'grunt-mocha-nyc' ) ; grunt . loadNpmTasks ( 'grunt-mkdir' ) ; grunt . loadNpmTasks ( 'grunt-browserify' ) ; grunt . loadNpmTasks ( 'grunt-contrib-uglify' ) ; } 
function updateConfig ( config ) { config = config || { } ; if ( argv . src && argv . src . length ) { config . src = [ ] ; let s , p ; const named = { } ; _ . each ( argv . src , item => { s = item . split ( ':' ) ; if ( s . length > 1 ) { p = s [ 0 ] ; named [ p ] = named [ p ] || [ ] ; named [ p ] . push ( s . slice ( 1 ) ) ; } else { config . src . push ( item ) ; } } ) ; if ( _ . keys ( named ) . length ) config . src . push ( named ) ; } if ( argv . dest ) config . dest = argv . dest ; if ( argv . clean ) config . clean = Boolean ( argv . clean ) ; if ( argv . base ) { config . app = config . app || { } ; config . app . base = argv . base ; } 
function _addMetasToDoc ( $ , metaList ) { if ( ! _ . isArray ( metaList ) || metaList . length === 0 ) return ; const $head = $ ( 'head' ) ; let lastMeta ; const existingMetas = $head . find ( 'meta' ) ; if ( existingMetas . length > 0 ) { lastMeta = existingMetas . eq ( existingMetas . length - 1 ) ; } else { lastMeta = HtmlParser . DOM . N_TAB + HtmlParser . DOM . getMetaElem ( metaList [ 0 ] ) ; lastMeta = $head . prepend ( lastMeta ) . find ( 'meta' ) ; metaList . shift ( ) ; 
function _insertBeforeFirst ( $container , selector , elem ) { const foundElems = $container . find ( selector ) ; if ( foundElems . length > 0 ) { foundElems . eq ( 0 ) . before ( elem ) ; } else { $container . append ( elem ) ; } } 
function setTitleSize ( ) { var sb = templateOpts . sidebar . enabled ; var nb = templateOpts . navbar . enabled ; if ( ! sb && ! nb ) return ; var $a = sb ? $ ( '.sidebar-title a' ) : $ ( '.navbar-title a' ) ; 
function cleanFilter ( ) { sbSearch . reset ( ) ; if ( ! templateOpts . sidebar . enabled || ! $sidebarNodes ) return ; setFilterBtnStates ( ) ; if ( $txtSearch ) $txtSearch . val ( '' ) ; $sidebarNodes . removeClass ( 'hidden' ) ; if ( $btnClean ) $btnClean . hide ( ) ; $ ( '.toolbar-buttons > span' ) . css ( 'color' , '#fff' ) ; 
function applySearch ( strSearch ) { sbSearch . parse ( strSearch ) ; setFilterBtnStates ( ) ; $sidebarNodes . each ( function ( ) { var node = $ ( this ) ; var show = true ; if ( sbSearch . scope . length > 0 ) { show = sbSearch . hasScope ( node . attr ( 'data-scope' ) ) ; } if ( show && sbSearch . kind . length > 0 ) { show = sbSearch . hasKind ( node . attr ( 'data-kind' ) ) ; } if ( show && sbSearch . keywords . length > 0 ) { 
function filterSidebarNodes ( strSearch ) { if ( ! templateOpts . sidebar . enabled ) return ; strSearch = ( strSearch || '' ) . trim ( ) . toLowerCase ( ) ; if ( ! strSearch ) { cleanFilter ( ) ; return ; } if ( $btnClean ) $btnClean . show ( ) ; 
function toggleSubTree ( elem , fold ) { fold = typeof fold !== 'boolean' ? ! elem . hasClass ( 'members-folded' ) 
function toggleHamMenu ( show ) { if ( ! $nbmBtn ) return ; var fn = show ? 'addClass' : 'removeClass' ; $nbmBtn [ fn ] ( 'toggled' ) ; $navOverlay [ fn ] ( 'toggled' ) ; 
function breakNavbarMenu ( ) { 
function checkOpenDetails ( ) { if ( docma . location . hash ) { var elem = $ ( 'details#' + $ . escapeSelector ( docma . location . hash ) ) ; if ( elem && elem [ 0 ] ) elem . attr ( 'open' , '' ) ; } } 
function getFilterClickHandler ( filter ) { var isKind = filter === 'kind' ; var has = isKind ? sbSearch . hasKind : sbSearch . hasScope ; var add = isKind ? sbSearch . addKind : sbSearch . addScope ; var remove = isKind ? sbSearch . removeKind : sbSearch . removeScope ; return function ( event ) { var btn = $ ( this ) ; 
function _redirecting ( ) { if ( PATH_ROUTING ) { var redirectPath = sessionStorage . getItem ( 'redirectPath' ) || null ; if ( redirectPath ) { sessionStorage . removeItem ( 'redirectPath' ) ; docma . info ( 'Redirecting to:' , redirectPath ) ; page . redirect ( redirectPath ) ; return true ; } } return false ; } 
function getFileSync ( filename , basePath = null ) { const cPath = Path . resolve ( Path . join ( basePath || process . cwd ( ) , filename ) ) ; return fs . pathExistsSync ( cPath ) ? cPath : null ; } 
function _promiseAppendJQuery ( obj ) { const document = obj . document || obj ; 
function getTemplate ( nameOrTemplate , loadFromCache ) { if ( ! nameOrTemplate ) { return ; } if ( typeof nameOrTemplate === 'function' && nameOrTemplate . template ) { 
function getWithResolvedData ( ctx , cur , down ) { return function ( data ) { return ctx . push ( data ) . _get ( cur , down ) ; } ; } 
function DocmaWeb ( data ) { this . _ = data || { } ; * Provides configuration data of the generated SPA, which is originally set * at build-time, by the user. * See {@link api/#Docma~BuildConfiguration|build configuration} for more * details on how these settings take affect. * @name DocmaWeb#app * @type {Object} * * @property {String} title * Document title for the main file of the generated app. * (Value of the `&lt;title/>` tag.) * @property {Array} meta * Array of arbitrary objects set for main document meta (tags). * @property {String} base * Base path of the generated web app. * @property {String} entrance * Name of the initial content displayed, when the web app is first * loaded. * @property {String|Object} routing * Routing settings for the generated SPA. * @property {String} server * Server/host type of the generated SPA. */ Object . defineProperty ( this , 'app' , { configurable : false , get : function ( ) { return this . _ . app || null ; } } ) ; Object . defineProperty ( this , 'apis' , { configurable : false , get : function ( ) { return this . _ . apis || { } ; } } ) ; Object . defineProperty ( this , 'routes' , { configurable : false , get : function ( ) { return this . _ . routes || { } ; } } ) ; Object . defineProperty ( this , 'template' , { configurable : false , get : function ( ) { return this . _ . template || { } ; } } ) ; * Similar to `window.location` but with differences and additional * information. * * @name DocmaWeb#location * @type {Object} * @readonly * * @property {String} origin * Gets the protocol, hostname and port number of the current URL. * @property {String} host * Gets the hostname and port number of the current URL. * @property {String} hostname * Gets the domain name of the web host. * @property {String} protocol * Gets the web protocol used, without `:` suffix. * @property {String} href * Gets the href (URL) of the current location. * @property {String} entrance * Gets the application entrance route, which is set at Docma build-time. * @property {String} base * Gets the base path of the application URL, which is set at Docma build-time. * @property {String} fullpath * Gets the path and filename of the current URL. * @property {String} pathname * Gets the path and filename of the current URL, without the base. * @property {String} path * Gets the path, filename and query-string of the current URL, without the base. * @property {String} hash * Gets the anchor `#` of the current URL, without `#` prefix. * @property {String} query * Gets the querystring part of the current URL, without `?` prefix. * @property {Function} getQuery() * Gets the value of the given querystring parameter. */ Object . defineProperty ( this , 'location' , { configurable : false , get : function ( ) { var fullpath = Utils . _ensureSlash ( true , window . location . pathname , true ) , base = Utils . _ensureSlash ( true , docma . app . base , true ) , pathname = fullpath ; if ( fullpath . slice ( 0 , base . length ) === base ) { pathname = fullpath . slice ( base . length - 1 , fullpath . length ) ; } return { host : window . location . host , hostname : window . location . hostname , origin : window . location . origin , port : window . location . port , protocol : ( window . location . protocol || '' ) . replace ( / :$ / , '' ) , entrance : Utils . _ensureSlash ( true , docma . app . entrance , false ) , base : base , hash : ( window . location . hash || '' ) . replace ( / ^# / , '' ) , query : ( window . location . search || '' ) . replace ( / ^\? / , '' ) , href : window . location . href , fullpath : fullpath , pathname : pathname , path : pathname + ( window . location . search || '' ) , getQuery : function ( name , query ) { * Gets the route information for the current rendered content being * displayed. * * @name DocmaWeb#currentRoute * @type {DocmaWeb.Route} * @readonly * * @property {String} type * Type of the current route. If a generated JSDoc API * documentation is being displayed, this is set to `"api"`. * If any other HTML content (such as a converted markdown) is * being displayed; this is set to `"content"`. * @property {String} name * Name of the current route. For `api` routes, this is the name * of the grouped JS files parsed. If no name is given, this is * set to `"_def_"` by default. For `content` routes, this is * either the custom name given at build-time or, by default; the * name of the generated HTML file; lower-cased, without the * extension. e.g. `"README.md"` will have the route name * `"readme"` after the build. * @property {String} path * Path of the current route. */ Object . defineProperty ( this , 'currentRoute' , { configurable : false , get : function ( ) { return this . _ . currentRoute || null ; } } ) ; Object . defineProperty ( this , 'documentation' , { configurable : false , get : function ( ) { return this . _ . documentation || [ ] ; } } ) ; Object . defineProperty ( this , 'symbols' , { configurable : false , get : function ( ) { return this . _ . symbols || [ ] ; } } ) ; } 
function setOpt ( oldProp , oldType , target , rename ) { const types = utils . ensureArray ( oldType ) ; if ( oldProp in opts && types . indexOf ( typeOf ( opts [ oldProp ] ) ) >= 0 ) { target [ rename || oldProp ] = opts [ oldProp ] ; } } 
function cleanName ( name ) { 
function checkRootDir ( ) { return fs . pathExists ( rootDirPath ) . then ( exists => { if ( ! exists ) { 
function getTreeLine ( treeNode , addClass ) { var cls = 'item-tree-line' ; if ( addClass ) cls += ' ' + addClass ; if ( treeNode === 'parent' ) cls += ' item-tree-parent' ; return '<img class="' + cls + '" src="img/tree-' + treeNode + '.png" width="' + app . TREE_NODE_WIDTH + '" height="' + app . SIDEBAR_NODE_HEIGHT + '" />' ; } 
function getTreeLineImgs ( levels , treeNode , hasChildren , lastNodeLevels ) { 
function computeInputVariants ( str , n ) { var variants = [ str ] ; for ( var i = 1 ; i < n ; i ++ ) { var pos = Math . floor ( Math . random ( ) * str . length ) ; var chr = String . fromCharCode ( ( str . charCodeAt ( pos ) + Math . floor ( Math . random ( ) * 128 ) ) % 128 ) ; variants [ i ] = str . substring ( 0 , pos ) + chr + str . substring ( pos + 1 , str . length ) ; } return variants ; } 
function Benchmark ( name , run , setup , tearDown ) { this . name = name ; this . run = run ; this . Setup = setup ? setup : function ( ) { } ; this . TearDown = tearDown ? tearDown : function ( ) { } ; } 
function BenchmarkSuite ( name , reference , benchmarks ) { this . name = name ; this . reference = reference ; this . benchmarks = benchmarks ; BenchmarkSuite . suites . push ( this ) ; } 
function RunNextSetup ( ) { if ( index < length ) { try { suite . benchmarks [ index ] . Setup ( ) ; } catch ( e ) { suite . NotifyError ( e ) ; return null ; } return RunNextBenchmark ; } suite . NotifyResult ( ) ; return null ; } 
function FormatMessage ( type , arg0 , arg1 , arg2 ) { var arg0 = NoSideEffectsToString ( arg0 ) ; var arg1 = NoSideEffectsToString ( arg1 ) ; var arg2 = NoSideEffectsToString ( arg2 ) ; try { return % FormatMessageString ( type , arg0 , arg1 , arg2 ) ; } catch ( e ) { return "<error>" ; } } 
function GetColumnNumber ( message ) { var script = % MessageGetScript ( message ) ; var start_position = % MessageGetStartPosition ( message ) ; var location = script . locationFromPosition ( start_position , true ) ; if ( location == null ) return - 1 ; return location . column ; } 
function GetSourceLine ( message ) { var script = % MessageGetScript ( message ) ; var start_position = % MessageGetStartPosition ( message ) ; var location = script . locationFromPosition ( start_position , true ) ; if ( location == null ) return "" ; return location . sourceText ; } 
function CallSite ( receiver , fun , pos , strict_mode ) { 
function ( ) { var formatted_stack_trace = UNDEFINED ; var holder = this ; while ( holder ) { var formatted_stack_trace = GET_PRIVATE ( holder , formattedStackTraceSymbol ) ; if ( IS_UNDEFINED ( formatted_stack_trace ) ) { 
function SetUpError ( error_function ) { % FunctionSetInstanceClassName ( error_function , 'Error' ) ; var name = error_function . name ; var prototype = new GlobalObject ( ) ; if ( name !== 'Error' ) { % InternalSetPrototype ( error_function , GlobalError ) ; % InternalSetPrototype ( prototype , GlobalError . prototype ) ; } % FunctionSetPrototype ( error_function , prototype ) ; % AddNamedProperty ( error_function . prototype , 'name' , name , DONT_ENUM ) ; % AddNamedProperty ( error_function . prototype , 'message' , '' , DONT_ENUM ) ; % AddNamedProperty ( error_function . prototype , 'constructor' , error_function , DONT_ENUM ) ; % SetCode ( error_function , function ( m ) { if ( IS_UNDEFINED ( new . target ) ) return new error_function ( m ) ; try { captureStackTrace ( this , error_function ) ; } catch ( e ) { } 
function sendPacket ( socket , srcMAC , type , serverIP , yourIP ) { 
function Float32x4Constructor ( c0 , c1 , c2 , c3 ) { if ( ! IS_UNDEFINED ( new . target ) ) { throw MakeTypeError ( kNotConstructor , "Float32x4" ) ; } return % CreateFloat32x4 ( TO_NUMBER ( c0 ) , TO_NUMBER ( c1 ) , TO_NUMBER ( c2 ) , TO_NUMBER ( c3 ) ) ; } 
function StringPad ( thisString , maxLength , fillString ) { maxLength = TO_LENGTH ( maxLength ) ; var stringLength = thisString . length ; if ( maxLength <= stringLength ) return "" ; if ( IS_UNDEFINED ( fillString ) ) { fillString = " " ; } else { fillString = TO_STRING ( fillString ) ; if ( fillString === "" ) { 
function TimerEvent ( label , color , pause , thread_id ) { assert ( thread_id >= 0 && thread_id < kNumThreads , "invalid thread id" ) ; this . label = label ; this . color = color ; this . pause = pause ; this . ranges = [ ] ; this . thread_id = thread_id ; this . index = ++ num_timer_event ; } 
function assert ( something , message ) { if ( ! something ) { var error = new Error ( message ) ; error_output ( error . stack ) ; } } 
function ( timestamp ) { int_timestamp = parseInt ( timestamp ) ; assert ( int_timestamp >= last_timestamp , "Inconsistent timestamps." ) ; last_timestamp = int_timestamp ; distortion += distortion_per_entry ; return int_timestamp / 1000 - distortion ; } 
function SpreadArguments ( ) { var count = arguments . length ; var args = new InternalArray ( ) ; for ( var i = 0 ; i < count ; ++ i ) { var array = arguments [ i ] ; var length = array . length ; for ( var j = 0 ; j < length ; ++ j ) { args . push ( array [ j ] ) ; } } return args ; } 
function IsRegExp ( o ) { if ( ! IS_RECEIVER ( o ) ) return false ; var is_regexp = o [ matchSymbol ] ; if ( ! IS_UNDEFINED ( is_regexp ) ) return TO_BOOLEAN ( is_regexp ) ; return IS_REGEXP ( o ) ; } 
function RegExpInitialize ( object , pattern , flags ) { pattern = IS_UNDEFINED ( pattern ) ? '' : TO_STRING ( pattern ) ; flags = IS_UNDEFINED ( flags ) ? '' : TO_STRING ( flags ) ; % RegExpInitializeAndCompile ( object , pattern , flags ) ; return object ; } 
function RegExpConstructor ( pattern , flags ) { var newtarget = new . target ; var pattern_is_regexp = IsRegExp ( pattern ) ; if ( IS_UNDEFINED ( newtarget ) ) { newtarget = GlobalRegExp ; 
function RegExpCompileJS ( pattern , flags ) { if ( ! IS_REGEXP ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , "RegExp.prototype.compile" , this ) ; } if ( IS_REGEXP ( pattern ) ) { if ( ! IS_UNDEFINED ( flags ) ) throw MakeTypeError ( kRegExpFlags ) ; flags = PatternFlags ( pattern ) ; pattern = REGEXP_SOURCE ( pattern ) ; } RegExpInitialize ( this , pattern , flags ) ; 
function RegExpExecJS ( string ) { if ( ! IS_REGEXP ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , 'RegExp.prototype.exec' , this ) ; } string = TO_STRING ( string ) ; var lastIndex = this . lastIndex ; 
function RegExpSplit ( string , limit ) { 
function StringReplaceGlobalRegExpWithFunction ( subject , regexp , replace ) { var resultArray = reusableReplaceArray ; if ( resultArray ) { reusableReplaceArray = null ; } else { 
function CaptureString ( string , lastCaptureInfo , index ) { 
function GetSubstitution ( matched , string , position , captures , replacement ) { var matchLength = matched . length ; var stringLength = string . length ; var capturesLength = captures . length ; var tailPos = position + matchLength ; var result = "" ; var pos , expansion , peek , next , scaledIndex , advance , newScaledIndex ; var next = % StringIndexOf ( replacement , '$' , 0 ) ; if ( next < 0 ) { result += replacement ; return result ; } if ( next > 0 ) result += % _SubString ( replacement , 0 , next ) ; while ( true ) { expansion = '$' ; pos = next + 1 ; if ( pos < replacement . length ) { peek = % _StringCharCodeAt ( replacement , pos ) ; if ( peek == 36 ) { 
function AdvanceStringIndex ( string , index , unicode ) { var increment = 1 ; if ( unicode ) { var first = % _StringCharCodeAt ( string , index ) ; if ( first >= 0xD800 && first <= 0xDBFF && string . length > index + 1 ) { var second = % _StringCharCodeAt ( string , index + 1 ) ; if ( second >= 0xDC00 && second <= 0xDFFF ) { increment = 2 ; } } } return increment ; } 
function RegExpGetLastMatch ( ) { var regExpSubject = LAST_SUBJECT ( RegExpLastMatchInfo ) ; return % _SubString ( regExpSubject , RegExpLastMatchInfo [ CAPTURE0 ] , RegExpLastMatchInfo [ CAPTURE1 ] ) ; } 
function RegExpMakeCaptureGetter ( n ) { return function foo ( ) { var index = n * 2 ; if ( index >= NUMBER_OF_CAPTURES ( RegExpLastMatchInfo ) ) return '' ; var matchStart = RegExpLastMatchInfo [ CAPTURE ( index ) ] ; var matchEnd = RegExpLastMatchInfo [ CAPTURE ( index + 1 ) ] ; if ( matchStart == - 1 || matchEnd == - 1 ) return '' ; return % _SubString ( LAST_SUBJECT ( RegExpLastMatchInfo ) , matchStart , matchEnd ) ; } ; } 
function RegExpGetFlags ( ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kRegExpNonObject , "RegExp.prototype.flags" , TO_STRING ( this ) ) ; } var result = '' ; if ( this . global ) result += 'g' ; if ( this . ignoreCase ) result += 'i' ; if ( this . multiline ) result += 'm' ; if ( this . unicode ) result += 'u' ; if ( this . sticky ) result += 'y' ; return result ; } 
function RegExpGetIgnoreCase ( ) { if ( ! IS_REGEXP ( this ) ) { 
function RegExpGetMultiline ( ) { if ( ! IS_REGEXP ( this ) ) { 
function BigInteger ( a , b , c ) { this . array = new Array ( ) ; if ( a != null ) if ( "number" == typeof a ) this . fromNumber ( a , b , c ) ; else if ( b == null && "string" != typeof a ) this . fromString ( a , 256 ) ; else this . fromString ( a , b ) ; } 
function am1 ( i , x , w , j , c , n ) { var this_array = this . array ; var w_array = w . array ; while ( -- n >= 0 ) { var v = x * this_array [ i ++ ] + w_array [ j ] + c ; c = Math . floor ( v / 0x4000000 ) ; w_array [ j ++ ] = v & 0x3ffffff ; } return c ; } 
function bnpCopyTo ( r ) { var this_array = this . array ; var r_array = r . array ; for ( var i = this . t - 1 ; i >= 0 ; -- i ) r_array [ i ] = this_array [ i ] ; r . t = this . t ; r . s = this . s ; } 
function bnpFromInt ( x ) { var this_array = this . array ; this . t = 1 ; this . s = ( x < 0 ) ? - 1 : 0 ; if ( x > 0 ) this_array [ 0 ] = x ; else if ( x < - 1 ) this_array [ 0 ] = x + DV ; else this . t = 0 ; } 
function bnpClamp ( ) { var this_array = this . array ; var c = this . s & BI_DM ; while ( this . t > 0 && this_array [ this . t - 1 ] == c ) -- this . t ; } 
function bnCompareTo ( a ) { var this_array = this . array ; var a_array = a . array ; var r = this . s - a . s ; if ( r != 0 ) return r ; var i = this . t ; r = i - a . t ; if ( r != 0 ) return r ; while ( -- i >= 0 ) if ( ( r = this_array [ i ] - a_array [ i ] ) != 0 ) return r ; return 0 ; } 
function bnBitLength ( ) { var this_array = this . array ; if ( this . t <= 0 ) return 0 ; return BI_DB * ( this . t - 1 ) + nbits ( this_array [ this . t - 1 ] ^ ( this . s & BI_DM ) ) ; } 
function bnpDLShiftTo ( n , r ) { var this_array = this . array ; var r_array = r . array ; var i ; for ( i = this . t - 1 ; i >= 0 ; -- i ) r_array [ i + n ] = this_array [ i ] ; for ( i = n - 1 ; i >= 0 ; -- i ) r_array [ i ] = 0 ; r . t = this . t + n ; r . s = this . s ; } 
function bnpDRShiftTo ( n , r ) { var this_array = this . array ; var r_array = r . array ; for ( var i = n ; i < this . t ; ++ i ) r_array [ i - n ] = this_array [ i ] ; r . t = Math . max ( this . t - n , 0 ) ; r . s = this . s ; } 
function bnpLShiftTo ( n , r ) { var this_array = this . array ; var r_array = r . array ; var bs = n % BI_DB ; var cbs = BI_DB - bs ; var bm = ( 1 << cbs ) - 1 ; var ds = Math . floor ( n / BI_DB ) , c = ( this . s << bs ) & BI_DM , i ; for ( i = this . t - 1 ; i >= 0 ; -- i ) { r_array [ i + ds + 1 ] = ( this_array [ i ] >> cbs ) | c ; c = ( this_array [ i ] & bm ) << bs ; } for ( i = ds - 1 ; i >= 0 ; -- i ) r_array [ i ] = 0 ; r_array [ ds ] = c ; r . t = this . t + ds + 1 ; r . s = this . s ; r . clamp ( ) ; } 
function bnpRShiftTo ( n , r ) { var this_array = this . array ; var r_array = r . array ; r . s = this . s ; var ds = Math . floor ( n / BI_DB ) ; if ( ds >= this . t ) { r . t = 0 ; return ; } var bs = n % BI_DB ; var cbs = BI_DB - bs ; var bm = ( 1 << bs ) - 1 ; r_array [ 0 ] = this_array [ ds ] >> bs ; for ( var i = ds + 1 ; i < this . t ; ++ i ) { r_array [ i - ds - 1 ] |= ( this_array [ i ] & bm ) << cbs ; r_array [ i - ds ] = this_array [ i ] >> bs ; } if ( bs > 0 ) r_array [ this . t - ds - 1 ] |= ( this . s & bm ) << cbs ; r . t = this . t - ds ; r . clamp ( ) ; } 
function bnpSubTo ( a , r ) { var this_array = this . array ; var r_array = r . array ; var a_array = a . array ; var i = 0 , c = 0 , m = Math . min ( a . t , this . t ) ; while ( i < m ) { c += this_array [ i ] - a_array [ i ] ; r_array [ i ++ ] = c & BI_DM ; c >>= BI_DB ; } if ( a . t < this . t ) { c -= a . s ; while ( i < this . t ) { c += this_array [ i ] ; r_array [ i ++ ] = c & BI_DM ; c >>= BI_DB ; } c += this . s ; } else { c += this . s ; while ( i < a . t ) { c -= a_array [ i ] ; r_array [ i ++ ] = c & BI_DM ; c >>= BI_DB ; } c -= a . s ; } r . s = ( c < 0 ) ? - 1 : 0 ; if ( c < - 1 ) r_array [ i ++ ] = BI_DV + c ; else if ( c > 0 ) r_array [ i ++ ] = c ; r . t = i ; r . clamp ( ) ; } 
function bnpMultiplyTo ( a , r ) { var this_array = this . array ; var r_array = r . array ; var x = this . abs ( ) , y = a . abs ( ) ; var y_array = y . array ; var i = x . t ; r . t = i + y . t ; while ( -- i >= 0 ) r_array [ i ] = 0 ; for ( i = 0 ; i < y . t ; ++ i ) r_array [ i + x . t ] = x . am ( 0 , y_array [ i ] , r , i , 0 , x . t ) ; r . s = 0 ; r . clamp ( ) ; if ( this . s != a . s ) BigInteger . ZERO . subTo ( r , r ) ; } 
function bnpSquareTo ( r ) { var x = this . abs ( ) ; var x_array = x . array ; var r_array = r . array ; var i = r . t = 2 * x . t ; while ( -- i >= 0 ) r_array [ i ] = 0 ; for ( i = 0 ; i < x . t - 1 ; ++ i ) { var c = x . am ( i , x_array [ i ] , r , 2 * i , 0 , 1 ) ; if ( ( r_array [ i + x . t ] += x . am ( i + 1 , 2 * x_array [ i ] , r , 2 * i + 1 , c , x . t - i - 1 ) ) >= BI_DV ) { r_array [ i + x . t ] -= BI_DV ; r_array [ i + x . t + 1 ] = 1 ; } } if ( r . t > 0 ) r_array [ r . t - 1 ] += x . am ( i , x_array [ i ] , r , 2 * i , 0 , 1 ) ; r . s = 0 ; r . clamp ( ) ; } 
function bnpDivRemTo ( m , q , r ) { var pm = m . abs ( ) ; if ( pm . t <= 0 ) return ; var pt = this . abs ( ) ; if ( pt . t < pm . t ) { if ( q != null ) q . fromInt ( 0 ) ; if ( r != null ) this . copyTo ( r ) ; return ; } if ( r == null ) r = nbi ( ) ; var y = nbi ( ) , ts = this . s , ms = m . s ; var pm_array = pm . array ; var nsh = BI_DB - nbits ( pm_array [ pm . t - 1 ] ) ; 
function bnpInvDigit ( ) { var this_array = this . array ; if ( this . t < 1 ) return 0 ; var x = this_array [ 0 ] ; if ( ( x & 1 ) == 0 ) return 0 ; var y = x & 3 ; 
function montReduce ( x ) { var x_array = x . array ; while ( x . t <= this . mt2 ) 
function bnIntValue ( ) { var this_array = this . array ; if ( this . s < 0 ) { if ( this . t == 1 ) return this_array [ 0 ] - BI_DV ; else if ( this . t == 0 ) return - 1 ; } else if ( this . t == 1 ) return this_array [ 0 ] ; else if ( this . t == 0 ) return 0 ; 
function bnToByteArray ( ) { var this_array = this . array ; var i = this . t , r = new Array ( ) ; r [ 0 ] = this . s ; var p = BI_DB - ( i * BI_DB ) % 8 , d , k = 0 ; if ( i -- > 0 ) { if ( p < BI_DB && ( d = this_array [ i ] >> p ) != ( this . s & BI_DM ) >> p ) r [ k ++ ] = d | ( this . s << ( BI_DB - p ) ) ; while ( i >= 0 ) { if ( p < 8 ) { d = ( this_array [ i ] & ( ( 1 << p ) - 1 ) ) << ( 8 - p ) ; d |= this_array [ -- i ] >> ( p += BI_DB - 8 ) ; } else { d = ( this_array [ i ] >> ( p -= 8 ) ) & 0xff ; if ( p <= 0 ) { p += BI_DB ; -- i ; } } if ( ( d & 0x80 ) != 0 ) d |= - 256 ; if ( k == 0 && ( this . s & 0x80 ) != ( d & 0x80 ) ) ++ k ; if ( k > 0 || d != this . s ) r [ k ++ ] = d ; } } return r ; } 
function bnpBitwiseTo ( a , op , r ) { var this_array = this . array ; var a_array = a . array ; var r_array = r . array ; var i , f , m = Math . min ( a . t , this . t ) ; for ( i = 0 ; i < m ; ++ i ) r_array [ i ] = op ( this_array [ i ] , a_array [ i ] ) ; if ( a . t < this . t ) { f = a . s & BI_DM ; for ( i = m ; i < this . t ; ++ i ) r_array [ i ] = op ( this_array [ i ] , f ) ; r . t = this . t ; } else { f = this . s & BI_DM ; for ( i = m ; i < a . t ; ++ i ) r_array [ i ] = op ( f , a_array [ i ] ) ; r . t = a . t ; } r . s = op ( this . s , a . s ) ; r . clamp ( ) ; } 
function bnNot ( ) { var this_array = this . array ; var r = nbi ( ) ; var r_array = r . array ; for ( var i = 0 ; i < this . t ; ++ i ) r_array [ i ] = BI_DM & ~ this_array [ i ] ; r . t = this . t ; r . s = ~ this . s ; return r ; } 
function bnGetLowestSetBit ( ) { var this_array = this . array ; for ( var i = 0 ; i < this . t ; ++ i ) if ( this_array [ i ] != 0 ) return i * BI_DB + lbit ( this_array [ i ] ) ; if ( this . s < 0 ) return this . t * BI_DB ; return - 1 ; } 
function bnpDMultiply ( n ) { var this_array = this . array ; this_array [ this . t ] = this . am ( 0 , n - 1 , this , 0 , 0 , this . t ) ; ++ this . t ; this . clamp ( ) ; } 
function bnpDAddOffset ( n , w ) { var this_array = this . array ; while ( this . t <= w ) this_array [ this . t ++ ] = 0 ; this_array [ w ] += n ; while ( this_array [ w ] >= BI_DV ) { this_array [ w ] -= BI_DV ; if ( ++ w >= this . t ) this_array [ this . t ++ ] = 0 ; ++ this_array [ w ] ; } } 
function bnpModInt ( n ) { var this_array = this . array ; if ( n <= 0 ) return 0 ; var d = BI_DV % n , r = ( this . s < 0 ) ? n - 1 : 0 ; if ( this . t > 0 ) if ( d == 0 ) r = this_array [ 0 ] % n ; else for ( var i = this . t - 1 ; i >= 0 ; -- i ) r = ( d * r + this_array [ i ] ) % n ; return r ; } 
function pkcs1pad2 ( s , n ) { if ( n < s . length + 11 ) { alert ( "Message too long for RSA" ) ; return null ; } var ba = new Array ( ) ; var i = s . length - 1 ; while ( i >= 0 && n > 0 ) ba [ -- n ] = s . charCodeAt ( i -- ) ; ba [ -- n ] = 0 ; var rng = new SecureRandom ( ) ; var x = new Array ( ) ; while ( n > 2 ) { 
function RSASetPublic ( N , E ) { if ( N != null && E != null && N . length > 0 && E . length > 0 ) { this . n = parseBigInt ( N , 16 ) ; this . e = parseInt ( E , 16 ) ; } else alert ( "Invalid RSA public key" ) ; } 
function pkcs1unpad2 ( d , n ) { var b = d . toByteArray ( ) ; var i = 0 ; while ( i < b . length && b [ i ] == 0 ) ++ i ; if ( b . length - i != n - 1 || b [ i ] != 2 ) return null ; ++ i ; while ( b [ i ] != 0 ) if ( ++ i >= b . length ) return null ; var ret = "" ; while ( ++ i < b . length ) ret += String . fromCharCode ( b [ i ] ) ; return ret ; } 
function RSASetPrivate ( N , E , D ) { if ( N != null && E != null && N . length > 0 && E . length > 0 ) { this . n = parseBigInt ( N , 16 ) ; this . e = parseInt ( E , 16 ) ; this . d = parseBigInt ( D , 16 ) ; } else alert ( "Invalid RSA private key" ) ; } 
function AddBoundMethod ( obj , methodName , implementation , length , type ) { % CheckIsBootstrapping ( ) ; var internalName = % CreatePrivateSymbol ( methodName ) ; 
function supportedLocalesOf ( service , locales , options ) { if ( IS_NULL ( InternalRegExpMatch ( GetServiceRE ( ) , service ) ) ) { throw MakeError ( kWrongServiceType , service ) ; } 
function lookupSupportedLocalesOf ( requestedLocales , availableLocales ) { var matchedLocales = new InternalArray ( ) ; for ( var i = 0 ; i < requestedLocales . length ; ++ i ) { 
function getGetOption ( options , caller ) { if ( IS_UNDEFINED ( options ) ) throw MakeError ( kDefaultOptionsMissing , caller ) ; var getOption = function getOption ( property , type , values , defaultValue ) { if ( ! IS_UNDEFINED ( options [ property ] ) ) { var value = options [ property ] ; switch ( type ) { case 'boolean' : value = TO_BOOLEAN ( value ) ; break ; case 'string' : value = TO_STRING ( value ) ; break ; case 'number' : value = TO_NUMBER ( value ) ; break ; default : throw MakeError ( kWrongValueType ) ; } if ( ! IS_UNDEFINED ( values ) && % _Call ( ArrayIndexOf , values , value ) === - 1 ) { throw MakeRangeError ( kValueOutOfRange , value , caller , property ) ; } return value ; } return defaultValue ; } return getOption ; } 
function resolveLocale ( service , requestedLocales , options ) { requestedLocales = initializeLocaleList ( requestedLocales ) ; var getOption = getGetOption ( options , service ) ; var matcher = getOption ( 'localeMatcher' , 'string' , [ 'lookup' , 'best fit' ] , 'best fit' ) ; var resolved ; if ( matcher === 'lookup' ) { resolved = lookupMatcher ( service , requestedLocales ) ; } else { resolved = bestFitMatcher ( service , requestedLocales ) ; } return resolved ; } 
function lookupMatcher ( service , requestedLocales ) { if ( IS_NULL ( InternalRegExpMatch ( GetServiceRE ( ) , service ) ) ) { throw MakeError ( kWrongServiceType , service ) ; } 
function parseExtension ( extension ) { var extensionSplit = % _Call ( StringSplit , extension , '-' ) ; 
function setOptions ( inOptions , extensionMap , keyValues , getOption , outOptions ) { var extension = '' ; var updateExtension = function updateExtension ( key , value ) { return '-' + key + '-' + TO_STRING ( value ) ; } var updateProperty = function updateProperty ( property , type , value ) { if ( type === 'boolean' && ( typeof value === 'string' ) ) { value = ( value === 'true' ) ? true : false ; } if ( ! IS_UNDEFINED ( property ) ) { defineWEProperty ( outOptions , property , value ) ; } } for ( var key in keyValues ) { if ( HAS_OWN_PROPERTY ( keyValues , key ) ) { var value = UNDEFINED ; var map = keyValues [ key ] ; if ( ! IS_UNDEFINED ( map . property ) ) { 
function freezeArray ( input ) { var array = [ ] ; var l = input . length ; for ( var i = 0 ; i < l ; i ++ ) { if ( i in input ) { % object_define_property ( array , i , { value : input [ i ] , configurable : false , writable : false , enumerable : true } ) ; } } % object_define_property ( array , 'length' , { value : l , writable : false } ) ; return array ; } 
function getOptimalLanguageTag ( original , resolved ) { 
function getAvailableLocalesOf ( service ) { var available = % AvailableLocalesOf ( service ) ; for ( var i in available ) { if ( HAS_OWN_PROPERTY ( available , i ) ) { var parts = InternalRegExpMatch ( / ^([a-z]{2,3})-([A-Z][a-z]{3})-([A-Z]{2})$ / , i ) ; if ( ! IS_NULL ( parts ) ) { 
function defineWEProperty ( object , property , value ) { % object_define_property ( object , property , { value : value , writable : true , enumerable : true } ) ; } 
function addWEPropertyIfDefined ( object , property , value ) { if ( ! IS_UNDEFINED ( value ) ) { defineWEProperty ( object , property , value ) ; } } 
function defineWECProperty ( object , property , value ) { % object_define_property ( object , property , { value : value , writable : true , enumerable : true , configurable : true } ) ; } 
function addWECPropertyIfDefined ( object , property , value ) { if ( ! IS_UNDEFINED ( value ) ) { defineWECProperty ( object , property , value ) ; } } 
function toTitleCaseWord ( word ) { return % StringToUpperCase ( % _Call ( StringSubstr , word , 0 , 1 ) ) + % StringToLowerCase ( % _Call ( StringSubstr , word , 1 ) ) ; } 
function toTitleCaseTimezoneLocation ( location ) { var match = InternalRegExpMatch ( GetTimezoneNameLocationPartRE ( ) , location ) if ( IS_NULL ( match ) ) throw MakeRangeError ( kExpectedLocation , location ) ; var result = toTitleCaseWord ( match [ 1 ] ) ; if ( ! IS_UNDEFINED ( match [ 2 ] ) && 2 < match . length ) { 
function canonicalizeLanguageTag ( localeID ) { 
function initializeLocaleList ( locales ) { var seen = new InternalArray ( ) ; if ( ! IS_UNDEFINED ( locales ) ) { 
function isValidLanguageTag ( locale ) { 
function BuildLanguageTagREs ( ) { var alpha = '[a-zA-Z]' ; var digit = '[0-9]' ; var alphanum = '(' + alpha + '|' + digit + ')' ; var regular = '(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|' + 'zh-min|zh-min-nan|zh-xiang)' ; var irregular = '(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|' + 'i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|' + 'i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)' ; var grandfathered = '(' + irregular + '|' + regular + ')' ; var privateUse = '(x(-' + alphanum + '{1,8})+)' ; var singleton = '(' + digit + '|[A-WY-Za-wy-z])' ; LANGUAGE_SINGLETON_RE = new GlobalRegExp ( '^' + singleton + '$' , 'i' ) ; var extension = '(' + singleton + '(-' + alphanum + '{2,8})+)' ; var variant = '(' + alphanum + '{5,8}|(' + digit + alphanum + '{3}))' ; LANGUAGE_VARIANT_RE = new GlobalRegExp ( '^' + variant + '$' , 'i' ) ; var region = '(' + alpha + '{2}|' + digit + '{3})' ; var script = '(' + alpha + '{4})' ; var extLang = '(' + alpha + '{3}(-' + alpha + '{3}){0,2})' ; var language = '(' + alpha + '{2,3}(-' + extLang + ')?|' + alpha + '{4}|' + alpha + '{5,8})' ; var langTag = language + '(-' + script + ')?(-' + region + ')?(-' + variant + ')*(-' + extension + ')*(-' + privateUse + ')?' ; var languageTag = '^(' + langTag + '|' + privateUse + '|' + grandfathered + ')$' ; LANGUAGE_TAG_RE = new GlobalRegExp ( languageTag , 'i' ) ; } 
function initializeCollator ( collator , locales , options ) { if ( % IsInitializedIntlObject ( collator ) ) { throw MakeTypeError ( kReinitializeIntl , "Collator" ) ; } if ( IS_UNDEFINED ( options ) ) { options = { } ; } var getOption = getGetOption ( options , 'collator' ) ; var internalOptions = { } ; defineWEProperty ( internalOptions , 'usage' , getOption ( 'usage' , 'string' , [ 'sort' , 'search' ] , 'sort' ) ) ; var sensitivity = getOption ( 'sensitivity' , 'string' , [ 'base' , 'accent' , 'case' , 'variant' ] ) ; if ( IS_UNDEFINED ( sensitivity ) && internalOptions . usage === 'sort' ) { sensitivity = 'variant' ; } defineWEProperty ( internalOptions , 'sensitivity' , sensitivity ) ; defineWEProperty ( internalOptions , 'ignorePunctuation' , getOption ( 'ignorePunctuation' , 'boolean' , UNDEFINED , false ) ) ; var locale = resolveLocale ( 'collator' , locales , options ) ; * Map of Unicode extensions to option properties, and their values and types, * for a collator. */ var COLLATOR_KEY_MAP = { 'kn' : { 'property' : 'numeric' , 'type' : 'boolean' } , 'kf' : { 'property' : 'caseFirst' , 'type' : 'string' , 'values' : [ 'false' , 'lower' , 'upper' ] } } ; setOptions ( options , extensionMap , COLLATOR_KEY_MAP , getOption , internalOptions ) ; var collation = 'default' ; var extension = '' ; if ( HAS_OWN_PROPERTY ( extensionMap , 'co' ) && internalOptions . usage === 'sort' ) { var ALLOWED_CO_VALUES = [ 'big5han' , 'dict' , 'direct' , 'ducet' , 'gb2312' , 'phonebk' , 'phonetic' , 'pinyin' , 'reformed' , 'searchjl' , 'stroke' , 'trad' , 'unihan' , 'zhuyin' ] ; if ( % _Call ( ArrayIndexOf , ALLOWED_CO_VALUES , extensionMap . co ) !== - 1 ) { extension = '-u-co-' + extensionMap . co ; 
function compare ( collator , x , y ) { return % InternalCompare ( % GetImplFromInitializedIntlObject ( collator ) , TO_STRING ( x ) , TO_STRING ( y ) ) ; } 
function getNumberOption ( options , property , min , max , fallback ) { var value = options [ property ] ; if ( ! IS_UNDEFINED ( value ) ) { value = TO_NUMBER ( value ) ; if ( NUMBER_IS_NAN ( value ) || value < min || value > max ) { throw MakeRangeError ( kPropertyValueOutOfRange , property ) ; } return % math_floor ( value ) ; } return fallback ; } 
function initializeNumberFormat ( numberFormat , locales , options ) { if ( % IsInitializedIntlObject ( numberFormat ) ) { throw MakeTypeError ( kReinitializeIntl , "NumberFormat" ) ; } if ( IS_UNDEFINED ( options ) ) { options = { } ; } var getOption = getGetOption ( options , 'numberformat' ) ; var locale = resolveLocale ( 'numberformat' , locales , options ) ; var internalOptions = { } ; defineWEProperty ( internalOptions , 'style' , getOption ( 'style' , 'string' , [ 'decimal' , 'percent' , 'currency' ] , 'decimal' ) ) ; var currency = getOption ( 'currency' , 'string' ) ; if ( ! IS_UNDEFINED ( currency ) && ! isWellFormedCurrencyCode ( currency ) ) { throw MakeRangeError ( kInvalidCurrencyCode , currency ) ; } if ( internalOptions . style === 'currency' && IS_UNDEFINED ( currency ) ) { throw MakeTypeError ( kCurrencyCode ) ; } var currencyDisplay = getOption ( 'currencyDisplay' , 'string' , [ 'code' , 'symbol' , 'name' ] , 'symbol' ) ; if ( internalOptions . style === 'currency' ) { defineWEProperty ( internalOptions , 'currency' , % StringToUpperCase ( currency ) ) ; defineWEProperty ( internalOptions , 'currencyDisplay' , currencyDisplay ) ; } * Map of Unicode extensions to option properties, and their values and types, * for a number format. */ var NUMBER_FORMAT_KEY_MAP = { 'nu' : { 'property' : UNDEFINED , 'type' : 'string' } } ; var extension = setOptions ( options , extensionMap , NUMBER_FORMAT_KEY_MAP , getOption , internalOptions ) ; var requestedLocale = locale . locale + extension ; var resolved = % object_define_properties ( { } , { currency : { writable : true } , currencyDisplay : { writable : true } , locale : { writable : true } , maximumFractionDigits : { writable : true } , minimumFractionDigits : { writable : true } , minimumIntegerDigits : { writable : true } , numberingSystem : { writable : true } , requestedLocale : { value : requestedLocale , writable : true } , style : { value : internalOptions . style , writable : true } , useGrouping : { writable : true } } ) ; if ( HAS_OWN_PROPERTY ( internalOptions , 'minimumSignificantDigits' ) ) { defineWEProperty ( resolved , 'minimumSignificantDigits' , UNDEFINED ) ; } if ( HAS_OWN_PROPERTY ( internalOptions , 'maximumSignificantDigits' ) ) { defineWEProperty ( resolved , 'maximumSignificantDigits' , UNDEFINED ) ; } var formatter = % CreateNumberFormat ( requestedLocale , internalOptions , resolved ) ; if ( internalOptions . style === 'currency' ) { % object_define_property ( resolved , 'currencyDisplay' , { value : currencyDisplay , writable : true } ) ; } % MarkAsInitializedIntlObjectOfType ( numberFormat , 'numberformat' , formatter ) ; numberFormat [ resolvedSymbol ] = resolved ; if ( FLAG_intl_extra ) { % object_define_property ( resolved , 'pattern' , patternAccessor ) ; % object_define_property ( numberFormat , 'resolved' , resolvedAccessor ) ; } return numberFormat ; } 
function formatNumber ( formatter , value ) { 
function toLDMLString ( options ) { var getOption = getGetOption ( options , 'dateformat' ) ; var ldmlString = '' ; var option = getOption ( 'weekday' , 'string' , [ 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { narrow : 'EEEEE' , short : 'EEE' , long : 'EEEE' } ) ; option = getOption ( 'era' , 'string' , [ 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { narrow : 'GGGGG' , short : 'GGG' , long : 'GGGG' } ) ; option = getOption ( 'year' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'yy' , 'numeric' : 'y' } ) ; option = getOption ( 'month' , 'string' , [ '2-digit' , 'numeric' , 'narrow' , 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'MM' , 'numeric' : 'M' , 'narrow' : 'MMMMM' , 'short' : 'MMM' , 'long' : 'MMMM' } ) ; option = getOption ( 'day' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'dd' , 'numeric' : 'd' } ) ; var hr12 = getOption ( 'hour12' , 'boolean' ) ; option = getOption ( 'hour' , 'string' , [ '2-digit' , 'numeric' ] ) ; if ( IS_UNDEFINED ( hr12 ) ) { ldmlString += appendToLDMLString ( option , { '2-digit' : 'jj' , 'numeric' : 'j' } ) ; } else if ( hr12 === true ) { ldmlString += appendToLDMLString ( option , { '2-digit' : 'hh' , 'numeric' : 'h' } ) ; } else { ldmlString += appendToLDMLString ( option , { '2-digit' : 'HH' , 'numeric' : 'H' } ) ; } option = getOption ( 'minute' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'mm' , 'numeric' : 'm' } ) ; option = getOption ( 'second' , 'string' , [ '2-digit' , 'numeric' ] ) ; ldmlString += appendToLDMLString ( option , { '2-digit' : 'ss' , 'numeric' : 's' } ) ; option = getOption ( 'timeZoneName' , 'string' , [ 'short' , 'long' ] ) ; ldmlString += appendToLDMLString ( option , { short : 'z' , long : 'zzzz' } ) ; return ldmlString ; } 
function fromLDMLString ( ldmlString ) { 
function toDateTimeOptions ( options , required , defaults ) { if ( IS_UNDEFINED ( options ) ) { options = { } ; } else { options = TO_OBJECT ( options ) ; } var needsDefault = true ; if ( ( required === 'date' || required === 'any' ) && ( ! IS_UNDEFINED ( options . weekday ) || ! IS_UNDEFINED ( options . year ) || ! IS_UNDEFINED ( options . month ) || ! IS_UNDEFINED ( options . day ) ) ) { needsDefault = false ; } if ( ( required === 'time' || required === 'any' ) && ( ! IS_UNDEFINED ( options . hour ) || ! IS_UNDEFINED ( options . minute ) || ! IS_UNDEFINED ( options . second ) ) ) { needsDefault = false ; } if ( needsDefault && ( defaults === 'date' || defaults === 'all' ) ) { % object_define_property ( options , 'year' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; % object_define_property ( options , 'month' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; % object_define_property ( options , 'day' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; } if ( needsDefault && ( defaults === 'time' || defaults === 'all' ) ) { % object_define_property ( options , 'hour' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; % object_define_property ( options , 'minute' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; % object_define_property ( options , 'second' , { value : 'numeric' , writable : true , enumerable : true , configurable : true } ) ; } return options ; } 
function initializeDateTimeFormat ( dateFormat , locales , options ) { if ( % IsInitializedIntlObject ( dateFormat ) ) { throw MakeTypeError ( kReinitializeIntl , "DateTimeFormat" ) ; } if ( IS_UNDEFINED ( options ) ) { options = { } ; } var locale = resolveLocale ( 'dateformat' , locales , options ) ; options = toDateTimeOptions ( options , 'any' , 'date' ) ; var getOption = getGetOption ( options , 'dateformat' ) ; * Map of Unicode extensions to option properties, and their values and types, * for a date/time format. */ var DATETIME_FORMAT_KEY_MAP = { 'ca' : { 'property' : UNDEFINED , 'type' : 'string' } , 'nu' : { 'property' : UNDEFINED , 'type' : 'string' } } ; var extension = setOptions ( options , extensionMap , DATETIME_FORMAT_KEY_MAP , getOption , internalOptions ) ; var requestedLocale = locale . locale + extension ; var resolved = % object_define_properties ( { } , { calendar : { writable : true } , day : { writable : true } , era : { writable : true } , hour12 : { writable : true } , hour : { writable : true } , locale : { writable : true } , minute : { writable : true } , month : { writable : true } , numberingSystem : { writable : true } , [ patternSymbol ] : { writable : true } , requestedLocale : { value : requestedLocale , writable : true } , second : { writable : true } , timeZone : { writable : true } , timeZoneName : { writable : true } , tz : { value : tz , writable : true } , weekday : { writable : true } , year : { writable : true } } ) ; var formatter = % CreateDateTimeFormat ( requestedLocale , { skeleton : ldmlString , timeZone : tz } , resolved ) ; if ( resolved . timeZone === "Etc/Unknown" ) { throw MakeRangeError ( kUnsupportedTimeZone , tz ) ; } % MarkAsInitializedIntlObjectOfType ( dateFormat , 'dateformat' , formatter ) ; dateFormat [ resolvedSymbol ] = resolved ; if ( FLAG_intl_extra ) { % object_define_property ( resolved , 'pattern' , patternAccessor ) ; % object_define_property ( dateFormat , 'resolved' , resolvedAccessor ) ; } return dateFormat ; } 
function formatDate ( formatter , dateValue ) { var dateMs ; if ( IS_UNDEFINED ( dateValue ) ) { dateMs = % DateCurrentTime ( ) ; } else { dateMs = TO_NUMBER ( dateValue ) ; } if ( ! NUMBER_IS_FINITE ( dateMs ) ) throw MakeRangeError ( kDateRange ) ; return % InternalDateFormat ( % GetImplFromInitializedIntlObject ( formatter ) , new GlobalDate ( dateMs ) ) ; } 
function canonicalizeTimeZoneID ( tzID ) { 
function initializeBreakIterator ( iterator , locales , options ) { if ( % IsInitializedIntlObject ( iterator ) ) { throw MakeTypeError ( kReinitializeIntl , "v8BreakIterator" ) ; } if ( IS_UNDEFINED ( options ) ) { options = { } ; } var getOption = getGetOption ( options , 'breakiterator' ) ; var internalOptions = { } ; defineWEProperty ( internalOptions , 'type' , getOption ( 'type' , 'string' , [ 'character' , 'word' , 'sentence' , 'line' ] , 'word' ) ) ; var locale = resolveLocale ( 'breakiterator' , locales , options ) ; var resolved = % object_define_properties ( { } , { requestedLocale : { value : locale . locale , writable : true } , type : { value : internalOptions . type , writable : true } , locale : { writable : true } } ) ; var internalIterator = % CreateBreakIterator ( locale . locale , internalOptions , resolved ) ; % MarkAsInitializedIntlObjectOfType ( iterator , 'breakiterator' , internalIterator ) ; iterator [ resolvedSymbol ] = resolved ; if ( FLAG_intl_extra ) { % object_define_property ( iterator , 'resolved' , resolvedAccessor ) ; } return iterator ; } 
function cachedOrNewService ( service , locales , options , defaults ) { var useOptions = ( IS_UNDEFINED ( defaults ) ) ? options : defaults ; if ( IS_UNDEFINED ( locales ) && IS_UNDEFINED ( options ) ) { checkDateCacheCurrent ( ) ; if ( IS_UNDEFINED ( defaultObjects [ service ] ) ) { defaultObjects [ service ] = new savedObjects [ service ] ( locales , useOptions ) ; } return defaultObjects [ service ] ; } return new savedObjects [ service ] ( locales , useOptions ) ; } 
function toLocaleDateTime ( date , locales , options , required , defaults , service ) { if ( ! ( date instanceof GlobalDate ) ) { throw MakeTypeError ( kMethodInvokedOnWrongType , "Date" ) ; } if ( IsNaN ( date ) ) return 'Invalid Date' ; var internalOptions = toDateTimeOptions ( options , required , defaults ) ; var dateFormat = cachedOrNewService ( service , locales , options , internalOptions ) ; return formatDate ( dateFormat , date ) ; } 
function ( options ) { this . options = Object . extend ( { canvasHeight : 100 , canvasWidth : 100 , pixelWidth : 2 , pixelHeight : 2 , renderDiffuse : false , renderShadows : false , renderHighlights : false , renderReflections : false , rayDepth : 2 } , options || { } ) ; this . options . canvasHeight /= this . options . pixelHeight ; this . options . canvasWidth /= this . options . pixelWidth ; } 
function toAbsolutePath ( path ) { if ( typeof path !== 'string' ) { return null ; } const parts = path . split ( '/' ) ; const n = normalizePath ( parts ) ; if ( ! n ) { return null ; } return ` ${ n . join ( '/' ) } ` ; } 
function locateAcpiDevice ( dev ) { if ( ! dev . isDevice ( ) ) { return null ; } const addr = dev . address ( ) ; const slotId = ( ( addr >>> 16 ) & 0xffff ) >>> 0 ; const funcId = ( addr & 0xffff ) >>> 0 ; let busId = 0 ; if ( dev . isRootBridge ( ) ) { busId = dev . getRootBridgeBusNumber ( ) ; return { bus : busId , slot : slotId , func : funcId , } ; } const parentDev = dev . parent ( ) ; if ( parentDev === null ) { return null ; } if ( ! parentDev . isDevice ( ) ) { return null ; } if ( parentDev . isRootBridge ( ) ) { busId = parentDev . getRootBridgeBusNumber ( ) ; return { bus : busId , slot : slotId , func : funcId , } ; } const parentLocation = locateAcpiDevice ( parentDev ) ; if ( parentLocation === null ) { return null ; } const pciParent = pciAccessorFactory . get ( { bus : parentLocation . bus , slot : parentLocation . slot , func : parentLocation . func , } ) ; const header = pciParent . read ( pciParent . fields ( ) . HEADER_TYPE ) ; 
function toIntArray ( str ) { var w1 , w2 , u , r4 = [ ] , r = [ ] , i = 0 ; var s = str + '\0\0\0' ; 
function add ( x , y ) { var lsb = ( x & 0xffff ) + ( y & 0xffff ) ; var msb = ( x >>> 16 ) + ( y >>> 16 ) + ( lsb >>> 16 ) ; return ( msb << 16 ) | ( lsb & 0xffff ) ; } 
function seed_mix ( ) { a ^= b << 11 ; d = add ( d , a ) ; b = add ( b , c ) ; b ^= c >>> 2 ; e = add ( e , b ) ; c = add ( c , d ) ; c ^= d << 8 ; f = add ( f , c ) ; d = add ( d , e ) ; d ^= e >>> 16 ; g = add ( g , d ) ; e = add ( e , f ) ; e ^= f << 10 ; h = add ( h , e ) ; f = add ( f , g ) ; f ^= g >>> 4 ; a = add ( a , f ) ; g = add ( g , h ) ; g ^= h << 8 ; b = add ( b , g ) ; h = add ( h , a ) ; h ^= a >>> 9 ; c = add ( c , h ) ; a = add ( a , b ) ; } 
function UnaryConstraint ( v , strength ) { UnaryConstraint . superConstructor . call ( this , strength ) ; this . myOutput = v ; this . satisfied = false ; this . addConstraint ( ) ; } 
function BinaryConstraint ( var1 , var2 , strength ) { BinaryConstraint . superConstructor . call ( this , strength ) ; this . v1 = var1 ; this . v2 = var2 ; this . direction = Direction . NONE ; this . addConstraint ( ) ; } 
function ScaleConstraint ( src , scale , offset , dest , strength ) { this . direction = Direction . NONE ; this . scale = scale ; this . offset = offset ; ScaleConstraint . superConstructor . call ( this , src , dest , strength ) ; } 
function EqualityConstraint ( var1 , var2 , strength ) { EqualityConstraint . superConstructor . call ( this , var1 , var2 , strength ) ; } 
function Variable ( name , initialValue ) { this . value = initialValue || 0 ; this . constraints = new OrderedCollection ( ) ; this . determinedBy = null ; this . mark = 0 ; this . walkStrength = Strength . WEAKEST ; this . stay = true ; this . name = name ; } 
function WeakMapConstructor ( iterable ) { if ( IS_UNDEFINED ( new . target ) ) { throw MakeTypeError ( kConstructorNotFunction , "WeakMap" ) ; } % WeakCollectionInitialize ( this ) ; if ( ! IS_NULL_OR_UNDEFINED ( iterable ) ) { var adder = this . set ; if ( ! IS_CALLABLE ( adder ) ) { throw MakeTypeError ( kPropertyNotFunction , adder , 'set' , this ) ; } for ( var nextItem of iterable ) { if ( ! IS_RECEIVER ( nextItem ) ) { throw MakeTypeError ( kIteratorValueNotAnObject , nextItem ) ; } % _Call ( adder , this , nextItem [ 0 ] , nextItem [ 1 ] ) ; } } } 
function WeakSetConstructor ( iterable ) { if ( IS_UNDEFINED ( new . target ) ) { throw MakeTypeError ( kConstructorNotFunction , "WeakSet" ) ; } % WeakCollectionInitialize ( this ) ; if ( ! IS_NULL_OR_UNDEFINED ( iterable ) ) { var adder = this . add ; if ( ! IS_CALLABLE ( adder ) ) { throw MakeTypeError ( kPropertyNotFunction , adder , 'add' , this ) ; } for ( var value of iterable ) { % _Call ( adder , this , value ) ; } } } 
function sc_alert ( ) { var len = arguments . length ; var s = "" ; var i ; for ( i = 0 ; i < len ; i ++ ) { s += sc_toDisplayString ( arguments [ i ] ) ; } return alert ( s ) ; } 
function sc_error ( ) { var a = [ sc_jsstring2symbol ( "*error*" ) ] ; for ( var i = 0 ; i < arguments . length ; i ++ ) { a [ i + 1 ] = arguments [ i ] ; } throw a ; } 
function sc_withHandlerLambda ( handler , body ) { try { return body ( ) ; } catch ( e ) { if ( ! e . _internalException ) return handler ( e ) ; else throw e ; } } 
function sc_putpropBang ( sym , key , val ) { var ht = sc_properties [ sym ] ; if ( ! ht ) { ht = new Object ( ) ; sc_properties [ sym ] = ht ; } ht [ key ] = val ; } 
function sc_getprop ( sym , key ) { var ht = sc_properties [ sym ] ; if ( ht ) { if ( key in ht ) return ht [ key ] ; else return false ; } else return false ; } 
function sc_equal ( x ) { for ( var i = 1 ; i < arguments . length ; i ++ ) if ( x !== arguments [ i ] ) return false ; return true ; } 
function sc_less ( x ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { if ( x >= arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc_greater ( x , y ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { if ( x <= arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc_lessEqual ( x , y ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { if ( x > arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc_greaterEqual ( x , y ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { if ( x < arguments [ i ] ) return false ; x = arguments [ i ] ; } return true ; } 
function sc_plus ( ) { var sum = 0 ; for ( var i = 0 ; i < arguments . length ; i ++ ) sum += arguments [ i ] ; return sum ; } 
function sc_multi ( ) { var product = 1 ; for ( var i = 0 ; i < arguments . length ; i ++ ) product *= arguments [ i ] ; return product ; } 
function sc_minus ( x ) { if ( arguments . length === 1 ) return - x ; else { var res = x ; for ( var i = 1 ; i < arguments . length ; i ++ ) res -= arguments [ i ] ; return res ; } } 
function sc_div ( x ) { if ( arguments . length === 1 ) return 1 / x ; else { var res = x ; for ( var i = 1 ; i < arguments . length ; i ++ ) res /= arguments [ i ] ; return res ; } } 
function sc_modulo ( x , y ) { var remainder = x % y ; 
function sc_gcd ( ) { var gcd = 0 ; for ( var i = 0 ; i < arguments . length ; i ++ ) gcd = sc_euclid_gcd ( gcd , arguments [ i ] ) ; return gcd ; } 
function sc_lcm ( ) { var lcm = 1 ; for ( var i = 0 ; i < arguments . length ; i ++ ) { var f = Math . round ( arguments [ i ] / sc_euclid_gcd ( arguments [ i ] , lcm ) ) ; lcm *= Math . abs ( f ) ; } return lcm ; } 
function sc_consStar ( ) { var res = arguments [ arguments . length - 1 ] ; for ( var i = arguments . length - 2 ; i >= 0 ; i -- ) res = new sc_Pair ( arguments [ i ] , res ) ; return res ; } 
function sc_lastPair ( l ) { if ( ! sc_isPair ( l ) ) sc_error ( "sc_lastPair: pair expected" ) ; var res = l ; var cdr = l . cdr ; while ( sc_isPair ( cdr ) ) { res = cdr ; cdr = res . cdr ; } return res ; } 
function sc_isList ( o ) { var rabbit ; var turtle ; var rabbit = o ; var turtle = o ; while ( true ) { if ( rabbit === null || ( rabbit instanceof sc_Pair && rabbit . cdr === null ) ) return true ; 
function sc_list ( ) { var res = null ; var a = arguments ; for ( var i = a . length - 1 ; i >= 0 ; i -- ) res = new sc_Pair ( a [ i ] , res ) ; return res ; } 
function sc_iota ( num , init ) { var res = null ; if ( ! init ) init = 0 ; for ( var i = num - 1 ; i >= 0 ; i -- ) res = new sc_Pair ( i + init , res ) ; return res ; } 
function sc_makeList ( nbEls , fill ) { var res = null ; for ( var i = 0 ; i < nbEls ; i ++ ) res = new sc_Pair ( fill , res ) ; return res ; } 
function sc_length ( l ) { var res = 0 ; while ( l !== null ) { res ++ ; l = l . cdr ; } return res ; } 
function sc_remq ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l !== null ) { if ( l . car !== o ) { tail . cdr = sc_cons ( l . car , null ) ; tail = tail . cdr ; } l = l . cdr ; } return dummy . cdr ; } 
function sc_remqBang ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; var needsAssig = true ; while ( l !== null ) { if ( l . car === o ) { needsAssig = true ; } else { if ( needsAssig ) { tail . cdr = l ; needsAssig = false ; } tail = l ; } l = l . cdr ; } tail . cdr = null ; return dummy . cdr ; } 
function sc_delete ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l !== null ) { if ( ! sc_isEqual ( l . car , o ) ) { tail . cdr = sc_cons ( l . car , null ) ; tail = tail . cdr ; } l = l . cdr ; } return dummy . cdr ; } 
function sc_deleteBang ( o , l ) { var dummy = { cdr : null } ; var tail = dummy ; var needsAssig = true ; while ( l !== null ) { if ( sc_isEqual ( l . car , o ) ) { needsAssig = true ; } else { if ( needsAssig ) { tail . cdr = l ; needsAssig = false ; } tail = l ; } l = l . cdr ; } tail . cdr = null ; return dummy . cdr ; } 
function sc_append ( ) { if ( arguments . length === 0 ) return null ; var res = arguments [ arguments . length - 1 ] ; for ( var i = arguments . length - 2 ; i >= 0 ; i -- ) res = sc_dualAppend ( arguments [ i ] , res ) ; return res ; } 
function sc_appendBang ( ) { var res = null ; for ( var i = 0 ; i < arguments . length ; i ++ ) res = sc_dualAppendBang ( res , arguments [ i ] ) ; return res ; } 
function sc_reverse ( l1 ) { var res = null ; while ( l1 !== null ) { res = sc_cons ( l1 . car , res ) ; l1 = l1 . cdr ; } return res ; } 
function sc_listTail ( l , k ) { var res = l ; for ( var i = 0 ; i < k ; i ++ ) { res = res . cdr ; } return res ; } 
function sc_memq ( o , l ) { while ( l !== null ) { if ( l . car === o ) return l ; l = l . cdr ; } return false ; } 
function sc_memv ( o , l ) { while ( l !== null ) { if ( l . car === o ) return l ; l = l . cdr ; } return false ; } 
function sc_member ( o , l ) { while ( l !== null ) { if ( sc_isEqual ( l . car , o ) ) return l ; l = l . cdr ; } return false ; } 
function sc_assq ( o , al ) { while ( al !== null ) { if ( al . car . car === o ) return al . car ; al = al . cdr ; } return false ; } 
function sc_assv ( o , al ) { while ( al !== null ) { if ( al . car . car === o ) return al . car ; al = al . cdr ; } return false ; } 
function sc_assoc ( o , al ) { while ( al !== null ) { if ( sc_isEqual ( al . car . car , o ) ) return al . car ; al = al . cdr ; } return false ; } 
function sc_isCharAlphabetic ( c ) { return sc_isCharOfClass ( c . val , SC_LOWER_CLASS ) || sc_isCharOfClass ( c . val , SC_UPPER_CLASS ) ; } 
function sc_isCharWhitespace ( c ) { var tmp = c . val ; return tmp === " " || tmp === "\r" || tmp === "\n" || tmp === "\t" || tmp === "\f" ; } 
function sc_isVectorEqual ( v1 , v2 , comp ) { if ( v1 . length !== v2 . length ) return false ; for ( var i = 0 ; i < v1 . length ; i ++ ) if ( ! comp ( v1 [ i ] , v2 [ i ] ) ) return false ; return true ; } 
function sc_makeVector ( size , fill ) { var a = new sc_Vector ( size ) ; if ( fill !== undefined ) sc_vectorFillBang ( a , fill ) ; return a ; } 
function sc_vector ( ) { var a = new sc_Vector ( ) ; for ( var i = 0 ; i < arguments . length ; i ++ ) a . push ( arguments [ i ] ) ; return a ; } 
function sc_vector2list ( a ) { var res = null ; for ( var i = a . length - 1 ; i >= 0 ; i -- ) res = sc_cons ( a [ i ] , res ) ; return res ; } 
function sc_list2vector ( l ) { var a = new sc_Vector ( ) ; while ( l !== null ) { a . push ( l . car ) ; l = l . cdr ; } return a ; } 
function sc_vectorFillBang ( a , fill ) { for ( var i = 0 ; i < a . length ; i ++ ) a [ i ] = fill ; } 
function sc_copyVector ( a , len ) { if ( len <= a . length ) return a . slice ( 0 , len ) ; else { var tmp = a . concat ( ) ; tmp . length = len ; return tmp ; } } 
function sc_vectorCopyBang ( target , tstart , source , sstart , send ) { if ( ! sstart ) sstart = 0 ; if ( ! send ) send = source . length ; 
function sc_apply ( proc ) { var args = new Array ( ) ; 
function sc_map ( proc , l1 ) { if ( l1 === undefined ) return null ; 
function sc_mapBang ( proc , l1 ) { if ( l1 === undefined ) return null ; 
function sc_forEach ( proc , l1 ) { if ( l1 === undefined ) return undefined ; 
function sc_filter ( proc , l1 ) { var dummy = { cdr : null } ; var tail = dummy ; while ( l1 !== null ) { if ( proc ( l1 . car ) !== false ) { tail . cdr = sc_cons ( l1 . car , null ) ; tail = tail . cdr ; } l1 = l1 . cdr ; } return dummy . cdr ; } 
function sc_filterBang ( proc , l1 ) { var head = sc_cons ( "dummy" , l1 ) ; var it = head ; var next = l1 ; while ( next !== null ) { if ( proc ( next . car ) !== false ) { it . cdr = next it = next ; } next = next . cdr ; } it . cdr = null ; return head . cdr ; } 
function sc_filterMap ( proc , l1 , l2 , l3 ) { if ( l2 === undefined ) return sc_filterMap1 ( proc , l1 ) ; else if ( l3 === undefined ) return sc_filterMap2 ( proc , l1 , l2 ) ; 
function sc_any ( proc , l ) { var revres = null ; while ( l !== null ) { var tmp = proc ( l . car ) ; if ( tmp !== false ) return tmp ; l = l . cdr ; } return false ; } 
function sc_every ( proc , l ) { var revres = null ; var tmp = true ; while ( l !== null ) { tmp = proc ( l . car ) ; if ( tmp === false ) return false ; l = l . cdr ; } return tmp ; } 
function sc_everyPred ( proc , l ) { var tmp = sc_every ( proc , l ) ; if ( tmp !== false ) return true ; return false ; } 
function sc_makePromise ( proc ) { var isResultReady = false ; var result = undefined ; return function ( ) { if ( ! isResultReady ) { var tmp = proc ( ) ; if ( ! isResultReady ) { isResultReady = true ; result = tmp ; } } return result ; } ; } 
function sc_callWithValues ( producer , consumer ) { var produced = producer ( ) ; if ( produced instanceof sc_Values ) return consumer . apply ( null , produced . values ) ; else return consumer ( produced ) ; } 
function sc_jsCall ( o , fun ) { var args = new Array ( ) ; for ( var i = 2 ; i < arguments . length ; i ++ ) args [ i - 2 ] = arguments [ i ] ; return fun . apply ( o , args ) ; } 
function sc_jsMethodCall ( o , field ) { var args = new Array ( ) ; for ( var i = 2 ; i < arguments . length ; i ++ ) args [ i - 2 ] = arguments [ i ] ; return o [ field ] . apply ( o , args ) ; } 
function sc_jsNew ( c ) { var evalStr = "new c(" ; evalStr += arguments . length > 1 ? "arguments[1]" : "" ; for ( var i = 2 ; i < arguments . length ; i ++ ) evalStr += ", arguments[" + i + "]" ; evalStr += ")" ; return eval ( evalStr ) ; } 
function sc_pregexpMatch ( re , s ) { var reg = ( re instanceof RegExp ) ? re : sc_pregexp ( re ) ; var tmp = reg . exec ( sc_string2jsstring ( s ) ) ; if ( tmp == null ) return false ; var res = null ; for ( var i = tmp . length - 1 ; i >= 0 ; i -- ) { if ( tmp [ i ] !== null ) { res = sc_cons ( sc_jsstring2string ( tmp [ i ] ) , res ) ; } else { res = sc_cons ( false , res ) ; } } return res ; } 
function sc_pregexpReplace ( re , s1 , s2 ) { var reg ; var jss1 = sc_string2jsstring ( s1 ) ; var jss2 = sc_string2jsstring ( s2 ) ; if ( re instanceof RegExp ) { if ( re . global ) reg = re ; else reg = new RegExp ( re . source ) ; } else { reg = new RegExp ( sc_string2jsstring ( re ) ) ; } return jss1 . replace ( reg , jss2 ) ; } 
function sc_pregexpSplit ( re , s ) { var reg = ( ( re instanceof RegExp ) ? re : new RegExp ( sc_string2jsstring ( re ) ) ) ; var jss = sc_string2jsstring ( s ) ; var tmp = jss . split ( reg ) ; if ( tmp == null ) return false ; return sc_vector2list ( tmp ) ; } 
function sc_hashtablePutBang ( ht , key , val ) { var hash = sc_hash ( key ) ; ht [ hash ] = new sc_HashtableElement ( key , val ) ; } 
function sc_hashtableGet ( ht , key ) { var hash = sc_hash ( key ) ; if ( hash in ht ) return ht [ hash ] . val ; else return false ; } 
function sc_hashtableForEach ( ht , f ) { for ( var v in ht ) { if ( ht [ v ] instanceof sc_HashtableElement ) f ( ht [ v ] . key , ht [ v ] . val ) ; } } 
function sc_hashtableContains ( ht , key ) { var hash = sc_hash ( key ) ; if ( hash in ht ) return true ; else return false ; } 
function sc_bindExitLambda ( proc ) { var escape_obj = new sc_BindExitException ( ) ; var escape = function ( res ) { escape_obj . res = res ; throw escape_obj ; } ; try { return proc ( escape ) ; } catch ( e ) { if ( e === escape_obj ) { return e . res ; } throw e ; } } 
function sc_Token ( type , val , pos ) { this . type = type ; this . val = val ; this . pos = pos ; } 
function sc_read ( port ) { if ( port === undefined ) 
function sc_readChar ( port ) { if ( port === undefined ) 
function sc_peekChar ( port ) { if ( port === undefined ) 
function sc_basename ( p ) { var i = p . lastIndexOf ( '/' ) ; if ( i >= 0 ) return p . substring ( i + 1 , p . length ) ; else return '' ; } 
function sc_withInputFromPort ( p , thunk ) { try { var tmp = SC_DEFAULT_IN ; 
function sc_withOutputToPort ( p , thunk ) { try { var tmp = SC_DEFAULT_OUT ; 
function sc_withOutputToProcedure ( proc , thunk ) { var t = function ( s ) { proc ( sc_jsstring2string ( s ) ) ; } ; return sc_withOutputToPort ( new sc_GenericOutputPort ( t ) , thunk ) ; } 
function sc_write ( o , p ) { if ( p === undefined ) 
function sc_display ( o , p ) { if ( p === undefined ) 
function sc_writeChar ( c , p ) { if ( p === undefined ) 
function sc_writeCircle ( o , p ) { if ( p === undefined ) 
function sc_print ( s ) { if ( arguments . length === 1 ) { sc_display ( s ) ; sc_newline ( ) ; } else { for ( var i = 0 ; i < arguments . length ; i ++ ) sc_display ( arguments [ i ] ) ; sc_newline ( ) ; } } 
function sc_format ( s , args ) { var len = s . length ; var p = new sc_StringOutputPort ( ) ; var i = 0 , j = 1 ; while ( i < len ) { var i2 = s . indexOf ( "~" , i ) ; if ( i2 == - 1 ) { p . appendJSString ( s . substring ( i , len ) ) ; return p . close ( ) ; } else { if ( i2 > i ) { if ( i2 == ( len - 1 ) ) { p . appendJSString ( s . substring ( i , len ) ) ; return p . close ( ) ; } else { p . appendJSString ( s . substring ( i , i2 ) ) ; i = i2 ; } } switch ( s . charCodeAt ( i2 + 1 ) ) { case 65 : case 97 : 
function sc_isEqual ( o1 , o2 ) { return ( ( o1 === o2 ) || ( sc_isPair ( o1 ) && sc_isPair ( o2 ) && sc_isPairEqual ( o1 , o2 , sc_isEqual ) ) || ( sc_isVector ( o1 ) && sc_isVector ( o2 ) && sc_isVectorEqual ( o1 , o2 , sc_isEqual ) ) ) ; } 
function sc_symbolAppend ( ) { var res = sc_SYMBOL_PREFIX ; for ( var i = 0 ; i < arguments . length ; i ++ ) res += arguments [ i ] . slice ( 1 ) ; return res ; } 
function sc_string ( ) { for ( var i = 0 ; i < arguments . length ; i ++ ) arguments [ i ] = arguments [ i ] . val ; return "" . concat . apply ( "" , arguments ) ; } 
function sc_isSubstring_at ( s1 , s2 , i ) { return s2 == s1 . substring ( i , i + s2 . length ) ; } 
function ArraySpeciesCreate ( array , length ) { length = INVERT_NEG_ZERO ( length ) ; var constructor = % ArraySpeciesConstructor ( array ) ; return new constructor ( length ) ; } 
function SparseJoin ( array , keys , convert ) { var keys_length = keys . length ; var elements = new InternalArray ( keys_length ) ; for ( var i = 0 ; i < keys_length ; i ++ ) { var e = array [ keys [ i ] ] ; elements [ i ] = IS_STRING ( e ) ? e : convert ( e ) ; } return % StringBuilderConcat ( elements , keys_length , '' ) ; } 
function SparseSlice ( array , start_i , del_count , len , deleted_elements ) { 
function SparseMove ( array , start_i , del_count , len , num_additional_args ) { 
function SimpleSlice ( array , start_i , del_count , len , deleted_elements ) { for ( var i = 0 ; i < del_count ; i ++ ) { var index = start_i + i ; if ( index in array ) { var current = array [ index ] ; % CreateDataProperty ( deleted_elements , i , current ) ; } } } 
function ArrayToString ( ) { var array ; var func ; if ( IS_ARRAY ( this ) ) { func = this . join ; if ( func === ArrayJoin ) { return Join ( this , this . length , ',' , ConvertToString ) ; } array = this ; } else { array = TO_OBJECT ( this ) ; func = array . join ; } if ( ! IS_CALLABLE ( func ) ) { return % _Call ( ObjectToString , array ) ; } return % _Call ( func , array ) ; } 
function ArrayPop ( ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.pop" ) ; var array = TO_OBJECT ( this ) ; var n = TO_LENGTH ( array . length ) ; if ( n == 0 ) { array . length = n ; return ; } n -- ; var value = array [ n ] ; % DeleteProperty_Strict ( array , n ) ; array . length = n ; return value ; } 
function ArrayPush ( ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.push" ) ; var array = TO_OBJECT ( this ) ; var n = TO_LENGTH ( array . length ) ; var m = arguments . length ; 
function SparseReverse ( array , len ) { var keys = GetSortedArrayKeys ( array , % GetArrayKeys ( array , len ) ) ; var high_counter = keys . length - 1 ; var low_counter = 0 ; while ( low_counter <= high_counter ) { var i = keys [ low_counter ] ; var j = keys [ high_counter ] ; var j_complement = len - j - 1 ; var low , high ; if ( j_complement <= i ) { high = j ; while ( keys [ -- high_counter ] == j ) { } low = j_complement ; } if ( j_complement >= i ) { low = i ; while ( keys [ ++ low_counter ] == i ) { } high = len - i - 1 ; } var current_i = array [ low ] ; if ( ! IS_UNDEFINED ( current_i ) || low in array ) { var current_j = array [ high ] ; if ( ! IS_UNDEFINED ( current_j ) || high in array ) { array [ low ] = current_j ; array [ high ] = current_i ; } else { array [ high ] = current_i ; delete array [ low ] ; } } else { var current_j = array [ high ] ; if ( ! IS_UNDEFINED ( current_j ) || high in array ) { array [ low ] = current_j ; delete array [ high ] ; } } } } 
function CopyFromPrototype ( obj , length ) { var max = 0 ; for ( var proto = % object_get_prototype_of ( obj ) ; proto ; proto = % object_get_prototype_of ( proto ) ) { var indices = IS_PROXY ( proto ) ? length : % GetArrayKeys ( proto , length ) ; if ( IS_NUMBER ( indices ) ) { 
function ( obj , from , to ) { for ( var proto = % object_get_prototype_of ( obj ) ; proto ; proto = % object_get_prototype_of ( proto ) ) { var indices = IS_PROXY ( proto ) ? to : % GetArrayKeys ( proto , to ) ; if ( IS_NUMBER ( indices ) ) { 
function InnerArrayFilter ( f , receiver , array , length , result ) { var result_length = 0 ; for ( var i = 0 ; i < length ; i ++ ) { if ( i in array ) { var element = array [ i ] ; if ( % _Call ( f , receiver , element , i , array ) ) { % CreateDataProperty ( result , result_length , element ) ; result_length ++ ; } } } return result ; } 
function ArraySome ( f , receiver ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.some" ) ; 
function InnerArrayIndexOf ( array , element , index , length ) { if ( length == 0 ) return - 1 ; if ( IS_UNDEFINED ( index ) ) { index = 0 ; } else { index = INVERT_NEG_ZERO ( TO_INTEGER ( index ) ) ; 
function ArrayCopyWithin ( target , start , end ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.copyWithin" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArrayCopyWithin ( target , start , end , array , length ) ; } 
function ArrayFind ( predicate , thisArg ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.find" ) ; var array = TO_OBJECT ( this ) ; var length = TO_INTEGER ( array . length ) ; return InnerArrayFind ( predicate , thisArg , array , length ) ; } 
function ArrayFindIndex ( predicate , thisArg ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.findIndex" ) ; var array = TO_OBJECT ( this ) ; var length = TO_INTEGER ( array . length ) ; return InnerArrayFindIndex ( predicate , thisArg , array , length ) ; } 
function InnerArrayFill ( value , start , end , array , length ) { var i = IS_UNDEFINED ( start ) ? 0 : TO_INTEGER ( start ) ; var end = IS_UNDEFINED ( end ) ? length : TO_INTEGER ( end ) ; if ( i < 0 ) { i += length ; if ( i < 0 ) i = 0 ; } else { if ( i > length ) i = length ; } if ( end < 0 ) { end += length ; if ( end < 0 ) end = 0 ; } else { if ( end > length ) end = length ; } if ( ( end - i ) > 0 && % object_is_frozen ( array ) ) { throw MakeTypeError ( kArrayFunctionsOnFrozen ) ; } for ( ; i < end ; i ++ ) array [ i ] = value ; return array ; } 
function ArrayFill ( value , start , end ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.fill" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArrayFill ( value , start , end , array , length ) ; } 
function ArrayIncludes ( searchElement , fromIndex ) { CHECK_OBJECT_COERCIBLE ( this , "Array.prototype.includes" ) ; var array = TO_OBJECT ( this ) ; var length = TO_LENGTH ( array . length ) ; return InnerArrayIncludes ( searchElement , fromIndex , array , length ) ; } 
function ArrayFrom ( arrayLike , mapfn , receiver ) { var items = TO_OBJECT ( arrayLike ) ; var mapping = ! IS_UNDEFINED ( mapfn ) ; if ( mapping ) { if ( ! IS_CALLABLE ( mapfn ) ) { throw MakeTypeError ( kCalledNonCallable , mapfn ) ; } } var iterable = GetMethod ( items , iteratorSymbol ) ; var k ; var result ; var mappedValue ; var nextValue ; if ( ! IS_UNDEFINED ( iterable ) ) { result = % IsConstructor ( this ) ? new this ( ) : [ ] ; k = 0 ; for ( nextValue of { [ iteratorSymbol ] ( ) { return GetIterator ( items , iterable ) } } ) { if ( mapping ) { mappedValue = % _Call ( mapfn , receiver , nextValue , k ) ; } else { mappedValue = nextValue ; } % CreateDataProperty ( result , k , mappedValue ) ; k ++ ; } result . length = k ; return result ; } else { var len = TO_LENGTH ( items . length ) ; result = % IsConstructor ( this ) ? new this ( len ) : new GlobalArray ( len ) ; for ( k = 0 ; k < len ; ++ k ) { nextValue = items [ k ] ; if ( mapping ) { mappedValue = % _Call ( mapfn , receiver , nextValue , k ) ; } else { mappedValue = nextValue ; } % CreateDataProperty ( result , k , mappedValue ) ; } result . length = k ; return result ; } } 
function ArrayOf ( ... args ) { var length = args . length ; var constructor = this ; 
function GlobalParseInt ( string , radix ) { if ( IS_UNDEFINED ( radix ) || radix === 10 || radix === 0 ) { 
function GlobalParseFloat ( string ) { 
function ObjectIsPrototypeOf ( V ) { if ( ! IS_RECEIVER ( V ) ) return false ; var O = TO_OBJECT ( this ) ; return % HasInPrototypeChain ( V , O ) ; } 
function GetMethod ( obj , p ) { var func = obj [ p ] ; if ( IS_NULL_OR_UNDEFINED ( func ) ) return UNDEFINED ; if ( IS_CALLABLE ( func ) ) return func ; throw MakeTypeError ( kCalledNonCallable , typeof func ) ; } 
function ObjectSetPrototypeOf ( obj , proto ) { CHECK_OBJECT_COERCIBLE ( obj , "Object.setPrototypeOf" ) ; if ( proto !== null && ! IS_RECEIVER ( proto ) ) { throw MakeTypeError ( kProtoObjectOrNull , proto ) ; } if ( IS_RECEIVER ( obj ) ) { % SetPrototype ( obj , proto ) ; } return obj ; } 
function ObjectSetProto ( proto ) { CHECK_OBJECT_COERCIBLE ( this , "Object.prototype.__proto__" ) ; if ( ( IS_RECEIVER ( proto ) || IS_NULL ( proto ) ) && IS_RECEIVER ( this ) ) { % SetPrototype ( this , proto ) ; } } 
function NumberToStringJS ( radix ) { 
function NumberToFixedJS ( fractionDigits ) { var x = this ; if ( ! IS_NUMBER ( this ) ) { if ( ! IS_NUMBER_WRAPPER ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , "Number.prototype.toFixed" , this ) ; } 
function NumberToExponentialJS ( fractionDigits ) { var x = this ; if ( ! IS_NUMBER ( this ) ) { if ( ! IS_NUMBER_WRAPPER ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , "Number.prototype.toExponential" , this ) ; } 
function NumberToPrecisionJS ( precision ) { var x = this ; if ( ! IS_NUMBER ( this ) ) { if ( ! IS_NUMBER_WRAPPER ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , "Number.prototype.toPrecision" , this ) ; } 
function GetIterator ( obj , method ) { if ( IS_UNDEFINED ( method ) ) { method = obj [ iteratorSymbol ] ; } if ( ! IS_CALLABLE ( method ) ) { throw MakeTypeError ( kNotIterable , obj ) ; } var iterator = % _Call ( method , obj ) ; if ( ! IS_RECEIVER ( iterator ) ) { throw MakeTypeError ( kNotAnIterator , iterator ) ; } return iterator ; } 
function CreateStringIterator ( string ) { CHECK_OBJECT_COERCIBLE ( string , 'String.prototype[Symbol.iterator]' ) ; var s = TO_STRING ( string ) ; var iterator = new StringIterator ; SET_PRIVATE ( iterator , stringIteratorIteratedStringSymbol , s ) ; SET_PRIVATE ( iterator , stringIteratorNextIndexSymbol , 0 ) ; return iterator ; } 
function StringIteratorNext ( ) { var iterator = this ; var value = UNDEFINED ; var done = true ; if ( ! IS_RECEIVER ( iterator ) || ! HAS_DEFINED_PRIVATE ( iterator , stringIteratorNextIndexSymbol ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , 'String Iterator.prototype.next' ) ; } var s = GET_PRIVATE ( iterator , stringIteratorIteratedStringSymbol ) ; if ( ! IS_UNDEFINED ( s ) ) { var position = GET_PRIVATE ( iterator , stringIteratorNextIndexSymbol ) ; var length = TO_UINT32 ( s . length ) ; if ( position >= length ) { SET_PRIVATE ( iterator , stringIteratorIteratedStringSymbol , UNDEFINED ) ; } else { var first = % _StringCharCodeAt ( s , position ) ; value = % _StringCharFromCode ( first ) ; done = false ; position ++ ; if ( first >= 0xD800 && first <= 0xDBFF && position < length ) { var second = % _StringCharCodeAt ( s , position ) ; if ( second >= 0xDC00 && second <= 0xDFFF ) { value += % _StringCharFromCode ( second ) ; position ++ ; } } SET_PRIVATE ( iterator , stringIteratorNextIndexSymbol , position ) ; } } return % _CreateIterResultObject ( value , done ) ; } 
function FluidField ( canvas ) { function addFields ( x , s , dt ) { for ( var i = 0 ; i < size ; i ++ ) x [ i ] += dt * s [ i ] ; } function set_bnd ( b , x ) { if ( b === 1 ) { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = x [ i + height * rowSize ] ; } for ( var j = 1 ; i <= height ; i ++ ) { x [ j * rowSize ] = - x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = - x [ width + j * rowSize ] ; } } else if ( b === 2 ) { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = - x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = - x [ i + height * rowSize ] ; } for ( var j = 1 ; j <= height ; j ++ ) { x [ j * rowSize ] = x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = x [ width + j * rowSize ] ; } } else { for ( var i = 1 ; i <= width ; i ++ ) { x [ i ] = x [ i + rowSize ] ; x [ i + ( height + 1 ) * rowSize ] = x [ i + height * rowSize ] ; } for ( var j = 1 ; j <= height ; j ++ ) { x [ j * rowSize ] = x [ 1 + j * rowSize ] ; x [ ( width + 1 ) + j * rowSize ] = x [ width + j * rowSize ] ; } } var maxEdge = ( height + 1 ) * rowSize ; x [ 0 ] = 0.5 * ( x [ 1 ] + x [ rowSize ] ) ; x [ maxEdge ] = 0.5 * ( x [ 1 + maxEdge ] + x [ height * rowSize ] ) ; x [ ( width + 1 ) ] = 0.5 * ( x [ width ] + x [ ( width + 1 ) + rowSize ] ) ; x [ ( width + 1 ) + maxEdge ] = 0.5 * ( x [ width + maxEdge ] + x [ ( width + 1 ) + height * rowSize ] ) ; } function lin_solve ( b , x , x0 , a , c ) { if ( a === 0 && c === 1 ) { for ( var j = 1 ; j <= height ; j ++ ) { var currentRow = j * rowSize ; ++ currentRow ; for ( var i = 0 ; i < width ; i ++ ) { x [ currentRow ] = x0 [ currentRow ] ; ++ currentRow ; } } set_bnd ( b , x ) ; } else { var invC = 1 / c ; for ( var k = 0 ; k < iterations ; k ++ ) { for ( var j = 1 ; j <= height ; j ++ ) { var lastRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; var lastX = x [ currentRow ] ; ++ currentRow ; for ( var i = 1 ; i <= width ; i ++ ) lastX = x [ currentRow ] = ( x0 [ currentRow ] + a * ( lastX + x [ ++ currentRow ] + x [ ++ lastRow ] + x [ ++ nextRow ] ) ) * invC ; } set_bnd ( b , x ) ; } } } function diffuse ( b , x , x0 , dt ) { var a = 0 ; lin_solve ( b , x , x0 , a , 1 + 4 * a ) ; } function lin_solve2 ( x , x0 , y , y0 , a , c ) { if ( a === 0 && c === 1 ) { for ( var j = 1 ; j <= height ; j ++ ) { var currentRow = j * rowSize ; ++ currentRow ; for ( var i = 0 ; i < width ; i ++ ) { x [ currentRow ] = x0 [ currentRow ] ; y [ currentRow ] = y0 [ currentRow ] ; ++ currentRow ; } } set_bnd ( 1 , x ) ; set_bnd ( 2 , y ) ; } else { var invC = 1 / c ; for ( var k = 0 ; k < iterations ; k ++ ) { for ( var j = 1 ; j <= height ; j ++ ) { var lastRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; var lastX = x [ currentRow ] ; var lastY = y [ currentRow ] ; ++ currentRow ; for ( var i = 1 ; i <= width ; i ++ ) { lastX = x [ currentRow ] = ( x0 [ currentRow ] + a * ( lastX + x [ currentRow ] + x [ lastRow ] + x [ nextRow ] ) ) * invC ; lastY = y [ currentRow ] = ( y0 [ currentRow ] + a * ( lastY + y [ ++ currentRow ] + y [ ++ lastRow ] + y [ ++ nextRow ] ) ) * invC ; } } set_bnd ( 1 , x ) ; set_bnd ( 2 , y ) ; } } } function diffuse2 ( x , x0 , y , y0 , dt ) { var a = 0 ; lin_solve2 ( x , x0 , y , y0 , a , 1 + 4 * a ) ; } function advect ( b , d , d0 , u , v , dt ) { var Wdt0 = dt * width ; var Hdt0 = dt * height ; var Wp5 = width + 0.5 ; var Hp5 = height + 0.5 ; for ( var j = 1 ; j <= height ; j ++ ) { var pos = j * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { var x = i - Wdt0 * u [ ++ pos ] ; var y = j - Hdt0 * v [ pos ] ; if ( x < 0.5 ) x = 0.5 ; else if ( x > Wp5 ) x = Wp5 ; var i0 = x | 0 ; var i1 = i0 + 1 ; if ( y < 0.5 ) y = 0.5 ; else if ( y > Hp5 ) y = Hp5 ; var j0 = y | 0 ; var j1 = j0 + 1 ; var s1 = x - i0 ; var s0 = 1 - s1 ; var t1 = y - j0 ; var t0 = 1 - t1 ; var row1 = j0 * rowSize ; var row2 = j1 * rowSize ; d [ pos ] = s0 * ( t0 * d0 [ i0 + row1 ] + t1 * d0 [ i0 + row2 ] ) + s1 * ( t0 * d0 [ i1 + row1 ] + t1 * d0 [ i1 + row2 ] ) ; } } set_bnd ( b , d ) ; } function project ( u , v , p , div ) { var h = - 0.5 / Math . sqrt ( width * height ) ; for ( var j = 1 ; j <= height ; j ++ ) { var row = j * rowSize ; var previousRow = ( j - 1 ) * rowSize ; var prevValue = row - 1 ; var currentRow = row ; var nextValue = row + 1 ; var nextRow = ( j + 1 ) * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { div [ ++ currentRow ] = h * ( u [ ++ nextValue ] - u [ ++ prevValue ] + v [ ++ nextRow ] - v [ ++ previousRow ] ) ; p [ currentRow ] = 0 ; } } set_bnd ( 0 , div ) ; set_bnd ( 0 , p ) ; lin_solve ( 0 , p , div , 1 , 4 ) ; var wScale = 0.5 * width ; var hScale = 0.5 * height ; for ( var j = 1 ; j <= height ; j ++ ) { var prevPos = j * rowSize - 1 ; var currentPos = j * rowSize ; var nextPos = j * rowSize + 1 ; var prevRow = ( j - 1 ) * rowSize ; var currentRow = j * rowSize ; var nextRow = ( j + 1 ) * rowSize ; for ( var i = 1 ; i <= width ; i ++ ) { u [ ++ currentPos ] -= wScale * ( p [ ++ nextPos ] - p [ ++ prevPos ] ) ; v [ currentPos ] -= hScale * ( p [ ++ nextRow ] - p [ ++ prevRow ] ) ; } } set_bnd ( 1 , u ) ; set_bnd ( 2 , v ) ; } function dens_step ( x , x0 , u , v , dt ) { addFields ( x , x0 , dt ) ; diffuse ( 0 , x0 , x , dt ) ; advect ( 0 , x , x0 , u , v , dt ) ; } function vel_step ( u , v , u0 , v0 , dt ) { addFields ( u , u0 , dt ) ; addFields ( v , v0 , dt ) ; var temp = u0 ; u0 = u ; u = temp ; var temp = v0 ; v0 = v ; v = temp ; diffuse2 ( u , u0 , v , v0 , dt ) ; project ( u , v , u0 , v0 ) ; var temp = u0 ; u0 = u ; u = temp ; var temp = v0 ; v0 = v ; v = temp ; advect ( 1 , u , u0 , u0 , v0 , dt ) ; advect ( 2 , v , v0 , u0 , v0 , dt ) ; project ( u , v , u0 , v0 ) ; } var uiCallback = function ( d , u , v ) { } ; function Field ( dens , u , v ) { 
function LogReader ( dispatchTable , timedRange , pairwiseTimedRange ) { this . dispatchTable_ = dispatchTable ; this . timedRange_ = timedRange ; this . pairwiseTimedRange_ = pairwiseTimedRange ; if ( pairwiseTimedRange ) { this . timedRange_ = true ; } this . lineNum_ = 0 ; this . csvParser_ = new CsvParser ( ) ; this . hasSeenTimerMarker_ = false ; this . logLinesSinceLastTimerMarker_ = [ ] ; } 
function ArrayBufferSlice ( start , end ) { if ( ! IS_ARRAYBUFFER ( this ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , 'ArrayBuffer.prototype.slice' , this ) ; } var relativeStart = TO_INTEGER ( start ) ; if ( ! IS_UNDEFINED ( end ) ) { end = TO_INTEGER ( end ) ; } var first ; var byte_length = % _ArrayBufferGetByteLength ( this ) ; if ( relativeStart < 0 ) { first = MaxSimple ( byte_length + relativeStart , 0 ) ; } else { first = MinSimple ( relativeStart , byte_length ) ; } var relativeEnd = IS_UNDEFINED ( end ) ? byte_length : end ; var fin ; if ( relativeEnd < 0 ) { fin = MaxSimple ( byte_length + relativeEnd , 0 ) ; } else { fin = MinSimple ( relativeEnd , byte_length ) ; } if ( fin < first ) { fin = first ; } var newLen = fin - first ; var constructor = SpeciesConstructor ( this , GlobalArrayBuffer , true ) ; var result = new constructor ( newLen ) ; if ( ! IS_ARRAYBUFFER ( result ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , 'ArrayBuffer.prototype.slice' , result ) ; } 
function MakeMirror ( value , opt_transient ) { var mirror ; 
function ValueMirror ( type , value , transient ) { % _Call ( Mirror , this , type ) ; this . value_ = value ; if ( ! transient ) { this . allocateHandle_ ( ) ; } else { this . allocateTransientHandle_ ( ) ; } } 
function ObjectMirror ( value , type , transient ) { type = type || MirrorType . OBJECT_TYPE ; % _Call ( ValueMirror , this , type , value , transient ) ; } 
function UnresolvedFunctionMirror ( value ) { 
function PropertyMirror ( mirror , name , details ) { % _Call ( Mirror , this , MirrorType . PROPERTY_TYPE ) ; this . mirror_ = mirror ; this . name_ = name ; this . value_ = details [ 0 ] ; this . details_ = details [ 1 ] ; this . is_interceptor_ = details [ 2 ] ; if ( details . length > 3 ) { this . exception_ = details [ 3 ] ; this . getter_ = details [ 4 ] ; this . setter_ = details [ 5 ] ; } } 
function InternalPropertyMirror ( name , value ) { % _Call ( Mirror , this , MirrorType . INTERNAL_PROPERTY_TYPE ) ; this . name_ = name ; this . value_ = value ; } 
function FrameMirror ( break_id , index ) { % _Call ( Mirror , this , MirrorType . FRAME_TYPE ) ; this . break_id_ = break_id ; this . index_ = index ; this . details_ = new FrameDetails ( break_id , index ) ; } 
function ScopeMirror ( frame , fun , index , opt_details ) { % _Call ( Mirror , this , MirrorType . SCOPE_TYPE ) ; if ( frame ) { this . frame_index_ = frame . index_ ; } else { this . frame_index_ = UNDEFINED ; } this . scope_index_ = index ; this . details_ = new ScopeDetails ( frame , fun , index , opt_details ) ; } 
function ScriptMirror ( script ) { % _Call ( Mirror , this , MirrorType . SCRIPT_TYPE ) ; this . script_ = script ; this . context_ = new ContextMirror ( script . context_data ) ; this . allocateHandle_ ( ) ; } 
function serializeLocationFields ( location , content ) { if ( ! location ) { return ; } content . position = location . position ; var line = location . line ; if ( ! IS_UNDEFINED ( line ) ) { content . line = line ; } var column = location . column ; if ( ! IS_UNDEFINED ( column ) ) { content . column = column ; } } 
function StringConcat ( other ) { 
function StringMatchJS ( pattern ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.match" ) ; if ( ! IS_NULL_OR_UNDEFINED ( pattern ) ) { var matcher = pattern [ matchSymbol ] ; if ( ! IS_UNDEFINED ( matcher ) ) { return % _Call ( matcher , pattern , this ) ; } } var subject = TO_STRING ( this ) ; 
function StringReplace ( search , replace ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.replace" ) ; 
function ExpandReplacement ( string , subject , matchInfo , result ) { var length = string . length ; var next = % StringIndexOf ( string , '$' , 0 ) ; if ( next < 0 ) { if ( length > 0 ) result += string ; return result ; } if ( next > 0 ) result += % _SubString ( string , 0 , next ) ; while ( true ) { var expansion = '$' ; var position = next + 1 ; if ( position < length ) { var peek = % _StringCharCodeAt ( string , position ) ; if ( peek == 36 ) { 
function StringSearch ( pattern ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.search" ) ; if ( ! IS_NULL_OR_UNDEFINED ( pattern ) ) { var searcher = pattern [ searchSymbol ] ; if ( ! IS_UNDEFINED ( searcher ) ) { return % _Call ( searcher , pattern , this ) ; } } var subject = TO_STRING ( this ) ; 
function StringSlice ( start , end ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.slice" ) ; var s = TO_STRING ( this ) ; var s_len = s . length ; var start_i = TO_INTEGER ( start ) ; var end_i = s_len ; if ( ! IS_UNDEFINED ( end ) ) { end_i = TO_INTEGER ( end ) ; } if ( start_i < 0 ) { start_i += s_len ; if ( start_i < 0 ) { start_i = 0 ; } } else { if ( start_i > s_len ) { return '' ; } } if ( end_i < 0 ) { end_i += s_len ; if ( end_i < 0 ) { return '' ; } } else { if ( end_i > s_len ) { end_i = s_len ; } } if ( end_i <= start_i ) { return '' ; } return % _SubString ( s , start_i , end_i ) ; } 
function StringSplitJS ( separator , limit ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.split" ) ; if ( ! IS_NULL_OR_UNDEFINED ( separator ) ) { var splitter = separator [ splitSymbol ] ; if ( ! IS_UNDEFINED ( splitter ) ) { return % _Call ( splitter , separator , this , limit ) ; } } var subject = TO_STRING ( this ) ; limit = ( IS_UNDEFINED ( limit ) ) ? kMaxUint32 : TO_UINT32 ( limit ) ; var length = subject . length ; var separator_string = TO_STRING ( separator ) ; if ( limit === 0 ) return [ ] ; 
function StringSubstr ( start , length ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.substr" ) ; var s = TO_STRING ( this ) ; var size = s . length ; start = TO_INTEGER ( start ) ; length = IS_UNDEFINED ( length ) ? size : TO_INTEGER ( length ) ; if ( start < 0 ) start = MaxSimple ( size + start , 0 ) ; length = MinSimple ( MaxSimple ( length , 0 ) , size - start ) ; if ( length <= 0 ) return '' ; return % _SubString ( s , start , start + length ) ; } 
function StringRepeat ( count ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.repeat" ) ; var s = TO_STRING ( this ) ; var n = TO_INTEGER ( count ) ; if ( n < 0 || n === INFINITY ) throw MakeRangeError ( kInvalidCountValue ) ; 
function StringCodePointAt ( pos ) { CHECK_OBJECT_COERCIBLE ( this , "String.prototype.codePointAt" ) ; var string = TO_STRING ( this ) ; var size = string . length ; pos = TO_INTEGER ( pos ) ; if ( pos < 0 || pos >= size ) { return UNDEFINED ; } var first = % _StringCharCodeAt ( string , pos ) ; if ( first < 0xD800 || first > 0xDBFF || pos + 1 == size ) { return first ; } var second = % _StringCharCodeAt ( string , pos + 1 ) ; if ( second < 0xDC00 || second > 0xDFFF ) { return first ; } return ( first - 0xD800 ) * 0x400 + second + 0x2400 ; } 
function StringRaw ( callSite ) { "use strict" ; var numberOfSubstitutions = arguments . length ; var cooked = TO_OBJECT ( callSite ) ; var raw = TO_OBJECT ( cooked . raw ) ; var literalSegments = TO_LENGTH ( raw . length ) ; if ( literalSegments <= 0 ) return "" ; var result = TO_STRING ( raw [ 0 ] ) ; for ( var i = 1 ; i < literalSegments ; ++ i ) { if ( i < numberOfSubstitutions ) { result += TO_STRING ( arguments [ i ] ) ; } result += TO_STRING ( raw [ i ] ) ; } return result ; } 
function CreateResolvingFunctions ( promise ) { var alreadyResolved = false ; 
function Promise ( executor ) { if ( executor === promiseRawSymbol ) { return % _NewObject ( GlobalPromise , new . target ) ; } if ( IS_UNDEFINED ( new . target ) ) throw MakeTypeError ( kNotAPromise , this ) ; if ( ! IS_CALLABLE ( executor ) ) { throw MakeTypeError ( kResolverNotAFunction , executor ) ; } var promise = PromiseInit ( % _NewObject ( GlobalPromise , new . target ) ) ; var callbacks = CreateResolvingFunctions ( promise ) ; var debug_is_active = DEBUG_IS_ACTIVE ; try { if ( debug_is_active ) % DebugPushPromise ( promise , Promise ) ; executor ( callbacks . resolve , callbacks . reject ) ; } catch ( e ) { % _Call ( callbacks . reject , UNDEFINED , e ) ; } finally { if ( debug_is_active ) % DebugPopPromise ( ) ; } return promise ; } 
function PromiseSet ( promise , status , value ) { SET_PRIVATE ( promise , promiseStateSymbol , status ) ; SET_PRIVATE ( promise , promiseResultSymbol , value ) ; 
function ResolvePromise ( promise , resolution ) { if ( resolution === promise ) { return RejectPromise ( promise , MakeTypeError ( kPromiseCyclic , resolution ) ) ; } if ( IS_RECEIVER ( resolution ) ) { 
function RejectPromise ( promise , reason ) { 
function NewPromiseCapability ( C ) { if ( C === GlobalPromise ) { 
function PromiseReject ( r ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kCalledOnNonObject , PromiseResolve ) ; } if ( this === GlobalPromise ) { 
function PromiseThen ( onResolve , onReject ) { var status = GET_PRIVATE ( this , promiseStateSymbol ) ; if ( IS_UNDEFINED ( status ) ) { throw MakeTypeError ( kNotAPromise , this ) ; } var constructor = SpeciesConstructor ( this , GlobalPromise ) ; onResolve = IS_CALLABLE ( onResolve ) ? onResolve : PromiseIdResolveHandler ; onReject = IS_CALLABLE ( onReject ) ? onReject : PromiseIdRejectHandler ; var deferred = NewPromiseCapability ( constructor ) ; switch ( status ) { case kPending : PromiseAttachCallbacks ( this , deferred , onResolve , onReject ) ; break ; case kFulfilled : PromiseEnqueue ( GET_PRIVATE ( this , promiseResultSymbol ) , onResolve , deferred , kFulfilled ) ; break ; case kRejected : if ( ! HAS_DEFINED_PRIVATE ( this , promiseHasHandlerSymbol ) ) { 
function PromiseResolve ( x ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kCalledOnNonObject , PromiseResolve ) ; } if ( IsPromise ( x ) && x . constructor === this ) return x ; var promiseCapability = NewPromiseCapability ( this ) ; var resolveResult = % _Call ( promiseCapability . resolve , UNDEFINED , x ) ; return promiseCapability . promise ; } 
function PromiseAll ( iterable ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kCalledOnNonObject , "Promise.all" ) ; } var deferred = NewPromiseCapability ( this ) ; var resolutions = new InternalArray ( ) ; var count ; function CreateResolveElementFunction ( index , values , promiseCapability ) { var alreadyCalled = false ; return ( x ) => { if ( alreadyCalled === true ) return ; alreadyCalled = true ; values [ index ] = x ; if ( -- count === 0 ) { var valuesArray = [ ] ; % MoveArrayContents ( values , valuesArray ) ; % _Call ( promiseCapability . resolve , UNDEFINED , valuesArray ) ; } } ; } try { var i = 0 ; count = 1 ; for ( var value of iterable ) { var nextPromise = this . resolve ( value ) ; ++ count ; nextPromise . then ( CreateResolveElementFunction ( i , resolutions , deferred ) , deferred . reject ) ; SET_PRIVATE ( deferred . reject , promiseCombinedDeferredSymbol , deferred ) ; ++ i ; } 
function PromiseRace ( iterable ) { if ( ! IS_RECEIVER ( this ) ) { throw MakeTypeError ( kCalledOnNonObject , PromiseRace ) ; } var deferred = NewPromiseCapability ( this ) ; try { for ( var value of iterable ) { this . resolve ( value ) . then ( deferred . resolve , deferred . reject ) ; SET_PRIVATE ( deferred . reject , promiseCombinedDeferredSymbol , deferred ) ; } } catch ( e ) { deferred . reject ( e ) } return deferred . promise ; } 
function PromiseHasUserDefinedRejectHandlerCheck ( handler , deferred ) { if ( handler !== PromiseIdRejectHandler ) { var combinedDeferred = GET_PRIVATE ( handler , promiseCombinedDeferredSymbol ) ; if ( IS_UNDEFINED ( combinedDeferred ) ) return true ; if ( PromiseHasUserDefinedRejectHandlerRecursive ( combinedDeferred . promise ) ) { return true ; } } else if ( PromiseHasUserDefinedRejectHandlerRecursive ( deferred . promise ) ) { return true ; } return false ; } 
function receive ( intf , srcIP , destIP , u8 , headerOffset ) { const srcPort = udpHeader . getSrcPort ( u8 , headerOffset ) ; const destPort = udpHeader . getDestPort ( u8 , headerOffset ) ; const dataLength = udpHeader . getDataLength ( u8 , headerOffset ) - udpHeader . headerLength ; const dataOffset = headerOffset + udpHeader . headerLength ; debug ( 'recv UDP over IP4' , srcPort , destPort , dataLength ) ; const socket = UDPSocket . lookupReceive ( destPort ) ; if ( ! socket ) { return ; } const u8data = u8 . subarray ( dataOffset ) ; if ( socket . onmessage ) setImmediate ( ( ) => socket . onmessage ( srcIP , srcPort , u8data ) ) ; } 
function SetConstructor ( iterable ) { if ( IS_UNDEFINED ( new . target ) ) { throw MakeTypeError ( kConstructorNotFunction , "Set" ) ; } % _SetInitialize ( this ) ; if ( ! IS_NULL_OR_UNDEFINED ( iterable ) ) { var adder = this . add ; if ( ! IS_CALLABLE ( adder ) ) { throw MakeTypeError ( kPropertyNotFunction , adder , 'add' , this ) ; } for ( var value of iterable ) { % _Call ( adder , this , value ) ; } } } 
function MapConstructor ( iterable ) { if ( IS_UNDEFINED ( new . target ) ) { throw MakeTypeError ( kConstructorNotFunction , "Map" ) ; } % _MapInitialize ( this ) ; if ( ! IS_NULL_OR_UNDEFINED ( iterable ) ) { var adder = this . set ; if ( ! IS_CALLABLE ( adder ) ) { throw MakeTypeError ( kPropertyNotFunction , adder , 'set' , this ) ; } for ( var nextItem of iterable ) { if ( ! IS_RECEIVER ( nextItem ) ) { throw MakeTypeError ( kIteratorValueNotAnObject , nextItem ) ; } % _Call ( adder , this , nextItem [ 0 ] , nextItem [ 1 ] ) ; } } } 
function ApplyPatchMultiChunk ( script , diff_array , new_source , preview_only , change_log ) { var old_source = script . source ; 
function CollectNew ( node_list ) { for ( var i = 0 ; i < node_list . length ; i ++ ) { link_to_original_script_list . push ( node_list [ i ] ) ; CollectNew ( node_list [ i ] . children ) ; } } 
function GatherCompileInfo ( source , script ) { 
function ResetIndexes ( new_parent_index , old_parent_index ) { var previous_sibling = - 1 ; while ( current_index < compile_info . length && compile_info [ current_index ] . outer_index == old_parent_index ) { var saved_index = current_index ; compile_info [ saved_index ] . outer_index = new_parent_index ; if ( previous_sibling != - 1 ) { compile_info [ previous_sibling ] . next_sibling_index = saved_index ; } previous_sibling = saved_index ; current_index ++ ; ResetIndexes ( saved_index , old_index_map [ saved_index ] ) ; } if ( previous_sibling != - 1 ) { compile_info [ previous_sibling ] . next_sibling_index = - 1 ; } } 
function PatchFunctionCode ( old_node , change_log ) { var new_info = old_node . corresponding_node . info ; if ( old_node . live_shared_function_infos ) { old_node . live_shared_function_infos . forEach ( function ( old_info ) { % LiveEditReplaceFunctionCode ( new_info . raw_array , old_info . raw_array ) ; 
function LinkToOldScript ( old_info_node , old_script , report_array ) { if ( old_info_node . live_shared_function_infos ) { old_info_node . live_shared_function_infos . forEach ( function ( info ) { % LiveEditFunctionSetScript ( info . info , old_script ) ; } ) ; report_array . push ( { name : old_info_node . info . function_name } ) ; } else { report_array . push ( { name : old_info_node . info . function_name , not_found : true } ) ; } } 
function TemporaryRemoveBreakPoints ( original_script , change_log ) { var script_break_points = GetScriptBreakPoints ( original_script ) ; var break_points_update_report = [ ] ; change_log . push ( { break_points_update : break_points_update_report } ) ; var break_point_old_positions = [ ] ; for ( var i = 0 ; i < script_break_points . length ; i ++ ) { var break_point = script_break_points [ i ] ; break_point . clear ( ) ; 
function BuildCodeInfoTree ( code_info_array ) { 
function MarkChangedFunctions ( code_info_tree , chunks ) { 
function ProcessInternals ( info_node ) { info_node . new_start_pos = chunk_it . TranslatePos ( info_node . info . start_position ) ; var child_index = 0 ; var code_changed = false ; var source_changed = false ; 
function FindCorrespondingFunctions ( old_code_tree , new_code_tree ) { 
function FindFunctionInfos ( compile_info ) { var wrappers = [ ] ; for ( var i = 0 ; i < shared_infos . length ; i ++ ) { var wrapper = shared_infos [ i ] ; if ( wrapper . start_position == compile_info . start_position && wrapper . end_position == compile_info . end_position ) { wrappers . push ( wrapper ) ; } } if ( wrappers . length > 0 ) { return wrappers ; } } 
function FunctionCompileInfo ( raw_array ) { this . function_name = raw_array [ 0 ] ; this . start_position = raw_array [ 1 ] ; this . end_position = raw_array [ 2 ] ; this . param_num = raw_array [ 3 ] ; this . code = raw_array [ 4 ] ; this . code_scope_info = raw_array [ 5 ] ; this . scope_info = raw_array [ 6 ] ; this . outer_index = raw_array [ 7 ] ; this . shared_function_info = raw_array [ 8 ] ; this . next_sibling_index = null ; this . raw_array = raw_array ; } 
function PatchPositions ( old_info_node , diff_array , report_array ) { if ( old_info_node . live_shared_function_infos ) { old_info_node . live_shared_function_infos . forEach ( function ( info ) { % LiveEditPatchFunctionPositions ( info . raw_array , diff_array ) ; } ) ; report_array . push ( { name : old_info_node . info . function_name } ) ; } else { 
function IsFunctionContextLocalsChanged ( function_info1 , function_info2 ) { var scope_info1 = function_info1 . scope_info ; var scope_info2 = function_info2 . scope_info ; var scope_info1_text ; var scope_info2_text ; if ( scope_info1 ) { scope_info1_text = scope_info1 . toString ( ) ; } else { scope_info1_text = "" ; } if ( scope_info2 ) { scope_info2_text = scope_info2 . toString ( ) ; } else { scope_info2_text = "" ; } if ( scope_info1_text != scope_info2_text ) { return "Variable map changed: [" + scope_info1_text + "] => [" + scope_info2_text + "]" ; } 
function CheckStackActivations ( old_shared_wrapper_list , new_shared_list , change_log ) { var old_shared_list = new GlobalArray ( ) ; for ( var i = 0 ; i < old_shared_wrapper_list . length ; i ++ ) { old_shared_list [ i ] = old_shared_wrapper_list [ i ] . info ; } var result = % LiveEditCheckAndDropActivations ( old_shared_list , new_shared_list , true ) ; if ( result [ old_shared_wrapper_list . length ] ) { 
function SetScriptSource ( script , new_source , preview_only , change_log ) { var old_source = script . source ; var diff = CompareStrings ( old_source , new_source ) ; return ApplyPatchMultiChunk ( script , diff , new_source , preview_only , change_log ) ; } 
function ApplySingleChunkPatch ( script , change_pos , change_len , new_str , change_log ) { var old_source = script . source ; 
function DescribeChangeTree ( old_code_tree ) { function ProcessOldNode ( node ) { var child_infos = [ ] ; for ( var i = 0 ; i < node . children . length ; i ++ ) { var child = node . children [ i ] ; if ( child . status != FunctionStatus . UNCHANGED ) { child_infos . push ( ProcessOldNode ( child ) ) ; } } var new_child_infos = [ ] ; if ( node . textually_unmatched_new_nodes ) { for ( var i = 0 ; i < node . textually_unmatched_new_nodes . length ; i ++ ) { var child = node . textually_unmatched_new_nodes [ i ] ; new_child_infos . push ( ProcessNewNode ( child ) ) ; } } var res = { name : node . info . function_name , positions : DescribePositions ( node ) , status : node . status , children : child_infos , new_children : new_child_infos } ; if ( node . status_explanation ) { res . status_explanation = node . status_explanation ; } if ( node . textual_corresponding_node ) { res . new_positions = DescribePositions ( node . textual_corresponding_node ) ; } return res ; } function ProcessNewNode ( node ) { var child_infos = [ ] ; 
function ValidateIndex ( index , length ) { var numberIndex = TO_NUMBER ( index ) ; var accessIndex = TO_INTEGER ( numberIndex ) ; if ( numberIndex !== accessIndex ) { throw MakeRangeError ( kInvalidAtomicAccessIndex ) ; } if ( accessIndex < 0 || accessIndex >= length ) { throw MakeRangeError ( kInvalidAtomicAccessIndex ) ; } return accessIndex ; } 
function AtomicsCompareExchangeJS ( sta , index , oldValue , newValue ) { CheckSharedIntegerTypedArray ( sta ) ; index = ValidateIndex ( index , % _TypedArrayGetLength ( sta ) ) ; oldValue = TO_NUMBER ( oldValue ) ; newValue = TO_NUMBER ( newValue ) ; return % _AtomicsCompareExchange ( sta , index , oldValue , newValue ) ; } 
function AtomicsFutexWaitJS ( ia , index , value , timeout ) { CheckSharedInteger32TypedArray ( ia ) ; index = ValidateIndex ( index , % _TypedArrayGetLength ( ia ) ) ; if ( IS_UNDEFINED ( timeout ) ) { timeout = INFINITY ; } else { timeout = TO_NUMBER ( timeout ) ; if ( NUMBER_IS_NAN ( timeout ) ) { timeout = INFINITY ; } else { timeout = MaxSimple ( 0 , timeout ) ; } } return % AtomicsFutexWait ( ia , index , value , timeout ) ; } 
function ToPositiveInteger ( x , rangeErrorIndex ) { var i = TO_INTEGER ( x ) + 0 ; if ( i < 0 ) throw MakeRangeError ( rangeErrorIndex ) ; return i ; } 
function MakeBreakPoint ( source_position , opt_script_break_point ) { var break_point = new BreakPoint ( source_position , opt_script_break_point ) ; break_points . push ( break_point ) ; return break_point ; } 
function BreakPoint ( source_position , opt_script_break_point ) { this . source_position_ = source_position ; if ( opt_script_break_point ) { this . script_break_point_ = opt_script_break_point ; } else { this . number_ = next_break_point_number ++ ; } this . active_ = true ; this . condition_ = null ; } 
function ScriptBreakPoint ( type , script_id_or_name , opt_line , opt_column , opt_groupId , opt_position_alignment ) { this . type_ = type ; if ( type == Debug . ScriptBreakPointType . ScriptId ) { this . script_id_ = script_id_or_name ; } else if ( type == Debug . ScriptBreakPointType . ScriptName ) { this . script_name_ = script_id_or_name ; } else if ( type == Debug . ScriptBreakPointType . ScriptRegExp ) { this . script_regexp_object_ = new GlobalRegExp ( script_id_or_name ) ; } else { throw MakeError ( kDebugger , "Unexpected breakpoint type " + type ) ; } this . line_ = opt_line || 0 ; this . column_ = opt_column ; this . groupId_ = opt_groupId ; this . position_alignment_ = IS_UNDEFINED ( opt_position_alignment ) ? Debug . BreakPositionAlignment . Statement : opt_position_alignment ; this . active_ = true ; this . condition_ = null ; this . break_points_ = [ ] ; } 
function UpdateScriptBreakPoints ( script ) { for ( var i = 0 ; i < script_break_points . length ; i ++ ) { var break_point = script_break_points [ i ] ; if ( ( break_point . type ( ) == Debug . ScriptBreakPointType . ScriptName || break_point . type ( ) == Debug . ScriptBreakPointType . ScriptRegExp ) && break_point . matchesScript ( script ) ) { break_point . set ( script ) ; } } } 
function scriptById ( scriptId ) { var scripts = Debug . scripts ( ) ; for ( var script of scripts ) { if ( script . id == scriptId ) return script ; } return UNDEFINED ; } 
function ObjectToProtocolObject_ ( object , mirror_serializer ) { var content = { } ; for ( var key in object ) { 
function ArrayToProtocolArray_ ( array , mirror_serializer ) { var json = [ ] ; for ( var i = 0 ; i < array . length ; i ++ ) { json . push ( ValueToProtocolValue_ ( array [ i ] , mirror_serializer ) ) ; } return json ; } 
function ValueToProtocolValue_ ( value , mirror_serializer ) { 
function runRichards ( ) { var scheduler = new Scheduler ( ) ; scheduler . addIdleTask ( ID_IDLE , 0 , null , COUNT ) ; var queue = new Packet ( null , ID_WORKER , KIND_WORK ) ; queue = new Packet ( queue , ID_WORKER , KIND_WORK ) ; scheduler . addWorkerTask ( ID_WORKER , 1000 , queue ) ; queue = new Packet ( null , ID_DEVICE_A , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_A , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_A , KIND_DEVICE ) ; scheduler . addHandlerTask ( ID_HANDLER_A , 2000 , queue ) ; queue = new Packet ( null , ID_DEVICE_B , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_B , KIND_DEVICE ) ; queue = new Packet ( queue , ID_DEVICE_B , KIND_DEVICE ) ; scheduler . addHandlerTask ( ID_HANDLER_B , 3000 , queue ) ; scheduler . addDeviceTask ( ID_DEVICE_A , 4000 , null ) ; scheduler . addDeviceTask ( ID_DEVICE_B , 5000 , null ) ; scheduler . schedule ( ) ; if ( scheduler . queueCount != EXPECTED_QUEUE_COUNT || scheduler . holdCount != EXPECTED_HOLD_COUNT ) { var msg = "Error during execution: queueCount = " + scheduler . queueCount + ", holdCount = " + scheduler . holdCount + "." ; throw new Error ( msg ) ; } } 
function Scheduler ( ) { this . queueCount = 0 ; this . holdCount = 0 ; this . blocks = new Array ( NUMBER_OF_IDS ) ; this . list = null ; this . currentTcb = null ; this . currentId = null ; } 
function TaskControlBlock ( link , id , priority , queue , task ) { this . link = link ; this . id = id ; this . priority = priority ; this . queue = queue ; this . task = task ; if ( queue == null ) { this . state = STATE_SUSPENDED ; } else { this . state = STATE_SUSPENDED_RUNNABLE ; } } 
function IdleTask ( scheduler , v1 , count ) { this . scheduler = scheduler ; this . v1 = v1 ; this . count = count ; } 
function WorkerTask ( scheduler , v1 , v2 ) { this . scheduler = scheduler ; this . v1 = v1 ; this . v2 = v2 ; } 
function Packet ( link , id , kind ) { this . link = link ; this . id = id ; this . kind = kind ; this . a1 = 0 ; this . a2 = new Array ( DATA_SIZE ) ; } 
function ProxyCreateRevocable ( target , handler ) { var p = new GlobalProxy ( target , handler ) ; return { proxy : p , revoke : ( ) => % JSProxyRevoke ( p ) } ; } 
function InstallGetter ( object , name , getter , attributes , prefix ) { % CheckIsBootstrapping ( ) ; if ( IS_UNDEFINED ( attributes ) ) attributes = DONT_ENUM ; SetFunctionName ( getter , name , IS_UNDEFINED ( prefix ) ? "get" : prefix ) ; % FunctionRemovePrototype ( getter ) ; % DefineGetterPropertyUnchecked ( object , name , getter , attributes ) ; % SetNativeFlag ( getter ) ; } 
function InstallGetterSetter ( object , name , getter , setter , attributes ) { % CheckIsBootstrapping ( ) ; if ( IS_UNDEFINED ( attributes ) ) attributes = DONT_ENUM ; SetFunctionName ( getter , name , "get" ) ; SetFunctionName ( setter , name , "set" ) ; % FunctionRemovePrototype ( getter ) ; % FunctionRemovePrototype ( setter ) ; % DefineAccessorPropertyUnchecked ( object , name , getter , setter , DONT_ENUM ) ; % SetNativeFlag ( getter ) ; % SetNativeFlag ( setter ) ; } 
function SetUpLockedPrototype ( constructor , fields , methods ) { % CheckIsBootstrapping ( ) ; var prototype = constructor . prototype ; 
function PostNatives ( utils ) { % CheckIsBootstrapping ( ) ; for ( ; ! IS_UNDEFINED ( imports ) ; imports = imports . next ) { imports ( exports_container ) ; } 
function CreateArrayIterator ( array , kind ) { var object = TO_OBJECT ( array ) ; var iterator = new ArrayIterator ; SET_PRIVATE ( iterator , arrayIteratorObjectSymbol , object ) ; SET_PRIVATE ( iterator , arrayIteratorNextIndexSymbol , 0 ) ; SET_PRIVATE ( iterator , arrayIterationKindSymbol , kind ) ; return iterator ; } 
function ArrayIteratorNext ( ) { var iterator = this ; var value = UNDEFINED ; var done = true ; if ( ! IS_RECEIVER ( iterator ) || ! HAS_DEFINED_PRIVATE ( iterator , arrayIteratorNextIndexSymbol ) ) { throw MakeTypeError ( kIncompatibleMethodReceiver , 'Array Iterator.prototype.next' , this ) ; } var array = GET_PRIVATE ( iterator , arrayIteratorObjectSymbol ) ; if ( ! IS_UNDEFINED ( array ) ) { var index = GET_PRIVATE ( iterator , arrayIteratorNextIndexSymbol ) ; var itemKind = GET_PRIVATE ( iterator , arrayIterationKindSymbol ) ; var length = TO_UINT32 ( array . length ) ; 
function getCFunc ( ident ) { try { var func = globalScope [ 'Module' ] [ '_' + ident ] ; 
function ccallFunc ( func , returnType , argTypes , args ) { var stack = 0 ; function toC ( value , type ) { if ( type == 'string' ) { if ( value === null || value === undefined || value === 0 ) return 0 ; 
function setValue ( ptr , value , type , noSafe ) { type = type || 'i8' ; if ( type . charAt ( type . length - 1 ) === '*' ) type = 'i32' ; 
function addPreRun ( func ) { if ( ! Module [ 'preRun' ] ) Module [ 'preRun' ] = [ ] ; else if ( typeof Module [ 'preRun' ] == 'function' ) Module [ 'preRun' ] = [ Module [ 'preRun' ] ] ; Module [ 'preRun' ] . push ( func ) ; } 
function ( filedes ) { 
function copyString ( element , value ) { var offset = ___utsname_struct_layout [ element ] ; for ( var i = 0 ; i < value . length ; i ++ ) { HEAP8 [ ( ( ( name ) + ( offset + i ) ) | 0 ) ] = value . charCodeAt ( i ) } HEAP8 [ ( ( ( name ) + ( offset + i ) ) | 0 ) ] = 0 } 
function TypedArrayDefaultConstructor ( typedArray ) { switch ( % _ClassOf ( typedArray ) ) { macro TYPED_ARRAY_CONSTRUCTOR_CASE ( ARRAY_ID , NAME , ELEMENT_SIZE ) case "NAME" : return GlobalNAME ; endmacro TYPED_ARRAYS ( TYPED_ARRAY_CONSTRUCTOR_CASE ) } 
function componentWillMount ( ) { 
function updater ( prevState ) { var state = this . constructor . getDerivedStateFromProps ( nextProps , prevState ) ; return state !== null && state !== undefined ? state : null ; } 
function findPackage ( directory ) { const file = path . resolve ( directory , 'package.json' ) if ( fs . existsSync ( file ) && fs . statSync ( file ) . isFile ( ) ) { return require ( file ) } const parent = path . resolve ( directory , '..' ) return parent === directory ? null : findPackage ( parent ) } 
function isMultisource ( arg ) { return Array . isArray ( arg ) && ! ( typeof arg [ 0 ] === 'number' && ( arg . length === 1 || typeof arg [ 1 ] === 'number' ) ) && ! ( arg . length < 32 && arg . every ( ch => Array . isArray ( ch ) || ArrayBuffer . isView ( ch ) ) ) } 
function parseArgs ( audio , time , duration , options ) { 
function resolvePath ( fileName , depth = 2 ) { if ( ! isBrowser && isRelative ( fileName ) && ! isURL ( fileName ) ) { var callerPath = callsites ( ) [ depth ] . getFileName ( ) fileName = path . dirname ( callerPath ) + path . sep + fileName fileName = path . normalize ( fileName ) } return fileName } 
function multiSelect ( Table , Checkbox ) { var _class , _temp , _initialiseProps ; return _temp = _class = function ( _Component ) { _inherits ( MultiSelect , _Component ) ; function MultiSelect ( props ) { _classCallCheck ( this , MultiSelect ) ; var _this = _possibleConstructorReturn ( this , _Component . call ( this , props ) ) ; _initialiseProps . call ( _this ) ; var obj = _this . getCheckedOrIndeter ( props . data ) ; _this . state = _extends ( { } , obj , { data : ( 0 , _util . ObjectAssign ) ( props . data ) } ) ; return _this ; } MultiSelect . prototype . componentWillReceiveProps = function componentWillReceiveProps ( nextProps ) { if ( 'data' in nextProps ) { var obj = this . getCheckedOrIndeter ( nextProps . data ) ; this . setState ( _extends ( { } , obj , { data : ( 0 , _util . ObjectAssign ) ( nextProps . data ) } ) ) ; } } ; MultiSelect . prototype . getCheckedOrIndeter = function getCheckedOrIndeter ( data ) { var obj = { } ; var checkStatus = this . setChecked ( data ) ; if ( ! checkStatus ) { obj . checkedAll = false ; obj . indeterminate = false ; return obj ; } if ( checkStatus == 'indeter' ) { obj . indeterminate = true ; obj . checkedAll = false ; } else if ( checkStatus == 'all' ) { obj . checkedAll = true ; obj . indeterminate = false ; } return obj ; } ; MultiSelect . prototype . setChecked = function setChecked ( data ) { if ( ! this . isArray ( data ) ) return false ; if ( data . length == 0 ) return false ; var count = 0 ; var disabledCount = 0 ; data . forEach ( function ( da ) { if ( da . _checked && ! da . _disabled ) { count ++ ; } if ( da . _disabled ) { disabledCount ++ ; } } ) ; if ( data . length == count + disabledCount ) { return "all" ; } return count == 0 ? false : "indeter" ; } ; MultiSelect . prototype . isArray = function isArray ( o ) { return Object . prototype . toString . call ( o ) == '[object Array]' ; } ; MultiSelect . prototype . render = function render ( ) { var columns = this . props . columns ; var data = this . state . data ; return _react2 [ "default" ] . createElement ( Table , _extends ( { } , this . props , { columns : this . getDefaultColumns ( columns ) , data : data } ) ) ; } ; return MultiSelect ; } ( _react . Component ) , _class . defaultProps = { prefixCls : "u-table-mult-select" , getSelectedDataFunc : function getSelectedDataFunc ( ) { } } , _initialiseProps = function _initialiseProps ( ) { var _this2 = this ; this . onAllCheckChange = function ( ) { var _state = _this2 . state , data = _state . data , checkedAll = _state . checkedAll , indeterminate = _state . indeterminate ; var check = false ; if ( checkedAll ) { check = false ; } else { 
function renderSelect ( Select , Icon ) { var _class , _temp2 ; return _temp2 = _class = function ( _Component ) { _inherits ( SelectRender , _Component ) ; function SelectRender ( ) { var _temp , _this , _ret ; _classCallCheck ( this , SelectRender ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possibleConstructorReturn ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handleChange = function ( e ) { var value = e ; if ( _this . props . onChange ) { _this . props . onChange ( value ) ; } _this . setState ( { value : value } ) ; setTimeout ( function ( ) { _this . setState ( { editable : false } ) ; } , 0 ) ; } , _this . check = function ( ) { _this . setState ( { editable : false } ) ; if ( _this . props . onChange ) { _this . props . onChange ( _this . state . value ) ; } } , _this . edit = function ( ) { _this . setState ( { editable : true } ) ; } , _temp ) , _possibleConstructorReturn ( _this , _ret ) ; } SelectRender . prototype . render = function render ( ) { var _this2 = this ; var _state = this . state , value = _state . value , editable = _state . editable ; var _props = this . props , isclickTrigger = _props . isclickTrigger , dataSource = _props . dataSource ; var cellContent = "" ; if ( editable ) { cellContent = isclickTrigger ? _react2 [ "default" ] . createElement ( "div" , { className : "editable-cell-input-wrapper" } , _react2 [ "default" ] . createElement ( Select , _extends ( { } , this . props , { value : this . state . value , onBlur : function onBlur ( value ) { console . log ( value ) ; 
function sortBy ( arr , prop , desc ) { var props = [ ] , ret = [ ] , i = 0 , len = arr . length ; if ( typeof prop == 'string' ) { for ( ; i < len ; i ++ ) { var oI = arr [ i ] ; ( props [ i ] = new String ( oI && oI [ prop ] || '' ) ) . _obj = oI ; } } else if ( typeof prop == 'function' ) { for ( ; i < len ; i ++ ) { var _oI = arr [ i ] ; ( props [ i ] = new String ( _oI && prop ( _oI ) || '' ) ) . _obj = _oI ; } } else { throw '参数类型错误'; } props . sort ( ) ; for ( i = 0 ; i < len ; i ++ ) { ret [ i ] = props [ i ] . _obj ; } if ( desc ) ret . reverse ( ) ; return ret ; } 
function ObjectAssign ( obj ) { var b = obj instanceof Array ; var tagObj = b ? [ ] : { } ; if ( b ) { 
function sort ( Table , Icon ) { var _class , _temp , _initialiseProps ; var IconType = [ { 'type' : 'flat' , 'icon' : 'uf-symlist' , 'order' : 'flatscend' } , { 'type' : 'up' , 'icon' : 'uf-sortup' , 'order' : 'ascend' } , { 'type' : 'down' , 'icon' : 'uf-sortdown' , 'order' : 'descend' } ] ; return _temp = _class = function ( _Component ) { _inherits ( SortTable , _Component ) ; function SortTable ( props ) { _classCallCheck ( this , SortTable ) ; var _this2 = _possibleConstructorReturn ( this , _Component . call ( this , props ) ) ; _initialiseProps . call ( _this2 ) ; var flatColumns = [ ] ; _this2 . _toFlatColumn ( props . columns , - 1 , flatColumns ) ; _this2 . state = { data : _this2 . props . data , columns : props . columns , flatColumns : flatColumns } ; return _this2 ; } *column扁平化处理，适应多表头避免递归操作 * */ SortTable . prototype . _toFlatColumn = function _toFlatColumn ( columns ) { var parentIndex = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : - 1 ; var flatColumns = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : [ ] ; var _this = this ; var children = [ ] ; * column 当前的排序的列 * 当有的列不排序时，将该列的orderNum置为‘’，并动态的修改其他列的orderNum。 */ 
function filterColumn ( Table , Popover ) { var _class , _temp , _initialiseProps ; return _temp = _class = function ( _Component ) { _inherits ( FilterColumn , _Component ) ; function FilterColumn ( props ) { _classCallCheck ( this , FilterColumn ) ; var _this = _possibleConstructorReturn ( this , _Component . call ( this , props ) ) ; _initialiseProps . call ( _this ) ; var columns = props . columns ; _this . state = { columns : _this . setColumOrderByIndex ( ( 0 , _util . ObjectAssign ) ( columns ) ) , showModal : false , screenY : 0 } ; return _this ; } FilterColumn . prototype . componentWillReceiveProps = function componentWillReceiveProps ( nextProps ) { if ( nextProps . columns != this . props . columns ) { this . setState ( { columns : this . setColumOrderByIndex ( ( 0 , _util . ObjectAssign ) ( nextProps . columns ) ) } ) ; } this . setState ( { showModal : nextProps . showFilterPopover ? true : false } ) ; } ; FilterColumn . prototype . render = function render ( ) { var _props = this . props , data = _props . data , prefixCls = _props . prefixCls , scrollPro = _props . scroll ; var _state = this . state , columns = _state . columns , showModal = _state . showModal ; var locale = ( 0 , _tool . getComponentLocale ) ( this . props , this . context , 'Table' , function ( ) { return _i18n2 [ "default" ] ; } ) ; var _columns = [ ] , widthState = 0 , scroll = scrollPro ; columns . forEach ( function ( da ) { if ( da . ifshow ) { _columns . push ( da ) ; if ( da . width ) { widthState ++ ; } } } ) ; 
function renderInput ( Form , Input , Icon ) { var _class , _temp2 ; return _temp2 = _class = function ( _Component ) { _inherits ( InputRender , _Component ) ; function InputRender ( ) { var _temp , _this , _ret ; _classCallCheck ( this , InputRender ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possibleConstructorReturn ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handleChange = function ( e ) { var value = e ; _this . setState ( { value : value } ) ; } , _this . check = function ( ) { if ( typeof _this . flag === "undefined" || _this . flag ) { _this . props . check ( _this . flag , _this . obj ) ; _this . setState ( { editable : false } ) ; if ( _this . props . onChange ) { _this . props . onChange ( _this . state . value ) ; } _this . flag = undefined ; } } , _this . checkValidate = function ( flag , obj ) { _this . flag = flag ; _this . obj = obj ; } , _this . edit = function ( ) { _this . setState ( { editable : true } ) ; } , _this . handleKeydown = function ( event ) { if ( event . keyCode == 13 ) { _this . check ( ) ; } else if ( event . keyCode == 9 ) { } } , _this . formatCurrency = function ( money ) { if ( money && money != null && ! ! Number ( money ) ) { money = String ( money ) ; var left = money . split ( "." ) [ 0 ] , right = money . split ( "." ) [ 1 ] ; right = right ? right . length >= 2 ? "." + right . substr ( 0 , 2 ) : "." + right + "0" : ".00" ; var temp = left . split ( "" ) . reverse ( ) . join ( "" ) . match ( / (\d{1,3}) / g ) ; return ( Number ( money ) < 0 ? "-" : "" ) + temp . join ( "," ) . split ( "" ) . reverse ( ) . join ( "" ) + right ; } else if ( money === 0 ) { 
function renderCheckbox ( Checkbox , Icon ) { return function ( _Component ) { _inherits ( CheckboxRender , _Component ) ; function CheckboxRender ( ) { var _temp , _this , _ret ; _classCallCheck ( this , CheckboxRender ) ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return _ret = ( _temp = ( _this = _possibleConstructorReturn ( this , _Component . call . apply ( _Component , [ this ] . concat ( args ) ) ) , _this ) , _this . state = { value : _this . props . value , editable : false } , _this . handleChange = function ( e ) { var value = e . target . value ; _this . setState ( { value : value } ) ; } , _this . check = function ( ) { _this . setState ( { editable : false } ) ; if ( _this . props . onChange ) { _this . props . onChange ( _this . state . value ) ; } } , _this . edit = function ( ) { _this . setState ( { editable : true } ) ; } , _this . handleKeydown = function ( event ) { if ( event . keyCode == 13 ) { _this . check ( ) ; } } , _temp ) , _possibleConstructorReturn ( _this , _ret ) ; } CheckboxRender . prototype . render = function render ( ) { var _state = this . state , value = _state . value , editable = _state . editable ; var cellContent = "" ; if ( editable ) { cellContent = _react2 [ "default" ] . createElement ( "div" , { className : "editable-cell-input-wrapper" } , _react2 [ "default" ] . createElement ( Checkbox , { onChange : this . handleChange , onKeyDown : this . handleKeydown , onBlur : this . check , autoFocus : true , value : value } ) ) ; } else { cellContent = _react2 [ "default" ] . createElement ( "div" , { className : "editable-cell-text-wrapper" } , value || " " , _react2 [ "default" ] . createElement ( Icon , { type : "uf-pencil" , className : "editable-cell-icon" , onClick : this . edit } ) ) ; } return _react2 [ "default" ] . createElement ( "div" , { className : "editable-cell" } , cellContent ) ; } ; return CheckboxRender ; } ( _react . Component ) ; } 
function dragColumn ( Table ) { return function ( _Component ) { _inherits ( DragColumn , _Component ) ; function DragColumn ( props ) { _classCallCheck ( this , DragColumn ) ; var _this = _possibleConstructorReturn ( this , _Component . call ( this , props ) ) ; _this . setColumOrderByIndex = function ( _column ) { _column . forEach ( function ( da , i ) { da . dragIndex = i ; da . drgHover = false ; } ) ; return _column ; } ; _this . onDrop = function ( event , data ) { var dragSource = data . dragSource , dragTarg = data . dragTarg ; var columns = _this . state . columns ; var sourceIndex = - 1 , targetIndex = - 1 ; sourceIndex = columns . findIndex ( function ( da , i ) { return da . key == dragSource . key ; } ) ; targetIndex = columns . findIndex ( function ( da , i ) { return da . key == dragTarg . key ; } ) ; 
function minimize ( dfa ) { const table = dfa . getTransitionTable ( ) ; const allStates = Object . keys ( table ) ; const alphabet = dfa . getAlphabet ( ) ; const accepting = dfa . getAcceptingStateNumbers ( ) ; currentTransitionMap = { } ; const nonAccepting = new Set ( ) ; allStates . forEach ( state => { state = Number ( state ) ; const isAccepting = accepting . has ( state ) ; if ( isAccepting ) { currentTransitionMap [ state ] = accepting ; } else { nonAccepting . add ( state ) ; currentTransitionMap [ state ] = nonAccepting ; } } ) ; 
function areEquivalent ( s1 , s2 , table , alphabet ) { for ( const symbol of alphabet ) { if ( ! goToSameSet ( s1 , s2 , table , symbol ) ) { return false ; } } return true ; } 
function goToSameSet ( s1 , s2 , table , symbol ) { if ( ! currentTransitionMap [ s1 ] || ! currentTransitionMap [ s2 ] ) { return false ; } const originalTransitionS1 = table [ s1 ] [ symbol ] ; const originalTransitionS2 = table [ s2 ] [ symbol ] ; 
function isSimpleRange ( classRange ) { const { from , to } = classRange ; return ( from . codePoint >= DIGIT_0_CP && from . codePoint <= DIGIT_9_CP && to . codePoint >= DIGIT_0_CP && to . codePoint <= DIGIT_9_CP ) || ( from . codePoint >= UPPER_A_CP && from . codePoint <= UPPER_Z_CP && to . codePoint >= UPPER_A_CP && to . codePoint <= UPPER_Z_CP ) || ( from . codePoint >= LOWER_A_CP && from . codePoint <= LOWER_Z_CP && to . codePoint >= LOWER_A_CP && to . codePoint <= LOWER_Z_CP ) ; } 
function getRange ( text ) { const range = text . match ( / \d+ / g ) . map ( Number ) ; if ( Number . isFinite ( range [ 1 ] ) && range [ 1 ] < range [ 0 ] ) { throw new SyntaxError ( ` ${ text } ` ) ; } return range ; } 
function checkClassRange ( from , to ) { if ( from . kind === 'control' || to . kind === 'control' || ( ! isNaN ( from . codePoint ) && ! isNaN ( to . codePoint ) && from . codePoint > to . codePoint ) ) { throw new SyntaxError ( ` ${ from . value } ${ to . value } ` ) ; } } 
function Char ( value , kind , loc ) { let symbol ; let codePoint ; switch ( kind ) { case 'decimal' : { codePoint = Number ( value . slice ( 1 ) ) ; symbol = String . fromCodePoint ( codePoint ) ; break ; } case 'oct' : { codePoint = parseInt ( value . slice ( 1 ) , 8 ) ; symbol = String . fromCodePoint ( codePoint ) ; break ; } case 'hex' : case 'unicode' : { if ( value . lastIndexOf ( '\\u' ) > 0 ) { let [ lead , trail ] = value . split ( '\\u' ) . slice ( 1 ) ; lead = parseInt ( lead , 16 ) ; trail = parseInt ( trail , 16 ) ; codePoint = ( lead - 0xd800 ) * 0x400 + ( trail - 0xdc00 ) + 0x10000 ; symbol = String . fromCodePoint ( codePoint ) ; } else { const hex = value . slice ( 2 ) . replace ( '{' , '' ) ; codePoint = parseInt ( hex , 16 ) ; if ( codePoint > 0x10ffff ) { throw new SyntaxError ( ` ${ value } ` ) ; } symbol = String . fromCodePoint ( codePoint ) ; } break ; } case 'meta' : { switch ( value ) { case '\\t' : symbol = '\t' ; codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\n' : symbol = '\n' ; codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\r' : symbol = '\r' ; codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\v' : symbol = '\v' ; codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\f' : symbol = '\f' ; codePoint = symbol . codePointAt ( 0 ) ; break ; case '\\b' : symbol = '\b' ; codePoint = symbol . codePointAt ( 0 ) ; case '\\0' : symbol = '\0' ; codePoint = 0 ; case '.' : symbol = '.' ; codePoint = NaN ; break ; default : codePoint = NaN ; } break ; } case 'simple' : { symbol = value ; codePoint = symbol . codePointAt ( 0 ) ; break ; } } return Node ( { type : 'Char' , value , kind , symbol , codePoint , } , loc ) ; } 
function checkFlags ( flags ) { const seen = new Set ( ) ; for ( const flag of flags ) { if ( seen . has ( flag ) || ! validFlags . includes ( flag ) ) { throw new SyntaxError ( ` ${ flags } ` ) ; } seen . add ( flag ) ; } return flags . split ( '' ) . sort ( ) . join ( '' ) ; } 
function GroupRefOrDecChar ( text , textLoc ) { const reference = Number ( text . slice ( 1 ) ) ; if ( reference > 0 && reference <= capturingGroupsCount ) { return Node ( { type : 'Backreference' , kind : 'number' , number : reference , reference , } , textLoc ) ; } return Char ( text , 'decimal' , textLoc ) ; } 
function validateUnicodeGroupName ( name , state ) { const isUnicodeName = uRe . test ( name ) || ucpRe . test ( name ) ; const isUnicodeState = ( state === 'u' || state === 'xu' || state === 'u_class' ) ; if ( isUnicodeName && ! isUnicodeState ) { throw new SyntaxError ( ` ${ name } \` \` ` ) ; } } 
function NamedGroupRefOrChars ( text , textLoc ) { const groupName = text . slice ( 3 , - 1 ) ; if ( namedGroups . hasOwnProperty ( groupName ) ) { return Node ( { type : 'Backreference' , kind : 'name' , number : namedGroups [ groupName ] , reference : groupName , } , textLoc ) ; } 
function Node ( node , loc ) { if ( yy . options . captureLocations ) { node . loc = { source : parsingString . slice ( loc . startOffset , loc . endOffset ) , start : { line : loc . startLine , column : loc . startColumn , offset : loc . startOffset , } , end : { line : loc . endLine , column : loc . endColumn , offset : loc . endOffset , } , } ; } return node ; } 
function loc ( start , end ) { if ( ! yy . options . captureLocations ) { return null ; } return { startOffset : start . startOffset , endOffset : end . endOffset , startLine : start . startLine , endLine : end . endLine , startColumn : start . startColumn , endColumn : end . endColumn , } ; } 
function sortCharClass ( a , b ) { const aValue = getSortValue ( a ) ; const bValue = getSortValue ( b ) ; if ( aValue === bValue ) { 
function isMeta ( expression , value = null ) { return expression . type === 'Char' && expression . kind === 'meta' && ( value ? expression . value === value : / ^\\[dws]$ / i . test ( expression . value ) ) ; } 
function astTraverse ( root , options = { } ) { const pre = options . pre ; const post = options . post ; const skipProperty = options . skipProperty ; function visit ( node , parent , prop , idx ) { if ( ! node || typeof node . type !== 'string' ) { return ; } let res = undefined ; if ( pre ) { res = pre ( node , parent , prop , idx ) ; } if ( res !== false ) { 
function char ( c ) { const inState = new NFAState ( ) ; const outState = new NFAState ( { accepting : true , } ) ; return new NFA ( inState . addTransition ( c , outState ) , outState ) ; } 
function altPair ( first , second ) { first . out . accepting = false ; second . out . accepting = true ; first . out . addTransition ( EPSILON , second . in ) ; return new NFA ( first . in , second . out ) ; } 
function alt ( first , ... fragments ) { for ( let fragment of fragments ) { first = altPair ( first , fragment ) ; } return first ; } 
function orPair ( first , second ) { const inState = new NFAState ( ) ; const outState = new NFAState ( ) ; inState . addTransition ( EPSILON , first . in ) ; inState . addTransition ( EPSILON , second . in ) ; outState . accepting = true ; first . out . accepting = false ; second . out . accepting = false ; first . out . addTransition ( EPSILON , outState ) ; second . out . addTransition ( EPSILON , outState ) ; return new NFA ( inState , outState ) ; } 
function or ( first , ... fragments ) { for ( let fragment of fragments ) { first = orPair ( first , fragment ) ; } return first ; } 
function repExplicit ( fragment ) { const inState = new NFAState ( ) ; const outState = new NFAState ( { accepting : true , } ) ; 
function rep ( fragment ) { fragment . in . addTransition ( EPSILON , fragment . out ) ; fragment . out . addTransition ( EPSILON , fragment . in ) ; return fragment ; } 
function rewriteNumberRanges ( path ) { const { node } = path ; node . expressions . forEach ( ( expression , i ) => { if ( isFullNumberRange ( expression ) ) { path . getChild ( i ) . replace ( { type : 'Char' , value : '\\d' , kind : 'meta' , } ) ; } } ) ; } 
function rewriteWordRanges ( path , hasIFlag , hasUFlag ) { const { node } = path ; let numberPath = null ; let lowerCasePath = null ; let upperCasePath = null ; let underscorePath = null ; let u017fPath = null ; let u212aPath = null ; node . expressions . forEach ( ( expression , i ) => { 
function rewriteWhitespaceRanges ( path ) { const { node } = path ; let spacePath = null ; let tPath = null ; let nPath = null ; let rPath = null ; let fPath = null ; node . expressions . forEach ( ( expression , i ) => { 
function gen ( node ) { if ( node && ! generator [ node . type ] ) { throw new Error ( ` ${ node . type } ` ) ; } return node ? generator [ node . type ] ( node ) : '' ; } 
function preservesInCharClass ( value , index , parent ) { if ( value === '^' ) { 
function combineRepeatingPatternLeft ( alternative , child , index ) { const { node } = alternative ; const nbPossibleLengths = Math . ceil ( index / 2 ) ; let i = 0 ; while ( i < nbPossibleLengths ) { const startIndex = index - 2 * i - 1 ; let right , left ; if ( i === 0 ) { right = child ; left = alternative . getChild ( startIndex ) ; } else { right = NodePath . getForNode ( { type : 'Alternative' , expressions : [ ... node . expressions . slice ( index - i , index ) , child . node ] } ) ; left = NodePath . getForNode ( { type : 'Alternative' , expressions : [ ... node . expressions . slice ( startIndex , index - i ) ] } ) ; } if ( right . hasEqualSource ( left ) ) { for ( let j = 0 ; j < 2 * i + 1 ; j ++ ) { alternative . getChild ( startIndex ) . remove ( ) ; } child . replace ( { type : 'Repetition' , expression : i === 0 ? right . node : { type : 'Group' , capturing : false , expression : right . node } , quantifier : { type : 'Quantifier' , kind : 'Range' , from : 2 , to : 2 , greedy : true } } ) ; return startIndex ; } i ++ ; } return index ; } 
function combineWithPreviousRepetition ( alternative , child , index ) { const { node } = alternative ; let i = 0 ; while ( i < index ) { let previousChild = alternative . getChild ( i ) ; if ( previousChild . node . type === 'Repetition' && previousChild . node . quantifier . greedy ) { let left = previousChild . getChild ( ) ; let right ; if ( left . node . type === 'Group' && ! left . node . capturing ) { left = left . getChild ( ) ; } if ( i + 1 === index ) { right = child ; if ( right . node . type === 'Group' && ! right . node . capturing ) { right = right . getChild ( ) ; } } else { right = NodePath . getForNode ( { type : 'Alternative' , expressions : [ ... node . expressions . slice ( i + 1 , index + 1 ) ] } ) ; } if ( left . hasEqualSource ( right ) ) { for ( let j = i ; j < index ; j ++ ) { alternative . getChild ( i + 1 ) . remove ( ) ; } increaseQuantifierByOne ( previousChild . node . quantifier ) ; return i ; } } i ++ ; } return index ; } 
function combineRepetitionWithPrevious ( alternative , child , index ) { const { node } = alternative ; if ( child . node . type === 'Repetition' && child . node . quantifier . greedy ) { let right = child . getChild ( ) ; let left ; if ( right . node . type === 'Group' && ! right . node . capturing ) { right = right . getChild ( ) ; } let rightLength ; if ( right . node . type === 'Alternative' ) { rightLength = right . node . expressions . length ; left = NodePath . getForNode ( { type : 'Alternative' , expressions : [ ... node . expressions . slice ( index - rightLength , index ) ] } ) ; } else { rightLength = 1 ; left = alternative . getChild ( index - 1 ) ; if ( left . node . type === 'Group' && ! left . node . capturing ) { left = left . getChild ( ) ; } } if ( left . hasEqualSource ( right ) ) { for ( let j = index - rightLength ; j < index ; j ++ ) { alternative . getChild ( index - rightLength ) . remove ( ) ; } increaseQuantifierByOne ( child . node . quantifier ) ; return index - rightLength ; } } return index ; } 
function getSurrogatePairFromCodePoint ( codePoint ) { const lead = Math . floor ( ( codePoint - 0x10000 ) / 0x400 ) + 0xd800 ; const trail = ( codePoint - 0x10000 ) % 0x400 + 0xdc00 ; return { lead : lead . toString ( 16 ) , trail : trail . toString ( 16 ) } ; } 
function disjunctionToList ( node ) { if ( node . type !== 'Disjunction' ) { throw new TypeError ( ` ${ node . type } ` ) ; } const list = [ ] ; if ( node . left && node . left . type === 'Disjunction' ) { list . push ( ... disjunctionToList ( node . left ) , node . right ) ; } else { list . push ( node . left , node . right ) ; } return list ; } 
function increaseQuantifierByOne ( quantifier ) { if ( quantifier . kind === '*' ) { quantifier . kind = '+' ; } else if ( quantifier . kind === '+' ) { quantifier . kind = 'Range' ; quantifier . from = 2 ; delete quantifier . to ; } else if ( quantifier . kind === '?' ) { quantifier . kind = 'Range' ; quantifier . from = 1 ; quantifier . to = 2 ; } else if ( quantifier . kind === 'Range' ) { quantifier . from += 1 ; if ( quantifier . to ) { quantifier . to += 1 ; } } } 
function ScrollWrapper ( { children , ... props } ) { return ( < div { ... props } > < section style = { { ... style } } > < h1 > ⬇ Scroll Down ⬇</h1 > < / section > { children } < section style = { { ... style } } > < h1 > ⬆︎ Scroll up ⬆︎</h1> < / section > < / div > ) } 
function createFlow ( ) { fs . writeFileSync ( path . join ( process . cwd ( ) , pkg . main + '.flow' ) , createFlowFile ( ) , 'utf-8' , ) fs . writeFileSync ( path . join ( process . cwd ( ) , pkg . module + '.flow' ) , createFlowFile ( ) , 'utf-8' , ) } 
function install ( name , algorithm ) { if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } if ( typeof algorithm !== 'object' || algorithm === null || Array . isArray ( algorithm ) ) { throw new TypeError ( 'The algorithm object must be an object.' ) ; } if ( typeof algorithm . hash !== 'function' ) { throw new TypeError ( 'The hash property of the algorithm object should be a function.' ) ; } if ( typeof algorithm . verify !== 'function' ) { throw new TypeError ( 'The verify property of the algorithm object should be a function.' ) ; } if ( typeof algorithm . identifiers !== 'function' ) { throw new TypeError ( 'The identifiers property of the algorithm object should be a function.' ) ; } if ( funcs [ name ] !== undefined ) { throw new TypeError ( ` ${ name } ` ) ; } const idfs = algorithm . identifiers ( ) ; for ( const an of queue ) { if ( funcs [ an ] . identifiers ( ) . some ( idf => idfs . indexOf ( idf ) !== - 1 ) ) { throw new Error ( 'The identifiers property of the algorithm object clashes with the ones of another algorithm.' ) ; } } funcs [ name ] = Object . assign ( { } , algorithm ) ; Object . freeze ( funcs [ name ] ) ; queue . push ( name ) ; } 
function uninstall ( name ) { if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } const hashFunc = funcs [ name ] ; if ( ! hashFunc ) { throw new TypeError ( ` ${ name } ` ) ; } delete funcs [ name ] ; queue . splice ( queue . indexOf ( name ) , 1 ) ; } 
function use ( name ) { if ( name === undefined ) { if ( queue . length === 0 ) { throw new Error ( 'No algorithm installed.' ) ; } name = queue [ queue . length - 1 ] ; } else if ( typeof name !== 'string' || name === '' ) { throw new TypeError ( 'The algorithm name must be an non-empty string.' ) ; } const hashFunc = funcs [ name ] ; if ( ! hashFunc ) { throw new TypeError ( ` ${ name } ` ) ; } return hashFunc ; } 
function which ( hashstr ) { if ( typeof hashstr !== 'string' || hashstr === '' ) { throw new TypeError ( 'The hashstr param must be an non-empty string.' ) ; } const fields = hashstr . split ( '$' ) ; if ( fields . length < 3 || fields [ 0 ] !== '' ) { throw new TypeError ( 'The hashstr param provided is not in a supported format.' ) ; } const idf = fields [ 1 ] ; if ( queue . length === 0 ) { throw new Error ( 'No algorithm installed.' ) ; } for ( const name of queue ) { if ( funcs [ name ] . identifiers ( ) . indexOf ( idf ) === - 1 ) continue ; return name ; } return null ; } 
function verify ( hashstr , password ) { const name = which ( hashstr ) ; if ( name === null ) { throw new TypeError ( 'No compatible algorithm installed.' ) ; } return use ( name ) . verify ( hashstr , password ) ; } 
function replacePrimitive ( node , value , yaml ) { return yaml . substr ( 0 , node . start_mark . pointer ) + String ( value ) + yaml . substring ( node . end_mark . pointer ) ; } 
function replaceNode ( node , value , yaml ) { let indentedValue = indent ( value , node . start_mark . column ) ; let lineStart = node . start_mark . pointer - node . start_mark . column ; return yaml . substr ( 0 , lineStart ) + indentedValue + yaml . substring ( getNodeEndMark ( node ) . pointer ) ; } 
function getNodeEndMark ( ast ) { if ( isArray ( ast . value ) && ast . value . length ) { let lastItem = last ( ast . value ) ; if ( isArray ( lastItem ) && lastItem . length ) { return getNodeEndMark ( last ( lastItem ) ) ; } return getNodeEndMark ( lastItem ) ; } return ast . end_mark ; } 
function cleanDump ( value ) { let yaml = dump ( value ) . replace ( / \n$ / , '' ) ; if ( EOL !== '\n' ) { yaml = yaml . replace ( / \n / g , EOL ) ; } return yaml ; } 
function setNodeRemark ( ast , remark , yaml ) { let index = getNodeEndMark ( ast ) . pointer ; while ( index < yaml . length && yaml [ index ] !== '#' && yaml [ index ] !== EOL ) { ++ index ; } if ( EOL === yaml [ index ] || index === yaml . length ) { return yaml . substr ( 0 , index ) + ' # ' + remark + yaml . substring ( index ) ; } else { while ( index < yaml . length && ( yaml [ index ] === '#' || yaml [ index ] === ' ' ) ) { ++ index ; } let end = index ; while ( end < yaml . length && yaml [ end ] !== EOL ) { ++ end ; } return yaml . substr ( 0 , index ) + remark + yaml . substring ( end ) ; } } 
function getNode ( ast , path ) { if ( path . length ) { if ( ast . tag === MAP_TAG ) { let value = ast . value ; for ( let i = 0 ; i < value . length ; ++ i ) { let [ keyNode , valNode ] = value [ i ] ; if ( path [ 0 ] === keyNode . value ) { return getNode ( valNode , path . slice ( 1 ) ) ; } } return undefined ; } else if ( ast . tag === SEQ_TAG ) { return ast . value [ path [ 0 ] ] && getNode ( ast . value [ path [ 0 ] ] , path . slice ( 1 ) ) ; } } return ast ; } 
function updateSeq ( ast , newJson , yaml ) { var values = ( 0 , _jsYaml . load ) ( ( 0 , _yamlJs . serialize ) ( ast ) ) ; var min = Math . min ( values . length , newJson . length ) ; if ( values . length > min ) { for ( var i = values . length - 1 ; i >= min ; -- i ) { yaml = removeArrayElement ( ast . value [ i ] , yaml ) ; } } else if ( newJson . length > min ) { yaml = insertAfterNode ( ast , cleanDump ( newJson . slice ( min ) ) , yaml ) ; } for ( var i = min - 1 ; i >= 0 ; -- i ) { yaml = changeArrayElement ( ast . value [ i ] , cleanDump ( newJson [ i ] ) , yaml ) ; } return yaml ; } 
function updateMap ( ast , newJson , json , yaml ) { 
function insertAfterNode ( node , value , yaml ) { var indentedValue = indent ( value , node . start_mark . column ) ; return yaml . substr ( 0 , getNodeEndMark ( node ) . pointer ) + _os . EOL + indentedValue + yaml . substring ( getNodeEndMark ( node ) . pointer ) ; } 
function removeArrayElement ( node , yaml ) { var index = node . start_mark . pointer - node . start_mark . column - 1 ; return yaml . substr ( 0 , index ) + yaml . substring ( getNodeEndMark ( node ) . pointer ) ; } 
function changeArrayElement ( node , value , yaml ) { var indentedValue = indent ( value , node . start_mark . column ) ; 
function getNodeEndMark ( _x ) { var _again = true ; _function : while ( _again ) { var ast = _x ; _again = false ; if ( ( 0 , _lodash . isArray ) ( ast . value ) && ast . value . length ) { var lastItem = ( 0 , _lodash . last ) ( ast . value ) ; if ( ( 0 , _lodash . isArray ) ( lastItem ) && lastItem . length ) { _x = ( 0 , _lodash . last ) ( lastItem ) ; _again = true ; lastItem = undefined ; continue _function ; } _x = lastItem ; _again = true ; lastItem = undefined ; continue _function ; } return ast . end_mark ; } } 
function indent ( str , depth ) { return str . split ( _os . EOL ) . filter ( function ( line ) { return line ; } ) . map ( function ( line ) { return ( 0 , _lodash . repeat ) ( SPACE , depth ) + line ; } ) . join ( _os . EOL ) ; } 
function cleanDump ( value ) { var yaml = ( 0 , _jsYaml . dump ) ( value ) . replace ( / \n$ / , '' ) ; if ( _os . EOL !== '\n' ) { yaml = yaml . replace ( / \n / g , _os . EOL ) ; } return yaml ; } 
function getNodeRemark ( ast , yaml ) { var index = getNodeEndMark ( ast ) . pointer ; while ( index < yaml . length && yaml [ index ] !== '#' && yaml [ index ] !== _os . EOL ) { ++ index ; } if ( _os . EOL === yaml [ index ] || index === yaml . length ) { return '' ; } else { while ( index < yaml . length && ( yaml [ index ] === '#' || yaml [ index ] === ' ' ) ) { ++ index ; } var end = index ; while ( end < yaml . length && yaml [ end ] !== _os . EOL ) { ++ end ; } return yaml . substring ( index , end ) ; } } 
function getNode ( _x2 , _x3 ) { var _left ; var _again2 = true ; _function2 : while ( _again2 ) { var ast = _x2 , path = _x3 ; _again2 = false ; if ( path . length ) { if ( ast . tag === MAP_TAG ) { var value = ast . value ; for ( var i = 0 ; i < value . length ; ++ i ) { var _value$i = _slicedToArray ( value [ i ] , 2 ) ; var keyNode = _value$i [ 0 ] ; var valNode = _value$i [ 1 ] ; if ( path [ 0 ] === keyNode . value ) { _x2 = valNode ; _x3 = path . slice ( 1 ) ; _again2 = true ; value = i = _value$i = keyNode = valNode = undefined ; continue _function2 ; } } return undefined ; } else if ( ast . tag === SEQ_TAG ) { if ( ! ( _left = ast . value [ path [ 0 ] ] ) ) { return _left ; } _x2 = ast . value [ path [ 0 ] ] ; _x3 = path . slice ( 1 ) ; _again2 = true ; value = i = _value$i = keyNode = valNode = undefined ; continue _function2 ; } } return ast ; } } 
function getRect ( el ) { if ( el && typeof ( el . getBoundingClientRect ) === 'function' ) { return el . getBoundingClientRect ( ) ; } if ( el === window || el === document ) { return { top : 0 , left : 0 , bottom : window . innerHeight , height : window . innerHeight , width : window . innerWidth , right : window . innerWidth } ; } return { top : 0 , left : 0 , right : 0 , bottom : 0 , width : 0 , height : 0 } ; } 
function sanitizeProps ( props , toRemove ) { props = { ... props } ; for ( let i = 0 , l = toRemove . length ; i < l ; i += 1 ) { delete props [ toRemove [ i ] ] } return props ; } 
function mockPrepareHosts ( command ) { 
function getServers ( ) { var interfaces = os . networkInterfaces ( ) var result = [ ] for ( var key in interfaces ) { var addresses = interfaces [ key ] for ( var i = addresses . length ; i -- ; ) { var address = addresses [ i ] if ( address . family === 'IPv4' && ! address . internal ) { var subnet = ip . subnet ( address . address , address . netmask ) var current = ip . toLong ( subnet . firstAddress ) var last = ip . toLong ( subnet . lastAddress ) - 1 while ( current ++ < last ) result . push ( ip . fromLong ( current ) ) } } } return result } 
function pingServer ( address ) { return new Promise ( function ( resolve ) { var socket = new net . Socket ( ) socket . setTimeout ( 1000 , close ) socket . connect ( 80 , address , close ) socket . once ( 'error' , close ) function close ( ) { socket . destroy ( ) resolve ( address ) } } ) } 
function parseAll ( data ) { if ( ! data || ! data [ 0 ] ) { return [ ] } if ( process . platform . includes ( 'linux' ) ) { var rows = data [ 0 ] . split ( '\n' ) return rows . map ( function ( row ) { return parseLinux ( row , servers ) } ) . filter ( Boolean ) } else if ( process . platform . includes ( 'win32' ) ) { var winRows = data [ 0 ] . split ( '\n' ) . splice ( 1 ) return winRows . map ( function ( row ) { return parseWin32 ( row , servers ) } ) . filter ( Boolean ) } return data [ 0 ] . trim ( ) . split ( '\n' ) . map ( function ( row ) { return parseRow ( row , servers ) } ) . filter ( Boolean ) } 
function parseOne ( data ) { if ( ! data || ! data [ 0 ] ) { return } if ( process . platform . includes ( 'linux' ) ) { 
function createWebpack ( { alias = { } , context , name = 'index' } ) { const pkgJson = require ( path . join ( context , 'package.json' ) ) ; const ENV = process . env . NODE_ENV || 'development' ; const isProd = ENV === 'production' ; const hasPublic = fs . existsSync ( path . join ( context , 'public' ) ) ; const plugins = hasPublic ? [ new CopyWebpackPlugin ( [ { from : 'public' } ] ) ] : [ ] ; return { context , devtool : isProd ? 'source-map' : 'cheap-eval-source-map' , entry : [ ` ${ name } ` , isProd ? null : 'webpack-plugin-serve/client' ] . filter ( ( entry ) => entry ) , mode : ENV , output : { chunkFilename : ` ` , filename : ` ` , globalObject : ` ` , path : path . join ( context , 'build' ) } , resolve : { alias : { ... alias , 'koa' : 'empty' , 'koa-websocket' : 'empty' , 'node-lmdb' : 'empty' , 'package-json' : 'empty' , 'snappy' : 'empty' } , extensions : [ '.js' , '.jsx' , '.ts' , '.tsx' ] } , module : { rules : [ { test : / \.(js|ts|tsx)$ / , exclude : / (node_modules) / , use : [ require . resolve ( 'thread-loader' ) , { loader : require . resolve ( 'babel-loader' ) , options : require ( '@polkadot/dev-react/config/babel' ) } ] } , { test : [ / \.bmp$ / , / \.gif$ / , / \.jpe?g$ / , / \.png$ / ] , use : [ { loader : require . resolve ( 'url-loader' ) , options : { limit : 10000 , name : 'static/[name].[hash:8].[ext]' } } ] } , { test : [ / \.eot$ / , / \.ttf$ / , / \.svg$ / , / \.woff$ / , / \.woff2$ / ] , use : [ { loader : require . resolve ( 'file-loader' ) , options : { name : 'static/[name].[hash:8].[ext]' } } ] } ] } , node : { child_process : 'empty' , dgram : 'empty' , fs : 'empty' , net : 'empty' , tls : 'empty' } , optimization : { runtimeChunk : 'single' , splitChunks : { cacheGroups : { vendorOther : { chunks : 'initial' , enforce : true , name : 'vendor' , test : / node_modules\/(asn1|bn\.js|buffer|cuint|elliptic|lodash|moment|readable-stream|rxjs) / } , vendorReact : { chunks : 'initial' , enforce : true , name : 'react' , test : / node_modules\/(i18next|react) / } } } } , performance : { hints : false } , plugins : plugins . concat ( [ new webpack . IgnorePlugin ( / ^\.\/locale$ / , / moment$ / ) , new webpack . DefinePlugin ( { 'process.env' : { NODE_ENV : JSON . stringify ( ENV ) , VERSION : JSON . stringify ( pkgJson . version ) , DEBUG : JSON . stringify ( DEBUG ) } } ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( context , ` ${ hasPublic ? 'public/' : '' } ${ name } ` ) , PAGE_TITLE : 'PRE Light Client' } ) , new webpack . optimize . SplitChunksPlugin ( ) , new WebpackPluginServe ( { liveReload : true , port : 3000 , static : path . join ( process . cwd ( ) , '/build' ) } ) ] ) , watch : ! isProd } ; } 
function timePassed ( t ) { if ( t > 0 ) this . find ( ".wcp-time-current" ) . text ( parseTime ( t , this . vlc . length ) ) ; else if ( this . find ( ".wcp-time-current" ) . text ( ) != "" && this . find ( ".wcp-time-total" ) . text ( ) == "" ) this . find ( ".wcp-time-current" ) . text ( "" ) ; if ( typeof opts [ this . context ] . subtitles === 'undefined' ) opts [ this . context ] . subtitles = [ ] ; if ( opts [ this . context ] . subtitles . length > 0 ) { 
function singleResize ( width , height ) { this . canvas . width = width ; this . canvas . height = height ; var container = $ ( this . context ) , canvasParent = $ ( this . canvas ) . parent ( ) [ 0 ] ; if ( opts [ this . context ] . aspectRatio != "Default" && opts [ this . context ] . aspectRatio . indexOf ( ":" ) > - 1 ) { var res = opts [ this . context ] . aspectRatio . split ( ":" ) ; var ratio = gcd ( this . canvas . width , this . canvas . height ) ; } var destAspect = container . width ( ) / container . height ( ) ; if ( ratio ) var sourceAspect = ( ratio * parseFloat ( res [ 0 ] ) ) / ( ratio * parseFloat ( res [ 1 ] ) ) ; else var sourceAspect = this . canvas . width / this . canvas . height ; if ( opts [ this . context ] . crop != "Default" && opts [ this . context ] . crop . indexOf ( ":" ) > - 1 ) { var res = opts [ this . context ] . crop . split ( ":" ) ; var ratio = gcd ( this . canvas . width , this . canvas . height ) ; var sourceAspect = ( ratio * parseFloat ( res [ 0 ] ) ) / ( ratio * parseFloat ( res [ 1 ] ) ) ; } var cond = destAspect > sourceAspect ; if ( opts [ this . context ] . crop != "Default" && opts [ this . context ] . crop . indexOf ( ":" ) > - 1 ) { if ( cond ) { canvasParent . style . height = "100%" ; canvasParent . style . width = ( ( ( container . height ( ) * sourceAspect ) / container . width ( ) ) * 100 ) + "%" ; } else { canvasParent . style . height = ( ( ( container . width ( ) / sourceAspect ) / container . height ( ) ) * 100 ) + "%" ; canvasParent . style . width = "100%" ; } var sourceAspect = this . canvas . width / this . canvas . height ; futureWidth = ( ( ( canvasParent . offsetHeight * sourceAspect ) / canvasParent . offsetWidth ) * canvasParent . offsetWidth ) ; if ( futureWidth < canvasParent . offsetWidth ) { var sourceAspect = this . canvas . height / this . canvas . width ; this . canvas . style . width = canvasParent . offsetWidth + "px" ; this . canvas . style . height = ( ( ( canvasParent . offsetWidth * sourceAspect ) / canvasParent . offsetHeight ) * canvasParent . offsetHeight ) + "px" ; } else { this . canvas . style . height = canvasParent . offsetHeight + "px" ; this . canvas . style . width = ( ( ( canvasParent . offsetHeight * sourceAspect ) / canvasParent . offsetWidth ) * canvasParent . offsetWidth ) + "px" ; } } else { if ( cond ) { canvasParent . style . height = ( 100 * opts [ this . context ] . zoom ) + "%" ; canvasParent . style . width = ( ( ( container . height ( ) * sourceAspect ) / container . width ( ) ) * 100 * opts [ this . context ] . zoom ) + "%" ; } else { canvasParent . style . height = ( ( ( container . width ( ) / sourceAspect ) / container . height ( ) ) * 100 * opts [ this . context ] . zoom ) + "%" ; canvasParent . style . width = ( 100 * opts [ this . context ] . zoom ) + "%" ; } this . canvas . style . height = "100%" ; this . canvas . style . width = "100%" ; } } 
function ( opts ) { var fs = require ( 'fs' ) ; if ( opts . configFile ) { try { config = JSON . parse ( fs . readFileSync ( opts . configFile , 'utf-8' ) ) ; if ( config ) { for ( var key in opts ) { if ( typeof opts [ key ] !== 'undefined' ) { config [ key ] = opts [ key ] ; } } } opts = config ; } catch ( e ) { throw new Error ( 'Could not read or parse configuration file - ' + e ) ; } delete opts . configFile ; } return opts ; } 
function ( opts ) { opts . selenium = opts . selenium || 'http://localhost:4444/wd/hub' ; if ( typeof opts . selenium === 'string' ) { if ( opts . selenium === 'ondemand.saucelabs.com' || opts . selenium === 'hub.browserstack.com' ) { opts . selenium = opts . selenium + '/wd/hub' ; } if ( ! opts . selenium . match ( / ^http(s)?:\/\/ / ) ) { opts . selenium = 'http://' + opts . selenium } var url = require ( 'url' ) ; opts . selenium = url . parse ( opts . selenium ) ; } if ( typeof opts . username !== 'undefined' ) { opts . selenium . user = opts . username ; } if ( typeof opts . accesskey !== 'undefined' ) { opts . selenium . pwd = opts . accesskey ; } if ( typeof opts . selenium . port !== 'number' ) { opts . selenium . port = parseInt ( opts . selenium . port , 10 ) ; } if ( isNaN ( opts . selenium . port ) ) { opts . selenium . port = null ; } return opts ; } 
function ( opts ) { var browserConfig = { } ; 
function ( opts ) { opts . accesskey = opts . accesskey || opts . password ; delete opts . password ; if ( opts . selenium . hostname . match ( / ondemand.saucelabs.com / ) ) { opts . SAUCE_USERNAME = opts . SAUCE_USERNAME || opts . username ; opts . SAUCE_ACCESSKEY = opts . SAUCE_ACCESSKEY || opts . accesskey ; if ( typeof opts . SAUCE_USERNAME !== 'undefined' && typeof opts . SAUCE_ACCESSKEY !== 'undefined' ) { opts . selenium . auth = opts . SAUCE_USERNAME + ':' + opts . SAUCE_ACCESSKEY ; delete opts . SAUCE_ACCESSKEY ; delete opts . SAUCE_USERNAME ; } } else if ( opts . selenium . hostname . match ( / hub.browserstack.com / ) ) { opts . BROWSERSTACK_USERNAME = opts . BROWSERSTACK_USERNAME || opts . username ; opts . BROWSERSTACK_KEY = opts . BROWSERSTACK_KEY || opts . accesskey ; if ( typeof opts . BROWSERSTACK_USERNAME !== 'undefined' ) { opts . browsers . forEach ( function ( browser ) { browser [ 'browserstack.user' ] = opts . BROWSERSTACK_USERNAME ; browser [ 'browserstack.key' ] = opts . BROWSERSTACK_KEY ; } ) ; delete opts . BROWSERSTACK_USERNAME ; delete opts . BROWSERSTACK_KEY ; delete opts . selenium . user ; delete opts . selenium . pwd ; } } delete opts . username ; delete opts . password ; return opts ; } 
function ( opts ) { if ( opts . preScriptFile ) { var path = require ( 'path' ) ; opts . preScript = require ( path . resolve ( opts . preScriptFile ) ) ; delete opts . preScriptFile ; } opts . preScript = opts . preScript || function ( browser ) { return ; } ; return opts ; } 
function ( opts ) { opts . actions = opts . actions || 'scroll' ; if ( typeof opts . actions === 'string' ) { opts . actions = opts . actions . split ( / [,;] / ) ; } else if ( typeof opts . actions === 'function' ) { opts . actions = [ opts . actions ] ; } return opts ; } 
function ( opts ) { opts . metrics = opts . metrics || require ( './metrics' ) . builtIns ; if ( typeof opts . metrics === 'string' ) { opts . metrics = opts . metrics . split ( / [,;] / ) ; } else if ( typeof opts . metrics === 'function' ) { opts . metrics = [ opts . metrics ] ; } return opts ; } 
function ScrollAction ( opt_callback , opt_distance_func ) { var self = this ; this . beginMeasuringHook = function ( ) { } this . endMeasuringHook = function ( ) { } this . callback_ = opt_callback ; this . distance_func_ = opt_distance_func ; } 
function mockXhrGenerator ( file ) { var xhr = new MockHttpRequest ( ) ; xhr . upload = { } ; xhr . onsend = function ( ) { if ( xhr . upload . onloadstart ) { xhr . upload . onloadstart ( ) ; } var total = file && file . size || 1024 , done = 0 ; function start ( ) { setTimeout ( progress , 1000 ) ; } function progress ( ) { xhr . upload . onprogress ( { total : total , loaded : done } ) ; if ( done < total ) { setTimeout ( progress , 200 ) ; done = Math . min ( total , done + 254000 ) ; } else if ( ! file . abort ) { setTimeout ( finish , 1000 ) ; } } function finish ( ) { xhr . receive ( 200 , '{"message":"OK"}' ) ; } start ( ) ; } ; return xhr ; } 
function limitUpdate ( limit , update ) { la ( check . fn ( limit ) , 'expected limit function' , limit ) const filter = R . filter ( version => limit ( update . name , version ) ) return R . evolve ( { versions : filter } ) ( update ) } 
function filterVersions ( fromVersion , toVersion ) { var diff = semver . diff ( fromVersion , toVersion ) 
function getLocalModuleVersion ( name ) { check . verify . string ( name , 'missing name string' ) try { var filename = path . join ( 'node_modules' , name , 'package.json' ) var contents = fs . readFileSync ( filename , 'utf-8' ) var pkg = JSON . parse ( contents ) return pkg . version } catch ( error ) { console . error ( 'could not fetch version for local module' , name ) console . error ( error ) return null } } 
function cleanVersionPair ( nameVersion ) { check . verify . array ( nameVersion , 'expected an array' ) console . assert ( nameVersion . length === 2 , 'expected 2 items, name and version ' + nameVersion ) var name = nameVersion [ 0 ] check . verify . string ( name , 'could not get module name from ' + nameVersion ) var version = nameVersion [ 1 ] check . verify . string ( version , 'could not get module version from ' + nameVersion ) version = cleanVersion ( version , name ) if ( ! version ) { return } nameVersion [ 1 ] = version return nameVersion } 
function fetchVersions ( options , nameVersion ) { 
function nextVersions ( options , nameVersionPairs , checkLatestOnly ) { check . verify . object ( options , 'expected object with options' ) check . verify . array ( nameVersionPairs , 'expected array' ) nameVersionPairs = cleanVersions ( nameVersionPairs ) const verbose = verboseLog ( options ) verbose ( 'checking NPM registry' ) var MAX_CHECK_TIMEOUT = options . checkVersionTimeout || 10000 var fetchPromises = nameVersionPairs . map ( fetchVersions . bind ( null , options ) ) var fetchAllPromise = q . all ( fetchPromises ) . timeout ( MAX_CHECK_TIMEOUT , 'timed out waiting for NPM after ' + MAX_CHECK_TIMEOUT + 'ms' ) return fetchAllPromise . then ( _ . partial ( filterFetchedVersions , checkLatestOnly ) , q . reject ) } 
function revert ( moduleName ) { if ( moduleName ) { console . log ( 'reverting module' , JSON . stringify ( moduleName ) ) } var toCheck = getDependenciesToCheck ( { } , moduleName ) debug ( 'need to check' ) debug ( toCheck ) var installPromises = toCheck . map ( function ( info ) { la ( isRevertInfo ( info ) , 'invalid revert info' , info ) return installModule . bind ( null , { name : info . name , version : info . version , tldr : false } ) } ) return installPromises . reduce ( q . when , q ( ) ) } 
function installModule ( options , results ) { check . verify . object ( options , 'missing options' ) la ( check . unemptyString ( options . name ) , 'expected module name string' , options . name , 'all options' , options ) check . verify . string ( options . version , 'expected version string' ) if ( options . keep ) { console . assert ( typeof options . keep === 'boolean' , 'invalid keep' ) } if ( results ) { check . verify . array ( results , 'missing results' ) } var cmd = formInstallCommand ( [ [ { name : options . name , version : options . version , works : true } ] ] ) check . verify . unemptyString ( cmd , 'could not form install command' ) cmd = cmd . trim ( ) var moduleVersion = options . name + '@' + options . version var npm if ( options . keep ) { console . log ( ' ' , cmd ) var args = cmd . split ( ' ' ) args . shift ( ) args . push ( '--save-exact' ) npm = spawn ( NPM_PATH , args ) } else { if ( ! options . tldr ) { console . log ( ' installing' , moduleVersion ) } npm = spawn ( NPM_PATH , [ 'install' , moduleVersion ] ) } // eslint-disable-next-line no-unused-vars var testOutput = '' var testErrors = '' npm . stdout . setEncoding ( 'utf-8' ) npm . stderr . setEncoding ( 'utf-8' ) function hasError ( str ) { return / error / i . test ( str ) } npm . stdout . on ( 'data' , function ( data ) { if ( hasError ( data ) ) { console . log ( 'stdout:' , data ) } testOutput += data } ) npm . stderr . on ( 'data' , function ( data ) { if ( hasError ( data ) ) { console . log ( 'stderr:' , data ) } testErrors += data } ) npm . on ( 'error' , function ( err ) { console . error ( 'error:' , err ) testErrors += err . toString ( ) } ) var deferred = q . defer ( ) npm . on ( 'exit' , function ( code ) { if ( code ) { console . error ( 'npm returned' , code ) console . error ( 'errors:\n' + testErrors ) deferred . reject ( { code : code , errors : testErrors } ) } else { if ( ! options . tldr ) { console . log ( moduleVersion , 'installed successfully' ) } deferred . resolve ( results ) } } ) return deferred . promise } 
function available ( moduleName , options ) { options = options || { } var toCheck = getDependenciesToCheck ( options , moduleName ) la ( check . array ( toCheck ) , 'expected object of deps to check, was' , toCheck ) var toCheckHash = _ . zipObject ( _ . pluck ( toCheck , 'name' ) , _ . pluck ( toCheck , 'version' ) ) log ( 'need to check these dependencies' ) log ( toCheckHash ) var nextVersionsPromise = nextVersions ( options , toCheck ) return nextVersionsPromise . then ( function ( info ) { return reportAvailable ( info , toCheckHash , options ) } , function ( error ) { console . error ( 'Could not fetch available modules\n' , error ) } ) } 
function checkAllUpdates ( options ) { options = options || { } var moduleName = options . names var checkLatestOnly = ! ! options . latest var checkCommand = options . testCommand if ( checkCommand ) { verify . unemptyString ( checkCommand , 'invalid test command ' + checkCommand ) } var all = options . all if ( all ) { checkLatestOnly = true console . log ( 'will check only latest versions because testing all' ) } if ( check . string ( options . without ) ) { options . without = [ options . without ] } if ( check . string ( moduleName ) ) { moduleName = [ moduleName ] } checkLatestOnly = ! ! checkLatestOnly if ( checkCommand ) { check . verify . string ( checkCommand , 'expected string test command' ) } var toCheck = getDependenciesToCheck ( options , moduleName ) check . verify . array ( toCheck , 'dependencies to check should be an array' ) makeSureValidModule ( moduleName , toCheck ) var testVersionsBound = testVersions . bind ( null , { modules : toCheck , command : checkCommand , all : all , color : options . color , keep : options . keep , allowed : options . allow || options . allowed , tldr : options . tldr , type : options . type , limit : options . limit } ) return isOnline ( ) . then ( function ( online ) { if ( ! online ) { throw new Error ( 'Need to be online to check new modules' ) } } ) . then ( function ( ) { if ( isSingleSpecificVersion ( moduleName ) ) { var nv = nameVersionParser ( moduleName [ 0 ] ) console . log ( 'checking only specific:' , nv . name , nv . version ) var list = [ { name : nv . name , versions : [ nv . version ] } ] return testVersionsBound ( list ) } else { var nextVersionsPromise = nextVersions ( options , toCheck , checkLatestOnly ) return nextVersionsPromise . then ( testVersionsBound ) } } ) } 
function printCurrentModules ( infos ) { check . verify . array ( infos , 'expected array of modules' ) var modules = [ ] infos . forEach ( function ( nameVersionArray ) { check . verify . array ( nameVersionArray , 'expected name version in ' + modules ) modules . push ( { name : nameVersionArray [ 0 ] , version : nameVersionArray [ 1 ] } ) } ) print ( modules ) } 
function serializeMethods ( o ) { var v ; for ( var k in o ) { v = o [ k ] ; if ( _ . isObject ( v ) && ! _ . isArray ( v ) && ! _ . isFunction ( v ) ) { serializeMethods ( v ) ; } else { o [ k ] = serializeFunctions ( v ) ; } } } 
function getArpTable ( callback ) { var arp = spawn ( 'arp' , [ '-a' ] ) var arpStr = [ ] arp . stdout . setEncoding ( 'utf8' ) arp . stdout . on ( 'data' , function ( data ) { arpStr . push ( data ) } ) arp . on ( 'close' , function ( x ) { callback ( null , parseArpTable ( arpStr ) ) 
function parseArpTable ( arpStr ) { var arpArr = [ ] var arpt = arpStr . join ( ) arpt = arpt . split ( '\n' ) var x for ( x in arpt ) { var entry = arpt [ x ] var arpObj = { } 
function storageFor ( key , modelName , options = { } ) { if ( arguments . length === 2 && typeof modelName === 'object' ) { options = modelName ; modelName = null ; } assert ( 'The options argument must be an object' , typeof options === 'object' ) ; 
function createStorage ( context , key , modelKey , options ) { const owner = getOwner ( context ) ; const factoryType = 'storage' ; const storageFactory = ` ${ factoryType } ${ key } ` ; let storageKey ; owner . registerOptionsForType ( factoryType , { instantiate : false } ) ; if ( options . legacyKey ) { deprecate ( 'Using legacyKey has been deprecated and will be removed in version 2.0.0' , false , { id : 'ember-local-storage.storageFor.options.legacyKey' , until : '2.0.0' , url : 'https://github.com/funkensturm/ember-local-storage#deprecations' } ) ; storageKey = options . legacyKey ; } else { storageKey = modelKey ? ` ${ storageFactory } ${ modelKey } ` : storageFactory ; } storageKey = _buildKey ( context , storageKey ) ; const initialState = { } , defaultState = { _storageKey : storageKey } , StorageFactory = owner . lookup ( storageFactory ) ; if ( ! StorageFactory ) { throw new TypeError ( ` ${ storageFactory } ` ) ; } if ( typeof ( StorageFactory . initialState ) === 'function' ) { initialState . _initialContent = StorageFactory . initialState . call ( context ) ; } else if ( StorageFactory . initialState ) { throw new TypeError ( 'initialState property must be a function' ) ; } assign ( initialState , defaultState ) ; if ( StorageFactory . create ) { return StorageFactory . create ( initialState ) ; } return Ember . Object . create ( StorageFactory ) ; } 
function _getNamespace ( appConfig , addonConfig ) { 
function _buildKey ( context , key ) { let appConfig = getOwner ( context ) . resolveRegistration ( 'config:environment' ) ; let addonConfig = appConfig && appConfig [ 'ember-local-storage' ] || { } ; let namespace = _getNamespace ( appConfig , addonConfig ) ; let delimiter = addonConfig . keyDelimiter || ':' ; return namespace ? ` ${ namespace } ${ delimiter } ${ key } ` : key ; } 
function buildXmlInput ( options ) { debug ( 'buildXmlInput' , options ) ; var data = { } , root ; var params = options . params || { } ; root = data [ options . opType + 'Request' ] = [ ] ; 
function _toJson ( next ) { options . xmlConverter ( response . body , options , function ( error , data ) { if ( error ) return next ( error ) ; debug ( 'Parsed XML' , data ) ; timer ( 'time to parsed XML' , Date . now ( ) - _startTime ) ; next ( null , data ) ; } ) ; } 
function itemsCallback ( error , itemsResponse ) { if ( error ) throw error ; var items = itemsResponse . searchResult . item ; console . log ( 'Found' , items . length , 'items' ) ; for ( var i = 0 ; i < items . length ; i ++ ) { console . log ( '- ' + items [ i ] . title ) ; } } 
function _isArrayOfValuePairs ( el ) { if ( _ . isArray ( el ) ) { if ( _ . all ( el , _isValuePair ) ) return true ; } return false ; } 
function _isValuePair ( el ) { if ( _ . isObject ( el ) && _ . size ( el ) === 2 ) { var keys = _ . keys ( el ) ; if ( new RegExp ( / ^@ / ) . test ( keys [ 0 ] ) && keys [ 1 ] === '__value__' ) { return true ; } } return false ; } 
function _canFlattenKey ( key , requestContext ) { 
function _flattenSillyArray ( parentObj , key , requestContext ) { 
function getExe ( ) { switch ( process . platform ) { case "darwin" : return "mkcert-" + MKCERT_VERSION + "-darwin-amd64" case "linux" : return "mkcert-" + MKCERT_VERSION + "-linux-amd64" case "win32" : return "mkcert-" + MKCERT_VERSION + "-windows-amd64.exe" default : console . warn ( "Cannot generate the localhost certificate on your " + "platform. Please, consider contacting the developer if you can help." ) process . exit ( 0 ) } } 
function download ( url , path ) { console . log ( "Downloading the mkcert executable..." ) const file = fs . createWriteStream ( path ) return new Promise ( resolve => { function get ( url , file ) { https . get ( url , ( response ) => { if ( response . statusCode === 302 ) get ( response . headers . location , file ) else response . pipe ( file ) . on ( "finish" , resolve ) } ) } get ( url , file ) } ) } 
function mkcert ( appDataPath , exe ) { const logPath = path . join ( appDataPath , "mkcert.log" ) const errPath = path . join ( appDataPath , "mkcert.err" ) 
function remove ( appDataPath = CERT_PATH ) { if ( fs . existsSync ( appDataPath ) ) { fs . readdirSync ( appDataPath ) . forEach ( file => fs . unlinkSync ( path . join ( appDataPath , file ) ) ) fs . rmdirSync ( appDataPath ) } } 
function isBreakingChange ( { header , body , footer } ) { const re = / ^BREAKING\s+CHANGES?:\s+ / ; return ( re . test ( header . subject ) || re . test ( body || '' ) || re . test ( footer || '' ) ) ; } 
function track ( trackingFn , options = { sendReturnValue : true } ) { let decorator = function ( target , name , descriptor ) { const hasDescriptor = typeof descriptor . value !== "undefined" ; const fn = hasDescriptor ? descriptor . value : target ; function trackDecorator ( ) { let fnReturnValue = fn . apply ( this , arguments ) , value = null ; if ( options . sendReturnValue ) { value = fnReturnValue ; } trackEvent ( typeof trackingFn === "string" ? Object . assign ( { name : trackingFn , data : value } , options ) : trackingFn . apply ( this , [ value ] ) ) ; return fnReturnValue ; } ; if ( hasDescriptor ) { descriptor . value = trackDecorator ; } else { target = trackDecorator ; } } ; decorator . sendReturnValue = function ( value = true ) { options . sendReturnValue = ! ! value ; return this ; } ; return decorator ; } 
function clone ( v ) { if ( v === null || typeof v !== "object" ) { return v ; } if ( isArray ( v ) ) { var arr = v . slice ( ) ; for ( var i = 0 ; i < v . length ; i ++ ) { arr [ i ] = clone ( arr [ i ] ) ; } return arr ; } else { var obj = { } ; for ( var k in v ) { obj [ k ] = clone ( v [ k ] ) ; } return obj ; } } 
function alertV2 ( ) { var baseURL = '/v2/alerts/' ; var savedSearchbaseURL = baseURL + "saved-searches/" ; var closeActionPath = "/close/" ; var acknowledgeActionPath = "/acknowledge/" ; var unAcknowledgeActionPath = "/unacknowledge/" ; var addNoteActionPath = "/notes/" ; var snoozeActionPath = "/snooze/" ; var escalateToNextActionPath = "/escalate/" ; var assignActionPath = "/assign/" ; var addTeamActionPath = "/teams/" ; var tagsActionPath = "/tags/" ; var detailsActionPath = "/details/" ; var customActionPath = "/actions/" ; var recipientsPath = "/recipients/" ; var listLogsPath = "/logs/" ; var listNotesPath = "/notes/" ; return { get : function ( identifier , config , cb ) { var path = api . getPath ( baseURL , identifier , null ) ; api . get ( path , config , cb ) } , create : function ( data , config , cb ) { api . post ( baseURL , data , config , cb ) } , delete : function ( identifier , config , cb ) { var path = api . getPath ( baseURL , identifier , null ) ; api . delete ( path , config , cb ) } , getRequestStatus : function ( requestId , config , cb ) { var path = baseURL + "requests/" + requestId ; api . get ( path , config , cb ) } , list : function ( params , config , cb ) { var path = api . getPathWithListParams ( baseURL , params ) ; api . get ( path , config , cb ) } , acknowledge : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , acknowledgeActionPath ) ; api . post ( path , data , config , cb ) ; } , close : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , closeActionPath ) ; api . post ( path , data , config , cb ) ; } , addNote : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , addNoteActionPath ) ; api . post ( path , data , config , cb ) ; } , unacknowledge : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , unAcknowledgeActionPath ) ; api . post ( path , data , config , cb ) ; } , snooze : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , snoozeActionPath ) ; api . post ( path , data , config , cb ) ; } , escalateToNext : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , escalateToNextActionPath ) ; api . post ( path , data , config , cb ) ; } , assign : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , assignActionPath ) ; api . post ( path , data , config , cb ) ; } , addTeam : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , addTeamActionPath ) ; api . post ( path , data , config , cb ) ; } , addTags : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , tagsActionPath ) ; api . post ( path , data , config , cb ) ; } , removeTags : function ( identifier , data , config , cb ) { if ( data . tags === undefined ) { return new Error ( "tags param can not be empty." ) ; } var path = api . getPathWithData ( baseURL , identifier , tagsActionPath , data ) ; api . delete ( path , config , cb ) ; } , addDetails : function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , detailsActionPath ) ; api . post ( path , data , config , cb ) ; } , removeDetails : function ( identifier , data , config , cb ) { if ( data . keys === undefined ) { return new Error ( "details param can not be empty." ) ; } var path = api . getPathWithData ( baseURL , identifier , detailsActionPath , data ) ; api . delete ( path , config , cb ) ; } , executeAction : function ( identifier , data , config , cb ) { if ( data . action === undefined ) { return new Error ( "action param can not be empty." ) ; } var path = api . getPath ( baseURL , identifier , customActionPath + data . action ) ; api . post ( path , data , config , cb ) ; } , listAlertRecipients : function ( identifier , config , cb ) { var path = api . getPath ( baseURL , identifier , recipientsPath ) ; api . get ( path , config , cb ) ; } , listAlertLogs : function ( identifier , data , config , cb ) { var path = api . getPathWithData ( baseURL , identifier , listLogsPath , data ) ; api . get ( path , config , cb ) ; } , listAlertNotes : function ( identifier , data , config , cb ) { var path = api . getPathWithData ( baseURL , identifier , listNotesPath , data ) ; api . get ( path , config , cb ) ; } , getSavedSearch : function ( identifier , config , cb ) { var path = api . getPath ( savedSearchbaseURL , identifier , null ) ; api . get ( path , config , cb ) } , createSavedSearch : function ( data , config , cb ) { api . post ( savedSearchbaseURL , data , config , cb ) } , updateSavedSearch : function ( identifier , data , config , cb ) { var path = api . getPath ( savedSearchbaseURL , identifier , null ) ; api . patch ( path , data , config , cb ) } , listSavedSearches : function ( config , cb ) { api . get ( savedSearchbaseURL , config , cb ) } } ; } 
function ( identifier , config , cb ) { var path = api . getPath ( baseURL , identifier , null ) ; api . get ( path , config , cb ) } 
function ( requestId , config , cb ) { var path = baseURL + "requests/" + requestId ; api . get ( path , config , cb ) } 
function ( params , config , cb ) { var path = api . getPathWithListParams ( baseURL , params ) ; api . get ( path , config , cb ) } 
function ( identifier , data , config , cb ) { if ( data . tags === undefined ) { return new Error ( "tags param can not be empty." ) ; } var path = api . getPathWithData ( baseURL , identifier , tagsActionPath , data ) ; api . delete ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . getPath ( baseURL , identifier , detailsActionPath ) ; api . post ( path , data , config , cb ) ; } 
function ( identifier , data , config , cb ) { if ( data . keys === undefined ) { return new Error ( "details param can not be empty." ) ; } var path = api . getPathWithData ( baseURL , identifier , detailsActionPath , data ) ; api . delete ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { if ( data . action === undefined ) { return new Error ( "action param can not be empty." ) ; } var path = api . getPath ( baseURL , identifier , customActionPath + data . action ) ; api . post ( path , data , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . getPathWithData ( baseURL , identifier , listLogsPath , data ) ; api . get ( path , config , cb ) ; } 
function ( identifier , data , config , cb ) { var path = api . getPath ( savedSearchbaseURL , identifier , null ) ; api . patch ( path , data , config , cb ) } 
function alert ( ) { var baseURL = '/v1/json/alert/' ; var defaultOperations = [ 'get' , 'list' , 'create' , 'delete' , 'deleteById' ] ; var ops = { baseURL : baseURL , close : function ( data , config , cb ) { api . post ( this . baseURL + 'close' , data , config , cb ) ; } , count : function ( data , config , cb ) { api . get ( this . baseURL + 'count' , data , config , cb ) ; } , listAlertNotes : function ( data , config , cb ) { api . get ( this . baseURL + 'note' , data , config , cb ) ; } , listAlertLogs : function ( data , config , cb ) { api . get ( this . baseURL + 'log' , data , config , cb ) ; } , listAlertRecipients : function ( data , config , cb ) { api . get ( this . baseURL + 'recipient' , data , config , cb ) ; } , acknowledge : function ( data , config , cb ) { api . post ( this . baseURL + 'acknowledge' , data , config , cb ) ; } , snooze : function ( data , config , cb ) { api . post ( this . baseURL + 'snooze' , data , config , cb ) ; } , renotify : function ( data , config , cb ) { api . post ( this . baseURL + 'renotify' , data , config , cb ) ; } , takeOwnership : function ( data , config , cb ) { api . post ( this . baseURL + 'takeOwnership' , data , config , cb ) ; } , assign : function ( data , config , cb ) { api . post ( this . baseURL + 'assign' , data , config , cb ) ; } , addTeam : function ( data , config , cb ) { api . post ( this . baseURL + 'team' , data , config , cb ) ; } , addRecipient : function ( data , config , cb ) { api . post ( this . baseURL + 'recipient' , data , config , cb ) ; } , addNote : function ( data , config , cb ) { api . post ( this . baseURL + 'note' , data , config , cb ) ; } , addTags : function ( data , config , cb ) { api . post ( this . baseURL + 'tags' , data , config , cb ) ; } , removeTags : function ( data , config , cb ) { if ( data . tags === undefined ) { return new Error ( "tags param can not be empty." ) ; } api . delete ( this . baseURL + 'tags' , data , config , cb ) ; } , addDetails : function ( data , config , cb ) { api . post ( this . baseURL + 'details' , data , config , cb ) ; } , removeDetails : function ( data , config , cb ) { if ( data . keys === undefined ) { return new Error ( "details param can not be empty." ) ; } api . delete ( this . baseURL + 'details' , data , config , cb ) ; } , executeAction : function ( data , config , cb ) { api . post ( this . baseURL + 'executeAction' , data , config , cb ) ; } } ; ops = operations . attach ( ops , defaultOperations ) ; return ops ; } 
function ( data , config , cb ) { if ( data . tags === undefined ) { return new Error ( "tags param can not be empty." ) ; } api . delete ( this . baseURL + 'tags' , data , config , cb ) ; } 
function ( data , config , cb ) { if ( data . keys === undefined ) { return new Error ( "details param can not be empty." ) ; } api . delete ( this . baseURL + 'details' , data , config , cb ) ; } 
function BufferedMetricsLogger ( opts ) { this . aggregator = opts . aggregator || new Aggregator ( opts . defaultTags ) ; this . reporter = opts . reporter || new DataDogReporter ( opts . apiKey , opts . appKey , opts . agent ) ; this . host = opts . host ; this . prefix = opts . prefix || '' ; this . flushIntervalSeconds = opts . flushIntervalSeconds ; if ( this . flushIntervalSeconds ) { debug ( 'Auto-flushing every %d seconds' , this . flushIntervalSeconds ) ; } else { debug ( 'Auto-flushing is disabled' ) ; } var self = this ; var autoFlushCallback = function ( ) { self . flush ( ) ; if ( self . flushIntervalSeconds ) { var interval = self . flushIntervalSeconds * 1000 ; var tid = setTimeout ( autoFlushCallback , interval ) ; 
function Metric ( key , tags , host ) { this . key = key ; this . tags = tags || [ ] ; this . host = host || '' ; } 
function Gauge ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . value = 0 ; } 
function Counter ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . value = 0 ; } 
function Histogram ( key , tags , host ) { Metric . call ( this , key , tags , host ) ; this . min = Infinity ; this . max = - Infinity ; this . sum = 0 ; this . count = 0 ; this . samples = [ ] ; this . percentiles = [ 0.75 , 0.85 , 0.95 , 0.99 ] ; } 
function init ( opts ) { opts = opts || { } ; if ( ! opts . flushIntervalSeconds && opts . flushIntervalSeconds !== 0 ) { opts . flushIntervalSeconds = 15 ; } sharedLogger = new loggers . BufferedMetricsLogger ( opts ) ; } 
function callOnSharedLogger ( funcName ) { if ( sharedLogger === null ) { init ( ) ; } var args = Array . prototype . slice . call ( arguments , 1 ) ; sharedLogger [ funcName ] . apply ( sharedLogger , args ) ; } 
function DataDogReporter ( apiKey , appKey , agent ) { apiKey = apiKey || process . env . DATADOG_API_KEY ; appKey = appKey || process . env . DATADOG_APP_KEY ; if ( ! apiKey ) { throw new Error ( 'DATADOG_API_KEY environment variable not set' ) ; } 
async function optimize ( file ) { check ( file ) ; const name = getName ( file ) ; log ( 'reading file ' + path . basename ( name ) ) ; const data = await readFile ( name , 'utf8' ) ; return onDataRead ( file , data ) ; } 
async function onDataRead ( filename , data ) { log ( 'file ' + path . basename ( filename ) + ' read' ) ; const ext = path . extname ( filename ) . replace ( / ^\. / , '' ) ; const optimizedData = await minify [ ext ] ( data ) ; let b64Optimize ; if ( ext === 'css' ) [ , b64Optimize ] = await tryToCatch ( minify . img , filename , optimizedData ) ; return b64Optimize || optimizedData ; } 
function applyOptions ( options ) { const settings = { } ; options = options || { } ; Object . assign ( settings , defaults , options ) ; return settings ; } 
function redirect ( options , ctx ) { 
function factory ( options ) { options = applyOptions ( options ) ; return ( ctx , next ) => { 
function parseForwarded ( value ) { const forwarded = { } value . trim ( ) . split ( ';' ) . forEach ( ( part ) => { const pair = part . trim ( ) . split ( '=' ) ; forwarded [ pair [ 0 ] ] = pair [ 1 ] ; } ) ; return forwarded ; } 
function forwardedResolver ( ctx ) { const header = ctx . request . header [ 'forwarded' ] ; if ( ! header ) { return false ; } else { const forwarded = parseForwarded ( header ) ; return forwarded . proto === 'https' ; } } 
function loadRcConfig ( callback ) { const sync = typeof callback !== 'function' ; if ( sync ) { const fp = rcLoader . for ( this . resourcePath ) ; if ( typeof fp !== 'string' ) { 
function inferMaster ( ) { var inferred = _ . find ( self . nestedLocales , { name : self . defaultLocale } ) || self . nestedLocales [ 0 ] ; if ( ( self . nestedLocales . length > 1 ) && ( ! _ . find ( self . nestedLocales , function ( locale ) { return locale . children && locale . children . length ; } ) ) ) { var others = _ . filter ( self . nestedLocales , function ( locale ) { return locale . name !== inferred . name ; } ) ; self . nestedLocales = [ inferred ] ; if ( others . length ) { inferred . children = others ; } } } 
function workflowGuidWorkflowLocale ( ) { return self . apos . docs . db . ensureIndex ( { workflowGuid : 1 , workflowLocale : 1 } , { sparse : 1 , unique : 1 } ) 
function replaceIdsRecursively ( doc ) { _ . each ( doc , function ( val , key ) { if ( key === 'workflowGuidAndLocaleDuplicates' ) { 
function fallback ( callback ) { return async . series ( [ viaBasis , noBasis ] , callback ) ; function viaBasis ( callback ) { return self . apos . migrations . eachDoc ( { workflowLocale : basis } , 5 , function ( doc , callback ) { if ( ! self . includeType ( doc . type ) ) { return setImmediate ( callback ) ; } doc . workflowResolveDeferred = true ; var afterSaveOptions = _ . assign ( { } , options , { permissions : false , workflowMissingLocalesLive : self . apos . argv . live ? true : 'liveOnly' } ) ; return self . docAfterSave ( req , doc , afterSaveOptions , callback ) ; } , callback ) ; } function noBasis ( callback ) { var localeNames = Object . keys ( self . locales ) ; var orphans ; return async . series ( [ find , fix ] , callback ) ; function find ( callback ) { const query = [ { $match : { workflowLocale : { $in : localeNames } } } , { $group : { _id : "$workflowGuid" , count : { $sum : 1 } } } , { $match : { count : { $lt : localeNames . length } } } ] ; return self . apos . docs . db . aggregate ( query ) . toArray ( function ( err , _orphans ) { if ( err ) { return callback ( err ) ; } orphans = _orphans ; return callback ( null ) ; } ) ; } function fix ( callback ) { var seen = { } ; if ( ! orphans . length ) { return callback ( null ) ; } 
function getWorkflowGuids ( callback ) { return self . apos . docs . db . findWithProjection ( { _id : { $in : _ . pluck ( related , '_id' ) } } , { _id : 1 , workflowGuid : 1 , type : 1 } ) . toArray ( function ( err , guidDocs ) { if ( err ) { return fail ( err ) ; } _ . each ( guidDocs , function ( guidDoc ) { var relatedOne = _ . find ( related , { _id : guidDoc . _id } ) ; if ( relatedOne ) { relatedOne . workflowGuid = guidDoc . workflowGuid ; idsByGuid [ relatedOne . workflowGuid ] = relatedOne . _id ; relatedOne . type = guidDoc . type ; } } ) ; 
function resolveToSource ( callback ) { return async . series ( [ _ . partial ( self . resolveRelationships , req , draft , to . workflowLocale ) , _ . partial ( self . resolveRelationships , req , from , to . workflowLocale ) ] , callback ) ; } 
function crossCorrectPass ( callback ) { return async . series ( [ find , correct ] , callback ) ; function find ( callback ) { return self . apos . docs . db . findWithProjection ( { parkedId : { $exists : 1 } } ) . toArray ( function ( err , _pages ) { if ( err ) { return callback ( err ) ; } pages = _pages ; return callback ( null ) ; } ) ; } function correct ( callback ) { var parkedIdsByWorkflowGuid = { } ; _ . each ( pages , function ( page ) { parkedIdsByWorkflowGuid [ page . workflowGuid ] = page . parkedId ; } ) ; return async . eachSeries ( _ . keys ( parkedIdsByWorkflowGuid ) , function ( workflowGuid , callback ) { return self . apos . docs . db . update ( { workflowGuid : workflowGuid } , { $set : { parkedId : parkedIdsByWorkflowGuid [ workflowGuid ] } } , { multi : true } , callback ) ; } , callback ) ; } } 
function getContentType ( file ) { var mimeType = mime . lookup ( file . unzipPath || file . path ) || 'application/octet-stream' ; var charset = mime . charset ( mimeType ) ; return charset ? mimeType + '; charset=' + charset . toLowerCase ( ) : mimeType ; } 
function toAwsParams ( file ) { var params = { } ; var headers = file . s3 . headers || { } ; for ( var header in headers ) { if ( header === 'x-amz-acl' ) { params . ACL = headers [ header ] ; } else if ( header === 'Content-MD5' ) { params . ContentMD5 = headers [ header ] ; } else { params [ pascalCase ( header ) ] = headers [ header ] ; } } params . Key = file . s3 . path ; params . Body = file . contents ; return params ; } 
function initFile ( file ) { if ( ! file . s3 ) { file . s3 = { } ; file . s3 . headers = { } ; file . s3 . path = file . relative . replace ( / \\ / g , '/' ) ; } return file ; } 
function fileShouldBeDeleted ( key , whitelist ) { for ( var i = 0 ; i < whitelist . length ; i ++ ) { var expr = whitelist [ i ] ; if ( expr instanceof RegExp ) { if ( expr . test ( key ) ) { return false ; } } else if ( typeof expr === 'string' ) { if ( expr === key ) { return false ; } } else { throw new Error ( 'whitelist param can only contain regular expressions or strings' ) ; } } return true ; } 
function Publisher ( AWSConfig , cacheOptions ) { this . config = AWSConfig ; this . client = new AWS . S3 ( AWSConfig ) ; var bucket = this . config . params . Bucket ; if ( ! bucket ) { throw new Error ( 'Missing `params.Bucket` config value.' ) ; } 
function ZarinPal ( MerchantID , sandbox ) { if ( typeof MerchantID === 'string' && MerchantID . length === config . merchantIDLength ) { this . merchant = MerchantID ; } else { console . error ( 'The MerchantID must be ' + config . merchantIDLength + ' Characters.' ) ; return false ; } this . sandbox = sandbox || false ; this . url = ( sandbox === true ) ? config . sandbox : config . https ; } 
function deferred ( ) { var outResolve = function ( ) { } ; 
function loadNodeStruct ( xpub , version_public ) { stringToUTF8 ( xpub , _xpub , XPUB_SIZE ) ; if ( _hdnode_deserialize ( _xpub , version_public , 0 , _hdnode , 0 ) !== 0 ) { throw new Error ( "Wrong XPUB type!!" ) ; 
function processMessage ( event ) { var data = event [ 'data' ] ; var type = data [ 'type' ] ; switch ( type ) { case 'deriveAddressRange' : var addresses = deriveAddressRange ( data [ 'node' ] , data [ 'firstIndex' ] , data [ 'lastIndex' ] , data [ 'version' ] , data [ 'addressFormat' ] ) ; self . postMessage ( { 'addresses' : addresses , 'firstIndex' : data [ 'firstIndex' ] , 'lastIndex' : data [ 'lastIndex' ] , 'i' : data [ 'i' ] } ) ; break ; case 'deriveNode' : var node = deriveNode ( data [ 'xpub' ] , data [ 'index' ] , data [ 'version' ] ) ; self . postMessage ( { 'xpub' : node , 'i' : data [ 'i' ] } ) ; break ; default : throw new Error ( 'Unknown message type: ' + type ) ; } } 
function formatError ( error : mixed ) : Error { if ( typeof error === 'object' && error != null && error instanceof Error ) { return error ; } if ( typeof error === 'object' && error != null && error . message != null ) { return new Error ( error . message ) ; } return new Error ( JSON . stringify ( error ) ) ; } 
function search ( effectiveUtxos , target , costOfChange ) { if ( effectiveUtxos . length === 0 ) { return null ; } let tries = maxTries ; const selected = [ ] ; 
async function parseResponse ( header , response , active = false , id ) { const rows = [ ] ; _ . each ( response , ( value , key ) => { let row = [ ] ; if ( active ) { _ . each ( response [ key ] . active , ( activeValue ) => { row = [ ] ; 
async function display ( header , items , type , active = false , parse = false , id ) { let rows ; if ( type === 'txt' ) { await text ( header , items ) ; } else if ( type === 'txtHorizontal' ) { const opts = { head : header , chars : { top : '' , 'top-mid' : '' , 'top-left' : '' , 'top-right' : '' , bottom : '' , 'bottom-mid' : '' , 'bottom-left' : '' , 'bottom-right' : '' , left : '' , 'left-mid' : '' , mid : '' , 'mid-mid' : '' , right : '' , 'right-mid' : '' , middle : ' ' . repeat ( 2 ) } , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'white' ] , border : [ 'white' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type === 'prettyHorizontal' ) { const opts = { head : header , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'blue' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await horizontal ( rows , opts ) ; } else { await horizontal ( items , opts ) ; } } else if ( type === 'txtVertical' ) { const style = { chars : { top : '' , 'top-mid' : '' , 'top-left' : '' , 'top-right' : '' , bottom : '' , 'bottom-mid' : '' , 'bottom-left' : '' , 'bottom-right' : '' , left : '' , 'left-mid' : '' , mid : '' , 'mid-mid' : '' , right : '' , 'right-mid' : '' , middle : ' ' . repeat ( 3 ) } , style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'white' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else if ( type === 'prettyVertical' ) { const style = { style : { 'padding-left' : 0 , 'padding-right' : 0 , head : [ 'blue' ] } } ; if ( parse ) { rows = await parseResponse ( header , items , active , id ) ; await vertical ( header , rows , style ) ; } else { await vertical ( header , items , style ) ; } } else { await pretty ( header , items ) ; } } 
function shutdownHandler ( context , shutdownFn ) { const assignment = context . assignment || process . env . NODE_TYPE || process . env . assignment || 'unknown-assignment' ; const isProcessRestart = process . env . process_restart ; const restartOnFailure = assignment !== 'exectution_controller' ; const api = { exiting : false , exit } ; const shutdownTimeout = _ . get ( context , 'sysconfig.teraslice.shutdown_timeout' , 20 * 1000 ) ; const events = context . apis . foundation . getSystemEvents ( ) ; const logger = context . apis . foundation . makeLogger ( { module : ` ${ assignment } ` } ) ; if ( assignment === 'execution_controller' && isProcessRestart ) { logger . fatal ( 'Execution Controller runtime error led to a restart, terminating execution with failed status, please use the recover api to return slicer to a consistent state' ) ; process . exit ( 0 ) ; } function flushLogs ( ) { return Promise . resolve ( ) . then ( ( ) => this . logger . flush ( ) ) . then ( ( ) => Promise . delay ( 1000 ) ) ; } let startTime ; function exitingIn ( ) { if ( ! api . exiting ) { return ` ${ shutdownTimeout } ` ; } const elapsed = Date . now ( ) - startTime ; return ` ${ shutdownTimeout - elapsed } ` ; } function exit ( event , err ) { if ( api . exiting ) return ; api . exiting = true ; startTime = Date . now ( ) ; Promise . race ( [ shutdownFn ( event , err ) , Promise . delay ( shutdownTimeout - 2000 ) ] ) . then ( ( ) => { logger . info ( ` ${ assignment } ${ Date . now ( ) - startTime } ` ) ; } ) . catch ( ( error ) => { logger . error ( ` ${ assignment } ` , error ) ; } ) . then ( ( ) => { const code = process . exitCode || 0 ; logger . trace ( ` ${ code } ` ) ; return flushLogs ( ) . finally ( ( ) => { process . exit ( ) ; } ) ; } ) ; } process . on ( 'SIGINT' , ( ) => { logger . info ( ` ${ assignment } ${ exitingIn ( ) } ` ) ; if ( ! api . exiting ) { process . exitCode = 0 ; } exit ( 'SIGINT' ) ; } ) ; process . on ( 'SIGTERM' , ( ) => { logger . info ( ` ${ assignment } ${ exitingIn ( ) } ` ) ; if ( ! api . exiting ) { process . exitCode = 0 ; } exit ( 'SIGTERM' ) ; } ) ; process . on ( 'uncaughtException' , ( err ) => { logger . fatal ( err , ` ${ assignment } ${ exitingIn ( ) } ` ) ; if ( ! api . exiting ) { process . exitCode = restartOnFailure ? 1 : 0 ; } exit ( 'uncaughtException' , err ) ; } ) ; process . once ( 'unhandledRejection' , ( err ) => { logger . fatal ( err , ` ${ assignment } ${ exitingIn ( ) } ` ) ; if ( ! api . exiting ) { process . exitCode = restartOnFailure ? 1 : 0 ; } exit ( 'unhandledRejection' , err ) ; } ) ; 
function _getClusterState ( ) { return k8s . list ( 'app=teraslice' , 'pods' ) . then ( k8sPods => k8sState . gen ( k8sPods , clusterState , clusterNameLabel ) ) . catch ( ( err ) => { 
function allocateSlicer ( execution ) { const exSvcResource = new K8sResource ( 'services' , 'execution_controller' , context . sysconfig . teraslice , execution ) ; const exService = exSvcResource . resource ; execution . slicer_port = _ . get ( exService , 'spec.ports[0].targetPort' ) ; execution . slicer_hostname = _ . get ( exService , 'metadata.name' ) ; const exJobResource = new K8sResource ( 'jobs' , 'execution_controller' , context . sysconfig . teraslice , execution ) ; const exJob = exJobResource . resource ; logger . debug ( ` \n \n ${ JSON . stringify ( exJob , null , 2 ) } ` ) ; 
function allocateWorkers ( execution ) { const kr = new K8sResource ( 'deployments' , 'worker' , context . sysconfig . teraslice , execution ) ; const workerDeployment = kr . resource ; logger . debug ( ` \n \n ${ JSON . stringify ( workerDeployment , null , 2 ) } ` ) ; return k8s . post ( workerDeployment , 'deployment' ) . then ( result => logger . debug ( ` ${ JSON . stringify ( result ) } ` ) ) . catch ( ( err ) => { const error = new TSError ( err , { reason : 'Error submitting k8s worker deployment' } ) ; return Promise . reject ( error ) ; } ) ; } 
async function addWorkers ( executionContext , numWorkers ) { await k8s . scaleExecution ( executionContext . ex_id , numWorkers , 'add' ) ; return { action : 'add' , ex_id : executionContext . ex_id , workerNum : numWorkers } ; } 
async function removeWorkers ( exId , numWorkers ) { await k8s . scaleExecution ( exId , numWorkers , 'remove' ) ; return { action : 'remove' , ex_id : exId , workerNum : numWorkers } ; } 
function makePrometheus ( stats , defaultLabels = { } ) { const metricMapping = { processed : 'teraslice_slices_processed' , failed : 'teraslice_slices_failed' , queued : 'teraslice_slices_queued' , job_duration : '' , 
function loadConnector ( type ) { const localPath = ` ${ __dirname } ${ type } ` ; const paths = { } ; paths [ localPath ] = true ; paths [ type ] = true ; const err = ` ${ type } \n ` ; return getModule ( type , paths , err ) ; } 
function newProcessor ( context , opConfig , jobConfig ) { const jobLogger = context . logger ; jobLogger . info ( 'Drop_property asset loaded.' ) ; return function processor ( data , sliceLogger , msg ) { data . forEach ( ( doc ) => { if ( doc . hasOwnProperty ( opConfig . property ) ) { delete doc [ opConfig . property ] ; } } ) ; return data ; } ; } 
function getOffsets ( size , total , delimiter ) { if ( total === 0 ) { return [ ] ; } if ( total < size ) { return [ { length : total , offset : 0 } ] ; } const fullChunks = Math . floor ( total / size ) ; const delta = delimiter . length ; const length = size + delta ; const chunks = [ ] ; for ( let chunk = 1 ; chunk < fullChunks ; chunk += 1 ) { chunks . push ( { length , offset : ( chunk * size ) - delta } ) ; } 
function getChunk ( readerClient , slice , opConfig , logger , metadata ) { const delimiter = opConfig . line_delimiter ; async function getMargin ( offset , length ) { let margin = '' ; return new Promise ( async ( resolve ) => { while ( margin . indexOf ( delimiter ) === - 1 ) { 
function finishExecution ( exId , err ) { if ( err ) { const error = new TSError ( err , { reason : ` ${ exId } ` , context : { ex_id : exId , } } ) ; logger . error ( error ) ; } return getExecutionContext ( exId ) . then ( ( execution ) => { const status = execution . _status ; if ( [ 'stopping' , 'stopped' ] . includes ( status ) ) { logger . debug ( ` ${ exId } ` ) ; return true ; } logger . debug ( ` ${ exId } ` ) ; return clusterService . stopExecution ( exId ) . catch ( ( stopErr ) => { const stopError = new TSError ( stopErr , { reason : 'error finishing the execution' , context : { ex_id : exId , } } ) ; logger . error ( stopError ) ; } ) ; } ) ; } 
function getActiveExecution ( exId ) { const str = terminalStatusList ( ) . map ( state => ` ${ state } ` ) . join ( 'OR' ) ; const query = ` ${ exId } ${ str . trim ( ) } ` ; return searchExecutionContexts ( query , null , 1 , '_created:desc' ) . then ( ( ex ) => { if ( ex . length === 0 ) { const error = new Error ( ` ${ exId } ` ) ; error . code = 404 ; return Promise . reject ( error ) ; } return ex [ 0 ] ; } ) ; } 
function registerAPI ( name , api ) { if ( Object . prototype . hasOwnProperty . call ( context . apis , name ) ) { throw new Error ( ` ${ name } ` ) ; } else { context . apis [ name ] = api ; } } 
function gen ( k8sPods , clusterState , clusterNameLabel ) { 
function Node ( data , prev , next ) { this . next = next ; if ( next ) { next . prev = this ; } this . prev = prev ; if ( prev ) { prev . next = this ; } this . value = data ; } 
function errorHandler ( err ) { 
function allocateWorkers ( execution , numOfWorkersRequested ) { const exId = execution . ex_id ; const jobId = execution . job_id ; const jobStr = JSON . stringify ( execution ) ; const sortedNodes = _ . orderBy ( clusterState , 'available' , 'desc' ) ; let workersRequested = numOfWorkersRequested ; let availWorkers = _availableWorkers ( false , true ) ; const dispatch = _makeDispatch ( ) ; while ( workersRequested > 0 && availWorkers > 0 ) { for ( let i = 0 ; i < sortedNodes . length ; i += 1 ) { 
function getRecord ( recordId , indexArg , fields ) { logger . trace ( ` ${ recordId } ` ) ; const query = { index : indexArg || indexName , type : recordType , id : recordId } ; if ( fields ) { query . _source = fields ; } return elasticsearch . get ( query ) ; } 
function create ( record , indexArg = indexName ) { logger . trace ( 'creating record' , logRecord ? record : null ) ; const query = { index : indexArg , type : recordType , id : record [ idField ] , body : record , refresh : forceRefresh } ; return elasticsearch . create ( query ) ; } 
function verifyStatusUpdate ( exId , desiredStatus ) { if ( ! desiredStatus || ! _isValidStatus ( desiredStatus ) ) { const error = new Error ( ` ${ desiredStatus } ` ) ; error . statusCode = 422 ; return Promise . reject ( error ) ; } return getStatus ( exId ) . then ( ( status ) => { 
function _attachRoomsSocketIO ( ) { if ( ! io ) return ; 
function _toRecords ( rawData , delimiter , slice ) { 
function raw ( incomingData , logger , opConfig , metadata , slice ) { const data = _toRecords ( incomingData , opConfig . line_delimiter , slice ) ; return data . map ( ( record ) => { try { return DataEntity . make ( { data : record } , metadata ) ; } catch ( err ) { if ( opConfig . _dead_letter_action === 'log' ) { logger . error ( err , 'Bad record:' , record ) ; } else if ( opConfig . _dead_letter_action === 'throw' ) { throw err ; } return null ; } } ) ; } 
function tsv ( incomingData , logger , opConfig , metadata , slice ) { return csv ( incomingData , logger , opConfig , metadata , slice ) ; } 
function determineWorkerENV ( worker ) { const options = { } ; if ( worker . service_context ) { const envConfig = JSON . parse ( worker . service_context ) ; _ . assign ( options , envConfig ) ; options . __process_restart = true ; options . service_context = worker . service_context ; } return options ; } 
function TransformStreamCloseReadable ( transformStream ) { 
function TransformStreamCloseReadableInternal ( transformStream ) { assert ( transformStream . _errored === false ) ; assert ( transformStream . _readableClosed === false ) ; try { ReadableStreamDefaultControllerClose ( transformStream . _readableController ) ; } catch ( e ) { assert ( false ) ; } transformStream . _readableClosed = true ; } 
function TransformStreamReadableReadyPromise ( transformStream ) { assert ( transformStream . _backpressureChangePromise !== undefined , '_backpressureChangePromise should have been initialized' ) ; if ( transformStream . _backpressure === false ) { return Promise . resolve ( ) ; } assert ( transformStream . _backpressure === true , '_backpressure should have been initialized' ) ; return transformStream . _backpressureChangePromise ; } 
function pipeLoop ( ) { currentWrite = Promise . resolve ( ) ; if ( shuttingDown === true ) { return Promise . resolve ( ) ; } return writer . _readyPromise . then ( ( ) => { return ReadableStreamDefaultReaderRead ( reader ) . then ( ( { value , done } ) => { if ( done === true ) { return undefined ; } currentWrite = WritableStreamDefaultWriterWrite ( writer , value ) ; return currentWrite ; } ) ; } ) . then ( pipeLoop ) ; } 
function ReadableStreamAddReadIntoRequest ( stream ) { assert ( IsReadableStreamBYOBReader ( stream . _reader ) === true ) ; assert ( stream . _state === 'readable' || stream . _state === 'closed' ) ; const promise = new Promise ( ( resolve , reject ) => { const readIntoRequest = { _resolve : resolve , _reject : reject } ; stream . _reader . _readIntoRequests . push ( readIntoRequest ) ; } ) ; return promise ; } 
function ReadableStreamReaderGenericCancel ( reader , reason ) { const stream = reader . _ownerReadableStream ; assert ( stream !== undefined ) ; return ReadableStreamCancel ( stream , reason ) ; } 
function ReadableStreamDefaultControllerClose ( controller ) { const stream = controller . _controlledReadableStream ; assert ( controller . _closeRequested === false ) ; assert ( stream . _state === 'readable' ) ; controller . _closeRequested = true ; if ( controller . _queue . length === 0 ) { ReadableStreamClose ( stream ) ; } } 
function ReadableByteStreamControllerClose ( controller ) { const stream = controller . _controlledReadableStream ; assert ( controller . _closeRequested === false ) ; assert ( stream . _state === 'readable' ) ; if ( controller . _totalQueuedBytes > 0 ) { controller . _closeRequested = true ; return ; } if ( controller . _pendingPullIntos . length > 0 ) { const firstPendingPullInto = controller . _pendingPullIntos [ 0 ] ; if ( firstPendingPullInto . bytesFilled > 0 ) { const e = new TypeError ( 'Insufficient bytes to fill elements in the given buffer' ) ; ReadableByteStreamControllerError ( controller , e ) ; throw e ; } } ReadableStreamClose ( stream ) ; } 
function through ( fn , keepOpen ) { if ( keepOpen === void 0 ) { keepOpen = false ; } return duplex_1 . createDuplex ( function ( input , output ) { var nextInput = function ( ) { input . next ( ) . then ( function ( _a ) { var value = _a . value ; if ( value == null ) { if ( ! keepOpen ) { return output . return ( ) ; } } return pump_1 . pump ( wrap_async_iterable_iterator_1 . wrapAsyncIterableIterator ( fn ( value ) ) , function ( value ) { return output . unshift ( value ) ; } ) . then ( nextInput ) ; } ) ; } ; nextInput ( ) ; } ) ; } 
function StoredPromise ( init ) { this . _resolve = value => { this . _resolved = true ; this . _value = value } this . _reject = value => { this . _rejected = true ; this . _value = value ; } init ( value => { this . _resolve ( value ) } , value => { this . _reject ( value ) } ) ; } 
function WritableStreamAddWriteRequest ( stream ) { assert ( IsWritableStreamLocked ( stream ) === true ) ; assert ( stream . _state === 'writable' ) ; const promise = new Promise ( ( resolve , reject ) => { const writeRequest = { _resolve : resolve , _reject : reject } ; stream . _writeRequests . push ( writeRequest ) ; } ) ; return promise ; } 
function IsWritableStreamDefaultWriter ( x ) { if ( ! typeIsObject ( x ) ) { return false ; } if ( ! Object . prototype . hasOwnProperty . call ( x , '_ownerWritableStream' ) ) { return false ; } return true ; } 
function WritableStreamDefaultWriterAbort ( writer , reason ) { const stream = writer . _ownerWritableStream ; assert ( stream !== undefined ) ; return WritableStreamAbort ( stream , reason ) ; } 
function WritableStreamDefaultControllerAbort ( controller , reason ) { controller . _queue = [ ] ; const sinkAbortPromise = PromiseInvokeOrFallbackOrNoop ( controller . _underlyingSink , 'abort' , [ reason ] , 'close' , [ controller ] ) ; return sinkAbortPromise . then ( ( ) => undefined ) ; } 
function WritableStreamDefaultControllerError ( controller , e ) { const stream = controller . _controlledWritableStream ; assert ( stream . _state === 'writable' || stream . _state === 'closing' ) ; WritableStreamError ( stream , e ) ; controller . _queue = [ ] ; } 
function pipe ( ) { var _this = this ; var items = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i ++ ) { items [ _i ] = arguments [ _i ] ; } var _done = false ; var targets = items . map ( wrap_async_iterable_iterator_1 . wrapAsyncIterableIterator ) ; var call = function ( methodName , value ) { return new Promise ( function ( resolve , reject ) { var remaining = targets . concat ( ) ; var next = function ( _a ) { var value = _a . value , done = _a . done ; if ( ! _done ) { _done = done ; } 
function validate ( object , schema , options ) { options = mixin ( { } , validate . defaults , options ) ; var errors = [ ] ; if ( schema . type === 'array' ) validateProperty ( object , object , '' , schema , options , errors ) ; else validateObject ( object , schema , options , errors ) ; 
function updateDisplay ( ) { var value = $ ( "#show" ) . val ( ) ; switch ( value ) { case "runtime" : $ ( ".load" ) . hide ( ) ; $ ( ".runtime" ) . show ( ) ; break ; case "load" : $ ( ".load" ) . show ( ) ; $ ( ".runtime" ) . hide ( ) ; break ; default : $ ( ".load" ) . show ( ) ; $ ( ".runtime" ) . show ( ) ; break ; } } 
function ( eventType , handler ) { if ( this . deferredEvents === null ) this . deferredEvents = { } ; var handlers = this . deferredEvents [ eventType ] ; if ( handlers === undefined ) handlers = this . deferredEvents [ eventType ] = [ ] ; handlers . push ( { eventType : eventType , handler : handler } ) ; } 
function ( ) { qx . Bootstrap . executePendingDefers ( ) ; qx . $$loader . delayDefer = false ; qx . $$loader . scriptLoaded = true ; function done ( ) { var readyHandlers = [ ] ; if ( qx . $$loader . deferredEvents ) { Object . keys ( qx . $$loader . deferredEvents ) . forEach ( function ( eventType ) { var handlers = qx . $$loader . deferredEvents [ eventType ] ; handlers . forEach ( function ( handler ) { qx . event . Registration . addListener ( window , eventType , handler . handler ) ; if ( eventType === "ready" ) readyHandlers . push ( handler . handler ) ; } ) ; } ) ; } if ( window . qx && qx . event && qx . event . handler && qx . event . handler . Application ) { qx . event . handler . Application . onScriptLoaded ( ) ; qx . $$loader . applicationHandlerReady = true ; } else { qx . $$loader . applicationHandlerReady = false ; readyHandlers . forEach ( function ( handler ) { handler ( null ) ; } ) ; } } if ( qx . $$loader . splashscreen ) qx . $$loader . splashscreen . loadComplete ( done ) ; else done ( ) ; } 
function ( ) { var l = qx . $$loader ; l . decodeUris ( l . cssBefore , "resourceUri" ) . forEach ( function ( uri ) { loadCss ( uri ) ; } ) ; allScripts = l . decodeUris ( l . urisBefore , "resourceUri" ) ; if ( ! l . bootIsInline ) { var add = l . decodeUris ( l . packages [ l . parts [ l . boot ] [ 0 ] ] . uris ) ; Array . prototype . push . apply ( allScripts , add ) ; } function begin ( ) { flushScriptQueue ( function ( ) { 
function loadScript ( uri , callback ) { var elem = document . createElement ( "script" ) ; elem . charset = "utf-8" ; elem . src = uri ; elem . onreadystatechange = elem . onload = function ( ) { if ( ! this . readyState || readyStateValue [ this . readyState ] ) { elem . onreadystatechange = elem . onload = null ; if ( typeof callback === "function" ) { callback ( ) ; } } } ; elem . onerror = function ( ) { if ( console && typeof console . error == "function" ) console . error ( "Cannot load script " + uri ) ; callback && callback ( "Cannot load script " + uri ) ; } if ( qx . $$loader . isLoadParallel ) { elem . async = null ; } var head = document . getElementsByTagName ( "head" ) [ 0 ] ; head . appendChild ( elem ) ; } 
function loadCss ( uri ) { var elem = document . createElement ( "link" ) ; elem . rel = "stylesheet" ; elem . type = "text/css" ; elem . href = uri ; var head = document . getElementsByTagName ( "head" ) [ 0 ] ; head . appendChild ( elem ) ; } 
function ( classname ) { this . base ( arguments ) ; this . initType ( ) ; var args = qx . lang . Array . fromArguments ( arguments ) ; var t = this ; this . __classes = [ ] ; args . forEach ( function ( arg ) { if ( qx . lang . Type . isArray ( arg ) ) { qx . lang . Array . append ( t . __classes , arg ) ; } else { t . __classes . push ( arg ) ; } } ) ; this . set ( { include : [ ] , exclude : [ ] } ) ; } 
function ( ) { var t = this ; var Console = qx . tool . compiler . Console . getInstance ( ) ; var analyser = this . getAnalyser ( ) ; var db = analyser . getDatabase ( ) ; var allDeps = new qx . tool . compiler . utils . IndexedArray ( ) ; var exclude = { } ; var fatalCompileErrors = [ ] ; this . __loadDeps = null ; var partsByName = { } ; var parts = [ ] ; var bootPart = null ; var classDataByClassname = { } ; if ( this . __parts && this . __parts . length ) { parts = [ ] ; t . __parts . forEach ( part => { if ( partsByName [ part . getName ( ) ] ) { throw new Error ( Console . decode ( "qx.tool.compiler.application.duplicatePartNames" , part . getName ( ) ) ) ; } var partData = { name : part . getName ( ) , include : part . getInclude ( ) , exclude : part . getExclude ( ) , classes : [ ] , dependsOn : { } , combine : part . getCombine ( ) , minify : part . getMinify ( ) } ; partData . match = qx . tool . compiler . app . Application . createWildcardMatchFunction ( part . getInclude ( ) , part . getExclude ( ) ) ; partsByName [ part . getName ( ) ] = partData ; parts . push ( partData ) ; } ) ; bootPart = partsByName . boot ; if ( ! bootPart ) { throw new Error ( Console . decode ( "qx.tool.compiler.application.noBootPart" ) ) ; } } else { bootPart = { name : "boot" , include : [ "*" ] , exclude : [ ] , classes : [ ] , dependsOn : { } , combine : false , minify : false , match : function ( ) { return true ; } } ; partsByName . boot = bootPart ; parts . push ( bootPart ) ; } function createClassData ( classname ) { if ( classDataByClassname [ classname ] ) { return classDataByClassname [ classname ] ; } var classData = classDataByClassname [ classname ] = { classname : classname , parts : { } , best : null , actual : null } ; parts . forEach ( part => { if ( part === bootPart ) { return ; } var result = part . match ( classname ) ; if ( result !== null ) { classData . parts [ part . name ] = result ; var lastMatch = classData . best && classData . parts [ classData . best . name ] ; if ( lastMatch === undefined || lastMatch === null ) { classData . best = part ; * We could say that when a class is `.require`d, then we treat any of it's `construct:true` dependencies as `require:true` * The problem is given this example: * qx.core.Init.defer() * qx.event.Registration.addListener * qx.event.Registration.getManager * qx.event.Manager.construct * new qx.util.DeferredCall * * new qx.util.DeferredCall is a runtime only dependency so is not available. * * So the theory is that deferred calls tend to be about initialisation, so prioritising constructor dependencies * may be helpful */ /* * Recursively finds all the dependencies for a class which have not already been added * to the list of classes to load. * * @param classname {String} * @param deps {String[]} array to modify */ function compileAllRemainingDeps ( classname , deps ) { var checked = { } ; var depNames = { } ; depNames [ classname ] = true ; function search ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var info = db . classInfo [ classname ] ; if ( info && info . dependsOn ) { for ( var depName in info . dependsOn ) { var dd = info . dependsOn [ depName ] ; if ( dd . load || dd . require || dd . defer || dd . construct ) { if ( ! allDeps . contains ( depName ) ) { depNames [ depName ] = true ; } search ( depName ) ; } } } } search ( classname ) ; for ( var depName in depNames ) { deps . push ( depName ) ; } } var addDepDepth = 0 ; function addDep ( classname ) { if ( exclude [ classname ] ) { return ; } if ( allDeps . contains ( classname ) || stack . contains ( classname ) ) { return ; } var info = db . classInfo [ classname ] ; if ( ! info ) { return ; } if ( info . fatalCompileError ) { fatalCompileErrors . push ( classname ) ; } addDepDepth ++ ; var environmentLoadDeps = { } ; if ( info . environment && info . environment . required ) { for ( var key in info . environment . required ) { var envInfo = info . environment . required [ key ] ; if ( envInfo . defer ) { environmentLoadDeps [ envInfo . className ] = true ; } } } var deferDeps = [ ] ; if ( info . dependsOn ) { stack . push ( classname ) ; for ( var depName in info . dependsOn ) { var dd = info . dependsOn [ depName ] ; if ( dd . load || dd . require || environmentLoadDeps [ depName ] ) { addDep ( depName ) ; } else if ( dd . defer ) { deferDeps . push ( depName ) ; } else if ( ! allDeps . contains ( depName ) ) { needed . push ( depName ) ; } } stack . remove ( classname ) ; } if ( parts && ! allDeps . contains ( classname ) ) { var classData = createClassData ( classname ) ; var part = classData . best || bootPart ; part . classes . push ( classname ) ; classData . actual = part ; } allDeps . push ( classname ) ; deferDeps . forEach ( function ( depName ) { var deps = [ ] ; compileAllRemainingDeps ( depName , deps ) ; deps . forEach ( addDep ) ; } ) ; if ( addDepDepth === 1 ) { while ( neededIndex < needed . getLength ( ) ) { classname = needed . getItem ( neededIndex ++ ) ; addDep ( classname ) ; } } addDepDepth -- ; } exclude = { } ; t . __expandClassnames ( t . getExclude ( ) ) . forEach ( name => exclude [ name ] = true ) ; // Start the ball rolling addDep ( "qx.core.Object" ) ; t . getRequiredClasses ( ) . forEach ( function ( classname ) { addDep ( classname ) ; } ) ; if ( t . getTheme ( ) ) { addDep ( t . getTheme ( ) ) ; } /* parts.forEach((part) => { if (part !== bootPart) { t.__expandClassnames(part.include).forEach((name) => addDep(name)); } }); */ while ( neededIndex < needed . length ) { var classname = needed [ neededIndex ++ ] ; addDep ( classname ) ; } if ( parts && parts . length > 1 ) { // Calculate inter-part dependencies parts . forEach ( part => { var checked = { } ; function check ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var classData = classDataByClassname [ classname ] ; if ( classData . actual !== part ) { part . dependsOn [ classData . actual . name ] = true ; } for ( var depName in db . classInfo . dependsOn ) { check ( depName ) ; } } part . classes . forEach ( check ) ; part . dependsOn = Object . keys ( part . dependsOn ) ; } ) ; // Check for recursive dependencies parts . forEach ( part => { var checked = { } ; function check ( partname ) { if ( checked [ partname ] ) { return false ; } checked [ partname ] = true ; var checkPart = partsByName [ partname ] ; if ( checkPart === part ) { return true ; } return part . dependsOn . some ( check ) ; } if ( part . dependsOn . some ( check ) ) { Console . print ( "qx.tool.compiler.application.partRecursive" , part . name ) ; } } ) ; } /* * Done */ this . __loadDeps = allDeps . toArray ( ) ; var requiredLibs = { } ; this . __loadDeps . forEach ( classname => { let classInfo = db . classInfo [ classname ] ; if ( classInfo . assets ) { classInfo . assets . forEach ( asset => { var pos = asset . indexOf ( '/' ) ; if ( pos > - 1 ) { var ns = asset . substring ( 0 , pos ) ; if ( analyser . findLibrary ( ns ) ) requiredLibs [ ns ] = true ; } } ) ; } requiredLibs [ classInfo . libraryName ] = true ; } ) ; this . __requiredLibs = [ ] ; for ( let ns in requiredLibs ) { if ( analyser . findLibrary ( ns ) ) { this . __requiredLibs . push ( ns ) ; } else { Console . print ( "qx.tool.compiler.application.missingRequiredLibrary" , ns ) ; } } this . __partsDeps = parts ; this . __fatalCompileErrors = fatalCompileErrors . length ? fatalCompileErrors : null ; } 
function compileAllRemainingDeps ( classname , deps ) { var checked = { } ; var depNames = { } ; depNames [ classname ] = true ; function search ( classname ) { if ( checked [ classname ] ) { return ; } checked [ classname ] = true ; var info = db . classInfo [ classname ] ; if ( info && info . dependsOn ) { for ( var depName in info . dependsOn ) { var dd = info . dependsOn [ depName ] ; if ( dd . load || dd . require || dd . defer || dd . construct ) { if ( ! allDeps . contains ( depName ) ) { depNames [ depName ] = true ; } search ( depName ) ; } } } } search ( classname ) ; for ( var depName in depNames ) { deps . push ( depName ) ; } } 
function ( ) { var uris = [ ] ; var db = this . getAnalyser ( ) . getDatabase ( ) ; function add ( classname ) { var def = db . classInfo [ classname ] ; uris . push ( def . libraryName + ":" + classname . replace ( / \. / g , "/" ) + ".js" ) ; } this . __loadDeps . forEach ( add ) ; return uris ; } 
function ( resManager , environment ) { var assets = [ ] ; var analyser = this . getAnalyser ( ) ; var db = analyser . getDatabase ( ) ; 
function ( ) { var result = { } ; this . __classes . forEach ( name => result [ name ] = true ) ; this . __expandClassnames ( this . getInclude ( ) ) . forEach ( name => result [ name ] = true ) ; this . __expandClassnames ( this . getExclude ( ) ) . forEach ( name => delete result [ name ] ) ; 
function ( names ) { var t = this ; var result = { } ; names . forEach ( function ( name ) { var pos = name . indexOf ( "*" ) ; if ( pos < 0 ) { result [ name ] = true ; } else { var prefix = name . substring ( 0 , pos ) ; t . getAnalyser ( ) . getLibraries ( ) . forEach ( function ( lib ) { var symbols = lib . getKnownSymbols ( ) ; for ( var symbol in symbols ) { if ( symbols [ symbol ] == "class" && symbol . startsWith ( prefix ) ) { result [ symbol ] = true ; } } } ) ; } } ) ; return Object . keys ( result ) ; } 
function ( value , oldValue ) { var loader = path . join ( __dirname , "loader-" + ( this . isBrowserApp ( ) ? "browser" : "server" ) + ".tmpl.js" ) ; this . setLoaderTemplate ( loader ) ; this . setTheme ( null ) ; } 
function ( value ) { if ( ! value ) { return null ; } if ( ! qx . lang . Type . isArray ( value ) ) { return [ value ] ; } return value ; } 
function ( include , exclude ) { var code = [ ] ; if ( exclude ) { exclude . forEach ( spec => { var pos ; if ( ( pos = spec . indexOf ( "*" ) ) > - 1 ) { code . push ( " if (value.startsWith(\"" + spec . substring ( 0 , pos ) + "\"))\n return null; // " + spec ) ; } else { code . push ( " if (value === \"" + spec + "\")\n return null;" ) ; } } ) ; } if ( include ) { include . forEach ( spec => { var pos ; pos = - 1 ; var nsDepth = 0 ; while ( ( pos = spec . indexOf ( "." , pos + 1 ) ) > - 1 ) { nsDepth ++ ; } if ( ( pos = spec . indexOf ( "*" ) ) > - 1 ) { code . push ( " if (value.startsWith(\"" + spec . substring ( 0 , pos ) + "\"))\n return " + nsDepth + "; // " + spec ) ; } else { code . push ( " if (value === \"" + spec + "\")\n return \"exact\";" ) ; } } ) ; } code . push ( " return null;" ) ; return new Function ( "value" , code . join ( "\n" ) ) ; } 
async function ( compileInfo ) { var t = this ; var application = compileInfo . application ; var targetUri = t . _getOutputRootUri ( application ) ; var appRootDir = this . getApplicationRoot ( application ) ; var mapTo = this . getPathMapping ( path . join ( appRootDir , this . getOutputDir ( ) , "transpiled/" ) ) ; var sourceUri = mapTo ? mapTo : targetUri + "transpiled/" ; 
function AbstractError ( msg , code , constr ) { Error . captureStackTrace ( this , constr || this ) ; this . message = msg || "Error" ; this . code = code || "EUNKNOWN" ; } 
function mkpath ( dir , cb ) { dir = path . normalize ( dir ) ; var segs = dir . split ( path . sep ) ; var made = "" ; async . eachSeries ( segs , function ( seg , cb ) { if ( made . length || ! seg . length ) { made += "/" ; } made += seg ; fs . exists ( made , function ( exists ) { if ( ! exists ) { fs . mkdir ( made , function ( err ) { if ( err && err . code === "EEXIST" ) { err = null ; } cb ( err ) ; } ) ; return ; } fs . stat ( made , function ( err , stat ) { if ( err ) { cb ( err ) ; } else if ( stat . isDirectory ( ) ) { cb ( null ) ; } else { cb ( new Error ( "Cannot create " + made + " (in " + dir + ") because it exists and is not a directory" , "ENOENT" ) ) ; } } ) ; } ) ; } , function ( err ) { cb ( err ) ; } ) ; } 
function promisifyThis ( fn , self , ... args ) { return new Promise ( ( resolve , reject ) => { args = args . slice ( ) ; args . push ( function ( err , result ) { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; try { fn . apply ( self , args ) ; } catch ( ex ) { reject ( ex ) ; } } ) ; } 
function ( dbFilename ) { this . base ( arguments ) ; this . __dbFilename = dbFilename || "db.json" ; this . __libraries = [ ] ; this . __librariesByNamespace = { } ; this . __initialClassesToScan = new qx . tool . compiler . utils . IndexedArray ( ) ; this . __locales = [ "en" ] ; this . __cldrs = { } ; this . __translations = { } ; this . __classFiles = { } ; this . __environmentChecks = { } ; } 
function ( ) { var t = this ; var p ; if ( ! this . __opened ) { this . __opened = true ; var resManager = null ; if ( this . isProcessResources ( ) ) { resManager = new qx . tool . compiler . resources . Manager ( this ) ; } this . __resManager = resManager ; p = Promise . all ( [ util . promisifyThis ( t . loadDatabase , t ) , new Promise ( ( resolve , reject ) => { if ( resManager ) { log . debug ( "Loading resource database" ) ; return util . promisifyThis ( resManager . loadDatabase , resManager ) . then ( resolve ) . catch ( reject ) ; } resolve ( ) ; return undefined ; } ) ] ) ; } else { p = Promise . resolve ( ) ; } return p . then ( ( ) => { log . debug ( "Scanning source code" ) ; return util . promisifyThis ( t . initialScan , t ) ; } ) . then ( ( ) => { log . debug ( "Saving database" ) ; return t . saveDatabase ( ) ; } ) ; } 
function ( cb ) { var t = this ; if ( ! this . __db ) { this . __db = { } ; } async . parallel ( [ 
function ( cb ) { if ( ! t . __resManager ) { cb ( null ) ; return ; } t . __resManager . findAllResources ( function ( err ) { if ( err ) { cb ( err ) ; return ; } log . debug ( "found all resources" ) ; cb ( null ) ; } ) ; } 
function ( cb ) { async . each ( t . __libraries , function ( library , cb ) { library . scanForClasses ( err => { log . debug ( "Finished scanning for " + library . getNamespace ( ) ) ; cb ( err ) ; } ) ; } , err => { log . debug ( "Finished scanning for all libraries" ) ; cb ( err ) ; } ) ; } 
function ( cb ) { var t = this ; async . waterfall ( [ function readDb ( cb ) { fs . exists ( t . getDbFilename ( ) , function ( exists ) { if ( exists ) { fs . readFile ( t . getDbFilename ( ) , { encoding : "utf-8" } , cb ) ; } else { cb ( null , null ) ; } } ) ; } , function parseDb ( data , cb ) { if ( data && data . trim ( ) . length ) { log . debug ( "Parsing database" ) ; t . __db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse" ) ; t . __db = { } ; } cb ( null , t . __db ) ; } ] , function ( err , result ) { log . debug ( "loaded database: err=" + err ) ; cb ( ) ; } ) ; } 
function readDb ( cb ) { fs . exists ( t . getDbFilename ( ) , function ( exists ) { if ( exists ) { fs . readFile ( t . getDbFilename ( ) , { encoding : "utf-8" } , cb ) ; } else { cb ( null , null ) ; } } ) ; } 
function parseDb ( data , cb ) { if ( data && data . trim ( ) . length ) { log . debug ( "Parsing database" ) ; t . __db = jsonlint . parse ( data ) ; } else { log . debug ( "No database to parse" ) ; t . __db = { } ; } cb ( null , t . __db ) ; } 
async function ( ) { log . debug ( "saving generator database" ) ; this . fireDataEvent ( "saveDatabase" , this . __db ) ; await qx . tool . compiler . utils . Json . saveJsonAsync ( this . getDbFilename ( ) , this . __db ) . then ( ( ) => this . __resManager && this . __resManager . saveDatabase ( ) ) ; } 
function ( cb ) { var t = this ; if ( ! this . __db ) { this . __db = { } ; } var db = this . __db ; var metaWrittenLog = { } ; var compiledClasses = { } ; var metaFixupDescendants = { } ; var listenerId = this . addListener ( "compiledClass" , function ( evt ) { var data = evt . getData ( ) ; if ( data . oldDbClassInfo ) { if ( data . oldDbClassInfo . extends ) { metaFixupDescendants [ data . oldDbClassInfo . extends ] = true ; } if ( data . oldDbClassInfo . implement ) { data . oldDbClassInfo . implement . forEach ( name => metaFixupDescendants [ name ] = true ) ; } if ( data . oldDbClassInfo . include ) { data . oldDbClassInfo . include . forEach ( name => metaFixupDescendants [ name ] = true ) ; } } if ( data . dbClassInfo . extends ) { metaFixupDescendants [ data . dbClassInfo . extends ] = true ; } if ( data . dbClassInfo . implement ) { data . dbClassInfo . implement . forEach ( name => metaFixupDescendants [ name ] = true ) ; } if ( data . dbClassInfo . include ) { data . dbClassInfo . include . forEach ( name => metaFixupDescendants [ name ] = true ) ; } compiledClasses [ data . classFile . getClassName ( ) ] = data ; } ) ; 
function ( cb ) { t . getClassInfo ( classes [ classIndex ++ ] , ( err , dbClassInfo ) => { if ( dbClassInfo ) { var deps = dbClassInfo . dependsOn ; for ( var depName in deps ) { t . _addRequiredClass ( depName ) ; } } if ( err && err . code === "ENOCLASSFILE" ) { console . error ( err . message ) ; err = null ; } return cb ( err ) ; } ) ; } 
function ( err ) { if ( err ) { cb && cb ( err ) ; return ; } classes . forEach ( function ( className ) { var info = t . __db . classInfo [ className ] ; var deps = getIndirectLoadDependencies ( className ) ; deps . forEach ( function ( depName ) { if ( ! info . dependsOn ) { info . dependsOn = { } ; } if ( ! info . dependsOn [ depName ] ) { info . dependsOn [ depName ] = { } ; } info . dependsOn [ depName ] . load = true ; } ) ; } ) ; t . removeListenerById ( listenerId ) ; analyzeMeta ( ) . then ( ( ) => cb ( ) ) . catch ( err => cb ( err ) ) ; } 
function ( className ) { let t = this ; 
function ( className , forceScan , cb ) { var t = this ; if ( ! this . __db ) { this . __db = { } ; } var db = this . __db ; if ( typeof forceScan == "function" ) { cb = forceScan ; forceScan = false ; } if ( ! db . classInfo ) { db . classInfo = { } ; } var library = t . getLibraryFromClassname ( className ) ; if ( ! library ) { let err = new Error ( "Cannot find class file " + className ) ; err . code = "ENOCLASSFILE" ; cb && cb ( err ) ; return ; } var sourceClassFilename = qx . tool . compiler . ClassFile . getSourcePath ( library , className ) ; var outputClassFilename = qx . tool . compiler . ClassFile . getOutputPath ( this , className ) ; function scanFile ( stat , outputStat ) { var dbClassInfo = db . classInfo [ className ] ; if ( dbClassInfo && outputStat ) { var dbMtime = null ; try { dbMtime = dbClassInfo . mtime && new Date ( dbClassInfo . mtime ) ; } catch ( e ) { } if ( dbMtime && dbMtime . getTime ( ) == stat . mtime . getTime ( ) ) { if ( outputStat . mtime . getTime ( ) >= stat . mtime . getTime ( ) ) { cb && cb ( null , dbClassInfo ) ; return ; } } } 
async function ( locale ) { var t = this ; var cldr = this . __cldrs [ locale ] ; if ( cldr ) { return cldr ; } return qx . tool . compiler . app . Cldr . loadCLDR ( locale ) . then ( cldr => t . __cldrs [ locale ] = cldr ) ; } 
async function ( library , locale ) { var t = this ; var id = locale + ":" + library . getNamespace ( ) ; var translation = t . __translations [ id ] ; if ( ! translation ) { translation = t . __translations [ id ] = new qx . tool . compiler . app . Translation ( library , locale ) ; await translation . checkRead ( ) ; } return translation ; } 
function ( library , locales ) { const Promisify = qx . tool . compiler . utils . Promisify ; return Promise . all ( locales . map ( locale => { var translation = new qx . tool . compiler . app . Translation ( library , locale ) ; return translation . read ( ) . then ( ( ) => { let unusedEntries = { } ; for ( let msgid in translation . getEntries ( ) ) unusedEntries [ msgid ] = true ; return Promise . all ( this . __classes . map ( async classname => { if ( ! classname . startsWith ( library . getNamespace ( ) ) ) { return ; } let dbClassInfo = await Promisify . call ( cb => this . getClassInfo ( classname , cb ) ) ; if ( ! dbClassInfo . translations ) return ; dbClassInfo . translations . forEach ( function ( src ) { var entry = translation . getOrCreateEntry ( src . msgid ) ; delete unusedEntries [ src . msgid ] ; if ( src . msgid_plural ) { entry . msgid_plural = src . msgid_plural ; } if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = src . comment ; entry . comments . reference = { } ; let ref = entry . comments . reference ; const fileName = classname . replace ( / \. / g , "/" ) + ".js" ; const fnAddReference = lineNo => { let arr = ref [ fileName ] ; if ( ! arr ) arr = ref [ fileName ] = [ ] ; if ( ! arr . includes ( src . lineNo ) ) { arr . push ( lineNo ) ; } } ; if ( qx . lang . Type . isArray ( src . lineNo ) ) { src . lineNo . forEach ( fnAddReference ) ; } else { fnAddReference ( src . lineNo ) ; } } ) ; } ) ) . then ( ( ) => { Object . keys ( unusedEntries ) . forEach ( msgid => { var entry = translation . getEntry ( msgid ) ; if ( entry ) { if ( ! entry . comments ) { entry . comments = { } ; } entry . comments . extracted = "NO LONGER USED" ; entry . comments . reference = { } ; } } ) ; } ) ; } ) . then ( ( ) => translation . write ( ) ) ; } ) ) ; } 
function ( name ) { var t = this ; for ( var j = 0 ; j < t . __libraries . length ; j ++ ) { var library = t . __libraries [ j ] ; var info = library . getSymbolType ( name ) ; if ( info ) { return info ; } } return null ; } 
function ( className ) { var t = this ; var info = this . __classFiles [ className ] ; if ( info ) { return info . library ; } for ( var j = 0 ; j < t . __libraries . length ; j ++ ) { var library = t . __libraries [ j ] ; info = library . getSymbolType ( className ) ; if ( info && ( info . symbolType == "class" || info . symbolType == "member" ) ) { return library ; } } return null ; } 
function ( className ) { var library = this . getLibraryFromClassname ( className ) ; if ( ! library ) { return null ; } var path = library . getRootDir ( ) + "/" + library . getSourcePath ( ) + "/" + className . replace ( / \. / g , "/" ) + ".js" ; return path ; } 
function ( key , value ) { if ( typeof key == "object" ) { var map = key ; for ( key in map ) { this . __environmentChecks [ key ] = map [ key ] ; } } else if ( value === undefined ) { delete this . __environmentChecks [ key ] ; } else { this . __environmentChecks [ key ] = value ; } } 
function ( ) { if ( this . __qooxdooVersion ) { return this . __qooxdooVersion ; } if ( ! this . __qooxdooVersion ) { let lib = this . findLibrary ( "qx" ) ; if ( lib ) { this . __qooxdooVersion = lib . getVersion ( ) ; } } return this . __qooxdooVersion ; } 
function ( ) { var m = this . __dbFilename . match ( / (^.*)\/([^/]+)$ / ) ; var resDb ; if ( m && m . length == 3 ) { resDb = m [ 1 ] + "/resource-db.json" ; } else { resDb = "resource-db.json" ; } return resDb ; } 
function ( comment ) { var current = { name : "@description" , body : "" } ; var cmds = [ current ] ; if ( typeof comment == "string" ) { comment = comment . split ( "\n" ) ; } comment . forEach ( function ( line ) { 
function ( ) { ------------------------------------------------------------------------- Below is your actual application code... ------------------------------------------------------------------------- */ 
async function ( ) { this . argv . watch = true ; this . argv [ "machine-readable" ] = false ; this . argv [ "feedback" ] = false ; return this . base ( arguments ) . then ( ( ) => this . runWebServer ( ) ) ; } 
function ( ) { ------------------------------------------------------------------------- Below is your actual application code... Remove or edit the following code to create your application. ------------------------------------------------------------------------- */ var login = new $ { namespace } . page . Login ( ) ; var overview = new $ { namespace } . page . Overview ( ) ; 
function ( ) { return path . join ( process . cwd ( ) , qx . tool . cli . ConfigSchemas . lockfile . filename ) ; } 
async function ( ) { let contrib_json_path = this . getContribFileName ( ) ; if ( ! await fs . existsAsync ( contrib_json_path ) ) { return { version : qx . tool . cli . ConfigSchemas . lockfile . version , libraries : [ ] } ; } return qx . tool . compiler . utils . Json . loadJsonAsync ( contrib_json_path ) ; } 
async function ( repo_name , library_name ) { let library = ( await this . getContribData ( ) ) . libraries . find ( lib => lib . repo_name === repo_name && lib . library_name === library_name ) ; return library ? library . repo_tag : false ; } 
async function ( library_name ) { return ( await this . getContribData ( ) ) . libraries . find ( lib => lib . library_name === library_name ) ; } 
function ( readFromFile = false ) { if ( ! readFromFile && this . __cache && typeof this . __cache == "object" ) { return this . __cache ; } try { this . __cache = jsonlint . parse ( fs . readFileSync ( this . getCachePath ( ) , "UTF-8" ) ) ; } catch ( e ) { this . __cache = { repos : { list : [ ] , data : { } } , compat : { } } ; } return this . __cache ; } 
async function ( ) { await qx . tool . cli . Utils . makeParentDir ( this . getCachePath ( ) ) ; await fs . writeFileAsync ( this . getCachePath ( ) , JSON . stringify ( this . __cache , null , 2 ) , "UTF-8" ) ; } 
async function ( path ) { return fs . writeFileAsync ( path , JSON . stringify ( this . __cache , null , 2 ) , "UTF-8" ) . catch ( e => console . error ( ` ${ path } ` + e . message ) ) ; } 
function expandMemberExpression ( str ) { var segs = str . split ( "." ) ; var expr = types . memberExpression ( types . identifier ( segs [ 0 ] ) , types . identifier ( segs [ 1 ] ) ) ; for ( var i = 2 ; i < segs . length ; i ++ ) { expr = types . memberExpression ( expr , types . identifier ( segs [ i ] ) ) ; } return expr ; } 
function ( analyser , className , library ) { this . base ( arguments ) ; this . __analyser = analyser ; this . __className = className ; this . __metaStack = [ ] ; this . __metaDefinitions = { } ; this . __library = library ; this . __sourceFilename = qx . tool . compiler . ClassFile . getSourcePath ( library , className ) ; this . __requiredClasses = { } ; this . __environmentChecks = { provided : { } , required : { } } ; this . __requiredAssets = [ ] ; this . __translations = [ ] ; this . __markers = [ ] ; this . __haveMarkersFor = { } ; this . __scope = { parent : null , vars : { } , unresolved : { } } ; this . __taskQueueDrains = [ ] ; this . __taskQueue = async . queue ( function ( task , cb ) { task ( cb ) ; } ) ; this . __taskQueue . drain = this . _onTaskQueueDrain ; this . __taskQueue . error = err => { this . error ( err . stack || err ) ; } ; } 
function ( callback ) { var t = this ; var className = this . __className ; t . __fatalCompileError = false ; t . __numClassesDefined = 0 ; fs . readFile ( this . getSourcePath ( ) , { encoding : "utf-8" } , function ( err , src ) { if ( err ) { callback ( err ) ; return ; } try { let options = t . __analyser . getBabelOptions ( ) || { } ; options . modules = false ; var config = { babelrc : false , sourceFileName : t . getSourcePath ( ) , filename : t . getSourcePath ( ) , sourceMaps : true , "presets" : [ [ require . resolve ( "@babel/preset-env" ) , options ] ] , plugins : [ t . _babelClassPlugin ( ) ] , parserOpts : { sourceType : "script" } , passPerPreset : true } ; var result = babelCore . transform ( src , config ) ; } catch ( ex ) { if ( ex . _babel ) { console . log ( ex ) ; } t . addMarker ( "compiler.syntaxError" , ex . loc , ex . message , ex . codeFrame ) ; t . __fatalCompileError = true ; t . _compileDbClassInfo ( ) ; callback ( ) ; return ; } if ( ! t . __numClassesDefined ) { t . addMarker ( "compiler.missingClassDef" ) ; t . __fatalCompileError = true ; t . _compileDbClassInfo ( ) ; callback ( ) ; return ; } if ( ! t . __metaDefinitions [ className ] ) { t . addMarker ( "compiler.wrongClassName" , null , className , Object . keys ( t . __metaDefinitions ) . join ( ", " ) ) ; t . _compileDbClassInfo ( ) ; } var pos = className . lastIndexOf ( "." ) ; var name = pos > - 1 ? className . substring ( pos + 1 ) : className ; var outputPath = t . getOutputPath ( ) ; util . mkParentPath ( outputPath , function ( err ) { if ( err ) { callback ( err ) ; return ; } fs . writeFile ( outputPath , result . code + "\n\n//# sourceMappingURL=" + name + ".js.map?dt=" + ( new Date ( ) . getTime ( ) ) , { encoding : "utf-8" } , function ( err ) { if ( err ) { callback ( err ) ; return ; } fs . writeFile ( outputPath + ".map" , JSON . stringify ( result . map , null , 2 ) , { encoding : "utf-8" } , function ( err ) { if ( err ) { callback ( err ) ; return ; } t . _waitForTaskQueueDrain ( function ( ) { callback ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } 
function ( dbClassInfo ) { delete dbClassInfo . unresolved ; delete dbClassInfo . dependsOn ; delete dbClassInfo . assets ; delete dbClassInfo . translations ; delete dbClassInfo . markers ; delete dbClassInfo . fatalCompileError ; for ( var key in this . __dbClassInfo ) { dbClassInfo [ key ] = this . __dbClassInfo [ key ] ; } } 
function ( ) { var t = this ; var dbClassInfo = this . __dbClassInfo = { } ; 
function ( ) { var t = this ; function getKeyName ( key ) { var keyName = key . type == "StringLiteral" ? key . value : key . name ; return keyName ; } function enterFunction ( path , isClassMember ) { var node = path . node ; if ( node . id ) { t . addDeclaration ( node . id . name ) ; } t . pushScope ( node . id ? node . id . name : null , node , isClassMember ) ; for ( var i = 0 ; i < node . params . length ; i ++ ) { t . addDeclaration ( node . params [ i ] . name ) ; } } function exitFunction ( path ) { var node = path . node ; t . popScope ( node ) ; } var FUNCTION_DECL_OR_EXPR = { enter : enterFunction , exit : exitFunction } ; function getJsDoc ( comment ) { if ( ! comment ) { return null ; } if ( ! qx . lang . Type . isArray ( comment ) ) { comment = [ comment ] ; } var result = { } ; comment . forEach ( comment => { var tmp = qx . tool . compiler . jsdoc . Parser . parseComment ( comment . value ) ; for ( var key in tmp ) { var value = tmp [ key ] ; if ( ! result [ key ] ) { result [ key ] = value ; } else { qx . lang . Array . append ( result [ key ] , value ) ; } } } ) ; return result ; } function makeMeta ( sectionName , functionName , node ) { var meta ; if ( functionName ) { var section = t . __classMeta [ sectionName ] ; if ( section === undefined ) { section = t . __classMeta [ sectionName ] = { } ; } meta = section [ functionName ] ; if ( meta === undefined ) { meta = section [ functionName ] = { } ; } } else { meta = t . __classMeta [ sectionName ] ; if ( meta === undefined ) { meta = t . __classMeta [ sectionName ] = { } ; } } meta . location = node . loc ; if ( node . leadingComments ) { var jsdoc = getJsDoc ( node . leadingComments ) ; if ( jsdoc ) { if ( jsdoc [ "@ignore" ] ) { jsdoc [ "@ignore" ] . forEach ( function ( elem ) { t . addIgnore ( elem . body ) ; } ) ; } meta . jsdoc = jsdoc ; } } if ( sectionName === "members" || sectionName === "statics" ) { if ( node . type == "ObjectMethod" || node . value . type === "FunctionExpression" ) { meta . type = "function" ; } else { meta . type = "variable" ; } if ( functionName . startsWith ( "__" ) ) { meta . access = "private" ; } else if ( functionName . startsWith ( "_" ) ) { meta . access = "protected" ; } else { meta . access = "public" ; } } return meta ; } var needsQxCoreEnvironment = false ; var COLLECT_CLASS_NAMES_VISITOR = { MemberExpression ( path ) { var self = this ; var str = collapseMemberExpression ( path . node ) ; t . _requireClass ( str , { location : path . node . loc } ) ; var info = t . __analyser . getSymbolType ( str ) ; if ( info && info . symbolType == "class" ) { self . collectedClasses . push ( str ) ; } } } ; const CODE_ELIMINATION_VISITOR = { CallExpression ( path ) { const name = collapseMemberExpression ( path . node . callee ) ; if ( ( name === "qx.core.Environment.select" || name === "qx.core.Environment.get" ) && types . isLiteral ( path . node . arguments [ 0 ] ) ) { const arg = path . node . arguments [ 0 ] ; const env = t . __analyser . getEnvironment ( ) ; const envValue = env [ arg . value ] ; if ( envValue !== undefined ) { if ( name === "qx.core.Environment.get" ) { path . skip ( ) ; path . replaceWithSourceString ( formatValueAsCode ( envValue ) ) ; return ; } else if ( name === "qx.core.Environment.select" ) { const subPath = path . get ( "arguments.1" ) ; let option = subPath . node . properties . find ( prop => prop . key . value === envValue . toString ( ) ) ; if ( ! option ) { 
function ( className ) { var pos = className . lastIndexOf ( "." ) ; var meta = { className : className , packageName : pos > - 1 ? className . substring ( 0 , pos ) : null , name : pos > - 1 ? className . substring ( pos + 1 ) : className , superClass : null , interfaces : [ ] , mixins : [ ] , functionName : null } ; this . __metaStack . push ( meta ) ; this . __classMeta = meta ; this . __metaDefinitions [ className ] = meta ; this . __numClassesDefined ++ ; } 
function ( className ) { if ( ! this . __metaStack . length ) { throw new Error ( "No __metaStack entries to pop" ) ; } let meta = this . __metaStack [ this . __metaStack . length - 1 ] ; if ( className && meta . className != className ) { throw new Error ( "Wrong __metaStack entries to pop, expected " + className + " found " + meta . className ) ; } this . __metaStack . pop ( ) ; meta = this . __metaStack [ this . __metaStack . length - 1 ] || null ; this . __classMeta = meta ; } 
function ( functionName , node , isClassMember ) { this . __scope = { functionName : functionName , parent : this . __scope , vars : { } , unresolved : { } , isClassMember : ! ! isClassMember } ; } 
function ( node ) { var old = this . __scope ; var scope = this . __scope = this . __scope . parent ; var unresolved = scope . unresolved ; for ( var name in old . unresolved ) { var entry = unresolved [ name ] ; if ( ! entry ) { entry = unresolved [ name ] = { name : name , locations : [ ] } ; } entry . locations . push . apply ( entry . locations , old . unresolved [ name ] . locations ) ; } } 
function ( name , valueName ) { if ( this . __scope . vars [ name ] === undefined ) { this . __scope . vars [ name ] = valueName || true ; var unresolved = this . __scope . unresolved ; delete unresolved [ name ] ; var re = new RegExp ( name + "\\." ) ; for ( var tmp in unresolved ) { if ( re . test ( tmp ) ) { delete unresolved [ tmp ] ; } } } } 
function ( name ) { var pos = name . indexOf ( "." ) ; if ( pos > - 1 ) { name = name . substring ( 0 , pos ) ; } for ( var tmp = this . __scope ; tmp ; tmp = tmp . parent ) { if ( tmp . vars [ name ] !== undefined ) { return true ; } } return false ; } 
function ( name , loc ) { var str = "" ; for ( var i = 0 ; i < name . length ; i ++ ) { if ( i ) { str += "." ; } str += name [ i ] ; if ( qx . tool . compiler . ClassFile . GLOBAL_SYMBOLS [ str ] || this . isIgnored ( str ) ) { return ; } } name = name . join ( "." ) ; if ( name == this . __className || name . startsWith ( this . __className + "." ) || name . startsWith ( "(" ) ) { return ; } if ( name == "qx.ui.tooltip.ToolTip" ) debugger ; var scope = this . __scope ; if ( scope . vars [ name ] !== undefined ) { return ; } if ( ! scope . unresolved [ name ] ) { scope . unresolved [ name ] = { name : name , locations : loc ? [ loc ] : [ ] , load : this . isLoadScope ( ) , defer : this . __inDefer } ; } else if ( loc ) { scope . unresolved [ name ] . locations . push ( loc ) ; } } 
function ( name ) { delete this . __scope . unresolved [ name ] ; var stub = name + "." ; for ( var id in this . __scope . unresolved ) { if ( id . startsWith ( stub ) ) { delete this . __scope . unresolved [ id ] ; } } } 
function ( name ) { var scope = this . __scope ; if ( ! scope . ignore ) { scope . ignore = { } ; } var segs = name . split ( "," ) ; segs . forEach ( name => { if ( name . endsWith ( ".*" ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 2 ) ; } else if ( name . endsWith ( "*" ) ) { scope . ignore [ name ] = name . substring ( 0 , name . length - 1 ) ; } else { scope . ignore [ name ] = true ; } } ) ; } 
function ( name ) { for ( var tmp = this . __scope ; tmp ; tmp = tmp . parent ) { if ( tmp . ignore ) { if ( tmp . ignore [ name ] ) { return true ; } for ( var key in tmp . ignore ) { if ( tmp . ignore [ key ] !== true ) { if ( name . startsWith ( tmp . ignore [ key ] ) ) { return true ; } } } } } return false ; } 
function ( name , location ) { var t = this ; var requiredOpts = { load : t . isLoadScope ( ) , defer : t . __inDefer , construct : t . __classMeta && t . __classMeta . functionName == "$$constructor" , location : location } ; var dest = t . __environmentChecks . required [ name ] ; if ( ! dest ) { dest = t . __environmentChecks . required [ name ] = { } ; } if ( requiredOpts . load ) { dest . load = true ; } if ( requiredOpts . defer ) { dest . defer = true ; } if ( requiredOpts . construct ) { dest . construct = true ; } t . _requireClass ( "qx.core.Environment" , { location : location } ) ; if ( qx . tool . compiler . ClassFile . ENVIRONMENT_CONSTANTS [ name ] === undefined ) { var entry = qx . tool . compiler . ClassFile . ENVIRONMENT_CHECKS [ name ] ; if ( entry && entry . className ) { t . _requireClass ( entry . className , { load : requiredOpts . load , location : location } ) ; dest . className = entry . className ; } else if ( ! entry ) { t . _requireClass ( name , { load : requiredOpts . load , location : location } ) ; } } } 
function ( msgId , pos ) { msgId = "qx.tool.compiler." + msgId ; 
function ( name , opts ) { if ( qx . lang . Type . isArray ( name ) ) { name . forEach ( name => this . _requireClass ( name ) ) ; return null ; } let t = this ; if ( name == this . __className ) { return null ; } if ( ! name ) { throw new Error ( "No classname" ) ; } if ( this . isIgnored ( name ) ) { return null ; } let requireOpts = { load : t . isLoadScope ( ) , defer : t . __inDefer , construct : t . __classMeta && t . __classMeta . functionName == "$$constructor" } ; if ( opts ) { for ( let key in opts ) { requireOpts [ key ] = opts [ key ] ; } } let info = t . __analyser . getSymbolType ( name ) ; let symbolType = info ? info . symbolType : null ; let className = info ? info . className : null ; if ( symbolType != "package" && className && className != t . __className ) { 
function ( path ) { if ( path . indexOf ( "/" ) < 0 && path . indexOf ( "." ) > - 1 ) { path = path . replace ( / \. / g , "/" ) ; } if ( ! qx . lang . Array . contains ( this . __requiredAssets , path ) ) { this . __requiredAssets . push ( path ) ; } } 
function ( library , className ) { return pathModule . join ( library . getRootDir ( ) , library . getSourcePath ( ) , className . replace ( / \. / g , pathModule . sep ) + ".js" ) ; } 
function ( analyser , className ) { var filename = pathModule . join ( analyser . getOutputDir ( ) , "transpiled" , className . replace ( / \. / g , pathModule . sep ) + ".js" ) ; return filename ; } 
function ( array , searchElement ) { var minIndex = 0 ; var maxIndex = array . length - 1 ; var currentIndex ; var currentElement ; while ( minIndex <= maxIndex ) { currentIndex = ( minIndex + maxIndex ) / 2 | 0 ; currentElement = array [ currentIndex ] ; if ( currentElement < searchElement ) { minIndex = currentIndex + 1 ; } else if ( currentElement > searchElement ) { maxIndex = currentIndex - 1 ; } else { return currentIndex ; } } return - 1 ; } 
async function ( ) { let compile = await this . parseCompileConfig ( ) ; for ( let target of compile . targets ) { await this . __removePath ( path . join ( process . cwd ( ) , target . outputPath ) ) ; } await this . __removePath ( path . join ( process . cwd ( ) , "contrib" ) ) ; } 
function getPages ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; var pages = [ ] ; var order = { } ; if ( metadata . site . pages ) metadata . site . pages . forEach ( ( url , index ) => typeof url == "string" ? order [ url ] = index : null ) ; var unorderedPages = [ ] ; function addPage ( url , title ) { var page = { url : url , title : title } ; var index = order [ url ] ; if ( index !== undefined ) pages [ index ] = page ; else unorderedPages . push ( page ) ; } for ( var filename in files ) { var file = files [ filename ] ; if ( filename == "index.html" ) addPage ( "/" , file . title || "Home Page" ) ; else if ( file . permalink || file . navigation ) addPage ( file . permalink || filename , file . title || "Home Page" ) ; } unorderedPages . forEach ( page => pages . push ( page ) ) ; metadata . site . pages = pages ; done ( ) ; } 
function loadPartials ( files , metalsmith , done ) { var metadata = metalsmith . metadata ( ) ; fs . readdirAsync ( "./partials" , "utf8" ) . then ( files => { var promises = files . map ( filename => { var m = filename . match ( / ^(.+)\.([^.]+)$ / ) ; if ( ! m ) return ; var name = m [ 1 ] ; var ext = m [ 2 ] ; return fs . readFileAsync ( "partials/" + filename , "utf8" ) . then ( data => { var fn ; try { fn = dot . template ( data ) ; } catch ( err ) { console . log ( "Failed to load partial " + filename + ": " + err ) ; return ; } fn . name = filename ; metadata . partials [ filename ] = fn ; if ( ext == "html" ) metadata . partials [ name ] = fn ; } ) ; } ) ; return Promise . all ( promises ) ; } ) . then ( ( ) => done ( ) ) . catch ( err => done ( err ) ) ; } 
function generateSite ( ) { return new Promise ( ( resolve , reject ) => { Metalsmith ( __dirname ) . metadata ( { site : { title : "Qooxdoo Application Server" , description : "Mini website used by \"qx serve\"" , email : "info@qooxdoo.org" , twitter_username : "qooxdoo" , github_username : "qooxdoo" , pages : [ "/" , "/about/" ] } , baseurl : "" , url : "" , lang : "en" , partials : { } } ) . source ( './src' ) . destination ( './build' ) . clean ( true ) . use ( loadPartials ) . use ( markdown ( ) ) . use ( getPages ) . use ( layouts ( { engine : 'dot' } ) ) . build ( function ( err ) { if ( err ) reject ( err ) ; else resolve ( ) ; } ) ; } ) ; } 
function compileScss ( ) { return new Promise ( ( resolve , reject ) => { sass . render ( { file : "sass/qooxdoo.scss" , outFile : "build/qooxdoo.css" } , function ( err , result ) { if ( err ) reject ( err ) ; else resolve ( result ) ; } ) ; } ) . then ( result => fs . writeFileAsync ( "build/qooxdoo.css" , result . css , "utf8" ) ) ; } 
function ( ) { return { command : "list [repository]" , describe : "if no repository name is given, lists all available contribs that are compatible with the project's qooxdoo version (\"--all\" lists incompatible ones as well). Otherwise, list all compatible contrib libraries." , builder : { all : { alias : "a" , describe : "Show all versions, including incompatible ones" } , verbose : { alias : "v" , describe : "Verbose logging" } , quiet : { alias : "q" , describe : "No output" } , json : { alias : "j" , describe : "Output list as JSON literal" } , installed : { alias : "i" , describe : "Show only installed libraries" } , namespace : { alias : "n" , describe : "Display library namespace" } , match : { alias : "m" , describe : "Filter by regular expression (case-insensitive)" } , "libraries" : { alias : "l" , describe : "List libraries only (no repositories)" } , "short" : { alias : "s" , describe : "Omit title and description to make list more compact" } , "noheaders" : { alias : "H" , describe : "Omit header and footer" } } , handler : function ( argv ) { return new qx . tool . cli . commands . contrib . List ( argv ) . process ( ) . catch ( e => { console . error ( e . stack || e . message ) ; process . exit ( 1 ) ; } ) ; } } ; } 
async function ( ) { this . __repositories = [ ] ; this . __libraries = { } ; this . __latestCompatible = { } ; const localPathRepoName = this . self ( arguments ) . localPathRepoName ; let repos_cache = this . getCache ( ) . repos ; 
async function ( qooxdoo_version ) { if ( this . argv . installed ) { 
async function ( ) { 
function ( library , locale ) { this . base ( arguments ) ; this . setLibrary ( library ) ; if ( locale ) { this . setLocale ( locale ) ; } this . __translations = { } ; this . __headers = { } ; } 
async function ( ) { if ( ! this . __mtime ) { return this . read ( ) ; } var poFile = this . getPoFilename ( ) ; let stat = await qx . tool . compiler . files . Utils . safeStat ( poFile ) ; if ( stat && this . __mtime == stat . mtime ) { return undefined ; } return this . read ( ) ; } 
function ( ) { var t = this ; if ( t . __onRead ) { return t . __onRead ; } return t . __onRead = new Promise ( ( resolve , reject ) => { t . __translations = { } ; t . __headers = { } ; var poFile = this . getPoFilename ( ) ; fs . stat ( poFile , function ( err , stat ) { if ( err ) { if ( err . code == "ENOENT" ) { resolve ( ) ; return undefined ; } reject ( err ) ; return undefined ; } t . __mtime = stat . mtime ; return readFile ( poFile , { encoding : "utf8" } ) . then ( data => { var entry = null ; var lastKey = null ; function saveEntry ( ) { if ( entry ) { var key ; if ( entry . msgctxt ) { key = entry . msgctxt + ":" + entry . msgid ; } else { key = entry . msgid ; } t . __translations [ key ] = entry ; } entry = null ; lastKey = null ; } function set ( key , value , append ) { var index = null ; var m = key . match ( / ^([^[]+)\[([0-9]+)\]$ / ) ; if ( m ) { key = m [ 1 ] ; index = parseInt ( m [ 2 ] ) ; if ( entry [ key ] === undefined ) { entry [ key ] = [ ] ; } if ( ! append || typeof entry [ key ] [ index ] !== "string" ) { entry [ key ] [ index ] = value ; } else { entry [ key ] [ index ] += value ; } } else if ( ! append || typeof entry [ key ] !== "string" ) { entry [ key ] = value ; } else { entry [ key ] += value ; } } data . split ( "\n" ) . forEach ( function ( line , lineNo ) { line = line . trim ( ) ; if ( ! line ) { saveEntry ( ) ; return ; } if ( ! entry ) { entry = { } ; } 
function ( filename , cb ) { var t = this ; var lines = [ ] ; function write ( key , value ) { if ( value === undefined || value === null ) { return ; } value = value . replace ( / \t / g , "\\t" ) . replace ( / \r / g , "\\r" ) . replace ( / \n / g , "\\n" ) . replace ( / " / g , "\\\"" ) ; lines . push ( key + " \"" + value + "\"" ) ; } for ( var msgid in t . __translations ) { var entry = t . __translations [ msgid ] ; if ( entry . comments ) { if ( entry . comments . translator ) { lines . push ( "# " + entry . comments . translator ) ; } if ( entry . comments . extracted ) { lines . push ( "#. " + entry . comments . extracted ) ; } if ( entry . comments . reference ) { let refStr = "#:" ; const ref = entry . comments . reference ; for ( let classname in ref ) { if ( ref [ classname ] ) { for ( let lineNo of ref [ classname ] ) { const addStr = " " + classname + ":" + lineNo ; if ( refStr . length + addStr . length > 78 ) { 
function ( id ) { var t = this ; var entry = t . __translations [ id ] ; if ( ! entry ) { entry = t . __translations [ id ] = { msgid : id } ; } return entry ; } 
async function ( ) { let qooxdooJsonPath = path . join ( process . cwd ( ) , "qooxdoo.json" ) ; let data = { } ; if ( await fs . existsAsync ( qooxdooJsonPath ) ) { data = await this . parseJsonFile ( qooxdooJsonPath ) ; } else { if ( await fs . existsAsync ( path . join ( process . cwd ( ) , "Manifest.json" ) ) ) { data . libraries = [ { path : "." } ] ; } if ( await fs . existsAsync ( path . join ( process . cwd ( ) , "compile.json" ) ) ) { data . applications = [ { path : "." } ] ; } else if ( await fs . existsAsync ( path . join ( process . cwd ( ) , "demo/default/compile.json" ) ) ) { data . applications = [ { path : "demo/default" } ] ; } } return data ; } 
async function ( ) { let { libraries } = await this . getProjectData ( ) ; if ( libraries instanceof Array && libraries . length ) { return path . resolve ( process . cwd ( ) , libraries [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . UserError ( "Cannot find library path - are you in the right directory?" ) ; } 
async function ( ) { let { applications } = await this . getProjectData ( ) ; if ( applications instanceof Array && applications . length ) { return path . resolve ( process . cwd ( ) , applications [ 0 ] . path ) ; } throw new qx . tool . cli . Utils . UserError ( "Cannot find application path - are you in the right directory?" ) ; } 
async function ( filePath ) { var data = await fs . readFileAsync ( filePath , "utf8" ) ; try { let compileAst = JsonToAst . parseToAst ( data , { verbose : true } ) ; let compileJson = JsonToAst . astToObject ( compileAst ) ; return compileJson ; } catch ( e ) { throw new qx . tool . cli . Utils . UserError ( ` ${ filePath } ` + e . message ) ; } } 
async function ( ) { let compileJsonPath = null ; try { path . join ( await this . getApplicationPath ( ) , "compile.json" ) ; } catch ( ex ) { 
async function ( ) { let qxpath = await this . getAppQxPath ( ) ; return path . isAbsolute ( qxpath ) ? qxpath : path . resolve ( qxpath ) ; } 
async function ( libPath ) { let manifestPath = path . join ( libPath , "Manifest.json" ) ; let manifest = await this . parseJsonFile ( manifestPath ) ; let version ; try { version = manifest . info . version ; } catch ( e ) { throw new qx . tool . cli . Utils . UserError ( ` ` ) ; } if ( ! semver . valid ( version ) ) { throw new qx . tool . cli . Utils . UserError ( ` ${ manifestPath } ${ version } ` ) ; } return version ; } 
function ( cmd , args ) { let opts = { env : process . env } ; return new Promise ( ( resolve , reject ) => { let exe = child_process . spawn ( cmd , args , opts ) ; 
function ( cmd ) { return new Promise ( ( resolve , reject ) => { child_process . exec ( cmd , ( err , stdout , stderr ) => { if ( err ) { reject ( err ) ; } if ( stderr ) { reject ( new Error ( stderr ) ) ; } resolve ( stdout ) ; } ) ; } ) ; } 
function ( yargs , classNames , packageName ) { let pkg = null ; packageName . split ( "." ) . forEach ( seg => { if ( pkg === null ) { pkg = window [ seg ] ; } else { pkg = pkg [ seg ] ; } } ) ; classNames . forEach ( cmd => { require ( "../../../" + packageName . replace ( / \. / g , "/" ) + "/" + cmd ) ; let data = pkg [ cmd ] . getYargsCommand ( ) ; yargs . command ( data ) ; } ) ; } 
function ( msgId , ... args ) { for ( var i = 0 ; i < args . length ; i ++ ) { var arg = args [ i ] ; if ( typeof arg !== "string" && typeof arg !== "number" && arg !== null ) { args [ i ] = String ( arg ) ; } } if ( this . isMachineReadable ( ) ) { let str = "##" + msgId + ":" + JSON . stringify ( args ) ; console . log ( str ) ; } else { var writer = this . getWriter ( ) ; let str = this . decode ( msgId , ... args ) ; if ( writer ) { writer ( str , msgId , ... args ) ; } else { console . log ( str ) ; } } } 
function ( msgId , ... args ) { var msg = qx . tool . compiler . Console . MESSAGE_IDS [ msgId ] || msgId ; var str = qx . lang . String . format ( msg . message , args || [ ] ) ; return str ; } 
function ( obj , type ) { for ( var id in obj ) { this . MESSAGE_IDS [ id ] = { id : id , message : obj [ id ] , type : type || "message" } ; } } 
function ( marker , showPosition ) { var msg = qx . tool . compiler . Console . MESSAGE_IDS [ marker . msgId ] || marker . msgId ; var str = "" ; var pos = marker . pos ; if ( showPosition !== false && pos && pos . start && pos . start . line ) { str += "[" + pos . start . line ; if ( pos . start . column ) { str += "," + pos . start . column ; } if ( pos . end && pos . end . line && pos . end . line !== pos . start . line && pos . end . column !== pos . start . column ) { str += " to " + pos . end . line ; if ( pos . end . column ) { str += "," + pos . end . column ; } } str += "] " ; } str += qx . lang . String . format ( msg . message , marker . args || [ ] ) ; return str ; } 
async function ( ) { var parsedArgs = await this . __parseImpl ( ) ; var config = { } ; var contribConfig = { version : qx . tool . cli . ConfigSchemas . lockfile . version } ; if ( parsedArgs . config ) { config = await this . __loadJson ( parsedArgs . config ) ; let lockfile = qx . tool . cli . ConfigSchemas . lockfile . filename ; try { var name = path . join ( path . dirname ( parsedArgs . config ) , lockfile ) ; contribConfig = await this . __loadJson ( name ) ; } catch ( ex ) { 
function ( parsedArgs , config , contribConfig ) { if ( parsedArgs . config ) { var defaultTarget = parsedArgs . target || config . defaultTarget ; if ( defaultTarget ) { for ( var i = 0 ; i < config . targets . length ; i ++ ) { if ( config . targets [ i ] . type === defaultTarget ) { config . target = config . targets [ i ] ; break ; } } } if ( ! config . target ) { if ( config . targets && ( config . targets . length > 0 ) ) { config . target = config . targets [ 0 ] ; } } } else { var target = config . target = { } ; if ( parsedArgs . target ) { target . type = parsedArgs . target ; } if ( parsedArgs . outputPath ) { target . outputPath = parsedArgs . outputPath ; } } if ( ! config . locales ) { config . locales = [ ] ; } if ( parsedArgs . locales ) { parsedArgs . locales . forEach ( function ( locale ) { if ( config . locales . indexOf ( locale ) < 0 ) { config . locales . push ( locale ) ; } } ) ; } if ( typeof parsedArgs . writeAllTranslations == "boolean" ) { config . writeAllTranslations = parsedArgs . writeAllTranslations ; } if ( parsedArgs . environment ) { if ( ! config . environment ) { config . environment = { } ; } for ( var key in parsedArgs . environment ) { config . environment [ key ] = parsedArgs . environment [ key ] ; } } if ( ! config . applications ) { config . applications = [ ] ; } parsedArgs . applications . forEach ( function ( app ) { if ( ! app . appClass ) { throw new Error ( "Missing --app-class <classname> argument" ) ; } var configApp = { class : app . appClass } ; if ( app . theme ) { configApp . theme = app . theme ; } if ( app . name ) { configApp . name = app . name ; } config . applications . push ( configApp ) ; } ) ; if ( parsedArgs . libraries ) { if ( ! config . libraries ) { config . libraries = [ ] ; } parsedArgs . libraries . forEach ( function ( aPath ) { config . libraries . push ( aPath ) ; } ) ; } 
async function ( ) { let apps = [ ] ; let argv = this . argv ; let result = { target : argv . target , outputPath : argv . outputPath || null , locales : null , writeAllTranslations : argv . writeAllTranslations , environment : { } , applications : apps , libraries : argv . library || [ ] , config : argv . configFile || "compile.json" , continuous : argv . continuous , verbose : argv . verbose } ; if ( argv . set ) { argv . set . forEach ( function ( kv ) { var m = kv . match ( / ^([^=\s]+)(=(.+))?$ / ) ; if ( m ) { var key = m [ 1 ] ; var value = m [ 3 ] ; try { result . environment [ key ] = Function ( "\"use strict\";return (" + value + ")" ) ( ) ; } catch ( error ) { throw new Error ( "Failed to translate environment value '" + value + "' to a js datatype - " + error ) ; } } else { throw new Error ( "Failed to parse environment setting commandline option '" + kv + "'" ) ; } } ) ; } if ( argv . locale && argv . locale . length ) { result . locales = argv . locale ; } return result ; } 
function ( className , theme ) { this . base ( arguments ) ; this . __applications = [ ] ; if ( className ) { var app = new qx . tool . compiler . app . Application ( className ) ; if ( theme ) { app . setTheme ( theme ) ; } this . addApplication ( app ) ; } } 
function ( ) { var analyser = this . getAnalyser ( ) ; 
function ( ) { return { command : "migrate [options]" , desc : "migrates a qooxdoo application to the next major version" , usage : "migrate" , builder : { "verbose" : { alias : "v" , describe : "enables additional progress output to console" , type : "boolean" } } , handler : function ( argv ) { return new qx . tool . cli . commands . Migrate ( argv ) . process ( ) . catch ( e => { console . error ( e . stack || e . message ) ; process . exit ( 1 ) ; } ) ; } } ; } 
async function ( ) { var t = this ; var compileAst = null ; var compileJson = { } ; var configJson ; var lets = { } ; function getMacro ( name ) { var value = lets [ name ] ; value = replaceMacros ( value ) ; return value ; } function replaceMacros ( value ) { if ( ! value ) { return "" ; } 
async function ( ) { if ( this . argv [ "machine-readable" ] ) { qx . tool . compiler . Console . getInstance ( ) . setMachineReadable ( true ) ; } else if ( this . argv [ "feedback" ] ) { this . __gauge = new Gauge ( ) ; this . __gauge . show ( "Compiling" , 0 ) ; const TYPES = { "error" : "ERROR" , "warning" : "Warning" } ; qx . tool . compiler . Console . getInstance ( ) . setWriter ( ( str , msgId ) => { msgId = qx . tool . compiler . Console . MESSAGE_IDS [ msgId ] ; if ( msgId . type !== "message" ) { this . __gauge . hide ( ) ; console . log ( TYPES [ msgId . type ] + ": " + str ) ; this . __gauge . show ( ) ; } else { this . __gauge . show ( str ) ; } } ) ; } var config = this . __config = await this . parse ( this . argv ) ; if ( ! config ) { throw new qx . tool . cli . Utils . UserError ( "Error: Cannot find any configuration" ) ; } var maker = this . __maker = await this . createMakerFromConfig ( config ) ; if ( ! maker ) { throw new qx . tool . cli . Utils . UserError ( "Error: Cannot find anything to make" ) ; } let errors = await this . __checkDependencies ( maker , config . contribs ) ; if ( errors . length > 0 ) { if ( this . argv . warnAsError ) { throw new qx . tool . cli . Utils . UserError ( errors . join ( "\n" ) ) ; } else { console . log ( errors . join ( "\n" ) ) ; } } if ( this . argv [ "clean" ] ) { await maker . eraseOutputDir ( ) ; await qx . tool . compiler . files . Utils . safeUnlink ( maker . getAnalyser ( ) . getDbFilename ( ) ) ; await qx . tool . compiler . files . Utils . safeUnlink ( maker . getAnalyser ( ) . getResDbFilename ( ) ) ; } var analyser = maker . getAnalyser ( ) ; var target = maker . getTarget ( ) ; if ( this . __gauge ) { maker . addListener ( "writingApplications" , ( ) => this . __gauge . show ( "Writing Applications" , 0 ) ) ; maker . addListener ( "writtenApplications" , ( ) => this . __gauge . show ( "Writing Applications" , 1 ) ) ; maker . addListener ( "writingApplication" , evt => this . __gauge . pulse ( "Writing Application " + evt . getData ( ) . getName ( ) ) ) ; analyser . addListener ( "compilingClass" , evt => this . __gauge . pulse ( "Compiling " + evt . getData ( ) . classFile . getClassName ( ) ) ) ; if ( target instanceof qx . tool . compiler . targets . BuildTarget ) { target . addListener ( "minifyingApplication" , evt => this . __gauge . pulse ( "Minifying " + evt . getData ( ) . application . getName ( ) + " " + evt . getData ( ) . filename ) ) ; } } else { maker . addListener ( "writingApplication" , evt => qx . tool . compiler . Console . print ( "qx.tool.cli.compile.writingApplication" , evt . getData ( ) . getName ( ) ) ) ; if ( target instanceof qx . tool . compiler . targets . BuildTarget ) { target . addListener ( "minifyingApplication" , evt => qx . tool . compiler . Console . print ( "qx.tool.cli.compile.minifyingApplication" , evt . getData ( ) . application . getName ( ) , evt . getData ( ) . filename ) ) ; } if ( this . argv . verbose ) { var startTimes = { } ; analyser . addListener ( "compilingClass" , evt => { var classname = evt . getData ( ) . classFile . getClassName ( ) ; startTimes [ classname ] = new Date ( ) ; qx . tool . compiler . Console . print ( "qx.tool.cli.compile.compilingClass" , classname ) ; } ) ; analyser . addListener ( "compiledClass" , evt => { var classname = evt . getData ( ) . classFile . getClassName ( ) ; var startTime = startTimes [ classname ] ; var endTime = new Date ( ) ; var diff = endTime . getTime ( ) - startTime . getTime ( ) ; qx . tool . compiler . Console . print ( "qx.tool.cli.compile.compiledClass" , classname , qx . tool . cli . Utils . formatTime ( diff ) ) ; } ) ; } } maker . addListener ( "writingApplications" , e => this . dispatchEvent ( e . clone ( ) ) ) ; maker . addListener ( "writtenApplications" , e => { this . dispatchEvent ( e . clone ( ) ) ; if ( this . argv . verbose ) { console . log ( "\nCompleted all applications, libraries used are:" ) ; maker . getAnalyser ( ) . getLibraries ( ) . forEach ( lib => { console . log ( ` ${ lib . getNamespace ( ) } ${ lib . getRootDir ( ) } ` ) ; } ) ; } } ) ; maker . addListener ( "writingApplication" , e => this . dispatchEvent ( e . clone ( ) ) ) ; maker . addListener ( "writtenApplication" , e => this . dispatchEvent ( e . clone ( ) ) ) ; analyser . addListener ( "compilingClass" , e => this . dispatchEvent ( e . clone ( ) ) ) ; analyser . addListener ( "compiledClass" , e => this . dispatchEvent ( e . clone ( ) ) ) ; analyser . addListener ( "saveDatabase" , e => this . dispatchEvent ( e . clone ( ) ) ) ; target . addListener ( "checkEnvironment" , e => this . dispatchEvent ( e . clone ( ) ) ) ; var p = qx . tool . compiler . files . Utils . safeStat ( "source/index.html" ) . then ( stat => stat && qx . tool . compiler . Console . print ( "qx.tool.cli.compile.legacyFiles" , "source/index.html" ) ) ; 
async function ( data ) { var t = this ; var maker = null ; var outputPath = data . target . outputPath ; if ( ! outputPath ) { throw new qx . tool . cli . Utils . UserError ( "Missing output-path for target " + data . target . type ) ; } maker = new qx . tool . compiler . makers . AppMaker ( ) ; if ( ! this . argv [ "erase" ] ) { maker . setNoErase ( true ) ; } if ( ! data . target ) { throw new qx . tool . cli . Utils . UserError ( "No target specified" ) ; } var targetClass = data . target . targetClass ? this . resolveTargetClass ( data . target . targetClass ) : null ; if ( ! targetClass && data . target . type ) { targetClass = this . resolveTargetClass ( data . target . type ) ; } if ( ! targetClass ) { throw new qx . tool . cli . Utils . UserError ( "Cannot find target class: " + ( data . target . targetClass || data . target . type ) ) ; } var target = new targetClass ( outputPath ) ; if ( data . target . uri ) { qx . tool . compiler . Console . print ( "qx.tool.cli.compile.deprecatedUri" , "target.uri" , data . target . uri ) ; } if ( data . target . writeCompileInfo ) { target . setWriteCompileInfo ( true ) ; } target . setWriteLibraryInfo ( this . argv . writeLibraryInfo ) ; target . setUpdatePoFiles ( this . argv . updatePoFiles ) ; maker . setTarget ( target ) ; maker . setLocales ( data . locales || [ "en" ] ) ; if ( data . writeAllTranslations ) { maker . setWriteAllTranslations ( data . writeAllTranslations ) ; } if ( typeof data . target . typescript == "string" ) { maker . set ( { outputTypescript : true , outputTypescriptTo : data . target . typescript } ) ; } else if ( typeof data . target . typescript == "boolean" ) { maker . set ( { outputTypescript : true } ) ; } if ( this . argv [ "typescript" ] ) { maker . set ( { outputTypescript : true } ) ; } if ( data . environment ) { maker . setEnvironment ( data . environment ) ; } if ( data . target . environment ) { target . setEnvironment ( data . target . environment ) ; } if ( data [ "path-mappings" ] ) { for ( var from in data [ "path-mappings" ] ) { var to = data [ "path-mappings" ] [ from ] ; target . addPathMapping ( from , to ) ; } } function mergeArray ( dest , ... srcs ) { srcs . forEach ( function ( src ) { if ( src ) { src . forEach ( function ( elem ) { if ( ! qx . lang . Array . contains ( dest , src ) ) { dest . push ( elem ) ; } } ) ; } } ) ; return dest ; } let babelOptions = data . babelOptions || { } ; qx . lang . Object . mergeWith ( babelOptions , data . target . babelOptions || { } ) ; maker . getAnalyser ( ) . setBabelOptions ( babelOptions ) ; var addCreatedAt = data . target [ "addCreatedAt" ] || t . argv [ "addCreatedAt" ] ; if ( addCreatedAt ) { maker . getAnalyser ( ) . setAddCreatedAt ( true ) ; } var appNames = null ; if ( t . argv [ "app-name" ] ) { appNames = t . argv [ "app-name" ] . split ( "," ) ; } let hasExplicitDefaultApp = false ; let defaultApp = null ; data . applications . forEach ( function ( appData , appIndex ) { if ( appNames && appNames . indexOf ( appData . name ) === - 1 ) { return ; } var app = new qx . tool . compiler . app . Application ( appData [ "class" ] ) ; [ "type" , "theme" , "name" , "environment" , "outputPath" , "bootPath" , "loaderTemplate" ] . forEach ( name => { if ( appData [ name ] !== undefined ) { var fname = "set" + qx . lang . String . firstUp ( name ) ; app [ fname ] ( appData [ name ] ) ; } } ) ; if ( app . isBrowserApp ( ) ) { var setDefault ; if ( appData . writeIndexHtmlToRoot !== undefined ) { qx . tool . compiler . Console . print ( "qx.tool.cli.compile.deprecatedCompileSeeOther" , "application.writeIndexHtmlToRoot" , "application.default" ) ; setDefault = appData . writeIndexHtmlToRoot ; } else if ( appData [ "default" ] !== undefined ) { setDefault = appData [ "default" ] ; } if ( setDefault !== undefined ) { if ( setDefault ) { if ( hasExplicitDefaultApp ) { throw new qx . tool . cli . Utils . UserError ( "Error: Can only set one application to be the default application!" ) ; } hasExplicitDefaultApp = true ; defaultApp = app ; } } else if ( ! defaultApp ) { defaultApp = app ; } } if ( appData . uri ) { qx . tool . compiler . Console . print ( "qx.tool.cli.compile.deprecatedUri" , "application.uri" , appData . uri ) ; } if ( appData . title ) { app . setTitle ( appData . title ) ; } 
async function ( maker , contribs ) { let errors = [ ] ; let libs = maker . getAnalyser ( ) . getLibraries ( ) ; const SDK_VERSION = await this . getUserQxVersion ( ) ; 
function ( type ) { if ( ! type ) { return null ; } if ( type . $$type == "Class" ) { return type ; } if ( type == "build" ) { return qx . tool . compiler . targets . BuildTarget ; } if ( type == "source" ) { return qx . tool . compiler . targets . SourceTarget ; } if ( type == "typescript" ) { throw new qx . tool . cli . Utils . UserError ( "Typescript targets are no longer supported - please use `typescript: true` in source target instead" ) ; } if ( type ) { var targetClass ; if ( type . indexOf ( "." ) < 0 ) { targetClass = qx . Class . getByName ( "qx.tool.compiler.targets." + type ) ; } else { targetClass = qx . Class . getByName ( type ) ; } return targetClass ; } return null ; } 
function ( analyser ) { this . base ( arguments ) ; this . __analyser = analyser ; this . __dbFilename = analyser . getResDbFilename ( ) || "resource-db.json" ; this . __handlers = [ new qx . tool . compiler . resources . ImageHandler ( ) , new qx . tool . compiler . resources . MetaHandler ( ) , new qx . tool . compiler . resources . ScssHandler ( this . __analyser ) ] ; } 
function ( callback ) { var t = this ; async . waterfall ( [ function readDb ( callback ) { fs . exists ( t . __dbFilename , function ( exists ) { if ( exists ) { fs . readFile ( t . __dbFilename , { encoding : "utf-8" } , callback ) ; } else { callback ( null , null ) ; } } ) ; } , function parseDb ( data , callback ) { t . __db = data && data . trim ( ) . length ? jsonlint . parse ( data ) : { } ; callback ( null , t . __db ) ; } ] , callback ) ; } 
function ( callback ) { log . debug ( "saving resource manager database" ) ; return qx . tool . compiler . utils . Json . saveJsonAsync ( this . __dbFilename , this . __db ) ; } 
function ( uri ) { var t = this ; 
function scanDir ( rootDir , dir , resource , doNotCopy , callback ) { 
function ( srcPaths ) { var t = this ; var db = this . __db ; 
async function ( data ) { let t = this ; let result = { } ; return new Promise ( ( resolve , reject ) => { async . forEach ( data . libraries , function ( path , cb ) { t . __addLibrary ( path , result , cb ) ; } , function ( err ) { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; } ) ; } 
function ( rootDir , result , cb ) { var lib = new qx . tool . compiler . app . Library ( ) ; lib . loadManifest ( rootDir , function ( err ) { if ( ! err ) { let s = lib . getNamespace ( ) ; let libs = s . split ( "." ) ; result [ libs [ 0 ] ] = false ; } return cb && cb ( err , lib ) ; } ) ; } 
function ( str ) { if ( str === null ) { return null ; } str = str . trim ( ) ; if ( ! str ) { return null ; } var ast = JsonToAst . parseToAst ( str ) ; var json = JsonToAst . astToObject ( ast ) ; return json ; } 
async function ( filename ) { if ( ! await fs . existsAsync ( filename ) ) { return null ; } var data = await fs . readFileAsync ( filename , "utf8" ) ; try { return qx . tool . compiler . utils . Json . parseJson ( data ) ; } catch ( ex ) { throw new Error ( "Failed to load " + filename + ": " + ex ) ; } } 
async function ( filename , data ) { if ( ! data ) { if ( await fs . existsAsync ( filename ) ) { fs . unlinkAsync ( filename ) ; } } else { await fs . writeFileAsync ( filename , JSON . stringify ( data , null , 2 ) , "utf8" ) ; } } 
async function ( compileInfo ) { var t = this ; var _arguments = arguments ; var application = compileInfo . application ; var targetUri = t . _getOutputRootUri ( application ) ; var appRootDir = this . getApplicationRoot ( application ) ; 
function ( from , to , filter ) { var t = this ; function copy ( statFrom , statTo ) { if ( statFrom . isDirectory ( ) ) { var p ; if ( statTo === null ) { p = mkdir ( to ) ; } else { p = Promise . resolve ( ) ; } return p . then ( ( ) => readdir ( from ) . then ( files => Promise . all ( files . map ( file => t . sync ( from + "/" + file , to + "/" + file , filter ) ) ) ) ) ; } else if ( statFrom . isFile ( ) ) { return qx . Promise . resolve ( filter ? filter ( from , to ) : true ) . then ( result => result && t . copyFile ( from , to ) ) ; } return undefined ; } return new Promise ( ( resolve , reject ) => { var statFrom = null ; var statTo = null ; stat ( from ) . then ( tmp => { statFrom = tmp ; return stat ( to ) . then ( tmp => statTo = tmp ) . catch ( err => { if ( err . code !== "ENOENT" ) { throw err ; } } ) ; } ) . then ( ( ) => { if ( ! statTo || statFrom . isDirectory ( ) != statTo . isDirectory ( ) ) { return t . deleteRecursive ( to ) . then ( ( ) => copy ( statFrom , statTo ) ) ; } else if ( statFrom . isDirectory ( ) || ( statFrom . mtime . getTime ( ) > statTo . mtime . getTime ( ) || statFrom . size != statTo . size ) ) { return copy ( statFrom , statTo ) ; } return undefined ; } ) . then ( resolve ) . catch ( reject ) ; } ) ; } 
function ( from , to ) { return new Promise ( ( resolve , reject ) => { util . mkParentPath ( to , function ( ) { var rs = fs . createReadStream ( from , { flags : "r" , encoding : "binary" } ) ; var ws = fs . createWriteStream ( to , { flags : "w" , encoding : "binary" } ) ; rs . on ( "end" , function ( ) { resolve ( ) ; } ) ; rs . on ( "error" , reject ) ; ws . on ( "error" , reject ) ; rs . pipe ( ws ) ; } ) ; } ) ; } 
function ( filename ) { return new Promise ( ( resolve , reject ) => { fs . stat ( filename , function ( err , stats ) { if ( err && err . code != "ENOENT" ) { reject ( err ) ; } else { resolve ( err ? null : stats ) ; } } ) ; } ) ; } 
function ( filename ) { return new Promise ( ( resolve , reject ) => { fs . unlink ( filename , function ( err ) { if ( err && err . code != "ENOENT" ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
async function ( filename , length ) { if ( await this . safeStat ( filename ) && length > 1 ) { var lastFile = null ; for ( var i = length ; i > 0 ; i -- ) { var tmp = filename + "." + i ; if ( i == length ) { await this . safeUnlink ( tmp ) ; } else if ( await this . safeStat ( tmp ) ) { await rename ( tmp , lastFile ) ; } lastFile = tmp ; } await rename ( filename , lastFile ) ; } } 
function ( name ) { return new Promise ( ( resolve , reject ) => { rimraf ( name , err => { if ( err ) { reject ( err ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
function ( dir ) { var drivePrefix = "" ; if ( process . platform === "win32" && dir . match ( / ^[a-zA-Z]: / ) ) { drivePrefix = dir . substring ( 0 , 2 ) ; dir = dir . substring ( 2 ) ; } dir = dir . replace ( / \\ / g , "/" ) ; var segs = dir . split ( "/" ) ; if ( ! segs . length ) { return drivePrefix + dir ; } var currentDir ; var index ; if ( segs [ 0 ] . length ) { currentDir = "" ; index = 0 ; } else { currentDir = "/" ; index = 1 ; } function bumpToNext ( nextSeg ) { index ++ ; if ( currentDir . length && currentDir !== "/" ) { currentDir += "/" ; } currentDir += nextSeg ; return next ( ) ; } function next ( ) { if ( index == segs . length ) { if ( process . platform === "win32" ) { currentDir = currentDir . replace ( / \/ / g , "\\" ) ; } return Promise . resolve ( drivePrefix + currentDir ) ; } let nextSeg = segs [ index ] ; if ( nextSeg == "." || nextSeg == ".." ) { return bumpToNext ( nextSeg ) ; } return new Promise ( ( resolve , reject ) => { fs . readdir ( currentDir . length == 0 ? "." : drivePrefix + currentDir , { encoding : "utf8" } , ( err , files ) => { if ( err ) { reject ( err ) ; return ; } let nextLowerCase = nextSeg . toLowerCase ( ) ; let exact = false ; let insensitive = null ; for ( let i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] === nextSeg ) { exact = true ; break ; } if ( files [ i ] . toLowerCase ( ) === nextLowerCase ) { insensitive = files [ i ] ; } } if ( ! exact && insensitive ) { nextSeg = insensitive ; } bumpToNext ( nextSeg ) . then ( resolve ) ; } ) ; } ) ; } return new Promise ( ( resolve , reject ) => { fs . stat ( drivePrefix + dir , err => { if ( err ) { if ( err . code == "ENOENT" ) { resolve ( drivePrefix + dir ) ; } else { reject ( err ) ; } } else { next ( ) . then ( resolve ) ; } } ) ; } ) ; } 
function ( ) { if ( qx . core . Environment . get ( "runtime.name" ) == "rhino" ) { qx . log . Logger . register ( qx . log . appender . RhinoConsole ) ; } else if ( qx . core . Environment . get ( "runtime.name" ) == "node.js" ) { qx . log . Logger . register ( qx . log . appender . NodeConsole ) ; } if ( window . arguments ) { try { this . _argumentsToSettings ( window . arguments ) ; } catch ( ex ) { this . error ( ex . toString ( ) ) ; return ; } } this . info ( "Hello World!" ) ; } 
function ( args ) { var opts ; for ( var i = 0 , l = args . length ; i < l ; i ++ ) { if ( args [ i ] . indexOf ( "settings=" ) == 0 ) { opts = args [ i ] . substr ( 9 ) ; break ; } else if ( args [ i ] . indexOf ( "'settings=" ) == 0 ) { opts = / 'settings\=(.*?)' / . exec ( args [ i ] ) [ 1 ] ; break ; } } if ( opts ) { opts = opts . replace ( / \\\{ / g , "{" ) . replace ( / \\\} / g , "}" ) ; opts = qx . lang . Json . parse ( opts ) ; for ( var prop in opts ) { var value = opts [ prop ] ; if ( typeof value == "string" ) { value = value . replace ( / \$$ / g , " " ) ; } try { qx . core . Environment . add ( prop , value ) ; } catch ( ex ) { this . error ( "Unable to define command-line setting " + prop + ": " + ex ) ; } } } } 
function SortableDirective ( $timeout ) { return { restrict : 'A' , scope : { isSortable : '=sortable' , onSortableSort : '&' } , link : function ( $scope , $element , $attrs ) { var rootEl = $element [ 0 ] , dragEl , nextEl , dropEl ; function isbefore ( a , b ) { if ( a . parentNode == b . parentNode ) { for ( var cur = a ; cur ; cur = cur . previousSibling ) { if ( cur === b ) { return true ; } } } return false ; } ; function onDragEnter ( e ) { var target = e . target ; if ( isbefore ( dragEl , target ) ) { target . parentNode . insertBefore ( dragEl , target ) ; } else if ( target . nextSibling && target . hasAttribute ( 'draggable' ) ) { target . parentNode . insertBefore ( dragEl , target . nextSibling . nextSibling ) ; } } ; function onDragEnd ( evt ) { evt . preventDefault ( ) ; dragEl . classList . remove ( 'dt-clone' ) ; $element . off ( 'dragend' , onDragEnd ) ; $element . off ( 'dragenter' , onDragEnter ) ; if ( nextEl !== dragEl . nextSibling ) { $scope . onSortableSort ( { event : evt , columnId : angular . element ( dragEl ) . attr ( 'data-id' ) } ) ; } } ; function onDragStart ( evt ) { if ( ! $scope . isSortable ) return false ; evt = evt . originalEvent || evt ; dragEl = evt . target ; nextEl = dragEl . nextSibling ; dragEl . classList . add ( 'dt-clone' ) ; evt . dataTransfer . effectAllowed = 'move' ; evt . dataTransfer . setData ( 'Text' , dragEl . textContent ) ; $element . on ( 'dragenter' , onDragEnter ) ; $element . on ( 'dragend' , onDragEnd ) ; } ; $element . on ( 'dragstart' , onDragStart ) ; $scope . $on ( '$destroy' , ( ) => { $element . off ( 'dragstart' , onDragStart ) ; } ) ; } } } 
function ResizableDirective ( $document , $timeout ) { return { restrict : 'A' , scope : { isResizable : '=resizable' , minWidth : '=' , maxWidth : '=' , onResize : '&' } , link : function ( $scope , $element , $attrs ) { if ( $scope . isResizable ) { $element . addClass ( 'resizable' ) ; } var handle = angular . element ( ` ` ) , parent = $element . parent ( ) , prevScreenX ; handle . on ( 'mousedown' , function ( event ) { if ( ! $element [ 0 ] . classList . contains ( 'resizable' ) ) { return false ; } event . stopPropagation ( ) ; event . preventDefault ( ) ; $document . on ( 'mousemove' , mousemove ) ; $document . on ( 'mouseup' , mouseup ) ; } ) ; function mousemove ( event ) { event = event . originalEvent || event ; var width = parent [ 0 ] . clientWidth , movementX = event . movementX || event . mozMovementX || ( event . screenX - prevScreenX ) , newWidth = width + ( movementX || 0 ) ; prevScreenX = event . screenX ; if ( ( ! $scope . minWidth || newWidth >= $scope . minWidth ) && ( ! $scope . maxWidth || newWidth <= $scope . maxWidth ) ) { parent . css ( { width : newWidth + 'px' } ) ; } } function mouseup ( ) { if ( $scope . onResize ) { $timeout ( function ( ) { let width = parent [ 0 ] . clientWidth ; if ( width < $scope . minWidth ) { width = $scope . minWidth ; } $scope . onResize ( { width : width } ) ; } ) ; } $document . unbind ( 'mousemove' , mousemove ) ; $document . unbind ( 'mouseup' , mouseup ) ; } $element . append ( handle ) ; } } ; } 
function ScaleColumns ( colsByGroup , maxWidth , totalFlexGrow ) { 
function GetTotalFlexGrow ( columns ) { var totalFlexGrow = 0 ; for ( let c of columns ) { totalFlexGrow += c . flexGrow || 0 ; } return totalFlexGrow ; } 
function ForceFillColumnWidths ( allColumns , expectedWidth , startIdx ) { var contentWidth = 0 , columnsToResize = startIdx > - 1 ? allColumns . slice ( startIdx , allColumns . length ) . filter ( ( c ) => { return c . canAutoResize } ) : allColumns . filter ( ( c ) => { return c . canAutoResize } ) ; allColumns . forEach ( ( c ) => { if ( ! c . canAutoResize ) { contentWidth += c . width ; } else { contentWidth += ( c . $$oldWidth || c . width ) ; } } ) ; var remainingWidth = expectedWidth - contentWidth , additionWidthPerColumn = remainingWidth / columnsToResize . length , exceedsWindow = contentWidth > expectedWidth ; columnsToResize . forEach ( ( column ) => { if ( exceedsWindow ) { column . width = column . $$oldWidth || column . width ; } else { if ( ! column . $$oldWidth ) { column . $$oldWidth = column . width ; } var newSize = column . $$oldWidth + additionWidthPerColumn ; if ( column . minWith && newSize < column . minWidth ) { column . width = column . minWidth ; } else if ( column . maxWidth && newSize > column . maxWidth ) { column . width = column . maxWidth ; } else { column . width = newSize ; } } } ) ; } 
function PDU ( ) { this . type = asn1ber . pduTypes . GetRequestPDU ; this . reqid = 1 ; this . error = 0 ; this . errorIndex = 0 ; this . varbinds = [ new VarBind ( ) ] ; } 
function concatBuffers ( buffers ) { var total , cur = 0 , buf ; 
function clearRequest ( reqs , reqid ) { var self = this ; var entry = reqs [ reqid ] ; if ( entry ) { if ( entry . timeout ) { clearTimeout ( entry . timeout ) ; } delete reqs [ reqid ] ; } } 
function parseSingleOid ( oid ) { if ( typeof oid !== 'string' ) { return oid ; } if ( oid [ 0 ] !== '.' ) { throw new Error ( 'Invalid OID format' ) ; } oid = oid . split ( '.' ) . filter ( function ( s ) { return s . length > 0 ; } ) . map ( function ( s ) { return parseInt ( s , 10 ) ; } ) ; return oid ; } 
function parseOids ( options ) { if ( options . oid ) { options . oid = parseSingleOid ( options . oid ) ; } if ( options . oids ) { options . oids = options . oids . map ( parseSingleOid ) ; } } 
function defaults ( targ , _defs ) { [ ] . slice . call ( arguments , 1 ) . forEach ( function ( def ) { Object . keys ( def ) . forEach ( function ( key ) { if ( ! targ . hasOwnProperty ( key ) ) { targ [ key ] = def [ key ] ; } } ) ; } ) ; } 
function encode ( pkt ) { var version , community , reqid , err , erridx , vbs , pdu , message ; 
function parse ( buf ) { var pkt , oid , bvb , vb , hdr , vbhdr ; pkt = new Packet ( ) ; 
function compareOids ( oidA , oidB ) { var mlen , i ; 
function msgReceived ( msg , rinfo ) { var self = this , now = Date . now ( ) , pkt , entry ; if ( msg . length === 0 ) { 
function Session ( options ) { var self = this ; self . options = options || { } ; defaults ( self . options , exports . defaultOptions ) ; self . reqs = { } ; self . socket = dgram . createSocket ( self . options . family ) ; self . socket . on ( 'message' , msgReceived . bind ( self ) ) ; self . socket . on ( 'close' , function ( ) { 
function inTree ( root , oid ) { var i ; if ( oid . length <= root . length ) { return false ; } for ( i = 0 ; i < root . length ; i ++ ) { if ( oid [ i ] !== root [ i ] ) { return false ; } } return true ; } 
function result ( error , varbinds ) { if ( combinedTimeoutExpired ) { return ; } if ( error ) { clearTimeout ( combinedTimeoutTimer ) ; callback ( error ) ; } else { if ( inTree ( options . startOid , varbinds [ 0 ] . oid ) ) { if ( varbinds [ 0 ] . value === 'endOfMibView' || varbinds [ 0 ] . value === 'noSuchObject' || varbinds [ 0 ] . value === 'noSuchInstance' ) { clearTimeout ( combinedTimeoutTimer ) ; callback ( null , vbs ) ; } else if ( vbs . length && compareOids ( vbs . slice ( - 1 ) [ 0 ] . oid , varbinds [ 0 ] . oid ) !== 1 ) { return callback ( new Error ( 'OID not increasing' ) ) ; } else { vbs . push ( varbinds [ 0 ] ) ; var next = { oid : varbinds [ 0 ] . oid } ; defaults ( next , options ) ; self . getNext ( next , result ) ; } } else { clearTimeout ( combinedTimeoutTimer ) ; callback ( null , vbs ) ; } } } 
function lengthArray ( len ) { var arr = [ ] ; if ( len <= 127 ) { 
function wrapper ( type , contents ) { var buf , len , i ; 
function oidInt ( val ) { var bytes = [ ] ; bytes . push ( val % 128 ) ; val = parseInt ( val / 128 , 10 ) ; while ( val > 127 ) { bytes . push ( 128 + val % 128 ) ; val = parseInt ( val / 128 , 10 ) ; } bytes . push ( val + 128 ) ; return bytes . reverse ( ) ; } 
function oidArray ( oid ) { var bytes , i , val ; 
function intArray ( val ) { var array = [ ] , encVal = val , bytes ; if ( val === 0 ) { array . push ( 0 ) ; } else { if ( val < 0 ) { bytes = Math . floor ( 1 + Math . log ( - val ) / LOG256 ) ; 
function encodeIntegerish ( val , type ) { var i , arr , buf ; 
function typeAndLength ( buf ) { var res , len , i ; res = { type : buf [ 0 ] , len : 0 , header : 1 } ; if ( buf [ 1 ] < 128 ) { 
function proxiesRemaining ( proxyData ) { return Object . keys ( proxyData ) . filter ( key => proxyData [ key ] == null ) ; } 
function maybeGetNewToken ( ) { let user = options . user || options . username ; if ( ! options . passcode && ( ! user || ! options . password ) ) { throw new Error ( "missing username or password" ) ; } if ( ! options . no_token ) { org = new Organization ( c ) ; c . org = org ; let arg1 = { password : options . password } ; 
function loadKeysIntoMap ( org , cb ) { var uuid = uuidV4 ( ) ; var re = new RegExp ( '(?:\r\n|\r|\n)' , 'g' ) ; var keypair = new NodeRSA ( { b : opt . options . keystrength } ) ; var publicKeyPem = keypair . exportKey ( 'pkcs8-public-pem' ) . replace ( re , '\\n' ) ; var privateKeyPem = keypair . exportKey ( 'pkcs8-private-pem' ) . replace ( re , '\\n' ) ; var options = { env : opt . options . env , kvm : opt . options . privkeysmap , key : 'private__' + uuid , value : privateKeyPem } ; common . logWrite ( sprintf ( 'provisioning new key %s' , uuid ) ) ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; options . kvm = opt . options . pubkeysmap ; options . key = 'public__' + uuid ; options . value = publicKeyPem ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; options . kvm = opt . options . kidmap ; options . key = 'currentKid' ; options . value = uuid ; org . kvms . put ( options , function ( e , result ) { if ( e ) return cb ( e , result ) ; cb ( null , result ) ; } ) ; } ) ; } ) ; } 
function resolveExpiry ( subject ) { var pattern = new RegExp ( '^([1-9][0-9]*)([smhdw])$' , 'i' ) ; var multipliers = { s : 1 , m : 60 , h : 60 * 60 , d : 60 * 60 * 24 , w : 60 * 60 * 24 * 7 , y : 60 * 60 * 24 * 365 } ; var match = pattern . exec ( subject ) ; if ( match ) { return match [ 1 ] * multipliers [ match [ 2 ] ] * 1000 ; } return - 1 ; } 
function insureFreshToken ( conn , cb ) { var rh = conn . requestHeaders ; if ( rh && rh . authorization && conn . user && rh . authorization . indexOf ( 'Bearer ' ) === 0 ) { var stashedToken = tokenMgmt . currentToken ( conn . user , conn . loginBaseUrl , conn . mgmtServer ) ; if ( tokenMgmt . isInvalidOrExpired ( stashedToken ) ) { return conn . refreshToken ( stashedToken , function ( e , result ) { if ( e ) { throw new Error ( 'error refreshing token: ' + e ) ; } cb ( merge ( true , { headers : rh } ) ) ; } ) ; } else { cb ( merge ( true , { headers : rh } ) ) ; } } else { cb ( merge ( true , { headers : rh } ) ) ; } } 
function loadKeyIntoMap ( org , cb ) { var re = new RegExp ( '(?:\r\n|\r|\n)' , 'g' ) ; var pemcontent = fs . readFileSync ( opt . options . pemfile , "utf8" ) . replace ( re , '\n' ) ; var options = { env : opt . options . env , kvm : opt . options . mapname , key : opt . options . entryname , value : pemcontent } ; common . logWrite ( 'storing new key' ) ; org . kvms . put ( options , cb ) ; } 
function revEnvReducer ( org , name , revision ) { return ( p , env ) => p . then ( ( ) => org . proxies . undeploy ( { name , revision , environment : env . name } ) ) ; } 
function ( arg ) { var value = arg . value ; var flag = arg . flag ; var result = null ; if ( value ) { value = Array . isArray ( value ) ? value : [ value ] ; result = [ ] ; value . forEach ( function ( path ) { result . push ( flag ) ; result . push ( path ) ; } ) ; } return result ; } 
function getCosmiConfig ( ) { try { const config = cosmiconfig ( 'iopipe' , { cache : false , sync : true , rcExtensions : true } ) . load ( ) ; if ( config !== null ) { return config . config ; } } catch ( err ) { void 0 ; 
function requireFromString ( src , args ) { if ( ! src ) { return undefined ; } 
function getPlugins ( plugins ) { if ( typeof plugins !== 'object' || ! Array . isArray ( plugins ) ) return undefined ; return plugins . filter ( Boolean ) . map ( plugin => { if ( Array . isArray ( plugin ) ) { 
function getCosmiConfig ( ) { try { const config = require ( configPath ) ; if ( typeof config === 'object' && typeof config . iopipe === 'object' ) { return config . iopipe ; } } catch ( err ) { Function . prototype ; 
function executeUploaded ( ) { console . log ( 'Running acceptance test invocations' ) ; Promise . all ( arns . map ( arn => { return lambda . invoke ( { InvocationType : 'RequestResponse' , FunctionName : arn , Payload : JSON . stringify ( { test : true } ) } ) . promise ( ) ; } ) ) . then ( ( [ fn1 , fn2 , fn3 , fn4 ] ) => { const bool = every ( [ fn1 . StatusCode === 200 , fn1 . Payload === '"callback"' , fn2 . StatusCode === 200 , fn2 . Payload === '"context.succeed"' , fn3 . StatusCode === 200 , fn3 . FunctionError === 'Handled' , fn3 . Payload === JSON . stringify ( { errorMessage : 'context.fail' } ) , fn4 . StatusCode === 200 , fn4 . Payload === '"context.done"' ] ) ; if ( bool ) { console . log ( 'Acceptance test passed.' ) ; return process . exit ( 0 ) ; } console . error ( 'Acceptance test failed.' ) ; console . error ( 'Results: ' , JSON . stringify ( [ fn1 , fn2 , fn3 , fn4 ] ) ) ; return process . exit ( 1 ) ; } ) . catch ( err => { console . error ( err ) ; process . exit ( 1 ) ; } ) ; } 
function setupTimeoutCapture ( wrapperInstance ) { const { context , sendReport , config } = wrapperInstance ; const { getRemainingTimeInMillis = ( ) => 0 } = context ; 
function center ( node ) { return node . targetLinks . length ? node . depth : node . sourceLinks . length ? min ( node . sourceLinks , targetDepth ) - 1 : 0 ; } 
function scaleSankeySize ( graph , margin ) { var maxColumn = max ( graph . nodes , function ( node ) { return node . column ; } ) ; var currentWidth = x1 - x0 ; var currentHeight = y1 - y0 ; var newWidth = currentWidth + margin . right + margin . left ; var newHeight = currentHeight + margin . top + margin . bottom ; var scaleX = currentWidth / newWidth ; var scaleY = currentHeight / newHeight ; x0 = x0 * scaleX + margin . left ; x1 = margin . right == 0 ? x1 : x1 * scaleX ; y0 = y0 * scaleY + margin . top ; y1 = y1 * scaleY ; graph . nodes . forEach ( function ( node ) { node . x0 = x0 + node . column * ( ( x1 - x0 - dx ) / maxColumn ) ; node . x1 = node . x0 + dx ; } ) ; return scaleY ; } 
function computeNodeDepths ( graph ) { var nodes , next , x ; for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; ++ x , nodes = next , next = [ ] ) { nodes . forEach ( function ( node ) { node . depth = x ; node . sourceLinks . forEach ( function ( link ) { if ( next . indexOf ( link . target ) < 0 && ! link . circular ) { next . push ( link . target ) ; } } ) ; } ) ; } for ( nodes = graph . nodes , next = [ ] , x = 0 ; nodes . length ; ++ x , nodes = next , next = [ ] ) { nodes . forEach ( function ( node ) { node . height = x ; node . targetLinks . forEach ( function ( link ) { if ( next . indexOf ( link . source ) < 0 && ! link . circular ) { next . push ( link . source ) ; } } ) ; } ) ; } 
function computeNodeBreadths ( graph , iterations , id ) { var columns = nest ( ) . key ( function ( d ) { return d . column ; } ) . sortKeys ( ascending ) . entries ( graph . nodes ) . map ( function ( d ) { return d . values ; } ) ; initializeNodeBreadth ( id ) ; resolveCollisions ( ) ; for ( var alpha = 1 , n = iterations ; n > 0 ; -- n ) { relaxLeftAndRight ( alpha *= 0.99 , id ) ; resolveCollisions ( ) ; } function initializeNodeBreadth ( id ) { 
function sortLinkColumnAscending ( link1 , link2 ) { if ( linkColumnDistance ( link1 ) == linkColumnDistance ( link2 ) ) { return link1 . circularLinkType == 'bottom' ? sortLinkSourceYDescending ( link1 , link2 ) : sortLinkSourceYAscending ( link1 , link2 ) ; } else { return linkColumnDistance ( link2 ) - linkColumnDistance ( link1 ) ; } } 
function linkPerpendicularYToLinkTarget ( longerLink , shorterLink ) { 
function sortSourceLinks ( graph , y1 , id , moveNodes ) { graph . nodes . forEach ( function ( node ) { 
function selfLinking ( link , id ) { return getNodeID ( link . source , id ) == getNodeID ( link . target , id ) ; } 
function ascendingSourceBreadth ( a , b ) { return ascendingBreadth ( a . source , b . source ) || a . index - b . index } 
function ascendingTargetBreadth ( a , b ) { return ascendingBreadth ( a . target , b . target ) || a . index - b . index } 
function ascendingBreadth ( a , b ) { if ( a . partOfCycle === b . partOfCycle ) { return a . y0 - b . y0 } else { if ( a . circularLinkType === 'top' || b . circularLinkType === 'bottom' ) { return - 1 } else { return 1 } } } 
function find ( nodeById , id ) { var node = nodeById . get ( id ) if ( ! node ) throw new Error ( 'missing: ' + id ) return node } 
function computeNodeLinks ( graph ) { graph . nodes . forEach ( function ( node , i ) { node . index = i node . sourceLinks = [ ] node . targetLinks = [ ] } ) var nodeById = map ( graph . nodes , id ) graph . links . forEach ( function ( link , i ) { link . index = i var source = link . source var target = link . target if ( typeof source !== 'object' ) { source = link . source = find ( nodeById , source ) } if ( typeof target !== 'object' ) { target = link . target = find ( nodeById , target ) } source . sourceLinks . push ( link ) target . targetLinks . push ( link ) } ) return graph } 
function relaxLeftAndRight ( alpha , id ) { var columnsLength = columns . length columns . forEach ( function ( nodes ) { var n = nodes . length var depth = nodes [ 0 ] . depth nodes . forEach ( function ( node ) { 
function resolveCollisions ( ) { columns . forEach ( function ( nodes ) { var node , dy , y = y0 , n = nodes . length , i 
function computeLinkBreadths ( graph ) { graph . nodes . forEach ( function ( node ) { node . sourceLinks . sort ( ascendingTargetBreadth ) node . targetLinks . sort ( ascendingSourceBreadth ) } ) graph . nodes . forEach ( function ( node ) { var y0 = node . y0 var y1 = y0 
function identifyCircles ( graph , id , sortNodes ) { var circularLinkID = 0 if ( sortNodes === null ) { 
function selectCircularLinkTypes ( graph , id ) { var numberOfTops = 0 var numberOfBottoms = 0 graph . links . forEach ( function ( link ) { if ( link . circular ) { 
function linkAngle ( link ) { var adjacent = Math . abs ( link . y1 - link . y0 ) var opposite = Math . abs ( link . target . x0 - link . source . x1 ) return Math . atan ( opposite / adjacent ) } 
function circularLinksCross ( link1 , link2 ) { if ( link1 . source . column < link2 . target . column ) { return false } else if ( link1 . target . column > link2 . source . column ) { return false } else { return true } } 
function numberOfNonSelfLinkingCycles ( node , id ) { var sourceCount = 0 node . sourceLinks . forEach ( function ( l ) { sourceCount = l . circular && ! selfLinking ( l , id ) ? sourceCount + 1 : sourceCount } ) var targetCount = 0 node . targetLinks . forEach ( function ( l ) { targetCount = l . circular && ! selfLinking ( l , id ) ? targetCount + 1 : targetCount } ) return sourceCount + targetCount } 
function onlyCircularLink ( link ) { var nodeSourceLinks = link . source . sourceLinks var sourceCount = 0 nodeSourceLinks . forEach ( function ( l ) { sourceCount = l . circular ? sourceCount + 1 : sourceCount } ) var nodeTargetLinks = link . target . targetLinks var targetCount = 0 nodeTargetLinks . forEach ( function ( l ) { targetCount = l . circular ? targetCount + 1 : targetCount } ) if ( sourceCount > 1 || targetCount > 1 ) { return false } else { return true } } 
function calcVerticalBuffer ( links , circularLinkGap , id ) { links . sort ( sortLinkColumnAscending ) links . forEach ( function ( link , i ) { var buffer = 0 if ( selfLinking ( link , id ) && onlyCircularLink ( link ) ) { link . circularPathData . verticalBuffer = buffer + link . width / 2 } else { var j = 0 for ( j ; j < i ; j ++ ) { if ( circularLinksCross ( links [ i ] , links [ j ] ) ) { var bufferOverThisLink = links [ j ] . circularPathData . verticalBuffer + links [ j ] . width / 2 + circularLinkGap buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer } } link . circularPathData . verticalBuffer = buffer + link . width / 2 } } ) return links } 
function createCircularPathString ( link ) { var pathString = '' 
function resolveNodeLinkOverlaps ( graph , y0 , y1 , id ) { graph . links . forEach ( function ( link ) { if ( link . circular ) { return } if ( link . target . column - link . source . column > 1 ) { var columnToTest = link . source . column + 1 var maxColumnToTest = link . target . column - 1 var i = 1 var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1 for ( columnToTest , ( i = 1 ) ; columnToTest <= maxColumnToTest ; columnToTest ++ , i ++ ) { graph . nodes . forEach ( function ( node ) { if ( node . column == columnToTest ) { var t = i / ( numberOfColumnsToTest + 1 ) 
function nodesOverlap ( nodeA , nodeB ) { 
function adjustNodeHeight ( node , dy , sankeyY0 , sankeyY1 ) { if ( ( node . y0 + dy >= sankeyY0 ) && ( node . y1 + dy <= sankeyY1 ) ) { node . y0 = node . y0 + dy node . y1 = node . y1 + dy node . targetLinks . forEach ( function ( l ) { l . y1 = l . y1 + dy } ) node . sourceLinks . forEach ( function ( l ) { l . y0 = l . y0 + dy } ) } return node } 
function Pastebin ( config ) { if ( typeof config === 'string' ) { config = { api_dev_key : config } ; } this . config = _ . extend ( conf . defaults , config ) ; } 
function runWithCallback ( promiseFunc , callback ) { if ( ! _ . isFunction ( callback ) ) { throw new Error ( 'This function requires a callback!' ) ; } promiseFunc . then ( function ( data ) { callback ( null , data ) ; } ) . catch ( function ( err ) { callback ( err , null ) ; } ) ; } 
function Poloniex ( key , secret ) { if ( key && secret ) { authenticated = true ; } 
function ( options , callback ) { if ( ! ( 'headers' in options ) ) { options . headers = { } ; } options . json = true ; options . headers [ 'User-Agent' ] = Poloniex . USER_AGENT ; options . strictSSL = Poloniex . STRICT_SSL ; options . timeout = Poloniex . TIMEOUT ; return new Promise ( function ( resolve , reject ) { request ( options , function ( err , response , body ) { 
function ( command , parameters , callback ) { if ( typeof parameters === 'function' ) { callback = parameters ; parameters = { } ; } parameters || ( parameters = { } ) ; parameters . command = command ; const options = { method : 'GET' , url : PUBLIC_API_URL , qs : parameters } ; options . qs . command = command ; return this . _request ( options , callback ) ; } 
function ( command , parameters , callback ) { if ( typeof parameters === 'function' ) { callback = parameters ; parameters = { } ; } parameters || ( parameters = { } ) ; parameters . command = command ; parameters . nonce = nonce ( ) ; const options = { method : 'POST' , url : PRIVATE_API_URL , form : parameters , headers : this . _getPrivateHeaders ( parameters ) } ; return this . _request ( options , callback ) ; } 
function ( currencyA , currencyB , callback ) { if ( typeof currencyB === 'function' ) { callback = currencyB ; currencyB = null ; } const parameters = { currencyPair : joinCurrencies ( currencyA , currencyB ) } ; return this . _private ( 'returnOpenOrders' , parameters , callback ) ; } 
function spawnChildProcess ( bin , args , option ) { const result = spawnCancelableChild ( bin , args , option ) ; return result . process ; } 
function spawnCancelableChild ( bin , args , option ) { let innerCancel = null ; let isCanceled = false ; const canceller = function ( ) { if ( isCanceled ) { return ; } isCanceled = true ; if ( typeof innerCancel === 'function' ) { innerCancel ( ) ; } } ; const process = new Promise ( function ( resolve , reject ) { if ( isCanceled ) { reject ( ) ; return ; } console . log ( 'spawn: ' + bin + ' ' + args . join ( ' ' ) ) ; const proc = childProcess . spawn ( bin , args , option ) ; innerCancel = function ( ) { proc . kill ( 'SIGINT' ) ; } ; proc . on ( 'exit' , function ( status ) { resolve ( status ) ; } ) ; } ) ; return { canceller , process , } ; } 
function CasStrategy ( options , verify ) { if ( typeof options == 'function' ) { verify = options ; options = undefined ; } options = options || { } ; if ( ! verify ) { throw new TypeError ( 'CasStrategy requires a verify callback' ) ; } if ( ! options . casURL ) { throw new TypeError ( 'CasStrategy requires a casURL option' ) ; } Strategy . call ( this ) ; this . name = 'cas' ; this . _verify = verify ; this . _passReqToCallback = options . passReqToCallback ; this . casBaseUrl = options . casURL ; this . casPgtUrl = options . pgtURL || undefined ; this . casPropertyMap = options . propertyMap || { } ; this . casSessionKey = options . sessionKey || 'cas' ; this . cas = new CAS ( { base_url : this . casBaseUrl , version : 2 , external_pgt_url : this . casPgtUrl , ssl_cert : options . sslCert , ssl_key : options . sslKey , ssl_ca : options . sslCA } ) ; } 
function PgtServer ( casURL , pgtURL , serverCertificate , serverKey , serverCA ) { var parsedURL = url . parse ( pgtURL ) ; var cas = new CAS ( { base_url : casURL , version : 2.0 , pgt_server : true , pgt_host : parsedURL . hostname , pgt_port : parsedURL . port , ssl_key : serverKey , ssl_cert : serverCertificate , ssl_ca : serverCA || null } ) ; } 
function ( element , link ) { // Normalize the link parameter if ( angular . isFunction ( link ) ) { link = { post : link } ; } var compiledContents ; return { pre : ( link && link . pre ) ? link . pre : null , post : function ( scope , element , attrs , trvw ) { // Compile our template if ( ! compiledContents ) { compiledContents = $compile ( trvw . getNodeTpl ( ) ) ; } // Add the compiled template compiledContents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; // Call the post-linking function, if any if ( link && link . post ) { link . post . apply ( null , arguments ) ; } } } ; } 
function ( scope , element , attrs , trvw ) { // Compile our template if ( ! compiledContents ) { compiledContents = $compile ( trvw . getNodeTpl ( ) ) ; } // Add the compiled template compiledContents ( scope , function ( clone ) { element . append ( clone ) ; } ) ; // Call the post-linking function, if any if ( link && link . post ) { link . post . apply ( null , arguments ) ; } } 
function ( href , attributes ) { var head = document . head || document . getElementsByTagName ( 'head' ) [ 0 ] ; var link = document . createElement ( 'link' ) ; link . href = href ; link . rel = 'stylesheet' ; for ( var key in attributes ) { if ( ! attributes . hasOwnProperty ( key ) ) { continue ; } var value = attributes [ key ] ; link . setAttribute ( 'data-' + key , value ) ; } head . appendChild ( link ) ; } 
function ( cssText , attributes , extraOptions ) { extraOptions = extraOptions || { } ; var style = document . createElement ( 'style' ) ; style . type = 'text/css' ; for ( var key in attributes ) { if ( ! attributes . hasOwnProperty ( key ) ) { continue ; } var value = attributes [ key ] ; style . setAttribute ( 'data-' + key , value ) ; } if ( style . sheet ) { 
function ( baseDir , importPath ) { var parts = importPath . split ( '/' ) ; var pathname = path . join ( baseDir , importPath ) ; if ( parts [ 0 ] === 'node_modules' ) { 
function ( imageFile , mimeType ) { 
function ( options , callback ) { if ( _ . isFunction ( options ) && ! callback ) { callback = options ; options = { } ; } options = _ . clone ( options ) ; bootcode ( function ( err , code ) { if ( err ) { return callback ( err ) ; } if ( ! code ) { return callback ( new Error ( 'sandbox: bootcode missing!' ) ) ; } options . bootCode = code ; 
function extend ( klass , instance , override , methods ) { var extendee = instance ? klass . prototype : klass ; initializeClass ( klass ) ; iterateOverObject ( methods , function ( name , method ) { var original = extendee [ name ] ; var existed = hasOwnProperty ( extendee , name ) ; if ( typeof override === 'function' ) { method = wrapNative ( extendee [ name ] , method , override ) ; } if ( override !== false || ! extendee [ name ] ) { defineProperty ( extendee , name , method ) ; } 
function multiArgs ( args , fn ) { var result = [ ] , i , len ; for ( i = 0 , len = args . length ; i < len ; i ++ ) { result . push ( args [ i ] ) ; if ( fn ) fn . call ( args , args [ i ] , i ) ; } return result ; } 
function getRange ( start , stop , fn , step ) { var arr = [ ] , i = parseInt ( start ) , down = step < 0 ; while ( ( ! down && i <= stop ) || ( down && i >= stop ) ) { arr . push ( i ) ; if ( fn ) fn . call ( this , i ) ; i += step || 1 ; } return arr ; } 
function getRegExpFlags ( reg , add ) { var flags = reg . toString ( ) . match ( / [^/]*$ / ) [ 0 ] ; if ( add ) { flags = ( flags + add ) . split ( '' ) . sort ( ) . join ( '' ) . replace ( / ([gimy])\1+ / g , '$1' ) ; } return flags ; } 
function stringify ( thing , stack ) { var type = typeof thing , thingIsObject , thingIsArray , klass , value , arr , key , i , len ; 
function entryAtIndex ( arr , args , str ) { var result = [ ] , length = arr . length , loop = args [ args . length - 1 ] !== false , r ; multiArgs ( args , function ( index ) { if ( isBoolean ( index ) ) return false ; if ( loop ) { index = index % length ; if ( index < 0 ) index = length + index ; } r = str ? arr . charAt ( index ) || '' : arr [ index ] ; result . push ( r ) ; } ) ; return result . length < 2 ? result [ 0 ] : result ; } 
function buildObjectInstanceMethods ( set , target ) { extendSimilar ( target , true , false , set , function ( methods , name ) { methods [ name + ( name === 'equal' ? 's' : '' ) ] = function ( ) { return object [ name ] . apply ( null , [ this ] . concat ( multiArgs ( arguments ) ) ) ; } } ) ; } 
function arrayIndexOf ( arr , search , fromIndex , increment ) { var length = arr . length , fromRight = increment == - 1 , start = fromRight ? length - 1 : 0 , index = toIntegerWithDefault ( fromIndex , start ) ; if ( index < 0 ) { index = length + index ; } if ( ( ! fromRight && index < 0 ) || ( fromRight && index >= length ) ) { index = start ; } while ( ( fromRight && index >= 0 ) || ( ! fromRight && index < length ) ) { if ( arr [ index ] === search ) { return index ; } index += increment ; } return - 1 ; } 
function ( fn , scope ) { var length = this . length , index = 0 ; checkFirstArgumentExists ( arguments ) ; while ( index < length ) { if ( index in this && fn . call ( scope , this [ index ] , index , this ) ) { return true ; } index ++ ; } return false ; } 
function ( fn , scope ) { var length = this . length , index = 0 , result = new Array ( length ) ; checkFirstArgumentExists ( arguments ) ; while ( index < length ) { if ( index in this ) { result [ index ] = fn . call ( scope , this [ index ] , index , this ) ; } index ++ ; } return result ; } 
function ( fn , scope ) { var length = this . length , index = 0 ; checkCallback ( fn ) ; while ( index < length ) { if ( index in this ) { fn . call ( scope , this [ index ] , index , this ) ; } index ++ ; } } 
function buildTrim ( ) { var support = getTrimmableCharacters ( ) . match ( / ^\s+$ / ) ; try { string . prototype . trim . call ( [ 1 ] ) ; } catch ( e ) { support = false ; } extend ( string , true , ! support , { 'trim' : function ( ) { return this . toString ( ) . trimLeft ( ) . trimRight ( ) ; } , 'trimLeft' : function ( ) { return this . replace ( regexp ( '^[' + getTrimmableCharacters ( ) + ']+' ) , '' ) ; } , 'trimRight' : function ( ) { return this . replace ( regexp ( '[' + getTrimmableCharacters ( ) + ']+$' ) , '' ) ; } } ) ; } 
function ( scope ) { var fn = this , args = multiArgs ( arguments ) . slice ( 1 ) , nop , bound ; if ( ! isFunction ( this ) ) { throw new TypeError ( 'Function.prototype.bind called on a non-function' ) ; } bound = function ( ) { return fn . apply ( fn . prototype && this instanceof fn ? this : scope , args . concat ( multiArgs ( arguments ) ) ) ; } bound . prototype = this . prototype ; return bound ; } 
function multiMatch ( el , match , scope , params ) { var result = true ; if ( el === match ) { 
function arrayEach ( arr , fn , startIndex , loop ) { var length , index , i ; if ( startIndex < 0 ) startIndex = arr . length + startIndex ; i = isNaN ( startIndex ) ? 0 : startIndex ; length = loop === true ? arr . length + i : arr . length ; while ( i < length ) { index = i % arr . length ; if ( ! ( index in arr ) ) { return iterateOverSparseArray ( arr , fn , i , loop ) ; } else if ( fn . call ( arr , arr [ index ] , index , arr ) === false ) { break ; } i ++ ; } } 
function getMinOrMax ( obj , map , which , all ) { var edge , result = [ ] , max = which === 'max' , min = which === 'min' , isArray = Array . isArray ( obj ) ; iterateOverObject ( obj , function ( key ) { var el = obj [ key ] , test = transformArgument ( el , map , obj , isArray ? [ el , parseInt ( key ) , obj ] : [ ] ) ; if ( isUndefined ( test ) ) { throw new TypeError ( 'Cannot compare with undefined' ) ; } if ( test === edge ) { result . push ( el ) ; } else if ( isUndefined ( edge ) || ( max && test > edge ) || ( min && test < edge ) ) { result = [ el ] ; edge = test ; } } ) ; if ( ! isArray ) result = arrayFlatten ( result , 1 ) ; return all ? result : result [ 0 ] ; } 
function collateStrings ( a , b ) { var aValue , bValue , aChar , bChar , aEquiv , bEquiv , index = 0 , tiebreaker = 0 ; a = getCollationReadyString ( a ) ; b = getCollationReadyString ( b ) ; do { aChar = getCollationCharacter ( a , index ) ; bChar = getCollationCharacter ( b , index ) ; aValue = getCollationValue ( aChar ) ; bValue = getCollationValue ( bChar ) ; if ( aValue === - 1 || bValue === - 1 ) { aValue = a . charCodeAt ( index ) || null ; bValue = b . charCodeAt ( index ) || null ; } aEquiv = aChar !== a . charAt ( index ) ; bEquiv = bChar !== b . charAt ( index ) ; if ( aEquiv !== bEquiv && tiebreaker === 0 ) { tiebreaker = aEquiv - bEquiv ; } index += 1 ; } while ( aValue != null && bValue != null && aValue === bValue ) ; if ( aValue === bValue ) return tiebreaker ; return aValue < bValue ? - 1 : 1 ; } 
function ( ) { var result = [ ] , tmp ; multiArgs ( arguments , function ( a ) { if ( isObjectPrimitive ( a ) ) { try { tmp = array . prototype . slice . call ( a , 0 ) ; if ( tmp . length > 0 ) { a = tmp ; } } catch ( e ) { } ; } result = result . concat ( a ) ; } ) ; return result ; } 
function ( f , index , loop ) { var result = [ ] ; arrayEach ( this , function ( el , i , arr ) { if ( multiMatch ( el , f , arr , [ el , i , arr ] ) ) { result . push ( el ) ; } } , index , loop ) ; return result ; } 
function ( f , startIndex , loop ) { var index = arrayFind ( this , f , startIndex , loop , true ) ; return isUndefined ( index ) ? - 1 : index ; } 
function ( start , end ) { var i , len ; if ( isUndefined ( start ) ) return this ; if ( isUndefined ( end ) ) end = start ; for ( i = 0 , len = end - start ; i <= len ; i ++ ) { this . splice ( start , 1 ) ; } return this ; } 
function ( num ) { if ( isUndefined ( num ) ) return this [ this . length - 1 ] ; var start = this . length - num < 0 ? 0 : this . length - num ; return this . slice ( start ) ; } 
function ( map ) { var arr = map ? this . map ( map ) : this ; return arr . length > 0 ? arr . reduce ( function ( a , b ) { return a + b ; } ) : 0 ; } 
function ( map ) { var arr = map ? this . map ( map ) : this ; return arr . length > 0 ? arr . sum ( ) / arr . length : 0 ; } 
function ( num , padding ) { var pad = arguments . length > 1 ; var arr = this ; var result = [ ] ; var divisor = ceil ( this . length / num ) ; getRange ( 0 , num - 1 , function ( i ) { var index = i * divisor ; var group = arr . slice ( index , index + divisor ) ; if ( pad && group . length < divisor ) { getRange ( 1 , divisor - group . length , function ( ) { group = group . add ( padding ) ; } ) ; } result . push ( group ) ; } ) ; return result ; } 
function ( map , desc ) { var arr = this . clone ( ) ; arr . sort ( function ( a , b ) { var aProperty , bProperty , comp ; aProperty = transformArgument ( a , map , arr , [ a ] ) ; bProperty = transformArgument ( b , map , arr , [ b ] ) ; if ( isString ( aProperty ) && isString ( bProperty ) ) { comp = collateStrings ( aProperty , bProperty ) ; } else if ( aProperty < bProperty ) { comp = - 1 ; } else if ( aProperty > bProperty ) { comp = 1 ; } else { comp = 0 ; } return comp * ( desc ? - 1 : 1 ) ; } ) ; return arr ; } 
function ( ) { var arr = this . concat ( ) , i = arr . length , j , x ; while ( i ) { j = ( math . random ( ) * i ) | 0 ; x = arr [ -- i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = x ; } return arr ; } 
function ( ) { var args = multiArgs ( arguments ) ; return this . map ( function ( el , i ) { return [ el ] . concat ( args . map ( function ( k ) { return ( i in k ) ? k [ i ] : null ; } ) ) ; } ) ; } 
function ( el , index ) { if ( ! isNumber ( number ( index ) ) || isNaN ( index ) ) index = this . length ; array . prototype . splice . apply ( this , [ index , 0 ] . concat ( el ) ) ; return this ; } 
function ( ) { var i , arr = this ; multiArgs ( arguments , function ( f ) { i = 0 ; while ( i < arr . length ) { if ( multiMatch ( arr [ i ] , f , arr , [ arr [ i ] , i , arr ] ) ) { arr . splice ( i , 1 ) ; } else { i ++ ; } } } ) ; return arr ; } 
function ( all ) { var result = [ ] ; arrayEach ( this , function ( el , i ) { if ( isArray ( el ) ) { result . push ( el . compact ( ) ) ; } else if ( all && el ) { result . push ( el ) ; } else if ( ! all && el != null && el . valueOf ( ) === el . valueOf ( ) ) { result . push ( el ) ; } } ) ; return result ; } 
function ( map , fn ) { var arr = this , result = { } , key ; arrayEach ( arr , function ( el , index ) { key = transformArgument ( el , map , arr , [ el , index , arr ] ) ; if ( ! result [ key ] ) result [ key ] = [ ] ; result [ key ] . push ( el ) ; } ) ; if ( fn ) { iterateOverObject ( result , fn ) ; } return result ; } 
function keysWithCoercion ( obj ) { if ( obj && obj . valueOf ) { obj = obj . valueOf ( ) ; } return object . keys ( obj ) ; } 
function buildEnumerableMethods ( names , mapping ) { extendSimilar ( object , false , false , names , function ( methods , name ) { methods [ name ] = function ( obj , arg1 , arg2 ) { var result , coerced = keysWithCoercion ( obj ) ; result = array . prototype [ name ] . call ( coerced , function ( key ) { if ( mapping ) { return transformArgument ( obj [ key ] , arg1 , obj , [ key , obj [ key ] , obj ] ) ; } else { return multiMatch ( obj [ key ] , arg1 , obj , [ key , obj [ key ] , obj ] ) ; } } , arg2 ) ; if ( isArray ( result ) ) { 
function getLocalization ( localeCode , fallback ) { var loc ; if ( ! isString ( localeCode ) ) localeCode = '' ; loc = Localizations [ localeCode ] || Localizations [ localeCode . slice ( 0 , 2 ) ] ; if ( fallback === false && ! loc ) { throw new Error ( 'Invalid locale.' ) ; } return loc || CurrentLocalization ; } 
function addDateInputFormat ( locale , format , match , variant ) { locale . compiledFormats . unshift ( { variant : variant , locale : locale , reg : regexp ( '^' + format + '$' , 'i' ) , to : match } ) ; } 
function collectDateArguments ( args , allowDuration ) { var obj , arr ; if ( isObject ( args [ 0 ] ) ) { return args ; } else if ( isNumber ( args [ 0 ] ) && ! isNumber ( args [ 1 ] ) ) { return [ args [ 0 ] ] ; } else if ( isString ( args [ 0 ] ) && allowDuration ) { return [ getDateParamsFromString ( args [ 0 ] ) , args [ 1 ] ] ; } obj = { } ; DateArgumentUnits . forEach ( function ( u , i ) { obj [ u . unit ] = args [ i ] ; } ) ; return [ obj ] ; } 
function getFormatMatch ( match , arr ) { var obj = { } , value , num ; arr . forEach ( function ( key , i ) { value = match [ i + 1 ] ; if ( isUndefined ( value ) || value === '' ) return ; if ( key === 'year' ) { obj . yearAsString = value . replace ( / ' / , '' ) ; } num = parseFloat ( value . replace ( / ' / , '' ) . replace ( / , / , '.' ) ) ; obj [ key ] = ! isNaN ( num ) ? num : value . toLowerCase ( ) ; } ) ; return obj ; } 
function getWeekNumber ( date ) { date = date . clone ( ) ; var dow = callDateGet ( date , 'Day' ) || 7 ; date . addDays ( 4 - dow ) . reset ( ) ; return 1 + floor ( date . daysSince ( date . clone ( ) . beginningOfYear ( ) ) / 7 ) ; } 
function formatDate ( date , format , relative , localeCode ) { var adu , loc = getLocalization ( localeCode ) , caps = regexp ( / ^[A-Z] / ) , value , shortcut ; if ( ! date . isValid ( ) ) { return 'Invalid Date' ; } else if ( Date [ format ] ) { format = Date [ format ] ; } else if ( isFunction ( format ) ) { adu = getAdjustedUnitWithMonthFallback ( date ) ; format = format . apply ( date , adu . concat ( loc ) ) ; } if ( ! format && relative ) { adu = adu || getAdjustedUnitWithMonthFallback ( date ) ; 
function compareDate ( d , find , buffer , forceUTC ) { var p , t , min , max , minOffset , maxOffset , override , capitalized , accuracy = 0 , loBuffer = 0 , hiBuffer = 0 ; p = getExtendedDate ( find , null , null , forceUTC ) ; if ( buffer > 0 ) { loBuffer = hiBuffer = buffer ; override = true ; } if ( ! p . date . isValid ( ) ) return false ; if ( p . set && p . set . specificity ) { DateUnits . forEach ( function ( u , i ) { if ( u . unit === p . set . specificity ) { accuracy = u . multiplier ( p . date , d - p . date ) - 1 ; } } ) ; capitalized = simpleCapitalize ( p . set . specificity ) ; if ( p . set [ 'edge' ] || p . set [ 'shift' ] ) { p . date [ 'beginningOf' + capitalized ] ( ) ; } if ( p . set . specificity === 'month' ) { max = p . date . clone ( ) [ 'endOf' + capitalized ] ( ) . getTime ( ) ; } if ( ! override && p . set [ 'sign' ] && p . set . specificity != 'millisecond' ) { 
function prepareTime ( format , loc , iso ) { var timeSuffixMapping = { 'h' : 0 , 'm' : 1 , 's' : 2 } , add ; loc = loc || English ; return format . replace ( / {([a-z])} / g , function ( full , token ) { var separators = [ ] , isHours = token === 'h' , tokenIsRequired = isHours && ! iso ; if ( token === 't' ) { return loc [ 'ampm' ] . join ( '|' ) ; } else { if ( isHours ) { separators . push ( ':' ) ; } if ( add = loc [ 'timeSuffixes' ] [ timeSuffixMapping [ token ] ] ) { separators . push ( add + '\\s*' ) ; } return separators . length === 0 ? '' : '(?:' + separators . join ( '|' ) + ')' + ( tokenIsRequired ? '' : '?' ) ; } } ) ; } 
function checkMonthTraversal ( date , targetMonth ) { if ( targetMonth < 0 ) { targetMonth = targetMonth % 12 + 12 ; } if ( targetMonth % 12 != callDateGet ( date , 'Month' ) ) { callDateSet ( date , 'Date' , 0 ) ; } } 
function buildDateMethods ( ) { extendSimilar ( date , true , false , DateUnits , function ( methods , u , i ) { var unit = u . unit , caps = simpleCapitalize ( unit ) , multiplier = u . multiplier ( ) , since , until ; u . addMethod = 'add' + caps + 's' ; 
function applyErrorMargin ( ms ) { var num = ms / multiplier , fraction = num % 1 , error = u . error || 0.999 ; if ( fraction && math . abs ( fraction % 1 ) > error ) { num = round ( num ) ; } return parseInt ( num ) ; } 
function buildRelativeAliases ( ) { var special = 'today,yesterday,tomorrow,weekday,weekend,future,past' . split ( ',' ) ; var weekdays = English [ 'weekdays' ] . slice ( 0 , 7 ) ; var months = English [ 'months' ] . slice ( 0 , 12 ) ; extendSimilar ( date , true , false , special . concat ( weekdays ) . concat ( months ) , function ( methods , name ) { methods [ 'is' + simpleCapitalize ( name ) ] = function ( utc ) { return this . is ( name , 0 , utc ) ; } ; } ) ; } 
function ( localeCode , set ) { var loc = getLocalization ( localeCode , false ) ; CurrentLocalization = loc ; 
function ( week ) { var weekday = callDateGet ( this , 'Day' ) || 7 ; if ( isUndefined ( week ) ) return ; this . set ( { 'month' : 0 , 'date' : 4 } ) ; this . set ( { 'weekday' : 1 } ) ; if ( week > 1 ) { this . addWeeks ( week - 1 ) ; } if ( weekday !== 1 ) { this . advance ( { 'days' : weekday - 1 } ) ; } return this . getTime ( ) ; } 
function ( iso ) { var offset = this . _utc ? 0 : this . getTimezoneOffset ( ) ; var colon = iso === true ? ':' : '' ; if ( ! offset && iso ) return 'Z' ; return padNumber ( floor ( - offset / 60 ) , 2 , true ) + colon + padNumber ( math . abs ( offset % 60 ) , 2 ) ; } 
function ( f , localeCode ) { if ( isString ( f ) ) { localeCode = f ; f = null ; } return formatDate ( this , f , true , localeCode ) ; } 
function ( d , margin , utc ) { var tmp , comp ; if ( ! this . isValid ( ) ) return ; if ( isString ( d ) ) { d = d . trim ( ) . toLowerCase ( ) ; comp = this . clone ( ) . utc ( utc ) ; switch ( true ) { case d === 'future' : return this . getTime ( ) > new date ( ) . getTime ( ) ; case d === 'past' : return this . getTime ( ) < new date ( ) . getTime ( ) ; case d === 'weekday' : return callDateGet ( comp , 'Day' ) > 0 && callDateGet ( comp , 'Day' ) < 6 ; case d === 'weekend' : return callDateGet ( comp , 'Day' ) === 0 || callDateGet ( comp , 'Day' ) === 6 ; case ( tmp = English [ 'weekdays' ] . indexOf ( d ) % 7 ) > - 1 : return callDateGet ( comp , 'Day' ) === tmp ; case ( tmp = English [ 'months' ] . indexOf ( d ) % 12 ) > - 1 : return callDateGet ( comp , 'Month' ) === tmp ; } } return compareDate ( this , d , margin , utc ) ; } 
function ( unit ) { var params = { } , recognized ; unit = unit || 'hours' ; if ( unit === 'date' ) unit = 'days' ; recognized = DateUnits . some ( function ( u ) { return unit === u . unit || unit === u . unit + 's' ; } ) ; params [ unit ] = unit . match ( / ^days? / ) ? 1 : 0 ; return recognized ? this . set ( params , true ) : this ; } 
function buildNumberToDateAlias ( u , multiplier ) { var unit = u . unit , methods = { } ; function base ( ) { return round ( this * multiplier ) ; } function after ( ) { return createDate ( arguments ) [ u . addMethod ] ( this ) ; } function before ( ) { return createDate ( arguments ) [ u . addMethod ] ( - this ) ; } methods [ unit ] = base ; methods [ unit + 's' ] = base ; methods [ unit + 'Before' ] = before ; methods [ unit + 'sBefore' ] = before ; methods [ unit + 'Ago' ] = before ; methods [ unit + 'sAgo' ] = before ; methods [ unit + 'After' ] = after ; methods [ unit + 'sAfter' ] = after ; methods [ unit + 'FromNow' ] = after ; methods [ unit + 'sFromNow' ] = after ; number . extend ( methods ) ; } 
function ( start , end ) { this . start = date . create ( start ) ; this . end = date . create ( end ) ; } 
function ( obj ) { var self = this , arr = obj . start && obj . end ? [ obj . start , obj . end ] : [ obj ] ; return arr . every ( function ( d ) { return d >= self . start && d <= self . end ; } ) ; } 
function ( increment , fn ) { var current = this . start . clone ( ) , result = [ ] , index = 0 , params , isDay ; if ( isString ( increment ) ) { current . advance ( getDateParamsFromString ( increment , 0 ) , true ) ; params = getDateParamsFromString ( increment ) ; isDay = increment . toLowerCase ( ) === 'day' ; } else { params = { 'milliseconds' : increment } ; } while ( current <= this . end ) { result . push ( current ) ; if ( fn ) fn ( current , index ) ; if ( isDay && callDateGet ( current , 'Hours' ) === 23 ) { 
function ( range ) { return new DateRange ( this . start < range . start ? this . start : range . start , this . end > range . end ? this . end : range . end ) ; } 
function setDelay ( fn , ms , after , scope , args ) { var index ; 
function ( ms , limit ) { var fn = this , queue = [ ] , lock = false , execute , rounded , perExecution , result ; ms = ms || 1 ; limit = limit || Infinity ; rounded = ceil ( ms ) ; perExecution = round ( rounded / ms ) || 1 ; execute = function ( ) { if ( lock || queue . length == 0 ) return ; 
function ( ms ) { var fn = this ; var args = multiArgs ( arguments ) . slice ( 1 ) ; setDelay ( fn , ms , fn , fn , args ) ; return fn ; } 
function ( ms ) { var fn = this ; function debounced ( ) { debounced . cancel ( ) ; setDelay ( debounced , ms , fn , this , arguments ) ; } ; return debounced ; } 
function ( num ) { var fn = this , counter = 0 , storedArguments = [ ] ; if ( ! isNumber ( num ) ) { num = 1 ; } else if ( num === 0 ) { fn . call ( ) ; return fn ; } return function ( ) { var ret ; storedArguments . push ( multiArgs ( arguments ) ) ; counter ++ ; if ( counter == num ) { ret = fn . call ( this , storedArguments ) ; counter = 0 ; storedArguments = [ ] ; return ret ; } } } 
function ( ) { var fn = this , curried = multiArgs ( arguments ) ; return function ( ) { var args = multiArgs ( arguments ) ; curried . forEach ( function ( arg , index ) { if ( arg != null || index >= args . length ) args . splice ( index , 0 , arg ) ; } ) ; return fn . apply ( this , args ) ; } } 
function abbreviateNumber ( num , roundTo , str , mid , limit , bytes ) { var fixed = num . toFixed ( 20 ) , decimalPlace = fixed . search ( / \. / ) , numeralPlace = fixed . search ( / [1-9] / ) , significant = decimalPlace - numeralPlace , unit , i , divisor ; if ( significant > 0 ) { significant -= 1 ; } i = math . max ( math . min ( ( significant / 3 ) . floor ( ) , limit === false ? str . length : limit ) , - mid ) ; unit = str . charAt ( i + mid - 1 ) ; if ( significant < - 9 ) { i = - 3 ; roundTo = significant . abs ( ) - 9 ; unit = str . slice ( 0 , 1 ) ; } divisor = bytes ? ( 2 ) . pow ( 10 * i ) : ( 10 ) . pow ( i * 3 ) ; return ( num / divisor ) . round ( roundTo || 0 ) . format ( ) + unit . trim ( ) ; } 
function ( n1 , n2 ) { var min , max ; if ( arguments . length == 1 ) n2 = n1 , n1 = 0 ; min = math . min ( n1 || 0 , isUndefined ( n2 ) ? 1 : n2 ) ; max = math . max ( n1 || 0 , isUndefined ( n2 ) ? 1 : n2 ) + 1 ; return floor ( ( math . random ( ) * ( max - min ) ) + min ) ; } 
function ( place , thousands , decimal ) { var i , str , split , integer , fraction , result = '' ; if ( isUndefined ( thousands ) ) { thousands = ',' ; } if ( isUndefined ( decimal ) ) { decimal = '.' ; } str = ( isNumber ( place ) ? round ( this , place || 0 ) . toFixed ( math . max ( place , 0 ) ) : this . toString ( ) ) . replace ( / ^- / , '' ) ; split = str . split ( '.' ) ; integer = split [ 0 ] ; fraction = split [ 1 ] ; for ( i = integer . length ; i > 0 ; i -= 3 ) { if ( i < integer . length ) { result = thousands + result ; } result = integer . slice ( math . max ( 0 , i - 3 ) , i ) + result ; } if ( fraction ) { result += decimal + repeatString ( ( place || 0 ) - fraction . length , '0' ) + fraction ; } return ( this < 0 ? '-' : '' ) + result ; } 
function ( ) { var suffix , num = this . abs ( ) , last = parseInt ( num . toString ( ) . slice ( - 2 ) ) ; return this + getOrdinalizedSuffix ( last ) ; } 
function buildNumber ( ) { extendSimilar ( number , true , false , 'round,floor,ceil' , function ( methods , name ) { methods [ name ] = function ( precision ) { return round ( this , precision , name ) ; } } ) ; extendSimilar ( number , true , false , 'abs,pow,sin,asin,cos,acos,tan,atan,exp,pow,sqrt' , function ( methods , name ) { methods [ name ] = function ( a , b ) { return math [ name ] ( this , a , b ) ; } } ) ; } 
function buildTypeMethods ( ) { extendSimilar ( object , false , false , ClassNames , function ( methods , name ) { var method = 'is' + name ; ObjectTypeMethods . push ( method ) ; methods [ method ] = typeChecks [ name ] ; } ) ; } 
function ( obj , prop , fn ) { if ( ! definePropertySupport ) return ; var value = obj [ prop ] ; object . defineProperty ( obj , prop , { 'enumerable' : true , 'configurable' : true , 'get' : function ( ) { return value ; } , 'set' : function ( to ) { value = fn . call ( obj , prop , value , to ) ; } } ) ; } 
function ( obj , fn ) { var keys = object . keys ( obj ) ; keys . forEach ( function ( key ) { fn . call ( obj , key , obj [ key ] ) ; } ) ; return keys ; } 
function ( target , source , deep , resolve ) { var key , val ; 
function ( obj , fn ) { var values = [ ] ; iterateOverObject ( obj , function ( k , v ) { values . push ( v ) ; if ( fn ) fn . call ( obj , v ) ; } ) ; return values ; } 
function ( obj , deep ) { var target ; 
function ( str , deep ) { var result = object . extended ( ) , split ; str = str && str . toString ? str . toString ( ) : '' ; str . replace ( / ^.*?\? / , '' ) . split ( '&' ) . forEach ( function ( p ) { var split = p . split ( '=' ) ; if ( split . length !== 2 ) return ; setParamsObject ( result , split [ 0 ] , decodeURIComponent ( split [ 1 ] ) , deep ) ; } ) ; return result ; } 
function ( obj , arg ) { var fn = arg ; if ( ! isFunction ( arg ) ) { fn = function ( ) { if ( arg ) obj [ arg ] ( ) ; } } fn . call ( obj , obj ) ; return obj ; } 
function getAcronym ( word ) { var inflector = string . Inflector ; var word = inflector && inflector . acronyms [ word ] ; if ( isString ( word ) ) { return word ; } } 
function ( reg , pos , c ) { var str = this , source ; if ( isDefined ( pos ) ) str = str . slice ( 0 , pos ) ; if ( isUndefined ( c ) ) c = true ; source = isRegExp ( reg ) ? reg . source . replace ( '$' , '' ) : escapeRegExp ( reg ) ; return regexp ( source + '$' , c ? '' : 'i' ) . test ( str ) ; } 
function ( search , fn ) { var match , i , len ; if ( isFunction ( search ) ) { fn = search ; search = / [\s\S] / g ; } else if ( ! search ) { search = / [\s\S] / g } else if ( isString ( search ) ) { search = regexp ( escapeRegExp ( search ) , 'gi' ) ; } else if ( isRegExp ( search ) ) { search = regexp ( search . source , getRegExpFlags ( search , 'g' ) ) ; } match = this . match ( search ) || [ ] ; if ( fn ) { for ( i = 0 , len = match . length ; i < len ; i ++ ) { match [ i ] = fn . call ( this , match [ i ] , i , match ) || match [ i ] ; } } return match ; } 
function ( n ) { var result = '' ; n = n || 0 ; this . codes ( function ( c ) { result += chr ( c + n ) ; } ) ; return result ; } 
function ( fn ) { var codes = [ ] , i , len ; for ( i = 0 , len = this . length ; i < len ; i ++ ) { var code = this . charCodeAt ( i ) ; codes . push ( code ) ; if ( fn ) fn . call ( this , code , i ) ; } return codes ; } 
function ( fn ) { var paragraphs = this . trim ( ) . split ( / [\r\n]{2,} / ) ; paragraphs = paragraphs . map ( function ( p ) { if ( fn ) var s = fn . call ( p ) ; return s ? s : p ; } ) ; return paragraphs ; } 
function ( ) { return this . trim ( ) . replace ( / ([\r\n\s ])+/g , f nction(m a tch, w itespace){ return whitespace === ' ' ? w itespace : ' '; } ) ; } 
function ( ) { return this . replace ( / [-\s]+ / g , '_' ) . replace ( string . Inflector && string . Inflector . acronymRegExp , function ( acronym , index ) { return ( index > 0 ? '_' : '' ) + acronym . toLowerCase ( ) ; } ) . replace ( / ([A-Z\d]+)([A-Z][a-z]) / g , '$1_$2' ) . replace ( / ([a-z\d])([A-Z]) / g , '$1_$2' ) . toLowerCase ( ) ; } 
function ( first ) { return this . underscore ( ) . replace ( / (^|_)([^_]+) / g , function ( match , pre , word , index ) { var acronym = getAcronym ( word ) , capitalize = first !== false || index > 0 ; if ( acronym ) return capitalize ? acronym : acronym . toLowerCase ( ) ; return capitalize ? word . capitalize ( ) : word ; } ) ; } 
function ( ) { var str = this , args = arguments . length > 0 ? arguments : [ '' ] ; flattenedArgs ( args , function ( tag ) { str = str . replace ( regexp ( '<\/?' + escapeRegExp ( tag ) + '[^<>]*>' , 'gi' ) , '' ) ; } ) ; return str ; } 
function ( ) { var str = this , args = arguments . length > 0 ? arguments : [ '\\S+' ] ; flattenedArgs ( args , function ( t ) { var reg = regexp ( '<(' + t + ')[^<>]*(?:\\/>|>.*?<\\/\\1>)' , 'gi' ) ; str = str . replace ( reg , '' ) ; } ) ; return str ; } 
function ( length , split , from , ellipsis ) { var pos , prepend = '' , append = '' , str = this . toString ( ) , chars = '[' + getTrimmableCharacters ( ) + ']+' , space = '[^' + getTrimmableCharacters ( ) + ']*' , reg = regexp ( chars + space + '$' ) ; ellipsis = isUndefined ( ellipsis ) ? '...' : string ( ellipsis ) ; if ( str . length <= length ) { return str ; } switch ( from ) { case 'left' : pos = str . length - length ; prepend = ellipsis ; str = str . slice ( pos ) ; reg = regexp ( '^' + space + chars ) ; break ; case 'middle' : pos = floor ( length / 2 ) ; append = ellipsis + str . slice ( str . length - pos ) . trimLeft ( ) ; str = str . slice ( 0 , pos ) ; break ; default : pos = length ; append = ellipsis ; str = str . slice ( 0 , pos ) ; } if ( split === false && this . slice ( pos , pos + 1 ) . match ( / \S / ) ) { str = str . remove ( reg ) ; } return prepend + str + append ; } 
function ( num ) { var result = '' , str = this ; if ( ! isNumber ( num ) || num < 1 ) return '' ; while ( num ) { if ( num & 1 ) { result += str ; } if ( num >>= 1 ) { str += str ; } } return result ; } 
function ( base ) { var str = this . replace ( / , / g , '' ) ; return str . match ( / \. / ) ? parseFloat ( str ) : parseInt ( str , base || 10 ) ; } 
function ( all ) { var lastResponded ; return this . toLowerCase ( ) . replace ( all ? / [\s\S] / g : / ^\S / , function ( lower ) { var upper = lower . toUpperCase ( ) , result ; result = lastResponded ? lower : upper ; lastResponded = upper !== lower ; return result ; } ) ; } 
function ( ) { var assign = { } ; multiArgs ( arguments , function ( a , i ) { if ( isObject ( a ) ) { simpleMerge ( assign , a ) ; } else { assign [ i + 1 ] = a ; } } ) ; return this . replace ( / \{([^{]+?)\} / g , function ( m , key ) { return hasOwnProperty ( assign , key ) ? assign [ key ] : m ; } ) ; } 
function ( word ) { acronyms [ word . toLowerCase ( ) ] = word ; var all = object . keys ( acronyms ) . map ( function ( key ) { return acronyms [ key ] ; } ) ; Inflector . acronymRegExp = regexp ( all . join ( '|' ) , 'g' ) ; } 
function ( singular , plural ) { var singularFirst = singular . first ( ) , singularRest = singular . from ( 1 ) , pluralFirst = plural . first ( ) , pluralRest = plural . from ( 1 ) , pluralFirstUpper = pluralFirst . toUpperCase ( ) , pluralFirstLower = pluralFirst . toLowerCase ( ) , singularFirstUpper = singularFirst . toUpperCase ( ) , singularFirstLower = singularFirst . toLowerCase ( ) ; removeFromArray ( uncountables , singular ) ; removeFromArray ( uncountables , plural ) ; if ( singularFirstUpper == pluralFirstUpper ) { Inflector . plural ( new regexp ( '({1}){2}$' . assign ( singularFirst , singularRest ) , 'i' ) , '$1' + pluralRest ) ; Inflector . plural ( new regexp ( '({1}){2}$' . assign ( pluralFirst , pluralRest ) , 'i' ) , '$1' + pluralRest ) ; Inflector . singular ( new regexp ( '({1}){2}$' . assign ( pluralFirst , pluralRest ) , 'i' ) , '$1' + singularRest ) ; } else { Inflector . plural ( new regexp ( '{1}{2}$' . assign ( singularFirstUpper , singularRest ) ) , pluralFirstUpper + pluralRest ) ; Inflector . plural ( new regexp ( '{1}{2}$' . assign ( singularFirstLower , singularRest ) ) , pluralFirstLower + pluralRest ) ; Inflector . plural ( new regexp ( '{1}{2}$' . assign ( pluralFirstUpper , pluralRest ) ) , pluralFirstUpper + pluralRest ) ; Inflector . plural ( new regexp ( '{1}{2}$' . assign ( pluralFirstLower , pluralRest ) ) , pluralFirstLower + pluralRest ) ; Inflector . singular ( new regexp ( '{1}{2}$' . assign ( pluralFirstUpper , pluralRest ) ) , singularFirstUpper + singularRest ) ; Inflector . singular ( new regexp ( '{1}{2}$' . assign ( pluralFirstLower , pluralRest ) ) , singularFirstLower + singularRest ) ; } } 
function ( first ) { var add = array . isArray ( first ) ? first : multiArgs ( arguments ) ; uncountables = uncountables . concat ( add ) ; } 
function ( type ) { if ( paramMatchesType ( type , 'singulars' ) ) singulars = [ ] ; if ( paramMatchesType ( type , 'plurals' ) ) plurals = [ ] ; if ( paramMatchesType ( type , 'uncountables' ) ) uncountables = [ ] ; if ( paramMatchesType ( type , 'humans' ) ) humans = [ ] ; if ( paramMatchesType ( type , 'acronyms' ) ) acronyms = { } ; } 
function ( ) { var str = runReplacements ( this , humans ) , acronym ; str = str . replace ( / _id$ / g , '' ) ; str = str . replace ( / (_)?([a-z\d]*) / gi , function ( match , _ , word ) { acronym = hasOwnProperty ( acronyms , word ) ? acronyms [ word ] : null ; return ( _ ? ' ' : '' ) + ( acronym || word . toLowerCase ( ) ) ; } ) ; return capitalize ( str ) ; } 
function ( ) { var fullStopPunctuation = / [.:;!]$ / , hasPunctuation , lastHadPunctuation , isFirstOrLast ; return this . spacify ( ) . humanize ( ) . words ( function ( word , index , words ) { hasPunctuation = fullStopPunctuation . test ( word ) ; isFirstOrLast = index == 0 || index == words . length - 1 || hasPunctuation || lastHadPunctuation ; lastHadPunctuation = hasPunctuation ; if ( isFirstOrLast || Downcased . indexOf ( word ) === - 1 ) { return capitalize ( word ) ; } else { return word ; } } ) . join ( ' ' ) ; } 
function ( separator ) { var str = this ; if ( separator === undefined ) separator = '-' ; if ( str . normalize ) { str = str . normalize ( ) ; } str = str . replace ( / [^a-z0-9\-_]+ / gi , separator ) if ( separator ) { str = str . replace ( new regexp ( '^{sep}+|{sep}+$|({sep}){sep}+' . assign ( { 'sep' : escapeRegExp ( separator ) } ) , 'g' ) , '$1' ) ; } return encodeURI ( str . toLowerCase ( ) ) ; } 
function ( all ) { var str = this ; if ( all !== false ) { str = str . zenkaku ( 'k' ) ; } return str . replace ( / [\u30A1-\u30F6] / g , function ( c ) { return c . shift ( - 96 ) ; } ) ; } 
function ( done ) { var dependencies = [ ] , addPackageToDependencies = function ( pkg ) { dependencies . push ( pkg . name ) ; } ; this . bundler . on ( 'package' , addPackageToDependencies ) ; return this . compile ( function ( err ) { this . bundler . removeListener ( 'package' , addPackageToDependencies ) ; return done ( err , _ . uniq ( dependencies ) . sort ( ) ) ; } . bind ( this ) ) ; } 
function Foscam ( config ) { if ( ! config ) { throw new Error ( 'no config was supplied' ) ; } this . username = config . username ; this . password = config . password ; this . address = config . host ; this . port = config . port || 88 ; this . protocol = config . protocol || 'http' ; this . rejectUnauthorizedCerts = 'rejectUnauthorizedCerts' in config ? config . rejectUnauthorizedCerts : true ; this . baseUrl = this . protocol + '://' + this . address + ':' + this . port ; this . url = this . baseUrl + '/cgi-bin/CGIProxy.fcgi' ; this . streamUrl = this . baseUrl + '/cgi-bin/CGIStream.cgi' ; this . rpClient = rp . defaults ( { rejectUnauthorized : this . rejectUnauthorizedCerts , qs : { usr : this . username , pwd : this . password } } ) ; } 
function put ( point , data , octree , octant , depth ) { let children = octant . children ; let exists = false ; let done = false ; let i , l ; if ( octant . contains ( point , octree . bias ) ) { if ( children === null ) { if ( octant . points === null ) { octant . points = [ ] ; octant . data = [ ] ; } else { for ( i = 0 , l = octant . points . length ; ! exists && i < l ; ++ i ) { exists = octant . points [ i ] . equals ( point ) ; } } if ( exists ) { octant . data [ i - 1 ] = data ; done = true ; } else if ( octant . points . length < octree . maxPoints || depth === octree . maxDepth ) { octant . points . push ( point . clone ( ) ) ; octant . data . push ( data ) ; ++ octree . pointCount ; done = true ; } else { octant . split ( ) ; octant . redistribute ( octree . bias ) ; children = octant . children ; } } if ( children !== null ) { ++ depth ; for ( i = 0 , l = children . length ; ! done && i < l ; ++ i ) { done = put ( point , data , octree , children [ i ] , depth ) ; } } } return done ; } 
function fetch ( point , octree , octant ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( children !== null ) { for ( i = 0 , l = children . length ; result === null && i < l ; ++ i ) { result = fetch ( point , octree , children [ i ] ) ; } } else if ( octant . points !== null ) { points = octant . points ; for ( i = 0 , l = points . length ; result === null && i < l ; ++ i ) { if ( point . equals ( points [ i ] ) ) { result = octant . data [ i ] ; } } } } return result ; } 
function move ( point , position , octree , octant , parent , depth ) { const children = octant . children ; let result = null ; let i , l ; let points ; if ( octant . contains ( point , octree . bias ) ) { if ( octant . contains ( position , octree . bias ) ) { 
function findPoints ( point , radius , skipSelf , octant , result ) { const children = octant . children ; let i , l ; if ( children !== null ) { let child ; for ( i = 0 , l = children . length ; i < l ; ++ i ) { child = children [ i ] ; if ( child . contains ( point , radius ) ) { findPoints ( point , radius , skipSelf , child , result ) ; } } } else if ( octant . points !== null ) { const points = octant . points ; const rSq = radius * radius ; let p ; for ( i = 0 , l = points . length ; i < l ; ++ i ) { p = points [ i ] ; if ( p . equals ( point ) ) { if ( ! skipSelf ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } else if ( p . distanceToSquared ( point ) <= rSq ) { result . push ( { point : p . clone ( ) , data : octant . data [ i ] } ) ; } } } } 
function cull ( octant , region , result ) { const children = octant . children ; let i , l ; b . min = octant . min ; b . max = octant . max ; if ( region . intersectsBox ( b ) ) { if ( children !== null ) { for ( i = 0 , l = children . length ; i < l ; ++ i ) { cull ( children [ i ] , region , result ) ; } } else { result . push ( octant ) ; } } } 
function findOctantsByLevel ( octant , level , depth , result ) { const children = octant . children ; let i , l ; if ( depth === level ) { result . push ( octant ) ; } else if ( children !== null ) { ++ depth ; for ( i = 0 , l = children . length ; i < l ; ++ i ) { findOctantsByLevel ( children [ i ] , level , depth , result ) ; } } } 
function findEntryOctant ( tx0 , ty0 , tz0 , txm , tym , tzm ) { let entry = 0 ; 
function findNextOctant ( currentOctant , tx1 , ty1 , tz1 ) { let min ; let exit = 0 ; 
function raycastOctant ( octant , tx0 , ty0 , tz0 , tx1 , ty1 , tz1 , raycaster , intersects ) { const children = octant . children ; let currentOctant ; let txm , tym , tzm ; if ( tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0 ) { if ( children === null ) { * order as the t-values. Hence, if the first value is found to be the * greatest, the fourth one will be returned. If the second value is the * greatest, the fifth one will be returned, etc. */ switch ( currentOctant ) { case 0 : raycastOctant ( children [ flags ] , tx0 , ty0 , tz0 , txm , tym , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , tym , tzm ) ; break ; case 1 : raycastOctant ( children [ flags ^ 1 ] , tx0 , ty0 , tzm , txm , tym , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , tym , tz1 ) ; break ; case 2 : raycastOctant ( children [ flags ^ 2 ] , tx0 , tym , tz0 , txm , ty1 , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , ty1 , tzm ) ; break ; case 3 : raycastOctant ( children [ flags ^ 3 ] , tx0 , tym , tzm , txm , ty1 , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , txm , ty1 , tz1 ) ; break ; case 4 : raycastOctant ( children [ flags ^ 4 ] , txm , ty0 , tz0 , tx1 , tym , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , tym , tzm ) ; break ; case 5 : raycastOctant ( children [ flags ^ 5 ] , txm , ty0 , tzm , tx1 , tym , tz1 , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , tym , tz1 ) ; break ; case 6 : raycastOctant ( children [ flags ^ 6 ] , txm , tym , tz0 , tx1 , ty1 , tzm , raycaster , intersects ) ; currentOctant = findNextOctant ( currentOctant , tx1 , ty1 , tzm ) ; break ; case 7 : raycastOctant ( children [ flags ^ 7 ] , txm , tym , tzm , tx1 , ty1 , tz1 , raycaster , intersects ) ; 
function deferred ( options ) { let args = null ; const promise = new Promise ( ( resolve , reject ) => args = [ resolve , reject , options ] ) ; promise . defer = function defer ( ) { if ( ! args ) throw new Error ( 'defer has already been called' ) ; const callback = callbackBuilder . apply ( undefined , args ) ; args = null ; return callback ; } ; return promise ; } 
function withTimeout ( promise , delay , message ) { let timeout ; const timeoutPromise = new Promise ( ( resolve , reject ) => { 
function waitOn ( emitter , event , waitError ) { if ( waitError ) { return new Promise ( ( resolve , reject ) => { function unbind ( ) { emitter . removeListener ( 'error' , onError ) ; emitter . removeListener ( event , onEvent ) ; } function onEvent ( value ) { unbind ( ) ; resolve ( value ) ; } function onError ( err ) { unbind ( ) ; reject ( err ) ; } emitter . on ( 'error' , onError ) ; emitter . on ( event , onEvent ) ; } ) ; } return new Promise ( ( resolve ) => emitter . once ( event , resolve ) ) ; } 
function promisify ( orig , options ) { if ( typeof orig !== 'function' ) { throw new TypeError ( 'promisify requires a function' ) ; } if ( orig [ kCustomPromisifiedSymbol ] ) { const fn = orig [ kCustomPromisifiedSymbol ] ; if ( typeof fn !== 'function' ) { throw new TypeError ( 'The [util.promisify.custom] property must be a function' ) ; } Object . defineProperty ( fn , kCustomPromisifiedSymbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return fn ; } function fn ( ) { const args = toArray ( arguments ) ; return new Promise ( ( resolve , reject ) => { args . push ( callbackBuilder ( resolve , reject , options ) ) ; try { orig . apply ( this , args ) ; } catch ( err ) { reject ( err ) ; } } ) ; } Object . setPrototypeOf ( fn , Object . getPrototypeOf ( orig ) ) ; Object . defineProperty ( fn , kCustomPromisifiedSymbol , { value : fn , enumerable : false , writable : false , configurable : true } ) ; return Object . defineProperties ( fn , getOwnPropertyDescriptors ( orig ) ) ; } 
function promisifyMethod ( obj , methodName , options ) { if ( ! obj ) { 
function promisifyMethods ( obj , methodNames , options ) { if ( ! obj ) { 
function promisifyAll ( obj , options ) { if ( ! obj ) { 
function patchPromise ( ) { const props = { } ; for ( let method of methods ) { if ( Promise . prototype [ method . name ] && Promise . prototype [ method . name ] !== method ) { throw new Error ( '`Promise` already defines method `' + method . name + '`' ) ; } props [ method . name ] = { configurable : true , enumerable : false , writable : true , value : method } ; } Object . defineProperties ( Promise . prototype , props ) ; } 
function unpatchPromise ( ) { for ( let method of methods ) { if ( Promise . prototype [ method . name ] === method ) { delete Promise . prototype [ method . name ] ; } } } 
function asCheckedCallback ( promise , cb , useOwnMethod ) { let called = false ; if ( useOwnMethod ) { promise . asCallback ( after ) ; } else { asCallback ( promise , after ) ; } function after ( ) { expect ( called ) . toBeFalsy ( ) ; called = true ; return cb . apply ( this , arguments ) ; } } 
function asCallback ( promise , cb ) { promise . then ( ( res ) => cb ( null , res ) , cb ) ; } 
function interpolate ( min , max , ratio ) { return Math . floor ( ratio * ( ( max + 0.5 ) - min ) + min ) ; } 
function sample ( gen , count , raw ) { if ( arguments . length < 2 ) { count = DEFAULT_COUNT ; } var rng = new PRNG ( Date . now ( ) & 0xffffffff ) ; var results = new Array ( count ) ; for ( var i = 0 ; i < count ; i ++ ) { results [ i ] = gen ( rng , Math . floor ( i / 2 ) + 1 ) ; } return raw ? results : results . map ( getRoot ) ; } 
function ( root , childrenFunc ) { if ( ! ( this instanceof RoseTree ) ) { return new RoseTree ( root , childrenFunc ) ; } this . root = root ; this . _children = childrenFunc ? new Thunk ( childrenFunc ) : emptyThunk ; } 
function flatten ( tree ) { if ( ! ( tree . root instanceof RoseTree ) ) { throw new TypeError ( "Can't call flatten when elements aren't trees" ) ; } return new RoseTree ( tree . root . root , function ( ) { var innerChildren = tree . root . children ( ) ; var outerChildren = tree . children ( ) . map ( flatten ) ; return outerChildren . concat ( innerChildren ) ; } ) ; } 
function fmap ( f , tree ) { return new RoseTree ( f ( tree . root ) , function ( ) { return tree . children ( ) . map ( fmap . bind ( null , f ) ) ; } ) ; } 
function filterSubtrees ( pred , tree ) { return new RoseTree ( tree . root , function ( ) { return tree . children ( ) . filter ( function ( subtree ) { return pred ( subtree . root ) ; } ) . map ( filterSubtrees . bind ( null , pred ) ) ; } ) ; } 
function arrayToRoseTrees ( array , fun ) { return array . map ( function ( element ) { return new RoseTree ( element , function ( ) { return fun ( element ) ; } ) ; } ) ; } 
function roseify ( f ) { var roseified = function ( ) { var restArgs = [ ] . slice . call ( arguments , 1 ) ; return arrayToRoseTrees ( f . apply ( null , arguments ) , function ( value ) { return roseified . apply ( null , [ value ] . concat ( restArgs ) ) ; } ) ; } ; return roseified ; } 
function ( xts ) { return new RoseTree ( xts . map ( function ( tree ) { return tree . root ; } ) , function ( ) { return exports . array ( xts , tryRemoving ) ; } ) ; } 
function State ( options ) { const state = { options } const states = options . children state . path = pathFromURI ( options . uri ) state . params = paramsFromURI ( options . uri ) state . queryParams = queryParamsFromURI ( options . uri ) state . states = states state . data = options . data state . enter = options . enter || util . noop state . update = options . update state . exit = options . exit || util . noop function init ( router , name , parent ) { state . router = router state . name = name state . isDefault = name == '_default_' state . parent = parent state . parents = getParents ( ) state . root = state . parent ? state . parents [ state . parents . length - 1 ] : state state . children = util . objectToArray ( states ) state . fullName = getFullName ( ) state . asPublic = makePublicAPI ( ) eachChildState ( ( name , childState ) => { childState . init ( router , name , state ) } ) } function fullPath ( ) { let result = state . path let stateParent = state . parent while ( stateParent ) { if ( stateParent . path ) result = stateParent . path + '/' + result stateParent = stateParent . parent } return result } function getParents ( ) { const parents = [ ] let parent = state . parent while ( parent ) { parents . push ( parent ) parent = parent . parent } return parents } function getFullName ( ) { const result = state . parents . reduceRight ( ( acc , parent ) => { return acc + parent . name + '.' } , '' ) + state . name return state . isDefault ? result . replace ( '._default_' , '' ) : result } function allQueryParams ( ) { return state . parents . reduce ( ( acc , parent ) => { return util . mergeObjects ( acc , parent . queryParams ) } , util . copyObject ( state . queryParams ) ) } function makePublicAPI ( ) { return { name : state . name , fullName : state . fullName , data : options . data || { } , parent : state . parent && state . parent . asPublic } } function eachChildState ( callback ) { for ( let name in states ) callback ( name , states [ name ] ) } function matches ( paths ) { const params = { } const nonRestStatePaths = state . paths . filter ( p => p [ p . length - 1 ] !== '*' ) if ( nonRestStatePaths . length > paths . length ) return false for ( let i = 0 ; i < paths . length ; i ++ ) { const path = paths [ i ] const thatPath = state . paths [ i ] if ( ! thatPath ) return false const isRest = thatPath [ thatPath . length - 1 ] === '*' if ( isRest ) { const name = paramName ( thatPath ) params [ name ] = paths . slice ( i ) . join ( '/' ) return params } const isDynamic = thatPath [ 0 ] === ':' if ( isDynamic ) { const name = paramName ( thatPath ) params [ name ] = path } else if ( thatPath != path ) return false } return params } function interpolate ( params ) { const path = state . fullPath ( ) . replace ( PARAMS , p => params [ paramName ( p ) ] || '' ) const queryParams = allQueryParams ( ) const passedQueryParams = Object . keys ( params ) . filter ( p => queryParams [ p ] ) const query = passedQueryParams . map ( p => p + '=' + params [ p ] ) . join ( '&' ) return path + ( query . length ? ( '?' + query ) : '' ) } function toString ( ) { return state . fullName } state . init = init state . fullPath = fullPath state . allQueryParams = allQueryParams state . matches = matches state . interpolate = interpolate state . toString = toString return state } 
function init ( router , name , parent ) { state . router = router state . name = name state . isDefault = name == '_default_' state . parent = parent state . parents = getParents ( ) state . root = state . parent ? state . parents [ state . parents . length - 1 ] : state state . children = util . objectToArray ( states ) state . fullName = getFullName ( ) state . asPublic = makePublicAPI ( ) eachChildState ( ( name , childState ) => { childState . init ( router , name , state ) } ) } 
function fullPath ( ) { let result = state . path let stateParent = state . parent while ( stateParent ) { if ( stateParent . path ) result = stateParent . path + '/' + result stateParent = stateParent . parent } return result } 
function getParents ( ) { const parents = [ ] let parent = state . parent while ( parent ) { parents . push ( parent ) parent = parent . parent } return parents } 
function getFullName ( ) { const result = state . parents . reduceRight ( ( acc , parent ) => { return acc + parent . name + '.' } , '' ) + state . name return state . isDefault ? result . replace ( '._default_' , '' ) : result } 
function matches ( paths ) { const params = { } const nonRestStatePaths = state . paths . filter ( p => p [ p . length - 1 ] !== '*' ) if ( nonRestStatePaths . length > paths . length ) return false for ( let i = 0 ; i < paths . length ; i ++ ) { const path = paths [ i ] const thatPath = state . paths [ i ] if ( ! thatPath ) return false const isRest = thatPath [ thatPath . length - 1 ] === '*' if ( isRest ) { const name = paramName ( thatPath ) params [ name ] = paths . slice ( i ) . join ( '/' ) return params } const isDynamic = thatPath [ 0 ] === ':' if ( isDynamic ) { const name = paramName ( thatPath ) params [ name ] = path } else if ( thatPath != path ) return false } return params } 
function interpolate ( params ) { const path = state . fullPath ( ) . replace ( PARAMS , p => params [ paramName ( p ) ] || '' ) const queryParams = allQueryParams ( ) const passedQueryParams = Object . keys ( params ) . filter ( p => queryParams [ p ] ) const query = passedQueryParams . map ( p => p + '=' + params [ p ] ) . join ( '&' ) return path + ( query . length ? ( '?' + query ) : '' ) } 
function isIn ( fullStateName ) { let current = state while ( current ) { if ( current . fullName == fullStateName ) return true current = current . parent } return false } 
function Router ( declarativeStates ) { const router = { } const states = stateTrees ( declarativeStates ) const eventCallbacks = { } let options = util . copyObject ( defaultOptions ) let firstTransition = true let ignoreNextURLChange = false let currentPathQuery let currentParamsDiff = { } let currentState let previousState let transition let leafStates let urlChanged let initialized let hashSlashString function setState ( state , params , acc ) { const fromState = transition ? StateWithParams ( transition . currentState , transition . toParams ) : currentState const diff = util . objectDiff ( fromState && fromState . params , params ) const toState = StateWithParams ( state , params , currentPathQuery , diff ) if ( preventTransition ( fromState , toState , diff ) ) { if ( transition && transition . exiting ) cancelTransition ( ) return } if ( transition ) cancelTransition ( ) * Return whether the passed state is the same as the current one * in which case the router can ignore the change. */ function preventTransition ( current , newState , diff ) { if ( ! current ) return false return ( newState . state == current . state ) && ( Object . keys ( diff . all ) . length == 0 ) } function notFound ( state ) { logger . log ( 'State not found: {0}' , state ) if ( options . notFound ) return setState ( leafStates [ options . notFound ] , { } ) else throw new Error ( 'State "' + state + '" could not be found' ) } function configure ( withOptions ) { util . mergeObjects ( options , withOptions ) return router } function init ( initState , initParams ) { if ( options . enableLogs || Router . log ) Router . enableLogs ( ) if ( options . interceptAnchors ) interceptAnchors ( router ) hashSlashString = '#' + options . hashPrefix + '/' logger . log ( 'Router init' ) initStates ( ) logStateTree ( ) initState = ( initState !== undefined ) ? initState : urlPathQuery ( ) logger . log ( 'Initializing to state {0}' , initState || '""' ) transitionTo ( initState , initParams ) listenToURLChanges ( ) initialized = true return router } function terminate ( ) { window . onhashchange = null window . onpopstate = null options = util . copyObject ( defaultOptions ) logger . enabled = false logger . log = logger . error = util . noop } function listenToURLChanges ( ) { function onURLChange ( evt ) { if ( ignoreNextURLChange ) { ignoreNextURLChange = false return } const newState = evt . state || urlPathQuery ( ) logger . log ( 'URL changed: {0}' , newState ) urlChanged = true setStateForPathQuery ( newState ) } window [ isHashMode ( ) ? 'onhashchange' : 'onpopstate' ] = onURLChange } function initStates ( ) { const stateArray = util . objectToArray ( states ) addDefaultStates ( stateArray ) eachRootState ( ( name , state ) => { state . init ( router , name ) } ) assertPathUniqueness ( stateArray ) leafStates = registerLeafStates ( stateArray , { } ) assertNoAmbiguousPaths ( ) } function assertPathUniqueness ( states ) { const paths = { } states . forEach ( state => { if ( paths [ state . path ] ) { const fullPaths = states . map ( s => s . fullPath ( ) || 'empty' ) throw new Error ( 'Two sibling states have the same path (' + fullPaths + ')' ) } paths [ state . path ] = 1 assertPathUniqueness ( state . children ) } ) } function assertNoAmbiguousPaths ( ) { const paths = { } for ( var name in leafStates ) { const path = util . normalizePathQuery ( leafStates [ name ] . fullPath ( ) ) if ( paths [ path ] ) throw new Error ( 'Ambiguous state paths: ' + path ) paths [ path ] = 1 } } function addDefaultStates ( states ) { states . forEach ( state => { var children = util . objectToArray ( state . states ) * Request a programmatic state change. * * Two notations are supported: * transitionTo('my.target.state', {id: 33, filter: 'desc'}) * transitionTo('target/33?filter=desc') */ function transitionTo ( pathQueryOrName ) { const name = leafStates [ pathQueryOrName ] const params = ( name ? arguments [ 1 ] : null ) || { } const acc = name ? arguments [ 2 ] : arguments [ 1 ] logger . log ( 'Changing state to {0}' , pathQueryOrName || '""' ) urlChanged = false if ( name ) setStateByName ( name , params , acc ) else setStateForPathQuery ( pathQueryOrName , acc ) } function replaceParams ( newParams ) { if ( ! currentState ) return const newUri = router . link ( currentState . state . fullName , newParams ) currentState = StateWithParams ( currentState . state , newParams , newUri ) history . replaceState ( newUri , document . title , newUri ) } function backTo ( stateName , defaultParams , acc ) { const params = leafStates [ stateName ] . lastParams || defaultParams transitionTo ( stateName , params , acc ) } function setStateForPathQuery ( pathQuery , acc ) { let state , params , _state , _params currentPathQuery = util . normalizePathQuery ( pathQuery ) const pq = currentPathQuery . split ( '?' ) const path = pq [ 0 ] const query = pq [ 1 ] const paths = util . parsePaths ( path ) const queryParams = util . parseQueryParams ( query ) for ( var name in leafStates ) { _state = leafStates [ name ] _params = _state . matches ( paths ) if ( _params ) { state = _state params = util . mergeObjects ( _params , queryParams ) break } } if ( state ) setState ( state , params , acc ) else notFound ( currentPathQuery ) } function setStateByName ( name , params , acc ) { const state = leafStates [ name ] if ( ! state ) return notFound ( name ) const pathQuery = interpolate ( state , params ) setStateForPathQuery ( pathQuery , acc ) } function addState ( name , state ) { if ( states [ name ] ) throw new Error ( 'A state already exist in the router with the name ' + name ) state = stateTree ( state ) states [ name ] = state * Read the path/query from the URL. */ function urlPathQuery ( ) { const hashSlash = location . href . indexOf ( hashSlashString ) let pathQuery if ( hashSlash > - 1 ) pathQuery = location . href . slice ( hashSlash + hashSlashString . length ) else if ( isHashMode ( ) ) pathQuery = '/' else pathQuery = ( location . pathname + location . search ) . slice ( 1 ) return util . normalizePathQuery ( pathQuery ) } function isHashMode ( ) { return options . urlSync == 'hash' } function link ( stateName , params ) { const state = leafStates [ stateName ] if ( ! state ) throw new Error ( 'Cannot find state ' + stateName ) const interpolated = interpolate ( state , params ) const uri = util . normalizePathQuery ( interpolated ) return isHashMode ( ) ? '#' + options . hashPrefix + uri : uri } function interpolate ( state , params ) { const encodedParams = { } for ( let key in params ) { if ( params [ key ] !== undefined ) encodedParams [ key ] = encodeURIComponent ( params [ key ] ) } return state . interpolate ( encodedParams ) } function getCurrent ( ) { return currentState && currentState . asPublic } function getPrevious ( ) { return previousState && previousState . asPublic } function getParamsDiff ( ) { return currentParamsDiff } function allStatesRec ( states , acc ) { acc . push . apply ( acc , states ) states . forEach ( state => allStatesRec ( state . children , acc ) ) return acc } function allStates ( ) { return allStatesRec ( util . objectToArray ( states ) , [ ] ) } function findState ( by ) { const filterFn = ( typeof by === 'object' ) ? state => by === state . options : state => by === state . fullName const state = allStates ( ) . filter ( filterFn ) [ 0 ] return state && state . asPublic } function isFirstTransition ( ) { return previousState == null } function on ( eventName , cb ) { eventCallbacks [ eventName ] = cb return router } function stateTrees ( states ) { return util . mapValues ( states , stateTree ) } function stateTree ( state ) { if ( state . children ) state . children = stateTrees ( state . children ) return State ( state ) } function logStateTree ( ) { if ( ! logger . enabled ) return function indent ( level ) { if ( level == 0 ) return '' return new Array ( 2 + ( level - 1 ) * 4 ) . join ( ' ' ) + '── ' } const stateTree = function ( state ) { const path = util . normalizePathQuery ( state . fullPath ( ) ) const pathStr = ( state . children . length == 0 ) ? ' (@ path)' . replace ( 'path' , path ) : '' const str = indent ( state . parents . length ) + state . name + pathStr + '\n' return str + state . children . map ( stateTree ) . join ( '' ) } let msg = '\nState tree\n\n' msg += util . objectToArray ( states ) . map ( stateTree ) . join ( '' ) msg += '\n' logger . log ( msg ) } 
function setState ( state , params , acc ) { const fromState = transition ? StateWithParams ( transition . currentState , transition . toParams ) : currentState const diff = util . objectDiff ( fromState && fromState . params , params ) const toState = StateWithParams ( state , params , currentPathQuery , diff ) if ( preventTransition ( fromState , toState , diff ) ) { if ( transition && transition . exiting ) cancelTransition ( ) return } if ( transition ) cancelTransition ( ) 
function preventTransition ( current , newState , diff ) { if ( ! current ) return false return ( newState . state == current . state ) && ( Object . keys ( diff . all ) . length == 0 ) } 
function notFound ( state ) { logger . log ( 'State not found: {0}' , state ) if ( options . notFound ) return setState ( leafStates [ options . notFound ] , { } ) else throw new Error ( 'State "' + state + '" could not be found' ) } 
function init ( initState , initParams ) { if ( options . enableLogs || Router . log ) Router . enableLogs ( ) if ( options . interceptAnchors ) interceptAnchors ( router ) hashSlashString = '#' + options . hashPrefix + '/' logger . log ( 'Router init' ) initStates ( ) logStateTree ( ) initState = ( initState !== undefined ) ? initState : urlPathQuery ( ) logger . log ( 'Initializing to state {0}' , initState || '""' ) transitionTo ( initState , initParams ) listenToURLChanges ( ) initialized = true return router } 
function terminate ( ) { window . onhashchange = null window . onpopstate = null options = util . copyObject ( defaultOptions ) logger . enabled = false logger . log = logger . error = util . noop } 
function transitionTo ( pathQueryOrName ) { const name = leafStates [ pathQueryOrName ] const params = ( name ? arguments [ 1 ] : null ) || { } const acc = name ? arguments [ 2 ] : arguments [ 1 ] logger . log ( 'Changing state to {0}' , pathQueryOrName || '""' ) urlChanged = false if ( name ) setStateByName ( name , params , acc ) else setStateForPathQuery ( pathQueryOrName , acc ) } 
function replaceParams ( newParams ) { if ( ! currentState ) return const newUri = router . link ( currentState . state . fullName , newParams ) currentState = StateWithParams ( currentState . state , newParams , newUri ) history . replaceState ( newUri , document . title , newUri ) } 
function backTo ( stateName , defaultParams , acc ) { const params = leafStates [ stateName ] . lastParams || defaultParams transitionTo ( stateName , params , acc ) } 
function addState ( name , state ) { if ( states [ name ] ) throw new Error ( 'A state already exist in the router with the name ' + name ) state = stateTree ( state ) states [ name ] = state 
function urlPathQuery ( ) { const hashSlash = location . href . indexOf ( hashSlashString ) let pathQuery if ( hashSlash > - 1 ) pathQuery = location . href . slice ( hashSlash + hashSlashString . length ) else if ( isHashMode ( ) ) pathQuery = '/' else pathQuery = ( location . pathname + location . search ) . slice ( 1 ) return util . normalizePathQuery ( pathQuery ) } 
function link ( stateName , params ) { const state = leafStates [ stateName ] if ( ! state ) throw new Error ( 'Cannot find state ' + stateName ) const interpolated = interpolate ( state , params ) const uri = util . normalizePathQuery ( interpolated ) return isHashMode ( ) ? '#' + options . hashPrefix + uri : uri } 
function findState ( by ) { const filterFn = ( typeof by === 'object' ) ? state => by === state . options : state => by === state . fullName const state = allStates ( ) . filter ( filterFn ) [ 0 ] return state && state . asPublic } 
function stateTree ( state ) { if ( state . children ) state . children = stateTrees ( state . children ) return State ( state ) } 
function Transition ( fromStateWithParams , toStateWithParams , paramsDiff , acc , router , logger ) { let root = { root : null , inclusive : true } let enters let exits const fromState = fromStateWithParams && fromStateWithParams . state const toState = toStateWithParams . state const params = toStateWithParams . params const isUpdate = ( fromState == toState ) const transition = { from : fromState , to : toState , toParams : params , cancel , run , cancelled : false , currentState : fromState } 
function transitionRoot ( fromState , toState , isUpdate , paramsDiff ) { let closestCommonParent const parents = [ fromState ] . concat ( fromState . parents ) . reverse ( ) 
function execCmd ( i ) { var cmd = cmdlines [ i ] ; if ( ! cmd ) return ; var child = exec ( cmd , function ( error , stdout , stderr ) { if ( stdout ) { console . log ( '-- exec stdout: ' ) ; console . log ( stdout ) ; } if ( stderr ) { console . log ( '-- exec stderr: ' ) ; console . log ( stderr ) ; } if ( error ) { console . log ( '-- exec error: ' ) ; console . log ( error ) ; } execCmd ( ++ i ) ; } ) ; } 
function ( bytes , byteOffset , byteLength ) { try { UTF8 . getStringFromBytes ( bytes , byteOffset , byteLength , true ) ; } catch ( e ) { return true ; } return false ; } 
function ( ) { 
function MIDIFileHeader ( buffer ) { let a ; 
function emitError ( currentDomain , err ) { util . _extend ( err , { domain : currentDomain , domain_thrown : true } ) ; currentDomain . emit ( 'error' , err ) ; currentDomain . exit ( ) ; } 
function start ( ) { 
function startListening ( ) { if ( shouldBind ) { try { bind ( self . fd , self . port , self . host ) ; listen ( self . fd , self . options . backlog ) ; } catch ( e ) { self . kill ( 'SIGKILL' ) ; throw e ; } } self . callback && self . callback ( ) ; self . emit ( 'listening' ) ; } 
function sum ( arr , prop ) { return arr . reduce ( function ( sum , obj ) { return sum + obj . stats [ prop ] ; } , 0 ) ; } 
function traverse ( file ) { file = master . resolve ( file ) ; fs . stat ( file , function ( err , stat ) { if ( ! err ) { if ( stat . isDirectory ( ) ) { if ( ~ exports . ignoreDirectories . indexOf ( basename ( file ) ) ) return ; fs . readdir ( file , function ( err , files ) { files . map ( function ( f ) { return file + '/' + f ; } ) . forEach ( traverse ) ; } ) ; } else { watch ( file ) ; } } } ) ; } 
function watch ( file ) { if ( ! ~ extensions . indexOf ( extname ( file ) ) ) return ; fs . watchFile ( file , { interval : interval } , function ( curr , prev ) { if ( curr . mtime > prev . mtime ) { console . log ( ' \033[36mchanged\033[0m \033[90m- %s\033[0m' , file ) ; master . restartWorkers ( signal ) ; } } ) ; } 
function detectGeoCSV ( buf ) { var lines = buf . toString ( ) . split ( / \r\n|\r|\n / g ) . filter ( function ( line ) { return line !== '' ; } ) ; return lines . length > 0 && 
function installWatcher ( startingFolder , callback ) { bs . init ( { server : config . commands . build . output , port : config . commands . build . port , ui : false , open : false , logLevel : 'silent' } ) const watcher = createWatcher ( path . join ( startingFolder , '**/data.xml' ) ) watcher . on ( 'change' , ( ) => { callback ( ) bs . reload ( ) } ) } 
function installDevelopmentWatcher ( startingFolder , callback ) { const buildFolder = config . commands . build . output 
function createDir ( dir ) { if ( fs . existsSync ( dir ) ) { return false } mkdirp . sync ( dir ) return true } 
function findAllFiles ( baseDir , { ignoredFolders = [ ] , maxDepth = undefined } = { } ) { let list = [ ] function search ( dir , depth ) { fs . readdirSync ( dir ) . forEach ( file => { file = path . join ( dir , file ) 
function getElementHeight ( element ) { var clone = element . cloneNode ( true ) clone . style . cssText = 'visibility: hidden; display: block; margin: -999px 0' var height = ( element . parentNode . appendChild ( clone ) ) . clientHeight element . parentNode . removeChild ( clone ) return height } 
function loadDataFile ( filename ) { let xml = fs . readFileSync ( filename , 'utf-8' ) 
function normalizeKeys ( keys , json ) { Object . keys ( json ) . filter ( k => keys . includes ( k ) ) . forEach ( k => { json [ k ] = normalize ( json [ k ] ) } ) return json } 
async function build ( dataFilePath , presskit , { company = { } , products = [ ] , analytics = '' } = { } ) { const buildFolder = createAndGetBuildFolder ( ) const pageFolder = getPageFolder ( buildFolder , dataFilePath , presskit . type ) 
function createAndGetBuildFolder ( ) { const destination = config . commands . build . output sfs . createDir ( destination ) return destination } 
function getAbsolutePageUrl ( dataFilePath , pageType ) { const buildFolder = createAndGetBuildFolder ( ) const pageFolder = getPageFolder ( buildFolder , dataFilePath , pageType ) const htmlFilePath = getHtmlFilePath ( pageFolder ) const relativePath = path . posix . relative ( buildFolder , htmlFilePath ) return path . posix . join ( config . commands . build . baseUrl , relativePath ) } 
function getImagesFolder ( dataFile ) { const stat = fs . statSync ( dataFile ) const dataFileFolder = stat . isFile ( ) ? path . dirname ( dataFile ) : dataFile return path . join ( dataFileFolder , imagesFolderName ) } 
function getImages ( source ) { if ( ! fs . existsSync ( source ) ) { console . error ( ` ${ source } ` , '🤔') return } const images = { header : null , screenshots : [ ] , logos : [ ] } sfs . findAllFiles ( source ) . forEach ( filePathWithSource => { 
function sortScreenshotsByCategories ( images ) { const clone = { ... images } 
async function createThumbnails ( target , images ) { for ( const x of images ) { const imagePath = path . join ( target , x ) const thumbPath = path . join ( target , ` ${ x } ` ) try { 
function exportArchives ( images , source , target ) { if ( ! images ) return createArchive ( 'images.zip' , target , source , images . screenshots ) createArchive ( 'logo.zip' , target , source , images . logos ) } 
function parseXML ( xml ) { if ( ! xml ) { throw new Error ( 'XML input was null or empty' ) } let data new XMLParser ( OPTIONS ) . parseString ( xml , function ( err , result ) { if ( err || ! result ) { throw new Error ( 'Failed to parse XML file' ) } 
function createTemplate ( type , destination ) { const templatePath = getTemplatePath ( assets , type ) if ( ! templatePath ) { throw new Error ( 'Missing template! Make sure your presskit has a "type" field (product/company)' ) } registerPartials ( assets ) registerHelpers ( destination ) const template = fs . readFileSync ( templatePath , 'utf-8' ) return handlebars . compile ( template ) } 
function getTemplatePath ( folder , type ) { switch ( type ) { case 'product' : return path . join ( folder , 'product.html' ) case 'company' : return path . join ( folder , 'company.html' ) } } 
function registerPartials ( folder ) { const partialsFolder = path . join ( folder , '_includes' ) const partials = fs . readdirSync ( partialsFolder ) . filter ( isValidPartial ) . reduce ( ( result , partial ) => { const ext = path . extname ( partial ) const fileFullPath = path . join ( partialsFolder , partial ) const data = fs . readFileSync ( fileFullPath , 'utf-8' ) 
function ( image ) { const imageName = path . join ( 'images' , image ) const thumbName = path . join ( 'images' , ` ${ image } ` ) const thumbPath = path . join ( destination , thumbName ) if ( fs . existsSync ( thumbPath ) ) return thumbName return imageName } 
async function generate ( entryPoint ) { console . log ( ` ${ chalk . green ( entryPoint ) } ` ) cleanBuildFolder ( ) const pages = findData ( entryPoint ) if ( countDataFiles ( pages ) === 0 ) { console . log ( '' ) console . warn ( 'No data files found!' ) return } if ( ! pages . company ) { console . log ( '' ) console . error ( 'No company data file found!' ) return } await generateHTML ( pages ) await exportAdditionalAssets ( ) console . log ( '' ) console . log ( 'Done! 👌') if ( config . commands . build . watch ) { const port = config . commands . build . port const address = chalk . green ( ` ${ port } ` ) showHeader ( ` ${ address } ` ) startWatcher ( entryPoint , ( ) => generateHTML ( findData ( entryPoint ) ) ) } } 
function createRelation ( type , product ) { return { type , text : product . presskit . title , path : getAbsolutePageUrl ( product . path , product . presskit . type ) } } 
async function copyMandatoryFiles ( ) { const buildDir = createAndGetBuildFolder ( ) for ( const f of assetsToCopy ) { const filepath = path . resolve ( f ) 
function countDataFiles ( pages ) { let count = 0 count += ( pages . company ? 1 : 0 ) count += pages . products . length return count } 
function isDataFile ( filename ) { const ext = path . extname ( filename ) const filenameWithoutExt = path . basename ( filename , ext ) return filenameWithoutExt === 'data' && ext === '.xml' } 
function startWatcher ( entryPoint , callback ) { if ( config . commands . build . dev ) { 
function colorize ( colorizer , args ) { return Array . from ( args ) . map ( el => colorizer ( el ) ) } 
function runBuildCommand ( launchOptions ) { config . commands . build = launchOptions parseEntryPoint ( launchOptions . entryPoint , ( err , entry ) => { if ( err ) { console . warn ( 'No valid entry point provided. Use current directory instead' ) console . log ( '' ) generator . generate ( process . cwd ( ) ) return } generator . generate ( entry ) } ) } 
function zip ( name , destination , source , files ) { if ( files && files . length > 0 ) { const filename = path . join ( destination , name ) const output = fs . createWriteStream ( filename ) const archive = archiver ( 'zip' , { store : true } ) archive . on ( 'error' , ( err ) => { throw err } ) archive . pipe ( output ) files . forEach ( ( f ) => { archive . append ( fs . createReadStream ( path . join ( source , f ) ) , { name : f } ) } ) archive . finalize ( ) return filename } } 
function isPrototype ( value ) { var Ctor = value && value . constructor , proto = ( typeof Ctor == 'function' && Ctor . prototype ) || objectProto$4 ; return value === proto ; } 
function hashHas ( key ) { var data = this . __data__ ; return nativeCreate ? ( data [ key ] !== undefined ) : hasOwnProperty$6 . call ( data , key ) ; } 
function reduce ( collection , iteratee , accumulator ) { var func = isArray ( collection ) ? arrayReduce : baseReduce , initAccum = arguments . length < 3 ; return func ( collection , baseIteratee ( iteratee , 4 ) , accumulator , initAccum , baseEach ) ; } 
function assignValue ( object , key , value ) { var objValue = object [ key ] ; if ( ! ( hasOwnProperty$a . call ( object , key ) && eq ( objValue , value ) ) || ( value === undefined && ! ( key in object ) ) ) { baseAssignValue ( object , key , value ) ; } } 
function baseKeysIn ( object ) { if ( ! isObject ( object ) ) { return nativeKeysIn ( object ) ; } var isProto = isPrototype ( object ) , result = [ ] ; for ( var key in object ) { if ( ! ( key == 'constructor' && ( isProto || ! hasOwnProperty$b . call ( object , key ) ) ) ) { result . push ( key ) ; } } return result ; } 
function isEmpty ( value ) { if ( value == null ) { return true ; } if ( isArrayLike ( value ) && ( isArray ( value ) || typeof value == 'string' || typeof value . splice == 'function' || isBuffer ( value ) || isTypedArray ( value ) || isArguments ( value ) ) ) { return ! value . length ; } var tag = getTag$1 ( value ) ; if ( tag == mapTag$3 || tag == setTag$3 ) { return ! value . size ; } if ( isPrototype ( value ) ) { return ! baseKeys ( value ) . length ; } for ( var key in value ) { if ( hasOwnProperty$c . call ( value , key ) ) { return false ; } } return true ; } 
function some ( collection , predicate , guard ) { var func = isArray ( collection ) ? arraySome : baseSome ; if ( guard && isIterateeCall ( collection , predicate , guard ) ) { predicate = undefined ; } return func ( collection , baseIteratee ( predicate , 3 ) ) ; } 
function initCloneByTag ( object , tag , isDeep ) { var Ctor = object . constructor ; switch ( tag ) { case arrayBufferTag$2 : return cloneArrayBuffer ( object ) ; case boolTag$2 : case dateTag$2 : return new Ctor ( + object ) ; case dataViewTag$3 : return cloneDataView ( object , isDeep ) ; case float32Tag$1 : case float64Tag$1 : case int8Tag$1 : case int16Tag$1 : case int32Tag$1 : case uint8Tag$1 : case uint8ClampedTag$1 : case uint16Tag$1 : case uint32Tag$1 : return cloneTypedArray ( object , isDeep ) ; case mapTag$4 : return new Ctor ; case numberTag$2 : case stringTag$3 : return new Ctor ( object ) ; case regexpTag$2 : return cloneRegExp ( object ) ; case setTag$4 : return new Ctor ; case symbolTag$2 : return cloneSymbol ( object ) ; } } 
function forEachRight ( collection , iteratee ) { var func = isArray ( collection ) ? arrayEachRight : baseEachRight ; return func ( collection , castFunction ( iteratee ) ) ; } 
function compileTS ( module ) { var exitCode = 0 ; var tmpDir = path . join ( options . tmpDir , "tsreq" ) ; var relativeFolder = path . dirname ( path . relative ( process . cwd ( ) , module . filename ) ) ; var jsname = path . join ( tmpDir , relativeFolder , path . basename ( module . filename , ".ts" ) + ".js" ) ; if ( ! isModified ( module . filename , jsname ) ) { return jsname ; } var argv = [ "node" , "tsc.js" , ! ! options . emitOnError ? "" : "--noEmitOnError" , "--nolib" , "--rootDir" , process . cwd ( ) , "--target" , options . targetES5 ? "ES5" : "ES3" , ! ! options . moduleKind ? "--module" : "" , ! ! options . moduleKind ? options . moduleKind : "" , "--outDir" , tmpDir , libPath , options . nodeLib ? path . resolve ( __dirname , "typings/node.d.ts" ) : null , module . filename ] ; var proc = merge ( merge ( { } , process ) , { argv : compact ( argv ) , exit : function ( code ) { if ( code !== 0 && options . exitOnError ) { console . error ( 'Fatal Error. Unable to compile TypeScript file. Exiting.' ) ; process . exit ( code ) ; } exitCode = code ; } } ) ; var sandbox = { process : proc , require : require , module : module , Buffer : Buffer , setTimeout : setTimeout , clearTimeout : clearTimeout , __filename : tsc } ; tscScript . runInNewContext ( sandbox ) ; if ( exitCode !== 0 ) { throw new Error ( 'Unable to compile TypeScript file.' ) ; } return jsname ; } 
function toHexString ( num ) { var str = num . toString ( 16 ) ; while ( str . length < 2 ) { str = '0' + str ; } return str ; } 
function toColorHexString ( ref ) { var results = [ ] ; for ( var j = 0 , len = ref . length ; j < len ; j ++ ) { results . push ( toHexString ( ref [ j ] ) ) ; } return '#' + results . join ( '' ) ; } 
function resetStyles ( stack ) { var stackClone = stack . slice ( 0 ) ; stack . length = 0 ; return stackClone . reverse ( ) . map ( function ( tag ) { return '</' + tag + '>' ; } ) . join ( '' ) ; } 
function range ( low , high ) { const results = [ ] ; for ( var j = low ; j <= high ; j ++ ) { results . push ( j ) ; } return results ; } 
function categoryForCode ( code ) { code = parseInt ( code , 10 ) ; var result = null ; if ( code === 0 ) { result = 'all' ; } else if ( code === 1 ) { result = 'bold' ; } else if ( ( 2 < code && code < 5 ) ) { result = 'underline' ; } else if ( ( 4 < code && code < 7 ) ) { result = 'blink' ; } else if ( code === 8 ) { result = 'hide' ; } else if ( code === 9 ) { result = 'strike' ; } else if ( ( 29 < code && code < 38 ) || code === 39 || ( 89 < code && code < 98 ) ) { result = 'foreground-color' ; } else if ( ( 39 < code && code < 48 ) || code === 49 || ( 99 < code && code < 108 ) ) { result = 'background-color' ; } return result ; } 
function updateStickyStack ( stickyStack , token , data ) { if ( token !== 'text' ) { stickyStack = stickyStack . filter ( notCategory ( categoryForCode ( data ) ) ) ; stickyStack . push ( { token : token , data : data , category : categoryForCode ( data ) } ) ; } return stickyStack ; } 
function VFile ( options ) { var prop var index var length if ( ! options ) { options = { } } else if ( typeof options === 'string' || buffer ( options ) ) { options = { contents : options } } else if ( 'message' in options && 'messages' in options ) { return options } if ( ! ( this instanceof VFile ) ) { return new VFile ( options ) } this . data = { } this . messages = [ ] this . history = [ ] this . cwd = process . cwd ( ) 
function assertPart ( part , name ) { if ( part . indexOf ( path . sep ) !== - 1 ) { throw new Error ( '`' + name + '` cannot be a path: did not expect `' + path . sep + '`' ) } } 
function message ( reason , position , origin ) { var filePath = this . path var message = new VMessage ( reason , position , origin ) if ( filePath ) { message . name = filePath + ':' + message . name message . file = filePath } message . fatal = false this . messages . push ( message ) return message } 
async function initProject ( answers , install = true ) { const inquirer = require ( 'inquirer' ) ; let templateName ; if ( answers . name ) { templateName = answers . name ; } else { 
function getConfig ( projectDir , appName , env ) { if ( ! [ 'dev' , 'test' , 'prod' ] . includes ( env ) ) exit ( ` ${ env } ` ) ; process . env . NODE_ENV = { dev : 'development' , test : 'testing' , prod : 'production' } [ env ] ; const configPath = path . join ( projectDir , 'basys.json' ) ; let projectConfig ; try { projectConfig = fs . readFileSync ( configPath , 'utf8' ) ; } catch ( e ) { exit ( ` ${ configPath } \n ` ) ; } try { projectConfig = JSON5 . parse ( projectConfig ) ; } catch ( e ) { exit ( ` ${ configPath } ${ e . message } \n ` + 'You can use JSON5 (https://json5.org) which is an extension of the JSON format, that includes:\n' + ' - comments,\n - unquoted and single-quoted object keys,\n - trailing commas,\n - single-quoted and multi-line strings.\n' , ) ; } 
function codeConfig ( config ) { const conf = Object . create ( null ) ; for ( const key in config . custom ) { conf [ key ] = config . custom [ key ] ; } for ( const key of [ 'host' , 'port' , 'backendPort' ] ) { conf [ key ] = config [ key ] ; } return conf ; } 
function monitorServerStatus ( host , port , once , onChange ) { const socket = net . connect ( { host , port } ) ; let connected = true ; let reconnect = true ; socket . on ( 'connect' , ( ) => { connected = true ; onChange ( true ) ; if ( once ) { reconnect = false ; socket . destroy ( ) ; } } ) ; socket . on ( 'error' , ( ) => { } ) ; socket . on ( 'close' , err => { if ( reconnect ) { if ( connected ) { connected = false ; onChange ( false ) ; } setTimeout ( ( ) => socket . connect ( { host , port } ) , 500 ) ; } } ) ; return socket ; } 
function ( cb ) { var id = new Buffer ( 8 ) , time = Date . now ( ) - this . epoch ; id . fill ( 0 ) ; 
function o ( patternString , action ) { if ( typeof action === 'undefined' ) { return [ patternString , '$$ = $1;' ] ; } action = action . replace ( / \bnew / g , '$&yy.' ) ; return [ patternString , '$$ = ' + action + ';' ] ; } 
function Route ( spec ) { var route ; if ( this ) { 
function createVisitor ( handlers ) { nodeTypes . forEach ( function ( nodeType ) { if ( typeof handlers [ nodeType ] === 'undefined' ) { throw new Error ( 'No handler defined for ' + nodeType . displayName ) ; } } ) ; return { visit : function ( node , context ) { return this . handlers [ node . displayName ] . call ( this , node , context ) ; } , handlers : handlers } ; } 
function writeTop ( d , loc ) { if ( d . indexOf ( '\n' ) != - 1 ) { throw 'Can not write content having \\n' } this . chunks . unshift ( chunk ( d , loc ) ) } 
function updateIndent ( ) { var str = '' for ( var idx = 0 ; idx < this . indentLevel ; idx ++ ) { str += this . indentUnit } this . currentIndent = str } 
function parseOpts ( argv ) { var lastOpt , parsed , opts = { } argv . forEach ( function ( arg ) { parsed = rOption . exec ( arg ) if ( parsed ) { lastOpt = parsed [ 1 ] opts [ lastOpt ] = true return } opts [ lastOpt ] = arg } ) return opts } 
function run ( opts ) { throwIfRequiredOption ( opts , 'src' ) 
function _eval ( opts ) { throwIfRequiredOption ( opts , 'src' ) var src = opts [ 'src' ] 
function compile ( opts ) { var srcPath = opts [ 'src' ] || process . cwd ( ) var dstPath = opts [ 'dst' ] var format = opts [ 'format' ] || 'cjs' var toStdout = dstPath === 'stdout' var stat = fs . statSync ( srcPath ) if ( ! srcPath ) { srcPath = path . cwd ( ) } 
function compileFile ( srcPath , dstPath , format , toStdout ) { if ( ! fs . existsSync ( dstPath ) ) { makePath ( dstPath ) } fs . readFile ( srcPath , 'utf8' , function ( err , data ) { if ( err ) throw err var cwd = process . cwd ( ) var smapDstPath = dstPath + '.map' var smapSrcPath = path . relative ( path . dirname ( path . join ( cwd , dstPath ) ) , path . join ( cwd , srcPath ) ) var result = ram . compile ( data , { filename : srcPath , format : format , sourceMap : ! toStdout , sourceMapCfg : { source : smapSrcPath , sourceContent : data } } ) if ( toStdout ) { process . stdout . write ( result . js + '\n' ) return } if ( result . js ) { result . js = result . js + '\n//# sourceMappingURL=' + path . basename ( dstPath ) + '.map' fs . writeFile ( dstPath , result . js , 'utf8' , function ( err ) { if ( err ) throw err } ) } if ( result . sourceMap ) { fs . writeFile ( smapDstPath , result . sourceMap , 'utf8' , function ( err ) { if ( err ) throw err } ) } } ) } 
function makePath ( dirPath ) { dirPath = path . dirname ( dirPath ) . split ( path . sep ) dirPath . reduce ( function ( dirPath , p ) { dirPath = path . join ( dirPath , p ) if ( ! fs . existsSync ( dirPath ) ) { try { fs . mkdirSync ( dirPath ) } catch ( e ) { throw 'Could not make path ' + dirPath } } return dirPath } , '' ) } 
function readFromStdin ( cb ) { var chunks = [ ] var stdin = process . stdin stdin . resume ( ) stdin . setEncoding ( 'utf8' ) stdin . on ( 'data' , function ( chunk ) { chunks . push ( chunk ) } ) stdin . on ( 'end' , function ( ) { cb ( chunks . join ( ' ' ) ) } ) } 
function walk ( node , parent , ctx ) { if ( ! node ) { return } 
function isRIdent ( node ) { return node && node . type && node . type === T . IDENT && node . content === 'R' } 
function srcToChunks ( src , opts , ctx ) { opts = opts || { } var ast = parse ( src , opts ) 
function chunksToSourceMap ( chunks , cfg ) { var loc var outLine = 0 var outColumn = 0 var smap = sourcemap . newSourceMap ( ) var acc = '' chunks . forEach ( function ( chunk ) { if ( chunk . content === '\n' ) { outLine = outLine + 1 outColumn = 0 } loc = chunk . loc if ( loc ) { smap . add ( 
function parse ( src , opts ) { var parser = new Parser ( ) parser . yy = { parseError : util . parseError , filename : opts . filename } return parser . parse ( src ) } 
function walk ( node , parent , ctx ) { if ( ! node ) { return } node . parent = parent 
function writeCommonJSStub ( ast , ctx ) { 
function writeIIFEStub ( ctx ) { writeRamdaFunctionAsGlobalStub ( ctx ) ctx . writeTop ( ';(function () {' ) ctx . newLine ( ) ctx . newLine ( ) ctx . write ( '})()' ) } 
function writeRamdaFunctionAsGlobalStub ( ctx ) { ctx . newLineTop ( ) ctx . newLineTop ( ) Object . keys ( ctx . usedRamdaFns ) . forEach ( function ( key ) { ctx . newLineTop ( ) ctx . writeTop ( 'var ' + key + ' = R.' + key ) } ) } 
function forMethods ( obj , props , callback ) { var prop ; if ( typeof props === "string" ) { 
function crc16 ( octet_nums ) { var crc = octet_nums [ 0 ] ; for ( var b = 1 ; b < octet_nums . length ; b ++ ) { crc = _updcrc ( octet_nums [ b ] , crc ) ; } crc = _updcrc ( 0 , _updcrc ( 0 , crc ) ) ; 
function verify32 ( bytes_arr , crc ) { try { __verify ( this . crc32 ( bytes_arr ) , crc ) ; } catch ( err ) { err . input = bytes_arr . slice ( 0 ) ; throw err ; } } 
function ( hdr ) { 
function send_files ( session , files , options ) { if ( ! options ) options = { } ; 
function save_to_disk ( packets , name ) { var blob = new Blob ( packets ) ; var url = URL . createObjectURL ( blob ) ; var el = document . createElement ( "a" ) ; el . style . display = "none" ; el . href = url ; el . download = name ; document . body . appendChild ( el ) ; 
function offer_parameters ( params ) { if ( ! params . name ) { throw new Zmodem . Error ( "validation" , "Need “name”!"); } if ( typeof params . name !== "string" ) { throw new Zmodem . Error ( "validation" , "“name” (" + p r ms.nam e + " ust be a string!"); } 
function strip_ignored_bytes ( octets ) { for ( var o = octets . length - 1 ; o >= 0 ; o -- ) { switch ( octets [ o ] ) { case XON : case XON_HIGH : case XOFF : case XOFF_HIGH : octets . splice ( o , 1 ) ; continue ; } } return octets ; } 
function find_subarray ( haystack , needle ) { var h = 0 , n ; var start = Date . now ( ) ; HAYSTACK : while ( h !== - 1 ) { h = haystack . indexOf ( needle [ 0 ] , h ) ; if ( h === - 1 ) break HAYSTACK ; for ( n = 1 ; n < needle . length ; n ++ ) { if ( haystack [ h + n ] !== needle [ n ] ) { h ++ ; continue HAYSTACK ; } } return h ; } return - 1 ; } 
function registerAction ( resource ) { return client . sendCommand ( { id : Lime . Guid ( ) , method : Lime . CommandMethod . SET , type : 'application/vnd.iris.eventTrack+json' , uri : '/event-track' , resource : resource } ) . catch ( e => console . log ( e ) ) ; } 
function wrapIPv6Address ( host , port ) { if ( ! port ) { if ( host . indexOf ( '[' ) === 0 ) return host host = host . split ( ':' ) port = host [ 1 ] host = host [ 0 ] } return '[' + host + ']:' + port } 
function request ( snek ) { snek . options . body = snek . options . data ; const type = snek . options . responseType === 'arraybuffer' ? 'arrayBuffer' : 'text' ; return window . fetch ( snek . options . url , snek . options ) . then ( ( r ) => r [ type ] ( ) . then ( ( raw ) => { const headers = { } ; for ( const [ k , v ] of r . headers . entries ( ) ) { headers [ k . toLowerCase ( ) ] = v ; } return { raw , headers , statusCode : r . status , statusText : r . statusText , } ; } ) ) ; } 
function mimeOfBuffer ( input ) { const buf = new Uint8Array ( input ) ; if ( ! ( buf && buf . length > 1 ) ) return null ; if ( buf [ 0 ] === 0xFF && buf [ 1 ] === 0xD8 && buf [ 2 ] === 0xFF ) { return { ext : 'jpg' , mime : 'image/jpeg' , } ; } if ( buf [ 0 ] === 0x89 && buf [ 1 ] === 0x50 && buf [ 2 ] === 0x4E && buf [ 3 ] === 0x47 ) { return { ext : 'png' , mime : 'image/png' , } ; } if ( buf [ 0 ] === 0x47 && buf [ 1 ] === 0x49 && buf [ 2 ] === 0x46 ) { return { ext : 'gif' , mime : 'image/gif' , } ; } if ( buf [ 8 ] === 0x57 && buf [ 9 ] === 0x45 && buf [ 10 ] === 0x42 && buf [ 11 ] === 0x50 ) { return { ext : 'webp' , mime : 'image/webp' , } ; } if ( buf [ 0 ] === 0x46 && buf [ 1 ] === 0x4C && buf [ 2 ] === 0x49 && buf [ 3 ] === 0x46 ) { return { ext : 'flif' , mime : 'image/flif' , } ; } 
function parse_status_block ( block ) { var match ; var parsed = { } ; if ( ( match = block . match ( / bssid=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . bssid = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / freq=([0-9]+) / ) ) ) { parsed . frequency = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = block . match ( / mode=([^\s]+) / ) ) ) { parsed . mode = match [ 1 ] ; } if ( ( match = block . match ( / key_mgmt=([^\s]+) / ) ) ) { parsed . key_mgmt = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / [^b]ssid=([^\n]+) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = block . match ( / [^b]pairwise_cipher=([^\n]+) / ) ) ) { parsed . pairwise_cipher = match [ 1 ] ; } if ( ( match = block . match ( / [^b]group_cipher=([^\n]+) / ) ) ) { parsed . group_cipher = match [ 1 ] ; } if ( ( match = block . match ( / p2p_device_address=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . p2p_device_address = match [ 1 ] ; } if ( ( match = block . match ( / wpa_state=([^\s]+) / ) ) ) { parsed . wpa_state = match [ 1 ] ; } if ( ( match = block . match ( / ip_address=([^\n]+) / ) ) ) { parsed . ip = match [ 1 ] ; } if ( ( match = block . match ( / [^_]address=([A-Fa-f0-9:]{17}) / ) ) ) { parsed . mac = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / uuid=([^\n]+) / ) ) ) { parsed . uuid = match [ 1 ] ; } if ( ( match = block . match ( / [^s]id=([0-9]+) / ) ) ) { parsed . id = parseInt ( match [ 1 ] , 10 ) ; } return parsed ; } 
function parse_command_interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { var output = parse_command_block ( stdout . trim ( ) ) ; if ( output . result === 'FAIL' ) { callback ( new Error ( output . result ) ) ; } else { callback ( error , parse_command_block ( stdout . trim ( ) ) ) ; } } } ; } 
function parse_scan_results ( block ) { var match ; var results = [ ] ; var lines ; lines = block . split ( '\n' ) . map ( function ( item ) { return item + "\n" ; } ) ; lines . forEach ( function ( entry ) { var parsed = { } ; if ( ( match = entry . match ( / ([A-Fa-f0-9:]{17})\t / ) ) ) { parsed . bssid = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = entry . match ( / \t([\d]+)\t+ / ) ) ) { parsed . frequency = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = entry . match ( / ([-][0-9]+)\t / ) ) ) { parsed . signalLevel = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = entry . match ( / \t(\[.+\])\t / ) ) ) { parsed . flags = match [ 1 ] ; } if ( ( match = entry . match ( / \t([^\t]{1,32}(?=\n)) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ! ( Object . keys ( parsed ) . length === 0 && parsed . constructor === Object ) ) { results . push ( parsed ) ; } } ) ; return results ; } 
function parse_scan_results_interface ( callback ) { return function ( error , stdout , stderr ) { if ( error ) { callback ( error ) ; } else { callback ( error , parse_scan_results ( stdout . trim ( ) ) ) ; } } ; } 
function set ( interface , variable , value , callback ) { var command = [ 'wpa_cli -i' , interface , 'set' , variable , value ] . join ( ' ' ) ; return this . exec ( command , parse_command_interface ( callback ) ) ; } 
function parse_status_block ( block ) { var match ; var parsed = { interface : block . match ( / ^([^\s]+) / ) [ 1 ] } ; if ( ( match = block . match ( / Link encap:\s*([^\s]+) / ) ) ) { parsed . link = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / HWaddr\s+([^\s]+) / ) ) ) { parsed . address = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = block . match ( / inet6\s+addr:\s*([^\s]+) / ) ) ) { parsed . ipv6_address = match [ 1 ] ; } if ( ( match = block . match ( / inet\s+addr:\s*([^\s]+) / ) ) ) { parsed . ipv4_address = match [ 1 ] ; } if ( ( match = block . match ( / Bcast:\s*([^\s]+) / ) ) ) { parsed . ipv4_broadcast = match [ 1 ] ; } if ( ( match = block . match ( / Mask:\s*([^\s]+) / ) ) ) { parsed . ipv4_subnet_mask = match [ 1 ] ; } if ( ( match = block . match ( / UP / ) ) ) { parsed . up = true ; } if ( ( match = block . match ( / BROADCAST / ) ) ) { parsed . broadcast = true ; } if ( ( match = block . match ( / RUNNING / ) ) ) { parsed . running = true ; } if ( ( match = block . match ( / MULTICAST / ) ) ) { parsed . multicast = true ; } if ( ( match = block . match ( / LOOPBACK / ) ) ) { parsed . loopback = true ; } return parsed ; } 
function parse_status ( callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else callback ( error , stdout . trim ( ) . split ( '\n\n' ) . map ( parse_status_block ) ) ; } ; } 
function up ( options , callback ) { return this . exec ( 'ifconfig ' + options . interface + ' ' + options . ipv4_address + ' netmask ' + options . ipv4_subnet_mask + ' broadcast ' + options . ipv4_broadcast + ' up' , callback ) ; } 
function enable ( options , callback ) { var file = options . interface + '-wpa_supplicant.conf' ; var command = 'wpa_passphrase "' + options . ssid + '" "' + options . passphrase + '" > ' + file + ' && wpa_supplicant -i ' + options . interface + ' -B -D ' + options . driver + ' -c ' + file + ' && rm -f ' + file ; return this . exec ( command , callback ) ; } 
function manual ( options , callback ) { var command = [ 'wpa_supplicant' , '-i' , options . interface , '-s -B -P /run/wpa_supplicant/' + options . interface + '.pid' , '-D' , options . drivers . join ( ',' ) , '-C /run/wpa_supplicant' ] . join ( ' ' ) ; return this . exec ( command , callback ) ; } 
function expand_r ( options , lines , prefix ) { Object . getOwnPropertyNames ( options ) . forEach ( function ( key ) { var full = prefix . concat ( key ) ; var value = options [ key ] ; if ( Array . isArray ( value ) ) { value . forEach ( function ( val ) { lines . push ( full . concat ( val ) . join ( ' ' ) ) ; } ) ; } else if ( typeof ( value ) == 'object' ) { expand_r ( value , lines , full ) ; } else { lines . push ( full . concat ( value ) . join ( ' ' ) ) ; } } ) ; } 
function enable ( options , callback ) { var file = options . interface + '-udhcpd.conf' ; var commands = [ ] . concat ( 'cat <<EOF >' + file + ' && udhcpd ' + file + ' && rm -f ' + file , expand ( options ) ) ; return this . exec ( commands . join ( '\n' ) , callback ) ; } 
function parse_cell ( cell ) { var parsed = { } ; var match ; if ( ( match = cell . match ( / BSS ([0-9A-Fa-f:-]{17})\(on / ) ) ) { parsed . address = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = cell . match ( / freq: ([0-9]+) / ) ) ) { parsed . frequency = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / signal: (-?[0-9.]+) dBm / ) ) ) { parsed . signal = parseFloat ( match [ 1 ] ) ; } if ( ( match = cell . match ( / last seen: ([0-9]+) ms ago / ) ) ) { parsed . lastSeenMs = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / SSID: \\x00 / ) ) ) { delete parsed . ssid ; } else if ( ( match = cell . match ( / SSID: ([^\n]*) / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = cell . match ( / DS Parameter set: channel ([0-9]+) / ) ) ) { parsed . channel = parseInt ( match [ 1 ] , 10 ) ; } else if ( ( match = cell . match ( / \* primary channel: ([0-9]+) / ) ) ) { parsed . channel = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / RSN:[\s*]+Version: 1 / ) ) ) { parsed . security = 'wpa2' ; } else if ( ( match = cell . match ( / WPA:[\s*]+Version: 1 / ) ) ) { parsed . security = 'wpa' ; } else if ( ( match = cell . match ( / capability: ESS Privacy / ) ) ) { parsed . security = 'wep' ; } else if ( ( match = cell . match ( / capability: ESS / ) ) ) { parsed . security = 'open' ; } return parsed ; } 
function scan ( options , callback ) { var interface , show_hidden if ( typeof options === 'string' ) { var interface = options ; var show_hidden = false ; } else { var interface = options . iface ; var show_hidden = options . show_hidden || false ; } this . exec ( 'iw dev ' + interface + ' scan' , parse_scan ( show_hidden , callback ) ) ; } 
function parse_status_block ( block ) { var match ; 
function enable ( options , callback ) { var file = options . interface + '-hostapd.conf' ; var commands = [ 'cat <<EOF >' + file + ' && hostapd -B ' + file + ' && rm -f ' + file ] ; Object . getOwnPropertyNames ( options ) . forEach ( function ( key ) { commands . push ( key + '=' + options [ key ] ) ; } ) ; return this . exec ( commands . join ( '\n' ) , callback ) ; } 
function parse_cell ( cell ) { var parsed = { } ; var match ; if ( ( match = cell . match ( / Address\s*[:|=]\s*([A-Fa-f0-9:]{17}) / ) ) ) { parsed . address = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = cell . match ( / Channel\s*([0-9]+) / ) ) ) { parsed . channel = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / Frequency\s*[:|=]\s*([0-9\.]+)\s*GHz / ) ) ) { parsed . frequency = parseFloat ( match [ 1 ] ) ; } if ( ( match = cell . match ( / Mode\s*[:|=]\s*([^\s]+) / ) ) ) { parsed . mode = match [ 1 ] . toLowerCase ( ) ; } if ( ( match = cell . match ( / Quality\s*[:|=]\s*([0-9]+) / ) ) ) { parsed . quality = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / Signal level\s*[:|=]\s*(-?[0-9]+) / ) ) ) { parsed . signal = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / Noise level\s*[:|=]\s*(-?[0-9]+) / ) ) ) { parsed . noise = parseInt ( match [ 1 ] , 10 ) ; } if ( ( match = cell . match ( / ESSID\s*[:|=]\s*"([^"]+)" / ) ) ) { parsed . ssid = match [ 1 ] ; } if ( ( match = cell . match ( / WPA2\s+Version / ) ) ) { parsed . security = 'wpa2' ; } else if ( ( match = cell . match ( / WPA\s+Version / ) ) ) { parsed . security = 'wpa' ; } else if ( ( match = cell . match ( / Encryption key\s*[:|=]\s*on / ) ) ) { parsed . security = 'wep' ; } else if ( ( match = cell . match ( / Encryption key\s*[:|=]\s*off / ) ) ) { parsed . security = 'open' ; } return parsed ; } 
function parse_scan ( show_hidden , callback ) { return function ( error , stdout , stderr ) { if ( error ) callback ( error ) ; else if ( show_hidden ) { callback ( error , stdout . split ( / Cell [0-9]+ - / ) . map ( parse_cell ) . filter ( has_keys ) . sort ( by_signal ) ) ; } else { callback ( error , stdout . split ( / Cell [0-9]+ - / ) . map ( parse_cell ) . filter ( has_ssid ) . sort ( by_signal ) ) ; } } ; } 
function createItemContent ( cfg , item ) { var data = item . children || cfg . data ; var frag = document . createDocumentFragment ( ) ; var label = _ . el ( 'span' ) ; var iconPrepend = _ . el ( 'i' ) ; var iconAppend = _ . el ( 'i' ) ; var prependClasses = [ 'fa' ] ; var appendClasses = [ 'fa' ] ; 
function el ( element ) { var classes = [ ] ; var tag = element ; var el ; if ( isElement ( element ) ) { return element ; } classes = element . split ( '.' ) ; if ( classes . length > 1 ) { tag = classes [ 0 ] ; } el = document . createElement ( tag ) ; addClass ( el , classes . slice ( 1 ) ) ; return el ; } 
function closest ( element , test ) { var el = element ; while ( el ) { if ( test ( el ) ) { return el ; } el = el . parentNode ; } return null ; } 
function addClass ( element , className ) { var classNames = className ; function _addClass ( el , cn ) { if ( ! el . className ) { el . className = cn ; } else if ( ! hasClass ( el , cn ) ) { if ( el . classList ) { el . classList . add ( cn ) ; } else { el . className += ' ' + cn ; } } } if ( ! isArray ( className ) ) { classNames = className . trim ( ) . split ( / \s+ / ) ; } classNames . forEach ( _addClass . bind ( null , element ) ) ; return element ; } 
function removeClass ( element , className ) { var classNames = className ; function _removeClass ( el , cn ) { var classRegex ; if ( el . classList ) { el . classList . remove ( cn ) ; } else { classRegex = new RegExp ( '(?:^|\\s)' + cn + '(?!\\S)' , 'g' ) ; el . className = el . className . replace ( classRegex , '' ) . trim ( ) ; } } if ( ! isArray ( className ) ) { classNames = className . trim ( ) . split ( / \s+ / ) ; } classNames . forEach ( _removeClass . bind ( null , element ) ) ; return element ; } 
function hasClass ( element , className ) { if ( ! element || ! ( 'className' in element ) ) { return false ; } return element . className . split ( / \s+ / ) . indexOf ( className ) !== - 1 ; } 
function nextSiblings ( element ) { var next = element . nextSibling ; var siblings = [ ] ; while ( next ) { siblings . push ( next ) ; next = next . nextSibling ; } return siblings ; } 
function previousSiblings ( element ) { var prev = element . previousSibling ; var siblings = [ ] ; while ( prev ) { siblings . push ( prev ) ; prev = prev . previousSibling ; } return siblings ; } 
function uniqueCountryData ( data , type , parent ) { var hash = data . reduce ( function each ( prev , curr ) { if ( ! ( curr [ type ] in prev ) ) { if ( parent ) { if ( parent . label === curr [ parent . type ] ) { prev [ curr [ type ] ] = curr ; } } else if ( curr [ type ] ) { prev [ curr [ type ] ] = curr ; } } return prev ; } , { } ) ; return Object . keys ( hash ) . map ( function each ( item ) { return extend ( hash [ item ] , { label : item , type : type === 'name' ? 'country' : type } ) ; } ) ; } 
function includesFilterMatch ( text ) { if ( ! configuration_1 . Configuration . includesFilter || configuration_1 . Configuration . includesFilter . length === 0 ) return true ; if ( text === null || text === undefined ) return false ; return text . includes ( configuration_1 . Configuration . includesFilter ) ; } 
function preferredProviderFor ( uri ) { 
function providerExists ( uri ) { let providerOrigin = ( new URL ( uri ) ) . origin let providerConfigUri = providerOrigin + '/.well-known/openid-configuration' return fetch ( providerConfigUri , { method : 'HEAD' } ) . then ( result => { if ( result . ok ) { return providerOrigin } return null } ) } 
function discoverFromHeaders ( webId ) { return fetch ( webId , { method : 'OPTIONS' } ) . then ( response => { if ( response . ok ) { return parseProviderLink ( response . headers ) } return null } ) } 
function validateProviderUri ( provider , webId ) { if ( ! provider ) { let error = new Error ( ` ${ webId } ` ) error . statusCode = 400 throw error } if ( ! validUrl . isUri ( provider ) ) { let error = new Error ( ` ${ webId } ${ provider } ` ) error . statusCode = 400 throw error } } 
function authenticate ( authRequest ) { let debug = authRequest . host . debug || console . log . bind ( console ) let webId = authenticatedUser ( authRequest ) if ( webId ) { debug ( 'User is already authenticated as' , webId ) initSubjectClaim ( authRequest , webId ) } else { 
function ( el ) { var className = el . className var listClass = className . split ( ' ' ) this . classList = listClass this . el = el } 
function ( el ) { this . el = el if ( typeof el . classList !== 'undefined' ) { 
function ( obj , src ) { var result = false var key for ( key in obj ) { if ( obj . hasOwnProperty ( key ) && key === src ) result = true } return result } 
function ( v ) { var result = 0 var key for ( key in v ) { v . hasOwnProperty ( key ) && result ++ } return result } 
function ( el , check ) { var cls = el . classList var size = cls . length var result = false var i = 0 for ( i ; i < size ; i ++ ) { if ( cls [ i ] . toString ( ) === check ) result = true } return result } 
function ( v , search , val ) { var defined = Object . create ( null ) defined . is = false defined . count = 0 var length = v . length var i for ( i = 0 ; i < length ; i ++ ) { if ( isDefine ( v [ i ] [ search ] ) ) { if ( isDefine ( val ) && v [ i ] [ search ] === val ) { defined . is = true defined . count += 1 } } } return defined } 
function ( el , classid ) { createEl . enter = el var cElm_exits = createEl . $exits . length 
function ( el , classid ) { createEl . exit = el var cElm_enter = createEl . $enter . length 
function ( rw ) { var result var rgsize = createEl . register . length var i for ( i = 0 ; i < rgsize ; i ++ ) { if ( createEl . register [ i ] . rawName === rw ) result = createEl . register [ i ] . classid } return result } 
function ( css ) { css = css . split ( '-' ) var result = css [ 0 ] === 'float' ? 'cssFloat' : css [ 0 ] var size = css . length var i for ( i = 0 ; i < size ; i ++ ) { if ( i > 0 ) result += css [ i ] . charAt ( 0 ) . toUpperCase ( ) + css [ i ] . substr ( 1 ) } return result } 
function ( arg , classId , callback ) { var view = inView ( '.' + classId ) arg === 'on' ? view . on ( 'enter' , callback . enter ) . on ( 'exit' , callback . exit ) : arg === 'once' ? view . once ( 'enter' , callback . enter ) . once ( 'exit' , callback . exit ) : console . warn ( '[in-view] event handler not found' ) } 
function ( $m ) { var convert var key for ( key in $m ) { if ( $m . hasOwnProperty ( key ) && $m [ key ] === true ) { if ( isDefine ( convert ) ) convert += '.' + key else convert = key } } return convert } 
function ( arg ) { var result switch ( arg ) { case 'on' : result = arg break case 'once' : result = arg break case 'class' : result = arg break case 'style' : result = arg break case 'enter' : result = arg break case 'leave' : result = arg break case 'animate' : result = arg break case 'parent' : result = arg break default : console . warn ( '[in-view] argument ${arg} undefined' ) } return result } 
function ( bidd , callback ) { if ( ! isDefine ( bidd . arg ) ) callback ( ) if ( bidd . arg === 'on' || bidd . arg === 'once' && objLength ( bidd . modifiers ) === 0 ) callback ( ) } 
function ( clss , el ) { if ( isString ( clss ) ) classList ( el ) . add ( clss ) if ( isObject ( clss ) ) { var classArr = el . className . split ( ' ' ) var key for ( key in clss ) { if ( classArr . indexOf ( key ) && clss [ key ] === false ) classList ( el ) . remove ( key ) if ( clss . hasOwnProperty ( key ) && clss [ key ] === true ) classList ( el ) . add ( key ) } } if ( isArray ( clss ) ) { var i for ( i = 0 ; i < clss . length ; i ++ ) { classList ( el ) . add ( clss [ i ] ) } } } 
function ( css , el ) { var style = el . style if ( isObject ( css ) ) { var key for ( key in css ) { if ( isDefine ( style [ cssjs ( key ) ] ) ) style [ cssjs ( key ) ] = css [ key ] } } if ( isArray ( css ) ) { var size = css . length var i for ( i = 0 ; i < size ; i ++ ) { if ( isDefine ( style [ cssjs ( css [ i ] ) ] ) ) style [ cssjs ( css [ i ] ) ] = "" } } } 
function ( data ) { var inverse = [ [ 'In' , 'Out' ] , [ 'X' , 'Y' ] , [ 'Down' , 'Up' ] , [ 'Left' , 'Right' ] ] var i = 0 var size = inverse . length var result for ( i ; i < size ; i ++ ) { var index = inverse [ i ] if ( index . indexOf ( data ) >= 0 ) { var colm = index . indexOf ( data ) result = colm === 0 ? index [ 1 ] : index [ 0 ] } } return result } 
function ( an , type ) { var data = an var animate var result if ( / ^[a-z]+[A-Z][a-z]+$ / . test ( data ) ) { animate = data . match ( / ^([a-z]+)([A-Z][a-z]+)$ / ) if ( type === 'toggle' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) } } if ( / ^[a-z]+[A-Z][a-z]+[A-Z]$ / . test ( data ) ) { animate = data . match ( / ^([a-z]+)([A-Z][a-z]+)([A-Z])$ / ) if ( type === 'toggle' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type === 'toggle.inverse' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { var direct = isDefine ( animate_inverse ( animate [ 3 ] ) ) ? animate_inverse ( animate [ 3 ] ) : animate [ 3 ] result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + direct } } if ( / ^[a-z]+[A-Z][a-z]+[A-Z][a-z]+$ / . test ( data ) ) { animate = data . match ( / ^([a-z]+)([A-Z][a-z]+)([A-Z][a-z]+)$ / ) if ( type === 'toggle' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type === 'toggle.inverse' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { var direct = isDefine ( animate_inverse ( animate [ 3 ] ) ) ? animate_inverse ( animate [ 3 ] ) : animate [ 3 ] result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + direct } } if ( / ^[a-z]+[A-Z][a-z]+[A-Z][a-z]+[A-Z][a-z]+$ / . test ( data ) ) { animate = data . match ( / ^([a-z]+)([A-Z][a-z]+)([A-Z][a-z]+)([A-Z][a-z]+)$ / ) if ( type === 'toggle' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + animate [ 3 ] } if ( type === 'toggle.inverse' && isDefine ( animate_inverse ( animate [ 2 ] ) ) ) { var direct = isDefine ( animate_inverse ( animate [ 3 ] ) ) ? animate_inverse ( animate [ 3 ] ) : animate [ 3 ] + isDefine ( animate_inverse ( animate [ 4 ] ) ) ? animate_inverse ( animate [ 4 ] ) : animate [ 4 ] result = animate [ 1 ] + animate_inverse ( animate [ 2 ] ) + direct } } return result } 
function ( el , callback ) { var size = el . length var i = 0 for ( i ; i < size ; i ++ ) { callback ( el [ i ] , i ) } } 
function ( cls , el , mdf ) { var display = el . getAttribute ( 'animate-display' ) if ( display !== null ) { el . style . display = dispay } else { var none = el . getAttribute ( 'animate-display-none' ) if ( none === null || none !== 'false' ) { el . style . display = 'block' } } if ( isString ( cls ) ) { if ( isDefine ( mdf ) ) { var inverseAnim = animate_direction ( cls , mdf ) if ( isDefine ( inverseAnim ) && classList ( el ) . hasClass ( inverseAnim ) ) { var rmClass = { } rmClass [ inverseAnim ] = false object_class ( rmClass , el ) } } var hasToggling = false if ( classList ( el ) . hasClass ( cls ) ) { hasToggling = true var rmClass = { } rmClass [ cls ] = false object_class ( rmClass , el ) } if ( isDefine ( mdf ) && hasToggling ) { var inverseAnim = animate_direction ( cls , mdf ) if ( isDefine ( inverseAnim ) ) { object_class ( inverseAnim , el ) } } else { var animate = ! classList ( el ) . hasClass ( 'animated' ) ? [ 'animated' , cls ] : cls object_class ( animate , el ) } } if ( isArray ( cls ) ) { var i = 0 var size = cls . length var iClass var animate for ( i ; i < size ; i ++ ) { if ( classList ( el ) . hasClass ( cls [ i ] ) ) { var rmClass = { } rmClass [ cls [ i ] ] = false iClass = i object_class ( rmClass , el ) } } if ( isDefine ( mdf ) && mdf === 'toggle' ) { var getClass = isDefine ( iClass ) && size > 0 && ( iClass + 1 ) < size ? cls [ ( iClass + 1 ) ] : cls [ 0 ] animate = ! classList ( el ) . hasClass ( 'animated' ) ? [ 'animated' , getClass ] : getClass } else { animate = ! classList ( el ) . hasClass ( 'animated' ) ? cls . push ( 'animated' ) : cls } object_class ( animate , el ) } } 
function ( el ) { var normal = el . querySelectorAll ( '[animate]' ) var toggle = el . querySelectorAll ( '[animate-toggle]' ) var inverse = el . querySelectorAll ( '[animate-toggle-inverse]' ) if ( normal !== null ) element_looping ( normal , function ( els ) { var attr = els . getAttribute ( 'animate' ) object_animation ( attr , els ) } ) if ( toggle !== null ) element_looping ( toggle , function ( els ) { var attr = els . getAttribute ( 'animate-toggle' ) object_animation ( attr , els , 'toggle' ) } ) if ( inverse !== null ) element_looping ( inverse , function ( els ) { var attr = els . getAttribute ( 'animate-toggle-inverse' ) object_animation ( attr , els , 'toggle.inverse' ) } ) } 
function ( el , $bd ) { 
function ( el , att ) { var result = false if ( / ^\.[\w]+ / . test ( att ) ) { var className = att . match ( / ^\.([\w]+) / ) [ 1 ] var gClass = el . className . split ( ' ' ) if ( gClass . indexOf ( className ) > - 1 ) { result = true } } if ( / ^\#[\w]+ / . test ( att ) ) { var idName = att . match ( / ^\#([\w]+) / ) [ 1 ] if ( el . hasAttribute ( 'id' ) && el . getAttribute ( 'id' ) === idName ) result = true } if ( / ^\[[\w]+=\"[\w]+\"\]$ / . test ( att ) ) { var attr = att . match ( / ^\[([\w]+)=\"([\w]+)\"\]$ / ) var attName = attr [ 1 ] var attval = attr [ 2 ] if ( el . hasAttribute ( attName ) && el . getAttribute ( attName ) === attval ) result = true } if ( / ^\[[\w]+=\'[\w]+\'\]$ / . test ( att ) ) { var attr = att . match ( / ^\[([\w]+)=\'([\w]+)\'\]$ / ) var attName = attr [ 1 ] var attval = attr [ 2 ] if ( el . hasAttribute ( attName ) && el . getAttribute ( attName ) === attval ) result = true } return result } 
function ( $arg , $opt ) { var lastEnter = 0 var lastExit = 0 updateLifeCycle ( function ( ) { if ( isDefine ( $opt ) && isObject ( $opt ) && isString ( $arg ) ) { if ( countEntered > lastEnter ) { isDefine ( $opt . enter ) && hasAtt ( createEl . enter , $arg ) && $opt . enter ( createEl . enter ) lastEnter = countEntered } if ( countExits > lastExit ) { isDefine ( $opt . exit ) && hasAtt ( createEl . exit , $arg ) && $opt . exit ( createEl . exit ) lastExit = countExits } } } ) } 
function findWorkspaceRoot ( initial ) { if ( ! initial ) { initial = process . cwd ( ) ; } let previous = null ; let current = path . normalize ( initial ) ; do { const manifest = readPackageJSON ( current ) ; const workspaces = extractWorkspaces ( manifest ) ; if ( workspaces ) { const relativePath = path . relative ( current , initial ) ; if ( relativePath === '' || micromatch ( [ relativePath ] , workspaces ) . length > 0 ) { return current ; } else { return null ; } } previous = current ; current = path . dirname ( current ) ; } while ( current !== previous ) ; return null ; } 
function madgwickAHRSupdateIMU ( gx , gy , gz , ax , ay , az ) { let recipNorm ; let s0 , s1 , s2 , s3 ; let qDot1 , qDot2 , qDot3 , qDot4 ; let v2q0 , v2q1 , v2q2 , v2q3 , v4q0 , v4q1 , v4q2 , v8q1 , v8q2 , q0q0 , q1q1 , q2q2 , q3q3 ; 
function madgwickAHRSupdate ( gx , gy , gz , ax , ay , az , mx , my , mz , deltaTimeSec ) { recipSampleFreq = deltaTimeSec || recipSampleFreq ; let recipNorm ; let s0 , s1 , s2 , s3 ; let qDot1 , qDot2 , qDot3 , qDot4 ; let hx , hy ; let v2q0mx , v2q0my , v2q0mz , v2q1mx , v2bx , v2bz , v4bx , v4bz , v2q0 , v2q1 , v2q2 , v2q3 , v2q0q2 , v2q2q3 ; let q0q0 , q0q1 , q0q2 , q0q3 , q1q1 , q1q2 , q1q3 , q2q2 , q2q3 , q3q3 ; 
function mahonyAHRSupdateIMU ( gx , gy , gz , ax , ay , az ) { let recipNorm ; let halfvx , halfvy , halfvz ; let halfex , halfey , halfez ; 
function mahonyAHRSupdate ( gx , gy , gz , ax , ay , az , mx , my , mz , deltaTimeSec ) { recipSampleFreq = deltaTimeSec || recipSampleFreq ; let recipNorm ; let q0q0 , q0q1 , q0q2 , q0q3 , q1q1 , q1q2 , q1q3 , q2q2 , q2q3 , q3q3 ; let hx , hy , bx , bz ; let halfvx , halfvy , halfvz , halfwx , halfwy , halfwz ; let halfex , halfey , halfez ; 
function ( ) { var self = this ; console . log ( 'starting capture...' ) ; var req = get_req ( ) ; req . onreadystatechange = function start_capture_response ( ) { if ( req . readyState === 4 ) { if ( req . status == 200 ) { console . log ( 'started.' ) ; jQuery ( "#start" ) . hide ( ) ; jQuery ( "#stop" ) . show ( ) ; htracr . ui . pulse_logo ( ) ; } else { var error = eval ( "(" + req . responseText + ")" ) ; alert ( "Sorry, I can't start the sniffer; it says \"" + error . message + "\"." ) ; console . log ( "start problem: " + error ) ; } } } ; req . open ( "POST" , "/start" , true ) ; req . send ( "" ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'stopping capture...' ) ; var req = get_req ( ) ; req . onreadystatechange = function stop_capture_response ( ) { if ( req . readyState === 4 ) { self . update_state ( ) ; console . log ( 'stopped.' ) ; jQuery ( "#stop" ) . hide ( ) ; jQuery ( "#start" ) . show ( ) ; htracr . ui . unpulse_logo ( true ) ; } } ; req . open ( "POST" , "/stop" , true ) ; req . send ( "" ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'updating...' ) ; var req = get_req ( ) ; req . onreadystatechange = function update_state_response ( ) { if ( req . readyState === 4 ) { if ( req . status === 200 ) { var capture = JSON . parse ( req . responseText ) ; if ( capture . error ) { alert ( capture . error . message ) ; } htracr . ui . update ( capture ) ; console . log ( 'updated.' ) ; } else { console . log ( 'no updates.' ) ; } } } ; req . open ( "GET" , "/conns" , true ) ; req . send ( "" ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'clearing...' ) ; var req = get_req ( ) ; req . onreadystatechange = function clear_state_response ( ) { if ( req . readyState === 4 ) { htracr . ui . clear ( ) ; } } ; req . open ( "POST" , "/clear" , true ) ; req . send ( "" ) ; return false ; } 
function ( ) { var self = this ; console . log ( 'getting servers...' ) ; var req = get_req ( ) ; var server_names ; req . onreadystatechange = function get_servers_response ( ) { if ( req . readyState === 4 ) { server_names = JSON . parse ( req . responseText ) ; } } ; req . open ( "GET" , "/servers" , false ) ; req . send ( "" ) ; return server_names ; } 
function ( packet_id ) { var req = get_req ( ) ; var data ; req . onreadystatechange = function packet_fetch ( ) { if ( req . readyState === 4 && req . status === 200 ) { data = jQuery ( '<div/>' ) . text ( JSON . parse ( req . responseText ) . data ) . html ( ) ; } } ; 
function get_req ( ) { var self = this ; var req ; if ( window . XMLHttpRequest ) { try { req = new XMLHttpRequest ( ) ; } catch ( e1 ) { req = false ; } } else if ( window . ActiveXObject ) { try { req = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } catch ( e2 ) { req = false ; } } return req ; } 
function ( capture ) { var self = this ; self . clear ( ) ; self . capture = capture ; self . capture_idx = index_capture ( capture ) ; self . render ( ) ; } 
function ( ) { var self = this ; self . clear_ui ( ) ; self . resize ( ) ; self . draw_scale ( ) ; self . capture_idx . servers . forEach ( function ( bundle ) { var server_name = bundle [ 0 ] ; var conn_ids = bundle [ 1 ] ; var i ; self . y += self . server_pad ; self . draw_server_label ( server_name ) ; self . y += self . server_pad ; conn_ids . forEach ( function ( conn_id ) { var conn = self . capture . sessions [ server_name ] [ conn_id ] ; htracr . connection ( conn ) . draw ( di , [ server_name , conn_id , undefined , 0 ] ) ; i = 0 ; conn . http_reqs . forEach ( function ( http_req ) { var msg = htracr . http_msg ( http_req ) ; msg . kind = "req" ; msg . draw ( di , [ server_name , conn_id , 'http_reqs' , i ] ) ; i += 1 ; } ) ; i = 0 ; conn . http_ress . forEach ( function ( http_req ) { var msg = htracr . http_msg ( http_req ) ; msg . kind = "res" ; msg . draw ( di , [ server_name , conn_id , 'http_ress' , i ] ) ; i += 1 ; } ) ; i = 0 ; conn . packets . forEach ( function ( packet ) { var pkt = htracr . packet ( packet ) ; pkt . draw ( di , [ server_name , conn_id , 'packets' , i ] ) ; i += 1 ; } ) ; self . y += self . conn_pad ; } ) ; self . draw_referers ( ) ; self . draw_locations ( ) ; } ) ; } 
function ( ) { var self = this ; var idx = self . capture_idx ; self . w = ( ( idx . end - idx . start ) / 1000 * self . pix_per_sec ) + margin [ 1 ] + margin [ 3 ] ; self . h = margin [ 0 ] + margin [ 2 ] ; for ( var s in idx . servers ) { self . h += ( self . server_pad * 2 ) ; self . h += ( ( idx . servers [ s ] [ 1 ] . length ) * self . conn_pad ) ; } console . log ( "resizing to " + self . w + " x " + self . h ) ; paper . setSize ( self . w , self . h ) ; labels . setSize ( self . label_w , self . h ) ; } 
function ( ) { var self = this ; var start_x = time_x ( self . capture_idx . start ) ; var end_x = time_x ( self . capture_idx . end ) ; var end_y = self . h - margin [ 2 ] ; var end_attrs = { stroke : "#666" , "stroke-width" : "1" } ; var label_attrs = { fill : "white" , "font-size" : "16" , "opacity" : ".5" } ; paper . path ( "M" + start_x + "," + margin [ 0 ] + " " + "L" + start_x + "," + end_y ) . attr ( end_attrs ) ; var m ; if ( self . pix_per_sec <= 1000 ) { m = 1000 ; } else if ( self . pix_per_sec <= 2000 ) { m = 500 ; } else if ( self . pix_per_sec <= 3500 ) { m = 250 ; } else if ( self . pix_per_sec <= 5000 ) { m = 100 ; } else { m = 50 ; } for ( var i = self . capture_idx . start ; i < self . capture_idx . end ; i += m ) { var i_x = time_x ( i ) ; paper . path ( "M" + i_x + "," + margin [ 0 ] + " " + "L" + i_x + "," + end_y ) . attr ( { stroke : "#444" , "stroke-width" : "1" } ) ; paper . text ( i_x , end_y + 10 , ( ( i - self . capture_idx . start ) / 1000 ) + "s" ) . attr ( label_attrs ) ; paper . text ( i_x , margin [ 0 ] - 20 , ( ( i - self . capture_idx . start ) / 1000 ) + "s" ) . attr ( label_attrs ) ; } paper . path ( "M" + end_x + "," + margin [ 0 ] + " " + "L" + end_x + "," + end_y ) . attr ( end_attrs ) ; } 
function ( val ) { var self = this ; console . log ( "zooming to " + val + "..." ) ; self . pix_per_sec = val ; self . render ( ) ; } 
function ( start , end , y_adj , attrs ) { var start_x = time_x ( start ) || margin [ 3 ] ; var end_x = time_x ( end ) || ui . w - margin [ 1 ] ; var y = ui . y + y_adj ; var e = paper . path ( "M" + start_x + "," + y + " " + "L" + end_x + "," + y ) . attr ( attrs || { } ) ; return e ; } 
function ( when , len , attrs ) { var x = time_x ( when ) ; var end_y = ui . y + len ; var e = paper . path ( "M" + x + "," + ui . y + " " + "L" + x + "," + end_y ) . attr ( attrs || { } ) ; return e ; } 
function ( name , value , cursor , single ) { if ( value ) { if ( ! htracr . ui . urls [ name ] ) { ui . urls [ name ] = { } ; } if ( single === true ) { ui . urls [ name ] [ value ] = cursor ; } else { if ( ! ui . urls [ name ] [ value ] ) { ui . urls [ name ] [ value ] = [ ] ; } ui . urls [ name ] [ value ] . push ( cursor ) ; } } } 
function time_x ( t ) { var self = this ; if ( t === null ) { return null ; } var delta = t - ui . capture_idx . start ; if ( delta < 0 ) { console . log ( 'Negative delta for time ' + t ) ; } var pix = delta * ui . pix_per_sec / 1000 ; var x = margin [ 3 ] + pix ; return x ; } 
function index_capture ( capture ) { function server_sortfunc ( a , b ) { return capture . sessions [ a [ 0 ] ] [ a [ 1 ] [ a [ 1 ] . length - 1 ] ] . start - capture . sessions [ b [ 0 ] ] [ b [ 1 ] [ b [ 1 ] . length - 1 ] ] } function conn_sortfunc ( a , b ) { return a . start - b . start ; } var servers = [ ] ; var start ; var end ; for ( var server_id in capture . sessions ) { if ( capture . sessions . hasOwnProperty ( server_id ) ) { var conns = [ ] ; for ( var conn_id in capture . sessions [ server_id ] ) { if ( capture . sessions [ server_id ] . hasOwnProperty ( conn_id ) ) { var conn = capture . sessions [ server_id ] [ conn_id ] ; if ( conn . http_reqs . length ) { conns . push ( conn ) ; } } } conns . sort ( conn_sortfunc ) ; var conn_ids = [ ] ; conns . forEach ( function ( conn ) { conn_ids . push ( conn . local_port ) ; } ) if ( conn_ids . length ) { if ( ! start || conns [ 0 ] . start < start ) { start = conns [ 0 ] . start || capture . start ; } if ( ! end || conns [ conns . length - 1 ] . end > end ) { end = conns [ conns . length - 1 ] . end || capture . end ; } servers . push ( [ server_id , conn_ids ] ) ; } } } servers . sort ( server_sortfunc ) ; return { start : start , end : end , servers : servers } ; } 
function wmic ( callback ) { var args = [ 'PROCESS' , 'get' , 'ParentProcessId,ProcessId' ] ; var options = { windowsHide : true , windowsVerbatimArguments : true } ; bin ( 'wmic' , args , options , function ( err , stdout , code ) { if ( err ) { callback ( err ) ; return ; } if ( code !== 0 ) { callback ( new Error ( 'pidtree wmic command exited with code ' + code ) ) ; return ; } 
function list ( PID , options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = { } ; } if ( typeof options !== 'object' ) { options = { } ; } PID = parseInt ( PID , 10 ) ; if ( isNaN ( PID ) || PID < - 1 ) { callback ( new TypeError ( 'The pid provided is invalid' ) ) ; return ; } getAll ( function ( err , list ) { if ( err ) { callback ( err ) ; return ; } 
function list ( pid , options , callback ) { if ( typeof options === 'function' ) { callback = options ; options = undefined ; } if ( typeof callback === 'function' ) { pidtree ( pid , options , callback ) ; return ; } return pify ( pidtree , pid , options ) ; } 
function get ( callback ) { if ( file === undefined ) { callback ( new Error ( os . platform ( ) + ' is not supported yet, please open an issue (https://github.com/simonepri/pidtree)' ) ) ; } var list = require ( './' + file ) ; list ( callback ) ; } 
function run ( cmd , args , options , done ) { if ( typeof options === 'function' ) { done = options ; options = undefined ; } var executed = false ; var ch = spawn ( cmd , args , options ) ; var stdout = '' ; var stderr = '' ; ch . stdout . on ( 'data' , function ( d ) { stdout += d . toString ( ) ; } ) ; ch . stderr . on ( 'data' , function ( d ) { stderr += d . toString ( ) ; } ) ; ch . on ( 'error' , function ( err ) { if ( executed ) return ; executed = true ; done ( new Error ( err ) ) ; } ) ; ch . on ( 'close' , function ( code ) { if ( executed ) return ; executed = true ; if ( stderr ) { return done ( new Error ( stderr ) ) ; } done ( null , stdout , code ) ; } ) ; } 
function ps ( callback ) { var args = [ '-A' , '-o' , 'ppid,pid' ] ; bin ( 'ps' , args , function ( err , stdout , code ) { if ( err ) return callback ( err ) ; if ( code !== 0 ) { return callback ( new Error ( 'pidtree ps command exited with code ' + code ) ) ; } 
function regNewModel ( name , schema , opts ) { var model = MRModel . apply ( moonridgeSingleton , arguments ) models [ name ] = model return model } 
function bootstrap ( ) { var server = RPC . apply ( null , arguments ) var io = server . io var allQueries = [ ] Object . keys ( models ) . forEach ( function ( modelName ) { var model = models [ modelName ] model . _exposeCallback ( server ) } ) io . use ( function ( socket , next ) { const registeredLQs = { } socket . moonridge = { registeredLQs : registeredLQs , user : { privilege_level : 0 } } 
function ( socket ) { if ( this . listeners [ socket . id ] ) { delete this . listeners [ socket . id ] if ( Object . keys ( this . listeners ) . length === 0 ) { this . destroy ( ) 
function modelInstance ( data ) { var self = this ; 
function Parser ( input ) { var o = ( this !== exports ) ? this : { } ; o . input = input ; o . pos = 0 ; o . line = 1 ; o . linePos = 0 ; } 
function ( assemble , next ) { grunt . verbose . writeln ( 'Validating options' ) ; if ( utils . endsWithDot ( assemble . options . ext ) ) { grunt . warn ( 'Invalid ext "' + assemble . options . ext + '". ext cannot end with a period.' ) ; done ( false ) ; } 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling default layout' . cyan ) ; 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling partials' . cyan ) ; 
function ( assemble , next ) { grunt . verbose . writeln ( 'Assembling data' . cyan ) ; 
function ( buildDone ) { 
function ( assemble , next ) { grunt . verbose . writeln ( ( '\n' + 'Assembling pages...' ) . yellow ) ; async . forEach ( assemble . options . pages . slice ( ) , function ( page , done ) { grunt . verbose . writeln ( require ( 'util' ) . inspect ( page ) ) ; build ( page , assemble , function ( err , result ) { grunt . log . write ( 'Assembling ' + ( page . dest ) . cyan + ' ' ) ; if ( err ) { grunt . verbose . write ( ' ' ) ; grunt . log . error ( ) ; grunt . warn ( err ) ; done ( false ) ; return ; } 
function ( currentPage , assemble , callback ) { var options = assemble . options ; grunt . verbose . writeln ( 'Currentpage: ' + currentPage ) ; var pageContext = currentPage . data ; var layout = _ . cloneDeep ( options . defaultLayout ) ; var data = options . data ; var pages = options . pages ; var collections = options . collections ; var context = { } ; grunt . verbose . writeln ( 'Variables loaded' ) ; try { 
function ( grunt , context , data ) { var currentGruntConfigData = grunt . config . data ; grunt . config . data = _ . extend ( { } , grunt . config . data , context , data ) ; var processed = grunt . config . process ( data || context ) ; grunt . config . data = currentGruntConfigData ; return processed ; } 
function ( src , assemble , callback ) { var layoutStack = [ ] ; var layoutName = 'layout' ; var defaultLayout = assemble . engine . startDelimiter + ' body ' + assemble . engine . endDelimiter ; 
function reduceSourceWithRule ( source , rule , condition ) { if ( rule ) { if ( condition && source . condition !== condition ) { 
function install ( Vue , options ) { var type = Object . prototype . toString . call ( options ) ; if ( type === '[object String]' ) { Vue . component ( options , feather ) ; } else if ( type === '[object Object]' ) { if ( options . props ) { if ( options . props . baseClass ) { feather . props . baseClass = options . props . baseClass ; } if ( options . props . classPrefix ) { feather . props . classPrefix = options . props . classPrefix ; } } feather . mixins = [ options ] ; Vue . component ( options . name || 'icon' , feather ) ; } else { Vue . component ( 'icon' , feather ) ; } } 
function crossBrowser ( property , value , prefix ) { function ucase ( string ) { return string . charAt ( 0 ) . toUpperCase ( ) + string . slice ( 1 ) ; } var vendor = [ 'webkit' , 'moz' , 'ms' , 'o' ] , properties = { } ; for ( var i = 0 ; i < vendor . length ; i ++ ) { if ( prefix ) { value = value . replace ( prefix , '-' + vendor [ i ] + '-' + prefix ) ; } properties [ ucase ( vendor [ i ] ) + ucase ( property ) ] = value ; } properties [ property ] = value ; return properties ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; var userargs = JSON . parse ( decodeURIComponent ( args [ "userargs" ] ) ) ; result . ok ( screenshotJNEXT . hello ( { userargs : userargs } ) ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; resultObjs [ result . callbackId ] = result ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; vibration . getInstance ( ) . vibration_request ( result . callbackId , args ) ; result . noResult ( true ) ; } 
function ( success , fail , args ) { var userargs = JSON . parse ( decodeURIComponent ( args [ "userargs" ] ) ) ; success ( template . getInstance ( ) . hello ( { userargs : userargs } ) ) ; } 
function ( success , fail , args ) { 
function ( success , fail , args ) { args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; success ( gseCrypto . getInstance ( ) . hash ( args ) ) ; } 
function Template ( dispatch ) { // // Properties (GET/SET): // this . constructor . prototype . __defineGetter__ ( "bool" , dispatch . getBoolean ) ; this . constructor . prototype . __defineSetter__ ( "bool" , dispatch . setBoolean ) ; this . constructor . prototype . __defineGetter__ ( "string" , dispatch . getString ) ; this . constructor . prototype . __defineSetter__ ( "string" , dispatch . setString ) ; this . constructor . prototype . __defineGetter__ ( "integer" , dispatch . getInteger ) ; this . constructor . prototype . __defineSetter__ ( "integer" , dispatch . setInteger ) ; // // Functions: // this . constructor . prototype . add = function ( first , second ) { return dispatch . add ( first , second ) ; } ; this . constructor . prototype . log = function ( msg ) { return dispatch . log ( msg ) ; } ; // // Callbacks: // this . constructor . prototype . onEvent = function ( callback ) { return dispatch . onEvent ( callback ) ; } ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; var values = { value : args } ; result . ok ( curljs . getInstance ( ) . get ( result . callbackId , values ) , false ) ; } 
function Clipboard ( dispatch ) { // // Functions: // this . constructor . prototype . setText = function ( value ) { return dispatch . setText ( value ) ; } ; this . constructor . prototype . getText = function ( ) { return dispatch . getText ( ) ; } ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( screenDisplay . getInstance ( ) . sdgetsize ( ) , false ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; resultObjs [ result . callbackId ] = result ; readCallback = result . callbackId ; var views = qnx . webplatform . getWebViews ( ) ; var handle = null ; var group = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i ++ ) { if ( views [ i ] . visible && views [ i ] . zOrder > z ) { z = views [ i ] . zOrder ; group = views [ i ] . windowGroup ; handle = views [ i ] . jsScreenWindowHandle ; } } if ( handle !== null ) { var values = { group : group , handle : handle } ; result . ok ( barcodescanner . getInstance ( ) . startRead ( result . callbackId , values ) , true ) ; } else { result . error ( "Failed to find window handle" , false ) ; } } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( passwordCrypto . getInstance ( ) . ping ( ) , false ) ; } 
function ( ) { if ( cordova . plugins && cordova . plugins . simplexpbeacon ) { cordova . plugins . simplexpbeacon . pluginVersion ( function ( data ) { console . log ( 'XXXX DATA: ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Plugin Version: ' + json . plugin_version ) ; } else { app . logMessage ( 'Failed to get Plugin Version: ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . initialiseBluetooth ( function ( data ) { console . log ( 'XXXX DATA: ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Bluetooth initialised' ) ; bluetoothInitialised = true ; } else { app . logMessage ( 'Bluetooth failed to initialise: ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . addBeaconUuidToMonitor ( "8AEFB031-6C32-486F-825B-E26FA193487D" , function ( data ) { console . log ( 'XXXX DATA: ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Beacon added' ) ; bluetoothInitialised = true ; } else { app . logMessage ( 'Failed to add beacon: ' + json . desc ) ; } } ) ; } else { app . logMessage ( 'SimplexpXpBeaconPlugin was not found' ) ; } } 
function ( ) { cordova . plugins . simplexpbeacon . removeBeaconUuidToMonitor ( "8AEFB031-6C32-486F-825B-E26FA193487D" , function ( data ) { console . log ( 'XXXX DATA: ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Beacon removed' ) ; bluetoothInitialised = true ; } else { app . logMessage ( 'Failed to remove beacon: ' + json . desc ) ; } } ) ; cordova . plugins . simplexpbeacon . terminateBluetooth ( function ( data ) { console . log ( 'XXXX DATA: ' + data ) ; var json = JSON . parse ( data ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Bluetooth terminated' ) ; } else { app . logMessage ( 'Bluetooth failed to terminated: ' + json . desc ) ; } bluetoothInitialised = false ; } ) ; } 
function ( ) { $ ( "#btnStartMonitor" ) . click ( app . startMonitorMode ) ; $ ( "#btnStopMonitor" ) . click ( app . stopMonitorMode ) ; $ ( document ) . one ( "mobileinit" , function ( ) { app . receivedEvent ( 'deviceready' ) ; } ) ; $ . getScript ( 'js/jquery.mobile-1.4.4.min.js' ) ; } 
function ( id ) { console . log ( 'XXXX Received Event: ' + id ) ; $ ( "#btnStartMonitor" ) . prop ( 'disabled' , false ) ; $ ( "#btnStopMonitor" ) . prop ( 'disabled' , true ) ; btLeHandler . initialise ( ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( gseCrypto . getInstance ( ) . hash ( result . callbackId , args ) , false ) ; } 
function ( success , fail , args ) { args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; // look for the UIWebView in the set of WebViews. var views = qnx . webplatform . getWebViews ( ) ; var handle = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i ++ ) { if ( views [ i ] . visible && views [ i ] . zOrder > z ) { z = views [ i ] . zOrder ; handle = views [ i ] . jsScreenWindowHandle ; } } if ( handle !== null ) { var values = { value : args , handle : handle } ; success ( preventsleep . getInstance ( ) . setPreventSleep ( values ) ) ; } else { success ( "Unable to get window handle" ) ; } } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( led . getInstance ( ) . startLed ( args ) , false ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( simpleBtSppPlugin . getInstance ( ) . initialiseBluetooth ( ) , false ) ; } 
function setText ( text ) { var textDiv = document . getElementById ( "smartPosterDisplay_Text" ) ; clearKids ( textDiv ) ; textDiv . appendChild ( document . createTextNode ( text ) ) ; } 
function ( success , fail , args ) { args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; vibration . getInstance ( ) . vibration_request ( args ) ; success ( ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; var values = { value : args } ; result . ok ( clipboardjs . getInstance ( ) . setText ( result . callbackId , values ) , false ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; var views = qnx . webplatform . getWebViews ( ) ; var handle = null ; var z = - 1 ; for ( var i = 0 ; i < views . length ; i ++ ) { if ( views [ i ] . visible && views [ i ] . zOrder > z ) { z = views [ i ] . zOrder ; handle = views [ i ] . jsScreenWindowHandle ; } } if ( handle !== null ) { var values = { value : args , handle : handle } ; result . ok ( preventSleep . getInstance ( ) . setPreventSleep ( result . callbackId , values ) , false ) ; } else { result . error ( "Unable to get window handle" , false ) ; } } 
function katSHA ( ) { var which = Array ( "raw" , "hex" , "b64" ) ; var testVectors = katSHAvector ; var message = "" ; message += "<h2>SHA KAT</h2>" ; message += "<table>" ; for ( var i = 0 ; i < testVectors . length ; ++ i ) { var suite = testVectors [ i ] ; for ( var j = 0 ; j < which . length ; ++ j ) { var encoding = which [ j ] ; var toHash = suite [ encoding ] ; var params = { input : { } } ; params . input [ encoding ] = toHash ; var results = suite . results ; for ( var k = 0 ; k < results . length ; ++ k ) { var kat = results [ k ] ; var alg = kat . alg ; params . alg = alg ; var live = community . gseCrypto . hash ( params ) . output ; var match = kat . hex == live . hex ; message += ( "<tr>" ) ; message += ( "<td class='" + ( match ? "pass" : "fail" ) + "'>" + match + "</td>" ) ; match = kat . b64 == live . b64 ; message += ( "<td class='" + ( match ? "pass" : "fail" ) + "'>" + match + "</td>" ) ; message += ( "<td>" + JSON . stringify ( params ) + "</td>" ) ; message += ( "<td>" + kat . hex + "<br />" + live . hex + "</td>" ) ; message += ( "<td>" + kat . b64 + "<br />" + live . b64 + "</td>" ) ; message += ( "</tr>" ) ; } } } message += ( "</table>" ) ; log ( message ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; if ( ! initialiseBluetoothCallbackId ) { initialiseBluetoothCallbackId = result . callbackId ; resultObjs [ result . callbackId ] = result ; result . ok ( simpleXpBeaconPlugin . getInstance ( ) . initialiseBluetooth ( result . callbackId ) , true ) ; } else { result . error ( "Initialise Bluetooth failure" , false ) ; } } 
function ( ) { if ( com && com . blackberry . community . simplebeaconplugin ) { console . log ( 'XXXX Plugin Version is: ' + com . blackberry . community . simplebeaconplugin . pluginVersion ( ) ) ; var json = JSON . parse ( com . blackberry . community . simplebeaconplugin . initialiseBluetooth ( ) ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Bluetooth initialised' ) ; bluetoothInitialised = true ; } else { app . logMessage ( 'Bluetooth failed to initialise: ' + json . desc ) ; } } else { app . logMessage ( 'SimpleBeaconPlugin was not found' ) ; } } 
function ( ) { var json = JSON . parse ( com . blackberry . community . simplebeaconplugin . terminateBluetooth ( ) ) ; console . log ( 'XXXX json.status: ' + json . status ) ; if ( json . status === 'OK' ) { app . logMessage ( 'Bluetooth terminated' ) ; } else { app . logMessage ( 'Bluetooth failed to terminated: ' + json . desc ) ; } bluetoothInitialised = false ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; result . ok ( audiorec . getInstance ( ) . record ( ) , false ) ; } 
function makeGetCall ( method ) { var recall = new blackberry . transport . RemoteFunctionCall ( TEMPLATE_EXTENSION_URL + "/" + method ) ; //return recall.makeSyncCall(); recall . makeSyncCall ( ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( mongoose . getInstance ( ) . start ( args ) , false ) ; } 
function katAES ( ) { var plainText = katAESCBCvector . plainText ; var vectors = katAESCBCvector . vectors ; var message = "<table><tbody>" ; for ( var i = 0 ; i < vectors . length ; ++ i ) { var vector = vectors [ i ] ; var params = { alg : "aes" , mode : "cbc" , key : { hex : vector . key } , iv : { hex : vector . iv } , input : { hex : vector . result } } ; var result = community . gseCrypto . decrypt ( params ) ; if ( result . error ) { alert ( result . error ) ; } else { var match = result . output . hex == plainText ; var matchText = match ? "pass" : "fail" ; message += "<tr><td class='" ; message += matchText ; message += "'>" ; message += matchText ; message += "</td><td>" ; message += result . output . hex ; message += "</td></tr>" ; } } log ( message ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( emailSender . getInstance ( ) . sendEmail ( result . callbackId , args ) , false ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) ; args = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; result . ok ( uPnP . getInstance ( ) . discover ( result . callbackId , args ) , false ) ; } 
function ( e ) { var target = getTarget ( e ) ; if ( ! target ) return ; e . preventDefault ( ) ; PUSH ( { url : target . href , hash : target . hash , timeout : target . getAttribute ( 'data-timeout' ) , transition : target . getAttribute ( 'data-transition' ) } ) ; } 
function ( options ) { var key ; var data = { } ; var xhr = PUSH . xhr ; options . container = options . container || options . transition ? document . querySelector ( '.content' ) : document . body ; for ( key in bars ) { options [ key ] = options [ key ] || document . querySelector ( bars [ key ] ) ; } if ( xhr && xhr . readyState < 4 ) { xhr . onreadystatechange = noop ; xhr . abort ( ) } xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , options . url , true ) ; xhr . setRequestHeader ( 'X-PUSH' , 'true' ) ; xhr . onreadystatechange = function ( ) { if ( options . _timeout ) clearTimeout ( options . _timeout ) ; if ( xhr . readyState == 4 ) xhr . status == 200 ? success ( xhr , options ) : failure ( options . url ) ; } ; if ( ! PUSH . id ) { cacheReplace ( { id : + new Date , url : window . location . href , title : document . title , timeout : options . timeout , transition : null } ) ; } if ( options . timeout ) { options . _timeout = setTimeout ( function ( ) { xhr . abort ( 'timeout' ) ; } , options . timeout ) ; } xhr . send ( ) ; if ( xhr . readyState && ! options . ignorePush ) cachePush ( ) ; } 
function ( xhr , options ) { var key ; var barElement ; var data = parseXHR ( xhr , options ) ; if ( ! data . contents ) return locationReplace ( options . url ) ; if ( data . title ) document . title = data . title ; if ( options . transition ) { for ( key in bars ) { barElement = document . querySelector ( bars [ key ] ) if ( data [ key ] ) swapContent ( data [ key ] , barElement ) ; else if ( barElement ) barElement . parentNode . removeChild ( barElement ) ; } } swapContent ( data . contents , options . container , options . transition , function ( ) { cacheReplace ( { id : options . id || + new Date , url : data . url , title : data . title , timeout : options . timeout , transition : options . transition } , options . id ) ; triggerStateChange ( ) ; } ) ; if ( ! options . ignorePush && window . _gaq ) _gaq . push ( [ '_trackPageview' ] ) 
function ( swap , container , transition , complete ) { var enter ; var containerDirection ; var swapDirection ; if ( ! transition ) { if ( container ) container . innerHTML = swap . innerHTML ; else if ( swap . classList . contains ( 'content' ) ) document . body . appendChild ( swap ) ; else document . body . insertBefore ( swap , document . querySelector ( '.content' ) ) ; } else { enter = / in$ / . test ( transition ) ; if ( transition == 'fade' ) { container . classList . add ( 'in' ) ; container . classList . add ( 'fade' ) ; swap . classList . add ( 'fade' ) ; } if ( / slide / . test ( transition ) ) { swap . classList . add ( enter ? 'right' : 'left' ) ; swap . classList . add ( 'slide' ) ; container . classList . add ( 'slide' ) ; } container . parentNode . insertBefore ( swap , container ) ; } if ( ! transition ) complete && complete ( ) ; if ( transition == 'fade' ) { container . offsetWidth ; 
function ( success , fail , args , env ) { if ( ! processing ) { processing = true ; var result = new PluginResult ( args , env ) ; resultObjs [ result . callbackId ] = result ; var value ; if ( args && args [ "input" ] ) { value = JSON . parse ( decodeURIComponent ( args [ "input" ] ) ) ; audioMetaData . getInstance ( ) . audioMetaDataGetMetaData ( result . callbackId , value ) ; result . noResult ( true ) ; } } } 
function merge ( ) { var k , obj var res = { } var objs = Array . prototype . slice . call ( arguments ) for ( var i = 0 , l = objs . length ; i < l ; i ++ ) { obj = objs [ i ] for ( k in obj ) { if ( obj . hasOwnProperty ( k ) ) { res [ k ] = obj [ k ] } } } return res } 
function parse_tag ( str , parsers ) { if ( typeof str !== 'string' || str [ 0 ] !== '@' ) { return null } var data = parsers . reduce ( function ( state , parser ) { var result try { result = parser ( state . source , merge ( { } , state . data ) ) } catch ( err ) { state . data . errors = ( state . data . errors || [ ] ) . concat ( parser . name + ': ' + err . message ) } if ( result ) { state . source = state . source . slice ( result . source . length ) state . data = merge ( state . data , result . data ) } return state } , { source : str , data : { } } ) . data data . optional = ! ! data . optional data . type = data . type === undefined ? '' : data . type data . name = data . name === undefined ? '' : data . name data . description = data . description === undefined ? '' : data . description return data } 
function parse_block ( source , opts ) { var trim = opts . trim ? function trim ( s ) { return s . trim ( ) } : function trim ( s ) { return s } var source_str = source . map ( function ( line ) { return trim ( line . source ) } ) . join ( '\n' ) source_str = trim ( source_str ) var start = source [ 0 ] . number 
function mkextract ( opts ) { var chunk = null var indent = 0 var number = 0 opts = merge ( { } , { trim : true , dotted_names : false , parsers : [ PARSERS . parse_tag , PARSERS . parse_type , PARSERS . parse_name , PARSERS . parse_description ] } , opts || { } ) return function extract ( line ) { var result = null var startPos = line . indexOf ( MARKER_START ) var endPos = line . indexOf ( MARKER_END ) 
function Parser ( opts ) { opts = opts || { } stream . Transform . call ( this , { objectMode : true } ) this . _extract = parse . mkextract ( opts ) } 
function tokenize ( content ) { var tokens = [ ] ; var parser = new htmlparser . Parser ( { onopentag : function ( name , attribs ) { } , ontext : function ( text ) { var start = parser . startIndex ; tokens . push ( { value : text , index : start , offset : text . length } ) ; } , onclosetag : function ( tagname ) { } } ) ; parser . write ( content ) ; parser . end ( ) ; return tokens ; } 
function tokenizeDefine ( infos ) { return tokenize . split ( function ( text , tok ) { var _infos = _ . isFunction ( infos ) ? infos . apply ( null , arguments ) : _ . clone ( infos ) ; if ( ! _infos ) return null ; 
function tokenizeCheck ( ) { var fn = tokenize . serie . apply ( tokenize , arguments ) ; return function ( text , opts , callback ) { try { callback ( null , fn ( text , opts ) ) ; } catch ( err ) { callback ( err ) ; } } ; } 
function parseFile ( input ) { fileContent = fs . readFileSync ( input , { encoding : "utf-8" } ) ; var ext = path . extname ( input ) ; if ( ext == '.html' ) return tokenizeHTML ( fileContent ) ; return fileContent ; } 
function softReplace ( contentBlock , nativeString , localizedString ) { var escapedString = ignoreExtraSpaces ( ignoreEmptyAttrs ( utils . escapeRegExpSpecialChars ( nativeString ) ) ) ; var regex = new RegExp ( '([>"\']\\s*)(' + escapedString + ')(\\s*[<"\'])' , 'g' ) ; return contentBlock . replace ( regex , '$1' + localizedString + '$3' ) ; } 
function ignoreExtraSpaces ( string ) { return string . replace ( / (\s+) / g , '\\s+' ) . replace ( / (<\\\/) / g , '<\/\\s*' ) . replace ( / (<) / g , '<\\s*' ) . replace ( / (>) / g , '\\s*>' ) ; } 
function generateNonce ( length ) { return generateSecureRandom ( length ) . then ( ( nonce ) => { const nonceString = base64js . fromByteArray ( nonce ) ; return nonceString ; } ) ; } 
function _isEqualArray ( a , b ) { if ( a === b ) { return true ; } if ( ( a === undefined ) || ( b === undefined ) ) { return false ; } var i = a . length ; if ( i !== b . length ) { return false ; } while ( i -- ) { if ( a [ i ] !== b [ i ] ) { return false ; } } return true ; } 
function _destroyNode ( node ) { 
function _contextGetCreateAndOrderNodes ( renderNode , prev ) { 
function _contextNext ( ) { 
function _contextPrev ( ) { 
function _contextGet ( contextNodeOrId ) { if ( this . _nodesById && ( ( contextNodeOrId instanceof String ) || ( typeof contextNodeOrId === 'string' ) ) ) { var renderNode = this . _nodesById [ contextNodeOrId ] ; if ( ! renderNode ) { return undefined ; } 
function _contextSet ( contextNodeOrId , set ) { var contextNode = this . _nodesById ? _contextGet . call ( this , contextNodeOrId ) : contextNodeOrId ; if ( contextNode ) { var node = contextNode . node ; if ( ! node ) { if ( contextNode . next ) { if ( contextNode . index < this . _contextState . nextSetIndex ) { LayoutUtility . error ( 'Nodes must be layed out in the same order as they were requested!' ) ; } this . _contextState . nextSetIndex = contextNode . index ; } else if ( contextNode . prev ) { if ( contextNode . index > this . _contextState . prevSetIndex ) { LayoutUtility . error ( 'Nodes must be layed out in the same order as they were requested!' ) ; } this . _contextState . prevSetIndex = contextNode . index ; } node = _contextGetCreateAndOrderNodes . call ( this , contextNode . renderNode , contextNode . prev ) ; node . _viewSequence = contextNode . viewSequence ; node . _layoutCount ++ ; if ( node . _layoutCount === 1 ) { this . _contextState . addCount ++ ; } contextNode . node = node ; } node . usesTrueSize = contextNode . usesTrueSize ; node . trueSizeRequested = contextNode . trueSizeRequested ; node . set ( set , this . _context . size ) ; contextNode . set = set ; } return set ; } 
function _resolveConfigSize ( renderNode ) { if ( renderNode instanceof RenderNode ) { var result = null ; var target = renderNode . get ( ) ; if ( target ) { result = _resolveConfigSize ( target ) ; if ( result ) { return result ; } } if ( renderNode . _child ) { return _resolveConfigSize ( renderNode . _child ) ; } } else if ( renderNode instanceof Surface ) { return renderNode . size ? { renderNode : renderNode , size : renderNode . size } : undefined ; } else if ( renderNode . options && renderNode . options . size ) { return { renderNode : renderNode , size : renderNode . options . size } ; } return undefined ; } 
function _contextResolveSize ( contextNodeOrId , parentSize ) { var contextNode = this . _nodesById ? _contextGet . call ( this , contextNodeOrId ) : contextNodeOrId ; var resolveSize = this . _pool . resolveSize ; if ( ! contextNode ) { resolveSize [ 0 ] = 0 ; resolveSize [ 1 ] = 0 ; return resolveSize ; } 
function _getRoundedValue3D ( prop , def , precision , lockValue ) { if ( ! prop || ! prop . init ) { return def ; } return [ prop . enabled [ 0 ] ? ( Math . round ( ( prop . curState . x + ( ( prop . endState . x - prop . curState . x ) * lockValue ) ) / precision ) * precision ) : prop . endState . x , prop . enabled [ 1 ] ? ( Math . round ( ( prop . curState . y + ( ( prop . endState . y - prop . curState . y ) * lockValue ) ) / precision ) * precision ) : prop . endState . y , prop . enabled [ 2 ] ? ( Math . round ( ( prop . curState . z + ( ( prop . endState . z - prop . curState . z ) * lockValue ) ) / precision ) * precision ) : prop . endState . z ] ; } 
function _setPropertyValue ( prop , propName , endState , defaultValue , immediate , isTranslate ) { 
function _initFlowLayoutNode ( node , spec ) { if ( ! spec && this . options . flowOptions . insertSpec ) { node . setSpec ( this . options . flowOptions . insertSpec ) ; } } 
function _forEachRenderable ( callback ) { if ( this . _nodesById ) { for ( var key in this . _nodesById ) { callback ( this . _nodesById [ key ] ) ; } } else { var sequence = this . _viewSequence . getHead ( ) ; while ( sequence ) { var renderable = sequence . get ( ) ; if ( renderable ) { callback ( renderable ) ; } sequence = sequence . getNext ( ) ; } } } 
function _getActualDirection ( direction ) { 
function _getViewSequenceAtIndex ( index , startViewSequence ) { if ( this . _viewSequence . getAtIndex ) { return this . _viewSequence . getAtIndex ( index , startViewSequence ) ; } var viewSequence = startViewSequence || this . _viewSequence ; var i = viewSequence ? viewSequence . getIndex ( ) : index ; if ( index > i ) { while ( viewSequence ) { viewSequence = viewSequence . getNext ( ) ; if ( ! viewSequence ) { return undefined ; } i = viewSequence . getIndex ( ) ; if ( i === index ) { return viewSequence ; } else if ( index < i ) { return undefined ; } } } else if ( index < i ) { while ( viewSequence ) { viewSequence = viewSequence . getPrevious ( ) ; if ( ! viewSequence ) { return undefined ; } i = viewSequence . getIndex ( ) ; if ( i === index ) { return viewSequence ; } else if ( index > i ) { return undefined ; } } } return viewSequence ; } 
function _initLayoutNode ( node , spec ) { if ( ! spec && this . options . flowOptions . insertSpec ) { node . setSpec ( this . options . flowOptions . insertSpec ) ; } } 
function _isSequentiallyScrollingOptimized ( ) { return ! this . _layout . capabilities || ( this . _layout . capabilities . sequentialScrollingOptimized === undefined ) || this . _layout . capabilities . sequentialScrollingOptimized ; } 
function _updateSpring ( ) { var springValue = this . _scroll . scrollForceCount ? undefined : this . _scroll . springPosition ; if ( this . _scroll . springValue !== springValue ) { this . _scroll . springValue = springValue ; if ( springValue === undefined ) { if ( this . _scroll . springForceId !== undefined ) { this . _scroll . pe . detach ( this . _scroll . springForceId ) ; this . _scroll . springForceId = undefined ; 
function _mouseDown ( event ) { 
function _touchStart ( event ) { 
function _touchMove ( event ) { if ( ! this . options . enabled ) { return ; } 
function _touchEnd ( event ) { 
function _scrollUpdate ( event ) { if ( ! this . options . enabled ) { return ; } var offset = Array . isArray ( event . delta ) ? event . delta [ this . _direction ] : event . delta ; this . scroll ( offset ) ; } 
function _setParticle ( position , velocity , phase ) { if ( position !== undefined ) { 
function _calcScrollOffset ( normalize , refreshParticle ) { 
function _calcBounds ( size , scrollOffset ) { 
function _calcScrollToOffset ( size , scrollOffset ) { var scrollToRenderNode = this . _scroll . scrollToRenderNode || this . _scroll . ensureVisibleRenderNode ; if ( ! scrollToRenderNode ) { return ; } 
function _snapToPage ( ) { 
function _normalizePrevViewSequence ( scrollOffset ) { var count = 0 ; var normalizedScrollOffset = scrollOffset ; var normalizeNextPrev = false ; var node = this . _nodes . getStartEnumNode ( false ) ; while ( node ) { if ( ! node . _invalidated || ! node . _viewSequence ) { break ; } if ( normalizeNextPrev ) { this . _viewSequence = node . _viewSequence ; normalizedScrollOffset = scrollOffset ; normalizeNextPrev = false ; } if ( ( node . scrollLength === undefined ) || node . trueSizeRequested || ( scrollOffset < 0 ) ) { break ; } scrollOffset -= node . scrollLength ; count ++ ; if ( node . scrollLength ) { if ( this . options . alignment ) { normalizeNextPrev = ( scrollOffset >= 0 ) ; } else { if ( Math . round ( scrollOffset ) >= 0 ) { this . _viewSequence = node . _viewSequence ; normalizedScrollOffset = scrollOffset ; } } } node = node . _prev ; } return normalizedScrollOffset ; } 
function _getVisibleItem ( first ) { var result = { } ; var diff ; var prevDiff = 10000000 ; var diffDelta = ( first && this . options . alignment ) ? - this . _contextSizeCache [ this . _direction ] : ( ( ! first && ! this . options . alignment ) ? this . _contextSizeCache [ this . _direction ] : 0 ) ; var scrollOffset = this . _scroll . unnormalizedScrollOffset ; var node = this . _nodes . getStartEnumNode ( true ) ; while ( node ) { if ( ! node . _invalidated || ( node . scrollLength === undefined ) ) { break ; } if ( node . _viewSequence ) { diff = Math . abs ( diffDelta - ( scrollOffset + ( ! first ? node . scrollLength : 0 ) ) ) ; if ( diff >= prevDiff ) { break ; } prevDiff = diff ; result . scrollOffset = scrollOffset ; result . _node = node ; scrollOffset += node . scrollLength ; } node = node . _next ; } scrollOffset = this . _scroll . unnormalizedScrollOffset ; node = this . _nodes . getStartEnumNode ( false ) ; while ( node ) { if ( ! node . _invalidated || ( node . scrollLength === undefined ) ) { break ; } if ( node . _viewSequence ) { scrollOffset -= node . scrollLength ; diff = Math . abs ( diffDelta - ( scrollOffset + ( ! first ? node . scrollLength : 0 ) ) ) ; if ( diff >= prevDiff ) { break ; } prevDiff = diff ; result . scrollOffset = scrollOffset ; result . _node = node ; } node = node . _prev ; } if ( ! result . _node ) { return undefined ; } result . scrollLength = result . _node . scrollLength ; if ( this . options . alignment ) { result . visiblePerc = ( Math . min ( result . scrollOffset + result . scrollLength , 0 ) - Math . max ( result . scrollOffset , - this . _contextSizeCache [ this . _direction ] ) ) / result . scrollLength ; } else { result . visiblePerc = ( Math . min ( result . scrollOffset + result . scrollLength , this . _contextSizeCache [ this . _direction ] ) - Math . max ( result . scrollOffset , 0 ) ) / result . scrollLength ; } result . index = result . _node . _viewSequence . getIndex ( ) ; result . viewSequence = result . _node . _viewSequence ; result . renderNode = result . _node . renderNode ; return result ; } 
function _goToSequence ( viewSequence , next , noAnimation ) { if ( noAnimation ) { this . _viewSequence = viewSequence ; this . _scroll . springPosition = undefined ; _updateSpring . call ( this ) ; this . halt ( ) ; this . _scroll . scrollDelta = 0 ; _setParticle . call ( this , 0 , 0 , '_goToSequence' ) ; this . _scroll . scrollDirty = true ; } else { this . _scroll . scrollToSequence = viewSequence ; this . _scroll . scrollToRenderNode = viewSequence . get ( ) ; this . _scroll . ensureVisibleRenderNode = undefined ; this . _scroll . scrollToDirection = next ; this . _scroll . scrollDirty = true ; } } 
function _ensureVisibleSequence ( viewSequence , next ) { this . _scroll . scrollToSequence = undefined ; this . _scroll . scrollToRenderNode = undefined ; this . _scroll . ensureVisibleRenderNode = viewSequence . get ( ) ; this . _scroll . scrollToDirection = next ; this . _scroll . scrollDirty = true ; } 
function _goToPage ( amount , noAnimation ) { 
function _layout ( size , scrollOffset , nested ) { 
function _innerRender ( ) { var specs = this . _specs ; for ( var i3 = 0 , j3 = specs . length ; i3 < j3 ; i3 ++ ) { if ( specs [ i3 ] . renderNode ) { specs [ i3 ] . target = specs [ i3 ] . renderNode . render ( ) ; } } 
function ListLayout ( context , options ) { 
function _setPullToRefreshState ( pullToRefresh , state ) { if ( pullToRefresh . state !== state ) { pullToRefresh . state = state ; if ( pullToRefresh . node && pullToRefresh . node . setPullToRefreshStatus ) { pullToRefresh . node . setPullToRefreshStatus ( state ) ; } } } 
function ViewStackLayout ( context , options ) { var set = { size : context . size , translate : [ 0 , 0 , 0 ] } ; this . _size [ 0 ] = context . size [ 0 ] ; this . _size [ 1 ] = context . size [ 1 ] ; var views = context . get ( 'views' ) ; var transferables = context . get ( 'transferables' ) ; var visibleCount = 0 ; for ( var i = 0 ; i < views . length ; i ++ ) { var item = this . _viewStack [ i ] ; switch ( item . state ) { case ItemState . HIDDEN : context . set ( views [ i ] , { size : context . size , translate : [ context . size [ 0 ] * 2 , context . size [ 1 ] * 2 , 0 ] } ) ; break ; case ItemState . HIDE : case ItemState . HIDING : case ItemState . VISIBLE : case ItemState . SHOW : case ItemState . SHOWING : if ( visibleCount < 2 ) { visibleCount ++ ; 
function _createLayout ( ) { this . _renderables = { views : [ ] , transferables : [ ] } ; this . _viewStack = [ ] ; this . layout = new LayoutController ( { layout : ViewStackLayout . bind ( this ) , layoutOptions : this . options , dataSource : this . _renderables } ) ; this . add ( this . layout ) ; this . layout . on ( 'layoutend' , _processAnimations . bind ( this ) ) ; } 
function _getViewSpec ( item , view , id , callback ) { if ( ! item . view ) { return ; } var spec = view . getSpec ( id ) ; if ( spec && ! spec . trueSizeRequested ) { callback ( spec ) ; } else { Timer . after ( _getViewSpec . bind ( this , item , view , id , callback ) , 1 ) ; } } 
function _getTransferable ( item , view , id ) { 
function _initTransferableAnimations ( item , prevItem , callback ) { var callbackCount = 0 ; function waitForAll ( ) { callbackCount -- ; if ( callbackCount === 0 ) { callback ( ) ; } } for ( var sourceId in item . options . transfer . items ) { if ( _initTransferableAnimation . call ( this , item , prevItem , sourceId , waitForAll ) ) { callbackCount ++ ; } } if ( ! callbackCount ) { callback ( ) ; } } 
function _endTransferableAnimations ( item ) { for ( var j = 0 ; j < item . transferables . length ; j ++ ) { var transferable = item . transferables [ j ] ; for ( var i = 0 ; i < this . _renderables . transferables . length ; i ++ ) { if ( this . _renderables . transferables [ i ] === transferable . renderNode ) { this . _renderables . transferables . splice ( i , 1 ) ; break ; } } transferable . source . show ( transferable . originalSource ) ; transferable . target . show ( transferable . originalTarget ) ; } item . transferables = [ ] ; this . layout . reflowLayout ( ) ; } 
function _processAnimations ( event ) { var prevItem ; for ( var i = 0 ; i < this . _viewStack . length ; i ++ ) { var item = this . _viewStack [ i ] ; switch ( item . state ) { case ItemState . HIDE : item . state = ItemState . HIDING ; _initHideAnimation . call ( this , item , prevItem , event . size ) ; _updateState . call ( this ) ; break ; case ItemState . SHOW : item . state = ItemState . SHOWING ; _initShowAnimation . call ( this , item , prevItem , event . size ) ; _updateState . call ( this ) ; break ; } prevItem = item ; } } 
function _initShowAnimation ( item , prevItem , size ) { var spec = item . options . show . animation ? item . options . show . animation . call ( undefined , true , size ) : { } ; item . startSpec = spec ; item . endSpec = { opacity : 1 , transform : Transform . identity } ; item . mod . halt ( ) ; if ( spec . transform ) { item . mod . setTransform ( spec . transform ) ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( spec . opacity ) ; } if ( spec . align ) { item . mod . setAlign ( spec . align ) ; } if ( spec . origin ) { item . mod . setOrigin ( spec . origin ) ; } var startShowAnimation = _startShowAnimation . bind ( this , item , spec ) ; var waitAndShow = item . wait ? function ( ) { item . wait . then ( startShowAnimation , startShowAnimation ) ; } : startShowAnimation ; if ( prevItem ) { _initTransferableAnimations . call ( this , item , prevItem , waitAndShow ) ; } else { waitAndShow ( ) ; } } 
function _startShowAnimation ( item , spec ) { if ( ! item . halted ) { var callback = item . showCallback ; if ( spec . transform ) { item . mod . setTransform ( Transform . identity , item . options . show . transition , callback ) ; callback = undefined ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( 1 , item . options . show . transition , callback ) ; callback = undefined ; } _startTransferableAnimations . call ( this , item , callback ) ; } } 
function _haltItemAtFrame ( item , perc ) { item . mod . halt ( ) ; item . halted = true ; if ( item . startSpec && ( perc !== undefined ) ) { if ( ( item . startSpec . opacity !== undefined ) && ( item . endSpec . opacity !== undefined ) ) { item . mod . setOpacity ( _interpolate ( item . startSpec . opacity , item . endSpec . opacity , perc ) ) ; } if ( item . startSpec . transform && item . endSpec . transform ) { var transform = [ ] ; for ( var i = 0 ; i < item . startSpec . transform . length ; i ++ ) { transform . push ( _interpolate ( item . startSpec . transform [ i ] , item . endSpec . transform [ i ] , perc ) ) ; } item . mod . setTransform ( transform ) ; } } } 
function _initHideAnimation ( item , prevItem , size ) { var startHideAnimation = _startHideAnimation . bind ( this , item , prevItem , size ) ; if ( item . wait ) { item . wait . then ( startHideAnimation , startHideAnimation ) ; } else { startHideAnimation ( ) ; } } 
function _startHideAnimation ( item , prevItem , size ) { var spec = item . options . hide . animation ? item . options . hide . animation . call ( undefined , false , size ) : { } ; item . endSpec = spec ; item . startSpec = { opacity : 1 , transform : Transform . identity } ; if ( ! item . halted ) { item . mod . halt ( ) ; var callback = item . hideCallback ; if ( spec . transform ) { item . mod . setTransform ( spec . transform , item . options . hide . transition , callback ) ; callback = undefined ; } if ( spec . opacity !== undefined ) { item . mod . setOpacity ( spec . opacity , item . options . hide . transition , callback ) ; callback = undefined ; } if ( callback ) { callback ( ) ; } } } 
function _setItemOptions ( item , options , callback ) { item . options = { show : { transition : this . options . show . transition || this . options . transition , animation : this . options . show . animation || this . options . animation } , hide : { transition : this . options . hide . transition || this . options . transition , animation : this . options . hide . animation || this . options . animation } , transfer : { transition : this . options . transfer . transition || this . options . transition , items : this . options . transfer . items || { } , zIndex : this . options . transfer . zIndex , fastResize : this . options . transfer . fastResize } } ; if ( options ) { item . options . show . transition = ( options . show ? options . show . transition : undefined ) || options . transition || item . options . show . transition ; if ( options && options . show && ( options . show . animation !== undefined ) ) { item . options . show . animation = options . show . animation ; } else if ( options && ( options . animation !== undefined ) ) { item . options . show . animation = options . animation ; } item . options . transfer . transition = ( options . transfer ? options . transfer . transition : undefined ) || options . transition || item . options . transfer . transition ; item . options . transfer . items = ( options . transfer ? options . transfer . items : undefined ) || item . options . transfer . items ; item . options . transfer . zIndex = ( options . transfer && ( options . transfer . zIndex !== undefined ) ) ? options . transfer . zIndex : item . options . transfer . zIndex ; item . options . transfer . fastResize = ( options . transfer && ( options . transfer . fastResize !== undefined ) ) ? options . transfer . fastResize : item . options . transfer . fastResize ; } item . showCallback = function ( ) { item . showCallback = undefined ; item . state = ItemState . VISIBLE ; _updateState . call ( this ) ; _endTransferableAnimations . call ( this , item ) ; item . endSpec = undefined ; item . startSpec = undefined ; if ( callback ) { callback ( ) ; } } . bind ( this ) ; } 
function _updateState ( ) { var prevItem ; var invalidated = false ; var hiddenViewCount = 0 ; var i = 0 ; while ( i < this . _viewStack . length ) { if ( this . _viewStack [ i ] . state === ItemState . HIDDEN ) { hiddenViewCount ++ ; for ( var j = 0 ; j < this . _viewStack . length ; j ++ ) { if ( ( this . _viewStack [ j ] . state !== ItemState . HIDDEN ) && ( this . _viewStack [ j ] . view === this . _viewStack [ i ] . view ) ) { this . _viewStack [ i ] . view = undefined ; this . _renderables . views . splice ( i , 1 ) ; this . _viewStack . splice ( i , 1 ) ; i -- ; hiddenViewCount -- ; break ; } } } i ++ ; } while ( hiddenViewCount > this . options . keepHiddenViewsInDOMCount ) { this . _viewStack [ 0 ] . view = undefined ; this . _renderables . views . splice ( 0 , 1 ) ; this . _viewStack . splice ( 0 , 1 ) ; hiddenViewCount -- ; } for ( i = hiddenViewCount ; i < ( Math . min ( this . _viewStack . length - hiddenViewCount , 2 ) + hiddenViewCount ) ; i ++ ) { var item = this . _viewStack [ i ] ; if ( item . state === ItemState . QUEUED ) { if ( ! prevItem || ( prevItem . state === ItemState . VISIBLE ) || ( prevItem . state === ItemState . HIDING ) ) { if ( prevItem && ( prevItem . state === ItemState . VISIBLE ) ) { prevItem . state = ItemState . HIDE ; prevItem . wait = item . wait ; } item . state = ItemState . SHOW ; invalidated = true ; } break ; } else if ( ( item . state === ItemState . VISIBLE ) && item . hide ) { item . state = ItemState . HIDE ; } if ( ( item . state === ItemState . SHOW ) || ( item . state === ItemState . HIDE ) ) { this . layout . reflowLayout ( ) ; } prevItem = item ; } if ( invalidated ) { _updateState . call ( this ) ; this . layout . reflowLayout ( ) ; } } 
function WheelLayout ( context , options ) { 
function ProportionalLayout ( context , options ) { 
function Base ( options ) { this . _eventOutput = new EventHandler ( ) ; this . _pool = [ ] ; EventHandler . setOutputHandler ( this , this . _eventOutput ) ; if ( options ) { for ( var key in options ) { this [ key ] = options [ key ] ; } } } 
function _createRenderable ( id , data ) { var option = this . options . createRenderables [ Array . isArray ( id ) ? id [ 0 ] : id ] ; if ( option instanceof Function ) { return option . call ( this , id , data ) ; } else if ( ! option ) { return undefined ; } if ( ( data !== undefined ) && ( data instanceof Object ) ) { return data ; } var surface = new Surface ( { classes : this . classes , content : data ? ( '<div>' + data + '</div>' ) : undefined } ) ; if ( Array . isArray ( id ) ) { for ( var i = 0 ; i < id . length ; i ++ ) { surface . addClass ( id [ i ] ) ; } } else { surface . addClass ( id ) ; } return surface ; } 
function _setDateToScrollWheels ( date ) { for ( var i = 0 ; i < this . scrollWheels . length ; i ++ ) { var scrollWheel = this . scrollWheels [ i ] ; var component = scrollWheel . component ; var item = scrollWheel . scrollController . getFirstVisibleItem ( ) ; var viewSequence = item ? item . viewSequence : scrollWheel . viewSequence ; if ( viewSequence ) { var renderNode = viewSequence . get ( ) ; var currentValue = component . getComponent ( renderNode . date ) ; var destValue = component . getComponent ( date ) ; 
function _getDateFromScrollWheels ( ) { var date = new Date ( this . _date ) ; for ( var i = 0 ; i < this . scrollWheels . length ; i ++ ) { var scrollWheel = this . scrollWheels [ i ] ; var component = scrollWheel . component ; var item = scrollWheel . scrollController . getFirstVisibleItem ( ) ; if ( item && item . renderNode ) { component . setComponent ( date , component . getComponent ( item . renderNode . date ) ) ; } } return date ; } 
function _createLayout ( ) { this . container = new ContainerSurface ( this . options . container ) ; this . container . setClasses ( this . classes ) ; this . layout = new LayoutController ( { layout : ProportionalLayout , layoutOptions : { ratios : [ ] } , direction : Utility . Direction . X } ) ; this . container . add ( this . layout ) ; this . add ( this . container ) ; } 
function _clickItem ( scrollWheel , event ) { if ( scrollWheel && event && event . target ) { scrollWheel . scrollController . goToRenderNode ( event . target ) ; } } 
function _updateComponents ( ) { this . scrollWheels = [ ] ; this . _scrollingCount = 0 ; var dataSource = [ ] ; var sizeRatios = [ ] ; for ( var i = 0 ; i < this . _components . length ; i ++ ) { var component = this . _components [ i ] ; component . createRenderable = _createRenderable . bind ( this ) ; var viewSequence = new VirtualViewSequence ( { factory : component , value : component . create ( new Date ( this . _date . getTime ( ) ) ) } ) ; var options = LayoutUtility . combineOptions ( this . options . scrollController , { layout : WheelLayout , layoutOptions : this . options . wheelLayout , flow : false , direction : Utility . Direction . Y , dataSource : viewSequence , autoPipeEvents : true } ) ; var scrollController = new ScrollController ( options ) ; scrollController . on ( 'scrollstart' , _scrollWheelScrollStart . bind ( this ) ) ; scrollController . on ( 'scrollend' , _scrollWheelScrollEnd . bind ( this ) ) ; scrollController . on ( 'pagechange' , _scrollWheelPageChange . bind ( this ) ) ; var scrollWheel = { component : component , scrollController : scrollController , viewSequence : viewSequence } ; this . scrollWheels . push ( scrollWheel ) ; component . on ( 'click' , _clickItem . bind ( this , scrollWheel ) ) ; dataSource . push ( scrollController ) ; sizeRatios . push ( component . sizeRatio ) ; } this . layout . setDataSource ( dataSource ) ; this . layout . setLayoutOptions ( { ratios : sizeRatios } ) ; } 
function OverlayLayout ( context , options ) { var height = ( context . size [ 1 ] - options . itemSize ) / 2 ; context . set ( 'top' , { size : [ context . size [ 0 ] , height ] , translate : [ 0 , 0 , 1 ] } ) ; context . set ( 'middle' , { size : [ context . size [ 0 ] , context . size [ 1 ] - ( height * 2 ) ] , translate : [ 0 , height , 1 ] } ) ; context . set ( 'bottom' , { size : [ context . size [ 0 ] , height ] , translate : [ 0 , context . size [ 1 ] - height , 1 ] } ) ; } 
function _createOverlay ( ) { this . overlay = new LayoutController ( { layout : OverlayLayout , layoutOptions : { itemSize : this . options . wheelLayout . itemSize } , dataSource : this . _overlayRenderables } ) ; this . add ( this . overlay ) ; } 
function TabBarLayout ( context , options ) { 
function _setSelectedItem ( index ) { if ( index !== this . _selectedItemIndex ) { var oldIndex = this . _selectedItemIndex ; this . _selectedItemIndex = index ; this . layout . setLayoutOptions ( { selectedItemIndex : index } ) ; if ( ( oldIndex >= 0 ) && this . _renderables . items [ oldIndex ] . removeClass ) { this . _renderables . items [ oldIndex ] . removeClass ( 'selected' ) ; } if ( this . _renderables . items [ index ] . addClass ) { this . _renderables . items [ index ] . addClass ( 'selected' ) ; } if ( oldIndex >= 0 ) { this . _eventOutput . emit ( 'tabchange' , { target : this , index : index , oldIndex : oldIndex , item : this . _renderables . items [ index ] , oldItem : ( ( oldIndex >= 0 ) && ( oldIndex < this . _renderables . items . length ) ) ? this . _renderables . items [ oldIndex ] : undefined } ) ; } } } 
function _createRenderable ( id , data ) { var option = this . options . createRenderables [ id ] ; if ( option instanceof Function ) { return option . call ( this , id , data ) ; } else if ( ! option ) { return undefined ; } if ( ( data !== undefined ) && ( data instanceof Object ) ) { return data ; } var surface = new Surface ( { classes : this . classes , content : data ? ( '<div>' + data + '</div>' ) : undefined } ) ; surface . addClass ( id ) ; if ( id === 'item' ) { if ( this . options . tabBarLayout && this . options . tabBarLayout . itemSize && ( this . options . tabBarLayout . itemSize === true ) ) { surface . setSize ( this . layout . getDirection ( ) ? [ undefined , true ] : [ true , undefined ] ) ; } } return surface ; } 
function _createRenderables ( ) { this . tabBar = new TabBar ( this . options . tabBar ) ; this . animationController = new AnimationController ( this . options . animationController ) ; this . _renderables = { tabBar : this . tabBar , content : this . animationController } ; } 
function _createLayout ( ) { this . layout = new LayoutController ( this . options . layoutController ) ; this . layout . setLayout ( TabBarController . DEFAULT_LAYOUT . bind ( this ) ) ; this . layout . setDataSource ( this . _renderables ) ; this . add ( this . layout ) ; } 
function _setListeners ( ) { this . tabBar . on ( 'tabchange' , function ( event ) { _updateView . call ( this , event ) ; this . _eventOutput . emit ( 'tabchange' , { target : this , index : event . index , oldIndex : event . oldIndex , item : this . _items [ event . index ] , oldItem : ( ( event . oldIndex >= 0 ) && ( event . oldIndex < this . _items . length ) ) ? this . _items [ event . oldIndex ] : undefined } ) ; } . bind ( this ) ) ; } 
function _updateView ( event ) { var index = this . tabBar . getSelectedItemIndex ( ) ; this . animationController . halt ( ) ; if ( index >= 0 ) { this . animationController . show ( this . _items [ index ] . view ) ; } else { this . animationController . hide ( ) ; } } 
function _layoutLine ( next , endReached ) { if ( ! lineNodes . length ) { return 0 ; } 
function _resolveNodeSize ( node ) { var localItemSize = itemSize ; if ( getItemSize ) { localItemSize = getItemSize ( node . renderNode , size ) ; } if ( ( localItemSize [ 0 ] === true ) || ( localItemSize [ 1 ] === true ) ) { var result = context . resolveSize ( node , size ) ; if ( localItemSize [ 0 ] !== true ) { result [ 0 ] = itemSize [ 0 ] ; } if ( localItemSize [ 1 ] !== true ) { result [ 1 ] = itemSize [ 1 ] ; } return result ; } else { return localItemSize ; } } 
function CollectionLayout ( context_ , options ) { 
function CoverLayout ( context , options ) { 
function FontLayout ( context , options ) { 
async function move ( src , dest ) { const files = await fs . readdir ( src ) ; for ( const file of files ) { await fs . move ( path . join ( src , file ) , path . join ( dest , file ) , { overwrite : true } ) ; } await fs . rmdir ( src ) ; } 
function DynamoDBFormatter ( ) { var datatypes = typeof ( window ) === "undefined" ? require ( "./datatypes" ) . DynamoDBDatatype : window . DynamoDBDatatype ; var t = new datatypes ( ) ; var EmptyConditionArray = "Need to pass in an array with 1 or more Condition Objects." ; var BadElementInConditionArray = "Only Condition objects are allowed as members of the array." ; var InvalidCondition = "Need to pass in a valid Condition Object." ; this . setCustomAgent = function ( request ) { var isBrowser = typeof ( window ) === "undefined" ; var prefix = isBrowser ? "" : "X-Amz-" ; var sdk = isBrowser ? "nodejs" : "js" ; var currentHeader = request . httpRequest . headers [ prefix + 'User-Agent' ] ; request . httpRequest . headers [ prefix + 'User-Agent' ] = currentHeader + "/document-sdk-" + sdk ; } function formatAttrValInput ( attrValueMap ) { var attributeValueMap = { } ; for ( var attr in attrValueMap ) { var value = attrValueMap [ attr ] ; attributeValueMap [ attr ] = t . formatDataType ( value ) ; } return attributeValueMap ; } function formatConditions ( conditions ) { if ( conditions . prototype && conditions . prototype . instanceOf === "DynamoDBConditionObject" ) { conditions = [ conditions ] ; } else { if ( Array . isArray ( conditions ) ) { if ( conditions . length === 0 ) { throw new Error ( EmptyConditionArray ) ; } for ( var index = 0 ; index < conditions . length ; index ++ ) { var condition = conditions [ index ] ; if ( ! ( condition . prototype ) || ! ( condition . prototype . instanceOf === "DynamoDBConditionObject" ) ) { throw new Error ( BadElementInConditionArray ) ; } } } else { throw new Error ( InvalidCondition ) ; } } var expected = { } ; for ( var index = 0 ; index < conditions . length ; index ++ ) { var condition = conditions [ index ] ; expected [ condition . key ] = condition . format ( ) ; } return expected ; } function formatUpdates ( updates ) { var attrUpdates = { } ; for ( var attr in updates ) { if ( updates . hasOwnProperty ( attr ) ) { var actionValue = { } ; var value = updates [ attr ] . Value ; var action = updates [ attr ] . Action ; actionValue . Action = action ; if ( value !== undefined ) { actionValue . Value = t . formatDataType ( value ) ; } attrUpdates [ attr ] = actionValue ; } } return attrUpdates ; } function handleWriteRequest ( request ) { var requestCopy = { } ; if ( request . DeleteRequest ) { var key = request . DeleteRequest . Key ; requestCopy . DeleteRequest = { } ; requestCopy . DeleteRequest . Key = formatAttrValInput ( key ) ; } else { var item = request . PutRequest . Item ; requestCopy . PutRequest = { } ; requestCopy . PutRequest . Item = formatAttrValInput ( item ) ; } return requestCopy ; } function formatRequestItems ( requests ) { var requestItems = { } ; for ( var table in requests ) { if ( requests . hasOwnProperty ( table ) ) { requestItems [ table ] = { } ; var request = requests [ table ] ; if ( Array . isArray ( request ) ) { var writeRequests = [ ] ; for ( var wIndex in request ) { writeRequests . push ( handleWriteRequest ( request [ wIndex ] ) ) ; } requestItems [ table ] = writeRequests ; } else { if ( request . AttributesToGet ) { requestItems [ table ] . AttributesToGet = request . AttributesToGet ; } if ( request . ConsistentRead ) { requestItems [ table ] . ConsistentRead = request . ConsistentRead ; } if ( request . ProjectionExpression ) { requestItems [ table ] . ProjectionExpression = request . ProjectionExpression ; } if ( request . ExpressionAttributeNames ) { requestItems [ table ] . ExpressionAttributeNames = request . ExpressionAttributeNames ; } if ( request . Keys ) { var keys = [ ] ; for ( var gIndex in request . Keys ) { var key = request . Keys [ gIndex ] ; keys . push ( formatAttrValInput ( key ) ) ; } requestItems [ table ] . Keys = keys ; } } } } return requestItems ; } var inputMap = { "AttributeUpdates" : formatUpdates , "ExclusiveStartKey" : formatAttrValInput , "Expected" : formatConditions , "ExpressionAttributeValues" : formatAttrValInput , "Item" : formatAttrValInput , "Key" : formatAttrValInput , "KeyConditions" : formatConditions , "RequestItems" : formatRequestItems , "ScanFilter" : formatConditions , "QueryFilter" : formatConditions } ; function formatAttrValOutput ( item ) { var attrList = { } ; for ( var attribute in item ) { var keys = Object . keys ( item [ attribute ] ) ; var key = keys [ 0 ] ; var value = item [ attribute ] [ key ] ; value = t . formatWireType ( key , value ) ; attrList [ attribute ] = value ; } return attrList ; } function formatItems ( items ) { for ( var index in items ) { items [ index ] = formatAttrValOutput ( items [ index ] ) ; } return items ; } function handleCollectionKey ( metrics ) { var collectionKey = metrics . ItemCollectionKey ; metrics . ItemCollectionKey = formatAttrValOutput ( collectionKey ) ; return metrics ; } function handleBatchMetrics ( metrics ) { for ( var table in metrics ) { if ( metrics . hasOwnProperty ( table ) ) { var listOfKeys = metrics [ table ] ; for ( var index in listOfKeys ) { listOfKeys [ index ] = handleCollectionKey ( listOfKeys [ index ] ) ; } } } return metrics ; } function formatMetrics ( metrics ) { var collectionKey = metrics . ItemCollectionKey ; if ( collectionKey ) { metrics = handleCollectionKey ( metrics ) ; } else { metrics = handleBatchMetrics ( metrics ) ; } return metrics ; } function formatResponses ( responses ) { for ( var table in responses ) { if ( responses . hasOwnProperty ( table ) ) { var listOfItems = responses [ table ] ; for ( var index in listOfItems ) { listOfItems [ index ] = formatAttrValOutput ( listOfItems [ index ] ) ; } } } return responses ; } function formatUnprocessedItems ( unprocessedItems ) { for ( var table in unprocessedItems ) { if ( unprocessedItems . hasOwnProperty ( table ) ) { var tableInfo = unprocessedItems [ table ] ; for ( var index in tableInfo ) { var request = tableInfo [ index ] ; if ( request . DeleteRequest ) { tableInfo [ index ] . DeleteRequest . Key = formatAttrValOutput ( request . DeleteRequest . Key ) ; } else { tableInfo [ index ] . PutRequest . Item = formatAttrValOutput ( request . PutRequest . Item ) ; } } } } return unprocessedItems ; } function formatUnprocessedKeys ( unprocessedKeys ) { for ( var table in unprocessedKeys ) { if ( unprocessedKeys . hasOwnProperty ( table ) ) { var tableInfo = unprocessedKeys [ table ] ; var listOfKeys = tableInfo . Keys ; for ( var index in listOfKeys ) { tableInfo . Keys [ index ] = formatAttrValOutput ( listOfKeys [ index ] ) ; } } } return unprocessedKeys ; } this . formatOutput = function ( response ) { var outputMap = { "Attributes" : formatAttrValOutput , "Item" : formatAttrValOutput , "Items" : formatItems , "ItemCollectionMetrics" : formatMetrics , "LastEvaluatedKey" : formatAttrValOutput , "Responses" : formatResponses , "UnprocessedKeys" : formatUnprocessedKeys , "UnprocessedItems" : formatUnprocessedItems } ; var data = response . data ; if ( data ) { for ( var key in data ) { if ( data . hasOwnProperty ( key ) ) { var formatFunc = outputMap [ key ] ; if ( formatFunc ) { response . data [ key ] = formatFunc ( data [ key ] ) ; } } } } } ; this . formatInput = function ( request ) { var paramsCopy = { } ; var params = request . params ; for ( var key in params ) { if ( params . hasOwnProperty ( key ) ) { var param = params [ key ] ; var formatFunc = inputMap [ key ] ; if ( formatFunc ) { param = formatFunc ( param ) ; } paramsCopy [ key ] = param ; } } request . params = paramsCopy ; } ; } 
function parseCommandOptions ( command , notManaged ) { let possibleCommandOptions = [ ] ; let possibleCommandOptionsShort = [ ] ; const parsedOptions = { managed : { } , unmanaged : { } , } ; const getName = ( name , option ) => { if ( name ) { return name . length === 1 ? '-' + name : '--' + name ; } const shortOption = option . alias ? ' / ' + bold ( '-' + option . alias ) : '' ; return '--' + option . name + shortOption ; } ; if ( command && command . options ) { const options = objectToArray ( command . options ) ; possibleCommandOptions = options . map ( ( option ) => option . name ) ; possibleCommandOptionsShort = options . reduce ( ( previous , option ) => { if ( option . alias ) { return previous . concat ( option . alias ) ; } return previous ; } , [ ] ) ; options . forEach ( ( option ) => { let value ; let name ; 
function convert ( value , mapping ) { const val = mapping . converter ( value ) ; const validationResult = isValid ( val , mapping . validator ) ; if ( validationResult === true ) { return val ; } 
function updateDependencies ( dependencies , name , path ) { const local = { ... dependencies } ; Object . keys ( local ) . forEach ( ( dependency ) => { if ( isString ( local [ dependency ] ) ) { local [ dependency ] = { version : local [ dependency ] , } ; } local [ dependency ] = { ... local [ dependency ] , context : path , extension : name , } ; } ) ; return local ; } 
function removeFromExports ( exports , dependencies = { } ) { const localExports = { ... exports } ; Object . keys ( localExports ) . forEach ( ( exported ) => { if ( dependencies [ exported ] ) { delete localExports [ exported ] ; } } ) ; return localExports ; } 
function getKeys ( obj = { } , flag = false , oldPath = '' , allKeys = [ ] , allGroups = [ ] ) { let isValue = true ; Object . keys ( obj ) . forEach ( ( key ) => { const value = obj [ key ] ; const newPath = oldPath + key ; if ( isPlainObject ( value ) && key !== RAW && key !== '__meta' ) { isValue = true ; if ( newPath !== 'settings' ) { allGroups . push ( true ) ; allKeys . push ( newPath ) ; } const keys = getKeys ( value , flag , ` ${ newPath } ` , allKeys , allGroups ) ; 
async function showListOfTemplates ( ) { const spinner = ora ( 'Fetching list of official templates' ) . start ( ) ; const templates = await getOfficialTemplates ( ) ; spinner . stop ( ) ; const choices = templates . map ( ( template ) => ( { name : ` ${ template . name } ${ template . description && ' - ' + template . description } ` , short : template . name , value : template . full_name , } ) ) ; const { option } = await inquirer . prompt ( [ { type : 'rawlist' , name : 'option' , message : 'Select a template' , choices , } ] ) ; return option ; } 
function sha256x2 ( buffer ) { var tmp = createHash ( 'sha256' ) . update ( buffer ) . digest ( ) return createHash ( 'sha256' ) . update ( tmp ) . digest ( ) } 
function encode ( payload ) { var checksum = checksumFn ( payload ) return base58 . encode ( Buffer . concat ( [ payload , checksum ] , payload . length + 4 ) ) } 
function main ( ) { return new Promise ( ( resolve ) => { fsx . readFile ( path . resolve ( __dirname , '../package.json' ) , 'utf8' , ( err , data ) => { if ( err ) { throw err ; } resolve ( data ) ; } ) ; } ) . then ( ( data ) => JSON . parse ( data ) ) . then ( ( packageData ) => { const { author , version , description , keywords , repository , license , bugs , homepage , peerDependencies , dependencies , } = packageData ; const minimalPackage = { name : '@boundlessgeo/sdk' , author , version , description , keywords , repository , license , bugs , homepage , peerDependencies , dependencies , } ; return new Promise ( ( resolve ) => { const buildPath = path . resolve ( __dirname , '../dist/package.json' ) ; const data = JSON . stringify ( minimalPackage , null , 2 ) ; fsx . writeFile ( buildPath , data , ( err ) => { if ( err ) { throw ( err ) ; } process . stdout . write ( ` ${ buildPath } \n ` ) ; resolve ( ) ; } ) ; } ) ; } ) ; } 
function getVersion ( obj , key ) { if ( obj . metadata === undefined ) { return undefined ; } return obj . metadata [ key ] ; } 
function authTileLoader ( fetchOptions ) { return function ( tile , src ) { fetch ( src , fetchOptions ) . then ( r => r . blob ( ) ) . then ( ( imgData ) => { tile . getImage ( ) . src = URL . createObjectURL ( imgData ) ; } ) . catch ( ( ) => { console . error ( 'Error fetchimg image at:' , src ) ; } ) ; } ; } 
function authVectorTileLoader ( fetchOptions ) { return function ( tile , url ) { const loader = ( ) => { fetch ( url , fetchOptions ) . then ( r => r . arrayBuffer ( ) ) . then ( ( source ) => { const format = tile . getFormat ( ) ; tile . setProjection ( format . readProjection ( source ) ) ; tile . setFeatures ( format . readFeatures ( source ) ) ; tile . setExtent ( format . getLastExtent ( ) ) ; } ) . catch ( ( err ) => { tile . onError ( ) ; } ) ; } ; tile . setLoader ( loader ) ; } ; } 
function configureTileSource ( glSource , mapProjection , time , fetchOptions ) { const tile_url = glSource . tiles [ 0 ] ; const commonProps = { attributions : glSource . attribution , minZoom : glSource . minzoom , maxZoom : 'maxzoom' in glSource ? glSource . maxzoom : 22 , tileSize : glSource . tileSize || 512 , crossOrigin : 'crossOrigin' in glSource ? glSource . crossOrigin : 'anonymous' , projection : mapProjection , } ; 
function configureImageSource ( glSource ) { const coords = glSource . coordinates ; return new ImageStaticSource ( { url : glSource . url , imageExtent : [ coords [ 0 ] [ 0 ] , coords [ 3 ] [ 1 ] , coords [ 1 ] [ 0 ] , coords [ 0 ] [ 1 ] ] , projection : 'EPSG:4326' , } ) ; } 
function configureMvtSource ( glSource , accessToken , fetchOptions ) { if ( glSource . tiles ) { return new Promise ( ( resolve , reject ) => { 
function configureGeojsonSource ( glSource , mapView , baseUrl , wrapX , fetchOptions ) { const use_bbox = ( typeof glSource . data === 'string' && glSource . data . indexOf ( BBOX_STRING ) >= 0 ) ; const vector_src = new VectorSource ( { strategy : use_bbox ? bboxStrategy : allStrategy , loader : getLoaderFunction ( glSource , mapView . getProjection ( ) , baseUrl , fetchOptions ) , useSpatialIndex : true , wrapX : wrapX , } ) ; 
function configureSource ( glSource , mapView , accessToken , baseUrl , time , wrapX , fetchOptions ) { let src ; 
function getLayerGroupName ( layer_group ) { const all_names = [ ] ; for ( let i = 0 , ii = layer_group . length ; i < ii ; i ++ ) { all_names . push ( layer_group [ i ] . id ) ; } return ` ${ layer_group [ 0 ] . source } ${ all_names . join ( ',' ) } ` ; } 
function hydrateLayerGroup ( layersDef , layerGroup ) { const hydrated_group = [ ] ; for ( let i = 0 , ii = layerGroup . length ; i < ii ; i ++ ) { 
function incrementVersion ( metadata , version ) { const new_metadata = Object . assign ( { } , metadata ) ; new_metadata [ version ] = getVersion ( metadata , version ) + 1 ; return { metadata : new_metadata , } ; } 
function placeLayer ( state , layer , targetId ) { const new_layers = state . layers . slice ( ) ; const idx1 = getLayerIndexById ( new_layers , layer . id ) ; const idx2 = getLayerIndexById ( new_layers , targetId ) ; if ( idx1 !== - 1 ) { new_layers . splice ( idx1 , 1 ) ; } const newIndex = ( targetId && idx2 !== - 1 ) ? idx2 : new_layers . length ; new_layers . splice ( newIndex , 0 , layer ) ; return Object . assign ( { } , state , { layers : new_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; } 
function changeTarget ( state , action ) { const layerIdx = getLayerIndexById ( state . layers , action . layerId ) ; const layer = state . layers [ layerIdx ] ; const layerGroup = getGroup ( layer ) ; const targetIdx = getLayerIndexById ( state . layers , action . targetId ) ; if ( layerGroup ) { return false ; } let i , ii ; if ( layerIdx < targetIdx ) { 
function orderLayer ( state , action ) { let layer = null , target = null ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i ++ ) { if ( state . layers [ i ] . id === action . layerId ) { layer = state . layers [ i ] ; } if ( state . layers [ i ] . id === action . targetId ) { target = state . layers [ i ] ; } } if ( layer !== null ) { let targetId = action . targetId ; let targetGroup = getGroup ( target ) ; let layerGroup = getGroup ( layer ) ; if ( layerGroup !== targetGroup ) { targetId = changeTarget ( state , action ) ; } if ( targetId !== false ) { return placeLayer ( state , layer , targetId ) ; } } return state ; } 
function moveGroup ( state , action ) { const place_at = getLayerIndexById ( state . layers , action . placeAt ) ; const n_layers = state . layers . length ; 
function addLayer ( state , action ) { 
function removeLayer ( state , action ) { const new_layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i ++ ) { if ( state . layers [ i ] . id !== action . layerId ) { new_layers . push ( state . layers [ i ] ) ; } } return Object . assign ( { } , state , { layers : new_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; } 
function clearLayerFilter ( state , action ) { const new_layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i ++ ) { if ( state . layers [ i ] . id === action . layerId ) { const newProps = Object . assign ( { } , state . layers [ i ] ) ; delete newProps . filter ; new_layers . push ( newProps ) ; } else { new_layers . push ( state . layers [ i ] ) ; } } return Object . assign ( { } , state , { layers : new_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; } 
function updateLayer ( state , action ) { 
function addSource ( state , action ) { const new_source = { } ; new_source [ action . sourceName ] = Object . assign ( { } , action . sourceDef ) ; if ( action . sourceDef . type === 'geojson' ) { if ( action . sourceDef . data === undefined || action . sourceDef . data === null ) { new_source [ action . sourceName ] . data = { } ; } else if ( typeof action . sourceDef . data === 'object' ) { new_source [ action . sourceName ] . data = Object . assign ( { } , action . sourceDef . data ) ; } else { new_source [ action . sourceName ] . data = action . sourceDef . data ; } } const new_metadata = { } ; new_metadata [ dataVersionKey ( action . sourceName ) ] = 0 ; const new_sources = Object . assign ( { } , state . sources , new_source ) ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , new_metadata ) , sources : new_sources , } , incrementVersion ( state . metadata , SOURCE_VERSION_KEY ) ) ; } 
function removeSource ( state , action ) { const new_sources = Object . assign ( { } , state . sources ) ; delete new_sources [ action . sourceName ] ; return Object . assign ( { } , state , { sources : new_sources , } , incrementVersion ( state . metadata , SOURCE_VERSION_KEY ) ) ; } 
function changeData ( state , sourceName , data ) { const source = state . sources [ sourceName ] ; if ( ! source ) { return state ; } const src_mixin = { } ; 
function addFeatures ( state , action ) { const source = state . sources [ action . sourceName ] ; if ( ! source ) { return state ; } const data = source . data ; 
function clusterPoints ( state , action ) { const source = state . sources [ action . sourceName ] ; if ( ! source ) { return state ; } const src_mixin = [ ] ; const cluster_settings = { } ; if ( typeof action . cluster !== 'undefined' ) { cluster_settings . cluster = action . cluster ; 
function removeFeatures ( state , action ) { 
function setLayerInGroupVisible ( state , action ) { const updated_layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i ++ ) { const layer = state . layers [ i ] ; if ( layer . metadata && layer . metadata [ GROUP_KEY ] === action . groupId ) { updated_layers . push ( { ... layer , layout : { ... layer . layout , visibility : layer . id === action . layerId ? 'visible' : 'none' , } , } ) ; } else { updated_layers . push ( layer ) ; } } return Object . assign ( { } , state , { layers : updated_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; } 
function setVisibility ( state , action ) { let updated = false ; const updated_layers = [ ] ; for ( let i = 0 , ii = state . layers . length ; i < ii ; i ++ ) { const layer = state . layers [ i ] ; if ( layer . id === action . layerId ) { updated_layers . push ( { ... layer , layout : { ... layer . layout , visibility : action . visibility , } , } ) ; updated = true ; } else { updated_layers . push ( layer ) ; } } if ( updated ) { return Object . assign ( { } , state , { layers : updated_layers , } , incrementVersion ( state . metadata , LAYER_VERSION_KEY ) ) ; } 
function setContext ( state , action ) { let metadata = incrementVersion ( state . metadata , SOURCE_VERSION_KEY ) ; metadata = incrementVersion ( metadata . metadata , LAYER_VERSION_KEY ) ; return Object . assign ( { } , action . context , { metadata : Object . assign ( { } , metadata . metadata , action . context . metadata ) } ) ; } 
function updateMetadata ( state , action ) { return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , action . metadata ) , } ) ; } 
function addGroup ( state , action ) { const groups = state . metadata ? Object . assign ( { } , state . metadata [ GROUPS_KEY ] ) : { } ; groups [ action . id ] = action . config ; const metadata = { } ; metadata [ GROUPS_KEY ] = groups ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , metadata ) , } ) ; } 
function removeGroup ( state , action ) { const groups = state . metadata ? Object . assign ( { } , state . metadata [ GROUPS_KEY ] ) : { } ; delete groups [ action . id ] ; const metadata = { } ; metadata [ GROUPS_KEY ] = groups ; return Object . assign ( { } , state , { metadata : Object . assign ( { } , state . metadata , metadata ) , } ) ; } 
function updateSource ( state , action ) { const old_source = state . sources [ action . sourceName ] ; const new_source = { } ; new_source [ action . sourceName ] = Object . assign ( { } , old_source , action . sourceDef ) ; const new_sources = Object . assign ( { } , state . sources , new_source ) ; let metadata ; if ( new_source [ action . sourceName ] . type === 'geojson' ) { metadata = incrementVersion ( state . metadata , dataVersionKey ( action . sourceName ) ) ; } else { metadata = incrementVersion ( state . metadata , SOURCE_VERSION_KEY ) ; } return Object . assign ( { } , state , { sources : Object . assign ( { } , state . sources , new_sources ) , } , metadata ) ; } 
function setZoom ( state , action ) { let zoom = Math . min ( DEFAULT_ZOOM . MAX , action . zoom ) ; zoom = Math . max ( DEFAULT_ZOOM . MIN , zoom ) ; return Object . assign ( { } , state , { zoom } ) ; } 
function fitExtent ( state , action ) { const extent = action . extent ; const resolution = getResolutionForExtent ( extent , action . size , action . projection ) ; const zoom = getZoomForResolution ( resolution , action . projection ) ; const center = [ ( extent [ 0 ] + extent [ 2 ] ) / 2 , ( extent [ 1 ] + extent [ 3 ] ) / 2 ] ; return Object . assign ( { } , state , { center , zoom } ) ; } 
function getRemoteLegend ( href ) { let ref = null ; const div = ( < div ref = { ( me ) => { ref = me ; } } / > ) ; 
function proposeFloat ( value , defaultValue ) { const proposed = parseFloat ( value ) ; if ( typeof proposed === 'number' && isFinite ( proposed ) ) { return proposed ; } return defaultValue ; } 
function mapDispatchToProps ( dispatch ) { return { moveSlide : ( count ) => { dispatch ( bookmarkAction . moveSlide ( count ) ) ; } , zoomTo : ( coords , zoomLevel ) => { dispatch ( mapActions . setView ( coords , zoomLevel ) ) ; } } ; } 
function addAction ( state , action ) { const action_id = uuid . v4 ( ) ; const new_action = { } ; new_action [ action_id ] = action ; const new_actions = Object . assign ( { } , state . actions , new_action ) ; return Object . assign ( { } , state , { actions : new_actions } ) ; } 
function finishedAction ( state , action ) { const new_actions = Object . assign ( { } , state . actions ) ; delete new_actions [ action . id ] ; return Object . assign ( { } , state , { actions : new_actions } ) ; } 
function addPoints ( sourceName , n_points = 10 ) { for ( let i = 0 ; i < n_points ; i ++ ) { 
function toJssRules ( cssRules , options ) { const jssRules = { } function stripUnit ( value ) { if ( ! options . unit || 
function stripZeros ( aInput ) { var a = aInput ; 
function decodeParams ( names , types , data , useNumberedParams = true ) { 
function encodeSignature ( method ) { const signature = ` ${ method . name } ${ utils . getKeys ( method . inputs , 'type' ) . join ( ',' ) } ` ; const signatureEncoded = ` ${ ( new Buffer ( utils . keccak256 ( signature ) , 'hex' ) ) . slice ( 0 , 4 ) . toString ( 'hex' ) } ` ; return signatureEncoded ; } 
function encodeMethod ( method , values ) { const paramsEncoded = encodeParams ( utils . getKeys ( method . inputs , 'type' ) , values ) . substring ( 2 ) ; return ` ${ encodeSignature ( method ) } ${ paramsEncoded } ` ; } 
function decodeMethod ( method , data ) { const outputNames = utils . getKeys ( method . outputs , 'name' , true ) ; const outputTypes = utils . getKeys ( method . outputs , 'type' ) ; return decodeParams ( outputNames , outputTypes , utils . hexOrBuffer ( data ) ) ; } 
function decodeEvent ( eventObject , data , topics , useNumberedParams = true ) { const nonIndexed = eventObject . inputs . filter ( ( input ) => ! input . indexed ) const nonIndexedNames = utils . getKeys ( nonIndexed , 'name' , true ) ; const nonIndexedTypes = utils . getKeys ( nonIndexed , 'type' ) ; const event = decodeParams ( nonIndexedNames , nonIndexedTypes , utils . hexOrBuffer ( data ) , useNumberedParams ) ; const topicOffset = eventObject . anonymous ? 0 : 1 ; eventObject . inputs . filter ( ( input ) => input . indexed ) . map ( ( input , i ) => { const topic = new Buffer ( topics [ i + topicOffset ] . slice ( 2 ) , 'hex' ) ; const coder = getParamCoder ( input . type ) ; event [ input . name ] = coder . decode ( topic , 0 ) . value ; } ) ; event . _eventName = eventObject . name ; return event ; } 
function decodeLogItem ( eventObject , log , useNumberedParams = true ) { if ( eventObject && log . topics [ 0 ] === eventSignature ( eventObject ) ) { return decodeEvent ( eventObject , log . data , log . topics , useNumberedParams ) } } 
function logDecoder ( abi , useNumberedParams = true ) { const eventMap = { } abi . filter ( item => item . type === 'event' ) . map ( item => { eventMap [ eventSignature ( item ) ] = item } ) return function ( logItems ) { return logItems . map ( log => decodeLogItem ( eventMap [ log . topics [ 0 ] ] , log , useNumberedParams ) ) . filter ( i => i ) } } 
function loader ( content ) { const { addDependency , resource , resourcePath } = this ; 
function ( ) { var client = redis . client ( ) ; return client . keysAsync ( 'bull:*:id' ) . then ( function ( keys ) { return _ . map ( keys , function ( key ) { return key . slice ( 5 , - 3 ) ; } ) ; } ) ; } 
function ( qName ) { if ( ! qName || qName . length === 0 ) { throw new Error ( 'You must specify a queue name.' ) ; } var client = redis . client ( ) ; return client . keysAsync ( 'bull:' + qName + ':*' ) . then ( function ( keys ) { if ( keys . length ) { return client . del ( keys ) ; } } ) ; } 
function ( qName ) { if ( this . _q . name !== qName ) { this . _q . name = qName ; var queueOpts = { redis : { host : redis . redisOpts . host , port : redis . redisOpts . port , DB : redis . redisOpts . db , opts : { auth_pass : redis . redisOpts . auth_pass } } } ; this . _q . instance = new bull ( qName , queueOpts ) ; } return this . _q . instance ; } 
function ( qName , id ) { var q = queue . get ( qName ) ; return q . getJob ( id ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } 
function ( qName , data , opts ) { var q = queue . get ( qName ) ; return q . add ( data , opts ) . then ( function ( job ) { if ( ! job ) { return job ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } 
function ( qName , id ) { var q = queue . get ( qName ) ; return q . getJob ( id ) . then ( function ( job ) { return job . remove ( ) ; } ) ; } 
function ( qName , type ) { var client = redis . client ( ) ; var key = 'bull:' + qName + ':' + type ; if ( type === 'wait' || type === 'active' ) { return client . llenAsync ( key ) ; } else if ( type === 'delayed' ) { return client . zcardAsync ( key ) ; } else if ( type === 'completed' || type === 'failed' ) { return client . scardAsync ( key ) ; } throw new Error ( 'You must provide a valid job type.' ) ; } 
function ( qName , type , offset , limit ) { var q = queue . get ( qName ) ; if ( ! ( offset >= 0 ) ) { offset = 0 ; } if ( ! ( limit >= 0 ) ) { limit = 30 ; } if ( type === 'wait' || type === 'active' ) { return q . getJobs ( type , 'LIST' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type === 'delayed' ) { return q . getJobs ( type , 'ZSET' , offset , offset + limit - 1 ) . then ( function ( jobs ) { return Promise . all ( _ . map ( jobs , function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ) ; } ) ; } else if ( type === 'completed' || type === 'failed' ) { var client = redis . client ( ) ; var key = 'bull:' + qName + ':' + type ; return client . smembersAsync ( key ) . then ( function ( ids ) { var _ids = ids . slice ( offset , offset + limit ) ; return Promise . all ( _ . map ( _ids , function ( id ) { return q . getJob ( id ) . then ( function ( job ) { if ( ! job ) { return null ; } return job . getState ( ) . then ( function ( state ) { job . state = state ; return job ; } ) ; } ) ; } ) ) ; } ) ; } throw new Error ( 'You must provide a valid job type.' ) ; } 
function ( opts ) { this . _client = Promise . promisifyAll ( redis . createClient ( opts ) ) ; if ( opts . db ) { this . _client . selectAsync ( opts . db ) ; } this . redisOpts = opts ; } 
function ( ) { var multi = this . _client . multi ( ) ; multi . execAsync = Promise . promisify ( multi . exec ) ; return multi ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; Object . defineProperty ( exports , "__esModule" , { value : true } ) ; exports . reactComponent = reactComponent ; var _react = __webpack_require__ ( 1 ) ; var _react2 = _interopRequireDefault ( _react ) ; function _interopRequireDefault ( obj ) { return obj && obj . __esModule ? obj : { default : obj } ; } function reactComponent ( ) { return _react2 . default . createElement ( 'div' , null , _react2 . default . createElement ( 'p' , null , 'I am the webpack application, and I\'m using SystemJS\' version of react.' ) , _react2 . default . createElement ( 'p' , null , 'I don\'t have to bundle react in with me, which makes my bundle a lot smaller.' ) , _react2 . default . createElement ( 'p' , null , 'I exported a react component from the entry module of my webpack config, and that export made it to the SystemJS app that loaded me, who was able to render my react component to the DOM.' ) ) ; } $__register__main__exports ( exports ) ; } 
function ( repo , commit ) { return commit . getTree ( ) . then ( function ( tree ) { return Git . Diff . treeToWorkdir ( repo , tree ) ; } ) . then ( function ( diff ) { return diff . patches ( ) ; } ) ; } 
function getStatus ( file ) { var status ; if ( file . isNew ( ) ) status = 'new' ; else if ( file . isModified ( ) ) status = 'modified' ; else if ( file . isDeleted ( ) ) status = 'deleted' ; else if ( file . isTypeChange ( ) ) status = 'typechange' ; else if ( file . isRenamed ( ) ) status = 'renamed' ; else if ( file . isIgnored ( ) ) status = 'ignored' ; debug ( '%s %s' , status , file . path ( ) ) ; return { 'path' : file . path ( ) , 'status' : status } ; } 
function ial ( app , opts ) { Object . defineProperty ( app . context , 'i18n' , { get : function ( ) { if ( this . _i18n ) { return this . _i18n } const i18n = new I18n ( opts ) i18n . request = this . request this . _i18n = i18n 
function registerMethods ( helpers , i18n ) { I18n . resMethods . forEach ( method => { helpers [ method ] = i18n [ method ] . bind ( i18n ) } ) } 
function handleGroup ( self , group , width , maxColumns ) { if ( group . length === 0 ) { return ; } var minRows = Math . ceil ( group . length / maxColumns ) ; for ( var row = 0 ; row < minRows ; row ++ ) { for ( var col = 0 ; col < maxColumns ; col ++ ) { var idx = row * maxColumns + col ; if ( idx >= group . length ) { break ; } var item = group [ idx ] ; self . _writeToOutput ( item ) ; if ( col < maxColumns - 1 ) { for ( var s = 0 ; s < width - item . length ; s ++ ) { self . _writeToOutput ( ' ' ) ; } } } self . _writeToOutput ( '\r\n' ) ; } self . _writeToOutput ( '\r\n' ) ; } 
function emitKeypressEvents ( stream , iface ) { if ( stream [ KEYPRESS_DECODER ] ) return ; if ( StringDecoder === undefined ) StringDecoder = require ( 'string_decoder' ) . StringDecoder ; stream [ KEYPRESS_DECODER ] = new StringDecoder ( 'utf8' ) ; stream [ ESCAPE_DECODER ] = emitKeys ( stream ) ; stream [ ESCAPE_DECODER ] . next ( ) ; const escapeCodeTimeout = ( ) => stream [ ESCAPE_DECODER ] . next ( '' ) ; let timeoutId ; function onData ( b ) { if ( stream . listenerCount ( 'keypress' ) > 0 ) { var r = stream [ KEYPRESS_DECODER ] . write ( b ) ; if ( r ) { clearTimeout ( timeoutId ) ; if ( iface ) { iface . _sawKeyPress = r . length === 1 ; } for ( var i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] === '\t' && typeof r [ i + 1 ] === 'string' && iface ) { iface . isCompletionEnabled = false ; } try { stream [ ESCAPE_DECODER ] . next ( r [ i ] ) ; 
function cursorTo ( stream , x , y ) { if ( stream === null || stream === undefined ) return ; if ( typeof x !== 'number' && typeof y !== 'number' ) return ; if ( typeof x !== 'number' ) throw new Error ( 'ERR_INVALID_CURSOR_POS' ) ; if ( typeof y !== 'number' ) { stream . write ( CSI ` ${ x + 1 } ` ) ; } else { stream . write ( CSI ` ${ y + 1 } ${ x + 1 } ` ) ; } } 
function moveCursor ( stream , dx , dy ) { if ( stream === null || stream === undefined ) return ; if ( dx < 0 ) { stream . write ( CSI ` ${ - dx } ` ) ; } else if ( dx > 0 ) { stream . write ( CSI ` ${ dx } ` ) ; } if ( dy < 0 ) { stream . write ( CSI ` ${ - dy } ` ) ; } else if ( dy > 0 ) { stream . write ( CSI ` ${ dy } ` ) ; } } 
function clearLine ( stream , dir ) { if ( stream === null || stream === undefined ) return ; if ( dir < 0 ) { 
function argumentsAreShallowlyEqual ( equalityCheck , prev , next ) { if ( prev === null || next === null || prev . length !== next . length ) { return false ; } 
function getObservableValue_fromDynamicKey_fromObservable ( key , root , helperOptions , readOptions ) { 
function toCompute ( value ) { if ( value ) { if ( value . isComputed ) { return value ; } if ( value . compute ) { return value . compute ; } else { return makeComputeLike ( value ) ; } } return value ; } 
function HelperOptions ( scope , nodeList , exprData , stringOnly ) { this . metadata = { rendered : false } ; this . stringOnly = stringOnly ; this . scope = scope ; this . nodeList = nodeList ; this . exprData = exprData ; } 
function valueShouldBeInsertedAsHTML ( value ) { return value !== null && typeof value === "object" && ( typeof value [ toDOMSymbol ] === "function" || typeof value [ viewInsertSymbol ] === "function" || typeof value . nodeType === "number" ) ; } 
function ( scope , nodeList , mode , exprData , truthyRenderer , falseyRenderer , stringOnly ) { if ( mode === "^" ) { var temp = truthyRenderer ; truthyRenderer = falseyRenderer ; falseyRenderer = temp ; } var value , helperOptions = new HelperOptions ( scope , nodeList , exprData , stringOnly ) ; 
function ( expressionString , state ) { expressionString = expressionString . trim ( ) ; var exprData , partialName = expressionString . split ( / \s+ / ) . shift ( ) ; if ( partialName !== expressionString ) { exprData = core . expression . parse ( expressionString ) ; } return function ( scope , parentSectionNodeList ) { 
function ( mode , expressionString , state ) { var exprData = core . expression . parse ( expressionString ) , 
function ( mode , expressionString , state ) { 
function ( template ) { 
function ( key , root , originalKey ) { this . root = root ; this . key = key ; 
function debuggerHelper ( left , right ) { 
function ( helperOptions ) { 
function ( process ) { var subSection = new TextSection ( ) ; this . last ( ) . add ( { process : process , truthy : subSection } ) ; this . stack . push ( subSection ) ; } 
function ( key , root , sourceText ) { this . key = key ; this . rootExpr = root ; canReflect . setKeyValue ( this , sourceTextSymbol , sourceText ) ; } 
function normalizeValue ( value ) { if ( Array . isArray ( value ) ) { return value ; } if ( isPlainObject ( value ) ) { return [ value ] ; } return [ { name : value } ] ; } 
function inferType ( type ) { if ( ! type ) return '' ; function iterateTypes ( subTree ) { return map ( normalizeValue ( subTree ) , inferType ) . join ( ', ' ) ; } switch ( type . name ) { case 'arrayOf' : return ` ${ iterateTypes ( type . value ) } ` ; case 'custom' : return COMMON_PROP_TYPES_TO_LINKS_MAP [ type . raw ] || type . raw ; case 'enum' : return ` ${ iterateTypes ( type . value ) } ` ; case 'shape' : case 'shapeOf' : 
function generateMarkdownTable ( api ) { if ( isEmpty ( api . props ) ) return '' ; return HEADER . concat ( join ( map ( api . props , ( description , propName ) => join ( [ ` \` ${ propName } \` ` , description . required ? 'true' : '' , inferType ( description . type ) , replaceNewlineWithBreak ( getValue ( description , 'defaultValue.value' , '' ) ) , replaceNewlineWithBreak ( description . description ) , ] , ' | ' ) ) , '\n' ) ) ; } 
function buildDocs ( api ) { const view = buildTemplateView ( api ) ; 
function ( section , mode , stache , lineNo ) { if ( mode === ">" ) { 
function ( ) { var lastElement = state . sectionElementStack [ state . sectionElementStack . length - 1 ] ; return state . sectionElementStack . length ? lastElement . type === "section" || lastElement . type === "custom" : true ; } 
function ( overwrites ) { var cur = { tag : state . node && state . node . tag , attr : state . attr && state . attr . name , 
function ( node , callback ) { if ( ! node . attributes ) { node . attributes = [ ] ; } node . attributes . unshift ( callback ) ; } 
function safeStep ( callback , stepFn ) { var err ; try { stepFn ( ) ; } catch ( error ) { err = error ; } callback ( err ) ; } 
function flush ( callback ) { 
function setup ( options ) { var childRunner = ChildRunner . current ( ) ; if ( childRunner ) { _deepMerge ( _config , childRunner . parentScope . WCT . _config ) ; 
function _deepMerge ( target , source ) { Object . keys ( source ) . forEach ( function ( key ) { if ( target [ key ] !== null && typeof target [ key ] === 'object' && ! Array . isArray ( target [ key ] ) ) { _deepMerge ( target [ key ] , source [ key ] ) ; } else { target [ key ] = source [ key ] ; } } ) ; } 
function parseUrl ( url ) { var parts = url . match ( / ^(.*?)(?:\?(.*))?$ / ) ; return { base : parts [ 1 ] , params : getParams ( parts [ 2 ] || '' ) , } ; } 
function expandUrl ( url , base ) { if ( ! base ) return url ; if ( url . match ( / ^(\/|https?:\/\/) / ) ) return url ; if ( base . substr ( base . length - 1 ) !== '/' ) { base = base + '/' ; } return base + url ; } 
function mergeParams ( target , source ) { Object . keys ( source ) . forEach ( function ( key ) { if ( ! ( key in target ) ) { target [ key ] = [ ] ; } target [ key ] = target [ key ] . concat ( source [ key ] ) ; } ) ; } 
function scriptPrefix ( filename ) { var scripts = document . querySelectorAll ( 'script[src*="' + filename + '"]' ) ; if ( scripts . length !== 1 ) { return null ; } var script = scripts [ 0 ] . src ; return script . substring ( 0 , script . indexOf ( filename ) ) ; } 
function getTitles ( runnable ) { var titles = [ ] ; while ( runnable && ! runnable . root && runnable . title ) { titles . unshift ( runnable . title ) ; runnable = runnable . parent ; } return titles ; } 
function HTML ( runner ) { var output = document . createElement ( 'div' ) ; output . id = 'mocha' ; document . body . appendChild ( output ) ; runner . on ( 'suite' , function ( _test ) { this . total = runner . total ; } . bind ( this ) ) ; Mocha . reporters . HTML . call ( this , runner ) ; } 
function drawFaviconArc ( context , total , start , length , color ) { var arcStart = ARC_OFFSET + Math . PI * 2 * ( start / total ) ; var arcEnd = ARC_OFFSET + Math . PI * 2 * ( ( start + length ) / total ) ; context . beginPath ( ) ; context . strokeStyle = color ; context . lineWidth = ARC_WIDTH ; context . arc ( 16 , 16 , 16 - ARC_WIDTH / 2 , arcStart , arcEnd ) ; context . stroke ( ) ; } 
function loadSuites ( files ) { files . forEach ( function ( file ) { if ( / \.js(\?.*)?$ / . test ( file ) ) { jsSuites$1 . push ( file ) ; } else if ( / \.html(\?.*)?$ / . test ( file ) ) { htmlSuites$1 . push ( file ) ; } else { throw new Error ( 'Unknown resource type: ' + file ) ; } } ) ; } 
function loadJsSuites ( _reporter , done ) { debug ( 'loadJsSuites' , jsSuites$1 ) ; var loaders = jsSuites$1 . map ( function ( file ) { 
function _runMocha ( reporter , done , waited ) { if ( get ( 'waitForFrameworks' ) && ! waited ) { var waitFor = ( get ( 'waitFor' ) || whenFrameworksReady ) . bind ( window ) ; waitFor ( _runMocha . bind ( null , reporter , done , true ) ) ; return ; } debug ( '_runMocha' ) ; var mocha = window . mocha ; var Mocha = window . Mocha ; mocha . reporter ( reporter . childReporter ( window . location ) ) ; mocha . suite . title = reporter . suiteTitle ( window . location ) ; mocha . grep ( GREP ) ; 
function injectMocha ( Mocha ) { _injectPrototype ( Console , Mocha . reporters . Base . prototype ) ; _injectPrototype ( HTML , Mocha . reporters . HTML . prototype ) ; 
function loadSync ( ) { debug ( 'Loading environment scripts:' ) ; var a11ySuiteScriptPath = 'web-component-tester/data/a11ySuite.js' ; var scripts = get ( 'environmentScripts' ) ; var a11ySuiteWillBeLoaded = window . __generatedByWct || scripts . indexOf ( a11ySuiteScriptPath ) > - 1 ; 
function listenForErrors ( ) { window . addEventListener ( 'error' , function ( event ) { globalErrors . push ( event . error ) ; } ) ; 
function extendInterfaces ( helperName , helperFactory ) { interfaceExtensions . push ( function ( ) { var Mocha = window . Mocha ; 
function addLocalGulpTasks ( subfile , submodule , tasks ) { var gulpMod = findModule ( function ( mod ) { return ( path . basename ( path . dirname ( mod . id ) ) === 'gulp' ) ; } , submodule ) ; var localInst = gulpMod . exports ; 
function loadFiles ( pattern , rootDir ) { 
function ( args , callback ) { let child = this . runProtractor ( args ) . on ( 'exit' , function ( code ) { if ( child ) { child . kill ( ) ; } if ( callback ) { callback ( code ) ; } } ) ; } 
function ( callback , verbose , startOptions ) { log ( PLUGIN_NAME + ' - Webdriver standalone server will be started' ) ; let callbackWasCalled = false ; let logOutput = true ; let command ; let seleniumPid = null ; function _interceptLogData ( data ) { let dataString = data . toString ( ) ; if ( logOutput && verbose ) { log ( dataString ) ; } if ( dataString . indexOf ( WEB_DRIVER_LOG_STARTED_NEW ) >= 0 || dataString . indexOf ( WEB_DRIVER_LOG_STARTED ) >= 0 ) { log ( PLUGIN_NAME + ' - Webdriver standalone server is started' ) ; callbackWasCalled = true ; logOutput = false ; callback ( ) ; } else if ( dataString . indexOf ( WEB_DRIVER_LOG_STOPPED ) >= 0 ) { logOutput = true ; if ( verbose ) { log ( dataString ) ; } } else if ( dataString . indexOf ( SELENIUM_PID ) >= 0 ) { seleniumPid = parseInt ( dataString . split ( SELENIUM_PID ) [ 1 ] . substr ( 1 ) . trim ( ) , 10 ) ; log ( PLUGIN_NAME + ' - Webdriver standalone server PID is detected:' + seleniumPid ) ; } } command = childProcess . spawn ( COMMAND_RELATIVE_PATH + WEB_DRIVER_COMMAND , [ WEB_DRIVER_START_COMMAND ] . concat ( startOptions && startOptions . args ? startOptions . args : [ ] ) , { 'cwd' : protractorDirToUse } ) ; command . once ( 'close' , function ( errorCode ) { log ( PLUGIN_NAME + ' - Webdriver standalone server will be closed' ) ; if ( ! callbackWasCalled ) { callback ( errorCode ) ; } } ) ; command . stderr . on ( 'data' , _interceptLogData ) ; command . stdout . on ( 'data' , _interceptLogData ) ; return function ( ) { if ( seleniumPid ) { process . kill ( seleniumPid , 'SIGINT' ) ; } } ; } 
function ( optsOrCallback , cb ) { let callback = cb ? cb : optsOrCallback ; let options = cb ? optsOrCallback : null ; let args = [ 'update' , '--standalone' ] ; let browsers = [ 'chrome' ] ; if ( options ) { if ( options . browsers && options . browsers . length > 0 ) { browsers = options . browsers ; } browsers . forEach ( function ( element ) { args . push ( '--' + element ) ; } ) ; if ( options . args ) { args = args . concat ( options . args ) ; } } childProcess . spawn ( COMMAND_RELATIVE_PATH + WEB_DRIVER_COMMAND , args , { 'cwd' : protractorDirToUse , 'stdio' : 'inherit' } ) . once ( 'close' , callback ) ; } 
function ( callback , verbose , updateOptions , startOptions ) { log ( PLUGIN_NAME + ' - Webdriver standalone will be updated' ) ; return new Promise ( ( resolve ) => { this . webDriverUpdate ( updateOptions , ( ) => { log ( PLUGIN_NAME + ' - Webdriver standalone is updated' ) ; resolve ( this . webDriverStandaloneStart ( callback , verbose , startOptions ) ) ; } ) ; } ) ; } 
function ( ) { ! fs . existsSync ( __dirname + '/target' ) && fs . mkdirSync ( __dirname + '/target' ) ; ! fs . existsSync ( __dirname + '/target/e2e' ) && fs . mkdirSync ( __dirname + '/target/e2e' ) ; var reporterPath = path . resolve ( path . join ( __dirname , '/target/e2e' ) ) ; console . info ( 'The JUnit report will be generated into the following path:' , reporterPath ) ; jasmine . getEnv ( ) . addReporter ( new reporters . JUnitXmlReporter ( { 'savePath' : reporterPath , 'consolidate' : true , 'consolidateAll' : true } ) ) ; } 
function sha256stream ( ) { var sha256 = createHash ( 'sha256' ) ; var stream = new Transform ( ) ; stream . _transform = function ( chunk , encoding , callback ) { this . push ( chunk ) ; sha256 . update ( chunk ) ; callback ( ) ; } ; stream . on ( 'finish' , ( ) => { stream . emit ( 'sha256' , sha256 . digest ( 'hex' ) ) ; } ) ; return stream ; } 
function download ( url ) { var req = request . get ( url ) ; 
function downloadString ( url ) { return new Promise ( ( resolve , reject ) => { request ( { url , 
function tmpdir ( ) { return new Promise ( ( resolve ) => { var dir = fsTemp . template ( 't2-sdk-%s' ) . mkdirSync ( ) ; resolve ( { path : dir , cleanup : ( ) => { try { fs . removeSync ( dir ) ; } catch ( e ) { 
function extract ( checksumVerify , filename , sdkStream , root , strip , name , decompress ) { return tmpdir ( ) . then ( destdir => { 
function extractTools ( checksumVerify , filename , sdkStream ) { var root = path . join ( SDK_PATHS . sdk , getPlatform ( ) ) ; return extract ( checksumVerify , filename , sdkStream , root , 2 , 'Tessel build tools' , bz2 ( ) ) ; } 
function extractRustlib ( checksumVerify , filename , sdkStream , rustVersion ) { var root = path . join ( SDK_PATHS . rustlib , rustVersion ) ; return extract ( checksumVerify , filename , sdkStream , root , 0 , 'MIPS libstd' , zlib . createGunzip ( ) ) ; } 
function transformKey ( value ) { return Object . keys ( replacements ) . reduce ( ( value , key ) => value . replace ( key , replacements [ key ] ) , value ) ; } 
function closeCommand ( error ) { 
function USBProcess ( id , daemon ) { active && !closed = Process is running as usual !active && !closed = Process has been sent a signal but not completely closed (resources freed) !active && closed = Process has stopped running and has already been destroyed */ 
function RemoteWritableStream ( process , daemon , writeHeaderFunc , closeHeaderFunc ) { 
function RemoteReadableStream ( process , daemon , ackHeaderFunc ) { 
function logAndFinish ( tessel ) { 
function Tessel ( connection ) { if ( connection === undefined ) { throw new Error ( 'Cannot create a Tessel with an undefined connection type' ) ; } this . usbConnection = undefined ; this . lanConnection = undefined ; this . lanPrefer = false ; this . close = ( ) => { 
function ( modulePath ) { var assetRoot = path . resolve ( __dirname , '../../../..' ) ; return modulePath . startsWith ( assetRoot ) && ! modulePath . startsWith ( assetRoot + path . sep + 'node' + path . sep + 'node_modules' ) ; } 
function ( path ) { var p = path ; const ar = p . indexOf ( '->' ) ; if ( ar >= 0 ) { p = p . substring ( ar + 2 ) ; } const cu = p . indexOf ( '/{' ) ; if ( cu > 0 ) { p = p . substring ( 0 , cu ) ; } return p ; } 
function ChartJsProvider ( ) { var options = { } ; var ChartJs = { Chart : Chart , getOptions : function ( type ) { var typeOptions = type && options [ type ] || { } ; return angular . extend ( { } , options , typeOptions ) ; } } ; this . setOptions = function ( type , customOptions ) { 
function hexToRgb ( hex ) { var bigint = parseInt ( hex , 16 ) , r = ( bigint >> 16 ) & 255 , g = ( bigint >> 8 ) & 255 , b = bigint & 255 ; return [ r , g , b ] ; } 
function ( str , delim ) { var res = [ ] ; var segs = str . split ( delim ) ; var accum = '' ; for ( let i = 0 ; i < segs . length ; i ++ ) { var seg = segs [ i ] ; if ( seg . endsWith ( '\\' ) ) { accum += seg . substring ( 0 , seg . length - 1 ) + delim ; } else { accum += seg ; res . push ( accum ) ; accum = '' ; } } return res ; } 
function ( input ) { var dollarCurly = input . indexOf ( '${' ) ; if ( dollarCurly >= 0 ) { var endCurly = input . indexOf ( '}' , dollarCurly ) ; if ( endCurly >= 0 ) { return { start : dollarCurly , stop : endCurly , expr : input . substring ( dollarCurly + 2 , endCurly ) } ; } } return null ; } 
function ( input , it ) { var output = input ; var expr ; while ( ( expr = this . getExpr ( output ) ) !== null ) { var evalsTo = $parse ( expr . expr ) ( { it : it } ) ; output = output . substring ( 0 , expr . start ) + evalsTo + output . substring ( expr . stop + 1 ) ; } return output ; } 
function findMedianRange ( values ) { var result = [ null , null ] ; if ( values . length > 0 ) { var n = values . length ; 
function updateSelectedItem ( datum ) { d3 . event . stopPropagation ( ) ; selection = utils . setSelection ( datum == selection . current ( ) ? null : datum , options ) ; var item = selection . current ( ) || geoObject ; options . updateInfoCard ( selection . info ( ) ) ; var projection = path . projection ( ) ; projection . center ( item . center ) . scale ( item . scale ) ; mapLayer . selectAll ( 'path' ) . attr ( 'stroke' , selection . strokeColor ) . attr ( 'fill' , selection . fillColor ) . attr ( 'class' , selection . className ) . transition ( ) . duration ( 600 ) . ease ( 'cubic-in-out' ) . attr ( 'd' , path ) ; textLayer . attr ( 'hidden' , selection . hideLabels ) ; textLayer . selectAll ( 'text' ) . attr ( 'fill' , selection . textFill ) . transition ( ) . duration ( 400 ) . ease ( 'cubic-in-out' ) . attr ( 'font-size' , selection . textSize ) . attr ( 'transform' , selection . textPosition ) ; } 
function ( selector , context , skipFiltering ) { 
function uki ( val , context ) { if ( typeof val === "string" ) { return selector . find ( val , context ) ; } if ( val . length === undefined ) { val = [ val ] ; } if ( val . length > 0 && utils . isFunction ( val [ 0 ] . typeName ) ) { return new collection . Collection ( val ) ; } return builder . build ( val ) ; } 
function ( ) { var e = this . baseEvent ; if ( e . preventDefault ) { e . preventDefault ( ) ; } else { e . returnValue = false ; } this . isDefaultPrevented = fun . FT ; } 
function domHandler ( e ) { e = e || env . root . event ; var wrapped = wrapDomEvent ( e ) ; evt . trigger ( this , normalize ( wrapped ) ) ; } 
function ( name , value ) { if ( arguments . length > 1 ) { for ( var i = this . length - 1 ; i >= 0 ; i -- ) { utils . prop ( this [ i ] , name , value ) ; } return this ; } else { return this [ 0 ] ? utils . prop ( this [ 0 ] , name ) : "" ; } } 
function ( index ) { var range = this . _visibleRange ( ) , dm = this . metrics ( ) . rowDimensions ( index ) , maxY = dm . top + dm . height , minY = dm . top ; if ( maxY >= range . to ) { this . scrollableParent ( ) . scroll ( 0 , maxY - range . to + 
function ( ) { var range = this . _renderingRange ( ) ; if ( ! range ) { return ; } var packs = this . childViews ( ) , fromPX = packs [ 0 ] && packs [ 0 ] . fromPX , toPX = packs [ 0 ] && packs [ packs . length - 1 ] . toPX , i , h = range . to - range . from ; if ( packs . length && fromPX <= range . from && toPX >= range . to ) { 
function ( type ) { return Focusable . _domForEvent . call ( this , type ) || Container . prototype . domForEvent . call ( this , type ) ; } 
function ( ) { var result = [ ] , indexes = this . selection ( ) . indexes ( ) ; for ( var i = 0 , l = indexes . length ; i < l ; i ++ ) { var item = this . _data . slice ( indexes [ i ] , indexes [ i ] + 1 ) [ 0 ] ; if ( item ) result . push ( item ) ; } ; return result ; } 
function ( template , context , partials ) { if ( ! includes ( "#" , template ) && ! includes ( "^" , template ) ) { return template ; } var that = this ; 
function ( template , context , partials , in_recursion ) { 
function ( name , context ) { name = trim ( name ) ; var value ; if ( is_kinda_truthy ( context [ name ] ) ) { value = context [ name ] ; } else if ( is_kinda_truthy ( this . context [ name ] ) ) { value = this . context [ name ] ; } if ( typeof value === "function" ) { return value . apply ( context ) ; } if ( value !== undefined ) { return value ; } 
function ( template , view , partials , send_fun ) { var renderer = new Renderer ( ) ; if ( send_fun ) { renderer . send = send_fun ; } renderer . render ( template , view , partials ) ; if ( ! send_fun ) { return renderer . buffer . join ( "\n" ) ; } } 
function ( tagName , options , children ) { var e = env . doc . createElement ( tagName ) ; utils . forEach ( options || { } , function ( value , name ) { if ( name == 'style' ) { e . style . cssText = value ; } else if ( name == 'html' ) { e . innerHTML = value ; } else if ( name == 'className' ) { e . className = value ; } else { e . setAttribute ( name , value ) ; } } ) ; children && utils . forEach ( children , function ( c ) { e . appendChild ( c ) ; } ) ; return e ; } 
function ( elem , ignoreScroll ) { var rect = elem . getBoundingClientRect ( ) ; var result = { top : rect . top | 0 , left : rect . left | 0 , right : rect . right | 0 , bottom : rect . bottom | 0 , width : ( rect . right - rect . left ) | 0 , height : ( rect . bottom - rect . top ) | 0 } ; if ( ignoreScroll ) { return result ; } var body = env . doc . body ; result . top += env . root . pageYOffset || body . scrollTop ; result . top += env . root . pageXOffset || body . scrollLeft ; return result ; } 
function ( id ) { if ( ! arguments . length ) { return this . dom ( ) . id ; } if ( this . dom ( ) . id ) { view . unregisterId ( this ) ; } this . dom ( ) . id = id ; view . registerId ( this ) ; return this ; } 
function ( value ) { if ( ! arguments . length ) { return this . dom ( ) . style ; } this . dom ( ) . style . cssText = styleToString ( value ) ; return this ; } 
function ( pos ) { if ( ! arguments . length ) { return this . _styleToPos ( this . dom ( ) . style ) ; } pos = this . _expandPos ( pos ) ; this . addStyle ( pos ) ; return this ; } 
function DragControls ( _objects , _camera , _domElement ) { if ( _objects . isCamera ) { console . warn ( 'THREE.DragControls: Constructor now expects ( objects, camera, domElement )' ) ; var temp = _objects ; _objects = _camera ; _camera = temp ; } var _plane = new Plane ( ) ; var _raycaster = new Raycaster ( ) ; var _mouse = new Vector2 ( ) ; var _offset = new Vector3 ( ) ; var _intersection = new Vector3 ( ) ; var _selected = null , _hovered = null ; 
function ( context ) { var _children = [ ] ; _children . push ( React . DOM . i ( { className : 'icon ' + context . icon } ) ) ; React . Children . forEach ( context . children , function ( child ) { _children . push ( child ) ; } ) ; context . children = _children ; } 
function ( context ) { context . icon = 'loading' ; context . disabled = true ; if ( this . props . loadingMessage ) { context . children = this . props . loadingMessage ; } } 
function normalizeEvents ( events , rtn , prefix ) { rtn = rtn || { } ; if ( prefix ) { prefix += ':' ; } else { prefix = '' ; } var value , valueType ; for ( var key in events ) { if ( events . hasOwnProperty ( key ) ) { value = events [ key ] ; valueType = typeof value ; if ( valueType === 'string' || valueType === 'function' ) { rtn [ prefix + key ] = value ; } else if ( value ) { normalizeEvents ( value , rtn , prefix + key ) ; } } } return rtn ; } 
function manageEvent ( type , data ) { var _data = { type : type } ; for ( var name in data ) { if ( data . hasOwnProperty ( name ) ) { _data [ name ] = data [ name ] ; } } var watchedEvents = getState ( '__watchedEvents' , this ) ; if ( ! watchedEvents ) { watchedEvents = [ ] ; setState ( { __watchedEvents : watchedEvents } , this ) ; } _data . context = _data . context || this ; watchedEvents . push ( _data ) ; 
function _watchedEventsBindAll ( context ) { var watchedEvents = getState ( '__watchedEvents' , context ) ; if ( watchedEvents ) { var data ; for ( var name in watchedEvents ) { if ( watchedEvents . hasOwnProperty ( name ) ) { data = watchedEvents [ name ] ; var target = getTarget ( data . target , context ) ; if ( target ) { target [ data . type ] ( data . event , data . callback , data . context ) ; } } } } } 
function _watchedEventsUnbindAll ( keepRegisteredEvents , context ) { var watchedEvents = getState ( '__watchedEvents' , context ) ; if ( watchedEvents ) { var data ; for ( var name in watchedEvents ) { if ( watchedEvents . hasOwnProperty ( name ) ) { data = watchedEvents [ name ] ; var target = getTarget ( data . target , context ) ; if ( target ) { target . off ( data . event , data . callback , data . context ) ; } } } if ( ! keepRegisteredEvents ) { setState ( { __watchedEvents : [ ] } , context ) ; } } } 
function createHandler ( event , callback , context , dontWrapCallback ) { if ( ! dontWrapCallback ) { var _callback = callback , noArg ; if ( typeof callback === 'object' ) { 
function ( identifier , optionsOrHandler ) { if ( typeof optionsOrHandler !== 'function' ) { 
function ( ) { var args = Array . prototype . slice . call ( arguments ) , target = this ; 
function ( target , ev , callback , context ) { var data = ev ? { event : ev , callback : callback , target : target , context : context } : target ; manageEvent . call ( this , 'on' , data ) ; } 
function S3Receiver ( s3ClientOpts ) { s3ClientOpts = s3ClientOpts || { } ; s3ClientOpts = _ . extend ( { } , globalOpts , s3ClientOpts ) ; var wasMaxBytesPerUpstreamQuotaExceeded ; var wasMaxBytesPerFileQuotaExceeded ; var maxBytesPerUpstream = s3ClientOpts . maxBytes || undefined ; var maxBytesPerFile = s3ClientOpts . maxBytesPerFile || undefined ; var receiver = Writable ( { objectMode : true } ) ; receiver . once ( 'error' , ( unusedErr ) => { 
function _stripKeysWithUndefinedValues ( dictionary ) { for ( let k in dictionary ) { if ( dictionary [ k ] === undefined ) { delete dictionary [ k ] ; } } return dictionary ; } 
function _buildS3Client ( s3ClientOpts ) { var s3ConstructorArgins = _stripKeysWithUndefinedValues ( { apiVersion : '2006-03-01' , region : s3ClientOpts . region , accessKeyId : s3ClientOpts . key , secretAccessKey : s3ClientOpts . secret , endpoint : s3ClientOpts . endpoint } ) ; return new AWS . S3 ( s3ConstructorArgins ) ; } 
function _uploadFile ( incomingFd , incomingFileStream , handleProgress , s3ClientOpts , done ) { 
function getParameterValue ( parameter , context ) { var path = parameter . path || parameter ; var value = ( path [ 0 ] === '.' ) ? JSPath . apply ( path , context ) : path ; 
function faultHandler ( context , error ) { debug ( 'default errorHandler: %s' , error . stack ? error . stack : error . message ) ; if ( context . response ) { context . response . statusCode = 500 ; context . response . end ( error . message ) ; } } 
function normalizeProtocol ( protocol ) { if ( protocol && protocol . length > 0 && protocol . charAt ( protocol . length - 1 ) !== ':' ) { return protocol + ':' } return protocol } 
function grabTheRightIcon ( rawText ) { 
function safeBody ( body ) { if ( Array . isArray ( body ) ) { return body ; } return Object . keys ( body ) . sort ( ) . map ( idx => body [ idx ] ) ; } 
function buildSvg ( path , { size : { width , height } , VIEW_BOX } , pathOptions ) { const svgOptions = { viewBox : ` ${ VIEW_BOX } ${ VIEW_BOX } ` , 'shape-rendering' : 'optimizeSpeed' , } ; const svgOptionsStr = Object . entries ( svgOptions ) . map ( ( [ key , value ] ) => ` ${ key } ${ encodeURIComponent ( value ) } ` ) . join ( ' ' ) ; const pathOptionsStr = Object . entries ( pathOptions ) . map ( ( [ key , value ] ) => ` ${ key } ${ encodeURIComponent ( value ) } ` ) . join ( ' ' ) ; const svg = ` ${ width } ${ height } ${ svgOptionsStr } ${ pathOptionsStr } ${ path } ` ; const sprite = Sprite . fromImage ( ` ${ svg } ` ) ; sprite . _generatedSvgTexture = true ; return sprite ; } 
function readFile ( inPath , useHeader , regex ) { var index = 0 ; var outData = [ ] ; var readStream = fs . createReadStream ( inPath ) . pipe ( split ( ) ) . on ( 'data' , function ( line ) { line = line . toString ( ) . match ( regex ) ; if ( line ) { if ( useHeader && index == 0 ) { setHeaderRowAsKeys ( line ) ; } else if ( useHeader ) { 
function requestPromise ( options ) { return new Promise ( ( resolve , reject ) => { request ( options , ( error , response ) => { if ( ! error && response . statusCode === 200 ) { resolve ( response ) ; } else if ( error ) { reject ( error ) ; } else { reject ( new Error ( ` ${ response . statusCode } ` ) ) ; } } ) ; } ) ; } 
function prettify ( result ) { const collection = { } ; Object . keys ( result ) . forEach ( key => { const readableKey = aliases [ key ] ; let value = result [ key ] ; if ( key === 'published' ) { value = moment ( value ) . format ( 'LLL' ) ; } if ( key === 'propertiesCount' ) { const array = [ ] ; value . forEach ( item => { array . push ( [ item . property , item . count ] ) ; } ) ; if ( array . length !== 0 ) { value = array . join ( '\n' ) . replace ( / , / g , ': ' ) ; } } if ( KEY_BYTE . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.0b' ) . replace ( / ^0\.0B$ / , '0' ) ; } if ( KEY_PERCENT . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.0%' ) . replace ( / ^0\.0%$ / , '0' ) ; } if ( KEY_NUMBER . indexOf ( key ) !== - 1 ) { value = numeral ( value ) . format ( '0.000' ) ; } if ( Array . isArray ( value ) ) { const maxLen = 64 ; value = value . map ( val => { if ( val . length > maxLen ) { return ` ${ val . substring ( 0 , maxLen ) } ` ; } return val ; } ) ; value = value . join ( '\n' ) === '' ? 'N/A' : value . join ( '\n' ) ; } collection [ readableKey ] = value ; } ) ; return collection ; } 
function ( name , index , length ) { this . name = name ; this . start = index ; this . length = length ; this . args = [ ] ; } 
function ( isMacroAvailable , usid ) { this . currentDirective = null ; this . matches = [ ] ; this . isMacroAvailable = isMacroAvailable ; this . usid = usid ; this . data = { } ; 
function ( match , value , index , length ) { if ( ! this . currentMacro ) return ; this . currentMacro . args . push ( { start : index + value . length , index : index , length : length , value : value } ) ; } 
function ( obj , from ) { for ( var key in from ) { if ( ! from . hasOwnProperty ( key ) ) continue ; obj [ key ] = from [ key ] ; } return obj ; } 
function ( match , strUntilValue , name , value , index ) { var self = this ; var containsTemplate = false ; 
function getPropType ( propValue ) { const propType = typeof propValue ; if ( Array . isArray ( propValue ) ) { return 'array' ; } if ( propValue instanceof RegExp ) { 
function _getObjectWithFallback ( object , keyProperty , labelProperty ) { if ( hasIn ( object , labelProperty ) ) { return object ; } else if ( hasIn ( object , keyProperty ) ) { 
function _loadSingleObject ( object , keyProperty , labelProperty , objectLoader ) { if ( hasIn ( object , labelProperty ) ) { 
function loadObjectData ( object , keyProperty , labelProperty , objectLoader , onLoadingStart = ( ) => { } , onLoadingEnd = ( ) => { } ) { if ( isNil ( object ) ) { return Promise . resolve ( object ) ; } 
function getTotalCount ( response ) { let range = response . headers [ 'content-range' ] ; let index = range . indexOf ( '/' ) ; let totalCount = range . substring ( index + 1 ) ; return parseInt ( totalCount , 10 ) ; } 
function showMessage ( message , messageBtn ) { var uiMessage = document . querySelectorAll ( message ) , uiMessageBtn = document . querySelectorAll ( messageBtn ) , timeOut = 2000 , 
function uiMessage ( ) { 
function ( err ) { notify . onError ( { title : "Error in " + err . plugin , message : err . message } ) ( err ) ; this . emit ( 'end' ) ; } 
function default_headers ( class_context ) { class_context = class_context || { } ; let headers = { } ; if ( class_context . token ) { headers . Token = class_context . token ; } if ( ! isBrowser ) { headers [ 'User-Agent' ] = ` ${ pkg . version } ` ; } return headers ; } 
function version ( ) { const url = ` ${ config . api_url } ` ; const method = 'GET' ; const headers = default_headers ( ) ; const options = Object . assign ( { } , headers , { url , method } ) ; return request ( options ) ; } 
function getTokenByName ( account , device_id , names = null ) { return co ( function * ( ) { const tokens = yield account . devices . tokenList ( device_id ) ; if ( ! tokens || ! tokens [ 0 ] ) return ; let token ; if ( names ) { names = Array . isArray ( names ) ? names : [ names ] ; for ( const name of names ) { token = tokens . find ( ( token ) => token . name . indexOf ( name ) >= 0 ) ; if ( token ) break ; } } else { token = tokens [ 0 ] ; } if ( ! token ) throw ` ${ device_id } ${ names } ` ; return token . token ; } ) . catch ( ( error ) => { throw error ; } ) ; } 
function env_to_obj ( environment ) { return environment . reduce ( ( pv , cv ) => { pv [ cv . key ] = cv . value ; return pv ; } , { } ) ; } 
function index ( dragHandlerEl ) { var opt = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; if ( opt . minTranslate == null ) { opt . minTranslate = 10 ; } var store = getPureStore ( ) ; var destroy = function destroy ( ) { DragEventService . off ( dragHandlerEl , 'end' , dragHandlerEl . _draggbleEventHandler ) ; hp . offDOM ( dragHandlerEl , 'selectstart' , preventSelect ) ; delete dragHandlerEl . _draggbleEventHandler ; } ; if ( dragHandlerEl . _draggbleEventHandler ) { destroy ( ) ; } dragHandlerEl . _draggbleEventHandler = start ; DragEventService . on ( dragHandlerEl , 'start' , dragHandlerEl . _draggbleEventHandler ) ; hp . onDOM ( dragHandlerEl , 'selectstart' , preventSelect ) ; return destroy ; function start ( e , mouse ) { 
function makeNext ( browser ) { return function next ( code ) { exitCode += code ; currentRun ++ ; if ( code === 0 ) { 
function ( options ) { var self = this if ( ! ( self instanceof Device ) ) return new Device ( options ) EventEmitter . call ( self ) self . config = options self . host = self . config . addresses [ 0 ] self . _playing = false } 
function ( ) { var buildRequest = buildJSONRequest . bind ( this ) ; if ( arguments . length == 2 ) { 
function ( baseURL , relativeURL , opts ) { opts = opts || { } ; 
function getLongestArray ( arrays ) { var lengths = arrays . map ( array => array . length ) return Math . max . apply ( null , lengths ) } 
function rejectAfter ( milliseconds , errorMessage ) { return new Promise ( ( resolve , reject ) => { later ( reject , new Error ( errorMessage ) , milliseconds ) ; } ) ; } 
function loadScript ( src ) { return new Promise ( resolve => { const script = document . createElement ( 'script' ) ; script . onload = resolve ; script . src = src ; document . head . appendChild ( script ) ; } ) ; } 
function loadStylesheet ( href ) { return new Promise ( resolve => { const link = document . createElement ( 'link' ) ; link . onload = resolve ; link . rel = 'stylesheet' link . type = 'text/css' ; link . href = href ; document . head . appendChild ( link ) ; } ) ; } 
function md5crypt ( password , salt , magic ) { var rearranged = '' , mixin , final , m , v , i ; m = crypto . createHash ( 'md5' ) ; m . update ( password + magic + salt ) ; mixin = crypto . createHash ( 'md5' ) . update ( password + salt + password ) . digest ( "binary" ) ; for ( i = 0 ; i < password . length ; i ++ ) { m . update ( mixin [ i % 16 ] ) ; } 
function deploy ( req , res ) { var stackName = req . params . stack , regionName = req . params . region , name = req . remoteUser . name ; function _deploy ( to_revision ) { async . waterfall ( [ dreadnot . deploy . bind ( dreadnot , stackName , regionName , to_revision , name ) , function ( number , callback ) { dreadnot . getDeploymentSummary ( stackName , regionName , number , callback ) ; } ] , res . respond ) ; } 
function saveWarning ( req , res ) { var text = req . body . action === 'save' ? req . body . warning_text : '' ; dreadnot . setWarning ( req . remoteUser , text , function ( err ) { if ( err ) { res . respond ( err ) ; } else { getWarning ( req , res ) ; } } ) ; } 
function handleError ( err , req , res ) { switch ( err . name ) { case 'NotFoundError' : res . send ( err , 404 ) ; break ; default : res . send ( err , 500 ) ; } } 
function responseCallback ( req , res ) { return function ( err , data ) { if ( err ) { handleError ( err , req , res ) ; } else { res . send ( data ) ; } } ; } 
function CloudMonitoring ( options , log ) { this . _options = options ; this . log = log || logmagic . local ( 'cloudmonitoring' ) ; this . defaultSuppressionDuration = options . defaultSuppressionDuration || DEFAULT_SUPPRESSION_DURATION ; this . monitoringApiUri = options . monitoringApiUri || DEFAULT_MONITORING_API_URI ; this . keystoneClient = new KeystoneClient ( options . authUri || DEFAULT_AUTH_URI , { username : options . username , apiKey : options . apiKey } ) ; } 
function Nagios ( options , log ) { var parsed = url . parse ( options . url ) ; 
function NewRelic ( license_key , options , log ) { this . url = "https://api.newrelic.com" ; this . _options = options ; this . license_key = license_key ; if ( ! this . _options . hasOwnProperty ( 'user' ) ) { this . _options [ 'user' ] = 'dreadnot' ; } this . log = log || logmagic . local ( 'sensu' ) ; } 
function PagerDuty ( options , log ) { var parsed = url . parse ( options . url ) ; delete parsed . host ; this . url = url . format ( parsed ) ; this . users = options . users ; this . schedules = options . schedules ; this . log = log || logmagic . local ( 'pagerduty' ) ; this . pagerduty_auth = sprintf ( 'Token token=%s' , options . password ) ; } 
function Stack ( name , dreadnot , config ) { var self = this , logName = sprintf ( 'deploy.stack.%s' , name ) , sinkName = sprintf ( 'stack.%s' , name ) , moduleName ; if ( config . stacks [ name ] . hasOwnProperty ( 'module_name' ) ) { moduleName = config . stacks [ name ] . module_name ; } else { moduleName = name ; } this . name = name ; this . dreadnot = dreadnot ; this . module = require ( path . join ( path . resolve ( dreadnot . stackdir ) , moduleName ) ) ; this . config = config ; this . stackConfig = config . stacks [ name ] ; this . log = logmagic . local ( logName ) ; this . logRoot = path . join ( config . data_root , 'logs' , name ) ; this . newestDeployments = { } ; this . repo = this . stackConfig . repo || name ; this . current = null ; this . _cache = { } ; this . _waiting = { } ; logmagic . registerSink ( sinkName , function ( moduleName , lvl , msg , obj ) { var both = moduleName . split ( '.' ) . slice ( - 2 ) , logPath = [ 'regions' , both [ 0 ] , 'deployments' , both [ 1 ] , 'log' ] . join ( '.' ) ; 
function Graphite ( host , port , eventPort , secure , log ) { this . client = graphite . createClient ( sprintf ( 'plaintext://%s:%s/' , host , port ) ) ; this . secure = secure ; this . host = host ; this . port = port ; this . eventPort = eventPort ; this . log = log || logmagic . local ( 'graphite' ) ; } 
function render ( req , res , template , data , options ) { res . render ( template , misc . merge ( { user : req . remoteUser , title : dreadnot . config . name , env : dreadnot . config . env , url : req . originalUrl , emsg : res . emsg , wmsg : dreadnot . warning , helpers : viewHelpers , data : data } , options || { } ) ) ; } 
function handleError ( req , res , err ) { switch ( err . name ) { case 'NotFoundError' : render ( req , res , 'error' , err , { status : 404 } ) ; break ; default : render ( req , res , 'error' , err , { status : 500 } ) ; } } 
function renderCallback ( req , res , template ) { return function ( err , data ) { if ( err ) { handleError ( req , res , err ) ; } else { render ( req , res , template , data ) ; } } ; } 
function getLogin ( req , res ) { var next = req . param ( 'next' ) ; render ( req , res , 'login.jade' , { next : next } ) ; } 
function attemptLogin ( req , res ) { var username = req . param ( 'username' ) , password = req . param ( 'password' ) , next = req . param ( 'next' , '/' ) ; authdb . validate ( username , password , function ( err , valid ) { if ( valid ) { req . session . authed = true ; req . session . username = username ; res . redirect ( next ) ; } else { res . emsg = 'Invalid Username or Password' ; render ( req , res , 'login.jade' , { next : next } ) ; } } ) ; } 
function getStacks ( req , res ) { var data = { } ; async . auto ( { stacks : function ( callback ) { dreadnot . getStackSummaries ( function ( err , stacks ) { data . stacks = stacks ; callback ( err ) ; } ) ; } , regions : [ 'stacks' , function ( callback ) { async . forEach ( data . stacks , function ( stack , callback ) { dreadnot . getRegionSummaries ( stack . name , function ( err , regions ) { if ( err ) { callback ( err ) ; return ; } stack . regions = regions ; async . forEach ( stack . regions , function ( region , callback ) { 
function getDeployments ( req , res ) { async . parallel ( { stack : dreadnot . getStackSummary . bind ( dreadnot , req . params . stack ) , region : dreadnot . getRegionSummary . bind ( dreadnot , req . params . stack , req . params . region ) , deployments : dreadnot . getDeploymentSummaries . bind ( dreadnot , req . params . stack , req . params . region ) } , renderCallback ( req , res , 'deployments.jade' ) ) ; } 
function getDeployment ( req , res ) { async . parallel ( { stack : dreadnot . getStackSummary . bind ( dreadnot , req . params . stack ) , region : dreadnot . getRegionSummary . bind ( dreadnot , req . params . stack , req . params . region ) , deployment : dreadnot . getDeploymentSummary . bind ( dreadnot , req . params . stack , req . params . region , req . params . deployment ) } , renderCallback ( req , res , 'deployment.jade' ) ) ; } 
function deploy ( req , res ) { var stackName = req . params . stack , regionName = req . params . region , to = req . body . to_revision , user ; dreadnot . deploy ( stackName , regionName , to , req . remoteUser . name , function ( err , number ) { if ( err ) { res . respond ( err ) ; return ; } else { res . redirect ( sprintf ( '/stacks/%s/regions/%s/deployments/%s' , stackName , regionName , number ) ) ; } } ) ; } 
function Jenkins ( options , log ) { var parsed = url . parse ( options . url ) ; if ( options . username && options . password ) { parsed [ 'auth' ] = util . format ( '%s:%s' , options . username , options . password ) ; } this . _url = url . format ( parsed ) ; this . _options = options ; this . log = log || logmagic . local ( 'jenkins' ) ; } 
function Document ( options ) { Repository . call ( this , options ) ; options = options || { } ; var defaultConf = { host : 'https://nubiz-opensource.documents.azure.com:443/' , masterKey : '1A5vuEdjyl3zrqxuMASlB/4QGwllQsIroyrPmVXVslkfnaxYSEvA/H4QUrRCp4IUiG6rOuXUxEHX0SCGfsjPuA==' , dbName : 'node-viewmodel' } ; this . options = _ . defaults ( options , defaultConf ) ; } 
function Repository ( options ) { options = options || { } ; this . repositoryType = ( typeof ( options . type ) === 'string' ) ? options . type : null ; EventEmitter . call ( this ) ; } 
function ( query , queryOptions , callback ) { if ( ! queryOptions ) { callback = query ; query = { } ; queryOptions = { } ; } else if ( ! callback ) { callback = queryOptions ; queryOptions = { } ; } this . find ( query , queryOptions , function ( err , items ) { if ( err ) { return callback ( err ) ; } callback ( null , items [ 0 ] ) ; } ) ; } 
function ( obj ) { var res = _ . assign ( _ . assign ( { } , this ) , obj ) ; for ( var f in this ) { if ( _ . isFunction ( this [ f ] ) ) { res [ f ] = this [ f ] ; } } if ( _ . isFunction ( res . checkConnection ) ) { res . checkConnection ( ) ; } return res ; } 
function generateEntity ( obj ) { var entity = _ . clone ( obj ) ; for ( var property in entity ) { if ( property !== '_metadata' ) { if ( _ . isArray ( entity [ property ] ) ) { entity [ property ] = eg . String ( JSON . stringify ( entity [ property ] ) ) ; continue ; } if ( _ . isBoolean ( entity [ property ] ) ) { entity [ property ] = eg . Boolean ( entity [ property ] ) ; continue ; } if ( _ . isDate ( entity [ property ] ) ) { entity [ property ] = eg . DateTime ( entity [ property ] ) ; continue ; } if ( _ . isString ( entity [ property ] ) ) { entity [ property ] = eg . String ( entity [ property ] ) ; continue ; } if ( _ . isObject ( entity [ property ] ) ) { entity [ property ] = eg . String ( JSON . stringify ( entity [ property ] ) ) ; continue ; } entity [ property ] = eg . Entity ( entity [ property ] ) ; } } return entity ; } 
function AzureTable ( options ) { Repository . call ( this , options ) ; options = options || { } ; var azureConf = { storageAccount : 'nodeeventstore' , storageAccessKey : 'aXJaod96t980AbNwG9Vh6T3ewPQnvMWAn289Wft9RTv+heXQBxLsY3Z4w66CI7NN12+1HUnHM8S3sUbcI5zctg==' , storageTableHost : 'https://nodeeventstore.table.core.windows.net/' } ; this . options = _ . defaults ( options , azureConf ) ; } 
function ViewModel ( attr , repository , version ) { if ( ! repository ) { var errMsg = 'Please pass in a valid repository' ; console . log ( errMsg ) ; throw new Error ( errMsg ) ; } for ( var f in Repository . prototype ) { if ( ! _ . isFunction ( repository [ f ] ) ) { var errMsg = 'Please pass in a valid repository' ; console . log ( errMsg ) ; throw new Error ( errMsg ) ; } } if ( attr . id ) { this . id = _ . clone ( attr . id ) ; } 
function ( name , func ) { wrapper . prototype [ name ] = function ( ) { var args = slice . call ( arguments ) ; unshift . call ( args , this . _wrapped ) ; return result ( func . apply ( _ , args ) , this . _chain ) ; } ; } 
function ( name , factory ) { 
function ( fn , context ) { return fn . call ( context || global , _ . bind ( r , this ) , _ , this ) ; } 
function ( abbr , syntax , profile , contextNode ) { if ( ! abbr ) return '' ; syntax = syntax || defaultSyntax ; 
function ( ) { if ( global . console && global . console . log ) global . console . log . apply ( global . console , arguments ) ; } 
function ( child , position ) { child = child || new AbbreviationNode ; child . parent = this ; if ( _ . isUndefined ( position ) ) { this . children . push ( child ) ; } else { this . children . splice ( position , 0 , child ) ; } return child ; } 
function ( ) { var node = new AbbreviationNode ( ) ; var attrs = [ 'abbreviation' , 'counter' , '_name' , '_text' , 'repeatCount' , 'hasImplicitRepeat' , 'start' , 'end' , 'content' , 'padding' ] ; _ . each ( attrs , function ( a ) { node [ a ] = this [ a ] ; } , this ) ; 
function ( ) { var parent = this . parent ; var ix = _ . indexOf ( parent . children , this ) ; var items = _ . flatten ( arguments ) ; spliceFn . apply ( parent . children , [ ix , 1 ] . concat ( items ) ) ; 
function ( name , value ) { this [ name ] = value ; _ . each ( this . children , function ( child ) { child . updateProperty ( name , value ) ; } ) ; return this ; } 
function ( fn ) { if ( ! _ . isFunction ( fn ) ) { var elemName = fn . toLowerCase ( ) ; fn = function ( item ) { return item . name ( ) . toLowerCase ( ) == elemName ; } ; } var result = [ ] ; _ . each ( this . children , function ( child ) { if ( fn ( child ) ) result . push ( child ) ; result = result . concat ( child . findAll ( fn ) ) ; } ) ; return _ . compact ( result ) ; } 
function ( name , value ) { if ( arguments . length == 2 ) { this . _data [ name ] = value ; if ( name == 'resource' && require ( 'elements' ) . is ( value , 'snippet' ) ) { 
function ( ) { var attrs = [ ] ; var res = this . matchedResource ( ) ; if ( require ( 'elements' ) . is ( res , 'element' ) && _ . isArray ( res . attributes ) ) { attrs = attrs . concat ( res . attributes ) ; } return optimizeAttributes ( attrs . concat ( this . _attributes ) ) ; } 
function ( name , value ) { if ( arguments . length == 2 ) { 
function ( ) { var utils = require ( 'utils' ) ; var start = this . start ; var end = this . end ; var content = this . content ; 
function ( ) { if ( ! this . children . length ) return null ; var deepestChild = this ; while ( deepestChild . children . length ) { deepestChild = _ . last ( deepestChild . children ) ; } return deepestChild ; } 
function parseAbbreviation ( abbr ) { abbr = require ( 'utils' ) . trim ( abbr ) ; var root = new AbbreviationNode ; var context = root . addChild ( ) , ch ; var stream = require ( 'stringStream' ) . create ( abbr ) ; var loopProtector = 1000 , multiplier ; while ( ! stream . eol ( ) && -- loopProtector > 0 ) { ch = stream . peek ( ) ; switch ( ch ) { case '(' : 
function extractAttributes ( attrSet , attrs ) { attrSet = require ( 'utils' ) . trim ( attrSet ) ; var result = [ ] ; var stream = require ( 'stringStream' ) . create ( attrSet ) ; stream . eatSpace ( ) ; while ( ! stream . eol ( ) ) { stream . start = stream . pos ; if ( stream . eatWhile ( reWord ) ) { var attrName = stream . current ( ) ; var attrValue = '' ; if ( stream . peek ( ) == '=' ) { stream . next ( ) ; stream . start = stream . pos ; var quote = stream . peek ( ) ; if ( quote == '"' || quote == "'" ) { stream . next ( ) ; if ( consumeQuotedValue ( stream , quote ) ) { attrValue = stream . current ( ) ; 
function unroll ( node ) { for ( var i = node . children . length - 1 , j , child , maxCount ; i >= 0 ; i -- ) { child = node . children [ i ] ; if ( child . isRepeating ( ) ) { maxCount = j = child . repeatCount ; child . repeatCount = 1 ; child . updateProperty ( 'counter' , 1 ) ; child . updateProperty ( 'maxCount' , maxCount ) ; while ( -- j > 0 ) { child . parent . addChild ( child . clone ( ) , i + 1 ) . updateProperty ( 'counter' , j + 1 ) . updateProperty ( 'maxCount' , maxCount ) ; } } } 
function squash ( node ) { for ( var i = node . children . length - 1 ; i >= 0 ; i -- ) { var n = node . children [ i ] ; if ( n . isGroup ( ) ) { n . replace ( squash ( n ) . children ) ; } else if ( n . isEmpty ( ) ) { n . remove ( ) ; } } _ . each ( node . children , squash ) ; return node ; } 
function ( abbr , options ) { options = options || { } ; var tree = parseAbbreviation ( abbr ) ; if ( options . contextNode ) { 
function locateOutputPlaceholder ( text ) { var range = require ( 'range' ) ; var result = [ ] ; var stream = require ( 'stringStream' ) . create ( text ) ; while ( ! stream . eol ( ) ) { if ( stream . peek ( ) == '\\' ) { stream . next ( ) ; } else { stream . start = stream . pos ; if ( stream . match ( outputPlaceholder , true ) ) { result . push ( range . create ( stream . start , outputPlaceholder ) ) ; continue ; } } stream . next ( ) ; } return result ; } 
function replaceOutputPlaceholders ( source , value ) { var utils = require ( 'utils' ) ; var ranges = locateOutputPlaceholder ( source ) ; ranges . reverse ( ) ; _ . each ( ranges , function ( r ) { source = utils . replaceSubstring ( source , value , r ) ; } ) ; return source ; } 
function insertPastedContent ( node , content , overwrite ) { var nodesWithPlaceholders = node . findAll ( function ( item ) { return hasOutputPlaceholder ( item ) ; } ) ; if ( hasOutputPlaceholder ( node ) ) nodesWithPlaceholders . unshift ( node ) ; if ( nodesWithPlaceholders . length ) { _ . each ( nodesWithPlaceholders , function ( item ) { item . content = replaceOutputPlaceholders ( item . content , content ) ; _ . each ( item . _attributes , function ( attr ) { attr . value = replaceOutputPlaceholders ( attr . value , content ) ; } ) ; } ) ; } else { 
function tokener ( value , type , conf ) { var w = walker , c = conf || { } ; tokens . push ( { charstart : isset ( c [ 'char' ] ) ? c [ 'char' ] : w . chnum , charend : isset ( c . charend ) ? c . charend : w . chnum , linestart : isset ( c . line ) ? c . line : w . linenum , lineend : isset ( c . lineend ) ? c . lineend : w . linenum , value : value , type : type || value } ) ; } 
function error ( m , config ) { var w = walker , conf = config || { } , c = isset ( conf [ 'char' ] ) ? conf [ 'char' ] : w . chnum , l = isset ( conf . line ) ? conf . line : w . linenum ; return { name : "ParseError" , message : m + " at line " + ( l + 1 ) + ' char ' + ( c + 1 ) , walker : w , tokens : tokens } ; } 
function white ( ) { var c = walker . ch , token = '' , conf = getConf ( ) ; while ( c === " " || c === "\t" ) { token += c ; c = walker . nextChar ( ) ; } tokener ( token , 'white' , conf ) ; } 
function tokenize ( ) { var ch = walker . ch ; if ( ch === " " || ch === "\t" ) { return white ( ) ; } if ( ch === '/' ) { return comment ( ) ; } if ( ch === '"' || ch === "'" ) { return str ( ) ; } if ( ch === '(' ) { return brace ( ) ; } if ( ch === '-' || ch === '.' || isDigit ( ch ) ) { 
function getNewline ( content , pos ) { return content . charAt ( pos ) == '\r' && content . charAt ( pos + 1 ) == '\n' ? '\r\n' : content . charAt ( pos ) ; } 
function ( source ) { 
function ( ) { var res = require ( 'resources' ) ; if ( ! res ) { return '\n' ; } var nl = res . getVariable ( 'newline' ) ; return _ . isString ( nl ) ? nl : '\n' ; } 
function ( str , howMany ) { var result = [ ] ; for ( var i = 0 ; i < howMany ; i ++ ) result . push ( str ) ; return result . join ( '' ) ; } 
function ( strings ) { var lengths = _ . map ( strings , function ( s ) { return _ . isString ( s ) ? s . length : + s ; } ) ; var max = _ . max ( lengths ) ; return _ . map ( lengths , function ( l ) { var pad = max - l ; return pad ? this . repeatString ( ' ' , pad ) : '' ; } , this ) ; } 
function ( text , pad ) { var padStr = ( _ . isNumber ( pad ) ) ? this . repeatString ( require ( 'resources' ) . getVariable ( 'indentation' ) || '\t' , pad ) : pad ; var result = [ ] ; var lines = this . splitByLines ( text ) ; var nl = this . getNewline ( ) ; result . push ( lines [ 0 ] ) ; for ( var j = 1 ; j < lines . length ; j ++ ) result . push ( nl + padStr + lines [ j ] ) ; return result . join ( '' ) ; } 
function ( text , pad ) { var lines = this . splitByLines ( text ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . search ( pad ) == 0 ) lines [ i ] = lines [ i ] . substr ( pad . length ) ; } return lines . join ( this . getNewline ( ) ) ; } 
function ( str , symbol , replace ) { var i = 0 ; var il = str . length ; var sl = symbol . length ; var matchCount = 0 ; while ( i < il ) { if ( str . charAt ( i ) == '\\' ) { 
function ( str , vars ) { vars = vars || { } ; var resolver = _ . isFunction ( vars ) ? vars : function ( str , p1 ) { return p1 in vars ? vars [ p1 ] : null ; } ; var res = require ( 'resources' ) ; return require ( 'tabStops' ) . processText ( str , { variable : function ( data ) { var newValue = resolver ( data . token , data . name , data ) ; if ( newValue === null ) { 
function ( str , value , start , end ) { if ( _ . isObject ( start ) && 'end' in start ) { end = start . end ; start = start . start ; } if ( _ . isString ( end ) ) end = start + end . length ; if ( _ . isUndefined ( end ) ) end = start ; if ( start < 0 || start > str . length ) return str ; return str . substring ( 0 , start ) + value + str . substring ( end ) ; } 
function ( text , start , end ) { var range = require ( 'range' ) . create ( start , end ) ; var reSpace = / [\s\n\r\u00a0] / ; 
function ( text , from ) { var len = text . length , start = 0 , end = len - 1 ; 
function ( start , len ) { if ( _ . isUndefined ( start ) || start === null ) return null ; if ( start instanceof Range ) return start ; if ( _ . isObject ( start ) && 'start' in start && 'end' in start ) { len = start . end - start . start ; start = start . start ; } return new Range ( start , len ) ; } 
function ( start , end ) { if ( _ . isNumber ( start ) && _ . isNumber ( end ) ) { end -= start ; } return this . create ( start , end ) ; } 
function ( fn , options ) { this . _list . push ( _ . extend ( { order : 0 } , options || { } , { fn : fn } ) ) ; } 
function ( fn ) { this . _list = _ . without ( this . _list , _ . find ( this . _list , function ( item ) { return item . fn === fn ; } ) ) ; } 
function ( skipValue , args ) { args = args || [ ] ; var result = null ; _ . find ( this . list ( ) , function ( h ) { result = h . fn . apply ( h , args ) ; if ( result !== skipValue ) return true ; } ) ; return result ; } 
function ( open , close ) { var braceCount = 0 , ch ; var pos = this . pos , len = this . string . length ; while ( pos < len ) { ch = this . string . charAt ( pos ++ ) ; if ( ch == open ) { braceCount ++ ; } else if ( ch == close ) { braceCount -- ; if ( braceCount < 1 ) { this . pos = pos ; return true ; } } } return false ; } 
function ( pattern , consume , caseInsensitive ) { if ( typeof pattern == "string" ) { var cased = caseInsensitive ? function ( str ) { return str . toLowerCase ( ) ; } : function ( str ) { return str ; } ; if ( cased ( this . string ) . indexOf ( cased ( pattern ) , this . pos ) == this . pos ) { if ( consume !== false ) this . pos += pattern . length ; return true ; } } else { var match = this . string . slice ( this . pos ) . match ( pattern ) ; if ( match && consume !== false ) this . pos += match [ 0 ] . length ; return match ; } } 
function ( node , syntax ) { return resolvers . exec ( null , _ . toArray ( arguments ) ) || this . findSnippet ( syntax , node . name ( ) ) ; } 
function ( name ) { if ( ! name ) return null ; if ( ! ( name in cache ) ) { cache [ name ] = require ( 'utils' ) . deepMerge ( { } , systemSettings [ name ] , userSettings [ name ] ) ; } var data = cache [ name ] , subsections = _ . rest ( arguments ) , key ; while ( data && ( key = subsections . shift ( ) ) ) { if ( key in data ) { data = data [ key ] ; } else { return null ; } } return data ; } 
function ( syntax , name , memo ) { if ( ! syntax || ! name ) return null ; memo = memo || [ ] ; var names = [ name ] ; 
function ( syntax , name , minScore ) { minScore = minScore || 0.3 ; var payload = this . getAllSnippets ( syntax ) ; var sc = require ( 'string-score' ) ; name = normalizeName ( name ) ; var scores = _ . map ( payload , function ( value , key ) { return { key : key , score : sc . score ( value . nk , name , 0.1 ) } ; } ) ; var result = _ . last ( _ . sortBy ( scores , 'score' ) ) ; if ( result && result . score >= minScore ) { var k = result . key ; return payload [ k ] . parsedValue ; 
function humanizeActionName ( name ) { return require ( 'utils' ) . trim ( name . charAt ( 0 ) . toUpperCase ( ) + name . substring ( 1 ) . replace ( / _[a-z] / g , function ( str ) { return ' ' + str . charAt ( 1 ) . toUpperCase ( ) ; } ) ) ; } 
function ( name , fn , options ) { name = name . toLowerCase ( ) ; options = options || { } ; if ( ! options . label ) { options . label = humanizeActionName ( name ) ; } actions [ name ] = { name : name , fn : fn , options : options } ; } 
function ( name , args ) { if ( ! _ . isArray ( args ) ) { args = _ . rest ( arguments ) ; } var action = this . get ( name ) ; if ( action ) { return action . fn . apply ( emmet , args ) ; } else { emmet . log ( 'Action "%s" is not defined' , name ) ; return false ; } } 
function ( title , menu ) { var item = null ; _ . find ( menu || this . getMenu ( ) , function ( val ) { if ( val . type == 'action' ) { if ( val . label == title || val . name == title ) { return item = val . name ; } } else { return item = this . getActionNameForMenuTitle ( title , val . items ) ; } } , this ) ; return item || null ; } 
function ( name , syntax ) { if ( ! name && syntax ) { 
function ( editor ) { var allowedSyntaxes = { 'html' : 1 , 'xml' : 1 , 'xsl' : 1 } ; var syntax = String ( editor . getSyntax ( ) ) ; if ( syntax in allowedSyntaxes ) { var content = String ( editor . getContent ( ) ) ; var tag = require ( 'htmlMatcher' ) . find ( content , editor . getCaretPos ( ) ) ; if ( tag && tag . type == 'tag' ) { var startTag = tag . open ; var contextNode = { name : startTag . name , attributes : [ ] } ; 
function ( editor , fn ) { var content = String ( editor . getContent ( ) ) ; var il = content . length ; var exprStart = editor . getCaretPos ( ) - 1 ; var exprEnd = exprStart + 1 ; 
function ( editor , hint ) { var syntax = hint || 'html' ; if ( ! require ( 'resources' ) . hasSyntax ( syntax ) ) { syntax = 'html' ; } if ( syntax == 'html' && ( this . isStyle ( editor ) || this . isInlineCSS ( editor ) ) ) { syntax = 'css' ; } return syntax ; } 
function ( editor ) { var syntax = editor . getSyntax ( ) ; 
function ( editor ) { var content = String ( editor . getContent ( ) ) ; var caretPos = editor . getCaretPos ( ) ; var tag = require ( 'htmlMatcher' ) . tag ( content , caretPos ) ; return tag && tag . open . name . toLowerCase ( ) == 'style' && tag . innerRange . cmp ( caretPos , 'lte' , 'gte' ) ; } 
function ( editor ) { var content = String ( editor . getContent ( ) ) ; var caretPos = editor . getCaretPos ( ) ; var tree = require ( 'xmlEditTree' ) . parseFromPosition ( content , caretPos , true ) ; if ( tree ) { var attr = tree . itemFromPosition ( caretPos , true ) ; return attr && attr . name ( ) . toLowerCase ( ) == 'style' && attr . valueRange ( true ) . cmp ( caretPos , 'lte' , 'gte' ) ; } return false ; } 
function ( node ) { if ( node . children . length || node . _text || this . isSnippet ( node ) ) { return false ; } var r = node . matchedResource ( ) ; return r && r . is_empty ; } 
function ( node ) { return ( this . hasTagsInContent ( node ) && this . isBlock ( node ) ) || _ . any ( node . children , function ( child ) { return this . isBlock ( child ) ; } , this ) ; } 
function ( text , childContent , options ) { options = _ . extend ( { keepVariable : true , appendIfNoChild : true } , options || { } ) ; var childVariableReplaced = false ; var utils = require ( 'utils' ) ; text = utils . replaceVariables ( text , function ( variable , name , data ) { var output = variable ; if ( name == 'child' ) { 
function ( input ) { var output = [ ] ; var chr1 , chr2 , chr3 , enc1 , enc2 , enc3 , enc4 , cdp1 , cdp2 , cdp3 ; var i = 0 , il = input . length , b64 = chars ; while ( i < il ) { cdp1 = input . charCodeAt ( i ++ ) ; cdp2 = input . charCodeAt ( i ++ ) ; cdp3 = input . charCodeAt ( i ++ ) ; chr1 = cdp1 & 0xff ; chr2 = cdp2 & 0xff ; chr3 = cdp3 & 0xff ; enc1 = chr1 >> 2 ; enc2 = ( ( chr1 & 3 ) << 4 ) | ( chr2 >> 4 ) ; enc3 = ( ( chr2 & 15 ) << 2 ) | ( chr3 >> 6 ) ; enc4 = chr3 & 63 ; if ( isNaN ( cdp2 ) ) { enc3 = enc4 = 64 ; } else if ( isNaN ( cdp3 ) ) { enc4 = 64 ; } output . push ( b64 . charAt ( enc1 ) + b64 . charAt ( enc2 ) + b64 . charAt ( enc3 ) + b64 . charAt ( enc4 ) ) ; } return output . join ( '' ) ; } 
function ( data ) { var o1 , o2 , o3 , h1 , h2 , h3 , h4 , bits , i = 0 , ac = 0 , tmpArr = [ ] ; var b64 = chars , il = data . length ; if ( ! data ) { return data ; } data += '' ; do { 
function createMatcher ( text ) { var memo = { } , m ; return { open : function ( i ) { var m = this . matches ( i ) ; return m && m . type == 'open' ? m : null ; } , close : function ( i ) { var m = this . matches ( i ) ; return m && m . type == 'close' ? m : null ; } , matches : function ( i ) { var key = 'p' + i ; if ( ! ( key in memo ) ) { if ( text . charAt ( i ) == '<' ) { var substr = text . slice ( i ) ; if ( m = substr . match ( reOpenTag ) ) { memo [ key ] = openTag ( i , m ) ; } else if ( m = substr . match ( reCloseTag ) ) { memo [ key ] = closeTag ( i , m ) ; } else { * Returns original text * @returns {String} */ text : function ( ) { return text ; } } ; } 
function ( text , options ) { 
function ( node , offset ) { var maxNum = 0 ; var options = { tabstop : function ( data ) { var group = parseInt ( data . group ) ; if ( group > maxNum ) maxNum = group ; if ( data . placeholder ) return '${' + ( group + offset ) + ':' + data . placeholder + '}' ; else return '${' + ( group + offset ) + '}' ; } } ; _ . each ( [ 'start' , 'end' , 'content' ] , function ( p ) { node [ p ] = this . processText ( node [ p ] , options ) ; } , this ) ; return maxNum ; } 
function ( name , value , description ) { var prefs = name ; if ( _ . isString ( name ) ) { prefs = { } ; prefs [ name ] = { value : value , description : description } ; } _ . each ( prefs , function ( v , k ) { defaults [ k ] = isValueObj ( v ) ? v : { value : v } ; } ) ; } 
function ( name , value ) { var prefs = name ; if ( _ . isString ( name ) ) { prefs = { } ; prefs [ name ] = value ; } _ . each ( prefs , function ( v , k ) { if ( ! ( k in defaults ) ) { throw 'Property "' + k + '" is not defined. You should define it first with `define` method of current module' ; } 
function ( name ) { if ( name in preferences ) return preferences [ name ] ; if ( name in defaults ) return defaults [ name ] . value ; return void 0 ; } 
function ( name ) { var val = this . get ( name ) ; if ( _ . isUndefined ( val ) || val === null || val === '' ) { return null ; } val = _ . map ( val . split ( ',' ) , require ( 'utils' ) . trim ) ; if ( ! val . length ) { return null ; } return val ; } 
function ( name ) { var result = { } ; _ . each ( this . getArray ( name ) , function ( val ) { var parts = val . split ( ':' ) ; result [ parts [ 0 ] ] = parts [ 1 ] ; } ) ; return result ; } 
function ( name ) { if ( ! _ . isArray ( name ) ) name = [ name ] ; _ . each ( name , function ( key ) { if ( key in preferences ) delete preferences [ key ] ; if ( key in defaults ) delete defaults [ key ] ; } ) ; } 
function ( tree , filters , profile ) { var utils = require ( 'utils' ) ; profile = require ( 'profile' ) . get ( profile ) ; _ . each ( list ( filters ) , function ( filter ) { var name = utils . trim ( filter . toLowerCase ( ) ) ; if ( name && name in registeredFilters ) { tree = registeredFilters [ name ] ( tree , profile ) ; } } ) ; return tree ; } 
function ( syntax , profile , additionalFilters ) { profile = require ( 'profile' ) . get ( profile ) ; var filters = list ( profile . filters || require ( 'resources' ) . findItem ( syntax , 'filters' ) || basicFilters ) ; if ( profile . extraFilters ) { filters = filters . concat ( list ( profile . extraFilters ) ) ; } if ( additionalFilters ) { filters = filters . concat ( list ( additionalFilters ) ) ; } if ( ! filters || ! filters . length ) { 
function ( value , start , end ) { 
function ( name ) { if ( _ . isNumber ( name ) ) return this . list ( ) [ name ] ; if ( _ . isString ( name ) ) return _ . find ( this . list ( ) , function ( prop ) { return prop . name ( ) === name ; } ) ; return name ; } 
function ( name ) { if ( ! _ . isArray ( name ) ) name = [ name ] ; 
function ( name , value , pos ) { var element = this . get ( name ) ; if ( element ) return element . value ( value ) ; if ( ! _ . isUndefined ( value ) ) { 
function ( name ) { var element = this . get ( name ) ; if ( element ) { this . _updateSource ( '' , element . fullRange ( ) ) ; this . _children = _ . without ( this . _children , element ) ; } } 
function ( val ) { if ( ! _ . isUndefined ( val ) && this . _name !== ( val = String ( val ) ) ) { this . _updateSource ( val , this . _positions . name , this . _positions . name + this . _name . length ) ; this . _name = val ; } return this . _name ; } 
function ( pos , isAbsolute ) { return _ . find ( this . list ( ) , function ( elem ) { return elem . range ( isAbsolute ) . inside ( pos ) ; } ) ; } 
function ( val ) { if ( ! _ . isUndefined ( val ) && this . _value !== ( val = String ( val ) ) ) { this . parent . _updateSource ( val , this . valueRange ( ) ) ; this . _value = val ; } return this . _value ; } 
function ( val ) { if ( ! _ . isUndefined ( val ) && this . _name !== ( val = String ( val ) ) ) { this . parent . _updateSource ( val , this . nameRange ( ) ) ; this . _name = val ; } return this . _name ; } 
function trimWhitespaceTokens ( tokens , mask ) { mask = mask || ( WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END ) ; var whitespace = [ 'white' , 'line' ] ; if ( ( mask & WHITESPACE_REMOVE_FROM_END ) == WHITESPACE_REMOVE_FROM_END ) while ( tokens . length && _ . include ( whitespace , _ . last ( tokens ) . type ) ) { tokens . pop ( ) ; } if ( ( mask & WHITESPACE_REMOVE_FROM_START ) == WHITESPACE_REMOVE_FROM_START ) while ( tokens . length && _ . include ( whitespace , tokens [ 0 ] . type ) ) { tokens . shift ( ) ; } return tokens ; } 
function findSelectorRange ( it ) { var tokens = [ ] , token ; var start = it . position ( ) , end ; while ( token = it . next ( ) ) { if ( token . type == '{' ) break ; tokens . push ( token ) ; } trimWhitespaceTokens ( tokens ) ; if ( tokens . length ) { start = tokens [ 0 ] . start ; end = _ . last ( tokens ) . end ; } else { end = start ; } return range ( start , end - start ) ; } 
function findValueRange ( it ) { 
function findParts ( str ) { var stream = require ( 'stringStream' ) . create ( str ) ; var ch ; var result = [ ] ; var sep = / [\s\u00a0,] / ; var add = function ( ) { stream . next ( ) ; result . push ( range ( stream . start , stream . current ( ) ) ) ; stream . start = stream . pos ; } ; 
function isValidIdentifier ( it ) { 
function ( ) { var start = this . _positions . contentStart ; var source = this . source ; var utils = require ( 'utils' ) ; _ . each ( this . list ( ) , function ( p ) { p . styleBefore = source . substring ( start , p . namePosition ( ) ) ; 
function ( isAbsolute ) { var parts = findParts ( this . value ( ) ) ; if ( isAbsolute ) { var offset = this . valuePosition ( true ) ; _ . each ( parts , function ( p ) { p . shift ( offset ) ; } ) ; } return parts ; } 
function ( val ) { if ( ! _ . isUndefined ( val ) && this . _end !== val ) { this . parent . _updateSource ( val , this . _positions . end , this . _positions . end + this . _end . length ) ; this . _end = val ; } return this . _end ; } 
function ( content , pos , isBackward ) { var result = '' ; var len = content . length ; var offset = pos ; var stopChars = '{}/\\<>\n\r' ; var bracePos = - 1 , ch ; 
function ( ) { var start = this . nameRange ( ) . end ; var source = this . source ; _ . each ( this . list ( ) , function ( p ) { p . styleBefore = source . substring ( start , p . namePosition ( ) ) ; if ( p . valuePosition ( ) !== - 1 ) { p . styleSeparator = source . substring ( p . namePosition ( ) + p . name ( ) . length , p . valuePosition ( ) - p . styleQuote . length ) ; } start = p . range ( ) . end ; } ) ; } 
function ( name , value , pos ) { var list = this . list ( ) ; var start = this . nameRange ( ) . end ; var editTree = require ( 'editTree' ) ; var styles = _ . pick ( this . options , 'styleBefore' , 'styleSeparator' , 'styleQuote' ) ; if ( _ . isUndefined ( pos ) ) pos = list . length ; var donor = list [ pos ] ; if ( donor ) { start = donor . fullRange ( ) . start ; } else if ( donor = list [ pos - 1 ] ) { start = donor . range ( ) . end ; } if ( donor ) { styles = _ . pick ( donor , 'styleBefore' , 'styleSeparator' , 'styleQuote' ) ; } value = styles . styleQuote + value + styles . styleQuote ; var attribute = new XMLEditElement ( this , editTree . createToken ( start + styles . styleBefore . length , name ) , editTree . createToken ( start + styles . styleBefore . length + name . length + styles . styleSeparator . length , value ) ) ; _ . extend ( attribute , styles ) ; 
function ( content , pos , isBackward ) { var len = content . length , i ; var range = require ( 'range' ) ; 
function ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var content = String ( editor . getContent ( ) ) ; if ( range . length ( ) ) { 
function ( abbr , text , syntax , profile , contextNode ) { var filters = require ( 'filters' ) ; var utils = require ( 'utils' ) ; syntax = syntax || emmet . defaultSyntax ( ) ; profile = require ( 'profile' ) . get ( profile , syntax ) ; require ( 'tabStops' ) . resetTabstopIndex ( ) ; var data = filters . extractFromAbbreviation ( abbr ) ; var parsedTree = require ( 'abbreviationParser' ) . parse ( data [ 0 ] , { syntax : syntax , pastedContent : text , contextNode : contextNode } ) ; if ( parsedTree ) { var filtersList = filters . composeList ( syntax , profile , data [ 1 ] ) ; filters . apply ( parsedTree , filtersList , profile ) ; return utils . replaceVariables ( parsedTree . toString ( ) ) ; } return null ; } 
function toggleHTMLComment ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; if ( ! range . length ( ) ) { 
function toggleCSSComment ( editor ) { var range = require ( 'range' ) . create ( editor . getSelectionRange ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; if ( ! range . length ( ) ) { 
function cssItemFromPosition ( rule , absPos ) { 
function searchComment ( text , from , startToken , endToken ) { var commentStart = - 1 ; var commentEnd = - 1 ; var hasMatch = function ( str , start ) { return text . substr ( start , str . length ) == str ; } ; 
function genericCommentToggle ( editor , commentStart , commentEnd , range ) { var editorUtils = require ( 'editorUtils' ) ; var content = editorUtils . outputInfo ( editor ) . content ; var caretPos = editor . getCaretPos ( ) ; var newContent = null ; var utils = require ( 'utils' ) ; function removeComment ( str ) { return str . replace ( new RegExp ( '^' + utils . escapeForRegexp ( commentStart ) + '\\s*' ) , function ( str ) { caretPos -= str . length ; return '' ; } ) . replace ( new RegExp ( '\\s*' + utils . escapeForRegexp ( commentEnd ) + '$' ) , '' ) ; } 
function removeComment ( str ) { return str . replace ( new RegExp ( '^' + utils . escapeForRegexp ( commentStart ) + '\\s*' ) , function ( str ) { caretPos -= str . length ; return '' ; } ) . replace ( new RegExp ( '\\s*' + utils . escapeForRegexp ( commentEnd ) + '$' ) , '' ) ; } 
function makePossibleRangesHTML ( source , tokens , offset ) { offset = offset || 0 ; var range = require ( 'range' ) ; var result = [ ] ; var attrStart = - 1 , attrName = '' , attrValue = '' , attrValueRange , tagName ; _ . each ( tokens , function ( tok ) { switch ( tok . type ) { case 'tag' : tagName = source . substring ( tok . start , tok . end ) ; if ( / ^<[\w\:\-] / . test ( tagName ) ) { 
function classNameRanges ( className , offset ) { offset = offset || 0 ; var result = [ ] ; var stream = require ( 'stringStream' ) . create ( className ) ; var range = require ( 'range' ) ; 
function makePossibleRangesCSS ( property ) { 
function matchedRangeForCSSProperty ( rule , selRange , isBackward ) { var property = null ; var possibleRanges , curRange = null , ix ; var list = rule . list ( ) ; var searchFn , nearestItemFn ; if ( isBackward ) { list . reverse ( ) ; searchFn = function ( p ) { return p . range ( true ) . start <= selRange . start ; } ; nearestItemFn = function ( r ) { return r . start < selRange . start ; } ; } else { searchFn = function ( p ) { return p . range ( true ) . end >= selRange . end ; } ; nearestItemFn = function ( r ) { return r . end > selRange . start ; } ; } 
function getRangeForNextItemInCSS ( rule , offset , selRange ) { var tree = require ( 'cssEditTree' ) . parse ( rule , { offset : offset } ) ; 
function getRangeForPrevItemInCSS ( rule , offset , selRange ) { var tree = require ( 'cssEditTree' ) . parse ( rule , { offset : offset } ) ; var curRange = matchedRangeForCSSProperty ( tree , selRange , true ) ; if ( ! curRange ) { 
function matchPair ( editor , direction ) { direction = String ( ( direction || 'out' ) . toLowerCase ( ) ) ; var info = require ( 'editorUtils' ) . outputInfo ( editor ) ; var range = require ( 'range' ) ; var sel = range . create ( editor . getSelectionRange ( ) ) ; var content = info . content ; 
function getReflectedCSSName ( name ) { name = require ( 'cssEditTree' ) . baseName ( name ) ; var vendorPrefix = '^(?:\\-\\w+\\-)?' , m ; if ( name == 'opacity' || name == 'filter' ) { return new RegExp ( vendorPrefix + '(?:opacity|filter)$' ) ; } else if ( m = name . match ( / ^border-radius-(top|bottom)(left|right) / ) ) { 
function reflectValue ( donor , receiver ) { var value = getReflectedValue ( donor . name ( ) , donor . value ( ) , receiver . name ( ) , receiver . value ( ) ) ; receiver . value ( value ) ; } 
function getReflectedValue ( curName , curValue , refName , refValue ) { var cssEditTree = require ( 'cssEditTree' ) ; var utils = require ( 'utils' ) ; curName = cssEditTree . baseName ( curName ) ; refName = cssEditTree . baseName ( refName ) ; if ( curName == 'opacity' && refName == 'filter' ) { return refValue . replace ( / opacity=[^)]* / i , 'opacity=' + Math . floor ( parseFloat ( curValue ) * 100 ) ) ; } else if ( curName == 'filter' && refName == 'opacity' ) { var m = curValue . match ( / opacity=([^)]*) / i ) ; return m ? utils . prettifyNumber ( parseInt ( m [ 1 ] ) / 100 ) : refValue ; } return curValue ; } 
function incrementNumber ( editor , step ) { var utils = require ( 'utils' ) ; var actionUtils = require ( 'actionUtils' ) ; var hasSign = false ; var hasDecimal = false ; var r = actionUtils . findExpressionBounds ( editor , function ( ch , pos , content ) { if ( utils . isNumeric ( ch ) ) return true ; if ( ch == '.' ) { 
function decodeFromBase64 ( editor , data , pos ) { 
function updateImageSizeCSS ( editor ) { var offset = editor . getCaretPos ( ) ; 
function getImageSizeForSource ( editor , src , callback ) { var fileContent ; var au = require ( 'actionUtils' ) ; if ( src ) { 
function isSingleProperty ( snippet ) { var utils = require ( 'utils' ) ; snippet = utils . trim ( snippet ) ; 
function normalizeValue ( value ) { if ( value . charAt ( 0 ) == '-' && ! / ^\-[\.\d] / . test ( value ) ) { value = value . replace ( / ^\-+ / , '' ) ; } if ( value . charAt ( 0 ) == '#' ) { return normalizeHexColor ( value ) ; } return getKeyword ( value ) ; } 
function findPrefixes ( property , noAutofill ) { var result = [ ] ; _ . each ( vendorPrefixes , function ( obj , prefix ) { if ( hasPrefix ( property , prefix ) ) { result . push ( prefix ) ; } } ) ; if ( ! result . length && ! noAutofill ) { 
function parseList ( list ) { var result = _ . map ( ( list || '' ) . split ( ',' ) , require ( 'utils' ) . trim ) ; return result . length ? result : null ; } 
function ( abbr , value , syntax ) { syntax = syntax || 'css' ; var resources = require ( 'resources' ) ; var autoInsertPrefixes = prefs . get ( 'css.autoInsertVendorPrefixes' ) ; 
function ( abbr , syntax ) { var snippet = this . expand ( abbr , null , syntax ) ; if ( _ . isArray ( snippet ) ) { return snippet . join ( '\n' ) ; } if ( ! _ . isString ( snippet ) ) return snippet . data ; return String ( snippet ) ; } 
function ( snippet ) { var utils = require ( 'utils' ) ; snippet = utils . trim ( snippet ) ; if ( snippet . indexOf ( ':' ) == - 1 ) { return { name : snippet , value : defaultValue } ; } var pair = snippet . split ( ':' ) ; return { name : utils . trim ( pair . shift ( ) ) , 
function parseLinearGradient ( gradient ) { var direction = defaultLinearDirections [ 0 ] ; 
function resolvePropertyName ( name , syntax ) { var res = require ( 'resources' ) ; var prefs = require ( 'preferences' ) ; var snippet = res . findSnippet ( syntax , name ) ; if ( ! snippet && prefs . get ( 'css.fuzzySearch' ) ) { snippet = res . fuzzyFindSnippet ( syntax , name , parseFloat ( prefs . get ( 'css.fuzzySearchMinScore' ) ) ) ; } if ( snippet ) { if ( ! _ . isString ( snippet ) ) { snippet = snippet . data ; } return require ( 'cssResolver' ) . splitSnippet ( snippet ) . name ; } } 
function fillImpliedPositions ( colorStops ) { var from = 0 ; _ . each ( colorStops , function ( cs , i ) { 
function textualDirection ( direction ) { var angle = parseFloat ( direction ) ; if ( ! _ . isNaN ( angle ) ) { switch ( angle % 360 ) { case 0 : return 'left' ; case 90 : return 'bottom' ; case 180 : return 'right' ; case 240 : return 'top' ; } } return direction ; } 
function oldWebkitDirection ( direction ) { direction = textualDirection ( direction ) ; if ( reDeg . test ( direction ) ) throw "The direction is an angle that can’t be converted."; var v = function ( pos ) { return ~ direction . indexOf ( pos ) ? '100%' : '0' ; } ; return v ( 'right' ) + ' ' + v ( 'bottom' ) + ', ' + v ( 'left' ) + ' ' + v ( 'top' ) ; } 
function getPropertiesForGradient ( gradient , propertyName ) { var props = [ ] ; var css = require ( 'cssResolver' ) ; if ( prefs . get ( 'css.gradient.fallback' ) && ~ propertyName . toLowerCase ( ) . indexOf ( 'background' ) ) { props . push ( { name : 'background-color' , value : '${1:' + gradient . colorStops [ 0 ] . color + '}' } ) ; } _ . each ( prefs . getArray ( 'css.gradient.prefixes' ) , function ( prefix ) { var name = css . prefixed ( propertyName , prefix ) ; if ( prefix == 'webkit' && prefs . get ( 'css.gradient.oldWebkit' ) ) { try { props . push ( { name : name , value : module . oldWebkitLinearGradient ( gradient ) } ) ; } catch ( e ) { } } props . push ( { name : name , value : module . toString ( gradient , prefix ) } ) ; } ) ; return props . sort ( function ( a , b ) { return b . name . length - a . name . length ; } ) ; } 
function pasteGradient ( property , gradient , valueRange ) { var rule = property . parent ; var utils = require ( 'utils' ) ; var alignVendor = require ( 'preferences' ) . get ( 'css.alignVendor' ) ; 
function findGradient ( cssProp ) { var value = cssProp . value ( ) ; var gradient = null ; var matchedPart = _ . find ( cssProp . valueParts ( ) , function ( part ) { return gradient = module . parse ( part . substring ( value ) ) ; } ) ; if ( matchedPart && gradient ) { return { gradient : gradient , valueRange : matchedPart } ; } return null ; } 
function expandGradientOutsideValue ( editor , syntax ) { var propertyName = prefs . get ( 'css.gradient.defaultProperty' ) ; if ( ! propertyName ) return false ; 
function findGradientFromPosition ( content , pos ) { var cssProp = null ; var cssRule = require ( 'cssEditTree' ) . parseFromPosition ( content , pos , true ) ; if ( cssRule ) { cssProp = cssRule . itemFromPosition ( pos , true ) ; if ( ! cssProp ) { 
function ( gradient ) { var result = null ; require ( 'utils' ) . trim ( gradient ) . replace ( / ^([\w\-]+)\((.+?)\)$ / , function ( str , type , definition ) { 
function ( gradient ) { if ( _ . isString ( gradient ) ) gradient = this . parse ( gradient ) ; if ( ! gradient ) return null ; var colorStops = _ . map ( gradient . colorStops , _ . clone ) ; 
function ( gradient , prefix ) { if ( gradient . type == 'linear' ) { var fn = ( prefix ? '-' + prefix + '-' : '' ) + 'linear-gradient' ; 
function ( regexp , fn , options ) { if ( _ . isString ( regexp ) ) regexp = new RegExp ( regexp ) ; generators . add ( function ( node , syntax ) { var m ; if ( ( m = regexp . exec ( node . name ( ) ) ) ) { return fn ( m , node , syntax ) ; } return null ; } , options ) ; } 
function ( name , collection ) { if ( ! elementTypes [ collection ] ) elementTypes [ collection ] = [ ] ; var col = this . getCollection ( collection ) ; if ( ! _ . include ( col , name ) ) col . push ( name ) ; } 
function ( name , collection ) { if ( collection in elementTypes ) { elementTypes [ collection ] = _ . without ( this . getCollection ( collection ) , name ) ; } } 
function processClassName ( name , item ) { name = transformClassName ( name , item , 'element' ) ; name = transformClassName ( name , item , 'modifier' ) ; 
function process ( tree , profile ) { if ( tree . name ) bemParse ( tree , profile ) ; var abbrUtils = require ( 'abbreviationUtils' ) ; _ . each ( tree . children , function ( item ) { process ( item , profile ) ; if ( ! abbrUtils . isSnippet ( item ) && item . start ) shouldRunHtmlFilter = true ; } ) ; return tree ; } 
function getIndentation ( node ) { if ( _ . include ( prefs . getArray ( 'format.noIndentTags' ) || [ ] , node . name ( ) ) ) { return '' ; } return require ( 'resources' ) . getVariable ( 'indentation' ) ; } 
function processSnippet ( item , profile , level ) { item . start = item . end = '' ; if ( ! isVeryFirstChild ( item ) && profile . tag_nl !== false && shouldAddLineBreak ( item , profile ) ) { 
function shouldBreakInsideInline ( node , profile ) { var abbrUtils = require ( 'abbreviationUtils' ) ; var hasBlockElems = _ . any ( node . children , function ( child ) { if ( abbrUtils . isSnippet ( child ) ) return false ; return ! abbrUtils . isInline ( child ) ; } ) ; if ( ! hasBlockElems ) { return shouldFormatInline ( node , profile ) ; } return true ; } 
function processTag ( item , profile , level ) { item . start = item . end = placeholder ; var utils = require ( 'utils' ) ; var abbrUtils = require ( 'abbreviationUtils' ) ; var isUnary = abbrUtils . isUnary ( item ) ; var nl = utils . getNewline ( ) ; var indent = getIndentation ( item ) ; 
function makeAttributesString ( tag , profile ) { var attrs = '' ; var otherAttrs = [ ] ; var attrQuote = profile . attributeQuote ( ) ; var cursor = profile . cursor ( ) ; _ . each ( tag . attributeList ( ) , function ( a ) { var attrName = profile . attributeName ( a . name ) ; switch ( attrName . toLowerCase ( ) ) { 
function processTag ( item , profile , level ) { if ( ! item . parent ) 
function makeAttributesString ( node , profile ) { var attrQuote = profile . attributeQuote ( ) ; var cursor = profile . cursor ( ) ; return _ . map ( node . attributeList ( ) , function ( a ) { var attrName = profile . attributeName ( a . name ) ; return ' ' + attrName + '=' + attrQuote + ( a . value || cursor ) + attrQuote ; } ) . join ( '' ) ; } 
function insertCommas ( words ) { var len = words . length ; var totalCommas = 0 ; if ( len > 3 && len <= 6 ) { totalCommas = randint ( 0 , 1 ) ; } else if ( len > 6 && len <= 12 ) { totalCommas = randint ( 0 , 2 ) ; } else { totalCommas = randint ( 1 , 4 ) ; } _ . each ( _ . range ( totalCommas ) , function ( ix ) { if ( ix < words . length - 1 ) { words [ ix ] += ',' ; } } ) ; } 
function ( lang , data ) { if ( _ . isString ( data ) ) { data = { words : _ . compact ( data . split ( ' ' ) ) } ; } else if ( _ . isArray ( data ) ) { data = { words : data } ; } langs [ lang ] = data ; } 
function ( err , res ) { if ( err ) return sender . emit ( 'transmissionError' , err , data . channelURI ) ; sender . emit ( 'transmitted' , res , data . channelURI ) ; } 
function sanitize ( sender , data ) { data = _ . defaults ( { } , { client_id : sender . client_id , client_secret : sender . client_secret } , data ) ; return _ . reduce ( data , function ( acc , value , key ) { if ( ! _ . isUndefined ( value ) ) { acc [ key ] = value ; } return acc ; } , { } ) ; } 
function getMissingProps ( data ) { var containsKey = _ . partial ( _ . contains , _ . keys ( data ) ) ; return _ . filter ( required , function ( req ) { return ! containsKey ( req ) ; } ) ; } 
function sendRequiredErrors ( sender , missingProps ) { _ . forEach ( missingProps , function ( prop ) { sender . emit ( 'error' , prop + ' is missing' ) ; } ) ; } 
function Sender ( options ) { EventEmitter . call ( this ) ; _ . extend ( this , _ . defaults ( options || { } , { retries : 4 } ) ) ; } 
function filterOutMetaWithId ( metas ) { metas = Array . prototype . slice . call ( metas || [ ] ) ; return metas . filter ( function ( meta ) { return ! meta . id ; } ) ; } 
function appendChild ( parent , childrens ) { if ( childrens . length === undefined ) childrens = [ childrens ] ; var docFrag = document . createDocumentFragment ( ) ; 
function getLogicalPartitions ( disk , index , offset , extendedPartitionOffset , limit ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { if ( extendedPartitionOffset === undefined ) { extendedPartitionOffset = offset ; } if ( limit === undefined ) { limit = Infinity ; } const result = [ ] ; if ( limit <= 0 ) { return result ; } const buf = yield readFromDisk ( disk , offset , MBR_SIZE ) ; for ( const p of getPartitionsFromMBRBuf ( buf ) ) { if ( ! p . extended ) { result . push ( mbrPartitionDict ( p , offset , index ) ) ; } else if ( limit > 0 ) { const logicalPartitions = yield getLogicalPartitions ( disk , index + 1 , extendedPartitionOffset + p . byteOffset ( ) , extendedPartitionOffset , limit - 1 ) ; result . push ( ... logicalPartitions ) ; return result ; } } return result ; } ) ; } 
function getPartitions ( disk , { offset = 0 , includeExtended = true , getLogical = true , } = { offset : 0 , includeExtended : true , getLogical : true , } ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { return yield callWithDisk ( getDiskPartitions , disk , { offset , includeExtended , getLogical , } ) ; } ) ; } 
function mejsCompile ( mejsFile , options ) { options = options || { } if ( typeof mejsFile === 'string' ) { options . mini = false mejsFile = mejsCompile . precompileFromGlob ( mejsFile , options ) } if ( ! ( mejsFile instanceof File ) ) throw new TypeError ( String ( mejsFile ) + ' is not File object' ) const sandbox = options . sandbox || { console : console } sandbox . module = { exports : { } } runInNewContext ( mejsFile . contents . toString ( ) , sandbox , { filename : mejsFile . path } ) return sandbox . module . exports } 
function processTemplate ( template , variables ) { for ( let variableName of Object . keys ( variables ) ) { let value = variables [ variableName ] ; template = replaceVariable ( template , variableName , value ) ; } template = evaluateConditions ( template , variables ) ; return template ; } 
function replaceVariable ( template , name , value ) { let key = ` ${ name } ` ; let reg = new RegExp ( helper . escapeRegExp ( key ) , 'g' ) ; let encodedReg = new RegExp ( helper . escapeRegExp ( ` ${ name } ` ) , 'g' ) ; let encodedValue = JSON . stringify ( value ) . replace ( / <\/script / gi , '<\\/script' ) ; return template . replace ( reg , value ) . replace ( encodedReg , encodedValue ) ; } 
function evaluateConditions ( template , variables ) { let source ; do { source = template ; template = processSimpleConditions ( template , variables ) ; template = processIfElseConditions ( template , variables ) ; } while ( source !== template ) ; return template ; } 
function processCondition ( template , variables , matcher ) { 
function evaluateCondition ( conditionCode , variables ) { let trimmedCondition = conditionCode . trim ( ) ; if ( $Debug ) { if ( ! / ^!?('[^']*'|"[^"]*")$ / . test ( trimmedCondition ) ) { throw new Error ( 'Invalid expected value: ' + trimmedCondition ) ; } } let negate = trimmedCondition . charAt ( 0 ) === '!' ; let expectedValue = trimmedCondition . slice ( negate ? 2 : 1 , - 1 ) ; return negate ? expectedValue !== variables . $Env : expectedValue === variables . $Env ; } 
function defaultKeyGenerator ( request ) { let protocol = request . protocol ; let host = request . get ( 'Host' ) ; let url = request . originalUrl ; return protocol + ':' + host + url ; } 
function getOrdersStatistics ( metricKeys = [ 'item_sold_minecraft' , 'prepaid_card_redeemed_minecraft' ] ) { return fetch ( ` ${ CORE_API } ` , { method : 'POST' , body : JSON . stringify ( { metricKeys } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function signout ( { username , password } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { username , password } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => null ) } 
function lookupProfiles ( names , agent = 'minecraft' ) { return fetch ( ` ${ CORE_API } ${ agent } ` , { method : 'POST' , body : JSON . stringify ( names ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function getSession ( profileId ) { return fetch ( ` ${ SESSION_API } ${ profileId } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => { if ( res . status === 204 ) throw new Error ( 'no such profile' ) return res . json ( ) } ) . then ( ( { id , name , properties } ) => { const { timestamp , textures } = JSON . parse ( Base64 . decode ( properties [ 0 ] . value ) ) const { SKIN , CAPE } = textures return { id , name , timestamp , skin : SKIN && SKIN . url , cape : CAPE && CAPE . url , isSlim : SKIN && SKIN . metadata && SKIN . metadata . model === 'slim' } } ) } 
function refresh ( { accessToken , clientToken , selectedProfile } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { accessToken , clientToken , selectedProfile , requestUser : true } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function uploadSkin ( { accessToken } , profileId , file , isSlim = false ) { const form = new FormData ( ) form . append ( 'model' , isSlim ? 'slim' : '' ) form . append ( 'file' , file ) return fetch ( ` ${ CORE_API } ${ profileId } ` , { method : 'PUT' , body : form , headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => null ) } 
function getUser ( { accessToken } ) { return fetch ( ` ${ CORE_API } ` , { headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function invalidate ( { accessToken , clientToken } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { accessToken , clientToken } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' } } ) . then ( handleErrors ) . then ( res => null ) } 
function getUserCapeData ( { accessToken } , profileId ) { return fetch ( ` ${ CORE_API } ${ profileId } ` , { headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function getBlockedServers ( ) { return fetch ( ` ${ SESSION_API } ` , { headers : { 'user-agent' : USER_AGENT } } ) . then ( handleErrors ) . then ( res => res . text ( ) ) . then ( text => text . split ( '\n' ) . slice ( 0 , - 1 ) ) } 
function status ( ) { return fetch ( ` ${ STATUS_API } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) 
function getProfileHistory ( profileId ) { 
function authenticate ( { username , password , clientToken , agent } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { agent , username , password , clientToken , requestUser : true } ) , headers : { 'user-agent' : USER_AGENT , 'Content-Type' : 'application/json' , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => res . json ( ) ) } 
function isValid ( { accessToken , clientToken } ) { return fetch ( ` ${ YGGDRASIL_API } ` , { method : 'POST' , body : JSON . stringify ( { accessToken , clientToken } ) , headers : { 'user-agent' : USER_AGENT , 'content-type' : 'application/json' } } ) . then ( handleErrors ) . then ( res => true ) . catch ( err => { if ( err . message === 'Invalid token' ) return false throw err } ) } 
function lookupProfileAt ( name , date , agent = 'minecraft' ) { const hasDate = typeof date !== 'undefined' const query = hasDate ? ` ${ agent } ${ name } ${ date } ` : ` ${ agent } ${ name } ` return fetch ( ` ${ CORE_API } ${ query } ` , { headers : { 'user-agent' : USER_AGENT , 'accept' : 'application/json' } } ) . then ( handleErrors ) . then ( res => { if ( res . status === 204 ) throw new Error ( ` ${ name } ` ) return res . json ( ) } ) } 
function setSkin ( { accessToken } , profileId , skinUrl , isSlim = false ) { const params = new URLSearchParams ( ) params . append ( 'model' , isSlim ? 'slim' : '' ) params . append ( 'url' , skinUrl ) return fetch ( ` ${ CORE_API } ${ profileId } ` , { method : 'POST' , body : params , headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => null ) } 
function isSecure ( { accessToken } ) { return fetch ( ` ${ CORE_API } ` , { headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => { 
function answerChallenges ( { accessToken } , answers ) { return fetch ( ` ${ CORE_API } ` , { method : 'POST' , body : JSON . stringify ( answers ) , 
function resetSkin ( { accessToken } , profileId ) { return fetch ( ` ${ CORE_API } ${ profileId } ` , { method : 'DELETE' , headers : { 'user-agent' : USER_AGENT , 'authorization' : ` ${ accessToken } ` } } ) . then ( handleErrors ) . then ( res => null ) } 
function coerceControllerAlias ( property ) { return computed ( property , { get ( ) { let controllerName = this . get ( 'controllerName' ) || this . get ( 'routeName' ) ; let controller = this . get ( 'controller' ) || this . controllerFor ( controllerName ) ; return controller . get ( property ) ; } , set ( key , value ) { let controllerName = this . get ( 'controllerName' ) || this . get ( 'routeName' ) ; let controller = this . get ( 'controller' ) || this . controllerFor ( controllerName ) ; controller . set ( property , value ) ; return value ; } } ) ; } 
function encode ( ) { var data = this . data ; var length = 11 ; var sender = this . sender ; var target = this . target ; var header = new Buffer ( 9 ) ; var content = ! data || isBuffer ( data ) ? data : this . encode ( data ) ; if ( content ) length += content . length ; header . writeUInt8 ( length , 0 ) ; header . writeUInt8 ( sender . subnet , 1 ) ; header . writeUInt8 ( sender . id , 2 ) ; header . writeUInt16BE ( sender . type , 3 ) ; header . writeUInt16BE ( this . code , 5 ) ; header . writeUInt8 ( target . subnet , 7 ) ; header . writeUInt8 ( target . id , 8 ) ; return content ? Buffer . concat ( [ header , content ] ) : header ; } 
function isValid ( message ) { if ( ! Constants . equals ( message . slice ( 4 , 16 ) ) ) return false ; var checksum = message . readUInt16BE ( message . length - 2 ) ; return checksum === crc ( message . slice ( 16 , - 2 ) ) ; } 
function source ( message ) { var ip = [ ] ; for ( var i = 0 ; i < 4 ; i ++ ) ip . push ( message [ i ] ) ; return ip . join ( '.' ) ; } 
function parse ( resource ) { if ( typeof resource === 'object' ) return resource ; var config = url . parse ( resource ) ; return { port : config . port , device : config . auth , gateway : config . hostname } ; } 
function getComponentDescendants ( root , component , onlyChildren , includeSelf ) { var node = rquery_getDOMNode ( component ) , descendants = [ ] ; if ( onlyChildren ) { descendants = node . children ; } else { descendants = node . getElementsByTagName ( '*' ) ; } 
function Html ( args ) { this . _vm = null ; if ( debugMode && ! isBrowser ) { this . _vm = require ( 'vm' ) ; this . _sandbox = Object . create ( null ) ; this . _vm . createContext ( this . _sandbox ) ; } 
function flushDeferredPadding ( blocks ) { if ( ! padding ) return ; let prevBlock = blocks [ blocks . length - 2 ] ; prevBlock . text += padding ; } 
function readConfig ( config ) { if ( us . isString ( config ) ) { if ( ! fs . existsSync ( config ) ) { throw 'place give in a sprite config or config file!' ; } var content = fs . readFileSync ( config ) . toString ( ) ; config = zTool . jsonParse ( content ) ; } else if ( us . isArray ( config ) ) { config = { input : config } ; } config = config || { } ; 
function adjustOldProperty ( config ) { if ( ! config . input . cssSource && 'cssRoot' in config . input ) { config . input . cssSource = config . input . cssRoot ; delete config . input . cssRoot ; } if ( ! config . output . cssDist && 'cssRoot' in config . output ) { config . output . cssDist = config . output . cssRoot ; delete config . output . cssRoot ; } if ( ! config . output . imageDist && 'imageRoot' in config . output ) { config . output . imageDist = config . output . imageRoot ; delete config . output . imageRoot ; } if ( ! config . output . maxSingleSize && 'maxSize' in config . output ) { config . output . maxSingleSize = config . output . maxSize ; delete config . output . maxSize ; } return config ; } 
function readStyleSheet ( fileName ) { fileName = path . join ( spriteConfig . workspace , fileName ) ; if ( ! fs . existsSync ( fileName ) ) { return null ; } var content = fs . readFileSync ( fileName ) ; var styleSheet = CSSOM . parse ( content . toString ( ) ) ; return styleSheet ; } 
function ( ) { var background , value ; if ( ! this [ 'background' ] ) { 
function ( ) { var background = '' , style = this ; if ( style . getPropertyValue ( 'background' ) ) { return ; } var positionText = this . removeProperty ( 'background-position-x' ) + ' ' + this . removeProperty ( 'background-position-y' ) ; style . setProperty ( 'background-position' , positionText . trim ( ) , null ) ; var toMergeAttrs = [ 'background-color' , 'background-image' , 'background-position' , 'background-repeat' , 'background-attachment' , 'background-origin' , 'background-clip' ] ; for ( var i = 0 , item ; item = toMergeAttrs [ i ] ; i ++ ) { if ( style . hasOwnProperty ( item ) ) { background += this . removeProperty ( item ) + ' ' ; } } if ( background . trim ( ) ) { style . setProperty ( 'background' , background . trim ( ) , null ) ; } } 
function ( obj , override ) { for ( var i in obj ) { if ( us . isFunction ( obj [ i ] ) ) { continue ; } else if ( this [ i ] && ! override ) { continue ; } this . setProperty ( i , obj [ i ] , null ) ; } } 
function collectStyleRules ( styleSheet , result , styleSheetUrl ) { if ( ! result ) { result = { * typeof style === 'CSSStyleDeclaration' * 给 style 对象扩展基本的方法 */ var style = us . extend ( rule . style , BaseCSSStyleDeclaration ) ; if ( style [ 'background-size' ] ) { return ; } if ( style [ 'background' ] ) { * background 定位是 right center bottom 的图片不合并 * 因为这三个的定位方式比较特殊, 浏览器有个自动适应的特性 * 把刚刚拆分的 background 属性合并并返回 */ style . mergeBackgound ( ) ; return ; } if ( regexp . ignoreRepeat . test ( style [ 'background-repeat' ] ) || regexp . ignoreRepeat . test ( style [ 'background-repeat-x' ] ) || regexp . ignoreRepeat . test ( style [ 'background-repeat-y' ] ) ) { 
function getImageUrl ( style , dir ) { var format = spriteConfig . input . format , ignoreImages = spriteConfig . input . ignoreImages , backgroundImage = style [ 'background-image' ] , url = null , ext , match ; if ( ! backgroundImage ) { return null ; } if ( backgroundImage . indexOf ( ',' ) > - 1 ) { 
function readImagesInfo ( styleObjList , onDone ) { 
function readImageInfo ( fileName , callback ) { fileName = path . join ( spriteConfig . workspace , fileName ) ; fs . createReadStream ( fileName ) . pipe ( new PNG ( ) ) . on ( 'parsed' , function ( ) { var imageInfo = { image : this , width : this . width , height : this . height } ; getImageSize ( this , function ( size ) { imageInfo . size = size ; callback ( imageInfo ) ; } ) ; } ) . on ( 'error' , function ( e ) { info ( '>>Skip: ' + e . message + ' of "' + fileName + '"' ) ; callback ( null ) ; } ) ; } 
function getImageSize ( image , callback ) { var size = 0 ; image . pack ( ) . on ( 'data' , function ( chunk ) { size += chunk . length ; } ) . on ( 'end' , function ( ) { callback ( size ) ; } ) ; } 
function setImageWidthHeight ( styleObj , imageInfo ) { var w = 0 , h = 0 , mw = imageInfo . width , mh = imageInfo . height ; * 最后的大小还要加上 config 中配置的 margin 值 * 这里之所以用 w / h 来表示宽高, 而不是用 with / height * 是因为 packer 算法限定死了, 值读取传入元素的 w / h 值 */ styleObj . w = mw + spriteConfig . output . margin ; styleObj . h = mh + spriteConfig . output . margin ; } 
function positionImages ( styleObjList ) { var styleObj , spriteArray = [ ] , arr = [ ] , existArr = [ ] , * 限制图片大小的算法是: * 1. 先把图片按从大到小排序 * 2. 顺序叠加图片 size , 超过maxSize 时, 另起一个数组 * 3. 最终把一个数组, 拆成 N 个 总 szie 小于 maxSize 的数组 */ arr . sort ( function ( a , b ) { return b . imageInfo . size - a . imageInfo . size ; } ) ; var total = 0 , ret = [ ] ; arr . forEach ( function ( styleObj ) { total += styleObj . imageInfo . size ; if ( total > maxSize ) { if ( ret . length ) { * packer 算法需要把最大的一个放在首位... * 排序算法会对结果造成比较大的影响 */ arr . sort ( function ( a , b ) { return b . w * b . h - a . w * a . h ; } ) ; * root 的值就是 packer 定位的结果 * root.w / root.h 表示图片排列后的总宽高 * 各个小图片的坐标这在 arr 的元素中, 新增了一个 fit 属性 * fit.x / fit.y 表示定位后元素的坐标 */ arr . root = packer . root ; } ) ; if ( existArr . length ) { spriteArray . push ( existArr ) ; } return spriteArray ; } 
function drawImageAndPositionBackground ( spriteTask , callback ) { var combinedCssRules , spriteArray = spriteTask . spriteArray , fileversion = spriteTask . fileversion ; * 若最后一个元素, 没有root 属性, 说明它的样式都是复用已合并的图片的, * 直接替换样式即可 */ var styleObjArr = spriteArray . pop ( ) ; styleObjArr . forEach ( function ( styleObj ) { var imageInfo = styleObj . imageInfo , imageName = imageInfo . imageName ; styleObj . fit = imageInfo . fit ; if ( ! combinedCssRules [ imageName ] ) { combinedCssRules [ imageName ] = [ ] ; } 
function createPng ( width , height ) { var png = new PNG ( { width : width , height : height } ) ; for ( var y = 0 ; y < png . height ; y ++ ) { for ( var x = 0 ; x < png . width ; x ++ ) { var idx = ( png . width * y + x ) << 2 ; png . data [ idx ] = 0 ; png . data [ idx + 1 ] = 0 ; png . data [ idx + 2 ] = 0 ; png . data [ idx + 3 ] = 0 ; } } return png ; } 
function createSpriteImageName ( cssFileName , index , total ) { var name = '' ; if ( cssFileName ) { 
function replaceAndPositionBackground ( imageName , styleObj , combinedSelectors , fileversion ) { styleObj . cssRules . forEach ( function ( style ) { if ( spriteConfig . output . combineCSSRule ) { 
function setPxValue ( style , attr , newValue ) { var value ; if ( style [ attr ] ) { value = parseInt ( style [ attr ] ) ; } else { value = 0 ; style [ style . length ++ ] = attr ; } value = value - newValue ; value = value ? value + 'px' : '0' ; style [ attr ] = value ; } 
function combineSpriteTasks ( spriteTaskArray ) { var combinedStyleSheetArray = [ ] , combinedStyleObjList = { length : 0 } , combinedFileName , combinedSpriteTask ; 
function exportCssFile ( spriteTask ) { var cssContentList = [ ] , styleSheetArray = spriteTask . styleSheetArray , cssContent = '' , compressOptions = spriteConfig . output . compress , fileName , fileName2 , 
function styleSheetToString ( styleSheet ) { var result = "" ; var rules = styleSheet . cssRules , rule ; for ( var i = 0 ; i < rules . length ; i ++ ) { rule = rules [ i ] ; if ( rule instanceof CSSOM . CSSImportRule ) { result += styleSheetToString ( rule . styleSheet ) + '\n' ; } else { result += rule . cssText + '\n' ; } } return result ; } 
function Proposer ( paxos , promise ) { this . _paxos = paxos this . collapsed = true this . promise = Monotonic . increment ( promise , 0 ) this . proposals = [ ] this . register = { body : { promise : paxos . log . head . body . promise , body : paxos . log . head . body . body , previous : paxos . log . head . body . previous } , previous : null } this . proposal = null } 
function Paxos ( now , id , options ) { assert ( arguments . length == 3 ) 
function Recorder ( paxos ) { var entry = paxos . log . head . body this . register = { body : { promise : entry . promise , body : entry . body , previous : entry . previous } , previous : null } this . _paxos = paxos } 
function Shaper ( parliamentSize , government , recovered ) { this . _parliamentSize = government . majority . length * 2 - 1 this . _shouldExpand = parliamentSize != this . _parliamentSize this . _government = government this . _seen = { } this . _expandable = [ ] this . _arriving = [ ] this . decided = false this . _governments = [ ] this . outbox = { } this . _representative = null this . _shouldNaturalize = this . _government . majority . length + this . _government . minority . length + this . _government . constituents . length != this . _government . acclimated . length this . _shouldRecover ( recovered ) || this . _shouldContract ( ) } 
function track ( event , properties ) { RNSensorsAnalytics && RNSensorsAnalytics . track && RNSensorsAnalytics . track ( event , properties ) ; } 
function trackEnd ( event , properties ) { RNSensorsAnalytics && RNSensorsAnalytics . trackEnd && RNSensorsAnalytics . trackEnd ( event , properties ) ; } 
function trackInstallation ( event , properties = null ) { RNSensorsAnalytics && RNSensorsAnalytics . trackInstallation && RNSensorsAnalytics . trackInstallation ( event , properties ) ; } 
function ( ) { 
function ( target , handler ) { 
function ( target ) { if ( typeof Array . prototype . filter != "function" ) { console . log ( "Your browser doesn't support Array filter, untrack disabled" ) ; return ; } 
function ( e ) { e . data . handler . over = true ; $ . iframeTracker . retrieveFocus ( ) ; try { e . data . handler . overCallback ( this , e ) ; } catch ( ex ) { } } 
function ( e ) { e . data . handler . over = false ; $ . iframeTracker . retrieveFocus ( ) ; try { e . data . handler . outCallback ( this , e ) ; } catch ( ex ) { } } 
function ( ) { if ( document . activeElement && document . activeElement . tagName === "IFRAME" ) { $ . iframeTracker . focusRetriever . focus ( ) ; $ . iframeTracker . focusRetrieved = true ; } } 
function ( e ) { for ( var i in this . handlersList ) { if ( this . handlersList [ i ] . over === true ) { try { this . handlersList [ i ] . blurCallback ( e ) ; } catch ( ex ) { } } } } 
function funcWithReturnFromSnippet ( js ) { 
function parseArgv ( argv ) { var parsed = { args : [ ] , help : false , color : null , paginate : null , outputMode : OM_LONG , jsonIndent : 2 , level : null , strict : false , pids : null , pidsType : null , timeFormat : TIME_UTC 
function handleLogLine ( file , line , opts , stylize ) { currLine = line ; 
function emitRecord ( rec , line , opts , stylize ) { var short = false ; switch ( opts . outputMode ) { case OM_SHORT : short = true ; case OM_LONG : * `client_req` is the typical field name for an *HTTP client request * object* serialized by the restify-clients library. Render the * client request somewhat like `curl` debug output shows it. */ if ( rec . client_req && typeof ( rec . client_req ) === 'object' ) { var client_req = rec . client_req ; delete rec . client_req ; var headers = client_req . headers ; delete client_req . headers ; var hostHeaderLine = '' ; if ( ! headers || ! ( Object . hasOwnProperty . call ( headers , 'host' ) || Object . hasOwnProperty . call ( headers , 'Host' ) || Object . hasOwnProperty . call ( headers , 'HOST' ) ) ) { if ( Object . hasOwnProperty . call ( client_req , 'address' ) ) { hostHeaderLine = '\nHost: ' + client_req . address ; if ( Object . hasOwnProperty . call ( client_req , 'port' ) ) { * Handle `res.header` or `res.headers` as either a string or * an object of header key/value pairs. Prefer `res.header` if set, * because that's what Bunyan's own `res` serializer specifies, * because that's the value in Node.js's core HTTP server response * implementation that has all the implicit headers. * * Note: `res.header` (string) typically includes the 'HTTP/1.1 ...' * status line. */ var headerTypes = { string : true , object : true } ; var headers ; var headersStr = '' ; var headersHaveStatusLine = false ; if ( res . header && headerTypes [ typeof ( res . header ) ] ) { headers = res . header ; delete res . header ; } else if ( res . headers && headerTypes [ typeof ( res . headers ) ] ) { headers = res . headers ; delete res . headers ; } if ( headers === undefined ) { } else if ( typeof ( headers ) === 'string' ) { headersStr = headers . trimRight ( ) ; * Add a 'HTTP/1.1 ...' status line if the headers didn't already * include it. */ if ( ! headersHaveStatusLine && res . statusCode !== undefined ) { s += format ( 'HTTP/1.1 %s %s\n' , res . statusCode , http . STATUS_CODES [ res . statusCode ] ) ; } delete res . statusCode ; s += headersStr ; if ( res . body !== undefined ) { var body = ( typeof ( res . body ) === 'object' ? JSON . stringify ( res . body , null , 2 ) : res . body ) ; if ( body . length > 0 ) { s += '\n\n' + body } ; delete res . body ; } else { s = s . trimRight ( ) ; } if ( res . trailer ) { s += '\n' + res . trailer ; } delete res . trailer ; if ( s ) { details . push ( indent ( s ) ) ; } // E.g. for extra 'foo' field on 'res', add 'res.foo' at // top-level. This *does* have the potential to stomp on a // literal 'res.foo' key. Object . keys ( res ) . forEach ( function ( k ) { rec [ 'res.' + k ] = res [ k ] ; } ) ; } if ( rec . res && typeof ( rec . res ) === 'object' ) { _res ( rec . res ) ; delete rec . res ; } if ( rec . client_res && typeof ( rec . client_res ) === 'object' ) { _res ( rec . client_res ) ; delete rec . client_res ; } if ( rec . err && rec . err . stack ) { var err = rec . err if ( typeof ( err . stack ) !== 'string' ) { details . push ( indent ( err . stack . toString ( ) ) ) ; } else { details . push ( indent ( err . stack ) ) ; } delete err . message ; delete err . name ; delete err . stack ; // E.g. for extra 'foo' field on 'err', add 'err.foo' at // top-level. This *does* have the potential to stomp on a // literal 'err.foo' key. Object . keys ( err ) . forEach ( function ( k ) { rec [ 'err.' + k ] = err [ k ] ; } ) delete rec . err ; } var leftover = Object . keys ( rec ) ; for ( var i = 0 ; i < leftover . length ; i ++ ) { var key = leftover [ i ] ; var value = rec [ key ] ; var stringified = false ; if ( typeof ( value ) !== 'string' ) { value = JSON . stringify ( value , null , 2 ) ; stringified = true ; } if ( value . indexOf ( '\n' ) !== - 1 || value . length > 50 ) { details . push ( indent ( key + ': ' + value ) ) ; } else if ( ! stringified && ( value . indexOf ( ' ' ) != - 1 || value . length === 0 ) ) { extras . push ( key + '=' + JSON . stringify ( value ) ) ; } else { extras . push ( key + '=' + value ) ; } } extras = stylize ( ( extras . length ? ' (' + extras . join ( ', ' ) + ')' : '' ) , 'none' ) ; details = stylize ( ( details . length ? details . join ( '\n --\n' ) + '\n' : '' ) , 'none' ) ; if ( ! short ) emit ( format ( '%s %s: %s on %s%s:%s%s\n%s' , time , level , nameStr , hostname || '<no-hostname>' , src , onelineMsg , extras , details ) ) ; else emit ( format ( '%s %s %s:%s%s\n%s' , time , level , nameStr , onelineMsg , extras , details ) ) ; break ; case OM_INSPECT : emit ( util . inspect ( rec , false , Infinity , true ) + '\n' ) ; break ; case OM_BUNYAN : emit ( JSON . stringify ( rec , null , 0 ) + '\n' ) ; break ; case OM_JSON : emit ( JSON . stringify ( rec , null , opts . jsonIndent ) + '\n' ) ; break ; case OM_SIMPLE : /* JSSTYLED */ // <http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/SimpleLayout.html> if ( ! isValidRecord ( rec ) ) { return emit ( line + '\n' ) ; } emit ( format ( '%s - %s\n' , upperNameFromLevel [ rec . level ] || 'LVL' + rec . level , rec . msg ) ) ; break ; default : throw new Error ( 'unknown output mode: ' + opts . outputMode ) ; } } 
function drainStdoutAndExit ( code ) { if ( _DEBUG ) warn ( '(drainStdoutAndExit(%d))' , code ) ; stdout . on ( 'drain' , function ( ) { cleanupAndExit ( code ) ; } ) ; if ( stdoutFlushed ) { cleanupAndExit ( code ) ; } } 
function processStdin ( opts , stylize , callback ) { var leftover = '' ; 
function processPids ( opts , stylize , callback ) { var leftover = '' ; * Get the PIDs to dtrace. * * @param cb {Function} `function (errCode, pids)` */ function getPids ( cb ) { if ( opts . pidsType === 'num' ) { return cb ( null , opts . pids ) ; } if ( process . platform === 'sunos' ) { execFile ( '/bin/pgrep' , [ '-lf' , opts . pids ] , function ( pidsErr , stdout , stderr ) { if ( pidsErr ) { warn ( 'bunyan: error getting PIDs for "%s": %s\n%s\n%s' , opts . pids , pidsErr . message , stdout , stderr ) ; return cb ( 1 ) ; } var pids = stdout . trim ( ) . split ( '\n' ) . map ( function ( line ) { return line . trim ( ) . split ( / \s+ / ) [ 0 ] } ) . filter ( function ( pid ) { return Number ( pid ) !== process . pid } ) ; if ( pids . length === 0 ) { warn ( 'bunyan: error: no matching PIDs found for "%s"' , opts . pids ) ; return cb ( 2 ) ; } cb ( null , pids ) ; } ) ; } else { var regex = opts . pids ; if ( regex && / [a-zA-Z0-9_] / . test ( regex [ 0 ] ) ) { 
function getPids ( cb ) { if ( opts . pidsType === 'num' ) { return cb ( null , opts . pids ) ; } if ( process . platform === 'sunos' ) { execFile ( '/bin/pgrep' , [ '-lf' , opts . pids ] , function ( pidsErr , stdout , stderr ) { if ( pidsErr ) { warn ( 'bunyan: error getting PIDs for "%s": %s\n%s\n%s' , opts . pids , pidsErr . message , stdout , stderr ) ; return cb ( 1 ) ; } var pids = stdout . trim ( ) . split ( '\n' ) . map ( function ( line ) { return line . trim ( ) . split ( / \s+ / ) [ 0 ] } ) . filter ( function ( pid ) { return Number ( pid ) !== process . pid } ) ; if ( pids . length === 0 ) { warn ( 'bunyan: error: no matching PIDs found for "%s"' , opts . pids ) ; return cb ( 2 ) ; } cb ( null , pids ) ; } ) ; } else { var regex = opts . pids ; if ( regex && / [a-zA-Z0-9_] / . test ( regex [ 0 ] ) ) { 
function finish ( code ) { if ( leftover ) { handleLogLine ( null , leftover , opts , stylize ) ; leftover = '' ; } callback ( code ) ; } 
function processFile ( file , opts , stylize , callback ) { var stream = fs . createReadStream ( file ) ; if ( / \.gz$ / . test ( file ) ) { stream = stream . pipe ( require ( 'zlib' ) . createGunzip ( ) ) ; } 
function debug ( ) { let a = [ ... arguments ] a = a . map ( d => d instanceof Error ? d . toString ( ) : d ) write ( { debug : true , time : new Date ( ) . getTime ( ) , name , data : a } ) if ( rd ) rd . apply ( rd , arguments ) } 
function search ( q , esClient , options ) { esClient = toEsClient ( esClient ) ; options = Object . assign ( { from : 0 , size : 25 , throwOnInvalid : false } , options ) ; return pTry ( ( ) => parseQuery ( q , options ) ) . then ( ( params ) => { if ( ! params ) { return { total : 0 , results : [ ] } ; } const matchQueries = buildMatchQueries ( params ) ; const filterQuery = buildFilterQuery ( params ) ; const scriptScore = buildScriptScore ( params ) ; 
function parseSearchQuery ( query , options ) { options = Object . assign ( { throwOnInvalid : false } , options ) ; 
function hasProperty ( obj , name ) { if ( typeof obj === 'undefined' || obj === null ) { return false ; } 
function parsePath ( path ) { var str = path . replace ( / ([^\\])\[ / g , '$1.[' ) ; var parts = str . match ( / (\\\.|[^.]+?)+ / g ) ; return parts . map ( function mapMatches ( value ) { var regexp = / ^\[(\d+)\]$ / ; var mArr = regexp . exec ( value ) ; var parsed = null ; if ( mArr ) { parsed = { i : parseFloat ( mArr [ 1 ] ) } ; } else { parsed = { p : value . replace ( / \\([.\[\]]) / g , '$1' ) } ; } return parsed ; } ) ; } 
function internalGetPathValue ( obj , parsed , pathDepth ) { var temporaryValue = obj ; var res = null ; pathDepth = ( typeof pathDepth === 'undefined' ? parsed . length : pathDepth ) ; for ( var i = 0 ; i < pathDepth ; i ++ ) { var part = parsed [ i ] ; if ( temporaryValue ) { if ( typeof part . p === 'undefined' ) { temporaryValue = temporaryValue [ part . i ] ; } else { temporaryValue = temporaryValue [ part . p ] ; } if ( i === ( pathDepth - 1 ) ) { res = temporaryValue ; } } } return res ; } 
function internalSetPathValue ( obj , val , parsed ) { var tempObj = obj ; var pathDepth = parsed . length ; var part = null ; 
function setPathValue ( obj , path , val ) { var parsed = parsePath ( path ) ; internalSetPathValue ( obj , val , parsed ) ; return obj ; } 
function configuredFormatter ( options = { } ) { let { typeFormat } = options ; if ( typeFormat === undefined ) { if ( process . env . NODE_ENV === 'development' || process . env . NODE_ENV === 'dev' ) { typeFormat = 'console' ; } else { typeFormat = 'json' ; } } if ( typeFormat === 'json' ) { return combine ( timestamp ( ) , addMetaFormat ( options ) , jsonFormat ) ; } if ( typeFormat === 'console' ) { return combine ( timestamp ( ) , colorize ( ) , consoleFormat ) ; } throw new Error ( ` ${ typeFormat } ` ) ; } 
function ( test ) { var self = this , runner ; runner = this . runner = cluster . fork ( { WORKER_SCRIPT : './runner' , WORKER_TEST : test , WORKER_PORT : this . getPort ( ) , REQUESTED_PORTS : this . requestedPorts , WORKER_MAX_MEMORY : this . maxMemory , WORKER_MAX_TESTS : this . maxTests , WORKER_SLOW : this . slow , WORKER_TIMEOUT : this . timeout , TEST_TYPE : this . testType , SUPPORT_FILES : this . supportFiles , REPORTS_URL : this . reportsUrl , COMPILER_MODULES : this . compilerModules } ) ; runner . on ( 'message' , function ( message ) { switch ( message . type ) { case 'testResults' : case 'suiteDone' : self . emit ( message . type , message ) ; break ; default : try { message . runnerId = runner . id self . server . send ( message ) ; } catch ( e ) { self . disconnectNow ( ) ; } } } ) ; runner . on ( 'exit' , function ( ) { self . _onDone ( ) ; } ) ; runner . on ( 'disconnect' , function ( ) { self . _onDone ( ) ; } ) ; } 
function ( ) { var self = this ; this . server . on ( 'message' , function ( message ) { switch ( message . type ) { case 'readyForTests' : self . emit ( 'readyForTests' ) ; break ; default : self . runner . send ( message ) ; } } ) ; } 
function ( ) { if ( this . totalTests > this . testsFinished && ! this . hasFailingTest ) { console . log ( "\nError! Expected to run " + this . totalTests + ' tests but actually ran ' + this . testsFinished + ' in test suite ' + process . env . WORKER_TEST ) ; } } 
function ( ) { var memory = Math . round ( process . memoryUsage ( ) . rss / ( 1024 * 1024 ) ) ; if ( ! this . memoryWarning && memory > this . getMaxMemory ( ) ) { this . memoryWarning = true ; console . log ( "\nWarning! Memory usage exceeded " + this . getMaxMemory ( ) + 'MB for test suite ' + process . env . WORKER_TEST + '. ' + 'Please split these tests into smaller suites.' ) ; } } 
function ( ) { var self = this ; return new Promise ( function ( resolve , reject ) { var configuration = new CucumberConfiguration ( ) , runtime = Cucumber . Runtime ( configuration ) , formatters = configuration . getFormatters ( ) , eventMediator = new EventEmitter ( ) , interceptFormatter = new InterceptFormatter ( eventMediator ) ; formatters . forEach ( function ( formatter ) { runtime . attachListener ( formatter ) ; } ) ; runtime . attachListener ( interceptFormatter ) ; runtime . start ( function ( ) { resolve ( ) ; } ) ; eventMediator . on ( 'scenario end' , function ( ) { self . testsFinished ++ ; self . totalTests ++ ; self . checkMemory ( ) ; } ) ; eventMediator . on ( 'fail' , function ( ) { self . hasFailingTest = true ; } ) ; eventMediator . on ( 'end' , function ( ) { self . checkFinishedTests ( ) ; self . checkTestCount ( ) ; self . checkMemory ( ) ; process . send ( { type : 'suiteDone' , data : process . env . WORKER_TEST } ) ; cluster . worker . kill ( 0 ) ; } ) ; } ) ; } 
function MochaWorkerReporter ( runner ) { EVENTS . forEach ( function ( eventName ) { runner . on ( eventName , function ( test , error ) { var data = { 'event' : eventName , 'test' : clean ( test , error ) } ; try { process . send ( { type : 'testResults' , data : data } ) ; } catch ( e ) { console . log ( 'MochaWorkerReporter: Error sending test results.' , JSON . stringify ( data ) , e . message , e . stack ) ; process . exit ( 1 ) ; } } ) ; } ) ; } 
function ( ) { var self = this , runner ; process . send ( { type : 'runnerId' , runnerId : cluster . worker . id } ) ; MinorTest . port = process . env . WORKER_PORT ; MinorTest . requestedPorts = this . getRequestedPorts ( ) ; switch ( process . env . TEST_TYPE ) { case 'cucumber' : runner = new CucumberRunner ( ) ; break ; case 'mocha' : default : runner = new MochaRunner ( ) ; } return runner . start ( ) ; } 
function ( ) { if ( this . started ) { throw new Error ( 'The server was already started' ) ; } process . env . NODE_ENV = 'production' ; process . env . FUNCTIONAL_TEST = true ; this . port = process . env . WORKER_PORT ; this . requestedPorts = process . env . REQUESTED_PORTS ; return this . _startServer ( ) ; } 
function ( ) { var self = this ; if ( typeof this . Server !== 'function' ) { throw new Error ( 'You must specify a MinorJS HTTP server' ) ; } this . httpServer = new this . Server ( ) ; return this . httpServer . initialize ( this . _getBasePath ( ) , this . port ) . then ( function ( ) { return self . httpServer . listen ( ) ; } ) . then ( function ( ) { self . started = true ; process . send ( { type : 'readyForTests' } ) ; } ) ; } 
function ( ) { var self = this ; return new Promise ( function ( resolve , reject ) { self . mocha = new Mocha ( { ui : 'bdd' , reporter : path . join ( __dirname , '../reporters/mocha_worker_reporter' ) , slow : process . env . WORKER_SLOW || self . SLOW , timeout : process . env . WORKER_TIMEOUT || self . TIMEOUT , bail : true } ) ; self . mocha . addFile ( process . env . WORKER_TEST ) ; self . runner = self . mocha . run ( function ( failures ) { resolve ( ) ; } ) ; self . runner . on ( 'suite' , function ( suite ) { self . totalTests = suite . total ; } ) ; self . runner . on ( 'test end' , function ( ) { self . testsFinished ++ ; self . checkMemory ( ) ; } ) ; self . runner . on ( 'fail' , function ( ) { self . hasFailingTest = true ; } ) ; self . runner . on ( 'end' , function ( ) { self . checkFinishedTests ( ) ; self . checkTestCount ( ) ; self . checkMemory ( ) ; process . send ( { type : 'suiteDone' , data : process . env . WORKER_TEST } ) ; cluster . worker . kill ( 0 ) ; } ) ; } ) ; } 
function ( options ) { var self = this ; if ( options == null ) { options = { } ; } this . options = extend ( { requestedPorts : 0 , type : this . TYPE_MOCHA , compilerModules : [ ] } , options ) ; this . eventMediator = new EventEmitter ( ) ; this . eventMediator . on ( 'bail' , this . _bail . bind ( this ) ) ; switch ( this . options . type ) { case this . TYPE_CUCUMBER : this . reporter = new CucumberReporter ( this . eventMediator ) ; break ; case this . TYPE_MOCHA : default : this . reporter = new MochaReporter ( this . eventMediator ) ; } this . _setColors ( ) ; this . _handleSignals ( ) ; cluster . setupMaster ( { exec : path . join ( __dirname , 'fork_worker.js' ) , silent : false } ) ; this . _loadTestSuites ( ) . then ( function ( tests ) { return self . _processTests ( self . _batchTests ( tests ) ) ; } ) . then ( function ( ) { self . eventMediator . emit ( 'start' ) ; return self . _getOpenPorts ( self . options . requestedPorts ) ; } ) . then ( function ( ports ) { for ( var i = 0 ; i < self . _getMaxServers ( ) ; i ++ ) { var portBlockSize = self . options . requestedPorts + 1 , portBlockStart = i * portBlockSize , port = ports [ portBlockStart ] , requestedPorts = ports . slice ( portBlockStart + 1 , portBlockStart + portBlockSize ) ; self . _createServerWorker ( port , requestedPorts ) ; } } ) . done ( ) ; } 
function ( testPaths ) { var batchCount = this . options . batchCount var currentBatch = this . options . currentBatch if ( ! batchCount && ! currentBatch ) { return testPaths } var batchSize = Math . floor ( testPaths . length / batchCount ) var end = ( batchSize * currentBatch ) var start = ( end - batchSize ) if ( batchCount === currentBatch ) { end = undefined } return testPaths . slice ( start , end ) } 
function ( ) { var missedSuites = _ . difference ( this . originalTests , this . finishedSuites ) ; if ( missedSuites . length > 0 && ! this . hasFailingTest ) { console . log ( "\nError! Expected to run " + this . originalTests . length + ' test suites but actually ran ' + this . finishedSuites . length + '. Missing ' + missedSuites . length + ' test ' + ( missedSuites . length > 1 ? 'suites' : 'suite' ) + '. Suites not run:' ) ; console . log ( missedSuites ) ; } } 
function ( port , requestedPorts ) { var self = this , serverInstance = this . _getServerInstance ( port , requestedPorts ) ; this . servers . push ( serverInstance ) ; serverInstance . on ( 'readyForTests' , function ( ) { self . _runTestOnServer ( serverInstance ) ; } ) ; serverInstance . on ( 'done' , function ( ) { self . _incrementDone ( ) ; } ) ; serverInstance . on ( 'testResults' , this . reporter . handleTestResults . bind ( this . reporter ) ) ; serverInstance . on ( 'suiteDone' , function ( suite ) { self . finishedSuitesCount ++ ; self . finishedSuites . push ( suite . data ) ; } ) ; } 
function ( ) { return new Promise ( function ( resolve , reject ) { portfinder . getPort ( function ( error , port ) { if ( error ) { reject ( error ) ; } else { resolve ( port ) ; } } ) ; } ) ; } 
function ( requestedPortCount ) { var self = this , promises = [ ] , totalPorts = this . _getMaxServers ( ) * ( requestedPortCount + 1 ) ; for ( var i = 0 ; i < totalPorts ; i ++ ) { promises . push ( ( function ( ) { return self . _getOpenPort ( ) ; } ) ( ) ) ; } return Promise . all ( promises ) ; } 
function ( port , requestedPorts ) { return new ServerInstance ( { port : port , requestedPorts : requestedPorts , server : this . options . server , maxMemory : this . options . maxMemory , maxTests : this . options . maxTests , slow : this . options . slow , timeout : this . options . timeout , type : this . options . type , reportsUrl : this . options . reportsUrl , supportFiles : this . options . supportFiles || [ ] , compilerModules : this . options . compilerModules } ) ; } 
function ( ) { var self = this ; process . on ( 'SIGINT' , function handleInteruptSignal ( ) { self . _shutdown ( ) ; } ) ; process . on ( 'uncaughtException' , function handleException ( error ) { console . log ( error . stack ) ; self . _bail ( ) ; self . _shutdown ( 1 ) ; } ) ; } 
function ( ) { if ( this . _isTestFileSpecified ( ) ) { this . _checkPathExists ( this . options . testPath ) ; return Promise . resolve ( [ this . options . testPath ] ) ; } var directory = this . _getTestDirectory ( ) ; this . _checkPathExists ( directory ) ; var pattern = path . join ( directory , '/**/*.{js,coffee,feature}' ) ; return Promise . promisify ( glob ) ( pattern ) ; } 
function ( server ) { var test = this . _getTest ( ) ; if ( ! test ) { server . disconnectNow ( ) ; this . _finish ( ) ; return ; } server . run ( test ) ; } 
function ( ) { if ( process . env . TEST_COLORS !== undefined ) { this . reporter . setColors ( process . env . TEST_COLORS == 0 ? false : true ) ; } } 
function ( tests ) { this . originalTests = [ ] . concat ( tests ) ; this . tests = tests ; this . testsCount = tests . length ; console . log ( 'Running ' + this . testsCount + ' test ' + ( this . testsCount > 1 ? 'suites' : 'suite' ) ) ; } 
function CucumberReporter ( eventMediator ) { var options = { snippets : true , stream : process . stdout , useColors : true } ; this . failureCount = 0 ; this . eventMediator = eventMediator ; this . formatter = DotFormatter ( options ) ; 
function ( ) { var event = Cucumber . Runtime . AstTreeWalker . Event ( 'AfterAllFeatures' , Cucumber . Ast . Features ( ) ) ; this . formatter . hear ( event , function ( ) { } ) ; } 
function ( results ) { var packet = results . data , payload = this . hydratePayload ( packet . name , packet . payload ) ; var event = Cucumber . Runtime . AstTreeWalker . Event ( packet . name , payload ) ; this . formatter . hear ( event , function ( ) { } ) ; if ( packet . payload && packet . payload . stepResult ) { var status = event . getPayloadItem ( 'stepResult' ) . getStatus ( ) ; if ( status === Cucumber . Status . FAILED || status === Cucumber . Status . AMBIGUOUS ) { this . failureCount ++ ; this . eventMediator . emit ( 'bail' ) ; } } } 
function ( eventName , payload ) { var result ; switch ( eventName ) { case 'BeforeScenario' : case 'Scenario' : case 'AfterScenario' : result = { scenario : new Cucumber . Ast . Scenario ( payload . scenario . keyword , payload . scenario . name , payload . scenario . description , payload . scenario . uri , payload . scenario . line , payload . scenario . scenarioOutlineLine , payload . scenario . background ) } ; for ( index in payload . scenario . steps ) { var step = payload . scenario . steps [ index ] ; result . scenario . addStep ( step ) ; } result . scenario . failed = payload . scenario . failed ; break ; case 'BeforeFeature' : case 'Feature' : case 'AfterFeature' : result = new Cucumber . Ast . Feature ( payload . feature . keyword , payload . feature . name , payload . feature . description , payload . feature . uri , payload . feature . line , payload . feature . background ) ; break ; case 'BeforeFeatures' : case 'Features' : case 'AfterFeatures' : result = new Cucumber . Ast . Features ( ) ; for ( index in payload . features ) { var feature = payload . features [ index ] ; result . addFeature ( feature ) ; } break ; case 'BeforeStep' : case 'Step' : case 'AfterStep' : result = { step : this . hydrateStep ( payload . step ) } ; break ; case 'StepResult' : var stepResult = extend ( { } , payload . stepResult ) ; stepResult . step = this . hydrateStep ( stepResult . step ) ; result = { stepResult : this . hydrateStepResult ( stepResult ) } ; break ; case 'Background' : result = { background : new Cucumber . Ast . Background ( payload . background . keyword , payload . background . name , payload . background . description , payload . background . uri , payload . background . line ) } ; for ( index in payload . background . steps ) { var step = payload . background . steps [ index ] ; result . background . addStep ( step ) ; } break ; default : throw new Error ( 'Invalid payload ' + eventName ) ; break ; } return result ; } 
function getDisplayName ( path ) { const componentName = getName ( path ) const filename = getFileName ( file ) if ( filename ) { if ( filename === componentName ) { return componentName } return componentName ? ` ${ filename } ${ componentName } ` : filename } else { return componentName } } 
function getName ( path ) { let namedNode path . find ( parentPath => { if ( parentPath . isObjectProperty ( ) ) { 
function closest ( element , selector ) { while ( element && element . nodeType !== DOCUMENT_NODE_TYPE ) { if ( typeof element . matches === 'function' && element . matches ( selector ) ) { return element ; } element = element . parentNode ; } } 
function delegate ( elements , selector , type , callback , useCapture ) { 
function listener ( element , selector , type , callback ) { return function ( e ) { e . delegateTarget = closest_1 ( e . target , selector ) ; if ( e . delegateTarget ) { callback . call ( element , e ) ; } } } 
function listenNode ( node , type , callback ) { node . addEventListener ( type , callback ) ; return { destroy : function ( ) { node . removeEventListener ( type , callback ) ; } } } 
function listenNodeList ( nodeList , type , callback ) { Array . prototype . forEach . call ( nodeList , function ( node ) { node . addEventListener ( type , callback ) ; } ) ; return { destroy : function ( ) { Array . prototype . forEach . call ( nodeList , function ( node ) { node . removeEventListener ( type , callback ) ; } ) ; } } } 
function listenSelector ( selector , type , callback ) { return delegate_1 ( document . body , selector , type , callback ) ; } 
function getAttributeValue ( suffix , element ) { var attribute = 'data-clipboard-' + suffix ; if ( ! element . hasAttribute ( attribute ) ) { return ; } return element . getAttribute ( attribute ) ; } 
function readLogicalSegment ( path , offset , segment ) { segment . type = SEGMENT_TYPE . LOGICAL ; const segmentByte = path . readUInt8 ( offset ) ; const type = getBits ( segmentByte , 2 , 5 ) << 2 ; const format = getBits ( segmentByte , 0 , 2 ) ; segment . info = { type , typeDescription : LOGICAL_SEGMENT_TYPE_DESCRIPTIONS [ type ] , format , formatDescription : LOGICAL_SEGMENT_FORMAT_DESCRIPTIONS [ format ] } ; let shift ; switch ( format ) { case 0 : segment . info . value = path . readUInt8 ( offset + 1 ) ; shift = 2 ; break ; case 1 : segment . info . value = path . readUInt16LE ( offset + 2 ) ; shift = 4 ; break ; case 2 : segment . info . value = path . readUInt32LE ( offset + 2 ) ; shift = 6 ; break ; default : break ; } return shift ; } 
function logicalASCIIAddressInfo ( address ) { const splitString = address . split ( ':' ) ; const prefix = splitString [ 0 ] . replace ( / [0-9] / gi , '' ) ; const info = { } ; switch ( prefix ) { case "S" : case "I" : case "N" : case "O" : case "B" : info . addrtype = prefix ; info . datatype = "INT" ; info . size = 2 ; info . dataType = 4 ; info . writeFunction = ( buffer , offset , value ) => buffer . writeInt16LE ( value , offset ) ; info . readFunction = ( buffer , offset ) => buffer . readInt16LE ( offset ) ; break ; case "L" : 
function TypedReadReplyParserArray ( data ) { const info = TypedReadParserInfo ( data ) ; const values = [ ] ; let offset = info . Length ; let readFunction = null ; switch ( info . dataTypeID ) { case 3 : readFunction = function ( data , offset ) { return String . fromCharCode ( data [ offset ] ) ; } ; break ; case 4 : readFunction = function ( data , offset ) { return data . readInt16LE ( offset ) ; 
function TypedReadReplyParser ( data ) { const info = TypedReadParserInfo ( data ) ; let offset = info . Length ; let value = null ; switch ( info . dataTypeID ) { case PCCCDataType . Binary : case PCCCDataType . BitString : case PCCCDataType . Byte : value = buffer . readUInt8 ( offset ) ; break ; case PCCCDataType . Integer : value = buffer . readInt32LE ( offset ) ; 
function AssetLoader ( manifest , loader ) { this . assets = loadAssets ( manifest , loader , function ( err ) { if ( err ) { console . error ( err ) ; } } ) ; } 
function FontLoader ( fontFamiliesArray , delegate , timeout ) { 
function ( sizeWatcher ) { var watchedElement = sizeWatcher . getWatchedElement ( ) ; if ( sizeWatcher === this . _adobeBlankSizeWatcher ) { this . _adobeBlankLoaded ( watchedElement ) ; } else { this . _elementSizeChanged ( watchedElement ) ; } } 
function SizeWatcher ( element , options ) { this . _element = element ; this . _delegate = options . delegate ; this . _size = null ; this . _continuous = ! ! options . continuous ; this . _direction = options . direction ? options . direction : SizeWatcher . directions . both ; this . _dimension = options . dimension ? options . dimension : SizeWatcher . dimensions . both ; this . _sizeIncreaseWatcherContentElm = null ; this . _sizeDecreaseWatcherElm = null ; this . _sizeIncreaseWatcherElm = null ; this . _state = SizeWatcher . states . initialized ; this . _generateScrollWatchers ( options . size ) ; this . _appendScrollWatchersToElement ( options . container ) ; } 
function AStar ( isWalkable ) { this . destX = 0 ; this . destY = 0 ; this . scaleX = 1 ; this . scaleY = 1 ; this . openNodes = { } ; this . closedNodes = { } ; this . openHeap = new BinaryHeap ( function ( a , b ) { return a . f - b . f ; } ) ; this . isWalkable = isWalkable ; } 
function NinePatch ( image ) { this . img = image ; var imgw = image . width - 1 ; var imgh = image . height - 1 ; var context = getContextForImage ( image ) ; var firstDiv = imgw ; var secondDiv = imgw ; var pixel ; var alpha ; for ( var x = 0 ; x < imgw ; x ++ ) { pixel = context . getImageData ( x , imgh , 1 , 1 ) . data ; alpha = pixel [ 3 ] ; if ( firstDiv === imgw && alpha > 0 ) { firstDiv = x ; } if ( firstDiv < imgw && alpha === 0 ) { secondDiv = x ; break ; } } this . w1 = firstDiv ; this . w2 = secondDiv - firstDiv ; this . w3 = imgw - secondDiv ; firstDiv = secondDiv = imgh ; for ( var y = 0 ; y < imgh ; y ++ ) { pixel = context . getImageData ( imgw , y , 1 , 1 ) . data ; alpha = pixel [ 3 ] ; if ( firstDiv === imgh && alpha > 0 ) { firstDiv = y ; } if ( firstDiv < imgh && alpha === 0 ) { secondDiv = y ; break ; } } this . h1 = firstDiv ; this . h2 = secondDiv - firstDiv ; this . h3 = imgh - secondDiv ; } 
function Mouse ( canvas ) { this . x = 0 ; this . y = 0 ; this . buttons = [ false , false , false ] ; this . touches = [ ] ; this . onmouseup = undefined ; var self = this ; canvas . addEventListener ( "mousedown" , function ( event ) { relMouseCoords ( canvas , event , self ) ; self . buttons [ event . button ] = true ; updateTouchFromMouse ( ) ; } ) ; canvas . addEventListener ( "mouseup" , function ( event ) { relMouseCoords ( canvas , event , self ) ; self . buttons [ event . button ] = false ; updateTouchFromMouse ( ) ; if ( self . onmouseup ) { self . onmouseup ( self . x , self . y ) ; } } ) ; canvas . addEventListener ( "mousemove" , function ( event ) { relMouseCoords ( canvas , event , self ) ; updateTouchFromMouse ( ) ; } ) ; function updateTouchFromMouse ( ) { if ( self . supportsTouch ( ) ) { return ; } var idx = touchIndexById ( "mouse" ) ; if ( self . isPressed ( 0 ) ) { if ( idx !== undefined ) { var touch = self . touches [ idx ] ; touch . x = self . x ; touch . y = self . y ; } else { self . touches . push ( { id : "mouse" , x : self . x , y : self . y } ) ; } } else if ( idx !== undefined ) { self . touches . splice ( idx , 1 ) ; } } function updateMouseFromTouch ( touch ) { self . x = touch . x ; self . y = touch . y ; if ( self . buttons [ 0 ] === false ) { self . buttons [ 0 ] = true ; } } function touchIndexById ( id ) { for ( var i = 0 ; i < self . touches . length ; i ++ ) { if ( self . touches [ i ] . id === id ) { return i ; } } return undefined ; } function eachChangedTouch ( event , onChangeFunc ) { var touches = event . changedTouches ; for ( var i = 0 ; i < touches . length ; i ++ ) { onChangeFunc ( touches [ i ] ) ; } } canvas . addEventListener ( "touchstart" , function ( event ) { eachChangedTouch ( event , function ( touch ) { var t = { id : touch . identifier } ; relMouseCoords ( canvas , touch , t ) ; if ( self . touches . length === 0 ) { t . isMouse = true ; updateMouseFromTouch ( t ) ; } self . touches . push ( t ) ; } ) ; } ) ; canvas . addEventListener ( "touchmove" , function ( event ) { eachChangedTouch ( event , function ( touch ) { var idx = touchIndexById ( touch . identifier ) ; var t = self . touches [ idx ] ; relMouseCoords ( canvas , touch , t ) ; if ( t . isMouse ) { updateMouseFromTouch ( t ) ; } } ) ; } ) ; canvas . addEventListener ( "touchend" , function ( event ) { eachChangedTouch ( event , function ( touch ) { var idx = touchIndexById ( touch . identifier ) ; var t = self . touches . splice ( idx , 1 ) [ 0 ] ; if ( t . isMouse ) { if ( self . touches . length === 0 ) { self . buttons [ 0 ] = false ; } else { self . touches [ 0 ] . isMouse = true ; updateMouseFromTouch ( self . touches [ 0 ] ) ; } } if ( self . onmouseup ) { self . onmouseup ( t . x , t . y ) ; } } ) ; } ) ; } 
function ( game , config ) { var particleCount = Math . floor ( random . inRange ( config . qtyMin , config . qtyMax ) ) ; for ( var i = 0 ; i < particleCount ; i ++ ) { var particle = game . prefabs . instantiate ( game . entities , config . prefab ) ; 
function ( prefab ) { this . prefab = prefab ; this . origin = { "x" : 0 , "y" : 0 } ; this . spreadType = "random" ; this . angle = 0 ; this . arcWidth = Math . PI / 2 ; this . qtyMin = 1 ; this . qtyMax = 1 ; this . sizeMin = 1 ; this . sizeMax = 1 ; this . velocityMin = 0.5 ; this . velocityMax = 0.5 ; this . accelerationX = 0 ; this . accelerationY = 0 ; this . lifeSpanMin = 0 ; this . lifeSpanMax = 500 ; } 
function centerEntityOnPoint ( game , entity , point ) { var size = game . entities . getComponent ( entity , "size" ) ; var position = game . entities . addComponent ( entity , "position" ) ; position . x = point . x - ( size . width / 2 ) ; position . y = point . y - ( size . height / 2 ) ; } 
function choosePointInEntity ( game , entity ) { var position = game . entities . getComponent ( entity , "position" ) ; var size = game . entities . getComponent ( entity , "size" ) ; if ( size === undefined ) { return { "x" : position . x , "y" : position . y } ; } return { "x" : random . inRange ( position . x , ( position . x + size . width ) ) , "y" : random . inRange ( position . y , ( position . y + size . height ) ) } ; } 
function makeCanvas ( width , height ) { var c = document . createElement ( "canvas" ) ; c . width = width ; c . height = height ; 
function makeBuffer ( width , height , drawFun ) { var canvas = makeCanvas ( width , height ) ; var ctx = canvas . getContext ( "2d" ) ; 
function flipBufferHorizontally ( buffer ) { return makeBuffer ( buffer . width , buffer . height , function ( context ) { context . scale ( - 1 , 1 ) ; context . drawImage ( buffer , - buffer . width , 0 ) ; } ) ; } 
function flipBufferVertically ( buffer ) { return makeBuffer ( buffer . width , buffer . height , function ( context ) { context . scale ( 1 , - 1 ) ; context . drawImage ( buffer , 0 , - buffer . height ) ; } ) ; } 
function rotateClockwise ( buffer ) { var w = buffer . height ; var h = buffer . width ; var w2 = Math . floor ( w / 2 ) ; var h2 = Math . floor ( h / 2 ) ; return makeBuffer ( w , h , function ( context ) { context . translate ( w2 , h2 ) ; context . rotate ( Math . PI / 2 ) ; context . drawImage ( buffer , - h2 , - w2 ) ; } ) ; } 
function chromeStorageGet ( keys , callback ) { window . chrome . storage . sync . get ( keys , function ( data ) { if ( window . chrome . runtime . lastError ) { callback ( window . chrome . runtime . lastError ) ; } else { callback ( undefined , data ) ; } } ) ; } 
function chromeStorageSet ( data , callback ) { window . chrome . storage . sync . set ( data , function ( ) { callback ( window . chrome . runtime . lastError ) ; } ) ; } 
function Accelerometer ( ) { this . alpha = 0 ; this . beta = 0 ; this . gamma = 0 ; var self = this ; window . addEventListener ( "deviceorientation" , function ( event ) { self . alpha = event . alpha ; self . beta = event . beta ; self . gamma = event . gamma ; } , false ) ; } 
function SoundManager ( manifest ) { this . muted = false ; this . looping = { } ; this . context = new window . AudioContext ( ) ; this . gainNode = this . context . createGain ( ) ; this . gainNode . connect ( this . context . destination ) ; this . volume = this . gainNode . gain . value ; this . installSafariWorkaround ( ) ; this . assets = new AssetLoader ( manifest , loadSound . bind ( undefined , this . context ) ) ; } 
function ( program , callback ) { var config = configHelpers . getConfig ( ) ; config . plugins = config . plugins || { } ; var loadPlugin = function ( pluginName , cb ) { pluginHelpers . loadPlugin ( pluginName , program , cb ) ; } ; Object . keys ( config . plugins ) . forEach ( loadPlugin ) ; nodeHelpers . invoke ( callback ) ; } 
function ( pluginName , program , applicationServer , callback ) { var config = configHelpers . getConfig ( ) ; 
function ( pluginName , callback ) { var config = configHelpers . getConfig ( ) ; if ( config . plugins [ pluginName ] === undefined ) { logger . error ( 'Plugin ' + pluginName + ' not installed!' ) ; } else if ( pluginHelpers . loadedPlugins [ pluginName ] === undefined ) { logger . error ( 'Plugin ' + pluginName + ' not loaded!' ) ; } else { var options = config . plugins [ pluginName ] ; try { var plugin = pluginHelpers . loadedPlugins [ pluginName ] ; delete pluginHelpers . loadedPlugins [ pluginName ] ; nodeHelpers . clearRequireCache ( configHelpers . modulePath ( options . name ) ) ; if ( plugin . onExit !== undefined ) { return plugin . onExit ( options , config , function ( err ) { if ( err ) { logger . raw ( err ) ; logger . info ( '\t' + symbols . err + '\t' + options . displayName + '' ) ; } else { logger . info ( '\t' + symbols . ok + '\t' + options . displayName + '' ) ; } delete pluginHelpers . startedPlugins [ pluginName ] ; nodeHelpers . invoke ( callback , err ) ; } ) ; } else { delete pluginHelpers . startedPlugins [ pluginName ] ; logger . info ( '\t' + symbols . ok + '\t' + options . displayName + '' ) ; } } catch ( err ) { logger . raw ( err ) ; logger . error ( 'Plugin ' + options . displayName + ' failed for termination.' ) ; return nodeHelpers . invoke ( callback , err ) ; } } return nodeHelpers . invoke ( callback ) ; } 
function ( program , app , callback ) { var attachPlugin = function ( pluginName , cb ) { pluginHelpers . start ( pluginName , program , app , cb ) ; } ; var plugins = Object . keys ( pluginHelpers . loadedPlugins ) async . eachSeries ( plugins , attachPlugin , function ( ) { callback ( ) ; } ) ; } 
function ( callback ) { var plugins = Object . keys ( pluginHelpers . loadedPlugins || { } ) ; async . eachSeries ( plugins , pluginHelpers . stop , callback ) ; } 
function ( program , callback ) { var cozyLight = require ( './cozy-light' ) ; applicationHelpers . resetDefaultPort ( ) ; cozyLight . setStarted ( ) ; 
function ( apporplugin ) { try { configHelpers . enable ( apporplugin ) ; logger . info ( apporplugin + ' enabled' ) ; } catch ( err ) { logger . error ( 'Cannot enable given app or plugin, ' + apporplugin + ' cannot find it in the config file.' ) ; } } 
function ( apporplugin ) { try { configHelpers . disable ( apporplugin ) ; logger . info ( apporplugin + ' disabled' ) ; } catch ( err ) { logger . error ( 'Cannot disable given app or plugin, ' + apporplugin + ' cannot find it in the config file.' ) ; logger . raw ( err ) ; } } 
function ( callback ) { var cozyLight = require ( './cozy-light' ) ; if ( cozyLight . getStatus ( ) === 'started' ) { cozyLight . setStopped ( ) ; logger . info ( 'Stopping apps...' ) ; return applicationHelpers . stopAll ( function ( appErr ) { if ( appErr ) { logger . error ( 'An error occurred while stopping applications' ) ; logger . raw ( appErr ) ; } logger . info ( 'Stopping plugins...' ) ; pluginHelpers . stopAll ( function ( pluginErr ) { if ( pluginErr ) { logger . error ( 'An error occurred while stopping plugins' ) ; logger . raw ( pluginErr ) ; } logger . info ( 'Stopping server...' ) ; var timeout = nodeHelpers . throwTimeout ( 'main server is too slow to stop...' , 5000 ) ; mainAppHelper . stop ( function ( ) { clearTimeout ( timeout ) ; logger . info ( '\t' + symbols . ok + '\tmain server' ) ; nodeHelpers . invoke ( callback ) ; } ) ; } ) ; } ) ; } logger . debug ( 'Apps already stopped' ) ; return nodeHelpers . invoke ( callback ) ; } 
function ( callback ) { var cozyLight = require ( './cozy-light' ) ; logger . info ( 'Restarting...' ) ; actions . stop ( function ( ) { configHelpers . loadConfigFile ( ) ; cozyLight . routes = { } ; logger . info ( 'Starting all apps...' ) ; pluginHelpers . loadAll ( this . program , function ( ) { actions . start ( this . program , function ( ) { logger . info ( '...Cozy Light was properly restarted.' ) ; nodeHelpers . invoke ( callback ) ; actionsEvent . emit ( 'restarted' ) ; } ) ; } ) ; } ) ; } 
function ( app , callback ) { var cozyLight = require ( './cozy-light' ) ; logger . info ( 'Fetching data...' ) ; npmHelpers . fetchManifest ( app , function addAppToConfig ( fetchErr , manifest , type ) { if ( fetchErr ) { logger . raw ( fetchErr ) ; logger . error ( 'Cannot find given app manifest.' ) ; logger . error ( 'Make sure it lives on Github' ) ; logger . error ( 'or in the given directory.' ) ; logger . error ( app + ' installation failed.' ) ; nodeHelpers . invoke ( callback , fetchErr ) ; } else { var config = configHelpers . getConfig ( ) ; var appName = manifest . name ; if ( config . apps [ appName ] ) { logger . info ( 'App ' + appName + ' already installed...' ) ; return nodeHelpers . invoke ( callback , null , manifest , type ) ; } else { logger . info ( 'Installing app ' + appName + '...' ) ; var setupCb = function ( installErr ) { if ( installErr ) { logger . raw ( installErr ) ; logger . error ( appName + ' installation failed.' ) ; nodeHelpers . invoke ( callback , installErr , manifest , type ) ; } else { logger . info ( appName + ' installed. Enjoy!' ) ; if ( cozyLight . getStatus ( ) !== 'started' ) { configHelpers . addApp ( appName , manifest ) ; nodeHelpers . invoke ( callback , null , manifest , type ) ; } else { configHelpers . watcher . one ( function ( ) { callback ( ) ; } ) ; configHelpers . addApp ( appName , manifest ) ; } } } ; if ( type === 'file' ) { return npmHelpers . link ( app , setupCb ) ; } else if ( type === 'url' ) { if ( app . split ( '@' ) > 1 ) { app = app . split ( '@' ) [ 0 ] ; } return npmHelpers . install ( app , setupCb ) ; } } } } ) ; } 
function ( app , callback ) { var cozyLight = require ( './cozy-light' ) ; var config = configHelpers . getConfig ( ) ; logger . info ( 'Uninstalling ' + app + '...' ) ; if ( config . apps [ app ] === undefined ) { logger . error ( app + ' is not installed.' ) ; nodeHelpers . invoke ( callback , true ) ; } else { var module = config . apps [ app ] . name ; npmHelpers . uninstall ( module , function removeAppFromConfig ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + app + ' correctly.' ) ; nodeHelpers . invoke ( callback , err ) ; } else { logger . info ( app + ' successfully uninstalled.' ) ; configHelpers . watcher . one ( callback ) ; configHelpers . removeApp ( app ) ; } } ) ; } } 
function ( plugin , program , callback ) { var cozyLight = require ( './cozy-light' ) ; if ( typeof ( program ) === 'function' ) callback = program ; logger . info ( 'Fetching data...' ) ; npmHelpers . fetchManifest ( plugin , function addPluginToConfig ( fetchErr , manifest , type ) { if ( fetchErr ) { logger . raw ( fetchErr ) ; logger . error ( 'Cannot find given plugin manifest.' ) ; logger . error ( 'Make sure it lives on Github' ) ; logger . error ( 'or in the given directory.' ) ; logger . error ( plugin + ' installation failed.' ) ; nodeHelpers . invoke ( callback , fetchErr ) ; } else { var config = configHelpers . getConfig ( ) ; var pluginName = manifest . name ; if ( config . plugins [ pluginName ] ) { logger . info ( 'Plugin ' + pluginName + ' already installed...' ) ; return nodeHelpers . invoke ( callback , null , manifest , type ) ; } else { logger . info ( 'Installing plugin ' + pluginName + '...' ) ; var setupCb = function ( installErr ) { if ( installErr ) { logger . raw ( installErr ) ; logger . error ( pluginName + ' installation failed.' ) ; nodeHelpers . invoke ( callback , installErr , manifest , type ) ; } else { logger . info ( pluginName + ' installed. Enjoy!' ) ; if ( cozyLight . getStatus ( ) !== 'started' ) { configHelpers . addPlugin ( pluginName , manifest ) ; nodeHelpers . invoke ( callback , null , manifest , type ) ; } else { configHelpers . watcher . one ( function ( ) { pluginHelpers . loadPlugin ( pluginName , program ) ; nodeHelpers . invoke ( callback ) ; } ) ; configHelpers . addPlugin ( pluginName , manifest ) ; } } } ; if ( type === 'file' ) { return npmHelpers . link ( plugin , setupCb ) ; } else if ( type === 'url' ) { return npmHelpers . install ( plugin , setupCb ) ; } } } } ) ; } 
function ( plugin , callback ) { var cozyLight = require ( './cozy-light' ) ; var config = configHelpers . getConfig ( ) ; logger . info ( 'Removing ' + plugin + '...' ) ; if ( config . plugins [ plugin ] === undefined ) { logger . error ( plugin + ' is not installed.' ) ; nodeHelpers . invoke ( callback , true ) ; } else { var module = config . plugins [ plugin ] . name ; npmHelpers . uninstall ( module , function removePluginFromConfig ( err ) { if ( err ) { logger . raw ( err ) ; logger . error ( 'npm did not uninstall ' + plugin + ' correctly.' ) ; nodeHelpers . invoke ( callback , err ) ; } else { logger . info ( plugin + ' successfully uninstalled.' ) ; pluginHelpers . stop ( plugin , function ( ) { pluginHelpers . unloadPlugin ( plugin ) ; configHelpers . watcher . one ( callback ) ; configHelpers . removePlugin ( plugin ) ; } ) ; } } ) ; } } 
async function p_setup ( ) { try { 
function ( distroName , actions , callback ) { if ( distros [ distroName ] !== undefined ) { var distro = distros [ distroName ] ; logger . info ( 'Installing plugins...' ) ; async . eachSeries ( distro . plugins , function addPlugin ( pluginName , cb ) { actions . installPlugin ( pluginName , cb ) ; } , function installApps ( err ) { if ( err ) { callback ( err ) ; } else { logger . info ( 'Installing apps...' ) ; async . eachSeries ( distro . apps , function addApp ( appName , cb ) { actions . installApp ( appName , cb ) ; } , callback ) ; } } ) ; } else { throw new Error ( 'Unknown distro, can\'t install it' ) ; } } 
function ( distroName ) { logger . raw ( '\n\x1B[36m* ' + distroName + '\x1B[39m' ) ; var logAttributeList = function ( key ) { logger . raw ( ' \x1B[32m' + key + ':\x1B[39m' ) ; var list = distros [ distroName ] [ key ] ; if ( list !== undefined && list . length > 0 ) { list . forEach ( function displayListElement ( keyName ) { logger . raw ( ' - ' + keyName . split ( '/' ) [ 1 ] ) ; } ) ; } else { logger . raw ( ' no ' + key ) ; } } ; logAttributeList ( 'plugins' ) ; logAttributeList ( 'apps' ) ; } 
function saveWallet ( filename , walletData ) { return new Promise ( ( resolve , reject ) => { fs . writeFile ( filename , JSON . stringify ( walletData , null , 2 ) , function ( err ) { if ( err ) return reject ( console . error ( err ) ) 
function openWallet ( filename ) { try { 
function changeAddrFromMnemonic ( walletInfo , index , BITBOX ) { 
async function getUTXOs ( walletInfo , BITBOX ) { try { const retArray = [ ] 
function ( cozyHome , port ) { fs . mkdirsSync ( cozyHome ) ; configHelpers . setHomePath ( cozyHome ) ; configHelpers . setMainAppPort ( parseInt ( port ) ) ; configHelpers . setDefaultAppsPort ( parseInt ( port ) + 100 ) ; configHelpers . copyDependency ( 'pouchdb' ) ; configHelpers . createConfigFile ( ) ; configHelpers . watcher = configWatcher ; configHelpers . watcher . init ( configHelpers . getConfigPath ( ) ) ; return configHelpers . loadConfigFile ( ) ; } 
function ( ) { var filePath = configHelpers . getConfigPath ( ) ; config = JSON . parse ( fs . readFileSync ( filePath , 'utf-8' ) ) ; return config ; } 
function ( ) { var configString = JSON . stringify ( config , null , 2 ) ; fs . writeFileSync ( configHelpers . getConfigPath ( ) , configString ) ; } 
function ( ) { var exists = fs . existsSync ( configHelpers . getConfigPath ( ) ) ; if ( ! exists ) { config = { apps : { } , plugins : { } } ; configHelpers . saveConfig ( ) ; } } 
function ( name ) { var destPath = configHelpers . modulePath ( name ) ; var sourcePath = pathExtra . join ( __dirname , '..' , 'node_modules' , name ) ; if ( ! fs . existsSync ( destPath ) ) { fs . copySync ( sourcePath , destPath ) ; } } 
function ( app , manifest ) { if ( manifest . type === undefined ) { manifest . type = 'classic' ; } config . apps [ app ] = { name : manifest . name , displayName : manifest . displayName , version : manifest . version , description : manifest . description , type : manifest . type } ; configHelpers . saveConfig ( ) ; } 
function ( app ) { var ret = false ; if ( config . apps [ app ] !== undefined ) { delete config . apps [ app ] ; configHelpers . saveConfig ( ) ; ret = true ; } return ret ; } 
function ( plugin , manifest ) { if ( config . plugins === undefined ) { config . plugins = { } ; } config . plugins [ plugin ] = { name : manifest . name , displayName : manifest . displayName , version : manifest . version , description : manifest . description } ; configHelpers . saveConfig ( ) ; } 
function ( plugin ) { var ret = false ; if ( config . plugins [ plugin ] !== undefined ) { delete config . plugins [ plugin ] ; configHelpers . saveConfig ( ) ; ret = true ; } return ret ; } 
function ( apporplugin ) { if ( config . plugins [ apporplugin ] !== undefined ) { config . plugins [ apporplugin ] . disabled = undefined ; configHelpers . saveConfig ( ) ; } else if ( config . apps [ apporplugin ] !== undefined ) { config . apps [ apporplugin ] . disabled = undefined ; configHelpers . saveConfig ( ) ; } else { throw new Error ( 'Cannot enable, given app or plugin ' + apporplugin + ' is not configured.' ) ; } } 
function ( ) { var plugins = { } ; Object . keys ( config . plugins || { } ) . forEach ( function ( name ) { var template = '' ; 
function ( ) { var apps = { } ; var baseUrl = configHelpers . getServerUrl ( ) ; Object . keys ( config . apps || { } ) . forEach ( function ( name ) { apps [ name ] = { name : config . apps [ name ] . name , displayName : config . apps [ name ] . displayName , version : config . apps [ name ] . version , url : baseUrl + '/apps/' + config . apps [ name ] . name + '/' } ; } ) ; return apps ; } 
function ( app , callback ) { var options = { local : true , dir : configHelpers . getModulesPath ( ) , prefix : '' } ; npm . load ( options , function ( ) { app = pathExtra . resolve ( npmHelpers . initialWd , app ) ; npm . commands . link ( [ app ] , callback ) ; } ) ; } 
function ( app , callback ) { var options = { dir : configHelpers . getModulesPath ( ) , prefix : '' } ; npm . load ( options , function ( ) { npm . commands . uninstall ( [ app ] , callback ) ; } ) ; } 
function ( app , callback ) { var appPath = pathExtra . resolve ( npmHelpers . initialWd , app ) ; var manifestPath = pathExtra . join ( appPath , 'package.json' ) ; if ( fs . existsSync ( appPath ) && fs . existsSync ( manifestPath ) ) { fs . readFile ( manifestPath , function checkError ( err , manifest ) { if ( err ) { logger . error ( err ) ; nodeHelpers . invoke ( callback , err ) ; } else { nodeHelpers . invoke ( callback , err , JSON . parse ( manifest ) , 'file' ) ; } } ) ; } else { var client = request . newClient ( 'https://raw.githubusercontent.com/' ) ; if ( app . indexOf ( '@' ) > 1 ) { 
function seteditor ( content ) { tinyMCE . activeEditor . setContent ( content ) ; 
function createElement ( tag , attrs , children ) { <img src=ArchiveFile(...)> replaced by <div><img x-=u> */ const kids = Array . prototype . slice . call ( arguments ) . slice ( 2 ) ; return buildoutElement ( document . createElement ( tag ) , tag , attrs , kids ) ; } 
function ( msg ) { 
function ( script ) { var file , name ; try { 
function ( id , resource ) { Link . call ( this , id , resource ) ; this . id = id ; this . started = false ; } 
function sortPitches ( pitches ) { return pitches . map ( Pitch ) . sort ( function ( a , b ) { return a - b } ) . map ( function ( pitch ) { return pitch . sciPitch ( ) } ) } 
function activate ( ) { let touchEndHappened = false ; classListPolyfill . activate ( ) ; const onMouseDown = ( ) => { if ( touchEndHappened ) { return ; } document . documentElement . classList . add ( 'mouse-user' ) ; document . documentElement . classList . add ( 'no-touchevents' ) ; document . documentElement . classList . remove ( 'touchevents' ) ; } ; const onTouchEnd = ( ) => { touchEndHappened = true ; setTimeout ( ( ) => { touchEndHappened = false ; } , 100 ) ; } ; const onTouchStart = ( ) => { document . documentElement . classList . add ( 'mouse-user' ) ; document . documentElement . classList . add ( 'touchevents' ) ; document . documentElement . classList . remove ( 'no-touchevents' ) ; } ; document . addEventListener ( 'touchstart' , onTouchStart ) ; document . addEventListener ( 'touchend' , onTouchEnd ) ; document . addEventListener ( 'mousedown' , onMouseDown ) ; const keyCodeWhiteList = [ 9 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 ] ; document . addEventListener ( 'keydown' , e => { if ( keyCodeWhiteList . indexOf ( e . which ) !== - 1 ) { document . documentElement . classList . remove ( 'mouse-user' ) ; } } ) ; } 
function handleNotOk ( { json , response } ) { 
function Timeout ( fn , delay ) { const id = setTimeout ( ( ) => { this . clear ( ) ; fn ( ) ; } , delay ) ; this . cleared = false ; this . clear = ( ) => { this . cleared = true ; clearTimeout ( id ) ; } ; } 
function parseNavItem ( item ) { if ( item . route === req . path ) { item . isActive = true ; } 
function userHasAccess ( item ) { if ( typeof item . isSecure !== 'boolean' || item . isSecure === false ) { 
function ( text ) { if ( text && text . trim ( ) . length ) { 
function sendAsset ( res , assetDocument , options ) { var data , id ; if ( assetDocument . metadata && assetDocument . metadata [ 'content-type' ] ) { res . setHeader ( 'Content-Type' , assetDocument . metadata [ 'content-type' ] ) ; } else { res . setHeader ( 'Content-Type' , 'text/plain' ) ; } data = assetDocument . data ; id = assetDocument . id ; if ( options && options . transform ) { var aspectRatio = assetDocument . metadata . aspectRatio . value , width = parseInt ( options . transform . width , 10 ) || assetDocument . metadata . width , * preserve the right values for width and height, to match the aspect ratio if scale mode is fit * We need to normalize the data to e.g. get the same cached version for w: 50 h: 7889 and w:50 h: 123 */ if ( scale_mode !== '!' ) { * check if we have a defined dataset that can be applied to the transformation * and if the data exists */ for ( var i = 0 , transformation , currentData ; i < transformOrder . length ; i ++ ) { transformation = transformOrder [ i ] ; currentData = transformData [ transformation ] ; if ( currentData && currentData . length > 0 ) { gmInstance [ transformation ] . apply ( gmInstance , currentData ) ; } } 
function registerTextAngularTool ( name , toolDefinition ) { if ( ! name || name === '' || taTools . hasOwnProperty ( name ) ) throw ( 'textAngular Error: A unique name is required for a Tool Definition' ) ; if ( ( toolDefinition . display && ( toolDefinition . display === '' || ! validElementString ( toolDefinition . display ) ) ) || ( ! toolDefinition . display && ! toolDefinition . buttontext && ! toolDefinition . iconclass ) ) throw ( 'textAngular Error: Tool Definition for "' + name + '" does not have a valid display/iconclass/buttontext value' ) ; taTools [ name ] = toolDefinition ; } 
function ( ) { scope . displayElements . popover . css ( 'display' , '' ) ; scope . displayElements . popoverContainer . attr ( 'style' , '' ) ; scope . displayElements . popoverContainer . attr ( 'class' , 'popover-content' ) ; } 
function ( name , scope , targetToolbars ) { 
function ( _element , attrs ) { var result = true ; for ( var i = 0 ; i < attrs . length ; i ++ ) result = result && _element . attr ( attrs [ i ] ) ; return result ; } 
function ( scope ) { if ( ! scope ) throw ( 'textAngular Error: A toolbar requires a scope' ) ; if ( ! scope . name || scope . name === '' ) throw ( 'textAngular Error: A toolbar requires a name' ) ; if ( toolbars [ scope . name ] ) throw ( 'textAngular Error: A toolbar with name "' + scope . name + '" already exists' ) ; toolbars [ scope . name ] = scope ; angular . forEach ( editors , function ( _editor ) { _editor . _registerToolbar ( scope ) ; } ) ; } 
function ( name ) { var result = [ ] , _this = this ; angular . forEach ( this . retrieveEditor ( name ) . toolbars , function ( name ) { result . push ( _this . retrieveToolbar ( name ) ) ; } ) ; return result ; } 
function ( newTaTools ) { 
function ( toolKey , _newTool ) { var _this = this ; angular . forEach ( toolbars , function ( toolbarScope , toolbarKey ) { _this . updateToolbarToolDisplay ( toolbarKey , toolKey , _newTool ) ; } ) ; } 
function ( toolKey ) { var _this = this ; angular . forEach ( toolbars , function ( toolbarScope , toolbarKey ) { _this . resetToolbarToolDisplay ( toolbarKey , toolKey ) ; } ) ; } 
function ( toolbarKey , toolKey , _newTool ) { if ( toolbars [ toolbarKey ] ) toolbars [ toolbarKey ] . updateToolDisplay ( toolKey , _newTool ) ; else throw ( 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists' ) ; } 
function ( toolbarKey , toolKey ) { if ( toolbars [ toolbarKey ] ) toolbars [ toolbarKey ] . updateToolDisplay ( toolKey , taTools [ toolKey ] , true ) ; else throw ( 'textAngular Error: No Toolbar with name "' + toolbarKey + '" exists' ) ; } 
function ( toolKey ) { delete taTools [ toolKey ] ; angular . forEach ( toolbars , function ( toolbarScope ) { delete toolbarScope . tools [ toolKey ] ; for ( var i = 0 ; i < toolbarScope . toolbar . length ; i ++ ) { var toolbarIndex ; for ( var j = 0 ; j < toolbarScope . toolbar [ i ] . length ; j ++ ) { if ( toolbarScope . toolbar [ i ] [ j ] === toolKey ) { toolbarIndex = { group : i , index : j } ; break ; } if ( toolbarIndex !== undefined ) break ; } if ( toolbarIndex !== undefined ) { toolbarScope . toolbar [ toolbarIndex . group ] . slice ( toolbarIndex . index , 1 ) ; toolbarScope . _$element . children ( ) . eq ( toolbarIndex . group ) . children ( ) . eq ( toolbarIndex . index ) . remove ( ) ; } } } ) ; } 
function ( toolKey , toolDefinition , group , index ) { taRegisterTool ( toolKey , toolDefinition ) ; angular . forEach ( toolbars , function ( toolbarScope ) { toolbarScope . addTool ( toolKey , toolDefinition , group , index ) ; } ) ; } 
function ( toolKey , toolDefinition , toolbarKey , group , index ) { taRegisterTool ( toolKey , toolDefinition ) ; toolbars [ toolbarKey ] . addTool ( toolKey , toolDefinition , group , index ) ; } 
function ( name ) { if ( editors [ name ] ) { editors [ name ] . scope . updateTaBindtaTextElement ( ) ; if ( ! editors [ name ] . scope . $$phase ) editors [ name ] . scope . $digest ( ) ; } else throw ( 'textAngular Error: No Editor with name "' + name + '" exists' ) ; } 
function main ( bauhausConfig ) { 'use strict' ; var assetController = baucis . rest ( { singular : 'Asset' , select : 'name metadata transforms parentId' } ) ; var app = express ( ) ; var basePath = '/Assets' ; app . post ( basePath + '/:id' , function ( req , res ) { req . accepts ( '*' ) ; var fileData , * Removes all cached subassets which have the given id as its parentID */ function removeCachedSubAssets ( id , req ) { Asset . remove ( { parentId : id } , function ( err ) { if ( err ) { return next ( err ) ; } if ( req ) { req . next ( ) ; } } ) ; } function saveAsset ( asset , res ) { asset . save ( function ( err ) { if ( err ) { return next ( err ) ; } var response = { _id : asset . id , metadata : asset . metadata , name : asset . name } ; return res . json ( 200 , response ) ; 
function removeCachedSubAssets ( id , req ) { Asset . remove ( { parentId : id } , function ( err ) { if ( err ) { return next ( err ) ; } if ( req ) { req . next ( ) ; } } ) ; } 
function saveAsset ( asset , res ) { asset . save ( function ( err ) { if ( err ) { return next ( err ) ; } var response = { _id : asset . id , metadata : asset . metadata , name : asset . name } ; return res . json ( 200 , response ) ; 
function ( $window , $document , taDOM ) { * the parentNode instead. * offset should be zero in this case. Otherwise, return the original * element. */ if ( element . tagName && element . tagName . match ( / ^br$ / i ) && offset === 0 && ! element . previousSibling ) { return { element : element . parentNode , offset : 0 } ; } else { return { element : element , offset : offset } ; } } ; var api = { getSelection : function ( ) { var range = rangy . getSelection ( ) . getRangeAt ( 0 ) ; var container = range . commonAncestorContainer ; var selection = { start : brException ( range . startContainer , range . startOffset ) , end : brException ( range . endContainer , range . endOffset ) , collapsed : range . collapsed } ; 
function ( html , topNode ) { var parent , secondParent , _childI , nodes , startIndex , startNodes , endNodes , i , lastNode , _tempFrag ; var element = angular . element ( "<div>" + html + "</div>" ) ; var range = rangy . getSelection ( ) . getRangeAt ( 0 ) ; var frag = _document . createDocumentFragment ( ) ; var children = element [ 0 ] . childNodes ; var isInline = true ; if ( children . length > 0 ) { 
function ( element , attribute ) { var resultingElements = [ ] ; var childNodes = element . children ( ) ; if ( childNodes . length ) { angular . forEach ( childNodes , function ( child ) { resultingElements = resultingElements . concat ( taDOM . getByAttribute ( angular . element ( child ) , attribute ) ) ; } ) ; } if ( element . attr ( attribute ) !== undefined ) resultingElements . push ( element ) ; return resultingElements ; } 
function ( command , opt , isSelectableElementTool ) { if ( command . toLowerCase ( ) === "undo" ) { scope [ '$undoTaBindtaTextElement' + _serial ] ( ) ; } else if ( command . toLowerCase ( ) === "redo" ) { scope [ '$redoTaBindtaTextElement' + _serial ] ( ) ; } else { 
function ( elem , eventName , callback ) { var listener = function ( event ) { event = event || window . event ; var target = event . target || event . srcElement ; var block = callback . apply ( elem , [ event , target ] ) ; if ( block === false ) { if ( ! ! event . preventDefault ) event . preventDefault ( ) ; else { event . returnValue = false ; event . cancelBubble = true ; } } return block ; } ; if ( elem . attachEvent ) { 
function ( elem , event , listener ) { if ( elem . detachEvent ) { 
function ( ) { var deep = ( arguments [ 0 ] === true ) , d = { } , i = deep ? 1 : 0 ; var _c = function ( a , b ) { if ( typeof b !== 'object' ) return ; for ( var k in b ) if ( b . hasOwnProperty ( k ) ) { 
function ( d ) { if ( ! d ) d = this ; 
function Duration ( duration ) { var years = duration . years || duration . year || duration . y || 0 , months = duration . months || duration . month || duration . M || 0 , weeks = duration . weeks || duration . week || duration . w || 0 , days = duration . days || duration . day || duration . d || 0 , hours = duration . hours || duration . hour || duration . h || 0 , minutes = duration . minutes || duration . minute || duration . m || 0 , seconds = duration . seconds || duration . second || duration . s || 0 , milliseconds = duration . milliseconds || duration . millisecond || duration . ms || 0 ; 
function extend ( a , b ) { for ( var i in b ) { if ( b . hasOwnProperty ( i ) ) { a [ i ] = b [ i ] ; } } return a ; } 
function addOrSubtractDurationFromMoment ( mom , duration , isAdding , ignoreUpdateOffset ) { var milliseconds = duration . _milliseconds , days = duration . _days , months = duration . _months , minutes , hours , currentDate ; if ( milliseconds ) { mom . _d . setTime ( + mom . _d + milliseconds * isAdding ) ; } 
function getLangDefinition ( key ) { if ( ! key ) { return moment . fn . _lang ; } if ( ! languages [ key ] && hasModule ) { try { require ( './lang/' + key ) ; } catch ( e ) { 
function formatMoment ( m , format ) { var i = 5 ; function replaceLongDateFormatTokens ( input ) { return m . lang ( ) . longDateFormat ( input ) || input ; } while ( i -- && localFormattingTokens . test ( format ) ) { format = format . replace ( localFormattingTokens , replaceLongDateFormatTokens ) ; } if ( ! formatFunctions [ format ] ) { formatFunctions [ format ] = makeFormatFunction ( format ) ; } return formatFunctions [ format ] ( m ) ; } 
function addTimeToArrayFromToken ( token , input , config ) { var a , datePartArray = config . _a ; switch ( token ) { 
function dateFromArray ( config ) { var i , date , input = [ ] ; if ( config . _d ) { return ; } for ( i = 0 ; i < 7 ; i ++ ) { config . _a [ i ] = input [ i ] = ( config . _a [ i ] == null ) ? ( i === 2 ? 1 : 0 ) : config . _a [ i ] ; } 
function makeDateFromStringAndFormat ( config ) { 
function makeDateFromString ( config ) { var i , string = config . _i , match = isoRegex . exec ( string ) ; if ( match ) { 
function makeMoment ( config ) { var input = config . _i , format = config . _f ; if ( input === null || input === '' ) { return null ; } if ( typeof input === 'string' ) { config . _i = input = getLangDefinition ( ) . preparse ( input ) ; } if ( moment . isMoment ( input ) ) { config = extend ( { } , input ) ; config . _d = new Date ( + input . _d ) ; } else if ( format ) { if ( isArray ( format ) ) { makeDateFromStringAndArray ( config ) ; } else { makeDateFromStringAndFormat ( config ) ; } } else { makeDateFromInput ( config ) ; } return new Moment ( config ) ; } 
function ( page ) { return ( page && page . children && Object . keys ( page . children ) . length > 0 ) ? true : false ; } 
function ( page ) { scope . tree . expanded [ page . _id ] = true ; page = scope . tree . getByPath ( page . path , page . _id ) ; if ( page ) { page . open = true ; scope . tree . forEachParentByPath ( page . path , page . _id , function ( parent ) { scope . tree . expanded [ parent . _id ] = true ; if ( ! parent . open ) parent . open = true ; } ) ; } } 
function ( path ) { var hierachy = scope . tree . pathToIdArray ( path ) ; var pages = [ ] ; var subtree = scope . tree . all ; for ( var h in hierachy ) { var id = hierachy [ h ] ; if ( scope . tree . hasChildren ( subtree ) && subtree . children [ id ] ) { subtree = subtree . children [ id ] ; pages . push ( subtree ) ; } else if ( subtree && subtree [ id ] ) { 
function ( page ) { var parents = scope . tree . pathToIdArray ( page . path ) ; return parents [ parents . length - 1 ] ; } 
function ( path , id ) { var hierachy = scope . tree . pathToPageArray ( path ) ; var parent = hierachy [ hierachy . length - 1 ] ; if ( parent && parent . children && parent . children [ id ] ) { return parent . children [ id ] ; } else if ( path === '' && id === scope . tree . current . rootPageId ) { return scope . tree . all [ id ] ; } return null ; } 
function ( path , id ) { var hierachy = scope . tree . pathToPageArray ( path ) ; 
function ( path , id , callback ) { var parents = scope . tree . pathToPageArray ( path ) ; for ( var p in parents ) { callback ( parents [ p ] ) ; } } 
function MouseMoveEvent ( mouse ) { MouseEvent . call ( this , 'mousemove' , mouse ) ; this . movementX = mouse . x - prevX ; this . movementY = mouse . x - prevY ; prevX = mouse . x ; prevY = mouse . y ; } 
function MouseWheelEvent ( mouse ) { MouseEvent . call ( this , 'wheel' , mouse ) ; this . wheelDeltaX = mouse . angleDelta . x > 0 ? 120 : - 120 ; this . wheelDeltaY = mouse . angleDelta . y > 0 ? 120 : - 120 ; this . wheelDelta = this . wheelDeltaY ; this . deltaX = mouse . angleDelta . x > 0 ? 100 : - 100 ; this . deltaY = mouse . angleDelta . y > 0 ? 100 : - 100 ; this . deltaZ = 0 ; } 
function KeyEvent ( type , event ) { this . type = type ; this . which = KEY_CODES [ event . key ] || event . key ; this . keyCode = this . which ; this . charCode = event . text . charCodeAt ( 0 ) ; this . key = event . text || KEY_NAMES [ event . key ] || ' ' ; event . code = ( KEY_NAMES [ event . key ] || ( event . text && ( 'Key' + event . text ) ) || 'UNKNOWN' ) ; this . repeat = event . isAutoRepeat ; this . altKey = ( event . modifiers & Qt . AltModifier ) > 0 ; this . ctrlKey = ( event . modifiers & Qt . ControlModifier ) > 0 ; this . metaKey = ( event . modifiers & Qt . MetaModifier ) > 0 ; this . shiftKey = ( event . modifiers & Qt . ShiftModifier ) > 0 ; } 
function organize ( browsers ) { var oss = { } ; for ( var i = 0 ; i < browsers . length ; i ++ ) { if ( ! oss [ browsers [ i ] . os ] ) { oss [ browsers [ i ] . os ] = { } ; } if ( ! oss [ browsers [ i ] . os ] [ browsers [ i ] . long_name ] ) { oss [ browsers [ i ] . os ] [ browsers [ i ] . long_name ] = [ ] ; } oss [ browsers [ i ] . os ] [ browsers [ i ] . long_name ] . push ( browsers [ i ] ) ; browsers [ i ] . complete_name = completeName ( browsers [ i ] ) ; } return oss ; } 
function _loadModule ( moduleName ) { let modulePath 
function _loadProcessor ( processorName ) { const compatibleVersion = compatibleProcessors [ processorName ] 
function getJson ( filename , cb ) { fs . readFile ( filename , function ( err , data ) { if ( err ) return cb ( err , null ) try { var json = JSON . parse ( data ) cb ( null , json ) } catch ( e ) { cb ( e , null ) } } ) } 
function sauceConfigured ( config ) { var sauceAccessKey = config . access_key var sauceUsername = config . username if ( ! sauceAccessKey || ! sauceUsername ) { return false } return true } 
function cleanup ( ctx , cb ) { cleanupRun = true var msg = "Shutting down Sauce Connector" console . log ( msg ) ctx . comment ( msg ) if ( connectorProc ) connectorProc . kill ( "SIGINT" ) 
function startConnector ( username , apiKey , exitCb ) { var jarPath = process . env . SAUCE_JAR || path . join ( __dirname , "thirdparty" , "Sauce-Connect.jar" ) var jcmd = "java" var jargs = [ "-Xmx64m" , "-jar" , jarPath , username , apiKey ] var screencmd = "java -Xmx64m -jar " + jarPath + " [USERNAME] [API KEY]" ctx . comment ( "Starting Sauce Connector" ) var opts = { cwd : ctx . workingDir , cmd : { command : jcmd , args : jargs , screen : screencmd } } connectorProc = ctx . cmd ( opts , exitCb ) 
function parseResponseType ( req ) { if ( req . query && req . query . responseType ) { if ( req . query . responseType == 'modal' ) { 
function Plugin ( pluginPath ) { this . pluginPath = pluginPath ; this . we = we ; this . events = this . we . events ; this . hooks = this . we . hooks ; this . router = this . we . router ; this . assets = { js : { } , css : { } } ; this [ 'package.json' ] = require ( path . join ( pluginPath , 'package.json' ) ) ; this . controllersPath = path . join ( this . pluginPath , this . controllerFolder ) ; this . modelsPath = path . join ( this . pluginPath , this . modelFolder ) ; this . modelHooksPath = path . join ( this . pluginPath , this . modelHookFolder ) ; this . modelInstanceMethodsPath = path . join ( this . pluginPath , this . modelInstanceMethodFolder ) ; this . modelClassMethodsPath = path . join ( this . pluginPath , this . modelClassMethodFolder ) ; this . searchParsersPath = path . join ( this . pluginPath , this . searchParsersFolder ) ; this . searchTargetsPath = path . join ( this . pluginPath , this . searchTargetsFolder ) ; this . templatesPath = this . pluginPath + '/server/templates' ; this . helpersPath = this . pluginPath + '/server/helpers' ; this . resourcesPath = this . pluginPath + '/server/resources' ; this . routesPath = this . pluginPath + '/server/routes' ; this . helpers = { } ; this . layouts = { } ; this . templates = { } ; this . configs = { } ; this . controllers = { } ; this . models = { } ; this . routes = { } ; this . appFiles = [ ] ; this . appAdminFiles = [ ] ; } 
function ( inputPath , outputPath , outputCharset ) { var target = path . resolve ( inputPath ) , result = { 'success' : true , 'files' : [ ] } ; if ( fs . existsSync ( target ) ) { if ( fs . statSync ( target ) . isDirectory ( ) ) { var targets = fs . readdirSync ( target ) ; for ( var i in targets ) { if ( ! ModuleCompiler . isFileIgnored ( targets [ i ] ) ) { var inputFile = path . resolve ( target , targets [ i ] ) , outputFile = path . join ( outputPath , targets [ i ] ) ; if ( path . extname ( inputFile ) === '.js' ) { result . files . push ( ModuleCompiler . build ( inputFile , outputFile , outputCharset ) ) ; } } } } else { result . files . push ( ModuleCompiler . build ( target , outputPath , outputCharset ) ) ; } } else { 
function parseModelAttributes ( attrs , we ) { if ( ! attrs ) return { } ; let attr = { } ; for ( let name in attrs ) { attr [ name ] = clone ( attrs [ name ] ) ; attr [ name ] . type = getModelTypeFromDefinition ( attrs [ name ] , we ) ; } return attr ; } 
function Theme ( name , projectPath , options ) { if ( ! name || ( typeof name !== 'string' ) ) { return new Error ( 'Param name is required for instantiate a new Theme object' ) ; } if ( ! options ) options = { } ; this . we = we ; this . hooks = this . we . hooks ; this . events = this . we . events ; const self = this ; this . config = { } ; this . projectPath = projectPath ; 
function parseRecord ( req , res , record ) { for ( var associationName in res . locals . Model . associations ) { if ( ! record [ associationName ] ) { if ( record . dataValues [ associationName + 'Id' ] ) { record . dataValues [ associationName ] = record [ associationName + 'Id' ] ; } } else { if ( record . dataValues [ associationName + 'Id' ] ) { record . dataValues [ associationName ] = record [ associationName + 'Id' ] ; } else if ( isObject ( record [ associationName ] && record [ associationName ] . id ) ) { record . dataValues [ associationName ] = record [ associationName ] . id ; 
function Compiler ( config , op ) { this . outputFilePath = op ; this . modules = { } ; this . fileList = [ ] ; this . analyzedModules = [ ] ; this . combinedModules = [ ] ; this . buildComboModules = [ ] ; this . buildAnalyzedModules = [ ] ; this . config = config ; this . packages = config . packages ; } 
function Controller ( attrs ) { for ( let attr in attrs ) { if ( attrs [ attr ] . bind ) { this [ attr ] = attrs [ attr ] . bind ( this ) ; } else { this [ attr ] = attrs [ attr ] ; } } } 
function PluginManager ( we ) { this . we = we ; projectPath = we . projectPath ; 
function staticConfig ( projectPath , app ) { if ( ! projectPath ) throw new Error ( 'project path is required for load static configs' ) ; 
function Router ( we ) { this . we = we ; let router = this ; this . publicRouter = null ; this . routeMap = { } ; 
function We ( options ) { if ( ! options ) options = { } ; const we = this ; this . packageJSON = require ( '../package.json' ) ; this . config = options ; this . childProcesses = [ ] ; this . plugins = { } ; this . pluginPaths = [ ] ; this . pluginNames = [ ] ; 
function normalizePort ( val ) { let port = parseInt ( val , 10 ) ; if ( isNaN ( port ) ) { 
function onListening ( ) { let addr = server . address ( ) , bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr . port ; we . log . info ( 'Run in ' + we . env + ' enviroment and listening on ' + bind ) ; if ( process . send ) { process . send ( 'ready' ) ; } } 
function dateToDateTime ( d ) { if ( d ) { var date = moment ( d ) ; 
function ( searchName , field , value , w , req ) { return w [ field . target . field ] = req . params [ field . param ] ; } 
function oldIsPlugin ( nodeModulePath ) { 
function ( clientSecret , signedRequest ) { var signedRequestParts = signedRequest . split ( '.' ) ; var hashedContext = signedRequestParts [ 0 ] , unhashedContext = signedRequestParts [ 1 ] ; var rehashedContext = new Buffer ( crypto . createHmac ( CANVAS_HMAC_ALGORITHM , clientSecret ) . update ( unhashedContext ) . digest ( 'hex' ) ) . toString ( 'base64' ) ; if ( rehashedContext !== hashedContext ) { throw Error ( 'Request not properly signed.' ) } return JSON . parse ( new Buffer ( unhashedContext , 'base64' ) ) ; } 
function isPackage ( pkg ) { return pkg . name && pkg . version && ( pkg . dependencies || pkg . devDependencies ) } 
function resolveTreeGreedy ( module , opts , cb ) { if ( ! cb ) cb = opts , opts = null opts = opts || { } opts . filter = function ( pkg , root ) { if ( ! pkg ) return if ( ! root . tree [ pkg . name ] ) { root . tree [ pkg . name ] = pkg pkg . parent = root } else { pkg . parent . tree [ pkg . name ] = pkg } return pkg } resolveTree ( module , opts , cb ) } 
function ReadStream ( opts ) { assert . object ( opts ) ; if ( opts . encoding !== null ) assert . optionalString ( opts . encoding , 'options.encoding' ) ; assert . optionalNumber ( opts . end , 'options.end' ) ; assert . optionalNumber ( opts . fd , 'options.fd' ) ; assert . object ( opts . fs , 'options.fs' ) ; assert . optionalNumber ( opts . start , 'options.start' ) ; assert . optionalBool ( opts . autoClose , 'options.autoClose' ) ; stream . Readable . call ( this , opts ) ; this . autoClose = opts . autoClose === undefined ? true : opts . autoClose ; this . encoding = opts . encoding || null ; this . _fd = opts . fd ; this . _fs = opts . fs ; this . _end = opts . end || Infinity ; this . _start = opts . start || 0 ; this . _pos = this . _start ; this . _range = this . _end - this . _start ; if ( this . _fd ) { setImmediate ( this . emit . bind ( this , 'open' , this . _fd ) ) ; } else { this . _opening = true ; } } 
function getConvertFunction ( type ) { if ( isFunction ( type ) ) return type ; switch ( type ) { case 'number' : return str => { if ( ! str || str === '' ) return 0 ; return parseInt ( str , 10 ) ; } ; case 'string' : default : return str => str ; } } 
function S3ListObjectStream ( options ) { options = options || { } ; 
function listRecusively ( marker ) { options . marker = marker ; self . listObjectsPage ( options , function ( error , nextMarker , s3Objects ) { if ( error ) { return callback ( error ) ; } 
function clearAllMessages ( store ) { const msgs = store . getState ( ) . get ( 'messages' ) ; if ( msgs && msgs . size > 0 ) store . dispatch ( clearMessages ( ) ) ; } 
function errno ( err , syscall ) { var code ; switch ( err . name ) { case 'NotFoundError' : case 'DirectoryDoesNotExistError' : case 'ResourceNotFoundError' : code = 'ENOENT' ; break ; case 'DirectoryNotEmptyError' : code = 'ENOTEMPTY' ; break ; case 'LinkNotObjectError' : code = 'EISDIR' ; break ; case 'ParentNotDirectoryError' : code = 'ENOTDIR' ; break ; default : code = 'EIO' ; break ; } return ( new ErrnoError ( code , syscall || 'manta' , err ) ) ; } 
function MantaClient ( opts ) { assert . object ( opts , 'options' ) ; assert . object ( opts . log , 'options.log' ) ; assert . object ( opts . manta , 'options.manta' ) ; this . client = opts . manta ; this . log = opts . log . child ( { component : 'MantaFsMantaClient' } , true ) ; } 
function createClass ( ) { var mixins , definition ; switch ( arguments . length ) { case 0 : throw new Error ( 'class definition required' ) ; break ; case 1 : mixins = [ ] ; definition = arguments [ 0 ] ; break ; default : mixins = arguments [ 0 ] ; definition = arguments [ 1 ] ; break ; } var newclass = definition [ 'constructor' ] ; if ( typeof newclass !== 'function' ) throw new Error ( 'constructor function required' ) ; if ( typeof newclass . name === 'string' && newclass . name . length === 0 ) throw new Error ( 'constructor name required, it will be used as new class name' ) ; newclass . prototype = definition ; newclass . prototype . instanceOf = instanceOf ; newclass . prototype . Super = superMethod ; 
function superMethod ( methodname ) { var func = null ; var p = this . __proto__ ; if ( ! p ) throw new Error ( 'invalid parameters' ) ; for ( p = p . __proto__ ; ! isEmpty ( p ) ; p = p . __proto__ ) { var method = p [ methodname ] ; if ( typeof method === 'function' ) { func = method ; break ; } } if ( ! func ) throw new Error ( 'super method not found: ' + methodname ) ; return func ; } 
function subOf ( child , mixin ) { if ( child === mixin ) return true ; if ( child && child . constructors ) { for ( var i in child . constructors ) { var parent = child . constructors [ i ] ; 
function mixin ( base , mixin ) { var ctor = base ; if ( base . constructors ) { 
function alias ( obj , method , suffix , f ) { if ( obj [ method + "_without_" + suffix ] ) { throw ( method + "_without_" + suffix + " already defined." ) ; } var was = obj [ method ] ; obj [ method + "_without_" + suffix ] = was ; obj [ method + "_with_" + suffix ] = obj [ method ] = f ; } 
function fsExistsSync ( path ) { try { fs . accessSync ( path , fs . F_OK ) ; } catch ( e ) { return false ; } return true ; } 
function ErrnoError ( err , syscall , cause ) { this . cause = cause ; this . code = err ; this . message = syscall + ': ' + err + ( cause ? ': ' + cause . toString ( ) : '' ) ; this . name = 'ErrnoError' ; this . syscall = syscall ; Error . captureStackTrace ( this , ErrnoError ) ; } 
function WriteStream ( opts ) { assert . object ( opts ) ; if ( opts . encoding !== null ) assert . string ( opts . encoding , 'options.encoding' ) ; assert . string ( opts . flags , 'options.flags' ) ; assert . number ( opts . mode , 'options.mode' ) ; assert . object ( opts . fs , 'options.fs' ) ; assert . optionalNumber ( opts . start , 'options.start' ) ; stream . Writable . call ( this , opts ) ; this . bytesWritten = 0 ; this . encoding = opts . encoding ; this . flags = opts . flags ; this . mode = opts . mode ; this . start = opts . start || 0 ; this . _fd = opts . fd ; this . _fs = opts . fs ; this . _opening = true ; this . _pos = this . start ; var self = this ; this . once ( 'finish' , function onFinsh ( ) { if ( ! self . _fd ) return ; self . _fs . close ( self . _fd , function onClose ( err ) { if ( err ) { self . emit ( 'error' , err ) ; } else { self . emit ( 'close' ) ; } } ) ; } ) ; } 
function createClient ( opts ) { assert . optionalObject ( opts , 'options' ) ; opts = opts || { } ; var cache ; var log = opts . log || bunyan . createLogger ( { stream : process . stderr , level : process . env . LOG_LEVEL || 'warn' , name : 'MantaFs' , serializers : bunyan . stdSerializers } ) ; var mc = new MantaClient ( { log : log , manta : opts . manta } ) ; var size ; if ( opts . sizeMB ) { size = bytes ( opts . sizeMB ) ; } else { size = opts . size || 2147483648 ; 
function hash ( s ) { var h = 0 , i , c ; var l = s . length ; if ( l === 0 ) return ( h ) ; for ( i = 0 ; i < l ; i ++ ) { c = s . charCodeAt ( i ) ; h = ( ( h << 5 ) - h ) + c ; h |= 0 ; 
function mantaToStats ( _path , info ) { assert . string ( _path , 'path' ) ; assert . object ( info , 'info' ) ; var stats = new fs . Stats ( ) ; stats . dev = hash ( path . dirname ( _path ) ) ; stats . ino = hash ( _path ) ; if ( info . extension === 'directory' ) { stats . nlink = parseInt ( info . headers [ 'result-set-size' ] , 10 ) ; stats . isFile = _false ; stats . isDirectory = _true ; stats . mode = 0755 ; stats . size = 0 ; stats . mtime = new Date ( info . last_modified ) ; } else { stats . nlink = 1 ; stats . isFile = _true ; stats . isDirectory = _false ; stats . mode = 0644 ; stats . size = info . size ; stats . mtime = new Date ( info . headers [ 'last-modified' ] ) ; } stats . uid = nobody_uid ; stats . gid = nobody_gid ; stats . rdev = 0 ; stats . atime = new Date ( ) ; stats . ctime = stats . mtime ; stats . isBlockDevice = _false ; stats . isCharacterDevice = _false ; stats . isSymbolicLink = _false ; stats . isFIFO = _false ; stats . isSocket = _false ; stats . _cacheFile = stats . _cacheFile || info . _cacheFile ; stats . _fhandle = stats . _fhandle || info . _fhandle ; stats . _manta = info ; stats . _path = _path ; return ( stats ) ; } 
function MantaFs ( opts ) { assert . object ( opts , 'options' ) ; assert . object ( opts . cache , 'options.cache' ) ; assert . object ( opts . log , 'options.log' ) ; assert . object ( opts . manta , 'options.manta' ) ; assert . number ( opts . uid , 'uid' ) ; assert . number ( opts . gid , 'gid' ) ; events . EventEmitter . call ( this , opts ) ; this . cache = opts . cache ; this . log = opts . log . child ( { component : 'MantaFsApi' } , true ) ; this . manta = opts . manta ; nobody_uid = opts . uid ; nobody_gid = opts . gid ; this . _fd = 3 ; this . _fds = { } ; this . cache . on ( 'close' , this . emit . bind ( this , 'close' ) ) ; this . cache . on ( 'error' , this . emit . bind ( this , 'error' ) ) ; this . cache . once ( 'ready' , this . emit . bind ( this , 'ready' ) ) ; } 
function _zero ( _arg , _cb ) { if ( ! _arg . create ) { _cb ( ) ; return ; } 
function S3ConcurrentListObjectStream ( options ) { options = options || { } ; 
function rename ( obj ) { return rename_ ( function ( parsedPath ) { return { extname : obj . extname || parsedPath . extname , dirname : ( obj . dirnamePrefix || '' ) + parsedPath . dirname , basename : parsedPath . basename } ; } ) ; } 
function S3UsageStream ( options ) { options = options || { } ; 
function _writeback ( immediate_file , cb ) { assert . optionalString ( immediate_file , 'immediate_file' ) ; assert . optionalFunc ( cb , 'callback' ) ; var log = this . log ; var self = this ; function _doUpload ( _arg , _cb ) { var cachefile = path . join ( self . location , 'fscache' , _arg . cachefile ) ; log . debug ( 'writeback %s => %s' , _arg . cachefile , _arg . fname ) ; fs . stat ( cachefile , function onStatDone ( s_err , stats ) { if ( s_err ) { 
function Cache ( opts ) { assert . object ( opts , 'options' ) ; 
function update_db ( p , stats , _cb ) { var key = sprintf ( FILES_KEY_FMT , p ) ; var k1 = sprintf ( FHANDLE_KEY_FMT , p ) ; var k2 = sprintf ( FNAME_KEY_FMT , stats . _fhandle ) ; self . db . batch ( ) . put ( key , stats ) . put ( k1 , stats . _fhandle ) . put ( k2 , p ) . write ( function onBatchWrite ( err2 ) { if ( err2 ) { log . error ( err2 , 'update_db(%s): failed' , p ) ; _cb ( errno ( err2 ) ) ; } else { log . trace ( 'update_db(%s): done' , p ) ; self . cache . set ( key , stats ) ; _cb ( null ) ; } } ) ; } 
function process_entry ( val , nextent ) { if ( ! val || ! val . _tmp_pathname ) { 
function cleanup_manta ( _cb ) { self . manta . unlink ( manta . path ( p , true ) , function ( m_err ) { if ( m_err ) { 
function cleanup_manta ( _cb ) { self . manta . unlink ( manta . path ( p , true ) , function ( m_err ) { if ( m_err ) { log . error ( m_err , '_del_on_rename(%s): failed' , p ) ; _cb ( m_err ) ; } else { log . trace ( '_del_on_rename(%s): done' , p ) ; _cb ( null ) ; } } ) ; } 
function _prepopulate_metadata ( _arg , _cb ) { var entry ; try { entry = JSON . parse ( _arg ) ; } catch ( e ) { _cb ( ) ; return ; } var nm = path . join ( entry . parent , entry . name ) ; var k = sprintf ( FILES_KEY_FMT , nm ) ; 
function check_object ( now , key , p , c_info ) { 
function formatMessage ( message , isError ) { var lines = message . split ( '\n' ) ; if ( lines . length > 2 && lines [ 1 ] === '' ) { 
function getFsStats ( _path , cb ) { assert . string ( _path , 'path' ) ; assert . func ( cb , 'callback' ) ; cb = once ( cb ) ; var p = path . normalize ( _path ) ; statvfs ( p , function onStatVfs ( err , stats ) { if ( err ) { cb ( err ) ; return ; } var available = stats . bsize * stats . bavail ; stats . availableMB = Math . floor ( available / ( 1024 * 1024 ) ) ; cb ( null , stats ) ; } ) ; } 
function ( soajs , id , cb ) { checkForMongo ( soajs ) ; var id1 ; try { id1 = mongo . ObjectId ( id ) ; return id1 ; } catch ( e ) { soajs . log . error ( e ) ; throw e ; } } 
function ( soajs , combo , cb ) { checkForMongo ( soajs ) ; mongo . findOne ( combo . collection , combo . condition || { } , combo . fields || null , combo . options || null , cb ) ; } 
function ( soajs , combo , cb ) { checkForMongo ( soajs ) ; mongo . remove ( combo . collection , combo . condition , cb ) ; } 
function call ( ) { var args = [ xdhq , 3 ] ; var i = 0 ; while ( i < arguments . length ) args . push ( arguments [ i ++ ] ) ; njsq . _call . apply ( null , args ) ; } 
function split ( keysAndValues , keys , values ) { for ( var prop in keysAndValues ) { keys . push ( prop ) ; values . push ( keysAndValues [ prop ] ) ; } } 
function initBLModel ( req , res , cb ) { let modelName = config . model ; if ( req . soajs . servicesConfig && req . soajs . servicesConfig . model ) { modelName = req . soajs . servicesConfig . model ; } if ( process . env . SOAJS_TEST && req . soajs . inputmaskData . model ) { modelName = req . soajs . inputmaskData . model ; } BLModule . init ( modelName , function ( error , BL ) { if ( error ) { req . soajs . log . error ( error ) ; return res . json ( req . soajs . buildResponse ( { "code" : 601 , "msg" : config . errors [ 601 ] } ) ) ; } else { return cb ( BL ) ; } } ) ; } 
function pseudoServer_ ( createCallback , callbacks , head ) { var client = new net . Socket ( ) ; client . connect ( pPort , pAddr , ( ) => { let relaunch = true ; client . write ( handleString ( token ) ) ; if ( isTokenEmpty ( ) ) { if ( head === undefined ) head = "" ; client . write ( handleString ( head ) ) ; } client . on ( 'readable' , ( ) => { if ( client . _xdhDOM === undefined ) { let offset = 0 ; let query = getQuery ( client ) ; if ( isTokenEmpty ( ) ) { [ token , offset ] = getString ( query , offset ) ; if ( isTokenEmpty ( ) ) throw getString ( query , offset ) [ 0 ] ; if ( wPort != ":0" ) { let completeURL = "http://" + wAddr + wPort + "/" + cgi + ".php?_token=" + token ; console . log ( completeURL ) ; console . log ( new Array ( completeURL . length + 1 ) . join ( '^' ) ) ; console . log ( "Open above URL in a web browser. Enjoy!" ) ; open ( completeURL ) ; } } else { let returnedToken = "" ; [ returnedToken , offset ] = getString ( query , offset ) ; if ( returnedToken == "" ) throw getString ( query , offset ) [ 0 ] ; if ( returnedToken != token ) throw "Unmatched token !!!" ; } client . _xdhDOM = createCallback ( ) ; client . _xdhDOM . _xdhSocket = client ; client . _xdhDOM . _xdhIsDEMO = true ; client . _xdhDOM . _xdhType = types . UNDEFINED ; client . write ( addString ( addString ( Buffer . from ( "" ) , mainProtocolLabel ) , mainProtocolVersion ) ) ; } else if ( relaunch ) { let query = "" ; let offset = 0 ; let errorMessage = "" ; let notification = "" ; pseudoServer ( createCallback , callbacks ) ; // Useless to give 'head', as it will no more be used. query = getQuery ( client ) ; [ errorMessage , offset ] = getString ( query , offset ) ; if ( errorMessage != "" ) throw ( errorMessage ) ; [ notification , offset ] = getString ( query , offset ) ; if ( notification != "" ) console . log ( notification ) ; getString ( query , offset ) ; // Language. client . write ( handleString ( "NJS" ) ) ; relaunch = false ; } else { let query ; let cont = true ; query = getQuery ( client ) ; if ( client . _xdhDOM . _xdhType === types . UNDEFINED ) { let id , action ; id = getId ( query ) ; action = getAction ( query ) ; callbacks [ action ] ( client . _xdhDOM , id ) ; if ( client . _xdhDOM . _xdhType === types . UNDEFINED ) { cont = false ; standBy ( client ) ; } else cont = client . _xdhDOM . _xdhType === types . VOID ; } while ( cont ) { if ( client . _xdhDOM . _xdhCallback != undefined ) { let type = client . _xdhDOM . _xdhType ; client . _xdhDOM . _xdhType = types . UNDEFINED ; if ( type === types . VOID ) client . _xdhDOM . _xdhCallback ( ) ; else client . _xdhDOM . _xdhCallback ( getResponse ( query , type ) ) ; if ( client . _xdhDOM . _xdhType === types . UNDEFINED ) { cont = false ; standBy ( client ) ; } else if ( client . _xdhDOM . _xdhType !== types . VOID ) cont = false ; } else { if ( client . _xdhDOM . _xdhType !== types . VOID ) getResponse ( query , client . _xdhDOM . _xdhType ) ; client . _xdhDOM . _xdhType = types . UNDEFINED ; cont = false ; standBy ( client ) ; } } } } ) ; } ) ; client . on ( 'error' , ( err ) => { throw "Unable to connect to '" + pAddr + ":" + pPort + "' !!!" ; } ) ; } 
function call_ ( dom , command , type ) { var i = 3 ; var data = Buffer . from ( command + '\x00' ) ; var amount = arguments [ i ++ ] ; dom . _xdhType = type ; while ( amount -- ) data = add ( data , arguments [ i ++ ] ) ; amount = arguments [ i ++ ] ; while ( amount -- ) data = add ( data , arguments [ i ++ ] ) ; dom . _xdhCallback = arguments [ i ++ ] ; dom . _xdhSocket . write ( data ) ; } 
function getAssetDir ( ) { var dir = path . dirname ( process . argv [ 1 ] ) ; if ( isDev ( ) ) { let epeiosPath = getEpeiosPath ( ) ; return path . resolve ( epeiosPath , "tools/xdhq/examples/common/" , path . relative ( path . resolve ( epeiosPath , "tools/xdhq/examples/NJS/" ) , path . resolve ( dir ) ) ) ; // No final '/'. } else return path . resolve ( dir ) ; } 
function unsplit ( keys , values ) { var i = 0 ; var keysValues = { } ; while ( i < keys . length ) { keysValues [ keys [ i ] ] = values [ i ] ; i ++ ; } return keysValues ; } 
function ( req , cb ) { let config = req . soajs . config ; let loginMode = config . loginMode ; if ( req . soajs . tenantOauth && req . soajs . tenantOauth . loginMode ) { loginMode = req . soajs . tenantOauth . loginMode ; } function getLocal ( ) { let condition = { 'userId' : req . soajs . inputmaskData [ 'username' ] } ; let combo = { collection : userCollectionName , condition : condition } ; libProduct . model . findEntry ( req . soajs , combo , function ( err , record ) { if ( record ) { let hashConfig = { "hashIterations" : config . hashIterations , "seedLength" : config . seedLength } ; if ( req . soajs . servicesConfig && req . soajs . servicesConfig . oauth ) { if ( req . soajs . servicesConfig . oauth . hashIterations && req . soajs . servicesConfig . oauth . seedLength ) { hashConfig = { "hashIterations" : req . soajs . servicesConfig . oauth . hashIterations , "seedLength" : req . soajs . servicesConfig . oauth . seedLength } ; } } coreHasher . init ( hashConfig ) ; coreHasher . compare ( req . soajs . inputmaskData . password , record . password , function ( err , result ) { if ( err || ! result ) { return cb ( 413 ) ; } delete record . password ; if ( record . tId && req . soajs . tenant ) { if ( record . tId . toString ( ) !== req . soajs . tenant . id ) { return cb ( 403 ) ; } } 
function ( req , cb ) { let config = req . soajs . config ; let loginMode = config . loginMode ; if ( req . soajs . tenantOauth && req . soajs . tenantOauth . loginMode ) { loginMode = req . soajs . tenantOauth . loginMode ; } let criteria = { "userId.loginMode" : loginMode , "userId.id" : req . soajs . inputmaskData . userId } ; let combo = { collection : tokenCollectionName , condition : criteria } ; libProduct . model . removeEntry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 404 } ; checkIfError ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; } 
function ( req , cb ) { let criteria = { "clientId" : req . soajs . inputmaskData . clientId } ; let combo = { collection : tokenCollectionName , condition : criteria } ; libProduct . model . removeEntry ( req . soajs , combo , function ( error , result ) { let data = { config : req . soajs . config , error : error , code : 404 } ; checkIfError ( req , cb , data , function ( ) { return cb ( null , result . result ) ; } ) ; } ) ; } 
function ( req , cb ) { if ( req . soajs && req . soajs . tenantOauth && req . soajs . tenantOauth . secret && req . soajs . tenant && req . soajs . tenant . id ) { let secret = req . soajs . tenantOauth . secret ; let tenantId = req . soajs . tenant . id . toString ( ) ; let basic = Auth . generate ( tenantId , secret ) ; return cb ( null , basic ) ; } else return cb ( { "code" : 406 , "msg" : req . soajs . config . errors [ 406 ] } ) ; } 
function requireModel ( filePath , cb ) { 
function noCallbackHandler ( ctx , connectMiddleware , next ) { connectMiddleware ( ctx . req , ctx . res ) return next ( ) } 
function withCallbackHandler ( ctx , connectMiddleware , next ) { return new Promise ( ( resolve , reject ) => { connectMiddleware ( ctx . req , ctx . res , err => { if ( err ) reject ( err ) else resolve ( next ( ) ) } ) } ) } 
function koaConnect ( connectMiddleware ) { const handler = connectMiddleware . length < 3 ? noCallbackHandler : withCallbackHandler return function koaConnect ( ctx , next ) { return handler ( ctx , connectMiddleware , next ) } } 
function waitFor ( testFx , onReady , timeOutMillis ) { var maxtimeOutMillis = timeOutMillis ? timeOutMillis : 3001 , 
function makeOrdinal ( words ) { 
function toWords ( number , asOrdinal ) { var words ; var num = parseInt ( number , 10 ) ; if ( ! isFinite ( num ) ) { throw new TypeError ( 'Not a finite number: ' + number + ' (' + typeof number + ')' ) ; } if ( ! isSafeNumber ( num ) ) { throw new RangeError ( 'Input is not a safe number, it’s either too large or too small.' ) ; } words = generateWords ( num ) ; return asOrdinal ? makeOrdinal ( words ) : words ; } 
function toOrdinal ( number ) { var num = parseInt ( number , 10 ) ; if ( ! isFinite ( num ) ) { throw new TypeError ( 'Not a finite number: ' + number + ' (' + typeof number + ')' ) ; } if ( ! isSafeNumber ( num ) ) { throw new RangeError ( 'Input is not a safe number, it’s either too large or too small.' ) ; } var str = String ( num ) ; var lastTwoDigits = Math . abs ( num % 100 ) ; var betweenElevenAndThirteen = lastTwoDigits >= 11 && lastTwoDigits <= 13 ; var lastChar = str . charAt ( str . length - 1 ) ; return str + ( betweenElevenAndThirteen ? 'th' : lastChar === '1' ? 'st' : lastChar === '2' ? 'nd' : lastChar === '3' ? 'rd' : 'th' ) ; } 
function getPermission ( ) { var permission = NotificationAPI . permission ; var permissionGranted = false ; if ( permission === 'granted' ) { permissionGranted = true ; } return permissionGranted ; } 
function ( title , options , callback ) { var autoClose = 0 ; if ( options . autoClose && ( typeof options . autoClose === 'number' ) ) { autoClose = options . autoClose ; } 
function ( argumentsArray ) { 
function mergeProfiles ( what , userObj , updateProf , updateCreds , callback ) { var finalProfile , finalCreds ; if ( updateProf != undefined ) { finalProfile = { } ; for ( prop in userObj . profile ) finalProfile [ prop ] = userObj . profile [ prop ] ; for ( prop in updateProf ) finalProfile [ prop ] = updateProf [ prop ] ; } if ( updateCreds != undefined ) { finalCreds = { } ; for ( prop in userObj . credentials ) finalCreds [ prop ] = userObj . profile [ prop ] ; for ( prop in updateCreds ) finalCreds [ prop ] = updateCreds [ prop ] ; } what . update ( userObj . id , finalProfile , finalCreds , function ( d ) { if ( ! d . success || d . resp . errorCode ) { callback ( { success : false , error : "Failed to update user info" , resp : d . resp } ) ; return ; } callback ( { success : true , resp : d . resp } ) ; } ) } 
function OktaAPIGroups ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; this . helpers = require ( './OktaAPIGroupsHelpers.js' ) } 
function OktaAPISessions ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; } 
function OktaAPI ( apiToken , domain , preview ) { if ( apiToken == undefined || domain == undefined ) { throw new Error ( "OktaAPI requires an API token and a domain" ) ; } this . domain = domain ; if ( preview == undefined ) this . preview = false ; else this . preview = preview ; this . request = new NetworkAbstraction ( apiToken , domain , preview ) ; this . users = new OktaAPIUsers ( apiToken , domain , preview ) ; this . groups = new OktaAPIGroups ( apiToken , domain , preview ) ; this . sessions = new OktaAPISessions ( apiToken , domain , preview ) ; this . apps = new OktaAPIApps ( apiToken , domain , preview ) ; this . events = new OktaAPIEvents ( apiToken , domain , preview ) ; } 
function constructGroup ( name , description ) { var profile = { } ; profile . name = name ; profile . description = description ; return profile ; } 
function change ( evt ) { evt = evt || win . event ; if ( 'readystatechange' === evt . type ) { readystate . change ( docReadyState ( ) ) ; if ( complete !== docReadyState ( ) ) return ; } if ( 'load' === evt . type ) readystate . change ( 'complete' ) ; else readystate . change ( 'interactive' ) ; 
function UTF8ArrayToString ( u8Array , idx ) { var u0 , u1 , u2 , u3 , u4 , u5 ; var str = '' ; while ( 1 ) { 
function stringToUTF8 ( str , outPtr , maxBytesToWrite ) { assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; return stringToUTF8Array ( str , HEAPU8 , outPtr , maxBytesToWrite ) ; } 
function stringToUTF16 ( str , outPtr , maxBytesToWrite ) { assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; 
function stringToUTF32 ( str , outPtr , maxBytesToWrite ) { assert ( typeof maxBytesToWrite == 'number' , 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!' ) ; 
function lengthBytesUTF32 ( str ) { var len = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { 
function intArrayFromString ( stringy , dontAddNull , length ) { var len = length > 0 ? length : lengthBytesUTF8 ( stringy ) + 1 ; var u8array = new Array ( len ) ; var numBytesWritten = stringToUTF8Array ( stringy , u8array , 0 , u8array . length ) ; if ( dontAddNull ) u8array . length = numBytesWritten ; return u8array ; } 
function stackAlloc ( size ) { size = size | 0 ; var ret = 0 ; ret = STACKTOP ; STACKTOP = ( STACKTOP + size ) | 0 ; STACKTOP = ( STACKTOP + 15 ) & - 16 ; if ( ( STACKTOP | 0 ) >= ( STACK_MAX | 0 ) ) abort ( ) ; return ret | 0 ; } 
function dynCall_iiiiii ( index , a1 , a2 , a3 , a4 , a5 ) { index = index | 0 ; a1 = a1 | 0 ; a2 = a2 | 0 ; a3 = a3 | 0 ; a4 = a4 | 0 ; a5 = a5 | 0 ; return FUNCTION_TABLE_iiiiii [ index & 31 ] ( a1 | 0 , a2 | 0 , a3 | 0 , a4 | 0 , a5 | 0 ) | 0 ; } 
function constructProfile ( firstName , lastName , email , login , mobilePhone , customAttribs ) { var profile = { } ; profile . login = ( login ? login : email ) ; profile . email = email ; profile . firstName = firstName ; profile . lastName = lastName ; profile . mobilePhone = mobilePhone ; if ( customAttribs != undefined ) { for ( prop in customAttribs ) { profile [ prop ] = customAttribs [ prop ] ; } } return profile ; } 
function constructCredentials ( password , question , answer ) { var credentials = { } ; if ( password ) credentials . password = constructPassword ( password ) ; if ( question && answer ) credentials . recovery_question = constructRecoveryQuestion ( question , answer ) ; return credentials ; } 
function ( method , where , what , query , callback ) { var opts = { } ; if ( what == undefined ) opts . body = "" ; else opts . body = JSON . stringify ( what ) ; opts . headers = { } ; opts . headers [ 'Content-Length' ] = opts . body . length ; opts . headers [ 'Content-Type' ] = "application/json" ; opts . headers [ 'Authorization' ] = "SSWS " + apiKey ; opts . method = method ; opts . uri = url . parse ( where ) ; if ( query != null ) opts . qs = query ; request ( opts , function ( error , clientResp , resp ) { handleResponse ( error , false , clientResp , resp , callback ) } ) ; } 
function ( method , where , query , followLink , callback ) { var opts = { } ; 
function constructAppModel ( id , name , label , created , lastUpdated , status , features , signOnMode , accessibility , visibility , credentials , settings , links , embedded ) { var model = { } ; if ( id ) model . id = id ; if ( name ) model . name = name ; if ( label ) model . label = label ; if ( created ) model . created = created ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( status ) model . status = status ; if ( features ) model . features = features ; if ( signOnMode ) model . signOnMode = signOnMode ; if ( accessibility ) model . accessibility = accessibility ; if ( visibility ) model . visibility = visibility ; if ( credentials ) model . credentials = credentials ; if ( settings ) model . settings = settings ; if ( links ) model . links = links ; if ( embedded ) model . embedded = embedded ; return model ; } 
function constructAppUserModel ( id , externalId , created , lastUpdated , scope , status , statusChanged , passwordChanged , syncState , lastSync , credentials , lastSync , links ) { var model = { } ; if ( id ) model . id = id ; if ( externalId ) model . externalId = externalId ; if ( created ) model . created = created ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( scope ) model . scope = scope ; if ( status ) model . status = status ; if ( statusChanged ) model . statusChanged = statusChanged ; if ( passwordChanged ) model . passwordChanged = passwordChanged ; if ( syncState ) model . syncState = syncState ; if ( lastSync ) model . lastSync = lastSync ; if ( credentials ) model . credentials = credentials ; if ( lastSync ) model . lastSync = lastSync ; if ( links ) model . links = links ; return model ; } 
function constructAppGroupModel ( id , lastUpdated , priority , links ) { var model = { } ; if ( id ) model . id = id ; if ( lastUpdated ) model . lastUpdated = lastUpdated ; if ( priority ) model . priority = priority ; if ( links ) model . links = links ; return model ; } 
function generate ( state ) { return function proxy ( fn , context ) { var rs = this ; if ( rs . is ( state ) ) { setTimeout ( function ( ) { fn . call ( context , rs . readyState ) ; } , 0 ) ; } else { if ( ! rs . _events [ state ] ) rs . _events [ state ] = [ ] ; rs . _events [ state ] . push ( { fn : fn , context : context } ) ; } return rs ; } ; } 
function options ( options = [ ] , value , placeholder ) { if ( placeholder ) { options . unshift ( { label : placeholder } ) ; } return options { item . label } < / option > ) ; } ) ; } 
function ( rawErrors ) { var normalizedErrors = [ ] ; if ( typeof rawErrors === 'string' || ( typeof rawErrors === 'object' && ! Array . isArray ( rawErrors ) ) ) { 
function jsonp ( opts ) { var prefix = opts . prefix || '__jp' ; 
function getResultSeverity ( result , config ) { 
function ( inputNode , options = { } ) { this . formatter = require ( 'eslint/lib/formatters/stylish' ) if ( ! ( this instanceof StandardValidationFilter ) ) { return new StandardValidationFilter ( inputNode , options ) } 
function _boolToNum ( value , numTrue , numFalse , defaultVal ) { if ( typeof value === 'boolean' ) { return value ? numTrue : numFalse ; } return typeof value === 'number' ? value : defaultVal ; } 
function updateInput ( newNode , oldNode ) { const newValue = newNode . value ; const oldValue = oldNode . value ; updateAttribute ( newNode , oldNode , 'checked' ) ; updateAttribute ( newNode , oldNode , 'disabled' ) ; if ( newValue !== oldValue ) { oldNode . setAttribute ( 'value' , newValue ) ; oldNode . value = newValue ; } if ( newValue === 'null' ) { oldNode . value = '' ; oldNode . removeAttribute ( 'value' ) ; } if ( ! newNode . hasAttributeNS ( null , 'value' ) ) { oldNode . removeAttribute ( 'value' ) ; } else if ( oldNode . type === 'range' ) { 
function ( ) { if ( ( cachedWidth = element . offsetWidth ) != lastWidth || ( cachedHeight = element . offsetHeight ) != lastHeight ) { dirty = true ; lastWidth = cachedWidth ; lastHeight = cachedHeight ; } reset ( ) ; } 
function ( element , callback ) { var me = this ; var elementType = Object . prototype . toString . call ( element ) ; var isCollectionTyped = me . _isCollectionTyped = ( '[object Array]' === elementType || ( '[object NodeList]' === elementType ) || ( '[object HTMLCollection]' === elementType ) || ( 'undefined' !== typeof jQuery && element instanceof window . jQuery ) || 
function randInt ( start , end ) { return Math . floor ( Math . random ( ) * ( end - start ) ) + start ; } 
function wrapFn ( mocker , fn ) { return function ( ) { 
function Mocker ( obj , methodName , mockFn ) { this . obj = obj ; this . methodName = methodName ; this . originalFn = obj [ methodName ] ; this . history = [ ] ; 
function pass ( part , suiteIndex , testIndex ) { var o ; var isSuite = false ; if ( typeof testIndex === 'number' ) { o = suites [ suiteIndex ] . tests [ testIndex ] ; } else { isSuite = true ; o = suites [ suiteIndex ] ; } display . pass ( part , o ) ; if ( isSuite ) { 
function fail ( part , suiteIndex , testIndex , msg ) { if ( typeof testIndex === 'string' ) { msg = testIndex ; testIndex = undefined ; } var o ; var isSuite = false ; if ( typeof testIndex === 'number' ) { o = suites [ suiteIndex ] . tests [ testIndex ] ; if ( typeof msg === 'string' ) { suites [ suiteIndex ] . tests [ testIndex ] [ part ] . failmsg = msg ; } display . details ( 'test' , o ) ; } else { isSuite = true ; o = suites [ suiteIndex ] ; if ( typeof msg === 'string' ) { suites [ suiteIndex ] [ part ] . failmsg = msg ; } display . details ( 'suite' , o ) ; } display . fail ( part , o ) ; 
function run ( part , suiteIndex , testIndex ) { var local ; var o ; var isSuite = true ; if ( typeof testIndex === 'number' ) { isSuite = false ; o = suites [ suiteIndex ] . tests [ testIndex ] ; } else { o = suites [ suiteIndex ] ; } if ( part === 'setup' ) { if ( isSuite ) { display . suiteBorder ( ) ; display . details ( 'suite' , o ) ; 
function prepareJson ( shares ) { let json = [ ] ; for ( let i = 0 ; i < shares . length ; i ++ ) { let share = shares [ i ] ; json [ i ] = { } ; json [ i ] . id = share . id ; let status = '?' ; switch ( share . state ) { case 0 : status = 'stopped' ; break ; case 1 : status = 'running' ; break ; case 2 : status = 'errored' ; break ; default : status = 'unknown' ; } json [ i ] . status = status ; json [ i ] . configPath = share . config . storagePath ; json [ i ] . uptime = prettyMs ( share . meta . uptimeMs ) ; json [ i ] . restarts = share . meta . numRestarts || 0 ; json [ i ] . peers = share . meta . farmerState . totalPeers || 0 ; json [ i ] . allocs = fixContractValue ( share . meta . farmerState . contractCount ) ; json [ i ] . dataReceivedCount = fixContractValue ( share . meta . farmerState . dataReceivedCount ) ; json [ i ] . delta = share . meta . farmerState . ntpStatus . delta ; json [ i ] . port = share . meta . farmerState . portStatus . listenPort ; json [ i ] . shared = share . meta . farmerState . spaceUsed ; json [ i ] . sharedPercent = share . meta . farmerState . percentUsed ; var bridgeCxStat = share . meta . farmerState . bridgesConnectionStatus ; switch ( bridgeCxStat ) { case 0 : json [ i ] . bridgeConnectionStatus = 'disconnected' ; break ; case 1 : json [ i ] . bridgeConnectionStatus = 'connecting' ; break ; case 2 : json [ i ] . bridgeConnectionStatus = 'confirming' ; break ; case 3 : json [ i ] . bridgeConnectionStatus = 'connected' ; break ; default : break ; } } return JSON . stringify ( json ) ; } 
function ( content ) { 
function ( isRelevantTagAttr , usid , root , parseDynamicRoutes ) { this . currentDirective = null ; this . matches = [ ] ; this . isRelevantTagAttr = isRelevantTagAttr ; this . usid = usid ; this . ident = function ( ) { return "____" + usid + Math . random ( ) + "____" ; } ; this . data = { } ; this . root = root ; this . parseDynamicRoutes = parseDynamicRoutes ; } 
function ( match , strUntilValue , name , value , index ) { var self = this ; var expression = value ; if ( ! this . isRelevantTagAttr ( this . currentTag , name ) ) { return ; } 
function validateAndFormatCenter ( center ) { 
function ( newValue ) { var functionToExecute = newValue ? 'addClass' : 'removeClass' ; var elements = this . _elementDOM . find ( 'div' ) ; for ( var iterator = 0 ; iterator < elements . length ; iterator ++ ) { var element = angular . element ( elements [ iterator ] ) ; if ( element . hasClass ( 'angular-mapboxgl-map-loader' ) ) { element [ functionToExecute ] ( 'angular-mapboxgl-map-loading' ) ; } } } 
function DateTimePicker ( $mdUtil , $mdMedia , $document , picker ) { return { restrict : 'E' , require : [ '^ngModel' , 'smDateTimePicker' ] , scope : { weekStartDay : '@' , startView : '@' , mode : '@' , format : '@' , minDate : '@' , maxDate : '@' , fname : '@' , label : '@' , isRequired : '@' , disable : '=' , noFloatingLabel : '=' , disableYearSelection : '@' , closeOnSelect : '@' , onDateSelectedCall : '&' } , controller : [ '$scope' , '$element' , '$mdUtil' , '$mdMedia' , '$document' , '$parse' , SMDateTimePickerCtrl ] , controllerAs : 'vm' , bindToController : true , template : function ( element , attributes ) { var inputType = '' ; if ( attributes . hasOwnProperty ( 'onFocus' ) ) { inputType = '<input name="{{vm.fname}}" ng-model="vm.value" ' + 'type="text" placeholder="{{vm.label}}"' + ' aria-label="{{vm.fname}}" ng-focus="vm.show()" data-ng-required="vm.isRequired" ng-disabled="vm.disable"' + ' server-error class="sm-input-container" />' ; } else { inputType = '<input class="" name="{{vm.fname}}" ng-model="vm.value" ' + ' type="text" placeholder="{{vm.label}}" ' + ' aria-label="{{vm.fname}}" aria-hidden="true" data-ng-required="vm.isRequired" ng-disabled="vm.disable"/>' + ' <md-button tabindex="-1" class="sm-picker-icon md-icon-button" aria-label="showCalender" ng-disabled="vm.disable" aria-hidden="true" type="button" ng-click="vm.show()">' + ' <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>' + ' </md-button>' ; } return '<md-input-container class="sm-input-container md-icon-float md-block" md-no-float="vm.noFloatingLabel">' + inputType + ' <div id="picker" class="sm-calender-pane md-whiteframe-z2">' + ' <sm-date-picker ' + ' id="{{vm.fname}}Picker" ' + ' initial-date="vm.initialDate"' + ' ng-model="vm.value"' + ' mode="{{vm.mode || \'date\'}}" ' + ' disable-year-selection={{vm.disableYearSelection}}' + ' close-on-select="{{vm.closeOnSelect}}"' + ' start-view="{{vm.startView}}" ' + ' data-min-date="vm.minDate" ' + ' data-max-date="vm.maxDate" ' + ' data-format="{{vm.format}}" ' + ' data-on-select-call="vm.onDateSelected(date)"' + ' data-week-start-day="{{vm.weekStartDay}}" > ' + ' </sm-date-picker>' + ' </div>' + ' <div></div>' ' </md-input-container>' ; } , link : function ( scope , $element , attr , ctrl ) { var ngModelCtrl = ctrl [ 0 ] ; var pickerCtrl = ctrl [ 1 ] ; pickerCtrl . configureNgModel ( ngModelCtrl ) ; } } } 
function picker ( ) { var massagePath = 'X' ; var cancelLabel = 'Cancel' ; var okLabel = 'Ok' ; var clearLabel = 'Clear' ; var customRangeLabel = 'Custom Range' ; var format = 'MM-DD-YYYY' ; var customHeader = { date : 'ddd, MMM DD' , dateTime : 'ddd, MMM DD HH:mm' , time : 'HH:mm' , } 
function smRangePicker ( picker ) { return { restrict : 'E' , require : [ '^?ngModel' , 'smRangePicker' ] , scope : { format : '@' , divider : '@' , weekStartDay : '@' , customToHome : '@' , closeOnSelect : '@' , mode : '@' , showCustom : '@' , customList : '=' , minDate : '@' , maxDate : '@' , allowClear : '@' , allowEmpty : '@' , rangeSelectCall : '&' } , terminal : true , controller : [ '$scope' , 'picker' , RangePickerCtrl ] , controllerAs : 'vm' , bindToController : true , templateUrl : 'picker/range-picker.html' , link : function ( scope , element , att , ctrls ) { var ngModelCtrl = ctrls [ 0 ] ; var calCtrl = ctrls [ 1 ] ; calCtrl . configureNgModel ( ngModelCtrl ) ; } } ; } 
function smTimePickerNew ( $mdUtil , $mdMedia , $document , $timeout , picker ) { return { restrict : 'E' , replace : true , scope : { value : '=' , startDate : '@' , weekStartDay : '@' , startView : '@' , mode : '@' , format : '@' , minDate : '@' , maxDate : '@' , fname : '@' , lable : '@' , isRequired : '@' , disable : '=' , form : '=' , closeOnSelect : '@' } , templateUrl : 'picker/sm-time-picker.html' , link : function ( scope , $element , attr ) { var inputPane = $element [ 0 ] . querySelector ( '.sm-input-container' ) ; var calenderPane = $element [ 0 ] . querySelector ( '.sm-calender-pane' ) ; var cElement = angular . element ( calenderPane ) ; scope . ngMassagedTempaltePath = picker . massagePath ; 
function errorHandlingConfig ( config ) { if ( isObject ( config ) ) { if ( isDefined ( config . objectMaxDepth ) ) { minErrConfig . objectMaxDepth = isValidObjectMaxDepth ( config . objectMaxDepth ) ? config . objectMaxDepth : NaN ; } if ( isDefined ( config . urlErrorParamsEnabled ) && isBoolean ( config . urlErrorParamsEnabled ) ) { minErrConfig . urlErrorParamsEnabled = config . urlErrorParamsEnabled ; } } else { return minErrConfig ; } } 
function forEach ( obj , iterator , context ) { var key , length ; if ( obj ) { if ( isFunction ( obj ) ) { for ( key in obj ) { if ( key !== 'prototype' && key !== 'length' && key !== 'name' && obj . hasOwnProperty ( key ) ) { iterator . call ( context , obj [ key ] , key , obj ) ; } } } else if ( isArray ( obj ) || isArrayLike ( obj ) ) { var isPrimitive = typeof obj !== 'object' ; for ( key = 0 , length = obj . length ; key < length ; key ++ ) { if ( isPrimitive || key in obj ) { iterator . call ( context , obj [ key ] , key , obj ) ; } } } else if ( obj . forEach && obj . forEach !== forEach ) { obj . forEach ( iterator , context , obj ) ; } else if ( isBlankObject ( obj ) ) { 
function isError ( value ) { var tag = toString . call ( value ) ; switch ( tag ) { case '[object Error]' : return true ; case '[object Exception]' : return true ; case '[object DOMException]' : return true ; default : return value instanceof Error ; } } 
function copy ( source , destination , maxDepth ) { var stackSource = [ ] ; var stackDest = [ ] ; maxDepth = isValidObjectMaxDepth ( maxDepth ) ? maxDepth : NaN ; if ( destination ) { if ( isTypedArray ( destination ) || isArrayBuffer ( destination ) ) { throw ngMinErr ( 'cpta' , 'Can\'t copy! TypedArray destination cannot be mutated.' ) ; } if ( source === destination ) { throw ngMinErr ( 'cpi' , 'Can\'t copy! Source and destination are identical.' ) ; } 
function ( ) { if ( isDefined ( jq . name_ ) ) return jq . name_ ; var el ; var i , ii = ngAttrPrefixes . length , prefix , name ; for ( i = 0 ; i < ii ; ++ i ) { prefix = ngAttrPrefixes [ i ] ; el = window . document . querySelector ( '[' + prefix . replace ( ':' , '\\:' ) + 'jq]' ) ; if ( el ) { name = el . getAttribute ( prefix + 'jq' ) ; break ; } } return ( jq . name_ = name ) ; } 
function serializeObject ( obj , maxDepth ) { var seen = [ ] ; 
function JQLite ( element ) { if ( element instanceof JQLite ) { return element ; } var argIsString ; if ( isString ( element ) ) { element = trim ( element ) ; argIsString = true ; } if ( ! ( this instanceof JQLite ) ) { if ( argIsString && element . charAt ( 0 ) !== '<' ) { throw jqLiteMinErr ( 'nosel' , 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element' ) ; } return new JQLite ( element ) ; } if ( argIsString ) { jqLiteAddNodes ( this , jqLiteParseHTML ( element ) ) ; } else if ( isFunction ( element ) ) { jqLiteReady ( element ) ; } else { jqLiteAddNodes ( this , element ) ; } } 
function ( ) { var postDigestQueue = new NgMap ( ) ; var postDigestElements = [ ] ; this . $get = [ '$$AnimateRunner' , '$rootScope' , function ( $$AnimateRunner , $rootScope ) { return { enabled : noop , on : noop , off : noop , pin : noop , push : function ( element , event , options , domOperation ) { if ( domOperation ) { domOperation ( ) ; } options = options || { } ; if ( options . from ) { element . css ( options . from ) ; } if ( options . to ) { element . css ( options . to ) ; } if ( options . addClass || options . removeClass ) { addRemoveClassesPostDigest ( element , options . addClass , options . removeClass ) ; } var runner = new $$AnimateRunner ( ) ; 
function Browser ( window , document , $log , $sniffer , $$taskTrackerFactory ) { var self = this , location = window . location , history = window . history , setTimeout = window . setTimeout , clearTimeout = window . clearTimeout , pendingDeferIds = { } , taskTracker = $$taskTrackerFactory ( $log ) ; self . isMock = false ; * @name $browser#url * * @description * GETTER: * Without any argument, this method just returns current value of `location.href` (with a * trailing `#` stripped of if the hash is empty). * * SETTER: * With at least one argument, this method sets url to new value. * If html5 history api supported, `pushState`/`replaceState` is used, otherwise * `location.href`/`location.replace` is used. * Returns its own instance to allow chaining. * * NOTE: this api is intended for use only by the `$location` service. Please use the * {@link ng.$location $location service} to change url. * * @param {string} url New url (when used as setter) * @param {boolean=} replace Should new url replace current history record? * @param {object=} state State object to use with `pushState`/`replaceState` */ self . url = function ( url , replace , state ) { * @name $browser#state * * @description * This method is a getter. * * Return history.state or null if history.state is undefined. * * @returns {object} state */ self . state = function ( ) { return cachedState ; } ; var urlChangeListeners = [ ] , urlChangeInit = false ; function cacheStateAndFireUrlChange ( ) { pendingLocation = null ; fireStateOrUrlChange ( ) ; } * @name $browser#onUrlChange * * @description * Register callback function that will be called, when url changes. * * It's only called when the url is changed from outside of AngularJS: * - user types different url into address bar * - user clicks on history (forward/back) button * - user clicks on a link * * It's not called when url is changed by $browser.url() method * * The listener gets called with new url as parameter. * * NOTE: this api is intended for use only by the $location service. Please use the * {@link ng.$location $location service} to monitor url changes in AngularJS apps. * * @param {function(string)} listener Listener function to be called when url changes. * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous. */ self . onUrlChange = function ( callback ) { * @private * Remove popstate and hashchange handler from window. * * NOTE: this api is intended for use only by $rootScope. */ self . $$applicationDestroyed = function ( ) { jqLite ( window ) . off ( 'hashchange popstate' , cacheStateAndFireUrlChange ) ; } ; self . $$checkUrlChange = fireStateOrUrlChange ; * @name $browser#baseHref * * @description * Returns current <base href> * (always relative - without domain) * * @returns {string} The current base href */ self . baseHref = function ( ) { var href = baseElement . attr ( 'href' ) ; return href ? href . replace ( / ^(https?:)?\/\/[^/]* / , '' ) : '' ; } ; self . defer = function ( fn , delay , taskType ) { var timeoutId ; delay = delay || 0 ; taskType = taskType || taskTracker . DEFAULT_TASK_TYPE ; taskTracker . incTaskCount ( taskType ) ; timeoutId = setTimeout ( function ( ) { delete pendingDeferIds [ timeoutId ] ; taskTracker . completeTask ( fn , taskType ) ; } , delay ) ; pendingDeferIds [ timeoutId ] = taskType ; return timeoutId ; } ; self . defer . cancel = function ( deferId ) { if ( pendingDeferIds . hasOwnProperty ( deferId ) ) { var taskType = pendingDeferIds [ deferId ] ; delete pendingDeferIds [ deferId ] ; clearTimeout ( deferId ) ; taskTracker . completeTask ( noop , taskType ) ; return true ; } return false ; } ; } 
function ( key ) { if ( capacity < Number . MAX_VALUE ) { var lruEntry = lruHash [ key ] ; if ( ! lruEntry ) return ; if ( lruEntry === freshEnd ) freshEnd = lruEntry . p ; if ( lruEntry === staleEnd ) staleEnd = lruEntry . n ; link ( lruEntry . n , lruEntry . p ) ; delete lruHash [ key ] ; } if ( ! ( key in data ) ) return ; delete data [ key ] ; size -- ; } 
function refresh ( entry ) { if ( entry !== freshEnd ) { if ( ! staleEnd ) { staleEnd = entry ; } else if ( staleEnd === entry ) { staleEnd = entry . n ; } link ( entry . n , entry . p ) ; link ( entry , freshEnd ) ; freshEnd = entry ; freshEnd . n = null ; } } 
function link ( nextEntry , prevEntry ) { if ( nextEntry !== prevEntry ) { if ( nextEntry ) nextEntry . p = prevEntry ; 
function ( key , value , writeAttr , attrName ) { 
function groupScan ( node , attrStart , attrEnd ) { var nodes = [ ] ; var depth = 0 ; if ( attrStart && node . hasAttribute && node . hasAttribute ( attrStart ) ) { do { if ( ! node ) { throw $compileMinErr ( 'uterdir' , 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.' , attrStart , attrEnd ) ; } if ( node . nodeType === NODE_TYPE_ELEMENT ) { if ( node . hasAttribute ( attrStart ) ) depth ++ ; if ( node . hasAttribute ( attrEnd ) ) depth -- ; } nodes . push ( node ) ; node = node . nextSibling ; } while ( depth > 0 ) ; } else { nodes . push ( node ) ; } return jqLite ( nodes ) ; } 
function mergeTemplateAttributes ( dst , src ) { var srcAttr = src . $attr , dstAttr = dst . $attr ; 
function replaceWith ( $rootElement , elementsToRemove , newNode ) { var firstElementToRemove = elementsToRemove [ 0 ] , removeCount = elementsToRemove . length , parent = firstElementToRemove . parentNode , i , ii ; if ( $rootElement ) { for ( i = 0 , ii = $rootElement . length ; i < ii ; i ++ ) { if ( $rootElement [ i ] === firstElementToRemove ) { $rootElement [ i ++ ] = newNode ; for ( var j = i , j2 = j + removeCount - 1 , jj = $rootElement . length ; j < jj ; j ++ , j2 ++ ) { if ( j2 < jj ) { $rootElement [ j ] = $rootElement [ j2 ] ; } else { delete $rootElement [ j ] ; } } $rootElement . length -= removeCount - 1 ; 
function resolvePromise ( response , status , headers , statusText , xhrStatus ) { 
function constantWatchDelegate ( scope , listener , objectEquality , constantInterp ) { var unwatch = scope . $watch ( function constantInterpolateWatch ( scope ) { unwatch ( ) ; return constantInterp ( scope ) ; } , listener , objectEquality ) ; return unwatch ; } 
function encodePath ( path ) { var segments = path . split ( '/' ) , i = segments . length ; while ( i -- ) { 
function LocationHtml5Url ( appBase , appBaseNoFile , basePrefix ) { this . $$html5 = true ; basePrefix = basePrefix || '' ; parseAbsoluteUrl ( appBase , this ) ; this . $$parse = function ( url ) { var pathUrl = stripBaseUrl ( appBaseNoFile , url ) ; if ( ! isString ( pathUrl ) ) { throw $locationMinErr ( 'ipthprfx' , 'Invalid url "{0}", missing path prefix "{1}".' , url , appBaseNoFile ) ; } parseAppUrl ( pathUrl , this , true ) ; if ( ! this . $$path ) { this . $$path = '/' ; } this . $$compose ( ) ; } ; this . $$normalizeUrl = function ( url ) { return appBaseNoFile + url . substr ( 1 ) ; 
function urlsEqual ( a , b ) { return a === b || urlResolve ( a ) . href === urlResolve ( b ) . href ; } 
function $LogProvider ( ) { var debug = true , self = this ; this . debugEnabled = function ( flag ) { if ( isDefined ( flag ) ) { debug = flag ; return this ; } else { return debug ; } } ; this . $get = [ '$window' , function ( $window ) { * @ngdoc method * @name $log#log * * @description * Write a log message */ log : consoleLog ( 'log' ) , info : consoleLog ( 'info' ) , warn : consoleLog ( 'warn' ) , error : consoleLog ( 'error' ) , debug : ( function ( ) { var fn = consoleLog ( 'debug' ) ; return function ( ) { if ( debug ) { fn . apply ( self , arguments ) ; } } ; } ) ( ) } ; function formatError ( arg ) { if ( isError ( arg ) ) { if ( arg . stack && formatStackTrace ) { arg = ( arg . message && arg . stack . indexOf ( arg . message ) === - 1 ) ? 'Error: ' + arg . message + '\n' + arg . stack : arg . stack ; } else if ( arg . sourceURL ) { arg = arg . message + '\n' + arg . sourceURL + ':' + arg . line ; } } return arg ; } function consoleLog ( type ) { var console = $window . console || { } , logFn = console [ type ] || console . log || noop ; return function ( ) { var args = [ ] ; forEach ( arguments , function ( arg ) { args . push ( formatError ( arg ) ) ; } ) ; 
function isPure ( node , parentIsPure ) { switch ( node . type ) { 
function $ParseProvider ( ) { var cache = createMap ( ) ; var literals = { 'true' : true , 'false' : false , 'null' : null , 'undefined' : undefined } ; var identStart , identContinue ; this . addLiteral = function ( literalName , literalValue ) { literals [ literalName ] = literalValue ; } ; this . setIdentifierFns = function ( identifierStart , identifierContinue ) { identStart = identifierStart ; identContinue = identifierContinue ; return this ; } ; this . $get = [ '$filter' , function ( $filter ) { var noUnsafeEval = csp ( ) . noUnsafeEval ; var $parseOptions = { csp : noUnsafeEval , literals : copy ( literals ) , isIdentifierStart : isFunction ( identStart ) && identStart , isIdentifierContinue : isFunction ( identContinue ) && identContinue } ; $parse . $$getAst = $$getAst ; return $parse ; function $parse ( exp , interceptorFn ) { var parsedExpression , cacheKey ; switch ( typeof exp ) { case 'string' : exp = exp . trim ( ) ; cacheKey = exp ; parsedExpression = cache [ cacheKey ] ; if ( ! parsedExpression ) { var lexer = new Lexer ( $parseOptions ) ; var parser = new Parser ( lexer , $filter , $parseOptions ) ; parsedExpression = parser . parse ( exp ) ; cache [ cacheKey ] = addWatchDelegate ( parsedExpression ) ; } return addInterceptor ( parsedExpression , interceptorFn ) ; case 'function' : return addInterceptor ( exp , interceptorFn ) ; default : return addInterceptor ( noop , interceptorFn ) ; } } function $$getAst ( exp ) { var lexer = new Lexer ( $parseOptions ) ; var parser = new Parser ( lexer , $filter , $parseOptions ) ; return parser . getAst ( exp ) . ast ; } function expressionInputDirtyCheck ( newValue , oldValueOfValue , compareObjectIdentity ) { if ( newValue == null || oldValueOfValue == null ) { 
function $QProvider ( ) { var errorOnUnhandledRejections = true ; this . $get = [ '$rootScope' , '$exceptionHandler' , function ( $rootScope , $exceptionHandler ) { return qFactory ( function ( callback ) { $rootScope . $evalAsync ( callback ) ; } , $exceptionHandler , errorOnUnhandledRejections ) ; } ] ; this . errorOnUnhandledRejections = function ( value ) { if ( isDefined ( value ) ) { errorOnUnhandledRejections = value ; return this ; } else { return errorOnUnhandledRejections ; } } ; } 
function qFactory ( nextTick , exceptionHandler , errorOnUnhandledRejections ) { var $qMinErr = minErr ( '$q' , TypeError ) ; var queueSize = 0 ; var checkQueue = [ ] ; function defer ( ) { return new Deferred ( ) ; } function Deferred ( ) { var promise = this . promise = new Promise ( ) ; * @ngdoc method * @name $q#reject * @kind function * * @description * Creates a promise that is resolved as rejected with the specified `reason`. This api should be * used to forward rejection in a chain of promises. If you are dealing with the last promise in * a promise chain, you don't need to worry about it. * * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via * a promise error callback and you want to forward the error to the promise derived from the * current promise, you have to "rethrow" the error by returning a rejection constructed via * `reject`. * * ```js * promiseB = promiseA.then(function(result) { * // success: do something and resolve promiseB * // with the old or a new result * return result; * }, function(reason) { * // error: handle the error if possible and * // resolve promiseB with newPromiseOrValue, * // otherwise forward the rejection to promiseB * if (canHandle(reason)) { * // handle the error and recover * return newPromiseOrValue; * } * return $q.reject(reason); * }); * ``` * * @param {*} reason Constant, message, exception or an object representing the rejection reason. * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`. */ function reject ( reason ) { var result = new Promise ( ) ; rejectPromise ( result , reason ) ; return result ; } function handleCallback ( value , resolver , callback ) { var callbackOutput = null ; try { if ( isFunction ( callback ) ) callbackOutput = callback ( ) ; } catch ( e ) { return reject ( e ) ; } if ( isPromiseLike ( callbackOutput ) ) { return callbackOutput . then ( function ( ) { return resolver ( value ) ; } , reject ) ; } else { return resolver ( value ) ; } } /** * @ngdoc method * @name $q#when * @kind function * * @description * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. * This is useful when you are dealing with an object that might or might not be a promise, or if * the promise comes from a source that can't be trusted. * * @param {*} value Value or a promise * @param {Function=} successCallback * @param {Function=} errorCallback * @param {Function=} progressCallback * @returns {Promise} Returns a promise of the passed value or promise */ function when ( value , callback , errback , progressBack ) { var result = new Promise ( ) ; resolvePromise ( result , value ) ; return result . then ( callback , errback , progressBack ) ; } var resolve = when ; function all ( promises ) { var result = new Promise ( ) , counter = 0 , results = isArray ( promises ) ? [ ] : { } ; forEach ( promises , function ( promise , key ) { counter ++ ; when ( promise ) . then ( function ( value ) { results [ key ] = value ; if ( ! ( -- counter ) ) resolvePromise ( result , results ) ; } , function ( reason ) { rejectPromise ( result , reason ) ; } ) ; } ) ; if ( counter === 0 ) { resolvePromise ( result , results ) ; } return result ; } function race ( promises ) { var deferred = defer ( ) ; forEach ( promises , function ( promise ) { when ( promise ) . then ( deferred . resolve , deferred . reject ) ; } ) ; return deferred . promise ; } function $Q ( resolver ) { if ( ! isFunction ( resolver ) ) { throw $qMinErr ( 'norslvr' , 'Expected resolverFn, got \'{0}\'' , resolver ) ; } var promise = new Promise ( ) ; function resolveFn ( value ) { resolvePromise ( promise , value ) ; } function rejectFn ( reason ) { rejectPromise ( promise , reason ) ; } resolver ( resolveFn , rejectFn ) ; return promise ; } 
function when ( value , callback , errback , progressBack ) { var result = new Promise ( ) ; resolvePromise ( result , value ) ; return result . then ( callback , errback , progressBack ) ; } 
function all ( promises ) { var result = new Promise ( ) , counter = 0 , results = isArray ( promises ) ? [ ] : { } ; forEach ( promises , function ( promise , key ) { counter ++ ; when ( promise ) . then ( function ( value ) { results [ key ] = value ; if ( ! ( -- counter ) ) resolvePromise ( result , results ) ; } , function ( reason ) { rejectPromise ( result , reason ) ; } ) ; } ) ; if ( counter === 0 ) { resolvePromise ( result , results ) ; } return result ; } 
function race ( promises ) { var deferred = defer ( ) ; forEach ( promises , function ( promise ) { when ( promise ) . then ( deferred . resolve , deferred . reject ) ; } ) ; return deferred . promise ; } 
function $RootScopeProvider ( ) { var TTL = 10 ; var $rootScopeMinErr = minErr ( '$rootScope' ) ; var lastDirtyWatch = null ; var applyAsyncId = null ; this . digestTtl = function ( value ) { if ( arguments . length ) { TTL = value ; } return TTL ; } ; function createChildScopeClass ( parent ) { function ChildScope ( ) { this . $$watchers = this . $$nextSibling = this . $$childHead = this . $$childTail = null ; this . $$listeners = { } ; this . $$listenerCount = { } ; this . $$watchersCount = 0 ; this . $id = nextUid ( ) ; this . $$ChildScope = null ; this . $$suspended = false ; } ChildScope . prototype = parent ; return ChildScope ; } this . $get = [ '$exceptionHandler' , '$parse' , '$browser' , function ( $exceptionHandler , $parse , $browser ) { function destroyChildScope ( $event ) { $event . currentScope . $$destroyed = true ; } function cleanUpScope ( $scope ) { * @ngdoc type * @name $rootScope.Scope * * @description * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the * {@link auto.$injector $injector}. Child scopes are created using the * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when * compiled HTML template is executed.) See also the {@link guide/scope Scopes guide} for * an in-depth introduction and usage examples. * * * ## Inheritance * A scope can inherit from a parent scope, as in this example: * ```js var parent = $rootScope; var child = parent.$new(); parent.salutation = "Hello"; expect(child.salutation).toEqual('Hello'); child.salutation = "Welcome"; expect(child.salutation).toEqual('Welcome'); expect(parent.salutation).toEqual('Hello'); * ``` * * When interacting with `Scope` in tests, additional helper methods are available on the * instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional * details. * * * @param {Object.<string, function()>=} providers Map of service factory which need to be * provided for the current scope. Defaults to {@link ng}. * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should * append/override services provided by `providers`. This is handy * when unit-testing and having the need to override a default * service. * @returns {Object} Newly created scope. * */ function Scope ( ) { this . $id = nextUid ( ) ; this . $$phase = this . $parent = this . $$watchers = this . $$nextSibling = this . $$prevSibling = this . $$childHead = this . $$childTail = null ; this . $root = this ; this . $$destroyed = false ; this . $$suspended = false ; this . $$listeners = { } ; this . $$listenerCount = { } ; this . $$watchersCount = 0 ; this . $$isolateBindings = null ; } Scope . prototype = { constructor : Scope , $new : function ( isolate , parent ) { var child ; parent = parent || this ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; } else { * @ngdoc method * @name $rootScope.Scope#$watch * @kind function * * @description * Registers a `listener` callback to be executed whenever the `watchExpression` changes. * * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest * $digest()} and should return the value that will be watched. (`watchExpression` should not change * its value when executed multiple times with the same input because it may be executed multiple * times by {@link ng.$rootScope.Scope#$digest $digest()}. That is, `watchExpression` should be * [idempotent](http: * - The `listener` is called only when the value from the current `watchExpression` and the * previous call to `watchExpression` are not equal (with the exception of the initial run, * see below). Inequality is determined according to reference inequality, * [strict comparison](https: * via the `!==` Javascript operator, unless `objectEquality == true` * (see next point) * - When `objectEquality == true`, inequality of the `watchExpression` is determined * according to the {@link angular.equals} function. To save the value of the object for * later comparison, the {@link angular.copy} function is used. This therefore means that * watching complex objects will have adverse memory and performance implications. * - This should not be used to watch for changes in objects that are (or contain) * [File](https: * - The watch `listener` may change the model, which may trigger other `listener`s to fire. * This is achieved by rerunning the watchers until no changes are detected. The rerun * iteration limit is 10 to prevent an infinite loop deadlock. * * * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called, * you can register a `watchExpression` function with no `listener`. (Be prepared for * multiple calls to your `watchExpression` because it will execute multiple times in a * single {@link ng.$rootScope.Scope#$digest $digest} cycle if a change is detected.) * * After a watcher is registered with the scope, the `listener` fn is called asynchronously * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the * watcher. In rare cases, this is undesirable because the listener is called when the result * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the * listener was called due to initialization. * * * * @example * ```js // let's assume that scope was dependency injected as the $rootScope var scope = $rootScope; scope.name = 'misko'; scope.counter = 0; expect(scope.counter).toEqual(0); scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; }); expect(scope.counter).toEqual(0); scope.$digest(); expect(scope.counter).toEqual(1); scope.$digest(); expect(scope.counter).toEqual(1); scope.name = 'adam'; scope.$digest(); expect(scope.counter).toEqual(2); var food; scope.foodCounter = 0; expect(scope.foodCounter).toEqual(0); scope.$watch( function() { return food; }, function(newValue, oldValue) { if ( newValue !== oldValue ) { scope.foodCounter = scope.foodCounter + 1; } } ); expect(scope.foodCounter).toEqual(0); scope.$digest(); expect(scope.foodCounter).toEqual(0); food = 'cheeseburger'; scope.$digest(); expect(scope.foodCounter).toEqual(1); * ``` * * * * @param {(function()|string)} watchExpression Expression that is evaluated on each * {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers * a call to the `listener`. * * - `string`: Evaluated as {@link guide/expression expression} * - `function(scope)`: called with current `scope` as a parameter. * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value * of `watchExpression` changes. * * - `newVal` contains the current value of the `watchExpression` * - `oldVal` contains the previous value of the `watchExpression` * - `scope` refers to the current scope * @param {boolean=} [objectEquality=false] Compare for object equality using {@link angular.equals} instead of * comparing for reference equality. * @returns {function()} Returns a deregistration function for this listener. */ $watch : function ( watchExp , listener , objectEquality , prettyPrintExpression ) { var get = $parse ( watchExp ) ; var fn = isFunction ( listener ) ? listener : noop ; if ( get . $$watchDelegate ) { return get . $$watchDelegate ( this , fn , objectEquality , get , watchExp ) ; } var scope = this , array = scope . $$watchers , watcher = { fn : fn , last : initWatchVal , get : get , exp : prettyPrintExpression || watchExp , eq : ! ! objectEquality } ; lastDirtyWatch = null ; if ( ! array ) { array = scope . $$watchers = [ ] ; array . $$digestWatchIndex = - 1 ; } * @ngdoc method * @name $rootScope.Scope#$watchGroup * @kind function * * @description * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`. * If any one expression in the collection changes the `listener` is executed. * * - The items in the `watchExpressions` array are observed via the standard `$watch` operation. Their return * values are examined for changes on every call to `$digest`. * - The `listener` is called whenever any expression in the `watchExpressions` array changes. * * @param {Array.<string|Function(scope)>} watchExpressions Array of expressions that will be individually * watched using {@link ng.$rootScope.Scope#$watch $watch()} * * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any * expression in `watchExpressions` changes * The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching * those of `watchExpression` * and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching * those of `watchExpression` * The `scope` refers to the current scope. * @returns {function()} Returns a de-registration function for all listeners. */ $watchGroup : function ( watchExpressions , listener ) { var oldValues = new Array ( watchExpressions . length ) ; var newValues = new Array ( watchExpressions . length ) ; var deregisterFns = [ ] ; var self = this ; var changeReactionScheduled = false ; var firstRun = true ; if ( ! watchExpressions . length ) { * @ngdoc method * @name $rootScope.Scope#$watchCollection * @kind function * * @description * Shallow watches the properties of an object and fires whenever any of the properties change * (for arrays, this implies watching the array items; for object maps, this implies watching * the properties). If a change is detected, the `listener` callback is fired. * * - The `obj` collection is observed via standard $watch operation and is examined on every * call to $digest() to see if any items have been added, removed, or moved. * - The `listener` is called whenever anything within the `obj` has changed. Examples include * adding, removing, and moving items belonging to an object or array. * * * @example * ```js $scope.names = ['igor', 'matias', 'misko', 'james']; $scope.dataCount = 4; $scope.$watchCollection('names', function(newNames, oldNames) { $scope.dataCount = newNames.length; }); expect($scope.dataCount).toEqual(4); $scope.$digest(); expect($scope.dataCount).toEqual(4); $scope.names.pop(); $scope.$digest(); expect($scope.dataCount).toEqual(3); * ``` * * * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The * expression value should evaluate to an object or an array which is observed on each * {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the * collection will trigger a call to the `listener`. * * @param {function(newCollection, oldCollection, scope)} listener a callback function called * when a change is detected. * - The `newCollection` object is the newly modified data obtained from the `obj` expression * - The `oldCollection` object is a copy of the former collection data. * Due to performance considerations, the`oldCollection` value is computed only if the * `listener` function declares two or more arguments. * - The `scope` argument refers to the current scope. * * @returns {function()} Returns a de-registration function for this listener. When the * de-registration function is executed, the internal watch operation is terminated. */ $watchCollection : function ( obj , listener ) { * @ngdoc method * @name $rootScope.Scope#$digest * @kind function * * @description * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} * until no more listeners are firing. This means that it is possible to get into an infinite * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of * iterations exceeds 10. * * Usually, you don't call `$digest()` directly in * {@link ng.directive:ngController controllers} or in * {@link ng.$compileProvider#directive directives}. * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`. * * If you want to be notified whenever `$digest()` is called, * you can register a `watchExpression` function with * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`. * * In unit tests, you may need to call `$digest()` to simulate the scope life cycle. * * @example * ```js var scope = ...; scope.name = 'misko'; scope.counter = 0; expect(scope.counter).toEqual(0); scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; }); expect(scope.counter).toEqual(0); scope.$digest(); expect(scope.counter).toEqual(1); scope.$digest(); expect(scope.counter).toEqual(1); scope.name = 'adam'; scope.$digest(); expect(scope.counter).toEqual(2); * ``` * */ $digest : function ( ) { var watch , value , last , fn , get , watchers , dirty , ttl = TTL , next , current , target = asyncQueue . length ? $rootScope : this , watchLog = [ ] , logIdx , asyncTask ; beginPhase ( '$digest' ) ; * @ngdoc method * @name $rootScope.Scope#$suspend * @kind function * * @description * Suspend watchers of this scope subtree so that they will not be invoked during digest. * * This can be used to optimize your application when you know that running those watchers * is redundant. * * **Warning** * * Suspending scopes from the digest cycle can have unwanted and difficult to debug results. * Only use this approach if you are confident that you know what you are doing and have * ample tests to ensure that bindings get updated as you expect. * * Some of the things to consider are: * * * Any external event on a directive/component will not trigger a digest while the hosting * scope is suspended - even if the event handler calls `$apply()` or `$rootScope.$digest()`. * * Transcluded content exists on a scope that inherits from outside a directive but exists * as a child of the directive's containing scope. If the containing scope is suspended the * transcluded scope will also be suspended, even if the scope from which the transcluded * scope inherits is not suspended. * * Multiple directives trying to manage the suspended status of a scope can confuse each other: * * A call to `$suspend()` on an already suspended scope is a no-op. * * A call to `$resume()` on a non-suspended scope is a no-op. * * If two directives suspend a scope, then one of them resumes the scope, the scope will no * longer be suspended. This could result in the other directive believing a scope to be * suspended when it is not. * * If a parent scope is suspended then all its descendants will be also excluded from future * digests whether or not they have been suspended themselves. Note that this also applies to * isolate child scopes. * * Calling `$digest()` directly on a descendant of a suspended scope will still run the watchers * for that scope and its descendants. When digesting we only check whether the current scope is * locally suspended, rather than checking whether it has a suspended ancestor. * * Calling `$resume()` on a scope that has a suspended ancestor will not cause the scope to be * included in future digests until all its ancestors have been resumed. * * Resolved promises, e.g. from explicit `$q` deferreds and `$http` calls, trigger `$apply()` * against the `$rootScope` and so will still trigger a global digest even if the promise was * initiated by a component that lives on a suspended scope. */ $suspend : function ( ) { this . $$suspended = true ; } , /** * @ngdoc method * @name $rootScope.Scope#$isSuspended * @kind function * * @description * Call this method to determine if this scope has been explicitly suspended. It will not * tell you whether an ancestor has been suspended. * To determine if this scope will be excluded from a digest triggered at the $rootScope, * for example, you must check all its ancestors: * * ``` * function isExcludedFromDigest(scope) { * while(scope) { * if (scope.$isSuspended()) return true; * scope = scope.$parent; * } * return false; * ``` * * Be aware that a scope may not be included in digests if it has a suspended ancestor, * even if `$isSuspended()` returns false. * * @returns true if the current scope has been suspended. */ $isSuspended : function ( ) { return this . $$suspended ; } , /** * @ngdoc method * @name $rootScope.Scope#$resume * @kind function * * @description * Resume watchers of this scope subtree in case it was suspended. * * See {@link $rootScope.Scope#$suspend} for information about the dangers of using this approach. */ $resume : function ( ) { this . $$suspended = false ; } , /** * @ngdoc event * @name $rootScope.Scope#$destroy * @eventType broadcast on scope being destroyed * * @description * Broadcasted when a scope and its children are being destroyed. * * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to * clean up DOM bindings before an element is removed from the DOM. */ /** * @ngdoc method * @name $rootScope.Scope#$destroy * @kind function * * @description * Removes the current scope (and all of its children) from the parent scope. Removal implies * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer * propagate to the current scope and its children. Removal also implies that the current * scope is eligible for garbage collection. * * The `$destroy()` is usually used by directives such as * {@link ng.directive:ngRepeat ngRepeat} for managing the * unrolling of the loop. * * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope. * Application code can register a `$destroy` event handler that will give it a chance to * perform any necessary cleanup. * * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to * clean up DOM bindings before an element is removed from the DOM. */ $destroy : function ( ) { // We can't destroy a scope that has been already destroyed. if ( this . $$destroyed ) return ; var parent = this . $parent ; this . $broadcast ( '$destroy' ) ; this . $$destroyed = true ; if ( this === $rootScope ) { * @ngdoc method * @name $rootScope.Scope#$eval * @kind function * * @description * Executes the `expression` on the current scope and returns the result. Any exceptions in * the expression are propagated (uncaught). This is useful when evaluating AngularJS * expressions. * * @example * ```js var scope = ng.$rootScope.Scope(); scope.a = 1; scope.b = 2; expect(scope.$eval('a+b')).toEqual(3); expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3); * ``` * * @param {(string|function())=} expression An AngularJS expression to be executed. * * - `string`: execute using the rules as defined in {@link guide/expression expression}. * - `function(scope)`: execute the function with the current `scope` parameter. * * @param {(object)=} locals Local variables object, useful for overriding values in scope. * @returns {*} The result of evaluating the expression. */ $eval : function ( expr , locals ) { return $parse ( expr ) ( this , locals ) ; } , $evalAsync : function ( expr , locals ) { * @ngdoc method * @name $rootScope.Scope#$apply * @kind function * * @description * `$apply()` is used to execute an expression in AngularJS from outside of the AngularJS * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries). * Because we are calling into the AngularJS framework we need to perform proper scope life * cycle of {@link ng.$exceptionHandler exception handling}, * {@link ng.$rootScope.Scope#$digest executing watches}. * * **Life cycle: Pseudo-Code of `$apply()`** * * ```js function $apply(expr) { try { return $eval(expr); } catch (e) { $exceptionHandler(e); } finally { $root.$digest(); } } * ``` * * * Scope's `$apply()` method transitions through the following stages: * * 1. The {@link guide/expression expression} is executed using the * {@link ng.$rootScope.Scope#$eval $eval()} method. * 2. Any exceptions from the execution of the expression are forwarded to the * {@link ng.$exceptionHandler $exceptionHandler} service. * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the * expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method. * * * @param {(string|function())=} exp An AngularJS expression to be executed. * * - `string`: execute using the rules as defined in {@link guide/expression expression}. * - `function(scope)`: execute the function with current `scope` parameter. * * @returns {*} The result of evaluating the expression. */ $apply : function ( expr ) { try { beginPhase ( '$apply' ) ; try { return this . $eval ( expr ) ; } finally { clearPhase ( ) ; } } catch ( e ) { $exceptionHandler ( e ) ; } finally { try { $rootScope . $digest ( ) ; } catch ( e ) { $exceptionHandler ( e ) ; // eslint-disable-next-line no-unsafe-finally throw e ; } } } , /** * @ngdoc method * @name $rootScope.Scope#$applyAsync * @kind function * * @description * Schedule the invocation of $apply to occur at a later time. The actual time difference * varies across browsers, but is typically around ~10 milliseconds. * * This can be used to queue up multiple expressions which need to be evaluated in the same * digest. * * @param {(string|function())=} exp An AngularJS expression to be executed. * * - `string`: execute using the rules as defined in {@link guide/expression expression}. * - `function(scope)`: execute the function with current `scope` parameter. */ $applyAsync : function ( expr ) { var scope = this ; if ( expr ) { applyAsyncQueue . push ( $applyAsyncExpression ) ; } expr = $parse ( expr ) ; scheduleApplyAsync ( ) ; function $applyAsyncExpression ( ) { scope . $eval ( expr ) ; } } , /** * @ngdoc method * @name $rootScope.Scope#$on * @kind function * * @description * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for * discussion of event life cycle. * * The event listener function format is: `function(event, args...)`. The `event` object * passed into the listener has the following attributes: * * - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or * `$broadcast`-ed. * - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the * event propagates through the scope hierarchy, this property is set to null. * - `name` - `{string}`: name of the event. * - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel * further event propagation (available only for events that were `$emit`-ed). * - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag * to true. * - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called. * * @param {string} name Event name to listen on. * @param {function(event, ...args)} listener Function to call when the event is emitted. * @returns {function()} Returns a deregistration function for this listener. */ $on : function ( name , listener ) { var namedListeners = this . $$listeners [ name ] ; if ( ! namedListeners ) { this . $$listeners [ name ] = namedListeners = [ ] ; } namedListeners . push ( listener ) ; var current = this ; do { if ( ! current . $$listenerCount [ name ] ) { current . $$listenerCount [ name ] = 0 ; } current . $$listenerCount [ name ] ++ ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { var indexOfListener = namedListeners . indexOf ( listener ) ; if ( indexOfListener !== - 1 ) { // Use delete in the hope of the browser deallocating the memory for the array entry, // while not shifting the array indexes of other listeners. // See issue https://github.com/angular/angular.js/issues/16135 delete namedListeners [ indexOfListener ] ; decrementListenerCount ( self , 1 , name ) ; } } ; } , /** * @ngdoc method * @name $rootScope.Scope#$emit * @kind function * * @description * Dispatches an event `name` upwards through the scope hierarchy notifying the * registered {@link ng.$rootScope.Scope#$on} listeners. * * The event life cycle starts at the scope on which `$emit` was called. All * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get * notified. Afterwards, the event traverses upwards toward the root scope and calls all * registered listeners along the way. The event will stop propagating if one of the listeners * cancels it. * * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed * onto the {@link ng.$exceptionHandler $exceptionHandler} service. * * @param {string} name Event name to emit. * @param {...*} args Optional one or more arguments which will be passed onto the event listeners. * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}). */ $emit : function ( name , args ) { var empty = [ ] , namedListeners , scope = this , stopPropagation = false , event = { name : name , targetScope : scope , stopPropagation : function ( ) { stopPropagation = true ; } , preventDefault : function ( ) { event . defaultPrevented = true ; } , defaultPrevented : false } , listenerArgs = concat ( [ event ] , arguments , 1 ) , i , length ; do { namedListeners = scope . $$listeners [ name ] || empty ; event . currentScope = scope ; for ( i = 0 , length = namedListeners . length ; i < length ; i ++ ) { // if listeners were deregistered, defragment the array if ( ! namedListeners [ i ] ) { namedListeners . splice ( i , 1 ) ; i -- ; length -- ; continue ; } try { //allow all listeners attached to the current scope to run namedListeners [ i ] . apply ( null , listenerArgs ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } //if any listener on the current scope stops propagation, prevent bubbling if ( stopPropagation ) { break ; } //traverse upwards scope = scope . $parent ; } while ( scope ) ; event . currentScope = null ; return event ; } , /** * @ngdoc method * @name $rootScope.Scope#$broadcast * @kind function * * @description * Dispatches an event `name` downwards to all child scopes (and their children) notifying the * registered {@link ng.$rootScope.Scope#$on} listeners. * * The event life cycle starts at the scope on which `$broadcast` was called. All * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get * notified. Afterwards, the event propagates to all direct and indirect scopes of the current * scope and calls all registered listeners along the way. The event cannot be canceled. * * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed * onto the {@link ng.$exceptionHandler $exceptionHandler} service. * * @param {string} name Event name to broadcast. * @param {...*} args Optional one or more arguments which will be passed onto the event listeners. * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on} */ $broadcast : function ( name , args ) { var target = this , current = target , next = target , event = { name : name , targetScope : target , preventDefault : function ( ) { event . defaultPrevented = true ; } , defaultPrevented : false } ; if ( ! target . $$listenerCount [ name ] ) return event ; var listenerArgs = concat ( [ event ] , arguments , 1 ) , listeners , i , length ; //down while you can, then up and next sibling or up and next sibling until back at root while ( ( current = next ) ) { event . currentScope = current ; listeners = current . $$listeners [ name ] || [ ] ; for ( i = 0 , length = listeners . length ; i < length ; i ++ ) { // if listeners were deregistered, defragment the array if ( ! listeners [ i ] ) { listeners . splice ( i , 1 ) ; i -- ; length -- ; continue ; } try { listeners [ i ] . apply ( null , listenerArgs ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $digest // (though it differs due to having the extra check for $$listenerCount and // does not check $$suspended) if ( ! ( next = ( ( current . $$listenerCount [ name ] && current . $$childHead ) || ( current !== target && current . $$nextSibling ) ) ) ) { while ( current !== target && ! ( next = current . $$nextSibling ) ) { current = current . $parent ; } } } event . currentScope = null ; return event ; } } ; var $rootScope = new Scope ( ) ; //The internal queues. Expose them on the $rootScope for debugging/testing purposes. var asyncQueue = $rootScope . $$asyncQueue = [ ] ; var postDigestQueue = $rootScope . $$postDigestQueue = [ ] ; var applyAsyncQueue = $rootScope . $$applyAsyncQueue = [ ] ; var postDigestQueuePosition = 0 ; return $rootScope ; function beginPhase ( phase ) { if ( $rootScope . $$phase ) { throw $rootScopeMinErr ( 'inprog' , '{0} already in progress' , $rootScope . $$phase ) ; } $rootScope . $$phase = phase ; } function clearPhase ( ) { $rootScope . $$phase = null ; } function incrementWatchersCount ( current , count ) { do { current . $$watchersCount += count ; } while ( ( current = current . $parent ) ) ; } function decrementListenerCount ( current , count , name ) { do { current . $$listenerCount [ name ] -= count ; if ( current . $$listenerCount [ name ] === 0 ) { delete current . $$listenerCount [ name ] ; } } while ( ( current = current . $parent ) ) ; } /** * function used as an initial value for watchers. * because it's unique we can easily tell it apart from other values */ function initWatchVal ( ) { } function flushApplyAsync ( ) { while ( applyAsyncQueue . length ) { try { applyAsyncQueue . shift ( ) ( ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } applyAsyncId = null ; } function scheduleApplyAsync ( ) { if ( applyAsyncId === null ) { applyAsyncId = $browser . defer ( function ( ) { $rootScope . $apply ( flushApplyAsync ) ; } , null , '$applyAsync' ) ; } } } ] ; } 
function ( isolate , parent ) { var child ; parent = parent || this ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; } else { 
function ( watchExpressions , listener ) { var oldValues = new Array ( watchExpressions . length ) ; var newValues = new Array ( watchExpressions . length ) ; var deregisterFns = [ ] ; var self = this ; var changeReactionScheduled = false ; var firstRun = true ; if ( ! watchExpressions . length ) { 
function $$SanitizeUriProvider ( ) { var aHrefSanitizationWhitelist = / ^\s*(https?|s?ftp|mailto|tel|file): / , imgSrcSanitizationWhitelist = / ^\s*((https?|ftp|file|blob):|data:image\/) / ; this . aHrefSanitizationWhitelist = function ( regexp ) { if ( isDefined ( regexp ) ) { aHrefSanitizationWhitelist = regexp ; return this ; } return aHrefSanitizationWhitelist ; } ; this . imgSrcSanitizationWhitelist = function ( regexp ) { if ( isDefined ( regexp ) ) { imgSrcSanitizationWhitelist = regexp ; return this ; } return imgSrcSanitizationWhitelist ; } ; this . $get = function ( ) { return function sanitizeUri ( uri , isMediaUrl ) { 
function getTrusted ( type , maybeTrusted ) { if ( maybeTrusted === null || isUndefined ( maybeTrusted ) || maybeTrusted === '' ) { return maybeTrusted ; } var constructor = ( byType . hasOwnProperty ( type ) ? byType [ type ] : null ) ; 
function urlIsAllowedOriginFactory ( whitelistedOriginUrls ) { var parsedAllowedOriginUrls = [ originUrl ] . concat ( whitelistedOriginUrls . map ( urlResolve ) ) ; return function urlIsAllowedOrigin ( requestUrl ) { var parsedUrl = urlResolve ( requestUrl ) ; return parsedAllowedOriginUrls . some ( urlsAreSameOrigin . bind ( null , parsedUrl ) ) ; } ; } 
function urlsAreSameOrigin ( url1 , url2 ) { url1 = urlResolve ( url1 ) ; url2 = urlResolve ( url2 ) ; return ( url1 . protocol === url2 . protocol && url1 . host === url2 . host ) ; } 
function getBaseUrl ( ) { if ( window . document . baseURI ) { return window . document . baseURI ; } 
function filterFilter ( ) { return function ( array , expression , comparator , anyPropertyKey ) { if ( ! isArrayLike ( array ) ) { if ( array == null ) { return array ; } else { throw minErr ( 'filter' ) ( 'notarray' , 'Expected array but received: {0}' , array ) ; } } anyPropertyKey = anyPropertyKey || '$' ; var expressionType = getTypeForFilter ( expression ) ; var predicateFn ; var matchAgainstAnyProp ; switch ( expressionType ) { case 'function' : predicateFn = expression ; break ; case 'boolean' : case 'null' : case 'number' : case 'string' : matchAgainstAnyProp = true ; 
function formatNumber ( number , pattern , groupSep , decimalSep , fractionSize ) { if ( ! ( isString ( number ) || isNumber ( number ) ) || isNaN ( number ) ) return '' ; var isInfinity = ! isFinite ( number ) ; var isZero = false ; var numStr = Math . abs ( number ) + '' , formattedText = '' , parsedNumber ; if ( isInfinity ) { formattedText = '\u221e' ; } else { parsedNumber = parse ( numStr ) ; roundNumber ( parsedNumber , fractionSize , pattern . minFrac , pattern . maxFrac ) ; var digits = parsedNumber . d ; var integerLen = parsedNumber . i ; var exponent = parsedNumber . e ; var decimals = [ ] ; isZero = digits . reduce ( function ( isZero , d ) { return isZero && ! d ; } , true ) ; 
function limitToFilter ( ) { return function ( input , limit , begin ) { if ( Math . abs ( Number ( limit ) ) === Infinity ) { limit = Number ( limit ) ; } else { limit = toInt ( limit ) ; } if ( isNumberNaN ( limit ) ) return input ; if ( isNumber ( input ) ) input = input . toString ( ) ; if ( ! isArrayLike ( input ) ) return input ; begin = ( ! begin || isNaN ( begin ) ) ? 0 : toInt ( begin ) ; begin = ( begin < 0 ) ? Math . max ( 0 , input . length + begin ) : begin ; if ( limit >= 0 ) { return sliceFn ( input , begin , begin + limit ) ; } else { if ( begin === 0 ) { return sliceFn ( input , limit , input . length ) ; } else { return sliceFn ( input , Math . max ( 0 , begin + limit ) , begin ) ; } } } ; } 
function ( control , newName ) { var oldName = control . $name ; if ( this [ oldName ] === control ) { delete this [ oldName ] ; } this [ newName ] = control ; control . $name = newName ; } 
function ( control ) { if ( control . $name && this [ control . $name ] === control ) { delete this [ control . $name ] ; } forEach ( this . $pending , function ( value , name ) { 
function ( ) { this . $$animate . setClass ( this . $$element , PRISTINE_CLASS , DIRTY_CLASS + ' ' + SUBMITTED_CLASS ) ; this . $dirty = false ; this . $pristine = true ; this . $submitted = false ; forEach ( this . $$controls , function ( control ) { control . $setPristine ( ) ; } ) ; } 
function ( isNgForm ) { return [ '$timeout' , '$parse' , function ( $timeout , $parse ) { var formDirective = { name : 'form' , restrict : isNgForm ? 'EAC' : 'E' , require : [ 'form' , '^^?form' ] , 
function setupValidity ( instance ) { instance . $$classCache = { } ; instance . $$classCache [ INVALID_CLASS ] = ! ( instance . $$classCache [ VALID_CLASS ] = instance . $$element . hasClass ( VALID_CLASS ) ) ; } 
function updateElementValue ( element , attr , value ) { 
function classDirective ( name , selector ) { name = 'ngClass' + name ; var indexWatchExpression ; return [ '$parse' , function ( $parse ) { return { restrict : 'AC' , link : function ( scope , element , attr ) { var classCounts = element . data ( '$classCounts' ) ; var oldModulo = true ; var oldClassString ; if ( ! classCounts ) { 
function ( ) { 
function ( ) { var formatters = this . $formatters , idx = formatters . length ; var viewValue = this . $modelValue ; while ( idx -- ) { viewValue = formatters [ idx ] ( viewValue ) ; } return viewValue ; } 
function ( ) { NgModelOptionsController . $inject = [ '$attrs' , '$scope' ] ; function NgModelOptionsController ( $attrs , $scope ) { this . $$attrs = $attrs ; this . $$scope = $scope ; } NgModelOptionsController . prototype = { $onInit : function ( ) { var parentOptions = this . parentCtrl ? this . parentCtrl . $options : defaultModelOptions ; var modelOptionsDefinition = this . $$scope . $eval ( this . $$attrs . ngModelOptions ) ; this . $options = parentOptions . createChild ( modelOptionsDefinition ) ; } } ; return { restrict : 'A' , 
function defaults ( dst , src ) { forEach ( src , function ( value , key ) { if ( ! isDefined ( dst [ key ] ) ) { dst [ key ] = value ; } } ) ; } 
function addOptionElement ( option , parent ) { var optionElement = optionTemplate . cloneNode ( false ) ; parent . appendChild ( optionElement ) ; updateOptionElement ( option , optionElement ) ; } 
function ( playAnimation ) { if ( ! animationCompleted ) { animationPaused = ! playAnimation ; if ( timings . animationDuration ) { var value = blockKeyframeAnimations ( node , animationPaused ) ; if ( animationPaused ) { temporaryStyles . push ( value ) ; } else { removeFromArray ( temporaryStyles , value ) ; } } } else if ( animationPaused && playAnimation ) { animationPaused = false ; close ( ) ; } } 
function ( element , bool ) { var argCount = arguments . length ; if ( argCount === 0 ) { 
function areAnimationsAllowed ( node , parentNode , event ) { var bodyNode = $document [ 0 ] . body ; var rootNode = getDomNode ( $rootElement ) ; var bodyNodeDetected = ( node === bodyNode ) || node . nodeName === 'HTML' ; var rootNodeDetected = ( node === rootNode ) ; var parentAnimationDetected = false ; var elementDisabled = disabledElementsLookup . get ( node ) ; var animateChildren ; var parentHost = jqLite . data ( node , NG_ANIMATE_PIN_DATA ) ; if ( parentHost ) { parentNode = getDomNode ( parentHost ) ; } while ( parentNode ) { if ( ! rootNodeDetected ) { 
function ( scope , $element , attrs , ctrl , $transclude ) { var previousElement , previousScope ; scope . $watchCollection ( attrs . ngAnimateSwap || attrs [ 'for' ] , function ( value ) { if ( previousElement ) { $animate . leave ( previousElement ) ; } if ( previousScope ) { previousScope . $destroy ( ) ; previousScope = null ; } if ( value || value === 0 ) { $transclude ( function ( clone , childScope ) { previousElement = clone ; previousScope = childScope ; $animate . enter ( clone , null , $element ) ; } ) ; } } ) ; } 
function $AriaProvider ( ) { var config = { ariaHidden : true , ariaChecked : true , ariaReadonly : true , ariaDisabled : true , ariaRequired : true , ariaInvalid : true , ariaValue : true , tabindex : true , bindKeydown : true , bindRoleForClick : true } ; this . config = function ( newConfig ) { config = angular . extend ( config , newConfig ) ; } ; function watchExpr ( attrName , ariaAttr , nodeBlackList , negate ) { return function ( scope , elem , attr ) { if ( attr . hasOwnProperty ( ARIA_DISABLE_ATTR ) ) return ; var ariaCamelName = attr . $normalize ( ariaAttr ) ; if ( config [ ariaCamelName ] && ! isNodeOneOf ( elem , nodeBlackList ) && ! attr [ ariaCamelName ] ) { scope . $watch ( attr [ attrName ] , function ( boolVal ) { * @ngdoc service * @name $aria * * @description * @priority 200 * * The $aria service contains helper methods for applying common * [ARIA](http: * * ngAria injects common accessibility attributes that tell assistive technologies when HTML * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria, * let's review a code snippet from ngAria itself: * *```js * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) { * return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false); * }]) *``` * Shown above, the ngAria module creates a directive with the same signature as the * traditional `ng-disabled` directive. But this ngAria version is dedicated to * solely managing accessibility attributes on custom elements. The internal `$aria` service is * used to watch the boolean attribute `ngDisabled`. If it has not been explicitly set by the * developer, `aria-disabled` is injected as an attribute with its value synchronized to the * value in `ngDisabled`. * * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do * anything to enable this feature. The `aria-disabled` attribute is automatically managed * simply as a silent side-effect of using `ng-disabled` with the ngAria module. * * The full list of directives that interface with ngAria: * * **ngModel** * * **ngChecked** * * **ngReadonly** * * **ngRequired** * * **ngDisabled** * * **ngValue** * * **ngShow** * * **ngHide** * * **ngClick** * * **ngDblclick** * * **ngMessages** * * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each * directive. * * * ## Dependencies * Requires the {@link ngAria} module to be installed. */ this . $get = function ( ) { return { config : function ( key ) { return config [ key ] ; } , $$watchExpr : watchExpr } ; } ; } 
function ( elem , attr ) { if ( attr . hasOwnProperty ( ARIA_DISABLE_ATTR ) ) return ; var shape = getShape ( attr , elem ) ; return { post : function ( scope , elem , attr , ngModel ) { var needsTabIndex = shouldAttachAttr ( 'tabindex' , 'tabindex' , elem , false ) ; function ngAriaWatchModelValue ( ) { return ngModel . $modelValue ; } function getRadioReaction ( newVal ) { 
function ( $scope , element , attrs ) { var src = attrs . ngMessagesInclude || attrs . src ; $templateRequest ( src ) . then ( function ( html ) { if ( $scope . $$destroyed ) return ; if ( isString ( html ) && ! html . trim ( ) ) { 
function replaceElementWithMarker ( element , src ) { 
function locale_locales__getSetGlobalLocale ( key , values ) { var data ; if ( key ) { if ( typeof values === 'undefined' ) { data = locale_locales__getLocale ( key ) ; } else { data = defineLocale ( key , values ) ; } if ( data ) { 
function configFromString ( config ) { var matched = aspNetJsonRegex . exec ( config . _i ) ; if ( matched !== null ) { config . _d = new Date ( + matched [ 1 ] ) ; return ; } configFromISO ( config ) ; if ( config . _isValid === false ) { delete config . _isValid ; utils_hooks__hooks . createFromInputFallback ( config ) ; } } 
function getSetWeekYear ( input ) { var year = weekOfYear ( this , this . localeData ( ) . _week . dow , this . localeData ( ) . _week . doy ) . year ; return input == null ? year : this . add ( ( input - year ) , 'y' ) ; } 
function getSetDayOfWeek ( input ) { var day = this . _isUTC ? this . _d . getUTCDay ( ) : this . _d . getDay ( ) ; if ( input != null ) { input = parseWeekday ( input , this . localeData ( ) ) ; return this . add ( input - day , 'd' ) ; } else { return day ; } } 
function duration_humanize__getSetRelativeTimeThreshold ( threshold , limit ) { if ( thresholds [ threshold ] === undefined ) { return false ; } if ( limit === undefined ) { return thresholds [ threshold ] ; } thresholds [ threshold ] = limit ; return true ; } 
function ( element , parent , options ) { options = options || { } ; $mdUtil . disableScrollAround . _count = Math . max ( 0 , $mdUtil . disableScrollAround . _count || 0 ) ; $mdUtil . disableScrollAround . _count ++ ; if ( $mdUtil . disableScrollAround . _restoreScroll ) { return $mdUtil . disableScrollAround . _restoreScroll ; } var body = $document [ 0 ] . body ; var restoreBody = disableBodyScroll ( ) ; var restoreElement = disableElementScroll ( parent ) ; return $mdUtil . disableScrollAround . _restoreScroll = function ( ) { if ( -- $mdUtil . disableScrollAround . _count <= 0 ) { restoreBody ( ) ; restoreElement ( ) ; delete $mdUtil . disableScrollAround . _restoreScroll ; } } ; function disableElementScroll ( element ) { element = angular . element ( element || body ) ; var scrollMask ; if ( options . disableScrollMask ) { scrollMask = element ; } else { scrollMask = angular . element ( '<div class="md-scroll-mask">' + ' <div class="md-scroll-mask-bar"></div>' + '</div>' ) ; element . append ( scrollMask ) ; } scrollMask . on ( 'wheel' , preventDefault ) ; scrollMask . on ( 'touchmove' , preventDefault ) ; return function restoreElementScroll ( ) { scrollMask . off ( 'wheel' ) ; scrollMask . off ( 'touchmove' ) ; if ( ! options . disableScrollMask && scrollMask [ 0 ] . parentNode ) { scrollMask [ 0 ] . parentNode . removeChild ( scrollMask [ 0 ] ) ; } } ; function preventDefault ( e ) { e . preventDefault ( ) ; } } 
function MdGesture ( $$MdGestureHandler , $$rAF , $timeout ) { var userAgent = navigator . userAgent || navigator . vendor || window . opera ; var isIos = userAgent . match ( / ipad|iphone|ipod / i ) ; var isAndroid = userAgent . match ( / android / i ) ; var touchActionProperty = getTouchAction ( ) ; var hasJQuery = ( typeof window . jQuery !== 'undefined' ) && ( angular . element === window . jQuery ) ; var self = { handler : addHandler , register : register , isAndroid : isAndroid , isIos : isIos , * Register an element to listen for a handler. * This allows an element to override the default options for a handler. * Additionally, some handlers like drag and hold only dispatch events if * the domEvent happens inside an element that's registered to listen for these events. * * @see GestureHandler for how overriding of default options works. * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horizontal: false }) */ function register ( element , handlerName , options ) { var handler = HANDLERS [ handlerName . replace ( / ^\$md. / , '' ) ] ; if ( ! handler ) { throw new Error ( 'Failed to register element with handler ' + handlerName + '. ' + 'Available handlers: ' + Object . keys ( HANDLERS ) . join ( ', ' ) ) ; } return handler . registerElement ( element , options ) ; } /* * add a handler to $mdGesture. see below. */ function addHandler ( name , definition ) { var handler = new $$MdGestureHandler ( name ) ; angular . extend ( handler , definition ) ; HANDLERS [ name ] = handler ; return self ; } /** * Register handlers. These listen to touch/start/move events, interpret them, * and dispatch gesture events depending on options & conditions. These are all * instances of GestureHandler. * @see GestureHandler */ return self /* * The press handler dispatches an event on touchdown/touchend. * It's a simple abstraction of touch/mouse/pointer start and end. */ . handler ( 'press' , { onStart : function ( ev , pointer ) { this . dispatchEvent ( ev , '$md.pressdown' ) ; } , onEnd : function ( ev , pointer ) { this . dispatchEvent ( ev , '$md.pressup' ) ; } } ) . handler ( 'hold' , { options : { maxDistance : 6 , delay : 500 } , onCancel : function ( ) { $timeout . cancel ( this . state . timeout ) ; } , onStart : function ( ev , pointer ) { * The drag handler dispatches a drag event if the user holds and moves his finger greater than * <minDistance> px in the x or y direction, depending on options.horizontal. * The drag will be cancelled if the user moves his finger greater than <minDistance>*<cancelMultiplier> in * the perpendicular direction. Eg if the drag is horizontal and the user moves his finger <minDistance>*<cancelMultiplier> * pixels vertically, this handler won't consider the move part of a drag. */ . handler ( 'drag' , { options : { minDistance : 6 , horizontal : true , cancelMultiplier : 1.5 } , onSetup : function ( element , options ) { if ( touchActionProperty ) { // We check for horizontal to be false, because otherwise we would overwrite the default opts. this . oldTouchAction = element [ 0 ] . style [ touchActionProperty ] ; element [ 0 ] . style [ touchActionProperty ] = options . horizontal ? 'pan-y' : 'pan-x' ; } } , onCleanup : function ( element ) { if ( this . oldTouchAction ) { element [ 0 ] . style [ touchActionProperty ] = this . oldTouchAction ; } } , onStart : function ( ev ) { // For drag, require a parent to be registered with $mdGesture.register() if ( ! this . state . registeredParent ) this . cancel ( ) ; } , onMove : function ( ev , pointer ) { var shouldStartDrag , shouldCancel ; // Don't scroll while deciding if this touchmove qualifies as a drag event. * The swipe handler will dispatch a swipe event if, on the end of a touch, * the velocity and distance were high enough. */ . handler ( 'swipe' , { options : { minVelocity : 0.65 , minDistance : 10 } , onEnd : function ( ev , pointer ) { var eventType ; if ( Math . abs ( pointer . velocityX ) > this . state . options . minVelocity && Math . abs ( pointer . distanceX ) > this . state . options . minDistance ) { eventType = pointer . directionX == 'left' ? '$md.swipeleft' : '$md.swiperight' ; this . dispatchEvent ( ev , eventType ) ; } else if ( Math . abs ( pointer . velocityY ) > this . state . options . minVelocity && Math . abs ( pointer . distanceY ) > this . state . options . minDistance ) { eventType = pointer . directionY == 'up' ? '$md.swipeup' : '$md.swipedown' ; this . dispatchEvent ( ev , eventType ) ; } } } ) ; function getTouchAction ( ) { var testEl = document . createElement ( 'div' ) ; var vendorPrefixes = [ '' , 'webkit' , 'Moz' , 'MS' , 'ms' , 'o' ] ; for ( var i = 0 ; i < vendorPrefixes . length ; i ++ ) { var prefix = vendorPrefixes [ i ] ; var property = prefix ? prefix + 'TouchAction' : 'touchAction' ; if ( angular . isDefined ( testEl . style [ property ] ) ) { return property ; } } } } 
function MdInteractionService ( $timeout , $mdUtil ) { this . $timeout = $timeout ; this . $mdUtil = $mdUtil ; this . bodyElement = angular . element ( document . body ) ; this . isBuffering = false ; this . bufferTimeout = null ; this . lastInteractionType = null ; this . lastInteractionTime = null ; 
function InterimElementProvider ( ) { InterimElementFactory . $inject = [ "$document" , "$q" , "$rootScope" , "$timeout" , "$rootElement" , "$animate" , "$mdUtil" , "$mdCompiler" , "$mdTheming" , "$injector" , "$exceptionHandler" ] ; createInterimElementProvider . $get = InterimElementFactory ; return createInterimElementProvider ; function createInterimElementProvider ( interimFactoryName ) { factory . $inject = [ "$$interimElement" , "$injector" ] ; var EXPOSED_METHODS = [ 'onHide' , 'onShow' , 'onRemove' ] ; var customMethods = { } ; var providerConfig = { presets : { } } ; var provider = { setDefaults : setDefaults , addPreset : addPreset , addMethod : addMethod , $get : factory } ; provider . addPreset ( 'build' , { methods : [ 'controller' , 'controllerAs' , 'resolve' , 'multiple' , 'template' , 'templateUrl' , 'themable' , 'transformTemplate' , 'parent' , 'contentElement' ] } ) ; return provider ; function setDefaults ( definition ) { providerConfig . optionsFactory = definition . options ; providerConfig . methods = ( definition . methods || [ ] ) . concat ( EXPOSED_METHODS ) ; return provider ; } function addMethod ( name , fn ) { customMethods [ name ] = fn ; return provider ; } function addPreset ( name , definition ) { definition = definition || { } ; definition . methods = definition . methods || [ ] ; definition . options = definition . options || function ( ) { return { } ; } ; if ( / ^cancel|hide|show$ / . test ( name ) ) { throw new Error ( "Preset '" + name + "' in " + interimFactoryName + " is reserved!" ) ; } if ( definition . methods . indexOf ( '_options' ) > - 1 ) { throw new Error ( "Method '_options' in " + interimFactoryName + " is reserved!" ) ; } providerConfig . presets [ name ] = { methods : definition . methods . concat ( EXPOSED_METHODS ) , optionsFactory : definition . options , argOption : definition . argOption } ; return provider ; } function addPresetMethod ( presetName , methodName , method ) { providerConfig . presets [ presetName ] [ methodName ] = method ; } function factory ( $$interimElement , $injector ) { var defaultMethods ; var defaultOptions ; var interimElementService = $$interimElement ( ) ; var publicService = { hide : interimElementService . hide , cancel : interimElementService . cancel , show : showInterimElement , * */ function showInterimElement ( opts ) { * Special method to hide and destroy an interimElement WITHOUT * any 'leave` or hide animations ( an immediate force hide/remove ) * * NOTE: This calls the onRemove() subclass method for each component... * which must have code to respond to `options.$destroy == true` */ function destroyInterimElement ( opts ) { return interimElementService . destroy ( opts ) ; } /** * Helper to call $injector.invoke with a local of the factory name for * this provider. * If an $mdDialog is providing options for a dialog and tries to inject * $mdDialog, a circular dependency error will happen. * We get around that by manually injecting $mdDialog as a local. */ function invokeFactory ( factory , defaultVal ) { var locals = { } ; locals [ interimFactoryName ] = publicService ; return $injector . invoke ( factory || function ( ) { return defaultVal ; } , { } , locals ) ; } } } /* @ngInject */ function InterimElementFactory ( $document , $q , $rootScope , $timeout , $rootElement , $animate , $mdUtil , $mdCompiler , $mdTheming , $injector , $exceptionHandler ) { return function createInterimElementService ( ) { var SHOW_CANCELLED = false ; /* * @ngdoc service * @name $$interimElement.$service * * @description * A service used to control inserting and removing an element into the DOM. * */ var service ; var showPromises = [ ] ; // Promises for the interim's which are currently opening. var hidePromises = [ ] ; * @ngdoc method * @name $$interimElement.$service#show * @kind function * * @description * Adds the `$interimElement` to the DOM and returns a special promise that will be resolved or rejected * with hide or cancel, respectively. To external cancel/hide, developers should use the * * @param {*} options is hashMap of settings * @returns a Promise * */ function show ( options ) { options = options || { } ; var interimElement = new InterimElement ( options || { } ) ; * @ngdoc method * @name $$interimElement.$service#hide * @kind function * * @description * Removes the `$interimElement` from the DOM and resolves the promise returned from `show` * * @param {*} resolveParam Data to resolve the promise with * @returns a Promise that will be resolved after the element has been removed. * */ function hide ( reason , options ) { options = options || { } ; if ( options . closeAll ) { * @ngdoc method * @name $$interimElement.$service#cancel * @kind function * * @description * Removes the `$interimElement` from the DOM and rejects the promise returned from `show` * * @param {*} reason Data to reject the promise with * @returns Promise that will be resolved after the element has been removed. * */ function cancel ( reason , options ) { var interim = showingInterims . pop ( ) ; if ( ! interim ) { return $q . when ( reason ) ; } var cancelAction = interim . remove ( reason , true , options || { } ) . catch ( function ( reason ) { return reason ; } ) . finally ( function ( ) { hidePromises . splice ( hidePromises . indexOf ( cancelAction ) , 1 ) ; } ) ; hidePromises . push ( cancelAction ) ; * Creates a function to wait for at least one interim element to be available. * @param callbackFn Function to be used as callback * @returns {Function} */ function waitForInterim ( callbackFn ) { return function ( ) { var fnArguments = arguments ; if ( ! showingInterims . length ) { * Special method to quick-remove the interim element without animations * Note: interim elements are in "interim containers" */ function destroy ( targetEl ) { var interim = ! targetEl ? showingInterims . shift ( ) : null ; var parentEl = angular . element ( targetEl ) . length && angular . element ( targetEl ) [ 0 ] . parentNode ; if ( parentEl ) { * Internal Interim Element Object * Used internally to manage the DOM element and related data */ function InterimElement ( options ) { var self , element , showAction = $q . when ( true ) ; options = configureScopeAndTransitions ( options ) ; return self = { options : options , deferred : $q . defer ( ) , show : createAndTransitionIn , remove : transitionOutAndRemove } ; function createAndTransitionIn ( ) { return $q ( function ( resolve , reject ) { * After the show process has finished/rejected: * - announce 'removing', * - perform the transition-out, and * - perform optional clean up scope. */ function transitionOutAndRemove ( response , isCancelled , opts ) { * The `show()` returns a promise that will be resolved when the interim * element is hidden or cancelled... */ function resolveAll ( response ) { self . deferred . resolve ( response ) ; } function rejectAll ( fault ) { self . deferred . reject ( fault ) ; } } function configureScopeAndTransitions ( options ) { options = options || { } ; if ( options . template ) { options . template = $mdUtil . processTemplate ( options . template ) ; } return angular . extend ( { preserveScope : false , cancelAutoHide : angular . noop , scope : options . scope || $rootScope . $new ( options . isolateScope ) , onShow : function transitionIn ( scope , element , options ) { return $animate . enter ( element , options . parent ) ; } , onRemove : function transitionOut ( scope , element ) { * Compile an element with a templateUrl, controller, and locals */ function compileElement ( options ) { var compiled = ! options . skipCompile ? $mdCompiler . compile ( options ) : null ; return compiled || $q ( function ( resolve ) { resolve ( { locals : { } , link : function ( ) { return options . element ; } } ) ; } ) ; } function linkElement ( compileData , options ) { angular . extend ( compileData . locals , options ) ; var element = compileData . link ( options . scope ) ; * Search for parent at insertion time, if not specified */ function findParent ( element , options ) { var parent = options . parent ; * If auto-hide is enabled, start timer and prepare cancel function */ function startAutoHide ( ) { var autoHideTimer , cancelAutoHide = angular . noop ; if ( options . hideDelay ) { autoHideTimer = $timeout ( service . hide , options . hideDelay ) ; cancelAutoHide = function ( ) { $timeout . cancel ( autoHideTimer ) ; } ; } * Show the element ( with transitions), notify complete and start * optional auto-Hide */ function showElement ( element , options , controller ) { 
function createInterimElementProvider ( interimFactoryName ) { factory . $inject = [ "$$interimElement" , "$injector" ] ; var EXPOSED_METHODS = [ 'onHide' , 'onShow' , 'onRemove' ] ; var customMethods = { } ; var providerConfig = { presets : { } } ; var provider = { setDefaults : setDefaults , addPreset : addPreset , addMethod : addMethod , $get : factory } ; provider . addPreset ( 'build' , { methods : [ 'controller' , 'controllerAs' , 'resolve' , 'multiple' , 'template' , 'templateUrl' , 'themable' , 'transformTemplate' , 'parent' , 'contentElement' ] } ) ; return provider ; function setDefaults ( definition ) { providerConfig . optionsFactory = definition . options ; providerConfig . methods = ( definition . methods || [ ] ) . concat ( EXPOSED_METHODS ) ; return provider ; } function addMethod ( name , fn ) { customMethods [ name ] = fn ; return provider ; } function addPreset ( name , definition ) { definition = definition || { } ; definition . methods = definition . methods || [ ] ; definition . options = definition . options || function ( ) { return { } ; } ; if ( / ^cancel|hide|show$ / . test ( name ) ) { throw new Error ( "Preset '" + name + "' in " + interimFactoryName + " is reserved!" ) ; } if ( definition . methods . indexOf ( '_options' ) > - 1 ) { throw new Error ( "Method '_options' in " + interimFactoryName + " is reserved!" ) ; } providerConfig . presets [ name ] = { methods : definition . methods . concat ( EXPOSED_METHODS ) , optionsFactory : definition . options , argOption : definition . argOption } ; return provider ; } function addPresetMethod ( presetName , methodName , method ) { providerConfig . presets [ presetName ] [ methodName ] = method ; } function factory ( $$interimElement , $injector ) { var defaultMethods ; var defaultOptions ; var interimElementService = $$interimElement ( ) ; var publicService = { hide : interimElementService . hide , cancel : interimElementService . cancel , show : showInterimElement , * */ function showInterimElement ( opts ) { * Special method to hide and destroy an interimElement WITHOUT * any 'leave` or hide animations ( an immediate force hide/remove ) * * NOTE: This calls the onRemove() subclass method for each component... * which must have code to respond to `options.$destroy == true` */ function destroyInterimElement ( opts ) { return interimElementService . destroy ( opts ) ; } function invokeFactory ( factory , defaultVal ) { var locals = { } ; locals [ interimFactoryName ] = publicService ; return $injector . invoke ( factory || function ( ) { return defaultVal ; } , { } , locals ) ; } } } 
function InterimElementFactory ( $document , $q , $rootScope , $timeout , $rootElement , $animate , $mdUtil , $mdCompiler , $mdTheming , $injector , $exceptionHandler ) { return function createInterimElementService ( ) { var SHOW_CANCELLED = false ; var service ; var showPromises = [ ] ; * @ngdoc method * @name $$interimElement.$service#show * @kind function * * @description * Adds the `$interimElement` to the DOM and returns a special promise that will be resolved or rejected * with hide or cancel, respectively. To external cancel/hide, developers should use the * * @param {*} options is hashMap of settings * @returns a Promise * */ function show ( options ) { options = options || { } ; var interimElement = new InterimElement ( options || { } ) ; * @ngdoc method * @name $$interimElement.$service#hide * @kind function * * @description * Removes the `$interimElement` from the DOM and resolves the promise returned from `show` * * @param {*} resolveParam Data to resolve the promise with * @returns a Promise that will be resolved after the element has been removed. * */ function hide ( reason , options ) { options = options || { } ; if ( options . closeAll ) { * @ngdoc method * @name $$interimElement.$service#cancel * @kind function * * @description * Removes the `$interimElement` from the DOM and rejects the promise returned from `show` * * @param {*} reason Data to reject the promise with * @returns Promise that will be resolved after the element has been removed. * */ function cancel ( reason , options ) { var interim = showingInterims . pop ( ) ; if ( ! interim ) { return $q . when ( reason ) ; } var cancelAction = interim . remove ( reason , true , options || { } ) . catch ( function ( reason ) { return reason ; } ) . finally ( function ( ) { hidePromises . splice ( hidePromises . indexOf ( cancelAction ) , 1 ) ; } ) ; hidePromises . push ( cancelAction ) ; * Creates a function to wait for at least one interim element to be available. * @param callbackFn Function to be used as callback * @returns {Function} */ function waitForInterim ( callbackFn ) { return function ( ) { var fnArguments = arguments ; if ( ! showingInterims . length ) { * Special method to quick-remove the interim element without animations * Note: interim elements are in "interim containers" */ function destroy ( targetEl ) { var interim = ! targetEl ? showingInterims . shift ( ) : null ; var parentEl = angular . element ( targetEl ) . length && angular . element ( targetEl ) [ 0 ] . parentNode ; if ( parentEl ) { * Internal Interim Element Object * Used internally to manage the DOM element and related data */ function InterimElement ( options ) { var self , element , showAction = $q . when ( true ) ; options = configureScopeAndTransitions ( options ) ; return self = { options : options , deferred : $q . defer ( ) , show : createAndTransitionIn , remove : transitionOutAndRemove } ; function createAndTransitionIn ( ) { return $q ( function ( resolve , reject ) { * After the show process has finished/rejected: * - announce 'removing', * - perform the transition-out, and * - perform optional clean up scope. */ function transitionOutAndRemove ( response , isCancelled , opts ) { * The `show()` returns a promise that will be resolved when the interim * element is hidden or cancelled... */ function resolveAll ( response ) { self . deferred . resolve ( response ) ; } function rejectAll ( fault ) { self . deferred . reject ( fault ) ; } } function configureScopeAndTransitions ( options ) { options = options || { } ; if ( options . template ) { options . template = $mdUtil . processTemplate ( options . template ) ; } return angular . extend ( { preserveScope : false , cancelAutoHide : angular . noop , scope : options . scope || $rootScope . $new ( options . isolateScope ) , onShow : function transitionIn ( scope , element , options ) { return $animate . enter ( element , options . parent ) ; } , onRemove : function transitionOut ( scope , element ) { * Compile an element with a templateUrl, controller, and locals */ function compileElement ( options ) { var compiled = ! options . skipCompile ? $mdCompiler . compile ( options ) : null ; return compiled || $q ( function ( resolve ) { resolve ( { locals : { } , link : function ( ) { return options . element ; } } ) ; } ) ; } function linkElement ( compileData , options ) { angular . extend ( compileData . locals , options ) ; var element = compileData . link ( options . scope ) ; * Search for parent at insertion time, if not specified */ function findParent ( element , options ) { var parent = options . parent ; * If auto-hide is enabled, start timer and prepare cancel function */ function startAutoHide ( ) { var autoHideTimer , cancelAutoHide = angular . noop ; if ( options . hideDelay ) { autoHideTimer = $timeout ( service . hide , options . hideDelay ) ; cancelAutoHide = function ( ) { $timeout . cancel ( autoHideTimer ) ; } ; } * Show the element ( with transitions), notify complete and start * optional auto-Hide */ function showElement ( element , options , controller ) { 
function show ( options ) { options = options || { } ; var interimElement = new InterimElement ( options || { } ) ; 
function MdCheckboxDirective ( inputDirective , $mdAria , $mdConstant , $mdTheming , $mdUtil , $mdInteraction ) { inputDirective = inputDirective [ 0 ] ; return { restrict : 'E' , transclude : true , require : [ '^?mdInputContainer' , '?ngModel' , '?^form' ] , priority : $mdConstant . BEFORE_NG_ARIA , template : '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>' , compile : compile } ; 
function MdColorsDirective ( $mdColors , $mdUtil , $log , $parse ) { return { restrict : 'A' , require : [ '^?mdTheme' ] , compile : function ( tElem , tAttrs ) { var shouldWatch = shouldColorsWatch ( ) ; return function ( scope , element , attrs , ctrl ) { var mdThemeController = ctrl [ 0 ] ; var lastColors = { } ; var parseColors = function ( theme ) { if ( typeof theme !== 'string' ) { theme = '' ; } if ( ! attrs . mdColors ) { attrs . mdColors = '{}' ; } var colors = $parse ( attrs . mdColors ) ( scope ) ; if ( mdThemeController ) { Object . keys ( colors ) . forEach ( function ( prop ) { var color = colors [ prop ] ; if ( ! $mdColors . hasTheme ( color ) ) { colors [ prop ] = ( theme || mdThemeController . $mdTheme ) + '-' + color ; } } ) ; } cleanElement ( colors ) ; return colors ; } ; var cleanElement = function ( colors ) { if ( ! angular . equals ( colors , lastColors ) ) { var keys = Object . keys ( lastColors ) ; if ( lastColors . background && ! keys . color ) { keys . push ( 'color' ) ; } keys . forEach ( function ( key ) { element . css ( key , '' ) ; } ) ; } lastColors = colors ; } ; var unregisterChanges = angular . noop ; if ( mdThemeController ) { unregisterChanges = mdThemeController . registerChanges ( function ( theme ) { $mdColors . applyThemeColors ( element , parseColors ( theme ) ) ; } ) ; } scope . $on ( '$destroy' , function ( ) { unregisterChanges ( ) ; } ) ; try { if ( shouldWatch ) { scope . $watch ( parseColors , angular . bind ( this , $mdColors . applyThemeColors , element ) , true ) ; } else { $mdColors . applyThemeColors ( element , parseColors ( ) ) ; } } catch ( e ) { $log . error ( e . message ) ; } } ; function shouldColorsWatch ( ) { 
function GridTileDirective ( $mdMedia ) { return { restrict : 'E' , require : '^mdGridList' , template : '<figure ng-transclude></figure>' , transclude : true , scope : { } , 
function mdInputContainerDirective ( $mdTheming , $parse ) { ContainerCtrl . $inject = [ "$scope" , "$element" , "$attrs" , "$animate" ] ; var INPUT_TAGS = [ 'INPUT' , 'TEXTAREA' , 'SELECT' , 'MD-SELECT' ] ; var LEFT_SELECTORS = INPUT_TAGS . reduce ( function ( selectors , isel ) { return selectors . concat ( [ 'md-icon ~ ' + isel , '.md-icon ~ ' + isel ] ) ; } , [ ] ) . join ( "," ) ; var RIGHT_SELECTORS = INPUT_TAGS . reduce ( function ( selectors , isel ) { return selectors . concat ( [ isel + ' ~ md-icon' , isel + ' ~ .md-icon' ] ) ; } , [ ] ) . join ( "," ) ; return { restrict : 'E' , compile : compile , controller : ContainerCtrl } ; function compile ( tElement ) { 
function MdNavBar ( $mdAria , $mdTheming ) { return { restrict : 'E' , transclude : true , controller : MdNavBarController , controllerAs : 'ctrl' , bindToController : true , scope : { 'mdSelectedNavItem' : '=?' , 'mdNoInkBar' : '=?' , 'navBarAriaLabel' : '@?' , } , template : '<div class="md-nav-bar">' + '<nav role="navigation">' + '<ul class="_md-nav-bar-list" ng-transclude role="listbox" ' + 'tabindex="0" ' + 'ng-focus="ctrl.onFocus()" ' + 'ng-keydown="ctrl.onKeydown($event)" ' + 'aria-label="{{ctrl.navBarAriaLabel}}">' + '</ul>' + '</nav>' + '<md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar>' + '</div>' , link : function ( scope , element , attrs , ctrl ) { $mdTheming ( element ) ; if ( ! ctrl . navBarAriaLabel ) { $mdAria . expectAsync ( element , 'aria-label' , angular . noop ) ; } } , } ; } 
function onRemove ( scope , element , opts ) { var animationRunner = null ; var destroyListener = scope . $on ( '$destroy' , function ( ) { * For normal closes (eg clicks), animate the removal. * For forced closes (like $destroy events from navigation), * skip the animations */ function animateRemoval ( ) { animationRunner = $animateCss ( element , { addClass : 'md-leave' } ) ; return animationRunner . start ( ) ; } function cleanElement ( ) { destroyListener ( ) ; element . removeClass ( 'md-active' ) . attr ( 'aria-hidden' , 'true' ) . css ( 'display' , 'none' ) ; element . parent ( ) . find ( 'md-select-value' ) . removeAttr ( 'aria-hidden' ) ; announceClosed ( opts ) ; if ( ! opts . $destroy && opts . restoreFocus ) { opts . target . focus ( ) ; } } } 
function positionAndFocusMenu ( ) { return $q ( function ( resolve ) { if ( opts . isRemoved ) return $q . reject ( false ) ; var info = calculateMenuPositions ( scope , element , opts ) ; info . container . element . css ( animator . toCss ( info . container . styles ) ) ; info . dropDown . element . css ( animator . toCss ( info . dropDown . styles ) ) ; $$rAF ( function ( ) { element . addClass ( 'md-active' ) ; info . dropDown . element . css ( animator . toCss ( { transform : '' } ) ) ; resolve ( ) ; } ) ; } ) ; } 
function sanitizeAndConfigure ( scope , options ) { var selectEl = element . find ( 'md-select-menu' ) ; if ( ! options . target ) { throw new Error ( $mdUtil . supplant ( ERROR_TARGET_EXPECTED , [ options . target ] ) ) ; } angular . extend ( options , { isRemoved : false , target : angular . element ( options . target ) , 
function updateIsOpen ( isOpen ) { 
function SidenavController ( $scope , $attrs , $mdComponentRegistry , $q , $interpolate ) { var self = this ; 
function compile ( tElement , tAttrs ) { var wrapper = angular . element ( tElement [ 0 ] . getElementsByClassName ( 'md-slider-wrapper' ) ) ; var tabIndex = tAttrs . tabindex || 0 ; wrapper . attr ( 'tabindex' , tabIndex ) ; if ( tAttrs . disabled || tAttrs . ngDisabled ) wrapper . attr ( 'tabindex' , - 1 ) ; tElement . attr ( 'role' , 'slider' ) ; $mdAria . expect ( tElement , 'aria-label' ) ; return postLink ; } 
function keydownListener ( ev ) { if ( isDisabled ( ) ) return ; var changeAmount ; if ( vertical ? ev . keyCode === $mdConstant . KEY_CODE . DOWN_ARROW : ev . keyCode === $mdConstant . KEY_CODE . LEFT_ARROW ) { changeAmount = - step ; } else if ( vertical ? ev . keyCode === $mdConstant . KEY_CODE . UP_ARROW : ev . keyCode === $mdConstant . KEY_CODE . RIGHT_ARROW ) { changeAmount = step ; } changeAmount = invert ? - changeAmount : changeAmount ; if ( changeAmount ) { if ( ev . metaKey || ev . ctrlKey || ev . altKey ) { changeAmount *= 4 ; } ev . preventDefault ( ) ; ev . stopPropagation ( ) ; scope . $evalAsync ( function ( ) { setModelValue ( ngModelCtrl . $viewValue + changeAmount ) ; } ) ; } } 
function refreshPosition ( item ) { 
function MdToastController ( $mdToast , $scope ) { 
function VirtualRepeatModelArrayLike ( model ) { if ( ! angular . isFunction ( model . getItemAtIndex ) || ! angular . isFunction ( model . getLength ) ) { throw Error ( 'When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement ' + 'functions getItemAtIndex() and getLength() ' ) ; } this . model = model ; } 
function init ( ) { $mdUtil . initOptionalProperties ( $scope , $attrs , { searchText : '' , selectedItem : null , clearButton : false } ) ; $mdTheming ( $element ) ; configureWatchers ( ) ; $mdUtil . nextTick ( function ( ) { gatherElements ( ) ; moveDropdown ( ) ; 
function positionDropdown ( ) { if ( ! elements ) { return $mdUtil . nextTick ( positionDropdown , false , $scope ) ; } var dropdownHeight = ( $scope . dropdownItems || MAX_ITEMS ) * ITEM_HEIGHT ; var hrect = elements . wrap . getBoundingClientRect ( ) , vrect = elements . snap . getBoundingClientRect ( ) , root = elements . root . getBoundingClientRect ( ) , top = vrect . bottom - root . top , bot = root . bottom - vrect . top , left = hrect . left - root . left , width = hrect . width , offset = getVerticalOffset ( ) , position = $scope . dropdownPosition , styles ; * Calculates the vertical offset for floating label examples to account for ngMessages * @returns {number} */ function getVerticalOffset ( ) { var offset = 0 ; var inputContainer = $element . find ( 'md-input-container' ) ; if ( inputContainer . length ) { var input = inputContainer . find ( 'input' ) ; offset = inputContainer . prop ( 'offsetHeight' ) ; offset -= input . prop ( 'offsetTop' ) ; offset -= input . prop ( 'offsetHeight' ) ; * Makes sure that the menu doesn't go off of the screen on either side. */ function correctHorizontalAlignment ( ) { var dropdown = elements . scrollContainer . getBoundingClientRect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU_PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px' ; } elements . $ . scrollContainer . css ( styles ) ; } } 
function correctHorizontalAlignment ( ) { var dropdown = elements . scrollContainer . getBoundingClientRect ( ) , styles = { } ; if ( dropdown . right > root . right - MENU_PADDING ) { styles . left = ( hrect . right - dropdown . width ) + 'px' ; } elements . $ . scrollContainer . css ( styles ) ; } 
function gatherElements ( ) { var snapWrap = gatherSnapWrap ( ) ; elements = { main : $element [ 0 ] , scrollContainer : $element [ 0 ] . querySelector ( '.md-virtual-repeat-container' ) , scroller : $element [ 0 ] . querySelector ( '.md-virtual-repeat-scroller' ) , ul : $element . find ( 'ul' ) [ 0 ] , input : $element . find ( 'input' ) [ 0 ] , wrap : snapWrap . wrap , snap : snapWrap . snap , root : document . body } ; elements . li = elements . ul . getElementsByTagName ( 'li' ) ; elements . $ = getAngularElements ( elements ) ; inputModelCtrl = elements . $ . input . controller ( 'ngModel' ) ; } 
function selectedItemChange ( selectedItem , previousSelectedItem ) { updateModelValidators ( ) ; if ( selectedItem ) { getDisplayValue ( selectedItem ) . then ( function ( val ) { $scope . searchText = val ; handleSelectedItemChange ( selectedItem , previousSelectedItem ) ; } ) ; } else if ( previousSelectedItem && $scope . searchText ) { getDisplayValue ( previousSelectedItem ) . then ( function ( displayValue ) { 
function handleSearchText ( searchText , previousSearchText ) { ctrl . index = getDefaultIndex ( ) ; 
function keydown ( event ) { switch ( event . keyCode ) { case $mdConstant . KEY_CODE . DOWN_ARROW : if ( ctrl . loading ) return ; event . stopPropagation ( ) ; event . preventDefault ( ) ; ctrl . index = Math . min ( ctrl . index + 1 , ctrl . matches . length - 1 ) ; updateScroll ( ) ; reportMessages ( false , ReportType . Selected ) ; break ; case $mdConstant . KEY_CODE . UP_ARROW : if ( ctrl . loading ) return ; event . stopPropagation ( ) ; event . preventDefault ( ) ; ctrl . index = ctrl . index < 0 ? ctrl . matches . length - 1 : Math . max ( 0 , ctrl . index - 1 ) ; updateScroll ( ) ; reportMessages ( false , ReportType . Selected ) ; break ; case $mdConstant . KEY_CODE . TAB : 
function getDisplayValue ( item ) { return $q . when ( getItemText ( item ) || item ) . then ( function ( itemText ) { if ( itemText && ! angular . isString ( itemText ) ) { $log . warn ( 'md-autocomplete: Could not resolve display value to a string. ' + 'Please check the `md-item-text` attribute.' ) ; } return itemText ; } ) ; function getItemText ( item ) { return ( item && $scope . itemText ) ? $scope . itemText ( getItemAsNameVal ( item ) ) : null ; } } 
function updateScroll ( ) { if ( ! elements . li [ 0 ] ) return ; var height = elements . li [ 0 ] . offsetHeight , top = height * ctrl . index , bot = top + height , hgt = elements . scroller . clientHeight , scrollTop = elements . scroller . scrollTop ; if ( top < scrollTop ) { scrollTo ( top ) ; } else if ( bot > scrollTop + hgt ) { scrollTo ( bot - hgt ) ; } } 
function selectItemOnMatch ( ) { var searchText = $scope . searchText , matches = ctrl . matches , item = matches [ 0 ] ; if ( matches . length === 1 ) getDisplayValue ( item ) . then ( function ( displayValue ) { var isMatching = searchText == displayValue ; if ( $scope . matchInsensitive && ! isMatching ) { isMatching = searchText . toLowerCase ( ) == displayValue . toLowerCase ( ) ; } if ( isMatching ) select ( 0 ) ; } ) ; } 
function MdChipsCtrl ( $scope , $attrs , $mdConstant , $log , $element , $timeout , $mdUtil , $exceptionHandler ) { this . $timeout = $timeout ; this . $mdConstant = $mdConstant ; this . $scope = $scope ; this . parent = $scope . $parent ; this . $mdUtil = $mdUtil ; this . $log = $log ; this . $exceptionHandler = $exceptionHandler ; this . $element = $element ; this . $attrs = $attrs ; this . ngModelCtrl = null ; this . userInputNgModelCtrl = null ; this . autocompleteCtrl = null ; this . userInputElement = null ; this . items = [ ] ; this . selectedChip = - 1 ; this . enableChipEdit = $mdUtil . parseAttributeBoolean ( $attrs . mdEnableChipEdit ) ; this . addOnBlur = $mdUtil . parseAttributeBoolean ( $attrs . mdAddOnBlur ) ; this . inputAriaLabel = 'Chips input.' ; this . containerHint = 'Chips container. Use arrow keys to select chips.' ; this . deleteHint = 'Press delete to remove this chip.' ; this . deleteButtonLabel = 'Remove' ; this . chipBuffer = '' ; this . useTransformChip = false ; this . useOnAdd = false ; this . useOnRemove = false ; this . wrapperId = '' ; this . contentIds = [ ] ; this . ariaTabIndex = null ; this . chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY ; this . deRegister = [ ] ; this . init ( ) ; } 
function setupTabsController ( ) { ctrl . selectedIndex = ctrl . selectedIndex || 0 ; compileTemplate ( ) ; configureWatchers ( ) ; bindEvents ( ) ; $mdTheming ( $element ) ; $mdUtil . nextTick ( function ( ) { 
function handleStretchTabs ( stretchTabs ) { var elements = getElements ( ) ; angular . element ( elements . wrapper ) . toggleClass ( 'md-stretch-tabs' , shouldStretchTabs ( ) ) ; updateInkBarStyles ( ) ; } 
function handleOffsetChange ( left ) { var elements = getElements ( ) ; var newValue = ( ( ctrl . shouldCenterTabs || isRtl ( ) ? '' : '-' ) + left + 'px' ) ; 
function scroll ( event ) { if ( ! ctrl . shouldPaginate ) return ; event . preventDefault ( ) ; ctrl . offsetLeft = fixOffset ( ctrl . offsetLeft - event . wheelDelta ) ; } 
function shouldPaginate ( ) { if ( ctrl . noPagination || ! loaded ) return false ; var canvasWidth = $element . prop ( 'clientWidth' ) ; angular . forEach ( getElements ( ) . tabs , function ( tab ) { canvasWidth -= tab . offsetWidth ; } ) ; return canvasWidth < 0 ; } 
function adjustOffset ( index ) { var elements = getElements ( ) ; if ( ! angular . isNumber ( index ) ) index = ctrl . focusIndex ; if ( ! elements . tabs [ index ] ) return ; if ( ctrl . shouldCenterTabs ) return ; var tab = elements . tabs [ index ] , left = tab . offsetLeft , right = tab . offsetWidth + left , extraOffset = 32 ; 
function updateInkBarStyles ( ) { var elements = getElements ( ) ; if ( ! elements . tabs [ ctrl . selectedIndex ] ) { angular . element ( elements . inkBar ) . css ( { left : 'auto' , right : 'auto' } ) ; return ; } if ( ! ctrl . tabs . length ) return queue . push ( ctrl . updateInkBarStyles ) ; 
function Barcode2D ( ) { this . width = 0 ; this . height = 0 ; this . background = '#FFF' ; this . modulecolor = '#000' ; this . type = 'PNG' ; this . leftoffset = 0 ; this . topoffset = 0 ; this . unitwidth = 0 ; this . unitheight = 0 ; } 
function Barcode1D ( ) { this . mode = MODE_BARWIDTH ; this . width = 0 ; this . height = 0 ; this . background = '#FFF' ; this . barcolor = '#000' ; this . type = 'PNG' ; this . offset = 0 ; this . modulewidth = 1 ; } 
function generateSequence ( seq , check ) { seq = seq . substr ( 0 , 12 ) + '' + check ; var first = seq . substr ( 0 , 1 ) , group1 = seq . substr ( 1 , 6 ) , group2 = seq . substr ( 7 ) ; var left = [ ] , right = [ ] , enc = ENCODE_GROUPS [ parseInt ( first ) ] , dInt ; for ( var i = 0 ; i < 6 ; i ++ ) { dInt = parseInt ( group1 [ i ] ) ; left = left . concat ( BARMAP [ enc [ i ] ] [ dInt ] ) ; } for ( var i = 0 ; i < 6 ; i ++ ) { dInt = parseInt ( group2 [ i ] ) right = right . concat ( BARMAP [ RIGHT ] [ dInt ] ) ; } return [ ] . concat ( START , left , MIDDLE , right , END ) ; } 
function fromUpcA ( upcastr ) { var upca = upcastr . split ( '' ) ; if ( upca . length == 12 ) { upca . pop ( ) ; } var first = upca . shift ( ) ; if ( upca . length != 10 || first != 1 && first != 0 ) { return '' ; } var upcamask = upca . join ( '' ) , match = null , upce = '' ; 
function generateSequence ( pattern , parity , check ) { if ( pattern . length !== 6 ) { return null ; } check = parseInt ( check ) ; parity = parseInt ( parity ) ; var p = PAIRITYMAP [ check ] [ parity ] , seq = START ; for ( var i = 0 ; i < 6 ; i ++ ) { seq = seq . concat ( BARMAP [ p [ i ] ] [ parseInt ( pattern [ i ] ) ] ) ; } return seq . concat ( END ) ; } 
function buildFrameTree ( frame ) { var tree = { name : frame . getParamValue ( "tabname" ) || "mira.frame (" + frame . id + ")" , children : [ ] } ; frame . getObjects ( ) . forEach ( function ( obj ) { tree . children . push ( { name : obj . type + "(" + obj . id + ")" } ) ; } ) ; return tree ; } 
function update ( ) { var stateTree = buildTreeJSON ( xebraState . getPatchers ( ) ) ; var nodes = d3 . hierarchy ( stateTree , function ( d ) { return d . children ; } ) ; d3Tree ( nodes ) ; var link = g . selectAll ( ".link" ) . data ( nodes . descendants ( ) . slice ( 1 ) ) . enter ( ) . append ( "path" ) . attr ( "class" , "link" ) . attr ( "d" , diagonal ) ; var node = g . selectAll ( ".node" ) . data ( nodes . descendants ( ) ) . enter ( ) . append ( "g" ) . attr ( "class" , function ( d ) { return "node" + ( d . children ? " node--internal" : " node--leaf" ) ; } ) . attr ( "transform" , function ( d ) { return "translate(" + d . y + "," + d . x + ")" ; } ) ; node . append ( "circle" ) . attr ( "r" , 2.5 ) ; node . append ( "text" ) . attr ( "dy" , function ( d ) { return d . children ? - 10 : 0 } ) . attr ( "x" , function ( d ) { return d . children ? - 8 : 8 ; } ) . style ( "text-anchor" , "start" ) . text ( function ( d ) { return d . data . name ; } ) ; } 
function toHebon ( s ) { var hebon = '' ; var lastHebon = '' ; var lastChar = '' ; var i = 0 ; while ( i < s . length ) { var hr = getHebon ( s , i ) ; if ( hr . c == 'っ') { 
function toKatakana ( s ) { var res = '' ; for ( var i = 0 ; i < s . length ; i += 1 ) { var cd = s . charCodeAt ( i ) ; res += ( minHira <= cd && cd <= maxHira ) ? String . fromCharCode ( cd - minHira + minKata ) : s . charAt ( i ) ; } return res ; } 
function toHiragana ( s ) { var res = '' ; for ( var i = 0 ; i < s . length ; i += 1 ) { var cd = s . charCodeAt ( i ) ; res += ( minKata <= cd && cd <= maxKata ) ? String . fromCharCode ( cd - minKata + minHira ) : s . charAt ( i ) ; } return res ; } 
function swal_alert ( message , customOptions ) { var options = angular . extend ( { title : 'Alert' , text : message , type : 'warning' , showCancelButton : false } , customOptions ) ; return $q . when ( swal ( options ) ) ; } 
function swal_open ( options ) { var resolve = angular . extend ( { } , options . resolve ) ; angular . forEach ( resolve , function ( value , key ) { resolve [ key ] = angular . isString ( value ) ? $injector . get ( value ) : $injector . invoke ( value , null , null , key ) ; } ) ; return $q . all ( { html : _getHtml ( options ) , locals : $q . all ( resolve ) } ) . then ( function ( setup ) { var scope = options . scope , controller = options . controller , controllerAsOption = options . controllerAs , preConfirm = options . preConfirm ; delete options . html ; delete options . htmlTemplate ; delete options . resolve ; delete options . scope ; delete options . controller ; delete options . controllerAs ; delete options . preConfirm ; var locals = setup . locals ; options . html = setup . html ; scope = scope ? scope . $new ( ) : $rootScope . $new ( ) ; if ( controller ) { var controllerAs ; if ( controllerAsOption && angular . isString ( controllerAsOption ) ) { controllerAs = controllerAsOption ; } var controllerInstance = $controller ( controller , angular . extend ( locals , { $scope : scope } ) , false , controllerAs ) ; if ( typeof preConfirm === 'string' ) { options . preConfirm = function ( ) { return $timeout ( controllerInstance [ preConfirm ] . bind ( controllerInstance ) ) ; } ; } } if ( typeof preConfirm === 'function' ) { options . preConfirm = function ( ) { return $timeout ( preConfirm ) ; } ; } var prom = $q . when ( swal ( options ) ) ; var html = document . getElementsByClassName ( 'swal2-modal' ) [ 0 ] ; 
function swal_base ( arg1 , arg2 , arg3 ) { 
function message ( msg , thisArg ) { var sig = colors . red ( thisArg . name ) ; sig += ' in plugin ' ; sig += '"' + colors . cyan ( thisArg . plugin ) + '"' ; sig += '\n' ; sig += msg ; return sig ; } 
function setDefaults ( plugin , message , opts ) { if ( typeof plugin === 'object' ) { return defaults ( plugin ) ; } opts = opts || { } ; if ( message instanceof Error ) { opts . error = message ; } else if ( typeof message === 'object' ) { opts = message ; } else { opts . message = message ; } opts . plugin = plugin ; return defaults ( opts ) ; } 
function toStr_ ( n , minLen ) { const str = n . toString ( 16 ) ; return str . length < 2 ? '0' + str : str ; } 
function Unshort ( options ) { if ( ! ( this instanceof Unshort ) ) return new Unshort ( options ) ; options = options || { } ; this . _options = merge . all ( [ { timeout : 30 * 1000 , retries : 1 , followRedirect : false , 
function splitSegments ( polygon ) { if ( typeof polygon !== "string" ) { throw new Error ( "Polygon should be a path string" ) ; } var start = null ; var position = null ; var result = [ ] ; var input = polygon ; function stripWhitespace ( ) { polygon = polygon . trim ( ) ; } function readCharSeq ( n ) { var c = polygon . charCodeAt ( n ) ; while ( c >= 48 && c <= 57 ) { n ++ ; c = polygon . charCodeAt ( n ) ; } return n ; } function readNumber ( ) { stripWhitespace ( ) ; var start = 0 ; var end = 0 ; if ( polygon [ start ] === "," ) { start ++ ; end ++ ; } if ( polygon [ start ] === "-" ) { end ++ ; } end = readCharSeq ( end ) ; if ( polygon [ end ] === "." ) { end ++ ; end = readCharSeq ( end ) ; } var s = polygon . substring ( start , end ) ; if ( s !== "" ) { var num = toFloat ( s ) ; polygon = polygon . substring ( end ) ; if ( polygon . length && polygon [ 0 ] . toLowerCase ( ) === "e" ) { var f = 1 ; var expEnd = 0 ; if ( polygon . length > 1 && polygon [ 1 ] === "-" ) { f = - 1 ; expEnd = readCharSeq ( 2 ) ; } else { expEnd = readCharSeq ( 1 ) ; } var exp = toFloat ( polygon . substring ( 1 , expEnd ) ) ; if ( mathAbs ( exp ) > 0 ) { num *= mathPow ( 10 , exp ) ; } polygon = polygon . substring ( expEnd ) ; } return num ; } else { throw new Error ( "Expected number: " + polygon ) ; } } function readNumbers ( n , fn ) { stripWhitespace ( ) ; var index = 0 ; var c = polygon . charCodeAt ( 0 ) ; while ( ( c >= 48 && c <= 57 ) || c === 44 || c === 45 ) { var numbers = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { numbers . push ( readNumber ( ) ) ; } fn ( numbers , index ) ; stripWhitespace ( ) ; c = polygon . charCodeAt ( 0 ) ; index ++ ; } } function readCoords ( n , fn ) { readNumbers ( n * 2 , function ( numbers , index ) { var coords = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { coords . push ( numbers . splice ( 0 , 2 ) ) ; } fn ( coords , index ) ; } ) ; } function pushType ( itemType , offset ) { return function ( c ) { if ( offset ) { c = c . map ( function ( c ) { return [ x ( c ) + x ( offset ) , y ( c ) + y ( offset ) ] ; } ) ; } c . unshift ( position ) ; result . push ( { type : itemType , coords : c , } ) ; position = c [ c . length - 1 ] ; } ; } function calculateCubicControlPoints ( coords ) { return [ coords [ 0 ] , [ x ( coords [ 0 ] ) + 2.0 / 3.0 * ( x ( coords [ 1 ] ) - x ( coords [ 0 ] ) ) , y ( coords [ 0 ] ) + 2.0 / 3.0 * ( y ( coords [ 1 ] ) - y ( coords [ 0 ] ) ) , ] , [ x ( coords [ 2 ] ) + 2.0 / 3.0 * ( x ( coords [ 1 ] ) - x ( coords [ 2 ] ) ) , y ( coords [ 2 ] ) + 2.0 / 3.0 * ( y ( coords [ 1 ] ) - y ( coords [ 2 ] ) ) , ] , coords [ 2 ] , ] ; } function calculateBezierControlPoint ( ) { var lastBezier = result [ result . length - 1 ] ; var controlPoint = null ; if ( ! lastBezier || lastBezier . type !== bezier3Type ) { controlPoint = position ; } else { 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _isPlaceholder = __webpack_require__ ( 36 ) ; function _curry2 ( fn ) { return function f2 ( a , b ) { switch ( arguments . length ) { case 0 : return f2 ; case 1 : return _isPlaceholder ( a ) ? f2 : _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) ; default : return _isPlaceholder ( a ) && _isPlaceholder ( b ) ? f2 : _isPlaceholder ( a ) ? _curry1 ( function ( _a ) { return fn ( _a , b ) ; } ) : _isPlaceholder ( b ) ? _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) : fn ( a , b ) ; } } ; } module . exports = _curry2 ; } 
function _curry2 ( fn ) { return function f2 ( a , b ) { switch ( arguments . length ) { case 0 : return f2 ; case 1 : return _isPlaceholder ( a ) ? f2 : _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) ; default : return _isPlaceholder ( a ) && _isPlaceholder ( b ) ? f2 : _isPlaceholder ( a ) ? _curry1 ( function ( _a ) { return fn ( _a , b ) ; } ) : _isPlaceholder ( b ) ? _curry1 ( function ( _b ) { return fn ( a , _b ) ; } ) : fn ( a , b ) ; } } ; } 
function ( module , exports , __webpack_require__ ) { var _isPlaceholder = __webpack_require__ ( 36 ) ; function _curry1 ( fn ) { return function f1 ( a ) { if ( arguments . length === 0 || _isPlaceholder ( a ) ) { return f1 ; } else { return fn . apply ( this , arguments ) ; } } ; } module . exports = _curry1 ; } 
function _curry1 ( fn ) { return function f1 ( a ) { if ( arguments . length === 0 || _isPlaceholder ( a ) ) { return f1 ; } else { return fn . apply ( this , arguments ) ; } } ; } 
function _dispatchable ( methodNames , xf , fn ) { return function ( ) { if ( arguments . length === 0 ) { return fn ( ) ; } var args = Array . prototype . slice . call ( arguments , 0 ) ; var obj = args . pop ( ) ; if ( ! _isArray ( obj ) ) { var idx = 0 ; while ( idx < methodNames . length ) { if ( typeof obj [ methodNames [ idx ] ] === 'function' ) { return obj [ methodNames [ idx ] ] . apply ( obj , args ) ; } idx += 1 ; } if ( _isTransformer ( obj ) ) { var transducer = xf . apply ( null , args ) ; return transducer ( obj ) ; } } return fn . apply ( this , arguments ) ; } ; } 
function ( module , exports ) { module . exports = { init : function ( ) { return this . xf [ '@@transducer/init' ] ( ) ; } , result : function ( result ) { return this . xf [ '@@transducer/result' ] ( result ) ; } } ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _curryN = __webpack_require__ ( 33 ) ; var curryN = _curry2 ( function curryN ( length , fn ) { if ( length === 1 ) { return _curry1 ( fn ) ; } return _arity ( length , _curryN ( length , [ ] , fn ) ) ; } ) ; module . exports = curryN ; } 
function ( module , exports ) { function _has ( prop , obj ) { return Object . prototype . hasOwnProperty . call ( obj , prop ) ; } module . exports = _has ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _map = __webpack_require__ ( 37 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _xmap = __webpack_require__ ( 344 ) ; var curryN = __webpack_require__ ( 7 ) ; var keys = __webpack_require__ ( 15 ) ; var map = _curry2 ( _dispatchable ( [ 'fantasy-land/map' , 'map' ] , _xmap , function map ( fn , functor ) { switch ( Object . prototype . toString . call ( functor ) ) { case '[object Function]' : return curryN ( functor . length , function ( ) { return fn . call ( this , functor . apply ( this , arguments ) ) ; } ) ; case '[object Object]' : return _reduce ( function ( acc , key ) { acc [ key ] = fn ( functor [ key ] ) ; return acc ; } , { } , keys ( functor ) ) ; default : return _map ( fn , functor ) ; } } ) ) ; module . exports = map ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _equals = __webpack_require__ ( 319 ) ; var equals = _curry2 ( function equals ( a , b ) { return _equals ( a , b , [ ] , [ ] ) ; } ) ; module . exports = equals ; } 
function ( module , exports ) { function _concat ( set1 , set2 ) { set1 = set1 || [ ] ; set2 = set2 || [ ] ; var idx ; var len1 = set1 . length ; var len2 = set2 . length ; var result = [ ] ; idx = 0 ; while ( idx < len1 ) { result [ result . length ] = set1 [ idx ] ; idx += 1 ; } idx = 0 ; while ( idx < len2 ) { result [ result . length ] = set2 [ idx ] ; idx += 1 ; } return result ; } module . exports = _concat ; } 
function ( module , exports , __webpack_require__ ) { var _checkForMethod = __webpack_require__ ( 23 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var slice = _curry3 ( _checkForMethod ( 'slice' , function slice ( fromIndex , toIndex , list ) { return Array . prototype . slice . call ( list , fromIndex , toIndex ) ; } ) ) ; module . exports = slice ; } 
function ( module , exports ) { function _arity ( n , fn ) { switch ( n ) { case 0 : return function ( ) { return fn . apply ( this , arguments ) ; } ; case 1 : return function ( a0 ) { return fn . apply ( this , arguments ) ; } ; case 2 : return function ( a0 , a1 ) { return fn . apply ( this , arguments ) ; } ; case 3 : return function ( a0 , a1 , a2 ) { return fn . apply ( this , arguments ) ; } ; case 4 : return function ( a0 , a1 , a2 , a3 ) { return fn . apply ( this , arguments ) ; } ; case 5 : return function ( a0 , a1 , a2 , a3 , a4 ) { return fn . apply ( this , arguments ) ; } ; case 6 : return function ( a0 , a1 , a2 , a3 , a4 , a5 ) { return fn . apply ( this , arguments ) ; } ; case 7 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 ) { return fn . apply ( this , arguments ) ; } ; case 8 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ) { return fn . apply ( this , arguments ) ; } ; case 9 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 ) { return fn . apply ( this , arguments ) ; } ; case 10 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ) { return fn . apply ( this , arguments ) ; } ; default : throw new Error ( 'First argument to _arity must be a non-negative integer no greater than ten' ) ; } } module . exports = _arity ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _has = __webpack_require__ ( 8 ) ; var _isArguments = __webpack_require__ ( 208 ) ; * Returns a list containing the names of all the enumerable own properties of * the supplied object. * Note that the order of the output array is not guaranteed to be consistent * across different JS platforms. * * @func * @memberOf R * @since v0.1.0 * @category Object * @sig {k: v} -> [k] * @param {Object} obj The object to extract properties from * @return {Array} An array of the object's own properties. * @see R.keysIn, R.values * @example * * R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c'] */ var _keys = typeof Object . keys === 'function' && ! hasArgsEnumBug ? function keys ( obj ) { return Object ( obj ) !== obj ? [ ] : Object . keys ( obj ) ; } : function keys ( obj ) { if ( Object ( obj ) !== obj ) { return [ ] ; } var prop , nIdx ; var ks = [ ] ; var checkArgsLength = hasArgsEnumBug && _isArguments ( obj ) ; for ( prop in obj ) { if ( _has ( prop , obj ) && ( ! checkArgsLength || prop !== 'length' ) ) { ks [ ks . length ] = prop ; } } if ( hasEnumBug ) { nIdx = nonEnumerableProps . length - 1 ; while ( nIdx >= 0 ) { prop = nonEnumerableProps [ nIdx ] ; if ( _has ( prop , obj ) && ! contains ( ks , prop ) ) { ks [ ks . length ] = prop ; } nIdx -= 1 ; } } return ks ; } ; var keys = _curry1 ( _keys ) ; module . exports = keys ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var _reduce = __webpack_require__ ( 11 ) ; var reduce = _curry3 ( _reduce ) ; module . exports = reduce ; } 
function ( module , exports ) { module . exports = Array . isArray || function _isArray ( val ) { return val != null && val . length >= 0 && Object . prototype . toString . call ( val ) === '[object Array]' ; } ; } 
function ( module , exports ) { function _reduced ( x ) { return x && x [ '@@transducer/reduced' ] ? x : { '@@transducer/value' : x , '@@transducer/reduced' : true } ; } module . exports = _reduced ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var always = _curry1 ( function always ( val ) { return function ( ) { return val ; } ; } ) ; module . exports = always ; } 
function ( module , exports , __webpack_require__ ) { var _indexOf = __webpack_require__ ( 207 ) ; function _contains ( a , list ) { return _indexOf ( list , a , 0 ) >= 0 ; } module . exports = _contains ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var max = _curry2 ( function max ( a , b ) { return b > a ? b : a ; } ) ; module . exports = max ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var path = _curry2 ( function path ( paths , obj ) { var val = obj ; var idx = 0 ; while ( idx < paths . length ) { if ( val == null ) { return ; } val = val [ paths [ idx ] ] ; idx += 1 ; } return val ; } ) ; module . exports = path ; } 
function ( module , exports , __webpack_require__ ) { var _isArray = __webpack_require__ ( 17 ) ; function _checkForMethod ( methodname , fn ) { return function ( ) { var length = arguments . length ; if ( length === 0 ) { return fn ( ) ; } var obj = arguments [ length - 1 ] ; return _isArray ( obj ) || typeof obj [ methodname ] !== 'function' ? fn . apply ( this , arguments ) : obj [ methodname ] . apply ( obj , Array . prototype . slice . call ( arguments , 0 , length - 1 ) ) ; } ; } module . exports = _checkForMethod ; } 
function ( module , exports ) { function _isString ( x ) { return Object . prototype . toString . call ( x ) === '[object String]' ; } module . exports = _isString ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isFunction = __webpack_require__ ( 35 ) ; var curryN = __webpack_require__ ( 7 ) ; var toString = __webpack_require__ ( 28 ) ; var invoker = _curry2 ( function invoker ( arity , method ) { return curryN ( arity + 1 , function ( ) { var target = arguments [ arity ] ; if ( target != null && _isFunction ( target [ method ] ) ) { return target [ method ] . apply ( target , Array . prototype . slice . call ( arguments , 0 , arity ) ) ; } throw new TypeError ( toString ( target ) + ' does not have a method named "' + method + '"' ) ; } ) ; } ) ; module . exports = invoker ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isString = __webpack_require__ ( 24 ) ; var nth = _curry2 ( function nth ( offset , list ) { var idx = offset < 0 ? list . length + offset : offset ; return _isString ( list ) ? list . charAt ( idx ) : list [ idx ] ; } ) ; module . exports = nth ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var map = __webpack_require__ ( 9 ) ; var prop = __webpack_require__ ( 60 ) ; var pluck = _curry2 ( function pluck ( p , list ) { return map ( prop ( p ) , list ) ; } ) ; module . exports = pluck ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _toString = __webpack_require__ ( 331 ) ; var toString = _curry1 ( function toString ( val ) { return _toString ( val , [ ] ) ; } ) ; module . exports = toString ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var add = _curry2 ( function add ( a , b ) { return Number ( a ) + Number ( b ) ; } ) ; module . exports = add ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var assoc = _curry3 ( function assoc ( prop , val , obj ) { var result = { } ; for ( var p in obj ) { result [ p ] = obj [ p ] ; } result [ prop ] = val ; return result ; } ) ; module . exports = assoc ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var curryN = __webpack_require__ ( 7 ) ; var flip = _curry1 ( function flip ( fn ) { return curryN ( fn . length , function ( a , b ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; args [ 0 ] = b ; args [ 1 ] = a ; return fn . apply ( this , args ) ; } ) ; } ) ; module . exports = flip ; } 
function ( module , exports ) { function _containsWith ( pred , x , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( pred ( x , list [ idx ] ) ) { return true ; } idx += 1 ; } return false ; } module . exports = _containsWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _isArray = __webpack_require__ ( 17 ) ; var _isString = __webpack_require__ ( 24 ) ; var _isArrayLike = _curry1 ( function isArrayLike ( x ) { if ( _isArray ( x ) ) { return true ; } if ( ! x ) { return false ; } if ( typeof x !== 'object' ) { return false ; } if ( _isString ( x ) ) { return false ; } if ( x . nodeType === 1 ) { return ! ! x . length ; } if ( x . length === 0 ) { return true ; } if ( x . length > 0 ) { return x . hasOwnProperty ( 0 ) && x . hasOwnProperty ( x . length - 1 ) ; } return false ; } ) ; module . exports = _isArrayLike ; } 
function ( module , exports ) { function _isFunction ( x ) { return Object . prototype . toString . call ( x ) === '[object Function]' ; } module . exports = _isFunction ; } 
function ( module , exports ) { function _isPlaceholder ( a ) { return a != null && typeof a === 'object' && a [ '@@functional/placeholder' ] === true ; } module . exports = _isPlaceholder ; } 
function ( module , exports ) { function _map ( fn , functor ) { var idx = 0 ; var len = functor . length ; var result = Array ( len ) ; while ( idx < len ) { result [ idx ] = fn ( functor [ idx ] ) ; idx += 1 ; } return result ; } module . exports = _map ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var map = __webpack_require__ ( 9 ) ; var lens = _curry2 ( function lens ( getter , setter ) { return function ( toFunctorFn ) { return function ( target ) { return map ( function ( focus ) { return setter ( focus , target ) ; } , toFunctorFn ( getter ( target ) ) ) ; } ; } ; } ) ; module . exports = lens ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var liftN = __webpack_require__ ( 219 ) ; var lift = _curry1 ( function lift ( fn ) { return liftN ( fn . length , fn ) ; } ) ; module . exports = lift ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var _isObject = __webpack_require__ ( 57 ) ; var mergeWithKey = __webpack_require__ ( 59 ) ; var mergeDeepWithKey = _curry3 ( function mergeDeepWithKey ( fn , lObj , rObj ) { return mergeWithKey ( function ( k , lVal , rVal ) { if ( _isObject ( lVal ) && _isObject ( rVal ) ) { return mergeDeepWithKey ( fn , lVal , rVal ) ; } else { return fn ( k , lVal , rVal ) ; } } , lObj , rObj ) ; } ) ; module . exports = mergeDeepWithKey ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var nAry = _curry2 ( function nAry ( n , fn ) { switch ( n ) { case 0 : return function ( ) { return fn . call ( this ) ; } ; case 1 : return function ( a0 ) { return fn . call ( this , a0 ) ; } ; case 2 : return function ( a0 , a1 ) { return fn . call ( this , a0 , a1 ) ; } ; case 3 : return function ( a0 , a1 , a2 ) { return fn . call ( this , a0 , a1 , a2 ) ; } ; case 4 : return function ( a0 , a1 , a2 , a3 ) { return fn . call ( this , a0 , a1 , a2 , a3 ) ; } ; case 5 : return function ( a0 , a1 , a2 , a3 , a4 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 ) ; } ; case 6 : return function ( a0 , a1 , a2 , a3 , a4 , a5 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 , a5 ) ; } ; case 7 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 , a5 , a6 ) ; } ; case 8 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ) ; } ; case 9 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 ) ; } ; case 10 : return function ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ) { return fn . call ( this , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ) ; } ; default : throw new Error ( 'First argument to nAry must be a non-negative integer no greater than ten' ) ; } } ) ; module . exports = nAry ; } 
function ( module , exports , __webpack_require__ ) { var _curryN = __webpack_require__ ( 33 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _has = __webpack_require__ ( 8 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _xreduceBy = __webpack_require__ ( 345 ) ; var reduceBy = _curryN ( 4 , [ ] , _dispatchable ( [ ] , _xreduceBy , function reduceBy ( valueFn , valueAcc , keyFn , list ) { return _reduce ( function ( acc , elt ) { var key = keyFn ( elt ) ; acc [ key ] = valueFn ( _has ( key , acc ) ? acc [ key ] : valueAcc , elt ) ; return acc ; } , { } , list ) ; } ) ) ; module . exports = reduceBy ; } 
function ( module , exports , __webpack_require__ ) { var _complement = __webpack_require__ ( 205 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var filter = __webpack_require__ ( 51 ) ; var reject = _curry2 ( function reject ( pred , filterable ) { return filter ( _complement ( pred ) , filterable ) ; } ) ; module . exports = reject ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _isString = __webpack_require__ ( 24 ) ; var reverse = _curry1 ( function reverse ( list ) { return _isString ( list ) ? list . split ( '' ) . reverse ( ) . join ( '' ) : Array . prototype . slice . call ( list , 0 ) . reverse ( ) ; } ) ; module . exports = reverse ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _reduce = __webpack_require__ ( 11 ) ; var map = __webpack_require__ ( 9 ) ; var ap = _curry2 ( function ap ( applyF , applyX ) { return typeof applyX [ 'fantasy-land/ap' ] === 'function' ? applyX [ 'fantasy-land/ap' ] ( applyF ) : typeof applyF . ap === 'function' ? applyF . ap ( applyX ) : typeof applyF === 'function' ? function ( x ) { return applyF ( x ) ( applyX ( x ) ) ; } : 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _makeFlat = __webpack_require__ ( 210 ) ; var _xchain = __webpack_require__ ( 334 ) ; var map = __webpack_require__ ( 9 ) ; var chain = _curry2 ( _dispatchable ( [ 'fantasy-land/chain' , 'chain' ] , _xchain , function chain ( fn , monad ) { if ( typeof monad === 'function' ) { return function ( x ) { return fn ( monad ( x ) ) ( x ) ; } ; } return _makeFlat ( false ) ( map ( fn , monad ) ) ; } ) ) ; module . exports = chain ; } 
function ( module , exports , __webpack_require__ ) { var pipe = __webpack_require__ ( 228 ) ; var reverse = __webpack_require__ ( 44 ) ; function compose ( ) { if ( arguments . length === 0 ) { throw new Error ( 'compose requires at least one argument' ) ; } return pipe . apply ( this , reverse ( arguments ) ) ; } module . exports = compose ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isArray = __webpack_require__ ( 17 ) ; var _isFunction = __webpack_require__ ( 35 ) ; var _isString = __webpack_require__ ( 24 ) ; var toString = __webpack_require__ ( 28 ) ; var concat = _curry2 ( function concat ( a , b ) { if ( _isArray ( a ) ) { if ( _isArray ( b ) ) { return a . concat ( b ) ; } throw new TypeError ( toString ( b ) + ' is not an array' ) ; } if ( _isString ( a ) ) { if ( _isString ( b ) ) { return a + b ; } throw new TypeError ( toString ( b ) + ' is not a string' ) ; } if ( a != null && _isFunction ( a [ 'fantasy-land/concat' ] ) ) { return a [ 'fantasy-land/concat' ] ( b ) ; } if ( a != null && _isFunction ( a . concat ) ) { return a . concat ( b ) ; } throw new TypeError ( toString ( a ) + ' does not have a method named "concat" or "fantasy-land/concat"' ) ; } ) ; module . exports = concat ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var curryN = __webpack_require__ ( 7 ) ; var curry = _curry1 ( function curry ( fn ) { return curryN ( fn . length , fn ) ; } ) ; module . exports = curry ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _filter = __webpack_require__ ( 54 ) ; var _isObject = __webpack_require__ ( 57 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _xfilter = __webpack_require__ ( 339 ) ; var keys = __webpack_require__ ( 15 ) ; var filter = _curry2 ( _dispatchable ( [ 'filter' ] , _xfilter , function ( pred , filterable ) { return _isObject ( filterable ) ? _reduce ( function ( acc , key ) { if ( pred ( filterable [ key ] ) ) { acc [ key ] = filterable [ key ] ; } return acc ; } , { } , keys ( filterable ) ) : 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _identity = __webpack_require__ ( 55 ) ; var identity = _curry1 ( _identity ) ; module . exports = identity ; } 
function ( module , exports , __webpack_require__ ) { var _objectAssign = __webpack_require__ ( 324 ) ; module . exports = typeof Object . assign === 'function' ? Object . assign : _objectAssign ; } 
function ( module , exports ) { function _filter ( fn , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { result [ result . length ] = list [ idx ] ; } idx += 1 ; } return result ; } module . exports = _filter ; } 
function ( module , exports ) { module . exports = Number . isInteger || function _isInteger ( n ) { return n << 0 === n ; } ; } 
function ( module , exports ) { function _isObject ( x ) { return Object . prototype . toString . call ( x ) === '[object Object]' ; } module . exports = _isObject ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var _has = __webpack_require__ ( 8 ) ; var mergeWithKey = _curry3 ( function mergeWithKey ( fn , l , r ) { var result = { } ; var k ; for ( k in l ) { if ( _has ( k , l ) ) { result [ k ] = _has ( k , r ) ? fn ( k , l [ k ] , r [ k ] ) : l [ k ] ; } } for ( k in r ) { if ( _has ( k , r ) && ! _has ( k , result ) ) { result [ k ] = r [ k ] ; } } return result ; } ) ; module . exports = mergeWithKey ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var path = __webpack_require__ ( 22 ) ; var prop = _curry2 ( function prop ( p , obj ) { return path ( [ p ] , obj ) ; } ) ; module . exports = prop ; } 
function ( module , exports , __webpack_require__ ) { var _checkForMethod = __webpack_require__ ( 23 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var slice = __webpack_require__ ( 13 ) ; var tail = _curry1 ( _checkForMethod ( 'tail' , slice ( 1 , Infinity ) ) ) ; module . exports = tail ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xtake = __webpack_require__ ( 346 ) ; var slice = __webpack_require__ ( 13 ) ; var take = _curry2 ( _dispatchable ( [ 'take' ] , _xtake , function take ( n , xs ) { return slice ( 0 , n < 0 ? Infinity : n , xs ) ; } ) ) ; module . exports = take ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var type = _curry1 ( function type ( val ) { return val === null ? 'Null' : val === undefined ? 'Undefined' : Object . prototype . toString . call ( val ) . slice ( 8 , - 1 ) ; } ) ; module . exports = type ; } 
function ( module , exports , __webpack_require__ ) { var identity = __webpack_require__ ( 52 ) ; var uniqBy = __webpack_require__ ( 237 ) ; var uniq = uniqBy ( identity ) ; module . exports = uniq ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var adjust = __webpack_require__ ( 186 ) ; var always = __webpack_require__ ( 19 ) ; var update = _curry3 ( function update ( idx , x , list ) { return adjust ( always ( x ) , idx , list ) ; } ) ; module . exports = update ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var emptyObject = { } ; if ( false ) { Object . freeze ( emptyObject ) ; } module . exports = emptyObject ; } 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { * @param withoutSuffix boolean true = a length of time; false = before/after a period of time. */ function format ( forms , number , withoutSuffix ) { if ( withoutSuffix ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var adjust = _curry3 ( function adjust ( fn , idx , list ) { if ( idx >= list . length || idx < - list . length ) { return list ; } var start = idx < 0 ? list . length : 0 ; var _idx = start + idx ; var _list = _concat ( list ) ; _list [ _idx ] = fn ( list [ _idx ] ) ; return _list ; } ) ; module . exports = adjust ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var and = _curry2 ( function and ( a , b ) { return a && b ; } ) ; module . exports = and ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xany = __webpack_require__ ( 211 ) ; var any = _curry2 ( _dispatchable ( [ 'any' ] , _xany , function any ( fn , list ) { var idx = 0 ; while ( idx < list . length ) { if ( fn ( list [ idx ] ) ) { return true ; } idx += 1 ; } return false ; } ) ) ; module . exports = any ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var apply = _curry2 ( function apply ( fn , args ) { return fn . apply ( this , args ) ; } ) ; module . exports = apply ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var _has = __webpack_require__ ( 8 ) ; var _isArray = __webpack_require__ ( 17 ) ; var _isInteger = __webpack_require__ ( 56 ) ; var assoc = __webpack_require__ ( 30 ) ; var isNil = __webpack_require__ ( 215 ) ; var assocPath = _curry3 ( function assocPath ( path , val , obj ) { if ( path . length === 0 ) { return val ; } var idx = path [ 0 ] ; if ( path . length > 1 ) { var nextObj = ! isNil ( obj ) && _has ( idx , obj ) ? obj [ idx ] : _isInteger ( path [ 1 ] ) ? [ ] : { } ; val = assocPath ( Array . prototype . slice . call ( path , 1 ) , val , nextObj ) ; } if ( _isInteger ( idx ) && _isArray ( obj ) ) { var arr = [ ] . concat ( obj ) ; arr [ idx ] = val ; return arr ; } else { return assoc ( idx , val , obj ) ; } } ) ; module . exports = assocPath ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var bind = _curry2 ( function bind ( fn , thisObj ) { return _arity ( fn . length , function ( ) { return fn . apply ( thisObj , arguments ) ; } ) ; } ) ; module . exports = bind ; } 
function ( module , exports , __webpack_require__ ) { var chain = __webpack_require__ ( 47 ) ; var compose = __webpack_require__ ( 48 ) ; var map = __webpack_require__ ( 9 ) ; function composeK ( ) { if ( arguments . length === 0 ) { throw new Error ( 'composeK requires at least one argument' ) ; } var init = Array . prototype . slice . call ( arguments ) ; var last = init . pop ( ) ; return compose ( compose . apply ( this , map ( chain , init ) ) , last ) ; } module . exports = composeK ; } 
function composeK ( ) { if ( arguments . length === 0 ) { throw new Error ( 'composeK requires at least one argument' ) ; } var init = Array . prototype . slice . call ( arguments ) ; var last = init . pop ( ) ; return compose ( compose . apply ( this , map ( chain , init ) ) , last ) ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var curry = __webpack_require__ ( 50 ) ; var nAry = __webpack_require__ ( 41 ) ; var constructN = _curry2 ( function constructN ( n , Fn ) { if ( n > 10 ) { throw new Error ( 'Constructor with greater than ten arguments' ) ; } if ( n === 0 ) { return function ( ) { return new Fn ( ) ; } ; } return curry ( nAry ( n , function ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 , $9 ) { switch ( arguments . length ) { case 1 : return new Fn ( $0 ) ; case 2 : return new Fn ( $0 , $1 ) ; case 3 : return new Fn ( $0 , $1 , $2 ) ; case 4 : return new Fn ( $0 , $1 , $2 , $3 ) ; case 5 : return new Fn ( $0 , $1 , $2 , $3 , $4 ) ; case 6 : return new Fn ( $0 , $1 , $2 , $3 , $4 , $5 ) ; case 7 : return new Fn ( $0 , $1 , $2 , $3 , $4 , $5 , $6 ) ; case 8 : return new Fn ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 ) ; case 9 : return new Fn ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 ) ; case 10 : return new Fn ( $0 , $1 , $2 , $3 , $4 , $5 , $6 , $7 , $8 , $9 ) ; } } ) ) ; } ) ; module . exports = constructN ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _map = __webpack_require__ ( 37 ) ; var curryN = __webpack_require__ ( 7 ) ; var max = __webpack_require__ ( 21 ) ; var pluck = __webpack_require__ ( 27 ) ; var reduce = __webpack_require__ ( 16 ) ; var converge = _curry2 ( function converge ( after , fns ) { return curryN ( reduce ( max , 0 , pluck ( 'length' , fns ) ) , function ( ) { var args = arguments ; var context = this ; return after . apply ( context , _map ( function ( fn ) { return fn . apply ( context , args ) ; } , fns ) ) ; } ) ; } ) ; module . exports = converge ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var defaultTo = _curry2 ( function defaultTo ( d , v ) { return v == null || v !== v ? d : v ; } ) ; module . exports = defaultTo ; } 
function ( module , exports , __webpack_require__ ) { var _contains = __webpack_require__ ( 20 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var difference = _curry2 ( function difference ( first , second ) { var out = [ ] ; var idx = 0 ; var firstLen = first . length ; while ( idx < firstLen ) { if ( ! _contains ( first [ idx ] , second ) && ! _contains ( first [ idx ] , out ) ) { out [ out . length ] = first [ idx ] ; } idx += 1 ; } return out ; } ) ; module . exports = difference ; } 
function ( module , exports , __webpack_require__ ) { var _containsWith = __webpack_require__ ( 32 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var differenceWith = _curry3 ( function differenceWith ( pred , first , second ) { var out = [ ] ; var idx = 0 ; var firstLen = first . length ; while ( idx < firstLen ) { if ( ! _containsWith ( pred , first [ idx ] , second ) && ! _containsWith ( pred , first [ idx ] , out ) ) { out . push ( first [ idx ] ) ; } idx += 1 ; } return out ; } ) ; module . exports = differenceWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var dissoc = _curry2 ( function dissoc ( prop , obj ) { var result = { } ; for ( var p in obj ) { result [ p ] = obj [ p ] ; } delete result [ prop ] ; return result ; } ) ; module . exports = dissoc ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xdrop = __webpack_require__ ( 335 ) ; var slice = __webpack_require__ ( 13 ) ; var drop = _curry2 ( _dispatchable ( [ 'drop' ] , _xdrop , function drop ( n , xs ) { return slice ( Math . max ( 0 , n ) , Infinity , xs ) ; } ) ) ; module . exports = drop ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xdropRepeatsWith = __webpack_require__ ( 212 ) ; var last = __webpack_require__ ( 217 ) ; var dropRepeatsWith = _curry2 ( _dispatchable ( [ ] , _xdropRepeatsWith , function dropRepeatsWith ( pred , list ) { var result = [ ] ; var idx = 1 ; var len = list . length ; if ( len !== 0 ) { result [ 0 ] = list [ 0 ] ; while ( idx < len ) { if ( ! pred ( last ( result ) , list [ idx ] ) ) { result [ result . length ] = list [ idx ] ; } idx += 1 ; } } return result ; } ) ) ; module . exports = dropRepeatsWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _isArguments = __webpack_require__ ( 208 ) ; var _isArray = __webpack_require__ ( 17 ) ; var _isObject = __webpack_require__ ( 57 ) ; var _isString = __webpack_require__ ( 24 ) ; var empty = _curry1 ( function empty ( x ) { return x != null && typeof x [ 'fantasy-land/empty' ] === 'function' ? x [ 'fantasy-land/empty' ] ( ) : x != null && x . constructor != null && typeof x . constructor [ 'fantasy-land/empty' ] === 'function' ? x . constructor [ 'fantasy-land/empty' ] ( ) : x != null && typeof x . empty === 'function' ? x . empty ( ) : x != null && x . constructor != null && typeof x . constructor . empty === 'function' ? x . constructor . empty ( ) : _isArray ( x ) ? [ ] : _isString ( x ) ? '' : _isObject ( x ) ? { } : _isArguments ( x ) ? function ( ) { return arguments ; } ( ) : 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var identical = _curry2 ( function identical ( a , b ) { 
function _clone ( value , refFrom , refTo , deep ) { var copy = function copy ( copiedValue ) { var len = refFrom . length ; var idx = 0 ; while ( idx < len ) { if ( value === refFrom [ idx ] ) { return refTo [ idx ] ; } idx += 1 ; } refFrom [ idx + 1 ] = value ; refTo [ idx + 1 ] = copiedValue ; for ( var key in value ) { copiedValue [ key ] = deep ? _clone ( value [ key ] , refFrom , refTo , true ) : value [ key ] ; } return copiedValue ; } ; switch ( type ( value ) ) { case 'Object' : return copy ( { } ) ; case 'Array' : return copy ( [ ] ) ; case 'Date' : return new Date ( value . valueOf ( ) ) ; case 'RegExp' : return _cloneRegExp ( value ) ; default : return value ; } } 
function ( module , exports ) { function _cloneRegExp ( pattern ) { return new RegExp ( pattern . source , ( pattern . global ? 'g' : '' ) + ( pattern . ignoreCase ? 'i' : '' ) + ( pattern . multiline ? 'm' : '' ) + ( pattern . sticky ? 'y' : '' ) + ( pattern . unicode ? 'u' : '' ) ) ; } module . exports = _cloneRegExp ; } 
function ( module , exports ) { function _complement ( f ) { return function ( ) { return ! f . apply ( this , arguments ) ; } ; } module . exports = _complement ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry2 = __webpack_require__ ( 1 ) ; function _createPartialApplicator ( concat ) { return _curry2 ( function ( fn , args ) { return _arity ( Math . max ( 0 , fn . length - args . length ) , function ( ) { return fn . apply ( this , concat ( args , arguments ) ) ; } ) ; } ) ; } module . exports = _createPartialApplicator ; } 
function ( module , exports , __webpack_require__ ) { var equals = __webpack_require__ ( 10 ) ; function _indexOf ( list , a , idx ) { var inf , item ; 
function ( module , exports , __webpack_require__ ) { var _has = __webpack_require__ ( 8 ) ; var toString = Object . prototype . toString ; var _isArguments = function ( ) { return toString . call ( arguments ) === '[object Arguments]' ? function _isArguments ( x ) { return toString . call ( x ) === '[object Arguments]' ; } : function _isArguments ( x ) { return _has ( 'callee' , x ) ; } ; } ; module . exports = _isArguments ; } 
function ( module , exports ) { function _isNumber ( x ) { return Object . prototype . toString . call ( x ) === '[object Number]' ; } module . exports = _isNumber ; } 
function ( module , exports , __webpack_require__ ) { var _isArrayLike = __webpack_require__ ( 34 ) ; function _makeFlat ( recursive ) { return function flatt ( list ) { var value , jlen , j ; var result = [ ] ; var idx = 0 ; var ilen = list . length ; while ( idx < ilen ) { if ( _isArrayLike ( list [ idx ] ) ) { value = recursive ? flatt ( list [ idx ] ) : list [ idx ] ; j = 0 ; jlen = value . length ; while ( j < jlen ) { result [ result . length ] = value [ j ] ; j += 1 ; } } else { result [ result . length ] = list [ idx ] ; } idx += 1 ; } return result ; } ; } module . exports = _makeFlat ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XAny = function ( ) { function XAny ( f , xf ) { this . xf = xf ; this . f = f ; this . any = false ; } XAny . prototype [ '@@transducer/init' ] = _xfBase . init ; XAny . prototype [ '@@transducer/result' ] = function ( result ) { if ( ! this . any ) { result = this . xf [ '@@transducer/step' ] ( result , false ) ; } return this . xf [ '@@transducer/result' ] ( result ) ; } ; XAny . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . f ( input ) ) { this . any = true ; result = _reduced ( this . xf [ '@@transducer/step' ] ( result , true ) ) ; } return result ; } ; return XAny ; } ( ) ; var _xany = _curry2 ( function _xany ( f , xf ) { return new XAny ( f , xf ) ; } ) ; module . exports = _xany ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XDropRepeatsWith = function ( ) { function XDropRepeatsWith ( pred , xf ) { this . xf = xf ; this . pred = pred ; this . lastValue = undefined ; this . seenFirstValue = false ; } XDropRepeatsWith . prototype [ '@@transducer/init' ] = _xfBase . init ; XDropRepeatsWith . prototype [ '@@transducer/result' ] = _xfBase . result ; XDropRepeatsWith . prototype [ '@@transducer/step' ] = function ( result , input ) { var sameAsLast = false ; if ( ! this . seenFirstValue ) { this . seenFirstValue = true ; } else if ( this . pred ( this . lastValue , input ) ) { sameAsLast = true ; } this . lastValue = input ; return sameAsLast ? result : this . xf [ '@@transducer/step' ] ( result , input ) ; } ; return XDropRepeatsWith ; } ( ) ; var _xdropRepeatsWith = _curry2 ( function _xdropRepeatsWith ( pred , xf ) { return new XDropRepeatsWith ( pred , xf ) ; } ) ; module . exports = _xdropRepeatsWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var is = _curry2 ( function is ( Ctor , val ) { return val != null && val . constructor === Ctor || val instanceof Ctor ; } ) ; module . exports = is ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var isNil = _curry1 ( function isNil ( x ) { return x == null ; } ) ; module . exports = isNil ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var converge = __webpack_require__ ( 194 ) ; var juxt = _curry1 ( function juxt ( fns ) { return converge ( function ( ) { return Array . prototype . slice . call ( arguments , 0 ) ; } , fns ) ; } ) ; module . exports = juxt ; } 
function ( module , exports , __webpack_require__ ) { var nth = __webpack_require__ ( 26 ) ; var last = nth ( - 1 ) ; module . exports = last ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _isNumber = __webpack_require__ ( 209 ) ; var length = _curry1 ( function length ( list ) { return list != null && _isNumber ( list . length ) ? list . length : NaN ; } ) ; module . exports = length ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduce = __webpack_require__ ( 11 ) ; var ap = __webpack_require__ ( 46 ) ; var curryN = __webpack_require__ ( 7 ) ; var map = __webpack_require__ ( 9 ) ; var liftN = _curry2 ( function liftN ( arity , fn ) { var lifted = curryN ( arity , fn ) ; return curryN ( arity , function ( ) { return _reduce ( ap , map ( lifted , arguments [ 0 ] ) , Array . prototype . slice . call ( arguments , 1 ) ) ; } ) ; } ) ; module . exports = liftN ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var sum = __webpack_require__ ( 234 ) ; var mean = _curry1 ( function mean ( list ) { return sum ( list ) / list . length ; } ) ; module . exports = mean ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _has = __webpack_require__ ( 8 ) ; var memoizeWith = _curry2 ( function memoizeWith ( mFn , fn ) { var cache = { } ; return _arity ( fn . length , function ( ) { var key = mFn . apply ( this , arguments ) ; if ( ! _has ( key , cache ) ) { cache [ key ] = fn . apply ( this , arguments ) ; } return cache [ key ] ; } ) ; } ) ; module . exports = memoizeWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var multiply = _curry2 ( function multiply ( a , b ) { return a * b ; } ) ; module . exports = multiply ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var not = _curry1 ( function not ( a ) { return ! a ; } ) ; module . exports = not ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var objOf = _curry2 ( function objOf ( key , val ) { var obj = { } ; obj [ key ] = val ; return obj ; } ) ; module . exports = objOf ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var or = _curry2 ( function or ( a , b ) { return a || b ; } ) ; module . exports = or ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; * Returns the result of "setting" the portion of the given data structure * focused by the given lens to the result of applying the given function to * the focused value. * * @func * @memberOf R * @since v0.16.0 * @category Object * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s * @sig Lens s a -> (a -> a) -> s -> s * @param {Lens} lens * @param {*} v * @param {*} x * @return {*} * @see R.prop, R.lensIndex, R.lensProp * @example * * var headLens = R.lensIndex(0); * * R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); */ var over = _curry3 ( function over ( lens , f , x ) { 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var pickAll = _curry2 ( function pickAll ( names , obj ) { var result = { } ; var idx = 0 ; var len = names . length ; while ( idx < len ) { var name = names [ idx ] ; result [ name ] = obj [ name ] ; idx += 1 ; } return result ; } ) ; module . exports = pickAll ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _pipe = __webpack_require__ ( 326 ) ; var reduce = __webpack_require__ ( 16 ) ; var tail = __webpack_require__ ( 61 ) ; function pipe ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipe requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe , arguments [ 0 ] , tail ( arguments ) ) ) ; } module . exports = pipe ; } 
function pipe ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipe requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipe , arguments [ 0 ] , tail ( arguments ) ) ) ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _pipeP = __webpack_require__ ( 327 ) ; var reduce = __webpack_require__ ( 16 ) ; var tail = __webpack_require__ ( 61 ) ; function pipeP ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipeP requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipeP , arguments [ 0 ] , tail ( arguments ) ) ) ; } module . exports = pipeP ; } 
function pipeP ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipeP requires at least one argument' ) ; } return _arity ( arguments [ 0 ] . length , reduce ( _pipeP , arguments [ 0 ] , tail ( arguments ) ) ) ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var prepend = _curry2 ( function prepend ( el , list ) { return _concat ( [ el ] , list ) ; } ) ; module . exports = prepend ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var reduceRight = _curry3 ( function reduceRight ( fn , acc , list ) { var idx = list . length - 1 ; while ( idx >= 0 ) { acc = fn ( list [ idx ] , acc ) ; idx -= 1 ; } return acc ; } ) ; module . exports = reduceRight ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var remove = _curry3 ( function remove ( start , count , list ) { var result = Array . prototype . slice . call ( list , 0 ) ; result . splice ( start , count ) ; return result ; } ) ; module . exports = remove ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var ap = __webpack_require__ ( 46 ) ; var map = __webpack_require__ ( 9 ) ; var prepend = __webpack_require__ ( 230 ) ; var reduceRight = __webpack_require__ ( 231 ) ; var sequence = _curry2 ( function sequence ( of , traversable ) { return typeof traversable . sequence === 'function' ? traversable . sequence ( of ) : reduceRight ( function ( x , acc ) { return ap ( map ( prepend , x ) , acc ) ; } , of ( [ ] ) , traversable ) ; } ) ; module . exports = sequence ; } 
function ( module , exports , __webpack_require__ ) { var add = __webpack_require__ ( 29 ) ; var reduce = __webpack_require__ ( 16 ) ; var sum = reduce ( add , 0 ) ; module . exports = sum ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var drop = __webpack_require__ ( 199 ) ; var takeLast = _curry2 ( function takeLast ( n , xs ) { return drop ( n >= 0 ? xs . length - n : 0 , xs ) ; } ) ; module . exports = takeLast ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var times = _curry2 ( function times ( fn , n ) { var len = Number ( n ) ; var idx = 0 ; var list ; if ( len < 0 || isNaN ( len ) ) { throw new RangeError ( 'n must be a non-negative number' ) ; } list = new Array ( len ) ; while ( idx < len ) { list [ idx ] = fn ( idx ) ; idx += 1 ; } return list ; } ) ; module . exports = times ; } 
function ( module , exports , __webpack_require__ ) { var _Set = __webpack_require__ ( 314 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var uniqBy = _curry2 ( function uniqBy ( fn , list ) { var set = new _Set ( ) ; var result = [ ] ; var idx = 0 ; var appliedItem , item ; while ( idx < list . length ) { item = list [ idx ] ; appliedItem = fn ( item ) ; if ( set . add ( appliedItem ) ) { result . push ( item ) ; } idx += 1 ; } return result ; } ) ; module . exports = uniqBy ; } 
function ( module , exports , __webpack_require__ ) { var _containsWith = __webpack_require__ ( 32 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var uniqWith = _curry2 ( function uniqWith ( pred , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; var item ; while ( idx < len ) { item = list [ idx ] ; if ( ! _containsWith ( pred , item , result ) ) { result [ result . length ] = item ; } idx += 1 ; } return result ; } ) ; module . exports = uniqWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var curryN = __webpack_require__ ( 7 ) ; var useWith = _curry2 ( function useWith ( fn , transformers ) { return curryN ( transformers . length , function ( ) { var args = [ ] ; var idx = 0 ; while ( idx < transformers . length ) { args . push ( transformers [ idx ] . call ( this , arguments [ idx ] ) ) ; idx += 1 ; } return fn . apply ( this , args . concat ( Array . prototype . slice . call ( arguments , transformers . length ) ) ) ; } ) ; } ) ; module . exports = useWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var keys = __webpack_require__ ( 15 ) ; var values = _curry1 ( function values ( obj ) { var props = keys ( obj ) ; var len = props . length ; var vals = [ ] ; var idx = 0 ; while ( idx < len ) { vals [ idx ] = obj [ props [ idx ] ] ; idx += 1 ; } return vals ; } ) ; module . exports = values ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _has = __webpack_require__ ( 8 ) ; var where = _curry2 ( function where ( spec , testObj ) { for ( var prop in spec ) { if ( _has ( prop , spec ) && ! spec [ prop ] ( testObj [ prop ] ) ) { return false ; } } return true ; } ) ; module . exports = where ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; if ( true ) { module . exports = __webpack_require__ ( 464 ) ; } else { module . exports = require ( './cjs/react.development.js' ) ; } } 
function ( module , exports , __webpack_require__ ) { var always = __webpack_require__ ( 19 ) ; var F = always ( false ) ; module . exports = F ; } 
function ( module , exports , __webpack_require__ ) { var always = __webpack_require__ ( 19 ) ; var T = always ( true ) ; module . exports = T ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var curryN = __webpack_require__ ( 7 ) ; var addIndex = _curry1 ( function addIndex ( fn ) { return curryN ( fn . length , function ( ) { var idx = 0 ; var origFn = arguments [ 0 ] ; var list = arguments [ arguments . length - 1 ] ; var args = Array . prototype . slice . call ( arguments , 0 ) ; args [ 0 ] = function ( ) { var result = origFn . apply ( this , _concat ( arguments , [ idx , list ] ) ) ; idx += 1 ; return result ; } ; return fn . apply ( this , args ) ; } ) ; } ) ; module . exports = addIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xall = __webpack_require__ ( 332 ) ; var all = _curry2 ( _dispatchable ( [ 'all' ] , _xall , function all ( fn , list ) { var idx = 0 ; while ( idx < list . length ) { if ( ! fn ( list [ idx ] ) ) { return false ; } idx += 1 ; } return true ; } ) ) ; module . exports = all ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var curryN = __webpack_require__ ( 7 ) ; var max = __webpack_require__ ( 21 ) ; var pluck = __webpack_require__ ( 27 ) ; var reduce = __webpack_require__ ( 16 ) ; var anyPass = _curry1 ( function anyPass ( preds ) { return curryN ( reduce ( max , 0 , pluck ( 'length' , preds ) ) , function ( ) { var idx = 0 ; var len = preds . length ; while ( idx < len ) { if ( preds [ idx ] . apply ( this , arguments ) ) { return true ; } idx += 1 ; } return false ; } ) ; } ) ; module . exports = anyPass ; } 
function ( module , exports , __webpack_require__ ) { var _aperture = __webpack_require__ ( 315 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xaperture = __webpack_require__ ( 333 ) ; var aperture = _curry2 ( _dispatchable ( [ ] , _xaperture , _aperture ) ) ; module . exports = aperture ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var append = _curry2 ( function append ( el , list ) { return _concat ( list , [ el ] ) ; } ) ; module . exports = append ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var apply = __webpack_require__ ( 189 ) ; var curryN = __webpack_require__ ( 7 ) ; var map = __webpack_require__ ( 9 ) ; var max = __webpack_require__ ( 21 ) ; var pluck = __webpack_require__ ( 27 ) ; var reduce = __webpack_require__ ( 16 ) ; var values = __webpack_require__ ( 240 ) ; var applySpec = _curry1 ( function applySpec ( spec ) { spec = map ( function ( v ) { return typeof v == 'function' ? v : applySpec ( v ) ; } , spec ) ; return curryN ( reduce ( max , 0 , pluck ( 'length' , values ( spec ) ) ) , function ( ) { var args = arguments ; return map ( function ( f ) { return apply ( f , args ) ; } , spec ) ; } ) ; } ) ; module . exports = applySpec ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var applyTo = _curry2 ( function applyTo ( x , f ) { return f ( x ) ; } ) ; module . exports = applyTo ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var nAry = __webpack_require__ ( 41 ) ; var binary = _curry1 ( function binary ( fn ) { return nAry ( 2 , fn ) ; } ) ; module . exports = binary ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isFunction = __webpack_require__ ( 35 ) ; var and = __webpack_require__ ( 187 ) ; var lift = __webpack_require__ ( 39 ) ; var both = _curry2 ( function both ( f , g ) { return _isFunction ( f ) ? function _both ( ) { return f . apply ( this , arguments ) && g . apply ( this , arguments ) ; } : lift ( and ) ( f , g ) ; } ) ; module . exports = both ; } 
function ( module , exports , __webpack_require__ ) { var curry = __webpack_require__ ( 50 ) ; var call = curry ( function call ( fn ) { return fn . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } ) ; module . exports = call ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var clamp = _curry3 ( function clamp ( min , max , value ) { if ( min > max ) { throw new Error ( 'min must not be greater than max in clamp(min, max, value)' ) ; } return value < min ? min : value > max ? max : value ; } ) ; module . exports = clamp ; } 
function ( module , exports , __webpack_require__ ) { var _clone = __webpack_require__ ( 203 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var clone = _curry1 ( function clone ( value ) { return value != null && typeof value . clone === 'function' ? value . clone ( ) : _clone ( value , [ ] , [ ] , true ) ; } ) ; module . exports = clone ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var comparator = _curry1 ( function comparator ( pred ) { return function ( a , b ) { return pred ( a , b ) ? - 1 : pred ( b , a ) ? 1 : 0 ; } ; } ) ; module . exports = comparator ; } 
function ( module , exports , __webpack_require__ ) { var lift = __webpack_require__ ( 39 ) ; var not = __webpack_require__ ( 223 ) ; var complement = lift ( not ) ; module . exports = complement ; } 
function ( module , exports , __webpack_require__ ) { var pipeP = __webpack_require__ ( 229 ) ; var reverse = __webpack_require__ ( 44 ) ; function composeP ( ) { if ( arguments . length === 0 ) { throw new Error ( 'composeP requires at least one argument' ) ; } return pipeP . apply ( this , reverse ( arguments ) ) ; } module . exports = composeP ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var map = __webpack_require__ ( 9 ) ; var max = __webpack_require__ ( 21 ) ; var reduce = __webpack_require__ ( 16 ) ; var cond = _curry1 ( function cond ( pairs ) { var arity = reduce ( max , 0 , map ( function ( pair ) { return pair [ 0 ] . length ; } , pairs ) ) ; return _arity ( arity , function ( ) { var idx = 0 ; while ( idx < pairs . length ) { if ( pairs [ idx ] [ 0 ] . apply ( this , arguments ) ) { return pairs [ idx ] [ 1 ] . apply ( this , arguments ) ; } idx += 1 ; } } ) ; } ) ; module . exports = cond ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var constructN = __webpack_require__ ( 193 ) ; var construct = _curry1 ( function construct ( Fn ) { return constructN ( Fn . length , Fn ) ; } ) ; module . exports = construct ; } 
function ( module , exports , __webpack_require__ ) { var _contains = __webpack_require__ ( 20 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var contains = _curry2 ( _contains ) ; module . exports = contains ; } 
function ( module , exports , __webpack_require__ ) { var reduceBy = __webpack_require__ ( 42 ) ; var countBy = reduceBy ( function ( acc , elem ) { return acc + 1 ; } , 0 ) ; module . exports = countBy ; } 
function ( module , exports , __webpack_require__ ) { var add = __webpack_require__ ( 29 ) ; var dec = add ( - 1 ) ; module . exports = dec ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var descend = _curry3 ( function descend ( fn , a , b ) { var aa = fn ( a ) ; var bb = fn ( b ) ; return aa > bb ? - 1 : aa < bb ? 1 : 0 ; } ) ; module . exports = descend ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isInteger = __webpack_require__ ( 56 ) ; var assoc = __webpack_require__ ( 30 ) ; var dissoc = __webpack_require__ ( 198 ) ; var remove = __webpack_require__ ( 232 ) ; var update = __webpack_require__ ( 65 ) ; var dissocPath = _curry2 ( function dissocPath ( path , obj ) { switch ( path . length ) { case 0 : return obj ; case 1 : return _isInteger ( path [ 0 ] ) ? remove ( path [ 0 ] , 1 , obj ) : dissoc ( path [ 0 ] , obj ) ; default : var head = path [ 0 ] ; var tail = Array . prototype . slice . call ( path , 1 ) ; if ( obj [ head ] == null ) { return obj ; } else if ( _isInteger ( path [ 0 ] ) ) { return update ( head , dissocPath ( tail , obj [ head ] ) , obj ) ; } else { return assoc ( head , dissocPath ( tail , obj [ head ] ) , obj ) ; } } } ) ; module . exports = dissocPath ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var divide = _curry2 ( function divide ( a , b ) { return a / b ; } ) ; module . exports = divide ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _dropLast = __webpack_require__ ( 317 ) ; var _xdropLast = __webpack_require__ ( 336 ) ; var dropLast = _curry2 ( _dispatchable ( [ ] , _xdropLast , _dropLast ) ) ; module . exports = dropLast ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _dropLastWhile = __webpack_require__ ( 318 ) ; var _xdropLastWhile = __webpack_require__ ( 337 ) ; var dropLastWhile = _curry2 ( _dispatchable ( [ ] , _xdropLastWhile , _dropLastWhile ) ) ; module . exports = dropLastWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xdropRepeatsWith = __webpack_require__ ( 212 ) ; var dropRepeatsWith = __webpack_require__ ( 200 ) ; var equals = __webpack_require__ ( 10 ) ; var dropRepeats = _curry1 ( _dispatchable ( [ ] , _xdropRepeatsWith ( equals ) , dropRepeatsWith ( equals ) ) ) ; module . exports = dropRepeats ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xdropWhile = __webpack_require__ ( 338 ) ; var slice = __webpack_require__ ( 13 ) ; var dropWhile = _curry2 ( _dispatchable ( [ 'dropWhile' ] , _xdropWhile , function dropWhile ( pred , xs ) { var idx = 0 ; var len = xs . length ; while ( idx < len && pred ( xs [ idx ] ) ) { idx += 1 ; } return slice ( idx , Infinity , xs ) ; } ) ) ; module . exports = dropWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isFunction = __webpack_require__ ( 35 ) ; var lift = __webpack_require__ ( 39 ) ; var or = __webpack_require__ ( 225 ) ; var either = _curry2 ( function either ( f , g ) { return _isFunction ( f ) ? function _either ( ) { return f . apply ( this , arguments ) || g . apply ( this , arguments ) ; } : lift ( or ) ( f , g ) ; } ) ; module . exports = either ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var equals = __webpack_require__ ( 10 ) ; var takeLast = __webpack_require__ ( 235 ) ; var endsWith = _curry2 ( function ( suffix , list ) { return equals ( takeLast ( suffix . length , list ) , suffix ) ; } ) ; module . exports = endsWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var equals = __webpack_require__ ( 10 ) ; var eqBy = _curry3 ( function eqBy ( f , x , y ) { return equals ( f ( x ) , f ( y ) ) ; } ) ; module . exports = eqBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var equals = __webpack_require__ ( 10 ) ; var eqProps = _curry3 ( function eqProps ( prop , obj1 , obj2 ) { return equals ( obj1 [ prop ] , obj2 [ prop ] ) ; } ) ; module . exports = eqProps ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var evolve = _curry2 ( function evolve ( transformations , object ) { var result = { } ; var transformation , key , type ; for ( key in object ) { transformation = transformations [ key ] ; type = typeof transformation ; result [ key ] = type === 'function' ? transformation ( object [ key ] ) : transformation && type === 'object' ? evolve ( transformation , object [ key ] ) : object [ key ] ; } return result ; } ) ; module . exports = evolve ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xfind = __webpack_require__ ( 340 ) ; var find = _curry2 ( _dispatchable ( [ 'find' ] , _xfind , function find ( fn , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { return list [ idx ] ; } idx += 1 ; } } ) ) ; module . exports = find ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xfindIndex = __webpack_require__ ( 341 ) ; var findIndex = _curry2 ( _dispatchable ( [ ] , _xfindIndex , function findIndex ( fn , list ) { var idx = 0 ; var len = list . length ; while ( idx < len ) { if ( fn ( list [ idx ] ) ) { return idx ; } idx += 1 ; } return - 1 ; } ) ) ; module . exports = findIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xfindLast = __webpack_require__ ( 342 ) ; var findLast = _curry2 ( _dispatchable ( [ ] , _xfindLast , function findLast ( fn , list ) { var idx = list . length - 1 ; while ( idx >= 0 ) { if ( fn ( list [ idx ] ) ) { return list [ idx ] ; } idx -= 1 ; } } ) ) ; module . exports = findLast ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xfindLastIndex = __webpack_require__ ( 343 ) ; var findLastIndex = _curry2 ( _dispatchable ( [ ] , _xfindLastIndex , function findLastIndex ( fn , list ) { var idx = list . length - 1 ; while ( idx >= 0 ) { if ( fn ( list [ idx ] ) ) { return idx ; } idx -= 1 ; } return - 1 ; } ) ) ; module . exports = findLastIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _makeFlat = __webpack_require__ ( 210 ) ; var flatten = _curry1 ( _makeFlat ( true ) ) ; module . exports = flatten ; } 
function ( module , exports , __webpack_require__ ) { var _checkForMethod = __webpack_require__ ( 23 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var forEach = _curry2 ( _checkForMethod ( 'forEach' , function forEach ( fn , list ) { var len = list . length ; var idx = 0 ; while ( idx < len ) { fn ( list [ idx ] ) ; idx += 1 ; } return list ; } ) ) ; module . exports = forEach ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var keys = __webpack_require__ ( 15 ) ; var forEachObjIndexed = _curry2 ( function forEachObjIndexed ( fn , obj ) { var keyList = keys ( obj ) ; var idx = 0 ; while ( idx < keyList . length ) { var key = keyList [ idx ] ; fn ( obj [ key ] , key , obj ) ; idx += 1 ; } return obj ; } ) ; module . exports = forEachObjIndexed ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var fromPairs = _curry1 ( function fromPairs ( pairs ) { var result = { } ; var idx = 0 ; while ( idx < pairs . length ) { result [ pairs [ idx ] [ 0 ] ] = pairs [ idx ] [ 1 ] ; idx += 1 ; } return result ; } ) ; module . exports = fromPairs ; } 
function ( module , exports , __webpack_require__ ) { var _checkForMethod = __webpack_require__ ( 23 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var reduceBy = __webpack_require__ ( 42 ) ; var groupBy = _curry2 ( _checkForMethod ( 'groupBy' , reduceBy ( function ( acc , item ) { if ( acc == null ) { acc = [ ] ; } acc . push ( item ) ; return acc ; } , null ) ) ) ; module . exports = groupBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var groupWith = _curry2 ( function ( fn , list ) { var res = [ ] ; var idx = 0 ; var len = list . length ; while ( idx < len ) { var nextidx = idx + 1 ; while ( nextidx < len && fn ( list [ nextidx - 1 ] , list [ nextidx ] ) ) { nextidx += 1 ; } res . push ( list . slice ( idx , nextidx ) ) ; idx = nextidx ; } return res ; } ) ; module . exports = groupWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var gt = _curry2 ( function gt ( a , b ) { return a > b ; } ) ; module . exports = gt ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var gte = _curry2 ( function gte ( a , b ) { return a >= b ; } ) ; module . exports = gte ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _has = __webpack_require__ ( 8 ) ; var has = _curry2 ( _has ) ; module . exports = has ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var hasIn = _curry2 ( function hasIn ( prop , obj ) { return prop in obj ; } ) ; module . exports = hasIn ; } 
function ( module , exports , __webpack_require__ ) { var nth = __webpack_require__ ( 26 ) ; var head = nth ( 0 ) ; module . exports = head ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var curryN = __webpack_require__ ( 7 ) ; var ifElse = _curry3 ( function ifElse ( condition , onTrue , onFalse ) { return curryN ( Math . max ( condition . length , onTrue . length , onFalse . length ) , function _ifElse ( ) { return condition . apply ( this , arguments ) ? onTrue . apply ( this , arguments ) : onFalse . apply ( this , arguments ) ; } ) ; } ) ; module . exports = ifElse ; } 
function ( module , exports , __webpack_require__ ) { var add = __webpack_require__ ( 29 ) ; var inc = add ( 1 ) ; module . exports = inc ; } 
function ( module , exports , __webpack_require__ ) { module . exports = { } ; module . exports . F = __webpack_require__ ( 253 ) ; module . exports . T = __webpack_require__ ( 254 ) ; module . exports . __ = __webpack_require__ ( 255 ) ; module . exports . add = __webpack_require__ ( 29 ) ; module . exports . addIndex = __webpack_require__ ( 256 ) ; module . exports . adjust = __webpack_require__ ( 186 ) ; module . exports . all = __webpack_require__ ( 257 ) ; module . exports . allPass = __webpack_require__ ( 258 ) ; module . exports . always = __webpack_require__ ( 19 ) ; module . exports . and = __webpack_require__ ( 187 ) ; module . exports . any = __webpack_require__ ( 188 ) ; module . exports . anyPass = __webpack_require__ ( 259 ) ; module . exports . ap = __webpack_require__ ( 46 ) ; module . exports . aperture = __webpack_require__ ( 260 ) ; module . exports . append = __webpack_require__ ( 261 ) ; module . exports . apply = __webpack_require__ ( 189 ) ; module . exports . applySpec = __webpack_require__ ( 262 ) ; module . exports . applyTo = __webpack_require__ ( 263 ) ; module . exports . ascend = __webpack_require__ ( 264 ) ; module . exports . assoc = __webpack_require__ ( 30 ) ; module . exports . assocPath = __webpack_require__ ( 190 ) ; module . exports . binary = __webpack_require__ ( 265 ) ; module . exports . bind = __webpack_require__ ( 191 ) ; module . exports . both = __webpack_require__ ( 266 ) ; module . exports . call = __webpack_require__ ( 267 ) ; module . exports . chain = __webpack_require__ ( 47 ) ; module . exports . clamp = __webpack_require__ ( 268 ) ; module . exports . clone = __webpack_require__ ( 269 ) ; module . exports . comparator = __webpack_require__ ( 270 ) ; module . exports . complement = __webpack_require__ ( 271 ) ; module . exports . compose = __webpack_require__ ( 48 ) ; module . exports . composeK = __webpack_require__ ( 192 ) ; module . exports . composeP = __webpack_require__ ( 272 ) ; module . exports . concat = __webpack_require__ ( 49 ) ; module . exports . cond = __webpack_require__ ( 273 ) ; module . exports . construct = __webpack_require__ ( 274 ) ; module . exports . constructN = __webpack_require__ ( 193 ) ; module . exports . contains = __webpack_require__ ( 275 ) ; module . exports . converge = __webpack_require__ ( 194 ) ; module . exports . countBy = __webpack_require__ ( 276 ) ; module . exports . curry = __webpack_require__ ( 50 ) ; module . exports . curryN = __webpack_require__ ( 7 ) ; module . exports . dec = __webpack_require__ ( 277 ) ; module . exports . defaultTo = __webpack_require__ ( 195 ) ; module . exports . descend = __webpack_require__ ( 278 ) ; module . exports . difference = __webpack_require__ ( 196 ) ; module . exports . differenceWith = __webpack_require__ ( 197 ) ; module . exports . dissoc = __webpack_require__ ( 198 ) ; module . exports . dissocPath = __webpack_require__ ( 279 ) ; module . exports . divide = __webpack_require__ ( 280 ) ; module . exports . drop = __webpack_require__ ( 199 ) ; module . exports . dropLast = __webpack_require__ ( 281 ) ; module . exports . dropLastWhile = __webpack_require__ ( 282 ) ; module . exports . dropRepeats = __webpack_require__ ( 283 ) ; module . exports . dropRepeatsWith = __webpack_require__ ( 200 ) ; module . exports . dropWhile = __webpack_require__ ( 284 ) ; module . exports . either = __webpack_require__ ( 285 ) ; module . exports . empty = __webpack_require__ ( 201 ) ; module . exports . endsWith = __webpack_require__ ( 286 ) ; module . exports . eqBy = __webpack_require__ ( 287 ) ; module . exports . eqProps = __webpack_require__ ( 288 ) ; module . exports . equals = __webpack_require__ ( 10 ) ; module . exports . evolve = __webpack_require__ ( 289 ) ; module . exports . filter = __webpack_require__ ( 51 ) ; module . exports . find = __webpack_require__ ( 290 ) ; module . exports . findIndex = __webpack_require__ ( 291 ) ; module . exports . findLast = __webpack_require__ ( 292 ) ; module . exports . findLastIndex = __webpack_require__ ( 293 ) ; module . exports . flatten = __webpack_require__ ( 294 ) ; module . exports . flip = __webpack_require__ ( 31 ) ; module . exports . forEach = __webpack_require__ ( 295 ) ; module . exports . forEachObjIndexed = __webpack_require__ ( 296 ) ; module . exports . fromPairs = __webpack_require__ ( 297 ) ; module . exports . groupBy = __webpack_require__ ( 298 ) ; module . exports . groupWith = __webpack_require__ ( 299 ) ; module . exports . gt = __webpack_require__ ( 300 ) ; module . exports . gte = __webpack_require__ ( 301 ) ; module . exports . has = __webpack_require__ ( 302 ) ; module . exports . hasIn = __webpack_require__ ( 303 ) ; module . exports . head = __webpack_require__ ( 304 ) ; module . exports . identical = __webpack_require__ ( 202 ) ; module . exports . identity = __webpack_require__ ( 52 ) ; module . exports . ifElse = __webpack_require__ ( 305 ) ; module . exports . inc = __webpack_require__ ( 306 ) ; module . exports . indexBy = __webpack_require__ ( 308 ) ; module . exports . indexOf = __webpack_require__ ( 309 ) ; module . exports . init = __webpack_require__ ( 310 ) ; module . exports . innerJoin = __webpack_require__ ( 311 ) ; module . exports . insert = __webpack_require__ ( 312 ) ; module . exports . insertAll = __webpack_require__ ( 313 ) ; module . exports . intersection = __webpack_require__ ( 349 ) ; module . exports . intersperse = __webpack_require__ ( 350 ) ; module . exports . into = __webpack_require__ ( 351 ) ; module . exports . invert = __webpack_require__ ( 352 ) ; module . exports . invertObj = __webpack_require__ ( 353 ) ; module . exports . invoker = __webpack_require__ ( 25 ) ; module . exports . is = __webpack_require__ ( 214 ) ; module . exports . isEmpty = __webpack_require__ ( 354 ) ; module . exports . isNil = __webpack_require__ ( 215 ) ; module . exports . join = __webpack_require__ ( 355 ) ; module . exports . juxt = __webpack_require__ ( 216 ) ; module . exports . keys = __webpack_require__ ( 15 ) ; module . exports . keysIn = __webpack_require__ ( 356 ) ; module . exports . last = __webpack_require__ ( 217 ) ; module . exports . lastIndexOf = __webpack_require__ ( 357 ) ; module . exports . length = __webpack_require__ ( 218 ) ; module . exports . lens = __webpack_require__ ( 38 ) ; module . exports . lensIndex = __webpack_require__ ( 358 ) ; module . exports . lensPath = __webpack_require__ ( 359 ) ; module . exports . lensProp = __webpack_require__ ( 360 ) ; module . exports . lift = __webpack_require__ ( 39 ) ; module . exports . liftN = __webpack_require__ ( 219 ) ; module . exports . lt = __webpack_require__ ( 361 ) ; module . exports . lte = __webpack_require__ ( 362 ) ; module . exports . map = __webpack_require__ ( 9 ) ; module . exports . mapAccum = __webpack_require__ ( 363 ) ; module . exports . mapAccumRight = __webpack_require__ ( 364 ) ; module . exports . mapObjIndexed = __webpack_require__ ( 365 ) ; module . exports . match = __webpack_require__ ( 366 ) ; module . exports . mathMod = __webpack_require__ ( 367 ) ; module . exports . max = __webpack_require__ ( 21 ) ; module . exports . maxBy = __webpack_require__ ( 368 ) ; module . exports . mean = __webpack_require__ ( 220 ) ; module . exports . median = __webpack_require__ ( 369 ) ; module . exports . memoize = __webpack_require__ ( 370 ) ; module . exports . memoizeWith = __webpack_require__ ( 221 ) ; module . exports . merge = __webpack_require__ ( 371 ) ; module . exports . mergeAll = __webpack_require__ ( 372 ) ; module . exports . mergeDeepLeft = __webpack_require__ ( 373 ) ; module . exports . mergeDeepRight = __webpack_require__ ( 374 ) ; module . exports . mergeDeepWith = __webpack_require__ ( 375 ) ; module . exports . mergeDeepWithKey = __webpack_require__ ( 40 ) ; module . exports . mergeWith = __webpack_require__ ( 376 ) ; module . exports . mergeWithKey = __webpack_require__ ( 59 ) ; module . exports . min = __webpack_require__ ( 377 ) ; module . exports . minBy = __webpack_require__ ( 378 ) ; module . exports . modulo = __webpack_require__ ( 379 ) ; module . exports . multiply = __webpack_require__ ( 222 ) ; module . exports . nAry = __webpack_require__ ( 41 ) ; module . exports . negate = __webpack_require__ ( 380 ) ; module . exports . none = __webpack_require__ ( 381 ) ; module . exports . not = __webpack_require__ ( 223 ) ; module . exports . nth = __webpack_require__ ( 26 ) ; module . exports . nthArg = __webpack_require__ ( 382 ) ; module . exports . o = __webpack_require__ ( 383 ) ; module . exports . objOf = __webpack_require__ ( 224 ) ; module . exports . of = __webpack_require__ ( 384 ) ; module . exports . omit = __webpack_require__ ( 385 ) ; module . exports . once = __webpack_require__ ( 386 ) ; module . exports . or = __webpack_require__ ( 225 ) ; module . exports . over = __webpack_require__ ( 226 ) ; module . exports . pair = __webpack_require__ ( 387 ) ; module . exports . partial = __webpack_require__ ( 388 ) ; module . exports . partialRight = __webpack_require__ ( 389 ) ; module . exports . partition = __webpack_require__ ( 390 ) ; module . exports . path = __webpack_require__ ( 22 ) ; module . exports . pathEq = __webpack_require__ ( 391 ) ; module . exports . pathOr = __webpack_require__ ( 392 ) ; module . exports . pathSatisfies = __webpack_require__ ( 393 ) ; module . exports . pick = __webpack_require__ ( 394 ) ; module . exports . pickAll = __webpack_require__ ( 227 ) ; module . exports . pickBy = __webpack_require__ ( 395 ) ; module . exports . pipe = __webpack_require__ ( 228 ) ; module . exports . pipeK = __webpack_require__ ( 396 ) ; module . exports . pipeP = __webpack_require__ ( 229 ) ; module . exports . pluck = __webpack_require__ ( 27 ) ; module . exports . prepend = __webpack_require__ ( 230 ) ; module . exports . product = __webpack_require__ ( 397 ) ; module . exports . project = __webpack_require__ ( 398 ) ; module . exports . prop = __webpack_require__ ( 60 ) ; module . exports . propEq = __webpack_require__ ( 399 ) ; module . exports . propIs = __webpack_require__ ( 400 ) ; module . exports . propOr = __webpack_require__ ( 401 ) ; module . exports . propSatisfies = __webpack_require__ ( 402 ) ; module . exports . props = __webpack_require__ ( 403 ) ; module . exports . range = __webpack_require__ ( 404 ) ; module . exports . reduce = __webpack_require__ ( 16 ) ; module . exports . reduceBy = __webpack_require__ ( 42 ) ; module . exports . reduceRight = __webpack_require__ ( 231 ) ; module . exports . reduceWhile = __webpack_require__ ( 405 ) ; module . exports . reduced = __webpack_require__ ( 406 ) ; module . exports . reject = __webpack_require__ ( 43 ) ; module . exports . remove = __webpack_require__ ( 232 ) ; module . exports . repeat = __webpack_require__ ( 407 ) ; module . exports . replace = __webpack_require__ ( 408 ) ; module . exports . reverse = __webpack_require__ ( 44 ) ; module . exports . scan = __webpack_require__ ( 409 ) ; module . exports . sequence = __webpack_require__ ( 233 ) ; module . exports . set = __webpack_require__ ( 410 ) ; module . exports . slice = __webpack_require__ ( 13 ) ; module . exports . sort = __webpack_require__ ( 411 ) ; module . exports . sortBy = __webpack_require__ ( 412 ) ; module . exports . sortWith = __webpack_require__ ( 413 ) ; module . exports . split = __webpack_require__ ( 414 ) ; module . exports . splitAt = __webpack_require__ ( 415 ) ; module . exports . splitEvery = __webpack_require__ ( 416 ) ; module . exports . splitWhen = __webpack_require__ ( 417 ) ; module . exports . startsWith = __webpack_require__ ( 418 ) ; module . exports . subtract = __webpack_require__ ( 419 ) ; module . exports . sum = __webpack_require__ ( 234 ) ; module . exports . symmetricDifference = __webpack_require__ ( 420 ) ; module . exports . symmetricDifferenceWith = __webpack_require__ ( 421 ) ; module . exports . tail = __webpack_require__ ( 61 ) ; module . exports . take = __webpack_require__ ( 62 ) ; module . exports . takeLast = __webpack_require__ ( 235 ) ; module . exports . takeLastWhile = __webpack_require__ ( 422 ) ; module . exports . takeWhile = __webpack_require__ ( 423 ) ; module . exports . tap = __webpack_require__ ( 424 ) ; module . exports . test = __webpack_require__ ( 425 ) ; module . exports . times = __webpack_require__ ( 236 ) ; module . exports . toLower = __webpack_require__ ( 426 ) ; module . exports . toPairs = __webpack_require__ ( 427 ) ; module . exports . toPairsIn = __webpack_require__ ( 428 ) ; module . exports . toString = __webpack_require__ ( 28 ) ; module . exports . toUpper = __webpack_require__ ( 429 ) ; module . exports . transduce = __webpack_require__ ( 430 ) ; module . exports . transpose = __webpack_require__ ( 431 ) ; module . exports . traverse = __webpack_require__ ( 432 ) ; module . exports . trim = __webpack_require__ ( 433 ) ; module . exports . tryCatch = __webpack_require__ ( 434 ) ; module . exports . type = __webpack_require__ ( 63 ) ; module . exports . unapply = __webpack_require__ ( 435 ) ; module . exports . unary = __webpack_require__ ( 436 ) ; module . exports . uncurryN = __webpack_require__ ( 437 ) ; module . exports . unfold = __webpack_require__ ( 438 ) ; module . exports . union = __webpack_require__ ( 439 ) ; module . exports . unionWith = __webpack_require__ ( 440 ) ; module . exports . uniq = __webpack_require__ ( 64 ) ; module . exports . uniqBy = __webpack_require__ ( 237 ) ; module . exports . uniqWith = __webpack_require__ ( 238 ) ; module . exports . unless = __webpack_require__ ( 441 ) ; module . exports . unnest = __webpack_require__ ( 442 ) ; module . exports . until = __webpack_require__ ( 443 ) ; module . exports . update = __webpack_require__ ( 65 ) ; module . exports . useWith = __webpack_require__ ( 239 ) ; module . exports . values = __webpack_require__ ( 240 ) ; module . exports . valuesIn = __webpack_require__ ( 444 ) ; module . exports . view = __webpack_require__ ( 445 ) ; module . exports . when = __webpack_require__ ( 446 ) ; module . exports . where = __webpack_require__ ( 241 ) ; module . exports . whereEq = __webpack_require__ ( 447 ) ; module . exports . without = __webpack_require__ ( 448 ) ; module . exports . xprod = __webpack_require__ ( 449 ) ; module . exports . zip = __webpack_require__ ( 450 ) ; module . exports . zipObj = __webpack_require__ ( 451 ) ; module . exports . zipWith = __webpack_require__ ( 452 ) ; } 
function ( module , exports , __webpack_require__ ) { var reduceBy = __webpack_require__ ( 42 ) ; var indexBy = reduceBy ( function ( acc , elem ) { return elem ; } , null ) ; module . exports = indexBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _indexOf = __webpack_require__ ( 207 ) ; var _isArray = __webpack_require__ ( 17 ) ; var indexOf = _curry2 ( function indexOf ( target , xs ) { return typeof xs . indexOf === 'function' && ! _isArray ( xs ) ? xs . indexOf ( target ) : _indexOf ( xs , target , 0 ) ; } ) ; module . exports = indexOf ; } 
function ( module , exports , __webpack_require__ ) { var slice = __webpack_require__ ( 13 ) ; var init = slice ( 0 , - 1 ) ; module . exports = init ; } 
function ( module , exports , __webpack_require__ ) { var _containsWith = __webpack_require__ ( 32 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var _filter = __webpack_require__ ( 54 ) ; var innerJoin = _curry3 ( function innerJoin ( pred , xs , ys ) { return _filter ( function ( x ) { return _containsWith ( pred , x , ys ) ; } , xs ) ; } ) ; module . exports = innerJoin ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var insert = _curry3 ( function insert ( idx , elt , list ) { idx = idx < list . length && idx >= 0 ? idx : list . length ; var result = Array . prototype . slice . call ( list , 0 ) ; result . splice ( idx , 0 , elt ) ; return result ; } ) ; module . exports = insert ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var insertAll = _curry3 ( function insertAll ( idx , elts , list ) { idx = idx < list . length && idx >= 0 ? idx : list . length ; return [ ] . concat ( Array . prototype . slice . call ( list , 0 , idx ) , elts , Array . prototype . slice . call ( list , idx ) ) ; } ) ; module . exports = insertAll ; } 
function ( module , exports ) { function _aperture ( n , list ) { var idx = 0 ; var limit = list . length - ( n - 1 ) ; var acc = new Array ( limit >= 0 ? limit : 0 ) ; while ( idx < limit ) { acc [ idx ] = Array . prototype . slice . call ( list , idx , idx + n ) ; idx += 1 ; } return acc ; } module . exports = _aperture ; } 
function ( module , exports ) { function _arrayFromIterator ( iter ) { var list = [ ] ; var next ; while ( ! ( next = iter . next ( ) ) . done ) { list . push ( next . value ) ; } return list ; } module . exports = _arrayFromIterator ; } 
function ( module , exports , __webpack_require__ ) { var take = __webpack_require__ ( 62 ) ; function dropLast ( n , xs ) { return take ( n < xs . length ? xs . length - n : 0 , xs ) ; } module . exports = dropLast ; } 
function ( module , exports , __webpack_require__ ) { var slice = __webpack_require__ ( 13 ) ; function dropLastWhile ( pred , xs ) { var idx = xs . length - 1 ; while ( idx >= 0 && pred ( xs [ idx ] ) ) { idx -= 1 ; } return slice ( 0 , idx + 1 , xs ) ; } module . exports = dropLastWhile ; } 
function ( module , exports , __webpack_require__ ) { var _arrayFromIterator = __webpack_require__ ( 316 ) ; var _containsWith = __webpack_require__ ( 32 ) ; var _functionName = __webpack_require__ ( 322 ) ; var _has = __webpack_require__ ( 8 ) ; var identical = __webpack_require__ ( 202 ) ; var keys = __webpack_require__ ( 15 ) ; var type = __webpack_require__ ( 63 ) ; function _uniqContentEquals ( aIterator , bIterator , stackA , stackB ) { var a = _arrayFromIterator ( aIterator ) ; var b = _arrayFromIterator ( bIterator ) ; function eq ( _a , _b ) { return _equals ( _a , _b , stackA . slice ( ) , stackB . slice ( ) ) ; } 
function _uniqContentEquals ( aIterator , bIterator , stackA , stackB ) { var a = _arrayFromIterator ( aIterator ) ; var b = _arrayFromIterator ( bIterator ) ; function eq ( _a , _b ) { return _equals ( _a , _b , stackA . slice ( ) , stackB . slice ( ) ) ; } 
function ( module , exports , __webpack_require__ ) { var _forceReduced = __webpack_require__ ( 321 ) ; var _isArrayLike = __webpack_require__ ( 34 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var preservingReduced = function ( xf ) { return { '@@transducer/init' : _xfBase . init , '@@transducer/result' : function ( result ) { return xf [ '@@transducer/result' ] ( result ) ; } , '@@transducer/step' : function ( result , input ) { var ret = xf [ '@@transducer/step' ] ( result , input ) ; return ret [ '@@transducer/reduced' ] ? _forceReduced ( ret ) : ret ; } } ; } ; var _flatCat = function _xcat ( xf ) { var rxf = preservingReduced ( xf ) ; return { '@@transducer/init' : _xfBase . init , '@@transducer/result' : function ( result ) { return rxf [ '@@transducer/result' ] ( result ) ; } , '@@transducer/step' : function ( result , input ) { return ! _isArrayLike ( input ) ? _reduce ( rxf , result , [ input ] ) : _reduce ( rxf , result , input ) ; } } ; } ; module . exports = _flatCat ; } 
function ( module , exports ) { function _functionName ( f ) { 
function ( module , exports ) { function _isRegExp ( x ) { return Object . prototype . toString . call ( x ) === '[object RegExp]' ; } module . exports = _isRegExp ; } 
function ( module , exports , __webpack_require__ ) { var _has = __webpack_require__ ( 8 ) ; 
function ( module , exports ) { function _pipe ( f , g ) { return function ( ) { return g . call ( this , f . apply ( this , arguments ) ) ; } ; } module . exports = _pipe ; } 
function ( module , exports ) { function _pipeP ( f , g ) { return function ( ) { var ctx = this ; return f . apply ( ctx , arguments ) . then ( function ( x ) { return g . call ( ctx , x ) ; } ) ; } ; } module . exports = _pipeP ; } 
function ( module , exports ) { function _quote ( s ) { var escaped = s . replace ( / \\ / g , '\\\\' ) . replace ( / [\b] / g , '\\b' ) 
function ( module , exports , __webpack_require__ ) { var _assign = __webpack_require__ ( 53 ) ; var _identity = __webpack_require__ ( 55 ) ; var _isArrayLike = __webpack_require__ ( 34 ) ; var _isTransformer = __webpack_require__ ( 58 ) ; var objOf = __webpack_require__ ( 224 ) ; var _stepCatArray = { '@@transducer/init' : Array , '@@transducer/step' : function ( xs , x ) { xs . push ( x ) ; return xs ; } , '@@transducer/result' : _identity } ; var _stepCatString = { '@@transducer/init' : String , '@@transducer/step' : function ( a , b ) { return a + b ; } , '@@transducer/result' : _identity } ; var _stepCatObject = { '@@transducer/init' : Object , '@@transducer/step' : function ( result , input ) { return _assign ( result , _isArrayLike ( input ) ? objOf ( input [ 0 ] , input [ 1 ] ) : input ) ; } , '@@transducer/result' : _identity } ; function _stepCat ( obj ) { if ( _isTransformer ( obj ) ) { return obj ; } if ( _isArrayLike ( obj ) ) { return _stepCatArray ; } if ( typeof obj === 'string' ) { return _stepCatString ; } if ( typeof obj === 'object' ) { return _stepCatObject ; } throw new Error ( 'Cannot create transformer for ' + obj ) ; } module . exports = _stepCat ; } 
function ( module , exports ) { var pad = function pad ( n ) { return ( n < 10 ? '0' : '' ) + n ; } ; var _toISOString = typeof Date . prototype . toISOString === 'function' ? function _toISOString ( d ) { return d . toISOString ( ) ; } : function _toISOString ( d ) { return d . getUTCFullYear ( ) + '-' + pad ( d . getUTCMonth ( ) + 1 ) + '-' + pad ( d . getUTCDate ( ) ) + 'T' + pad ( d . getUTCHours ( ) ) + ':' + pad ( d . getUTCMinutes ( ) ) + ':' + pad ( d . getUTCSeconds ( ) ) + '.' + ( d . getUTCMilliseconds ( ) / 1000 ) . toFixed ( 3 ) . slice ( 2 , 5 ) + 'Z' ; } ; module . exports = _toISOString ; } 
function ( module , exports , __webpack_require__ ) { var _contains = __webpack_require__ ( 20 ) ; var _map = __webpack_require__ ( 37 ) ; var _quote = __webpack_require__ ( 328 ) ; var _toISOString = __webpack_require__ ( 330 ) ; var keys = __webpack_require__ ( 15 ) ; var reject = __webpack_require__ ( 43 ) ; function _toString ( x , seen ) { var recur = function recur ( y ) { var xs = seen . concat ( [ x ] ) ; return _contains ( y , xs ) ? '<Circular>' : _toString ( y , xs ) ; } ; 
function ( obj , keys ) { return _map ( function ( k ) { return _quote ( k ) + ': ' + recur ( obj [ k ] ) ; } , keys . slice ( ) . sort ( ) ) ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XAll = function ( ) { function XAll ( f , xf ) { this . xf = xf ; this . f = f ; this . all = true ; } XAll . prototype [ '@@transducer/init' ] = _xfBase . init ; XAll . prototype [ '@@transducer/result' ] = function ( result ) { if ( this . all ) { result = this . xf [ '@@transducer/step' ] ( result , true ) ; } return this . xf [ '@@transducer/result' ] ( result ) ; } ; XAll . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( ! this . f ( input ) ) { this . all = false ; result = _reduced ( this . xf [ '@@transducer/step' ] ( result , false ) ) ; } return result ; } ; return XAll ; } ( ) ; var _xall = _curry2 ( function _xall ( f , xf ) { return new XAll ( f , xf ) ; } ) ; module . exports = _xall ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XAperture = function ( ) { function XAperture ( n , xf ) { this . xf = xf ; this . pos = 0 ; this . full = false ; this . acc = new Array ( n ) ; } XAperture . prototype [ '@@transducer/init' ] = _xfBase . init ; XAperture . prototype [ '@@transducer/result' ] = function ( result ) { this . acc = null ; return this . xf [ '@@transducer/result' ] ( result ) ; } ; XAperture . prototype [ '@@transducer/step' ] = function ( result , input ) { this . store ( input ) ; return this . full ? this . xf [ '@@transducer/step' ] ( result , this . getCopy ( ) ) : result ; } ; XAperture . prototype . store = function ( input ) { this . acc [ this . pos ] = input ; this . pos += 1 ; if ( this . pos === this . acc . length ) { this . pos = 0 ; this . full = true ; } } ; XAperture . prototype . getCopy = function ( ) { return _concat ( Array . prototype . slice . call ( this . acc , this . pos ) , Array . prototype . slice . call ( this . acc , 0 , this . pos ) ) ; } ; return XAperture ; } ( ) ; var _xaperture = _curry2 ( function _xaperture ( n , xf ) { return new XAperture ( n , xf ) ; } ) ; module . exports = _xaperture ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _flatCat = __webpack_require__ ( 320 ) ; var map = __webpack_require__ ( 9 ) ; var _xchain = _curry2 ( function _xchain ( f , xf ) { return map ( f , _flatCat ( xf ) ) ; } ) ; module . exports = _xchain ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XDrop = function ( ) { function XDrop ( n , xf ) { this . xf = xf ; this . n = n ; } XDrop . prototype [ '@@transducer/init' ] = _xfBase . init ; XDrop . prototype [ '@@transducer/result' ] = _xfBase . result ; XDrop . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . n > 0 ) { this . n -= 1 ; return result ; } return this . xf [ '@@transducer/step' ] ( result , input ) ; } ; return XDrop ; } ( ) ; var _xdrop = _curry2 ( function _xdrop ( n , xf ) { return new XDrop ( n , xf ) ; } ) ; module . exports = _xdrop ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XDropLast = function ( ) { function XDropLast ( n , xf ) { this . xf = xf ; this . pos = 0 ; this . full = false ; this . acc = new Array ( n ) ; } XDropLast . prototype [ '@@transducer/init' ] = _xfBase . init ; XDropLast . prototype [ '@@transducer/result' ] = function ( result ) { this . acc = null ; return this . xf [ '@@transducer/result' ] ( result ) ; } ; XDropLast . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . full ) { result = this . xf [ '@@transducer/step' ] ( result , this . acc [ this . pos ] ) ; } this . store ( input ) ; return result ; } ; XDropLast . prototype . store = function ( input ) { this . acc [ this . pos ] = input ; this . pos += 1 ; if ( this . pos === this . acc . length ) { this . pos = 0 ; this . full = true ; } } ; return XDropLast ; } ( ) ; var _xdropLast = _curry2 ( function _xdropLast ( n , xf ) { return new XDropLast ( n , xf ) ; } ) ; module . exports = _xdropLast ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XDropLastWhile = function ( ) { function XDropLastWhile ( fn , xf ) { this . f = fn ; this . retained = [ ] ; this . xf = xf ; } XDropLastWhile . prototype [ '@@transducer/init' ] = _xfBase . init ; XDropLastWhile . prototype [ '@@transducer/result' ] = function ( result ) { this . retained = null ; return this . xf [ '@@transducer/result' ] ( result ) ; } ; XDropLastWhile . prototype [ '@@transducer/step' ] = function ( result , input ) { return this . f ( input ) ? this . retain ( result , input ) : this . flush ( result , input ) ; } ; XDropLastWhile . prototype . flush = function ( result , input ) { result = _reduce ( this . xf [ '@@transducer/step' ] , result , this . retained ) ; this . retained = [ ] ; return this . xf [ '@@transducer/step' ] ( result , input ) ; } ; XDropLastWhile . prototype . retain = function ( result , input ) { this . retained . push ( input ) ; return result ; } ; return XDropLastWhile ; } ( ) ; var _xdropLastWhile = _curry2 ( function _xdropLastWhile ( fn , xf ) { return new XDropLastWhile ( fn , xf ) ; } ) ; module . exports = _xdropLastWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XDropWhile = function ( ) { function XDropWhile ( f , xf ) { this . xf = xf ; this . f = f ; } XDropWhile . prototype [ '@@transducer/init' ] = _xfBase . init ; XDropWhile . prototype [ '@@transducer/result' ] = _xfBase . result ; XDropWhile . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . f ) { if ( this . f ( input ) ) { return result ; } this . f = null ; } return this . xf [ '@@transducer/step' ] ( result , input ) ; } ; return XDropWhile ; } ( ) ; var _xdropWhile = _curry2 ( function _xdropWhile ( f , xf ) { return new XDropWhile ( f , xf ) ; } ) ; module . exports = _xdropWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XFilter = function ( ) { function XFilter ( f , xf ) { this . xf = xf ; this . f = f ; } XFilter . prototype [ '@@transducer/init' ] = _xfBase . init ; XFilter . prototype [ '@@transducer/result' ] = _xfBase . result ; XFilter . prototype [ '@@transducer/step' ] = function ( result , input ) { return this . f ( input ) ? this . xf [ '@@transducer/step' ] ( result , input ) : result ; } ; return XFilter ; } ( ) ; var _xfilter = _curry2 ( function _xfilter ( f , xf ) { return new XFilter ( f , xf ) ; } ) ; module . exports = _xfilter ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XFind = function ( ) { function XFind ( f , xf ) { this . xf = xf ; this . f = f ; this . found = false ; } XFind . prototype [ '@@transducer/init' ] = _xfBase . init ; XFind . prototype [ '@@transducer/result' ] = function ( result ) { if ( ! this . found ) { result = this . xf [ '@@transducer/step' ] ( result , void 0 ) ; } return this . xf [ '@@transducer/result' ] ( result ) ; } ; XFind . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . f ( input ) ) { this . found = true ; result = _reduced ( this . xf [ '@@transducer/step' ] ( result , input ) ) ; } return result ; } ; return XFind ; } ( ) ; var _xfind = _curry2 ( function _xfind ( f , xf ) { return new XFind ( f , xf ) ; } ) ; module . exports = _xfind ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XFindIndex = function ( ) { function XFindIndex ( f , xf ) { this . xf = xf ; this . f = f ; this . idx = - 1 ; this . found = false ; } XFindIndex . prototype [ '@@transducer/init' ] = _xfBase . init ; XFindIndex . prototype [ '@@transducer/result' ] = function ( result ) { if ( ! this . found ) { result = this . xf [ '@@transducer/step' ] ( result , - 1 ) ; } return this . xf [ '@@transducer/result' ] ( result ) ; } ; XFindIndex . prototype [ '@@transducer/step' ] = function ( result , input ) { this . idx += 1 ; if ( this . f ( input ) ) { this . found = true ; result = _reduced ( this . xf [ '@@transducer/step' ] ( result , this . idx ) ) ; } return result ; } ; return XFindIndex ; } ( ) ; var _xfindIndex = _curry2 ( function _xfindIndex ( f , xf ) { return new XFindIndex ( f , xf ) ; } ) ; module . exports = _xfindIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XFindLast = function ( ) { function XFindLast ( f , xf ) { this . xf = xf ; this . f = f ; } XFindLast . prototype [ '@@transducer/init' ] = _xfBase . init ; XFindLast . prototype [ '@@transducer/result' ] = function ( result ) { return this . xf [ '@@transducer/result' ] ( this . xf [ '@@transducer/step' ] ( result , this . last ) ) ; } ; XFindLast . prototype [ '@@transducer/step' ] = function ( result , input ) { if ( this . f ( input ) ) { this . last = input ; } return result ; } ; return XFindLast ; } ( ) ; var _xfindLast = _curry2 ( function _xfindLast ( f , xf ) { return new XFindLast ( f , xf ) ; } ) ; module . exports = _xfindLast ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XFindLastIndex = function ( ) { function XFindLastIndex ( f , xf ) { this . xf = xf ; this . f = f ; this . idx = - 1 ; this . lastIdx = - 1 ; } XFindLastIndex . prototype [ '@@transducer/init' ] = _xfBase . init ; XFindLastIndex . prototype [ '@@transducer/result' ] = function ( result ) { return this . xf [ '@@transducer/result' ] ( this . xf [ '@@transducer/step' ] ( result , this . lastIdx ) ) ; } ; XFindLastIndex . prototype [ '@@transducer/step' ] = function ( result , input ) { this . idx += 1 ; if ( this . f ( input ) ) { this . lastIdx = this . idx ; } return result ; } ; return XFindLastIndex ; } ( ) ; var _xfindLastIndex = _curry2 ( function _xfindLastIndex ( f , xf ) { return new XFindLastIndex ( f , xf ) ; } ) ; module . exports = _xfindLastIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XMap = function ( ) { function XMap ( f , xf ) { this . xf = xf ; this . f = f ; } XMap . prototype [ '@@transducer/init' ] = _xfBase . init ; XMap . prototype [ '@@transducer/result' ] = _xfBase . result ; XMap . prototype [ '@@transducer/step' ] = function ( result , input ) { return this . xf [ '@@transducer/step' ] ( result , this . f ( input ) ) ; } ; return XMap ; } ( ) ; var _xmap = _curry2 ( function _xmap ( f , xf ) { return new XMap ( f , xf ) ; } ) ; module . exports = _xmap ; } 
function ( module , exports , __webpack_require__ ) { var _curryN = __webpack_require__ ( 33 ) ; var _has = __webpack_require__ ( 8 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XReduceBy = function ( ) { function XReduceBy ( valueFn , valueAcc , keyFn , xf ) { this . valueFn = valueFn ; this . valueAcc = valueAcc ; this . keyFn = keyFn ; this . xf = xf ; this . inputs = { } ; } XReduceBy . prototype [ '@@transducer/init' ] = _xfBase . init ; XReduceBy . prototype [ '@@transducer/result' ] = function ( result ) { var key ; for ( key in this . inputs ) { if ( _has ( key , this . inputs ) ) { result = this . xf [ '@@transducer/step' ] ( result , this . inputs [ key ] ) ; if ( result [ '@@transducer/reduced' ] ) { result = result [ '@@transducer/value' ] ; break ; } } } this . inputs = null ; return this . xf [ '@@transducer/result' ] ( result ) ; } ; XReduceBy . prototype [ '@@transducer/step' ] = function ( result , input ) { var key = this . keyFn ( input ) ; this . inputs [ key ] = this . inputs [ key ] || [ key , this . valueAcc ] ; this . inputs [ key ] [ 1 ] = this . valueFn ( this . inputs [ key ] [ 1 ] , input ) ; return result ; } ; return XReduceBy ; } ( ) ; var _xreduceBy = _curryN ( 4 , [ ] , function _xreduceBy ( valueFn , valueAcc , keyFn , xf ) { return new XReduceBy ( valueFn , valueAcc , keyFn , xf ) ; } ) ; module . exports = _xreduceBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XTake = function ( ) { function XTake ( n , xf ) { this . xf = xf ; this . n = n ; this . i = 0 ; } XTake . prototype [ '@@transducer/init' ] = _xfBase . init ; XTake . prototype [ '@@transducer/result' ] = _xfBase . result ; XTake . prototype [ '@@transducer/step' ] = function ( result , input ) { this . i += 1 ; var ret = this . n === 0 ? result : this . xf [ '@@transducer/step' ] ( result , input ) ; return this . n >= 0 && this . i >= this . n ? _reduced ( ret ) : ret ; } ; return XTake ; } ( ) ; var _xtake = _curry2 ( function _xtake ( n , xf ) { return new XTake ( n , xf ) ; } ) ; module . exports = _xtake ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduced = __webpack_require__ ( 18 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XTakeWhile = function ( ) { function XTakeWhile ( f , xf ) { this . xf = xf ; this . f = f ; } XTakeWhile . prototype [ '@@transducer/init' ] = _xfBase . init ; XTakeWhile . prototype [ '@@transducer/result' ] = _xfBase . result ; XTakeWhile . prototype [ '@@transducer/step' ] = function ( result , input ) { return this . f ( input ) ? this . xf [ '@@transducer/step' ] ( result , input ) : _reduced ( result ) ; } ; return XTakeWhile ; } ( ) ; var _xtakeWhile = _curry2 ( function _xtakeWhile ( f , xf ) { return new XTakeWhile ( f , xf ) ; } ) ; module . exports = _xtakeWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _xfBase = __webpack_require__ ( 6 ) ; var XTap = function ( ) { function XTap ( f , xf ) { this . xf = xf ; this . f = f ; } XTap . prototype [ '@@transducer/init' ] = _xfBase . init ; XTap . prototype [ '@@transducer/result' ] = _xfBase . result ; XTap . prototype [ '@@transducer/step' ] = function ( result , input ) { this . f ( input ) ; return this . xf [ '@@transducer/step' ] ( result , input ) ; } ; return XTap ; } ( ) ; var _xtap = _curry2 ( function _xtap ( f , xf ) { return new XTap ( f , xf ) ; } ) ; module . exports = _xtap ; } 
function ( module , exports , __webpack_require__ ) { var _contains = __webpack_require__ ( 20 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _filter = __webpack_require__ ( 54 ) ; var flip = __webpack_require__ ( 31 ) ; var uniq = __webpack_require__ ( 64 ) ; var intersection = _curry2 ( function intersection ( list1 , list2 ) { var lookupList , filteredList ; if ( list1 . length > list2 . length ) { lookupList = list1 ; filteredList = list2 ; } else { lookupList = list2 ; filteredList = list1 ; } return uniq ( _filter ( flip ( _contains ) ( lookupList ) , filteredList ) ) ; } ) ; module . exports = intersection ; } 
function ( module , exports , __webpack_require__ ) { var _checkForMethod = __webpack_require__ ( 23 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var intersperse = _curry2 ( _checkForMethod ( 'intersperse' , function intersperse ( separator , list ) { var out = [ ] ; var idx = 0 ; var length = list . length ; while ( idx < length ) { if ( idx === length - 1 ) { out . push ( list [ idx ] ) ; } else { out . push ( list [ idx ] , separator ) ; } idx += 1 ; } return out ; } ) ) ; module . exports = intersperse ; } 
function ( module , exports , __webpack_require__ ) { var _clone = __webpack_require__ ( 203 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var _isTransformer = __webpack_require__ ( 58 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _stepCat = __webpack_require__ ( 329 ) ; var into = _curry3 ( function into ( acc , xf , list ) { return _isTransformer ( acc ) ? _reduce ( xf ( acc ) , acc [ '@@transducer/init' ] ( ) , list ) : _reduce ( xf ( _stepCat ( acc ) ) , _clone ( acc , [ ] , [ ] , false ) , list ) ; } ) ; module . exports = into ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _has = __webpack_require__ ( 8 ) ; var keys = __webpack_require__ ( 15 ) ; var invert = _curry1 ( function invert ( obj ) { var props = keys ( obj ) ; var len = props . length ; var idx = 0 ; var out = { } ; while ( idx < len ) { var key = props [ idx ] ; var val = obj [ key ] ; var list = _has ( val , out ) ? out [ val ] : out [ val ] = [ ] ; list [ list . length ] = key ; idx += 1 ; } return out ; } ) ; module . exports = invert ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var keys = __webpack_require__ ( 15 ) ; var invertObj = _curry1 ( function invertObj ( obj ) { var props = keys ( obj ) ; var len = props . length ; var idx = 0 ; var out = { } ; while ( idx < len ) { var key = props [ idx ] ; out [ obj [ key ] ] = key ; idx += 1 ; } return out ; } ) ; module . exports = invertObj ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var empty = __webpack_require__ ( 201 ) ; var equals = __webpack_require__ ( 10 ) ; var isEmpty = _curry1 ( function isEmpty ( x ) { return x != null && equals ( x , empty ( x ) ) ; } ) ; module . exports = isEmpty ; } 
function ( module , exports , __webpack_require__ ) { var invoker = __webpack_require__ ( 25 ) ; var join = invoker ( 1 , 'join' ) ; module . exports = join ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var keysIn = _curry1 ( function keysIn ( obj ) { var prop ; var ks = [ ] ; for ( prop in obj ) { ks [ ks . length ] = prop ; } return ks ; } ) ; module . exports = keysIn ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isArray = __webpack_require__ ( 17 ) ; var equals = __webpack_require__ ( 10 ) ; var lastIndexOf = _curry2 ( function lastIndexOf ( target , xs ) { if ( typeof xs . lastIndexOf === 'function' && ! _isArray ( xs ) ) { return xs . lastIndexOf ( target ) ; } else { var idx = xs . length - 1 ; while ( idx >= 0 ) { if ( equals ( xs [ idx ] , target ) ) { return idx ; } idx -= 1 ; } return - 1 ; } } ) ; module . exports = lastIndexOf ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var lens = __webpack_require__ ( 38 ) ; var nth = __webpack_require__ ( 26 ) ; var update = __webpack_require__ ( 65 ) ; var lensIndex = _curry1 ( function lensIndex ( n ) { return lens ( nth ( n ) , update ( n ) ) ; } ) ; module . exports = lensIndex ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var assocPath = __webpack_require__ ( 190 ) ; var lens = __webpack_require__ ( 38 ) ; var path = __webpack_require__ ( 22 ) ; var lensPath = _curry1 ( function lensPath ( p ) { return lens ( path ( p ) , assocPath ( p ) ) ; } ) ; module . exports = lensPath ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var assoc = __webpack_require__ ( 30 ) ; var lens = __webpack_require__ ( 38 ) ; var prop = __webpack_require__ ( 60 ) ; var lensProp = _curry1 ( function lensProp ( k ) { return lens ( prop ( k ) , assoc ( k ) ) ; } ) ; module . exports = lensProp ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var lt = _curry2 ( function lt ( a , b ) { return a < b ; } ) ; module . exports = lt ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var lte = _curry2 ( function lte ( a , b ) { return a <= b ; } ) ; module . exports = lte ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var mapAccum = _curry3 ( function mapAccum ( fn , acc , list ) { var idx = 0 ; var len = list . length ; var result = [ ] ; var tuple = [ acc ] ; while ( idx < len ) { tuple = fn ( tuple [ 0 ] , list [ idx ] ) ; result [ idx ] = tuple [ 1 ] ; idx += 1 ; } return [ tuple [ 0 ] , result ] ; } ) ; module . exports = mapAccum ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var mapAccumRight = _curry3 ( function mapAccumRight ( fn , acc , list ) { var idx = list . length - 1 ; var result = [ ] ; var tuple = [ acc ] ; while ( idx >= 0 ) { tuple = fn ( list [ idx ] , tuple [ 0 ] ) ; result [ idx ] = tuple [ 1 ] ; idx -= 1 ; } return [ result , tuple [ 0 ] ] ; } ) ; module . exports = mapAccumRight ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _reduce = __webpack_require__ ( 11 ) ; var keys = __webpack_require__ ( 15 ) ; var mapObjIndexed = _curry2 ( function mapObjIndexed ( fn , obj ) { return _reduce ( function ( acc , key ) { acc [ key ] = fn ( obj [ key ] , key , obj ) ; return acc ; } , { } , keys ( obj ) ) ; } ) ; module . exports = mapObjIndexed ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var match = _curry2 ( function match ( rx , str ) { return str . match ( rx ) || [ ] ; } ) ; module . exports = match ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isInteger = __webpack_require__ ( 56 ) ; var mathMod = _curry2 ( function mathMod ( m , p ) { if ( ! _isInteger ( m ) ) { return NaN ; } if ( ! _isInteger ( p ) || p < 1 ) { return NaN ; } return ( m % p + p ) % p ; } ) ; module . exports = mathMod ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var maxBy = _curry3 ( function maxBy ( f , a , b ) { return f ( b ) > f ( a ) ? b : a ; } ) ; module . exports = maxBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var mean = __webpack_require__ ( 220 ) ; var median = _curry1 ( function median ( list ) { var len = list . length ; if ( len === 0 ) { return NaN ; } var width = 2 - len % 2 ; var idx = ( len - width ) / 2 ; return mean ( Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { return a < b ? - 1 : a > b ? 1 : 0 ; } ) . slice ( idx , idx + width ) ) ; } ) ; module . exports = median ; } 
function ( module , exports , __webpack_require__ ) { var memoizeWith = __webpack_require__ ( 221 ) ; var toString = __webpack_require__ ( 28 ) ; var memoize = memoizeWith ( function ( ) { return toString ( arguments ) ; } ) ; module . exports = memoize ; } 
function ( module , exports , __webpack_require__ ) { var _assign = __webpack_require__ ( 53 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var merge = _curry2 ( function merge ( l , r ) { return _assign ( { } , l , r ) ; } ) ; module . exports = merge ; } 
function ( module , exports , __webpack_require__ ) { var _assign = __webpack_require__ ( 53 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var mergeAll = _curry1 ( function mergeAll ( list ) { return _assign . apply ( null , [ { } ] . concat ( list ) ) ; } ) ; module . exports = mergeAll ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var mergeDeepWithKey = __webpack_require__ ( 40 ) ; var mergeDeepLeft = _curry2 ( function mergeDeepLeft ( lObj , rObj ) { return mergeDeepWithKey ( function ( k , lVal , rVal ) { return lVal ; } , lObj , rObj ) ; } ) ; module . exports = mergeDeepLeft ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var mergeDeepWithKey = __webpack_require__ ( 40 ) ; var mergeDeepRight = _curry2 ( function mergeDeepRight ( lObj , rObj ) { return mergeDeepWithKey ( function ( k , lVal , rVal ) { return rVal ; } , lObj , rObj ) ; } ) ; module . exports = mergeDeepRight ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var mergeDeepWithKey = __webpack_require__ ( 40 ) ; var mergeDeepWith = _curry3 ( function mergeDeepWith ( fn , lObj , rObj ) { return mergeDeepWithKey ( function ( k , lVal , rVal ) { return fn ( lVal , rVal ) ; } , lObj , rObj ) ; } ) ; module . exports = mergeDeepWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var mergeWithKey = __webpack_require__ ( 59 ) ; var mergeWith = _curry3 ( function mergeWith ( fn , l , r ) { return mergeWithKey ( function ( _ , _l , _r ) { return fn ( _l , _r ) ; } , l , r ) ; } ) ; module . exports = mergeWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var min = _curry2 ( function min ( a , b ) { return b < a ? b : a ; } ) ; module . exports = min ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var minBy = _curry3 ( function minBy ( f , a , b ) { return f ( b ) < f ( a ) ? b : a ; } ) ; module . exports = minBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var modulo = _curry2 ( function modulo ( a , b ) { return a % b ; } ) ; module . exports = modulo ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var negate = _curry1 ( function negate ( n ) { return - n ; } ) ; module . exports = negate ; } 
function ( module , exports , __webpack_require__ ) { var _complement = __webpack_require__ ( 205 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xany = __webpack_require__ ( 211 ) ; var any = __webpack_require__ ( 188 ) ; var none = _curry2 ( _complement ( _dispatchable ( [ 'any' ] , _xany , any ) ) ) ; module . exports = none ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var curryN = __webpack_require__ ( 7 ) ; var nth = __webpack_require__ ( 26 ) ; var nthArg = _curry1 ( function nthArg ( n ) { var arity = n < 0 ? 1 : n + 1 ; return curryN ( arity , function ( ) { return nth ( n , arguments ) ; } ) ; } ) ; module . exports = nthArg ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var o = _curry3 ( function o ( f , g , x ) { return f ( g ( x ) ) ; } ) ; module . exports = o ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _of = __webpack_require__ ( 325 ) ; var of = _curry1 ( _of ) ; module . exports = of ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var omit = _curry2 ( function omit ( names , obj ) { var result = { } ; var index = { } ; var idx = 0 ; var len = names . length ; while ( idx < len ) { index [ names [ idx ] ] = 1 ; idx += 1 ; } for ( var prop in obj ) { if ( ! index . hasOwnProperty ( prop ) ) { result [ prop ] = obj [ prop ] ; } } return result ; } ) ; module . exports = omit ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _curry1 = __webpack_require__ ( 3 ) ; var once = _curry1 ( function once ( fn ) { var called = false ; var result ; return _arity ( fn . length , function ( ) { if ( called ) { return result ; } called = true ; result = fn . apply ( this , arguments ) ; return result ; } ) ; } ) ; module . exports = once ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var pair = _curry2 ( function pair ( fst , snd ) { return [ fst , snd ] ; } ) ; module . exports = pair ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _createPartialApplicator = __webpack_require__ ( 206 ) ; var partial = _createPartialApplicator ( _concat ) ; module . exports = partial ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _createPartialApplicator = __webpack_require__ ( 206 ) ; var flip = __webpack_require__ ( 31 ) ; var partialRight = _createPartialApplicator ( flip ( _concat ) ) ; module . exports = partialRight ; } 
function ( module , exports , __webpack_require__ ) { var filter = __webpack_require__ ( 51 ) ; var juxt = __webpack_require__ ( 216 ) ; var reject = __webpack_require__ ( 43 ) ; var partition = juxt ( [ filter , reject ] ) ; module . exports = partition ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var equals = __webpack_require__ ( 10 ) ; var path = __webpack_require__ ( 22 ) ; var pathEq = _curry3 ( function pathEq ( _path , val , obj ) { return equals ( path ( _path , obj ) , val ) ; } ) ; module . exports = pathEq ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var defaultTo = __webpack_require__ ( 195 ) ; var path = __webpack_require__ ( 22 ) ; var pathOr = _curry3 ( function pathOr ( d , p , obj ) { return defaultTo ( d , path ( p , obj ) ) ; } ) ; module . exports = pathOr ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var path = __webpack_require__ ( 22 ) ; var pathSatisfies = _curry3 ( function pathSatisfies ( pred , propPath , obj ) { return propPath . length > 0 && pred ( path ( propPath , obj ) ) ; } ) ; module . exports = pathSatisfies ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var pick = _curry2 ( function pick ( names , obj ) { var result = { } ; var idx = 0 ; while ( idx < names . length ) { if ( names [ idx ] in obj ) { result [ names [ idx ] ] = obj [ names [ idx ] ] ; } idx += 1 ; } return result ; } ) ; module . exports = pick ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var pickBy = _curry2 ( function pickBy ( test , obj ) { var result = { } ; for ( var prop in obj ) { if ( test ( obj [ prop ] , prop , obj ) ) { result [ prop ] = obj [ prop ] ; } } return result ; } ) ; module . exports = pickBy ; } 
function ( module , exports , __webpack_require__ ) { var composeK = __webpack_require__ ( 192 ) ; var reverse = __webpack_require__ ( 44 ) ; function pipeK ( ) { if ( arguments . length === 0 ) { throw new Error ( 'pipeK requires at least one argument' ) ; } return composeK . apply ( this , reverse ( arguments ) ) ; } module . exports = pipeK ; } 
function ( module , exports , __webpack_require__ ) { var multiply = __webpack_require__ ( 222 ) ; var reduce = __webpack_require__ ( 16 ) ; var product = reduce ( multiply , 1 ) ; module . exports = product ; } 
function ( module , exports , __webpack_require__ ) { var _map = __webpack_require__ ( 37 ) ; var identity = __webpack_require__ ( 52 ) ; var pickAll = __webpack_require__ ( 227 ) ; var useWith = __webpack_require__ ( 239 ) ; var project = useWith ( _map , [ pickAll , identity ] ) ; 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var equals = __webpack_require__ ( 10 ) ; var propEq = _curry3 ( function propEq ( name , val , obj ) { return equals ( val , obj [ name ] ) ; } ) ; module . exports = propEq ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var is = __webpack_require__ ( 214 ) ; var propIs = _curry3 ( function propIs ( type , name , obj ) { return is ( type , obj [ name ] ) ; } ) ; module . exports = propIs ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var _has = __webpack_require__ ( 8 ) ; var propOr = _curry3 ( function propOr ( val , p , obj ) { return obj != null && _has ( p , obj ) ? obj [ p ] : val ; } ) ; module . exports = propOr ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var propSatisfies = _curry3 ( function propSatisfies ( pred , name , obj ) { return pred ( obj [ name ] ) ; } ) ; module . exports = propSatisfies ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var props = _curry2 ( function props ( ps , obj ) { var len = ps . length ; var out = [ ] ; var idx = 0 ; while ( idx < len ) { out [ idx ] = obj [ ps [ idx ] ] ; idx += 1 ; } return out ; } ) ; module . exports = props ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _isNumber = __webpack_require__ ( 209 ) ; var range = _curry2 ( function range ( from , to ) { if ( ! ( _isNumber ( from ) && _isNumber ( to ) ) ) { throw new TypeError ( 'Both arguments to range must be numbers' ) ; } var result = [ ] ; var n = from ; while ( n < to ) { result . push ( n ) ; n += 1 ; } return result ; } ) ; module . exports = range ; } 
function ( module , exports , __webpack_require__ ) { var _curryN = __webpack_require__ ( 33 ) ; var _reduce = __webpack_require__ ( 11 ) ; var _reduced = __webpack_require__ ( 18 ) ; var reduceWhile = _curryN ( 4 , [ ] , function _reduceWhile ( pred , fn , a , list ) { return _reduce ( function ( acc , x ) { return pred ( acc , x ) ? fn ( acc , x ) : _reduced ( acc ) ; } , a , list ) ; } ) ; module . exports = reduceWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _reduced = __webpack_require__ ( 18 ) ; var reduced = _curry1 ( _reduced ) ; module . exports = reduced ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var always = __webpack_require__ ( 19 ) ; var times = __webpack_require__ ( 236 ) ; var repeat = _curry2 ( function repeat ( value , n ) { return times ( always ( value ) , n ) ; } ) ; module . exports = repeat ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var replace = _curry3 ( function replace ( regex , replacement , str ) { return str . replace ( regex , replacement ) ; } ) ; module . exports = replace ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var scan = _curry3 ( function scan ( fn , acc , list ) { var idx = 0 ; var len = list . length ; var result = [ acc ] ; while ( idx < len ) { acc = fn ( acc , list [ idx ] ) ; result [ idx + 1 ] = acc ; idx += 1 ; } return result ; } ) ; module . exports = scan ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var always = __webpack_require__ ( 19 ) ; var over = __webpack_require__ ( 226 ) ; var set = _curry3 ( function set ( lens , v , x ) { return over ( lens , always ( v ) , x ) ; } ) ; module . exports = set ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var sort = _curry2 ( function sort ( comparator , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( comparator ) ; } ) ; module . exports = sort ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var sortBy = _curry2 ( function sortBy ( fn , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { var aa = fn ( a ) ; var bb = fn ( b ) ; return aa < bb ? - 1 : aa > bb ? 1 : 0 ; } ) ; } ) ; module . exports = sortBy ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var sortWith = _curry2 ( function sortWith ( fns , list ) { return Array . prototype . slice . call ( list , 0 ) . sort ( function ( a , b ) { var result = 0 ; var i = 0 ; while ( result === 0 && i < fns . length ) { result = fns [ i ] ( a , b ) ; i += 1 ; } return result ; } ) ; } ) ; module . exports = sortWith ; } 
function ( module , exports , __webpack_require__ ) { var invoker = __webpack_require__ ( 25 ) ; var split = invoker ( 1 , 'split' ) ; module . exports = split ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var length = __webpack_require__ ( 218 ) ; var slice = __webpack_require__ ( 13 ) ; var splitAt = _curry2 ( function splitAt ( index , array ) { return [ slice ( 0 , index , array ) , slice ( index , length ( array ) , array ) ] ; } ) ; module . exports = splitAt ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var slice = __webpack_require__ ( 13 ) ; var splitEvery = _curry2 ( function splitEvery ( n , list ) { if ( n <= 0 ) { throw new Error ( 'First argument to splitEvery must be a positive integer' ) ; } var result = [ ] ; var idx = 0 ; while ( idx < list . length ) { result . push ( slice ( idx , idx += n , list ) ) ; } return result ; } ) ; module . exports = splitEvery ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var splitWhen = _curry2 ( function splitWhen ( pred , list ) { var idx = 0 ; var len = list . length ; var prefix = [ ] ; while ( idx < len && ! pred ( list [ idx ] ) ) { prefix . push ( list [ idx ] ) ; idx += 1 ; } return [ prefix , Array . prototype . slice . call ( list , idx ) ] ; } ) ; module . exports = splitWhen ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var equals = __webpack_require__ ( 10 ) ; var take = __webpack_require__ ( 62 ) ; var startsWith = _curry2 ( function ( prefix , list ) { return equals ( take ( prefix . length , list ) , prefix ) ; } ) ; module . exports = startsWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var subtract = _curry2 ( function subtract ( a , b ) { return Number ( a ) - Number ( b ) ; } ) ; module . exports = subtract ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var concat = __webpack_require__ ( 49 ) ; var difference = __webpack_require__ ( 196 ) ; var symmetricDifference = _curry2 ( function symmetricDifference ( list1 , list2 ) { return concat ( difference ( list1 , list2 ) , difference ( list2 , list1 ) ) ; } ) ; module . exports = symmetricDifference ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var concat = __webpack_require__ ( 49 ) ; var differenceWith = __webpack_require__ ( 197 ) ; var symmetricDifferenceWith = _curry3 ( function symmetricDifferenceWith ( pred , list1 , list2 ) { return concat ( differenceWith ( pred , list1 , list2 ) , differenceWith ( pred , list2 , list1 ) ) ; } ) ; module . exports = symmetricDifferenceWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var slice = __webpack_require__ ( 13 ) ; var takeLastWhile = _curry2 ( function takeLastWhile ( fn , xs ) { var idx = xs . length - 1 ; while ( idx >= 0 && fn ( xs [ idx ] ) ) { idx -= 1 ; } return slice ( idx + 1 , Infinity , xs ) ; } ) ; module . exports = takeLastWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xtakeWhile = __webpack_require__ ( 347 ) ; var slice = __webpack_require__ ( 13 ) ; var takeWhile = _curry2 ( _dispatchable ( [ 'takeWhile' ] , _xtakeWhile , function takeWhile ( fn , xs ) { var idx = 0 ; var len = xs . length ; while ( idx < len && fn ( xs [ idx ] ) ) { idx += 1 ; } return slice ( 0 , idx , xs ) ; } ) ) ; module . exports = takeWhile ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var _dispatchable = __webpack_require__ ( 5 ) ; var _xtap = __webpack_require__ ( 348 ) ; var tap = _curry2 ( _dispatchable ( [ ] , _xtap , function tap ( fn , x ) { fn ( x ) ; return x ; } ) ) ; module . exports = tap ; } 
function ( module , exports , __webpack_require__ ) { var _cloneRegExp = __webpack_require__ ( 204 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var _isRegExp = __webpack_require__ ( 323 ) ; var toString = __webpack_require__ ( 28 ) ; var test = _curry2 ( function test ( pattern , str ) { if ( ! _isRegExp ( pattern ) ) { throw new TypeError ( '‘test’ requires a value of type RegExp as its first argument; received ' + t S ring(pat t ern)); } return _cloneRegExp ( pattern ) . test ( str ) ; } ) ; module . exports = test ; } 
function ( module , exports , __webpack_require__ ) { var invoker = __webpack_require__ ( 25 ) ; var toLower = invoker ( 0 , 'toLowerCase' ) ; module . exports = toLower ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var _has = __webpack_require__ ( 8 ) ; var toPairs = _curry1 ( function toPairs ( obj ) { var pairs = [ ] ; for ( var prop in obj ) { if ( _has ( prop , obj ) ) { pairs [ pairs . length ] = [ prop , obj [ prop ] ] ; } } return pairs ; } ) ; module . exports = toPairs ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var toPairsIn = _curry1 ( function toPairsIn ( obj ) { var pairs = [ ] ; for ( var prop in obj ) { pairs [ pairs . length ] = [ prop , obj [ prop ] ] ; } return pairs ; } ) ; module . exports = toPairsIn ; } 
function ( module , exports , __webpack_require__ ) { var invoker = __webpack_require__ ( 25 ) ; var toUpper = invoker ( 0 , 'toUpperCase' ) ; module . exports = toUpper ; } 
function ( module , exports , __webpack_require__ ) { var _reduce = __webpack_require__ ( 11 ) ; var _xwrap = __webpack_require__ ( 213 ) ; var curryN = __webpack_require__ ( 7 ) ; var transduce = curryN ( 4 , function transduce ( xf , fn , acc , list ) { return _reduce ( xf ( typeof fn === 'function' ? _xwrap ( fn ) : fn ) , acc , list ) ; } ) ; module . exports = transduce ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var transpose = _curry1 ( function transpose ( outerlist ) { var i = 0 ; var result = [ ] ; while ( i < outerlist . length ) { var innerlist = outerlist [ i ] ; var j = 0 ; while ( j < innerlist . length ) { if ( typeof result [ j ] === 'undefined' ) { result [ j ] = [ ] ; } result [ j ] . push ( innerlist [ j ] ) ; j += 1 ; } i += 1 ; } return result ; } ) ; module . exports = transpose ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var map = __webpack_require__ ( 9 ) ; var sequence = __webpack_require__ ( 233 ) ; var traverse = _curry3 ( function traverse ( of , f , traversable ) { return typeof traversable [ 'fantasy-land/traverse' ] === 'function' ? traversable [ 'fantasy-land/traverse' ] ( f , of ) : sequence ( of , map ( f , traversable ) ) ; } ) ; module . exports = traverse ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF' ; var zeroWidth = '\u200b' ; var hasProtoTrim = typeof String . prototype . trim === 'function' ; var _trim = ! hasProtoTrim || ws . trim ( ) || ! zeroWidth . trim ( ) ? function trim ( str ) { var beginRx = new RegExp ( '^[' + ws + '][' + ws + ']*' ) ; var endRx = new RegExp ( '[' + ws + '][' + ws + ']*$' ) ; return str . replace ( beginRx , '' ) . replace ( endRx , '' ) ; } : function trim ( str ) { return str . trim ( ) ; } ; var trim = _curry1 ( _trim ) ; module . exports = trim ; } 
function ( module , exports , __webpack_require__ ) { var _arity = __webpack_require__ ( 14 ) ; var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var tryCatch = _curry2 ( function _tryCatch ( tryer , catcher ) { return _arity ( tryer . length , function ( ) { try { return tryer . apply ( this , arguments ) ; } catch ( e ) { return catcher . apply ( this , _concat ( [ e ] , arguments ) ) ; } } ) ; } ) ; module . exports = tryCatch ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var unapply = _curry1 ( function unapply ( fn ) { return function ( ) { return fn ( Array . prototype . slice . call ( arguments , 0 ) ) ; } ; } ) ; module . exports = unapply ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var nAry = __webpack_require__ ( 41 ) ; var unary = _curry1 ( function unary ( fn ) { return nAry ( 1 , fn ) ; } ) ; module . exports = unary ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var curryN = __webpack_require__ ( 7 ) ; var uncurryN = _curry2 ( function uncurryN ( depth , fn ) { return curryN ( depth , function ( ) { var currentDepth = 1 ; var value = fn ; var idx = 0 ; var endIdx ; while ( currentDepth <= depth && typeof value === 'function' ) { endIdx = currentDepth === depth ? arguments . length : idx + value . length ; value = value . apply ( this , Array . prototype . slice . call ( arguments , idx , endIdx ) ) ; currentDepth += 1 ; idx = endIdx ; } return value ; } ) ; } ) ; module . exports = uncurryN ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var unfold = _curry2 ( function unfold ( fn , seed ) { var pair = fn ( seed ) ; var result = [ ] ; while ( pair && pair . length ) { result [ result . length ] = pair [ 0 ] ; pair = fn ( pair [ 1 ] ) ; } return result ; } ) ; module . exports = unfold ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var compose = __webpack_require__ ( 48 ) ; var uniq = __webpack_require__ ( 64 ) ; var union = _curry2 ( compose ( uniq , _concat ) ) ; module . exports = union ; } 
function ( module , exports , __webpack_require__ ) { var _concat = __webpack_require__ ( 12 ) ; var _curry3 = __webpack_require__ ( 4 ) ; var uniqWith = __webpack_require__ ( 238 ) ; var unionWith = _curry3 ( function unionWith ( pred , list1 , list2 ) { return uniqWith ( pred , _concat ( list1 , list2 ) ) ; } ) ; module . exports = unionWith ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var unless = _curry3 ( function unless ( pred , whenFalseFn , x ) { return pred ( x ) ? x : whenFalseFn ( x ) ; } ) ; module . exports = unless ; } 
function ( module , exports , __webpack_require__ ) { var _identity = __webpack_require__ ( 55 ) ; var chain = __webpack_require__ ( 47 ) ; var unnest = chain ( _identity ) ; module . exports = unnest ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var until = _curry3 ( function until ( pred , fn , init ) { var val = init ; while ( ! pred ( val ) ) { val = fn ( val ) ; } return val ; } ) ; module . exports = until ; } 
function ( module , exports , __webpack_require__ ) { var _curry1 = __webpack_require__ ( 3 ) ; var valuesIn = _curry1 ( function valuesIn ( obj ) { var prop ; var vs = [ ] ; for ( prop in obj ) { vs [ vs . length ] = obj [ prop ] ; } return vs ; } ) ; module . exports = valuesIn ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; * Returns a "view" of the given data structure, determined by the given lens. * The lens's focus determines which portion of the data structure is visible. * * @func * @memberOf R * @since v0.16.0 * @category Object * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s * @sig Lens s a -> s -> a * @param {Lens} lens * @param {*} x * @return {*} * @see R.prop, R.lensIndex, R.lensProp * @example * * var xLens = R.lensProp('x'); * * R.view(xLens, {x: 1, y: 2}); * R.view(xLens, {x: 4, y: 2}); */ var view = _curry2 ( function view ( lens , x ) { 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var when = _curry3 ( function when ( pred , whenTrueFn , x ) { return pred ( x ) ? whenTrueFn ( x ) : x ; } ) ; module . exports = when ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var equals = __webpack_require__ ( 10 ) ; var map = __webpack_require__ ( 9 ) ; var where = __webpack_require__ ( 241 ) ; var whereEq = _curry2 ( function whereEq ( spec , testObj ) { return where ( map ( equals , spec ) , testObj ) ; } ) ; module . exports = whereEq ; } 
function ( module , exports , __webpack_require__ ) { var _contains = __webpack_require__ ( 20 ) ; var _curry2 = __webpack_require__ ( 1 ) ; var flip = __webpack_require__ ( 31 ) ; var reject = __webpack_require__ ( 43 ) ; var without = _curry2 ( function ( xs , list ) { return reject ( flip ( _contains ) ( xs ) , list ) ; } ) ; module . exports = without ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var xprod = _curry2 ( function xprod ( a , b ) { 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var zip = _curry2 ( function zip ( a , b ) { var rv = [ ] ; var idx = 0 ; var len = Math . min ( a . length , b . length ) ; while ( idx < len ) { rv [ idx ] = [ a [ idx ] , b [ idx ] ] ; idx += 1 ; } return rv ; } ) ; module . exports = zip ; } 
function ( module , exports , __webpack_require__ ) { var _curry2 = __webpack_require__ ( 1 ) ; var zipObj = _curry2 ( function zipObj ( keys , values ) { var idx = 0 ; var len = Math . min ( keys . length , values . length ) ; var out = { } ; while ( idx < len ) { out [ keys [ idx ] ] = values [ idx ] ; idx += 1 ; } return out ; } ) ; module . exports = zipObj ; } 
function ( module , exports , __webpack_require__ ) { var _curry3 = __webpack_require__ ( 4 ) ; var zipWith = _curry3 ( function zipWith ( fn , a , b ) { var rv = [ ] ; var idx = 0 ; var len = Math . min ( a . length , b . length ) ; while ( idx < len ) { rv [ idx ] = fn ( a [ idx ] , b [ idx ] ) ; idx += 1 ; } return rv ; } ) ; module . exports = zipWith ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; function checkDCE ( ) { if ( typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ . checkDCE !== 'function' ) { return ; } if ( false ) { 
function ( module , exports , __webpack_require__ ) { if ( typeof Promise === 'undefined' ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _createClass = function ( ) { function defineProperties ( target , props ) { for ( var i = 0 ; i < props . length ; i ++ ) { var descriptor = props [ i ] ; descriptor . enumerable = descriptor . enumerable || false ; descriptor . configurable = true ; if ( "value" in descriptor ) descriptor . writable = true ; Object . defineProperty ( target , descriptor . key , descriptor ) ; } } return function ( Constructor , protoProps , staticProps ) { if ( protoProps ) defineProperties ( Constructor . prototype , protoProps ) ; if ( staticProps ) defineProperties ( Constructor , staticProps ) ; return Constructor ; } ; } ( ) ; var _react = __webpack_require__ ( 243 ) ; var _react2 = _interopRequireDefault ( _react ) ; var _reactDom = __webpack_require__ ( 455 ) ; var _reactDom2 = _interopRequireDefault ( _reactDom ) ; var _reactCalendarMultiday = __webpack_require__ ( 453 ) ; var _reactCalendarMultiday2 = _interopRequireDefault ( _reactCalendarMultiday ) ; __webpack_require__ ( 459 ) ; var _moment = __webpack_require__ ( 2 ) ; var _moment2 = _interopRequireDefault ( _moment ) ; var _ramda = __webpack_require__ ( 307 ) ; function _interopRequireDefault ( obj ) { return obj && obj . __esModule ? obj : { default : obj } ; } function _classCallCheck ( instance , Constructor ) { if ( ! ( instance instanceof Constructor ) ) { throw new TypeError ( "Cannot call a class as a function" ) ; } } function _possibleConstructorReturn ( self , call ) { if ( ! self ) { throw new ReferenceError ( "this hasn't been initialised - super() hasn't been called" ) ; } return call && ( typeof call === "object" || typeof call === "function" ) ? call : self ; } function _inherits ( subClass , superClass ) { if ( typeof superClass !== "function" && superClass !== null ) { throw new TypeError ( "Super expression must either be null or a function, not " + typeof superClass ) ; } subClass . prototype = Object . create ( superClass && superClass . prototype , { constructor : { value : subClass , enumerable : false , writable : true , configurable : true } } ) ; if ( superClass ) Object . setPrototypeOf ? Object . setPrototypeOf ( subClass , superClass ) : subClass . __proto__ = superClass ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var Promise = __webpack_require__ ( 242 ) ; var DEFAULT_WHITELIST = [ ReferenceError , TypeError , RangeError ] ; var enabled = false ; exports . disable = disable ; function disable ( ) { enabled = false ; Promise . _10 = null ; Promise . _97 = null ; } exports . enable = enable ; function enable ( options ) { options = options || { } ; if ( enabled ) disable ( ) ; enabled = true ; var id = 0 ; var displayId = 0 ; var rejections = { } ; Promise . _10 = function ( promise ) { if ( promise . _81 === 2 && 
function ( layer ) { return { type : 'rectangle' , northEast : { lat : layer . getBounds ( ) . _northEast . lat , lng : layer . getBounds ( ) . _northEast . lng , } , southWest : { lat : layer . getBounds ( ) . _southWest . lat , lng : layer . getBounds ( ) . _southWest . lng , } } ; } 
function ( filter ) { this . _startLatLng = filter . northEast ; var shape = new L . Rectangle ( new L . LatLngBounds ( this . _startLatLng , filter . southWest ) , this . options . shapeOptions ) ; return { type : 'rectangle' , 'layer' : shape } ; } 
function ( t ) { 
function ( t , e ) { 
function delaunayRefine ( points , triangulation ) { var stack = [ ] var numPoints = points . length var stars = triangulation . stars for ( var a = 0 ; a < numPoints ; ++ a ) { var star = stars [ a ] for ( var j = 1 ; j < star . length ; j += 2 ) { var b = star [ j ] 
function PartialHull ( a , b , idx , lowerIds , upperIds ) { this . a = a this . b = b this . idx = idx this . lowerIds = lowerIds this . upperIds = upperIds } 
function Event ( a , b , type , idx ) { this . a = a this . b = b this . type = type this . idx = idx } 
function compareEvent ( a , b ) { var d = ( a . a [ 0 ] - b . a [ 0 ] ) || ( a . a [ 1 ] - b . a [ 1 ] ) || ( a . type - b . type ) if ( d ) { return d } if ( a . type !== EVENT_POINT ) { d = orient ( a . a , a . b , b . b ) if ( d ) { return d } } return a . idx - b . idx } 
function ( filter ) { 
function ( filter , options ) { 
function ( layer ) { var center = layer . getLatLng ( ) ; var radius = layer . getRadius ( ) ; return { type : 'circle' , center : center , radius : radius } ; } 
function ( filter ) { 
function showValidation ( feedback ) { feedback . errors . forEach ( function ( error ) { console . log ( 'ERROR: ' + error ) ; } ) ; feedback . warnings . forEach ( function ( warning ) { console . log ( 'WARNING: ' + warning ) ; } ) ; console . log ( "Validator finished with " + feedback . warnings . length + " warnings and " + feedback . errors . length + " errors." ) ; process . exit ( feedback . errors . length > 0 ? 2 : 0 ) ; } 
function ( codeLines , h , lineNo ) { while ( ( codeLines . height ( ) - h ) <= 0 ) { if ( lineNo == opts . selectedLine ) codeLines . append ( "<div class='lineno lineselect'>" + lineNo + "</div>" ) ; else codeLines . append ( "<div class='lineno'>" + lineNo + "</div>" ) ; lineNo ++ ; } return lineNo ; } 
function ( input , prefix ) { _ . forOwn ( input , function ( value , key ) { if ( ( / [^\w-] / ) . test ( key ) ) { console . warn ( key + ': the key format is not valid' ) ; } if ( _ . isPlainObject ( value ) ) { return recursion ( value , prefix ? [ prefix , key ] . join ( '_' ) : key ) ; } result [ ( prefix ? [ null , prefix , key ] : [ null , key ] ) . join ( '_' ) ] = _ . isFinite ( value ) ? value : _ . truncate ( _ . toString ( value ) , { length : 32765 } ) ; 
function LocationHashbangUrl ( appBase , hashPrefix ) { var appBaseNoFile = stripFile ( appBase ) ; parseAbsoluteUrl ( appBase , this , appBase ) ; this . $$parse = function ( url ) { var withoutBaseUrl = beginsWith ( appBase , url ) || beginsWith ( appBaseNoFile , url ) ; var withoutHashUrl = withoutBaseUrl . charAt ( 0 ) == '#' ? beginsWith ( hashPrefix , withoutBaseUrl ) : ( this . $$html5 ) ? withoutBaseUrl : '' ; if ( ! isString ( withoutHashUrl ) ) { throw $locationMinErr ( 'ihshprfx' , 'Invalid url "{0}", missing hash prefix "{1}".' , url , hashPrefix ) ; } parseAppUrl ( withoutHashUrl , this , appBase ) ; this . $$path = removeWindowsDriveName ( this . $$path , withoutHashUrl , appBase ) ; this . $$compose ( ) ; function removeWindowsDriveName ( path , url , base ) { var windowsFilePathExp = / ^\/[A-Z]:(\/.*) / ; var firstPathSegmentMatch ; * Compose hashbang url and update `absUrl` property * @private */ this . $$compose = function ( ) { var search = toKeyValue ( this . $$search ) , hash = this . $$hash ? '#' + encodeUriSegment ( this . $$hash ) : '' ; this . $$url = encodePath ( this . $$path ) + ( search ? '?' + search : '' ) + hash ; this . $$absUrl = appBase + ( this . $$url ? hashPrefix + this . $$url : '' ) ; } ; this . $$rewrite = function ( url ) { if ( stripHash ( appBase ) == stripHash ( url ) ) { return url ; } } ; } 
function ( search , paramValue ) { switch ( arguments . length ) { case 0 : return this . $$search ; case 1 : if ( isString ( search ) ) { this . $$search = parseKeyValue ( search ) ; } else if ( isObject ( search ) ) { 
function $LocationProvider ( ) { var hashPrefix = '' , html5Mode = false ; this . hashPrefix = function ( prefix ) { if ( isDefined ( prefix ) ) { hashPrefix = prefix ; return this ; } else { return hashPrefix ; } } ; this . html5Mode = function ( mode ) { if ( isDefined ( mode ) ) { html5Mode = mode ; return this ; } else { return html5Mode ; } } ; this . $get = [ '$rootScope' , '$browser' , '$sniffer' , '$rootElement' , function ( $rootScope , $browser , $sniffer , $rootElement ) { var $location , LocationMode , baseHref = $browser . baseHref ( ) , 
function cspSafeGetterFn ( key0 , key1 , key2 , key3 , key4 , fullExp ) { ensureSafeMemberName ( key0 , fullExp ) ; ensureSafeMemberName ( key1 , fullExp ) ; ensureSafeMemberName ( key2 , fullExp ) ; ensureSafeMemberName ( key3 , fullExp ) ; ensureSafeMemberName ( key4 , fullExp ) ; return function cspSafeGetter ( scope , locals ) { var pathVal = ( locals && locals . hasOwnProperty ( key0 ) ) ? locals : scope ; if ( pathVal == null ) return pathVal ; pathVal = pathVal [ key0 ] ; if ( ! key1 ) return pathVal ; if ( pathVal == null ) return undefined ; pathVal = pathVal [ key1 ] ; if ( ! key2 ) return pathVal ; if ( pathVal == null ) return undefined ; pathVal = pathVal [ key2 ] ; if ( ! key3 ) return pathVal ; if ( pathVal == null ) return undefined ; pathVal = pathVal [ key3 ] ; if ( ! key4 ) return pathVal ; if ( pathVal == null ) return undefined ; pathVal = pathVal [ key4 ] ; return pathVal ; } ; } 
function $ParseProvider ( ) { var cache = { } ; var $parseOptions = { csp : false } ; this . $get = [ '$filter' , '$sniffer' , function ( $filter , $sniffer ) { $parseOptions . csp = $sniffer . csp ; return function ( exp , interceptorFn ) { var parsedExpression , oneTime , cacheKey = ( exp = trim ( exp ) ) ; switch ( typeof exp ) { case 'string' : if ( cache . hasOwnProperty ( cacheKey ) ) { parsedExpression = cache [ cacheKey ] ; } else { if ( exp . charAt ( 0 ) === ':' && exp . charAt ( 1 ) === ':' ) { oneTime = true ; exp = exp . substring ( 2 ) ; } var lexer = new Lexer ( $parseOptions ) ; var parser = new Parser ( lexer , $filter , $parseOptions ) ; parsedExpression = parser . parse ( exp ) ; if ( parsedExpression . constant ) parsedExpression . $$watchDelegate = constantWatch ; else if ( oneTime ) parsedExpression . $$watchDelegate = oneTimeWatch ; if ( cacheKey !== 'hasOwnProperty' ) { 
function getFirstAnchor ( list ) { var result = null ; forEach ( list , function ( element ) { if ( ! result && nodeName_ ( element ) === 'a' ) result = element ; } ) ; return result ; } 
function applyDirectivesToNode ( directives , compileNode , templateAttrs , transcludeFn , jqCollection , originalReplaceDirective , preLinkFns , postLinkFns , previousCompileContext ) { previousCompileContext = previousCompileContext || { } ; var terminalPriority = - Number . MAX_VALUE , newScopeDirective , controllerDirectives = previousCompileContext . controllerDirectives , newIsolateScopeDirective = previousCompileContext . newIsolateScopeDirective , templateDirective = previousCompileContext . templateDirective , nonTlbTranscludeDirective = previousCompileContext . nonTlbTranscludeDirective , hasTranscludeDirective = false , hasTemplate = false , hasElementTranscludeDirective = previousCompileContext . hasElementTranscludeDirective , $compileNode = templateAttrs . $$element = jqLite ( compileNode ) , directive , directiveName , $template , replaceDirective = originalReplaceDirective , childTranscludeFn = transcludeFn , linkFn , directiveValue ; 
function shallowCopy ( src , dst ) { var i = 0 ; if ( isArray ( src ) ) { dst = dst || [ ] ; for ( ; i < src . length ; i ++ ) { dst [ i ] = src [ i ] ; } } else if ( isObject ( src ) ) { dst = dst || { } ; var keys = Object . keys ( src ) ; for ( var l = keys . length ; i < l ; i ++ ) { var key = keys [ i ] ; if ( ! ( key . charAt ( 0 ) === '$' && key . charAt ( 1 ) === '$' ) ) { dst [ key ] = src [ key ] ; } } } return dst || src ; } 
function bootstrap ( element , modules , config ) { if ( ! isObject ( config ) ) config = { } ; var defaultConfig = { strictDi : false } ; config = extend ( defaultConfig , config ) ; var doBootstrap = function ( ) { element = jqLite ( element ) ; if ( element . injector ( ) ) { var tag = ( element [ 0 ] === document ) ? 'document' : startingTag ( element ) ; throw ngMinErr ( 'btstrpd' , "App Already Bootstrapped with this Element '{0}'" , tag ) ; } modules = modules || [ ] ; modules . unshift ( [ '$provide' , function ( $provide ) { $provide . value ( '$rootElement' , element ) ; } ] ) ; modules . unshift ( 'ng' ) ; var injector = createInjector ( modules , config . strictDi ) ; injector . invoke ( [ '$rootScope' , '$rootElement' , '$compile' , '$injector' , function ( scope , element , compile , injector ) { scope . $apply ( function ( ) { element . data ( '$injector' , injector ) ; compile ( element ) ( scope ) ; } ) ; } ] ) ; return injector ; } ; var NG_DEFER_BOOTSTRAP = / ^NG_DEFER_BOOTSTRAP! / ; if ( window && ! NG_DEFER_BOOTSTRAP . test ( window . name ) ) { return doBootstrap ( ) ; } window . name = window . name . replace ( NG_DEFER_BOOTSTRAP , '' ) ; angular . resumeBootstrap = function ( extraModules ) { forEach ( extraModules , function ( module ) { modules . push ( module ) ; } ) ; doBootstrap ( ) ; } ; } 
function push ( ) { var name , value , browserCookies , updated ; 
function makeSwipeDirective ( directiveName , direction ) { ngMobile . directive ( directiveName , [ '$parse' , function ( $parse ) { 
function limitToFilter ( ) { return function ( input , limit ) { if ( ! isArray ( input ) && ! isString ( input ) ) return input ; if ( Math . abs ( Number ( limit ) ) === Infinity ) { limit = Number ( limit ) ; } else { limit = int ( limit ) ; } if ( isString ( input ) ) { 
function $SnifferProvider ( ) { this . $get = [ '$window' , '$document' , function ( $window , $document ) { var eventSupport = { } , android = int ( ( / android (\d+) / . exec ( lowercase ( ( $window . navigator || { } ) . userAgent ) ) || [ ] ) [ 1 ] ) , boxee = / Boxee / i . test ( ( $window . navigator || { } ) . userAgent ) , document = $document [ 0 ] || { } , documentMode = document . documentMode , vendorPrefix , vendorRegex = / ^(Moz|webkit|O|ms)(?=[A-Z]) / , bodyStyle = document . body && document . body . style , transitions = false , animations = false , match ; if ( bodyStyle ) { for ( var prop in bodyStyle ) { if ( match = vendorRegex . exec ( prop ) ) { vendorPrefix = match [ 0 ] ; vendorPrefix = vendorPrefix . substr ( 0 , 1 ) . toUpperCase ( ) + vendorPrefix . substr ( 1 ) ; break ; } } if ( ! vendorPrefix ) { vendorPrefix = ( 'WebkitOpacity' in bodyStyle ) && 'webkit' ; } transitions = ! ! ( ( 'transition' in bodyStyle ) || ( vendorPrefix + 'Transition' in bodyStyle ) ) ; animations = ! ! ( ( 'animation' in bodyStyle ) || ( vendorPrefix + 'Animation' in bodyStyle ) ) ; if ( android && ( ! transitions || ! animations ) ) { transitions = isString ( document . body . style . webkitTransition ) ; animations = isString ( document . body . style . webkitAnimation ) ; } } return { 
function ( ) { var pending = [ ] , value , deferred ; deferred = { resolve : function ( val ) { if ( pending ) { var callbacks = pending ; pending = undefined ; value = ref ( val ) ; if ( callbacks . length ) { nextTick ( function ( ) { var callback ; for ( var i = 0 , ii = callbacks . length ; i < ii ; i ++ ) { callback = callbacks [ i ] ; value . then ( callback [ 0 ] , callback [ 1 ] , callback [ 2 ] ) ; } } ) ; } } } , reject : function ( reason ) { deferred . resolve ( createInternalRejectedPromise ( reason ) ) ; } , notify : function ( progress ) { if ( pending ) { var callbacks = pending ; if ( pending . length ) { nextTick ( function ( ) { var callback ; for ( var i = 0 , ii = callbacks . length ; i < ii ; i ++ ) { callback = callbacks [ i ] ; callback [ 2 ] ( progress ) ; } } ) ; } } } , promise : { then : function ( callback , errback , progressback ) { var result = defer ( ) ; var wrappedCallback = function ( value ) { try { result . resolve ( ( isFunction ( callback ) ? callback : defaultCallback ) ( value ) ) ; } catch ( e ) { result . reject ( e ) ; exceptionHandler ( e ) ; } } ; var wrappedErrback = function ( reason ) { try { result . resolve ( ( isFunction ( errback ) ? errback : defaultErrback ) ( reason ) ) ; } catch ( e ) { result . reject ( e ) ; exceptionHandler ( e ) ; } } ; var wrappedProgressback = function ( progress ) { try { result . notify ( ( isFunction ( progressback ) ? progressback : defaultCallback ) ( progress ) ) ; } catch ( e ) { exceptionHandler ( e ) ; } } ; if ( pending ) { pending . push ( [ wrappedCallback , wrappedErrback , wrappedProgressback ] ) ; } else { value . then ( wrappedCallback , wrappedErrback , wrappedProgressback ) ; } return result . promise ; } , "catch" : function ( callback ) { return this . then ( null , callback ) ; } , "finally" : function ( callback ) { function makePromise ( value , resolved ) { var result = defer ( ) ; if ( resolved ) { result . resolve ( value ) ; } else { result . reject ( value ) ; } return result . promise ; } function handleCallback ( value , isResolved ) { var callbackOutput = null ; try { callbackOutput = ( callback || defaultCallback ) ( ) ; } catch ( e ) { return makePromise ( e , false ) ; } if ( isPromiseLike ( callbackOutput ) ) { return callbackOutput . then ( function ( ) { return makePromise ( value , isResolved ) ; } , function ( error ) { return makePromise ( error , false ) ; } ) ; } else { return makePromise ( value , isResolved ) ; } } return this . then ( function ( value ) { return handleCallback ( value , true ) ; } , function ( error ) { return handleCallback ( error , false ) ; } ) ; } } } ; return deferred ; } 
function validate ( ctrl , validatorName , validity , value ) { ctrl . $setValidity ( validatorName , validity ) ; return validity ? value : undefined ; } 
function addNativeHtml5Validators ( ctrl , validatorName , badFlags , ignoreFlags , validity ) { if ( isObject ( validity ) ) { ctrl . $$hasNativeValidators = true ; var validator = function ( value ) { 
function ( ) { return { restrict : 'A' , require : [ 'ngModel' , '^?form' , '^?ngModelOptions' ] , controller : NgModelController , link : { pre : function ( scope , element , attr , ctrls ) { 
function ( ) { return { restrict : 'A' , require : 'ngModel' , link : function ( scope , element , attr , ctrl ) { 
function $RootScopeProvider ( ) { var TTL = 10 ; var $rootScopeMinErr = minErr ( '$rootScope' ) ; var lastDirtyWatch = null ; this . digestTtl = function ( value ) { if ( arguments . length ) { TTL = value ; } return TTL ; } ; this . $get = [ '$injector' , '$exceptionHandler' , '$parse' , '$browser' , function ( $injector , $exceptionHandler , $parse , $browser ) { function Scope ( ) { this . $id = nextUid ( ) ; this . $$phase = this . $parent = this . $$watchers = this . $$nextSibling = this . $$prevSibling = this . $$childHead = this . $$childTail = null ; this [ 'this' ] = this . $root = this ; this . $$destroyed = false ; this . $$asyncQueue = [ ] ; this . $$postDigestQueue = [ ] ; this . $$listeners = { } ; this . $$listenerCount = { } ; this . $$isolateBindings = { } ; } Scope . prototype = { constructor : Scope , $new : function ( isolate ) { var ChildScope , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; * @ngdoc method * @name $rootScope.Scope#$watch * @kind function * * @description * Registers a `listener` callback to be executed whenever the `watchExpression` changes. * * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest * $digest()} and should return the value that will be watched. (Since * {@link ng.$rootScope.Scope#$digest $digest()} reruns when it detects changes the * `watchExpression` can execute multiple times per * {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.) * - The `listener` is called only when the value from the current `watchExpression` and the * previous call to `watchExpression` are not equal (with the exception of the initial run, * see below). Inequality is determined according to reference inequality, * [strict comparison](https: * via the `!==` Javascript operator, unless `objectEquality == true` * (see next point) * - When `objectEquality == true`, inequality of the `watchExpression` is determined * according to the {@link angular.equals} function. To save the value of the object for * later comparison, the {@link angular.copy} function is used. This therefore means that * watching complex objects will have adverse memory and performance implications. * - The watch `listener` may change the model, which may trigger other `listener`s to fire. * This is achieved by rerunning the watchers until no changes are detected. The rerun * iteration limit is 10 to prevent an infinite loop deadlock. * * * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called, * you can register a `watchExpression` function with no `listener`. (Since `watchExpression` * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a * change is detected, be prepared for multiple calls to your listener.) * * After a watcher is registered with the scope, the `listener` fn is called asynchronously * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the * watcher. In rare cases, this is undesirable because the listener is called when the result * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the * listener was called due to initialization. * * * * # Example * ```js // let's assume that scope was dependency injected as the $rootScope var scope = $rootScope; scope.name = 'misko'; scope.counter = 0; expect(scope.counter).toEqual(0); scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; }); expect(scope.counter).toEqual(0); scope.$digest(); expect(scope.counter).toEqual(1); scope.$digest(); expect(scope.counter).toEqual(1); scope.name = 'adam'; scope.$digest(); expect(scope.counter).toEqual(2); var food; scope.foodCounter = 0; expect(scope.foodCounter).toEqual(0); scope.$watch( function() { return food; }, function(newValue, oldValue) { if ( newValue !== oldValue ) { scope.foodCounter = scope.foodCounter + 1; } } ); expect(scope.foodCounter).toEqual(0); scope.$digest(); expect(scope.foodCounter).toEqual(0); food = 'cheeseburger'; scope.$digest(); expect(scope.foodCounter).toEqual(1); * ``` * * * * @param {(function()|string)} watchExpression Expression that is evaluated on each * {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers * a call to the `listener`. * * - `string`: Evaluated as {@link guide/expression expression} * - `function(scope)`: called with current `scope` as a parameter. * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value * of `watchExpression` changes. * * - `newVal` contains the current value of the `watchExpression` * - `oldVal` contains the previous value of the `watchExpression` * - `scope` refers to the current scope * @param {boolean=} objectEquality Compare for object equality using {@link angular.equals} instead of * comparing for reference equality. * @param {function()=} deregisterNotifier Function to call when the deregistration function * get called. * @returns {function()} Returns a deregistration function for this listener. */ $watch : function ( watchExp , listener , objectEquality , deregisterNotifier ) { var get = compileToFn ( watchExp , 'watch' ) ; if ( get . $$watchDelegate ) { return get . $$watchDelegate ( this , listener , objectEquality , deregisterNotifier , get ) ; } var scope = this , array = scope . $$watchers , watcher = { fn : listener , last : initWatchVal , get : get , exp : watchExp , eq : ! ! objectEquality } ; lastDirtyWatch = null ; if ( ! isFunction ( listener ) ) { watcher . fn = noop ; } if ( ! array ) { array = scope . $$watchers = [ ] ; } * @ngdoc method * @name $rootScope.Scope#$watchGroup * @kind function * * @description * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`. * If any one expression in the collection changes the `listener` is executed. * * - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every * call to $digest() to see if any items changes. * - The `listener` is called whenever any expression in the `watchExpressions` array changes. * * @param {Array.<string|Function(scope)>} watchExpressions Array of expressions that will be individually * watched using {@link ng.$rootScope.Scope#$watch $watch()} * * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any * expression in `watchExpressions` changes * The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching * those of `watchExpression` * and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching * those of `watchExpression` * The `scope` refers to the current scope. * @returns {function()} Returns a de-registration function for all listeners. */ $watchGroup : function ( watchExpressions , listener ) { var oldValues = new Array ( watchExpressions . length ) ; var newValues = new Array ( watchExpressions . length ) ; var deregisterFns = [ ] ; var changeCount = 0 ; var self = this ; var masterUnwatch ; if ( watchExpressions . length === 1 ) { * @ngdoc method * @name $rootScope.Scope#$watchCollection * @kind function * * @description * Shallow watches the properties of an object and fires whenever any of the properties change * (for arrays, this implies watching the array items; for object maps, this implies watching * the properties). If a change is detected, the `listener` callback is fired. * * - The `obj` collection is observed via standard $watch operation and is examined on every * call to $digest() to see if any items have been added, removed, or moved. * - The `listener` is called whenever anything within the `obj` has changed. Examples include * adding, removing, and moving items belonging to an object or array. * * * # Example * ```js $scope.names = ['igor', 'matias', 'misko', 'james']; $scope.dataCount = 4; $scope.$watchCollection('names', function(newNames, oldNames) { $scope.dataCount = newNames.length; }); expect($scope.dataCount).toEqual(4); $scope.$digest(); expect($scope.dataCount).toEqual(4); $scope.names.pop(); $scope.$digest(); expect($scope.dataCount).toEqual(3); * ``` * * * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The * expression value should evaluate to an object or an array which is observed on each * {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the * collection will trigger a call to the `listener`. * * @param {function(newCollection, oldCollection, scope)} listener a callback function called * when a change is detected. * - The `newCollection` object is the newly modified data obtained from the `obj` expression * - The `oldCollection` object is a copy of the former collection data. * Due to performance considerations, the`oldCollection` value is computed only if the * `listener` function declares two or more arguments. * - The `scope` argument refers to the current scope. * * @returns {function()} Returns a de-registration function for this listener. When the * de-registration function is executed, the internal watch operation is terminated. */ $watchCollection : function ( obj , listener ) { var self = this ; * @ngdoc method * @name $rootScope.Scope#$digest * @kind function * * @description * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} * until no more listeners are firing. This means that it is possible to get into an infinite * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of * iterations exceeds 10. * * Usually, you don't call `$digest()` directly in * {@link ng.directive:ngController controllers} or in * {@link ng.$compileProvider#directive directives}. * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`. * * If you want to be notified whenever `$digest()` is called, * you can register a `watchExpression` function with * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`. * * In unit tests, you may need to call `$digest()` to simulate the scope life cycle. * * # Example * ```js var scope = ...; scope.name = 'misko'; scope.counter = 0; expect(scope.counter).toEqual(0); scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; }); expect(scope.counter).toEqual(0); scope.$digest(); expect(scope.counter).toEqual(1); scope.$digest(); expect(scope.counter).toEqual(1); scope.name = 'adam'; scope.$digest(); expect(scope.counter).toEqual(2); * ``` * */ $digest : function ( ) { var watch , value , last , watchers , asyncQueue = this . $$asyncQueue , postDigestQueue = this . $$postDigestQueue , length , dirty , ttl = TTL , next , current , target = this , watchLog = [ ] , logIdx , logMsg , asyncTask ; beginPhase ( '$digest' ) ; lastDirtyWatch = null ; do { * @ngdoc event * @name $rootScope.Scope#$destroy * @eventType broadcast on scope being destroyed * * @description * Broadcasted when a scope and its children are being destroyed. * * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to * clean up DOM bindings before an element is removed from the DOM. */ $destroy : function ( ) { * @ngdoc method * @name $rootScope.Scope#$eval * @kind function * * @description * Executes the `expression` on the current scope and returns the result. Any exceptions in * the expression are propagated (uncaught). This is useful when evaluating Angular * expressions. * * # Example * ```js var scope = ng.$rootScope.Scope(); scope.a = 1; scope.b = 2; expect(scope.$eval('a+b')).toEqual(3); expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3); * ``` * * @param {(string|function())=} expression An angular expression to be executed. * * - `string`: execute using the rules as defined in {@link guide/expression expression}. * - `function(scope)`: execute the function with the current `scope` parameter. * * @param {(object)=} locals Local variables object, useful for overriding values in scope. * @returns {*} The result of evaluating the expression. */ $eval : function ( expr , locals ) { return $parse ( expr ) ( this , locals ) ; } , $evalAsync : function ( expr ) { * @ngdoc method * @name $rootScope.Scope#$apply * @kind function * * @description * `$apply()` is used to execute an expression in angular from outside of the angular * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries). * Because we are calling into the angular framework we need to perform proper scope life * cycle of {@link ng.$exceptionHandler exception handling}, * {@link ng.$rootScope.Scope#$digest executing watches}. * * ## Life cycle * * # Pseudo-Code of `$apply()` * ```js function $apply(expr) { try { return $eval(expr); } catch (e) { $exceptionHandler(e); } finally { $root.$digest(); } } * ``` * * * Scope's `$apply()` method transitions through the following stages: * * 1. The {@link guide/expression expression} is executed using the * {@link ng.$rootScope.Scope#$eval $eval()} method. * 2. Any exceptions from the execution of the expression are forwarded to the * {@link ng.$exceptionHandler $exceptionHandler} service. * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the * expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method. * * * @param {(string|function())=} exp An angular expression to be executed. * * - `string`: execute using the rules as defined in {@link guide/expression expression}. * - `function(scope)`: execute the function with current `scope` parameter. * * @returns {*} The result of evaluating the expression. */ $apply : function ( expr ) { try { beginPhase ( '$apply' ) ; return this . $eval ( expr ) ; } catch ( e ) { $exceptionHandler ( e ) ; } finally { clearPhase ( ) ; try { $rootScope . $digest ( ) ; } catch ( e ) { $exceptionHandler ( e ) ; throw e ; } } } , /** * @ngdoc method * @name $rootScope.Scope#$on * @kind function * * @description * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for * discussion of event life cycle. * * The event listener function format is: `function(event, args...)`. The `event` object * passed into the listener has the following attributes: * * - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or * `$broadcast`-ed. * - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the * event propagates through the scope hierarchy, this property is set to null. * - `name` - `{string}`: name of the event. * - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel * further event propagation (available only for events that were `$emit`-ed). * - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag * to true. * - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called. * * @param {string} name Event name to listen on. * @param {function(event, ...args)} listener Function to call when the event is emitted. * @returns {function()} Returns a deregistration function for this listener. */ $on : function ( name , listener ) { var namedListeners = this . $$listeners [ name ] ; if ( ! namedListeners ) { this . $$listeners [ name ] = namedListeners = [ ] ; } namedListeners . push ( listener ) ; var current = this ; do { if ( ! current . $$listenerCount [ name ] ) { current . $$listenerCount [ name ] = 0 ; } current . $$listenerCount [ name ] ++ ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { namedListeners [ indexOf ( namedListeners , listener ) ] = null ; decrementListenerCount ( self , 1 , name ) ; } ; } , /** * @ngdoc method * @name $rootScope.Scope#$emit * @kind function * * @description * Dispatches an event `name` upwards through the scope hierarchy notifying the * registered {@link ng.$rootScope.Scope#$on} listeners. * * The event life cycle starts at the scope on which `$emit` was called. All * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get * notified. Afterwards, the event traverses upwards toward the root scope and calls all * registered listeners along the way. The event will stop propagating if one of the listeners * cancels it. * * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed * onto the {@link ng.$exceptionHandler $exceptionHandler} service. * * @param {string} name Event name to emit. * @param {...*} args Optional one or more arguments which will be passed onto the event listeners. * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}). */ $emit : function ( name , args ) { var empty = [ ] , namedListeners , scope = this , stopPropagation = false , event = { name : name , targetScope : scope , stopPropagation : function ( ) { stopPropagation = true ; } , preventDefault : function ( ) { event . defaultPrevented = true ; } , defaultPrevented : false } , listenerArgs = concat ( [ event ] , arguments , 1 ) , i , length ; do { namedListeners = scope . $$listeners [ name ] || empty ; event . currentScope = scope ; for ( i = 0 , length = namedListeners . length ; i < length ; i ++ ) { // if listeners were deregistered, defragment the array if ( ! namedListeners [ i ] ) { namedListeners . splice ( i , 1 ) ; i -- ; length -- ; continue ; } try { //allow all listeners attached to the current scope to run namedListeners [ i ] . apply ( null , listenerArgs ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } //if any listener on the current scope stops propagation, prevent bubbling if ( stopPropagation ) { event . currentScope = null ; return event ; } //traverse upwards scope = scope . $parent ; } while ( scope ) ; event . currentScope = null ; return event ; } , /** * @ngdoc method * @name $rootScope.Scope#$broadcast * @kind function * * @description * Dispatches an event `name` downwards to all child scopes (and their children) notifying the * registered {@link ng.$rootScope.Scope#$on} listeners. * * The event life cycle starts at the scope on which `$broadcast` was called. All * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get * notified. Afterwards, the event propagates to all direct and indirect scopes of the current * scope and calls all registered listeners along the way. The event cannot be canceled. * * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed * onto the {@link ng.$exceptionHandler $exceptionHandler} service. * * @param {string} name Event name to broadcast. * @param {...*} args Optional one or more arguments which will be passed onto the event listeners. * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on} */ $broadcast : function ( name , args ) { var target = this , current = target , next = target , event = { name : name , targetScope : target , preventDefault : function ( ) { event . defaultPrevented = true ; } , defaultPrevented : false } , listenerArgs = concat ( [ event ] , arguments , 1 ) , listeners , i , length ; //down while you can, then up and next sibling or up and next sibling until back at root while ( ( current = next ) ) { event . currentScope = current ; listeners = current . $$listeners [ name ] || [ ] ; for ( i = 0 , length = listeners . length ; i < length ; i ++ ) { // if listeners were deregistered, defragment the array if ( ! listeners [ i ] ) { listeners . splice ( i , 1 ) ; i -- ; length -- ; continue ; } try { listeners [ i ] . apply ( null , listenerArgs ) ; } catch ( e ) { $exceptionHandler ( e ) ; } } // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $digest // (though it differs due to having the extra check for $$listenerCount) if ( ! ( next = ( ( current . $$listenerCount [ name ] && current . $$childHead ) || ( current !== target && current . $$nextSibling ) ) ) ) { while ( current !== target && ! ( next = current . $$nextSibling ) ) { current = current . $parent ; } } } event . currentScope = null ; return event ; } } ; var $rootScope = new Scope ( ) ; return $rootScope ; function beginPhase ( phase ) { if ( $rootScope . $$phase ) { throw $rootScopeMinErr ( 'inprog' , '{0} already in progress' , $rootScope . $$phase ) ; } $rootScope . $$phase = phase ; } function clearPhase ( ) { $rootScope . $$phase = null ; } function compileToFn ( exp , name ) { var fn = $parse ( exp ) ; assertArgFn ( fn , name ) ; return fn ; } function decrementListenerCount ( current , count , name ) { do { current . $$listenerCount [ name ] -= count ; if ( current . $$listenerCount [ name ] === 0 ) { delete current . $$listenerCount [ name ] ; } } while ( ( current = current . $parent ) ) ; } /** * function used as an initial value for watchers. * because it's unique we can easily tell it apart from other values */ function initWatchVal ( ) { } } ] ; } 
function ( isolate ) { var ChildScope , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; 
function ( watchExpressions , listener ) { var oldValues = new Array ( watchExpressions . length ) ; var newValues = new Array ( watchExpressions . length ) ; var deregisterFns = [ ] ; var changeCount = 0 ; var self = this ; var masterUnwatch ; if ( watchExpressions . length === 1 ) { 
function ( ) { 
function ( name , listener ) { var namedListeners = this . $$listeners [ name ] ; if ( ! namedListeners ) { this . $$listeners [ name ] = namedListeners = [ ] ; } namedListeners . push ( listener ) ; var current = this ; do { if ( ! current . $$listenerCount [ name ] ) { current . $$listenerCount [ name ] = 0 ; } current . $$listenerCount [ name ] ++ ; } while ( ( current = current . $parent ) ) ; var self = this ; return function ( ) { namedListeners [ indexOf ( namedListeners , listener ) ] = null ; decrementListenerCount ( self , 1 , name ) ; } ; } 
function ( event ) { scope . $apply ( function ( ) { controller . $commitViewValue ( ) ; } ) ; event . preventDefault ? event . preventDefault ( ) : event . returnValue = false ; 
function ( docular_webapp_target ) { var ABS_SCRIPTS = __dirname ; var ABS_LIB = path . resolve ( ABS_SCRIPTS + '/..' ) ; var ABS_DEFAULT_GENERATED_WEBAPP = ABS_LIB + '/generated/' ; return docular_webapp_target ? path . resolve ( process . cwd ( ) + '/' + docular_webapp_target ) : path . relative ( process . cwd ( ) , ABS_DEFAULT_GENERATED_WEBAPP ) ; } 
function IntegrationContext ( variable , options ) { this . variable = variable . clone ( ) ; this . options = options ; this . _constantExpr = { } ; this . subIntegral = { } ; this . rules = options . rules ; this . debugIndent = 0 ; } 
function preprocessIntegrand ( expr , context ) { expr = removeParenthesis ( expr ) ; expr = reduceFunctions ( expr ) ; expr = removeDivision ( expr ) ; return expr ; function removeParenthesis ( node ) { if ( node . type === "ParenthesisNode" ) { return removeParenthesis ( node . content ) ; } else { return node . map ( removeParenthesis ) ; } } function reduceFunctions ( expr ) { return helper ( expr ) ; function helper ( expr ) { if ( ! context . isConstant ( expr ) && expr . type === "FunctionNode" ) { var funcName = typeof expr . fn === "string" ? expr . fn : expr . fn . name ; switch ( funcName ) { case "add" : return new OperatorNode ( '+' , 'add' , expr . args ) ; case "subtract" : return new OperatorNode ( '-' , 'subtract' , expr . args ) ; case "multiply" : return new OperatorNode ( '*' , 'multiply' , expr . args ) ; case "divide" : return new OperatorNode ( '/' , 'divide' , expr . args ) ; case "sqrt" : return new OperatorNode ( '^' , 'pow' , [ expr . args [ 0 ] . map ( helper ) , new OperatorNode ( '/' , 'divide' , [ new ConstantNode ( 1 ) , new ConstantNode ( 2 ) ] ) ] ) ; case "nthRoot" : return new OperatorNode ( '^' , 'pow' , [ expr . args [ 0 ] . map ( helper ) , new OperatorNode ( '/' , 'divide' , [ new ConstantNode ( 1 ) , expr . args [ 1 ] . map ( helper ) ] ) ] ) ; case "exp" : return new OperatorNode ( '^' , 'pow' , [ new SymbolNode ( 'e' ) , expr . args [ 0 ] ] ) ; case "pow" : return new OperatorNode ( '^' , 'pow' , expr . args ) ; case "log" : if ( expr . args . length === 2 ) { return new OperatorNode ( '/' , 'divide' , [ new FunctionNode ( 'log' , [ expr . args [ 0 ] . map ( helper ) ] ) , new FunctionNode ( 'log' , [ expr . args [ 1 ] . map ( helper ) ] ) ] ) ; } else { break ; } default : break ; } } return expr . map ( helper ) ; } } function removeDivision ( expr ) { return expr . transform ( function ( node ) { if ( ! context . isConstant ( node ) && node . type === 'OperatorNode' && node . op === '/' ) { return new OperatorNode ( '*' , 'multiply' , [ node . args [ 0 ] , new OperatorNode ( '^' , 'pow' , [ node . args [ 1 ] , new ConstantNode ( - 1 ) ] ) ] ) ; } else { return node ; } } ) ; } } 
function getNumericValue ( expr ) { var simplified = simplifyConstant ( expr ) ; return toNumber ( simplified ) ; function toNumber ( expr ) { if ( expr . type === 'OperatorNode' && expr . op === '-' && expr . args . length === 1 ) { 
function ( expr , context , subIntegral ) { var simplified = simplify . simplifyCore ( expr , context ) ; if ( ! simplified . equals ( expr ) ) { return subIntegral ( simplified , context , "simplified expression" ) ; } } 
function ( expr , context , subIntegral ) { if ( expr . type === 'ParenthesisNode' ) { var int = subIntegral ( expr . content , context , "parentheses removal" ) ; return int ? new ParenthesisNode ( int ) : null ; } } 
function ( expr , context ) { if ( context . isConstant ( expr ) ) { return new OperatorNode ( '*' , 'multiply' , [ expr . clone ( ) , context . variable . clone ( ) ] ) ; } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && ( expr . op === '+' || expr . op === '-' ) ) { var childInts = expr . args . map ( function ( expr ) { return subIntegral ( expr , context , "sum rule" ) ; } ) ; if ( childInts . every ( function ( n ) { return n ; } ) ) { return new OperatorNode ( expr . op , expr . fn , childInts ) ; } } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && expr . op === "*" ) { var factors = getFactors ( expr ) ; if ( factors . length > expr . args . length ) { return subIntegral ( new OperatorNode ( '*' , 'multiply' , factors ) , context , "product flattening" ) ; } } function getFactors ( expr ) { if ( expr . type === "OperatorNode" && expr . op === "*" ) { return expr . args . reduce ( function ( factors , expr ) { return factors . concat ( getFactors ( expr ) ) ; } , [ ] ) ; } else if ( expr . type === "ParenthesisNode" ) { return getFactors ( expr . content ) } else { return [ expr ] ; } } } 
function ( expr , context ) { if ( expr . type === "SymbolNode" && expr . name === context . variable . name ) { return new OperatorNode ( '*' , 'multiply' , [ new OperatorNode ( '/' , 'divide' , [ new ConstantNode ( 1 ) , new ConstantNode ( 2 ) ] ) , new OperatorNode ( '^' , 'pow' , [ expr . clone ( ) , new ConstantNode ( 2 ) ] ) ] ) ; } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && expr . op === '*' ) { var constantFactors = [ ] ; var nonConstantFactors = [ ] ; expr . args . forEach ( function ( expr ) { if ( context . isConstant ( expr ) ) { constantFactors . push ( expr ) ; } else { nonConstantFactors . push ( expr ) ; } } ) ; if ( constantFactors . length !== 0 ) { var constantNode = factorsToNode ( constantFactors ) ; var nonConstantNode = factorsToNode ( nonConstantFactors ) ; var nonConstantIntegral = subIntegral ( nonConstantNode , context , "multiplication by constant" ) ; if ( nonConstantIntegral ) { return new OperatorNode ( '*' , 'multiply' , [ constantNode , nonConstantIntegral ] ) ; } } function factorsToNode ( factors ) { if ( factors . length === 1 ) { return factors [ 0 ] ; } else { return new OperatorNode ( '*' , 'multiply' , factors ) ; } } } } 
function ( expr , context ) { if ( expr . type === "OperatorNode" && expr . op === '^' && expr . args [ 0 ] . equals ( context . variable ) && context . isConstant ( expr . args [ 1 ] ) ) { 
function ( expr , context ) { if ( expr . type === 'OperatorNode' && expr . op === '^' ) { if ( context . isConstant ( expr . args [ 0 ] ) && expr . args [ 1 ] . equals ( context . variable ) ) { return new OperatorNode ( '/' , 'divide' , [ expr , new FunctionNode ( 'log' , [ expr . args [ 0 ] ] ) ] ) ; } } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && expr . op === '*' ) { var argsAsPower = expr . args . map ( getExprInPowerForm ) ; 
function ( expr , context , subIntegral ) { if ( expr . type === 'OperatorNode' && expr . op === '^' ) { var base = expr . args [ 0 ] ; var exponent = expr . args [ 1 ] ; if ( base . type === 'OperatorNode' && base . op === '*' ) { return subIntegral ( new OperatorNode ( '*' , 'multiply' , base . args . map ( function ( baseChild ) { return new OperatorNode ( '^' , 'pow' , [ baseChild , exponent ] ) ; } ) ) , context , "distributing power" ) ; } } } 
function ( expr , context , subIntegral ) { if ( expr . type === 'OperatorNode' && expr . op === '^' ) { if ( expr . args [ 0 ] . type === 'OperatorNode' && expr . args [ 0 ] . op === '^' ) { return subIntegral ( new OperatorNode ( '^' , 'pow' , [ expr . args [ 0 ] . args [ 0 ] , new OperatorNode ( '*' , 'multiply' , [ expr . args [ 0 ] . args [ 1 ] , expr . args [ 1 ] ] ) ] ) , context , 'removing double exponential' ) ; } } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && expr . op === '*' ) { var wasChange = false ; var isTotalPositive = true ; var processedArgs = [ ] ; expr . args . forEach ( function ( expr ) { if ( expr . type === "OperatorNode" && expr . args . length === 1 && ( expr . op === '+' || expr . op === '-' ) ) { wasChange = true ; isTotalPositive = isTotalPositive ^ ( expr . op === '-' ) ; processedArgs . push ( expr . args [ 0 ] ) ; } else { processedArgs . push ( expr ) ; } } ) ; if ( wasChange ) { var int = subIntegral ( new OperatorNode ( '*' , 'multiply' , processedArgs ) , context , "removing unary +/- from factors" ) ; if ( int ) { return isTotalPositive ? int : new OperatorNode ( '-' , 'unaryMinus' , [ int ] ) ; } } } } 
function ( expr , context , subIntegral ) { if ( expr . type === "OperatorNode" && expr . op === '*' ) { var sumNode = null ; var otherFactors = null ; for ( var i = 0 ; i < expr . args . length ; i ++ ) { if ( expr . args [ i ] . type === "OperatorNode" && ( expr . args [ i ] . op === '+' || expr . args [ i ] . op === '-' ) ) { sumNode = expr . args [ i ] ; otherFactors = expr . args . filter ( function ( expr , index ) { return index !== i ; } ) ; break ; } } if ( sumNode !== null ) { var newTerms = sumNode . args . map ( function ( term ) { return new OperatorNode ( '*' , 'multiply' , otherFactors . concat ( [ term ] ) ) ; } ) ; return subIntegral ( new OperatorNode ( sumNode . op , sumNode . fn , newTerms ) , context , "product distribution" ) ; } } } 
function ( expr , context , subIntegral ) { var createIntegralWrapper = null ; var uniqueParent = getParentOfUniqueVariable ( expr ) ; if ( uniqueParent !== null && uniqueParent . type === "OperatorNode" ) { if ( uniqueParent . op === '+' || uniqueParent . op === '-' ) { if ( uniqueParent . args . length === 1 ) { 
function ( expr , context , subIntegral ) { var MaxExponentExpanded = 10 ; if ( expr . type === 'OperatorNode' && expr . op === '^' ) { var multipliedOut = tryMultiplyOut ( expr ) ; if ( multipliedOut ) { var int = subIntegral ( multipliedOut , context , "reducing power" ) ; if ( int ) { return int ; } } } else if ( expr . type === 'OperatorNode' && expr . op === '*' ) { for ( var i = 0 ; i < expr . args . length ; i ++ ) { var multipliedOutChild = tryMultiplyOut ( expr . args [ i ] ) ; if ( multipliedOutChild ) { var int = subIntegral ( new OperatorNode ( '*' , 'multiply' , multipliedOutChild . args . concat ( expr . args . slice ( 0 , i ) , expr . args . slice ( i + 1 ) ) ) , context , "reducing power" ) ; if ( int ) { return int ; } } } } 
function ( expr , context , subIntegral ) { if ( expr . type === 'FunctionNode' && expr . name === 'log' && expr . args . length === 1 ) { if ( expr . args . length === 1 && expr . args [ 0 ] . equals ( context . variable ) ) { return new OperatorNode ( '-' , 'subtract' , [ new OperatorNode ( '*' , 'multiply' , [ context . variable , new FunctionNode ( 'log' , [ context . variable ] ) ] ) , context . variable ] ) ; } } } 
function ( expr , context , subIntegral ) { if ( expr . type === 'FunctionNode' && expr . args [ 0 ] . equals ( context . variable ) ) { switch ( expr . name ) { case "sin" : return new OperatorNode ( '-' , 'unaryMinus' , [ new FunctionNode ( "cos" , [ context . variable ] ) ] ) ; case "cos" : return new FunctionNode ( "sin" , [ context . variable ] ) ; case "tan" : 
function _integral ( expr , context , lastRuleComment ) { var exprString = expr . toString ( { parenthesis : 'all' , handler : function ( node , options ) { if ( node . type === 'ParenthesisNode' ) { return '(' + node . content . toString ( options ) + ')' ; } } } ) ; var debugComment = lastRuleComment ? lastRuleComment + ": " : "" ; debugComment += "find integral of " + exprString + " d" + context . variable . name ; context . printDebug ( debugComment ) ; context . debugIndent ++ ; 
function JoyStick ( device ) { var self = this ; Mouse . apply ( this , arguments ) ; this . on ( 'data' , function ( ev ) { if ( ev . type == InputEvent . EVENT_TYPES . EV_INIT ) { self . emit ( 'init' , ev ) ; } } ) ; } 
function Rotary ( device ) { var self = this ; InputEvent . apply ( this , arguments ) ; this . on ( 'data' , function ( ev ) { 
function InputEvent ( device , options ) { var self = this ; EventEmitter . call ( this ) ; if ( device instanceof InputEvent ) { device = device . device ; } this . device = device ; this . options = options || { flags : 'r' , encoding : null } ; this . options . fd = fs . openSync ( this . device , this . options . flags ) ; this . fd = fs . createReadStream ( null , this . options ) ; this . fd . on ( 'data' , function ( data ) { self . emit ( 'raw' , data ) ; self . process ( data ) ; } ) ; this . fd . on ( 'error' , function ( err ) { self . emit ( 'error' , err ) ; } ) ; } 
function Keyboard ( device ) { var self = this ; InputEvent . apply ( this , arguments ) ; this . on ( 'data' , function ( ev ) { 
function Mouse ( device ) { var self = this ; Keyboard . apply ( this , arguments ) ; this . on ( 'data' , function ( ev , data ) { if ( InputEvent . EVENT_TYPES . EV_REL == ev . type ) { 
function ( ) { this . __lux . cleanup . forEach ( ( method ) => method . call ( this ) ) ; this . __lux . cleanup = undefined ; delete this . __lux . cleanup ; } 
function defaultProcess ( template , content ) { return template . replace ( options . parsePattern , function ( match , inner ) { var processed = processPlaceholder ( inner , content ) ; if ( processed === undefined ) { processed = ( ! options . removeUndefined ? match : "" ) ; } return processed ; } ) ; } 
function checkFile ( src ) { if ( ! grunt . file . exists ( src ) ) { grunt . log . error ( "Source file \"" + src + "\" not fount." ) ; return false ; } return true ; } 
function parseInlineValues ( string ) { var match ; var values = { } ; while ( match = attributesRegex . exec ( string ) ) { values [ match [ 1 ] ] = match [ 2 ] ; } return values ; } 
function parseSignature ( signature ) { var match ; var result ; 
function resolveName ( name , values ) { name = String ( name ) . replace ( / \[([^\]]+)\] / g , function ( match , inner ) { return "." + resolveName ( inner , values ) ; } ) ; return mout . object . get ( values , name ) ; } 
function applyIndent ( indent , content ) { if ( ! indent || indent . length < 1 ) { return content ; } return content . split ( "\n" ) . map ( function ( line ) { 
function getArrayValues ( string , values ) { string = string . split ( " " ) . join ( "" ) ; if ( arrayRegex . test ( string ) ) return string . match ( arrayRegex ) [ 1 ] . split ( "," ) ; else { var array = processPlaceholder ( string , values ) ; if ( ! mout . lang . isArray ( array ) ) array = [ ] ; return array ; } } 
function validateIf ( inlineValues , values ) { if ( "_if" in inlineValues ) { var value = inlineValues [ "_if" ] ; delete inlineValues [ "_if" ] ; var params = { } ; var condition = value . replace ( ifRegex , function ( match , varname ) { if ( ! varname ) return match ; var resolved = resolveName ( varname , values ) ; 
function validateRender ( inlineValues ) { if ( "_render" in inlineValues ) { var skipValue = inlineValues [ "_render" ] ; if ( skipValue in options ) { return ! options [ skipValue ] ; } } return false ; } 
function validateForEach ( inlineValues , values , array ) { if ( "_foreach" in inlineValues ) { 
function validateBake ( inlineValues ) { if ( "_bake" in inlineValues ) { var signature = inlineValues [ "_bake" ] ; delete inlineValues [ "_bake" ] ; var set = signature . split ( ">" , 2 ) ; return { src : mout . string . trim ( set [ 0 ] ) , dest : mout . string . trim ( set [ 1 ] ) } ; } return null ; } 
function validateProcess ( inlineValues ) { if ( "_process" in inlineValues ) { var value = inlineValues [ "_process" ] ; delete inlineValues [ "_process" ] ; return String ( value ) . toLowerCase ( ) === 'true' ; } return true ; } 
function extractSection ( content ) { var depth = 0 ; 
function parse ( fileContent , filePath , destFile , values ) { var section = extractSection ( fileContent ) ; if ( section ) { fileContent = processContent ( section . before , values ) ; if ( section . inner ) { fileContent += replaceString ( section . inner , "" , "" , filePath , section . attributes , filePath , destFile , values ) ; } else if ( section . includePath ) { fileContent += replaceFile ( section . linebreak , section . indent , section . includePath , section . attributes , filePath , destFile , values ) ; } fileContent += parse ( section . after , filePath , destFile , values ) ; } else { return processContent ( fileContent , values ) ; } return fileContent ; } 
function processContent ( content , values ) { return mout . lang . isFunction ( options . process ) ? options . process ( content , values ) : content ; } 
function bakeFile ( src , dest , content ) { var srcContent = grunt . file . read ( src ) ; var destContent = parse ( srcContent , src , dest , content ) ; grunt . file . write ( dest , destContent ) ; grunt . log . ok ( "File \"" + dest + "\" created." ) ; } 
function ( clientId , clientSecret ) { this . _clientId = clientId this . _clientSecret = clientSecret this . _auth = new googleAuth . OAuth2 ( clientId , clientSecret , '' ) ; } 
function compare ( a , b , index ) { return ( ( a . charCodeAt ( index ) || 0 ) - ( b . charCodeAt ( index ) || 0 ) || compare ( a , b , index + 1 ) ) } 
function javascript ( node ) { if ( ! is ( node , 'script' ) ) { return false } if ( has ( node , 'type' ) ) { return check ( node . properties . type ) } return ! has ( node , 'language' ) || check ( node . properties . language , 'text/' ) } 
function check ( value , prefix ) { var val if ( typeof value !== 'string' ) { return false } val = trim ( value . split ( ';' , 1 ) [ 0 ] ) . toLowerCase ( ) return val === '' || mime . indexOf ( ( prefix || '' ) + val ) !== - 1 } 
function collapsable ( node ) { return ( is ( 'text' , node ) || element ( node , list ) || embedded ( node ) || bodyOK ( node ) || ( element ( node , 'meta' ) && has ( node , 'itemProp' ) ) ) } 
function Module ( app , options = DEFAULT_OPTIONS ) { const sessionName = options . sessionName || options . session_name || DEFAULT_OPTIONS . sessionName ; const utilityName = options . utilityName || options . utility_name || DEFAULT_OPTIONS . utilityName ; const localsName = options . localsName || options . locals_name || DEFAULT_OPTIONS . localsName ; const viewName = options . viewName || options . view_name || DEFAULT_OPTIONS . viewName ; const beforeSingleRender = options . beforeSingleRender || options . beforeSingleRender || DEFAULT_OPTIONS . beforeSingleRender ; const afterAllRender = options . afterAllRender || options . afterAllRender || DEFAULT_OPTIONS . afterAllRender ; function render ( req , res , next ) { if ( ! req . session [ sessionName ] . length ) { next ( ) ; } else { const resultHTML = [ ] ; async . each ( req . session [ sessionName ] , function ( item , next ) { beforeSingleRender ( item , function ( error , item ) { if ( error ) return next ( error ) ; app . render ( viewName , item , function ( error , html ) { if ( error ) return next ( error ) ; resultHTML . push ( html ) ; next ( null ) ; } ) } ) } , function ( error ) { if ( error ) return next ( error ) ; req . session [ sessionName ] . length = 0 ; afterAllRender ( resultHTML , function ( error , html ) { if ( error ) return next ( error ) ; res . locals [ localsName ] = html ; next ( ) ; } ) } ) } } function FlashMiddleware ( req , res , next ) { if ( ! isObject ( req . session ) ) throw new Error ( 'express-session is required. (npm i express-session)' ) ; if ( ! req . session [ sessionName ] || ! isArray ( req . session [ sessionName ] ) ) req . session [ sessionName ] = [ ] ; req [ utilityName ] = function ( ) { const argc = arguments . length ; let notification ; let redirect = REDIRECT ; * When there is no redirect, notifications must be rendered now and since * rendering is async (and this method is sync), a *promise* like function is returned. * The function can be called with a callback that will be called after all notifcations * are rendered, otherwise, rendering will be done during the next request. */ return function ManualRender ( callback ) { render ( req , res , callback ) ; } } } render ( req , res , next ) ; } return FlashMiddleware ; } 
function render ( req , res , next ) { if ( ! req . session [ sessionName ] . length ) { next ( ) ; } else { const resultHTML = [ ] ; async . each ( req . session [ sessionName ] , function ( item , next ) { beforeSingleRender ( item , function ( error , item ) { if ( error ) return next ( error ) ; app . render ( viewName , item , function ( error , html ) { if ( error ) return next ( error ) ; resultHTML . push ( html ) ; next ( null ) ; } ) } ) } , function ( error ) { if ( error ) return next ( error ) ; req . session [ sessionName ] . length = 0 ; afterAllRender ( resultHTML , function ( error , html ) { if ( error ) return next ( error ) ; res . locals [ localsName ] = html ; next ( ) ; } ) } ) } } 
function FlashMiddleware ( req , res , next ) { if ( ! isObject ( req . session ) ) throw new Error ( 'express-session is required. (npm i express-session)' ) ; if ( ! req . session [ sessionName ] || ! isArray ( req . session [ sessionName ] ) ) req . session [ sessionName ] = [ ] ; req [ utilityName ] = function ( ) { const argc = arguments . length ; let notification ; let redirect = REDIRECT ; * When there is no redirect, notifications must be rendered now and since * rendering is async (and this method is sync), a *promise* like function is returned. * The function can be called with a callback that will be called after all notifcations * are rendered, otherwise, rendering will be done during the next request. */ return function ManualRender ( callback ) { render ( req , res , callback ) ; } } } render ( req , res , next ) ; } 
function ( s ) { let md5blks = [ ] , i ; for ( i = 0 ; i < 64 ; i += 4 ) { md5blks [ i >> 2 ] = s . charCodeAt ( i ) + ( s . charCodeAt ( i + 1 ) << 8 ) + ( s . charCodeAt ( i + 2 ) << 16 ) + ( s . charCodeAt ( i + 3 ) << 24 ) ; } return md5blks ; } 
function getFrameworkPath ( { framework , baseDir } ) { const pkgPath = path . join ( baseDir , 'package.json' ) ; assert ( fs . existsSync ( pkgPath ) , ` ${ pkgPath } ` ) ; const moduleDir = path . join ( baseDir , 'node_modules' ) ; const pkg = utility . readJSONSync ( pkgPath ) ; 
function getFrameworkOrEggPath ( cwd , eggNames ) { eggNames = eggNames || [ 'egg' ] ; const moduleDir = path . join ( cwd , 'node_modules' ) ; if ( ! fs . existsSync ( moduleDir ) ) { return '' ; } 
function autoInjectServices ( object , args ) { if ( args . length === 0 ) return ; let code = object . constructor . toString ( ) ; code = code . match ( 'constructor\\([\\$a-zA-Z0-9\\,\\s]+\\)' ) [ 0 ] ; code = code . substring ( code . indexOf ( '(' ) + 1 , code . indexOf ( ')' ) ) ; code = code . split ( ', ' ) ; for ( let i = 0 ; i < code . length ; i ++ ) { Object . defineProperty ( object , code [ i ] , { value : args [ i ] } ) } } 
function SettableObservable ( fn , context , initialValue ) { this . lastSetValue = new SimpleObservable ( initialValue ) ; function observe ( ) { return fn . call ( context , this . lastSetValue . get ( ) ) ; } this . handler = this . handler . bind ( this ) ; 
function SetterObservable ( getter , setter ) { this . setter = setter ; this . observation = new Observation ( getter ) ; this . handler = this . handler . bind ( this ) ; 
function AsyncObservable ( fn , context , initialValue ) { this . resolve = this . resolve . bind ( this ) ; this . lastSetValue = new SimpleObservable ( initialValue ) ; this . handler = this . handler . bind ( this ) ; function observe ( ) { this . resolveCalled = false ; 
function load ( dotGraph , appendTo ) { var dotAST = parseDot ( dotGraph ) ; if ( dotAST . length > 1 && appendTo !== undefined ) { throw new Error ( 'Dot file contains multiple graphs. Cannot use `saveTo` in this case' ) ; } if ( ! appendTo ) { appendTo = require ( 'ngraph.graph' ) ( ) ; } 
function updateNodes ( parent , old , vnodes , recycling , hooks , nextSibling , ns ) { if ( old === vnodes || old == null && vnodes == null ) return else if ( old == null ) createNodes ( parent , vnodes , 0 , vnodes . length , hooks , nextSibling , ns ) else if ( vnodes == null ) removeNodes ( old , 0 , old . length , vnodes ) else { if ( old . length === vnodes . length ) { var isUnkeyed = false for ( var i = 0 ; i < vnodes . length ; i ++ ) { if ( vnodes [ i ] != null && old [ i ] != null ) { isUnkeyed = vnodes [ i ] . key == null && old [ i ] . key == null break } } if ( isUnkeyed ) { for ( var i = 0 ; i < old . length ; i ++ ) { if ( old [ i ] === vnodes [ i ] ) continue else if ( old [ i ] == null && vnodes [ i ] != null ) createNode ( parent , vnodes [ i ] , hooks , ns , getNextSibling ( old , i + 1 , nextSibling ) ) else if ( vnodes [ i ] == null ) removeNodes ( old , i , i + 1 , vnodes ) else updateNode ( parent , old [ i ] , vnodes [ i ] , hooks , getNextSibling ( old , i + 1 , nextSibling ) , recycling , ns ) } return } } recycling = recycling || isRecyclable ( old , vnodes ) if ( recycling ) { var pool = old . pool old = old . concat ( old . pool ) } var oldStart = 0 , start = 0 , oldEnd = old . length - 1 , end = vnodes . length - 1 , map while ( oldEnd >= oldStart && end >= start ) { var o = old [ oldStart ] , v = vnodes [ start ] if ( o === v && ! recycling ) oldStart ++ , start ++ else if ( o == null ) oldStart ++ else if ( v == null ) start ++ else if ( o . key === v . key ) { var shouldRecycle = ( pool != null && oldStart >= old . length - pool . length ) || ( ( pool == null ) && recycling ) oldStart ++ , start ++ updateNode ( parent , o , v , hooks , getNextSibling ( old , oldStart , nextSibling ) , shouldRecycle , ns ) if ( recycling && o . tag === v . tag ) insertNode ( parent , toFragment ( o ) , nextSibling ) } else { var o = old [ oldEnd ] if ( o === v && ! recycling ) oldEnd -- , start ++ else if ( o == null ) oldEnd -- else if ( v == null ) start ++ else if ( o . key === v . key ) { var shouldRecycle = ( pool != null && oldEnd >= old . length - pool . length ) || ( ( pool == null ) && recycling ) updateNode ( parent , o , v , hooks , getNextSibling ( old , oldEnd + 1 , nextSibling ) , shouldRecycle , ns ) if ( recycling || start < end ) insertNode ( parent , toFragment ( o ) , getNextSibling ( old , oldStart , nextSibling ) ) oldEnd -- , start ++ } else break } } while ( oldEnd >= oldStart && end >= start ) { var o = old [ oldEnd ] , v = vnodes [ end ] if ( o === v && ! recycling ) oldEnd -- , end -- else if ( o == null ) oldEnd -- else if ( v == null ) end -- else if ( o . key === v . key ) { var shouldRecycle = ( pool != null && oldEnd >= old . length - pool . length ) || ( ( pool == null ) && recycling ) updateNode ( parent , o , v , hooks , getNextSibling ( old , oldEnd + 1 , nextSibling ) , shouldRecycle , ns ) if ( recycling && o . tag === v . tag ) insertNode ( parent , toFragment ( o ) , nextSibling ) if ( o . dom != null ) nextSibling = o . dom oldEnd -- , end -- } else { if ( ! map ) map = getKeyMap ( old , oldEnd ) if ( v != null ) { var oldIndex = map [ v . key ] if ( oldIndex != null ) { var movable = old [ oldIndex ] var shouldRecycle = ( pool != null && oldIndex >= old . length - pool . length ) || ( ( pool == null ) && recycling ) updateNode ( parent , movable , v , hooks , getNextSibling ( old , oldEnd + 1 , nextSibling ) , recycling , ns ) insertNode ( parent , toFragment ( movable ) , nextSibling ) old [ oldIndex ] . skip = true if ( movable . dom != null ) nextSibling = movable . dom } else { var dom = createNode ( parent , v , hooks , ns , nextSibling ) nextSibling = dom } } end -- } if ( end < start ) break } createNodes ( parent , vnodes , start , end + 1 , hooks , nextSibling , ns ) removeNodes ( old , oldStart , oldEnd + 1 , vnodes ) } } 
function removeNodes ( vnodes , start , end , context ) { for ( var i = start ; i < end ; i ++ ) { var vnode = vnodes [ i ] if ( vnode != null ) { if ( vnode . skip ) vnode . skip = false else removeNode ( vnode , context ) } } } 
function setAttrs ( vnode , attrs2 , ns ) { for ( var key2 in attrs2 ) { setAttr ( vnode , key2 , null , attrs2 [ key2 ] , ns ) } } 
function updateStyle ( element , old , style ) { if ( old === style ) element . style . cssText = "" , old = null if ( style == null ) element . style . cssText = "" else if ( typeof style === "string" ) element . style . cssText = style else { if ( typeof old === "string" ) element . style . cssText = "" for ( var key2 in style ) { element . style [ key2 ] = style [ key2 ] } if ( old != null && typeof old !== "string" ) { for ( var key2 in old ) { if ( ! ( key2 in style ) ) element . style [ key2 ] = "" } } } } 
function updateEvent ( vnode , key2 , value ) { var element = vnode . dom var callback = typeof onevent !== "function" ? value : function ( e ) { var result = value . call ( element , e ) onevent . call ( element , e ) return result } if ( key2 in element ) element [ key2 ] = typeof value === "function" ? callback : null else { var eventName = key2 . slice ( 2 ) if ( vnode . events === undefined ) vnode . events = { } if ( vnode . events [ key2 ] === callback ) return if ( vnode . events [ key2 ] != null ) element . removeEventListener ( eventName , vnode . events [ key2 ] , false ) if ( typeof value === "function" ) { vnode . events [ key2 ] = callback element . addEventListener ( eventName , vnode . events [ key2 ] , false ) } } } 
function initLifecycle ( source , vnode , hooks ) { if ( typeof source . oninit === "function" ) source . oninit . call ( vnode . state , vnode ) if ( typeof source . oncreate === "function" ) hooks . push ( source . oncreate . bind ( vnode . state , vnode ) ) } 
function ( message ) { message . tabId = chrome . devtools . inspectedWindow . tabId chrome . extension . sendMessage ( message ) } 
function ( ) { var sendTracerInit = function ( ) { sendObjectToInspectedPage ( { content : { type : "MEIOSIS_TRACER_INIT" } } ) } var triggerStreamValue = function ( index , value ) { sendObjectToInspectedPage ( { content : { type : "MEIOSIS_TRIGGER_STREAM_VALUE" , index : index , value : value } } ) } tracer = window . meiosisTracer ( { selector : "#meiosis-tracer" , sendTracerInit : sendTracerInit , triggerStreamValue : triggerStreamValue , direction : "auto" } ) } 
function recurse ( streams ) { if ( streams . length < 2 ) return streams [ 0 ] . pipe ( streams [ 1 ] ) recurse ( streams . slice ( 1 ) ) } 
function TemporaryCredentials ( params ) { AWS . Credentials . call ( this ) ; this . loadMasterCredentials ( ) ; this . expired = true ; this . params = params || { } ; if ( this . params . RoleArn ) { this . params . RoleSessionName = this . params . RoleSessionName || 'temporary-credentials' ; } this . service = new AWS . STS ( { params : this . params } ) ; } 
function refresh ( callback ) { var self = this ; if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; self . service . config . credentials = self . masterCredentials ; var operation = self . params . RoleArn ? self . service . assumeRole : self . service . getSessionToken ; operation . call ( self . service , function ( err , data ) { if ( ! err ) { self . service . credentialsFrom ( data , self ) ; } callback ( err ) ; } ) ; } 
function addPositions ( base , relative ) { return { line : base . line + relative . line - 1 , 
function SAMLCredentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . params = params ; this . service = new AWS . STS ( { params : this . params } ) ; } 
function refresh ( callback ) { var self = this ; if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; self . metadataService . loadCredentials ( function ( err , creds ) { if ( ! err ) { self . expired = false ; self . metadata = creds ; self . accessKeyId = creds . AccessKeyId ; self . secretAccessKey = creds . SecretAccessKey ; self . sessionToken = creds . Token ; self . expireTime = new Date ( creds . Expiration ) ; } callback ( err ) ; } ) ; } 
function Service ( config ) { if ( ! this . loadServiceClass ) { throw AWS . util . error ( new Error ( ) , 'Service must be constructed with `new\' operator' ) ; } var ServiceClass = this . loadServiceClass ( config || { } ) ; if ( ServiceClass ) return new ServiceClass ( config ) ; this . initialize ( config ) ; } 
function getSignerClass ( ) { var version ; if ( this . config . signatureVersion ) { version = this . config . signatureVersion ; } else { version = this . api . signatureVersion ; } return AWS . Signers . RequestSigner . getVersion ( version ) ; } 
function defineMethods ( svc ) { AWS . util . each ( svc . prototype . api . operations , function iterator ( method ) { if ( svc . prototype [ method ] ) return ; svc . prototype [ method ] = function ( params , callback ) { return this . makeRequest ( method , params , callback ) ; } ; } ) ; } 
function defineService ( serviceIdentifier , versions , features ) { if ( ! Array . isArray ( versions ) ) { features = versions ; versions = [ ] ; } var svc = inherit ( AWS . Service , features || { } ) ; if ( typeof serviceIdentifier === 'string' ) { AWS . Service . addVersions ( svc , versions ) ; var identifier = svc . serviceIdentifier || serviceIdentifier ; svc . serviceIdentifier = identifier ; } else { 
function abort ( ) { this . removeAllListeners ( 'validateResponse' ) ; this . removeAllListeners ( 'extractError' ) ; this . on ( 'validateResponse' , function addAbortedError ( resp ) { resp . error = AWS . util . error ( new Error ( 'Request aborted by user' ) , { code : 'RequestAbortedError' , retryable : false } ) ; } ) ; if ( this . httpRequest . stream ) { 
function eachItem ( callback ) { function wrappedCallback ( err , data ) { if ( err ) return callback ( err , null ) ; if ( data === null ) return callback ( null , null ) ; var config = this . request . service . paginationConfig ( this . request . operation ) ; var resultKey = config . resultKey ; if ( Array . isArray ( resultKey ) ) resultKey = resultKey [ 0 ] ; var results = AWS . util . jamespath . query ( resultKey , data ) ; AWS . util . arrayEach ( results , function ( result ) { AWS . util . arrayEach ( result , function ( item ) { callback ( null , item ) ; } ) ; } ) ; } this . eachPage ( wrappedCallback ) ; } 
function createReadStream ( ) { var streams = AWS . util . nodeRequire ( 'stream' ) ; var req = this ; var stream = null ; var legacyStreams = false ; if ( AWS . HttpClient . streamsApiVersion === 2 ) { stream = new streams . Readable ( ) ; stream . _read = function ( ) { } ; } else { stream = new streams . Stream ( ) ; stream . readable = true ; } stream . sent = false ; stream . on ( 'newListener' , function ( event ) { if ( ! stream . sent && ( event === 'data' || event === 'readable' ) ) { if ( event === 'data' ) legacyStreams = true ; stream . sent = true ; process . nextTick ( function ( ) { req . send ( function ( ) { } ) ; } ) ; } } ) ; this . on ( 'httpHeaders' , function streamHeaders ( statusCode , headers , resp ) { if ( statusCode < 300 ) { this . httpRequest . _streaming = true ; req . removeListener ( 'httpData' , AWS . EventListeners . Core . HTTP_DATA ) ; req . removeListener ( 'httpError' , AWS . EventListeners . Core . HTTP_ERROR ) ; req . on ( 'httpError' , function streamHttpError ( error , resp ) { resp . error = error ; resp . error . retryable = false ; } ) ; var httpStream = resp . httpResponse . stream ; if ( legacyStreams ) { httpStream . on ( 'data' , function ( arg ) { stream . emit ( 'data' , arg ) ; } ) ; httpStream . on ( 'end' , function ( ) { stream . emit ( 'end' ) ; } ) ; } else { httpStream . on ( 'readable' , function ( ) { var chunk ; do { chunk = httpStream . read ( ) ; if ( chunk !== null ) stream . push ( chunk ) ; } while ( chunk !== null ) ; stream . read ( 0 ) ; } ) ; httpStream . on ( 'end' , function ( ) { stream . push ( null ) ; } ) ; } httpStream . on ( 'error' , function ( err ) { stream . emit ( 'error' , err ) ; } ) ; } } ) ; this . on ( 'error' , function ( err ) { stream . emit ( 'error' , err ) ; } ) ; return stream ; } 
function constructor ( service , state ) { this . service = service ; this . state = state ; if ( typeof this . state === 'object' ) { AWS . util . each . call ( this , this . state , function ( key , value ) { this . state = key ; this . expectedValue = value ; } ) ; } this . loadWaiterConfig ( this . state ) ; if ( ! this . expectedValue ) { this . expectedValue = this . config . successValue ; } } 
function checkSuccess ( resp ) { if ( ! this . config . successPath ) { return resp . httpResponse . statusCode < 300 ; } var r = AWS . util . jamespath . find ( this . config . successPath , resp . data ) ; if ( this . config . failureValue && this . config . failureValue . indexOf ( r ) >= 0 ) { return null ; 
function checkError ( resp ) { var value = this . config . successValue ; if ( typeof value === 'number' ) { return resp . httpResponse . statusCode === value ; } else { return resp . error && resp . error . code === value ; } } 
function WebIdentityCredentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . params = params ; this . params . RoleSessionName = this . params . RoleSessionName || 'web-identity' ; this . service = new AWS . STS ( { params : this . params } ) ; this . data = null ; } 
function SharedIniFileCredentials ( options ) { AWS . Credentials . call ( this ) ; options = options || { } ; this . filename = options . filename ; this . profile = options . profile || process . env . AWS_PROFILE || 'default' ; this . get ( function ( ) { } ) ; } 
function refresh ( callback ) { if ( ! callback ) callback = function ( err ) { if ( err ) throw err ; } ; try { if ( ! this . filename ) this . loadDefaultFilename ( ) ; var creds = AWS . util . ini . parse ( AWS . util . readFileSync ( this . filename ) ) ; if ( typeof creds [ this . profile ] === 'object' ) { this . accessKeyId = creds [ this . profile ] [ 'aws_access_key_id' ] ; this . secretAccessKey = creds [ this . profile ] [ 'aws_secret_access_key' ] ; this . sessionToken = creds [ this . profile ] [ 'aws_session_token' ] ; } if ( ! this . accessKeyId || ! this . secretAccessKey ) { throw new Error ( 'Credentials not set in ' + this . filename + ' using profile ' + this . profile ) ; } this . expired = false ; callback ( ) ; } catch ( err ) { callback ( err ) ; } } 
function CognitoIdentityCredentials ( params ) { AWS . Credentials . call ( this ) ; this . expired = true ; this . webIdentityCredentials = new AWS . WebIdentityCredentials ( params ) ; this . cognito = new AWS . CognitoIdentity ( { params : params } ) ; this . sts = new AWS . STS ( ) ; this . params = params ; this . data = null ; this . identityId = null ; this . loadCachedId ( ) ; } 
function getId ( callback ) { var self = this ; if ( typeof self . params . IdentityId === 'string' ) return callback ( ) ; self . cognito . getId ( function ( err , data ) { if ( ! err && data . IdentityId ) { self . params . IdentityId = data . IdentityId ; } callback ( err , data ) ; } ) ; } 
function Barrels ( sourceFolder ) { if ( ! ( this instanceof Barrels ) ) return new Barrels ( sourceFolder ) ; 
function ( collection , key , ip ) { if ( ! collection ) { collection = { } ; } if ( ! collection [ key ] ) { collection [ key ] = [ ] ; } collection [ key ] . push ( ip ) ; } 
function forward ( obj , target , onlyAccessors ) { onlyAccessors = onlyAccessors || false ; for ( var k in target ) { ( function ( k ) { if ( typeof ( target [ k ] ) == 'function' ) { if ( ! onlyAccessors ) { obj [ k ] = target [ k ] . bind ( target ) ; } } else { Object . defineProperty ( obj , k , { get : function ( ) { return target [ k ] ; } , set : function ( x ) { target [ k ] = x ; } } ) ; } } ) ( k ) ; } } 
function getDataContext ( ctxOrCanvas ) { if ( ctxOrCanvas instanceof HTMLCanvasElement ) { return getDataContext ( ctxOrCanvas . getContext ( '2d' ) ) ; } var ctx = ctxOrCanvas ; if ( stubGetDataContext ) { return stubGetDataContext ( ctx ) ; } else { for ( var i = 0 ; i < getDataContext . cache . length ; i ++ ) { var pair = getDataContext . cache [ i ] ; if ( pair [ 0 ] == ctx ) return pair [ 1 ] ; } var dtx = new DataContext ( ctx ) ; getDataContext . cache . push ( [ ctx , dtx ] ) ; return dtx ; } } 
function RecordingContext ( ctx ) { forward ( this , ctx , true ) ; var calls = [ ] ; this . calls = calls ; for ( var k in ctx ) { ( function ( k ) { if ( typeof ( ctx [ k ] ) != 'function' ) return ; this [ k ] = function ( ) { 
function transformedCalls ( calls , args ) { var image = args [ 0 ] , sx = 0 , sy = 0 , sWidth = image . width , sHeight = image . height , dx , dy , dWidth = image . width , dHeight = image . height ; if ( args . length == 3 ) { 
function ( originalCall ) { var call = originalCall . slice ( ) , 
function findRecorder ( div , selector ) { if ( ! div ) { if ( ! RecordingContext . recorders ) { throw 'You must call RecordingContext.recordAll() before using other RecordingContext static methods' ; } else if ( RecordingContext . recorders . length == 0 ) { throw 'Called a RecordingContext method, but no canvases are being recorded.' ; } else if ( RecordingContext . recorders . length > 1 ) { throw 'Called a RecordingContext method while multiple canvases were being recorded. Specify one using a div and selector.' ; } else { return RecordingContext . recorders [ 0 ] [ 1 ] ; } } else { return RecordingContext . recorderForSelector ( div , selector ) ; } } 
function ClickTrackingContext ( ctx , px , py ) { forward ( this , ctx ) ; var stack = [ ] ; this . hits = [ ] ; this . hit = null ; var that = this ; function recordHit ( ) { that . hits . unshift ( Array . prototype . slice . call ( stack ) ) ; that . hit = that . hits [ 0 ] ; } this . pushObject = function ( o ) { stack . unshift ( o ) ; } ; this . popObject = function ( ) { stack . shift ( ) ; } ; this . reset = function ( ) { this . hits = [ ] ; this . hit = null ; } ; 
function sort ( vector ) { 
function quartiles ( data ) { var qValues = new Array ( 2 ) , vector ; vector = new Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i ++ ) { vector [ i ] = data [ i ] [ 1 ] ; } qValues [ 0 ] = quantile ( vector , 0.25 ) ; qValues [ 1 ] = quantile ( vector , 0.75 ) ; return qValues ; } 
function quantile ( vector , percent ) { var numValues = vector . length , id , value ; 
function filter ( FLG ) { return function filter ( data ) { var qValues , iqr , bounds = new Array ( 4 ) , idx , d , outliers = [ ] ; 
function transform ( ) { var kde = new KDE ( ) ; return function transform ( data ) { kde . estimator ( data , 'silverman' ) ; return kde . eval ( data ) ; } ; } 
function getBuffer ( W ) { var buffer = new Array ( W ) ; for ( var i = 0 ; i < W ; i ++ ) { buffer [ i ] = 0 ; } return buffer ; } 
function onData ( W ) { var buffer = getBuffer ( W ) , full = false , oldVal , sos = 0 , mean = 0 , N = 0 , delta = 0 , old_delta = 0 , new_delta = 0 ; return function onData ( newVal ) { 
function kde_estimator_silverman ( vector ) { var sigma , N = vector . length , A ; 
function stringEscape ( str ) { let stringArray = str . toString ( ) . split ( '' ) ; for ( let j = 0 ; j < stringArray . length ; j ++ ) { for ( let i = 0 ; i < escapeArray . length ; i ++ ) { if ( stringArray [ j ] === escapeArray [ i ] ) { stringArray [ j ] = '\\' + escapeArray [ i ] ; } } } return stringArray . join ( '' ) ; } 
function fromMs ( ms , format = 'mm:ss' ) { if ( typeof ms !== 'number' || Number . isNaN ( ms ) ) { throw new Error ( 'NaN error' ) } let absMs = Math . abs ( ms ) let negative = ( ms < 0 ) let hours = Math . floor ( absMs / HOUR ) let minutes = Math . floor ( absMs % HOUR / MINUTE ) let seconds = Math . floor ( absMs % MINUTE / SECOND ) let miliseconds = Math . floor ( absMs % SECOND ) return formatTime ( { negative , hours , minutes , seconds , miliseconds } , format ) } 
function formatTime ( time , format ) { let showMs let showSc let showHr switch ( format . toLowerCase ( ) ) { case 'hh:mm:ss.sss' : showMs = true showSc = true showHr = true break case 'hh:mm:ss' : showMs = ! ( ! time . miliseconds ) showSc = true showHr = true break case 'hh:mm' : showMs = ! ( ! time . miliseconds ) showSc = showMs || ! ( ! time . seconds ) showHr = true break case 'mm:ss' : showMs = ! ( ! time . miliseconds ) showSc = true showHr = ! ( ! time . hours ) break case 'mm:ss.sss' : showMs = true showSc = true showHr = ! ( ! time . hours ) break default : throw new Error ( TIME_FORMAT_ERRMSG ) } let hh = zeroFill ( 2 , time . hours ) let mm = zeroFill ( 2 , time . minutes ) let ss = zeroFill ( 2 , time . seconds ) let sss = zeroFill ( 3 , time . miliseconds ) return ( time . negative ? '-' : '' ) + ( showHr ? ( showMs ? ` ${ hh } ${ mm } ${ ss } ${ sss } ` : showSc ? ` ${ hh } ${ mm } ${ ss } ` : ` ${ hh } ${ mm } ` ) : ( showMs ? ` ${ mm } ${ ss } ${ sss } ` : ` ${ mm } ${ ss } ` ) ) } 
function toMacAddress ( internalRepresentation ) { const parts = [ ] ; 
function getAttrs ( ) { if ( attrRes !== null ) { return attrRes ; } ; var xmlnsAlias ; var nsAttrName ; var attrList = isNamespace && hasSurmiseNS ? [ ] : null ; var i = attrStartPos + 1 ; 
function Hexdump ( data , options ) { var self = this ; self . hexdump = [ ] ; self . hex = false ; self . options = { container : options . container || '' , width : options . width || 16 , byteGrouping : options . byteGrouping || 0 , ascii : options . ascii , lineNumber : options . lineNumber , endian : options . endian || 'big' , html : options . html , base : options . base || 'hexadecimal' , nonPrintable : options . nonPrintable || '.' , style : { lineNumberLeft : options . style . lineNumberLeft || '' , lineNumberRight : options . style . lineNumberRight || ':' , stringLeft : options . style . stringLeft || '|' , stringRight : options . style . stringRight || '|' , hexLeft : options . style . hexLeft || '' , hexRight : options . style . hexRight || '' , hexNull : options . style . hexNull || '.' , stringNull : options . style . stringNull || ' ' } } ; if ( self . options . base == 'hex' ) { self . hex = true ; } else if ( self . options . base == 'hexadecimal' ) { self . hex = true ; } ; 
function get ( czConfig ) { const scopes = [ ] ; if ( typeof czConfig . scopes === 'undefined' ) { return defaults ; } for ( const scope of czConfig . scopes ) { scopes . push ( scope . name ) ; } if ( typeof czConfig . scopeOverrides === 'undefined' ) { return scopes ; } for ( const type of Object . keys ( czConfig . scopeOverrides ) ) { for ( const scope of czConfig . scopeOverrides [ type ] ) { scopes . push ( scope . name ) ; } } return scopes . filter ( function ( value , index , scope ) { return scope . indexOf ( value ) === index ; } ) ; } 
function get ( pathOrCzConfig , defaultConfig ) { const config = Object . assign ( cloneDeep ( defaults ) , cloneDeep ( defaultConfig ) || { } ) ; let czConfig = pathOrCzConfig || { } ; if ( typeof pathOrCzConfig === 'string' ) { czConfig = CzConfig . get ( pathOrCzConfig ) ; } 
function get ( path ) { let czConfig ; try { fs . accessSync ( path , fs . R_OK ) ; czConfig = require ( path ) ; } catch ( err ) { czConfig = { } ; } return czConfig ; } 
function get ( czConfig ) { const types = [ ] ; if ( typeof czConfig . types === 'undefined' ) { return defaults ; } for ( const type of czConfig . types ) { types . push ( type . value ) ; } return types ; } 
function Colog ( ) { if ( ( this instanceof Colog ) === false ) { return new Colog ( ) ; } var self = this ; var base = '\x1B[%dm' ; var reset = 0 ; var colorLightValueChange = 60 ; var lastCommand = 'log' ; var lastLineLength = 0 ; var color = { 'black' : [ 30 , 39 ] , 'red' : [ 31 , 39 ] , 'green' : [ 32 , 39 ] , 'yellow' : [ 33 , 39 ] , 'blue' : [ 34 , 39 ] , 'magenta' : [ 35 , 39 ] , 'cyan' : [ 36 , 39 ] , 'white' : [ 37 , 39 ] } ; var background = { 'black' : [ 40 , 49 ] , 'red' : [ 41 , 49 ] , 'green' : [ 42 , 49 ] , 'yellow' : [ 43 , 49 ] , 'blue' : [ 44 , 49 ] , 'magenta' : [ 45 , 49 ] , 'cyan' : [ 46 , 49 ] , 'white' : [ 47 , 49 ] } ; var effect = { 'b' : [ 1 , 22 ] , 'u' : [ 4 , 24 ] , 'i' : [ 7 , 27 ] , 's' : [ 9 , 29 ] , 'bold' : [ 1 , 22 ] , 'underline' : [ 4 , 24 ] , 'inverse' : [ 7 , 27 ] , 'strike' : [ 9 , 29 ] } ; var progress = [ 0 , 100 ] ; var defaults = { progress : { zero : '░', one : '▓', length : 40 , sufix : ' ~ %d%% (%s / %s)' , effects : [ 'colorYellow' ] , description : '' } } ; var beSilent = false ; var consoleWidth = 100 ; if ( process . stdout . isTTY ) { consoleWidth = process . stdout . getWindowSize ( ) [ 0 ] ; process . stdout . on ( 'resize' , function ( ) { consoleWidth = process . stdout . getWindowSize ( ) [ 0 ] ; } ) ; } function use ( code , lightColor ) { return util . format ( base , ( lightColor === true ) ? code + colorLightValueChange : code ) ; } function text ( message , effect , lightColor ) { return [ use ( effect [ 0 ] , lightColor ) , String ( message ) , use ( effect [ 1 ] , lightColor ) ] . join ( '' ) ; } function clearLine ( ) { if ( process . stdout . clearLine ) { process . stdout . clearLine ( ) ; process . stdout . cursorTo ( 0 ) ; } else { var str = '\r' , i = 0 ; for ( i = 0 ; i < lastLineLength ; i ++ ) { str += ' ' ; } process . stdout . write ( str ) ; } lastLineLength = 0 ; return self ; } this . silent = function ( isSilent ) { beSilent = ( isSilent ) ? true : false ; } this . getWidth = function ( ) { return consoleWidth ; } ; this . configureProgress = function ( zero , one , length , effects ) { length = Math . abs ( parseInt ( length , 10 ) ) ; defaults . progress . zero = ( zero !== undefined ) ? zero : defaults . progress . zero ; defaults . progress . one = ( one !== undefined ) ? one : defaults . progress . one ; defaults . progress . length = ( length > 0 ) ? length : defaults . progress . length ; defaults . progress . effects = ( effects instanceof Array ) ? effects : defaults . progress . effects ; return this ; } ; this . setProgressDescription = function ( text ) { text = String ( text ) ; defaults . progress . description = text ; return this ; } ; this . progress = function ( minOrChange , max , effects , returnString ) { if ( beSilent ) { return this ; } if ( lastCommand === 'progress' ) { clearLine ( ) ; } var i = 0 , prc = 0 , fullBarsToDraw = 0 , emptyBarsToDraw = 0 , totalBars = defaults . progress . length ; * Return "reset all effects" code * @returns {*} */ this . reset = function ( ) { return use ( reset ) ; } ; this . b = function ( message ) { return text ( message , effect . bold ) ; } ; this . u = function ( message ) { return text ( message , effect . underline ) ; } ; this . s = function ( message ) { return text ( message , effect . strike ) ; } ; this . i = function ( message ) { return text ( message , effect . inverse ) ; } ; this . bold = function ( message ) { return this . b ( message ) ; } ; this . underline = function ( message ) { return this . u ( message ) ; } ; this . strike = function ( message ) { return this . s ( message ) ; } ; this . inverse = function ( message ) { return this . i ( message ) ; } ; this . color = function ( message , name , light ) { if ( color [ name ] === undefined ) { var colors = [ ] , c ; for ( c in color ) { if ( color . hasOwnProperty ( c ) ) { colors . push ( c ) ; } } throw new Error ( 'Undefined color. Use: ' + colors . join ( ', ' ) ) ; } return text ( message , color [ name ] , light ) ; } ; this . black = function ( message , light ) { return text ( message , color . black , light ) ; } ; this . red = function ( message , light ) { return text ( message , color . red , light ) ; } ; this . green = function ( message , light ) { return text ( message , color . green , light ) ; } ; this . yellow = function ( message , light ) { return text ( message , color . yellow , light ) ; } ; this . blue = function ( message , light ) { return text ( message , color . blue , light ) ; } ; this . magenta = function ( message , light ) { return text ( message , color . magenta , light ) ; } ; this . cyan = function ( message , light ) { return text ( message , color . cyan , light ) ; } ; this . white = function ( message , light ) { return text ( message , color . white , light ) ; } ; this . colorBlack = function ( message , light ) { return this . black ( message , light ) ; } ; this . colorRed = function ( message , light ) { return this . red ( message , light ) ; } ; this . colorGreen = function ( message , light ) { return this . green ( message , light ) ; } ; this . colorYellow = function ( message , light ) { return this . yellow ( message , light ) ; } ; this . colorBlue = function ( message , light ) { return this . blue ( message , light ) ; } ; this . colorMagenta = function ( message , light ) { return this . magenta ( message , light ) ; } ; this . colorCyan = function ( message , light ) { return this . cyan ( message , light ) ; } ; this . colorWhite = function ( message , light ) { return this . white ( message , light ) ; } ; this . background = function ( message , name , light ) { if ( background [ name ] === undefined ) { var backgrounds = [ ] , b ; for ( b in background ) { if ( background . hasOwnProperty ( b ) ) { backgrounds . push ( b ) ; } } throw new Error ( 'Undefined color. Use: ' + backgrounds . join ( ', ' ) ) ; } return text ( message , background [ name ] , light ) ; } ; this . bgBlack = function ( message , light ) { return text ( message , background . black , light ) ; } ; this . bgRed = function ( message , light ) { return text ( message , background . red , light ) ; } ; this . bgGreen = function ( message , light ) { return text ( message , background . green , light ) ; } ; this . bgYellow = function ( message , light ) { return text ( message , background . yellow , light ) ; } ; this . bgBlue = function ( message , light ) { return text ( message , background . blue , light ) ; } ; this . bgMagenta = function ( message , light ) { return text ( message , background . magenta , light ) ; } ; this . bgCyan = function ( message , light ) { return text ( message , background . cyan , light ) ; } ; this . bgWhite = function ( message , light ) { return text ( message , background . white , light ) ; } ; this . backgroundBlack = function ( message , light ) { return this . bgBlack ( message , light ) ; } ; this . backgroundRed = function ( message , light ) { return this . bgRed ( message , light ) ; } ; this . backgroundGreen = function ( message , light ) { return this . bgGreen ( message , light ) ; } ; this . backgroundYellow = function ( message , light ) { return this . bgYellow ( message , light ) ; } ; this . backgroundBlue = function ( message , light ) { return this . bgBlue ( message , light ) ; } ; this . backgroundMagenta = function ( message , light ) { return this . bgMagenta ( message , light ) ; } ; this . backgroundCyan = function ( message , light ) { return this . bgCyan ( message , light ) ; } ; this . backgroundWhite = function ( message , light ) { return this . bgWhite ( message , light ) ; } ; this . log = function ( message ) { if ( beSilent ) { return this ; } if ( lastCommand === 'progress' || lastCommand === 'write' ) { this . write ( '\n' ) ; } lastCommand = 'log' ; console . log ( message ) ; message += '' ; lastLineLength = message . length ; return this ; } ; this . write = function ( message ) { if ( beSilent ) { return this ; } lastCommand = 'write' ; process . stdout . write ( message ) ; message = String ( message ) ; if ( lastCommand === 'write' ) { lastLineLength += message . length ; } else { lastLineLength = message . length ; } return this ; } ; this . info = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'white' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . success = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'green' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . warning = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'yellow' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . error = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'red' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . question = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'cyan' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . answer = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'magenta' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerInfo = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'black' , 'bgWhite' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerSuccess = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'white' , 'bgGreen' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerWarning = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'black' , 'bgYellow' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerError = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'white' , 'bgRed' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerQuestion = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'white' , 'bgCyan' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . headerAnswer = function ( message , returnString ) { var str = this . apply ( message , [ 'bold' , 'white' , 'bgMagenta' ] ) ; return returnString === true ? str : this . log ( str ) ; } ; this . apply = function ( message , effects ) { if ( ( effects instanceof Array ) === false ) { throw new Error ( 'Effects must be an array' ) ; } if ( ! effects . length ) { return message ; } var i = 0 , limit = effects . length ; for ( i = 0 ; i < limit ; i ++ ) { if ( this . hasOwnProperty ( effects [ i ] ) && typeof this [ effects [ i ] ] === 'function' ) { message = this [ effects [ i ] ] ( message ) ; } else { var allEffects = [ ] , e = '' ; for ( e in this ) { if ( this . hasOwnProperty ( e ) && ( ( e . indexOf ( 'color' ) === 0 && e !== 'color' ) || ( e . indexOf ( 'background' ) === 0 && e !== 'background' ) || effect [ e ] !== undefined ) ) { allEffects . push ( e ) ; } } throw new Error ( util . format ( 'Invalid effect "%s", you can use "%s"' , effects [ i ] , allEffects . join ( '", "' ) ) ) ; } } return message ; } ; this . dump = function ( variable , effects ) { if ( beSilent ) { return this ; } if ( ! ( effects instanceof Array ) ) { effects = [ ] ; } effects = this . apply ( '\n' , effects ) ; effects = effects . split ( '\n' ) ; this . write ( effects [ 0 ] ) ; this . write ( util . inspect ( ( typeof variable === 'function' ) ? variable . toString ( ) : variable ) ) ; this . write ( effects [ 1 ] + '\n' ) ; return this ; } ; this . getAllEffects = function ( ) { var allEffects = [ ] , e = '' ; for ( e in this ) { if ( this . hasOwnProperty ( e ) && ( ( e . indexOf ( 'color' ) === 0 && e !== 'color' ) || ( ( e . indexOf ( 'background' ) === 0 || e . indexOf ( 'bg' ) === 0 ) && e !== 'background' ) || effect [ e ] !== undefined || color [ e ] !== undefined ) ) { allEffects . push ( e ) ; } } return allEffects ; } ; this . format = function ( ) { if ( beSilent ) { return this ; } this . log ( this . getFormat . apply ( this . getFormat , arguments ) ) ; return this ; } ; this . getFormat = function ( ) { var message = arguments . length > 0 ? arguments [ 0 ] : '' ; message = util . format . apply ( util . format , arguments ) ; var all = self . getAllEffects ( ) , i = 0 , limit = all . length , applyCallback = function ( match , content ) { return self . apply ( content , [ all [ i ] ] ) ; } ; for ( i = 0 ; i < limit ; i ++ ) { message = message . replace ( new RegExp ( util . format ( '<%s>([\\s\\S]*?)<\/%s>' , all [ i ] , all [ i ] ) , 'g' ) , applyCallback ) ; } return message ; } ; this . stripFormat = function ( ) { var message = arguments . length > 0 ? arguments [ 0 ] : '' ; message = util . format . apply ( util . format , arguments ) ; var all = this . getAllEffects ( ) , i = 0 , limit = all . length , applyCallback = function ( match , content ) { return content ; } ; for ( i = 0 ; i < limit ; i ++ ) { message = message . replace ( new RegExp ( util . format ( '<%s>([\\s\\S]*?)<\/%s>' , all [ i ] , all [ i ] ) , 'g' ) , applyCallback ) ; } return message ; } ; this . nl = function ( ) { this . write ( '\n' ) ; return this ; } ; this . newLine = this . nl ; this . status = function ( text , status , textEffects , statusEffects , returnString ) { if ( beSilent ) { return this ; } if ( text instanceof Object ) { text = text . toString ( ) ; } if ( status instanceof Object ) { status = status . toString ( ) ; } var textLen = this . stripFormat ( text ) . length , statusLen = this . stripFormat ( status ) . length , emptyLength = consoleWidth - ( textLen + statusLen ) , emptyString = '' , i = 0 , str = '' ; text = this . getFormat ( text ) ; status = this . getFormat ( status ) ; if ( textEffects instanceof Array ) { text = this . apply ( text , textEffects ) ; } if ( statusEffects instanceof Array ) { status = this . apply ( status , statusEffects ) ; } if ( emptyLength < 2 ) { emptyLength = 2 ; } emptyLength -= 1 ; for ( i = 0 ; i < emptyLength ; i ++ ) { emptyString = emptyString + ' ' ; } str = text + emptyString + status ; if ( returnString === true ) { return str ; } this . log ( str ) ; return this ; } ; } 
function use ( code , lightColor ) { return util . format ( base , ( lightColor === true ) ? code + colorLightValueChange : code ) ; } 
function text ( message , effect , lightColor ) { return [ use ( effect [ 0 ] , lightColor ) , String ( message ) , use ( effect [ 1 ] , lightColor ) ] . join ( '' ) ; } 
function clearLine ( ) { if ( process . stdout . clearLine ) { process . stdout . clearLine ( ) ; process . stdout . cursorTo ( 0 ) ; } else { var str = '\r' , i = 0 ; for ( i = 0 ; i < lastLineLength ; i ++ ) { str += ' ' ; } process . stdout . write ( str ) ; } lastLineLength = 0 ; return self ; } 
function ( ) { L . DomUtil . empty ( this . _container ) ; var legends = this . options . legends ; if ( ! legends ) return ; legends . forEach ( function ( legend ) { if ( ! legend . elements ) return ; var elements = legend . elements ; var className = 'legend-block' ; if ( this . options . detectStretched ) { if ( elements . length === 3 && elements [ 0 ] . label !== '' && elements [ 1 ] . label === '' && elements [ 2 ] . label !== '' ) { legend . type = 'stretched' ; } } if ( legend . type === 'stretched' ) { className += ' legend-stretched' ; } var block = L . DomUtil . create ( 'div' , className , this . _container ) ; if ( this . options . collapseSimple && elements . length == 1 && ! elements [ 0 ] . label ) { this . _addElement ( elements [ 0 ] . imageData , legend . name , block ) ; return ; } if ( legend . name ) { var header = L . DomUtil . create ( 'h4' , null , block ) ; L . DomUtil . create ( 'div' , 'caret' , header ) ; L . DomUtil . create ( 'span' , null , header ) . innerHTML = legend . name ; L . DomEvent . on ( header , 'click' , function ( ) { if ( L . DomUtil . hasClass ( header , 'closed' ) ) { L . DomUtil . removeClass ( header , 'closed' ) ; } else { L . DomUtil . addClass ( header , 'closed' ) ; } } , this ) ; } var elementContainer = L . DomUtil . create ( 'div' , 'legend-elements' , block ) ; elements . forEach ( function ( element ) { this . _addElement ( element . imageData , element . label , elementContainer ) ; } , this ) ; } , this ) ; } 
function updateLocation ( method ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } return { type : _constants . CALL_HISTORY_METHOD , payload : { method : method , args : args } } ; } ; } 
function getHeader ( data ) { var header = { } header . umid = data . slice ( 0 , 3 ) header . mt_version = data . slice ( 3 , 5 ) header . rics = data . slice ( 5 , 9 ) header . key_id = data . slice ( 9 , 14 ) return header } 
function shoelace ( edges ) { var area = 0 ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = edges [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var _step$value = _slicedToArray ( _step . value , 2 ) ; var u = _step$value [ 0 ] ; var v = _step$value [ 1 ] ; area += vcross2 ( u , v ) ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator [ "return" ] ) { _iterator [ "return" ] ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } return Math . abs ( area ) / 2 ; } 
function topleft ( compare ) { return function ( a , b ) { var d ; d = compare ( a [ 0 ] , b [ 0 ] ) ; if ( d !== 0 ) { return d ; } return compare ( b [ 1 ] , a [ 1 ] ) ; } ; } 
function DCELMesh ( vertices , edges , faces ) { this . vertices = vertices ; this . edges = edges ; this . faces = faces ; } 
function cosval ( a , b , c ) { return cossign ( a , b , c ) / dist ( a , b ) / dist ( b , c ) ; } 
function sinval ( a , b , c ) { return sinsign ( a , b , c ) / dist ( a , b ) / dist ( b , c ) ; } 
function monotonic ( compare , d ) { return function ( a , b ) { return compare ( a [ d ] , b [ d ] ) ; } ; } 
function det3 ( A00 , A01 , A02 , A10 , A11 , A12 , A20 , A21 , A22 ) { return A00 * A11 * A22 + A01 * A12 * A20 + A02 * A10 * A21 - A20 * A11 * A02 - A21 * A12 * A00 - A22 * A10 * A01 ; } 
function scalar2 ( a , b ) { var c ; c = vsub2 ( a , b ) ; return vdot2 ( c , c ) ; } 
function cossign ( x , y , z ) { return ( y [ 0 ] - x [ 0 ] ) * ( y [ 0 ] - z [ 0 ] ) + ( y [ 1 ] - x [ 1 ] ) * ( y [ 1 ] - z [ 1 ] ) ; } 
function sinsign ( a , b , c ) { return ( b [ 0 ] - a [ 0 ] ) * ( c [ 1 ] - a [ 1 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) ; } 
function rayshoot ( d , m , A , b , z , r ) { var i = 0 ; var j = m ; var w = undefined ; while ( true ) { if ( i >= j ) return j ; var h = A [ i ] ; w = ( b [ i ] - vdot ( d , h , z ) ) / vdot ( d , h , r ) ; if ( w >= 0 ) break ; ++ i ; } var k = i ; while ( true ) { ++ i ; if ( i >= j ) return k ; var h = A [ i ] ; var l = ( b [ i ] - vdot ( d , h , z ) ) / vdot ( d , h , r ) ; if ( l < 0 || l >= w ) continue ; k = i ; w = l ; } } 
function vdot ( d , u , v ) { var s = 0 ; for ( var i = 0 ; i < d ; ++ i ) { s += u [ i ] * v [ i ] ; } return s ; } 
function getPlugins ( ) { var plugins = [ ] ; 
function generateStatsdRoutes ( stats ) { var result = { } ; Object . keys ( stats ) . forEach ( function ( name ) { var routes = stats [ name ] ; if ( ! ( routes instanceof Array ) ) { routes = [ routes ] ; } routes . forEach ( function ( route ) { result [ route . path ] = { name : name , methods : route . method ? route . method : route . methods } ; } ) ; } ) ; return result ; } 
function timeOutput ( difference , timeValue , pluralTimeName ) { let result = '' ; if ( Math . round ( difference / timeValue ) === 1 ) { result = ` ${ pluralTimeName . substring ( 0 , pluralTimeName . length - 1 ) } ` ; } else { result = ` ${ Math . round ( difference / timeValue ) } ${ pluralTimeName } ` ; } return result ; } 
function RestClient ( baseUrl ) { if ( typeof baseUrl !== 'string' ) { if ( typeof document !== 'undefined' ) { baseUrl = document . getElementById ( 'baseUrlHolder' ) . getAttribute ( 'data' ) + '/api/' ; } else { baseUrl = '/api/' ; } } this . organizations = new OrganizationsClient ( baseUrl ) ; this . projects = new ProjectsClient ( baseUrl ) ; this . user = new UserClient ( baseUrl ) ; this . users = new UsersClient ( baseUrl ) ; this . getStatus = ( ) => { return this . user . get ( [ 'status' ] ) ; } ; } 
function register ( ports , log ) { 
function storagePushToSet ( [ key , value ] ) { log ( 'storagePushToSet' , key , value ) ; const item = getLocalStorageItem ( key ) ; const list = Array . isArray ( item ) ? item : [ ] ; if ( list . indexOf ( value ) === - 1 ) { list . push ( value ) ; } setLocalStorageItem ( key , list ) ; } 
function getLocalStorageItem ( key ) { try { return JSON . parse ( window . localStorage . getItem ( key ) ) ; } catch ( e ) { return null ; } } 
function setLocalStorageItem ( key , value ) { window . localStorage . setItem ( key , JSON . stringify ( value ) ) ; } 
function taskGraphRunner ( opts ) { let graph = opts . graph ; let task = opts . task ; let force = opts . force || false ; let safe = true ; let queue = new Set ( graph . keys ( ) ) ; let running = new Set ( ) ; function getNextChunk ( ) { let chunk = [ ] ; let current = new Map ( ) ; if ( ! queue . size ) { return chunk ; } for ( let key of queue ) { let deps = graph . get ( key ) || [ ] ; let curr = deps . filter ( dep => queue . has ( dep ) ) ; current . set ( key , curr ) ; if ( ! curr . length ) { chunk . push ( key ) ; } } if ( chunk . length === 0 ) { if ( ! force ) { throw new Error ( 'Cycle detected in graph' ) ; } let items = Array . from ( queue ) ; let sorted = items . sort ( ( a , b ) => { let aCurr = current . get ( a ) || [ ] ; let bCurr = current . get ( b ) || [ ] ; let deps = aCurr . length - bCurr . length ; if ( deps !== 0 ) return deps ; let aChildren = items . filter ( item => arrayIncludes ( current . get ( item ) || [ ] , a ) ) ; let bChildren = items . filter ( item => arrayIncludes ( current . get ( item ) || [ ] , b ) ) ; return bChildren . length - aChildren . length ; } ) ; let first = sorted [ 0 ] ; chunk . push ( first ) ; safe = false ; } chunk = chunk . filter ( key => { let deps = graph . get ( key ) || [ ] ; return ! deps . find ( dep => running . has ( dep ) ) ; } ) ; for ( let key of chunk ) { queue . delete ( key ) ; } return chunk ; } let values = new Map ( ) ; function next ( ) { let chunk = getNextChunk ( ) ; let promises = [ ] ; for ( let key of chunk ) { running . add ( key ) ; promises . push ( Promise . resolve ( task ( key ) ) . then ( result => { running . delete ( key ) ; values . set ( key , result ) ; if ( queue . size ) { return next ( ) ; } } ) ) ; } return Promise . all ( promises ) ; } return new Promise ( ( resolve , reject ) => { return next ( ) . then ( resolve , reject ) ; } ) . then ( ( ) => { return { safe , values } ; } ) ; } 
function ( options ) { var self = this ; options = options || { } ; events . EventEmitter . call ( this ) ; this . _counter = 0 ; this . _lastSend = 0 ; this . _packets = new Array ( ) ; this . _sending = false ; this . _opened = false ; this . _serialPort = new SerialPort ( options . port , { baudrate : 115200 } ) ; this . _emitter = new events . EventEmitter ( ) ; this . _emitter . on ( "sendData" , function ( ) { if ( self . _packets . length > 0 ) { var packet = self . _packets . shift ( ) ; 
function run ( options ) { if ( options . results ) { return map ( options ) ; } return fetch ( options ) . then ( map . bind ( null , options ) ) ; } 
function fetch ( options ) { var time , promise , resolve , reject ; time = new Date ( ) ; promise = new Promise ( function ( r1 , r2 ) { resolve = r1 ; reject = r2 ; } ) ; try { options = normalise ( options ) ; if ( options . resultIds ) { wpt . getResults ( options , options . resultIds ) . then ( after ) ; } else { wpt . runTests ( options ) . then ( wpt . getResults . bind ( null , options ) ) . then ( after ) ; } } catch ( error ) { reject ( error ) ; } return promise ; function after ( results ) { results = { data : results , options : options , times : { begin : time , end : new Date ( ) } } ; if ( options . dump ) { dump ( options , results ) ; } resolve ( results ) ; } } 
function map ( options , results ) { var promise , resolve , reject ; promise = new Promise ( function ( r1 , r2 ) { resolve = r1 ; reject = r2 ; } ) ; try { 
function setHideProps ( target , propKey , value ) { Object . defineProperty ( target , propKey , { value , configurable : true , enumerable : false } ) } 
function List ( init = [ ] , Type , options = { } ) { classCallCheck ( this , List ) const arr = observable . array ( [ ] , options ) ObservableArray . apply ( this , [ [ ] , arr . $mobx . enhancer ] ) addHideProps ( this , '_Type' , Type ) this . assign ( init ) } 
function onMessage ( msg , rinfo ) { 
function ( o ) { function CreatedObject ( ) { } CreatedObject . prototype = o ; var tmp = new CreatedObject ( ) ; tmp . __proto__ = o ; return tmp ; } 
function toRingClass ( claz ) { if ( claz . __classId__ ) return ; var proto = ! Object . getOwnPropertyNames ? claz . prototype : ( function ( ) { var keys = { } ; ( function crawl ( p ) { if ( p === Object . prototype ) return ; _ . extend ( keys , _ . chain ( Object . getOwnPropertyNames ( p ) ) . map ( function ( el ) { return [ el , true ] ; } ) . fromPairs ( ) . value ( ) ) ; crawl ( Object . getPrototypeOf ( p ) ) ; } ) ( claz . prototype ) ; return _ . fromPairs ( _ . map ( _ . keys ( keys ) , function ( k ) { return [ k , claz . prototype [ k ] ] ; } ) ) ; } ) ( ) ; proto = _ . chain ( proto ) . map ( function ( v , k ) { return [ k , v ] ; } ) . filter ( function ( el ) { return el [ 0 ] !== "constructor" && el [ 0 ] !== "__proto__" ; } ) . fromPairs ( ) . value ( ) ; var id = classCounter ++ ; _ . extend ( claz , { __mro__ : [ claz , ring . Object ] , __properties__ : _ . extend ( { } , proto , { __ringConstructor__ : function ( ) { this . $super . apply ( this , arguments ) ; var tmp = this . $super ; this . $super = null ; try { claz . apply ( this , arguments ) ; } finally { this . $super = tmp ; } } } ) , __classId__ : id , __parents__ : [ ring . Object ] , __classIndex__ : { "1" : ring . Object } , __ringConvertedObject__ : true } ) ; claz . __classIndex__ [ id ] = claz ; } 
function mixedRenderer ( model , propsOrClassName , props , ... children ) { if ( model && typeof model === 'object' ) { if ( typeof propsOrClassName === 'string' ) { propsOrClassName = { className : propsOrClassName } props = props || { } props = { ... props , ... propsOrClassName } } else { children = [ props ] . concat ( children ) props = propsOrClassName } return r . apply ( this , [ model , props , ... children ] ) } return h . apply ( this , arguments ) } 
function urlSync ( urlKeyOrTarget , property , descriptor ) { if ( invokedWithArgs ( arguments ) ) { let options = property return ( target , property , descriptor ) => urlsync ( urlKeyOrTarget || property , { ... keyMap , ... options } , target , property , descriptor ) } return urlsync ( property , keyMap , urlKeyOrTarget , property , descriptor ) } 
function ZWaveDeviceConnection ( ipAddressFamily , ipAddress , pskIdentity , pskPassword ) { 
function ( thisObject , commandClass , requestCommand , data , responseCommand , responseMatchingId ) { if ( typeof responseMatchingId === "undefined" ) { 
function ( thisObject , commandClass , command , data ) { if ( typeof data === "undefined" ) { 
function ( thisObject , data , rinfo ) { if ( typeof data === "undefined" ) { 
function MessageWaitingForAck ( callback , timeoutTimestamp , timeoutObject , responseCallbackObject ) { this . callback = callback ; this . timeoutTimestamp = timeoutTimestamp ; this . timeoutObject = timeoutObject ; this . responseCallbackObject = responseCallbackObject ; 
function ZWaveCommandCallback ( commandClass , command , matchIdentifier , callback , timeoutInMilliseconds , timeoutObject , isWrappedInZipFrame ) { this . commandClass = commandClass ; this . command = command ; this . matchIdentifier = matchIdentifier ; this . callback = callback ; this . timeoutInMilliseconds = timeoutInMilliseconds ; this . timeoutTimestamp = addTime ( process . hrtime ( ) , timeoutInMilliseconds ) ; 
function ( config , webpack ) { config . entry . PICIDAE_ENTRY = [ config . entry . PICIDAE_ENTRY , require . resolve ( '../' ) ] console . log ( config . entry ) config . resolve = config . resolve || { } config . resolve . alias = Object . assign ( { } , alias , config . resolve . alias ) return config } 
function ( ) { if ( ! _paginationData . links . next === null || ! _paginationData . links . previous ) { return { } ; } 
function ensureNameForm ( name , i ) { var pos = i || 0 ; 
function ( type , i ) { return maybe ( utils . find ( maybe ( this . getNameForm ( i ) ) . parts , { type : type } ) ) . value ; } 
function ( fullText , i ) { this . changed = true ; var nameForm = ensureNameForm ( this , i ) ; if ( ! ! fullText ) { nameForm . fullText = fullText ; } else { delete nameForm . fullText ; } 
function ( name , type , i ) { this . changed = true ; var nameForm = ensureNameForm ( this , i ) ; if ( ! utils . isArray ( nameForm . parts ) ) { nameForm . parts = [ ] ; } var part = utils . find ( nameForm . parts , { type : type } ) ; if ( ! ! name ) { if ( ! part ) { part = { type : type } ; nameForm . parts . push ( part ) ; } part . value = name ; } else if ( ! ! part ) { nameForm . parts . splice ( nameForm . parts . indexOf ( part ) , 1 ) ; } 
function pedigreeConvenienceFunctionGenerator ( numberLabel ) { return { getPersons : function ( ) { return maybe ( this . getData ( ) ) . persons ; } , exists : function ( num ) { return ! ! maybe ( maybe ( utils . find ( maybe ( this . getData ( ) ) . persons , matchPersonNum ( numberLabel , num ) ) ) . data ) . id ; } , getPerson : function ( num ) { return utils . find ( maybe ( this . getData ( ) ) . persons , matchPersonNum ( numberLabel , num ) ) ; } } ; } 
function getRoot ( response ) { var obj = response . getData ( ) ; if ( obj ) { if ( obj . persons ) { return obj . persons ; } else if ( obj . childAndParentsRelationships ) { return obj . childAndParentsRelationships ; } else if ( obj . relationships ) { return obj . relationships ; } } return { } ; } 
function ( client ) { this . settings = client . settings ; this . client = client ; this . accessTokenInactiveTimer = null ; this . accessTokenCreationTimer = null ; } 
function ( object ) { var parts = [ ] ; for ( var param in object ) { if ( object . hasOwnProperty ( param ) ) { parts . push ( encodeURIComponent ( param ) + '=' + encodeURIComponent ( object [ param ] ) ) ; } } return parts . join ( '&' ) ; } 
function ( queryString ) { var pairs = queryString . split ( '&' ) ; var params = { } ; pairs . forEach ( function ( pair ) { pair = pair . split ( '=' ) ; params [ pair [ 0 ] ] = decodeURIComponent ( pair [ 1 ] || '' ) ; } ) ; return params ; } 
function templateMatches ( template , obj ) { for ( var key in template ) { if ( template . hasOwnProperty ( key ) && obj [ key ] !== template [ key ] ) { return false ; } } return true ; } 
function requireUsed ( files ) { if ( files ) { var filePattern ; for ( var i = files . length ; i > 0 ; i -- ) { filePattern = files [ i ] && files [ i ] . pattern ; if ( typeof filePattern === 'string' && ( filePattern . indexOf ( '\\karma-requirejs\\' ) !== - 1 || filePattern . indexOf ( '/karma-requirejs/' ) !== - 1 ) ) { return true ; } if ( typeof filePattern === 'string' && ( filePattern . indexOf ( '\\karma-cajon\\' ) !== - 1 || filePattern . indexOf ( '/karma-cajon/' ) !== - 1 ) ) { return true ; } } } return false ; } 
function createParser ( _options , _extraPlugins ) { 
function applyPlugin ( extraPlugin ) { if ( Array . isArray ( extraPlugin ) ) { const plugin = extraPlugin [ 0 ] const config = extraPlugin [ 1 ] return parser . use ( plugin , config || { } ) } parser . use ( extraPlugin ) } 
function liftFeedbackLoop ( loops , mappings ) { return function ( outerState , scheduler ) { var embededLoops = loops . map ( function ( loop ) { return loop ( outerState . pipe ( map_1 . map ( mappings . mapState ) ) , scheduler ) . pipe ( map_1 . map ( mappings . mapEvent ) ) ; } ) ; return rx . merge . apply ( rx , embededLoops ) ; } ; } 
function system ( initialState , reduce , feedback ) { return rx . defer ( function ( ) { var state = new rx . ReplaySubject ( 1 ) ; var scheduler = rx . queueScheduler ; var events = feedback . map ( function ( x ) { return x ( state , scheduler ) ; } ) ; var mergedEvent = rx . merge . apply ( rx , events ) . pipe ( observeOn_1 . observeOn ( scheduler ) ) ; var eventsWithEffects = mergedEvent . pipe ( scan_1 . scan ( reduce , initialState ) , tap_1 . tap ( function ( x ) { state . next ( x ) ; } ) , subscribeOn_1 . subscribeOn ( scheduler ) , startWith_1 . startWith ( initialState ) , observeOn_1 . observeOn ( scheduler ) ) ; var hackOnSubscribed = rx . defer ( function ( ) { state . next ( initialState ) ; return rx . empty ( ) ; } ) ; return rx . merge . apply ( rx , [ eventsWithEffects , hackOnSubscribed ] ) . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . throwError ( e ) ; } ) ) ; } ) ; } 
function materializedRetryStrategy ( strategy ) { return function ( source ) { switch ( strategy . kind ) { case "ignoreErrorJustComplete" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . empty ( ) ; } ) ) ; case "ignoreErrorAndReturn" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . of ( strategy . value ) ; } ) ) ; case "exponentialBackoff" : return rx . defer ( function ( ) { var counter = 1 ; return source . pipe ( tap_1 . tap ( function ( ) { counter = 1 ; } , function ( ) { if ( counter * 2 <= strategy . maxBackoffFactor ) { counter *= 2 ; } } ) , retryWhen_1 . retryWhen ( function ( e ) { return e . pipe ( switchMap_1 . switchMap ( function ( x ) { dispatchError ( x ) ; return rx . of ( 0 ) . pipe ( delay_1 . delay ( strategy . initialTimeout * counter * 1000 ) ) ; } ) ) ; } ) ) ; } ) ; case "catchError" : return source . pipe ( catchError_1 . catchError ( function ( e ) { dispatchError ( e ) ; return rx . of ( strategy . handle ( e ) ) ; } ) ) ; default : return js_extensions_1 . unhandledCase ( strategy ) ; } } ; } 
function react ( request , effects , retryStrategy ) { return reactWithLatest ( function ( state ) { var requestInstance = request ( state ) ; return requestInstance != null ? [ { id : requestInstance , request : requestInstance } ] : [ ] ; } , function ( request , _ , scheduler ) { return effects ( request , scheduler ) ; } , retryStrategy ) ; } 
function reactSet ( requests , effects , retryStrategy ) { return reactWithLatest ( function ( state ) { var requestInstances = requests ( state ) ; var identifiableRequests = [ ] ; requestInstances . forEach ( function ( request ) { identifiableRequests . push ( { id : request , request : request } ) ; } ) ; return identifiableRequests ; } , function ( request , _ , scheduler ) { return effects ( request , scheduler ) ; } , retryStrategy ) ; } 
function URL ( url , baseURL ) { if ( url != undefined ) { let _url = URL . parseUrl ( url ) ; if ( _url !== false ) return _url ; if ( baseURL ) { _url = URL . parseUrl ( baseURL ) ; if ( _url === false ) return ; url = String ( url ) ; if ( url . slice ( 0 , 2 ) == '//' ) { return URL . parseUrl ( _url . protocol + url ) ; } let _path ; if ( url . slice ( 0 , 1 ) == '/' ) { _path = url ; } else { _path = _url . pathname . split ( '/' ) ; _path [ _path . length - 1 ] = url ; _path = _path . join ( '/' ) ; } return URL . parseUrl ( _url . origin + _path ) ; } throw new SyntaxError ( "Failed to construct 'URL': Invalid URL" ) ; } } 
function getElementServices ( app , name ) { let forecasts = app . get ( 'forecasts' ) if ( name ) { forecasts = forecasts . filter ( forecast => forecast . name === name ) } // Iterate over configured forecast models let services = [ ] for ( let forecast of forecasts ) { for ( let element of forecast . elements ) { let service = app . getService ( forecast . name + '/' + element . name ) if ( service ) { services . push ( service ) } } } return services } 
function fatalError ( stderr ) { return { errors : [ { message : [ { path : '' , code : 0 , line : 0 , start : 0 , descr : stderr } ] } ] } ; } 
function timelineMouseDown ( e ) { previousXPosition = e . clientX ; previousYPosition = e . clientY ; var chartAxes = existingChartRef . getAxes ( ) ; var timelineAxes = plot . getAxes ( ) ; var leftBoundVal = chartAxes . xaxis . min ; var rightBoundVal = chartAxes . xaxis . max ; var eventVal = timelineAxes . xaxis . c2p ( e . clientX - plot . offset ( ) . left ) ; if ( ( eventVal < leftBoundVal || eventVal > rightBoundVal ) && updateExistingChart ) { 
function ( next ) { var options = { type : ctx . type , count : ctx . count , now : ctx . now , nowISOString : ctx . nowISOString , params : { pk : Model . getIdName ( ) , id : ctx . params . id , relation : ctx . params . relation , custom : ctx . params . custom } } ; if ( ctx . type === 'model' ) { options . params . where = ctx . params . where ; options . params . range = ctx . params . range ; } new _queryBuilder2 . default ( options ) . onComplete ( next ) . build ( ) ; } 
function ( query , next ) { switch ( ctx . type ) { case 'model' : Model . find ( query , next ) ; break ; case 'relation' : Model . findOne ( query , function ( err , instance ) { if ( err ) return next ( err ) ; var builder = new _queryBuilder2 . default ( { type : ctx . type , count : ctx . count , now : ctx . now , nowISOString : ctx . nowISOString , params : { range : ctx . params . range , where : ctx . params . where , custom : ctx . params . custom } } ) ; builder . onComplete ( function ( _err , _query ) { if ( _err ) return next ( _err ) ; instance [ ctx . relation || ctx . params . relation ] ( _query , next ) ; } ) ; builder . build ( ) ; } ) ; break ; case 'nested' : Model . findOne ( query , function ( err , instance ) { return next ( err , instance [ ctx . nested ] ) ; } ) ; break ; default : next ( null , [ ] ) ; } } 
function computeRowPosition ( plot , cursor , index , count ) { var width = plot . width ( ) ; var height = plot . height ( ) ; var textAlign = 'left' ; var fontSizeInPx = Number ( cursor . fontSize . substring ( 0 , cursor . fontSize . length - 2 ) ) ; var y = cursor . y ; var x = cursor . x ; if ( x > ( width / 2 ) ) { x -= constants . labelPadding ; textAlign = 'right' ; } else { x += constants . labelPadding ; } if ( y > ( height / 2 ) ) { y -= constants . labelPadding * ( count - index ) + fontSizeInPx * ( count - 1 - index ) ; } else { y += constants . labelPadding * ( index + 1 ) + fontSizeInPx * ( index + 1 ) ; } return { x : x , y : y , textAlign : textAlign } ; } 
function findItem ( options ) { if ( ! options . itemid ) { return { error : 'Must provide the itemid of the saved search' , options : options } ; } var filters = [ new nlobjSearchFilter ( 'itemid' , null , 'equalto' , options . itemid ) ] ; var columns = [ new nlobjSearchColumn ( 'itemid' ) ] ; return nlapiSearchRecord ( 'item' , null , filters , columns ) ; } 
function ( sourceFileName , code ) { 
function ( options , code ) { var rst = JSON . parse ( JSON . stringify ( options ) ) ; 
function chartMouseDown ( e ) { if ( ( e . button && e . button === 1 ) || ( e . which && e . which === 2 ) ) { e . preventDefault ( ) ; var offsets = plot . offset ( ) ; plot . getPlaceholder ( ) . append ( '<div id="plot-highlight-div"></div>' ) . bind ( 'mousemove' , middleMouseMove ) ; $ ( '#plot-highlight-div' ) . bind ( 'mouseup' , chartMouseUp ) ; that . highlightContainer . highlighting = true ; that . highlightContainer . start = e . clientX ; return ; } that . previousXPosition = e . clientX ; that . previousYPosition = e . clientY ; if ( e . shiftKey ) { that . panType = 'vertical' ; plot . getPlaceholder ( ) . bind ( 'mousemove' , vertPanChart ) ; } else { that . panType = 'horizontal' ; plot . getPlaceholder ( ) . bind ( 'mousemove' , horPanChart ) ; } } 
function get ( self , steamObj , key ) { steamObj = steamObj || { } ; if ( steamObj [ key ] !== undefined ) { return steamObj [ key ] ; } else if ( self [ key ] !== undefined ) { return self [ key ] ; } else if ( Steam [ key ] !== undefined ) { return Steam [ key ] ; } else { throw new Error ( "Missing required field: " + key ) ; } } 
function request ( self , options , callback ) { var _http = get ( self , options , 'secure' ) ? https : http ; if ( Steam . devMode ) console . log ( options ) ; var req = _http . request ( options , function ( res ) { var data , dataStr = '' ; res . on ( 'data' , function ( chunk ) { dataStr += chunk ; } ) ; res . on ( 'end' , function ( ) { var statusCode = res . statusCode ; if ( statusCode !== 200 ) { if ( statusCode === 401 ) { return callback ( new Error ( 'Invalid API Key' ) ) ; } else { return callback ( new Error ( "HTTP " + statusCode + " " + http . STATUS_CODES [ statusCode ] ) ) ; } } 
function getParams ( self , steamObj , requiredParams , optionalParams ) { 
function addInterfaceMethod ( interfaceName , funcName , fN ) { 
function buildSteamWrapperMethod ( interfaceName , funcName , defaultVersion , httpMethod , requiredParams , optionalParams ) { 
function retrieveSteamAPIMethods ( key , callback ) { var _steam = new Steam ( ) ; _steam . getSupportedAPIList ( { key : key } , function ( err , data ) { if ( err ) return callback ( err ) ; var apiList = data . apilist ; if ( apiList === undefined ) return callback ( new Error ( 'No data returned' ) ) ; apiList = apiList . interfaces ; 
function filterElement ( flJson ) { var returnJson = { "photo" : { } } ; returnJson . photo . title = flJson . photo . title ; returnJson . photo . description = flJson . photo . description ; returnJson . photo . farm = flJson . photo . farm ; returnJson . photo . id = flJson . photo . id ; returnJson . photo . media = flJson . photo . media ; returnJson . photo . secret = flJson . photo . secret ; returnJson . photo . server = flJson . photo . server ; returnJson . photo . urls = flJson . photo . urls ; return returnJson ; } 
function pushFlickrJson ( flickrJson ) { if ( ! enabledCache ) return ; var isMatch = false ; var filterJson = filterElement ( flickrJson ) ; for ( var i = 0 ; i < cacheJson . length ; i ++ ) { if ( cacheJson [ i ] . fl . photo . id == flickrJson . photo . id ) { cacheJson [ i ] . fl = filterJson ; isMatch = true ; } } if ( ! isMatch ) cacheJson . push ( { "fl" : filterJson , "expires" : 0 } ) ; } 
function getFlickrCacheJson ( photoId ) { if ( ! enabledCache ) return null ; var d = new Date ( ) ; for ( var i = 0 ; i < cacheJson . length ; i ++ ) { if ( cacheJson [ i ] . fl . photo . id == photoId ) { if ( cacheJson [ i ] . expires > d . getTime ( ) ) { return cacheJson [ i ] . fl ; } break ; } } return null ; } 
function getImageSize ( flickrJson , photo_id , photo_size ) { var sizeInfo = { "width" : 0 , "height" : 0 } ; var sizeTable = { "s" : "Square" , "q" : "Large Square" , "t" : "Thumbnail" , "m" : "Small" , "n" : "Small 320" , "-" : "Medium" , "z" : "Medium 640" , "c" : "Medium 800" , "b" : "Large" , "o" : "Original" } if ( flickrJson && flickrJson . sizes . size ) { for ( var i = 0 ; i < flickrJson . sizes . size . length ; i ++ ) { if ( flickrJson . sizes . size [ i ] . label == sizeTable [ photo_size ] ) { sizeInfo . width = flickrJson . sizes . size [ i ] . width ; sizeInfo . height = flickrJson . sizes . size [ i ] . height ; } } } return sizeInfo ; } 
function pushImageSizeAndExpress_flickrJson ( imageSize , photo_id ) { if ( ! enabledCache ) return null ; var d = new Date ( ) ; var expiresTime = d . getTime ( ) + cachePeriod ; for ( var i = 0 ; i < cacheJson . length ; i ++ ) { if ( cacheJson [ i ] . fl . photo . id == photo_id ) { cacheJson [ i ] . fl . photo . imgSize = imageSize ; cacheJson [ i ] . expires = expiresTime ; } } } 
function ( tagArgs ) { if ( ! APIKey ) { throw new Error ( 'flickr_api_key configuration is required' ) ; } var tag = tagUtil . convertAttr ( tagArgs ) ; return new Promise ( function ( resolve , reject ) { var flJson = getFlickrCacheJson ( tag . id ) ; if ( ! flJson ) { 
function ( tagArgs , returnImgAttr ) { if ( ! APIKey ) { throw new Error ( 'flickr_api_key configuration is required' ) ; } var tag = tagUtil . convertAttr ( tagArgs ) ; return new Promise ( function ( resolve , reject ) { var flJson = getFlickrCacheJson ( tag . id ) ; if ( ! flJson || ! flJson . photo . imgSize ) { 
function hasClass ( el , className ) { var test ; if ( el . classList ) { test = el . classList . contains ( className ) ; } else { var className = new RegExp ( '(^| )' + className + '( |$)' , 'gi' ) ; test = new RegExp ( className ) . test ( el . className ) ; } return test ; } 
function LeipzigEvent ( name , data ) { var leipzigEvent = undefined ; if ( window . CustomEvent ) { leipzigEvent = new CustomEvent ( name , { detail : data , bubbles : true , cancelable : true } ) ; } else { 
function triggerEvent ( el , name , data ) { var e = new LeipzigEvent ( name , data ) ; el . dispatchEvent ( e ) ; } 
function Leipzig ( selector ) { var config = arguments . length <= 1 || arguments [ 1 ] === undefined ? { } : arguments [ 1 ] ; if ( ! ( this instanceof Leipzig ) ) { return new Leipzig ( selector , config ) ; } if ( typeof selector !== 'undefined' ) { if ( typeof selector === 'string' || selector instanceof NodeList || selector instanceof Element ) { config . selector = selector ; } else if ( typeof selector === 'object' ) { 
function processGloss ( gloss , callback ) { if ( ! ( gloss instanceof Element ) ) { var err = new Error ( 'Invalid gloss element' ) ; if ( typeof callback === 'function' ) { callback ( err ) ; } else { throw err ; } } var lines = Array . prototype . slice . call ( gloss . children ) ; var linesToAlign = [ ] ; var firstRawLine = null ; var firstRawLineNum = 0 ; triggerEvent ( gloss , events . beforeGloss ) ; if ( firstLineOrig ) { var firstLine = lines [ 0 ] ; addClass ( firstLine , classes . original ) ; } if ( lastLineFree ) { var lastLine = lines [ lines . length - 1 ] ; addClass ( lastLine , classes . freeTranslation ) ; } 
function blockOut ( block ) { var width = 8 , len = block . length , stp = len / width , x , y , z ; for ( x = 0 ; x < len ; x += stp ) { z = [ ] ; for ( y = 0 ; y < width ; y ++ ) { z . push ( block [ x + y ] ) ; } console . log ( [ x , z . join ( ) ] . join ( " " ) ) ; } } 
function xor ( ) { var args = [ ] . slice . call ( arguments ) , bits = args . shift ( ) . slice ( ) ; args . forEach ( function ( arg , y ) { arg . forEach ( function ( bit , x ) { bits [ x ] ^= bit ; } ) ; } ) ; return bits ; } 
function add ( ) { var args = [ ] . slice . call ( arguments ) , bits = args . shift ( ) . slice ( ) ; args . forEach ( function ( arg , y ) { var carry = 0 , len = arg . length , x , z ; for ( x = len - 1 ; x > - 1 ; x -- ) { z = bits [ x ] + arg [ x ] + carry ; switch ( z ) { case 3 : bits [ x ] = oneBit ; carry = 1 ; break ; case 2 : bits [ x ] = zeroBit ; carry = 1 ; break ; case 1 : bits [ x ] = oneBit ; carry = 0 ; break ; case 0 : bits [ x ] = zeroBit ; carry = 0 ; break ; default : throw new Error ( [ "add" , y , x , bits [ x ] , arg [ x ] , carry , z ] . join ( " " ) ) ; break ; } } } ) ; return bits ; } 
function sha256 ( message , debugging ) { var debugOutput = [ ] , noop = function ( ) { } , out = debugging ? function ( ) { debugOutput . push ( [ ] . slice . call ( arguments ) . join ( " " ) ) ; } : noop ; try { var h0 = hex2bin ( 0x6a09e667 ) , h1 = hex2bin ( 0xbb67ae85 ) , h2 = hex2bin ( 0x3c6ef372 ) , h3 = hex2bin ( 0xa54ff53a ) , h4 = hex2bin ( 0x510e527f ) , h5 = hex2bin ( 0x9b05688c ) , h6 = hex2bin ( 0x1f83d9ab ) , h7 = hex2bin ( 0x5be0cd19 ) ; Initialize array of round constants: (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311): k[0..63] := 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 */ var k = arrayHex2bin ( [ 0x428a2f98 , 0x71374491 , 0xb5c0fbcf , 0xe9b5dba5 , 0x3956c25b , 0x59f111f1 , 0x923f82a4 , 0xab1c5ed5 , 0xd807aa98 , 0x12835b01 , 0x243185be , 0x550c7dc3 , 0x72be5d74 , 0x80deb1fe , 0x9bdc06a7 , 0xc19bf174 , 0xe49b69c1 , 0xefbe4786 , 0x0fc19dc6 , 0x240ca1cc , 0x2de92c6f , 0x4a7484aa , 0x5cb0a9dc , 0x76f988da , 0x983e5152 , 0xa831c66d , 0xb00327c8 , 0xbf597fc7 , 0xc6e00bf3 , 0xd5a79147 , 0x06ca6351 , 0x14292967 , 0x27b70a85 , 0x2e1b2138 , 0x4d2c6dfc , 0x53380d13 , 0x650a7354 , 0x766a0abb , 0x81c2c92e , 0x92722c85 , 0xa2bfe8a1 , 0xa81a664b , 0xc24b8b70 , 0xc76c51a3 , 0xd192e819 , 0xd6990624 , 0xf40e3585 , 0x106aa070 , 0x19a4c116 , 0x1e376c08 , 0x2748774c , 0x34b0bcb5 , 0x391c0cb3 , 0x4ed8aa4a , 0x5b9cca4f , 0x682e6ff3 , 0x748f82ee , 0x78a5636f , 0x84c87814 , 0x8cc70208 , 0x90befffa , 0xa4506ceb , 0xbef9a3f7 , 0xc67178f2 ] ) ; var digest = "" , arMsg = message . split ( '' ) , arMsgLen = arMsg . length , originalBits = [ ] , originalBitsLength = 0 , err = null , i , s0 , s1 , S0 , S1 , ch , maj , temp1 , temp2 , a , b , c , d , e , f , g , h , l , m , n , o , p , u , v , w , x , y , z , z1 , z2 , z3 ; append a single '1' bit */ u = originalBits . slice ( ) ; u . push ( oneBit ) ; append K '0' bits, where K is the minimum number >= 0 such that L + 1 + K + 64 is a multiple of 512 */ v = u . length ; append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits */ Process the message in successive 512-bit chunks: */ for ( x = 0 ; x < v ; x += 512 ) { break message into 512-bit chunks for each chunk create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63] don't matter, so many implementations zero them here) */ w = [ ] ; /* copy chunk into first 16 words w[0..15] of the message schedule array */ for ( y = 0 ; y < 16 ; y ++ ) { w [ y ] = [ ] ; for ( z = 0 ; z < 32 ; z ++ ) { w [ y ] . push ( u [ x + y * 32 + z ] ) ; } //out("w[" + y + "]", w[y], bin2hex(w[y])); } /* Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array: for i from 16 to 63 */ for ( i = 16 ; i < 64 ; i ++ ) { /* s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) */ y = w [ i - 15 ] ; //out(i,"y",y); z = rightrotate ( y , 7 ) ; //out("z", z); z1 = rightrotate ( y , 18 ) ; //out("z1", z1); z2 = rightshift ( y , 3 ) ; //out("z2", z2); s0 = xor ( z , z1 , z2 ) ; //out("s0", s0); /* s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10) */ y = w [ i - 2 ] ; //out(i,"y",y); z = rightrotate ( y , 17 ) ; //out("z", z); z1 = rightrotate ( y , 19 ) ; //out("z1", z1); z2 = rightshift ( y , 10 ) ; //out("z2", z2); s1 = xor ( z , z1 , z2 ) ; //out("s1", s1); /* w[i] := w[i-16] + s0 + w[i-7] + s1 */ y = w [ i - 16 ] ; //out("y", y); z = w [ i - 7 ] ; //out("z", z); w [ i ] = add ( y , s0 , z , s1 ) ; //out("w["+i+"]", w[i]); } /* Initialize working variables to current hash value: a := h0 b := h1 c := h2 d := h3 e := h4 f := h5 g := h6 h := h7 */ a = h0 ; b = h1 ; c = h2 ; d = h3 ; e = h4 ; f = h5 ; g = h6 ; h = h7 ; /* Compression function main loop: for i from 0 to 63 */ for ( i = 0 ; i < 64 ; i ++ ) { /* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) */ l = rightrotate ( e , 6 ) ; m = rightrotate ( e , 11 ) ; n = rightrotate ( e , 25 ) ; S1 = xor ( l , m , n ) ; //out("S1", S1); /* ch := (e and f) xor ((not e) and g) */ l = and ( e , f ) ; m = not ( e ) ; n = and ( m , g ) ; ch = xor ( l , n ) ; //out("ch", ch); /* temp1 := h + S1 + ch + k[i] + w[i] */ temp1 = add ( h , S1 , ch , k [ i ] , w [ i ] ) ; //out("temp1", temp1); /* S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) */ l = rightrotate ( a , 2 ) ; m = rightrotate ( a , 13 ) ; n = rightrotate ( a , 22 ) ; S0 = xor ( l , m , n ) ; //out("S0", S0); /* maj := (a and b) xor (a and c) xor (b and c) */ l = and ( a , b ) ; m = and ( a , c ) ; n = and ( b , c ) ; maj = xor ( l , m , n ) ; //out("maj", maj); /* temp2 := S0 + maj */ temp2 = add ( S0 , maj ) ; //out("temp2", temp2); /* h := g g := f f := e e := d + temp1 d := c c := b b := a a := temp1 + temp2 */ h = g ; g = f ; f = e ; e = add ( d , temp1 ) ; //out("e", e); d = c ; c = b ; b = a ; a = add ( temp1 , temp2 ) ; //out("a", a); //out("t="+i, arrayBin2hex([a,b,c,d,e,f,g,h]).join(' ')); } /* Add the compressed chunk to the current hash value: h0 := h0 + a h1 := h1 + b h2 := h2 + c h3 := h3 + d h4 := h4 + e h5 := h5 + f h6 := h6 + g h7 := h7 + h */ //out("h0", bin2hex(h0), "+", bin2hex(a), "=", bin2hex(add(h0, a))); h0 = add ( h0 , a ) ; //out("h1", bin2hex(h1), "+", bin2hex(b), "=", bin2hex(add(h1, b))); h1 = add ( h1 , b ) ; //out("h2", bin2hex(h2), "+", bin2hex(c), "=", bin2hex(add(h2, c))); h2 = add ( h2 , c ) ; //out("h3", bin2hex(h3), "+", bin2hex(d), "=", bin2hex(add(h3, d))); h3 = add ( h3 , d ) ; //out("h4", bin2hex(h4), "+", bin2hex(e), "=", bin2hex(add(h4, e))); h4 = add ( h4 , e ) ; //out("h5", bin2hex(h5), "+", bin2hex(f), "=", bin2hex(add(h5, f))); h5 = add ( h5 , f ) ; //out("h6", bin2hex(h6), "+", bin2hex(g), "=", bin2hex(add(h6, g))); h6 = add ( h6 , g ) ; //out("h7", bin2hex(h7), "+", bin2hex(h), "=", bin2hex(add(h7, h))); h7 = add ( h7 , h ) ; } /* Produce the final hash value (big-endian): digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 */ digest = arrayBin2hex ( [ h0 , h1 , h2 , h3 , h4 , h5 , h6 , h7 ] ) ; } catch ( e ) { err = e ; console . error ( "ERROR" , e ) ; } finally { return debugging ? [ digest . join ( " " ) , debugOutput , err ] : digest . join ( '' ) ; } } 
function ( selector , config = { } ) { if ( ! ( this instanceof Leipzig ) ) { return new Leipzig ( selector , config ) ; } if ( typeof selector !== 'undefined' ) { if ( typeof selector === 'string' || selector instanceof NodeList || selector instanceof Element ) { config . selector = selector ; } else if ( typeof selector === 'object' ) { 
function UrlHelper ( params ) { this . url = "http://store.steampowered.com/search/?" ; if ( ! ! params . tags ) { for ( i = 0 ; i < params . tags . length ; i ++ ) params . tags [ i ] = parameters . tags . get ( params . tags [ i ] ) . value this . url += "tags=" + params . tags . join ( "," ) + "&" ; } if ( ! ! params . os ) { for ( i = 0 ; i < params . os . length ; i ++ ) params . os [ i ] = parameters . os . get ( params . os [ i ] ) . value this . url += "os=" + params . os . join ( "," ) + "&" ; } if ( ! ! params . playerAmount ) for ( i = 0 ; i < params . playerAmount . length ; i ++ ) params . playerAmount [ i ] = parameters . playerAmount . get ( params . playerAmount [ i ] ) . value this . url += "category3=" + params . playerAmount . join ( "," ) + "&" ; if ( params . gamesOnly ) this . url += "category1=998&" ; } 
function navigate ( ) { if ( location . hash ) { var newState = JSON . parse ( location . hash . substr ( 1 ) ) ; if ( JSON . stringify ( newState ) !== JSON . stringify ( forceDirectedGraph . state ) ) { forceDirectedGraph . state = newState ; } } } 
function serializeState ( ) { var data = model . data , scale = model . scale , translate = model . translate ; model . state = { nodes : data . nodes . map ( function ( node ) { return { type : node . type , property : node . property , fixed : node . fixed , 
function when ( properties , callback ) { 
function track ( property ) { if ( ! ( property in trackedProperties ) ) { trackedProperties [ property ] = true ; values [ property ] = model [ property ] ; Object . defineProperty ( model , property , { get : function ( ) { return values [ property ] ; } , set : function ( value ) { values [ property ] = value ; getListeners ( property ) . forEach ( function ( callback ) { callback ( value ) ; } ) ; } } ) ; } } 
function findAll ( collection , callbacks ) { localforage . getItem ( collection . sync . localforageKey , function ( err , data ) { if ( data && data . length ) { var done = function ( ) { if ( callbacks . success ) { callbacks . success ( data . filter ( function ( model ) { 
function __require ( uid , parentUid ) { if ( ! __moduleIsCached [ uid ] ) { require it, they will only see an empty Object for now */ 
function getPkgResource ( resources , ret , fullPackHit ) { var pkgList = { } ; var list = [ ] ; var handled = { } ; var idList = resources . map ( function ( resource ) { return resource . id ; } ) ; var resourceMap = { } ; resources . forEach ( function ( resource ) { resourceMap [ resource . id ] = resource ; } ) ; function fullPackPass ( resource ) { if ( ! fullPackHit ) { return true ; } var pkg = ret . map . pkg [ ret . map . res [ resource . id ] . pkg ] ; var unHit = pkg . has . filter ( function ( id ) { return idList . indexOf ( id ) == - 1 ; } ) ; return unHit . length === 0 ; } function addPkg ( id , pkg , srcId ) { if ( pkgList [ id ] ) return ; var head = false ; pkg . has . forEach ( function ( inPkg ) { handled [ inPkg ] = true ; if ( resourceMap [ inPkg ] ) { head = head || ( resourceMap [ inPkg ] . head || false ) ; } } ) ; pkgList [ id ] = true ; list . push ( { type : 'pkg' , id : id , srcId : srcId , head : head } ) ; } resources . forEach ( function ( resource ) { var id = resource . id ; if ( handled [ id ] ) { return false ; } 
function randomDate ( start , end ) { return new Date ( start . getTime ( ) + Math . random ( ) * ( end . getTime ( ) - start . getTime ( ) ) ) ; } 
function randomPrice ( oldPrice , volatility ) { const rnd = randomNumber ( ) ; let changePercent = 2 * volatility * rnd ; if ( changePercent > volatility ) { changePercent -= ( 2 * volatility ) ; } const changeAmount = oldPrice * changePercent ; const newPrice = oldPrice + changeAmount ; return newPrice ; } 
function randomIncident ( types , start , end ) { const x1 = randomDate ( start , end ) ; const x2 = new Date ( x1 ) ; x2 . setDate ( x1 . getDate ( ) + ( Math . floor ( Math . random ( ) * 45 ) ) ) ; Incidents . insert ( { x1 : x1 . getTime ( ) , x2 : x2 . getTime ( ) , y1 : ( Math . floor ( Math . random ( ) * 99 ) ) , type : types [ ( Math . floor ( Math . random ( ) * 2 ) ) ] , } ) ; } 
function getDatetimeUnit ( min , max ) { const diff = max . diff ( min , 'days' ) ; let unit = 'month' ; if ( diff <= 14 ) { unit = 'day' ; } else if ( diff > 14 && diff <= 183 ) { unit = 'week' ; } return unit ; } 
function getRenderedTemplate ( template , data , variableRegex ) { return template . replace ( variableRegex , ( match , captured ) => { const replacement = valueForProperty ( data , captured . trim ( ) ) ; 
function getProcessedPath ( file , data ) { return file . replace ( / __([A-Za-z0-9-]+_?[A-Za-z0-9-]+)+__ / g , ( match ) => { const dataKey = match . substring ( 2 , match . length - 2 ) ; const dataVal = data [ dataKey ] ; if ( dataVal ) { return dataVal ; } return match ; } ) ; } 
function scaffold ( { source = '' , destination = 'destination' , onlyFiles = false , exclude = [ ] , variableRegex = / \{\{\s?([A-Za-z0-9-]+_?[A-Za-z0-9-]+)+\s?\}\} / g , } = { } , data = { } , ) { const cwd = process . cwd ( ) ; const thisSource = pathIsAbsolute ( source ) ? source : path . join ( cwd , source ) ; const thisDestination = pathIsAbsolute ( destination ) ? destination : path . join ( cwd , destination ) ; const thisOnlyFiles = onlyFiles ; const thisExclude = exclude ; const thisVariableRegex = variableRegex ; try { const listOfFiles = fs . readdirSync ( thisSource ) ; const destinationExists = fs . existsSync ( thisDestination ) ; if ( ! destinationExists ) { fs . mkdirSync ( thisDestination ) ; } listOfFiles . forEach ( ( file ) => { const thisFile = path . join ( thisSource , file ) ; const stat = fs . statSync ( thisFile ) ; const destinationFilename = getProcessedPath ( file , data ) ; const destinationPath = path . join ( thisDestination , destinationFilename ) ; if ( stat && stat . isDirectory ( ) && ! thisOnlyFiles && ! thisExclude . includes ( file ) ) { scaffold ( { source : thisFile , destination : destinationPath , onlyFiles : thisOnlyFiles , exclude : thisExclude , variableRegex : thisVariableRegex , } , data ) ; } else if ( ! stat . isDirectory ( ) ) { const template = fs . readFileSync ( thisFile , 'utf-8' ) ; const filledTemplate = getRenderedTemplate ( template , data , thisVariableRegex ) ; fs . writeFileSync ( destinationPath , filledTemplate ) ; } } ) ; } catch ( e ) { throw new Error ( e ) ; } } 
function ( lookup ) { var matches = tmplRegExp . exec ( lookup ) ; if ( matches ) { return { src : matches && matches [ 0 ] , prop : matches && matches [ 1 ] || matches [ 2 ] , } ; } else { return false ; } } 
function ( data , lookup , options ) { var property ; 
function ( data , arr , options ) { return arr . map ( function ( lookup ) { return expander . process ( data , lookup , options ) ; } ) ; } 
function ( data , obj , options ) { var result = { } ; Object . keys ( obj ) . forEach ( function ( key ) { result [ key ] = expander . process ( data , obj [ key ] , options ) ; } ) ; return result ; } 
function _execute ( $vm ) { var __$args__ = __$util__ . slice ( arguments ) var __$expr__ = __$args__ [ 1 ] var __$fn__ = __$compiledExprs___ [ __$expr__ ] try { if ( ! __$fn__ ) { __$fn__ = __$compiledExprs___ [ __$expr__ ] = __$compile__ ( __$expr__ ) } return [ null , __$util__ . immutable ( __$fn__ ( __$util__ . extend ( { } , $vm . $methods , $vm . $data ) ) ) ] } catch ( e ) { __$args__ [ 1 ] = '. ' + __$args__ [ 2 ] + '=' + ( / ^\{ / . test ( __$args__ [ 1 ] ) ? __$args__ [ 1 ] : '{' + __$args__ [ 1 ] + '}' ) 
function style_html ( html_source , options ) { for (var i=0; i<this.indent_level; i++) { content += this.indent_string; } space = false; */ this . line_char_count = 0 ; continue ; } } content += input_char ; this . line_char_count ++ ; space = true ; } while ( content . indexOf ( delimiter ) == - 1 ) ; return content ; } this . get_token = function ( ) { 
function _set ( obj , keypath , value ) { var parts = _keyPathNormalize ( keypath ) . split ( '.' ) var last = parts . pop ( ) var dest = obj var hasError var errorInfo util . some ( parts , function ( key ) { var t = util . type ( dest ) if ( t != 'object' && t != 'array' ) { hasError = true errorInfo = [ key , dest ] return true } dest = dest [ key ] } ) 
function ( v ) { if ( ! this . _key ) return if ( util . type ( v ) == 'array' ) { var that = this this . _v = v var lastVms = that . _vms || [ ] var lastVmMap = that . _vmMap || { } var parentVm = that . $vm var removedVms = [ ] var changedVms = [ ] var insertedVms = [ ] var vms = that . _vms = new Array ( that . _v . length ) var vmMap = that . _vmMap = { } var lastInsertIndex = - 1 var continuedChangeOffset = 0 var lastChangeIndex = - 1 var isContinuedInsert = true var isContinuedChange = true var cursor = 0 util . forEach ( that . _v , function ( data , index ) { var isObj = util . isObj ( data ) var key if ( that . _isIndexKey ) { key = index } else if ( ! isObj || that . _isSelfStrKey ) { key = data + '' } else { key = keypath . get ( data , that . _key ) } var vm = lastVmMap [ key ] if ( vm ) { vm = vm . vm } var p = { key : key , vm : vm } if ( vmMap [ key ] ) { * If `listId` and compile result exit, use it */ if ( ! that . _compileCache && that . _listId && listCompileResults [ that . _listId ] ) { that . _compileCache = listCompileResults [ that . _listId ] } * cache compile result */ if ( that . _listId && ! listCompileResults [ that . _listId ] ) { listCompileResults [ that . _listId ] = that . _compileCache } if ( isContinuedInsert ) { if ( lastInsertIndex < 0 ) { lastInsertIndex = index } else { if ( lastInsertIndex + 1 != index ) { * remove */ util . forEach ( lastVms , function ( item ) { if ( ! vmMap [ item . key ] ) { removedVms . push ( item ) } } ) var changedCount = changedVms . length var insertedCount = insertedVms . length var removedCount = removedVms . length var onlyRemoved if ( ! insertedCount ) { if ( ! changedCount && ! removedCount ) { return } else if ( removedCount && ( ! changedCount || ( - 1 * continuedChangeOffset == removedCount && isContinuedChange ) ) ) { onlyRemoved = true } } else { if ( isContinuedInsert && ( ! changedCount || isContinuedChange ) ) { onlyRemoved = true 
function ( text ) { if ( ! text || ! text . replace ) return text return text . replace ( / (&[#a-zA-Z0-9]+;) / g , function ( m , s ) { return _convertEntity ( s ) } ) } 
function compute ( ) { 
function ( ) { var containerProps = pluckTableProps ( this . props ) ; containerProps . cssPrefix = "row" ; containerProps . wrapper = pluckTdProps ( mixin ( { } , Row . defaultProps . wrapper , this . props . wrapper || { } ) ) ; return containerProps ; } 
function submitRequest ( params ) { debug ( 'sending API request to proxy <iframe> %o' , params ) ; 
function getFileValue ( v ) { if ( isFile ( v ) ) { return v ; } if ( typeof v === 'object' && isFile ( v . fileContents ) ) { return v . fileContents ; } return null ; } 
function patchFileObjects ( formData ) { 
function install ( ) { debug ( 'install()' ) ; if ( iframe ) { uninstall ( ) ; } buffered = [ ] ; 
function uninstall ( ) { debug ( 'uninstall()' ) ; event . unbind ( window , 'message' , onmessage ) ; document . body . removeChild ( iframe ) ; loaded = false ; iframe = null ; } 
function onload ( ) { debug ( 'proxy <iframe> "load" event' ) ; loaded = true ; 
function onmessage ( e ) { debug ( 'onmessage' ) ; 
function onprogress ( data ) { debug ( 'got "progress" event: %o' , data ) ; const xhr = requests [ data . callbackId ] ; if ( xhr ) { const prog = new ProgressEvent ( 'progress' , data ) ; const target = data . upload ? xhr . upload : xhr ; target . dispatchEvent ( prog ) ; } } 
function resolve ( xhr , body , headers ) { const e = new ProgressEvent ( 'load' ) ; e . data = e . body = e . response = body ; e . headers = headers ; xhr . dispatchEvent ( e ) ; } 
function reject ( xhr , err , headers ) { const e = new ProgressEvent ( 'error' ) ; e . error = e . err = err ; e . headers = headers ; xhr . dispatchEvent ( e ) ; } 
function Real ( options ) { options = options || { } var optimiseOpt = options . optimise || { } var precompile = optimiseOpt . precompile var compileCache = optimiseOpt . compileCache var vm = this var NS = conf . namespace var _ready = options . ready var _created = options . created var _destroy = options . destroy var _binding if ( compileCache ) { _binding = compileCache . hasBinding } else { _binding = util . hasOwn ( options , 'binding' ) ? options . binding : true if ( precompile ) { precompile . hasBinding = _binding } } var _message if ( ! optimiseOpt . noMessage ) { _message = this . _message = new Message ( ) } this . $id = _cid ++ this . $name = options . name || '' this . $parent = options . parent || null this . $binding = ! ! _binding this . $shouldUpdate = options . shouldUpdate this . $directives = [ ] this . $components = [ ] this . $watchers = [ ] this . _$beforeDestroy = function ( ) { _safelyCall ( conf [ CATCH_KEY ] , _destroy , vm ) } var el = options . el var hasReplaceOption = util . hasOwn ( options , 'replace' ) ? options . replace : false if ( util . type ( el ) == 'string' ) { var sel = el if ( supportQuerySelector ) { el = document . querySelector ( sel ) } else if ( / ^\. / . test ( sel ) ) { el = _getElementsByClassName ( sel . replace ( / ^\. / , '' ) ) el && ( el = el [ 0 ] ) } else if ( / ^# / . test ( sel ) ) { el = document . getElementById ( sel . replace ( / ^# / , '' ) ) } else { el = null } if ( ! el ) return consoler . error ( 'Can\'t resolve element by "' + sel + '"' ) } /** * Container element must be a element or has template option */ var isHTMLElement = is . Element ( el ) var children if ( isHTMLElement && options . template ) { /** * If el is passed and has template option * if without "replace", it will render template to innerHTML, * otherwise template rendering to innerHTML and replace the component element with * root element of template. */ if ( util . hasAttribute ( el , NS + 'notemplate' ) || options . notemplate ) { // skip render template, using with SSR } else if ( hasReplaceOption ) { var child = _fragmentWrap ( options . template ) // for get first Element of the template as root element of the component children = _fragmentChildren ( child ) if ( ! children . length ) throw new Error ( 'Component with \'replace\' must has a child element of template.' , options . template ) var nextEl = children [ 0 ] var parent = el . parentNode if ( parent ) { parent . replaceChild ( nextEl , el ) } _cloneAttributes ( el , nextEl ) el = nextEl } else { // el is given then set template as innerHTML for the component if ( is . Fragment ( el ) ) { consoler . warn ( 'Container element should\'nt a fragment node when "template" is given. Template:\n' , options . template ) } else { el . innerHTML = options . template } } } else if ( ! el && options . template ) { if ( hasReplaceOption ) { var frag = _fragmentWrap ( options . template ) 
function instanceScopedDirective ( tar , dec , dname ) { 
function _safelyCall ( isCatch , fn , ctx ) { if ( ! fn ) return if ( isCatch ) { try { fn . call ( ctx ) } catch ( e ) { consoler . errorTrace ( e ) } } else { fn . call ( ctx ) } } 
function _update ( ) { if ( d . $destroyed ) return consoler . warn ( 'Directive "' + name + '" already destroyed.' ) var hasDiff = false 
function mixin ( a ) { var k , key , o ; var len = arguments . length ; for ( k = 1 ; k < len ; k += 1 ) { o = arguments [ k ] ; for ( key in o ) { var v = o [ key ] ; if ( o . hasOwnProperty ( key ) ) { if ( v === undefined || v === null ) { delete a [ key ] ; } else { a [ key ] = o [ key ] ; } } } } return a ; } 
function loadMiddlewareFilters ( filters ) { var result = [ ] , index , num = filters . length , filter , modulePath , middleware ; function startsWith ( string , searchString , position ) { position = position || 0 ; return string . indexOf ( searchString , position ) === position ; } for ( index = 0 ; index < num ; index ++ ) { filter = filters [ index ] ; 
function loadResources ( resources , providerIndex ) { var result = [ ] , index , num = resources . length , resource , prefilters , postfilters ; for ( index = 0 ; index < num ; index ++ ) { resource = resources [ index ] ; prefilters = [ ] ; postfilters = [ ] ; 
function loadProviders ( providers ) { var result = [ ] , index , num = providers . length , provider , prefilters , postfilters , resources ; for ( index = 0 ; index < num ; index ++ ) { provider = providers [ index ] ; prefilters = [ ] ; postfilters = [ ] ; resources = [ ] ; 
function load ( config ) { var configuration = { prefilters : [ ] , providers : [ ] , postfilters : [ ] } ; 
function Clyde ( options ) { 
function Currencies ( currencies ) { if ( ! currencies ) { throw new Error ( 'Missing currencies object' ) ; } this . keys = parseInt ( currencies . keys || 0 ) ; this . metal = parseFloat ( currencies . metal || 0 ) ; if ( isNaN ( this . keys ) || isNaN ( this . metal ) ) { throw new Error ( 'Not a valid currencies object' ) ; } this . metal = toRefined ( toScrap ( this . metal ) ) ; } 
function parsePath ( url ) { url = ( url || "" ) . trim ( ) var output = { protocols : protocols ( url ) , protocol : null , port : null , resource : "" , user : "" , pathname : "" , hash : "" , search : "" , href : url , query : Object . create ( null ) } , protocolIndex = url . indexOf ( "://" ) , resourceIndex = - 1 , splits = null , parts = null ; if ( url . startsWith ( "." ) ) { if ( url . startsWith ( "./" ) ) { url = url . substring ( 2 ) ; } output . pathname = url ; output . protocol = "file" ; } const firstChar = url . charAt ( 1 ) if ( ! output . protocol ) { output . protocol = output . protocols [ 0 ] if ( ! output . protocol ) { if ( isSsh ( url ) ) { output . protocol = "ssh" } else if ( firstChar === "/" || firstChar === "~" ) { url = url . substring ( 2 ) output . protocol = "file" } else { output . protocol = "file" } } } if ( protocolIndex !== - 1 ) { url = url . substring ( protocolIndex + 3 ) ; } parts = url . split ( "/" ) ; if ( output . protocol !== "file" ) { output . resource = parts . shift ( ) ; } else { output . resource = "" ; } 
function getOptions ( ) { 
function getWindowForElement ( element ) { var doc = element . ownerDocument || element ; return doc . defaultView || doc . parentWindow || window ; } 
function createInputInstance ( manager ) { var Type ; var inputClass = manager . options . inputClass ; if ( inputClass ) { Type = inputClass ; } else if ( SUPPORT_POINTER_EVENTS ) { Type = PointerEventInput ; } else if ( SUPPORT_ONLY_TOUCH ) { Type = TouchInput ; } else if ( ! SUPPORT_TOUCH ) { Type = MouseInput ; } else { Type = TouchMouseInput ; } return new Type ( manager , inputHandler ) ; } 
function inputHandler ( manager , eventType , input ) { var pointersLen = input . pointers . length ; var changedPointersLen = input . changedPointers . length ; var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0 ; var isFinal = eventType & ( INPUT_END | INPUT_CANCEL ) && pointersLen - changedPointersLen === 0 ; input . isFirst = ! ! isFirst ; input . isFinal = ! ! isFinal ; if ( isFirst ) { manager . session = { } ; } 
function computeInputData ( manager , input ) { var session = manager . session ; var pointers = input . pointers ; var pointersLength = pointers . length ; 
function TMEhandler ( manager , inputEvent , inputData ) { var isTouch = inputData . pointerType == INPUT_TYPE_TOUCH , isMouse = inputData . pointerType == INPUT_TYPE_MOUSE ; if ( isMouse && inputData . sourceCapabilities && inputData . sourceCapabilities . firesTouchEvents ) { return ; } 
function ( input ) { var srcEvent = input . srcEvent ; var direction = input . offsetDirection ; 
function ( tId , partialTree ) { if ( tId === void 0 ) { tId = '' ; } if ( partialTree === void 0 ) { partialTree = tree ; } if ( ! tId ) { return undefined ; } var found ; partialTree . some ( function ( treeItem ) { if ( treeItem [ id ] === tId ) { found = treeItem ; return true ; } found = treeItem [ children ] ? find ( tId , treeItem [ children ] ) : undefined ; return found ? true : false ; } ) ; return found ; } 
function ( tId , partialTree ) { if ( tId === void 0 ) { tId = '' ; } if ( partialTree === void 0 ) { partialTree = tree ; } if ( ! tId ) { return false ; } var found = false ; partialTree . some ( function ( treeItem , i ) { if ( treeItem [ id ] === tId ) { partialTree . splice ( i , 1 ) ; found = true ; return true ; } found = treeItem [ children ] ? deleteTreeItem ( tId , treeItem [ children ] ) : false ; if ( found && treeItem [ children ] . length === 0 ) { delete treeItem [ children ] ; delete treeItem [ opts . isOpen ] ; } return found ; } ) ; return found ; } 
function ( updatedTreeItem , partialTree ) { if ( partialTree === void 0 ) { partialTree = tree ; } var found = false ; partialTree . some ( function ( treeItem , i ) { if ( treeItem [ id ] === updatedTreeItem [ id ] ) { partialTree [ i ] = updatedTreeItem ; found = true ; return true ; } found = treeItem [ children ] ? updateTreeItem ( updatedTreeItem , treeItem [ children ] ) : false ; return found ; } ) ; return found ; } 
function ( el ) { return el . id ? el . id : el . parentElement ? findId ( el . parentElement ) : null ; } 
function listLocalDatasetClientData ( datasetClient , cb ) { syncStorage . readDatasetClientWithRecords ( datasetClient . getId ( ) , function ( err , datasetClientsWithRecords ) { if ( err ) { return cb ( err ) ; } 
function listAppliedChangeSinceLastSync ( datasetId , lastSyncEndTime , clientInfo , cb ) { syncStorage . listUpdates ( datasetId , { type : SYNC_UPDATE_TYPES . APPLIED , cuid : clientInfo . cuid , timestamp : { $gt : lastSyncEndTime } } , null , cb ) ; } 
function listPendingChangesForClient ( datasetId , clientInfo , cb ) { pendingQueue . search ( { datasetId : datasetId , cuid : clientInfo . cuid } , cb ) ; } 
function listChangesNotInLocalDataset ( datasetId , lastSyncTime , clientInfo , cb ) { async . parallel ( { appliedUpdatesSinceLastSync : async . apply ( listAppliedChangeSinceLastSync , datasetId , lastSyncTime , clientInfo ) , pendingChangesForClient : async . apply ( listPendingChangesForClient , datasetId , clientInfo ) } , function ( err , results ) { if ( err ) { return cb ( err ) ; } return cb ( null , results . appliedUpdatesSinceLastSync , results . pendingChangesForClient ) ; } ) ; } 
function removeAppliedUpdates ( clientRecords , localDatasetClient , appliedUpdates ) { _ . each ( appliedUpdates , function ( update , recordUid ) { if ( clientRecords [ recordUid ] ) { delete clientRecords [ recordUid ] ; } if ( localDatasetClient [ recordUid ] ) { delete localDatasetClient [ recordUid ] ; } 
function removePendingChanges ( clientRecords , localDatasetClient , pendingChanges ) { _ . each ( pendingChanges , function ( pendingChange , uid ) { if ( clientRecords [ uid ] ) { delete clientRecords [ uid ] ; } if ( localDatasetClient [ uid ] ) { delete localDatasetClient [ uid ] ; } } ) ; } 
function computeDelta ( datasetId , clientRecords , serverRecords ) { var creates = { } ; var updates = { } ; var deletes = { } ; _ . each ( serverRecords , function ( serverRecord , serverRecordUid ) { var serverRecHash = serverRecord . hash ; 
function syncRecords ( datasetId , params , cb ) { debug ( '[%s] process syncRecords request' , datasetId ) ; var queryParams = params . query_params || { } ; var metaData = params . meta_data || { } ; 
function processTouchEvent ( env , e ) { var listener , touches = [ ] ; e = JSON . parse ( e ) ; if ( e . touchSourceDevice !== 'CapacitiveKeyboard' || ! e . touchPoints || ! e . touchPoints . length ) { return ; } if ( ! _listeners [ env . webviewId ] ) { return ; } e . touchPoints . forEach ( function ( point ) { touches . push ( { keyboardX : point . screenPosition . x + _shift . x , keyboardY : point . screenPosition . y + _shift . y , state : point . state , identifier : point . id } ) ; } ) ; listener = _listeners [ env . webviewId ] ; listener ( { type : _type , touches : touches , timeStamp : e . timeStamp } ) ; } 
function ( metric , records ) { var returnValue = { message : 'no stats available' , name : metric . displayName } ; if ( records && records . length > 0 ) { returnValue = _ . chain ( records ) . map ( function ( recordStr ) { return JSON . parse ( recordStr ) ; } ) . groupBy ( function ( record ) { return record . tags [ metric . groupByTag ] ; } ) . reduce ( function ( reduced , groupRecords , groupKey ) { groupRecords = _ . sortBy ( groupRecords , 'ts' ) ; var processedData = _ . reduce ( groupRecords , function ( memo , groupRecord ) { var value = groupRecord . fields [ metric . valueField ] ; memo . current = value ; memo . numberOfRecords ++ ; memo . total += value ; memo . max = Math . max ( value , memo . max ) ; memo . min = Math . min ( value , memo . min ) ; memo . from = Math . min ( groupRecord . ts , memo . from ) ; memo . end = Math . max ( groupRecord . ts , memo . end ) ; return memo ; } , { max : 0 , min : MAX_NUMBER , current : 0 , numberOfRecords : 0 , total : 0 , from : MAX_NUMBER , end : 0 } ) ; reduced [ groupKey ] = { current : metric . dataFormatter ( processedData . current ) , max : metric . dataFormatter ( processedData . max ) , min : metric . dataFormatter ( processedData . min ) , average : metric . dataFormatter ( processedData . total / processedData . numberOfRecords ) , numberOfRecords : processedData . numberOfRecords , from : new Date ( processedData . from ) . toISOString ( ) , end : new Date ( processedData . end ) . toISOString ( ) } ; return reduced ; } , { } ) . value ( ) ; } return returnValue ; } 
function init ( dataset_id , options , cb ) { debug ( '[%s] init sync with options %j' , dataset_id , options ) ; datasets . init ( dataset_id , options ) ; 
function start ( cb ) { if ( arguments . length < 1 ) throw new Error ( 'start requires 1 argument' ) ; syncStarted = true ; if ( mongoDbClient === null || redisClient === null ) { throw new Error ( 'MongoDB Client & Redis Client are not connected. Ensure you have called sync.connect() before calling sync.init()' ) ; } metricsClient = metricsModule . init ( syncConfig , redisClient ) ; async . series ( [ function createQueues ( callback ) { ackQueue = new MongodbQueue ( 'fhsync_ack_queue' , metricsClient , syncLock , { mongodb : mongoDbClient , queueMessagesTTL : syncConfig . queueMessagesTTL } ) ; pendingQueue = new MongodbQueue ( 'fhsync_pending_queue' , metricsClient , syncLock , { mongodb : mongoDbClient , queueMessagesTTL : syncConfig . queueMessagesTTL , visibility : syncConfig . pendingWorkerRetryIntervalInSeconds } ) ; syncQueue = new MongodbQueue ( 'fhsync_queue' , metricsClient , syncLock , { mongodb : mongoDbClient , queueMessagesTTL : syncConfig . queueMessagesTTL } ) ; async . parallel ( [ async . apply ( ackQueue . create . bind ( ackQueue ) ) , async . apply ( pendingQueue . create . bind ( pendingQueue ) ) , async . apply ( syncQueue . create . bind ( syncQueue ) ) ] , callback ) ; } , function initApis ( callback ) { apiSync = syncApiModule ( interceptors , ackQueue , pendingQueue , syncStorage , syncConfig ) ; apiSyncRecords = syncRecordsApiModule ( syncStorage , pendingQueue , syncConfig ) ; return callback ( ) ; } , function createWorkers ( callback ) { var syncProcessorImpl = syncProcessor ( syncStorage , dataHandlers , metricsClient , hashProvider ) ; var syncWorkerOpts = { name : 'sync_worker' , interval : syncConfig . syncWorkerInterval , backoff : syncConfig . syncWorkerBackoff , collectStatsInterval : syncConfig . collectStatsInterval } ; for ( var i = 0 ; i < syncConfig . syncWorkerConcurrency ; i ++ ) { var syncWorker = new Worker ( syncQueue , syncProcessorImpl , metricsClient , syncWorkerOpts ) ; syncWorkers . push ( syncWorker ) ; } var ackProcessorImpl = ackProcessor ( syncStorage ) ; var ackWorkerOpts = { name : 'ack_worker' , interval : syncConfig . ackWorkerInterval , backoff : syncConfig . ackWorkerBackoff , collectStatsInterval : syncConfig . collectStatsInterval } ; for ( var j = 0 ; j < syncConfig . ackWorkerConcurrency ; j ++ ) { var ackWorker = new Worker ( ackQueue , ackProcessorImpl , metricsClient , ackWorkerOpts ) ; ackWorkers . push ( ackWorker ) ; } var pendingProcessorImpl = pendingProcessor ( syncStorage , dataHandlers , hashProvider , metricsClient , syncConfig . pendingWorkerRetryLimit ) ; var pendingWorkerOpts = { name : 'pending_worker' , interval : syncConfig . pendingWorkerInterval , backoff : syncConfig . pendingWorkerBackoff , collectStatsInterval : syncConfig . collectStatsInterval } ; for ( var k = 0 ; k < syncConfig . pendingWorkerConcurrency ; k ++ ) { var pendingWorker = new Worker ( pendingQueue , pendingProcessorImpl , metricsClient , pendingWorkerOpts ) ; pendingWorkers . push ( pendingWorker ) ; } startAllWorkers ( syncWorkers ) ; startAllWorkers ( ackWorkers ) ; startAllWorkers ( pendingWorkers ) ; return callback ( ) ; } , function startSyncScheduler ( callback ) { var SyncScheduler = syncSchedulerModule ( syncLock , syncStorage , metricsClient ) . SyncScheduler ; syncScheduler = new SyncScheduler ( syncQueue , { timeBetweenChecks : syncConfig . schedulerInterval , timeBeforeCrashAssumed : syncConfig . schedulerLockMaxTime , syncSchedulerLockName : syncConfig . schedulerLockName } ) ; syncScheduler . start ( ) ; return callback ( ) ; } , function startDatasetClientCleaner ( callback ) { var datasetClientCleanerBuilder = datasetClientCleanerModule ( syncStorage , syncLock ) ; datasetClientCleaner = datasetClientCleanerBuilder ( { retentionPeriod : syncConfig . datasetClientCleanerRetentionPeriod , checkFrequency : syncConfig . datasetClientCleanerCheckFrequency } ) ; datasetClientCleaner . start ( true , callback ) ; } ] , function ( err ) { if ( err ) { 
function stop ( dataset_id , cb ) { if ( ! syncStarted ) { return cb ( ) ; } debug ( '[%s] stop sync for dataset' , dataset_id ) ; syncStorage . updateManyDatasetClients ( { datasetId : dataset_id } , { stopped : true } , cb ) ; } 
function stopAll ( cb ) { 
function removeCollision ( datasetId , params , cb ) { debug ( '[%s] removeCollision' ) ; dataHandlers . removeCollision ( datasetId , params . hash , params . meta_data , cb ) ; } 
function doListDatasetClients ( filter , cb ) { debug ( 'doListDatasetClients' ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . find ( filter ) . toArray ( function ( err , datasetClients ) { if ( err ) { debugError ( 'Failed to list datasetClients due to error %s' , err ) ; } return cb ( err , datasetClients ) ; } ) ; } 
function doRemoveDatasetClients ( datasetClientsToRemove , cb ) { var removeIds = _ . pluck ( datasetClientsToRemove , 'id' ) ; var datasetIds = _ . uniq ( _ . pluck ( datasetClientsToRemove , 'datasetId' ) ) ; debug ( 'doRemoveDatasetClients: removed datasetClients = %d, datasets = %d' , removeIds . length , datasetIds . length ) ; async . series ( [ function deleteDatasetClientAndRefs ( callback ) { async . map ( removeIds , doRemoveDatasetClientWithRecords , function ( err , deleteResult ) { if ( err ) { debug ( 'Failed to delete datasetClients due to error %s' , err ) ; } return callback ( err , deleteResult ) ; } ) ; } , function removeUnusedRecords ( callback ) { async . map ( datasetIds , removeRecordsForDataset , function ( err , deletedCount ) { if ( err ) { debug ( 'Error occured when delete records for dataset due to error %s' , err ) ; } return callback ( err , deletedCount ) ; } ) ; } ] , function ( err , results ) { if ( err ) { return cb ( err ) ; } else { return cb ( null , results [ 0 ] ) ; } } ) ; } 
function doRemoveDatasetClientWithRecords ( datasetClientId , cb ) { debug ( 'doRemoveDatasetClientWithRecords datasetClientId = %s' , datasetClientId ) ; async . waterfall ( [ async . apply ( doReadDatasetClient , datasetClientId ) , function removeRefs ( datasetClientJson , next ) { var datasetId = datasetClientJson . datasetId ; var recordsCollection = mongoClient . collection ( getDatasetRecordsCollectionName ( datasetId ) ) ; recordsCollection . updateMany ( { 'refs' : datasetClientId } , { '$pull' : { 'refs' : datasetClientId } } , function ( err ) { return next ( err , datasetClientJson ) ; } ) ; } , function deleteDatasetClient ( datasetClientJson , next ) { var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . findOneAndDelete ( { 'id' : datasetClientId } , next ) ; } ] , function ( err , result ) { if ( err ) { debug ( 'Failed to doRemoveDatasetClientWithRecords due to error %s' , err ) ; return cb ( err ) ; } else { return cb ( null , result && result . value ) ; } } ) ; } 
function upsertOrDeleteDatasetRecords ( datasetId , datasetClientId , records , cb ) { var datasetRecordsCol = mongoClient . collection ( getDatasetRecordsCollectionName ( datasetId ) ) ; debug ( 'upsertOrDeleteDatasetRecords diff records = %j' , records ) ; async . mapLimit ( records , RECORDS_UPDATE_CONCURRENCY , function ( record , callback ) { var op = record . op ; var fields = { uid : record . uid , hash : record . hash , data : record . data } ; var update = { '$set' : fields } ; if ( op === 'update' ) { 
function listDatasetClientRecords ( datasetClientJson , projection , cb ) { debug ( 'listDatasetClientRecords datasetClientJson = %j' , datasetClientJson ) ; var datasetId = datasetClientJson . datasetId ; var datasetRecordsCol = mongoClient . collection ( getDatasetRecordsCollectionName ( datasetId ) ) ; var cursor = datasetRecordsCol . find ( { 'refs' : datasetClientJson . id } ) ; if ( projection ) { cursor = cursor . project ( projection ) ; } else { cursor = cursor . project ( { 'refs' : 0 } ) ; } return cursor . toArray ( function ( err , records ) { if ( err ) { debug ( '[%s] Failed to list datasetClient records due to error %s :: datasetClientJson = %j' , err , datasetClientJson ) ; } return cb ( err , records ) ; } ) ; } 
function doReadDatasetClientWithRecords ( datasetClientId , callback ) { debug ( 'doReadDatasetClientWithRecords datasetClientId = ' , datasetClientId ) ; async . waterfall ( [ async . apply ( doReadDatasetClient , datasetClientId ) , function listRecords ( datasetClientJson , next ) { if ( datasetClientJson ) { listDatasetClientRecords ( datasetClientJson , null , function ( err , localRecords ) { return next ( err , datasetClientJson , localRecords ) ; } ) ; } else { return next ( ) ; } } ] , function ( err , datasetClientJson , localRecords ) { if ( err ) { debugError ( 'Failed to doReadDatasetClientWithRecords due to error %s :: datasetClientId = %s' , err , datasetClientId ) ; return callback ( err ) ; } if ( datasetClientJson ) { datasetClientJson . records = localRecords ; } return callback ( null , datasetClientJson ) ; } ) ; } 
function doReadDatasetClient ( datasetClientId , cb ) { debug ( 'doReadDatasetClient datasetClientId = %s' , datasetClientId ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; col . findOne ( { id : datasetClientId } , function ( err , datasetClient ) { if ( err ) { debugError ( 'Failed to read datasetClient due to error %s :: datasetClientId = %s' , err , datasetClientId ) ; } return cb ( err , datasetClient ) ; } ) ; } 
function doUpdateDatasetClient ( datasetClientId , fields , upsert , cb ) { debug ( 'doUpdateDatasetClient datasetClientId = %s :: fields = %j' , datasetClientId , fields ) ; var col = mongoClient . collection ( DATASETCLIENTS_COLLECTION ) ; delete fields . _id ; col . findOneAndUpdate ( { id : datasetClientId } , { '$set' : fields } , { upsert : upsert , returnOriginal : false } , function ( err , result ) { if ( err ) { debugError ( 'Failed to update datasetClients due to error %s :: datasetClientId = %s :: fields = %j' , err , datasetClientId , fields ) ; return cb ( err ) ; } if ( result . value === null ) { return cb ( new Error ( 'DatasetClient not found for id ' + datasetClientId ) ) ; } 
function createIndexForCollection ( collectionName , indexField , indexOpts ) { var collection = mongoClient . collection ( collectionName ) ; collection . createIndex ( indexField , indexOpts , function ( err ) { if ( err ) { debugError ( 'Failed to create index for collection. collection = %s :: index = %j :: error = %j' , collectionName , indexField , err ) ; } else { debug ( 'Index created for collection. Collection = %s :: index = %j' , collectionName , indexField ) ; } } ) ; } 
function ensureIndexesForDataset ( datasetId ) { createIndexForCollection ( getDatasetRecordsCollectionName ( datasetId ) , { 'uid' : 1 } , { } ) ; createIndexForCollection ( getDatasetRecordsCollectionName ( datasetId ) , { 'refs' : 1 } , { } ) ; createIndexForCollection ( require ( './sync-updates' ) . getDatasetUpdatesCollectionName ( datasetId ) , { 'cuid' : 1 , 'hash' : 1 } , { } ) ; } 
function diffRecords ( localRecords , newRecords ) { var recordsDiff = { } ; _ . each ( newRecords , function ( record , uid ) { if ( localRecords [ uid ] ) { if ( localRecords [ uid ] . hash !== record . hash ) { record . op = "update" ; recordsDiff [ uid ] = record ; } } else { record . op = "update" ; recordsDiff [ uid ] = record ; } } ) ; _ . each ( localRecords , function ( record , uid ) { if ( ! newRecords [ uid ] ) { record . op = "delete" ; recordsDiff [ uid ] = record ; } } ) ; return recordsDiff ; } 
function doUpdateDatasetClientWithRecords ( datasetClientId , fields , records , callback ) { debug ( 'doUpdateDatasetClientWithRecords datasetClientId = %s :: records.length = %d' , datasetClientId , records . length ) ; async . waterfall ( [ function readDatasetClient ( next ) { doReadDatasetClient ( datasetClientId , function ( err , datasetClientJson ) { if ( ! datasetClientJson ) { return next ( new Error ( 'can not find datasetClient with id ' + datasetClientId ) ) ; } else { return next ( err , datasetClientJson ) ; } } ) ; } , function createIndex ( datasetClientJson , next ) { ensureIndexesForDataset ( datasetClientJson . datasetId ) ; return next ( null , datasetClientJson ) ; } , function listRecords ( datasetClientJson , next ) { 
function diff ( datasetClientJson , localRecords , next ) { var recordsDiff = diffRecords ( syncUtil . convertToObject ( localRecords ) , syncUtil . convertToObject ( records ) ) ; return next ( null , datasetClientJson , recordsDiff ) ; } 
function ( filter , callback ) { metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doListDatasetClients ) ( filter , callback ) ; } 
function ( datasetClientsToRemove , callback ) { if ( ! datasetClientsToRemove . length ) { return callback ( ) ; } return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doRemoveDatasetClients ) ( datasetClientsToRemove , callback ) ; } 
function ( datasetClientId , fieldsToUpdate , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClient ) ( datasetClientId , fieldsToUpdate , false , callback ) ; } 
function ( datasetClientId , fields , callback ) { fields . id = datasetClientId ; return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClient ) ( datasetClientId , fields , true , callback ) ; } 
function ( datasetClientId , fields , records , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doUpdateDatasetClientWithRecords ) ( datasetClientId , fields , records , callback ) ; } 
function ( datasetClientId , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doReadDatasetClientWithRecordsUseCache ) ( datasetClientId , callback ) ; } 
function doFindAndDeleteUpdate ( datasetId , acknowledgement , callback ) { debug ( '[%s] doFindAndDeleteUpdate acknowledgement = %j' , datasetId , acknowledgement ) ; var updatesCollection = mongoClient . collection ( getDatasetUpdatesCollectionName ( datasetId ) ) ; updatesCollection . findOneAndDelete ( { cuid : acknowledgement . cuid , hash : acknowledgement . hash } , function ( err , result ) { if ( err ) { debugError ( '[%s] Failed to doFindAndDeleteUpdate due to error %s :: acknowledgement = %j' , datasetId , err , acknowledgement ) ; return callback ( err ) ; } return callback ( null , result . value ) ; } ) ; } 
function doSaveUpdate ( datasetId , acknowledgementFields , callback ) { debug ( '[%s] doSaveUpdate acknowledgementFields = %j' , datasetId , acknowledgementFields ) ; var updatesCollection = mongoClient . collection ( getDatasetUpdatesCollectionName ( datasetId ) ) ; updatesCollection . findOneAndUpdate ( { cuid : acknowledgementFields . cuid , hash : acknowledgementFields . hash } , { '$set' : acknowledgementFields } , { upsert : true , returnOriginal : false } , function ( err , updateResult ) { if ( err ) { debugError ( '[%s] Failed to doSaveUpdate due to error %s :: acknowledgementFields = %j' , datasetId , err , acknowledgementFields ) ; return callback ( err ) ; } return callback ( null , updateResult . value ) ; } ) ; } 
function doListUpdates ( datasetId , criteria , options , callback ) { debug ( '[%s] doListUpdates criteria = %j' , datasetId , criteria ) ; var updatesCollection = mongoClient . collection ( getDatasetUpdatesCollectionName ( datasetId ) ) ; var docLimit = options && options . limit ; var cursor = updatesCollection . find ( criteria ) ; if ( docLimit && docLimit > 0 ) { cursor = cursor . limit ( docLimit ) ; } cursor . toArray ( function ( err , updates ) { if ( err ) { debugError ( '[%s] Failed to doListUpdates due to error %s :: criteria = %j' + criteria , datasetId , err , criteria ) ; return callback ( err ) ; } return callback ( null , updates ) ; } ) ; } 
function ( datasetId , acknowledgement , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doFindAndDeleteUpdate ) ( datasetId , acknowledgement , callback ) ; } 
function ( datasetId , acknowledgementFields , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doSaveUpdate ) ( datasetId , acknowledgementFields , callback ) ; } 
function ( datasetId , criteria , options , callback ) { return metrics . timeAsyncFunc ( metrics . KEYS . MONGODB_OPERATION_TIME , doListUpdates ) ( datasetId , criteria , options , callback ) ; } 
function DatasetClient ( datasetId , opts ) { opts = opts || { } ; this . datasetId = datasetId ; this . queryParams = opts . queryParams || { } ; this . metaData = opts . metaData || { } ; this . id = generateDatasetClientId ( this ) ; this . config = opts . config || datasets . getDatasetConfig ( datasetId ) ; this . collisionCount = opts . collisionCount || 0 ; this . stopped = opts . stopped ; this . syncScheduled = opts . syncScheduled ; this . syncCompleted = opts . syncCompleted ; this . syncLoopStart = opts . syncLoopStart ; this . syncLoopEnd = opts . syncLoopEnd ; this . lastAccessed = opts . lastAccessed ; } 
function connect ( mongoDBConnectionUrl , mongoDBConnectionOption , redisUrl , cb ) { if ( arguments . length < 4 ) throw new Error ( 'connect requires 4 arguments' ) ; async . series ( [ function connectToMongoDB ( callback ) { MongoClient . connect ( mongoDBConnectionUrl , mongoDBConnectionOption || { } , callback ) ; } , function connectToRedis ( callback ) { var redisOpts = { url : redisUrl } ; var client = redis . createClient ( redisOpts ) ; 
function invoke ( dataset_id , params , callback ) { debug ( 'invoke' ) ; if ( arguments . length < 3 ) throw new Error ( 'invoke requires 3 arguments' ) ; 
function strToUTF8Arr ( sDOMStr ) { var aBytes , nChr , nStrLen = sDOMStr . length , nArrLen = 0 , nMapIdx , nIdx , nChrIdx ; for ( nMapIdx = 0 ; nMapIdx < nStrLen ; nMapIdx ++ ) { nChr = sDOMStr . charCodeAt ( nMapIdx ) ; nArrLen += nChr < 0x80 ? 1 : nChr < 0x800 ? 2 : nChr < 0x10000 ? 3 : nChr < 0x200000 ? 4 : nChr < 0x4000000 ? 5 : 6 ; } aBytes = new Uint8Array ( nArrLen ) ; for ( nIdx = 0 , nChrIdx = 0 ; nIdx < nArrLen ; nChrIdx ++ ) { nChr = sDOMStr . charCodeAt ( nChrIdx ) ; if ( nChr < 128 ) { aBytes [ nIdx ++ ] = nChr ; } else if ( nChr < 0x800 ) { aBytes [ nIdx ++ ] = 192 + ( nChr >>> 6 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr & 63 ) ; } else if ( nChr < 0x10000 ) { aBytes [ nIdx ++ ] = 224 + ( nChr >>> 12 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 6 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr & 63 ) ; } else if ( nChr < 0x200000 ) { aBytes [ nIdx ++ ] = 240 + ( nChr >>> 18 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 12 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 6 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr & 63 ) ; } else if ( nChr < 0x4000000 ) { aBytes [ nIdx ++ ] = 248 + ( nChr >>> 24 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 18 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 12 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 6 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr & 63 ) ; } else { aBytes [ nIdx ++ ] = 252 + ( nChr / 1073741824 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 24 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 18 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 12 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr >>> 6 & 63 ) ; aBytes [ nIdx ++ ] = 128 + ( nChr & 63 ) ; } } return aBytes ; } 
function convertToObject ( itemArr ) { var obj = { } ; _ . each ( itemArr , function ( item ) { obj [ item . uid ] = item ; } ) ; return obj ; } 
function SyncScheduler ( syncQueueImpl , options ) { if ( ! syncQueueImpl ) { throw new Error ( 'syncQueueImpl is required' ) ; } this . syncQueue = syncQueueImpl ; options = options || { } ; this . syncSchedulerLockName = options . syncSchedulerLockName || 'locks:sync:SyncScheduler' ; this . timeBetweenChecks = options . timeBetweenChecks || 500 ; this . timeBeforeCrashAssumed = options . timeBeforeCrashAssumed || 20000 ; this . stopped = false ; } 
function updateDatasetClients ( wcb ) { var datasetClientIds = _ . pluck ( datasetClientsToSync , 'id' ) ; syncStorage . updateManyDatasetClients ( { id : { $in : datasetClientIds } } , { syncScheduled : Date . now ( ) } , wcb ) ; } 
function insertDocsToDb ( dburl , collectionName , docs , cb ) { MongoClient . connect ( dburl , function ( err , db ) { if ( err ) { return cb ( err ) ; } var col = db . collection ( collectionName ) ; col . insertMany ( docs , function ( err , result ) { if ( err ) { return cb ( err ) ; } return cb ( null , result ) ; } ) ; } ) ; } 
function set ( key , value , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . set ( key , value , cb ) ; } 
function get ( key , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . get ( key , cb ) ; } 
function del ( key , cb ) { if ( ! syncConfig . useCache || ! redisClient ) { return cb && cb ( ) ; } return redisClient . del ( key , cb ) ; } 
function validateIdMessageSettings ( args ) { if ( args . settings ) { args . settings = JSON . parse ( decodeURIComponent ( args . settings ) ) ; } else { args . settings = { } ; } if ( args . message ) { args . message = decodeURIComponent ( args . message ) ; args . message = args . message = args . message . replace ( / ^"|"$ / g , "" ) . replace ( / \\" / g , '"' ) . replace ( / \\\\ / g , '\\' ) ; } else { return 1 ; } return 0 ; } 
function syncWithBackend ( payload , tries , callback ) { var datasetClientId = payload . id ; var datasetId = payload . datasetId ; var startTime = payload . startTime ; if ( ! datasetClientId || ! datasetId ) { recordProcessTime ( startTime , false ) ; debugError ( "no datasetId value found in sync request payload %j" , payload ) ; return callback ( ) ; } if ( tries > 1 ) { 
function doCreate ( datasetId , pendingChange , callback ) { var record = pendingChange . post ; var metaData = pendingChange . meta_data ; debug ( '[%s] CREATE Start data = %j' , datasetId , record ) ; dataHandlers . doCreate ( datasetId , record , metaData , function ( err , data ) { if ( err ) { debugError ( '[%s] CREATE Failed - : err = %s' , datasetId , err ) ; } else { debug ( '[%s] CREATE Success - uid = %s' , datasetId , data . uid ) ; pendingChange . oldUid = pendingChange . uid ; pendingChange . uid = data . uid ; } return saveUpdate ( datasetId , pendingChange , err ? SYNC_UPDATE_TYPES . FAILED : SYNC_UPDATE_TYPES . APPLIED , err ? util . inspect ( err ) : null , callback ) ; } ) ; } 
function doDelete ( datasetId , pendingChange , callback ) { debug ( '[%s] DELETE Start' , datasetId ) ; var metaData = pendingChange . meta_data ; var uid = pendingChange . uid ; dataHandlers . doRead ( datasetId , uid , metaData , function ( err , data ) { if ( err ) { debugError ( 'READ for DELETE Failed - uid = %s : err = %s' , datasetId , uid , err ) ; return saveUpdate ( datasetId , pendingChange , SYNC_UPDATE_TYPES . FAILED , util . inspect ( err ) , callback ) ; } debug ( '[%s] READ for DELETE Success' , datasetId ) ; debug ( '[%s] READ for DELETE Data : \n%j' , datasetId , data ) ; var preHash = hashProvider . recordHash ( datasetId , pendingChange . pre ) ; var dataHash = hashProvider . recordHash ( datasetId , data ) ; debug ( '[%s] DELETE Hash Check %s (client :: dataStore) = %s :: %s' , datasetId , uid , preHash . dataHash ) ; if ( ! dataHash ) { 
function applyPendingChange ( pendingChange , tries , callback ) { var datasetId = pendingChange . datasetId ; if ( ! datasetId || ! pendingChange . action || ! pendingChange . uid || ! pendingChange . cuid || ! pendingChange . hash ) { debugError ( "[%s] invalid pendingChange request dropped :: item = %j" , datasetId , pendingChange ) ; return callback ( ) ; } debug ( '[%s] processPending :: item = %j' , datasetId , pendingChange ) ; if ( tries > retryLimit ) { 
function MongodbQueue ( name , metrics , lock , opts ) { if ( ! name ) { throw new Error ( 'name is required to create a mongodb queue' ) ; } if ( ! opts || ! opts . mongodb ) { throw new Error ( 'mongodb is not specified to create mongodb queue' ) ; } this . queueName = name ; this . metrics = metrics ; this . lock = lock ; this . lockName = opts . lockName || ( 'lock:sync:' + this . queueName ) ; this . lockTimeout = opts . lockTimeout || 10000 ; this . mongodb = opts . mongodb ; this . queueOptions = { visibility : opts . visibility || 30 , ttl : opts . queueMessagesTTL || 24 * 60 * 60 } ; this . queue ; } 
function listIndexes ( callback ) { debug ( '[%s] list existing indexes' , self . queueName ) ; collection . indexInformation ( { full : true } , function ( err , indexInfo ) { if ( err ) { debug ( '[%s] error getting indexInfo. skipping ttl index check: %s' , self . queueName , err ) ; return callback ( null , null ) ; } return callback ( null , indexInfo ) ; } ) ; } 
function ( datasetId , params , callback ) { var interceptor = requestInterceptors [ datasetId ] || defaults . requestInterceptor ; return interceptor ( datasetId , params , callback ) ; } 
function ( datasetId , queryParams , callback ) { var interceptor = responseInterceptors [ datasetId ] || defaults . responseInterceptor ; return interceptor ( datasetId , queryParams , callback ) ; } 
function addToQueue ( items , extraParams , targetQueue , cb ) { if ( ! items || items . length === 0 ) { return cb ( ) ; } var itemsToPush = _ . map ( items , function ( item ) { return _ . extend ( { } , item , extraParams ) ; } ) ; debug ( "adding %d items to queue %s" , itemsToPush . length , targetQueue . getName ( ) ) ; targetQueue . addMany ( itemsToPush , cb ) ; } 
function formatUpdates ( processedUpdates ) { var updates = { hashes : { } } ; _ . each ( processedUpdates , function ( update ) { var type = update . type ; var hash = update . hash ; updates . hashes [ hash ] = update ; updates [ type ] = updates [ type ] || { } ; updates [ type ] [ hash ] = update ; } ) ; return updates ; } 
function removeUpdatesInRequest ( updatesInDb , updatesInRequest ) { var updatesNotInRequest = _ . filter ( updatesInDb , function ( dbUpdate ) { var foundInRequest = _ . findWhere ( updatesInRequest , { hash : dbUpdate . hash } ) ; return ! foundInRequest ; } ) ; return updatesNotInRequest ; } 
function sync ( datasetId , params , cb ) { debug ( '[%s] process sync request for the dataset' , datasetId ) ; var queryParams = params . query_params || { } ; var metaData = params . meta_data || { } ; var datasetClient = new DatasetClient ( datasetId , { queryParams : queryParams , metaData : metaData } ) ; debug ( '[%s] processing sync API request :: query_params = %j:: meta_data = %j' , datasetId , queryParams , metaData ) ; async . series ( { requestInterceptor : async . apply ( interceptors . requestInterceptor , datasetId , params ) , readDatasetClient : function checkDatasetclientStopped ( callback ) { syncStorage . readDatasetClient ( datasetClient . getId ( ) , function ( err , datasetClientJson ) { if ( err ) { return callback ( err ) ; } if ( datasetClientJson && datasetClientJson . stopped === true ) { return callback ( new Error ( 'sync stopped for dataset ' + datasetId ) ) ; } else { return callback ( null , datasetClientJson ) ; } } ) ; } } , function ( err , results ) { if ( err ) { debugError ( '[%s] sync request returns error = %s %j' , datasetId , err , params ) ; return cb ( err ) ; } return processSyncAPI ( datasetId , params , results . readDatasetClient , cb ) ; } ) ; } 
function ( data , reason ) { switch ( reason ) { case "cancel" : if ( onCancel && typeof ( onCancel ) === "function" ) { onCancel ( ) ; } break ; case "done" : if ( onDone && typeof ( onDone ) === "function" ) { onDone ( data ) ; } break ; } } 
function ( result ) { var error ; if ( ! result . _success ) { error = new ContactError ( result . code ) ; } if ( onInvoke && typeof ( onInvoke ) === "function" ) { onInvoke ( error ) ; } } 
function DatasetClientsCleaner ( opts ) { this . retentionPeriod = opts . retentionPeriod || '24h' ; this . checkFrequency = opts . checkFrequency || '1h' ; this . cleanerLockName = opts . cleanerLockName || 'locks:sync:DatasetCleaner' ; this . lockTimeout = parseDuration ( this . checkFrequency ) / 2 ; this . job ; } 
function processAcknowledgement ( acknowledgement , callback ) { var datasetId = acknowledgement . datasetId ; if ( ! datasetId || ! acknowledgement . cuid || ! acknowledgement . hash ) { debugError ( "acknowledgement missing info %j" , acknowledgement ) ; return callback ( ) ; } debug ( 'processAcknowledge :: processing acknowledge %j' , acknowledgement ) ; syncStorage . findAndDeleteUpdate ( datasetId , acknowledgement , function ( err ) { if ( err ) { debugError ( 'END processAcknowledge - err=%s' , err ) ; return callback ( err ) ; } else { debug ( 'acknowledgement processed successfully. hash = %s' , acknowledgement . hash ) ; return callback ( ) ; } } ) ; } 
function ( success , fail , args , env ) { var result = new PluginResult ( args , env ) , userargs , wv , i ; 
function ( error ) { if ( error ) { result . callbackError ( error , false ) ; } else { result . callbackOk ( undefined , false ) ; } } 
function addEventListeners ( ) { window . addEventListener ( 'resize' , this . eventListener ) ; this . scrollParents . forEach ( parent => { parent . addEventListener ( 'scroll' , this . eventListener ) ; } ) ; } 
function removeEventListeners ( ) { window . removeEventListener ( 'resize' , this . eventListener ) ; this . scrollParents . forEach ( parent => { parent . removeEventListener ( 'scroll' , this . eventListener ) ; } ) ; } 
function ( element ) { for ( var i = 0 , len = this . length ; i < len ; i ++ ) { if ( element === this [ i ] ) { return true ; } } return false ; } 
function ( elements ) { if ( ! _ . isArray ( elements ) ) { elements = [ elements ] ; } elements . forEach ( function ( e ) { this . push ( e ) ; } . bind ( this ) ) ; return this ; } 
function ( list ) { var result = false ; list . forEach ( function ( e ) { result |= this . removeElement ( e ) ; } . bind ( this ) ) ; return result ; } 
function ( predicate ) { var lists = new ArrayList ; var arrays = _ . partition ( this , predicate ) ; arrays . forEach ( function ( arr ) { var list = new ArrayList ; lists . push ( list . add ( arr ) ) ; } ) ; return lists ; } 
function ( isSorted , iterator ) { var list = new ArrayList ; return list . add ( _ . uniq ( this , isSorted , iterator ) ) ; } 
function ( iterator , context ) { var list = new ArrayList ; return list . add ( _ . map ( this , iterator , context ) ) ; } 
function ( predicate , context ) { var list = new ArrayList ; return list . add ( _ . filter ( this , predicate , context ) ) ; } 
function ( iterator , context ) { var list = new ArrayList ; return list . add ( _ . sortBy ( this , iterator , context ) ) ; } 
function thisToArgs ( that , args ) { args = Array . prototype . slice . call ( args , 0 ) ; args . unshift ( that ) ; return args ; } 
function KoaNunjucks ( oCtx , sPath , oOpts ) { 
function parse ( report ) { var rows = [ '' , 'Binary Images:' ] ; var sys = report [ 'system' ] || { } ; var exe_path = sys [ 'CFBundleExecutablePath' ] ; var images = report [ 'binary_images' ] || [ ] ; _ . each ( images , function ( image ) { 
function get_cpu_arch ( major , minor ) { if ( major === CPU_TYPE_ARM64 ) { return 'arm64' ; } if ( major === CPU_TYPE_X86 ) { return 'i386' ; } if ( major === CPU_TYPE_X86_64 ) { return 'x86_64' ; } if ( major === CPU_TYPE_ARM ) { return CPU_ARM_TYPES [ minor ] || 'arm' ; } return ` ${ major } ${ minor } ` } 
function get_registers ( cpu ) { cpu = cpu . toLowerCase ( ) ; if ( cpu . startsWith ( 'arm' ) ) { return REGISTERS . ARM ; } if ( ~ [ 'x86' , 'i386' , 'i486' , 'i686' ] . indexOf ( cpu ) ) { return REGISTERS . X86 ; } if ( cpu === 'x86_64' ) { return REGISTERS . X86_64 ; } return [ ] ; } 
function parse ( report ) { var sys = report [ 'system' ] || { } ; var info = report [ 'report' ] || { } ; function _i ( x ) { return info [ x ] || '' ; } function _s ( x ) { return sys [ x ] || '' ; } var error = report [ 'crash' ] [ 'error' ] ; var thread = Utils . get_crash_thread ( report ) ; return [ Utils . header ( 'Incident Identifier:' , _i ( 'id' ) , 4 ) , Utils . header ( 'CrashReporter Key:' , _s ( 'device_app_hash' ) , 4 ) , Utils . header ( 'Hardware Model:' , _s ( 'machine' ) , 4 ) , Utils . header ( 'Process:' , ` ${ _s ( 'process_name' ) } ${ _s ( 'process_id' ) } ` ) , Utils . header ( 'Path:' , _s ( 'CFBundleExecutablePath' ) ) , Utils . header ( 'Identifier:' , _s ( 'CFBundleIdentifier' ) ) , Utils . header ( 'Version:' , ` ${ _s ( 'CFBundleShortVersionString' ) } ${ _s ( 'CFBundleVersion' ) } ` ) , Utils . header ( 'Code Type:' , get_cpu_arch ( report ) ) , Utils . header ( 'Parent Process:' , ` ${ _s ( 'parent_process_name' ) } ${ _s ( 'parent_process_id' ) } ` ) , Utils . header ( '' , '' ) , Utils . header ( 'Date/Time:' , get_time ( report ) ) , Utils . header ( 'OS Version:' , ` ${ _s ( 'system_name' ) } ${ _s ( 'system_version' ) } ${ _s ( 'os_version' ) } ` ) , Utils . header ( 'Report Version:' , 104 ) , Utils . header ( '' , '' ) ] . concat ( Errors . parse_errors ( error , thread ) ) ; } 
function parse ( report , crash , threads ) { crash = crash || report [ 'crash' ] || { } ; threads = threads || crash [ 'threads' ] || [ ] ; var rows = [ ] ; var idx = 0 ; _ . each ( threads , function ( thread ) { if ( idx ++ !== 0 ) { rows . push ( '' ) ; } var index = thread [ 'index' ] ; var name = thread [ 'name' ] ; var queue = thread [ 'dispatch_queue' ] ; if ( name ) { rows . push ( ` ${ index } ${ name } ` ) ; } else if ( queue ) { rows . push ( ` ${ index } ${ queue } ` ) ; } if ( thread [ 'crashed' ] ) { rows . push ( ` ${ index } ` ) ; } else { rows . push ( ` ${ index } ` ) ; } var backtrace = thread [ 'backtrace' ] ; var trace_log = Backtrace . parse_backtrace ( backtrace ) ; rows = rows . concat ( trace_log ) ; } ) ; return rows ; } 
function convert ( report ) { return [ ] . concat ( Parsers . parse ( 'headers' , report ) , Parsers . parse ( 'reason' , report ) , Parsers . parse ( 'threads' , report ) , Parsers . parse ( 'cpu' , report ) , Parsers . parse ( 'images' , report ) , Parsers . parse ( 'extras' , report ) ) . join ( '\n' ) } 
function get_crash_thread ( report ) { var crash = report [ 'crash' ] || { } ; var threads = crash [ 'threads' ] || [ ] ; var thread = threads . find ( function ( thread ) { return ! ! thread [ 'crashed' ] ; } ) ; return thread || crash [ 'crashed_thread' ] ; } 
function pad ( input , char , count , direction ) { var ipt = '' + ( input ) ; var rem = count - ipt . length ; if ( rem < 1 ) { return ipt ; } var padding = char . repeat ( count - ipt . length ) ; return direction === 'left' ? padding + ipt : ipt + padding ; } 
function parse ( report , thread ) { var rows = [ '' ] ; var crashed = thread || Utils . get_crash_thread ( report ) ; if ( ! crashed ) { return rows ; } var index = crashed [ 'index' ] ; var sys = report [ 'system' ] || { } ; var type = sys [ 'binary_cpu_type' ] ; var sub = sys [ 'binary_cpu_subtype' ] ; var arch ; if ( ! type && ! sub ) { arch = sys [ 'cpu_arch' ] ; } else { arch = CPU . get_cpu_arch ( type , sub ) ; } var cpu = CPU . get_cpu_type ( arch ) ; rows . push ( ` ${ index } ${ cpu } ` ) ; var registers = ( crashed [ 'registers' ] || { } ) [ 'basic' ] || { } ; var reg_order = CPU . get_registers ( cpu ) ; var line = '' ; for ( var i = 0 , j = reg_order . length ; i < j ; i ++ ) { if ( i % 4 === 0 && i !== 0 ) { rows . push ( line ) ; line = '' ; } var register = reg_order [ i ] ; var register_addr = registers [ register ] || 0 ; var register_name = Utils . pad_left ( register , ' ' , 6 ) ; var register_loc = Utils . pad_hex ( register_addr , '0' , 8 ) ; var register_pad = Utils . pad_right ( register_loc , ' ' , 9 ) ; line += ` ${ register_name } ${ register_pad } ` ; } if ( line ) { rows . push ( line ) ; } return rows ; } 
function parse ( report ) { var system = report [ 'system' ] || { } ; var crash = report [ 'crash' ] || { } ; return [ '' , 'Extra Information:' ] . concat ( parse_nsexception ( crash ) , parse_crash_thread ( report ) , parse_last_exception ( report ) , parse_diagnosis ( crash ) , parse_recrash ( report ) ) ; } 
function parse_errors ( error , thread ) { var signal = error [ 'signal' ] ; var mach = error [ 'mach' ] ; var exc_name = mach [ 'exception_name' ] || '0' ; var code_name = mach [ 'code_name' ] || '0x00000000' ; var sig_name = signal [ 'name' ] || signal [ 'signal' ] || '0' ; var addr_name = Utils . pad_hex ( error [ 'address' ] || 0 , '0' , 8 ) ; var index = 0 ; if ( thread ) { index = thread [ 'index' ] ; } return [ Utils . header ( 'Exception Type:' , ` ${ exc_name } ${ sig_name } ` ) , Utils . header ( 'Exception Codes:' , ` ${ code_name } ${ addr_name } ` ) , Utils . header ( 'Crashed Thread:' , index ) ] ; } 
function subscribeToTitle ( getTitle , setTitle ) { var titleElement = document . querySelector ( 'title' ) ; var docEl = document . documentElement ; function titleModified ( ) { var title = document . title ; var oldTitle = getTitle ( ) ; if ( oldTitle !== title ) { setTitle ( title ) ; } } function subscribeAsObserver ( ) { var observer = new MutationObserver ( function ( ) { titleModified ( ) ; } ) ; observer . observe ( titleElement , { childList : true } ) ; return function ( ) { return observer . disconnect ( ) ; } ; } function subscribeIE ( ) { 
function ( definedLogLevels ) { logLevels = this . _merge ( definedLogLevels ) ; 
function ( className ) { 
function parse ( report ) { var rows = [ '' ] ; var crash = report [ 'crash' ] || { } ; var error = crash [ 'error' ] ; var type = error [ 'type' ] ; var reason = error [ 'reason' ] ; var user_exception = error [ 'user_reported' ] ; var ns_exception = error [ 'nsexception' ] ; if ( ns_exception ) { rows . push ( format ( ns_exception ) ) ; rows . push ( '' ) ; return rows ; } if ( zombie_exception ( report ) ) { var last_exception = Utils . get_last_exception ( report ) ; if ( last_exception ) { rows . push ( format ( last_exception , reason ) ) ; rows . push ( 'NOTE: This exception has been deallocated! ' + 'Stack trace is crash from attempting to access this zombie exception.' ) ; rows . push ( '' ) ; } return rows ; } if ( user_exception ) { rows . push ( format ( user_exception , reason ) ) ; var line = user_exception [ 'line_of_code' ] ; var back = user_exception [ 'backtrace' ] || [ ] ; if ( line || back ) { rows . push ( 'Custom Backtrace:' ) ; } if ( line ) { rows . push ( ` ${ line } ` ) ; } return rows . concat ( back ) ; } if ( type == 'cpp_exception' ) { return rows . concat ( format ( error [ 'cppexception' ] , reason ) ) ; } if ( type == 'deadlock' ) { rows . push ( 'Application main thread deadlocked' ) ; rows . push ( '' ) ; } return rows ; } 
function parse_backtrace ( backtrace ) { if ( ! backtrace ) { return [ ] ; } var num = 0 ; var rows = [ ] ; var contents = backtrace [ 'contents' ] || [ ] ; _ . each ( contents , function ( trace ) { 
function order_stack ( stack ) { 
function ( name , src , onload , requester , errorback ) { 
function rgbToHex ( rgb ) { function componentToHex ( c ) { var hex = c . toString ( 16 ) . toUpperCase ( ) ; return hex . length === 1 ? "0" + hex : hex ; } var color = rgb . map ( function ( component ) { return componentToHex ( parseInt ( component * 255 ) ) ; } ) ; color . unshift ( "0X" ) ; color = color . join ( "" ) ; return parseInt ( color ) ; } 
function SlackBot ( slack_params , ws_params ) { this . cached = typeof slack_params . cached !== 'undefined' ? slack_params . cached : true this . token = slack_params . token || null this . name = slack_params . name || null this . reconnect_url = null ws_params = ws_params || { } this . ws_protocols = ws_params . protocols || null this . ws_options = ws_params . options || null } 
function wrapStandardArrayMutators ( array , subscribable , signal ) { var fnNames = [ 'pop' , 'push' , 'reverse' , 'shift' , 'sort' , 'splice' , 'unshift' ] ; fnNames . forEach ( function ( fnName ) { var origMutator = array [ fnName ] ; array [ fnName ] = function ( ) { var result = origMutator . apply ( this , arguments ) ; if ( signal . pause !== true ) { subscribable . notifySubscribers ( this ) ; } return result ; } ; } ) ; } 
function addKnockoutArrayMutators ( ko , array , subscribable , signal ) { var fnNames = [ 'remove' , 'removeAll' , 'destroy' , 'destroyAll' , 'replace' ] ; fnNames . forEach ( function ( fnName ) { 
function getSubscribableForArray ( ko , array ) { var subscribable = array . _subscribable ; var signal = { } ; if ( ! subscribable ) { subscribable = array . _subscribable = new ko . subscribable ( ) ; wrapStandardArrayMutators ( array , subscribable , signal ) ; addKnockoutArrayMutators ( ko , array , subscribable , signal ) ; } return subscribable ; } 
function startWatchingarray ( ko , observable , array ) { var subscribable = getSubscribableForArray ( ko , array ) ; return subscribable . subscribe ( observable ) ; } 
function notifyWhenPresentOrFutureArrayValuesMutate ( ko , observable ) { var watchingArraySubscription = null ; ko . computed ( function ( ) { 
function getRunner ( grunt ) { var path = require ( 'path' ) ; var tsd = require ( 'tsd' ) ; function getAPI ( options ) { grunt . log . writeln ( '-> config: ' + options . config ) ; var api = tsd . getAPI ( options . config , grunt . option ( 'verbose' ) ) ; if ( options . cacheDir ) { grunt . log . writeln ( 'cacheDir: ' + options . cacheDir ) ; api . context . paths . cacheDir = path . resolve ( options . cacheDir ) ; } return api ; } function reinstall ( options ) { var api = getAPI ( options ) ; return api . readConfig ( options . config , true ) . then ( function ( ) { var opts = tsd . Options . fromJSON ( options . opts ) ; opts . overwriteFiles = true ; opts . resolveDependencies = true ; opts . saveToConfig = true ; if ( options . latest ) { var query = new tsd . Query ( ) ; api . context . config . getInstalled ( ) . forEach ( function ( inst ) { var def = tsd . Def . getFrom ( inst . path ) ; query . addNamePattern ( def . project + '/' + def . name ) ; } ) ; query . versionMatcher = new tsd . VersionMatcher ( 'latest' ) ; return api . select ( query , opts ) . then ( function ( selection ) { return api . install ( selection , opts ) ; } ) ; } return api . reinstall ( opts ) ; } ) ; } return { getAPI : getAPI , commands : { reinstall : reinstall } } ; } 
async function CompositeBelow ( ctx , target , majorName , sideName , config ) { config = config || { } ; const major = this . items [ majorName ] ; const side = this . items [ sideName ] ; if ( ! major ) { this . remove ( sideName ) ; this . remove ( majorName ) ; this . introduce ( target , side ) ; return ; } // Add new cmaps for ( const unicode in side . cmap ) { if ( major . cmap [ unicode ] ) continue ; major . cmap [ unicode ] = side . cmap [ unicode ] ; } // Add new cmap UVS assignments if ( side . cmap_uvs ) { if ( ! major . cmap_uvs ) major . cmap_uvs = { } ; for ( const key in side . cmap_uvs ) { if ( major . cmap_uvs [ key ] ) continue ; major . cmap_uvs [ key ] = side . cmap_uvs [ key ] ; } } // Add new glyphs for ( const gid in side . glyf ) { major . glyf [ gid ] = side . glyf [ gid ] ; if ( major . TSI_23 && major . TSI_23 . glyphs && side . TSI_23 && side . TSI_23 . glyphs ) { major . TSI_23 . glyphs [ gid ] = side . TSI_23 . glyphs [ gid ] ; } if ( major . TSI_01 && major . TSI_01 . glyphs && side . TSI_01 && side . TSI_01 . glyphs ) { major . TSI_01 . glyphs [ gid ] = side . TSI_01 . glyphs [ gid ] ; } } if ( config . mergeOTL ) { mergeOTLTables ( major . GSUB , side . GSUB , false ) ; mergeOTLTables ( major . GPOS , side . GPOS , false ) ; major . GDEF = mergeGDEF ( side . GDEF || { } , major . GDEF || { } ) ; } // Change name this . remove ( sideName ) ; this . remove ( majorName ) ; this . introduce ( target , major ) ; } 
function filterFeature ( table , options ) { if ( ! table ) return ; options = options || { } ; const visibleLanguages = new Set ( ) ; const visibleFeatures = new Set ( ) ; const visibleLookups = new Set ( ) ; for ( let lid in table . languages ) { const lang = table . languages [ lid ] ; if ( ! lang ) continue ; if ( options . isValidLang && ! options . isValidLang ( lid , lang ) ) continue ; visibleLanguages . add ( lid ) ; if ( lang . requiredFeature && table . features [ lang . requiredFeature ] ) { if ( ! ( options . isValidFeature && ! options . isValidFeature ( lang . requiredFeature , table . features [ lang . requiredFeature ] ) ) ) { visibleFeatures . add ( lang . requiredFeature ) ; } } if ( ! lang . features ) lang . features = [ ] ; for ( let f of lang . features ) { if ( ! table . features [ f ] ) continue ; if ( options . isValidFeature && ! options . isValidFeature ( f , table . features [ f ] ) ) continue ; visibleFeatures . add ( f ) ; } } table . languages = kvfilter ( table . languages , k => visibleLanguages . has ( k ) ) ; table . features = kvfilter ( table . features , k => visibleFeatures . has ( k ) ) ; for ( let fid in table . features ) { if ( ! table . features [ fid ] ) continue ; for ( let lutid of table . features [ fid ] ) { if ( ! table . lookups [ lutid ] ) continue ; visibleLookups . add ( lutid ) ; } } do { const nA = visibleLookups . size ; for ( let lid in table . lookups ) { const lut = table . lookups [ lid ] ; if ( ! lut || ! visibleLookups . has ( lid ) ) continue ; switch ( lut . type ) { case "gsub_chaining" : case "gpos_chaining" : for ( let rule of lut . subtables ) { for ( let application of rule . apply ) { visibleLookups . add ( application . lookup ) ; } } break ; default : break ; } } const nK = visibleLookups . size ; if ( nK >= nA ) break ; } while ( true ) ; table . lookups = kvfilter ( table . lookups , k => visibleLookups . has ( k ) ) ; } 
function getValue ( options ) { return new Promise ( ( resolve , reject ) => { let url = apiURL ; 
function deleteBackup ( config ) { return new Promise ( ( resolve , reject ) => { const backupPath = path . join ( process . cwd ( ) , ( config . backup !== undefined ) ? config . backup : ".backup" ) ; fs . remove ( backupPath , ( error ) => { ( error === null ) ? resolve ( config ) : reject ( error ) ; } ) ; } ) ; } 
function inline ( config , files ) { return new Promise ( ( resolve , reject ) => { let filesChanged = 0 ; let i = 0 ; ( function proceed ( result ) { if ( result ) { filesChanged ++ ; } if ( i === files . length ) { resolve ( "Modified " + filesChanged + " files" ) ; } else { InlineImport . transform ( files [ i ++ ] , config . options ) . then ( proceed ) . catch ( reject ) ; } } ( ) ) ; } ) ; } 
function getFiles ( config ) { return new Promise ( ( resolve , reject ) => { const src = config . src ; let files = [ ] ; let i = 0 ; ( function proceed ( error , moreFiles ) { if ( error !== null ) { reject ( error ) ; } else { files = files . concat ( moreFiles ) ; if ( i === src . length ) { if ( files . length === 0 ) { reject ( "No input files found" ) ; } else { resolve ( [ config , files ] ) ; } } else { glob ( src [ i ++ ] , proceed ) ; } } } ( null , [ ] ) ) ; } ) ; } 
function validateConfig ( config ) { return new Promise ( ( resolve , reject ) => { if ( config . src !== undefined ) { if ( ! Array . isArray ( config . src ) ) { config . src = [ config . src ] ; } resolve ( config ) ; } else { reject ( "No source path specified" ) ; } } ) ; } 
function readConfig ( ) { 
function Markdown ( config ) { RED . nodes . createNode ( this , config ) ; var self = this ; this . on ( 'input' , function ( msg ) { msg . payload = marked ( msg . payload ) ; self . send ( msg ) ; } ) ; } 
function readFile ( file , encoding ) { return new Promise ( ( resolve , reject ) => { fs . readFile ( file , encoding , ( error , data ) => error ? reject ( error ) : resolve ( data ) ) ; } ) ; } 
function parseImports ( data , file , extensions ) { const imports = [ ] ; let result = importRegExp . exec ( data ) ; let encoding ; while ( result !== null ) { encoding = extensions [ path . extname ( result [ 2 ] ) ] ; 
function readImports ( imports , data ) { return ( imports . length === 0 ) ? Promise . resolve ( [ imports , data ] ) : new Promise ( ( resolve , reject ) => { let i = 0 ; ( function proceed ( error , importData ) { if ( importData ) { imports [ i ++ ] . data = importData ; } if ( error ) { reject ( error ) ; } else if ( i === imports . length ) { resolve ( [ imports , data ] ) ; } else { fs . readFile ( imports [ i ] . path , imports [ i ] . encoding , proceed ) ; } } ( ) ) ; } ) ; } 
function inlineImports ( imports , data , declaration ) { let modified = imports . length > 0 ; let i , item ; 
function writeFile ( modified , data , file ) { return ! modified ? Promise . resolve ( false ) : new Promise ( ( resolve , reject ) => { fs . writeFile ( file , data , ( error ) => { error ? reject ( error ) : resolve ( true ) ; } ) ; } ) ; } 
function ( N , data , CART_OR_SPH , DIRECT_OR_PINV ) { var Ndirs = data . length , Nsh = ( N + 1 ) * ( N + 1 ) ; var invY_N ; var mag = [ , ] ; if ( Nsh > Ndirs ) { console . log ( "The SHT degree is too high for the number of data points" ) } 
function ( coeffs , aziElev ) { var aziElevR = aziElev ; var N = Math . sqrt ( coeffs . length ) - 1 ; 
function ( array2D ) { for ( var q = 0 ; q < array2D . length ; q ++ ) console . log ( array2D [ q ] ) ; } 
function ( xyz , OMIT_MAG ) { var azi , elev , r ; var aziElevR = new Array ( xyz . length ) ; for ( var i = 0 ; i < xyz . length ; i ++ ) { azi = Math . atan2 ( xyz [ i ] [ 1 ] , xyz [ i ] [ 0 ] ) ; elev = Math . atan2 ( xyz [ i ] [ 2 ] , Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] ) ) ; if ( OMIT_MAG == 1 ) { aziElevR [ i ] = [ azi , elev ] ; } else { r = Math . sqrt ( xyz [ i ] [ 0 ] * xyz [ i ] [ 0 ] + xyz [ i ] [ 1 ] * xyz [ i ] [ 1 ] + xyz [ i ] [ 2 ] * xyz [ i ] [ 2 ] ) ; aziElevR [ i ] = [ azi , elev , r ] ; } } return aziElevR ; } 
function ( aziElevR ) { var x , y , z ; var xyz = new Array ( aziElevR . length ) ; for ( var i = 0 ; i < aziElevR . length ; i ++ ) { x = Math . cos ( aziElevR [ i ] [ 0 ] ) * Math . cos ( aziElevR [ i ] [ 1 ] ) ; y = Math . sin ( aziElevR [ i ] [ 0 ] ) * Math . cos ( aziElevR [ i ] [ 1 ] ) ; z = Math . sin ( aziElevR [ i ] [ 1 ] ) ; if ( aziElevR [ 0 ] . length == 2 ) xyz [ i ] = [ x , y , z ] ; else if ( aziElevR [ 0 ] . length == 3 ) xyz [ i ] = [ aziElevR [ i ] [ 2 ] * x , aziElevR [ i ] [ 2 ] * y , aziElevR [ i ] [ 2 ] * z ] ; } return xyz ; } 
function ( N , data ) { var azi = new Array ( data . length ) ; var elev = new Array ( data . length ) ; for ( var i = 0 ; i < data . length ; i ++ ) { azi [ i ] = data [ i ] [ 0 ] ; elev [ i ] = data [ i ] [ 1 ] ; } var factorials = new Array ( 2 * N + 1 ) ; var Ndirs = azi . length ; var Nsh = ( N + 1 ) * ( N + 1 ) ; var leg_n_minus1 = 0 ; var leg_n_minus2 = 0 ; var leg_n ; var sinel = numeric . sin ( elev ) ; var index_n = 0 ; var Y_N = new Array ( Nsh ) ; var Nn0 , Nnm ; var cosmazi , sinmazi ; 
function ( n , x , Pnm_minus1 , Pnm_minus2 ) { var Pnm = new Array ( n + 1 ) ; switch ( n ) { case 1 : var x2 = numeric . mul ( x , x ) ; var P10 = x ; var P11 = numeric . sqrt ( numeric . sub ( 1 , x2 ) ) ; Pnm [ 0 ] = P10 ; Pnm [ 1 ] = P11 ; break ; case 2 : var x2 = numeric . mul ( x , x ) ; var P20 = numeric . mul ( 3 , x2 ) ; P20 = numeric . sub ( P20 , 1 ) ; P20 = numeric . div ( P20 , 2 ) ; var P21 = numeric . sub ( 1 , x2 ) ; P21 = numeric . sqrt ( P21 ) ; P21 = numeric . mul ( 3 , P21 ) ; P21 = numeric . mul ( P21 , x ) ; var P22 = numeric . sub ( 1 , x2 ) ; P22 = numeric . mul ( 3 , P22 ) ; Pnm [ 0 ] = P20 ; Pnm [ 1 ] = P21 ; Pnm [ 2 ] = P22 ; break ; default : var x2 = numeric . mul ( x , x ) ; var one_min_x2 = numeric . sub ( 1 , x2 ) ; 
function ( A ) { var z = numeric . svd ( A ) , foo = z . S [ 0 ] ; var U = z . U , S = z . S , V = z . V ; var m = A . length , n = A [ 0 ] . length , tol = Math . max ( m , n ) * numeric . epsilon * foo , M = S . length ; var Sinv = new Array ( M ) ; for ( var i = M - 1 ; i !== - 1 ; i -- ) { if ( S [ i ] > tol ) Sinv [ i ] = 1 / S [ i ] ; else Sinv [ i ] = 0 ; } return numeric . dot ( numeric . dot ( V , numeric . diag ( Sinv ) ) , numeric . transpose ( U ) ) } 
function ( A ) { var AT = numeric . transpose ( A ) ; return numeric . dot ( numeric . inv ( numeric . dot ( AT , A ) ) , AT ) ; } 
function ( Rxyz , L ) { var Nsh = ( L + 1 ) * ( L + 1 ) ; 
function U ( l , m , n , R_1 , R_lm1 ) { return P ( 0 , l , m , n , R_1 , R_lm1 ) ; } 
function P ( i , l , a , b , R_1 , R_lm1 ) { var ri1 , rim1 , ri0 , ret ; ri1 = R_1 [ i + 1 ] [ 1 + 1 ] ; rim1 = R_1 [ i + 1 ] [ - 1 + 1 ] ; ri0 = R_1 [ i + 1 ] [ 0 + 1 ] ; if ( b == - l ) { ret = ri1 * R_lm1 [ a + l - 1 ] [ 0 ] + rim1 * R_lm1 [ a + l - 1 ] [ 2 * l - 2 ] ; } else { if ( b == l ) ret = ri1 * R_lm1 [ a + l - 1 ] [ 2 * l - 2 ] - rim1 * R_lm1 [ a + l - 1 ] [ 0 ] ; else ret = ri0 * R_lm1 [ a + l - 1 ] [ b + l - 1 ] ; } return ret ; } 
function ( yaw , pitch , roll ) { var Rx , Ry , Rz ; if ( roll == 0 ) Rx = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rx = [ [ 1 , 0 , 0 ] , [ 0 , Math . cos ( roll ) , Math . sin ( roll ) ] , [ 0 , - Math . sin ( roll ) , Math . cos ( roll ) ] ] ; if ( pitch == 0 ) Ry = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Ry = [ [ Math . cos ( pitch ) , 0 , - Math . sin ( pitch ) ] , [ 0 , 1 , 0 ] , [ Math . sin ( pitch ) , 0 , Math . cos ( pitch ) ] ] ; if ( yaw == 0 ) Rz = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; else Rz = [ [ Math . cos ( yaw ) , Math . sin ( yaw ) , 0 ] , [ - Math . sin ( yaw ) , Math . cos ( yaw ) , 0 ] , [ 0 , 0 , 1 ] ] ; var R = numeric . dotMMsmall ( Ry , Rz ) ; R = numeric . dotMMsmall ( Rx , R ) ; return R ; } 
function heapify ( compare , x ) { var n = x . length ; for ( var k = n / 2 | 0 ; k ; ) { ( 0 , _core . siftdown ) ( compare , x , 0 , n , -- k ) ; } return new _core . Heap ( compare , x ) ; } 
function siftdown ( compare , a , i , j , k ) { var current = k - i ; while ( true ) { 
function nextchild ( compare , a , i , j ) { if ( j - i < 2 ) return i ; if ( compare ( a [ i ] , a [ i + 1 ] ) <= 0 ) return i ; return i + 1 ; } 
function siftup ( compare , a , i , j , k ) { var current = k - i ; 
function exec ( command , options ) { return new PromiseWithEvents_1 . PromiseWithEvents ( function ( resolve , reject , eventEmitter ) { var childProcess = cp . exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { reject ( err ) ; } else { resolve ( { stdout : stdout . toString ( ) , stderr : stderr . toString ( ) } ) ; } } ) ; process . nextTick ( function ( ) { return eventEmitter . emit ( 'process' , childProcess ) ; } ) ; } ) ; } 
function ( password ) { if ( ! password ) return '' ; var encrypred ; try { encrypred = crypto . createHmac ( 'sha1' , this . salt ) . update ( password ) . digest ( 'hex' ) ; return encrypred ; } catch ( err ) { return '' ; } } 
function standardizeOldGradientArgs ( type , args ) { var stdArgStr = '' ; var stops = [ ] ; if ( / ^linear / . test ( type ) ) { 
function view ( query ) { var queryDefinition ; if ( query instanceof Function ) { queryDefinition = query ( ) ; } else { queryDefinition = query ; } var view = new Entity_1 . QView ( [ ] , queryDefinition ) ; var customEntity = queryDefinition . select ; view = convertMappedEntitySelect ( customEntity , queryDefinition , view , view , 'f' ) ; return view ; } 
function field ( query ) { var queryDefinition ; if ( query instanceof Function ) { queryDefinition = query ( ) ; } else { queryDefinition = query ; } var customField = queryDefinition . select ; customField = customField . addSubQuery ( queryDefinition ) ; 
function Id ( ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( entityMetadata . idProperty ) { throw "Cannot set primary key to '" + propertyKey + "', it is already set to '" + entityMetadata . idProperty + "'" ; } entityMetadata . idProperty = propertyKey ; } ; } 
function Column ( columnConfiguration ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . columnMap ) { entityMetadata . columnMap = { } ; } entityMetadata . columnMap [ propertyKey ] = columnConfiguration ; } ; } 
function JoinColumn ( joinColumnConfiguration ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . joinColumnMap ) { entityMetadata . joinColumnMap = { } ; } entityMetadata . joinColumnMap [ propertyKey ] = joinColumnConfiguration ; } ; } 
function Transient ( ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . transient ) { entityMetadata . transient = { } ; } entityMetadata . transient [ propertyKey ] = true ; } ; } 
function ManyToOne ( elements ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . manyToOneMap ) { entityMetadata . manyToOneMap = { } ; } entityMetadata . manyToOneMap [ propertyKey ] = elements ; } ; } 
function OneToMany ( elements ) { return function ( targetObject , propertyKey ) { var entityMetadata = targetObject ; if ( ! entityMetadata . oneToManyMap ) { entityMetadata . oneToManyMap = { } ; } entityMetadata . oneToManyMap [ propertyKey ] = elements ; } ; } 
function Entity ( entityConfiguration ) { return function ( constructor ) { var entityMetadata = constructor ; if ( entityMetadata . entity ) { throw "Cannot set @Table, it is already set to '" + JSON . stringify ( entityMetadata . entity ) + "'" ; } 
function Table ( tableConfiguration ) { return function ( constructor ) { var entityMetadata = constructor ; if ( entityMetadata . table ) { throw "Cannot set @Table, it is already set to '" + JSON . stringify ( entityMetadata . table ) + "'" ; } entityMetadata . table = tableConfiguration ; } ; } 
function CliGhCal ( data , options ) { var CLI_COLUMNS = cliSize ( ) . columns ; var cal = { total : 0 , days : { } , cStreak : 0 , lStreak : 0 , max : 0 , longestStreak : { } , currentStreak : { } } if ( options . noCrop === undefined ) { options . noCrop = ! ! options . raw || ! process . stdout . isTTY ; } 
function parse ( md , prevLinks ) { var tokenizer = / ((?:^|\n+)(?:\n---+|\* \*(?: \*)+)\n)|(?:^```(\w*)\n([\s\S]*?)\n```$)|((?:(?:^|\n+)(?:\t| {2,}).+)+\n*)|((?:(?:^|\n)([>*+-]|\d+\.)\s+.*)+)|(?:\!\[([^\]]*?)\]\(([^\)]+?)\))|(\[)|(\](?:\(([^\)]+?)\))?)|(?:(?:^|\n+)([^\s].*)\n(\-{3,}|={3,})(?:\n+|$))|(?:(?:^|\n+)(#{1,3})\s*(.+)(?:\n+|$))|(?:`([^`].*?)`)|( \n\n*|\n{2,}|__|\*\*|[_*]) / gm , context = [ ] , out = '' , links = prevLinks || { } , last = 0 , chunk , prev , token , inner , t ; function tag ( token ) { var desc = TAGS [ token . replace ( / \* / g , '_' ) [ 1 ] || '' ] , end = context [ context . length - 1 ] == token ; if ( ! desc ) { return token ; } if ( ! desc [ 1 ] ) { return desc [ 0 ] ; } context [ end ? 'pop' : 'push' ] ( token ) ; return desc [ end | 0 ] ; } function flush ( ) { var str = '' ; while ( context . length ) { str += tag ( context [ context . length - 1 ] ) ; } return str ; } md = md . replace ( / ^\[(.+?)\]:\s*(.+)$ / gm , function ( s , name , url ) { links [ name . toLowerCase ( ) ] = url ; return '' ; } ) . replace ( / ^\n+|\n+$ / g , '' ) ; while ( token = tokenizer . exec ( md ) ) { prev = md . substring ( last , token . index ) ; last = tokenizer . lastIndex ; chunk = token [ 0 ] ; if ( prev . match ( / [^\\](\\\\)*\\$ / ) ) { } 
function flattenize ( routes , prefix , parent ) { const list = { } Object . keys ( routes . local ) . forEach ( ( method ) => { const localName = prefix === '' ? '/' : ` ${ prefix } ` if ( ! list [ localName ] ) { list [ localName ] = { } } list [ localName ] [ method ] = [ ] . concat ( parent . before , routes . before , routes . local [ method ] , routes . after , parent . after ) } ) Object . keys ( routes . scoped ) . forEach ( ( scope ) => { const scoped = routes . scoped [ scope ] const listeners = flattenize ( scoped , ` ${ prefix } ${ scope } ` , { before : parent . before . concat ( routes . before ) , after : routes . after . concat ( parent . after ) , } ) Object . assign ( list , listeners ) } ) return list } 
function repaintBody ( _elTargetKey , _colGroup , _bodyRow , _groupRow , _list , _scrollConfig ) { var _elTarget = this . $ . panel [ _elTargetKey ] ; if ( ! isFirstPaint && ! _scrollConfig ) { this . $ . livePanelKeys . push ( _elTargetKey ) ; 
function getBody ( _colGroup , _bodyRow , _groupRow , _list ) { var SS = [ ] , di = void 0 , dl = void 0 , tri = void 0 , trl = void 0 , ci = void 0 , cl = void 0 , col = void 0 , val = void 0 ; 
function observeResize ( el , cb ) { assert . ok ( isDom ( el ) , 'observe-resize: el should be a valid DOM element' ) assert . equal ( typeof cb , 'function' , 'observe-resize: cb should be type function' ) 
function Collection ( obj ) { this . _init ( ) ; if ( ( 0 , _types . isString ) ( obj ) ) { this . data = obj . split ( '' ) ; } else if ( ( 0 , _types . isNumber ) ( obj ) ) { let i = isFinite ( obj ) ? Math . abs ( obj ) : false , done = false , value ; this . p . use = 'for of' ; this . data = { next : ( ) => { done = i === false ? done : done || ! i -- ; return { done , value } ; } , throw ( err ) { throw err ; } , return : v => { done = true ; value = v ; } } ; } else { this . data = ( 0 , _types . isObjectInstance ) ( obj ) ? ( 0 , _gcc . any ) ( obj ) : [ ] ; } } 
function getTasks ( ) { const tasks = { } , tmp = { } , mods = { } , exec = Object . assign ( { } , execStack ) ; let total = 0 , count = 0 ; ( 0 , _core2 . default ) ( exec ) . forEach ( ( el , key ) => { tmp [ key ] = ( 0 , _core2 . default ) ( el ) . map ( ( el , key ) => key ) ; mods [ key ] = 0 ; count ++ ; } , el => el . length ) ; const sort = ( a , b ) => b . value - a . value ; while ( total <= _thread . MAX_PRIORITY ) { const rands = [ ] ; ( 0 , _core2 . default ) ( exec ) . forEach ( ( el , key ) => { rands . push ( { key , value : _thread . PRIORITY [ key ] } ) ; } , el => el . length ) ; rands . sort ( sort ) ; let pos = rands . length - 1 , max = 0 ; ( 0 , _core2 . default ) ( rands ) . forEach ( ( el , i ) => { const interval = intervals [ pos ] ; if ( interval [ 1 ] > max ) { max = interval [ 1 ] ; } rands [ i ] . value = interval ; pos -- ; } ) ; const rand = ( 0 , _math . getRandomInt ) ( 0 , max ) ; ( 0 , _core2 . default ) ( rands ) . forEach ( ( { key , value } ) => { const arr = tmp [ key ] ; if ( rand >= value [ 0 ] && rand <= value [ 1 ] ) { tasks [ key ] = tasks [ key ] || [ ] ; let pos = lastPos [ key ] ; if ( arr [ pos ] == null ) { lastPos [ key ] = pos = 0 ; mods [ key ] = 0 ; } const point = exec [ key ] [ arr [ pos ] ] ; if ( point && ! point . pause ) { mods [ key ] ++ ; tasks [ key ] . push ( arr [ pos ] ) ; total += _thread . PRIORITY [ key ] ; } arr . splice ( pos , 1 ) ; if ( ! arr . length ) { delete exec [ key ] ; count -- ; } return false ; } } ) ; if ( ! count ) { break ; } } ( 0 , _core2 . default ) ( mods ) . forEach ( ( el , key ) => { lastPos [ key ] += el ; } ) ; return tasks ; } 
function checkTile ( tile ) { 
function returnCache ( cache ) { let text = '' ; for ( const key in cache ) { if ( ! cache . hasOwnProperty ( key ) ) { continue ; } text += cache [ key ] ; } return text ; } 
function compileCycle ( key , p ) { const isMapSet = _types . mapSet [ p . type ] ; const cantModI = ! ( p . type === 'array' || p . reverse || p . type === 'object' && p . notOwn && _hacks . OBJECT_KEYS_NATIVE_SUPPORT ) ; const cbArgs = cbArgsList . slice ( 0 , p . length ? p . cbArgs : cbArgsList . length ) , filterArgs = [ ] ; const maxArgsLength = p . length ? Math . max . apply ( null , [ ] . concat ( p . cbArgs , p . filterArgs ) ) : cbArgsList . length , needParallel = p . parallel || p . race , parallelFn = p . parallel ? 'wait' : 'race' , needCtx = maxArgsLength > 3 || needParallel || p . thread , fLength = p . filter . length ; for ( let i = 0 ; i < fLength ; i ++ ) { filterArgs . push ( filterArgsList . slice ( 0 , p . length ? p . filterArgs [ i ] : filterArgsList . length ) ) ; } const resolveFilterVal = ` ${ p . inverseFilter ? '!' : '' } ` , callCycleFilter = ` ${ filterArgsList . slice ( 0 , p . length ? maxArgsLength : filterArgsList . length ) } ` ; let iFn = _string . ws ` ` ; if ( p . withDescriptor ) { if ( p . withProto ) { iFn += _string . ws ` ` ; } else { iFn += 'var getDescriptor = Object.getOwnPropertyDescriptor;' ; } } 
function __encode ( raw , key ) { var len = _ . size ( key ) ; var cc = len ; 
function __decode ( raw , key ) { var res = [ ] ; 
function process ( rawXLSX , options ) { 
function validateOptions ( options ) { 
function isLikeArray ( obj ) { const res = isArray ( obj ) || obj && 
function isIterator ( obj ) { return Boolean ( obj && ( typeof Symbol === 'function' ? obj [ Symbol . iterator ] : isFunction ( obj [ '@@iterator' ] ) ) ) ; } 
function isStream ( obj ) { return Boolean ( obj && isFunction ( obj . addListener ) && isFunction ( obj . removeListener ) && isFunction ( obj . destroy ) && ( isFunction ( obj . write ) && isFunction ( obj . end ) || isFunction ( obj . pipe ) && isFunction ( obj . read ) && isFunction ( obj . pause ) && isFunction ( obj . resume ) ) ) ; } 
function getType ( obj , opt_use ) { if ( ! obj ) { return null ; } switch ( opt_use ) { case 'for' : return 'array' ; case 'for in' : return 'object' ; case 'for of' : return 'iterator' ; case 'async for of' : return 'asyncIterator' ; default : if ( obj === Empty ) { return null ; } if ( isMap ( obj ) ) { return 'map' ; } if ( isWeakMap ( obj ) ) { return 'weakMap' ; } if ( isSet ( obj ) ) { return 'set' ; } if ( isWeakSet ( obj ) ) { return 'weakSet' ; } if ( isGenerator ( obj ) ) { return 'generator' ; } if ( isLikeArray ( obj ) ) { return 'array' ; } if ( isIterator ( obj ) ) { return 'iterator' ; } if ( isIDBRequest ( obj ) ) { return 'idbRequest' ; } if ( isStream ( obj ) ) { return 'stream' ; } } return 'object' ; } 
function getSameAs ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) ) { return [ ] ; } if ( isPlainObject ( obj ) ) { return { } ; } if ( isMap ( obj ) ) { return new Map ( ) ; } if ( isSet ( obj ) ) { return new Set ( ) ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ? { } : false ; } 
function isStructure ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) || isPlainObject ( obj ) || isMap ( obj ) || isSet ( obj ) ) { return true ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ; } 
function canExtendProto ( obj ) { if ( ! obj ) { return false ; } if ( isArray ( obj ) || isPlainObject ( obj ) ) { return true ; } return isFunction ( obj . constructor ) && ! isNative . test ( obj . constructor . toString ( ) ) ; } 
function ws ( strings , expr ) { expr = [ ] ; for ( let i = 1 ; i < arguments . length ; i ++ ) { expr . push ( arguments [ i ] ) ; } let res = '' ; for ( let i = 0 ; i < strings . length ; i ++ ) { res += strings [ i ] . replace ( wsRgxp , ' ' ) + ( i in expr ? expr [ i ] : '' ) ; } return res ; } 
function autokey ( password , lodash ) { if ( ! lodash ) { return require ( minNormal ) ( password ) ; } return require ( minLodash ) ( password ) ; } 
function byLink ( obj , link , opt_params ) { const p = opt_params || { } ; const linkList = ( 0 , _types . isString ) ( link ) ? ( 0 , _gcc . any ) ( link ) . split ( '.' ) : [ ] . concat ( link ) , length = linkList . length , last = length - 1 ; let pre , preKey ; for ( let i = - 1 ; ++ i < length ; ) { const el = linkList [ i ] ; if ( obj == null ) { if ( p . test ) { return false ; } if ( p . error ) { throw new ReferenceError ( ` ${ el } ` ) ; } if ( p . delete ) { return { notFound : true , result : false , key : undefined , value : undefined } ; } return undefined ; } const isTest = i === last && p . test ; if ( isTest ) { pre = obj ; preKey = el ; } const objIsMap = ( 0 , _types . isMap ) ( obj ) , objIsSet = ( 0 , _types . isSet ) ( obj ) ; const isAMap = objIsMap || ( 0 , _types . isWeakMap ) ( obj ) , isASet = objIsSet || ( 0 , _types . isWeakSet ) ( obj ) ; 
function wrap ( obj ) { if ( _ . isArray ( obj ) ) { return obj . map ( wrap ) ; } return wrapRoute ( obj ) ; } 
function ajax ( ctx ) { 
function routePromise ( req , res ) { return new Promise ( ( resolve ) => { res . send ( { ok : true } ) ; resolve ( ) ; } ) ; } 
async function asyncRoute ( req , res ) { await fakeWait ( ) ; res . send ( { ok : true } ) ; } 
async function ( query , options ) { try { let response = await fetch ( ` ${ query } ` , options ) ; let json = await response . json ( ) ; return json ; } catch ( err ) { return err ; } } 
function wrapRoute ( fn ) { if ( ! _lodash2 . default . isFunction ( fn ) ) { throw new Error ( 'fn should be a function' ) ; } return function ( req , res , next ) { try { var result = fn ( req , res , next ) ; if ( result && result . catch ) { result . catch ( next ) ; } } catch ( e ) { next ( e ) ; } } ; } 
function wrap ( obj ) { if ( _lodash2 . default . isArray ( obj ) ) { return obj . map ( wrap ) ; } return wrapRoute ( obj ) ; } 
function buildSrc ( config ) { return new Promise ( ( resolve , reject ) => { webpack ( config , function ( err , stats ) { if ( err ) { reject ( err ) ; return ; } process . stdout . write ( stats . toString ( { colors : true , modules : false , children : false , chunks : false , chunkModules : false } ) + '\n\n' ) resolve ( ) ; } ) ; } ) ; } 
function _matchElement ( parentNodes , name , notAllChildren ) { var elems ; var tag = 0 ; 
function _getElement ( name , parentNode ) { if ( name === '' ) name = null ; var _elem ; var _isarr = false ; if ( typeof name === 'string' ) { if ( name [ 0 ] == '<' ) { _elem = window . document . createElement ( 'div' ) ; _elem . innerHTML = name ; if ( _elem . childNodes . length == 1 ) { _elem = _elem . childNodes [ 0 ] ; _isarr = false ; } else { _elem = _elem . childNodes ; _isarr = true ; } } else { if ( name . indexOf ( '<' ) > 0 || name . indexOf ( '>' ) > 0 ) throw new Error ( 'Syntax error, unrecognized' ) ; var names = name . split ( ' ' ) ; var nodes = parentNode ? [ parentNode ] : null ; for ( var i = 0 ; i < names . length ; i ++ ) { if ( names [ i ] != '' ) nodes = _matchElement ( nodes , names [ i ] , ! ! parentNode ) ; } if ( nodes . length <= 1 ) { _elem = nodes [ 0 ] ; _isarr = false ; } else { _elem = nodes ; _isarr = true ; } } } else { _elem = name ; } return { _elem , _isarr } ; } 
function _hasClass ( element , cName ) { if ( ! element || ! element . className || ( typeof element . className . match !== 'function' ) ) return false ; return ! ! element . className . match ( new RegExp ( "(\\s|^)" + cName + "(\\s|$)" ) ) ; 
function _addClass ( element , cName ) { if ( ! element ) return ; if ( typeof element . className === 'string' ) { if ( ! _hasClass ( element , cName ) ) { if ( stringUtils . isEmpty ( element . className ) ) element . className += cName ; else element . className += " " + cName ; } ; } } 
function _removeClass ( element , cName ) { if ( ! element ) return ; if ( typeof element . className === 'string' ) { if ( _hasClass ( element , cName ) ) { element . className = element . className . replace ( new RegExp ( "(\\s|^)" + cName + "(\\s|$)" ) , " " ) ; 
function _removeElement ( element ) { if ( element ) { var _parentElement = element . parentNode ; if ( _parentElement ) { _parentElement . removeChild ( element ) ; } } } 
function _appendChild ( element , node ) { if ( element ) { if ( node instanceof Dom ) { if ( ! node . _isArray ( ) ) { element . appendChild ( node [ 0 ] ) ; } else { for ( var i = 0 ; i < node . length ; i ++ ) { element . appendChild ( node [ i ] ) ; } } } else { element . appendChild ( node ) ; } } } 
function ( ent , id ) { 
function ( seneca , vkey , reply ) { 
function vcache_load ( msg , reply ) { var self = this var load_prior = this . prior var qent = msg . qent 
function vcache_remove ( msg , reply ) { var self = this var remove_prior = this . prior remove_prior . call ( self , msg , function ( err , ent ) { if ( err ) { return reply ( err ) } var vkey = versionKey ( msg . qent , msg . q . id ) 
function vcache_list ( msg , reply ) { 
function ( msg , flags ) { if ( flags . exact ) { seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'save' } ) , save ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'load' } ) , load ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'list' } ) , list ) seneca . add ( _ . extend ( { } , msg , { role : 'entity' , cmd : 'remove' } ) , remove ) return } var actions = { save : save , load : load , list : list , remove : remove } var core_patterns = [ { role : 'entity' , cmd : 'save' } , { role : 'entity' , cmd : 'load' } , { role : 'entity' , cmd : 'list' } , { role : 'entity' , cmd : 'remove' } ] _ . each ( core_patterns , function ( core_pat ) { var pats = seneca . list ( core_pat ) _ . each ( pats , function ( pat ) { seneca . add ( pat , actions [ core_pat . cmd ] ) } ) } ) } 
function FBOAuth2 ( appId , appSecret , redirectURL ) { this . _appId = appId ; this . _appSecret = appSecret ; this . _redirectURL = redirectURL ; this . _authURL = 'https://www.facebook.com/dialog/oauth' ; this . _graphAPIURL = 'https://graph.facebook.com' ; this . _accessTokenURI = '/oauth/access_token' ; this . _profileURI = '/me' ; } 
function ( options ) { EventEmitter . apply ( this , arguments ) ; options = options || { } ; this . limit = options . limit || 16 ; this . json = options . json || false ; this . records = options . records || [ ] ; } 
function spy ( obj , method ) { if ( ! obj && ! method ) { obj = { spy : function ( ) { } } ; method = 'spy' ; } return double ( obj , method ) ; } 
function ( conf , bitwise , parent ) { EventEmitter . call ( this ) ; conf = conf || { } ; constants ( this ) ; this . keys = keys ; this . bitwise = ( bitwise === true ) ; this . configure ( ) ; var cstreams = parent && conf . streams ; var streams = conf . streams , stream = conf . stream ; streams = streams || this . getDefaultStream ( conf ) ; delete conf . streams ; delete conf . stream ; var target = parent ? merge ( parent . conf , { } ) : merge ( defaults , { } ) ; this . conf = merge ( conf , target ) ; if ( typeof this . conf . name !== 'string' || ! this . conf . name . length ) { throw new Error ( 'Logger name \'' + this . conf . name + '\' is invalid' ) ; } this . name = this . conf . name ; conf . streams = streams ; if ( stream ) conf . stream = stream ; this . pid = this . conf . pid || process . pid ; this . hostname = this . conf . hostname || os . hostname ( ) ; this . fields = { } ; this . streams = [ ] ; if ( parent && cstreams ) { streams = Array . isArray ( streams ) ? streams : [ streams ] ; streams = streams . concat ( conf . streams ) ; } this . initialize ( streams ) ; } 
function createLogger ( conf , bitwise ) { conf = conf || { } ; if ( conf . json === undefined ) conf . json = true ; return new Logger ( conf , bitwise ) ; } 
function detectDirType ( dir , files ) { var type , isIndexedFiles , isLengthMatched ; type = 'object' ; isIndexedFiles = false ; isLengthMatched = false ; if ( path . extname ( dir ) === '.array' ) { if ( ! files . length ) { return 'array' ; } 
function ( id , type , attributes , relationships ) { var _this = this ; JsonApiResource . call ( _this , id , type ) ; BaseAttributesCreatedUpdated . call ( _this ) ; _this [ 'type' ] = type ; _this [ 'attributes' ] = attributes ; _this [ 'relationships' ] = relationships ; } 
function getFullErrorStack ( ex ) { var ret = ex . stack ; if ( ex . cause && typeof ( ex . cause ) === 'function' ) { var cex = ex . cause ( ) ; if ( cex ) { ret += '\nCaused by: ' + getFullErrorStack ( cex ) ; } } return ret ; } 
function updateFieldsState ( value , state , fields ) { const newModel = Object . assign ( { } , state ) ; fields . forEach ( selector => { const prevState = selector . getValue ( newModel , { } ) ; selector . setValueImmutable ( newModel , Object . assign ( { } , prevState , value ) ) ; } ) ; return newModel ; } 
function mergeModels ( value , model ) { const newModel = Object . assign ( { } , model ) ; tools_1 . deepExtend ( newModel , value ) ; return { model : newModel , isChanged : deepEqual ( model , newModel ) } ; } 
function createFormFactory ( ) { return { Form : Form_1 . Form , Field : Field_1 . Field , Transform : Transform_1 . Transform , Validation : Validation_1 . Validation , Scope : Scope_1 . Scope , Subscribe : Subscribe_1 . Subscribe , FormContext : Form_1 . Consumer , FieldContext : Field_1 . Consumer , TransformContext : Transform_1 . Consumer , ValidationContext : Validation_1 . Consumer , ScopeContext : Scope_1 . Consumer , SubscribeContext : Subscribe_1 . Consumer } ; } 
function accessTokenResponse ( error , accessToken ) { if ( error && typeof accessToken !== 'undefined' ) { waterlock . logger . debug ( error ) ; res . serverError ( ) ; } else { fb . getMe ( userInfoResponse ) ; } } 
function userInfoResponse ( error , response , body ) { if ( error ) { waterlock . logger . debug ( error ) ; res . serverError ( ) ; } else { var _data = JSON . parse ( body ) ; if ( _data . error ) { waterlock . logger . debug ( _data ) ; res . serverError ( _data . error ) ; } var attr = { facebookId : _data . id , name : _data . name , username : _data . name . replace ( ' ' , '' ) , email : _data . email } ; var fieldMap = authConfig . fieldMap || { } ; _ . each ( fieldMap , function ( val , key ) { if ( ! _ . isUndefined ( _data [ val ] ) ) { attr [ key ] = _data [ val ] ; } } ) ; if ( req . session . authenticated ) { attr [ 'user' ] = req . session . user . id ; waterlock . engine . attachAuthToUser ( attr , req . session . user , userFound ) ; } else { waterlock . engine . findOrCreateAuth ( { facebookId : attr . facebookId } , attr , userFound ) ; } } } 
function ( name , obj ) { obj . _namespace = name ; observers = observers . concat ( obj . _observers ) ; obj . _emitter = caramel ; } 
function ( name , obj ) { if ( obj . _observers . length > 0 ) { observers = observers . filter ( function ( o ) { return obj . _observers . indexOf ( o ) === - 1 ; } ) ; } obj . _destroy ( ) ; } 
function ( name , obj , after ) { if ( typeof after === 'string' && ! inject ( after ) ( ) ) { caramel . once ( 'register:' + after , function ( ) { register ( name , obj ) ; } ) ; return ; } var path = name . split ( '.' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i ++ ) { if ( ! ref [ path [ i ] ] ) { ref = ref [ path [ i ] ] = { } ; } else { ref = ref [ path [ i ] ] ; } } if ( ! ref [ path [ path . length - 1 ] ] ) { ref [ path [ path . length - 1 ] ] = { cream : obj } ; } else { ref [ path [ path . length - 1 ] ] . cream = obj ; } createCream ( name , obj ) ; caramel . emit ( 'register:' + name ) ; } 
function ( name ) { var path = name . split ( '.' ) ; var ref = container ; for ( var i = 0 ; i < path . length - 1 ; i ++ ) { if ( ! ( ref = ref [ path [ i ] ] ) ) { return ; } } if ( typeof ref [ path [ path . length - 1 ] ] === 'object' ) { if ( ref [ path [ path . length - 1 ] ] . _type === 'Cream' ) { removeCream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; } else if ( ref [ path [ path . length - 1 ] ] . cream && ref [ path [ path . length - 1 ] ] . cream . _type === 'Cream' ) { removeCream ( name , ref [ path [ path . length - 1 ] ] . cream ) ; delete ref [ path [ path . length - 1 ] ] . cream ; } delete ref [ path [ path . length - 1 ] ] ; } } 
function ( name ) { var injection = function ( ) { var path = name . split ( '.' ) ; var ref = container ; for ( var i = 0 ; i < path . length ; i ++ ) { if ( ! ref [ path [ i ] ] ) { if ( ref . cream ) { ref = ref . cream ; i -- ; continue ; } return ; } else { ref = ref [ path [ i ] ] ; } } return ref . cream || ref ; } ; injection . isInjection = true ; injection . namespace = name ; 
function _reduceStream ( stream$ , reducer , cb ) { stream$ . pipe ( reduce ( reducer . fn , reducer . memo ) ) . once ( 'data' , function ( reduction ) { cb ( null , reduction ) ; } ) . once ( 'error' , cb ) ; } 
function reduceHooks ( hooks ) { return msg => { let tmp return hooks . reduce ( ( prev , hook ) => { tmp = hook ( prev ) if ( tmp === undefined || tmp === null ) { return prev } return tmp } , msg ) } } 
function pcomp ( f , g ) { return function ( ) { return f . apply ( null , arguments ) && g . apply ( null , arguments ) ; } } 
function replace ( regex , replacement , fileFilter ) { if ( fileFilter instanceof Array ) { fileFilter = fileFilter . reduce ( pcomp ) ; } else if ( ! fileFilter ) { fileFilter = ( ) => true ; } return files => { _ . forEach ( files , ( file , path ) => { if ( fileFilter ( file , path ) ) { file . contents = new Buffer ( file . contents . toString ( ) . replace ( regex , replacement ) ) ; } } ) ; } } 
function filenameExtensionFilter ( ext ) { if ( typeof ext === 'string' ) { return ( _ , path ) => path . endsWith ( '.' + ext ) ; } else if ( ext instanceof Array ) { return ext . map ( filenameExtensionFilter ) . reduce ( pcomp ) ; } } 
function define ( protocolName ) { return function ( services , ... callbacks ) { let builder const protocolClass = class extends FogletProtocol { constructor ( foglet , ... args ) { super ( protocolName , foglet , ... args ) } } 
function rand ( from , to ) { return Math . floor ( Math . random ( ) * ( to - from ) + from ) ; } 
function insertCommas ( words ) { if ( words . length < 2 ) { return words ; } words = words . slice ( ) ; const len = words . length ; const hasComma = / ,$ / ; let totalCommas = 0 ; if ( len > 3 && len <= 6 ) { totalCommas = rand ( 0 , 1 ) ; } else if ( len > 6 && len <= 12 ) { totalCommas = rand ( 0 , 2 ) ; } else { totalCommas = rand ( 1 , 4 ) ; } for ( let i = 0 , pos , word ; i < totalCommas ; i ++ ) { pos = rand ( 0 , len - 2 ) ; if ( ! hasComma . test ( words [ pos ] ) ) { words [ pos ] += ',' ; } } return words ; } 
function paragraph ( dict , wordCount , startWithCommon ) { const result = [ ] ; let totalWords = 0 ; let words ; if ( startWithCommon && dict . common ) { words = dict . common . slice ( 0 , wordCount ) ; totalWords += words . length ; result . push ( sentence ( insertCommas ( words ) , '.' ) ) ; } while ( totalWords < wordCount ) { words = sample ( dict . words , Math . min ( rand ( 2 , 30 ) , wordCount - totalWords ) ) ; totalWords += words . length ; result . push ( sentence ( insertCommas ( words ) ) ) ; } return result . join ( ' ' ) ; } 
function isRepeating ( node ) { while ( node . parent ) { if ( node . repeat && node . repeat . value && node . repeat . value > 1 ) { return true ; } node = node . parent ; } return false ; } 
function ( scriptOrLink ) { for ( var p = 0 , len = options . ignorePatterns . length ; p < len ; p ++ ) { if ( options . ignorePatterns [ p ] . test ( scriptOrLink ) ) { return true ; } } return false ; } 
function ( html ) { var count = 0 ; page = html . replace ( / <link(.*?)\/?> / g , function ( match ) { if ( match . indexOf ( "stylesheet" ) > - 1 ) { return match . replace ( / href="([^"]*") / , function ( ref ) { // Ignore CDN References if ( options . ignoreCDN ) { // remove src= from the match so all that is left is the quotes and string partial = ref . slice ( 4 ) ; if ( partial . slice ( 1 , 3 ) === " 
function longToBytes ( long ) { 
function addExtendSize ( Nightmare , opts ) { Nightmare . action ( 'size' , function ( done ) { console . log ( 'size opts' , opts ) ; this . evaluate_now ( ( ) => { const w = Math . max ( document . documentElement . clientWidth , window . innerWidth || 0 ) ; const h = Math . max ( document . documentElement . clientHeight , window . innerHeight || 0 ) ; return { height : h , width : w } ; } , done ) ; } ) ; } 
function render ( activities , highlight ) { 
function topVerbs ( activities , count ) { var counts = { } , list = [ ] , top ; for ( var i in activities ) { var verb = activities [ i ] . verb ; counts [ verb ] = ( counts [ verb ] || 0 ) + 1 ; } for ( key in counts ) list . push ( { key : key , values : counts [ key ] } ) ; top = list . sort ( function ( a , b ) { return b . values - a . values } ) . slice ( 0 , count ) . map ( function ( verb ) { return verb . key } ) . concat ( "other" ) ; 
function verbColor ( verbs , verb ) { var index = verbs . indexOf ( verb ) , color = ( index >= 0 ) ? VERB_COLORS ( index ) : "#ccc" , rgb = d3 . rgb ( color ) ; return "rgba(" + rgb . r + "," + rgb . g + "," + rgb . b + ",0.5)" } 
function filterVerbs ( activities ) { return activities . filter ( function ( activity ) { var showing = verbsShowing [ activity . verb ] ; if ( showing == undefined ) showing = verbsShowing [ "other" ] ; return showing ; } ) } 
function renderVerbs ( verbs ) { 
function stdCall ( options , call , args , cb ) { var val = '' ; for ( var key in args ) { val += '&' + encodeURIComponent ( key ) + '=' + encodeURIComponent ( args [ key ] ) ; } if ( call !== undefined ) { call = '?command=' + call ; } if ( call === undefined ) { call = '' ; } if ( val === undefined ) { val = '' ; } http . get ( { hostname : 'localhost' , port : options . httpPort , path : '/requests/status.json' + call + val , auth : ':' + options . httpPassword , agent : false } , function ( res ) { if ( cb !== undefined ) { cb ( res ) ; } } ) ; } 
function findNextZipHeaderIndex ( arr ) { var startAt = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; return arr . findIndex ( function ( el , i , arr ) { return i >= startAt && arr [ i ] === 0x50 && arr [ i + 1 ] === 0x4B && arr [ i + 2 ] === 0x3 && arr [ i + 3 ] === 0x4 ; } ) ; } 
function Vanity ( options ) { this . connected = false ; if ( options ) { this . url = options . url ; this . token = options . token ; } 
function projectConfigAddPaths ( originalConfig ) { const config = originalConfig ; if ( ! Object . prototype . hasOwnProperty . call ( config . paths . src , TASK_NAME ) ) { config . paths . src [ TASK_NAME ] = ` ${ config . dirs . src } ` ; } if ( ! Object . prototype . hasOwnProperty . call ( config . paths . dest , TASK_NAME ) ) { config . paths . dest [ TASK_NAME ] = ` ${ config . dirs . dest } ` ; } return config ; } 
function findHeader ( aoa ) { const { i } = aoa . reduce ( ( prev , row , i ) => { const len = rowLength ( row ) if ( prev . len < len ) { return { i , len } } return prev } , { i : - 1 , len : 0 } ) return i } 
function lookup ( name , obj ) { for ( const key in obj ) { const re = RegExp ( key , 'i' ) if ( name . match ( re ) ) { return obj [ key ] } } 
function isSsh ( input ) { if ( Array . isArray ( input ) ) { return input . indexOf ( "ssh" ) !== - 1 || input . indexOf ( "rsync" ) !== - 1 ; } if ( typeof input !== "string" ) { return false ; } var prots = protocols ( input ) ; input = input . substring ( input . indexOf ( "://" ) + 3 ) ; if ( isSsh ( prots ) ) { return true ; } 
function ( options , cb ) { return doNpmCommand ( { npmCommand : 'install' , cmdArgs : options . dependencies , cmdOptions : { production : options . production || false , loglevel : options . loglevel || undefined , save : options . save || false , 'save-dev' : options . saveDev || false , 'save-exact' : options . saveExact || false , prefix : options . prefix || undefined , } , dir : options . dir } , cb ) ; } 
function ( expect , sinon , name ) { if ( typeof ( name ) === 'undefined' ) { name = 'spy' ; } SinonExpect . _expect = expect ; SinonExpect . _sinon = sinon ; SinonExpect . ExpectWrapper . __proto__ = expect . Assertion ; SinonExpect . ExpectWrapper . spyName = name ; var result = function ( obj ) { return new SinonExpect . ExpectWrapper ( obj ) ; } ; result . Assertion = SinonExpect . ExpectWrapper ; SinonExpect . buildMatchers ( ) ; return result ; } 
function ( ) { var i = 0 , len = SinonExpect . assertions . length , matcher ; for ( i , len ; i < len ; i ++ ) { matcher = SinonExpect . assertions [ i ] ; ( function ( matcher ) { SinonExpect . SinonAssertions . prototype [ matcher ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) , sinon = SinonExpect . _sinon ; args . unshift ( this . obj ) ; sinon . assert [ matcher ] . apply ( sinon . assert , args ) ; } ; } ( matcher ) ) ; } } 
function ( thingy ) { 
function ( elem , appendElem , stylesToAdd ) { 
function autoFill ( q , sValue ) { 
function ( time , timeZone ) { var format_time_options = { } ; if ( timeZone && timeZone != "Local" ) { format_time_options . timeZone = timeZone ; } return time . toLocaleString ( undefined , format_time_options ) ; } 
function ghIssueStats ( repository , options ) { options = merge ( { 
function ( segment_response ) { var tooltip = '<div>Segment <b>' + segment_response . name + '</b>:</div>' + '<div class="label">#docs:</div><div>' + number_format ( segment_response . size ) + '</div>' + '<div class="label">#dels:</div><div>' + number_format ( segment_response . delCount ) + '</div>' + '<div class="label">size:</div><div>' + number_format ( segment_response . sizeInBytes ) + ' bytes </div>' + '<div class="label">age:</div><div>' + segment_response . age + '</div>' + '<div class="label">source:</div><div>' + segment_response . source + '</div>' ; return tooltip ; } 
function ( golr_loc , golr_conf_obj , engine , mode ) { registry . call ( this , [ 'prerun' , 'reset' , 'search' , 'error' , 'postrun' ] ) ; this . _is_a = 'bbop-manager-golr' ; var anchor = this ; * Function: debug * * Turn on or off the verbose messages. Uses <bbop.logger>, so * they should come out everywhere. * * Parameters: * p - *[optional]* true or false for debugging * * Returns: * boolean; the current state of debugging */ this . debug = function ( p ) { if ( p === true || p === false ) { this . _logger . DEBUG = p ; * Function: minimal_query * * The length of the minimal query to consider. Defaults to 3. * * Parameters: * n - *[optional]* number, or nothing if just want current * * Returns: * number */ this . minimal_query = function ( n ) { if ( us . isNumber ( n ) ) { anchor . minimal_query_length = n ; } return this . minimal_query_length ; } ; this . lite = function ( use_lite_p ) { * Function: get_facet_limit * * Get the limit for a specified facet or the global limit. * * Parameters: * field - *[optional]* limit for a specific field; otherwise global value * * Returns: * integer or null */ this . get_facet_limit = function ( field ) { var retval = null ; if ( ! field ) { retval = anchor . current_facet_limit ; } else { var f = _field_to_facet_field ( field ) ; var try_val = anchor . current_facet_field_limits [ f ] ; if ( typeof ( try_val ) !== 'undefined' ) { retval = try_val ; } } return retval ; } ; this . set_facet_limit = function ( arg1 , arg2 ) { var retval = false ; * Function: set_default_facet_limit * * Permanently change the default number of facet values returned * per call. The default's default is likely 25. * * Just as in Solr, a -1 argument is how to indicate unlimted * facet returns. * * Parameters: * lim - (integer) set the global default limit * * Returns: * old default */ this . set_default_facet_limit = function ( lim ) { // Capture ret. var retval = anchor . default_facet_limit ; // Set anchor . default_facet_limit = lim ; //anchor.set('facet.limit', anchor.default_facet_limit); return retval ; } ; /* * Function: reset_facet_limit * * Either reset the global limit to the original (likely 25) * and/or remove the specified filter. Sets everything back to the * original values or whatever was set by * <set_default_facet_limit>. * * Parameters: * field - *[optional]* remove limit for a field; otherwise all and global * * Returns: * boolean on whether something was reset */ this . reset_facet_limit = function ( field ) { var retval = false ; if ( typeof ( field ) === 'undefined' ) { // Eliminate all fields by blowing them away. anchor . current_facet_limit = anchor . default_facet_limit ; anchor . set ( 'facet.limit' , anchor . current_facet_limit ) ; anchor . current_facet_field_limits = { } ; retval = true ; } else { // eliminate just the one field var f = _field_to_facet_field ( field ) ; if ( typeof ( anchor . current_facet_field_limits [ f ] ) !== 'undefined' ) { delete anchor . current_facet_field_limits [ f ] ; retval = true ; } } return retval ; } ; /* * Function: get_results_count * * Get the current number of results that will be returned. * * Parameters: * n/a * * Returns: * integer */ this . get_results_count = function ( field ) { return anchor . get ( 'rows' ) ; } ; /* * Function: set_results_count * * Change the number of result documents returned per call. * The default is likely 10. * * Parameters: * count - (integer) set the global results count * * Returns: * the count set */ this . set_results_count = function ( count ) { anchor . set ( 'rows' , count ) ; anchor . current_rows = count ; return anchor . current_rows ; } ; /* * Function: reset_results_count * * Reset the number of documents to their original setting, likely * 10. * * Parameters: * n/a * * Returns: * the new count */ this . reset_results_count = function ( ) { anchor . set ( 'rows' , anchor . default_rows ) ; anchor . current_rows = anchor . default_rows ; return anchor . current_rows ; } ; /* * Function: plist_to_property_hash * * Turn a plist to a hash containing the different properties that * can be defined for a query filter. Possible values are: '+' * (positive filter), '-' (negative filter), '*' (sticky filter), * '$' (transient). If mutually exclusive properties are defined * (e.g. both '+' and '-'), the last one will be used. Or, since * that is a call to silliness, let's say the behavior is * undefined. * * Parameters: * plist - *[optional]* a list of properties to apply to the filter * * Returns: * A hash version of the plist; otherwise, the default property hash */ this . plist_to_property_hash = function ( plist ) { * Function: add_query_filter_as_string * * Setter for query filters ('fq'). Acts as a * * Parameters: * filter_string - filter (type) string (e.g. "-type:gene") * plist - *[optional]* list of properties of the filter * * Returns: * (TODO) The current query filter hash. * * See also: * <add_query_filter> */ this . add_query_filter_as_string = function ( filter_string , plist ) { * Function: add_query_filter * * Setter for query filters ('fq'). * * Parameters: * filter - filter (type) string * value - filter value string (or TODO: defined logic hash) * plist - *[optional]* list of properties of the filter * * Returns: * (TODO) The current query filter hash. * * See also: * <plist_to_property_hash> */ this . add_query_filter = function ( filter , value , plist ) { * Function: remove_query_filter * * Remover for query filters ('fq'), is a plist is specified, it * will only remove if all of the listed criteria are met. * * Parameters: * filter - filter (type) string * value - filter value string (TODO: or defined logic hash) * plist - *[optional]* list of properties of the filter * * Returns: * boolean (on success) */ this . remove_query_filter = function ( filter , value , plist ) { * Function: reset_query_filters * * Reset the query filters ('fq'); but leave sticky filters alone. * * Parameters: * n/a * * Returns: * (TODO) The current query filter hash. */ this . reset_query_filters = function ( ) { * Function: get_query_filter_properties * * Get a hash representing a query filter ('fq'). * * Parameters: * key - filter string (TODO: or defined logic hash) * * Returns: * The current query filter hash for key. */ this . get_query_filter_properties = function ( filter , value ) { * Function: get_query_filters * * Get a list of hashes representing the query filters ('fq'). The * return lists look like: * * : [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...] * * Where A and B are strings and C and D are booleans. * * Parameters: * n/a * * Returns: * A list of the current query filter hashs. */ this . get_query_filters = function ( ) { var retlist = [ ] ; each ( anchor . query_filters , function ( values , f ) { each ( values , function ( props , v ) { retlist . push ( anchor . get_query_filter_properties ( f , v ) ) ; } ) ; } ) ; return retlist ; } ; this . get_sticky_query_filters = function ( ) { var retlist = [ ] ; each ( anchor . query_filters , function ( values , f ) { each ( values , function ( props , v ) { var qfp = anchor . get_query_filter_properties ( f , v ) ; if ( qfp [ 'sticky_p' ] === true ) { retlist . push ( qfp ) ; } } ) ; } ) ; return retlist ; } ; * Function: filter_list_to_assemble_hash * * Get all of our query filter variables and try and make * something of them that <get_assemble> can understand. * * Sticky doesn't matter here, but negativity does. However, we * can be pretty naive since the hashing should have already taken * out mutually exclusive dupes. * * The argument is a list of query filter properties, as returned * by <get_query_filters> and <get_sticky_query_filters>. * * Parameters: * flist - a list of query filter properties (see above) * * Returns: * hash of filter names to value lists * * See also: * <get_query_filters> * <get_sticky_query_filters> */ this . filter_list_to_assemble_hash = function ( flist ) { var h = { } ; each ( flist , function ( filter_property ) { // Grab only the properties that affect the // URL. var filter = filter_property [ 'filter' ] ; var value = filter_property [ 'value' ] ; var negative_p = filter_property [ 'negative_p' ] ; // We need to alter at the filter level. if ( negative_p ) { filter = '-' + filter ; } // Make sure it is defined. if ( typeof ( h [ filter ] ) === 'undefined' ) { h [ filter ] = [ ] ; } h [ filter ] . push ( value ) ; } ) ; return h ; } ; /* * Function: sensible_query_p * * Simply ask the manager if a free text query ('q') makes sense * at this point. * * This currently means that the query text ('q') is one of: * 1) the same as the default query * 2) the same as the fundamental query * 3) three (3) (or whatever minimal_query is set to) characters long * 4) the empty string ('') * and that query fields ('qf') are defined. * * This is an overridable opinion of the manager. * * Parameters: * n/a * * Returns: * boolean */ this . sensible_query_p = function ( ) { var retval = false ; var q = anchor . get_query ( ) ; var qf = anchor . query_field_set ( ) ; //console.log('q', q); //console.log('qf', qf); if ( qf && ! us . isEmpty ( qf ) ) { // first hurdle if ( q === anchor . get_default_query ( ) ) { retval = true ; } else if ( q === anchor . get_fundamental_query ( ) ) { retval = true ; } else if ( q && q . length >= anchor . minimal_query_length ) { retval = true ; } else if ( q === '' ) { retval = true ; } } return retval ; } ; /* * Function: last_packet_sent * * It is up to the UI to do something interesting with this number. * * Also remember that this number only rises through calls to * <update> or one of its wrappers. Calls to <get_query_url> and * the like will not affect this number. * * Parameters: * n/a * * Returns: * integer * * See also: * <update> */ this . last_packet_sent = function ( ) { return anchor . last_sent_packet ; } ; /* * Function: clear * * Clear all non-sticky query parameters to get back to a more * "original" state. * * Not to be confused with <reset>. * * Parameters: * n/a * * Returns: * n/a */ this . clear = function ( ) { // Reset 'q'. anchor . query = anchor . default_query ; // Reset 'fq', all but sticky. anchor . reset_query_filters ( ) ; } ; /* * Function: reset * * Manually trigger the "reset" chain of events. * * This is a curried wrapper for <update> and should be preferred * over a direct call to update. * * Note to be confused with <clear>. * * Returns: * the query url (with the jQuery callback specific parameters) * * See also: * <update> */ this . reset = function ( ) { return anchor . update ( 'reset' ) ; } ; /* * Function: search * * Trigger the "search" chain of events. * Takes a field-keyed hash of bbop.logics as an argument. * * This is a curried wrapper for <update> and should be preferred * over a direct call to update. * * Parameters: * n/a * * Returns: * the query url (with the jQuery callback specific parameters) * * See also: * <update> */ this . search = function ( ) { return anchor . update ( 'search' ) ; } ; /* * Function: page * * Re-trigger the "search" chain of events, but with the variables * set for a different section of the results. * * Note that this operates independently of any impossibilites in * the results--just how such paging would look and * triggering. Ths UI should handle impossibilities and the like. * * This is a wrapper for <update> and should be preferred over a * direct call to update. * * Parameters: * rows - the number of rows to return * start - the offset of the rows to return * * Returns: * the query url (with the jQuery callback specific parameters) * * See also: * <update> */ this . page = function ( rows , start ) { anchor . set ( 'rows' , rows ) ; anchor . set ( 'start' , start ) ; return anchor . update ( 'search' , rows , start ) ; } ; /* * Function: page_first * * Currently a convenience alias for <search>. Think about it--it * makes sense. * * This is a wrapper for <page> and should be preferred over a * direct call to page. * * Parameters: * n/a * * Returns: * n/a * * See also: * <page> */ this . page_first = anchor . search ; /* * Function: page_previous * * This is a wrapper for <page> and should be preferred over a * direct call to page. * * Parameters: * n/a * * Returns: * the query url (with the jQuery callback specific parameters) * * See also: * <page> */ this . page_previous = function ( ) { var do_rows = anchor . get_page_rows ( ) ; var do_offset = anchor . get_page_start ( ) - do_rows ; return anchor . page ( do_rows , do_offset ) ; } ; /* * Function: page_next * * This is a wrapper for <page> and should be preferred over a * direct call to page. * * Parameters: * the query url (with the jQuery callback specific parameters) * * Returns: * n/a * * See also: * <page> */ this . page_next = function ( ) { var do_rows = anchor . get_page_rows ( ) ; var do_offset = anchor . get_page_start ( ) + do_rows ; return anchor . page ( do_rows , do_offset ) ; } ; /* * Function: page_last * * Trigger search on last page parameters. * * Since the manager has no idea about what is actually being * returned, the real world number of total documents needs to be * added as an argument. * * This is a wrapper for <page> and should be preferred over a * direct call to page. * * Parameters: * total_document_count - integer for the total number of docs found * * Returns: * the query url (with the jQuery callback specific parameters) * * See also: * <page> */ this . page_last = function ( total_document_count ) { var do_rows = anchor . get_page_rows ( ) ; var mod = total_document_count % do_rows ; var do_offset = total_document_count - mod ; // ll("page_last: " + total_document_count + " " + // do_rows + " " + mod + " " + do_offset); var ret = null ; if ( mod === 0 ) { ret = anchor . page ( do_rows , do_offset - do_rows ) ; } else { ret = anchor . page ( do_rows , do_offset ) ; } return ret ; } ; /* * Function: get_page_rows * * Return the number of rows the manager is currently set * to. Useful as an argument to <page>. * * Parameters: * n/a * * Returns: * integer; the number of rows the manager is currently set to * * See also: * <page> */ this . get_page_rows = function ( ) { return anchor . get ( 'rows' ) ; } ; /* * Function: get_page_start * * Return the rows offset the manager is currently set to. Useful * as an argument to <page>. * * Parameters: * n/a * * Returns: * integer; the offset the manager is currently set to * * See also: * <page> */ this . get_page_start = function ( ) { return anchor . get ( 'start' ) ; } ; /* * Function: add_query_field * * Add a new query field to the query. * * This does not go through and expand into searchable fields, for * that see: <query_field_set>. * * Parameters: * qf - the query field to add * boost - *[optional]* defaults to 1.0 * * Returns: * true or false on whether or not it is a new field * * See also: * <query_field_set> */ this . add_query_field = function ( qf , boost ) { var retval = false ; // Make sure that some boost is there. if ( typeof ( boost ) === 'undefined' ) { boost = 1.0 ; } // Check. if ( typeof ( anchor . query_fields [ qf ] ) === 'undefined' ) { retval = true ; } // Add. anchor . query_fields [ qf ] = boost ; return retval ; } ; /* * Function: query_field_set * * Bulk getter/setter for the query fields--the fields that are * searched (and by what weight) when using a query ('q' or * set_query(), i.e. the 'qf' field). * * This will always use searchable fields if possible, * automatically replacing the non-searchable versions (I can't * think of any reason to use non-searchable versions unless you * want your searches to not work) if a personality is set. If no * personality is set, it will just use the arguments as-is. * * The argument replaces the current set. * * The qfs argument should be a hash like: * * {'field01': value01, ...} * * Parameters: * qfs - *[optional]* query fields to set * * Returns: * the current query_fields array (e.g. ["field01^value01", ...]) */ this . query_field_set = function ( qfs ) { * Function: facets * * Bulk getter/setter for facets (technically 'facet.field'). * * Parameters: * key - *[optional]* facet to add to the facet list * * Parameters: * list - *[optional]* list to replace the current list with * * Returns: * the current facets hash. */ this . facets = function ( list_or_key ) { if ( list_or_key ) { if ( bbop . what_is ( list_or_key ) !== 'array' ) { * Function: set_default_query * * Setter for the default query for the query variable ('q'). * * Call <reset_query> if you want to affect query immediately. * * Parameters: * new_default_query - new default query string (or TODO: <bbop.logic>) * * Returns: * the current setting of default query for ('q') */ this . set_default_query = function ( new_default_query ) { anchor . default_query = new_default_query ; return anchor . default_query ; } ; * Function: reset_default_query * * Reset the default query back to "*:*". * * Call <reset_query> if you want to affect query immediately. * * Parameters: * n/a * * Returns: * the current setting of default query ('q') */ this . reset_default_query = function ( ) { anchor . default_query = anchor . fundamental_query ; return anchor . default_query ; } ; this . set_query = function ( new_query ) { anchor . query = new_query ; return anchor . query ; } ; this . set_comfy_query = function ( new_query ) { var comfy_query = new_query ; * Function: set_id * * A limited setter, removing whatever else is on query. This is * for when you want to lock into one (unique) document by id * (essentially 'q=id:"foo"'). All other query operations behave * as they should around it. * * Parameters: * new_id - string id * * Returns: * the current setting of query ('q') * * Also see: * <set_ids> */ this . set_id = function ( new_id ) { anchor . query = 'id:' + bbop . ensure ( new_id , '"' ) ; return anchor . query ; } ; * Function: set_ids * * Like <set_id>, a limited setter. It removes whatever else is on * query and replaces it with something like: * * : gm.set_ids(['GO:1', 'GO:2']) * * This is for when you want to lock into a set of documents by id. All * other query operations behave as they should around it. * * Parameters: * id_list - a list of ids to search for * * Returns: * the current setting of query ('q') * * Also see: * <set_ids> */ this . set_ids = function ( id_list ) { anchor . query = _lock_map ( 'id' , id_list ) ; return anchor . query ; } ; this . set_targets = function ( id_list , field_list ) { var fixed_list = [ ] ; each ( field_list , function ( field ) { fixed_list . push ( _lock_map ( field , id_list ) ) ; } ) ; var sum = fixed_list . join ( ' OR ' ) ; anchor . query = sum ; return anchor . query ; } ; this . get_query = function ( ) { return anchor . query ; } ; this . get_default_query = function ( ) { return anchor . default_query ; } ; this . get_fundamental_query = function ( ) { return anchor . fundamental_query ; } ; this . get_query = function ( ) { return anchor . query ; } ; this . reset_query = function ( ) { anchor . query = anchor . default_query ; ll ( 'reset query to default: ' + anchor . query ) ; return anchor . query ; } ; this . set_extra = function ( new_extra ) { anchor . query_extra = new_extra ; return anchor . query_extra ; } ; this . get_extra = anchor . set_extra ; this . remove_extra = function ( ) { anchor . query_extra = "" ; return anchor . query_extra ; } ; this . set = function ( key , new_val ) { anchor . query_variants [ key ] = new_val ; } ; this . get = function ( key ) { return anchor . query_variants [ key ] ; } ; this . unset = function ( key ) { var retval = false ; if ( typeof ( anchor . query_variants [ key ] ) !== 'undefined' ) { retval = true ; delete anchor . query_variants [ key ] ; } return retval ; } ; this . include_highlighting = function ( hilite_p , html_elt_str ) { var retval = false ; if ( typeof ( hilite_p ) !== 'undefined' && ( hilite_p === true || hilite_p === false ) ) { if ( hilite_p === true ) { * Function: set_personality * * While we are always contacting the same Solr instance, we * sometimes want to have different weights, facets, etc. This * function allows us to use the pre-set ones defined in the * constructor configuration argument. * * Currently, this only sets the 'facet.field' internal variable. * * Parameters: * personality_id - string * * Returns: * Will return false if personality doesn't exist */ this . set_personality = function ( personality_id ) { var retval = false ; // This sets the facet.field internal variable. var cclass = anchor . _golr_conf . get_class ( personality_id ) ; if ( cclass ) { // Remember what our personality is. // WARNING: this line must go before the query_field_set // line below, or else we won't get the "smart" search. this . _current_class = cclass ; * Function: get_personality * * Returns the current personality, null if none. * * Parameters: * n/a * * Returns: * Returns the current personality as a string, null if none is set */ this . get_personality = function ( ) { var retval = null ; if ( typeof ( anchor . _current_class ) !== 'undefined' && bbop . what_is ( anchor . _current_class ) === 'golr-conf.conf_class' ) { retval = anchor . _current_class . id ( ) ; } return retval ; } ; this . get_query_url = function ( ) { * Function: push_excursion * * Save the current state of the manager--data and sticky filter * information--onto an internal stack. Batch information is not * stored. * * Useful for gettinginto a state, doing something else, then * returning to the original state. * * Parameters: * n/a * * Returns: * the number of items on the excursion stack * * Also see: * <get_query_url> * <pop_excursion> */ this . push_excursion = function ( ) { var now = { * Function: pop_excursion * * Return to a previously pushed state. Batch items are not * recovered. * * Parameters: * n/a * * Returns: * boolean on whether a state was recovered * * Also see: * <get_query_url> * <gpush_excursion> */ this . pop_excursion = function ( ) { var retval = false ; var then = anchor . _excursions . pop ( ) ; if ( then ) { retval = true ; * Function: get_download_url * * Get the current invariant state of the manager returned as a * URL string. * * This differs from <get_query_url> in that the generated string * is intended for text-processing uses rather than computerized * searching uses. The idea where is to create a TSV file for * downloading and consumption. * * Instead of downloading all of the results, a limited listed set * can be downloaded using entity_list, which identifies documents by id. * * The optional argument hash looks like: * rows - the number of rows to return; defaults to: 1000 * encapsulator - how to enclose whitespace fields; defaults to: "" * separator - separator between fields; defaults to: "%09" (tab) * header - whether or not to show headers; defaults to: "false" * mv_separator - separator for multi-valued fields; defaults to: "|" * entity_list - list of specific download items in results; default null * * With the entity list, keep in mind that null and an empty list * are handled in pretty much the same way--they are an indication * that we are going after nothing specific, and so all results * are game. * * Parameters: * field_list - a list of fields to return * in_arg_hash - *[optional]* additional optional arguments * * Returns: * URL string * * Also see: * <get_query_url> */ this . get_download_url = function ( field_list , in_arg_hash ) { * Function: get_filter_query_string * * Get the current state of the manager, as defined by the current * gross filter set--query, sticky filters, and standard filters-- * returned as a URL query string (sans the '?'). * * This differs from <get_query_url> and <get_state_url> in that * the generated string is intended for applications that may want * just enough information to recover filter state when the * personality, and other types of information, are already * known. It is intended to be part of a light RESTy bookmarking * mechanism in larger application. * * Parameters: * n/a * * Returns: * query string for current filters (sans the '?') * * Also see: * <get_query_url> * <get_state_url> */ this . get_filter_query_string = function ( ) { * Function: get_state_url * * Get the current invariant state of the manager, plus the * current personality as a parameter, returned as a URL string. * * This differs from <get_query_url> in that the generated string * is intended for applications that may want a little more * information and hinting over just what the current search * is. This method essentially parameterizes some of the "hidden * state" of the manager. * * Parameters: * n/a * * Returns: * URL string * * Also see: * <get_query_url> */ this . get_state_url = function ( ) { * Function: load_url * * Makes a a best attempt to recover the state of a manager from * the clues left in a data url. This can also (and probably * should) be thought of as a "load bookmark" * function. Theoretically, you should even be able to use * "bookmarks" from alien installations. * * Note that while this recovers enough to get the same data, * certain "session"/"preference" type things that are not encoded * in the url (e.g. filter stickiness, the contents of batch * queues, non-default base queries, etc.) will not be replayed * and must be recovered or guessed on an app by app basis.. * * Warning: this currently only replays a small subset of possible * parameters. Currently: personality, q, fq, ???. In the future, * this should no all non-session information. * * Warning: Because there is more to bookmarks than just the major * stuff, variants not supplied in the bookmark will be removed. * * This returns true if the parameter portions of the new and * bookmark urls match. However, this is often not the case--think * shifting personalities, etc. * * Parameters: * url - A URL string generated by a manager's get_query_url (or similar) * * Returns: * boolean */ this . load_url = function ( url ) { // // Some Regexps that would be nice to just compile once. // var regexp_url_space = /\%20/g; // '%20' === ' ' // var regexp_url_quote = /\%22/g; // '%22' === '"' // var regexp_url_left_paren = /\%28/g; // '%28' === '(' // var regexp_url_right_paren = /\%29/g; // '%29' === ')' // We are assuming that we are consuming our own URLs from // get_query_url(), so we start by attempting to decode it // (TODO: need a tab watch here)? var decoded_url = decodeURI ( url ) ; // Break down url. var in_params = bbop . url_parameters ( decoded_url ) ; // First, look for the personality setting and invoke it if // it's there--it will dominate unless we take care of it first. // Also note the all the keys that we see (for later erasure // of excess). var seen_params = { } ; each ( in_params , function ( ip ) { var key = ip [ 0 ] ; var val = ip [ 1 ] ; if ( key === 'personality' && val && val !== '' ) { anchor . set_personality ( val ) ; } seen_params [ key ] = true ; } ) ; // Now cycle through the the parameters again and invoke the // appropriate functions to bring them in line. var sticky_cache = { } ; each ( in_params , function ( ip ) { var key = ip [ 0 ] ; var val = ip [ 1 ] ; if ( typeof ( val ) !== 'undefined' && val !== '' ) { if ( key === 'personality' ) { // Already did it, skip. } else if ( key === 'q' ) { anchor . set_query ( val ) ; } else if ( key === 'fq' || key === 'sfq' ) { // Split the fq (or sfq) parameter. var fnv = bbop . first_split ( ':' , val ) ; var fname = fnv [ 0 ] ; var fval = fnv [ 1 ] ; //ll('HERE: fname: ' + fname); //ll('HERE: fval: ' + fval); if ( fname && fval ) { var plist = [ ] ; // Remove leading sign on a filter and // add it to the plist. var lead_char = fname . charAt ( 0 ) ; if ( lead_char === '-' || lead_char === '+' ) { plist . push ( lead_char ) ; fname = fname . substr ( 1 , fname . length - 1 ) ; } // // TODO: // // If the fval looks like it has not been // // decoded (like from a URL-safe // // bookmark), go ahead and do so. // fval = fval.replace(regexp_url_space, ' '); // fval = fval.replace(regexp_url_quote, '"'); // fval = fval.replace(regexp_url_left_paren, '('); // fval = fval.replace(regexp_url_right_paren,')'); // Do not allow quotes in--they will be // added by the assembler. fval = bbop . dequote ( fval ) ; // Make it sticky it it came in on "sfq". // Note if this is the sticky form. var skey = fname + '^' + fval ; if ( key === 'sfq' ) { sticky_cache [ skey ] = true ; plist . push ( '*' ) ; } // Add the query filter properly, but // only if we have not already added the // sticky form (prevent clobbering). if ( ! bbop . is_defined ( sticky_cache [ skey ] ) || key === 'sfq' ) { anchor . add_query_filter ( fname , fval , plist ) ; } } } else if ( key === 'qf' ) { // qf is handles a little strangely... var foo = bbop . first_split ( '^' , val ) ; //ll('qf: key: '+ key +', val: '+ val +', foo: '+ foo); anchor . add_query_field ( foo [ 0 ] , foo [ 1 ] ) ; } else if ( key === 'facet.field' ) { anchor . facets ( val ) ; } else if ( key === 'start' || key === 'rows' ) { // Numbers need to be handled carefully. if ( bbop . what_is ( val ) === 'string' ) { val = parseFloat ( val ) ; } anchor . set ( key , val ) ; } else { // This one catches all of the non-special // parameters and resets them using .set(). anchor . set ( key , val ) ; // if( key === 'fq' ){ // throw new Error("OI"); // } } } } ) ; // Now go through and remove all of the query variant // parameters that were not seen in the bookmark. each ( anchor . query_variants , function ( val , key ) { if ( typeof ( seen_params [ key ] ) === 'undefined' ) { anchor . unset ( key ) ; } } ) ; // Produce our own url from what we've done. If the parameters * Function: add_to_batch * * "Save" the current manager state to run later in serial batch * mode. * * The actual job of running these batches is left to the * implementation of the sub-managers; probably in "run_batch". * * Parameters: * n/a * * Returns: * state url */ this . add_to_batch = function ( ) { var qurl = anchor . get_query_url ( ) ; anchor . _batch_urls . push ( qurl ) ; return qurl ; } ; this . batch_urls = function ( ) { return anchor . _batch_urls ; } ; this . next_batch_url = function ( ) { return anchor . _batch_urls . shift ( ) || null ; } ; this . reset_batch = function ( ) { var num = anchor . _batch_urls . length ; anchor . _batch_urls = [ ] ; return num ; } ; } 
function _full_delete ( hash , key1 , key2 ) { if ( key1 && key2 && hash && hash [ key1 ] && hash [ key1 ] [ key2 ] ) { delete hash [ key1 ] [ key2 ] ; } if ( us . isEmpty ( hash [ key1 ] ) ) { delete hash [ key1 ] ; } } 
function SocketTransport ( URL , options ) { if ( ! URL ) { throw new Error ( 'A WebSocket URL must be passed to the SocketTransport constructor!' ) ; } if ( ! ( this instanceof SocketTransport ) ) { return new SocketTransport ( URL , options ) ; } this . _URL = URL ; this . _options = options || { } ; this . _socket = null ; this . _state = 'unconnected' ; this . _active = false ; this . _reconnectTimeout = null ; EventEmitter2 . call ( this ) ; var self = this ; var listeners = { open : function ( ) { self . _handleOpen ( ) ; } , error : function ( error ) { self . _handleError ( error ) ; } , close : function ( closeEvent ) { self . _handleDisconnect ( ) ; } , message : function ( messageEvent ) { self . emit ( 'message' , messageEvent . data ) ; } } ; this . _standardListeners = listeners ; } 
function Commander ( client , options ) { if ( ! ( this instanceof Commander ) ) { return new Commander ( client , options ) ; } EventEmitter2 . call ( this ) ; this . setMaxListeners ( 0 ) ; options = options || { } ; options . retryStrategy = options . retryStrategy || defaultRetry ; this . _client = client ; this . _options = options ; } 
function addListElementFontSize ( element ) { var hDataWeight = - 9007199254740992 ; var lDataWeight = 9007199254740992 ; $ . each ( element . find ( "li" ) , function ( ) { cDataWeight = getDataWeight ( this ) ; if ( cDataWeight == undefined ) { logWarning ( "No \"data-weight\" attribut defined on <li> element" ) ; } else { hDataWeight = cDataWeight > hDataWeight ? cDataWeight : hDataWeight ; lDataWeight = cDataWeight < lDataWeight ? cDataWeight : lDataWeight ; } } ) ; $ . each ( element . find ( "li" ) , function ( ) { var dataWeight = getDataWeight ( this ) ; var percent = Math . abs ( ( dataWeight - lDataWeight ) / ( lDataWeight - hDataWeight ) ) ; $ ( this ) . css ( 'font-size' , ( 1 + ( percent * settings [ 'multiplier' ] ) ) + "em" ) ; } ) ; } 
function ( value ) { if ( value !== Number ( value ) ) { var units = 'BKMGTPEZY' ; var match = value . match ( / ^(\d+([,\.]\d+)?) (\w)\w?$ / ) ; var value = parseFloat ( match [ 1 ] ) * Math . pow ( 1024 , units . indexOf ( match [ 3 ] . toUpperCase ( ) ) ) ; } return value ; } 
function toggles ( documents_form , show_json , show_file , show_doc , doc_text , show_wizard ) { var json_only = $ ( '#json-only' ) ; var the_document = $ ( '#document' , documents_form ) ; if ( show_doc ) { 
function addWizardFields ( active_core , wizard ) { var core_basepath = active_core . attr ( 'data-basepath' ) ; var select_options = "" ; 
function ( data ) { var field_select = $ ( "#wiz-field-select" , wizard ) ; field_select . empty ( ) ; $ . each ( data . fields , function ( i , item ) { 
function processAdd ( cmd ) { doc = cmd . solrDoc ; 
function mappr ( ) { for ( var _len2 = arguments . length , mappers = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { mappers [ _key2 ] = arguments [ _key2 ] ; } return _utils . flow . apply ( undefined , _toConsumableArray ( mappers . map ( applyMapper ) ) ) ; } 
function zk_error ( xhr , text_status , error_thrown ) { var zk = null ; try { eval ( 'zk = ' + xhr . responseText + ';' ) ; } catch ( e ) { } var message = '<p class="txt">Loading of "<code>' + xhr . url + '</code>" ' + 'failed (HTTP-Status <code>' + xhr . status + '</code>)</p>' + "\n" ; if ( zk . error ) { message += '<p class="msg">"' + zk . error . esc ( ) + '"</p>' + "\n" ; } this . closest ( '#cloud' ) . html ( '<div class="block" id="error">' + message + '</div>' ) ; } 
function ( direction , cloud_element ) { var start = $ ( '#cloudGraphPagingStart' ) . val ( ) ; var rows = $ ( '#cloudGraphPagingRows' ) . val ( ) ; var startAt = start ? parseInt ( start ) : 0 ; var numRows = rows ? parseInt ( rows ) : 20 ; var newStart = Math . max ( startAt + ( rows * direction ) , 0 ) ; $ ( '#cloudGraphPagingStart' ) . val ( newStart ) ; var graph_element = $ ( '#graph-content' , cloud_element ) ; $ ( '#canvas' , graph_element ) . empty ( ) ; init_graph ( graph_element ) ; } 
function dataimport_fetch_config ( ) { $ . ajax ( { url : handler_url + '?command=show-config&indent=true' , dataType : 'xml' , context : $ ( '#dataimport_config' , config_element ) , beforeSend : function ( xhr , settings ) { error_element . empty ( ) . hide ( ) ; } , success : function ( config , text_status , xhr ) { dataimport_element . removeClass ( 'error' ) ; config_element . addClass ( 'hidden' ) ; var entities = [ '<option value=""></option>' ] ; $ ( 'document > entity' , config ) . each ( function ( i , element ) { entities . push ( '<option>' + $ ( element ) . attr ( 'name' ) . esc ( ) + '</option>' ) ; } ) ; $ ( '#entity' , form_element ) . html ( entities . join ( "\n" ) ) ; $ ( '.editable textarea' , this ) . val ( xhr . responseText . replace ( / \n+$ / , '' ) ) ; } , error : function ( xhr , text_status , error_thrown ) { if ( 'parsererror' === error_thrown ) { dataimport_element . addClass ( 'error' ) ; error_element . text ( 'Dataimport XML-Configuration is not valid' ) . show ( ) ; config_element . removeClass ( 'hidden' ) ; } } , complete : function ( xhr , text_status ) { var code = $ ( '<pre class="syntax language-xml"><code>' + xhr . responseText . esc ( ) + '</code></pre>' ) ; $ ( '.formatted' , this ) . html ( code ) ; if ( 'success' === text_status ) { hljs . highlightBlock ( code . get ( 0 ) ) ; } } } ) ; } 
function ( loadedFrame , element ) { var response , responseStr = loadedFrame . contentWindow . document . body . innerHTML ; try { 
function ( element ) { 
function fileUpload ( ) { var form = $form [ 0 ] ; if ( $ ( ':input[name=submit],:input[id=submit]' , form ) . length ) { 
function doSubmit ( ) { 
function log ( ) { if ( $ . fn . ajaxSubmit . debug ) { var msg = '[jquery.form] ' + Array . prototype . join . call ( arguments , '' ) ; if ( window . console && window . console . log ) { window . console . log ( msg ) ; } else if ( window . opera && window . opera . postError ) { window . opera . postError ( msg ) ; } } } 
function ( status ) { var hc_button = $ ( '.healthcheck-status' ) if ( status == 'enable' ) { hc_button . parents ( 'dd' ) . removeClass ( 'ico-0' ) . addClass ( 'ico-1' ) ; hc_button . addClass ( 'enabled' ) . html ( 'disable ping' ) ; } else { hc_button . parents ( 'dd' ) . removeClass ( 'ico-1' ) . addClass ( 'ico-0' ) ; hc_button . removeClass ( 'enabled' ) . html ( 'enable ping' ) ; } } 
function AppClient ( URL , options ) { if ( ! ( this instanceof AppClient ) ) { return new AppClient ( URL , options ) ; } options = options || { } ; 
function writeTobuffer ( value , buffer ) { write ( buffer , value , OFFSET , LITTLE_ENDIAN , MANTISSA_LENGTH , NUMBER_OF_BYTES ) ; } 
function buf2hex ( buffer , options = { prefix : true } ) { var hex = Array . prototype . map . call ( new Uint8Array ( buffer ) , x => ( '00' + x . toString ( 16 ) ) . slice ( - 2 ) ) . join ( '' ) ; return options . prefix === true ? ` ${ hex } ` : hex ; } 
function num2hex ( value , options ) { if ( value === undefined ) throw new Error ( 'Value is undefined' ) ; var buffer = Buffer . alloc ( NUMBER_OF_BYTES ) ; writeTobuffer ( value , buffer ) ; return buf2hex ( buffer , options ) ; } 
function hex2num ( value ) { if ( value === undefined ) throw new Error ( 'Value is undefined' ) ; var buffer = hex2buf ( value ) ; return readFromBuffer ( buffer ) ; } 
function ( ) { var f = $ . jstree . _focused ( ) ; if ( f && f !== this ) { f . get_container ( ) . removeClass ( "jstree-focused" ) ; } if ( f !== this ) { this . get_container ( ) . addClass ( "jstree-focused" ) ; focused_instance = this . get_index ( ) ; } this . __callback ( ) ; } 
function ( obj , callback , skip_animation ) { obj = this . _get_node ( obj ) ; if ( ! obj . length ) { return false ; } if ( ! obj . hasClass ( "jstree-closed" ) ) { if ( callback ) { callback . call ( ) ; } return false ; } var s = skip_animation || is_ie6 ? 0 : this . _get_settings ( ) . core . animation , t = this ; if ( ! this . _is_loaded ( obj ) ) { obj . children ( "a" ) . addClass ( "jstree-loading" ) ; this . load_node ( obj , function ( ) { t . open_node ( obj , callback , skip_animation ) ; } , callback ) ; } else { if ( s ) { obj . children ( "ul" ) . css ( "display" , "none" ) ; } obj . removeClass ( "jstree-closed" ) . addClass ( "jstree-open" ) . children ( "a" ) . removeClass ( "jstree-loading" ) ; if ( s ) { obj . children ( "ul" ) . stop ( true ) . slideDown ( s , function ( ) { this . style . display = "" ; } ) ; } this . __callback ( { "obj" : obj } ) ; if ( callback ) { callback . call ( ) ; } } } 
function ( obj , position , js , callback , is_loaded ) { obj = this . _get_node ( obj ) ; position = typeof position === "undefined" ? "last" : position ; var d = $ ( "<li>" ) , s = this . _get_settings ( ) . core , tmp ; if ( obj !== - 1 && ! obj . length ) { return false ; } if ( ! is_loaded && ! this . _is_loaded ( obj ) ) { this . load_node ( obj , function ( ) { this . create_node ( obj , position , js , callback , true ) ; } ) ; return false ; } this . __rollback ( ) ; if ( typeof js === "string" ) { js = { "data" : js } ; } if ( ! js ) { js = { } ; } if ( js . attr ) { d . attr ( js . attr ) ; } if ( js . state ) { d . addClass ( "jstree-" + js . state ) ; } if ( ! js . data ) { js . data = s . strings . new_node ; } if ( ! $ . isArray ( js . data ) ) { tmp = js . data ; js . data = [ ] ; js . data . push ( tmp ) ; } $ . each ( js . data , function ( i , m ) { tmp = $ ( "<a>" ) ; if ( $ . isFunction ( m ) ) { m = m . call ( this , js ) ; } if ( typeof m == "string" ) { tmp . attr ( 'href' , '#' ) [ s . html_titles ? "html" : "text" ] ( m ) ; } else { if ( ! m . attr ) { m . attr = { } ; } if ( ! m . attr . href ) { m . attr . href = '#' ; } tmp . attr ( m . attr ) [ s . html_titles ? "html" : "text" ] ( m . title ) ; if ( m . language ) { tmp . addClass ( m . language ) ; } } tmp . prepend ( "<ins class='jstree-icon'>&#160;</ins>" ) ; if ( m . icon ) { if ( m . icon . indexOf ( "/" ) === - 1 ) { tmp . children ( "ins" ) . addClass ( m . icon ) ; } else { tmp . children ( "ins" ) . css ( "background" , "url('" + m . icon + "') center center no-repeat" ) ; } } d . append ( tmp ) ; } ) ; d . prepend ( "<ins class='jstree-icon'>&#160;</ins>" ) ; if ( obj === - 1 ) { obj = this . get_container ( ) ; if ( position === "before" ) { position = "first" ; } if ( position === "after" ) { position = "last" ; } } switch ( position ) { case "before" : obj . before ( d ) ; tmp = this . _get_parent ( obj ) ; break ; case "after" : obj . after ( d ) ; tmp = this . _get_parent ( obj ) ; break ; case "inside" : case "first" : if ( ! obj . children ( "ul" ) . length ) { obj . append ( "<ul>" ) ; } obj . children ( "ul" ) . prepend ( d ) ; tmp = obj ; break ; case "last" : if ( ! obj . children ( "ul" ) . length ) { obj . append ( "<ul>" ) ; } obj . children ( "ul" ) . append ( d ) ; tmp = obj ; break ; default : if ( ! obj . children ( "ul" ) . length ) { obj . append ( "<ul>" ) ; } if ( ! position ) { position = 0 ; } tmp = obj . children ( "ul" ) . children ( "li" ) . eq ( position ) ; if ( tmp . length ) { tmp . before ( d ) ; } else { obj . children ( "ul" ) . append ( d ) ; } tmp = obj ; break ; } if ( tmp === - 1 || tmp . get ( 0 ) === this . get_container ( ) . get ( 0 ) ) { tmp = - 1 ; } this . clean_node ( tmp ) ; this . __callback ( { "obj" : d , "parent" : tmp } ) ; if ( callback ) { callback . call ( this , d ) ; } return d ; } 
function ( obj ) { obj = this . _get_node ( obj ) ; if ( ! obj . length ) { return false ; } this . __rollback ( ) ; var p = this . _get_parent ( obj ) , prev = this . _get_prev ( obj ) ; obj = obj . remove ( ) ; if ( p !== - 1 && p . find ( "> ul > li" ) . length === 0 ) { p . removeClass ( "jstree-open jstree-closed" ) . addClass ( "jstree-leaf" ) ; } this . clean_node ( p ) ; this . __callback ( { "obj" : obj , "prev" : prev } ) ; return obj ; } 
function ( ) { var json = { } ; $ . each ( this , function ( k , v ) { if ( ! _isFunction ( v ) ) { json [ k ] = v ; } } ) ; return json ; } 
function ( ) { var display = "" ; $ . each ( this , function ( k , v ) { if ( ! _isFunction ( v ) ) { display += "<strong>" + k + "</strong> " + v + "<br />" ; } } ) ; return display ; } 
function ( attributes_only ) { var keys = [ ] ; for ( var property in this ) { if ( ! _isFunction ( this [ property ] ) || ! attributes_only ) { keys . push ( property ) ; } } return keys ; } 
function ( include_functions ) { var s = [ ] ; $ . each ( this , function ( k , v ) { if ( ! _isFunction ( v ) || include_functions ) { s . push ( '"' + k + '": ' + v . toString ( ) ) ; } } ) ; return "Sammy.Object: {" + s . join ( ',' ) + "}" ; } 
function ( ) { var proxy = this , app = this . app ; $ ( window ) . bind ( 'hashchange.' + this . app . eventNamespace ( ) , function ( e , non_native ) { 
function ( ) { $ ( window ) . unbind ( 'hashchange.' + this . app . eventNamespace ( ) ) ; Sammy . HashLocationProxy . _bindings -- ; if ( Sammy . HashLocationProxy . _bindings <= 0 ) { window . clearInterval ( Sammy . HashLocationProxy . _interval ) ; } } 
function ( ) { 
function ( new_proxy ) { var original_proxy = this . _location_proxy ; this . _location_proxy = new_proxy ; if ( this . isRunning ( ) ) { if ( original_proxy ) { 
function ( verb , path , callback ) { var app = this , param_names = [ ] , add_route , path_match ; 
function ( route_array ) { var app = this ; $ . each ( route_array , function ( i , route_args ) { app . route . apply ( app , route_args ) ; } ) ; return this ; } 
function ( name , data , callback ) { var app = this ; 
function ( options , callback ) { if ( _isFunction ( options ) ) { callback = options ; options = { } ; } this . befores . push ( [ options , callback ] ) ; return this ; } 
function ( start_url ) { if ( this . isRunning ( ) ) { return false ; } var app = this ; this.bind('submit', function(e) { var returned = app._checkFormSubmission($(e.target).closest('form')); return (returned === false) ? e.preventDefault() : false; }); */ 
function ( ) { if ( ! this . isRunning ( ) ) { return false ; } var app = this ; this . trigger ( 'unload' ) ; 
function ( callback ) { var app = this ; 
function ( verb , path ) { var app = this , routed = false ; this . trigger ( 'lookup-route' , { verb : verb , path : path } ) ; if ( typeof this . routes [ verb ] != 'undefined' ) { $ . each ( this . routes [ verb ] , function ( i , route ) { if ( app . routablePath ( path ) . match ( route . path ) ) { routed = route ; return false ; } } ) ; } return routed ; } 
function ( verb , path , params , target ) { var app = this , route = this . lookupRoute ( verb , path ) , context , wrapped_route , arounds , around , befores , before , callback_args , path_params , final_returned ; this . log ( 'runRoute' , [ verb , path ] . join ( ' ' ) ) ; this . trigger ( 'run-route' , { verb : verb , path : path , params : params } ) ; if ( typeof params == 'undefined' ) { params = { } ; } $ . extend ( params , this . _parseQueryString ( path ) ) ; if ( route ) { this . trigger ( 'route-found' , { route : route } ) ; 
function ( context , match_options , positive ) { 
function ( verb , path ) { var ret = this . error ( [ '404 Not Found' , verb , path ] . join ( ' ' ) ) ; return ( verb === 'get' ) ? ret : true ; } 
function ( message , original_error ) { if ( ! original_error ) { original_error = new Error ( ) ; } original_error . message = [ message , original_error . message ] . join ( ' ' ) ; this . trigger ( 'error' , { message : original_error . message , error : original_error } ) ; if ( this . raise_errors ) { throw ( original_error ) ; } else { this . log ( original_error . message , original_error ) ; } } 
function ( callback ) { if ( ! _isFunction ( callback ) ) { 
function ( content ) { this . waiting = false ; if ( typeof content !== 'undefined' ) { this . previous_content = this . content ; this . content = content ; } if ( this . callbacks . length > 0 ) { this . then ( this . callbacks . shift ( ) ) ; } } 
function ( location , options , callback ) { var context = this ; return this . then ( function ( ) { var should_cache , cached , is_json , location_array ; if ( _isFunction ( options ) ) { callback = options ; options = { } ; } else { options = $ . extend ( { } , options ) ; } if ( callback ) { this . then ( callback ) ; } if ( typeof location === 'string' ) { 
function ( location , data , callback ) { if ( _isFunction ( location ) && ! data ) { return this . then ( location ) ; } else { if ( ! data && this . content ) { data = this . content ; } return this . load ( location ) . interpolate ( data , location ) . then ( callback ) ; } } 
function ( ) { var context = this , args = _makeArray ( arguments ) , fun = args . shift ( ) ; if ( _isArray ( args [ 0 ] ) ) { args = args [ 0 ] ; } return this . then ( function ( content ) { args . push ( function ( response ) { context . next ( response ) ; } ) ; context . wait ( ) ; fun . apply ( fun , args ) ; return false ; } ) ; } 
function ( array , callback , now ) { var context = this ; var coll = function ( ) { if ( _isFunction ( array ) ) { callback = array ; array = this . content ; } var contents = [ ] , doms = false ; $ . each ( array , function ( i , item ) { var returned = callback . apply ( context , [ i , item ] ) ; if ( returned . jquery && returned . length == 1 ) { returned = returned [ 0 ] ; doms = true ; } contents . push ( returned ) ; return returned ; } ) ; return doms ? contents : contents . join ( '' ) ; } ; return now ? coll ( ) : this . then ( coll ) ; } 
function ( location , name , data , callback ) { if ( _isArray ( name ) ) { callback = data ; data = name ; name = null ; } return this . load ( location ) . then ( function ( content ) { var rctx = this ; if ( ! data ) { data = _isArray ( this . previous_content ) ? this . previous_content : [ ] ; } if ( callback ) { $ . each ( data , function ( i , value ) { var idata = { } , engine = this . next_engine || location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; callback ( value , rctx . event_context . interpolate ( content , idata , engine ) ) ; } ) ; } else { return this . collect ( data , function ( i , value ) { var idata = { } , engine = this . next_engine || location ; name ? ( idata [ name ] = value ) : ( idata = value ) ; return this . event_context . interpolate ( content , idata , engine ) ; } , true ) ; } } ) ; } 
function ( name , data ) { return this . then ( function ( content ) { if ( typeof data == 'undefined' ) { data = { content : content } ; } this . event_context . trigger ( name , data ) ; } ) ; } 
function ( engine ) { var context = this , engine_match ; 
function ( location , name , data , callback ) { return new Sammy . RenderContext ( this ) . renderEach ( location , name , data , callback ) ; } 
function ( ) { var to , args = _makeArray ( arguments ) , current_location = this . app . getLocation ( ) ; if ( args . length > 1 ) { args . unshift ( '/' ) ; to = this . join . apply ( this , args ) ; } else { to = args [ 0 ] ; } this . trigger ( 'redirect' , { to : to } ) ; this . app . last_location = [ this . verb , this . path ] ; this . app . setLocation ( to ) ; if ( current_location == to ) { this . app . trigger ( 'location-changed' ) ; } } 
function ( name , data ) { if ( typeof data == 'undefined' ) { data = { } ; } if ( ! data . context ) { data . context = this ; } return this . app . trigger ( name , data ) ; } 
function ( partialPath , locals ) { var normalizedPartialPath = normalizeTemplatePath ( partialPath , path . dirname ( normalizedTemplatePath ) ) ; return exports . compile ( normalizedPartialPath ) ( locals ) ; } 
function ( type , content , textAfter , state ) { if ( this . jsonMode ) { return / ^[\[,{]$ / . test ( content ) || / ^} / . test ( textAfter ) ; } else { if ( content == ";" && state . lexical && state . lexical . type == ")" ) return false ; return / ^[;{}]$ / . test ( content ) && ! / ^; / . test ( textAfter ) ; } } 
function scanForBracket ( cm , where , dir , style , config ) { var maxScanLen = ( config && config . maxScanLineLength ) || 10000 ; var maxScanLines = ( config && config . maxScanLines ) || 1000 ; var stack = [ ] ; var re = config && config . bracketRegex ? config . bracketRegex : / [(){}[\]] / ; var lineEnd = dir > 0 ? Math . min ( where . line + maxScanLines , cm . lastLine ( ) + 1 ) : Math . max ( cm . firstLine ( ) - 1 , where . line - maxScanLines ) ; for ( var lineNo = where . line ; lineNo != lineEnd ; lineNo += dir ) { var line = cm . getLine ( lineNo ) ; if ( ! line ) continue ; var pos = dir > 0 ? 0 : line . length - 1 , end = dir > 0 ? line . length : - 1 ; if ( line . length > maxScanLen ) continue ; if ( lineNo == where . line ) pos = where . ch - ( dir < 0 ? 1 : 0 ) ; for ( ; pos != end ; pos += dir ) { var ch = line . charAt ( pos ) ; if ( re . test ( ch ) && ( style === undefined || cm . getTokenTypeAt ( Pos ( lineNo , pos + 1 ) ) == style ) ) { var match = matching [ ch ] ; if ( ( match . charAt ( 1 ) == ">" ) == ( dir > 0 ) ) stack . push ( ch ) ; else if ( ! stack . length ) return { pos : Pos ( lineNo , pos ) , ch : ch } ; else stack . pop ( ) ; } } } return lineNo - dir == ( dir > 0 ? cm . lastLine ( ) : cm . firstLine ( ) ) ? false : null ; } 
function enteringString ( cm , pos , ch ) { var line = cm . getLine ( pos . line ) ; var token = cm . getTokenAt ( pos ) ; if ( / \bstring2?\b / . test ( token . type ) ) return false ; var stream = new CodeMirror . StringStream ( line . slice ( 0 , pos . ch ) + ch + line . slice ( pos . ch ) , 4 ) ; stream . pos = stream . start = token . start ; for ( ; ; ) { var type1 = cm . getMode ( ) . token ( stream , token . state ) ; if ( stream . pos >= pos . ch + 1 ) return / \bstring2?\b / . test ( type1 ) ; stream . start = stream . pos ; } } 
function Yr ( a , b ) { this . je = [ ] ; this . Lf = a ; this . Af = b || null ; this . Bd = this . Wc = ! 1 ; this . dc = void 0 ; this . Ye = this . Zf = this . ue = ! 1 ; this . me = 0 ; this . Va = null ; this . ve = 0 ; } 
function push ( type , packet ) { let msg = { 'type' : type != null ? 'results' : 'other' , 'value' : type , 'data' : packet . data ( ) } ; 
function resolve ( paths ) { paths = Array . isArray ( paths ) ? paths : [ paths ] ; var fullPath = path . resolve . apply ( this , paths ) . replace ( / \\ / g , '/' ) ; return { fullPath : fullPath , dirName : path . dirname ( fullPath ) , fileName : path . basename ( fullPath ) , extName : path . extname ( fullPath ) . replace ( '.' , '' ) } ; } 
function existsOrCreate ( filePath , opts , cb ) { if ( arguments . length === 2 ) { cb = arguments [ 1 ] ; opts = { } ; } opts . encoding = opts . encoding || 'utf8' ; opts . data = opts . data || opts . content || '' ; opts . mode = opts . mode || '0777' ; opts . replace = opts . replace ? true : false ; var fp = resolve ( filePath ) ; var isFile = opts . hasOwnProperty ( 'isFile' ) ? opts . isFile : ! ! fp . extName ; fs . exists ( fp . fullPath , function ( exists ) { if ( exists && ! opts . replace ) cb ( null , exists ) ; else { 
function existsOrCreateSync ( filePath , opts ) { opts = opts || { } ; opts . encoding = opts . encoding || 'utf8' ; opts . data = opts . data || opts . content || '' ; opts . mode = opts . mode || '0777' ; var fp = resolve ( filePath ) ; var isFile = opts . hasOwnProperty ( 'isFile' ) ? opts . isFile : ! ! fp . extName ; var exists = fs . existsSync ( fp . fullPath ) ; if ( ! exists || opts . replace ) { mkdir ( ( isFile ? fp . dirName : fp . fullPath ) ) ; if ( isFile || opts . replace ) fs . writeFileSync ( fp . fullPath , opts . data , opts . encoding ) ; } function mkdir ( fullPath ) { if ( fs . existsSync ( fullPath ) ) return ; else { var parentPath = fullPath . split ( '/' ) ; parentPath . pop ( ) ; mkdir ( parentPath . join ( '/' ) ) ; fs . mkdirSync ( fullPath , opts . mode ) ; } } return exists ; } 
function unwatch ( filePath ) { filePath = path . resolve ( filePath ) ; if ( _fileWatchers [ filePath ] ) _fileWatchers [ filePath ] . close ( ) ; delete _fileWatchers [ filePath ] ; } 
function unwatchAll ( ) { for ( var filePath in _fileWatchers ) { if ( _fileWatchers [ filePath ] ) _fileWatchers [ filePath ] . close ( ) ; delete _fileWatchers [ filePath ] ; } for ( var dirPath in _dirWatchers ) { if ( _dirWatchers [ dirPath ] ) _dirWatchers [ dirPath ] . close ( ) ; delete _dirWatchers [ dirPath ] ; } } 
function requireAsync ( filePath , opts , cb ) { if ( arguments . length === 2 ) { cb = arguments [ 1 ] ; opts = { } ; } filePath = path . resolve ( filePath ) ; opts . encoding = opts . encoding || 'utf8' ; 
function checkExistsName ( filePath , isDir , callback , count ) { 
function writeFile ( filePath , data , callback , count ) { 
function readFile ( filePath , opts , callback , count ) { 
function readFileLine ( filepath , opts , dataCb , completeCb ) { if ( typeof arguments [ 0 ] !== 'string' ) { completeCb = arguments [ 2 ] ; dataCb = arguments [ 1 ] ; opts = arguments [ 0 ] ; filepath = opts . file || opts . filename || opts . filepath ; } filepath = resolve ( filepath ) . fullPath ; opts = opts || { } ; var chunkSize = opts . chunkSize || 1 ; var hasHeader = opts . header || opts . headers || opts . hasHeader ; var headLine ; var instream = fs . createReadStream ( filepath , opts ) ; var outstream = new Stream ( ) ; var rl = readline . createInterface ( instream , outstream ) ; var onLines = dataCb || opts . onLine || opts . onLines || opts . onData ; var onClose = completeCb || opts . onClose || opts . onComplete ; var done = dataCb || completeCb ; instream . on ( 'error' , function ( err ) { rl . closed = true ; rl . close ( ) ; if ( done ) done ( err ) ; else throw err ; } ) ; opts . separator = opts . separator || opts . delimiter ; var lineParser = opts . lineParser || function ( line ) { if ( ! opts . separator ) return line ; return line . split ( opts . separator ) ; } ; var nextChunk = chunkSize ; var chunkData = [ ] ; var lineError ; var index = - 1 ; 
function fileLineReader ( filepath , opts ) { if ( typeof arguments [ 0 ] !== 'string' ) { opts = arguments [ 0 ] ; filepath = opts . file || opts . filename || opts . filepath ; } filepath = resolve ( filepath ) . fullPath ; opts = opts || { } ; var chunkSize = opts . chunkSize || 1 ; var hasHeader = opts . header || opts . headers || opts . hasHeader ; var headLine ; var instream = fs . createReadStream ( filepath , opts ) ; var outstream = new Stream ( ) ; var rl = readline . createInterface ( instream , outstream ) ; var onData ; var done ; instream . on ( 'error' , function ( err ) { rl . closed = true ; rl . close ( ) ; if ( done ) done ( err ) ; else throw err ; } ) ; opts . separator = opts . separator || opts . delimiter ; var lineParser = opts . lineParser || function ( line ) { if ( ! opts . separator ) return line ; return line . split ( opts . separator ) ; } ; var lines = [ ] ; var lineError ; var index = - 1 ; var limit = 1 ; function getLines ( numOfLines , cb ) { if ( arguments . length === 0 ) cb = arguments [ 0 ] ; if ( typeof cb !== 'function' ) throw new Error ( 'Wrong arguments' ) ; done = cb ; index = index === - 1 ? - 1 : 0 ; limit = numOfLines || 1 ; var result ; if ( lines . length === 0 ) index = - 1 ; 
function rmdirRecursive ( dir , clbk ) { dir = resolve ( dir ) . fullPath ; if ( clbk === null || typeof clbk === 'undefined' ) clbk = function ( err ) { } ; fs . readdir ( dir , function ( err , files ) { if ( err ) return clbk ( err ) ; if ( ! files ) return clbk ( new Error ( 'fsExt.rmdirRecursive: removing folders failed, folder not exists' ) ) ; ( function rmFile ( err ) { if ( err ) return clbk ( err ) ; var filename = files . shift ( ) ; if ( filename === null || typeof filename === 'undefined' ) return fs . rmdir ( dir , clbk ) ; var file = dir + '/' + filename ; fs . lstat ( file , function ( err , stat ) { if ( err ) return clbk ( err ) ; if ( stat . isDirectory ( ) ) rmdirRecursive ( file , rmFile ) ; else fs . unlink ( file , rmFile ) ; } ) ; } ) ( ) ; } ) ; } 
function walk ( dir , opts , done , rootDir , level ) { 
function getFileInfo ( fileId , filePath , cb , repeated ) { 
function getPathAncestors ( filename ) { var tree = filename . split ( '/' ) ; tree . pop ( ) ; 
function getName ( fileId , isFile ) { var splitted = fileId . split ( '/' ) ; 
function getExt ( filename ) { var splitted = filename . split ( '.' ) ; if ( splitted . length === 1 ) return '' ; 
function getFileItem ( fileId , stat , filePath ) { return { id : fileId , fullPath : filePath , name : getName ( fileId , ! stat . isDirectory ( ) ) , ancestors : getPathAncestors ( fileId ) , isDir : stat . isDirectory ( ) , isFile : ! stat . isDirectory ( ) , ext : ! stat . isDirectory ( ) ? getExt ( fileId ) : null , modifiedDT : stat . mtime , 
function watchRecursive ( dir , opts , onChange , cb , repeated ) { 
function getDirChildren ( parentId , items ) { var children = { } ; for ( var id in items ) { if ( items [ id ] . ancestors [ items [ id ] . ancestors . length - 1 ] === parentId ) children [ id ] = items [ id ] ; } return children ; } 
function compareDirFiles ( parentId , old_children , descendants ) { var changes = [ ] , not_found = object . extend ( { } , old_children ) ; for ( var id in descendants ) { if ( descendants [ id ] . ancestors [ descendants [ id ] . ancestors . length - 1 ] === parentId ) { 
function FastDom ( ) { var self = this ; self . reads = [ ] ; self . writes = [ ] ; self . raf = requestAnimationFrame$1 . bind ( window ) ; 
function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . reads . push ( task ) ; scheduleFlush ( this ) ; return task ; } 
function ( fn , ctx ) { var task = ! ctx ? fn : fn . bind ( ctx ) ; this . writes . push ( task ) ; scheduleFlush ( this ) ; return task ; } 
function ( props ) { if ( typeof props != 'object' ) { throw new Error ( 'expected object' ) ; } var child = Object . create ( this ) ; mixin ( child , props ) ; child . fastdom = this ; 
function scheduleFlush ( fastdom ) { if ( ! fastdom . scheduled ) { fastdom . scheduled = true ; fastdom . raf ( flush . bind ( null , fastdom ) ) ; } } 
function flush ( fastdom ) { var reads = fastdom . reads . splice ( 0 , fastdom . reads . length ) , writes = fastdom . writes . splice ( 0 , fastdom . writes . length ) , error ; try { runTasks ( reads ) ; runTasks ( writes ) ; } catch ( e ) { error = e ; } fastdom . scheduled = false ; 
function doCallEndpoint ( callSpec , next , onReceive , onError , store ) { const { method , path , urlParams , body , token , baseUrl } = callSpec return apiFetch ( compileUrl ( path , urlParams ) , { ... fetchOptions ( method , body , token ) , baseUrl } ) . then ( response => 
function create ( props ) { var knob = Object . create ( this ) ; 
function draw ( ) { 
function processPointerPosition ( e ) { var xOffset = e . clientX , yOffset = e . clientY ; var radius = this . rect . width / 2 ; this . lastValue = this . value ; if ( ! this . usesRotation ) { if ( this . lastPosition !== - 1 ) { 
function setContextValue ( setChainContext , chainId , name , value ) { if ( value instanceof Function ) { throw new FunctionAsValueException ( ) ; } setChainContext ( chainId , name , value ) ; } 
function recurse ( node ) { 
function ( url , prev , done ) { if ( url . indexOf ( 'bootstrap/' ) === 0 ) { var component = url . substr ( 'bootstrap/' . length + 1 ) ; var file = cmsDir + '/src/scss/bootstrap/_' + component + '.scss' ; try { var stats = fs . lstatSync ( file ) ; if ( stats . isFile ( ) ) { return { file : file } ; } } catch ( ex ) { 
function formatDate ( date , format ) { format = format + '' ; var result = '' ; var i_format = 0 ; var c = '' ; var token = '' ; var y = date . getYear ( ) + '' ; var M = date . getMonth ( ) + 1 ; var d = date . getDate ( ) ; var E = date . getDay ( ) ; var H = date . getHours ( ) ; var m = date . getMinutes ( ) ; var s = date . getSeconds ( ) ; var yyyy , yy , MMM , MM , dd , hh , h , mm , ss , ampm , HH , H , KK , K , kk , k ; 
function getDateFromFormat ( val , format ) { val = val + '' ; format = format + '' ; var i_val = 0 ; var i_format = 0 ; var c = '' ; var token = '' ; var token2 = '' ; var x , y ; var now = new Date ( 0 ) ; var year = now . getYear ( ) ; var month = now . getMonth ( ) + 1 ; var date = 1 ; var hh = now . getHours ( ) ; var mm = now . getMinutes ( ) ; var ss = now . getSeconds ( ) ; var ampm = '' ; while ( i_format < format . length ) { 
function _isInteger ( val ) { var digits = '1234567890' ; for ( var i = 0 ; i < val . length ; i ++ ) { if ( digits . indexOf ( val . charAt ( i ) ) === - 1 ) { return false ; } } return true ; } 
function streamToBuffer ( stream , cb ) { 
function Bucks ( params ) { this . _tasks = [ ] ; this . _taskcount = 0 ; this . _results = [ ] ; this . callback = none ; this . failure = none ; this . _alive = true ; this . _interrupt = false ; this . __id = uid ( ) ; Bucks . living [ this . __id ] = this ; this . initialize ( params ) ; } 
function _normalizeTask ( task ) { var _task = task ; if ( task . length < 3 ) { _task = function _task ( err , res , next ) { 
function _normalizeSuccess ( onSuccess ) { var _onSuccess = onSuccess ; if ( onSuccess . length < 2 ) { _onSuccess = function ( res , next ) { var result = onSuccess ( res ) ; next ( null , result ) ; } ; } else if ( onSuccess . length === 2 ) { _onSuccess = onSuccess ; } else { throw new Error ( 'args length invalid' ) ; } return _onSuccess ; } 
function _normalizeError ( onError ) { var _onError = onError ; if ( onError . length < 2 || 3 < onError . length ) { throw new Error ( onError . name + ': args length invalid. should be: onError(err, next)' ) ; } return _onError ; } 
function add ( task ) { if ( ! this . _alive ) { throw new Error ( 'this bucks object already destroyed.' ) ; } var _task = this . _normalizeTask ( task ) ; this . _tasks . push ( _task ) ; return this ; } 
function then ( onSuccess ) { var _onSuccess = this . _normalizeSuccess ( onSuccess ) ; return this . add ( function onSuccessTask ( err , res , next ) { if ( err ) { 
function error ( onError ) { var _onError = this . _normalizeError ( onError ) ; return this . add ( function onErrorTask ( err , res , next ) { if ( err ) { 
function _iterator ( err , res ) { if ( this . _interrupt ) { return this ; } if ( ! this . _alive ) { throw new Error ( 'this bucks object already destroyed.' ) ; } 
function parallel ( tasks ) { if ( ! isArray ( tasks ) ) { throw new Error ( 'tasks is not array.' ) ; } if ( isArrayEmpty ( tasks ) ) { return this . add ( function passEmpty ( err , res , next ) { next ( null , new ParallelHandler ( 0 ) . resultObj ) ; } ) ; } 
function waterfall ( tasks ) { if ( ! isArray ( tasks ) ) { throw new Error ( 'tasks is not array.' ) ; } if ( isArrayEmpty ( tasks ) ) { return this . add ( function passEmpty ( err , res , next ) { next ( null , [ ] ) ; } ) ; } 
function delay ( ms ) { return this . add ( function ( err , res , next ) { setTimeout ( function ( ) { next ( err , res ) ; } , ms || 0 ) ; } ) ; } 
function destroy ( err ) { if ( ! this . _alive ) { return this ; } var ress = this . _results ; var callback = this . callback ; var failure = this . failure ; var dispose = this . dispose ; this . _tasks = null ; this . _taskcount = 0 ; this . _results = null ; this . callback = none ; this . failure = none ; this . dispose = none ; 
function end ( callback , errback ) { if ( callback && callback . length < 1 ) { 
function successOne ( idx , err , res ) { this . _errors [ idx ] = err ; this . _results [ idx ] = res ; this . _waiting -- ; if ( this . _waiting <= 0 ) { this . _onFinish . call ( null , this . resultObj ) ; } } 
function ( e ) { var delta = e . loaded - progressBefore ; bar . value += delta ; progressBefore = e . loaded ; } 
function cached ( opt ) { if ( typeof opt == 'undefined' || opt === null ) opt = { } ; if ( typeof opt == 'string' ) opt = { type : opt } ; if ( typeof opt . id != 'string' ) opt . id = _random_string ( 8 ) ; opt = Object . assign ( { } , getSettings ( ) , opt ) ; for ( var i in opt ) checkSetting ( i , opt [ i ] ) ; return function ( func , key , descriptor ) { if ( key ) func = func [ key ] ; 
function ( ... rest ) { const _key = _hash ( rest , opt . id ) ; return cacheObj . get ( opt , _key ) . then ( res => { if ( typeof res == 'undefined' || res === null ) { res = _update . bind ( this ) ( opt , func , rest ) ; } return res ; } ) ; } 
function getChain ( storage , name ) { if ( storage [ GET_CHAIN_METHOD ] ) { return storage [ GET_CHAIN_METHOD ] ( name ) ; } var chain = Object . assign ( { } , storage [ name ] ) ; chain [ '$chainId' ] = ( 0 , _Util . generateUUID ) ( ) ; return Object . assign ( { } , chain ) ; } 
function getChainDataById ( storage , chainId ) { if ( storage [ GET_CHAIN_METHOD ] ) { return storage [ GET_CHAIN_METHOD ] ( chainId ) ; } return storage [ chainId ] ; } 
function getChainContext ( storage , chainId , field ) { if ( storage [ GET_CHAIN_CONTEXT_METHOD ] ) { return storage [ GET_CHAIN_CONTEXT_METHOD ] ( chainId , field ) ; } if ( storage [ chainId ] ) { return storage [ chainId ] [ field ] ; } } 
function create ( props ) { var multiButton = Object . create ( this ) ; _canvasWidget2 . default . create . call ( multiButton ) ; Object . assign ( multiButton , MultiButton . defaults , props ) ; if ( props . value ) { multiButton . __value = props . value ; } else { multiButton . __value = [ ] ; for ( var i = 0 ; i < multiButton . count ; i ++ ) { multiButton . __value [ i ] = 0 ; } multiButton . value = [ ] ; } multiButton . active = { } ; multiButton . __prevValue = [ ] ; multiButton . init ( ) ; return multiButton ; } 
function draw ( ) { this . ctx . fillStyle = this . __value === 1 ? this . fill : this . background ; this . ctx . strokeStyle = this . stroke ; this . ctx . lineWidth = this . lineWidth ; var buttonWidth = this . rect . width / this . columns , buttonHeight = this . rect . height / this . rows ; for ( var row = 0 ; row < this . rows ; row ++ ) { var y = row * buttonHeight ; for ( var column = 0 ; column < this . columns ; column ++ ) { var x = column * buttonWidth , _buttonNum = row * this . columns + column ; this . ctx . fillStyle = this . __value [ _buttonNum ] === 1 ? this . fill : this . background ; this . ctx . fillRect ( x , y , buttonWidth , buttonHeight ) ; this . ctx . strokeRect ( x , y , buttonWidth , buttonHeight ) ; } } } 
function mkSprite ( srcFiles , destImage , options , callback ) { options . src = srcFiles , grunt . verbose . writeln ( 'Options passed to Spritesmth:' , JSON . stringify ( options ) ) ; spritesmith ( options , function ( err , result ) { 
function isHostObject$1 ( value ) { 
function isPlainObject ( value ) { if ( ! isObjectLike$1 ( value ) || objectToString$1 . call ( value ) != objectTag || isHostObject$1 ( value ) ) { return false ; } var proto = getPrototype ( value ) ; if ( proto === null ) { return true ; } var Ctor = hasOwnProperty$1 . call ( proto , 'constructor' ) && proto . constructor ; return ( typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$1 . call ( Ctor ) == objectCtorString ) ; } 
function isHostObject$2 ( value ) { 
function Hash$1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function hashGet$1 ( key ) { var data = this . __data__ ; if ( nativeCreate$1 ) { var result = data [ key ] ; return result === HASH_UNDEFINED$1 ? undefined : result ; } return hasOwnProperty$2 . call ( data , key ) ? data [ key ] : undefined ; } 
function hashHas$1 ( key ) { var data = this . __data__ ; return nativeCreate$1 ? data [ key ] !== undefined : hasOwnProperty$2 . call ( data , key ) ; } 
function hashSet$1 ( key , value ) { var data = this . __data__ ; data [ key ] = ( nativeCreate$1 && value === undefined ) ? HASH_UNDEFINED$1 : value ; return this ; } 
function ListCache$1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function listCacheDelete$1 ( key ) { var data = this . __data__ , index = assocIndexOf$1 ( data , key ) ; if ( index < 0 ) { return false ; } var lastIndex = data . length - 1 ; if ( index == lastIndex ) { data . pop ( ) ; } else { splice$1 . call ( data , index , 1 ) ; } return true ; } 
function listCacheGet$1 ( key ) { var data = this . __data__ , index = assocIndexOf$1 ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function listCacheSet$1 ( key , value ) { var data = this . __data__ , index = assocIndexOf$1 ( data , key ) ; if ( index < 0 ) { data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function MapCache$1 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assocIndexOf$1 ( array , key ) { var length = array . length ; while ( length -- ) { if ( eq$1 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function baseIsNative$1 ( value ) { if ( ! isObject$1 ( value ) || isMasked$1 ( value ) ) { return false ; } var pattern = ( isFunction$1 ( value ) || isHostObject$2 ( value ) ) ? reIsNative$1 : reIsHostCtor$1 ; return pattern . test ( toSource$1 ( value ) ) ; } 
function baseToString$1 ( value ) { 
function getMapData$1 ( map , key ) { var data = map . __data__ ; return isKeyable$1 ( key ) ? data [ typeof key == 'string' ? 'string' : 'hash' ] : data . map ; } 
function getNative$1 ( object , key ) { var value = getValue$1 ( object , key ) ; return baseIsNative$1 ( value ) ? value : undefined ; } 
function hasPath ( object , path , hasFunc ) { path = isKey$1 ( path , object ) ? [ path ] : castPath$1 ( path ) ; var result , index = - 1 , length = path . length ; while ( ++ index < length ) { var key = toKey$1 ( path [ index ] ) ; if ( ! ( result = object != null && hasFunc ( object , key ) ) ) { break ; } object = object [ key ] ; } if ( result ) { return result ; } var length = object ? object . length : 0 ; return ! ! length && isLength ( length ) && isIndex ( key , length ) && ( isArray$1 ( object ) || isArguments ( object ) ) ; } 
function isKey$1 ( value , object ) { if ( isArray$1 ( value ) ) { return false ; } var type = typeof value ; if ( type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$1 ( value ) ) { return true ; } return reIsPlainProp$1 . test ( value ) || ! reIsDeepProp$1 . test ( value ) || ( object != null && value in Object ( object ) ) ; } 
function toKey$1 ( value ) { if ( typeof value == 'string' || isSymbol$1 ( value ) ) { return value ; } var result = ( value + '' ) ; return ( result == '0' && ( 1 / value ) == - INFINITY$1 ) ? '-0' : result ; } 
function toSource$1 ( func ) { if ( func != null ) { try { return funcToString$2 . call ( func ) ; } catch ( e ) { } try { return ( func + '' ) ; } catch ( e ) { } } return '' ; } 
function memoize$1 ( func , resolver ) { if ( typeof func != 'function' || ( resolver && typeof resolver != 'function' ) ) { throw new TypeError ( FUNC_ERROR_TEXT$1 ) ; } var memoized = function ( ) { var args = arguments , key = resolver ? resolver . apply ( this , args ) : args [ 0 ] , cache = memoized . cache ; if ( cache . has ( key ) ) { return cache . get ( key ) ; } var result = func . apply ( this , args ) ; memoized . cache = cache . set ( key , result ) ; return result ; } ; memoized . cache = new ( memoize$1 . Cache || MapCache$1 ) ; return memoized ; } 
function isArguments ( value ) { 
function isFunction$1 ( value ) { 
function isHostObject$3 ( value ) { 
function Hash$2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function hashGet$2 ( key ) { var data = this . __data__ ; if ( nativeCreate$2 ) { var result = data [ key ] ; return result === HASH_UNDEFINED$2 ? undefined : result ; } return hasOwnProperty$3 . call ( data , key ) ? data [ key ] : undefined ; } 
function hashHas$2 ( key ) { var data = this . __data__ ; return nativeCreate$2 ? data [ key ] !== undefined : hasOwnProperty$3 . call ( data , key ) ; } 
function hashSet$2 ( key , value ) { var data = this . __data__ ; data [ key ] = ( nativeCreate$2 && value === undefined ) ? HASH_UNDEFINED$2 : value ; return this ; } 
function ListCache$2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function listCacheDelete$2 ( key ) { var data = this . __data__ , index = assocIndexOf$2 ( data , key ) ; if ( index < 0 ) { return false ; } var lastIndex = data . length - 1 ; if ( index == lastIndex ) { data . pop ( ) ; } else { splice$2 . call ( data , index , 1 ) ; } return true ; } 
function listCacheGet$2 ( key ) { var data = this . __data__ , index = assocIndexOf$2 ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function listCacheSet$2 ( key , value ) { var data = this . __data__ , index = assocIndexOf$2 ( data , key ) ; if ( index < 0 ) { data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function MapCache$2 ( entries ) { var index = - 1 , length = entries ? entries . length : 0 ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assignValue ( object , key , value ) { var objValue = object [ key ] ; if ( ! ( hasOwnProperty$3 . call ( object , key ) && eq$2 ( objValue , value ) ) || ( value === undefined && ! ( key in object ) ) ) { object [ key ] = value ; } } 
function assocIndexOf$2 ( array , key ) { var length = array . length ; while ( length -- ) { if ( eq$2 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function baseIsNative$2 ( value ) { if ( ! isObject$2 ( value ) || isMasked$2 ( value ) ) { return false ; } var pattern = ( isFunction$2 ( value ) || isHostObject$3 ( value ) ) ? reIsNative$2 : reIsHostCtor$2 ; return pattern . test ( toSource$2 ( value ) ) ; } 
function baseSet ( object , path , value , customizer ) { if ( ! isObject$2 ( object ) ) { return object ; } path = isKey$2 ( path , object ) ? [ path ] : castPath$2 ( path ) ; var index = - 1 , length = path . length , lastIndex = length - 1 , nested = object ; while ( nested != null && ++ index < length ) { var key = toKey$2 ( path [ index ] ) , newValue = value ; if ( index != lastIndex ) { var objValue = nested [ key ] ; newValue = customizer ? customizer ( objValue , key , nested ) : undefined ; if ( newValue === undefined ) { newValue = isObject$2 ( objValue ) ? objValue : ( isIndex$1 ( path [ index + 1 ] ) ? [ ] : { } ) ; } } assignValue ( nested , key , newValue ) ; nested = nested [ key ] ; } return object ; } 
function baseToString$2 ( value ) { 
function getMapData$2 ( map , key ) { var data = map . __data__ ; return isKeyable$2 ( key ) ? data [ typeof key == 'string' ? 'string' : 'hash' ] : data . map ; } 
function getNative$2 ( object , key ) { var value = getValue$2 ( object , key ) ; return baseIsNative$2 ( value ) ? value : undefined ; } 
function isKey$2 ( value , object ) { if ( isArray$2 ( value ) ) { return false ; } var type = typeof value ; if ( type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2 ( value ) ) { return true ; } return reIsPlainProp$2 . test ( value ) || ! reIsDeepProp$2 . test ( value ) || ( object != null && value in Object ( object ) ) ; } 
function isKeyable$2 ( value ) { var type = typeof value ; return ( type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ) ? ( value !== '__proto__' ) : ( value === null ) ; } 
function toKey$2 ( value ) { if ( typeof value == 'string' || isSymbol$2 ( value ) ) { return value ; } var result = ( value + '' ) ; return ( result == '0' && ( 1 / value ) == - INFINITY$2 ) ? '-0' : result ; } 
function toSource$2 ( func ) { if ( func != null ) { try { return funcToString$3 . call ( func ) ; } catch ( e ) { } try { return ( func + '' ) ; } catch ( e ) { } } return '' ; } 
function memoize$2 ( func , resolver ) { if ( typeof func != 'function' || ( resolver && typeof resolver != 'function' ) ) { throw new TypeError ( FUNC_ERROR_TEXT$2 ) ; } var memoized = function ( ) { var args = arguments , key = resolver ? resolver . apply ( this , args ) : args [ 0 ] , cache = memoized . cache ; if ( cache . has ( key ) ) { return cache . get ( key ) ; } var result = func . apply ( this , args ) ; memoized . cache = cache . set ( key , result ) ; return result ; } ; memoized . cache = new ( memoize$2 . Cache || MapCache$2 ) ; return memoized ; } 
function isFunction$2 ( value ) { 
function arrCopy ( arr , offset ) { offset = offset || 0 ; var len = Math . max ( 0 , arr . length - offset ) ; var newArr = new Array ( len ) ; for ( var ii = 0 ; ii < len ; ii ++ ) { newArr [ ii ] = arr [ ii + offset ] ; } return newArr ; } 
function is ( valueA , valueB ) { if ( valueA === valueB || ( valueA !== valueA && valueB !== valueB ) ) { return true ; } if ( ! valueA || ! valueB ) { return false ; } if ( typeof valueA . valueOf === 'function' && typeof valueB . valueOf === 'function' ) { valueA = valueA . valueOf ( ) ; valueB = valueB . valueOf ( ) ; if ( valueA === valueB || ( valueA !== valueA && valueB !== valueB ) ) { return true ; } if ( ! valueA || ! valueB ) { return false ; } } if ( typeof valueA . equals === 'function' && typeof valueB . equals === 'function' && valueA . equals ( valueB ) ) { return true ; } return false ; } 
function hashString ( string ) { 
function mixin ( ctor , methods ) { var keyCopier = function ( key ) { ctor . prototype [ key ] = methods [ key ] ; } ; Object . keys ( methods ) . forEach ( keyCopier ) ; Object . getOwnPropertySymbols && Object . getOwnPropertySymbols ( methods ) . forEach ( keyCopier ) ; return ctor ; } 
function ( ) { assertNotInfinite ( this . size ) ; var array = new Array ( this . size || 0 ) ; this . valueSeq ( ) . __iterate ( function ( v , i ) { array [ i ] = v ; } ) ; return array ; } 
function isString ( value ) { return typeof value == 'string' || ( ! isArray$3 ( value ) && isObjectLike$4 ( value ) && objectToString$4 . call ( value ) == stringTag ) ; } 
function isFunction$3 ( value ) { if ( ! isObject$3 ( value ) ) { return false ; } 
function arrayIncludes ( array , value ) { var length = array ? array . length : 0 ; return ! ! length && baseIndexOf ( array , value , 0 ) > - 1 ; } 
function baseIndexOf ( array , value , fromIndex ) { if ( value !== value ) { return baseFindIndex ( array , baseIsNaN , fromIndex ) ; } var index = fromIndex - 1 , length = array . length ; while ( ++ index < length ) { if ( array [ index ] === value ) { return index ; } } return - 1 ; } 
function countHolders ( array , placeholder ) { var length = array . length , result = 0 ; while ( length -- ) { if ( array [ length ] === placeholder ) { result ++ ; } } return result ; } 
function isHostObject$4 ( value ) { 
function baseIsNative$3 ( value ) { if ( ! isObject$4 ( value ) || isMasked$3 ( value ) ) { return false ; } var pattern = ( isFunction$4 ( value ) || isHostObject$4 ( value ) ) ? reIsNative$3 : reIsHostCtor$3 ; return pattern . test ( toSource$3 ( value ) ) ; } 
function createRecurry ( func , bitmask , wrapFunc , placeholder , thisArg , partials , holders , argPos , ary , arity ) { var isCurry = bitmask & CURRY_FLAG , newHolders = isCurry ? holders : undefined , newHoldersRight = isCurry ? undefined : holders , newPartials = isCurry ? partials : undefined , newPartialsRight = isCurry ? undefined : partials ; bitmask |= ( isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG ) ; bitmask &= ~ ( isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG ) ; if ( ! ( bitmask & CURRY_BOUND_FLAG ) ) { bitmask &= ~ ( BIND_FLAG | BIND_KEY_FLAG ) ; } var result = wrapFunc ( func , bitmask , thisArg , newPartials , newHolders , newPartialsRight , newHoldersRight , argPos , ary , arity ) ; result . placeholder = placeholder ; return setWrapToString ( result , func , bitmask ) ; } 
function getNative$3 ( object , key ) { var value = getValue$3 ( object , key ) ; return baseIsNative$3 ( value ) ? value : undefined ; } 
function insertWrapDetails ( source , details ) { var length = details . length , lastIndex = length - 1 ; details [ lastIndex ] = ( length > 1 ? '& ' : '' ) + details [ lastIndex ] ; details = details . join ( length > 2 ? ', ' : ' ' ) ; return source . replace ( reWrapComment , '{\n/* [wrapped with ' + details + '] */\n' ) ; } 
function toSource$3 ( func ) { if ( func != null ) { try { return funcToString$4 . call ( func ) ; } catch ( e ) { } try { return ( func + '' ) ; } catch ( e ) { } } return '' ; } 
function isFunction$4 ( value ) { 
function toFinite ( value ) { if ( ! value ) { return value === 0 ? value : 0 ; } value = toNumber ( value ) ; if ( value === INFINITY$3 || value === - INFINITY$3 ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX_INTEGER ; } return value === value ? value : 0 ; } 
function toNumber ( value ) { if ( typeof value == 'number' ) { return value ; } if ( isSymbol$3 ( value ) ) { return NAN ; } if ( isObject$4 ( value ) ) { var other = typeof value . valueOf == 'function' ? value . valueOf ( ) : value ; value = isObject$4 ( other ) ? ( other + '' ) : other ; } if ( typeof value != 'string' ) { return value === 0 ? value : + value ; } value = value . replace ( reTrim , '' ) ; var isBinary = reIsBinary . test ( value ) ; return ( isBinary || reIsOctal . test ( value ) ) ? freeParseInt ( value . slice ( 2 ) , isBinary ? 2 : 8 ) : ( reIsBadHex . test ( value ) ? NAN : + value ) ; } 
function arrayLikeKeys ( value , inherited ) { 
function assignInDefaults ( objValue , srcValue , key , object ) { if ( objValue === undefined || ( eq$3 ( objValue , objectProto$7 [ key ] ) && ! hasOwnProperty$6 . call ( object , key ) ) ) { return srcValue ; } return objValue ; } 
function assignValue$1 ( object , key , value ) { var objValue = object [ key ] ; if ( ! ( hasOwnProperty$6 . call ( object , key ) && eq$3 ( objValue , value ) ) || ( value === undefined && ! ( key in object ) ) ) { object [ key ] = value ; } } 
function baseKeysIn ( object ) { if ( ! isObject$5 ( object ) ) { return nativeKeysIn ( object ) ; } var isProto = isPrototype ( object ) , result = [ ] ; for ( var key in object ) { if ( ! ( key == 'constructor' && ( isProto || ! hasOwnProperty$6 . call ( object , key ) ) ) ) { result . push ( key ) ; } } return result ; } 
function baseRest ( func , start ) { start = nativeMax$1 ( start === undefined ? ( func . length - 1 ) : start , 0 ) ; return function ( ) { var args = arguments , index = - 1 , length = nativeMax$1 ( args . length - start , 0 ) , array = Array ( length ) ; while ( ++ index < length ) { array [ index ] = args [ start + index ] ; } index = - 1 ; var otherArgs = Array ( start + 1 ) ; while ( ++ index < start ) { otherArgs [ index ] = args [ index ] ; } otherArgs [ start ] = array ; return apply$1 ( func , this , otherArgs ) ; } ; } 
function isIndex$3 ( value , length ) { length = length == null ? MAX_SAFE_INTEGER$3 : length ; return ! ! length && ( typeof value == 'number' || reIsUint$3 . test ( value ) ) && ( value > - 1 && value % 1 == 0 && value < length ) ; } 
function isIterateeCall ( value , index , object ) { if ( ! isObject$5 ( object ) ) { return false ; } var type = typeof index ; if ( type == 'number' ? ( isArrayLike$1 ( object ) && isIndex$3 ( index , object . length ) ) : ( type == 'string' && index in object ) ) { return eq$3 ( object [ index ] , value ) ; } return false ; } 
function isPrototype ( value ) { var Ctor = value && value . constructor , proto = ( typeof Ctor == 'function' && Ctor . prototype ) || objectProto$7 ; return value === proto ; } 
function isArguments$1 ( value ) { 
function isFunction$5 ( value ) { 
function getRawTag$1 ( value ) { var isOwn = hasOwnProperty$7 . call ( value , symToStringTag$1 ) , tag = value [ symToStringTag$1 ] ; try { value [ symToStringTag$1 ] = undefined ; } catch ( e ) { } var result = nativeObjectToString$1 . call ( value ) ; { if ( isOwn ) { value [ symToStringTag$1 ] = tag ; } else { delete value [ symToStringTag$1 ] ; } } return result ; } 
function baseGetTag$1 ( value ) { if ( value == null ) { return value === undefined ? undefinedTag$1 : nullTag$1 ; } return ( symToStringTag$2 && symToStringTag$2 in Object ( value ) ) ? _getRawTag ( value ) : _objectToString ( value ) ; } 
function isKey$3 ( value , object ) { if ( isArray_1 ( value ) ) { return false ; } var type = typeof value ; if ( type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1 ( value ) ) { return true ; } return reIsPlainProp$3 . test ( value ) || ! reIsDeepProp$3 . test ( value ) || ( object != null && value in Object ( object ) ) ; } 
function isFunction$6 ( value ) { if ( ! isObject_1 ( value ) ) { return false ; } 
function toSource$4 ( func ) { if ( func != null ) { try { return funcToString$5 . call ( func ) ; } catch ( e ) { } try { return ( func + '' ) ; } catch ( e ) { } } return '' ; } 
function baseIsNative$4 ( value ) { if ( ! isObject_1 ( value ) || _isMasked ( value ) ) { return false ; } var pattern = isFunction_1 ( value ) ? reIsNative$4 : reIsHostCtor$4 ; return pattern . test ( _toSource ( value ) ) ; } 
function getNative$4 ( object , key ) { var value = _getValue ( object , key ) ; return _baseIsNative ( value ) ? value : undefined ; } 
function hashDelete$3 ( key ) { var result = this . has ( key ) && delete this . __data__ [ key ] ; this . size -= result ? 1 : 0 ; return result ; } 
function hashGet$3 ( key ) { var data = this . __data__ ; if ( _nativeCreate ) { var result = data [ key ] ; return result === HASH_UNDEFINED$3 ? undefined : result ; } return hasOwnProperty$9 . call ( data , key ) ? data [ key ] : undefined ; } 
function hashHas$3 ( key ) { var data = this . __data__ ; return _nativeCreate ? ( data [ key ] !== undefined ) : hasOwnProperty$a . call ( data , key ) ; } 
function hashSet$3 ( key , value ) { var data = this . __data__ ; this . size += this . has ( key ) ? 0 : 1 ; data [ key ] = ( _nativeCreate && value === undefined ) ? HASH_UNDEFINED$4 : value ; return this ; } 
function Hash$3 ( entries ) { var index = - 1 , length = entries == null ? 0 : entries . length ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function assocIndexOf$3 ( array , key ) { var length = array . length ; while ( length -- ) { if ( eq_1 ( array [ length ] [ 0 ] , key ) ) { return length ; } } return - 1 ; } 
function listCacheDelete$3 ( key ) { var data = this . __data__ , index = _assocIndexOf ( data , key ) ; if ( index < 0 ) { return false ; } var lastIndex = data . length - 1 ; if ( index == lastIndex ) { data . pop ( ) ; } else { splice$3 . call ( data , index , 1 ) ; } -- this . size ; return true ; } 
function listCacheGet$3 ( key ) { var data = this . __data__ , index = _assocIndexOf ( data , key ) ; return index < 0 ? undefined : data [ index ] [ 1 ] ; } 
function listCacheSet$3 ( key , value ) { var data = this . __data__ , index = _assocIndexOf ( data , key ) ; if ( index < 0 ) { ++ this . size ; data . push ( [ key , value ] ) ; } else { data [ index ] [ 1 ] = value ; } return this ; } 
function ListCache$3 ( entries ) { var index = - 1 , length = entries == null ? 0 : entries . length ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function isKeyable$3 ( value ) { var type = typeof value ; return ( type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ) ? ( value !== '__proto__' ) : ( value === null ) ; } 
function getMapData$3 ( map , key ) { var data = map . __data__ ; return _isKeyable ( key ) ? data [ typeof key == 'string' ? 'string' : 'hash' ] : data . map ; } 
function mapCacheSet$3 ( key , value ) { var data = _getMapData ( this , key ) , size = data . size ; data . set ( key , value ) ; this . size += data . size == size ? 0 : 1 ; return this ; } 
function MapCache$3 ( entries ) { var index = - 1 , length = entries == null ? 0 : entries . length ; this . clear ( ) ; while ( ++ index < length ) { var entry = entries [ index ] ; this . set ( entry [ 0 ] , entry [ 1 ] ) ; } } 
function baseToString$3 ( value ) { 
function castPath$3 ( value , object ) { if ( isArray_1 ( value ) ) { return value ; } return _isKey ( value , object ) ? [ value ] : _stringToPath ( toString_1 ( value ) ) ; } 
function toKey$3 ( value ) { if ( typeof value == 'string' || isSymbol_1 ( value ) ) { return value ; } var result = ( value + '' ) ; return ( result == '0' && ( 1 / value ) == - INFINITY$5 ) ? '-0' : result ; } 
function get$2 ( object , path , defaultValue ) { var result = object == null ? undefined : _baseGet ( object , path ) ; return result === undefined ? defaultValue : result ; } 
function dropDB ( ) { nano . db . destroy ( nameDB , function ( err ) { if ( err && err . statusCode != 404 ) { logger_1 . logger . log ( 'error' , ` ${ nameDB } \n ` ) ; throw err ; } nano . db . create ( nameDB , function ( err ) { if ( err ) { logger_1 . logger . log ( 'error' , ` ${ nameDB } \n ` ) ; throw err ; } logger_1 . logger . log ( 'success' , ` ${ nameDB } \n ` ) ; if ( program . test ) { 
function dumpLoadOption ( ) { let p = new Promise ( ( resolve , reject ) => { let file = jsonfile . readFileSync ( program . dumpload ) ; let fileContent = [ ] ; if ( file . hasOwnProperty ( "rows" ) && file . rows instanceof Object && file ) { if ( ! Array . isArray ( file . rows ) ) fileContent . push ( file . rows ) ; else fileContent = file . rows ; } else if ( Array . isArray ( file ) ) fileContent = file ; else logger_1 . logger . log ( 'warn' , ` ` ) ; if ( fileContent . length > 0 ) { logger_1 . logger . log ( 'info' , ` ${ program . dumpload } ` ) ; storeJob ( fileContent ) . on ( 'storeDone' , ( ) => { logger_1 . logger . log ( 'success' , ` ${ program . dumpload } ${ nameDB } \n ` ) ; resolve ( ) ; } ) . on ( 'storeError' , ( err ) => { logger_1 . logger . log ( 'error' , ` ${ program . dumpload } \n ${ err } ` ) ; reject ( ) ; } ) ; } else { logger_1 . logger . log ( 'warn' , ` ` ) ; reject ( ) ; } } ) ; return p ; } 
function indexationOption ( ) { return new Promise ( ( resolve , reject ) => { logger_1 . logger . log ( 'info' , ` ` ) ; indexation ( configContent . previousCacheDir ) . on ( 'indexDone' , ( ) => { logger_1 . logger . log ( 'success' , ` \n ` ) ; resolve ( ) ; } ) . on ( 'indexError' , ( err ) => { logger_1 . logger . log ( 'error' , ` ${ err } ` ) ; reject ( err ) ; } ) ; } ) ; } 
function dumpOption ( ) { return new Promise ( ( resolve , reject ) => { dumpingDatabase ( ) . on ( 'dumpDone' , ( ) => { resolve ( ) ; } ) . on ( 'dumpFailed' , ( err ) => { reject ( err ) ; } ) ; } ) ; } 
function dumpingDatabase ( testDump = false ) { let dumpEmitter = new EventEmitter ( ) ; let wstream ; if ( testDump ) { wstream = fs . createWriteStream ( ` ${ nameDB } ` ) ; } else { wstream = fs . createWriteStream ( ` ${ nameDB } ` ) ; } let chunkRes = '' ; let chunkError = '' ; let curl ; if ( proxyBool ) { curl = child_process_1 . spawn ( 'curl' , [ '--noproxy' , ` ${ addressDB } ` , ` ` , ` ` , ` ${ accountDB } ${ passwordDB } ${ addressDB } ${ portDB } ${ nameDB } ` ] ) ; } else { curl = child_process_1 . spawn ( 'curl' , [ ` ` , ` ` , ` ${ accountDB } ${ passwordDB } ${ addressDB } ${ portDB } ${ nameDB } ` ] ) ; } curl . stdout . on ( 'data' , ( data ) => { chunkRes += data . toString ( 'utf8' ) ; } ) ; curl . stderr . on ( 'data' , ( data ) => { chunkError += data . toString ( 'utf8' ) ; } ) ; curl . on ( 'close' , ( code ) => { let split = chunkError . replace ( / (\r\n\t|\n|\r\t) / gm , " " ) . split ( " " ) ; if ( chunkError . length > 0 && chunkRes . length === 0 ) { logger_1 . logger . log ( 'error' , ` ${ nameDB } \n ${ chunkError } ` ) ; } else { try { wstream . write ( chunkRes ) ; if ( testDump ) logger_1 . logger . log ( 'success' , ` ${ nameDB } ${ nameDB } ` ) ; else logger_1 . logger . log ( 'success' , ` ${ nameDB } ${ nameDB } ` ) ; dumpEmitter . emit ( 'dumpDone' ) ; } catch ( err ) { logger_1 . logger . log ( 'error' , ` ${ nameDB } \n ${ err } ` ) ; dumpEmitter . emit ( 'dumpFailed' , err ) ; } } } ) ; return dumpEmitter ; } 
function constraintsCall ( constraints , connectType ) { let emitterCall = new EventEmitter ( ) ; 
function indexation ( cacheArray ) { let emitterIndex = new EventEmitter ( ) ; let pathResult = globCaches ( cacheArray ) ; 
function globCaches ( pathsArray ) { let deepIndex = [ ] ; let mergedIndex ; 
function directorySearch ( directoryPath ) { let uuidregexV4 = / [0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12} / ig ; let uuidArray = directoryPath . match ( uuidregexV4 ) ; let uuidDir = null ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( uuidArray ) } ` ) ; if ( uuidArray != null ) { uuidDir = uuidArray . pop ( ) ; 
function extractDoc ( path , uuid ) { let file ; if ( typeof ( path ) !== 'string' ) { logger_1 . logger . log ( 'warn' , ` \n ${ path } ` ) ; } try { file = jsonfile . readFileSync ( path ) ; } catch ( err ) { logger_1 . logger . log ( 'warn' , ` ${ path } \n ${ err } ` ) ; return null ; } return file ; } 
function constraintsToQuery ( constraints , either = false ) { let constEmitter = new EventEmitter ; let query = { "selector" : { } } ; let strConstr = JSON . stringify ( constraints ) ; let sel = query . selector ; if ( strConstr === JSON . stringify ( { } ) || strConstr === JSON . stringify ( [ ] ) ) { let error = 'Empty constraints json or array given' ; logger_1 . logger . log ( 'warn' , error ) ; constEmitter . emit ( 'errorOnConstraints' ) ; return constEmitter ; } 
function storeJob ( job ) { let storeEmitter = new EventEmitter ( ) ; dbMod . addToDB ( job , nameDB , accountDB , passwordDB , addressDB , portDB , proxyBool ) . then ( ( ) => { if ( Array . isArray ( job ) ) { logger_1 . logger . log ( 'success' , ` ${ job . length } ${ nameDB } ` ) ; } else logger_1 . logger . log ( 'success' , ` ${ nameDB } ` ) ; storeEmitter . emit ( 'storeDone' ) ; } ) . catch ( ( err ) => { storeEmitter . emit ( 'storeError' , err ) ; } ) ; return storeEmitter ; } 
function ( savePath , consolidate , useDotNotation , filePrefix , consolidateAll ) { this . savePath = savePath || '' ; this . consolidate = consolidate === jasmine . undefined ? true : consolidate ; this . consolidateAll = consolidateAll === jasmine . undefined ? false : consolidateAll ; this . useDotNotation = useDotNotation === jasmine . undefined ? true : useDotNotation ; this . filePrefix = filePrefix || ( this . consolidateAll ? 'junitresults' : 'TEST-' ) ; } 
function deleteCacheForConstructor ( constr ) { for ( var i in inheritanceChain ) { if ( inheritanceChain . hasOwnProperty ( i ) ) { if ( inheritanceChain [ i ] . indexOf ( constr . __get_protolib_id__ ) > - 1 ) { cached [ i ] = undefined ; delete cached [ i ] ; inheritanceChain [ i ] = undefined ; delete inheritanceChain [ i ] ; } } } return self ; } 
function attachLibraryToSelf ( ) { for ( var i in libs ) if ( libs . hasOwnProperty ( i ) && ! self [ i ] ) self [ i ] = libs [ i ] ; return self ; } 
function applyLibraryToPrototypes ( ) { if ( ! attached ) { Object . defineProperty ( Object . prototype , handle , { configurable : true , enumerable : false , 
function ( v ) { if ( this [ handle ] !== v ) { Object . defineProperty ( this , handle , { configurable : true , enumerable : true , writable : true , value : v } ) ; } } 
function ( ) { var ccId , proto = getProto ( this ) , cId = proto . constructor . __get_protolib_id__ , lib = { } , i = 0 , last = null , m ; currentThis = this ; do { ccId = proto . constructor . __get_protolib_id__ ; if ( cached [ ccId ] && i === 0 ) { return cached [ ccId ] ; } else if ( cached [ ccId ] ) { for ( m in cached [ ccId ] ) if ( cached [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = cached [ ccId ] [ m ] ; if ( ! inheritanceChain [ cId ] ) inheritanceChain [ cId ] = [ ] ; inheritanceChain [ cId ] = inheritanceChain [ ccId ] . concat ( inheritanceChain [ cId ] ) ; cached [ cId ] = lib ; return lib ; } else { if ( ! libp [ ccId ] ) libp [ ccId ] = { } ; for ( m in libp [ ccId ] ) if ( libp [ ccId ] . hasOwnProperty ( m ) ) lib [ m ] = libp [ ccId ] [ m ] ; if ( ! inheritanceChain [ ccId ] ) inheritanceChain [ ccId ] = [ ] ; inheritanceChain [ cId ] . unshift ( ccId ) ; cached [ cId ] = lib ; last = ccId ; } ++ i ; } while ( proto = getProto ( proto ) ) ; 
function removeLibraryFromPrototypes ( ) { Object . defineProperty ( Object . prototype , handle , { value : undefined } ) ; delete Object . prototype [ handle ] ; attached = false ; return self ; } 
function getThisValueAndInvoke ( callback ) { return callback ( currentThis !== undefined && currentThis !== null ? ( typeof currentThis === 'object' ? currentThis : currentThis . valueOf ( ) ) : currentThis ) ; } 
function create ( props ) { var button = Object . create ( this ) ; _canvasWidget2 . default . create . call ( button ) ; Object . assign ( button , Button . defaults , props ) ; if ( props . value ) button . __value = props . value ; button . init ( ) ; return button ; } 
function draw ( ) { this . ctx . fillStyle = this . __value === 1 ? this . fill : this . background ; this . ctx . strokeStyle = this . stroke ; this . ctx . lineWidth = this . lineWidth ; this . ctx . fillRect ( 0 , 0 , this . rect . width , this . rect . height ) ; this . ctx . strokeRect ( 0 , 0 , this . rect . width , this . rect . height ) ; } 
function addToDB ( data , nameDB , accountName , passwordDB , addressDB , portDB , proxyBool ) { return __awaiter ( this , void 0 , void 0 , function * ( ) { let docList = Array . isArray ( data ) ? data : [ data ] ; let arrayData = docList . length > 500 ? arraySplit ( docList , 500 ) : docList ; for ( let elem of arrayData ) { let addObj = new addData ( elem , nameDB , accountName , passwordDB , addressDB , portDB , proxyBool ) ; yield addObj . three_curl ( ) ; } ; } ) ; } 
function bindProperty ( o , parent , prop ) { Object . defineProperty ( o , prop , { get : function ( ) { try { return parent [ prop ] ; } catch ( e ) { } } , set : function ( val ) { try { parent [ prop ] = val ; } catch ( e ) { } } , configurable : true } ) ; } 
function iterateProperties ( _sub , _super ) { var props = Object . getOwnPropertyNames ( _super ) , proto ; _sub . __proto__ = _super ; 
function getKeys ( o ) { switch ( typeof o ) { case 'object' : return o ? Object . keys ( o ) : [ ] ; case 'string' : var keys = [ ] ; for ( var i = 0 ; i < o . length ; i ++ ) keys . push ( i . toString ( ) ) ; return keys ; default : return [ ] ; } } 
function camelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s === 'function' ) s = fixFirefoxFunctionString ( s . toString ( ) ) ; s = s . toString ( ) . replace ( / [^a-z0-9$] / gi , '_' ) . replace ( / \$(\w) / g , '$_$1' ) . split ( / [\s_]+ / g ) ; libs . object . each ( s , 1 , s . length , function ( i , k ) { this [ k ] = libs . string . ucFirst ( i ) ; } ) ; s = libs . string . lcFirst ( s . join ( '' ) ) ; } ret . push ( s ) ; } ) ; return ret . length === 1 ? ret [ 0 ] : ret ; } 
function decamelize ( ) { var ret = [ ] ; libs . object . every ( arguments , function ( s ) { if ( s ) { if ( typeof s === 'function' ) s = fixFirefoxFunctionString ( s . toString ( ) ) ; s = s . toString ( ) . replace ( / ([A-Z$]) / g , function ( $ ) { return ' ' + ( typeof $ === 'string' ? $ . toLowerCase ( ) : '' ) ; } ) . replace ( / function \(\) / g , 'function()' ) ; } ret . push ( typeof s === 'string' ? s . trim ( ) : s ) ; } ) ; return ret . length === 1 ? ret [ 0 ] : ret ; } 
function differenceFromString ( s , other ) { if ( typeof other !== 'string' || typeof s !== 'string' ) return s ; var sarr = s . split ( '' ) , oarr = other . split ( '' ) ; return libs . array . difference ( sarr , oarr ) . join ( '' ) ; } 
function intersectString ( s , other ) { if ( typeof other !== 'string' || typeof s !== 'string' ) return s ; var sarr = s . split ( '' ) , oarr = other . split ( '' ) ; return libs . array . intersect ( sarr , oarr ) . join ( '' ) ; } 
function repeat ( s , times ) { times = parseInt ( times , 10 ) ; times = isNaN ( times ) || ! isFinite ( times ) || times <= 0 ? 1 : times ; var os = s ; for ( var i = 1 ; i < times ; i ++ ) s += os ; return s ; } 
function rtrim ( s , what ) { what = typeof what === 'string' ? what : '\\s+' ; return s . replace ( new RegExp ( what + '$' ) , '' ) ; } 
function ltrim ( s , what ) { what = typeof what === 'string' ? what : '\\s+' ; return s . replace ( new RegExp ( '^' + what ) , '' ) ; } 
function titleCase ( s ) { var arr = [ ] ; libs . object . each ( s . split ( ' ' ) , function ( t ) { arr . push ( libs . string . ucFirst ( t ) ) ; } ) ; return arr . join ( ' ' ) ; } 
function splice ( s , index , count , add ) { return s . slice ( 0 , index ) + ( add || '' ) + s . slice ( index + count ) ; } 
function ellipses_ ( s , length , place , ellipses ) { if ( isNaN ( parseInt ( length , 10 ) ) ) length = s . length ; if ( length < 0 || ! isFinite ( length ) ) length = 0 ; ellipses = typeof ellipses === 'string' ? ellipses : '...' ; if ( s . length <= length ) return s ; if ( length <= ellipses . length ) { return ellipses . substring ( 0 , length ) ; } else if ( ! place || place !== 'front' ) { return s . substr ( 0 , length - ellipses . length ) + ellipses ; } else { return ellipses + s . substr ( 0 , length - ellipses . length ) ; } } 
function shuffle ( s , splitter ) { var a = s . split ( typeof splitter === 'string' ? splitter : '' ) , n = a . length , replaceSplits = n - 1 ; for ( var i = n - 1 ; i > 0 ; i -- ) { var j = Math . floor ( Math . random ( ) * ( i + 1 ) ) , tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } for ( var k = 0 ; k < replaceSplits ; k ++ ) a . splice ( libs . number . randomIntInRange ( 0 , a . length ) , 0 , splitter ) ; return a . join ( '' ) ; } 
function reverse ( s ) { if ( s . length < 64 ) { var str = '' ; for ( var i = s . length ; i >= 0 ; i -- ) str += s . charAt ( i ) ; return str ; } else { return s . split ( '' ) . reverse ( ) . join ( '' ) ; } } 
function withoutTrailingSlash ( s ) { if ( ! IS_BROWSER && HAS_OS && require ( 'os' ) . platform === 'win32' ) return s . replace ( / \\+$ / , '' ) ; return s . replace ( / \/+$ / , '' ) ; } 
function withTrailingSlash ( s ) { if ( ! IS_BROWSER && HAS_OS && require ( 'os' ) . platform === 'win32' ) return libs . string . withoutTrailingSlash ( s ) + '\\' ; return libs . string . withoutTrailingSlash ( s ) + '/' ; } 
function pad ( s , length , delim , pre ) { var i , thisLength = s . length ; if ( ! delim ) delim = ' ' ; if ( length === 0 ) return '' ; else if ( isNaN ( parseInt ( length , 10 ) ) ) return s ; length = parseInt ( length , 10 ) ; if ( length < thisLength ) return ! pre ? s . slice ( 0 , length ) : s . slice ( - length ) ; if ( pre ) { for ( i = 0 ; i < length - thisLength ; i ++ ) s = delim + s ; } else { for ( i = 0 ; i < length - thisLength ; i ++ ) s += delim ; } return s ; } 
function wordWrapToLength ( s , width , padleft , padright , omitFirst ) { if ( padright === undefined && padleft ) padright = padleft ; padleft = ! isNaN ( parseInt ( padleft , 10 ) ) ? parseInt ( padleft , 10 ) : 0 ; padright = ! isNaN ( parseInt ( padright , 10 ) ) ? parseInt ( padright , 10 ) : 0 ; var paddingLeft = '' ; for ( var n = 0 ; n < padleft ; n ++ ) paddingLeft += ' ' ; var cols = ! isNaN ( parseInt ( width , 10 ) ) ? length : 120 , arr = s . split ( ' ' ) , item = null , len = ! omitFirst ? cols - padright - padleft : cols - padright , str = ! omitFirst ? paddingLeft : '' , olen = cols - padright - padleft ; while ( ( item = arr . shift ( ) ) !== undefined ) { if ( item . length < len ) { str += item + ' ' ; len -= item . length + 1 ; } else if ( item . length > olen ) { str += item . substring ( 0 , len - 1 ) + '-\n' + paddingLeft ; arr . unshift ( item . substring ( len , item . length - 1 ) ) ; len = cols - padright - padleft ; } else { str += '\n' + paddingLeft + item + ' ' ; len = cols - padright - 1 - padleft - item . length ; } } return str ; } 
function advanceDays ( d , daysInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; daysInTheFuture = daysInTheFuture && libs . generic . isNumeric ( daysInTheFuture ) ? daysInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( daysInTheFuture * 86400000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; } 
function advanceMonths ( d , monthsInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; monthsInTheFuture = monthsInTheFuture && libs . generic . isNumeric ( monthsInTheFuture ) ? monthsInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( monthsInTheFuture * 2629746000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; } 
function advanceYears ( d , yearsInTheFuture , adjustForWeekend ) { if ( ! ( d instanceof Date ) ) return d ; yearsInTheFuture = yearsInTheFuture && libs . generic . isNumeric ( yearsInTheFuture ) ? yearsInTheFuture : 1 ; d . setTime ( d . getTime ( ) + ( yearsInTheFuture * 31536000000 ) ) ; if ( adjustForWeekend && ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) ) { while ( d . getDay ( ) === 0 || d . getDay ( ) === 6 ) d . setTime ( d . getTime ( ) + 86400000 ) ; } return d ; } 
function yyyymmdd ( d , delim ) { if ( ! ( d instanceof Date ) ) return d ; delim = typeof delim !== 'string' ? '-' : delim ; var dd = d . getDate ( ) , mm = d . getMonth ( ) + 1 , yyyy = d . getFullYear ( ) ; if ( dd < 10 ) dd = '0' + dd ; if ( mm < 10 ) mm = '0' + mm ; return yyyy + delim + mm + delim + dd ; } 
function clockTime ( d , omitMS ) { if ( ! ( d instanceof Date ) ) return d ; return libs . number . clockTime ( d . getTime ( ) , ! ! omitMS ) ; } 
function ( n , placeholder ) { if ( n === undefined || n === null || ! libs . object . isNumeric ( n ) ) return n ; placeholder = typeof placeholder === 'string' ? placeholder : '.' ; var rest , idx , int , ns = n . toString ( ) , neg = n < 0 ; idx = ns . indexOf ( '.' ) ; int = parseInt ( Math . abs ( n ) , 10 ) . toString ( ) ; if ( idx > - 1 ) rest = '.' + ns . substring ( idx + 1 , ns . length ) ; return ( neg ? '-' : '' ) + libs . string . reverse ( libs . string . reverse ( int ) . replace ( / (\d{3})(?!$) / g , '$1,' ) ) + ( rest || '' ) ; } 
function ( n , symbol ) { if ( n === undefined || n === null || ! libs . object . isNumeric ( n ) ) return n ; n = libs . object . getNumeric ( n ) . toFixed ( 2 ) ; symbol = typeof symbol === 'string' ? symbol : '$' ; return n . replace ( / ^(-)?(\d+)\.(\d+)$ / , function ( $0 , $1 , $2 , $3 ) { $1 = $2 === '0' && $3 === '00' ? null : $1 ; return ( $1 || '' ) + symbol + libs . number . withPlaceholders ( $2 ) + '.' + $3 ; } ) ; } 
function ( min , max ) { min = parseInt ( min , 10 ) ; max = parseInt ( max , 10 ) ; if ( isNaN ( min ) && ! isFinite ( min ) ) min = 0 ; if ( isNaN ( max ) && ! isFinite ( max ) ) max = Number . MAX_VALUE ; return Math . floor ( Math . random ( ) * ( max - min + 1 ) ) + min ; } 
function ( min , max ) { min = parseFloat ( min ) ; max = parseFloat ( max ) ; if ( isNaN ( min ) && ! isFinite ( min ) ) min = 0 ; if ( isNaN ( max ) && ! isFinite ( max ) ) max = Number . MAX_VALUE ; return Math . random ( ) * ( max - min ) + min ; } 
function factorial ( n ) { if ( typeof n !== 'number' || n < 0 ) return NaN ; if ( n > 170 ) return Infinity ; if ( n === 0 || n === 1 ) return 1 ; return n * factorial ( n - 1 ) ; } 
function isInt ( ) { return libs . object . every ( arguments , function ( n ) { return typeof n === 'number' && n % 1 === 0 && n . toString ( ) . indexOf ( '.' ) === - 1 ; } ) ; } 
function choose ( n , k ) { if ( typeof n !== 'number' || typeof k !== 'number' ) return NaN ; if ( k === 0 ) return 1 ; return ( n * choose ( n - 1 , k - 1 ) ) / k ; } 
function pad ( n , length ) { return libs . string . pad ( n . toString ( ) , length , '0' , true ) ; } 
function daysFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setDate ( date . getDate ( ) + n ) ; return date ; } 
function secondsFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setSeconds ( date . getSeconds ( ) + n ) ; return date ; } 
function yearsFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setFullYear ( date . getFullYear ( ) + n ) ; return date ; } 
function monthsFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setMonth ( date . getMonth ( ) + n ) ; return date ; } 
function hoursFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setHours ( date . getHours ( ) + n ) ; return date ; } 
function minutesFrom ( n , date ) { if ( typeof date === 'number' ) date = new Date ( date ) ; if ( ! ( date instanceof Date ) ) date = new Date ( ) ; date . setMinutes ( date . getMinutes ( ) + n ) ; return date ; } 
function clockTime ( t , omitMS ) { var ms , secs , mins , hrs ; ms = t % 1000 ; t = ( t - ms ) / 1000 ; secs = t % 60 ; t = ( t - secs ) / 60 ; mins = t % 60 ; hrs = ( t - mins ) / 60 ; return libs . number . pad ( hrs . toString ( ) , 2 ) + ':' + libs . number . pad ( mins . toString ( ) , 2 ) + ':' + libs . number . pad ( secs . toString ( ) , 2 ) + ( ( omitMS === true ) ? '' : '.' + libs . number . pad ( ms . toString ( ) , 3 ) ) ; } 
function inherits ( constructor , superConstructor ) { if ( constructor === undefined || constructor === null ) throw new TypeError ( 'The constructor to "inherits" must not be ' + 'null or undefined' ) ; if ( superConstructor === undefined || superConstructor === null ) throw new TypeError ( 'The super constructor to "inherits" must not ' + 'be null or undefined' ) ; if ( superConstructor . prototype === undefined ) throw new TypeError ( 'The super constructor to "inherits" must ' + 'have a prototype' ) ; constructor . super_ = superConstructor ; Object . setPrototypeOf ( constructor . prototype , superConstructor . prototype ) ; 
function union ( a ) { var args = libs . object . only ( libs . object . toArray ( arguments ) , 'array' ) ; var union = [ ] ; args . unshift ( a ) ; libs . object . each ( args , function ( array ) { libs . object . each ( array , function ( item ) { if ( union . indexOf ( item ) === - 1 ) union . push ( item ) ; } ) ; } ) ; return union ; } 
function difference ( ) { var arrays = libs . object . only ( libs . object . toArray ( arguments ) , 'array' ) , diff = [ ] , allItems = [ ] , i ; for ( i = 0 ; i < arrays . length ; i ++ ) allItems = allItems . concat ( arrays [ i ] ) ; for ( i = 0 ; i < allItems . length ; i ++ ) { var inArray = - 1 , unique = false ; for ( var n = 0 ; n < arrays . length ; n ++ ) { if ( inArray === - 1 && arrays [ n ] . indexOf ( allItems [ i ] ) > - 1 ) { inArray = n ; unique = true ; } else if ( inArray !== - 1 && arrays [ n ] . indexOf ( allItems [ i ] ) > - 1 ) { inArray = n ; unique = false ; } } if ( inArray !== - 1 && unique ) diff . push ( allItems [ i ] ) ; } return diff ; } 
function intersect ( ) { var arrays = libs . object . only ( libs . object . toArray ( arguments ) , 'array' ) ; if ( arrays . length === 0 ) return [ ] ; if ( arrays . length === 1 ) return libs . object . copy ( arrays [ 0 ] ) ; var intersection = arrays [ 0 ] , intermediate = [ ] ; for ( var i = 1 ; i < arrays . length ; i ++ ) { var arr = libs . object . copy ( arrays [ i ] ) ; 
function without ( ) { var args = libs . object . toArray ( arguments ) , a = args . shift ( ) , res = [ ] ; if ( ! ( a instanceof Array ) ) return a ; libs . object . each ( a , function ( v ) { if ( args . indexOf ( v ) === - 1 ) res . push ( v ) ; } ) ; return res ; } 
function rotate ( a , direction , amount ) { if ( ! ( a instanceof Array ) ) return a ; if ( direction && libs . object . isNumeric ( direction ) && ! amount ) { amount = direction ; direction = undefined ; } if ( ! amount || ( amount && ! libs . object . isNumeric ( amount ) ) ) amount = 1 ; for ( var i = 0 ; i < amount ; i ++ ) { if ( direction !== 'right' ) a . push ( a . shift ( ) ) ; else a . unshift ( a . pop ( ) ) ; } return a ; } 
function rotateLeft ( a , amount ) { if ( ! ( a instanceof Array ) ) return a ; return libs . array . rotate ( a , 'left' , amount ) ; } 
function makeUnique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { if ( visited . indexOf ( a [ i ] ) === - 1 ) { visited . push ( a [ i ] ) ; } else { a . splice ( i , 1 ) ; i -- ; 
function unique ( a ) { if ( ! ( a instanceof Array ) ) return a ; var visited = [ ] , unique = [ ] ; libs . object . each ( a , function ( item ) { if ( visited . indexOf ( item ) === - 1 ) { unique . push ( item ) ; visited . push ( item ) ; } } ) ; return unique ; } 
function ascending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a !== undefined && a !== null ) a = a . toString ( ) ; if ( b !== undefined && b !== null ) b = b . toString ( ) ; return a < b ? - 1 : a > b ? 1 : 0 ; } ) ; } 
function descending ( a ) { if ( ! ( a instanceof Array ) ) return a ; return a . sort ( function ( a , b ) { if ( a !== undefined && a !== null ) a = a . toString ( ) ; if ( b !== undefined && b !== null ) b = b . toString ( ) ; return a > b ? - 1 : a < b ? 1 : 0 ; } ) ; } 
function histogram ( ) { var histogram = { } ; libs . object . every ( arguments , function ( o ) { if ( typeof o === 'boolean' ) { if ( ! histogram [ o ] ) histogram [ o ] = 1 ; else histogram [ o ] ++ ; } else if ( typeof o === 'function' ) { if ( ! histogram [ 'function' ] ) histogram [ 'function' ] = 1 ; else histogram [ o ] ++ ; } else { libs . object . every ( o , function ( val ) { switch ( true ) { case typeof val === 'function' : case typeof val === 'undefined' : val = typeof val ; break ; case typeof val === 'object' && val === null : val = 'null' ; break ; case typeof val === 'object' && val instanceof Array : val = 'array' ; break ; case typeof val === 'object' : val = 'object' ; break ; default : val = val . toString ( ) ; } if ( typeof histogram [ val ] !== 'number' ) histogram [ val ] = 0 ; histogram [ val ] ++ ; } ) ; } } ) ; return histogram ; } 
function copy ( item ) { var copy ; if ( ! item ) return item ; switch ( typeof item ) { case 'string' : case 'number' : case 'function' : case 'boolean' : return item ; default : if ( item instanceof Array ) { return item . slice ( 0 ) ; } else { copy = { } ; } } libs . object . every ( item , function ( o , k ) { copy [ k ] = o ; } ) ; return copy ; } 
function occurrencesOf ( obj , what ) { if ( arguments . length < 2 ) return 0 ; if ( typeof obj === 'boolean' ) { return 0 ; } if ( typeof obj === 'number' ) { return occurrencesOf ( obj . toString ( ) , what ) ; } else if ( typeof obj === 'function' ) { return occurrencesOf ( fixFirefoxFunctionString ( obj . toString ( ) ) , what ) ; } var count = 0 ; if ( typeof obj === 'string' ) { if ( typeof what === 'string' || typeof what === 'number' ) { var regexp = new RegExp ( what . toString ( ) , 'g' ) , m ; while ( m = regexp . exec ( obj ) ) count ++ ; 
function keys ( o ) { if ( o === undefined || o === null ) return [ ] ; var keys = getKeys ( o ) , idx ; if ( libs . object . isArguments ( o ) ) { idx = keys . indexOf ( 'length' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; } return keys ; } 
function size ( o ) { switch ( true ) { case typeof o === 'function' : return 1 ; case typeof o === 'number' : return o . toString ( ) . length ; case o instanceof Array : case typeof o === 'string' : return o . length ; case libs . object . isArguments ( o ) && typeof o . length !== 'undefined' : return o . length ; case o && typeof o === 'object' : return Object . keys ( o ) . length ; default : return 0 ; } } 
function isNumeric ( ) { return libs . object . every ( arguments , function ( item ) { return ! isNaN ( parseFloat ( item ) ) && isFinite ( item ) ; } ) ; } 
function getNumeric ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { vals . push ( libs . object . isNumeric ( o ) ? parseFloat ( o ) : NaN ) ; } ) ; return vals . length === 1 ? vals [ 0 ] : vals ; } 
function isEmpty ( ) { return libs . object . every ( arguments , function ( item ) { return libs . object . size ( item ) === 0 && item !== false && item !== '' && item !== true ; } ) ; } 
function isArguments ( ) { return libs . object . every ( arguments , function ( item ) { return Object . prototype . toString . call ( item ) === '[object Arguments]' ; } ) ; } 
function toInt ( ) { var vals = [ ] ; libs . object . every ( arguments , function ( o ) { var radix = / ^0x / . test ( o ) ? 16 : 10 ; 
function random ( o ) { if ( typeof o === 'object' ) { return o instanceof Array ? o [ Math . floor ( Math . random ( ) * o . length ) ] : o [ Object . keys ( o ) [ Math . floor ( Math . random ( ) * Object . keys ( o ) . length ) ] ] ; } else if ( typeof o === 'string' || typeof o === 'number' ) { var val = o , negative = false ; if ( o . length === 0 ) return '' ; if ( typeof o === 'number' && o < 0 ) { negative = true ; val = Math . abs ( val ) ; } val = val . toString ( ) [ Math . floor ( Math . random ( ) * val . toString ( ) . length ) ] ; if ( typeof o === 'number' ) val = parseInt ( val , 10 ) ; return negative ? - val : val ; } return o ; } 
function each ( o , rangeA , rangeB , f ) { 
function any ( o , f ) { f = f instanceof Function ? f : undefined ; if ( f instanceof Function ) { var self = o , keys , property , value ; if ( typeof self === 'number' || typeof self === 'function' || typeof self === 'boolean' ) self = o . toString ( ) ; 
function toArray ( o ) { if ( o instanceof Array ) return libs . object . copy ( o ) ; var arr = [ ] ; libs . object . each ( o , function ( val ) { arr . push ( val ) ; } ) ; return arr ; } 
function first ( o , n ) { var gotN = ( n === 0 ? true : ! ! n ) , v ; n = parseInt ( n , 10 ) ; n = isNaN ( n ) || ! isFinite ( n ) ? 1 : n ; if ( typeof o === 'boolean' ) { return o ; } else if ( typeof o !== 'object' ) { if ( n !== 0 ) v = o . toString ( ) . slice ( 0 , n ) ; else return undefined ; } else if ( o instanceof Array ) { if ( n === 1 && ! gotN ) return o [ 0 ] ; if ( n === 0 && ! gotN ) return undefined ; return n !== 0 ? o . slice ( 0 , n ) : [ ] ; } else { v = { } ; libs . object . each ( o , 0 , n - 1 , function ( item , key ) { v [ key ] = item ; } ) ; var keys = getKeys ( v ) ; if ( n === 1 && ! gotN && keys . length === 0 ) return undefined ; return keys . length === 1 && ! gotN ? v [ keys [ 0 ] ] : v ; } return v . length === 1 && ! gotN ? v [ 0 ] : v ; } 
function last ( o , n ) { if ( typeof o === 'boolean' ) return o ; var gotN = ( ! ! n || n === 0 ) ; n = parseInt ( n , 10 ) ; n = isNaN ( n ) || ! isFinite ( n ) ? 1 : n ; var v = null , keys , len = libs . object . size ( o ) , idx ; if ( typeof o === 'boolean' ) { return o ; } else if ( libs . object . isArguments ( o ) ) { keys = getKeys ( o ) ; idx = keys . indexOf ( 'length' ) ; if ( idx > - 1 ) keys . splice ( idx , 1 ) ; v = [ ] ; len = keys . length ; 
function getCallback ( o ) { var last = libs . object . last ( o ) ; return last instanceof Function ? last : NULL_FUNCTION ; } 
function findChildAtPath ( o , path , delimiter , original , invoked , done ) { done = libs . object . getCallback ( arguments ) ; var self = o ; original = ( ! ( original instanceof Function ) && original ) ? original : self ; invoked = invoked || false ; if ( typeof o === 'object' && typeof path === 'string' ) { delimiter = typeof delimiter === 'string' ? delimiter : '.' ; path = path . split ( delimiter ) ; var p = path . shift ( ) ; if ( p ) { return libs . object . each ( o , function ( o , k , i , exit ) { if ( path . length === 0 && k === p ) { done . call ( original , o , self , k ) ; invoked = true ; exit ( o ) ; } else { var obj = libs . object . findChildAtPath ( o , path . join ( delimiter ) , delimiter , original , invoked , done ) ; if ( obj !== null ) exit ( obj ) ; } } ) ; } } if ( ! invoked && original === self && done instanceof Function ) done . call ( original , null , self , null ) ; return null ; } 
function clone ( o , replacer ) { if ( typeof o === 'string' || typeof o === 'number' ) return o ; try { return JSON . parse ( JSON . stringify ( o , replacer ) ) ; } catch ( e ) { throw new Error ( 'Unable to clone object: ' + e . message ) ; } } 
function only ( o , types ) { types = libs . object . toArray ( arguments ) ; types . shift ( ) ; 
function whereKeys ( o , predicate ) { if ( ! ( predicate instanceof Function ) ) { var temp = predicate ; predicate = function ( k ) { return k == temp ; } ; 
function invert ( o ) { if ( o === null || o === undefined ) return o ; if ( typeof o === 'string' ) return libs . string . reverse ( o ) ; if ( typeof o === 'number' ) return 1 / o ; if ( typeof o === 'boolean' ) return ! o ; if ( typeof o === 'function' ) { return function ( ) { return libs . object . invert ( o . apply ( o , arguments ) ) ; } ; } var obj = { } ; libs . object . each ( o , function ( item , key ) { if ( typeof item === 'string' || typeof item === 'number' ) { if ( ! obj [ item ] ) { obj [ item ] = key ; } else { var tmp = obj [ item ] ; obj [ item ] = [ ] ; obj [ item ] . push ( tmp , key ) ; } } } ) ; return obj ; } 
function max ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , maxValue ; if ( ! func ) { max = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item >= max ) max = item ; } ) ; } else { max = libs . object . first ( o ) ; maxValue = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value >= maxValue ) { max = item ; maxValue = value ; } } ) ; } return max ; } 
function keyOfMax ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; var max , maxValue , maxKey ; if ( ! func ) { max = libs . object . first ( o ) ; maxKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item >= max ) { max = item ; maxKey = key ; } } ) ; } else { max = libs . object . first ( o ) ; maxKey = libs . object . keys ( o ) [ 0 ] ; maxValue = func . call ( max , max ) ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value >= maxValue ) { if ( value >= maxValue ) { max = item ; maxValue = value ; maxKey = key ; } } } ) ; } return maxKey ; } 
function min ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o !== 'object' ) return o ; var min , minValue ; if ( ! func ) { min = libs . object . first ( o ) ; libs . object . each ( o , 1 , function ( item ) { if ( item <= min ) min = item ; } ) ; } else { min = libs . object . first ( o ) ; minValue = func . call ( min , min ) ; libs . object . each ( o , 1 , function ( item ) { var value = func . call ( item , item ) ; if ( value <= minValue ) { min = item ; minValue = value ; } } ) ; } return min ; } 
function keyOfMin ( o , func ) { if ( ! o || typeof o !== 'object' ) return o ; if ( libs . object . size ( o ) === 0 ) return ; if ( ! ( func instanceof Function ) ) func = undefined ; if ( typeof o !== 'object' ) return o ; var min , minValue , minKey ; if ( ! func ) { min = libs . object . first ( o ) ; minKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { if ( item <= min ) { min = item ; minKey = key ; } } ) ; } else { min = libs . object . first ( o ) ; minValue = func . call ( min , min ) ; minKey = libs . object . keys ( o ) [ 0 ] ; libs . object . each ( o , 1 , function ( item , key ) { var value = func . call ( item , item ) ; if ( value <= minValue ) { min = item ; minValue = value ; minKey = key ; } } ) ; } return minKey ; } 
function _implements ( ) { var args = libs . object . toArray ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) ) return false ; } ) ; } 
function implementsOwn ( o , method ) { var args = libs . object . toArray ( arguments ) , a = args . shift ( ) ; if ( ! a ) return false ; return libs . object . every ( args , function ( m ) { if ( ! ( a [ m ] instanceof Function ) || ! o . hasOwnProperty ( method ) ) return false ; } ) ; } 
function create ( props ) { var joystick = Object . create ( this ) ; 
function draw ( ) { 
function create ( ) { var shouldUseTouch = _utilities2 . default . getMode ( ) === 'touch' ; _widget2 . default . create . call ( this ) ; Object . assign ( this , DOMWidget . defaults ) ; * The DOM element used by the DOMWidget * @memberof DOMWidget * @instance */ this . element = this . createElement ( ) ; } else { throw new Error ( 'widget inheriting from DOMWidget does not implement createElement method; this is required.' ) ; } } 
function place ( ) { var containerWidth = this . container . getWidth ( ) , containerHeight = this . container . getHeight ( ) , width = this . width <= 1 ? containerWidth * this . width : this . width , height = this . height <= 1 ? containerHeight * this . height : this . height , x = this . x < 1 ? containerWidth * this . x : this . x , y = this . y < 1 ? containerHeight * this . y : this . y ; if ( ! this . attached ) { this . attached = true ; } if ( this . isSquare ) { if ( height > width ) { height = width ; } else { width = height ; } } this . element . width = width ; this . element . style . width = width + 'px' ; this . element . height = height ; this . element . style . height = height + 'px' ; this . element . style . left = x ; this . element . style . top = y ; this . rect = this . element . getBoundingClientRect ( ) ; } 
function normalizeAttributes ( attributes ) { let mainAttributes = [ ] let maxValue for ( let key in attributes ) { if ( validAttributes . indexOf ( key ) === - 1 ) { continue } if ( ! maxValue || attributes [ key ] > maxValue ) { maxValue = attributes [ key ] mainAttributes = [ key ] } else if ( attributes [ key ] === maxValue ) { mainAttributes . push ( key ) } } let secondaryAttributes = Object . keys ( attributes ) . filter ( a => mainAttributes . indexOf ( a ) === - 1 && validAttributes . indexOf ( a ) !== - 1 ) return [ mainAttributes , secondaryAttributes ] } 
function equalArrayElements ( needle , haystack ) { let missingNeedle = needle . filter ( n => haystack . indexOf ( n ) === - 1 ) if ( missingNeedle . length !== 0 ) { return false } let missingHaystack = haystack . filter ( h => needle . indexOf ( h ) === - 1 ) return missingHaystack . length === 0 } 
function getAsyncFncWrapper ( asyncFncWrapper ) { if ( ! asyncFncWrapper ) return setImmediate ; else if ( asyncFncWrapper === true ) return function ( cb ) { cb ( ) ; } ; else if ( ! ( asyncFncWrapper === setImmediate || asyncFncWrapper === setTimeout || typeof asyncFncWrapper === 'function' ) ) { throw new Error ( 'Wrong argument "asyncFncWrapper", it have to be function, setImmediate, setTimeout, ' + 'or true when use default function, or undefined to use setImmediate' ) ; } return asyncFncWrapper ; } 
function Series ( asyncFncWrapper ) { asyncFncWrapper = getAsyncFncWrapper ( asyncFncWrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length === 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc !== 'function' ) throw new Error ( 'Async Series: Last argument have to be function(arg1, arg2, ..., next).' ) ; this . _fncQueue = this . _fncQueue || [ ] ; this . _fncQueue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( finalFnc ) { var fncQueue = this . _fncQueue ; fncQueue . current = 0 ; fncQueue . scheduled = 0 ; function run ( itm ) { asyncFncWrapper ( function ( ) { fncQueue . scheduled = fncQueue . current ; if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( ! fncQueue || fncQueue . scheduled !== fncQueue . current ) throw new Error ( 'Async Series: cannot execute next() more than once per function' ) ; 
function Parallel ( asyncFncWrapper ) { asyncFncWrapper = getAsyncFncWrapper ( asyncFncWrapper ) ; this . add = function ( ) { var fnc , args ; if ( arguments . length === 1 ) { fnc = arguments [ 0 ] ; } else if ( arguments . length > 1 ) { fnc = arguments [ arguments . length - 1 ] ; args = [ ] ; for ( var i = 0 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } } if ( typeof fnc !== 'function' ) throw new Error ( 'Async Parallel: Last argument have to be function(arg1, arg2, ..., next).' ) ; this . _fncQueue = this . _fncQueue || [ ] ; this . _fncQueue . push ( { args : args , fnc : fnc } ) ; this . execute = function ( finalFnc ) { var fncQueue = this . _fncQueue ; fncQueue . finished = 0 ; function run ( itm ) { asyncFncWrapper ( function ( ) { if ( itm . args ) { itm . args . push ( next ) ; itm . fnc . apply ( itm , itm . args ) ; } else itm . fnc ( next ) ; } ) ; } function next ( ) { if ( arguments . length > 0 ) throw new Error ( 'Async Parallel: next() callback do not accept any arguments, ' + 'because of parallel behaviour, it cannot stop executing on error argument in callback' ) ; else if ( ! fncQueue ) 
function create ( props ) { var menu = Object . create ( this ) ; _domWidget2 . default . create . call ( menu ) ; Object . assign ( menu , Menu . defaults , props ) ; menu . createOptions ( ) ; menu . element . addEventListener ( 'change' , function ( e ) { menu . __value = e . target . value ; menu . output ( ) ; if ( menu . onvaluechange !== null ) { menu . onvaluechange ( menu . value ) ; } } ) ; return menu ; } 
function createOptions ( ) { this . element . innerHTML = '' ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = this . options [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var option = _step . value ; var optionEl = document . createElement ( 'option' ) ; optionEl . setAttribute ( 'value' , option ) ; optionEl . innerText = option ; this . element . appendChild ( optionEl ) ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } } 
function create ( props ) { var multiSlider = Object . create ( this ) ; 
function draw ( ) { 
function processPointerPosition ( e ) { var prevValue = this . value , sliderNum = void 0 ; if ( this . style === 'horizontal' ) { sliderNum = Math . floor ( e . clientY / this . rect . height / ( 1 / this . count ) ) ; this . __value [ sliderNum ] = ( e . clientX - this . rect . left ) / this . rect . width ; } else { sliderNum = Math . floor ( e . clientX / this . rect . width / ( 1 / this . count ) ) ; this . __value [ sliderNum ] = 1 - ( e . clientY - this . rect . top ) / this . rect . height ; } for ( var i = 0 ; i < this . count ; i ++ ) { if ( this . __value [ i ] > 1 ) this . __value [ i ] = 1 ; if ( this . __value [ i ] < 0 ) this . __value [ i ] = 0 ; } var shouldDraw = this . output ( ) ; if ( shouldDraw ) this . draw ( ) ; } 
function matchAll ( regex , string ) { let match let matches = [ ] while ( ( match = regex . exec ( string ) ) !== null ) { delete match [ 'index' ] delete match [ 'input' ] matches . push ( match ) } return matches } 
function ( fPath , fnAdd , fnRemove , depth ) { fs . stat ( fPath , function onStat ( err , stats ) { if ( err ) { return fnAdd && fnAdd ( err ) ; } if ( stats . isDirectory ( ) && depth > 0 ) { 
function flushBuffer ( ) { if ( fileBuffer . length > 0 && original_fnAdd ) { var tempBuffer = fileBuffer ; fileBuffer = [ ] ; original_fnAdd ( null , tempBuffer ) ; } flushTimer = null ; } 
function flushBuffer ( ) { if ( fileBuffer . length > 0 && original_fnRemove ) { var tempBuffer = fileBuffer ; fileBuffer = [ ] ; original_fnRemove ( null , tempBuffer ) ; } flushTimer = null ; } 
function beforeEach ( test , context , done ) { context . dir = tmp . dirSync ( ) . name ; process . chdir ( context . dir ) ; done && done ( ) ; } 
function promiseShouldFail ( promise , done , handler ) { promise . then ( result => done ( new Error ( 'Promise expected to fail' ) ) ) . catch ( error => { handler ( error ) done ( ) } ) . catch ( error => done ( error ) ) } 
function promiseShouldSucceed ( promise , done , handler ) { promise . then ( result => { handler ( result ) done ( ) } ) . catch ( error => done ( error ) ) } 
function copyAssetToContext ( src , dest , context ) { var sourceAsset = path . join ( testDir , src ) ; var targetAsset = path . join ( context . dir , dest ) ; if ( ! fs . existsSync ( sourceAsset ) ) { 
function deepSet ( parent , key , value , mode ) { 
function update ( obj , expression ) { if ( isObject ( expression ) ) for ( var key in expression ) { if ( isObject ( expression [ key ] ) ) { if ( key === '$set' ) obj = update ( obj , expression [ key ] ) ; else if ( key === '$inc' ) for ( var prop in expression [ key ] ) { if ( typeof expression [ key ] [ prop ] === 'number' ) { var orig = deepGet ( obj , prop ) ; if ( orig === undefined ) obj = deepSet ( obj , prop , expression [ key ] [ prop ] ) ; else if ( typeof orig === 'number' ) obj = deepSet ( obj , prop , orig + expression [ key ] [ prop ] ) ; } } else if ( key === '$max' || key === '$min' ) for ( var prop in expression [ key ] ) { if ( typeof expression [ key ] [ prop ] === 'number' ) { var orig = deepGet ( obj , prop ) ; if ( key === '$max' && orig < expression [ key ] [ prop ] ) obj = deepSet ( obj , prop , expression [ key ] [ prop ] ) ; else if ( key === '$min' && orig > expression [ key ] [ prop ] ) obj = deepSet ( obj , prop , expression [ key ] [ prop ] ) ; } } else if ( key === '$pull' || key === '$pullAll' ) for ( var prop in expression [ key ] ) { var orig = deepGet ( obj , prop ) , value = expression [ key ] [ prop ] ; if ( Array . isArray ( orig ) ) { if ( ! Array . isArray ( value ) ) value = [ value ] ; for ( var i = 0 ; i < value . length ; i ++ ) { var index = orig . indexOf ( value [ i ] ) ; if ( index !== - 1 ) orig . splice ( index , 1 ) ; } obj = deepSet ( obj , prop , orig ) ; } } else if ( key === '$push' ) for ( var prop in expression [ key ] ) { var orig = deepGet ( obj , prop ) , value = expression [ key ] [ prop ] ; if ( value . $each ) value = value . $each ; if ( Array . isArray ( orig ) ) { if ( ! Array . isArray ( value ) ) value = [ value ] ; for ( var i = 0 ; i < value . length ; i ++ ) { orig . push ( value [ i ] ) ; } obj = deepSet ( obj , prop , orig ) ; } } else if ( key [ 0 ] === '$' ) continue ; 
function ( fPath , strict , fn ) { if ( typeof ( strict ) === 'function' ) { fn = strict ; strict = false ; } var dir = path . dirname ( fPath ) ; var base = path . basename ( fPath ) ; if ( typeof watched === 'undefined' ) { return fn && fn ( '[checkFile] watched array not properly defined.' ) ; } else { fs . stat ( fPath , function onStat ( err , stats ) { 
function create ( props ) { var shouldUseTouch = _utilities2 . default . getMode ( ) === 'touch' ; _domWidget2 . default . create . call ( this ) ; Object . assign ( this , CanvasWidget . defaults ) ; this . ctx = this . element . getContext ( '2d' ) ; this . applyHandlers ( shouldUseTouch ) ; } 
function createElement ( ) { var element = document . createElement ( 'canvas' ) ; element . setAttribute ( 'touch-action' , 'none' ) ; element . style . position = 'absolute' ; element . style . display = 'block' ; return element ; } 
function convertOfficialArray ( attributes ) { let map = { } attributes . map ( attribute => { let key = officialAttributeMap [ attribute . attribute ] map [ key ] = attribute . modifier } ) return map } 
function convertOfficialMap ( attributes ) { let map = { } for ( let attribute in attributes ) { let key = officialAttributeMap [ attribute ] map [ key ] = attributes [ attribute ] } return map } 
function ( ) { return _ . map ( ko . unwrap ( that . relations ) , function ( relation ) { return ko . unwrap ( relation . relatedPost . id ) ; } ) ; } 
function ( postIds ) { if ( ! postIds ) return ; var updatedRelations = [ ] ; 
function ( element , valueAccessor , allBindings , viewModel , bindingContext ) { var $element = $ ( element ) ; var observable = valueAccessor ( ) ; if ( ko . unwrap ( observable ) ) { $element . datepicker ( 'update' , observable . datePicker ( ) . format ( 'DD.MM.YYYY' ) ) ; 
function jajax ( o , done , fail , _u ) { let xhr = jajax . createXHR ( FALSE ) ; if ( ! xhr ) { fail && fail ( NULL , 'xhr' , ` ` ) ; return xhr ; } if ( type ( o ) == 'String' ) { if ( done && type ( done ) == 'Object' ) { done . url = o ; o = done ; done = fail ; fail = _u ; } else { o = { url : o } ; } } o = extend ( { url : '' , 
function type ( obj ) { 
function each ( o , f ) { if ( ! o ) return o ; if ( isArray ( o ) || isArrayLike ( o ) ) { for ( let i = 0 , l = o [ LENGTH ] >>> 0 ; i < l ; i ++ ) if ( hop . call ( o , i ) ) { let s = o [ i ] ; if ( f . call ( s , i , s , o ) === FALSE ) return i ; } } else { for ( let i in o ) if ( hop . call ( o , i ) ) { let s = o [ i ] ; if ( f . call ( s , i , s , o ) === FALSE ) return i ; } } return o ; } 
function extend ( o ) { const cpy = ( i , s ) => { o [ i ] = s ; } ; each ( arguments , ( i , a ) => { i && each ( a , cpy ) ; } ) ; return o ; } 
async function disposable ( ) { const name = "tmp" + Math . floor ( Math . random ( ) * 10000 ) ; await connection . dbCreate ( name ) . run ( ) ; const r = Object . create ( connection ) ; r . dispose = async function ( ) { await this . dbDrop ( name ) . run ( ) ; } ; r . _poolMaster . _options . db = name ; return r ; } 
function runRequestQueue ( socket ) { var queue = socket . requestQueue ; if ( ! queue ) return ; for ( var i in queue ) { 
function JWR ( responseCtx ) { this . body = responseCtx . body || { } ; this . headers = responseCtx . headers || { } ; this . statusCode = responseCtx . statusCode || 200 ; if ( this . statusCode < 200 || this . statusCode >= 400 ) { this . error = this . body || this . statusCode ; } } 
function SailsSocket ( opts ) { var self = this ; opts = opts || { } ; 
function create ( props ) { var slider = Object . create ( this ) ; 
function draw ( ) { 
function processPointerPosition ( e ) { var prevValue = this . value ; if ( this . style === 'horizontal' ) { this . __value = ( e . clientX - this . rect . left ) / this . rect . width ; } else { this . __value = 1 - ( e . clientY - this . rect . top ) / this . rect . height ; } 
function setter ( obj , prop , value ) { var propDashed = prop . replace ( / _ / g , '-' ) ; var propUnderscored = prop . replace ( / \- / g , '_' ) ; obj [ prop ] = value ; obj [ propDashed ] = value ; obj [ propUnderscored ] = value ; return true ; } 
function replacer ( startString , endString ) { var startStringEscaped = startString . escape ( ) ; var endStringEscaped = endString . escape ( ) ; var matchRegexp = new RegExp ( startStringEscaped + '([^' + startString [ 0 ] . escape ( ) + endString [ 0 ] . escape ( ) + ']+)' + endStringEscaped , 'g' ) ; return function ( template , model ) { var brackets = template . match ( matchRegexp ) || [ ] , value ; for ( var i = 0 ; i < brackets . length ; i ++ ) { brackets [ i ] = brackets [ i ] . replace ( startString , '' ) . replace ( endString , '' ) ; value = object . getValue ( model , brackets [ i ] . trim ( ) ) || '' ; template = template . replace ( new RegExp ( startStringEscaped + brackets [ i ] + endStringEscaped , 'g' ) , value ) ; } return template ; } ; } 
function fromMongo ( item ) { if ( Array . isArray ( item ) && item . length ) { item = item [ 0 ] ; } item . id = item . _id ; delete item . _id ; return item ; } 
function getCollection ( cb ) { if ( collection ) { setImmediate ( function ( ) { cb ( null , collection ) ; } ) ; return ; } MongoClient . connect ( url , function ( err , db ) { if ( err ) { return cb ( err ) ; } collection = db . collection ( collectionName ) ; cb ( null , collection ) ; } ) ; } 
function list ( qs , limit , token , cb ) { token = token ? parseInt ( token , 10 ) : 0 ; if ( isNaN ( token ) ) { return cb ( new Error ( 'invalid token' ) ) ; } getCollection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . find ( { } ) . skip ( token ) . limit ( limit ) . toArray ( function ( err , results ) { if ( err ) { return cb ( err ) ; } var hasMore = results . length === limit ? token + results . length : false ; cb ( null , results . map ( fromMongo ) , hasMore ) ; 
function read ( id , cb ) { if ( ! / ^[a-fA-F0-9]{24}$ / . test ( id ) ) { return cb ( { code : 404 , message : 'Not valid ObjectId. Must be 24 hex string or 12 hex binary sequence.' } ) } ; getCollection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . findOne ( { _id : new ObjectID ( id ) } , function ( err , result ) { if ( err ) { return cb ( err ) ; } if ( ! result ) { return cb ( { code : 404 , message : 'Not found' } ) ; } cb ( null , fromMongo ( result ) ) ; } ) ; } ) ; } 
function update ( id , data , cb ) { getCollection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . update ( { _id : new ObjectID ( id ) } , { '$set' : toMongo ( data ) } , { w : 1 } , function ( err ) { if ( err ) { return cb ( err ) ; } return read ( id , cb ) ; } ) ; } ) ; } 
function _delete ( id , cb ) { getCollection ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } collection . remove ( { _id : new ObjectID ( id ) } , cb ) ; } ) ; } 
function pushConstraints ( constraints , param = config ) { let emitterConstraints = new EventEmitter ( ) ; portSocket = param . portSocket ; addressWarehouse = param . warehouseAddress ; urlSocket = ` ${ addressWarehouse } ${ portSocket } ` ; handshake ( param ) . then ( ( ) => { let socket = io . connect ( urlSocket ) ; let msg = messageBuilder ( constraints , 'pushConstraints' ) ; socket . on ( 'connect' , function ( ) { socket . emit ( 'pushConstraints' , msg ) ; } ) . on ( 'resultsConstraints' , ( messageResults ) => { if ( messageResults . value === 'found' ) { logger_1 . logger . log ( 'info' , ` ` ) ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( messageResults ) } ` ) ; let workPath = messageResults . data [ 0 ] . workDir ; fStdout_fSterr_Check ( workPath ) . on ( 'checkOK' , ( nameOut , nameErr ) => { logger_1 . logger . log ( 'success' , ` ${ messageResults . data . length } ` ) ; emitterConstraints . emit ( 'foundDocs' , nameOut , nameErr , workPath ) ; } ) . on ( 'checkNotOK' , ( ) => { emitterConstraints . emit ( 'notFoundDocs' ) ; } ) ; } ; if ( messageResults . value === 'notFound' ) { logger_1 . logger . log ( 'info' , ` ` ) ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( messageResults ) } ` ) ; emitterConstraints . emit ( 'notFoundDocs' , messageResults ) ; } if ( messageResults . value === 'errorConstraints' ) emitterConstraints . emit ( 'errorDocs' , messageResults ) ; } ) ; } ) . catch ( ( ) => { emitterConstraints . emit ( 'cantConnect' ) ; } ) ; return emitterConstraints ; } 
function storeJob ( jobCompleted ) { 
function messageBuilder ( data , event , store = false , index = false ) { let message = { 'type' : store ? 'store' : index ? 'indexation' : 'request' , 'value' : event , 'data' : data } ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( message ) } ` ) ; return message ; } 
function fStdout_fSterr_Check ( workDir ) { let emitterCheck = new EventEmitter ( ) ; let splitWorkDir = workDir . split ( '/' ) ; let nameOut = path . basename ( workDir ) + ".out" ; let nameErr = path . basename ( workDir ) + ".err" ; let pathOut = workDir + "/" + nameOut ; let pathErr = workDir + "/" + nameErr ; pathExists ( pathOut ) . then ( existsOut => { if ( existsOut ) { pathExists ( pathErr ) . then ( existsErr => { if ( existsErr ) { emitterCheck . emit ( 'checkOK' , nameOut , nameErr ) ; } else emitterCheck . emit ( 'checkNotOK' ) ; } ) . catch ( err => { emitterCheck . emit ( 'checkNotOK' ) ; } ) ; } else emitterCheck . emit ( 'checkNotOK' ) ; } ) . catch ( err => { emitterCheck . emit ( 'checkNotOK' ) ; } ) ; return emitterCheck ; } 
function handshake ( param ) { return new Promise ( ( resolve , reject ) => { if ( types . isClientConfig ( param ) ) { logger_1 . logger . log ( 'info' , ` ` ) ; logger_1 . logger . log ( 'debug' , ` \n ${ JSON . stringify ( param ) } ` ) ; let socket = io . connect ( ` ${ param . warehouseAddress } ${ param . portSocket } ` ) ; socket . on ( 'connect' , function ( ) { logger_1 . logger . log ( 'info' , ` \n ` ) ; resolve ( ) ; } ) . on ( 'connect_error' , function ( ) { logger_1 . logger . log ( 'debug' , ` \n ` ) ; reject ( ) ; socket . disconnect ( ) ; } ) ; } else { logger_1 . logger . log ( 'error' , ` \n ${ JSON . stringify ( config ) } ` ) ; reject ( ) ; } } ) ; } 
function pivotTable ( dataset ) { var column_names = [ ] ; var xvalues = [ ] ; var values = { } ; var rows = { } ; for ( rn in dataset . data ) { 
function VMessage ( reason , position , origin ) { var parts var range var location if ( typeof position === 'string' ) { origin = position position = null } parts = parseOrigin ( origin ) range = stringify ( position ) || '1:1' location = { start : { line : null , column : null } , end : { line : null , column : null } } 
function asyncProcessFileErrorWrapper ( e ) { if ( typeof e !== 'object' ) e = new Error ( '' + e ) ; e . file = relativePath ; e . treeDir = srcDir ; throw e ; } 
function mkdirSyncRecursive ( directory ) { var path = directory . replace ( / \/$ / , '' ) . split ( '/' ) ; for ( var i = 1 ; i <= path . length ; i ++ ) { var segment = path . slice ( 0 , i ) . join ( '/' ) ; segment . length > 0 && ! fs . existsSync ( segment ) ? fs . mkdirSync ( segment ) : null ; } } 
function init ( user_id , secret , storage , callback ) { API_USER_ID = user_id ; API_SECRET = secret ; TOKEN_STORAGE = storage ; if ( ! callback ) { callback = function ( ) { } } if ( ! fs . existsSync ( TOKEN_STORAGE ) ) { mkdirSyncRecursive ( TOKEN_STORAGE ) ; } if ( TOKEN_STORAGE . substr ( - 1 ) !== '/' ) { TOKEN_STORAGE += '/' ; } var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; if ( fs . existsSync ( TOKEN_STORAGE + hashName ) ) { TOKEN = fs . readFileSync ( TOKEN_STORAGE + hashName , { encoding : 'utf8' } ) ; } if ( ! TOKEN . length ) { getToken ( callback ) ; return ; } callback ( TOKEN ) } 
function getEmailTemplate ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty email template id' ) ) ; } sendRequest ( 'template/' + id , 'GET' , { } , true , callback ) ; } 
function updateEmailVariables ( callback , id , email , variables ) { if ( ( id === undefined ) || ( email === undefined ) || ( variables === undefined ) || ( ! variables . length ) ) { return callback ( returnError ( "Empty email, variables or book id" ) ) ; } var data = { email : email , variables : variables } ; sendRequest ( 'addressbooks/' + id + '/emails/variable' , 'POST' , data , true , callback ) ; } 
function smsAddPhones ( callback , addressbook_id , phones ) { if ( ( addressbook_id === undefined ) || ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones or book id" ) ) ; } var data = { addressBookId : addressbook_id , phones : JSON . stringify ( phones ) } ; sendRequest ( 'sms/numbers' , 'POST' , data , true , callback ) ; } 
function smsAddPhonesWithVariables ( callback , addressbook_id , phones ) { if ( ( addressbook_id === undefined ) || ( phones === undefined ) || ( ! Object . keys ( phones ) . length ) ) { return callback ( returnError ( "Empty phones or book id" ) ) ; } var data = { addressBookId : addressbook_id , phones : JSON . stringify ( phones ) } ; sendRequest ( 'sms/numbers/variables' , 'POST' , data , true , callback ) ; } 
function smsGetPhoneInfo ( callback , addressbook_id , phone ) { if ( ( addressbook_id === undefined ) || ( phone === undefined ) ) { return callback ( returnError ( "Empty phone or book id" ) ) ; } sendRequest ( 'sms/numbers/info/' + addressbook_id + '/' + phone , 'GET' , { } , true , callback ) ; } 
function smsUpdatePhonesVariables ( callback , addressbook_id , phones , variables ) { if ( addressbook_id === undefined ) { return callback ( returnError ( "Empty book id" ) ) ; } if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } if ( ( variables === undefined ) || ( ! Object . keys ( variables ) . length ) ) { return callback ( returnError ( "Empty variables" ) ) ; } var data = { 'addressBookId' : addressbook_id , 'phones' : JSON . stringify ( phones ) , 'variables' : JSON . stringify ( variables ) } sendRequest ( 'sms/numbers' , 'PUT' , data , true , callback ) ; } 
function smsAddPhonesToBlacklist ( callback , phones , comment ) { if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } var data = { 'phones' : JSON . stringify ( phones ) , 'description' : comment } sendRequest ( 'sms/black_list' , 'POST' , data , true , callback ) ; } 
function smsDeletePhonesFromBlacklist ( callback , phones ) { if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } var data = { 'phones' : JSON . stringify ( phones ) , } sendRequest ( 'sms/black_list' , 'DELETE' , data , true , callback ) ; } 
function smsAddCampaign ( callback , sender_name , addressbook_id , body , date , transliterate ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( addressbook_id === undefined ) { return callback ( returnError ( "Empty book id" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } var data = { 'sender' : sender_name , 'addressBookId' : addressbook_id , 'body' : body , 'date' : date , 'transliterate' : transliterate } sendRequest ( 'sms/campaigns' , 'POST' , data , true , callback ) ; } 
function smsSend ( callback , sender_name , phones , body , date , transliterate ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty phones" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } var data = { 'sender' : sender_name , 'phones' : JSON . stringify ( phones ) , 'body' : body , 'date' : date , 'transliterate' : transliterate } sendRequest ( 'sms/send' , 'POST' , data , true , callback ) ; } 
function smsGetListCampaigns ( callback , date_from , date_to ) { var data = { 'dateFrom' : date_from , 'dateTo' : date_to } sendRequest ( 'sms/campaigns/list' , 'GET' , data , true , callback ) ; } 
function smsGetCampaignInfo ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } sendRequest ( 'sms/campaigns/info/' + campaign_id , 'GET' , { } , true , callback ) ; } 
function smsCancelCampaign ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } sendRequest ( 'sms/campaigns/cancel/' + campaign_id , 'PUT' , { } , true , callback ) ; } 
function smsGetCampaignCost ( callback , sender_name , body , addressbook_id , phones ) { if ( sender_name === undefined ) { return callback ( returnError ( "Empty sender name" ) ) ; } if ( body === undefined ) { return callback ( returnError ( "Empty sms text" ) ) ; } if ( ( addressbook_id === undefined ) || ( phones === undefined ) || ( ! phones . length ) ) { return callback ( returnError ( "Empty book id or phones" ) ) ; } var data = { 'sender' : sender_name , 'body' : body , 'addressBookId' : addressbook_id } if ( phones . length ) { data [ 'phones' ] = JSON . stringify ( phones ) ; } sendRequest ( 'sms/campaigns/cost' , 'GET' , data , true , callback ) ; } 
function smsDeleteCampaign ( callback , campaign_id ) { if ( campaign_id === undefined ) { return callback ( returnError ( "Empty sms campaign id" ) ) ; } var data = { 'id' : campaign_id } sendRequest ( 'sms/campaigns' , 'DELETE' , data , true , callback ) ; } 
function forEach ( arr , callback , scope ) { var i , len = arr . length ; for ( i = 0 ; i < len ; i += 1 ) { callback . call ( scope , arr [ i ] , i ) ; } } 
function emit ( instance , name ) { var args = [ ] . slice . call ( arguments , 2 ) ; if ( events . indexOf ( name ) > - 1 ) { if ( instance . handlers [ name ] && instance . handlers [ name ] instanceof Array ) { forEach ( instance . handlers [ name ] , function ( handle ) { window . setTimeout ( function ( ) { handle . callback . apply ( handle . context , args ) ; } , 0 ) ; } ) ; } } else { throw new Error ( name + ' event cannot be found on TreeView.' ) ; } } 
function render ( self ) { var container = isDOMElement ( self . node ) ? self . node : document . getElementById ( self . node ) ; var leaves = [ ] , click ; var renderLeaf = function ( item ) { var leaf = document . createElement ( 'div' ) ; var content = document . createElement ( 'div' ) ; var text = document . createElement ( 'div' ) ; var expando = document . createElement ( 'div' ) ; leaf . setAttribute ( 'class' , 'tree-leaf' ) ; content . setAttribute ( 'class' , 'tree-leaf-content' ) ; content . setAttribute ( 'data-item' , JSON . stringify ( item ) ) ; text . setAttribute ( 'class' , 'tree-leaf-text' ) ; text . textContent = item . name ; expando . setAttribute ( 'class' , 'tree-expando ' + ( item . expanded ? 'expanded' : '' ) ) ; expando . textContent = item . expanded ? '-' : '+' ; content . appendChild ( expando ) ; content . appendChild ( text ) ; leaf . appendChild ( content ) ; if ( item . children && item . children . length > 0 ) { var children = document . createElement ( 'div' ) ; children . setAttribute ( 'class' , 'tree-child-leaves' ) ; forEach ( item . children , function ( child ) { var childLeaf = renderLeaf ( child ) ; children . appendChild ( childLeaf ) ; } ) ; if ( ! item . expanded ) { children . classList . add ( 'hidden' ) ; } leaf . appendChild ( children ) ; } else { expando . classList . add ( 'hidden' ) ; } return leaf ; } ; forEach ( self . data , function ( item ) { leaves . push ( renderLeaf . call ( self , item ) ) ; } ) ; container . innerHTML = leaves . map ( function ( leaf ) { return leaf . outerHTML ; } ) . join ( '' ) ; click = function ( e ) { var parent = ( e . target || e . currentTarget ) . parentNode ; var data = JSON . parse ( parent . getAttribute ( 'data-item' ) ) ; var leaves = parent . parentNode . querySelector ( '.tree-child-leaves' ) ; if ( leaves ) { if ( leaves . classList . contains ( 'hidden' ) ) { self . expand ( parent , leaves ) ; } else { self . collapse ( parent , leaves ) ; } } else { emit ( self , 'select' , { target : e , data : data } ) ; } } ; forEach ( container . querySelectorAll ( '.tree-leaf-text' ) , function ( node ) { node . onclick = click ; } ) ; forEach ( container . querySelectorAll ( '.tree-expando' ) , function ( node ) { node . onclick = click ; } ) ; } 
function validatePackageName ( package_name ) { 
function validateProjectName ( project_name ) { var msg = 'Error validating project name. ' ; 
function ( options ) { Transport . call ( this , options ) ; options = options || { } ; this . json = options . json || false ; this . colorize = options . colorize || false ; this . prettyPrint = options . prettyPrint || false ; this . timestamp = typeof options . timestamp !== 'undefined' ? options . timestamp : false ; this . showLevel = options . showLevel === undefined ? true : options . showLevel ; this . label = options . label || null ; this . logstash = options . logstash || false ; this . depth = options . depth || null ; this . align = options . align || false ; this . stderrLevels = setStderrLevels ( options . stderrLevels , options . debugStdout ) ; this . warnLevels = setWarnLevels ( options . warnLevels ) ; this . infoLevels = setInfoLevels ( options . infoLevels ) ; this . eol = options . eol || os . EOL ; this . console = options . console || console ; if ( this . json ) { this . stringify = options . stringify || function ( obj ) { return JSON . stringify ( obj , null , 2 ) ; } ; } 
function setStderrLevels ( levels , debugStdout ) { var defaultMsg = 'Cannot have non-string elements in stderrLevels Array' ; if ( debugStdout ) { if ( levels ) { 
function ( file ) { var contents = fs . readFileSync ( file , 'utf-8' ) ; if ( contents ) { 
function Config ( file ) { this . _file = file ; this . _doc = _this . parse ( file ) ; this . _root = this . _doc . getroot ( ) ; } 
function Evaluation ( evaluator , streamHandler ) { _evaluationCounter ++ ; this . counter = _evaluationCounter ; this . _evaluator = evaluator ; this . _streamHandler = streamHandler ; } 
function captureStream ( name , callback ) { var stream = process [ name ] ; var originalWrite = stream . write ; stream . write = function ( str ) { callback ( name , str ) ; } ; return { restore : function ( ) { stream . write = originalWrite ; } } ; } 
function createSocket ( type , ip , port , messageHandler ) { var uri = util . format ( 'tcp://%s:%d' , ip , port ) ; var socket = zmq . createSocket ( type ) ; socket . bind ( uri , function ( e ) { } ) ; if ( messageHandler ) { socket . on ( 'message' , messageHandler ) ; } return socket ; } 
function messageHandler ( ) { var message = messages . read ( arguments , _session . signer ) ; if ( ! message ) { return ; } var handler = _session . handlers [ message . header . msg_type ] ; if ( handler ) { handler ( message ) ; } } 
function runSession ( evaluator , config ) { _session . signer = signers . create ( config . signature_scheme , config . key ) ; _session . io = createSocket ( 'pub' , config . ip , config . iopub_port ) ; _session . shell = createSocket ( 'xrep' , config . ip , config . shell_port , messageHandler ) ; _session . control = createSocket ( 'xrep' , config . ip , config . control_port , messageHandler ) ; _session . evaluator = evaluator ; _session . handlers = handlers . create ( _session ) ; createSocket ( 'rep' , config . ip , config . hb_port , heartbeatHandler ) ; } 
function inspectCommand ( shell , args , data , evaluationId ) { if ( args . names ) { args . names . forEach ( function ( n ) { console . log ( n + ':' ) ; console . dir ( shell . state [ n ] ) ; console . log ( ) ; } ) ; } } 
function addMessage ( message ) { var text = message . content ? message . content . code . trim ( ) : '' ; if ( ! text ) { return ; } message . content . code = text ; _messages . push ( message ) ; 
function processMessage ( message ) { var complete = false ; function outputHandler ( name , str ) { if ( ! complete ) { var streamMessage = messages . stream ( message , name , str ) ; messages . write ( streamMessage , _session . io , _session . signer ) ; } } var currentEvaluation = evaluation . create ( _session . evaluator , outputHandler ) ; var result = currentEvaluation . execute ( message . content . code ) ; result . then ( function ( value ) { 
function textCommand ( shell , args , data , evaluationId ) { return dataCommand ( shell , args , data , evaluationId , function ( value ) { return value ; } ) ; } 
function jsonCommand ( shell , args , data , evaluationId ) { return dataCommand ( shell , args , data , evaluationId , function ( value ) { return JSON . parse ( value ) ; } ) ; } 
function createGlobals ( shell ) { var globals = { Buffer : Buffer , console : console , clearImmediate : clearImmediate , clearInterval : clearInterval , clearTimeout : clearTimeout , setImmediate : setImmediate , setInterval : setInterval , setTimeout : setTimeout , _ : ijsrt } ; globals . global = globals ; return globals ; } 
function createPromise ( result , error ) { 
function Shell ( config ) { this . config = config ; this . commands = { } ; this . runtime = ijsrt ; this . state = vm . createContext ( createGlobals ( this ) ) ; this . code = '' ; require ( '../../node_modules/tern/plugin/node.js' ) ; var ternOptions = { defs : [ require ( '../../node_modules/tern/defs/ecma5.json' ) ] , plugins : { node : { } } } ; this . ternServer = new tern . Server ( ternOptions ) ; } 
function createShell ( config , callback ) { var shell = new Shell ( config ) ; modules . initialize ( shell ) ; extensions . initialize ( shell ) ; require ( './commands' ) . initialize ( shell ) ; require ( './displayCommands' ) . initialize ( shell ) ; require ( './dataCommands' ) . initialize ( shell ) ; process . nextTick ( function ( ) { callback ( shell ) ; } ) ; } 
function moduleCommand ( shell , args , data , evaluationId ) { var deferred = shell . runtime . q . defer ( ) ; installer . install ( args . name , shell . config . userPath , false , function ( error ) { if ( error ) { deferred . reject ( shell . createError ( 'Could not install module' ) ) ; } else { shell . installedModules [ args . name ] = true ; deferred . resolve ( ) ; } } ) ; return deferred . promise ; } 
function modulesCommand ( shell , args , data , evaluationId ) { var names = [ ] ; for ( var n in shell . installedModules ) { names . push ( n ) ; } console . log ( names . join ( '\n' ) ) ; } 
function customRequire ( shell , name ) { var module = shell . requiredModules [ name ] ; if ( module ) { return module ; } if ( _knownModules [ name ] ) { module = require ( name ) ; } else if ( shell . installedModules [ name ] ) { 
function initialize ( shell ) { shell . requiredModules = { } ; shell . installedModules = { } ; shell . state . require = function ( name ) { return customRequire ( shell , name ) ; } ; shell . registerCommand ( 'module' , moduleCommand ) ; shell . registerCommand ( 'modules' , modulesCommand ) ; } 
function createMessage ( identities , header , parentHeader , metadata , content ) { return { identities : identities , header : header , parentHeader : parentHeader , metadata : metadata , content : content } ; } 
function newMessage ( type , parentMessage , content , metadata ) { var header = { msg_type : type , msg_id : uuid . v4 ( ) , session : parentMessage . header . session , username : parentMessage . header . username } ; metadata = metadata || { } ; content = content || { } ; return createMessage ( parentMessage . identities , header , parentMessage . header , metadata , content ) ; } 
function createKernelInfoResponseMessage ( parentMessage ) { var content = { language : 'javascript' , language_version : [ 1 , 0 ] , protocol_version : [ 4 , 1 ] } ; return newMessage ( _messageNames . kernelInfoResponse , parentMessage , content ) ; } 
function createExecuteErrorResponseMessage ( parentMessage , executionCount , error , traceback ) { var content = { status : 'error' , execution_count : executionCount , ename : error . constructor . name , evalue : error . toString ( ) , traceback : traceback } ; return newMessage ( _messageNames . executeResponse , parentMessage , content ) ; } 
function createExecuteSuccessResponseMessage ( parentMessage , executionCount , metadata ) { var content = { status : 'ok' , execution_count : executionCount , payload : [ ] , user_variables : { } , user_expressions : { } } ; return newMessage ( _messageNames . executeResponse , parentMessage , content , metadata ) ; } 
function createCompleteInfoResponseMessage ( parentMessage , matchedText , matches , metadata ) { var content = { status : 'ok' , matched_text : matchedText , matches : matches } ; return newMessage ( _messageNames . completeResponse , parentMessage , content , metadata ) ; } 
function createDataMessage ( parentMessage , representations ) { var content = { data : representations } ; return newMessage ( _messageNames . displayData , parentMessage , content ) ; } 
function createStreamMessage ( parentMessage , streamName , data ) { var content = { name : streamName , data : data } ; return newMessage ( _messageNames . stream , parentMessage , content ) ; } 
function createStatusMessage ( parentMessage , busy ) { var content = { execution_state : busy ? 'busy' : 'idle' } ; return newMessage ( _messageNames . status , parentMessage , content ) ; } 
function readMessage ( socketData , signer ) { var identities = socketData [ 0 ] ; var signature = socketData [ 2 ] . toString ( ) ; var header = socketData [ 3 ] ; var parentHeader = socketData [ 4 ] ; var metadata = socketData [ 5 ] ; var content = socketData [ 6 ] ; if ( ! signer . validate ( signature , [ header , parentHeader , metadata , content ] ) ) { return null ; } return createMessage ( identities , JSON . parse ( header ) , JSON . parse ( parentHeader ) , JSON . parse ( metadata ) , JSON . parse ( content ) ) ; } 
function writeMessage ( message , socket , signer ) { var header = JSON . stringify ( message . header ) ; var parentHeader = JSON . stringify ( message . parentHeader ) ; var metadata = JSON . stringify ( message . metadata ) ; var content = JSON . stringify ( message . content ) ; var signature = signer . sign ( [ header , parentHeader , metadata , content ] ) ; var socketData = [ message . identities , '<IDS|MSG>' , signature , header , parentHeader , metadata , content ] ; socket . send ( socketData ) ; } 
function htmlCommand ( shell , args , data , evaluationId ) { return shell . runtime . data . html ( data ) ; } 
function scriptCommand ( shell , args , data , evaluationId ) { return shell . runtime . data . script ( data ) ; } 
function kernelInfoHandler ( message ) { var infoMessage = messages . kernelInfoResponse ( message ) ; messages . write ( infoMessage , _session . shell , _session . signer ) ; } 
function createHandlers ( session ) { _session = session ; _queue = queue . create ( session ) ; var handlers = { } ; handlers [ messages . names . kernelInfoRequest ] = kernelInfoHandler ; handlers [ messages . names . shutdownRequest ] = shutdownHandler ; handlers [ messages . names . executeRequest ] = executeHandler ; handlers [ messages . names . completeRequest ] = completeHandler ; return handlers ; } 
function setupOutline ( ) { var markup = '<select id="tocDropDown" style="float: right"><option>Outline</option></select>' ; IPython . toolbar . element . append ( markup ) ; var tocDropDown = $ ( '#tocDropDown' ) ; tocDropDown . change ( function ( e ) { var index = tocDropDown . val ( ) ; if ( index . length === '' ) { return false ; } var scrollTop = IPython . notebook . get_cell ( 0 ) . element . position ( ) . top - IPython . notebook . get_cell ( parseInt ( index ) ) . element . position ( ) . top ; IPython . notebook . element . animate ( { scrollTop : - scrollTop } , 250 , 'easeInOutCubic' ) ; tocDropDown . blur ( ) ; tocDropDown . find ( 'option' ) . get ( 0 ) . selected = true ; return false ; } ) ; function createOption ( title , value , level ) { var prefix = level > 1 ? new Array ( level + 1 ) . join ( '&nbsp;&nbsp;' ) : '' ; var text = prefix + IPython . utils . escape_html ( title ) ; return '<option value="' + value + '">' + text + '</option>' ; } function updateOutline ( ) { var content = [ ] ; content . push ( createOption ( 'Table of Contents' , '' , 0 ) ) ; var cells = IPython . notebook . get_cells ( ) ; cells . forEach ( function ( c , i ) { if ( ( c . cell_type == 'heading' ) && ( c . level <= 3 ) ) { var cell = $ ( c . element ) ; var header = cell . find ( 'h' + c . level ) ; 
function main ( ) { var parser = nomnom ( ) ; parser . script ( 'ijs' ) . nocolors ( ) . printer ( function ( s , code ) { console . log ( s ) ; if ( code ) { process . exit ( code ) ; } } ) . option ( 'version' , { abbr : 'v' , flag : true , help : 'print version and exit' , callback : function ( ) { console . log ( '0.1.0' ) ; process . exit ( 0 ) ; } } ) . option ( 'userPath' , { abbr : 'u' , full : 'userPath' , metavar : 'path' , type : 'string' , required : true , help : 'path that will contain installed node modules' , callback : function ( userPath ) { if ( ! fs . existsSync ( userPath ) || ! fs . statSync ( userPath ) . isDirectory ( ) ) { return 'expected an existing directory for the userPath option' ; } return null ; } } ) . option ( 'connectionFile' , { position : 0 , required : true , help : 'path to file containing kernel connection information' } ) ; var options = parser . parse ( process . argv . slice ( 2 ) ) ; if ( options ) { var shellConfig = { userPath : options . userPath } ; var connectionConfig = JSON . parse ( fs . readFileSync ( options . connectionFile , { encoding : 'utf8' } ) ) ; Shell . create ( shellConfig , function ( shell ) { Session . run ( shell , connectionConfig ) ; } ) ; } } 
function computeSignature ( values , signatureScheme , signatureKey ) { var hmac = crypto . createHmac ( signatureScheme , signatureKey ) ; values . forEach ( function ( v ) { hmac . update ( v ) ; } ) ; return hmac . digest ( 'hex' ) ; } 
function createSigner ( signatureScheme , signatureKey ) { if ( signatureKey ) { 
function createError ( ) { var e = new Error ( util . format . apply ( null , arguments ) ) ; e . trace = false ; return e ; } 
function extensionCommand ( shell , args , data , evaluationId ) { var deferred = shell . runtime . q . defer ( ) ; var name = args . name ; var moduleName = 'ijs.ext.' + name ; var modulePath = args . path || moduleName ; installer . install ( modulePath , shell . config . userPath , true , function ( error ) { if ( error ) { deferred . reject ( shell . createError ( 'Unable to install extension module "%s"' , moduleName ) ) ; } else { var extensionPath = path . join ( shell . config . userPath , 'node_modules' , moduleName ) ; var extension = require ( extensionPath ) ; try { extension . initialize ( shell , function ( error , result ) { if ( error ) { deferred . reject ( shell . createError ( 'Error initializing extension' ) ) ; } else { shell . loadedExtensions [ name ] = true ; deferred . resolve ( result ) ; } } ) ; } catch ( e ) { deferred . reject ( shell . createError ( 'Error initializing extension' ) ) ; } } } ) return deferred . promise ; } 
function extensionsCommand ( shell , args , data , evaluationId ) { var names = [ ] ; for ( var n in shell . loadedExtensions ) { names . push ( n ) ; } console . log ( names . join ( '\n' ) ) ; } 
function initialize ( shell ) { shell . loadedExtensions = { } ; shell . registerCommand ( 'extension' , extensionCommand ) ; shell . registerCommand ( 'extensions' , extensionsCommand ) ; } 
function createDisplayData ( value ) { var displayData = { } ; if ( ( value === null ) || ( value === undefined ) ) { return displayData ; } var useFallbacks = true ; if ( typeof value . toHTML == 'function' ) { displayData [ 'text/html' ] = value . toHTML ( ) ; useFallbacks = false ; } if ( typeof value . toScript == 'function' ) { displayData [ 'application/javascript' ] = value . toScript ( ) ; useFallbacks = false ; } if ( typeof value . toImage == 'function' ) { var buffer = value . toImage ( ) ; if ( buffer ) { var data = buffer . toString ( 'base64' ) ; var mime = buffer . mime || 'image/png' ; displayData [ mime ] = data ; useFallbacks = false ; } } if ( typeof value . toText == 'function' ) { var text = value . toText ( ) ; if ( text ) { displayData [ 'text/plain' ] = text ; useFallbacks = false ; } } if ( useFallbacks ) { if ( ( value . constructor == Object ) || ( value . constructor == Array ) ) { displayData [ 'application/json' ] = JSON . stringify ( value ) ; } else if ( value . constructor == Buffer ) { var mime = value . mime || 'application/octet-stream' ; displayData [ mime ] = value . toString ( 'base64' ) ; } else { displayData [ 'text/plain' ] = value . toString ( ) ; } } return displayData ; } 
function ( dest ) { if ( grunt . util . _ . endsWith ( dest , '/' ) || grunt . util . _ . endsWith ( dest , '\\' ) ) { return 'directory' ; } else { return 'file' ; } } 
function findFile ( name , dir ) { dir = dir || process . cwd ( ) ; var filename = path . normalize ( path . join ( dir , name ) ) ; if ( findFileResults [ filename ] !== undefined ) { return findFileResults [ filename ] ; } var parent = path . resolve ( dir , "../" ) ; if ( shjs . test ( "-e" , filename ) ) { findFileResults [ filename ] = filename ; return filename ; } if ( dir === parent ) { findFileResults [ filename ] = null ; return null ; } return findFile ( name , parent ) ; } 
function ( view , offset , length ) { var trmOffset = lib . locateSeq ( [ 0 , 0 ] , view , offset , length ) ; if ( trmOffset === - 1 ) { return - 1 ; } if ( ( trmOffset - offset ) % 2 !== 0 ) { ++ trmOffset ; } return trmOffset ; } 
function ( view , offset , length ) { return String . fromCharCode . apply ( null , new Uint8Array ( view . buffer , offset , length ) ) ; } 
function ( view , offset , length ) { 
function ( view , offset , length ) { var trmOffset = lib . locateStrTrm . iso ( view , offset , length ) ; if ( trmOffset !== - 1 ) { length = trmOffset - offset ; } return lib . readStr . iso ( view , offset , length ) ; } 
function ( view , offset , length ) { var trmOffset = lib . locateStrTrm . ucs ( view , offset , length ) ; if ( trmOffset !== - 1 ) { length = trmOffset - offset ; } return lib . readStr . ucs ( view , offset , length ) ; } 
function Mailto ( form , options ) { this . form = null ; this . preventDefault = true ; this . formatter = Mailto . defaultFormatter ; this . onSubmit = function ( m ) { } ; this . initFormObject ( form ) ; this . initOptions ( options ) ; this . initFormHandler ( ) ; } 
function getMailtoUrl ( to , fields ) { this . form . action . match ( / mailto:([^\?&]+) / ) ; to = to || RegExp . $1 || '' ; fields = fields || { subject : this . form . getAttribute ( 'data-subject' ) || '' , body : this . getBody ( ) } ; if ( ! to && ! fields . to ) { throw new Error ( 'Could not find any person to send an email to.' ) ; } return 'mailto:' + to + '?' + Object . keys ( fields ) . reduce ( function ( a , b , i ) { return a + ( i > 0 ? '&' : '' ) + encodeURIComponent ( b ) + '=' + encodeURIComponent ( fields [ b ] ) . replace ( / %0A(?!%) / g , '%0D%0A' ) + 
function getFormData ( ) { var form = this . form ; var selector = [ 'input' , 'select' , 'textarea' ] . join ( ',' ) ; return [ ] . slice . call ( form . querySelectorAll ( selector ) ) . filter ( Mailto . formDataFilter ) . map ( Mailto . formDataMapper ( form ) ) ; } 
function getData ( ) { var data = { } ; this . getFormData ( ) . forEach ( function ( d ) { if ( Array . isArray ( data [ d . name ] ) ) { data [ d . name ] . push ( d . value ) ; } else if ( data [ d . name ] !== undefined ) { data [ d . name ] = [ data [ d . name ] , d . value ] ; } else { data [ d . name ] = d . value ; } } ) ; return data ; } 
function getSerialisedData ( ) { var data = this . getFormData ( ) ; return data . length === 0 ? '' : '?' + data . map ( function ( f ) { return encodeURIComponent ( f . name ) + '=' + encodeURIComponent ( f . value ) ; } ) . join ( '&' ) ; } 
function parseDate ( dayString , monthString , yearString ) { const initialDate = { day : parseAndConstrain ( 1 , 31 , dayString ) , month : parseAndConstrain ( 1 , 12 , monthString ) , year : parseAndConstrain ( 1 , 2500 , yearString ) , } ; const dateIsValid = flow ( toMilliseconds , millisecondsToBreakdownDate , parsed => JSON . stringify ( initialDate ) === JSON . stringify ( parsed ) ) ( initialDate ) ; if ( ! dateIsValid ) { 
function registerXDiv ( ) { 
function xController ( callback ) { 'use strict' ; var execute = function execute ( ) { callback . call ( document . currentScript . parentElement , document . currentScript . parentElement ) ; } ; 
function processCondition ( condition , errorMessage ) { if ( ! condition ) { var completeErrorMessage = '' ; var re = / at ([^\s]+)\s\( / g ; var stackTrace = new Error ( ) . stack ; var stackFunctions = [ ] ; var funcName = re . exec ( stackTrace ) ; while ( funcName && funcName [ 1 ] ) { stackFunctions . push ( funcName [ 1 ] ) ; funcName = re . exec ( stackTrace ) ; } 
function assert ( condition , errorMessage ) { var error = processCondition ( condition , errorMessage ) ; if ( typeof error === 'string' ) { throw new Error ( error ) ; } } 
function getParentField ( el ) { if ( ! el || ! el . parentNode ) { return el ; } return el . classList . contains ( 'fl-fb-Field' ) ? el : getParentField ( el . parentNode ) ; } 
function Credulous ( options ) { var i ; if ( ! this ) { return new Credulous ( options ) ; } options = validateOptions ( options ) ; this . labels = options . labels ; this . dataLength = options . dataLength ; 
function setUpDataStore ( dataStore , labels , dataLength ) { var i ; for ( i = 0 ; i < dataLength ; i ++ ) { dataStore [ i ] = { words : { } , labels : { } } ; labels . forEach ( function ( label ) { dataStore [ i ] . labels [ label ] = 0 ; } ) ; } } 
function argMax ( array ) { var maxIndex = 0 , i ; for ( i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > array [ maxIndex ] ) { maxIndex = i ; } } return maxIndex ; } 
function processDataItems ( items ) { var processedItems = [ ] ; 
function addLabel ( label , self ) { if ( ! ( label in self . labels ) ) { self . labels [ label ] = 1 ; } else { self . labels [ label ] ++ ; } } 
function FileQueue ( limit , newQueue ) { if ( typeof limit === 'boolean' ) { newQueue = limit ; limit = null ; } if ( ! limit ) { limit = 200 ; 
function fromJson ( winstonConf , callback ) { if ( _isEmpty ( winstonConf ) ) { callback ( new Error ( 'Empty winston configuration' ) , winston ) ; return ; } configLogger ( winstonConf ) ; callback ( null , winston ) ; } 
function fromFile ( filename , callback ) { var configFile = filename || '../config/winston-config.json' ; fs . exists ( configFile , function ( exists ) { if ( exists ) { var winstonConf = require ( configFile ) . logging ; fromJson ( winstonConf , callback ) ; } else { callback ( new Error ( 'No config file found (at least provide a config/winston-config.json) with winston configuration' ) , winston ) ; } } ) ; } 
function fromFileSync ( filename ) { var configFile = filename || '../config/winston-config.json' ; var exists = fs . existsSync ( configFile ) ; if ( exists ) { var winstonConf = require ( configFile ) . logging ; if ( _isEmpty ( winstonConf ) ) { console . log ( 'Empty winston configuration' ) ; } else { configLogger ( winstonConf ) ; } } else { console . log ( 'No config file found (at least provide a config/winston-config.json) with winston configuration' ) ; } return winston ; } 
function ( id ) { let user = { } let gender = Math . random ( ) > 0.5 user . id = '' + id user . gender = gender ? 'MALE' : 'FEMALE' user . first_name = gender ? randomArrayValue ( MALE_FIRST_NAMES ) : randomArrayValue ( FEMALE_FIRST_NAMES ) user . last_name = randomArrayValue ( LAST_NAMES ) user . email = user . first_name + user . last_name + '@' + randomArrayValue ( DOMAINS ) user . createdAt = randomCreatedAtDate ( ) user . updatedAt = randomUpdatedAtDate ( user . createdAt ) 
function Debug ( ... rest ) { if ( new . target ) { this . debug = ( id , stats , ... rest ) => { debug ( id ) ( ... rest ) ; } ; return ; } return new Debug ( ... rest ) ; } 
function log ( ctx , start , len , err , event ) { 
function sendMessage ( id , level , fallbackToLog , ... rest ) { const levelMethod = level . toLowerCase ( ) ; const options = buildMessageOptions ( id ) ; const tagsToDisable = get ( configRegistry , 'tags.disable' , [ ] ) ; const namespaceTags = get ( configRegistry , ` ${ id } ` , [ ] ) ; const containsDisabledTag = tagsToDisable . some ( ( element ) => { return namespaceTags . indexOf ( element ) > - 1 ; } ) ; if ( options . disable . indexOf ( level ) > - 1 || containsDisabledTag ) { 
function calcStats ( ) { return { maxIdLength : Math . max ( ... Object . keys ( loggers ) . map ( ( l ) => l . length ) ) } ; } 
function applyPlugins ( plugins = [ ] , id , level , stats , ... rest ) { if ( ! Array . isArray ( plugins ) || ! plugins . every ( ( p ) => typeof p === 'function' ) ) { throw new Error ( 'Plugins MUST be an array of functions' ) ; } const args = Object . freeze ( rest . map ( ( arg ) => Object . freeze ( arg ) ) ) ; 
function createLogger ( id ) { let log = ( level , fallbackToLog , ... rest ) => sendMessage ( id , level , fallbackToLog , ... rest ) ; return { get id ( ) { return id ; } , silly ( ... rest ) { log ( LEVELS . SILLY , true , ... rest ) ; } , debug ( ... rest ) { log ( LEVELS . DEBUG , true , ... rest ) ; } , info ( ... rest ) { log ( LEVELS . INFO , true , ... rest ) ; } , warn ( ... rest ) { log ( LEVELS . WARN , true , ... rest ) ; } , error ( ... rest ) { log ( LEVELS . ERROR , true , ... rest ) ; } , 
function getLogger ( id , { disable = [ ] , wrappers = [ ] , tags = [ ] } = { } ) { let config = { disable : normalizeArray ( disable ) . map ( v => v + '' ) , wrappers : normalizeArray ( wrappers ) , tags : normalizeArray ( tags ) } ; set ( configRegistry , ` ${ id } ` , deepmerge ( get ( configRegistry , ` ${ id } ` , { } ) , config , deepMergeOptions ) ) ; return loggers [ id ] || ( loggers [ id ] = createLogger ( id ) ) ; } 
function configure ( { useGlobal = true , disable = [ ] , namespaces = { } , tags = { } , verbose = false } = { } , override = false ) { const config = Object . create ( null ) ; config . useGlobal = ! ! useGlobal ; config . disable = normalizeArray ( disable ) . map ( v => v + '' ) ; config . namespaces = namespaces ; config . tags = { disable : normalizeArray ( get ( tags , 'disable' , [ ] ) ) } ; config . verbose = verbose ; configRegistry = override ? config : deepmerge ( configRegistry , config , deepMergeOptions ) ; } 
function addWrapper ( wrapper , { passInitialArguments = false , plugins = [ ] } = { } ) { const opts = { passInitialArguments , plugins : normalizeArray ( plugins ) } ; if ( typeof wrapper === 'object' && ! Array . isArray ( wrapper ) && ( typeof wrapper . log === 'function' || Object . keys ( LEVELS ) . some ( ( lvl ) => typeof wrapper [ lvl . toLowerCase ( ) ] === 'function' ) ) ) { 
function addPlugin ( useLevel , fn ) { let pluginFn = fn ; if ( typeof fn === 'undefined' && typeof useLevel === 'function' ) { pluginFn = useLevel ; } if ( typeof pluginFn !== 'function' ) { throw new Error ( 'Plugin must be a function!' ) ; } if ( typeof useLevel === 'string' ) { pluginFn = ( id , level , stats , ... rest ) => { if ( level === useLevel . toUpperCase ( ) ) { return fn ( id , level , stats , ... rest ) ; } return [ id , level , stats , ... rest ] ; } ; } pluginsRegistry . push ( pluginFn ) ; } 
function ( ) { var self = this return { version : '1.0.0' , 
function ( ) { var self = this var endpoints = new Array ( ) var flatten = function ( eps , topLevel , parentPath ) { for ( var _path in eps ) { if ( self . _includeUndocumented || ! eps [ _path ] . noDocument ) { var absPath = path . join ( parentPath , _path ) endpoints . push ( { path : absPath , topLevel : topLevel , endpoint : eps [ _path ] } ) if ( eps [ _path ] . endpoints ) { flatten ( eps [ _path ] . endpoints , false , absPath ) } } } } flatten ( self . _service . endpoints , true , '/' ) var methods = _o ( '../Endpoint' ) . prototype . ALL_METHODS for ( var i = 0 ; i < endpoints . length ; i ++ ) { var operations = methods . map ( function ( m ) { if ( endpoints [ i ] . endpoint [ m ] && ( self . _includeUndocumented || ! endpoints [ i ] . endpoint [ m ] . noDocument ) && ( m != "options" || self . _service . generateOptionsMethodsInDocs ) ) { return self . _generateOperationDescriptor ( m , endpoints [ i ] . endpoint [ m ] , endpoints [ i ] . path ) } return undefined } ) . filter ( function ( e ) { return e ? true : false ; } ) if ( operations . length == 0 ) { continue } endpoints [ i ] = { path : endpoints [ i ] . path , description : endpoints [ i ] . endpoint . description , topLevel : endpoints [ i ] . topLevel , parameters : self . _generateParameterDescriptors ( endpoints [ i ] . endpoint . parameters , undefined , endpoints [ i ] . path ) , allowUnauthenticated : endpoints [ i ] . endpoint . allowUnauthenticated , operations : operations } } endpoints = _ . sortBy ( endpoints , [ 'path' ] ) return endpoints } 
function ( method , operation , path_ ) { var self = this var allParameters = operation . getAllParameters ( ) var inheritedParameters = _ . keys ( allParameters ) . reduce ( function ( obj , e ) { if ( ! ( e in operation . parameters ) ) { obj [ e ] = allParameters [ e ] } return obj } , { } ) var parameterDescriptors = self . _generateParameterDescriptors ( operation . parameters , inheritedParameters , path_ ) 
function ( parameters , inheritedParameters , path_ ) { var _parameters = { 'path' : [ ] , 'query' : [ ] , 'body' : [ ] , 'header' : [ ] } self = this var descriptor = function ( parameter , inherited ) { return { name : parameter . name , description : parameter . description , location : parameter . location , schema : self . _removeNoDocumentProperties ( parameter . schema ) , example : parameter . example , required : parameter . required , default : parameter . default , inherited : inherited , } } if ( ! _ . isUndefined ( inheritedParameters ) ) { for ( var parameter in inheritedParameters ) { if ( this . _includeUndocumented || ! inheritedParameters [ parameter ] . noDocument ) { _parameters [ inheritedParameters [ parameter ] . location ] . push ( descriptor ( inheritedParameters [ parameter ] , true ) ) } } } for ( var parameter in parameters ) { if ( this . _includeUndocumented || ! parameters [ parameter ] . noDocument ) { _parameters [ parameters [ parameter ] . location ] . push ( descriptor ( parameters [ parameter ] , false ) ) } } var existingPathParams = _ . map ( _parameters . path , function ( val ) { return val . name } ) _parameters . path = _ . concat ( _parameters . path , this . _getPathParameters ( path_ , existingPathParams ) ) for ( var location in _parameters ) { if ( _parameters [ location ] . length == 0 ) { delete _parameters [ location ] } } return _parameters } 
function ( responses ) { assert ( _ . isObject ( responses ) ) self = this var descriptor = function ( response ) { return { name : response . statusCode . toString ( ) , statusCode : response . statusCode , description : response . description , schema : self . _removeNoDocumentProperties ( response . schema ) , example : response . example , headers : response . headers . length === 0 ? null : _ . join ( _ . map ( response . headers , function ( header ) { return _ . trim ( header . toString ( ) ) } ) , '\n' ) } } return _ . sortBy ( _ . map ( responses , descriptor ) , function ( r ) { return r . name } ) } 
function ( ) { var self = this 
function ( ) { var help = handlebars . Utils . escapeExpression ( this . _service . getUsage ( ) ) handlebars . registerPartial ( 'ServiceHelp' , ` ${ help } ` ) handlebars . registerPartial ( 'schemaElements' , ` ` ) } 
function ( objects , options ) { var self = this objects . forEach ( function ( object ) { self . cache [ object . _id ] = object } ) return objects } 
function ( options ) { var self = this var result = [ ] if ( options . _id ) { var id = Array . isArray ( options . _id ) ? options . _id : [ options . _id ] id . forEach ( function ( id ) { if ( self . cache [ id ] ) { result . push ( self . cache [ id ] ) } } ) } else { result = Object . keys ( this . cache ) . map ( function ( k ) { return self . cache [ k ] } ) . sort ( function ( count1 , count2 ) { return count1 . _id - count2 . _id } ) if ( options . skip || options . limit ) { var skip = options . skip || 0 var limit = options . limit || 0 return result . slice ( skip , skip + limit ) } } return result } 
function ( objects , options ) { var idSet = new Set ( objects . map ( function ( object ) { return object . _id } ) ) if ( idSet . length < objects . length ) { throw new this . getService ( ) . errors . BadRequest ( 'Duplicate IDs' ) } this . cache = objects return objects } 
function ( object , options ) { var created = typeof this . cache [ object . _id ] === 'undefined' this . cache [ object . _id ] = object return { created : created , val : object } } 
function ( update , options ) { var count = 0 for ( var id in this . cache ) { count += 1 if ( update . $inc ) { this . cache [ id ] . count += update . $inc } else { this . cache [ id ] . count -= update . $dec } } return count } 
function ( options ) { var objects = [ ] for ( var id in this . cache ) { objects . push ( this . cache [ id ] ) } this . cache = { } return objects } 
function ( update , options ) { var count = 0 for ( var id in this . cache ) { this . cache [ id ] . count += update . n count += 1 } 
function ( object , options ) { return this . collection . findOneAndReplace ( { _id : object . _id } , object , { returnOriginal : false } ) . value } 
async function myNewPackage ( config = { } ) { const { shouldRun = true , text , } = config if ( ! shouldRun ) return LOG ( 'my-new-package called with %s' , text ) return text } 
function addHandler ( cls , replacer , reviver ) { if ( typeof cls !== "function" ) { throw new TypeError ( "'cls' must be class/function" ) ; } if ( typeof replacer !== "function" ) { throw new TypeError ( "'replacer' must be function" ) ; } if ( typeof reviver !== "function" ) { throw new TypeError ( "'reviver' must be function" ) ; } __handlers [ cls . name ] = { cls : cls , replacer : replacer , reviver : reviver } ; } 
function ( object , options ) { var col = this . service . db . getCollection ( path . basename ( this . path ) ) return col . insertObject ( obj ) } 
function ( options ) { 
function ( ) { this . object = null this . ownerField = '__owner__' this . permissionDefinitions = { 
function ( ) { _o ( './Acl' ) . prototype . _init . call ( this ) 
function ( user , object ) { 
function ( user , filterSingleValue , filterArrays , acl ) { return sanitize ( this . object , user , filterSingleValue , filterArrays , acl ) } 
function sanitize ( value , user , filterSingleValue , filterArrays , acl ) { var result = doSanitize ( value , user , filterArrays , acl ) if ( typeof ( value ) === 'object' && result === undefined ) { if ( ! filterSingleValue ) { throw new Error ( "User unauthorized to see value" ) 
function doSanitize ( value , user , filterArrays , acl ) { if ( ! value ) { return value } var result = value if ( value . constructor === Array ) { result = doSanitizeArray ( value , user , filterArrays , acl ) } else if ( typeof ( value ) === 'object' ) { result = doSanitizeObject ( value , user , filterArrays , acl ) } return result } 
function doSanitizeArray ( arr , user , filterArrays , acl ) { var result = [ ] var processedElem arr . forEach ( function ( elem ) { if ( typeof ( elem ) === 'object' ) { processedElem = doSanitize ( elem , user , filterArrays , acl ) 
function doSanitizeObject ( obj , user , filterArrays , acl ) { var result = obj var finalAcl = undefined var objAclDatum = obj . __acl__ if ( objAclDatum ) { objAcl = o ( aclDatum , null , module . exports ) 
function addExtras ( callback ) { var n = 0 ; async . eachSeries ( data . _peopleInfo || [ ] , function ( personInfo , callback ) { var set = { $set : { } } ; var extras = { } ; 
function ifStatusOk ( response , fulfill , reject ) { var responseCode = response . code ; if ( isClientError ( responseCode ) ) { reject ( { name : "ClientErrorException" , message : response . body } ) ; } else if ( isServerError ( responseCode ) ) { reject ( { name : "ServerErrorException" , message : response . error } ) ; } else if ( isOtherErrorResponse ( responseCode ) ) { reject ( { name : "OtherCommunicationException" , message : response . error } ) ; } else { fulfill ( response . body ) } } 
function ( ) { this . permissionDefinitions = { 
function ( user , permission , env ) { if ( permission === 'get' ) { return this . hasPermission ( user , 'find' , env ) } if ( permission === 'patch' ) { return this . hasPermission ( user , 'update' , env ) } if ( permission === 'post' ) { 
function directoriesUnder ( rootDir ) { return directoryContents ( rootDir , stats => stats . isDirectory ( ) , ( path , stats ) => path ) } 
function filesUnder ( rootDir ) { return directoryContents ( rootDir , stats => ( stats . isFile ( ) && stats . size !== 0 ) , ( path , stats ) => [ path , stats . size ] ) } 
async function directoryContents ( rootDir , filter , transform ) { const items = await readdirAsync ( rootDir ) debug ( ` ${ items } ` ) const statedItems = await Promise . all ( items . map ( async item => { const itemPath = path . join ( rootDir , item ) const stats = await lstatAsync ( itemPath ) return filter ( stats ) ? transform ( itemPath , stats ) : null } ) ) const dirs = statedItems . filter ( d => ! ! d ) return dirs } 
function ( ) { this . description = undefined this . example = undefined this . noDocument = false this . allowUnauthenticated = false this . idParameterName = undefined this . parameters = { } this . options = undefined this . responses = { } this . endpoint = null } 
function ( schema ) { var _schema = schema . type === 'array' ? schema . items : schema if ( ! _ . isNil ( _schema . properties ) && _schema . properties [ this . idParameterName ] ) { _schema = _ . clone ( _schema ) if ( _schema . required ) { _schema . required = _ . difference ( _schema . required , [ this . idParameterName ] ) if ( _ . isEmpty ( _schema . required ) ) { delete _schema . required } } if ( _schema . additionalProperties ) { delete _schema . additionalProperties } if ( schema . type === 'array' ) { schema = _ . clone ( schema ) schema . items = _schema } else { schema = _schema } } return schema } 
function ( ) { this . idParameterName = '_id' * @property {string} [dbName] -- The database name. Note, this is only needed if * the {@link carbond.Service} instance connects * to multiple databases */ this . dbName = undefined * @property {string} collectionName -- The database collection name */ this . collectionName = undefined this . querySchema = undefined this . updateSchema = undefined this . updateObjectSchema = undefined } 
function ( ) { var self = this 
function ( options , context ) { var self = this var query = undefined if ( ! _ . isNil ( options . query ) ) { query = _ . clone ( options . query ) 
function ( config , req , res , context ) { var options = Collection . prototype . preFindObjectOperation . apply ( this , arguments ) options . driverOptions = config . driverOptions if ( ! _ . isNil ( options . projection ) ) { options . driverOptions . fields = options . projection delete options . projection } return options } 
function ( objects , options , context ) { var result = undefined var renameResult = undefined var tmpCollectionName = uuid ( ) + '-' + this . collection var tmpCollection = this . db . getCollection ( tmpCollectionName ) try { result = tmpCollection . insertMany ( objects , options . driverOptions ) renameResult = tmpCollection . rename ( this . collectionName , { dropTarget : true } ) } finally { if ( _ . isNil ( renameResult ) ) { tmpCollection . drop ( ) } } return result . ops } 
function ( config , req , res , context ) { var options = Collection . prototype . preSaveObjectOperation . call ( this , config , req , res ) options . driverOptions = _ . clone ( config . driverOptions ) options . driverOptions . returnOriginal = false if ( config . supportsUpsert ) { options . driverOptions . upsert = true } return options } 
function ( object , options , context ) { var result = this . collection . findOneAndReplace ( { _id : object . _id } , object , options . driverOptions ) return { val : result . value , created : options . driverOptions . upsert && ! result . lastErrorObject . updatedExisting } } 
function ( config , req , res , context ) { var options = Collection . prototype . preUpdateOperation . apply ( this , arguments ) options . driverOptions = config . driverOptions return options } 
function ( update , options , context ) { var driverOptions = { } if ( options . upsert ) { driverOptions = _ . assignIn ( driverOptions , options . driverOptions , { upsert : true } ) } var result = undefined try { var result = this . collection . updateMany ( options . query , update , driverOptions ) } catch ( e ) { 
function ( id , update , options , context ) { var driverOptions = { } if ( options . upsert ) { driverOptions = _ . assignIn ( driverOptions , options . driverOptions , { upsert : true } ) } 
function ( id , options , context ) { try { this . collection . deleteObject ( id , options . driverOptions ) return 1 } catch ( e ) { if ( e instanceof leafnode . errors . LeafnodeObjectSetOperationError ) { return e . deletedCount } throw e } } 
function ( ) { Limiter . prototype . _init . call ( this ) if ( ! ( this . selector instanceof LimiterSelector ) ) { throw new TypeError ( '"selector" must be an instance of `LimiterSelector`' ) } if ( ! ( this . policy instanceof LimiterPolicy ) ) { throw new TypeError ( '"policy" must be an instance of `LimiterPolicy`' ) } } 
function ( service , node ) { Limiter . prototype . initialize . call ( this , service , node ) 
function ( req , res , next ) { var selector = this . selector . key ( req ) if ( this . policy . allow ( req , res , selector ) ) { next ( ) } else { this . sendUnavailable ( res , next ) } } 
function ( ) { * @property {xxx} _allParameters -- xxx */ this . _allParameters = undefined * @property {string} name -- The operation name (i.e., HTTP method) * @readonly */ this . name = undefined this . endpoint = undefined * @property {string} [description] -- A brief description of what this operation * does. This will be displayed in any * generated documentation. */ this . description = undefined this . parameters = { } this . responses = { } this . validateOutput = true this . limiter = undefined } 
function ( ) { if ( this . _allParameters ) { return this . _allParameters } 
function ( endpoint , all ) { if ( ! _ . isNil ( endpoint ) ) { all = _ . assignIn ( _ . clone ( allEndpointParameters ( endpoint . parent , endpoint . parameters ) ) , all || { } ) } return all } 
function ( ) { for ( var statusCode in this . responses ) { var OperationResponse = _o ( './OperationResponse' ) if ( ! ( this . responses [ statusCode ] instanceof OperationResponse ) ) { if ( _ . isPlainObject ( this . responses [ statusCode ] ) ) { this . responses [ statusCode ] = o ( this . responses [ statusCode ] , OperationResponse ) } else { throw new Error ( 'Malformed response spec. ' + JSON . stringify ( this . responses [ statusCode ] ) ) } } } } 
function ( req ) { var parsed = url . parse ( req . originalUrl ) 
function getSrcInfo ( stack ) { const fileLineNoArr = [ ] ; const end = Math . min ( callsiteStackDepth , stack . length - 1 ) ; for ( let i = 1 ; i <= end ; ++ i ) { const call = stack [ i ] ; 
function configureApp ( app , config ) { app . set ( 'query parser' , 'simple' ) ; app . set ( 'x-powered-by' , false ) ; if ( thorin . env === 'production' ) { app . set ( 'env' , 'production' ) ; } app . set ( 'views' , undefined ) ; app . set ( 'view cache' , false ) ; if ( config . trustProxy ) { app . set ( 'trust proxy' , true ) ; } } 
function getAuthorizationData ( config , req ) { let data = null , types = Object . keys ( config ) ; for ( let i = 0 ; i < types . length ; i ++ ) { let authType = types [ i ] , authName = config [ authType ] ; if ( authType === 'header' ) { try { let tmp = req . headers [ authName ] || req . headers [ authName . toLowerCase ( ) ] || null ; if ( typeof tmp !== 'string' || ! tmp ) throw 1 ; if ( tmp . indexOf ( 'Bearer ' ) === 0 ) { tmp = tmp . substr ( 7 ) ; } tmp = tmp . trim ( ) ; if ( tmp === '' ) throw 1 ; data = tmp ; break ; } catch ( e ) { } } if ( authType === 'cookie' ) { try { let tmp = cookie . parse ( req . headers [ 'cookie' ] ) ; if ( typeof tmp [ authName ] !== 'string' ) throw 1 ; tmp = tmp [ authName ] . trim ( ) ; if ( tmp === '' ) throw 1 ; data = tmp ; break ; } catch ( e ) { } } } return data ; } 
function registerFavicon ( app , config ) { if ( typeof config . static !== 'string' || ! config . static ) return ; let stat ; 
function registerMiddleware ( app , config ) { if ( config . authorization && typeof config . authorization . basic === 'object' && config . authorization . basic ) { registerBasicAuth ( app , config . authorization . basic ) ; } 
function handleRequestNotFound ( req , res , next ) { if ( typeof req . uniqueId === 'undefined' ) { if ( uniqueRequestId >= MAX_REQUEST_ID ) { uniqueRequestId = 0 ; } req . uniqueId = ++ uniqueRequestId ; } req . startAt = Date . now ( ) ; let msg = 'The requested resource was not found' ; if ( this [ config ] . actionPath !== req . url ) { msg += ` ${ req . method } ${ req . url } ` ; } else if ( req . _actionType ) { msg += ': ' + req . _actionType ; } return next ( thorin . error ( 'TRANSPORT.NOT_FOUND' , msg , 404 ) ) ; } 
function handleRequestError ( err , req , res , next ) { 
function registerBasicAuth ( app , authConfig ) { if ( typeof authConfig . user !== 'string' || typeof authConfig . password !== 'string' ) return ; app . use ( ( req , res , next ) => { let credentials = basicAuth ( req ) ; if ( ! credentials || credentials . name !== authConfig . user || credentials . pass !== authConfig . password ) { res . setHeader ( 'WWW-Authenticate' , ` ${ config . realm || 'app' } ` ) ; return next ( thorin . error ( 'UNAUTHORIZED' , 'Authorization failed' , 401 ) ) ; } next ( ) ; } ) ; } 
function registerCors ( app , corsConfig , corsIgnore ) { if ( corsConfig === false ) return ; let domains = [ ] ; if ( typeof corsConfig === 'string' ) { domains = corsConfig . split ( ' ' ) ; } else if ( corsConfig instanceof Array ) { domains = corsConfig ; } app . use ( ( req , res , next ) => { let origin = req . headers [ 'origin' ] || req . headers [ 'referer' ] || null , shouldAddHeaders = false , rawOrigin = origin ; if ( typeof rawOrigin === 'string' ) { let qsIdx = rawOrigin . indexOf ( '?' ) ; if ( qsIdx !== - 1 ) { rawOrigin = rawOrigin . substr ( 0 , qsIdx ) ; } } if ( corsConfig === true ) { shouldAddHeaders = true ; } else if ( domains . length > 0 && typeof origin === 'string' ) { origin = getRawOrigin ( origin ) ; for ( let i = 0 ; i < domains . length ; i ++ ) { let domain = domains [ i ] , isMatch = matchCorsOrigin ( domain , origin , rawOrigin ) ; if ( isMatch ) { shouldAddHeaders = true ; break ; } } } if ( ! shouldAddHeaders ) return next ( ) ; 
function parseRequestInput ( source , target ) { let keys = Object . keys ( source ) ; if ( keys . length === 1 ) { 
function handleIncomingRequest ( actionType , alias , req , res , next ) { if ( typeof req . uniqueId === 'undefined' ) { req . uniqueId = ++ uniqueRequestId ; req . startAt = Date . now ( ) ; } if ( ! req . action ) { req . action = actionType ; } if ( typeof this [ actions ] [ actionType ] === 'undefined' ) { let msg = 'The requested resource was not found' ; if ( this [ config ] . actionPath !== req . url ) { msg += ` ${ req . method } ${ req . url } ` ; } return handleRequestError . call ( this , thorin . error ( 'TRANSPORT.NOT_FOUND' , msg , 404 ) , req , res , next ) ; } req . _hasDebug = this [ actions ] [ actionType ] . hasDebug ; req . exposeType = ( this [ actions ] [ actionType ] . defaultHandle === true ) ; 
function handleIntentRedirect ( req , res , intentObj , redirectUrl , redirectCode ) { try { res . redirect ( redirectCode , redirectUrl ) ; } catch ( e ) { logger ( 'warn' , "Failed to perform redirect on action " + req . action , e ) ; } if ( req . _hasDebug !== false ) { let logMsg = '[ENDED ' + req . uniqueId + "] - " , took = Date . now ( ) - req . startAt ; logMsg += req . action + ' ' ; logMsg += "(" + req . method . toUpperCase ( ) + ' ' + req . originalUrl . substr ( 0 , 64 ) + ') ' ; logMsg += '= ' + redirectCode + ' => ' + redirectUrl + ' ' ; logMsg += '(' + took + 'ms)' ; logger ( 'trace' , logMsg ) ; } } 
function handleIntentSuccess ( req , res , next , data , intentObj ) { let took = Date . now ( ) - req . startAt , status = 200 , isDone = false ; try { if ( typeof res . statusCode !== 'number' ) { res . status ( status ) ; } if ( res . headersSent ) { isDone = true ; } } catch ( e ) { } if ( isDone ) { try { res . end ( ) ; } catch ( e ) { } } else { 
function handleIntentError ( req , res , next , data , intentObj ) { if ( intentObj . hasRawResult ( ) ) { data . rawData = intentObj . result ( ) ; } req . intent = intentObj ; return handleRequestError . call ( this , data , req , res , next ) ; } 
function registerActionPath ( verb , url , actionName ) { var app = this [ server ] ; var reqHandler = handleIncomingRequest . bind ( this , actionName , url ) ; app [ verb ] ( url , reqHandler ) ; 
function setCors ( req , res , verb ) { let dom = this [ config ] . cors ; if ( dom === true ) { dom = req . headers [ 'origin' ] || '*' ; } else if ( dom instanceof Array ) { if ( ! req . headers [ 'origin' ] ) { dom = false ; } else { let found = false ; for ( let i = 0 , len = dom . length ; i < len ; i ++ ) { if ( dom [ i ] . indexOf ( req . headers [ 'origin' ] ) === - 1 ) continue ; found = true ; dom = dom [ i ] ; break ; } if ( ! found ) return ; } } 
function handleRequest ( req , res , next ) { setCors . call ( this , req , res , verb ) ; req . uniqueId = ++ uniqueRequestId ; req . startAt = Date . now ( ) ; if ( typeof req . body !== 'object' || ! req . body || typeof req . body . type !== 'string' || req . body . type === '' ) { return next ( thorin . error ( 'TRANSPORT.INVALID_TYPE' , 'Invalid or missing action type' , 404 ) ) ; } let actionType = req . body . type , wasFound = true ; if ( ! this [ actions ] [ actionType ] || ! this [ actions ] [ actionType ] . defaultHandle ) { wasFound = false ; } else { req . action = actionType ; } if ( ! wasFound ) { for ( let i = 0 , len = this [ actionPatterns ] . length ; i < len ; i ++ ) { let item = this [ actionPatterns ] [ i ] ; if ( item . match . test ( actionType ) ) { wasFound = true ; req . action = actionType ; actionType = item . action ; break ; } } } if ( ! wasFound ) { req . _actionType = actionType ; return handleRequestNotFound . call ( this , req , res , next ) ; } let payload = ( typeof req . body . payload === 'object' && req . body . payload ? req . body . payload : { } ) ; if ( typeof req . body . filter === 'object' && req . body . filter ) { req . filter = req . body . filter ; } if ( typeof req . body . meta === 'object' && req . body . meta ) { req . meta = req . body . meta ; } req . url = req . action ; req . body = payload ; req . query = { } ; req . params = { } ; handleIncomingRequest . call ( this , actionType , null , req , res , next ) ; } 
function AposGroups ( options ) { var self = this ; aposSchemas . addFieldType ( { name : 'a2Permissions' , displayer : function ( snippet , name , $field , $el , field , callback ) { _ . each ( apos . data . aposGroups . permissions , function ( permission ) { $el . findByName ( permission . value ) . val ( _ . contains ( snippet . permissions || [ ] , permission . value ) ? '1' : '0' ) ; } ) ; return callback ( ) ; } , converter : function ( data , name , $field , $el , field , callback ) { _ . each ( apos . data . aposGroups . permissions , function ( permission ) { data [ permission . value ] = $el . findByName ( permission . value ) . val ( ) ; } ) ; return callback ( ) ; } } ) ; aposSchemas . addFieldType ( { name : 'a2People' , displayer : function ( snippet , name , $field , $el , field , callback ) { var source = aposPages . getType ( 'people' ) . _action + '/autocomplete' ; $ . jsonCall ( source , { values : _ . map ( snippet . people || [ ] , function ( person ) { return person . _id ; } ) } , function ( results ) { var labelMap = { } ; _ . each ( results , function ( result ) { labelMap [ result . value ] = result . label ; } ) ; $el . find ( '[data-name="people"]' ) . selective ( { sortable : options . peopleSortable , extras : field . extras , source : source , data : _ . map ( snippet . _people || [ ] , function ( person ) { var label = labelMap [ person . _id ] ; var data = { label : label , value : person . _id } ; if ( person . groupExtras && person . groupExtras [ snippet . _id ] ) { $ . extend ( true , data , person . groupExtras [ snippet . _id ] ) ; } return data ; } ) } ) ; return callback ( ) ; } ) ; } , converter : function ( data , name , $field , $el , field , callback ) { data . _peopleInfo = $el . find ( '[data-name="people"]' ) . selective ( 'get' , { incomplete : true } ) ; return callback ( ) ; } } ) ; AposSnippets . call ( self , options ) ; self . addingToManager = function ( $el , $snippet , snippet ) { $snippet . find ( '[data-published]' ) . val ( snippet . published ? 'Yes' : 'No' ) ; } ; } 
function ( ) { this . selfAndBelow = false * @property {object} permissionDefinitions -- mapping of permissions to * defaults */ this . permissionDefinitions = { 
function ( p ) { var isRollLeft = roll == null || roll . getDepth ( ) >= 1 if ( roll ) { roll . up ( ) } if ( isRollLeft ) { next ( ) } else { callback ( null , null , resultStatus ) //could not be found //fail() } } 
async function supercopy ( options , callback ) { try { preprocess ( options ) const fileInfo = await collectFileInfo ( options ) let statements = generateScriptStatements ( fileInfo , options ) statements = annotateCopyStatements ( statements ) await options . client . run ( statements ) callback ( null ) } catch ( err ) { callback ( err ) } } 
function figureOutWhoUserIs ( req ) { 
function freezeProperties ( object , prototype ) { if ( ! _ . isObjectLike ( object ) ) { throw new TypeError ( 'freezeProperties requires a valid object to be passed' ) } var next = _ . isNil ( prototype ) ? object : prototype if ( _ . isArray ( next . _frozenProperties ) ) { next . _frozenProperties . forEach ( function ( propName ) { var prop = object [ propName ] Object . defineProperty ( object , propName , { configurable : false , enumerable : true , value : prop , writable : false } ) } ) } if ( ! _ . isNil ( Object . getPrototypeOf ( next ) ) ) { freezeProperties ( object , Object . getPrototypeOf ( next ) ) } } 
function ( ) { this . serverCertPath = null , this . serverKeyPath = null , this . serverKeyPassphrase = null , this . trustedCertsPaths = null , * @property {string?} [crl] -- A certificate revocation list in PEM format */ this . crl = null , this . ciphers = null , this . ecdhCurve = null , this . dhparam = null , this . handshakeTimeout = null , this . honorCipherOrder = true , this . requestCert = false , this . rejectUnauthorized = false , this . checkServerIdentity = null , this . NPNProtocols = null , this . SNICallback = null , this . sessionTimeout = null , this . ticketKeys = null , this . sessionIdContext = null , this . secureProtocol = 'TLSv1_method' , * @property {xxx} secureOptions -- xxx * @todo this doesn't appear to be used anywhere. get rid of it? * @ignore */ this . secureOptions = null } 
function ( ) { var result = { } _ . extend ( result , this ) result . cert = fs . readFileSync ( this . serverCertPath ) result . key = fs . readFileSync ( this . serverKeyPath ) if ( this . trustedCertsPaths ) { result . ca = this . _loadCertificates ( this . trustedCertsPaths ) } if ( this . serverKeyPassphrase ) { result . passphrase = this . serverKeyPassphrase delete this . serverKeyPassphrase } return result } 
function ( spec ) { var self = this if ( Array . isArray ( spec ) ) { return spec . reduce ( function ( result , element ) { return result . concat ( self . _loadCertificates ( element ) ) } , [ ] ) } else if ( fs . statSync ( spec ) . isDirectory ( ) ) { 
function ( ) { let parameters = this . parameters for ( let parameterName in parameters ) { let parameter = parameters [ parameterName ] if ( ! ( parameter instanceof OperationParameter ) ) { parameter = o ( _ . assign ( { name : parameterName } , parameter ) , OperationParameter ) parameters [ parameterName ] = parameter 
function ( ) { this . name = undefined this . location = undefined * @property {string} [description] -- A brief description of this parameter * This will be displayed in any generated * documentation. */ this . description = undefined this . schema = undefined this . required = false this . default = undefined 
function ( ) { if ( ! _ . isString ( this . name ) ) { throw new TypeError ( ` ${ this . name } ` ) } if ( ! _ . isString ( this . location ) || ! _ . includes ( VALID_LOCATIONS , this . location ) ) { throw new TypeError ( ` ${ this . location } ` + ` ${ VALID_LOCATIONS } ` ) } } 
function ( req ) { if ( ! this . name ) { throw new Error ( "Incomplete parameter definition. No name specified for parameter definition " + this ) } var result = undefined if ( this . location === "query" ) { result = req . query [ this . name ] } else if ( this . location === "path" ) { result = req . params [ this . name ] } else if ( this . location === "header" ) { result = req . header [ this . name ] } else if ( this . location === "body" ) { result = req . body } else if ( this . location === "formData" ) { result = req . body && req . body [ this . name ] } else { throw new Error ( "Unrecognized location value specified for parameter '" + this . name + "': " + this . location ) } 
function ( ) { * @property {string} path -- The URI path that routes to this endpoint. This * is built during service initialization and will * overwrite any value specified on instantiation. * @readonly */ this . path = '' * @property {carbond.Endpoint} parent -- The parent endpoint for this * endpoint in the endpoint tree * @readonly */ this . parent = null this . service = null * @property {string} [description] -- A brief description of what this endpoint * does. This will be displayed in any * generated documentation. */ this . description = undefined this . parameters = { } * @property {carbond.security.Acl} acl -- The access control list for this endpoint * @todo implement/document * @ignore */ this . acl = null * @property {xxx} dataAcl -- xxx * @todo implement/document * @ignore */ this . dataAcl = null this . sanitizesOutput = false this . sanitizeMode = 'strict' * @property {Array.<string>?} allowUnauthenticated * @description Skip authentication for the HTTP methods listed on this * endpoint */ this . allowUnauthenticated = null * @property {boolean} [validateOutput=true] * @description Controls whether or not response bodies are validated using * the response {@link carbond.OperationResponse.schema} corresponding * to the current response code */ this . validateOutput = true this . endpoints = { } this . noDocument = false this . limiter = undefined } 
function ( method ) { var self = this var Operation = _o ( './Operation' ) var operation = this [ method ] if ( typeof ( operation ) === 'function' ) { var opFn = operation 
function ( method , user , req ) { var acl = this . _cachedFullEndpointAcl if ( acl === undefined ) { acl = this . _computeFullEndpointAcl ( ) this . _cachedFullEndpointAcl = acl } if ( ! acl ) { 
function ( ) { var result = [ ] var self = this this . ALL_METHODS . forEach ( function ( method ) { if ( self [ method ] ) { result . push ( method ) } } ) return result } 
function ( ) { var endpoint = this var acl = endpoint . acl || null var parentAcl while ( endpoint = endpoint . parent ) { parentAcl = endpoint . acl if ( parentAcl && parentAcl . selfAndBelow ) { acl = this . _aclAndBelow ( parentAcl , acl ) } } return acl } 
function ( parentAcl , childAcl ) { var self = this return o ( { _type : parentAcl . constructor , hasPermission : function ( user , permission , env ) { var selfAndBelowFn = self . _selfAndBelowFn ( parentAcl ) return ( ! selfAndBelowFn || selfAndBelowFn ( user , permission , env ) ) && ( ! childAcl || childAcl . hasPermission ( user , permission , env ) ) } } ) } 
function ( parentAcl ) { var selfAndBelow = parentAcl . selfAndBelow if ( selfAndBelow ) { if ( typeof ( selfAndBelow ) === 'boolean' ) { return function ( user , permission , env ) { return parentAcl . hasPermission ( user , permission , env ) } } else if ( typeof ( selfAndBelow ) === 'function' ) { return selfAndBelow } else if ( selfAndBelow in parentAcl . permissionDefinitions ) { return function ( user , permission , env ) { return parentAcl . hasPermission ( user , selfAndBelow , env ) } } else { throw Error ( "Unexpected value for selfAndBelow: " + JSON . stringify ( parentAcl ) ) } } return null } 
function ( type , options ) { var self = this ; self . type = type ; if ( ! RandomGenerator . Type [ type ] ) { throw new Error ( "Unknown random generator type: " + type ) ; } if ( type === RandomGenerator . Type . ALEA ) { if ( ! options . seeds ) { throw new Error ( "No seeds were provided for Alea PRNG" ) ; } self . alea = Alea . apply ( null , options . seeds ) ; } } 
function checkType ( obj , field , expType , mustHave , min , max ) { let value = typeof ( obj ) === 'object' ? obj [ field ] : obj ; if ( value === undefined ) { return getDefault ( obj , field , mustHave ) ; } 
function handleSuccess ( ) { clearOutdatedErrors ( ) ; destroyErrorOverlay ( ) ; var isHotUpdate = ! isFirstCompilation ; isFirstCompilation = false ; hasCompileErrors = false ; 
function handleWarnings ( warnings ) { clearOutdatedErrors ( ) ; destroyErrorOverlay ( ) ; var isHotUpdate = ! isFirstCompilation ; isFirstCompilation = false ; hasCompileErrors = false ; function printWarnings ( ) { 
function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { 
function logMessage ( message , data ) { if ( ! message ) return render ( message , data , function ( err , res ) { if ( err ) { console . error ( '\n Error when rendering template complete message: ' + err . message . trim ( ) ) } else { console . log ( ` \n ` ) console . log ( '' ) console . log ( ` ${ chalk . gray ( ' ------------------' ) } ` ) console . log ( ' ' + res . split ( / \r?\n / g ) . map ( function ( line ) { return ` ${ chalk . blue ( line ) } ` } ) . join ( '\n' ) ) console . log ( ` ${ chalk . gray ( ' ------------------' ) } ` ) console . log ( '' ) console . log ( ` ${ chalk . blue . underline ( 'fe -h' ) } ` ) } } ) } 
function interceptWriteStream ( writeStream ) { return new Promise ( ( resolve , reject ) => { let response = "" ; let writeBkp = writeStream . write ; let sendBkp = writeStream . send ; 
function ( filepath , options , content ) { if ( ! inited ) { this . config ( ) } if ( arguments . length === 2 && ( typeof options === "string" ) ) { content = options ; options = { } ; } content = content || getFileString ( filepath ) ; options = options || { } ; if ( ! content ) return "" ; return compile ( content , filepath , options ) ; } 
function compile ( content , filePath , opt ) { var fileUrl , 
function getFileString ( filepath ) { if ( / (?:\/|\\)$ / . test ( filepath ) || ! fs . existsSync ( filepath ) ) { console . log ( "\x1B[31mfile is not exist：" + f lepath + " x1B[0m"); return null ; } else { return fs . readFileSync ( filepath ) . toString ( ) } } 
function deepCopy ( obj ) { var result = { } ; var type = toString . call ( obj ) ; if ( ! obj || ( type === "[object RegExp]" ) || typeof obj !== "object" ) return obj ; if ( type === "[object Array]" ) return slice . call ( obj ) ; for ( var k in obj ) { result [ k ] = deepCopy ( obj [ k ] ) } return result ; } 
function getRandomMusic ( queue , msg ) { fs . readFile ( './data/autoplaylist.txt' , 'utf8' , function ( err , data ) { if ( err ) throw err ; con ( 'OK: autoplaylist.txt' ) ; var random = data . split ( '\n' ) ; var num = getRandomInt ( random . length ) ; con ( random [ num ] ) var url = random [ num ] ; msg . author . username = "AUTOPLAYLIST" ; play ( msg , queue , url ) } ) ; } 
function formatMessage ( message ) { var lines = message . split ( '\n' ) ; 
function resolveBot ( bot ) { let isWaterfall = ( "function" == typeof bot ) || Array . isArray ( bot ) ; if ( isWaterfall ) { let dialog = bot ; let connector = new TestConnector ( ) ; bot = new builder . UniversalBot ( connector ) ; bot . dialog ( '/' , dialog ) ; } else if ( bot instanceof builder . UniversalBot ) { if ( ! bot . connector ( ) ) { bot . connector ( 'console' , new TestConnector ( ) ) ; } } else { throw new Error ( ` ${ JSON . stringify ( bot ) } ` ) ; } return bot ; } 
function mixin ( target , MixinConstructor , ... args ) { let source = new MixinConstructor ( ... args ) let names = Object . getOwnPropertyNames ( MixinConstructor . prototype ) for ( let name of names ) { let val = source [ name ] if ( _ . isFunction ( val ) && name !== 'constructor' ) { target [ name ] = val . bind ( source ) } } } 
function nestLists ( blocks , mode = 'html' ) { const tree = [ ] let currentList for ( let i = 0 ; i < blocks . length ; i ++ ) { const block = blocks [ i ] if ( ! isListBlock ( block ) ) { tree . push ( block ) currentList = null continue } 
function sortMarksByOccurences ( span , i , spans ) { if ( ! span . marks || span . marks . length === 0 ) { return span . marks || [ ] } const markOccurences = span . marks . reduce ( ( occurences , mark ) => { occurences [ mark ] = occurences [ mark ] ? occurences [ mark ] + 1 : 1 for ( let siblingIndex = i + 1 ; siblingIndex < spans . length ; siblingIndex ++ ) { const sibling = spans [ siblingIndex ] if ( sibling . marks && Array . isArray ( sibling . marks ) && sibling . marks . indexOf ( mark ) !== - 1 ) { occurences [ mark ] ++ } else { break } } return occurences } , { } ) const sortByOccurence = sortMarks . bind ( null , markOccurences ) 
function BlockSerializer ( props ) { const { node , serializers , options , isInline , children } = props const blockType = node . _type const serializer = serializers . types [ blockType ] if ( ! serializer ) { throw new Error ( ` ${ blockType } \` \` ` ) } return h ( serializer , { node , options , isInline } , children ) } 
function SpanSerializer ( props ) { const { mark , children } = props . node const isPlain = typeof mark === 'string' const markType = isPlain ? mark : mark . _type const serializer = props . serializers . marks [ markType ] if ( ! serializer ) { 
function ListSerializer ( props ) { const tag = props . type === 'bullet' ? 'ul' : 'ol' return h ( tag , null , props . children ) } 
function ListItemSerializer ( props ) { const children = ! props . node . style || props . node . style === 'normal' ? 
function BlockTypeSerializer ( props ) { const style = props . node . style || 'normal' if ( / ^h\d / . test ( style ) ) { return h ( style , null , props . children ) } return style === 'blockquote' ? h ( 'blockquote' , null , props . children ) : h ( 'p' , null , props . children ) } 
function serializeSpan ( span , serializers , index , options ) { if ( span === '\n' && serializers . hardBreak ) { return h ( serializers . hardBreak , { key : ` ${ index } ` } ) } if ( typeof span === 'string' ) { return serializers . text ? h ( serializers . text , { key : ` ${ index } ` } , span ) : span } let children if ( span . children ) { children = { children : span . children . map ( ( child , i ) => options . serializeNode ( child , i , span . children , true ) ) } } const serializedNode = objectAssign ( { } , span , children ) return h ( serializers . span , { key : span . _key || ` ${ index } ` , node : serializedNode , serializers } ) } 
function checksum ( str ) { let hash = 0 const strlen = str . length if ( strlen === 0 ) { return hash } for ( let i = 0 ; i < strlen ; i ++ ) { hash = ( hash << 5 ) - hash + str . charCodeAt ( i ) hash &= hash 
function Strategy ( options , verify ) { options = options || { } ; options . authorizationURL = options . authorizationURL || 'https://bitbucket.org/site/oauth2/authorize' ; options . tokenURL = options . tokenURL || 'https://bitbucket.org/site/oauth2/access_token' ; options . customHeaders = options . customHeaders || { } ; if ( ! options . customHeaders [ 'User-Agent' ] ) { options . customHeaders [ 'User-Agent' ] = options . userAgent || 'passport-bitbucket' ; 
function ( ) { var el = this . el ; this . lastPosition = el . getAttribute ( 'position' ) ; this . lastRotation = el . getAttribute ( 'rotation' ) ; this . lastScale = el . getAttribute ( 'scale' ) ; this . lerpingPosition = false ; this . lerpingRotation = false ; this . lerpingScale = false ; this . timeOfLastUpdate = 0 ; } 
function ( time , deltaTime ) { var progress ; var now = this . now ( ) ; var obj3d = this . el . object3D ; this . checkForComponentChanged ( ) ; 
function ( from , to ) { this . lerpingPosition = true ; this . startLerpTimePosition = this . now ( ) ; this . startPosition = new THREE . Vector3 ( from . x , from . y , from . z ) ; this . targetPosition = new THREE . Vector3 ( to . x , to . y , to . z ) ; } 
function ( from , to ) { this . lerpingRotation = true ; this . startLerpTimeRotation = this . now ( ) ; this . startRotation = new THREE . Quaternion ( ) ; this . startRotation . setFromEuler ( new THREE . Euler ( degToRad ( from . x ) , degToRad ( from . y ) , degToRad ( from . z ) , 'YXZ' ) ) ; this . targetRotation = new THREE . Quaternion ( ) ; this . targetRotation . setFromEuler ( new THREE . Euler ( degToRad ( to . x ) , degToRad ( to . y ) , degToRad ( to . z ) , 'YXZ' ) ) ; } 
function ( from , to ) { this . lerpingScale = true ; this . startLerpTimeScale = this . now ( ) ; this . startScale = new THREE . Vector3 ( from . x , from . y , from . z ) ; this . targetScale = new THREE . Vector3 ( to . x , to . y , to . z ) ; } 
function ( json , variables , memberMode , callback ) { if ( typeof memberMode == 'function' ) { callback = memberMode ; var member_mode = memberMode || false ; } else { var member_mode = memberMode || false ; } var str = JSON . stringify ( json ) ; var output = str . replace ( / {{\w+}} / g , function ( found ) { found = ( member_mode ) ? found . match ( / [\w\.]+ / ) [ 0 ] : found ; 
function ( datamodel , variables ) { traverse ( datamodel ) . forEach ( function ( path ) { 
function ( element ) { this . el = element ; this . core = window . lgData [ this . el . getAttribute ( 'lg-uid' ) ] ; 
function bufferContents ( file , enc , cb ) { 
function two ( context , next ) { setTimeout ( function ( ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; return next ( ) ; } , 1000 ) ; } 
function next ( ) { var middleware = chain . shift ( ) ; if ( middleware && typeof middleware === 'function' ) { middleware . call ( this , context , next ) ; } return this ; } 
function one ( context , next ) { setTimeout ( function ( ) { context . one = 'Hello' ; console . log ( 'Hello from one' , context ) ; return next ( ) ; } , 1000 ) ; console . log ( 'Hi from one' , context ) ; } 
function two ( context , next ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; console . log ( 'Hi from two' , context ) ; return next ( ) ; } 
function three ( context , next ) { console . log ( 'Hi from three' , context ) ; setTimeout ( function ( ) { context . three = 'Hello' ; console . log ( 'Hello from three' , context ) ; } , 1000 ) ; } 
function two ( context , next ) { setTimeout ( function ( ) { context . two = 'Hello' ; console . log ( 'Hello from two' , context ) ; chain ( { nested : 'Hello' } , [ one , three ] ) ; return next ( ) ; } , 1000 ) ; } 
function ExpressView ( view ) { this . render = ( options , callback ) => { const variables = { ... options . _locals , ... options } ; callback ( null , view ( variables ) ) ; } ; this . path = view . id ; } 
function tryMatchSequence ( key ) { seq . keys . push ( key . name ) ; 
function mat3from4 ( out , mat4x4 ) { out [ 0 ] [ 0 ] = mat4x4 [ 0 ] out [ 0 ] [ 1 ] = mat4x4 [ 1 ] out [ 0 ] [ 2 ] = mat4x4 [ 2 ] out [ 1 ] [ 0 ] = mat4x4 [ 4 ] out [ 1 ] [ 1 ] = mat4x4 [ 5 ] out [ 1 ] [ 2 ] = mat4x4 [ 6 ] out [ 2 ] [ 0 ] = mat4x4 [ 8 ] out [ 2 ] [ 1 ] = mat4x4 [ 9 ] out [ 2 ] [ 2 ] = mat4x4 [ 10 ] } 
function MotionDetector ( n ) { RED . nodes . createNode ( this , n ) ; this . cam = RED . nodes . getNode ( n . cam ) ; this . name = n . name ; this . topic = n . topic ; this . device = n . device ; this . resolution = n . resolution ; this . rotate = n . rotate ; var node = this ; node . on ( 'close' , function ( done ) { node . status ( { } ) ; done ( ) ; } ) ; eventEmitter . on ( 'event' , function ( data , data2 ) { var tmp = data . split ( ';' ) ; node . send ( { payload : { event : tmp [ 0 ] , date : tmp [ 1 ] , eventNumber : tmp [ 2 ] , frameNumber : tmp [ 3 ] , camera : tmp [ 4 ] , changedPixels : tmp [ 5 ] , noise : tmp [ 6 ] , width : tmp [ 7 ] , height : tmp [ 8 ] , xMotion : tmp [ 9 ] , yMotion : tmp [ 10 ] , text : tmp [ 11 ] , filename : tmp [ 12 ] , filetype : tmp [ 13 ] } } ) ; } ) ; } 
function filter ( fn , ctx ) { assert . equal ( typeof fn , 'function' ) return function ( val ) { val = Array . isArray ( val ) ? val : [ val ] return Promise . resolve ( val . filter ( fn , ctx ) ) } } 
function ( rawValue ) { const value = stringifyInput ( rawValue ) ; if ( ! value . match ( FORMAT ) ) { throw new Error ( 'Invalid data format; expecting: \'' + FORMAT + '\', found: \'' + value + '\'' ) ; } return mod97 ( value ) ; } 
async function sendMessage ( app , context , title , message , { update = '' , updateAfterDays = 7 , owner , repo } = { } ) { if ( ! app || ! context || ! title || ! message ) { throw new Error ( 'Required parameter missing' ) ; } if ( ! owner || ! repo ) { ( { owner , repo } = context . repo ( ) ) ; } const appGh = await app . auth ( ) ; const { name : appName , html_url : appUrl } = ( await appGh . apps . get ( { } ) ) . data ; const { data : issues } = await context . github . issues . getForRepo ( { owner , repo , state : 'open' , creator : ` ${ appName } ` , per_page : 100 } ) ; message = message . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const messageHash = crypto . createHash ( 'sha256' ) . update ( message ) . digest ( 'hex' ) ; const messageHashRx = new RegExp ( ` ${ messageHash } ` ) ; for ( const issue of issues ) { if ( ! messageHashRx . test ( issue . body ) ) { continue ; } let commentId = null ; if ( update && ! issue . locked && Date . now ( ) - Date . parse ( issue . updated_at ) >= updateAfterDays * 24 * 60 * 60 * 1000 ) { update = update . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const { data : commentData } = await context . github . issues . createComment ( { owner , repo , number : issue . number , body : update } ) ; commentId = commentData . id ; } return new Message ( owner , repo , issue . number , commentId , false ) ; } title = title . replace ( / {appName} / , appName ) . replace ( / {appUrl} / , appUrl ) ; const { data : issueData } = await context . github . issues . create ( { owner , repo , title , body : ` ${ message } \n ${ messageHash } ` } ) ; return new Message ( owner , repo , issueData . number , null , true ) ; } 
function packageStatesSerialize ( ) { if ( atom . packages . serialize != null ) { return atom . packages . serialize ( ) } atom . packages . getActivePackages ( ) . forEach ( ( pack ) => { var state if ( pack . serialize != null ) state = pack . serialize ( ) if ( state ) { atom . packages . setPackageState ( pack . name , state ) } } ) return atom . packages . packageStates } 
function atomSerialize ( ) { var options = { isUnloading : true } if ( atom . serialize != null ) return atom . serialize ( options ) 
function rdfToJsonld ( triples , config ) { var useRdfType = config . useRdfType ; var useNativeTypes = config . useNativeTypes ; var graphs = getGraphs ( triples ) ; var defaultGraph = { } ; var graphMap = { '@default' : defaultGraph } ; Object . keys ( graphs ) . forEach ( function ( name ) { var triples = graphs [ name ] ; if ( name === '' ) { name = '@default' ; } else if ( ! defaultGraph [ name ] ) { defaultGraph [ name ] = { '@id' : name } ; } graphMap [ name ] = graphMap [ name ] || { } ; var nodeMap = graphMap [ name ] ; triples . forEach ( function ( triple ) { if ( ! nodeMap [ triple . subject ] ) { nodeMap [ triple . subject ] = { '@id' : triple . subject } ; } var node = nodeMap [ triple . subject ] ; var object = triple . object ; if ( object . id ) { if ( ! nodeMap [ object . id ] ) { nodeMap [ object . id ] = { '@id' : object . id } ; } } if ( triple . predicate === RDF__TYPE && ! useRdfType && object . id ) { if ( ! node [ '@type' ] ) { node [ '@type' ] = [ object . id ] ; } return 'continue' ; } var value = rdfObjectToJsonldObject ( object , useNativeTypes ) ; if ( ! node [ triple . predicate ] ) { node [ triple . predicate ] = [ ] ; } var alreadyExists = node [ triple . predicate ] . some ( function ( existingValue ) { var areEquivalent = equivalentObjects ( value , existingValue ) ; return areEquivalent ; } ) ; if ( ! alreadyExists ) { node [ triple . predicate ] . push ( value ) ; } if ( object . id ) { if ( ! node . usages ) { node . usages = [ ] ; } node . usages . push ( { node : node , property : triple . predicate , value : value } ) ; } } ) ; } ) ; Object . keys ( graphMap ) . forEach ( function ( name ) { var graph = graphMap [ name ] ; var nil = graph [ RDF__NIL ] ; if ( ! nil ) { return 'continue' ; } nil . usages . forEach ( function ( usage ) { var node = usage . node ; var property = usage . property ; var head = usage . value ; var list = [ ] ; var listNodes = [ ] ; while ( property === RDF__REST && isWellFormedListNode ( node ) ) { list . push ( node [ RDF__FIRST ] [ 0 ] ) ; listNodes . push ( node [ '@id' ] ) ; var nodeUsage = node . usages [ 0 ] ; node = nodeUsage . node ; property = nodeUsage . property ; head = nodeUsage . value ; if ( ! / ^_: / . test ( node [ '@id' ] ) ) { break ; } } if ( property === RDF__FIRST ) { if ( node [ '@id' ] === RDF__NIL ) { return 'continue' ; } var headId = head [ '@id' ] ; head = graph [ headId ] ; head = head [ RDF__REST ] [ 0 ] ; list . pop ( ) ; listNodes . pop ( ) ; } delete head [ '@id' ] ; list . reverse ( ) ; head [ '@list' ] = list ; listNodes . forEach ( function ( nodeId ) { delete graph [ nodeId ] ; } ) ; } ) ; } ) ; var result = [ ] ; Object . keys ( defaultGraph ) . sort ( ) . forEach ( function ( subject ) { var node = defaultGraph [ subject ] ; if ( graphMap [ subject ] ) { node [ '@graph' ] = [ ] ; Object . keys ( graphMap [ subject ] ) . sort ( ) . forEach ( function ( s ) { var n = graphMap [ s ] ; delete n . usages ; if ( Object . keys ( n ) . length === 1 && n [ '@id' ] ) { return 'continue' ; } node [ '@graph' ] . push ( n ) ; } ) ; } delete node . usages ; if ( Object . keys ( node ) . length === 1 && node [ '@id' ] ) { return 'continue' ; } result . push ( node ) ; } ) ; return result ; } 
function splitUnique ( string ) { string = string && string . trim ( ) ; if ( string ) { return unique ( string . split ( / \s+ / ) ) ; } else { return undefined ; } } 
function walkNodes ( $nodes , currentItem ) { $nodes . each ( function ( i , node ) { var $node = $ ( node ) ; var props = splitUnique ( $node . attr ( 'itemprop' ) ) ; if ( props && currentItem ) { var value = null ; if ( $node . is ( '[itemscope]' ) ) { value = parseItem ( node , currentItem ) ; } else { value = parsePropertyValue ( node ) ; walkNodes ( $node . children ( ) , currentItem ) ; } currentItem . addProperties ( props , value ) ; } else if ( $node . is ( '[itemscope]' ) && ! $node . is ( '[itemprop]' ) ) { var newItem = parseItem ( node , currentItem ) ; if ( newItem !== Item . ERROR ) { items . push ( newItem ) ; } } else { walkNodes ( $node . children ( ) , currentItem ) ; } } ) ; } 
function parseItem ( node , currentItem ) { 
function resolveUrlAttribute ( $node , attr ) { var url = $node . attr ( attr ) ; if ( url === undefined ) return '' ; if ( isAbsoluteUrl ( url ) ) { return url ; } else { return urlUtil . resolve ( base , url ) ; } } 
function parsePropertyValue ( node ) { var $node = $ ( node ) ; if ( $node . is ( 'meta' ) ) { return resolveAttribute ( $node , 'content' ) ; } else if ( $node . is ( 'audio,embed,iframe,img,source,track,video' ) ) { return resolveUrlAttribute ( $node , 'src' ) ; } else if ( $node . is ( 'a,area,link' ) ) { return resolveUrlAttribute ( $node , 'href' ) ; } else if ( $node . is ( 'object' ) ) { return resolveUrlAttribute ( $node , 'data' ) ; } else if ( $node . is ( 'data,meter' ) ) { return resolveAttribute ( $node , 'value' ) ; } else if ( $node . is ( 'time' ) ) { return resolveAttribute ( $node , 'datetime' ) ; } else { var text = $node . text ( ) ; return text || '' ; } } 
function processPatterns ( patterns , fn ) { 
function sendMessage ( args ) { last = new Date ( ) ; fs . write ( tmpfile , JSON . stringify ( args ) + '\n' , 'a' ) ; 
function ( url ) { grunt . verbose . write ( 'Running PhantomJS...' ) . or . write ( '...' ) ; grunt . log . error ( ) ; grunt . warn ( 'PhantomJS unable to load "' + url + '" URI.' , 90 ) ; } 
function Flowa ( flow , name ) { this . name = typeof name == 'undefined' ? null : name ; this . _root = flow ; this . _tasks = { } ; this . _runners = { serial : serial , parallel : parallel } ; this . _rootName = Symbol ( '__root__' ) ; this . _tasksRunnersTypes = { } ; this . _tasksDepths = { } ; this . _tasksParents = { } ; this . _defaultRunnerType = 'serial' ; this . _init ( ) ; } 
function F ( type , term ) { let original = term ; if ( term && ! term . __meta ) { term = type . wrap ? type . wrap ( term ) : term ; term . __meta = { } ; term . __name = function ( name ) { term . __meta . name = name ; return term ; } ; term . __desc = function ( desc ) { term . __meta . desc = desc ; return term ; } ; if ( term . __meta ) { term . __meta . term = original ; term . __meta . name = "anon" ; term . __meta . desc = "no description" ; } ; } ; F . check ( type , term ) ; return term ; } 
function make ( options ) { var shopifyTheme ; var previous = shopifyThemeInstances . filter ( ( instance ) => { return options . shop_name === instance . _shopName && options . api_key === instance . _apiKey ; } ) ; if ( previous . length ) return previous [ 0 ] ; shopifyTheme = new ShopifyTheme ( options ) ; shopifyThemeInstances . push ( shopifyTheme ) ; return shopifyTheme ; } 
function end ( error ) { _this . _queueRunning = false ; if ( error ) { _this . _taskQueue = [ ] ; return ; } 
function Background ( width = 0 , height = 0 , radius = [ 0 , 0 , 0 , 0 ] ) { THREE . Mesh . call ( this , new BackgroundGeometry ( width , height , radius ) , new THREE . MeshStandardMaterial ( { side : THREE . DoubleSide } ) , undefined ) this . name = 'Background' 
function BorderLine ( lineWidth = [ 0.01 , 0.01 , 0.01 , 0.01 ] , width = 0 , height = 0 , radius = [ 0 , 0 , 0 , 0 ] ) { THREE . Mesh . call ( this , new BorderGeometry ( lineWidth , width , height , radius ) , new THREE . MeshStandardMaterial ( { side : THREE . DoubleSide } ) , undefined ) this . name = 'BorderLine' 
function ( json , delimiter ) { var result = [ ] ; var recurse = function ( cur , prop ) { for ( var key in cur ) { if ( cur . hasOwnProperty ( key ) ) { var item = cur [ key ] ; result . push ( { match : prop ? prop + delimiter + key : key , replacement : item , expression : false } ) ; 
function ld ( date , long = true , options = null ) { return Localizer . Singleton . formatDate ( date , long , options ) } 
function ldt ( date , long = true , options = null ) { return Localizer . Singleton . formatDateTime ( date , long , options ) } 
function ( replacer , e ) { var message = e ; if ( e instanceof Error ) { message = e . message ; } replacer . emit ( 'error' , e ) ; } 
function ( context ) { return function ( plugin ) { var pattern = context . pattern ; if ( plugin . match ( pattern , opts ) === true ) { plugin . transform ( pattern , opts , function ( items ) { if ( items instanceof Error ) { throw items ; } else { 
function ( opts ) { 
function getStyle ( element , property ) { if ( window . getComputedStyle ) { return getStyleProperty ( element , property ) . original ; } else if ( element . currentStyle ) { return element . currentStyle [ property ] ; } return null ; } 
function hasChanged ( newData , oldData ) { var changed = false for ( var i = 0 ; i < scope . length ; i ++ ) { var k = scope [ i ] , newVal = _ . get ( newData , k ) , oldVal = _ . get ( oldData , k ) if ( ! _ . isEqual ( newVal , oldVal ) ) { changed = true break } } return changed } 
function buildOptions ( data ) { var slg = slug ( _ . get ( data , slugField ) , slugOptions ) , key = doc + '|' 
function buildSlug ( data , update , done ) { var opt = buildOptions ( data ) 
function ( needles , haystack ) { var i , needleArr = needles . split ( / \s+ / g ) , needle , needleRegexpArr = [ ] , regexp , retVal = true , hasUpperCase , regexpFlags ; 
function ( values , callback , items ) { var valuesToAdd = values . splice ( 0 , 100 ) ; items = items || [ ] ; items = items . concat ( self . add ( valuesToAdd ) ) ; if ( values . length > 0 ) { setTimeout ( function ( ) { addAsync ( values , callback , items ) ; } , 10 ) ; } else { self . update ( ) ; callback ( items ) ; } } 
function ( initValues , element , notCreate ) { if ( element === undefined ) { if ( notCreate ) { item . values ( initValues , notCreate ) ; } else { item . values ( initValues ) ; } } else { item . elm = element ; var values = templater . get ( item , initValues ) ; item . values ( values ) ; } } 
function ( nodes ) { var result = Object . prototype . toString . call ( nodes ) ; if ( typeof nodes === 'object' && / ^\[object (HTMLCollection|NodeList|Object)\]$ / . test ( result ) && ( nodes . length == 0 || ( typeof nodes [ 0 ] === "object" && nodes [ 0 ] . nodeType > 0 ) ) ) { return true ; } return false ; } 
function validate ( host ) { const hostScheme = joi . array ( ) . items ( joi . string ( ) . min ( 1 ) ) . min ( 1 ) . single ( ) joi . assert ( host , hostScheme , 'The parameter `host` is invalid. Its' ) } 
function getRoutes ( server , host ) { return server . table ( host ) . map ( ( { path , method , settings : { vhost } } ) => ( { path , method , ... ( vhost ? { vhost } : { } ) } ) ) } 
function decorator ( server , ... rest ) { validate ( ... rest ) const routeList = getRoutes ( server , ... rest ) const sorted = _ . sortBy ( routeList , serialize ) return _ . sortedUniqBy ( sorted , serialize ) } 
function index ( origin ) { var newComers = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i ++ ) { newComers [ _i - 1 ] = arguments [ _i ] ; } var extensions = null ; var base = origin ; if ( isPlainObject ( origin ) && origin . extensions && Object . keys ( origin ) . length === 1 ) { base = { } ; extensions = origin . extensions ; } return newComers . reduce ( function ( result , newComer ) { return mergeRecursively ( result , newComer , extensions ) ; } , base ) ; } 
function checkUrl ( url , method , routes ) { method = method . toLowerCase ( ) ; for ( var i = 0 ; i < routes . length ; i ++ ) { var route = routes [ i ] ; if ( ( matchPath ( route . url , url ) ) && ( method == route . method ) ) return route ; } return false ; } 
function eatBraces ( stream , root ) { if ( stream . eat ( LBRACE ) ) { let stack = 1 , token ; while ( ! stream . eof ( ) ) { if ( stream . eat ( RBRACE ) ) { stack -- ; if ( ! stack ) { break ; } } else if ( stream . eat ( LBRACE ) ) { stack ++ ; } else if ( eatUrl ( stream ) || eatString ( stream ) ) { continue ; } else if ( token = comment ( stream ) ) { root . addComment ( token ) ; continue ; } else { stream . next ( ) ; } } return true ; } return false ; } 
function getCommitSha ( ) { try { return execSync ( "git rev-parse HEAD" ) . toString ( ) ; } catch ( ignore ) { console . warn ( "Failed to get commit sha via git command" ) ; } try { return execSync ( "cat .git/ORIG_HEAD" ) . toString ( ) ; } catch ( ignore ) { console . warn ( "Failed to get commit sha by reading from ORIG_HEAD" ) ; } return null ; } 
function underscore ( baseQuery ) { return _ . mapKeys ( baseQuery , function ( v , k ) { return tableColumnRenamer . underscore ( k ) } ) } 
function filterQueryParams ( baseClause , request ) { _ . forEach ( request . query , function ( v , k ) { addWhereClause ( baseClause , k , v ) } ) return baseClause } 
function addWhereClause ( baseClause , k , v ) { if ( v . startsWith ( '>' ) ) { baseClause . where ( k , '>=' , v . substring ( 1 ) ) ; return } if ( v . startsWith ( '<' ) ) { baseClause . where ( k , '<=' , v . substring ( 1 ) ) ; return } if ( v . startsWith ( '~' ) ) { baseClause . where ( k , 'LIKE' , v . substring ( 1 ) ) ; return } if ( k . endsWith ( 'Id' ) ) { baseClause . where ( k . substring ( 0 , k . length - 2 ) + '_id' , '=' , v ) ; return } baseClause . where ( k , '=' , v ) ; return } 
function findByIdQueryParams ( request , config ) { return typeof config . baseQuery === 'undefined' ? { 'id' : request . params . id } : _ . merge ( { 'id' : request . params . id } , underscore ( config . baseQuery ( request ) ) ) } 
function empty ( entity , schema , Empty ) { if ( typeof entity === 'undefined' || entity === null ) { return } _ . forEach ( schema , function ( v , k ) { if ( v === Empty ) { delete entity [ k ] } } ) } 
function initModel ( config ) { if ( typeof config . bookshelfModel . prototype . schema === 'undefined' ) { config . bookshelfModel . prototype . schema = { } } addConstraintsForForeignKeys ( config . bookshelfModel , config . baseQuery ) config . bookshelfModel . prototype . format = tableColumnRenamer . renameOnFormat config . bookshelfModel . prototype . parse = tableColumnRenamer . renameOnParse initJsonDateFormat ( config . bookshelfModel ) } 
function addConstraintsForForeignKeys ( bookshelfModel , baseQuery ) { if ( typeof baseQuery === 'undefined' ) { return } _ . forEach ( baseQuery ( { params : { } , payload : { } } ) , function ( v , k ) { const value = bookshelfModel . prototype . schema [ k ] if ( typeof value === 'undefined' ) { bookshelfModel . prototype . schema [ k ] = Joi . any ( ) . required ( ) } else if ( value . isJoi ) { bookshelfModel . prototype . schema [ k ] = bookshelfModel . prototype . schema [ k ] . required ( ) } } ) } 
function initJsonDateFormat ( bookshelfModel ) { const schema = bookshelfModel . prototype . schema const originalFunction = bookshelfModel . prototype . toJSON 
function formatNumber ( payload , schema ) { _ . forEach ( schema , function ( v , k ) { if ( v !== null && v . _type === 'number' ) { if ( typeof payload [ k ] === 'undefined' || payload [ k ] === null ) { payload [ k ] = 0 } } } ) } 
function formatDate ( payload , schema ) { _ . forEach ( schema , function ( v , k ) { if ( v !== null && v . _type === 'date' ) { if ( payload [ k ] !== null ) { payload [ k ] = new Date ( payload [ k ] ) } } } ) } 
function setForeignKeys ( request , baseQuery ) { if ( typeof baseQuery === 'undefined' ) { return } _ . forEach ( baseQuery ( request ) , function ( v , k ) { request . payload [ k ] = request . params [ k ] } ) } 
function transformConstraintViolationMessages ( input ) { return { validationErrors : _ . chain ( input . details ) . mapKeys ( function ( v , k ) { 
function lazyConsForce ( ) { var val = this . tailFn ( ) ; this . tailValue = Array . isArray ( val ) ? fromArray ( val ) : val ; delete this . tail ; delete this . force ; return this ; } 
function fromArrayIter ( arr , n ) { if ( n < arr . length ) { return cons ( arr [ n ] , function ( ) { return fromArrayIter ( arr , n + 1 ) ; } ) ; } else { return nil ; } } 
function append ( ) { var acc = nil ; for ( var i = 0 ; i < arguments . length ; i ++ ) { acc = acc . append ( arguments [ i ] ) ; } return acc ; } 
function listFold ( list , z , f , n ) { if ( n < list . length ) { return f ( list [ n ] , function ( ) { return listFold ( list , z , f , n + 1 ) ; } ) ; } else { return z ; } } 
function plugin ( opts ) { var obj = { } ; try { var content = fs . readFileSync ( './package.json' , { encoding : 'utf8' } ) ; obj = JSON . parse ( content ) ; } catch ( e ) { 
function isEmptyTag ( node ) { if ( node . constructor === Element && ! node . hasChildNodes ( ) ) return true return Boolean ( EMPTY_TAG_SET [ node . tagName ] ) } 
function LogWatcher ( dirpath , maxfiles , ignoreInitial ) { _classCallCheck ( this , LogWatcher ) ; var _this = _possibleConstructorReturn ( this , ( LogWatcher . __proto__ || Object . getPrototypeOf ( LogWatcher ) ) . call ( this ) ) ; _this . _dirpath = dirpath || DEFAULT_SAVE_DIR ; _this . _filter = isCommanderLog ; _this . _maxfiles = maxfiles || 3 ; _this . _logDetailMap = { } ; _this . _ops = [ ] ; _this . _op = null ; _this . _startTime = new Date ( ) ; _this . _timer = null ; _this . _die = false ; _this . _ignoreInitial = ignoreInitial || false ; _this . stopped = false ; _this . _loop ( ) ; _this . emit ( 'Started' ) ; return _this ; } 
function isCommanderLog ( fpath ) { var base = _path2 . default . basename ( fpath ) ; return base . indexOf ( 'Journal.' ) === 0 && _path2 . default . extname ( fpath ) === '.log' ; } 
function loadImage ( image ) { $scope . $applyAsync ( function ( ) { if ( $scope . reversed ) $scope . flipContext ( ) ; $scope . signatureReady = true ; ctxBackground . clearRect ( 0 , 0 , canvas . width , canvas . height ) ; ctxBackground . drawImage ( image , 0 , 0 , canvasBackground . width , canvasBackground . height ) ; } ) ; } 
function ( ) { if ( this . read ) { this.event(name, eventFunctionFactory(value, context), context); }*/ } 
function ( functionBody , argNames , argValues , context ) { 
function ( expected , actual , optionsOrMsg ) { var options = optionsOrMsg instanceof Object ? optionsOrMsg : { message : optionsOrMsg } , msg = options . message , compatHtml = bender . tools && bender . tools . compatHtml ; if ( ! options . skipCompatHtml ) { var sortAttributes = ( 'sortAttributes' in options ) ? options . sortAttributes : true , fixZWS = ( 'fixZWS' in options ) ? options . fixZWS : true , fixNbsp = ( 'fixNbsp' in options ) ? options . fixNbsp : true ; if ( ! compatHtml ) { throw new Error ( 'Missing bender.tools.compatHtml' ) ; } expected = compatHtml ( expected , options . noInterWS , sortAttributes , fixZWS , options . fixStyles , fixNbsp , options . noTempElements , options . customFilters ) ; actual = compatHtml ( actual , options . noInterWS , sortAttributes , fixZWS , options . fixStyles , fixNbsp , options . noTempElements , options . customFilters ) ; } bender . assert . areSame ( html_beautify ( expected , this . _config ) , html_beautify ( actual , this . _config ) , msg ) ; } 
function ( expected , actual , msg ) { bender . assert . areSame ( js_beautify ( expected , this . _config ) , js_beautify ( actual , this . _config ) , msg ) ; } 
function ( expected , actual , msg ) { var assert = bender . assert ; assert . isTypeOf ( 'object' , expected , 'Expected is not an object' ) ; assert . isTypeOf ( 'object' , actual , 'Actual is not an object' ) ; 
function checkIfShouldStick ( ) { if ( mediaQuery && ! matchMedia ( '(' + mediaQuery + ')' ) . matches ) return ; var scrollTop = ( window . pageYOffset || doc . scrollTop ) - ( doc . clientTop || 0 ) ; var shouldStick = scrollTop >= stickyLine ; 
function getSanitizedSelector ( selector ) { return selector . replace ( / -([a-z]) / g , function ( g ) { return g [ 1 ] . toUpperCase ( ) ; } ) . replace ( / \[|] / g , "" ) ; } 
function findClusterByAddinId ( id ) { var i , j ; var clusters ; for ( j = 1 ; j < arguments . length ; j ++ ) { clusters = arguments [ j ] ; for ( i = 0 ; i < clusters . length ; i ++ ) { if ( clusters [ i ] . containsAddin ( id ) ) { return clusters [ i ] ; } } } return null ; } 
function buildServicesInternal ( ) { if ( _ . isFunction ( subdivision . buildServices ) ) { subdivision . vent . trigger ( 'before:buildServices' ) ; return subdivision . buildServices ( ) . then ( function ( ) { subdivision . vent . trigger ( 'after:buildServices' ) ; } ) ; } else { return Promise . resolve ( ) ; } } 
function ( axis ) { if ( _ . isString ( axis ) ) { if ( _ . isEmpty ( axis ) || _ . indexOf ( axis , _delimiter ) >= 0 ) { return false ; } return true ; } return false ; } 
function ( ) { if ( arguments . length === 0 ) { return '' ; } if ( arguments [ 0 ] instanceof Array ) { return subdivision . registry . joinPath . apply ( this , _ . flatten ( arguments [ 0 ] ) ) ; } var args = Array . prototype . slice . call ( arguments , 0 ) ; var result = [ ] ; _ . forEach ( args , function ( value ) { var axes = subdivision . registry . breakPath ( value ) ; var i ; for ( i = 0 ; i < axes . length ; i ++ ) { result . push ( axes [ i ] ) ; } } ) ; if ( result . length === 0 ) { return '' ; } else { return result . join ( _delimiter ) ; } } 
function ( path ) { if ( ! _ . isString ( path ) ) { throw new Error ( 'path must be a string ' + JSON . stringify ( path ) ) ; } if ( path === '' ) { return [ ] ; } var splitPath = path . split ( _delimiter ) ; _ . forEach ( splitPath , function ( axis ) { if ( ! subdivision . registry . verifyAxis ( axis ) ) { throw new Error ( 'Invalid axis ' + axis ) ; } } ) ; return splitPath ; } 
function ( path ) { var node = this . $getNode ( path , false ) ; if ( node !== null ) { return _ . keys ( node . nodes ) ; } else { return null ; } } 
function Computed ( readFn , writeFn , context ) { this . readFn = readFn ; this . writeFn = writeFn ; this . context = context ; } 
function ( obj ) { if ( obj == null || typeof obj != 'object' || Object . isFrozen ( obj ) || obj . _keepHot ) return ; Object . freeze ( obj ) ; 
function ( parentClass , constructor ) { 
function f ( prex ) { return { restrict : 'A' , link : function link ( scope , elez , attrs , crtl ) { crtl . select ( attrs . tabHref ) ; } } ; } 
function BinarySearchTreeIterator ( tree , type ) { type = type || 'v' ; if ( type !== 'k' && type !== 'v' && type !== 'e' ) { throw new Error ( 'Incorrect binary search tree iterator type "' + type + '"!' ) ; } this . _type = type ; this . _tree = tree ; this . _last = null ; this . _done = false ; } 
function ( xhr , options , promise ) { var instance = this , url = options . url , method = options . method || GET , headers = options . headers ? options . headers . itsa_deepClone ( ) : { } , 
function ( xhr , promise , headers , method ) { 
function ( xhr , promise ) { 
function ( data ) { var paramArray = [ ] , key , value ; for ( key in data ) { value = data [ key ] ; key = ENCODE_URI_COMPONENT ( key ) ; paramArray . push ( ( value === null ) ? key : ( key + "=" + ENCODE_URI_COMPONENT ( value ) ) ) ; } return paramArray . join ( "&" ) ; } 
function ( queryString ) { var args = queryString . split ( "&" ) , data = { } ; args . forEach ( function ( arg ) { var item = arg . split ( "=" ) ; ( item . length === 2 ) && ( data [ item [ 0 ] ] = item [ 1 ] ) ; } ) ; return data ; } 
function ( ) { var instance = this ; instance . _runningRequests . forEach ( function ( promise ) { promise . abort ( ) ; } ) ; instance . _runningRequests . length = 0 ; } 
function ( options ) { var instance = this , props = { } , xhr , promise ; options = Object . itsa_isObject ( options ) ? options . itsa_deepClone ( ) : { } ; promise = Promise . itsa_manage ( options . streamback , options . stayActive ) ; xhr = new XMLHttpRequest ( ) ; props . _isXHR2 = xhr2support ; 
function loadTasks ( dir ) { dir = require ( 'path' ) . resolve ( dir ) ; var modules = { } ; var list = require ( 'fs' ) . readdirSync ( dir ) ; var jsFile = / .*\.js / ; 
function invokeConfigFn ( tasks ) { for ( var taskName in tasks ) { if ( tasks . hasOwnProperty ( taskName ) ) { tasks [ taskName ] ( grunt ) ; } } } 
function f ( prex ) { var template = '<div class="' + prex + '-progress-bar">\n\t<span class="caption" ng-transclude></span>\n\t<div class="bar {{cls}}"></div>\n</div>' ; return { restrict : 'E' , replace : true , transclude : true , scope : { 'color' : '&color' , 'caption' : '&title' , 'progress' : '&progress' } , link : function link ( scope , ele , attr , ctrl ) { var total = parseInt ( attr . total ) || 100 ; var bar = angular . element ( ele . children ( ) [ 1 ] ) ; scope . $watch ( scope . progress , function ( value ) { return bar . css ( { 'width' : Number ( value ) * 100 / total + '%' } ) ; } ) ; scope . $watch ( scope . color , function ( value ) { return scope . cls = value ; } ) ; } , template : template } ; } 
function callSuccess ( REQ , res , resObj ) { if ( typeof REQ . _onSuccess === 'function' ) REQ . _onSuccess ( res , resObj ) ; } 
function callError ( REQ , res , resObj ) { if ( typeof REQ . _onError === 'function' ) REQ . _onError ( res , resObj ) ; } 
function addHandlers ( reqOptions ) { reqOptions . success = cb => { if ( typeof cb === 'function' ) reqOptions . _onSuccess = cb ; else throw Error ( 'callback not passed to "success" method' ) ; return reqOptions ; } reqOptions . error = cb => { if ( typeof cb === 'function' ) reqOptions . _onError = cb ; else throw Error ( 'callback not passed to "error" method' ) ; return reqOptions ; } return reqOptions ; } 
function post ( url , data , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'POST' , data : data , headers : headers } ) ; } 
function postJson ( url , data , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'POST' , data : data , requestContentType : 'json' , headers : headers } ) ; } 
function put ( url , data ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'PUT' , data : data } ) ; } 
function putJson ( url , data , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'PUT' , data : data , requestContentType : 'json' , headers : headers } ) ; } 
function _delete ( url , data ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'DELETE' , data : data } ) ; } 
function deleteJson ( url , data , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; return newRequest ( { url : url , method : 'DELETE' , data : data , requestContentType : 'json' , headers : headers } ) ; } 
function f ( prex ) { var template = '<div class="alert {{types}} {{status}}" role="alert">\n\t<button class="' + prex + '-dismiss close" ng-click="close()">&times;</button>\n\t<h4 ng-if="show">{{block}}</h4>\n\t<p ng-transclude></p>\n</div>' ; return { restrict : 'E' , transclude : true , replace : true , scope : { 'status' : '@' , 'title' : '@' } , link : function link ( scope , elez , attrs ) { scope . types = scope . title ? 'block' : 'basic' ; scope . show = scope . types === 'block' ; scope . close = function ( ) { return elez . remove ( ) ; } ; } , template : template } ; } 
function ensureProperties ( str ) { str = str || '' ; t . ok ( hasPropertyDefinition ( view , 'value' ) , 'has `value` property' + str ) ; t . equal ( typeof view . name , 'string' , 'has `name` property that is a string' + str ) ; t . notEqual ( view . name , '' , '`name` property should not be empty string' + str ) ; t . ok ( isFunction ( view . setValue ) , 'has `setValue` method' + str ) ; t . equal ( typeof view . valid , 'boolean' , 'has `valid` property that is a boolean' + str ) ; t . equal ( parent , view . parent , 'has same `parent` property' + str ) ; } 
function printEnvironment ( environment , path , outputFile ) { 
function rte ( src , dest , data ) { if ( typeof dest === 'object' ) { data = dest ; dest = src ; } var rte = new Rte ( src , data ) ; return rte . stringify ( dest ) ; } 
function Rte ( path , data ) { this . data = data || { } ; this . path = path ; this . data . path = this . path ; } 
function f ( prex ) { return { restrict : 'E' , transclude : true , scope : { } , link : function link ( scope , elez , attrs , crtl ) { var panel = angular . element ( elez ) . children ( '.tabs-content' ) ; scope . position = attrs . position || 'top' ; scope . select = function ( ) { var name = arguments . length <= 0 || arguments [ 0 ] === undefined ? 0 : arguments [ 0 ] ; panel . addClass ( 'ng-hide' ) . removeClass ( 'active' ) ; angular . forEach ( panel , function ( value , key ) { var ele = angular . element ( value ) ; if ( ele . attr ( 'id' ) === name || name === key ) { ele . addClass ( 'ng-show' ) . removeClass ( 'ng-hide' ) . addClass ( 'active' ) ; } } ) ; } ; scope . select ( attr . home ) ; } , templete : '<div class="' + prex + '-tabs {{position}}" ng-transclude></div>' } ; } 
function ( domElement , model , parent ) { this . domElement = domElement ; this . model = model ; this . parent = parent ; this . traverseChildren = true ; this . bindings = [ ] ; } 
function ( domElement , model , parent ) { if ( domElement . nodeType !== Node . ELEMENT_NODE ) return ; var attributeName ; if ( domElement . tesujiBindingContext == null ) domElement . tesujiBindingContext = new ElementBindingContext ( domElement , model , parent ) ; else domElement . tesujiBindingContext . rebind ( model , parent ) ; if ( registeredComponents [ domElement . nodeName ] ) { 
function ( name , value , elementBindingContext ) { var binding ; for ( var i = 0 ; i < registeredAttributes . length ; i ++ ) { if ( ( registeredAttributes [ i ] . pattern . constructor == String && registeredAttributes [ i ] . pattern == name ) || ( registeredAttributes [ i ] . pattern . constructor == RegExp && name . search ( registeredAttributes [ i ] . pattern ) >= 0 ) ) { binding = new registeredAttributes [ i ] ( name , value , elementBindingContext ) ; elementBindingContext . addBinding ( binding ) ; binding . apply ( ) ; } } } 
function ( domElement ) { if ( domElement . nodeType !== Node . ELEMENT_NODE ) return ; if ( domElement . tesujiBindingContext == null ) return ; if ( domElement . tesujiBindingContext . keepTraversing ( ) ) { for ( var i = 0 ; i < domElement . children . length ; i ++ ) { removeModelFromDOMElement ( domElement . children [ i ] ) ; } } domElement . tesujiBindingContext . clearBindings ( ) ; } 
function Component ( domElement ) { this . domElement = domElement ; this . template = "" ; this . templateNodes = [ ] ; this . model = [ ] ; this . parentModel = null ; this . built = false ; } 
function ( template ) { 
function ( model , parentModel ) { if ( model == null ) model = this . model ; this . parentModel = parentModel ; 
function ( newModel ) { var oldPos ; for ( var i = 0 ; i < newModel . length ; i ++ ) { oldPos = this . model . indexOf ( newModel [ i ] ) ; if ( oldPos >= 0 ) { 
function ( position ) { if ( ! this . templateNodes [ 0 ] ) { var templateNodes = this.templateNodes[0]; if(position == null || position == this.templateNodes.length) { for(var i = 0; i < templateNodes.length; i++) { clonedNode = templateNodes[i].cloneNode(true); this.domElement.appendChild(clonedNode); clonedNodes.push(clonedNode); } this.templateNodes.push(clonedNodes); } else { for(var i = 0; i < templateNodes.length; i++) { clonedNode = templateNodes[i].cloneNode(true); this.domElement.insertBefore(clonedNode, this.templateNodes[position][0]); clonedNodes.push(clonedNode); } this.templateNodes.splice(position, 0, clonedNodes); }*/ var dummyWrapper = document . createElement ( "div" ) ; 
function ( from , to ) { var templateNodes = this . templateNodes [ from ] ; 
function BaseImporter ( ) { this . _schema = null ; this . _export = null ; this . _types = { } ; this . _model = { properties : { } , definitions : { } , ids : { } } ; this . error = null ; var baseImporter = this ; //setup listeners this . on ( 'readyStateChanged' , function ( readyState ) { //state changed if ( readyStates . complete === readyState ) { //state says loading has finished if ( baseImporter . error ) { baseImporter . emit ( 'failed' , baseImporter . error ) ; } else { baseImporter . emit ( 'success' , null , baseImporter . getModel ( ) ) ; } //send general complete notification baseImporter . emit ( 'complete' , baseImporter . error , baseImporter . getModel ( ) ) ; } } ) ; } 
function ( nextSchema , nextScope , nextIndex , nextPath , nextCBack ) { var nSchema = nextSchema || false ; var nScope = nextScope ; var nIndex = nextIndex ; var nPath = nextPath ; var nCBack = nextCBack || function ( ) { } ; if ( false === nSchema ) { return function ( ) { } ; } else { return function ( ) { baseimporter . indexIDs . call ( baseimporter , nSchema , nScope , nIndex , nPath , nCBack ) ; } ; } } 
function loadFormatter ( formatterPath ) { try { 
function createDirectory ( filePath , cb ) { var dirname = path . dirname ( filePath ) ; mkdirp ( dirname , function ( err ) { if ( ! err ) { cb ( ) ; } else { console . error ( 'Error creating directory: ' , err ) ; } } ) ; } 
function rstr_hmac_sha1 ( key , data ) { var bkey = rstr2binb ( key ) ; if ( bkey . length > 16 ) bkey = binb_sha1 ( bkey , key . length * 8 ) ; var ipad = Array ( 16 ) , opad = Array ( 16 ) ; for ( var i = 0 ; i < 16 ; i ++ ) ipad [ i ] = bkey [ i ] ^ 0x36363636 , opad [ i ] = bkey [ i ] ^ 0x5C5C5C5C ; var hash = binb_sha1 ( ipad . concat ( rstr2binb ( data ) ) , 512 + data . length * 8 ) ; return binb2rstr ( binb_sha1 ( opad . concat ( hash ) , 512 + 160 ) ) ; } 
function binb_sha1 ( x , len ) { 
function requestGET ( url , callback ) { request . get ( { url : url , encoding : null } , function ( err , res , body ) { if ( err ) { callback ( err ) ; return ; } if ( res . statusCode !== 200 ) { callback ( res . statusCode ) ; return ; } var regex = / (?:charset|encoding)\s*=\s*['"]? *([\w\-]+) / i ; var encoding = regex . exec ( res . headers [ 'content-type' ] ) [ 1 ] ; var $ = cheerio . load ( iconv . decode ( new Buffer ( body ) , encoding ) ) ; callback ( null , $ ) ; } ) ; } 
function toQS ( options , near , movie ) { var args = { } ; if ( options . date ) args . date = options . date ; if ( options . lang ) args . hl = options . lang ; if ( near ) args . near = near ; if ( movie ) args . movie = movie ; return '?' + qs . stringify ( args ) ; } 
function formatInfos ( infos ) { var cursor = 0 , duration = null , rating = null , genre = null ; if ( infos [ cursor ] . match ( / (1|2|hr|min) / ) ) { duration = infos [ cursor ] . trim ( ) ; cursor ++ ; } if ( infos [ cursor ] . match ( / (G|\+|13|16|18) / ) ) { rating = infos [ cursor ] . trim ( ) ; cursor ++ ; } if ( infos [ cursor ] . match ( / (^\D*$) / ) ) { genre = infos [ cursor ] . trim ( ) ; cursor ++ ; } return { duration : duration , rating : rating , genre : genre } ; } 
function formatShowtimes ( showtimes ) { var today = new Date ( ) ; var d = today ; 
function Observer ( fn , observerInfo ) { 
function ( directory ) { var git , gitRef , packagePath , packageInfos ; packagePath = path . join ( directory , "package.json" ) ; 
function simulateKeyboardEvent ( type , key ) { var codes = { left : 37 , up : 38 , right : 39 , down : 40 , w : 87 , a : 65 , s : 83 , d : 68 , enter : 13 , escape : 27 , space : 32 , control : 17 , z : 90 , x : 88 } ; var event = new KeyboardEvent ( type ) ; 
function ( payload , next ) { jira . getProject ( options . project , handleGetProject ( options , payload , next ) ) ; } 
function ( payload , next ) { var issueOptions = createIssueOptions ( payload , options ) ; jira . addNewIssue ( issueOptions , function ( err , issue ) { if ( err ) { return next ( err ) ; } else { next ( null , issue ) ; } } ) ; } 
function ( cssFilePath , fullUrl , imageUrl , options ) { imageUrl = imageUrl . trim ( ) . replace ( rQuotes , "" ) . replace ( rParams , "" ) ; 
function ( localImagePath ) { 
function end ( ) { try { this . queue ( transformCss ( filePath , data , opts ) ) ; } catch ( err ) { this . emit ( "error" , new Error ( err ) ) ; } this . queue ( null ) ; } 
function apilist ( items ) { return ul ( items . map ( item => li ( { 
function newRequest ( reqOptions ) { var XHR_REQ = addHandlers ( new XMLHttpRequest ( ) ) ; XHR_REQ . addEventListener ( 'readystatechange' , function ( evt ) { if ( XHR_REQ . readyState === 4 ) handleResponse ( XHR_REQ , reqOptions ) ; } ) ; XHR_REQ . open ( reqOptions . method , reqOptions . url ) ; if ( reqOptions . headers ) { ( 0 , _lodash8 . default ) ( reqOptions . headers , function ( val , key ) { if ( key === 'withCredentials' && val === true ) XHR_REQ . withCredentials = 'true' ; else XHR_REQ . setRequestHeader ( key , val ) ; } ) ; } if ( reqOptions . method === 'GET' ) XHR_REQ . send ( ) ; else { if ( reqOptions . requestContentType === 'json' ) { XHR_REQ . setRequestHeader ( 'Content-Type' , 'application/json;charset=UTF-8' ) ; if ( ( 0 , _lodash4 . default ) ( reqOptions . data ) ) XHR_REQ . send ( JSON . stringify ( reqOptions . data ) ) ; else XHR_REQ . send ( reqOptions . data ) ; } else if ( reqOptions . requestContentType === 'urlencoded' ) { XHR_REQ . setRequestHeader ( 'Content-Type' , 'application/x-www-form-urlencoded' ) ; XHR_REQ . send ( reqOptions . data ) ; } else XHR_REQ . send ( reqOptions . data ) ; } return XHR_REQ ; } 
function handleResponse ( XHR_REQ , reqOptions ) { var resObj = { response : XHR_REQ . response , responseText : XHR_REQ . responseText , responseURL : XHR_REQ . responseURL , status : XHR_REQ . status , statusText : XHR_REQ . statusText } ; if ( XHR_REQ . status >= 200 && XHR_REQ . status < 400 ) { var contentTypeHeader = XHR_REQ . getResponseHeader ( 'content-type' ) ; var isJsonResponse = / application\/json / . test ( contentTypeHeader ) ; if ( reqOptions . responseContentType === 'json' || isJsonResponse ) return handleJsonResponse ( XHR_REQ , resObj ) ; else return callSuccess ( XHR_REQ , XHR_REQ . response , resObj ) ; } else return callError ( XHR_REQ , XHR_REQ . response , resObj ) ; } 
function handleJsonResponse ( XHR_REQ , resObj ) { var jsonData = parseJson ( XHR_REQ . response ) ; if ( ( 0 , _lodash6 . default ) ( jsonData ) ) return callSuccess ( XHR_REQ , jsonData , resObj ) ; else return callError ( XHR_REQ , 'Error parsing response. Expected JSON.' , resObj ) ; } 
function get ( url , params , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; if ( ( 0 , _lodash4 . default ) ( params ) ) { if ( url . indexOf ( '?' ) === - 1 ) url = url + '?' ; url += serializeObject ( params ) ; } return newRequest ( { url : url , method : 'GET' , headers : headers } ) ; } 
function getJson ( url , params , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; if ( ( 0 , _lodash4 . default ) ( params ) ) { if ( url . indexOf ( '?' ) === - 1 ) url = url + '?' ; url += serializeObject ( params ) ; } return newRequest ( { url : url , method : 'GET' , responseContentType : 'json' , headers : headers } ) ; } 
function postUrlencoded ( url , data , headers ) { if ( typeof url !== 'string' ) throw Error ( 'url must be a string' ) ; if ( ! ( 0 , _lodash4 . default ) ( data ) ) throw Error ( 'data must be an object of key value pairs' ) ; return newRequest ( { url : url , method : 'POST' , data : serializeObject ( data ) , requestContentType : 'urlencoded' , headers : headers } ) ; } 
function ( subscribers , value ) { if ( ! subscribers ) return ; var subs = subscribers . slice ( ) ; for ( var i = 0 ; i < subs . length ; i ++ ) { if ( typeof subs [ i ] == "function" ) subs [ i ] ( value ) ; else if ( typeof subs [ i ] . call == "function" ) subs [ i ] . call ( value ) ; else throw new TypeError ( "Observer is not callable." ) ; } } 
function ( property , callback ) { if ( typeof property != "string" ) { callback = property ; property = "__all__" ; } this . _subscribers [ property ] = this . _subscribers [ property ] || [ ] ; if ( this . _subscribers [ property ] . indexOf ( callback ) == - 1 ) { this . _subscribers [ property ] . push ( callback ) ; } } 
function ( property , callback ) { if ( typeof property != "string" ) { callback = property ; property = "__all__" ; } 
function ( property , val ) { if ( val === undefined ) { 
function ( name , cwd ) { this . name = name || this . name ; this . cwd = cwd || this . cwd ; this . queueCmd = new QueueCmd ( ) ; } 
function ( args , option , callback ) { var cmdItem = this . _getCmdItem ( args , option , callback ) ; var cmdStr = CmdUtil . getCmdString ( cmdItem ) ; return this . queueCmd . queue ( cmdStr , cmdItem . option , cmdItem . callback ) ; } 
function f ( prex ) { var templete = '<nav class="' + prex + '-navigation" id="{{ids}}">\n\t<ul class="pagination {{color}}">\n\t\t<li class="first"><a ng-click="previous()" >{{text.first}}</a></li>\n\t\t<li class="previousPage disabled {{showPrevious}}"><a ng-click="previous(showNumber)">{{text.previous}} {{step}}</a></li>\n\t\t<li class="previous {{showPrevious}}"><a ng-click="previous(1)">{{text.previous}}</a></li>\n\t\t<li ng-repeat="val in arr" class="{{shomMe($index)}}"><a ng-href="{{hrefText(val)}}" data-index="{{$index}}">{{val}}</a></li>\n\t\t<li class="next {{showPrevious}}"><a ng-click="next(1)">{{text.next}}</a></li>\n\t\t<li class="nextPage {{showNext}}"><a ng-click="next(step)">{{text.next}} {{step}}</a></li>\n\t\t<li class="last"><a ng-click="next()">{{text.last}}</a></li>\n\t</ul>\n</nav>' ; return { restrict : 'E' , transclude : true , scope : { step : '@step' , max : '@max' , text : '@text' } , link : function link ( scope , elez , attrs , crtl ) { scope . pagination = 0 ; scope . step = 5 ; scope . arr = [ ] ; for ( var i = scope . max . length - 1 ; i >= 0 ; i -- ) { scope . arr . push ( i + 1 ) ; } scope . arr . reverse ( ) ; scope . previous = function ( index ) { if ( angular . isNumber ( index ) ) { scope . pagination -= index ; } else { scope . pagination = 0 ; } } ; scope . next = function ( index ) { if ( angular . isNumber ( index ) ) { scope . pagination += index ; } else { scope . pagination = Number ( attr . max ) - 1 - scope . step ; } } ; scope . showMe = function ( ) { var index = arguments . length <= 0 || arguments [ 0 ] === undefined ? 0 : arguments [ 0 ] ; var max = scope . pagination += scope . step ; if ( index < max && scope . pagination < index ) { return '' ; } else { return 'all-hide' ; } } ; scope . hrefText = function ( ) { var val = arguments . length <= 0 || arguments [ 0 ] === undefined ? 0 : arguments [ 0 ] ; return attr . href . replace ( ':pages' , val ) ; } ; } , templete : templete } ; } 
function rowgroup ( items , name ) { return items . map ( ( [ htmlterm , ariaterm ] , i ) => { htmlcount += htmlterm . split ( ', ' ) . length ariacount += ariaterm . split ( ', ' ) . length return tr ( [ ! i && th ( { rowSpan : items . length , children : name , } ) , td ( htmlterm ) , td ( ariaterm ) ] ) } ) } 
function normalize ( argv ) { var keys = Object . keys ( cli . tasks ) ; keys . forEach ( function ( key ) { if ( argv . hasOwnProperty ( key ) && key !== 'default' ) { argv . _ . push ( key ) ; parse ( argv [ key ] , key , argv ) ; } } ) ; if ( argv . _ . length === 0 ) { argv . _ . push ( 'help' ) ; } return argv ; } 
function encode ( s ) { var pairs = { '&' : '&amp;' , '"' : '&quot;' , '\'' : '&apos;' , '<' : '&lt;' , '>' : '&gt;' } ; for ( var r in pairs ) { if ( typeof s !== 'undefined' ) { s = s . replace ( new RegExp ( r , 'g' ) , pairs [ r ] ) ; } } return s || '' ; } 
function addStats ( database , cb ) { 
function isCommanderLog ( fpath ) { const base = path . basename ( fpath ) ; return base . indexOf ( 'Journal.' ) === 0 && path . extname ( fpath ) === '.log' ; } 
function tail ( array ) { var length = array ? array . length : 0 ; return length ? baseSlice ( array , 1 , length ) : [ ] ; } 
function forEach ( collection , iteratee ) { var func = isArray ( collection ) ? arrayEach : baseEach ; return func ( collection , baseIteratee ( iteratee , 3 ) ) ; } 
function basePick ( object , props ) { object = Object ( object ) ; return basePickBy ( object , props , function ( value , key ) { return key in object ; } ) ; } 
function arrayAggregator ( array , setter , iteratee , accumulator ) { var index = - 1 , length = array ? array . length : 0 ; while ( ++ index < length ) { var value = array [ index ] ; setter ( accumulator , value , iteratee ( value ) , array ) ; } return accumulator ; } 
function isElement ( value ) { return value != null && value . nodeType === 1 && isObjectLike ( value ) && ! isPlainObject ( value ) ; } 
function getChildNodesAsArray ( childNodes ) { const ignoreTrim = ! ( whitespaceRules === 'ignore-trim' ) ; const childNodesArr = [ ] ; let childNodesLength = childNodes . length ; for ( let i = 0 ; i < childNodesLength ; i ++ ) { if ( childNodes [ i ] . nodeType === 3 & ignoreTrim ) { if ( childNodes [ i ] . nodeValue === childNodes [ i ] . nodeValue . replace ( / ^\s+|\s+$ / g , '' ) ) { childNodesArr . push ( createVTree ( childNodes [ i ] , whitespaceRules ) ) ; } } else { childNodesArr . push ( createVTree ( childNodes [ i ] , whitespaceRules ) ) ; } } return childNodesArr ; } 
function createHybrid ( func , bitmask , thisArg , partials , holders , partialsRight , holdersRight , argPos , ary , arity ) { var isAry = bitmask & ARY_FLAG , isBind = bitmask & BIND_FLAG , isBindKey = bitmask & BIND_KEY_FLAG , isCurried = bitmask & ( CURRY_FLAG | CURRY_RIGHT_FLAG ) , isFlip = bitmask & FLIP_FLAG , Ctor = isBindKey ? undefined : createCtor ( func ) ; function wrapper ( ) { var length = arguments . length , args = Array ( length ) , index = length ; while ( index -- ) { args [ index ] = arguments [ index ] ; } if ( isCurried ) { var placeholder = getHolder ( wrapper ) , holdersCount = countHolders ( args , placeholder ) ; } if ( partials ) { args = composeArgs ( args , partials , holders , isCurried ) ; } if ( partialsRight ) { args = composeArgsRight ( args , partialsRight , holdersRight , isCurried ) ; } length -= holdersCount ; if ( isCurried && length < arity ) { var newHolders = replaceHolders ( args , placeholder ) ; return createRecurry ( func , bitmask , createHybrid , wrapper . placeholder , thisArg , args , newHolders , argPos , ary , arity - length ) ; } var thisBinding = isBind ? thisArg : this , fn = isBindKey ? thisBinding [ func ] : func ; length = args . length ; if ( argPos ) { args = reorder ( args , argPos ) ; } else if ( isFlip && length > 1 ) { args . reverse ( ) ; } if ( isAry && ary < length ) { args . length = ary ; } if ( this && this !== root && this instanceof wrapper ) { fn = Ctor || createCtor ( fn ) ; } return fn . apply ( thisBinding , args ) ; } return wrapper ; } 
function baseXor ( arrays , iteratee , comparator ) { var index = - 1 , length = arrays . length ; while ( ++ index < length ) { var result = result ? arrayPush ( baseDifference ( result , arrays [ index ] , iteratee , comparator ) , baseDifference ( arrays [ index ] , result , iteratee , comparator ) ) : arrays [ index ] ; } return ( result && result . length ) ? baseUniq ( result , iteratee , comparator ) : [ ] ; } 
function forIn ( object , iteratee ) { return object == null ? object : baseFor ( object , baseIteratee ( iteratee , 3 ) , keysIn ) ; } 
function baseMean ( array , iteratee ) { var length = array ? array . length : 0 ; return length ? ( baseSum ( array , iteratee ) / length ) : NAN ; } 
function dropRightWhile ( array , predicate ) { return ( array && array . length ) ? baseWhile ( array , baseIteratee ( predicate , 3 ) , true , true ) : [ ] ; } 
function pickBy ( object , predicate ) { return object == null ? { } : basePickBy ( object , getAllKeysIn ( object ) , baseIteratee ( predicate ) ) ; } 
function baseIsTypedArray ( value ) { return isObjectLike$1 ( value ) && isLength ( value . length ) && ! ! typedArrayTags [ objectToString$1 . call ( value ) ] ; } 
function isPrototype ( value ) { var Ctor = value && value . constructor , proto = typeof Ctor == 'function' && Ctor . prototype || objectProto$1 ; return value === proto ; } 
function isPlainObject$1 ( value ) { if ( ! isObjectLike$2 ( value ) || objectToString$2 . call ( value ) != objectTag$2 ) { return false ; } var proto = getPrototype$1 ( value ) ; if ( proto === null ) { return true ; } var Ctor = hasOwnProperty$2 . call ( proto , 'constructor' ) && proto . constructor ; return ( typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2 . call ( Ctor ) == objectCtorString$1 ) ; } 
function spread ( func , start ) { if ( typeof func != 'function' ) { throw new TypeError ( FUNC_ERROR_TEXT ) ; } start = start === undefined ? 0 : nativeMax ( toInteger ( start ) , 0 ) ; return baseRest ( function ( args ) { var array = args [ start ] , otherArgs = castSlice ( args , 0 , start ) ; if ( array ) { arrayPush ( otherArgs , array ) ; } return apply ( func , this , otherArgs ) ; } ) ; } 
function baseUnset ( object , path ) { path = isKey ( path , object ) ? [ path ] : castPath ( path ) ; object = parent ( object , path ) ; var key = toKey ( last ( path ) ) ; return ! ( object != null && hasOwnProperty . call ( object , key ) ) || delete object [ key ] ; } 
function basePullAt ( array , indexes ) { var length = array ? indexes . length : 0 , lastIndex = length - 1 ; while ( length -- ) { var index = indexes [ length ] ; if ( length == lastIndex || index !== previous ) { var previous = index ; if ( isIndex ( index ) ) { splice . call ( array , index , 1 ) ; } else if ( ! isKey ( index , array ) ) { var path = castPath ( index ) , object = parent ( array , path ) ; if ( object != null ) { delete object [ toKey ( last ( path ) ) ] ; } } else { delete array [ toKey ( index ) ] ; } } } return array ; } 
function isError ( value ) { if ( ! isObjectLike ( value ) ) { return false ; } return ( objectToString . call ( value ) == errorTag ) || ( typeof value . message == 'string' && typeof value . name == 'string' ) ; } 
function createWrap ( func , bitmask , thisArg , partials , holders , argPos , ary , arity ) { var isBindKey = bitmask & BIND_KEY_FLAG ; if ( ! isBindKey && typeof func != 'function' ) { throw new TypeError ( FUNC_ERROR_TEXT ) ; } var length = partials ? partials . length : 0 ; if ( ! length ) { bitmask &= ~ ( PARTIAL_FLAG | PARTIAL_RIGHT_FLAG ) ; partials = holders = undefined ; } ary = ary === undefined ? ary : nativeMax ( toInteger ( ary ) , 0 ) ; arity = arity === undefined ? arity : toInteger ( arity ) ; length -= holders ? holders . length : 0 ; if ( bitmask & PARTIAL_RIGHT_FLAG ) { var partialsRight = partials , holdersRight = holders ; partials = holders = undefined ; } var data = isBindKey ? undefined : getData ( func ) ; var newData = [ func , bitmask , thisArg , partials , holders , partialsRight , holdersRight , argPos , ary , arity ] ; if ( data ) { mergeData ( newData , data ) ; } func = newData [ 0 ] ; bitmask = newData [ 1 ] ; thisArg = newData [ 2 ] ; partials = newData [ 3 ] ; holders = newData [ 4 ] ; arity = newData [ 9 ] = newData [ 9 ] == null ? ( isBindKey ? 0 : func . length ) : nativeMax ( newData [ 9 ] - length , 0 ) ; if ( ! arity && bitmask & ( CURRY_FLAG | CURRY_RIGHT_FLAG ) ) { bitmask &= ~ ( CURRY_FLAG | CURRY_RIGHT_FLAG ) ; } if ( ! bitmask || bitmask == BIND_FLAG ) { var result = createBind ( func , bitmask , thisArg ) ; } else if ( bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG ) { result = createCurry ( func , bitmask , arity ) ; } else if ( ( bitmask == PARTIAL_FLAG || bitmask == ( BIND_FLAG | PARTIAL_FLAG ) ) && ! holders . length ) { result = createPartial ( func , bitmask , thisArg , partials ) ; } else { result = createHybrid . apply ( undefined , newData ) ; } var setter = data ? baseSetData : setData ; return setWrapToString ( setter ( result , newData ) , func , bitmask ) ; } 
function uniqBy ( array , iteratee ) { return ( array && array . length ) ? baseUniq ( array , baseIteratee ( iteratee , 2 ) ) : [ ] ; } 
function takeWhile ( array , predicate ) { return ( array && array . length ) ? baseWhile ( array , baseIteratee ( predicate , 3 ) ) : [ ] ; } 
function storeEventTarget ( HTMLElement , eventReference ) { var i = void 0 ; if ( ! eventStore$1 . hasOwnProperty ( eventReference ) ) { eventStore$1 [ eventReference ] = [ HTMLElement ] ; } else { var eventStoreRef = eventStore$1 [ eventReference ] ; if ( ! eventStoreRef . includes ( HTMLElement ) ) { eventStore$1 . push ( HTMLElement ) ; } } } 
function forInRight ( object , iteratee ) { return object == null ? object : baseForRight ( object , baseIteratee ( iteratee , 3 ) , keysIn ) ; } 
function forEachRight ( collection , iteratee ) { var func = isArray ( collection ) ? arrayEachRight : baseEachRight ; return func ( collection , baseIteratee ( iteratee , 3 ) ) ; } 
function basePickBy ( object , props , predicate ) { var index = - 1 , length = props . length , result = { } ; while ( ++ index < length ) { var key = props [ index ] , value = object [ key ] ; if ( predicate ( value , key ) ) { baseAssignValue ( result , key , value ) ; } } return result ; } 
function SelectQuery ( request , context ) { this . request = request ; this . domain = new Domain ( { source : request , context : context } ) ; this . filters = [ ] ; this . matchExpression = '' ; this . noResult = false ; this . parse ( ) ; } 
function Pipeline ( hookNames , options ) { hookNames = hookNames || [ ] ; options = options || { } ; options = _ . merge ( { ui : { logInfoColor : 'blue' , logErrorColor : 'red' } } , options ) ; this . _ui = options . ui ; this . _pipelineHooks = hookNames . reduce ( function ( pipelineHooks , hookName ) { pipelineHooks [ hookName ] = [ ] ; return pipelineHooks ; } , { didFail : [ ] } ) ; this . logInfo = chalk [ this . _ui . logInfoColor ] ; this . logError = chalk [ this . _ui . logErrorColor ] ; this . _progressBarLib = options . progressBarLib || require ( 'react-deploy-progress' ) ; } 
function getOptions ( opts , cb ) { var options = clonedeep ( opts || { } ) ; 
function render ( opts , cb , errorCb ) { var options = getOptions ( opts , cb ) ; importReplacer ( options , false ) . then ( cb , errorCb ) ; } 
function ( fieldName ) { var field ; if ( this . domain && fieldName ) { field = this . domain . getIndexField ( fieldName ) ; if ( ! field . exists ( ) ) { this . throwValidationError ( 'CS-UnknownFieldInMatchExpression' , 'Field \'' + fieldName + '\' is not defined in the metadata for this ' + 'collection. All fields used in the match expression must be ' + 'defined in the metadata.' ) ; } else if ( ! field . searchEnabled ) { this . available = false ; } } if ( ! field ) field = new IndexField ( fieldName ) . setType ( "text" ) ; return field ; } 
function formatTable ( table , links , notes ) { var widths = [ ] ; var rows = table . map ( function ( row ) { var cells = row . map ( function ( cell ) { return formatSpans ( cell , links , notes ) ; } ) ; cells . forEach ( function ( cell , index ) { widths [ index ] = Math . max ( cell . length , widths [ index ] || 5 ) ; widths [ index ] = Math . min ( widths [ index ] , 50 ) ; } ) ; return cells . join ( ' & ' ) ; } ) ; var totalWidth = widths . reduce ( function sum ( val , width ) { return val + width ; } , 0 ) ; totalWidth = Math . max ( totalWidth , 100 ) ; widths = widths . map ( function ( width ) { var relativeWidth = width / totalWidth ; return 'p{' + relativeWidth + '\\textwidth}' ; } ) . join ( ' | ' ) ; var str = '\\begin{longtable}{ | ' + widths + ' |}\n' + '\\hline\n' + rows . join ( ' \\\\\n\\hline\n' ) + ' \\\\\n' + '\\hline\n' + '\\end{longtable}' ; return str ; } 
function ( plugins , config ) { var self = this ; var aliasMap = Object . keys ( plugins ) . reduce ( function ( aliases , pluginName ) { if ( ! aliases [ pluginName ] || ! aliases [ pluginName ] . as ) { aliases [ pluginName ] = { as : [ pluginName ] } ; } aliases [ pluginName ] . as = self . _castArray ( aliases [ pluginName ] . as ) ; return aliases ; } , config ) ; var unknownConfigKeys = _ . difference ( Object . keys ( aliasMap ) , Object . keys ( plugins ) ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.alias' ) ; } return aliasMap ; } 
function ( aliasMap , config ) { var aliases = this . _flattenAliasMap ( aliasMap ) ; var allExcept = null ; if ( typeof config . allExcept !== 'undefined' ) { allExcept = this . _castArray ( config . allExcept ) ; delete config . allExcept ; } var keys = Object . keys ( config ) ; if ( allExcept ) { keys = keys . concat ( allExcept ) ; } var unknownConfigKeys = _ . difference ( keys , aliases ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.disabled' ) ; } var disabledMap = aliases . reduce ( function ( map , alias ) { if ( map [ alias ] === undefined ) { if ( allExcept && allExcept . length ) { if ( allExcept . indexOf ( alias ) >= 0 ) { map [ alias ] = false ; } else { map [ alias ] = true ; } } else { map [ alias ] = false ; } } return map ; } , config ) ; return disabledMap ; } 
function ( config , aliasMap , pluginInstances ) { var self = this ; pluginInstances . forEach ( function ( instance ) { if ( instance . runBefore ) { var befores = self . _castArray ( instance . runBefore ) ; config = self . _mergeAuthorProvidedOrderWithConfigOrder ( 'before' , instance . name , befores , config , aliasMap ) ; } if ( instance . runAfter ) { var afters = self . _castArray ( instance . runAfter ) ; config = self . _mergeAuthorProvidedOrderWithConfigOrder ( 'after' , instance . name , afters , config , aliasMap ) ; } } ) ; var aliases = this . _flattenAliasMap ( aliasMap ) ; var configNames = Object . keys ( config ) . reduce ( function ( arr , key ) { arr . push ( key ) ; var befores = self . _castArray ( config [ key ] . before ) ; var afters = self . _castArray ( config [ key ] . after ) ; return arr . concat ( befores ) . concat ( afters ) ; } , [ ] ) . reduce ( function ( arr , key ) { if ( arr . indexOf ( key ) === - 1 ) { arr . push ( key ) ; } return arr ; } , [ ] ) ; var unknownConfigKeys = _ . difference ( configNames , aliases ) ; if ( unknownConfigKeys . length ) { this . _logUnknownPlugins ( unknownConfigKeys , 'config.pipeline.runOrder' ) ; } return config ; } 
function uploadLocalFile ( ) { localFileCursor += 1 setImmediate ( checkDoMoreWork ) let fullPath = path . join ( localDir , localFileStat . path ) 
function ( options , params ) { 
function ( options , params ) { 
function exportCubeMixin ( cubeDef ) { var app = this ; var task = new Task ( ) ; promise ( ) . then ( function ( ) { 
function createListBoxMixin ( { id , field } ) { return this . createObject ( { qInfo : { qType : 'ListObject' } , qListObjectDef : { qStateName : '$' , qLibraryId : undef . if ( id , '' ) , qDef : { qFieldDefs : undef . if ( field , [ field ] , [ ] ) } , qInitialDataFetch : [ { qTop : 0 , qLeft : 0 , qHeight : 5 , qWidth : 1 } ] } } ) . then ( ( object ) => { return object . getLayout ( ) ; } ) } 
function exportMixin ( dimensions , measures , filters ) { var app = this ; var task = new Task ( ) ; promise ( ) . then ( function ( ) { 
function odagMixin ( options , params ) { var qrsApi = qrs ( options ) ; var global = this ; var task = new Task ( ) ; var templateApp = params . templateApp ; if ( typeof templateApp == 'undefined' ) { return promise . reject ( 'Please provide the templateApp parameter' ) ; } var maxParDup = undef . if ( params . maxParDup , 1 ) ; 
function grayInverse ( g ) { 
function grayTransform ( entry , direction , x , dim ) { 
function directionSequence ( i , dim ) { 
function curvePrecision ( index , dim ) { dim index xyz axis m bits 1 0-7 0<=x<2 2 3 2 0-63 2<=x<4 3 6 3 0-511 4<=x<8 4 9 4 4095 8<=x<16 5 12 5 32767 16<=x<32 6 15 6 262,144 32<=x<64 7 18 7 2,097,151 64<=x<128 8 21 8 16,777,215 128<=x<256 9 24 9 134,217,727 254<=x<512 10 27 10 1,073,741,823 512<=x<1024 11 30 */ var n = Math . pow ( 2 , dim ) var bits = 32 while ( bits % dim != 0 ) -- bits for ( var i = 1 ; i < bits ; i ++ ) { if ( index < Math . pow ( n , i ) ) return i + 1 } } 
function nthRoot ( num , nArg , precArg ) { 
function hilbertIndex ( point , options ) { 
function hilbertIndexInverse ( dim , index , options ) { 
function normalizeSuffixes ( suffixes ) { return typeof suffixes === 'string' ? suffixes . split ( ',' ) : ( Array . isArray ( suffixes ) ? suffixes : null ) ; } 
function expand ( patterns , suffixes ) { var globs = [ ] , nonGlobs = [ ] ; 
function ( filePath ) { return grunt . file . isFile ( filePath ) && ( ! suffixesDefined || hasSuffix ( suffixes , filePath . toLowerCase ( ) ) ) ; } 
function specFilter ( pattern , files ) { var specPattern , patternArray , filteredArray = [ ] , scriptSpecs = [ ] , matchPath = function ( path ) { return Boolean ( path . match ( specPattern ) ) ; } ; if ( pattern ) { 
function getConsoleReporterOpts ( opts ) { opts = opts || { } ; opts . print = function ( ) { grunt . log . write . apply ( this , arguments ) ; } ; 
function _taskFatalHandler_ ( e ) { var err = e ? ( e . stack || e . message || e ) : 'Unknown Error' ; grunt . fatal ( err , grunt . fail . code . TASK_FAILURE ) ; } 
function JasmineRunner ( options ) { options = options || { } ; this . jasmine = jasmineCore . boot ( jasmineCore ) ; this . env = this . jasmine . getEnv ( ) ; this . env . throwOnExpectationFailure ( Boolean ( options . stopOnFailure ) ) ; this . env . randomizeTests ( Boolean ( options . random ) ) ; this . env . seed ( Boolean ( options . seed ) ) ; if ( typeof options . defaultTimeout === 'number' && options . defaultTimeout >= 0 ) { this . jasmine . DEFAULT_TIMEOUT_INTERVAL = options . defaultTimeout ; } this . _reporters = [ ] ; } 
function ( options , cb ) { 
function pluckDeepWithSelectors ( coll , selectors ) { 
function ( payload , callback ) { var args = { } , argsKeys = [ 'location' , 'page' , 'title' ] ; argsKeys . forEach ( function consumer ( prop ) { if ( payload . hasOwnProperty ( prop ) ) { args [ prop ] = payload [ prop ] ; } } ) ; args . hitCallback = callback ; 
function ( payload , callback ) { var i13nNode = payload . i13nNode ; if ( i13nNode ) { var model = i13nNode . getMergedModel ( ) ; var hitType = 'event' ; var params = { hitType : hitType , eventCategory : model . category || DEFAULT_CATEGORY , eventAction : model . action || DEFAULT_ACTION , eventLabel : model . label || i13nNode . getText ( payload . target ) || DEFAULT_LABEL , eventValue : model . value || DEFAULT_VALUE , transport : model . transport || DEFAULT_TRANSPORT , nonInteraction : model . nonInteraction || DEFAULT_NON_INTERACTION , hitCallback : callback } ; _command . call ( this , { tracker : model . tracker || '' , commandName : 'send' , arguments : [ hitType , params ] } ) ; } else { callback && callback ( ) ; } } 
function createCurve ( amount ) { var curve = new Float32Array ( WS_CURVE_SIZE ) ; var k = 2 * amount / ( 1 - amount ) ; var x ; for ( var i = 0 ; i < WS_CURVE_SIZE ; i ++ ) { x = i * 2 / WS_CURVE_SIZE - 1 ; curve [ i ] = ( 1 + k ) * x / ( 1 + k * Math . abs ( x ) ) ; } return curve ; } 
function pageRange ( selected , numPages , num ) { let selectedPos = Math . ceil ( num / 2 ) ; let start = ( selected < selectedPos ) ? 1 : selected - selectedPos + 1 ; let len = ( numPages < start + num - 1 ) ? numPages - start + 1 : num ; return Array . apply ( null , Array ( len ) ) . map ( ( u , i ) => start + i ) ; } 
function getAllPropertyNames ( obj ) { var props = [ ] ; do { Object . getOwnPropertyNames ( obj ) . forEach ( function ( prop ) { if ( props . indexOf ( prop ) === - 1 ) { props . push ( prop ) ; } } ) ; } while ( obj = Object . getPrototypeOf ( obj ) ) ; return props ; } 
function showTasks ( tasks ) { const taskList = Object . keys ( tasks ) ; if ( taskList . length ) { taskList . forEach ( ( task ) => { process . stdout . write ( ` ${ task } ` ) ; if ( tasks [ task ] . description ) { process . stdout . write ( ` ${ tasks [ task ] . description } ` ) ; } process . stdout . write ( '\n' ) ; } ) ; } else { process . stdout . write ( 'No tasks available.\n' ) ; } } 
function getMatchRoute ( path ) { var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = routes [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var route = _step . value ; if ( route . url === path ) { return route ; } } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } return false ; } 
function runner ( done , errorShouldExit ) { core . utils . sh ( config . cmd , errorShouldExit , ( err ) => { if ( config . triggerBrowserReloadAfter ) { core . events . emit ( 'reload' ) ; 
function build ( done , errorShouldExit , watchTask ) { const cd = config . cwd ? ` ${ config . cwd } ` : '' ; core . utils . sh ( ` ${ cd } ${ config . commandPrefix } ${ watchTask ? ' --watch' : '' } ` , errorShouldExit , ( err ) => { done ( err ) ; } ) ; } 
function sh ( cmd , exitOnError , cb ) { const child = exec ( cmd , { encoding : 'utf8' , timeout : 1000 * 60 * 2 , 
function readYamlFile ( file , cb ) { fs . readFile ( file , 'utf8' , ( err , data ) => { if ( err ) throw err ; cb ( yaml . safeLoad ( data ) ) ; } ) ; } 
function writeYamlFile ( file , data , cb ) { fs . writeFile ( file , yaml . safeDump ( data ) , ( ) => { if ( cb ) cb ( ) ; } ) ; } 
function buildScript ( file , dest ) { var bundler = browserify ( { entries : [ file ] , cache : { } , packageCache : { } } , watchify . args ) , srcFile = file . substring ( file . lastIndexOf ( '/' ) + 1 ) ; if ( environment !== 'production' ) { bundler = watchify ( bundler ) ; bundler . on ( 'update' , function ( ) { rebundle ( ) ; } ) ; } function rebundle ( ) { gutil . log ( 'Running rebundle' ) ; return bundler . bundle ( ) . on ( 'error' , gutil . log . bind ( gutil , 'Browserify Error' ) ) . pipe ( source ( srcFile ) ) . pipe ( buffer ( ) ) . pipe ( productionOnly ( uglify ) ) . pipe ( gulp . dest ( dest ) ) . pipe ( developmentOnly ( browserSync . reload , { stream : true } ) ) ; } return rebundle ( ) ; } 
function middleware ( file , options ) { var matcher = new RegExp ( "\\.(?:" + middleware . extensions . join ( "|" ) + ")$" ) if ( ! matcher . test ( file ) ) return through ( ) ; var input = '' ; var write = function ( buffer ) { input += buffer ; } var end = function ( ) { this . queue ( createModule ( input , options ) ) ; this . queue ( null ) ; } return through ( write , end ) ; } 
function createModule ( body , options ) { body = middleware . sanitize ( body ) if ( String ( options . parameterize ) !== 'false' ) { body = middleware . parameterise ( body ) } if ( options . module === "es6" || options . module === "es2015" ) { var module = 'export default ' + body + ';\n' ; } else { var module = 'module.exports = ' + body + ';\n' ; } return module } 
function ( schema , definition ) { return _ . reduce ( schema , function ( memo , field ) { // console.log('definition normalize');console.log(definition); // Marshal mysql DESCRIBE to waterline collection semantics var attrName = field . COLUMN_NAME . toLowerCase ( ) ; Object . keys ( definition ) . forEach ( function ( key ) { if ( attrName === key . toLowerCase ( ) ) attrName = key ; } ) ; var type = field . DATA_TYPE ; // Remove (n) column-size indicators type = type . replace ( / \([0-9]+\)$ / , '' ) ; memo [ attrName ] = { type : type // defaultsTo: '', //autoIncrement: field.Extra === 'auto_increment' } ; if ( field . primaryKey ) { memo [ attrName ] . primaryKey = field . primaryKey ; } if ( field . unique ) { memo [ attrName ] . unique = field . unique ; } if ( field . indexed ) { memo [ attrName ] . indexed = field . indexed ; } return memo ; } , { } ) ; } 
function ( collectionName , values , key ) { return sql . build ( collectionName , values , sql . prepareValue , ', ' , key ) ; } 
function ( collectionName , where , key , parentKey ) { return sql . build ( collectionName , where , sql . predicate , ' AND ' , undefined , parentKey ) ; } 
function ( collectionName , criterion , key , parentKey ) { var queryPart = '' ; if ( parentKey ) { return sql . prepareCriterion ( collectionName , criterion , key , parentKey ) ; } // OR if ( key . toLowerCase ( ) === 'or' ) { queryPart = sql . build ( collectionName , criterion , sql . where , ' OR ' ) ; return ' ( ' + queryPart + ' ) ' ; } // AND else if ( key . toLowerCase ( ) === 'and' ) { queryPart = sql . build ( collectionName , criterion , sql . where , ' AND ' ) ; return ' ( ' + queryPart + ' ) ' ; } // IN else if ( _ . isArray ( criterion ) ) { queryPart = sql . prepareAttribute ( collectionName , null , key ) + " IN (" + sql . values ( collectionName , criterion , key ) + ")" ; return queryPart ; } // LIKE else if ( key . toLowerCase ( ) === 'like' ) { return sql . build ( collectionName , criterion , function ( collectionName , value , attrName ) { var attrStr = sql . prepareAttribute ( collectionName , value , attrName ) ; attrStr = attrStr . replace ( / ' / g , '"' ) ; // TODO: Handle regexp criterias if ( _ . isRegExp ( value ) ) { throw new Error ( 'RegExp LIKE criterias not supported by the MySQLAdapter yet. Please contribute @ http://github.com/balderdashy/sails-mysql' ) ; } var valueStr = sql . prepareValue ( collectionName , value , attrName ) ; // Handle escaped percent (%) signs [encoded as %%%] valueStr = valueStr . replace ( / %%% / g , '\\%' ) ; var condition = ( attrStr + " LIKE " + valueStr ) ; //condition = condition.replace(/'/g, '"'); return condition ; } , ' AND ' ) ; } // NOT else if ( key . toLowerCase ( ) === 'not' ) { throw new Error ( 'NOT not supported yet!' ) ; } // Basic criteria item else { return sql . prepareCriterion ( collectionName , criterion , key ) ; } } 
function ( collectionName , collection , fn , separator , keyOverride , parentKey ) { separator = separator || ', ' ; var $sql = '' ; _ . each ( collection , function ( value , key ) { $sql += fn ( collectionName , value , keyOverride || key , parentKey ) ; // (always append separator) $sql += separator ; } ) ; // (then remove final one) return _ . str . rtrim ( $sql , separator ) ; } 
function sqlTypeCast ( type , attrName ) { type = type && type . toLowerCase ( ) ; switch ( type ) { case 'string' : return 'VARCHAR2(255)' ; case 'text' : case 'array' : case 'json' : return 'VARCHAR2(255)' ; case 'boolean' : return 'NUMBER(1) CHECK("' + attrName + '" IN (0,1))' ; case 'int' : case 'integer' : return 'NUMBER' ; case 'float' : case 'double' : return 'FLOAT' ; case 'date' : return 'DATE' ; case 'datetime' : return 'TIMESTAMP' ; case 'binary' : return 'BLOB' ; default : console . error ( "Unregistered type given: " + type ) ; return "TEXT" ; } } 
function validSubAttrCriteria ( c ) { return _ . isObject ( c ) && ( ! _ . isUndefined ( c . not ) || ! _ . isUndefined ( c . greaterThan ) || ! _ . isUndefined ( c . lessThan ) || ! _ . isUndefined ( c . greaterThanOrEqual ) || ! _ . isUndefined ( c . lessThanOrEqual ) || ! _ . isUndefined ( c [ '<' ] ) || ! _ . isUndefined ( c [ '<=' ] ) || ! _ . isUndefined ( c [ '!' ] ) || ! _ . isUndefined ( c [ '>' ] ) || ! _ . isUndefined ( c [ '>=' ] ) || ! _ . isUndefined ( c . startsWith ) || ! _ . isUndefined ( c . endsWith ) || ! _ . isUndefined ( c . contains ) || ! _ . isUndefined ( c . like ) ) ; } 
function processIconTemplate ( srcFile , destFile , data , cb ) { fs . readFile ( srcFile , 'utf8' , ( err , srcFileContents ) => { if ( err ) throw err ; const result = template ( srcFileContents , { 
function icons ( done ) { const stream = gulp . src ( config . src ) . pipe ( iconfont ( { fontName : config . iconName , appendUniconde : true , formats : config . formats , timestamp : config . useTimestamp ? getTimestamp ( ) : 0 , autohint : config . autohint , normalize : config . normalize , } ) ) ; 
function isSafeMethod ( method , safeMethods ) { method = method . toUpperCase ( ) ; return ( safeMethods || SAFE_METHODS ) . some ( function ( safeMethod ) { return method . toUpperCase ( ) === safeMethod ; } ) ; } 
function injectData ( tokenValue , options , key ) { var data ; if ( ~ options . contentType . indexOf ( 'application/json' ) ) { data = options . data ? JSON . parse ( options . data ) : { } ; data [ key ] = tokenValue ; options . data = JSON . stringify ( data ) ; } else { options . data += options . data ? '&' : '' ; options . data += key + '=' + tokenValue ; } } 
function injectQuery ( tokenValue , options , param ) { options . url += ~ options . url . indexOf ( '?' ) ? '&' : '?' ; options . url += param + '=' + tokenValue ; } 
function homedir ( username ) { return username ? path . resolve ( path . dirname ( home ) , username ) : home ; } 
function ( connection , collections , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN registerConnection" ) ; } 
function ( conn , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN tearDown" ) ; } if ( typeof conn == 'function' ) { cb = conn ; conn = null ; } if ( ! conn ) { connections = { } ; return cb ( ) ; } if ( ! connections [ conn ] ) return cb ( ) ; delete connections [ conn ] ; cb ( ) ; } 
function ( connectionName , table , query , data , cb ) { var connectionObject = connections [ connectionName ] ; if ( LOG_DEBUG ) { console . log ( "BEGIN query" ) ; } if ( _ . isFunction ( data ) ) { cb = data ; data = null ; } 
function ( connectionName , table , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN describe" ) ; } var connectionObject = connections [ connectionName ] ; var collection = connectionObject . collections [ table ] ; if ( ! collection ) { return cb ( util . format ( 'Unknown collection `%s` in connection `%s`' , collectionName , connectionName ) ) ; } var queries = [ ] ; queries [ 0 ] = "SELECT COLUMN_NAME, DATA_TYPE, NULLABLE FROM USER_TAB_COLUMNS WHERE TABLE_NAME = '" + table + "'" ; queries [ 1 ] = "SELECT index_name,COLUMN_NAME FROM user_ind_columns WHERE table_name = '" + table + "'" ; queries [ 2 ] = "SELECT cols.table_name, cols.column_name, cols.position, cons.status, cons.owner " + "FROM all_constraints cons, all_cons_columns cols WHERE cols.table_name = '" + table + "' AND cons.constraint_type = 'P' AND cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner " + "ORDER BY cols.table_name, cols.position" ; 
function dropTable ( item , next ) { 
function ( connectionName , table , attrName , attrDef , cb ) { var connectionObject = connections [ connectionName ] ; if ( LOG_DEBUG ) { console . log ( "BEGIN addAttribute" ) ; } 
function ( collectionName , criteria , _cb ) { return adapter . find ( connectionName , collectionName , criteria , _cb , pool ) ; } 
function ( connectionName , table , options , cb ) { if ( LOG_DEBUG ) { console . log ( 'BEGIN find' ) ; } 
function ( connectionName , table , data , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN create" ) ; } var connectionObject = connections [ connectionName ] ; var collection = connectionObject . collections [ table ] ; var schemaName = collection . meta && collection . meta . schemaName ? utils . escapeName ( collection . meta . schemaName ) + '.' : '' ; var tableName = schemaName + utils . escapeName ( table ) ; 
function ( connectionName , table , options , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN count" ) ; } 
function ( connectionName , table , options , data , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN update" ) ; } 
function ( connectionName , table , options , cb ) { if ( LOG_DEBUG ) { console . log ( "BEGIN destroy" ) ; } var connectionObject = connections [ connectionName ] ; var collection = connectionObject . collections [ table ] ; var _schema = connectionObject . schema ; 
function _getPK ( connectionName , collectionName ) { var collectionDefinition ; try { collectionDefinition = connections [ connectionName ] . collections [ collectionName ] . definition ; var pk ; pk = _ . find ( Object . keys ( collectionDefinition ) , function _findPK ( key ) { var attrDef = collectionDefinition [ key ] ; if ( attrDef && attrDef . primaryKey ) return key ; else return false ; } ) ; if ( ! pk ) pk = 'id' ; return pk ; } catch ( e ) { throw new Error ( 'Unable to determine primary key for collection `' + collectionName + '` because ' + 'an error was encountered acquiring the collection definition:\n' + require ( 'util' ) . inspect ( e , false , null ) ) ; } } 
function plBuild ( done , errorShouldExit ) { core . events . emit ( 'pattern-lab:precompile' ) ; 
function getTwigNamespaceConfig ( workingDir ) { workingDir = workingDir || process . cwd ( ) ; 
function isReleaseFinished ( ) : boolean { const currentBranch = exec ( 'git rev-parse --abbrev-ref HEAD' , { silent : true } ) . stdout . trim ( ) return process . env . CIRCLECI && process . env . CIRCLE_BRANCH != currentBranch } 
function printError ( message ) { arrayify ( message ) . forEach ( function ( msg ) { console . error ( ansi . format ( msg , 'red' ) ) } ) } 
function printOutput ( message ) { process . stdout . on ( 'error' , err => { if ( err . code === 'EPIPE' ) { } } ) arrayify ( message ) . forEach ( function ( msg ) { console . log ( ansi . format ( msg ) ) } ) } 
function halt ( err , options ) { options = Object . assign ( { exitCode : 1 } , options ) if ( err ) { if ( err . code === 'EPIPE' ) { process . exit ( 0 ) } else { const t = require ( 'typical' ) printError ( t . isString ( err ) ? err : options . stack ? err . stack : err . message , options ) } } process . exit ( options . exitCode ) } 
function getCli ( definitions , usageSections , argv ) { const commandLineArgs = require ( 'command-line-args' ) const commandLineUsage = require ( 'command-line-usage' ) const usage = usageSections ? commandLineUsage ( usageSections ) : '' const options = commandLineArgs ( definitions , argv ) return { options , usage } } 
function CompositeError ( message , innerErrors ) { this . message = message ; this . name = 'CompositeError' ; this . innerErrors = normalizeInnerErrors ( innerErrors ) ; Error . captureStackTrace ( this , this . constructor ) ; this . originalStackDescriptor = Object . getOwnPropertyDescriptor ( this , 'stack' ) ; 
function getBmpBin ( ) : string { const cwd = new WorkingDirectory ( ) . resolve ( ) if ( fs . existsSync ( cwd + '/.yangpao.toml' ) ) { return which ( 'yangpao' ) } if ( fs . existsSync ( cwd + '/.bmp.yml' ) ) { return which ( 'bmp' ) } } 
function handleRequest ( req , res ) { var self = this ; var config = self . app . config ; 
function isRequired ( _ref ) { var validate = _ref . validate , required = _ref . required ; return required || validate && validate . some ( function ( item ) { return item . trigger !== "submit" && item . required ; } ) ; } 
function sliceData ( data , page , length ) { return data . slice ( ( page - 1 ) * length , page * length ) ; } 
function getMatchData ( value , matchCase , data , strict ) { var output = [ ] ; value = matchCase ? value : ( '' + value ) . toLowerCase ( ) ; for ( var i = 0 ; i < data . length ; i ++ ) { var item = data [ i ] ; var label = matchCase ? item . label : ( '' + item . label ) . toLowerCase ( ) ; if ( ! strict && ~ label . indexOf ( value ) ) { output . push ( ( 0 , _util . extend ) ( { } , item ) ) ; } else if ( strict && label === value ) { output . push ( ( 0 , _util . extend ) ( { } , item ) ) ; } } return output ; } 
function killPosix ( ) { getDescendentProcessInfo ( this . pid , ( err , descendent ) => { if ( err ) { return } descendent . forEach ( ( { PID : pid } ) => { try { process . kill ( pid ) } catch ( _err ) { 
function o ( obj ) { obj . source = { text : text ( ) , line : line ( ) , column : column ( ) } return obj ; } 
function TreeWalker ( ast , recv ) { var self = this ; this . ast = ast ; this . recv = recv ; this . stack = [ { traverse : ast , parent : undefined , name : undefined } , { fun : function ( ) { if ( self . hasProp ( self . recv , 'finished' ) && Function === self . recv . finished . constructor ) { return self . recv . finished ( ) ; } } } ] ; this . current = undefined ; } 
function _shellEscape ( params , options = { } ) { let escaped = [ __shellEscape ( params , options ) ] let flattened = _ . flattenDeep ( escaped ) return flattened . join ( ' ' ) } 
function __shellEscape ( params , options ) { if ( params instanceof Escaped ) { return params . value } else if ( Array . isArray ( params ) ) { return params . map ( param => __shellEscape ( param , options ) ) } else if ( params == null ) { return [ ] } else { return options . verbatim ? String ( params ) : shellEscape ( String ( params ) ) } } 
function shell ( strings , ... params ) { let result = '' for ( let [ string , param ] of _ . zip ( strings , params ) ) { result += string + _shellEscape ( param ) } return result } 
function ( ) { self . log ( "enumerate" ) ; var result = [ ] , keys , i , name , desc ; stm . recordRead ( self ) ; keys = handler . getPropertyNames ( ) ; for ( i = 0 ; i < keys . length ; i += 1 ) { name = keys [ i ] ; desc = handler . getPropertyDescriptor ( name ) ; if ( undefined !== desc && desc . enumerable ) { result . push ( name ) ; } } return result ; } 
function ( obj , meta ) { var val , parentId ; if ( undefined === obj || util . isPrimitive ( obj ) ) { return { proxied : obj , raw : obj } ; } val = this . proxiedToTVar . get ( obj ) ; if ( undefined === val ) { val = this . objToTVar . get ( obj ) ; if ( undefined === val ) { this . tVarCount += 1 ; val = new TVar ( this . tVarCount , obj , this ) ; this . proxiedToTVar . set ( val . proxied , val ) ; this . objToTVar . set ( obj , val ) ; this . idToTVar [ val . id ] = val ; this . recordCreation ( val , meta ) ; return val ; } else { 
function ContractFactory ( config ) { _classCallCheck ( this , ContractFactory ) ; this . _config = config ; this . _web3 = config . web3 ; this . _account = config . account ; this . _gas = config . gas ; } 
function Contract ( config ) { _classCallCheck ( this , Contract ) ; this . _config = config ; this . _web3 = config . web3 ; this . _bytecode = config . contract . bytecode ; this . _interface = JSON . parse ( config . contract . interface ) ; this . _contract = this . _web3 . eth . contract ( this . _interface ) ; this . _account = config . account ; this . _gas = config . gas ; this . _logger = DUMMY_LOGGER ; } 
function ContractInstance ( config ) { _classCallCheck ( this , ContractInstance ) ; this . _config = config ; this . _contract = config . contract ; this . _web3 = this . _contract . _web3 ; this . _address = config . address ; this . _inst = this . contract . _contract . at ( this . _address ) ; this . _logger = { } ; for ( var logMethod in DUMMY_LOGGER ) { this . _logger [ logMethod ] = function ( logMethod , self ) { return function ( ) { self . contract . logger [ logMethod ] . apply ( self . contract . logger , [ '[' + self . address + ']: ' ] . concat ( Array . from ( arguments ) ) ) ; } ; } ( logMethod , this ) ; } } 
function Transaction ( config ) { _classCallCheck ( this , Transaction ) ; this . _web3 = config . parent . _web3 ; this . _logger = config . parent . _logger ; this . _hash = config . hash ; } 
function getValidRegex ( pattern ) { var escaped = ( 0 , _escapeRegexp2 . default ) ( pattern ) ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = filters [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var data = _step . value ; var rxp = new RegExp ( "\\\\\\[" + data [ 0 ] + "\\\\:[A-Za-z]{0,}?\\\\]" , "g" ) ; if ( rxp . exec ( escaped ) ) { escaped = escaped . replace ( rxp , data [ 1 ] ) ; } } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } return new RegExp ( "^" + escaped + "$" , "g" ) ; } 
function getNamedProps ( pattern ) { var regex = / \[(\w+):(\w+)?] / g ; var props = [ ] ; var i = 0 ; pattern . replace ( regex , function ( ) { props . push ( ( arguments . length <= 2 ? undefined : arguments [ 2 ] ) || i ++ ) ; return "" ; } ) ; return props ; } 
function spawnCommandWithKill ( ... args ) { const child = spawnCommand ( ... args ) child . kill = kill . bind ( child ) return child } 
function applyFormat ( method , args , string ) { 
function accessObject ( obj , string ) { var m , pos = 0 ; while ( ( m = string . substring ( pos ) . match ( accessExp ) ) ) { 
function FormatError ( func , msg , value ) { this . name = 'FormatError' ; this . message = new Formatter ( ) ( msg , value ) ; if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , func ) ; } } 
function chooseDataSource ( dataSource ) { if ( dataSource === 'json' ) { return function ( file ) { return JSON . parse ( file . contents . toString ( ) ) ; } ; } else if ( dataSource === 'vinyl' ) { return function ( file ) { file [ bodyAttribute ] = file . contents . toString ( ) ; return file ; } ; } else if ( dataSource === 'data' ) { return function ( file ) { var data = file . data ; data [ bodyAttribute ] = file . contents . toString ( ) ; return data ; } ; } else if ( typeof dataSource === 'function' ) { return dataSource ; } else { throw pluginError ( 'Unknown dataSource' ) ; } } 
function templatesFromStream ( templateStream ) { var firstTemplate = null ; templateStream . on ( 'data' , function ( file ) { var relpath = file . relative ; var deferred ; if ( registry . hasOwnProperty ( relpath ) ) { deferred = registry [ relpath ] ; } else { deferred = registry [ relpath ] = new Deferred ( ) ; } try { if ( ! file . isBuffer ( ) ) { throw pluginError ( 'Template source must be buffer' ) ; } var template = compile ( { data : file . contents . toString ( ) , name : file . path , path : file . path } ) ; deferred . resolve ( template ) ; if ( firstTemplate === null ) { firstTemplate = template ; } else { firstTemplate = false ; theOnlyTemplate . reject ( pluginError ( 'Multiple templates given, must select one' ) ) ; } } catch ( err ) { deferred . reject ( err ) ; } } ) . on ( 'end' , function ( ) { if ( firstTemplate ) theOnlyTemplate . resolve ( firstTemplate ) ; else theOnlyTemplate . reject ( pluginError ( 'No templates in template stream' ) ) ; noMoreTemplates ( ) ; } ) . on ( 'error' , function ( err ) { templateStreamError = err ; noMoreTemplates ( ) ; } ) ; } 
function noMoreTemplates ( ) { registryComplete = true ; 
function templateFromFile ( path ) { 
function processFile ( file , cb ) { var data = dataSource ( file ) ; return pickTemplate ( forcedTemplateName || getTemplateName ( data ) || defaultTemplateName ) . then ( function ( template ) { file . path = replaceExt ( file . path , '.html' ) ; data . _file = file ; data . _target = { path : file . path , relative : replaceExt ( file . relative , '.html' ) , } ; 
function pickTemplate ( templateName ) { if ( templateName === THE_ONLY_TEMPLATE ) return theOnlyTemplate . promise ; if ( registry . hasOwnProperty ( templateName ) ) return registry [ templateName ] . promise ; if ( registryComplete ) throw noSuchTemplate ( templateName ) ; return ( registry [ templateName ] = new Deferred ( ) ) . promise ; } 
function getTemplateName ( data ) { for ( var i = 0 ; i < templateAttribute . length ; ++ i ) { if ( ! data ) return null ; data = data [ templateAttribute [ i ] ] ; } return data ; } 
function escapeshellarg ( arg ) { 
function tableDataSort ( key , data , direction ) { var dataCopy = data . map ( function ( i ) { return Object . assign ( { } , i ) ; } ) ; dataCopy . sort ( function ( a , b ) { var sortResult ; var aTmp = a [ key ] ; var bTmp = b [ key ] ; if ( typeof aTmp === 'number' && typeof bTmp === 'number' ) { sortResult = sort ( aTmp , bTmp ) ; } else { sortResult = sort ( ( aTmp + '' ) . toLowerCase ( ) , ( bTmp + '' ) . toLowerCase ( ) ) ; } return sortResult * direction ; } ) ; return dataCopy ; } 
function mod ( x , by ) { return ( x > 0 ) ? x % by : ( by - ( Math . abs ( x ) % by ) ) % by } 
function changeGroup ( num ) { if ( num === curGroup ) return console . log ( 'switching groups to' , num ) groups [ curGroup ] . forEach ( function ( window ) { X . UnmapWindow ( { window : window } ) } ) curGroup = num groups [ curGroup ] . forEach ( function ( window ) { X . MapWindow ( { window : window } ) } ) sizeWindows ( ) } 
function label ( ) { var self = this ; return this . execute ( function ( ) { var id = this . getAttribute ( 'id' ) ; var label = document . querySelector ( 'label[for="' + id + '"]' ) || closestLabel ( this ) ; return label ? label . textContent . trim ( ) : null ; } ) . then ( function ( text ) { if ( text === null ) { throw new Error ( self . toString ( ) + ' does not have a label' ) ; } return text ; } ) ; } 
function ( _this , count , asUTC ) { if ( _this instanceof Date ) { var date = $_NAME ( _this , count , asUTC ) return _this . setTime ( + date ) } throw new TypeError ( 'Method Date.prototype.add' + ( asUTC ? 'UTC' : '' ) + 'Months called on incompatible receiver ' + _this ) } 
function deepSet ( obj , path ) { var value = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : null ; var define = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : ! 1 ; if ( ! ( 0 , _object . isObject ) ( obj ) ) throw new TypeError ( 'Deepget is only supported for objects' ) ; var parts = interpolatePath ( path ) ; 
function deepGet ( obj , path ) { var get_parent = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : ! 1 ; if ( ! ( 0 , _object . isObject ) ( obj ) ) throw new TypeError ( 'Deepget is only supported for objects' ) ; var parts = interpolatePath ( path ) ; 
function update_stats ( data ) { var timenow = parseInt ( new Date ( ) . getTime ( ) / 1000 ) ; for ( var v in data ) { switch ( config . output_format ) { case 'console' : console . log ( [ [ os . hostname ( ) , v ] . join ( '.' ) , data [ v ] , timenow ] . join ( ' ' ) ) ; break ; case 'graphite' : console . log ( [ [ os . hostname ( ) , v ] . join ( '.' ) , data [ v ] , timenow ] . join ( ' ' ) ) ; break ; case 'rrd-simple' : var off = timenow % 60 ; timenow = ( off <= 30 ) ? timenow - off : timenow + ( 60 - off ) ; var data = [ [ timenow , v ] . join ( '.' ) , data [ v ] ] . join ( ' ' ) ; var http = require ( 'http' ) ; var opts = { host : config . rrdsimple . host , port : config . rrdsimple . port , path : config . rrdsimple . path , method : 'POST' , headers : { 'Content-Type' : 'application/x-www-form-urlencoded' , 'Content-Length' : data . length } } console . log ( '[' + new Date ( ) . toISOString ( ) + '] ' + [ timenow , v ] . join ( '.' ) + ' -> ' + opts [ 'host' ] ) ; var req = http . request ( opts , function ( res ) { 
function ( ) { var args = Array . prototype . slice . apply ( arguments ) ; var message = args [ 0 ] ; var rpcCallbackHandler = function ( ) { } ; 
function toPercentage ( val ) { var precision = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; var min = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 0 ; var max = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : 1 ; if ( ! isNumber ( val ) || isNumericalNaN ( val ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( ! isNumber ( min ) || isNumericalNaN ( min ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( ! isNumber ( max ) || isNumericalNaN ( max ) ) { throw new TypeError ( 'Value should be numeric' ) ; } return round ( ( val - min ) / ( max - min ) * 100 , precision ) ; } 
function round ( val ) { var precision = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 0 ; if ( ! isNumber ( val ) || isNumericalNaN ( val ) ) { throw new TypeError ( 'Value should be numeric' ) ; } if ( precision === ! 1 || precision < 1 ) { return Math . round ( val ) ; } var exp = Math . pow ( 10 , Math . round ( precision ) ) ; return Math . round ( val * exp ) / exp ; } 
function randomBetween ( ) { var min = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 0 ; var max = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 10 ; if ( ! isNumber ( min ) || isNumericalNaN ( min ) ) { throw new TypeError ( 'Min should be numeric' ) ; } if ( ! isNumber ( max ) || isNumericalNaN ( max ) ) { throw new TypeError ( 'Max should be numeric' ) ; } return Math . random ( ) * max + min ; } 
function expensiveOperation ( input ) { return new Promise ( ( resolve , reject ) => { setTimeout ( ( ) => { const output = 'result' cache . write ( input , output ) resolve ( output ) } , 3000 ) } ) } 
function Flow ( limit ) { this . limit = limit ; Object . defineProperty ( this , "futureStack_" , { enumerable : false , writable : true , value : [ ] } ) ; Object . defineProperty ( this , "runningNum_" , { enumerable : false , writable : true , value : 0 } ) ; } 
function Future ( f , args ) { var self = this ; function run ( ) { args [ args . length ] = function cb ( ) { switch ( arguments . length ) { case 0 : self . result = null ; break ; case 1 : if ( arguments [ 0 ] instanceof Error ) { self . err = arguments [ 0 ] ; } else { self . result = arguments [ 0 ] ; } break ; default : self . err = arguments [ 0 ] ; if ( arguments . length === 2 ) { self . result = arguments [ 1 ] ; } else { self . result = Array . prototype . slice . call ( arguments , 1 ) ; } break ; } if ( self . flow_ ) self . flow_ . futureFinished ( ) ; var caller = self . caller ; if ( caller ) caller . run ( ) ; } ; args . length ++ ; f . apply ( undefined , args ) ; } this . run = run ; var flow = Fiber . current . flow ; if ( flow ) { Object . defineProperty ( this , "flow_" , { enumerable : false , writable : true , value : flow } ) ; flow . registerFuture ( this ) ; } else { run ( ) ; } } 
function hashish ( ) { var id = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : Math . floor ( Math . random ( ) * 100 ) ; var n = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : 2 ; var base = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 36 ; return _createHash ( id , _createSalts ( n , base ) , base ) ; } 
function escape ( html , encode ) { if ( encode ) { if ( escape . escapeTest . test ( html ) ) { return html . replace ( escape . escapeReplace , function ( ch ) { return escape . replacements [ ch ] ; } ) ; } } else { if ( escape . escapeTestNoEncode . test ( html ) ) { return html . replace ( escape . escapeReplaceNoEncode , function ( ch ) { return escape . replacements [ ch ] ; } ) ; } } return html ; } 
function rtrim ( str , c , invert ) { if ( str . length === 0 ) { return '' ; } 
function indexOfMatch ( string , regex , index ) { const str = index !== null ? string . substring ( index ) : string ; const matches = str . match ( regex ) ; return matches ? str . indexOf ( matches [ 0 ] ) + index : - 1 ; } 
function lastIndexOfMatch ( string , regex , index ) { const str = index !== null ? string . substring ( 0 , index ) : string ; const matches = str . match ( regex ) ; return matches ? str . lastIndexOf ( matches [ matches . length - 1 ] ) : - 1 ; } 
function splitLines ( string , index ) { const str = index ? string . substring ( index ) : string ; return str . split ( / \r\n|\r|\n / ) ; } 
function inlineHandler ( string , selectionRange , symbol ) { let newString = string ; const newSelectionRange = [ ... selectionRange ] ; 
function blockHandler ( string , selectionRange , symbol ) { const start = selectionRange [ 0 ] ; const end = selectionRange [ 1 ] ; const boundaryRegex = / [0-9~*`_-]|\b|\n|$ / gm ; let value ; let lineStart = startOfLine ( string , start ) ; let lineEnd = endOfLine ( string , end ) ; 
function listHandler ( string , selectionRange , type ) { const start = startOfLine ( string , selectionRange [ 0 ] ) ; const end = endOfLine ( string , selectionRange [ 1 ] ) ; const lines = splitLines ( string . substring ( start , end ) ) ; const boundaryRegex = / [~*`_[!]|[a-zA-Z]|\r|\n|$ / gm ; const newLines = [ ] ; lines . forEach ( ( line , i ) => { const symbol = type === 'ul' ? '- ' : ` ${ i + 1 } ` ; let newLine ; 
function indentHandler ( string , selectionRange , type ) { const start = startOfLine ( string , selectionRange [ 0 ] ) ; const end = endOfLine ( string , selectionRange [ 1 ] ) ; const lines = splitLines ( string . substring ( start , end ) ) ; const newLines = [ ] ; lines . forEach ( line => { const fourSpaces = ' ' ; let newLine ; if ( type === 'out' ) { newLine = line . indexOf ( fourSpaces , 0 ) === 0 ? line . substring ( fourSpaces . length , line . length ) : line . substring ( line . search ( / [~*`_[!#>-]|[a-zA-Z0-9]|\r|\n|$ / gm ) , line . length ) ; return newLines . push ( newLine ) ; } newLine = fourSpaces + line . substring ( 0 , line . length ) ; return newLines . push ( newLine ) ; } ) ; const joined = newLines . join ( '\r\n' ) ; const value = string . substring ( 0 , start ) + newLines . join ( '\r\n' ) + string . substring ( end , string . length ) ; return { value , range : [ start , start + joined . replace ( / \n / gm , '' ) . length ] } ; } 
function insertHandler ( string , selectionRange , snippet ) { const start = selectionRange [ 0 ] ; const end = selectionRange [ 1 ] ; const value = string . substring ( 0 , start ) + snippet + string . substring ( end , string . length ) ; return { value , range : [ start , start + snippet . length ] } ; } 
function markymark ( container = document . getElementsByTagName ( 'marky-mark' ) ) { if ( container instanceof HTMLElement ) { return initializer ( container ) ; } if ( ! ( container instanceof Array ) && ! ( container instanceof HTMLCollection ) && ! ( container instanceof NodeList ) ) { throw new TypeError ( 'argument should be an HTMLElement, Array, HTMLCollection' ) ; } return Array . from ( container ) . map ( initializer ) ; } 
function getPDF ( mu , s2 ) { var A = 1 / ( Math . sqrt ( s2 * 2 * Math . PI ) ) , B = - 1 / ( 2 * s2 ) ; return function pdf ( x ) { var C = x - mu ; return A * Math . exp ( B * C * C ) ; } ; } 
function getCDF ( mu , s2 ) { var A = 1 / 2 , B = Math . sqrt ( s2 * 2 ) ; return function cdf ( x ) { var C = x - mu ; return A * ( 1 + erf ( C / B ) ) ; } ; } 
function getQuantileFunction ( mu , s2 ) { var A = mu , B = Math . sqrt ( s2 * 2 ) ; return function quantile ( x ) { var C = 2 * x - 1 ; return A + B * erfinv ( C ) ; } ; } 
function cdf ( x , sigma ) { if ( x < 0 ) { return 0 ; } var s2 = pow ( sigma , 2 ) ; return - expm1 ( - pow ( x , 2 ) / ( 2 * s2 ) ) ; } 
function toJavascript ( data , mergeInto ) { var result = mergeInto || { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i ++ ) { var p = keys [ i ] result [ p ] = toJsValue ( data [ p ] ) } return result } 
function toDDB ( data , mergeInto ) { var result = mergeInto || { } var keys = Object . keys ( data ) for ( var i = 0 ; i < keys . length ; i ++ ) { var p = keys [ i ] result [ p ] = toDDBValue ( data [ p ] ) } return result } 
function clone ( obj ) { var cloned = { } ; for ( var i in obj ) { if ( obj . hasOwnProperty ( i ) ) { cloned [ i ] = obj [ i ] ; } } return cloned ; } 
function deepClone ( obj ) { if ( obj == null || typeof obj !== 'object' ) { return obj ; } var cloned = obj . constructor ( ) ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) { cloned [ key ] = deepClone ( obj [ key ] ) ; } } return cloned ; } 
function deepMerge ( one , another ) { if ( another == null || typeof another !== 'object' ) { return another ; } if ( one == null && typeof another === 'object' ) { if ( Array . isArray ( another ) ) { one = [ ] ; } else { one = { } ; } } var cloned = deepClone ( another ) ; for ( var key in cloned ) { if ( cloned . hasOwnProperty ( key ) ) { one [ key ] = deepMerge ( one [ key ] , another [ key ] ) ; } } return one ; } 
function ( object ) { if ( isDecorated ( object ) ) { return object ; } if ( Array . isArray ( object ) ) { return new JSONArray ( object ) ; } return new JSONObject ( object ) ; } 
function contentsToDisplay ( req , res , scsId , scId = 0 , cb ) { var zlSiteContentIn = app . models . zlSiteContentIn ; var Role = app . models . Role ; var compMod = require ( './helpers/component-from-model' ) ( app ) ; 
function vhost ( hostname , subsite , handle ) { if ( ! hostname ) { throw new TypeError ( 'argument hostname is required' ) } if ( ! handle ) { throw new TypeError ( 'argument handle is required' ) } if ( typeof handle !== 'function' ) { throw new TypeError ( 'argument handle must be a function' ) } 
function vhostof ( req , regexp , subsite ) { var host = req . headers . host var hostname = hostnameof ( req ) if ( ! hostname ) { return } var match = regexp . exec ( hostname ) if ( ! match ) { return } if ( subsite && 'IS_ROUTE' != subsite && ! _ . startsWith ( req . path , subsite + '/' , 1 ) && ( req . get ( 'X-Base-Url-Path' ) != subsite ) ) { return } var obj = Object . create ( null ) obj . host = host obj . hostname = hostname obj . length = match . length - 1 for ( var i = 1 ; i < match . length ; i ++ ) { obj [ i - 1 ] = match [ i ] } return obj } 
function getPackages ( app , cb = null ) { let stdout = '' ; const ls = spawn ( 'npm' , [ 'ls' , '--json' , '--prod' , '--depth=0' , '--long' ] ) ; ls . stdout . on ( 'data' , data => { stdout += data ; } ) ; ls . stderr . on ( 'data' , data => { app . error ( ` ${ data } ` ) ; } ) ; ls . on ( 'close' , ( code ) => { if ( 0 !== code ) app . error ( 'child process exited with code %s' , code ) ; app . debug ( 'loading installed zealder packages' ) ; var p = JSON . parse ( stdout ) ; if ( p . dependencies ) { 
function setPackagesState ( app , dependencies , cb ) { var zealPacks = { } ; let promises = [ ] ; _ . forEach ( dependencies , function ( val , key ) { buildPackagesList ( app , zealPacks , val , key , promises ) ; } ) ; Promise . all ( promises ) . then ( ( ) => { app . emit ( 'zealder packages loaded' ) ; 
function loadModels ( app , datasource , src , cb = null ) { const ds = app . dataSources [ datasource ] ; let promises = [ ] , modelsNames = [ ] ; let files = fs . readdirSync ( src ) ; if ( files ) { files . forEach ( file => { * NOTE: UNCOMMENT TO UPDATE DB ON PRODUCTION ALTHOUGH THAT SHOULD BE * AVOIDED BECAUSE IT RECREATE TABLE STRUCTURE AND REMOVES INDEXES, while * TRYING TO REBUILD STRUCTURE/INDEX IT CAN LEAVE SOME OUT ON LARGE DB AND * CREATE OPTIMIZATION NIGHTMARE */ 
function makeEntity ( req , res , all , top , data , path = '' , promises ) { var Role = app . models . Role ; const { zlSite } = res . locals ; const zsBaseUrlPath = ( zlSite . zsBaseUrlPath ) ? ` ${ zlSite . zsBaseUrlPath } ` : '/' _ . forEach ( _ . filter ( all , [ 'scsParent' , top ] ) , function ( val ) { val = val . toJSON ( ) ; if ( _ . find ( all , [ 'scsParent' , val . scsId ] ) ) { data = makeEntity ( req , res , all , val . scsId , data , path + val . scsSlug + '/' , promises ) ; } let loadThisEntity = ( ) => { data [ val . scsId ] = val ; 
function parse ( attribute ) { if ( _ . isString ( attribute ) ) { if ( attribute . charAt ( 0 ) === "$" ) { 
function minify ( page , appNameMap , appContentMap ) { let cssContent = '' ; let xmlContent = fs . readFileSync ( page . wxml , 'utf8' ) ; if ( utils . isFile ( page . wxss ) ) { cssContent = fs . readFileSync ( page . wxss , 'utf8' ) ; } if ( cssContent ) { cssContent = new CleanCSS ( { keepBreaks : true } ) . minify ( cssContent ) . styles ; cssContent = cssContent . replace ( / ::?(after|before|first\-child|last\-child) / g , ':$1' ) ; } 
function getUserAppRoles ( app , usrId , uroFor , uroForId , cb ) { var zlUserRole = app . models . zlUserRole ; let filter = { where : { usrId : usrId , uroFor : uroFor , uroForId : uroForId } } ; zlUserRole . findOne ( filter , ( err , data ) => { if ( data && data . uroRoles ) { let allRoles = buildAllRoles ( [ ] , data . uroRoles ) ; cb ( allRoles ) ; } else if ( 'Network' !== uroFor ) { 
function buildAllRoles ( all , roles ) { all . push ( ... roles ) ; _ . forEach ( roles , function ( role ) { 
function replaceString ( from , str , prefix , ignores ) { 
function makeScreenCap ( zsId , url , req ) { const zlSite = app . models . zlSite ; 
function buildListItem ( list , item ) { if ( list && list . length && item . __k !== undefined ) { for ( let t of list ) { if ( t . __k !== undefined && t . __k === item . __k ) { return Object . assign ( { } , t , item ) ; } } } return item ; } 
function curry ( fn ) { return function resolver ( ) { for ( var _len = arguments . length , resolverArgs = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { resolverArgs [ _key ] = arguments [ _key ] ; } return function ( ) { for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } var nextArgs = resolverArgs . concat ( args . length ? args : null ) ; var next = nextArgs . length >= fn . length ? fn : resolver ; return next . apply ( undefined , toConsumableArray ( nextArgs ) ) ; } ; } ( ) ; } 
function resetLocalOrResetUTC ( increment , date , utc ) { var _incrementHandlers ; var incrementHandlers = ( _incrementHandlers = { } , defineProperty ( _incrementHandlers , SECOND , function ( date ) { return new Date ( date [ 'set' + utc + 'Seconds' ] ( date [ 'get' + utc + 'Seconds' ] ( ) , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , MINUTE , function ( date ) { return new Date ( date [ 'set' + utc + 'Minutes' ] ( date [ 'get' + utc + 'Minutes' ] ( ) , 0 , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , HOUR , function ( date ) { return new Date ( date [ 'set' + utc + 'Hours' ] ( date [ 'get' + utc + 'Hours' ] ( ) , 0 , 0 , 0 ) ) ; } ) , defineProperty ( _incrementHandlers , DATE , function ( date ) { date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , WEEK , function ( date ) { date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) - date [ 'get' + utc + 'Day' ] ( ) ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , MONTH , function ( date ) { date [ 'set' + utc + 'Month' ] ( date [ 'get' + utc + 'Month' ] ( ) , 1 ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , defineProperty ( _incrementHandlers , YEAR , function ( date ) { date [ 'set' + utc + 'FullYear' ] ( date [ 'get' + utc + 'FullYear' ] ( ) , 0 , 1 ) ; date [ 'set' + utc + 'Hours' ] ( 0 , 0 , 0 , 0 ) ; return new Date ( date ) ; } ) , _incrementHandlers ) ; return incrementHandlers [ increment ] ( date ) ; } 
function setLocalOrSetUTC ( increment , value , date ) { var _incrementHandlers ; var utc = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : '' ; var incrementHandlers = ( _incrementHandlers = { } , defineProperty ( _incrementHandlers , MILLISECOND , function ( date ) { return new Date ( date [ 'set' + utc + 'Milliseconds' ] ( value ) ) ; } ) , defineProperty ( _incrementHandlers , SECOND , function ( date ) { return new Date ( date [ 'set' + utc + 'Seconds' ] ( value ) ) ; } ) , defineProperty ( _incrementHandlers , MINUTE , function ( date ) { return new Date ( date [ 'set' + utc + 'Minutes' ] ( value ) ) ; } ) , defineProperty ( _incrementHandlers , HOUR , function ( date ) { return new Date ( date [ 'set' + utc + 'Hours' ] ( value ) ) ; } ) , defineProperty ( _incrementHandlers , DATE , function ( date ) { return new Date ( date [ 'set' + utc + 'Date' ] ( value ) ) ; } ) , defineProperty ( _incrementHandlers , DAY , function ( date ) { return new Date ( date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) - date [ 'get' + utc + 'Day' ] ( ) + ( value - 1 ) ) ) ; } ) , defineProperty ( _incrementHandlers , WEEK , function ( date ) { var currentDay = date [ 'get' + utc + 'Day' ] ( ) ; var currentMilliseconds = date [ 'get' + utc + 'Milliseconds' ] ( ) ; date [ 'set' + utc + 'FullYear' ] ( date [ 'get' + utc + 'FullYear' ] ( ) , 0 , value * 7 ) ; var n = currentDay - date [ 'get' + utc + 'Day' ] ( ) ; date [ 'set' + utc + 'Date' ] ( date [ 'get' + utc + 'Date' ] ( ) + n ) ; return new Date ( date [ 'set' + utc + 'Milliseconds' ] ( currentMilliseconds ) ) ; } ) , defineProperty ( _incrementHandlers , MONTH , function ( date ) { var newMonth = value - 1 ; var newYear = date [ 'get' + utc + 'FullYear' ] ( ) ; var newDate = date [ 'get' + utc + 'Date' ] ( ) ; var shiftMonth = new Date ( date [ 'set' + utc + 'FullYear' ] ( newYear , newMonth + 1 , 0 ) ) ; if ( newDate > shiftMonth [ 'get' + utc + 'Date' ] ( ) ) { return shiftMonth ; } else { return new Date ( date [ 'set' + utc + 'FullYear' ] ( newYear , newMonth , newDate ) ) ; } } ) , defineProperty ( _incrementHandlers , YEAR , function ( date ) { var newYear = value ; var newMonth = date [ 'get' + utc + 'Month' ] ( ) ; var newDate = date [ 'get' + utc + 'Date' ] ( ) ; var shiftMonth = new Date ( date [ 'set' + utc + 'FullYear' ] ( newYear , newMonth + 1 , 0 ) ) ; if ( newDate > shiftMonth [ 'get' + utc + 'Date' ] ( ) ) { return shiftMonth ; } else { return new Date ( date [ 'set' + utc + 'FullYear' ] ( newYear , newMonth , newDate ) ) ; } } ) , _incrementHandlers ) ; return incrementHandlers [ increment ] ( date ) ; } 
function getLocalOrGetUTC ( increment , date ) { var _incrementHandlers ; var utc = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : '' ; var incrementHandlers = ( _incrementHandlers = { } , defineProperty ( _incrementHandlers , TIMEZONE_OFFSET , function ( date ) { return utc ? 0 : date . getTimezoneOffset ( ) / 60 * - 1 ; } ) , defineProperty ( _incrementHandlers , MILLISECOND , function ( date ) { return date [ 'get' + utc + 'Milliseconds' ] ( ) ; } ) , defineProperty ( _incrementHandlers , SECOND , function ( date ) { return date [ 'get' + utc + 'Seconds' ] ( ) ; } ) , defineProperty ( _incrementHandlers , MINUTE , function ( date ) { return date [ 'get' + utc + 'Minutes' ] ( ) ; } ) , defineProperty ( _incrementHandlers , HOUR , function ( date ) { return date [ 'get' + utc + 'Hours' ] ( ) ; } ) , defineProperty ( _incrementHandlers , DATE , function ( date ) { return date [ 'get' + utc + 'Date' ] ( ) ; } ) , defineProperty ( _incrementHandlers , DAY , function ( date ) { return date [ 'get' + utc + 'Day' ] ( ) + 1 ; } ) , defineProperty ( _incrementHandlers , WEEK , function ( date ) { return Math . floor ( ( ( date - new Date ( date [ 'get' + utc + 'FullYear' ] ( ) , 0 , 1 ) ) / 1000 / 60 / 60 / 24 + 1 ) / 7 ) ; } ) , defineProperty ( _incrementHandlers , MONTH , function ( date ) { return date [ 'get' + utc + 'Month' ] ( ) + 1 ; } ) , defineProperty ( _incrementHandlers , YEAR , function ( date ) { return date [ 'get' + utc + 'FullYear' ] ( ) ; } ) , _incrementHandlers ) ; return incrementHandlers [ increment ] ( date ) ; } 
function diffIt ( increment , date1 , date2 ) { var _incrementHandlers ; var incrementHandlers = ( _incrementHandlers = { } , defineProperty ( _incrementHandlers , MILLISECOND , function ( date1 , date2 ) { return diff ( date1 , date2 ) ; } ) , defineProperty ( _incrementHandlers , SECOND , function ( date1 , date2 ) { return diff ( date1 , date2 ) / 1000 ; } ) , defineProperty ( _incrementHandlers , MINUTE , function ( date1 , date2 ) { return this [ SECOND ] ( date1 , date2 ) / 60 ; } ) , defineProperty ( _incrementHandlers , HOUR , function ( date1 , date2 ) { return this [ MINUTE ] ( date1 , date2 ) / 60 ; } ) , defineProperty ( _incrementHandlers , DATE , function ( date1 , date2 ) { return this [ HOUR ] ( date1 , date2 ) / 24 ; } ) , defineProperty ( _incrementHandlers , WEEK , function ( date1 , date2 ) { return this [ DATE ] ( date1 , date2 ) / 7 ; } ) , defineProperty ( _incrementHandlers , MONTH , function ( date1 , date2 ) { return this [ DATE ] ( date1 , date2 ) / 30.44 ; 
function hinter ( fspec , opt_options ) { return gulp . src ( fspec ) . pipe ( ignorer . exclude ( excludes ) ) . pipe ( jshint ( opt_options ) ) . pipe ( jshint . reporter ( stylish ) ) ; } 
function getInheritTheme ( theme , tree = { } ) { if ( ! app . locals . themes [ theme ] ) { 
function cache ( app ) { if ( app . locals . config . cacheDb && 'redis' === app . locals . config . cacheDb . connector ) { 
function ( ) { if ( 3 == arguments . length ) { 
function ( ) { if ( 4 == arguments . length ) { 
function ( ) { if ( 4 == arguments . length ) { 
function ( ) { if ( 3 == arguments . length ) { 
function bypass ( req , conditions = { files : 1 , api : 1 } ) { if ( conditions . files ) { 
function authCtx ( req , res ) { let ctx = { accessToken : null , remotingContext : { req : req , res : res } } 
function mailCommon ( type , data , req , res ) { const { zlSite } = res . locals ; if ( 'form-notice' === type ) { if ( data . text ) { data . text += ` \n ${ req . cookies . referer } \n \n ` + ` ` + ` \n \n ` + ` ${ req . ip } \n ${ req . get ( 'Referrer' ) } \n \n ` + ` ${ process . env . ZEAL_NETWORK_NAME } ` + ` ` } } 
function recaptchaVerify ( req , res , action = 'form_submit' , cb , token = '' , threshold = 0.3 ) { const { zlSite } = res . locals ; if ( zlSite . user ) { 
function startWatching ( watch_folder , dest_folder ) { var watch = require ( 'watch' ) ; watch . watchTree ( watch_folder , function ( f , curr , prev ) { if ( typeof f == "object" && prev === null && curr === null ) { 
function copyFileFrom ( file , to_dir ) { var sys = require ( "sys" ) ; var fs = require ( 'fs' ) ; var file_name = filenameFromPath ( file ) ; if ( file_name == ".DS_Store" ) { return ; } sys . pump ( fs . createReadStream ( file ) , fs . createWriteStream ( to_dir ) , function ( ) { console . log ( "Copied file: " + file ) ; console . log ( "To new destination: " + to_dir + "\n" ) ; } ) ; } 
function realDestinationPath ( file , from_dir , to_dir ) { var length = from_dir . length ; var from_dir_path = file . substring ( length , file . length ) ; return to_dir + from_dir_path ; } 
function removeFileAtPath ( file , to_dir ) { var fs = require ( 'fs' ) ; var file_name = filenameFromPath ( file ) ; var file_at_dest_dir = to_dir + file_name ; fs . unlink ( file_at_dest_dir ) ; console . log ( "Removed file at directory: " + file_at_dest_dir ) ; } 
function Class ( ctor ) { if ( is ( 'Object' , ctor ) ) { 
function base ( args , ctor ) { var plain = false ; 
function clas ( ) { 
function sizeIt ( gridSize , sizeEle , sizeScreen = 'xs' ) { 
function _getOuterSize ( gridSize , sizeScreen ) { if ( 'lg' === sizeScreen ) { if ( gridSize && gridSize . lg ) { return gridSize . lg ; } else if ( gridSize && gridSize . md ) { return gridSize . md ; } else if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'md' === sizeScreen ) { if ( gridSize && gridSize . md ) { return gridSize . md ; } else if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'sm' === sizeScreen ) { if ( gridSize && gridSize . sm ) { return gridSize . sm ; } else if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } else if ( 'xs' === sizeScreen ) { if ( gridSize && gridSize . xs ) { return gridSize . xs ; } } 
function RecursiveConcat ( options ) { this . concat = null ; this . currentCountDirectories = 0 ; this . currentCountFiles = 0 ; this . currentFolder = null ; this . newFileGenerated = null ; this . newFinalFile = "" ; this . options = options ; this . walkCounter = 0 ; this . stream = new Transform ( { objectMode : true } ) ; this . stream . _transform = function ( chunk , encoding , callback ) { var fullPath = null , file = { } , relative = chunk . relative ; file . base = chunk . base ; file . contents = chunk . contents ; file . extname = Path . extname ( relative ) ; file . basename = Path . basename ( relative , file . extname ) ; file . dirname = Path . dirname ( relative ) ; file . newDirname = utils . fixDirName ( file . dirname ) ; fullPath = file . newDirname + file . basename + file . extname ; file . path = Path . join ( chunk . base , fullPath ) ; if ( ! file . relative ) { file . relative = relative ; } callback ( null , self . walk ( file ) ) ; } ; var self = this ; return this . stream ; } 
function getThemeApp ( ) { let mapStateToProps = ( state ) => { return { pages : state . pages , zlSite : state . zlSite , themeData : state . themeData , loadedComponents , getComponent , page : state . pages [ state . currentPage ] } ; } 
function getThemePage ( component , scsId ) { let mapStateToProps = ( state ) => { let page = state . pages [ scsId ] ; let zsDefaultContent = state . zlSite . zsDefaultContent ; let gtags = state . zlSite . gtags ; const { isFetching , lastUpdated , contents } = state . pages [ scsId ] || { isFetching : true , contents : [ ] } let contentList ; if ( Array . isArray ( contents ) && contents . length > 0 ) { contentList = [ ] ; contents . forEach ( function ( scId ) { contentList . push ( state . siteContents [ scId ] ) ; } ) ; } return { page , contentList , zsDefaultContent , isFetching , lastUpdated , getComponent , gtags } ; } 
function createColor ( color , alpha ) { return alpha >= 1 ? color : Color ( color ) . alpha ( alpha ) . hsl ( ) . string ( ) ; } 
function getColor ( name , props ) { const t = getThemeOrDefault ( 'colors' , props ) ; if ( props && props . inverted ) { const invertedName = ` ${ name } ` ; if ( invertedName in t ) { const alphaName = ` ${ invertedName } ` ; return createColor ( t [ invertedName ] , t [ alphaName ] || 1 ) ; } } if ( name in t ) { const alphaName = ` ${ name } ` ; return createColor ( t [ name ] , t [ alphaName ] || 1 ) ; } return '#000000' ; } 
function protect_roles ( app , config , prefix ) { for ( var path in config ) { init_debug ( "Protecting path: " + prefix + path ) ; var allow = true ; if ( config [ path ] . action === "deny" ) allow = false ; init_debug ( "Allow: " + allow ) ; for ( var method in config [ path ] ) { init_debug ( "Protecting method: " + method ) ; if ( method != "action" ) { var config_array = config [ path ] [ method ] ; app [ method ] ( prefix + path , ( function ( allow , conf ) { return function ( req , resp , next ) { running_debug ( "config roles: " + conf ) ; running_debug ( "req roles: " + req . user . roles . toString ( ) ) ; var active_roles = _ . intersection ( conf , req . user . roles ) ; running_debug ( "active roles: " + active_roles ) ; if ( active_roles . length > 0 ) { running_debug ( "active roles > 0" ) ; if ( allow ) { running_debug ( "path allowed" ) ; req . user . authorized_roles = _ . union ( req . user . authorized_roles , active_roles ) ; } else { running_debug ( "path not allowed" ) ; req . user . authorized_roles = _ . difference ( req . user . authorized_roles , active_roles ) ; } } next ( ) ; } ; } ) ( allow , config_array ) ) ; } } } } 
function check_role_authorization ( req , res , next ) { if ( ! req . hasOwnProperty ( "user" ) || ! req . user . hasOwnProperty ( 'authorized_roles' ) || ! ( req . user . authorized_roles instanceof Array ) || req . user . authorized_roles . length === 0 ) { running_debug ( "Unhautorized: Invalid role or path not configured" ) ; var err = new Error ( "Unhautorized: Invalid role or path not configured" ) ; err . status = 401 ; return next ( err ) ; } running_debug ( "Authorized roles: " + req . user . authorized_roles ) ; return next ( ) ; } 
function InSicht ( ) { var options = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; _classCallCheck ( this , InSicht ) ; this . options = Object . assign ( { } , defaults , options ) ; this . init ( ) ; } 
function webpackDev ( app ) { var { config } = app . locals ; 
function userFromToken ( req , cb ) { const { accessToken } = req ; app . models . zlUser . findById ( accessToken . userId , ( err , usr ) => { if ( ! err && usr ) { cb ( null , usr ) ; } else cb ( err ) ; } ) ; } 
function render ( rawCode , idPre ) { var codeArr = { } ; 
function loadPages ( req , res , next ) { const { zlSite } = res . locals ; 
function ( key , value , keep ) { 
function ( key , storageType ) { 
function ( key , storageType ) { var isStorageType = typeof storageType === 'undefined' ? false : true ; if ( isStorageType ) { webStorage = $window [ storageType ] ; webStorage . removeItem ( key ) ; } else { webStorage = $window . sessionStorage ; webStorage . removeItem ( key ) ; webStorage = $window . localStorage ; webStorage . removeItem ( key ) ; } return true ; } 
function ( storageType ) { var isStorageType = typeof storageType === 'undefined' ? false : true ; var key , keys = [ ] ; if ( isStorageType ) { webStorage = $window [ storageType ] ; for ( key in webStorage ) { keys . push ( key ) ; } } else { webStorage = $window . localStorage ; for ( key in webStorage ) { keys . push ( key ) ; } webStorage = $window . sessionStorage ; for ( key in webStorage ) { if ( keys . indexOf ( key ) == - 1 ) keys . push ( key ) ; } } return keys ; } 
function ( storageType ) { var isStorageType = typeof storageType === 'undefined' ? false : true , key ; if ( isStorageType ) { webStorage = $window [ storageType ] ; for ( key in webStorage ) removeFromStorage ( key , storageType ) ; } else { webStorage = $window . sessionStorage ; for ( key in webStorage ) removeFromStorage ( key , 'sessionStorage' ) ; webStorage = $window . localStorage ; for ( key in webStorage ) removeFromStorage ( key , 'localStorage' ) ; } return true ; } 
function TripCase ( options ) { if ( ! options || ! options . email || ! options . password ) throw 'Missing required options' ; this . email = options . email ; this . password = options . password ; this . session = null ; return this ; } 
function readyBundleConf ( app , wpConfig , modIncl , compDict , sassPath , appBundled , wpEntry , type , key , pack , packagesVer ) { app . debug ( 'preparing bundle for %s' , key ) ; make available to a framework/lib such as bootstrap */ sassPath . push ( ` ${ pack . path } ${ pack . zealderConfig . sassPath } ` ) ; } if ( ! appBundled && pack . zealderConfig . clientRenderFile && pack . zealderConfig . serverRenderFile && 'theme' == type ) { 
function readyBundle ( app , zlSite , theme , resolve = ( ) => { } , cb ) { var { apps , themes , cache , getInheritTheme , defaultTheme , config } = app . locals ; var contentPath , bundlTheme ; if ( zlSite ) { 
function loadAssets ( req , res , next ) { var { zlSite , socketQuery , appStyles } = res . locals ; const { config , reCAPTCHAkey } = req . app . locals ; 
function trmv ( A , x , isLower ) { var dot = blas1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( isLower ) { for ( i = n - 1 ; i >= 0 ; i -- ) { x . set ( i , dot ( A . pick ( i , null ) . hi ( i + 1 ) , x . hi ( i + 1 ) ) ) ; } } else { for ( i = 0 ; i < n ; i ++ ) { x . set ( i , dot ( A . pick ( i , null ) . lo ( i ) , x . lo ( i ) ) ) ; } } return true ; } 
function ( ) { this . TYPE = { TAG : 'tag' , USER : 'user' } this . urlRules = { tag : { rule : / ((https?):\/\/)?(www\.)?instagram.com\/explore\/tags\/([\w_]+) / mi } , user : { rule : / ((https?):\/\/)?(www\.)?instagram\.com\/([\w._]+)\/? / mi } } } 
function fetchData ( url , type , conf , cb ) { let forUrl ; switch ( type ) { case 'categories' : forUrl = ` ${ url } ` ; break ; case 'post' : 
function getLocalOrGetUTC ( increment , date , utc = '' ) { const incrementHandlers = { [ TIMEZONE_OFFSET ] ( date ) { return utc ? 0 : date . getTimezoneOffset ( ) / 60 * - 1 ; } , [ MILLISECOND ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , [ SECOND ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , [ MINUTE ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , [ HOUR ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , [ DATE ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , [ DAY ] ( date ) { return date [ ` ${ utc } ` ] ( ) + 1 ; } , [ WEEK ] ( date ) { return Math . floor ( ( ( date - new Date ( date [ ` ${ utc } ` ] ( ) , 0 , 1 ) ) / 1000 / 60 / 60 / 24 + 1 ) / 7 , ) ; } , [ MONTH ] ( date ) { return date [ ` ${ utc } ` ] ( ) + 1 ; } , [ YEAR ] ( date ) { return date [ ` ${ utc } ` ] ( ) ; } , } ; return incrementHandlers [ increment ] ( date ) ; } 
function siteAppsAdmin ( req , res , cb ) { var { themeData } = res . locals ; const { apps , getInheritTheme , themes } = req . app . locals ; if ( ! themeData . managingSite ) cb ( ) ; else { 
function sanitize ( str ) { const symbolMap = { '\'' : '\\textquotesingle{}' , '"' : '\\textquotedbl{}' , '`' : '\\textasciigrave{}' , '^' : '\\textasciicircum{}' , '~' : '\\textasciitilde{}' , '<' : '\\textless{}' , '>' : '\\textgreater{}' , '|' : '\\textbar{}' , '\\' : '\\textbackslash{}' , '{' : '\\{' , '}' : '\\}' , '$' : '\\$' , '&' : '\\&' , '#' : '\\#' , '_' : '\\_' , '%' : '\\%' } return Array . from ( str ) . map ( char => symbolMap [ char ] || char ) . join ( '' ) } 
function execute ( target , prop , ... args ) { return _ . isFunction ( target [ prop ] ) ? target [ prop ] ( ... args ) : target [ prop ] ; } 
function tokenToCookie ( req , res , next ) { if ( req . signedCookies . authorization !== req . accessToken . id ) { let opt = _cookieOpt ( req , res ) ; res . cookie ( 'authorization' , req . accessToken . id , opt ) ; } next ( ) ; } 
function tokenQueryRemove ( req , res , next ) { if ( req . query && req . query . access_token && ! req . app . locals . bypass ( req ) ) { 
function loadUsrInfo ( token , app , zlSite , next ) { app . models . zlUser . findById ( token . userId , ( err , usr ) => { if ( err ) next ( err ) ; else if ( usr ) { zlSite . user = _ . cloneDeep ( usr ) ; if ( ! zlSite . user . usrPhoto && zlSite . user . email ) { 
function addTimeOrSubtractTime ( increment , n , date ) { const incrementHandlers = { [ MILLISECOND ] ( date ) { return new Date ( date . setUTCMilliseconds ( date . getUTCMilliseconds ( ) + n ) ) ; } , [ SECOND ] ( date ) { return new Date ( date . setUTCSeconds ( date . getUTCSeconds ( ) + n ) ) ; } , [ MINUTE ] ( date ) { return new Date ( date . setUTCMinutes ( date . getUTCMinutes ( ) + n ) ) ; } , [ HOUR ] ( date ) { return new Date ( date . setUTCHours ( date . getUTCHours ( ) + n ) ) ; } , [ DATE ] ( date ) { return new Date ( date . setUTCDate ( date . getUTCDate ( ) + n ) ) ; } , [ WEEK ] ( date ) { return new Date ( date . setUTCDate ( date . getUTCDate ( ) + n * 7 ) ) ; } , [ MONTH ] ( date ) { let newMonth = date . getUTCMonth ( ) + n ; let newYear = date . getUTCFullYear ( ) ; let newDate = date . getUTCDate ( ) ; if ( newDate > new Date ( date . setUTCFullYear ( newYear , newMonth + 1 , 0 ) ) . getUTCDate ( ) ) { return new Date ( date . setUTCFullYear ( newYear , newMonth + 1 , 0 ) ) ; } return new Date ( date . setUTCFullYear ( newYear , newMonth , newDate ) ) ; } , [ YEAR ] ( date ) { let newYear = date . getUTCFullYear ( ) + n ; let newMonth = date . getUTCMonth ( ) ; let newDate = date . getUTCDate ( ) ; if ( newDate > new Date ( date . setUTCFullYear ( newYear , newMonth + 1 , 0 ) ) . getUTCDate ( ) ) { return new Date ( date . setUTCFullYear ( newYear , newMonth + 1 , 0 ) ) ; } return new Date ( date . setUTCFullYear ( newYear , newMonth , newDate ) ) ; } , } ; return incrementHandlers [ increment ] ( date ) ; } 
function metaData ( req , res , next ) { var zlSite = res . locals . zlSite ; 
function trsv ( A , x , isLower ) { var dot = blas1 . dot ; var n = A . shape [ 1 ] ; var i = 0 ; if ( isLower ) { x . set ( 0 , x . get ( 0 ) / A . get ( 0 , 0 ) ) ; for ( i = 1 ; i < n ; i ++ ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . hi ( i ) , x . hi ( i ) ) ) / A . get ( i , i ) ) ; } } else { x . set ( n - 1 , x . get ( n - 1 ) / A . get ( n - 1 , n - 1 ) ) ; for ( i = n - 2 ; i >= 0 ; i -- ) { x . set ( i , ( x . get ( i ) - dot ( A . pick ( i , null ) . lo ( i + 1 ) , x . lo ( i + 1 ) ) ) / A . get ( i , i ) ) ; } } return true ; } 
function ( scContent ) { if ( _ . isEmpty ( scContent [ 'data' ] ) ) { return ; } let columns = [ ] ; if ( scContent [ 'columns' ] ) { 
function ( modelData , scContent ) { if ( scContent [ 'treeData' ] ) { 
function ( res , scContent , embedIn ) { this . app = app ; this . res = res ; const self = this ; let fields = [ ] ; if ( scContent [ 'fields' ] ) { 
function ( res , scContent , post , cb ) { let model = this . _modelInfo ( scContent [ 'forModel' ] ) ; 
function ( forModel ) { let model = { model : app . models [ forModel ] , prop : app . models [ forModel ] . definition . properties , settings : app . models [ forModel ] . settings , meta : app . models [ forModel ] . settings . zlMeta , ns : '' } ; if ( model . meta && model . meta [ 'Namespace' ] ) { model . ns = model . meta [ 'Namespace' ] ; } return model ; } 
function ( modMeth , filter , cb = ( err , val , cb ) => cb ( ) ) { this . promises . push ( new Promise ( ( resolve , reject ) => { modMeth ( ... filter , ( err , val ) => { cb ( err , val , resolve ) ; } ) ; } ) ) ; } 
function _embedGetter ( self , fields , embedGetter , key ) { let allOpts = [ ] ; self . res . locals . emiter . emit ( 'get-options' , embedGetter , allOpts ) ; if ( allOpts ) { allOpts . forEach ( function ( obj ) { obj . embedIn = key ; } ) ; fields . push ( ... allOpts ) ; } } 
function getAuthSites ( req , res , next ) { const zlUserRole = req . app . models . zlUserRole ; const zlSite = req . app . models . zlSite ; let { themeData , socketQuery , emiter } = res . locals ; themeData [ 'authSites' ] = { } , themeData [ 'managingSite' ] = null ; socketQuery [ 'authSites' ] = [ ] ; let filter = { where : { "usrId" : req . accessToken . userId , "uroFor" : 'Site' } } zlUserRole . find ( filter , ( err , data ) => { if ( err ) req . app . error ( err ) ; if ( data ) { let promises = [ ] ; _ . forEach ( data , function ( val ) { val = val . toJSON ( ) ; promises . push ( new Promise ( ( resolve , reject ) => { 
function shouldFetchContents ( state , scsId ) { const page = state . pages [ scsId ] ; if ( page . contents . length === 0 ) { return true } else if ( page . isFetching ) { return false } else { return page . didInvalidate } } 
function build ( app ) { console . log ( 'Building Zealder bundles...' ) ; let promises = [ ] ; 
function bundleServer ( app , promises ) { var { themes , config } = app . locals ; 
function serverRender ( req , res , next ) { var app = req . app ; var { themes , defaultTheme } = app . locals ; var { zlSite } = res . locals ; if ( ! zlSite || ! themes [ zlSite . zsTheme ] ) return next ( ) ; 
function ( active , suppressEvent ) { if ( this . active != active ) { this . active = active ; if ( suppressEvent !== true ) { this . fireEvent ( active ? 'activate' : 'deactivate' , this ) ; } } } 
function isInitializeMethod ( node ) { var expression = node . expression ; return expression . type === 'AssignmentExpression' && expression . left . type === 'MemberExpression' && expression . left . object . name === 'my' && expression . left . property . name === 'initialize' ; } 
function ( dataview ) { this . dataview = dataview ; dataview . mon ( dataview , { beforecontainerclick : this . cancelClick , scope : this , render : { fn : this . onRender , scope : this , single : true } } ) ; } 
function hmacSign ( input , algorithm , secret ) { return crypto . createHmac ( algorithm , secret ) . update ( input ) . digest ( 'base64' ) } 
function rsaSign ( input , algorithm , privateSecret ) { try { 
function sign ( input , algorithm , secret ) { const alg = algorithmMap [ algorithm ] if ( ! alg ) { throw new Error ( errorMap [ '002' ] . message ) } const type = typeMap [ algorithm ] let signature switch ( type ) { case 'hmac' : signature = hmacSign ( input , alg , secret ) break case 'sign' : signature = rsaSign ( input , alg , secret ) break default : signature = hmacSign ( input , alg , secret ) break } return signature } 
function hmacVerify ( input , algorithm , secret , signature ) { try { const verify = signature === hmacSign ( input , algorithm , secret ) if ( ! verify ) { errorMap [ '006' ] . message = 'Unvalid secret for hmac verify, signature verification failed' errorMap [ '006' ] . error = new Error ( errorMap [ '006' ] . message ) } return verify } catch ( e ) { errorMap [ '006' ] . message = 'Exception error in hamc verify, signature verification failed' errorMap [ '006' ] . error = e return false } } 
function rsaVerify ( input , algorithm , publicSecret , signature ) { try { 
function verify ( input , algorithm , secret , signature ) { const alg = algorithmMap [ algorithm ] if ( ! alg ) { errorMap [ '006' ] . message = 'Algorithm not recognized, signature verification failed' errorMap [ '006' ] . message = new Error ( errorMap [ '006' ] . message ) return false } const type = typeMap [ algorithm ] switch ( type ) { case 'hmac' : return hmacVerify ( input , alg , secret , signature ) case 'sign' : return rsaVerify ( input , alg , secret , signature ) default : return hmacVerify ( input , alg , secret , signature ) } } 
function ( data ) { if ( data . blocks ) delete data . blocks if ( ! controllersCount && request . page ) { callback ( null , { code : 404 } ) return ; } data . request = request me . server . tpl ( me . tpls [ data . tpl ] . tpl , data , function ( code ) { callback ( code ) ; } , request . locale ) } 
function ( data ) { for ( var i = 1 ; i <= me . tpls [ data . tpl ] . blocks ; i ++ ) { data [ 'BLOCK_' + i ] = [ ] } 
function registerCollection ( identifier , collection , model ) { this . registeredModelsAndCollections [ identifier ] = { collectionClass : collection , modelClass : model } ; } 
function findRegisteredIdentifier ( modelOrCollection ) { var foundKey ; for ( var key in this . registeredModelsAndCollections ) { var registeredModelOrCollection = this . registeredModelsAndCollections [ key ] ; if ( modelOrCollection . constructor === registeredModelOrCollection ) { foundKey = key ; break ; } else { if ( _ . has ( registeredModelOrCollection , 'collectionClass' ) && modelOrCollection . constructor === registeredModelOrCollection . collectionClass ) { foundKey = key ; break ; } } } return foundKey ; } 
function getType ( v ) { var result = '' ; if ( v == null ) { result = v + '' ; } else { result = typeof v ; if ( result == 'object' || result == 'function' ) { result = illa . classByType [ illa . classByType . toString . call ( v ) ] || 'object' ; } } return result ; } 
function bindUnsafe ( fn , obj ) { var args = [ ] ; for ( var _i = 2 ; _i < arguments . length ; _i ++ ) { args [ _i - 2 ] = arguments [ _i ] ; } return illa . bind . call ( this , arguments ) ; } 
function uuid ( ) { var base = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx' ; var result = base . replace ( / [xy] / g , function ( char ) { var random = cryptoRandom16 ( ) ; var result = char == 'x' ? random : ( random & 0x3 | 0x8 ) ; return result . toString ( 16 ) ; } ) ; return result ; } 
function addProps ( obj ) { var rest = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i ++ ) { rest [ _i - 1 ] = arguments [ _i ] ; } for ( var i = 0 , n = rest . length ; i < n ; i += 2 ) { if ( illa . isString ( rest [ i ] ) ) { obj [ rest [ i ] ] = rest [ i + 1 ] ; } } return obj ; } 
function ( ) { var me = this ; me . addEvents ( 'click' ) ; 
function ( ) { var me = this , attr ; me . callParent ( arguments ) ; me . el . on ( { click : me . onClick , mousedown : me . onMouseDown , mouseover : me . onMouseOver , mouseout : me . onMouseOut , scope : me } ) ; if ( me . tooltip ) { if ( Ext . quickTipsActive && Ext . isObject ( me . tooltip ) ) { Ext . tip . QuickTipManager . register ( Ext . apply ( { target : me . id } , me . tooltip ) ) ; } else { attr = me . tooltipType == 'qtip' ? 'data-qtip' : 'title' ; me . el . dom . setAttribute ( attr , me . tooltip ) ; } } } 
function ( type ) { var me = this , oldType = me . type ; me . type = type ; if ( me . rendered ) { if ( oldType ) { me . toolEl . removeCls ( me . baseCls + '-' + oldType ) ; } me . toolEl . addCls ( me . baseCls + '-' + type ) ; } else { me . renderData . type = type ; } return me ; } 
function ( ) { if ( Ext . quickTipsActive && Ext . isObject ( this . tooltip ) ) { Ext . tip . QuickTipManager . unregister ( this . id ) ; } this . callParent ( ) ; } 
function ( ) { var me = this , locked = me . lockable . lockedGrid . headerCt . getColumnsState ( ) , normal = me . lockable . normalGrid . headerCt . getColumnsState ( ) ; return locked . concat ( normal ) ; } 
function nextLine ( ) { var at ; if ( line >= lines . length ) { return false ; } character = 1 ; s = lines [ line ] ; line += 1 ; at = s . search ( / \t / ) ; if ( at >= 0 ) { warningAt ( "Mixed spaces and tabs." , line , at + 1 ) ; } s = s . replace ( / \t / g , tab ) ; at = s . search ( cx ) ; if ( at >= 0 ) { warningAt ( "Unsafe character." , line , at ) ; } if ( option . maxlen && option . maxlen < s . length ) { warningAt ( "Line too long." , line , s . length ) ; } return true ; } 
function it ( type , value ) { var i , t ; if ( type === '(color)' || type === '(range)' ) { t = { type : type } ; } else if ( type === '(punctuator)' || ( type === '(identifier)' && is_own ( syntax , value ) ) ) { t = syntax [ value ] || syntax [ '(error)' ] ; } else { t = syntax [ type ] ; } t = Object . create ( t ) ; if ( type === '(string)' || type === '(range)' ) { if ( jx . test ( value ) ) { warningAt ( "Script URL." , line , from ) ; } } if ( type === '(identifier)' ) { t . identifier = true ; if ( value === '__iterator__' || value === '__proto__' ) { errorAt ( "Reserved name '{a}'." , line , from , value ) ; } else if ( option . nomen && ( value . charAt ( 0 ) === '_' || value . charAt ( value . length - 1 ) === '_' ) ) { warningAt ( "Unexpected {a} in '{b}'." , line , from , "dangling '_'" , value ) ; } } t . value = value ; t . line = line ; t . character = character ; t . from = from ; i = t . id ; if ( i !== '(endline)' ) { prereg = i && ( ( '(,=:[!&|?{};' . indexOf ( i . charAt ( i . length - 1 ) ) >= 0 ) || i === 'return' ) ; } return t ; } 
function ( ) { var b , c , captures , d , depth , high , i , l , low , q , t ; function match ( x ) { var r = x . exec ( s ) , r1 ; if ( r ) { l = r [ 0 ] . length ; r1 = r [ 1 ] ; c = r1 . charAt ( 0 ) ; s = s . substr ( l ) ; from = character + l - r1 . length ; character += l ; return r1 ; } } function string ( x ) { var c , j , r = '' ; if ( jsonmode && x !== '"' ) { warningAt ( "Strings must use doublequote." , line , character ) ; } if ( xquote === x || ( xmode === 'scriptstring' && ! xquote ) ) { return it ( '(punctuator)' , x ) ; } function esc ( n ) { var i = parseInt ( s . substr ( j + 1 , n ) , 16 ) ; j += n ; if ( i >= 32 && i <= 126 && i !== 34 && i !== 92 && i !== 39 ) { warningAt ( "Unnecessary escapement." , line , character ) ; } character += n ; c = String . fromCharCode ( i ) ; } j = 0 ; for ( ; ; ) { while ( j >= s . length ) { j = 0 ; if ( xmode !== 'html' || ! nextLine ( ) ) { errorAt ( "Unclosed string." , line , from ) ; } } c = s . charAt ( j ) ; if ( c === x ) { character += 1 ; s = s . substr ( j + 1 ) ; return it ( '(string)' , r , x ) ; } if ( c < ' ' ) { if ( c === '\n' || c === '\r' ) { break ; } warningAt ( "Control character in string: {a}." , line , character + j , s . slice ( 0 , j ) ) ; } else if ( c === xquote ) { warningAt ( "Bad HTML string" , line , character + j ) ; } else if ( c === '<' ) { if ( option . safe && xmode === 'html' ) { warningAt ( "ADsafe string violation." , line , character + j ) ; } else if ( s . charAt ( j + 1 ) === '/' && ( xmode || option . safe ) ) { warningAt ( "Expected '<\\/' and instead saw '</'." , line , character ) ; } else if ( s . charAt ( j + 1 ) === '!' && ( xmode || option . safe ) ) { warningAt ( "Unexpected '<!' in a string." , line , character ) ; } } else if ( c === '\\' ) { if ( xmode === 'html' ) { if ( option . safe ) { warningAt ( "ADsafe string violation." , line , character + j ) ; } } else if ( xmode === 'styleproperty' ) { j += 1 ; character += 1 ; c = s . charAt ( j ) ; if ( c !== x ) { warningAt ( "Escapement in style string." , line , character + j ) ; } } else { j += 1 ; character += 1 ; c = s . charAt ( j ) ; switch ( c ) { case xquote : warningAt ( "Bad HTML string" , line , character + j ) ; break ; case '\\' : case '"' : case '/' : break ; case '\'' : if ( jsonmode ) { warningAt ( "Avoid \\'." , line , character ) ; } break ; case 'b' : c = '\b' ; break ; case 'f' : c = '\f' ; break ; case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case 'u' : esc ( 4 ) ; break ; case 'v' : if ( jsonmode ) { warningAt ( "Avoid \\v." , line , character ) ; } c = '\v' ; break ; case 'x' : if ( jsonmode ) { warningAt ( "Avoid \\x-." , line , character ) ; } esc ( 2 ) ; break ; default : warningAt ( "Bad escapement." , line , character ) ; } } } r += c ; character += 1 ; j += 1 ; } } for ( ; ; ) { if ( ! s ) { return it ( nextLine ( ) ? '(endline)' : '(end)' , '' ) ; } while ( xmode === 'outer' ) { i = s . search ( ox ) ; if ( i === 0 ) { break ; } else if ( i > 0 ) { character += 1 ; s = s . slice ( i ) ; break ; } else { if ( ! nextLine ( ) ) { return it ( '(end)' , '' ) ; } } } t = match ( rx [ xmode ] || tx ) ; if ( ! t ) { t = '' ; c = '' ; while ( s && s < '!' ) { s = s . substr ( 1 ) ; } if ( s ) { if ( xmode === 'html' ) { return it ( '(error)' , s . charAt ( 0 ) ) ; } else { errorAt ( "Unexpected '{a}'." , line , character , s . substr ( 0 , 1 ) ) ; } } } else { // identifier if ( c . isAlpha ( ) || c === '_' || c === '$' ) { return it ( '(identifier)' , t ) ; } // number if ( c . isDigit ( ) ) { if ( xmode !== 'style' && ! isFinite ( Number ( t ) ) ) { warningAt ( "Bad number '{a}'." , line , character , t ) ; } if ( xmode !== 'style' && xmode !== 'styleproperty' && s . substr ( 0 , 1 ) . isAlpha ( ) ) { warningAt ( "Missing space after '{a}'." , line , character , t ) ; } if ( c === '0' ) { d = t . substr ( 1 , 1 ) ; if ( d . isDigit ( ) ) { if ( token . id !== '.' && xmode !== 'styleproperty' ) { warningAt ( "Don't use extra leading zeros '{a}'." , line , character , t ) ; } } else if ( jsonmode && ( d === 'x' || d === 'X' ) ) { warningAt ( "Avoid 0x-. '{a}'." , line , character , t ) ; } } if ( t . substr ( t . length - 1 ) === '.' ) { warningAt ( "A trailing decimal point can be confused with a dot '{a}'." , line , character , t ) ; } return it ( '(number)' , t ) ; } switch ( t ) { // string case '"' : case "'" : return string ( t ) ; // // comment case ' 
function advance ( id , t ) { switch ( token . id ) { case '(number)' : if ( nexttoken . id === '.' ) { warning ( "A dot following a number can be confused with a decimal point." , token ) ; } break ; case '-' : if ( nexttoken . id === '-' || nexttoken . id === '--' ) { warning ( "Confusing minusses." ) ; } break ; case '+' : if ( nexttoken . id === '+' || nexttoken . id === '++' ) { warning ( "Confusing plusses." ) ; } break ; } if ( token . type === '(string)' || token . identifier ) { anonname = token . value ; } if ( id && nexttoken . id !== id ) { if ( t ) { if ( nexttoken . id === '(end)' ) { warning ( "Unmatched '{a}'." , t , t . id ) ; } else { warning ( "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'." , nexttoken , id , t . id , t . line , nexttoken . value ) ; } } else if ( nexttoken . type !== '(identifier)' || nexttoken . value !== id ) { warning ( "Expected '{a}' and instead saw '{b}'." , nexttoken , id , nexttoken . value ) ; } } prevtoken = token ; token = nexttoken ; for ( ; ; ) { nexttoken = lookahead . shift ( ) || lex . token ( ) ; if ( nexttoken . id === '(end)' || nexttoken . id === '(error)' ) { return ; } if ( nexttoken . type === 'special' ) { doOption ( ) ; } else { if ( nexttoken . id !== '(endline)' ) { break ; } } } } 
function expression ( rbp , initial ) { var left ; if ( nexttoken . id === '(end)' ) { error ( "Unexpected early end of program." , token ) ; } advance ( ) ; if ( option . safe && typeof predefined [ token . value ] === 'boolean' && ( nexttoken . id !== '(' && nexttoken . id !== '.' ) ) { warning ( 'ADsafe violation.' , token ) ; } if ( initial ) { anonname = 'anonymous' ; funct [ '(verb)' ] = token . value ; } if ( initial === true && token . fud ) { left = token . fud ( ) ; } else { if ( token . nud ) { left = token . nud ( ) ; } else { if ( nexttoken . type === '(number)' && token . id === '.' ) { warning ( "A leading decimal point can be confused with a dot: '.{a}'." , token , nexttoken . value ) ; advance ( ) ; return token ; } else { error ( "Expected an identifier and instead saw '{a}'." , token , token . id ) ; } } while ( rbp < nexttoken . lbp ) { advance ( ) ; if ( token . led ) { left = token . led ( left ) ; } else { error ( "Expected an operator and instead saw '{a}'." , token , token . id ) ; } } } return left ; } 
function adjacent ( left , right ) { left = left || token ; right = right || nexttoken ; if ( option . white || xmode === 'styleproperty' || xmode === 'style' ) { if ( left . character !== right . from && left . line === right . line ) { warning ( "Unexpected space after '{a}'." , right , left . value ) ; } } } 
function optionalidentifier ( fnparam ) { if ( nexttoken . identifier ) { advance ( ) ; if ( option . safe && banned [ token . value ] ) { warning ( "ADsafe violation: '{a}'." , token , token . value ) ; } else if ( token . reserved && ! option . es5 ) { 
function block ( ordinary , stmt ) { var a , b = inblock , old_indent = indent , m = strict_mode , s = scope , t ; inblock = ordinary ; scope = Object . create ( scope ) ; nonadjacent ( token , nexttoken ) ; t = nexttoken ; if ( nexttoken . id === '{' ) { advance ( '{' ) ; if ( nexttoken . id !== '}' || token . line !== nexttoken . line ) { indent += option . indent ; while ( ! ordinary && nexttoken . from > indent ) { indent += option . indent ; } if ( ! ordinary && ! use_strict ( ) && ! m && option . strict && funct [ '(context)' ] [ '(global)' ] ) { warning ( "Missing \"use strict\" statement." ) ; } a = statements ( ) ; strict_mode = m ; indent -= option . indent ; indentation ( ) ; } advance ( '}' , t ) ; indent = old_indent ; } else if ( ! ordinary ) { error ( "Expected '{a}' and instead saw '{b}'." , nexttoken , '{' , nexttoken . value ) ; } else { if ( ! stmt || option . curly ) warning ( "Expected '{a}' and instead saw '{b}'." , nexttoken , '{' , nexttoken . value ) ; noreach = true ; a = [ statement ( ) ] ; noreach = false ; } funct [ '(verb)' ] = null ; scope = s ; inblock = b ; if ( ordinary && option . noempty && ( ! a || a . length === 0 ) ) { warning ( "Empty block." ) ; } return a ; } 
function doBegin ( n ) { if ( n !== 'html' && ! option . fragment ) { if ( n === 'div' && option . adsafe ) { error ( "ADSAFE: Use the fragment option." ) ; } else { error ( "Expected '{a}' and instead saw '{b}'." , token , 'html' , n ) ; } } if ( option . adsafe ) { if ( n === 'html' ) { error ( "Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files." , token ) ; } if ( option . fragment ) { if ( n !== 'div' ) { error ( "ADsafe violation: Wrap the widget in a div." , token ) ; } } else { error ( "Use the fragment option." , token ) ; } } option . browser = true ; assume ( ) ; } 
function jsonValue ( ) { function jsonObject ( ) { var o = { } , t = nexttoken ; advance ( '{' ) ; if ( nexttoken . id !== '}' ) { for ( ; ; ) { if ( nexttoken . id === '(end)' ) { error ( "Missing '}' to match '{' from line {a}." , nexttoken , t . line ) ; } else if ( nexttoken . id === '}' ) { warning ( "Unexpected comma." , token ) ; break ; } else if ( nexttoken . id === ',' ) { error ( "Unexpected comma." , nexttoken ) ; } else if ( nexttoken . id !== '(string)' ) { warning ( "Expected a string and instead saw {a}." , nexttoken , nexttoken . value ) ; } if ( o [ nexttoken . value ] === true ) { warning ( "Duplicate key '{a}'." , nexttoken , nexttoken . value ) ; } else if ( nexttoken . value === '__proto__' ) { warning ( "Stupid key '{a}'." , nexttoken , nexttoken . value ) ; } else { o [ nexttoken . value ] = true ; } advance ( ) ; advance ( ':' ) ; jsonValue ( ) ; if ( nexttoken . id !== ',' ) { break ; } advance ( ',' ) ; } } advance ( '}' ) ; } function jsonArray ( ) { var t = nexttoken ; advance ( '[' ) ; if ( nexttoken . id !== ']' ) { for ( ; ; ) { if ( nexttoken . id === '(end)' ) { error ( "Missing ']' to match '[' from line {a}." , nexttoken , t . line ) ; } else if ( nexttoken . id === ']' ) { warning ( "Unexpected comma." , token ) ; break ; } else if ( nexttoken . id === ',' ) { error ( "Unexpected comma." , nexttoken ) ; } jsonValue ( ) ; if ( nexttoken . id !== ',' ) { break ; } advance ( ',' ) ; } } advance ( ']' ) ; } switch ( nexttoken . id ) { case '{' : jsonObject ( ) ; break ; case '[' : jsonArray ( ) ; break ; case 'true' : case 'false' : case 'null' : case '(number)' : case '(string)' : advance ( ) ; break ; case '-' : advance ( '-' ) ; if ( token . character !== nexttoken . from ) { warning ( "Unexpected space after '-'." , token ) ; } adjacent ( token , nexttoken ) ; advance ( '(number)' ) ; break ; default : error ( "Expected a JSON value." , nexttoken ) ; } } 
function ( s , o ) { var a , i , k ; JSHINT . errors = [ ] ; predefined = Object . create ( standard ) ; if ( o ) { a = o . predef ; if ( a ) { if ( Array . isArray ( a ) ) { for ( i = 0 ; i < a . length ; i += 1 ) { predefined [ a [ i ] ] = true ; } } else if ( typeof a === 'object' ) { k = Object . keys ( a ) ; for ( i = 0 ; i < k . length ; i += 1 ) { predefined [ k [ i ] ] = ! ! a [ k ] ; } } } if ( o . adsafe ) { o . safe = true ; } if ( o . safe ) { o . browser = o . css = o . debug = o . devel = o . evil = o . forin = o . on = o . rhino = o . windows = o . sub = o . widget = false ; o . eqeqeq = o . nomen = o . safe = o . undef = true ; predefined . Date = predefined [ 'eval' ] = predefined . Function = predefined . Object = null ; predefined . ADSAFE = predefined . lib = false ; } option = o ; } else { option = { } ; } option . indent = option . indent || 4 ; option . maxerr = option . maxerr || 50 ; adsafe_id = '' ; adsafe_may = false ; adsafe_went = false ; approved = { } ; if ( option . approved ) { for ( i = 0 ; i < option . approved . length ; i += 1 ) { approved [ option . approved [ i ] ] = option . approved [ i ] ; } } else { approved . test = 'test' ; } tab = '' ; for ( i = 0 ; i < option . indent ; i += 1 ) { tab += ' ' ; } indent = 1 ; global = Object . create ( predefined ) ; scope = global ; funct = { '(global)' : true , '(name)' : '(global)' , '(scope)' : scope , '(breakage)' : 0 , '(loopage)' : 0 } ; functions = [ funct ] ; ids = { } ; urls = [ ] ; src = false ; xmode = false ; stack = null ; member = { } ; membersOnly = null ; implied = { } ; inblock = false ; lookahead = [ ] ; jsonmode = false ; warnings = 0 ; lex . init ( s ) ; prereg = true ; strict_mode = false ; prevtoken = token = nexttoken = syntax [ '(begin)' ] ; assume ( ) ; try { advance ( ) ; if ( nexttoken . value . charAt ( 0 ) === '<' ) { html ( ) ; if ( option . adsafe && ! adsafe_went ) { warning ( "ADsafe violation: Missing ADSAFE.go." , this ) ; } } else { switch ( nexttoken . id ) { case '{' : case '[' : option . laxbreak = true ; jsonmode = true ; jsonValue ( ) ; break ; case '@' : case '*' : case '#' : case '.' : case ':' : xmode = 'style' ; advance ( ) ; if ( token . id !== '@' || ! nexttoken . identifier || nexttoken . value !== 'charset' || token . line !== 1 || token . from !== 1 ) { error ( "A css file should begin with @charset 'UTF-8';" ) ; } advance ( ) ; if ( nexttoken . type !== '(string)' && nexttoken . value !== 'UTF-8' ) { error ( "A css file should begin with @charset 'UTF-8';" ) ; } advance ( ) ; advance ( ';' ) ; styles ( ) ; break ; default : if ( option . adsafe && option . fragment ) { error ( "Expected '{a}' and instead saw '{b}'." , nexttoken , '<div>' , nexttoken . value ) ; } if ( nexttoken . value === 'use strict' ) { warning ( "Use the function form of \"use strict\"." ) ; use_strict ( ) ; } statements ( 'lib' ) ; } } advance ( '(end)' ) ; } catch ( e ) { if ( e ) { JSHINT . errors . push ( { reason : e . message , line : e . line || nexttoken . line , character : e . character || nexttoken . from } , null ) ; } } return JSHINT . errors . length === 0 ; } 
function Node ( t , init ) { var token = t . token ; if ( token ) { 
function Statements ( t , x , n ) { try { while ( ! t . done && t . peek ( true ) !== RIGHT_CURLY ) n . push ( Statement ( t , x ) ) ; } catch ( e ) { if ( t . done ) t . unexpectedEOF = true ; throw e ; } } 
function Statement ( t , x ) { var i , label , n , n2 , p , c , ss , tt = t . get ( true ) , tt2 , x2 , x3 ; 
function LetBlock ( t , x , isStatement ) { var n , n2 ; * If this is really an expression in let statement guise, then we * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop * the return value of the expression. */ n2 = new Node ( t , { type : SEMICOLON , expression : n } ) ; isStatement = false ; } if ( isStatement ) n . block = Block ( t , x ) ; else n . expression = AssignExpression ( t , x ) ; return n ; } 
function Tokenizer ( s , f , l ) { this . cursor = 0 ; this . source = String ( s ) ; this . tokens = [ ] ; this . tokenIndex = 0 ; this . lookahead = 0 ; this . scanNewlines = false ; this . unexpectedEOF = false ; this . filename = f || "" ; this . lineno = l || 1 ; } 
function ( ) { var input = this . source ; for ( ; ; ) { var ch = input [ this . cursor ++ ] ; var next = input [ this . cursor ] ; if ( ch === '\n' && ! this . scanNewlines ) { this . lineno ++ ; } else if ( ch === '/' && next === '*' ) { this . cursor ++ ; for ( ; ; ) { ch = input [ this . cursor ++ ] ; if ( ch === undefined ) throw this . newSyntaxError ( "Unterminated comment" ) ; if ( ch === '*' ) { next = input [ this . cursor ] ; if ( next === '/' ) { this . cursor ++ ; break ; } } else if ( ch === '\n' ) { this . lineno ++ ; } } } else if ( ch === '/' && next === '/' ) { this . cursor ++ ; for ( ; ; ) { ch = input [ this . cursor ++ ] ; if ( ch === undefined ) return ; if ( ch === '\n' ) { this . lineno ++ ; break ; } } } else if ( ch !== ' ' && ch !== '\t' ) { this . cursor -- ; return ; } } } 
function ( records ) { var ghost = this . createGhost ( records ) , store = ghost . store ; store . removeAll ( ) ; store . add ( records ) ; return ghost . getEl ( ) ; } 
function init ( ) { document . addEventListener ( 'visibilitychange' , visibilityChange . bind ( this ) ) ; window . onpopstate = popState . bind ( this ) ; window . onbeforeunload = beforeUnload . bind ( this ) ; 
function visibilityChange ( ev ) { 
function activate ( that , el ) { 
function Charged ( options ) { if ( ! ( this instanceof Charged ) ) { return new Charged ( options ) ; } this . options = options ; this . subdomain = options . subdomain || options . product || options . name ; this . apiKey = options . key || options . apiKey ; this . siteKey = options . siteKey ; this . defaultFamily = options . family || options . defaultFamily ; this . smartValidation = options . smartValidation ; this . debug = options . debug ; this . retry = options . retry || 1 ; this . cache = options . cache || false ; this . cacheTTL = options . cacheTTL || 20 * 1000 ; this . cacheThreshold = options . cacheThreshold || 100 ; this . _cache = { customers : { } , subscriptions : { } , components : { } , metadata : { } , usage : { } } ; this . cacheSchemas = options . cacheSchemas ; this . _schemaCache = { components : { } , products : { } } ; if ( ! this . subdomain || ! this . apiKey ) { throw new Error ( 'Options `subdomain` and `apiKey` are required for Charged.' ) ; } } 
function formatter ( name , callback ) { return function ( err , result ) { if ( err ) return callback ( err ) ; if ( ! result ) result = { } ; 
function parse ( str , del , eq ) { if ( ! str ) return { } ; var out = { } , s = str . split ( del || '&' ) , l = s . length , i = 0 , $ ; for ( ; i < l ; i ++ ) { $ = s [ i ] . split ( eq || '=' ) ; if ( $ [ 0 ] ) { $ [ 0 ] = unescape ( $ [ 0 ] ) ; $ [ 1 ] = $ [ 1 ] ? unescape ( $ [ 1 ] ) : '' ; parse . set ( out , $ [ 0 ] , $ [ 1 ] ) ; } } return out ; } 
function ( key , done ) { var val = null ; if ( cache . hasOwnProperty ( key ) ) { val = cache [ key ] ; } return done ( null , val ) ; } 
function ( additionalRules , opts ) { if ( check ( additionalRules ) . is ( 'undefined' ) ) { return true ; } if ( check ( additionalRules ) . is . not ( 'object' ) ) { logger . warn ( 'Provide an mapping of custom rules' ) ; return false ; } _ . each ( additionalRules , function ( rule , ruleName ) { if ( check ( rule ) . is . not ( 'function' ) || check ( ruleName ) . is . not ( 'string' ) ) { logger . warn ( 'Invalid custom rule provided' ) ; return ; } rules [ ruleName ] = rule ; opts [ ruleName ] = opts [ ruleName ] || true ; } ) ; return true ; } 
function ( opts , file , encoding , callback ) { var filePath = new FilePath ( file . path ) ; results [ filePath . value ] = results [ filePath . value ] || [ ] ; _ . each ( rules , function ( rule , name ) { var response ; if ( ! opts [ name ] ) { return ; } response = rule ( filePath , opts [ name ] ) ; if ( check ( response ) . is ( 'string' ) ) { results [ filePath . value ] . push ( response ) ; } } ) ; callback ( null , file ) ; } 
function ( data ) { return _ . reduce ( data , function ( results , errors , filePath ) { if ( check ( errors ) . is . not ( 'empty' ) ) { results [ filePath ] = errors ; } return results ; } , { } ) ; } 
function unpromisify ( fn ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } var callback = function callback ( ) { } ; if ( typeof _lodash2 [ 'default' ] . last ( args ) === 'function' ) { callback = _lodash2 [ 'default' ] . last ( args ) ; args = _lodash2 [ 'default' ] . take ( args , args . length - 1 ) ; } return _bluebird2 [ 'default' ] [ 'try' ] ( function ( ) { return fn . apply ( undefined , _toConsumableArray ( args ) ) ; } ) . nodeify ( callback ) ; } ; } 
function _returnMap ( callback , file , created ) { if ( typeof file === 'string' ) { var map = foldermap . mapSync ( file ) ; Object . defineProperty ( map , '_created' , { value : created } ) ; } else { var map = { } ; for ( var i in file ) { map [ i ] = foldermap . mapSync ( file [ i ] ) ; Object . defineProperty ( map [ i ] , '_created' , { value : created } ) ; } } callback ( null , map ) ; } 
function readyCb ( cb ) { 
function compute ( value , m ) { if ( ! m ) return { } var res = { } var keys = Object . keys ( m ) for ( var i = 0 ; i < keys . length ; ++ i ) { var k = keys [ i ] var v = m [ k ] if ( v > value ) { res [ k ] = v } } 
function _filter ( f ) { var fpath = path . format ( path . parse ( path . normalize ( path . dirname ( f ) ) ) ) ; if ( fpath === fpathParsed ) return true ; return false ; } 
function filterTrackeds ( tracked , code ) { return _ . omit ( tracked , Object . keys ( tracked ) . filter ( function ( fname ) { return tracked [ fname ] . code !== code ; } ) ) ; } 
function fileStatus ( prev , stat , filename , dir , fn ) { var fullname = path . join ( dir , filename ) // is a deleted file? // is a file added? if ( prev === undefined || prev === null ) { fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 1 } ) ; return ; } var mtimeChange = stat . mtime . valueOf ( ) != prev . stats . mtime . valueOf ( ) ; var sizeChange = stat . size != prev . stats . size ; // has changes ? if ( ! mtimeChange && ! sizeChange ) { return fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 0 } ) ; } // the file has change fn && fn ( null , { stats : { mtime : stat . mtime , size : stat . size } , code : 2 } ) ; } 
function getFiles ( dir , pattern , fn ) { if ( "function" === typeof pattern ) { fn = pattern ; pattern = undefined ; } pattern = pattern || / .* / ig ; fs . readdir ( dir , function ( err , files ) { if ( err ) return fn && fn ( err ) ; async . map ( files , function ( f , cb ) { fs . stat ( path . join ( dir , f ) , function ( err , stats ) { if ( err ) return cb && cb ( err ) ; cb && cb ( null , { filename : f , stats : stats } ) } ) } , function ( err , stats ) { if ( err ) return fn && fn ( err ) ; var fstats = stats . filter ( function ( f ) { return f . stats . isFile ( ) && pattern . test ( f . filename ) ; } ) ; fn && fn ( null , fstats ) ; } ) ; } ) ; } 
function ( key , value ) { 
function ( key , value ) { var me = this , map = me . map , old ; 
function ( key ) { var me = this , value ; if ( me . containsKey ( key ) ) { value = me . map [ key ] ; delete me . map [ key ] ; -- me . length ; if ( me . hasListeners . remove ) { me . fireEvent ( 'remove' , me , key , value ) ; } return true ; } return false ; } 
function ( isKey ) { var arr = [ ] , key , map = this . map ; for ( key in map ) { if ( map . hasOwnProperty ( key ) ) { arr . push ( isKey ? key : map [ key ] ) ; } } return arr ; } 
function ( fn , scope ) { 
function ( ) { var hash = new this . self ( this . initialConfig ) , map = this . map , key ; hash . suspendEvents ( ) ; for ( key in map ) { if ( map . hasOwnProperty ( key ) ) { hash . add ( key , map [ key ] ) ; } } hash . resumeEvents ( ) ; return hash ; } 
function ( astList , context , callback ) { var retval = new Array ( astList . length ) ; asyncEach ( astList , function ( ast , i , done ) { run ( ast , context , function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; done ( ) ; } } ) ; } , callback , null , retval ) ; } 
function ( astList , context , callback ) { var retval = new Array ( 2 ) ; var i = 0 ; var getOpArgs2_callback = function ( err , val ) { if ( err ) { callback ( err ) ; } else { retval [ i ] = val ; i ++ ; if ( i >= 2 ) callback ( null , retval ) ; } } ; run ( astList [ 1 ] , context , getOpArgs2_callback ) ; run ( astList [ 2 ] , context , getOpArgs2_callback ) ; } 
function ( ed , url ) { var t = this ; 
function peekTokenNoLineTerminator ( ) { var t = peekToken ( ) ; var start = lastToken . location . end . offset ; var end = t . location . start . offset ; for ( var i = start ; i < end ; i ++ ) { var code = input . charCodeAt ( i ) ; if ( isLineTerminator ( code ) ) return null ; 
function computeSeveralSnapshotVersions ( latestVersionId ) { if ( latestVersionId < Base ) return [ ] ; var k = Math . log ( latestVersionId / Base ) / LogRate ; k = Math . floor ( k ) ; var arr = [ ] ; 
function ImmutableCoreModelView ( args ) { 
function ( ) { 
function getModelView ( modelViewName ) { 
function makeImmutable ( modelView ) { 
function makeImmutableAsynchronous ( modelView ) { 
function makeImmutableSynchronous ( modelView ) { 
function setModelViewId ( modelViewConstructor ) { 
function setModelViewInstanceId ( modelViewInstance ) { 
function parse ( serializedStore ) { var self = this , keys = _ . keys ( serializedStore ) ; _ . each ( keys , function ( key ) { var serializedData = serializedStore [ key ] , identifier = serializedData . dataStoreModelIdentifier , Model ; if ( ! _ . has ( self . registeredModelsAndCollections , identifier ) ) { throw new Error ( 'Could not deserialize DataStore because ' + 'a required model was not registered before!' ) ; } else { var metaInformation = self . registeredModelsAndCollections [ identifier ] , jsonRepresentation = serializedData . data ; if ( _ . has ( metaInformation , 'collectionClass' ) ) { var Collection = metaInformation . collectionClass , deserializedCollection = new Collection ( ) ; Model = metaInformation . modelClass ; self . set ( key , deserializedCollection ) ; for ( var i in jsonRepresentation ) { var modelJson = jsonRepresentation [ i ] ; deserializedCollection . add ( new Model ( modelJson ) ) ; } } else { Model = metaInformation ; self . set ( key , new Model ( jsonRepresentation ) ) ; } } } ) ; } 
function findOuterChar ( str , char ) { var square = 0 , curly = 0 , round = 0 , angle = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { var c = str . charAt ( i ) ; if ( c === char && square === 0 && curly === 0 && round === 0 && angle === 0 ) { return i ; } if ( c === '[' ) ++ square ; else if ( c === ']' ) -- square ; else if ( c === '{' ) ++ curly ; else if ( c === '}' ) -- curly ; else if ( c === '(' ) ++ round ; else if ( c === ')' ) -- round ; else if ( c === '<' ) ++ angle ; else if ( c === '>' ) -- angle ; if ( c === char && square === 0 && curly === 0 && round === 0 && angle === 0 ) { return i ; } } if ( square !== 0 ) _ . errout ( 'mismatched [] brackets: ' + str ) ; if ( curly !== 0 ) _ . errout ( 'mismatched {} brackets: ' + str ) ; if ( round !== 0 ) _ . errout ( 'mismatched () brackets: ' + str ) ; return - 1 ; } 
function computeParamTypes ( rel , bindingTypes , implicits , computeTypeWrapper ) { _ . assertLength ( arguments , 4 ) _ . assertArray ( implicits ) rel . params . forEach ( function ( p ) { if ( p . type === 'macro' || p . type === 'partial-application' ) { return } computeTypeWrapper ( p , bindingTypes , implicits ) } ) } 
function CI ( pull_request , branch , build_number , builder ) { this . pull_request = pull_request ; this . branch = branch ; this . build_number = build_number ; this . builder = builder ; this . GetVersion = GetVersion ; this . GetPullRequest = GetPullRequest ; this . PublishGitTag = PublishGitTag ; this . MergeDownstream = MergeDownstream ; } 
function ( sb ) { var me = this ; me . statusBar = sb ; sb . on ( { single : true , scope : me , render : me . onStatusbarRender , beforedestroy : me . destroy } ) ; sb . on ( { click : { element : 'el' , fn : me . onStatusClick , scope : me , buffer : 200 } } ) ; } 
function ( f , isValid ) { var me = this , msg ; if ( ! me . monitor ) { return false ; } msg = f . getErrors ( ) [ 0 ] ; if ( msg ) { me . errors . add ( f . id , { field : f , msg : msg } ) ; } else { me . errors . removeAtKey ( f . id ) ; } this . updateErrorList ( ) ; if ( me . errors . getCount ( ) > 0 ) { if ( me . statusBar . getText ( ) !== me . showText ) { me . statusBar . setStatus ( { text : me . showText , iconCls : me . errorIconCls } ) ; } } else { me . statusBar . clearStatus ( ) . setIcon ( me . validIconCls ) ; } } 
function ( ) { var me = this , msg , msgEl = me . getMsgEl ( ) ; if ( me . errors . getCount ( ) > 0 ) { msg = [ '<ul>' ] ; this . errors . each ( function ( err ) { msg . push ( '<li id="x-err-' , err . field . id , '"><a href="#">' , err . msg , '</a></li>' ) ; } ) ; msg . push ( '</ul>' ) ; msgEl . update ( msg . join ( '' ) ) ; } else { msgEl . update ( '' ) ; } 
function ( ) { var me = this , msgEl = me . msgEl , t ; if ( ! msgEl ) { msgEl = me . msgEl = Ext . DomHelper . append ( Ext . getBody ( ) , { cls : me . errorListCls } , true ) ; msgEl . hide ( ) ; msgEl . on ( 'click' , function ( e ) { t = e . getTarget ( 'li' , 10 , true ) ; if ( t ) { Ext . getCmp ( t . id . split ( 'x-err-' ) [ 1 ] ) . focus ( ) ; me . hideErrors ( ) ; } } , null , { stopEvent : true } ) ; 
function ( ) { var me = this ; me . updateErrorList ( ) ; me . getMsgEl ( ) . alignTo ( me . statusBar . getEl ( ) , me . listAlign ) . slideIn ( 'b' , { duration : 300 , easing : 'easeOut' } ) ; me . statusBar . setText ( me . hideText ) ; me . formPanel . body . on ( 'click' , me . hideErrors , me , { single : true } ) ; 
function ( ) { var el = this . getMsgEl ( ) ; if ( el . isVisible ( ) ) { el . slideOut ( 'b' , { duration : 300 , easing : 'easeIn' } ) ; this . statusBar . setText ( this . showText ) ; } this . formPanel . body . un ( 'click' , this . hideErrors , this ) ; } 
function ( env ) { console . log ( 'Stubbatti server version %s.' , Stubbatti . version ) ; 
function ( table , toObj ) { ! table && ( table = '' ) ; var result = table ; var tablename = table . name || table ; tablename = tablename . trim ( ) ; if ( tablename . length == 0 ) { return false ; } while ( tablename . substr ( 0 , 1 ) == '_' ) { tablename = tablename . substr ( 1 ) ; } result . name = tablename ; return toObj ? result : tablename ; } 
function ( sql ) { if ( ! sql || typeof sql != 'string' ) { return '' ; } var tmp = sql . toLowerCase ( ) ; if ( tmp . indexOf ( "select" ) != 0 && tmp . indexOf ( "update" ) != 0 && tmp . indexOf ( "insert" ) != 0 && tmp . indexOf ( "delete" ) != 0 && tmp . indexOf ( "limit" ) != 0 && tmp . indexOf ( "where" ) != 0 ) { sql = "WHERE " + sql ; } return sql ; } 
function ( type ) { 
function ( value ) { var rs ; if ( typeof value == "object" ) { rs = "JSON" ; } else if ( / ^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$ / i . test ( value ) ) { rs = dataType ( "Number" ) ; } else if ( ! isNaN ( Date . parse ( value ) ) ) { rs = dataType ( "Date" ) ; } else { rs = dataType ( typeof value ) ; } return rs ; } 
function ( data ) { var schema = { } ; if ( ! data || typeof data != 'object' ) { data = { } ; } else if ( util . isArray ( data ) ) { return getValueSchema ( data [ 0 ] ) ; } for ( var key in data ) { schema [ key ] = valueType ( data [ key ] ) ; } return schema ; } 
function ( value , type ) { if ( typeof type != "string" ) { return checkValue ( value ) ; } var rs = value ; if ( value === null ) { return null ; } switch ( type ) { case "String" : if ( ! value ) { rs = "" ; } else { rs = value . toString ( ) ; } break ; case "Number" : rs = isNaN ( parseFloat ( value ) ) ? null : parseFloat ( value ) ; break ; case "Date" : rs = isNaN ( new Date ( value ) ) ? null : new Date ( value ) ; break ; case "Boolean" : if ( typeof value == 'string' ) { value = value . toLowerCase ( ) ; } switch ( value ) { case true : case "true" : case "t" : case 1 : case "1" : rs = true ; break ; case false : case "false" : case "f" : case 0 : case "0" : rs = false ; break ; default : rs = null ; break ; } break ; case "JSON" : rs = typeof value == 'object' ? value : { } ; break ; case "Binary" : break ; } return rs ; } 
function ( data ) { var type = typeof ( data ) , rs = { } ; if ( type != 'object' ) { key = '_' + type ; rs [ key ] = data ; } else { rs = data ; } return rs ; } 
function ( value ) { var rs ; if ( / ^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$ / i . test ( value ) ) { rs = parseFloat ( value ) ; } else if ( ! isNaN ( Date . parse ( value ) ) ) { rs = new Date ( value ) ; } else { rs = value ; } return rs ; } 
function ( value , type ) { var rs ; value = value . trim ( ) ; if ( value . indexOf ( "'" ) == 0 || value . indexOf ( '"' ) == 0 ) { rs = value . substr ( 1 , value . length - 2 ) ; if ( type ) { rs = dataTransfer ( rs , type ) ; } } else { if ( type ) { rs = dataTransfer ( value , type ) ; } if ( typeof ( value ) == 'object' ) { rs = value ; } else if ( value == 'true' ) { rs = true ; } else if ( value == 'false' ) { rs = false ; } else { rs = parseFloat ( value ) ; } } return rs ; } 
function index ( req , res , next ) { 
function ( table , config ) { config = Ext . apply ( { } , config ) ; table = this . table = Ext . get ( table ) ; var configFields = config . fields || [ ] , configColumns = config . columns || [ ] , fields = [ ] , cols = [ ] , headers = table . query ( "thead th" ) , i = 0 , len = headers . length , data = table . dom , width , height , store , col , text , name ; for ( ; i < len ; ++ i ) { col = headers [ i ] ; text = col . innerHTML ; name = 'tcol-' + i ; fields . push ( Ext . applyIf ( configFields [ i ] || { } , { name : name , mapping : 'td:nth(' + ( i + 1 ) + ')/@innerHTML' } ) ) ; cols . push ( Ext . applyIf ( configColumns [ i ] || { } , { text : text , dataIndex : name , width : col . offsetWidth , tooltip : col . title , sortable : true } ) ) ; } if ( config . width ) { width = config . width ; } else { width = table . getWidth ( ) + 1 ; } if ( config . height ) { height = config . height ; } Ext . applyIf ( config , { store : { data : data , fields : fields , proxy : { type : 'memory' , reader : { record : 'tbody tr' , type : 'xml' } } } , columns : cols , width : width , height : height } ) ; this . callParent ( [ config ] ) ; if ( config . remove !== false ) { 
function weight ( word ) { return HAMMING_TABLE [ ( word >> 0x00 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x04 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x08 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x0C ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x10 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x14 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x18 ) & 0xF ] + HAMMING_TABLE [ ( word >> 0x1C ) & 0xF ] ; } 
function highest ( word ) { word |= word >> 1 ; word |= word >> 2 ; word |= word >> 4 ; word |= word >> 8 ; word |= word >> 16 ; 
function onSelection ( ev ) { 
function multiplyDuration ( startDuration , multiplier ) { if ( ! isFinite ( multiplier ) || multiplier <= 0 ) { throw new Error ( 'Invalid Multiplier' ) ; } var newDuration = { } , hasTime = false , duration = '' ; if ( startDuration . getSeconds ( ) ) { newDuration . seconds = Math . round ( startDuration . getSeconds ( ) * multiplier ) ; } if ( startDuration . getMinutes ( ) ) { newDuration . minutes = Math . round ( startDuration . getMinutes ( ) * multiplier ) ; } if ( startDuration . getHours ( ) ) { newDuration . hours = Math . round ( startDuration . getHours ( ) * multiplier ) ; } if ( startDuration . getDays ( ) ) { newDuration . days = Math . round ( startDuration . getDays ( ) * multiplier ) ; } if ( startDuration . getMonths ( ) ) { newDuration . months = Math . round ( startDuration . getMonths ( ) * multiplier ) ; } if ( startDuration . getYears ( ) ) { newDuration . years = Math . round ( startDuration . getYears ( ) * multiplier ) ; } if ( newDuration . seconds ) { hasTime = true ; duration = newDuration . seconds + 'S' + duration ; } if ( newDuration . minutes ) { hasTime = true ; duration = newDuration . minutes + 'M' + duration ; } if ( newDuration . hours ) { hasTime = true ; duration = newDuration . hours + 'H' + duration ; } if ( hasTime ) { duration = 'T' + duration ; } if ( newDuration . days ) { duration = newDuration . days + 'D' + duration ; } if ( newDuration . months ) { duration = newDuration . months + 'M' + duration ; } if ( newDuration . years ) { duration = newDuration . years + 'Y' + duration ; } if ( ! duration ) { throw new Error ( 'Invalid Duration Multiplier' ) ; } return new Duration ( 'P' + duration ) ; } 
function addDuration ( startDate , duration ) { var end = getObjFromDate ( startDate , false ) , endString = '' ; 
function getDuration ( startDate , endDate ) { if ( ! ( startDate instanceof Simple && endDate instanceof Simple ) ) { throw new Error ( 'Start and end dates must be simple dates' ) ; } var start = getObjFromDate ( startDate , true ) , end = getObjFromDate ( endDate , true ) , hasTime = false , duration = '' ; zipDates ( start , end ) ; if ( end . seconds != undefined ) { while ( end . seconds - start . seconds < 0 ) { end . minutes -= 1 ; end . seconds += 60 ; } if ( end . seconds - start . seconds > 0 ) { hasTime = true ; duration = ( '00' + ( end . seconds - start . seconds ) ) . substr ( - 2 , 2 ) + 'S' + duration ; } } if ( end . minutes != undefined ) { while ( end . minutes - start . minutes < 0 ) { end . hours -= 1 ; end . minutes += 60 ; } if ( end . minutes - start . minutes > 0 ) { hasTime = true ; duration = ( '00' + ( end . minutes - start . minutes ) ) . substr ( - 2 , 2 ) + 'M' + duration ; } } if ( end . hours != undefined ) { while ( end . hours - start . hours < 0 ) { end . day -= 1 ; end . hours += 24 ; } if ( end . hours - start . hours > 0 ) { hasTime = true ; duration = ( '00' + ( end . hours - start . hours ) ) . substr ( - 2 , 2 ) + 'H' + duration ; } } if ( hasTime ) { duration = 'T' + duration ; } if ( end . day != undefined ) { while ( end . day - start . day < 0 ) { end . day += GlobalUtil . daysInMonth ( end . month , end . year ) ; end . month -= 1 ; if ( end . month < 1 ) { end . year -= 1 ; end . month += 12 ; } } if ( end . day - start . day > 0 ) { duration = ( '00' + ( end . day - start . day ) ) . substr ( - 2 , 2 ) + 'D' + duration ; } } if ( end . month != undefined ) { while ( end . month - start . month < 0 ) { end . year -= 1 ; end . month += 12 ; } if ( end . month - start . month > 0 ) { duration = ( '00' + ( end . month - start . month ) ) . substr ( - 2 , 2 ) + 'M' + duration ; } } if ( end . year - start . year > 0 ) { duration = ( '0000' + ( end . year - start . year ) ) . substr ( - 4 , 4 ) + 'Y' + duration ; } if ( end . year - start . year < 0 || duration == '' ) { throw new Error ( 'Start Date must be less than End Date' ) ; } return new Duration ( 'P' + duration ) ; } 
function zipDates ( start , end ) { if ( start . month != undefined && end . month == undefined ) { end . month = 1 ; } if ( start . month == undefined && end . month != undefined ) { start . month = 1 ; } if ( start . day != undefined && end . day == undefined ) { end . day = 1 ; } if ( start . day == undefined && end . day != undefined ) { start . day = 1 ; } if ( start . hours != undefined && end . hours == undefined ) { end . hours = 0 ; } if ( start . hours == undefined && end . hours != undefined ) { start . hours = 0 ; } if ( start . minutes != undefined && end . minutes == undefined ) { end . minutes = 0 ; } if ( start . minutes == undefined && end . minutes != undefined ) { start . minutes = 0 ; } if ( start . seconds != undefined && end . seconds == undefined ) { end . seconds = 0 ; } if ( start . seconds == undefined && end . seconds != undefined ) { start . seconds = 0 ; } } 
function zipDuration ( date , duration ) { var toSet = { } ; if ( duration . getSeconds ( ) ) { toSet = { seconds : true , minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getMinutes ( ) ) { toSet = { minutes : true , hours : true , days : true , months : true } ; } else if ( duration . getHours ( ) ) { toSet = { hours : true , days : true , months : true } ; } else if ( duration . getDays ( ) ) { toSet = { days : true , months : true } ; } else if ( duration . getMonths ( ) ) { toSet = { months : true } ; } else { return ; } if ( toSet . seconds && date . seconds == undefined ) { date . seconds = 0 ; } if ( toSet . minutes && date . minutes == undefined ) { date . minutes = 0 ; } if ( toSet . hours && date . hours == undefined ) { date . hours = 0 ; } if ( toSet . days && date . day == undefined ) { date . day = 1 ; } if ( toSet . months && date . month == undefined ) { date . month = 1 ; } } 
function getObjFromDate ( date , adjustTimezone ) { var obj = { year : date . getYear ( ) , month : date . getMonth ( ) , day : date . getDay ( ) , hours : date . getHours ( ) , minutes : date . getMinutes ( ) , seconds : date . getSeconds ( ) } if ( adjustTimezone ) { if ( obj . minutes != undefined && date . getTZMinutes ( ) != undefined ) { obj . minutes += date . getTZMinutes ( ) ; } if ( obj . hours != undefined && date . getTZHours ( ) != undefined ) { obj . hours += date . getTZHours ( ) ; } } return obj ; } 
function Range ( str ) { var range = str ; 
function ( p ) { return me . server . getModel ( 'admin.models.access' ) . getPageRates ( null , null , null , p , rates ) } 
function ( ) { Ext . data . flash . BinaryXhr . flashPluginActive = true ; Ext . data . flash . BinaryXhr . flashPlugin = document . getElementById ( "ext-flash-polyfill" ) ; Ext . globalEvents . fireEvent ( "flashready" ) ; 
function ( javascriptId , state , data ) { var connection ; 
function ( ) { var headers = [ ] ; Ext . Object . each ( this . responseHeaders , function ( name , value ) { headers . push ( name + ': ' + value ) ; } ) ; return headers . join ( '\x0d\x0a' ) ; } 
function ( method , url , async , user , password ) { var me = this ; me . method = method ; me . url = url ; me . async = async !== false ; me . user = user ; me . password = password ; 
function ( body ) { var me = this ; me . body = body ; if ( ! Ext . data . flash . BinaryXhr . flashPluginActive ) { Ext . globalEvents . addListener ( "flashready" , me . onFlashReady , me ) ; } else { this . onFlashReady ( ) ; } } 
function ( ) { var me = this , req , status ; me . javascriptId = Ext . data . flash . BinaryXhr . registerConnection ( me ) ; 
function ( state ) { var me = this ; if ( me . readyState != state ) { me . readyState = state ; me . onreadystatechange ( ) ; } } 
function ( data ) { var me = this ; 
function ResourcesAgent ( resourcesData , language , namespace ) { if ( ! resourcesData || ( resourcesData && typeof resourcesData !== "object" ) ) { throw new Error ( "Expected ResourceData." ) ; } if ( ! language ) { throw new Error ( "Expected argument language." ) ; } if ( ! namespace ) { throw new Error ( "Expected argument namespace." ) ; } if ( ! resourcesData [ language ] ) { throw new Error ( "Resource Language '" + language + "' is not available" ) ; } if ( ! resourcesData [ language ] [ namespace ] ) { throw new Error ( "Resource Namespace '" + namespace + "' is not available" ) ; } 
function consume_sl_comment ( proc_stack ) { let comment = "//" ; proc_stack . tSkip ( 2 ) ; let done = false ; while ( ! proc_stack . tAtEnd ( ) && ! done ) { let peek = proc_stack . tPeek ( ) ; if ( peek == "\r" || peek == "\n" ) { done = true ; } else { comment += proc_stack . tAccept ( ) ; } } return comment ; } 
function consume_ml_comment ( proc_stack ) { let comment = "/*" ; proc_stack . tSkip ( 2 ) ; while ( ! proc_stack . tMatches ( "*/" ) ) { comment += proc_stack . tAccept ( ) ; } proc_stack . tSkip ( 2 ) ; comment += "*/" ; return comment ; } 
function consume_string ( proc_stack ) { let delim = proc_stack . tAccept ( ) ; let str = delim ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc_stack . tAccept ( ) ; if ( c == "\\" ) { escaping ^= 1 ; } else { if ( c == delim && ! escaping ) { done = true ; } else if ( c == "\r" || c == "\n" ) { if ( ! escaping ) { throw new SyntaxError ( ` ` ) ; } if ( c == "\r" && proc_stack . tPeek ( ) == "\n" ) { proc_stack . tSkip ( ) ; } } escaping = 0 ; } str += c ; } return str ; } 
function consume_template ( proc_stack ) { let template = "`" ; proc_stack . tSkip ( 1 ) ; let escaping = 0 ; let done = false ; while ( ! done ) { let c = proc_stack . tAccept ( ) ; if ( c == "\\" ) { escaping ^= 1 ; } else { if ( c == "`" && ! escaping ) { done = true ; } escaping = 0 ; } template += c ; } return template ; } 
function consume_directive ( proc_stack ) { let pos = proc_stack . _tGetNPos ( ) ; proc_stack . tSkip ( 5 ) ; let directive_name = proc_stack . tAcceptUntil ( "(" ) ; proc_stack . tSkip ( ) ; let args = [ ] ; do { proc_stack . tSkipWhile ( WHITESPACE ) ; let peek = proc_stack . tPeek ( ) ; if ( peek == ")" ) { break ; } let arg_val_parts = [ ] ; do { proc_stack . tSkipWhile ( WHITESPACE ) ; let matched = false ; for ( let trig of CONSUMERS_DIRECTIVE_ARG_TRIGGERS ) { if ( proc_stack . tMatches ( trig ) ) { let consumed = CONSUMERS_DIRECTIVE_ARG [ trig ] ( proc_stack ) ; if ( consumed instanceof DirectiveExpr ) { arg_val_parts . push ( consumed ) ; } else { arg_val_parts . push ( Function ( ` ${ consumed } ` ) ( ) ) ; } matched = true ; break ; } } if ( ! matched ) { throw new SyntaxError ( ` ` ) ; } proc_stack . tSkipWhile ( WHITESPACE ) ; } while ( proc_stack . tSkipIf ( "+" ) ) ; args . push ( arg_val_parts ) ; } while ( proc_stack . tSkipIf ( "," ) ) ; if ( ! proc_stack . tSkipIf ( ")" ) ) { throw new SyntaxError ( ` ` ) ; } proc_stack . tSkipIf ( ";" ) ; return new DirectiveExpr ( proc_stack , pos , directive_name , args ) ; } 
function HttpLog ( ) { var args = arguer . apply ( _constructorFormat , arguments ) ; if ( args instanceof Error ) return httpLog ( args ) ; if ( args . response instanceof Http . IncomingMessage && args . response . statusCode ) return httpLog ( args . response . statusCode , Http . STATUS_CODES [ args . response . statusCode ] ) ; if ( args . error instanceof HttpLog ) return args . error ; var log ; if ( args . error ) { log = args . error ; } else if ( args . message !== undefined || ( args . status !== undefined && args . data !== null ) || args . data ) { log = new Error ( args . message ) ; } else { return HttpLog . none ; } log . __proto__ = HttpLog . prototype ; if ( args . status !== undefined ) log . status = args . status ; log . data = args . data || { } ; return log ; } 
function getStack ( log ) { log . __gettingStack = true ; var stack = log . stack ; log . __gettingStack = false ; return stack ; } 
function ( animate ) { var me = this ; me . setVisible ( ! me . isVisible ( ) , me . anim ( animate ) ) ; return me ; } 
function ( ) { var me = this ; if ( me . isStyle ( DISPLAY , NONE ) ) { me . setStyle ( VISIBILITY , HIDDEN ) ; me . setStyle ( DISPLAY , getDisplay ( me ) ) ; 
function skipWhitespaceNodes ( e , next ) { while ( e && ( e . nodeType === 8 || ( e . nodeType === 3 && / ^[ \t\n\r]*$ / . test ( e . nodeValue ) ) ) ) { e = next ( e ) ; } return e ; } 
function isEndOfListItem ( ) { var node = ed . selection . getNode ( ) ; var validElements = 'h1,h2,h3,h4,h5,h6,p,div' ; var isLastParagraphOfLi = ed . dom . is ( node , validElements ) && node . parentNode . tagName === 'LI' && node . parentNode . lastChild === node ; return ed . selection . isCollapsed ( ) && isLastParagraphOfLi && isCursorAtEndOfContainer ( ) ; } 
function createNewLi ( ed , e ) { if ( isEnterWithoutShift ( e ) && isEndOfListItem ( ) ) { var node = ed . selection . getNode ( ) ; var li = ed . dom . create ( "li" ) ; var parentLi = ed . dom . getParent ( node , 'li' ) ; ed . dom . insertAfter ( li , parentLi ) ; 
function setCursorPositionToOriginalLi ( li ) { var list = ed . dom . getParent ( li , 'ol,ul' ) ; if ( list != null ) { var lastLi = list . lastChild ; 
function ( config ) { config = config || { } ; var me = this , pos = config . position || 'left' ; pos = pos . charAt ( 0 ) . toUpperCase ( ) + pos . substring ( 1 ) ; 
function ( err ) { if ( err ) { if ( cb . length === 1 ) { console . log ( 'cb has no error handling, throwing: ' + cb ) throw err } if(cb.length === 1){ cb(api.getView(viewId, historicalKey)) }else{*/ try { var view = api . getView ( viewId ) } catch ( e ) { console . log ( 'ERROR during api.getView' ) console . log ( e . stack ) return } try { cb ( undefined , view ) 
function ( ed , cm , n ) { var le , p ; le = this . _getParentLayer ( n ) ; p = ed . dom . getParent ( n , 'DIV,P,IMG' ) ; if ( ! p ) { cm . setDisabled ( 'absolute' , 1 ) ; cm . setDisabled ( 'moveforward' , 1 ) ; cm . setDisabled ( 'movebackward' , 1 ) ; } else { cm . setDisabled ( 'absolute' , 0 ) ; cm . setDisabled ( 'moveforward' , ! le ) ; cm . setDisabled ( 'movebackward' , ! le ) ; cm . setActive ( 'absolute' , le && le . style . position . toLowerCase ( ) == "absolute" ) ; } } 
function ( ed , e , s ) { var dom = ed . dom ; tinymce . each ( dom . select ( 'div,p' , e ) , function ( e ) { if ( / ^(absolute|relative|fixed)$ / i . test ( e . style . position ) ) { if ( s ) dom . addClass ( e , 'mceItemVisualAid' ) ; else dom . removeClass ( e , 'mceItemVisualAid' ) ; dom . addClass ( e , 'mceItemLayer' ) ; } } ) ; } 
function Static ( app , root , opts ) { app . properties [ SERVER . Capabilities ] [ STATIC . CAPABILITY ] = { } ; app . properties [ SERVER . Capabilities ] [ STATIC . CAPABILITY ] [ SERVER . Version ] = packageVersion ; opts = opts || { } ; 
function listener ( bot ) { return function ( buffer ) { var line = buffer . toString ( ) ; var truncatedLine = line . slice ( 0 , line . length - 1 ) ; if ( current_actions && ! isNaN ( parseInt ( truncatedLine ) ) && parseInt ( truncatedLine ) < current_actions . length ) { var action = current_actions [ parseInt ( truncatedLine ) ] ; current_actions = null ; if ( typeof action === "string" ) { bot ( platform , { sessionId : sessionId } , { type : 'action' , message : action , action : action } , oncomplete ) ; } else if ( action . url ) { request ( action . url , function ( error , response , body ) { var article = unfluff ( body ) ; console . log ( bot_name + ' > Processed Body For ' + article . title ) ; console . log ( '\n' + article . text + '\n' ) ; oncomplete ( null , null , null , function ( ) { } ) ; } ) ; } else { bot ( platform , { sessionId : sessionId } , { type : 'action' , message : '' + action . payload , action : action . payload } , oncomplete ) ; } } else { current_actions = null ; bot ( platform , { sessionId : sessionId } , { type : 'message' , message : truncatedLine } , oncomplete ) ; } } ; } 
function ( obj , event , callback ) { 
function ( obj , event , callback ) { 
function ( obj , event , args ) { 
function ( obj , event , callback ) { 
function ( uuid ) { if ( ! uuid . match ( UUID . rvalid ) ) { 
function ( c ) { 
function ( list , func ) { list = list || [ ] ; func = func || function ( ) { return false ; } ; for ( var i = 0 , l = list . length ; i < l ; i ++ ) { if ( func ( list [ i ] ) ) { return i ; } } return - 1 ; } 
function ( ) { return underscore . reduce ( arguments , function ( first , second ) { return underscore . union ( underscore . difference ( first , second ) , underscore . difference ( second , first ) ) ; } ) ; } 
function ( object , path , value , overwrite ) { overwrite = overwrite || false ; value = value || null ; 
function ( obj ) { if ( ! obj ) { obj = promise ; } else { for ( var key in promise ) { obj [ key ] = promise [ key ] ; } } return obj ; } 
function ( config ) { var me = this , comp ; if ( arguments . length === 2 ) { 
function ( store , initial ) { var me = this ; me . mixins . bindable . bindStore . apply ( me , arguments ) ; store = me . store ; if ( store && store . isLoading ( ) ) { me . onBeforeLoad ( ) ; } } 
function callback ( key , err , result ) { delete waiting [ key ] ; results [ key ] = result ; context . log ( err ) ; checkDone ( ) ; } 
function getServerOnlyFiles ( ) { var files = fs . readdirSync ( path . join ( __dirname ) ) ; _ . each ( files , function ( file , i ) { files [ i ] = path . join ( __dirname , file ) ; } ) ; return files ; } 
function prepareBrowserify ( app , options ) { if ( ! _ . has ( options , 'mainFile' ) || ! _ . has ( options , 'url' ) ) { throw new Error ( 'Missing "mainFile" and "url" property.' ) ; } var mainFile = options . mainFile , url = options . url , exclude = options . exclude || [ ] , browserifyOptions ; exclude = exclude . concat ( getServerOnlyFiles ( ) ) ; browserifyOptions = { ignore : exclude } ; _ . extend ( browserifyOptions , _ . omit ( options , [ 'mainFile' , 'exclude' ] ) ) ; _ . defaults ( browserifyOptions , { debug : false , gzip : true , minify : true } ) ; app . get ( url , browserify ( mainFile , browserifyOptions ) ) ; } 
function start ( Router , APIAdapter , startOptions ) { debug ( 'Starting server' ) ; if ( ! _ . has ( startOptions , 'app' ) ) { throw new Error ( 'Missing "app" property in "startOptions"! Please ' + 'pass a valid express app instance when starting the barefoot ' + 'router on the server.' ) ; } if ( ! _ . has ( startOptions , 'mainJavaScriptFile' ) ) { throw new Error ( 'Missing "mainJavaScriptFile" property in ' + '"startOptions"! Please describe how browserify should serve your' + ' applications code.' ) ; } var app = startOptions . app , apiAdapter ; if ( _ . has ( startOptions , 'setupMiddlewares' ) ) { startOptions . setupMiddlewares ( app ) ; } if ( _ . has ( startOptions , 'setupApiAdapter' ) ) { apiAdapter = new APIAdapter ( startOptions ) ; startOptions . setupApiAdapter ( apiAdapter ) ; if ( ! _ . isUndefined ( apiAdapter , 'sync' ) ) { Backbone . sync = function ( ) { return apiAdapter . sync . apply ( apiAdapter , arguments ) ; } ; } startOptions . apiAdapter = apiAdapter ; } prepareBrowserify ( app , startOptions . mainJavaScriptFile ) ; 
function ( events ) { var me = this , i , event , stateEventsByName ; if ( me . stateful && me . getStateId ( ) ) { if ( typeof events == 'string' ) { events = Array . prototype . slice . call ( arguments , 0 ) ; } stateEventsByName = me . stateEventsByName || ( me . stateEventsByName = { } ) ; for ( i = events . length ; i -- ; ) { event = events [ i ] ; if ( ! stateEventsByName [ event ] ) { stateEventsByName [ event ] = 1 ; me . on ( event , me . onStateChange , me ) ; } } } } 
function ( ) { var me = this , delay = me . saveDelay , statics , runner ; if ( ! me . stateful ) { return ; } if ( delay ) { if ( ! me . stateTask ) { statics = Ext . state . Stateful ; runner = statics . runner || ( statics . runner = new Ext . util . TaskRunner ( ) ) ; me . stateTask = runner . newTask ( { run : me . saveState , scope : me , interval : delay , repeat : 1 } ) ; } me . stateTask . start ( ) ; } else { me . saveState ( ) ; } } 
function ( ) { var me = this , id = me . stateful && me . getStateId ( ) , hasListeners = me . hasListeners , state ; if ( id ) { state = Ext . state . Manager . get ( id ) ; if ( state ) { state = Ext . apply ( { } , state ) ; if ( ! hasListeners . beforestaterestore || me . fireEvent ( 'beforestaterestore' , me , state ) !== false ) { me . applyState ( state ) ; if ( hasListeners . staterestore ) { me . fireEvent ( 'staterestore' , me , state ) ; } } } } } 
function ( propName , state , stateName ) { var me = this , value = me [ propName ] , config = me . initialConfig ; if ( me . hasOwnProperty ( propName ) ) { if ( ! config || config [ propName ] !== value ) { if ( state ) { state [ stateName || propName ] = value ; } return true ; } } return false ; } 
function ( propNames , state ) { var me = this , i , n ; if ( typeof propNames == 'string' ) { me . savePropToState ( propNames , state ) ; } else { for ( i = 0 , n = propNames . length ; i < n ; ++ i ) { me . savePropToState ( propNames [ i ] , state ) ; } } return state ; } 
function ( ) { var me = this , task = me . stateTask ; if ( task ) { task . destroy ( ) ; me . stateTask = null ; } me . clearListeners ( ) ; } 
function ( element , styleName ) { var view = element . ownerDocument . defaultView , style = ( view ? view . getComputedStyle ( element , null ) : element . currentStyle ) || element . style ; return style [ styleName ] ; } 
function ( ) { var me = this , doc = document , toRun = me . toRun || me . tests , n = toRun . length , div = n && Ext . isReady && doc . createElement ( 'div' ) , notRun = [ ] , browserKey = getBrowserKey ( ) , test , vector , value ; if ( div ) { div . innerHTML = [ '<div style="height:30px;width:50px;">' , '<div style="height:20px;width:20px;"></div>' , '</div>' , '<div style="width: 200px; height: 200px; position: relative; padding: 5px;">' , '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>' , '</div>' , '<div style="position: absolute; left: 10%; top: 10%;"></div>' , '<div style="float:left; background-color:transparent;"></div>' ] . join ( '' ) ; doc . body . appendChild ( div ) ; } vector = supportsVectors [ browserKey ] ; while ( n -- ) { test = toRun [ n ] ; value = vector && vector [ n ] ; if ( value !== undefined ) { me [ test . identity ] = value ; } else if ( div || test . early ) { me [ test . identity ] = test . fn . call ( me , doc , div ) ; } else { notRun . push ( test ) ; } } if ( div ) { doc . body . removeChild ( div ) ; } me . toRun = notRun ; } 
function ( ) { var tests = this . tests , vector = [ ] , i = 0 , ln = tests . length , test ; for ( ; i < ln ; i ++ ) { test = tests [ i ] ; vector . push ( this [ test . identity ] ? 1 : 0 ) ; } return vector ; } 
function ( ) { var me = this ; if ( ! me . active ) { me . active = new Date ( ) ; me . startTime = me . getTime ( ) ; me . onStart ( ) ; me . fireEvent ( 'start' , me ) ; } } 
function ( ) { var me = this ; if ( me . active ) { me . active = null ; me . onStop ( ) ; me . fireEvent ( 'stop' , me ) ; } } 
function enter ( node , parent ) { if ( ! node . body ) return ; for ( var i = 0 ; i < node . body . length ; i ++ ) { 
function parseComment ( comment , append ) { 
function parseExampleLine ( left , right , result ) { if ( ! left || ! right ) return false ; 
function splitLines ( comment ) { if ( ! comment || ! ( comment = comment [ 1 ] ) ) return '' ; var result = comment . split ( '\n' ) , line ; for ( var i in result ) { 
function matchIdentifierName ( name ) { var noid = identifier ( ) . replace ( '[' , '[^' ) ; noid = '(^|$|' + noid + ')' ; return noid + name + noid ; } 
function ( v , meta , record , rowIdx , colIdx , store , view ) { var me = this , prefix = Ext . baseCSSPrefix , scope = me . origScope || me , items = me . items , len = items . length , i = 0 , item , ret , disabled , tooltip ; 
function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . isNumber ( index ) ) { index = Ext . Array . indexOf ( me . items , index ) ; } me . items [ index ] . disabled = false ; me . up ( 'tablepanel' ) . el . select ( '.' + Ext . baseCSSPrefix + 'action-col-' + index ) . removeCls ( me . disabledCls ) ; if ( ! silent ) { me . fireEvent ( 'enable' , me ) ; } } 
function ( index , silent ) { var me = this ; if ( ! index ) { index = 0 ; } else if ( ! Ext . isNumber ( index ) ) { index = Ext . Array . indexOf ( me . items , index ) ; } me . items [ index ] . disabled = true ; me . up ( 'tablepanel' ) . el . select ( '.' + Ext . baseCSSPrefix + 'action-col-' + index ) . addCls ( me . disabledCls ) ; if ( ! silent ) { me . fireEvent ( 'disable' , me ) ; } } 
function ( ) { var me = this , type = me . inputType , inputId = me . getInputId ( ) , data ; data = Ext . apply ( { id : inputId , cmpId : me . id , name : me . name || inputId , disabled : me . disabled , readOnly : me . readOnly , value : me . getRawValue ( ) , type : type , fieldCls : me . fieldCls , fieldStyle : me . getFieldStyle ( ) , tabIdx : me . tabIndex , inputCls : me . inputCls , typeCls : Ext . baseCSSPrefix + 'form-' + ( type === 'password' ? 'text' : type ) } , me . subTplData ) ; me . getInsertionRenderData ( data , me . subTplInsertions ) ; return data ; } 
function ( style ) { var me = this , inputEl = me . inputEl ; if ( inputEl ) { inputEl . applyStyles ( style ) ; } me . fieldStyle = style ; } 
function ( ) { var me = this , data = null , val ; if ( ! me . disabled && me . submitValue && ! me . isFileUpload ( ) ) { val = me . getSubmitValue ( ) ; if ( val !== null ) { data = { } ; data [ me . getName ( ) ] = val ; } } return data ; } 
function ( ) { var me = this , v = ( me . inputEl ? me . inputEl . getValue ( ) : Ext . value ( me . rawValue , '' ) ) ; me . rawValue = v ; return v ; } 
function ( ) { var me = this , val = me . rawToValue ( me . processRawValue ( me . getRawValue ( ) ) ) ; me . value = val ; return val ; } 
function ( value ) { var me = this ; me . setRawValue ( me . valueToRaw ( value ) ) ; return me . mixins . field . setValue . call ( me , value ) ; } 
function ( ) { var me = this , inputEl = me . inputEl ; me . callParent ( ) ; if ( inputEl ) { inputEl . dom . disabled = true ; if ( me . hasActiveError ( ) ) { 
function ( ) { var me = this , inputEl = me . inputEl ; me . callParent ( ) ; if ( inputEl ) { inputEl . dom . disabled = false ; if ( me . needsValidateOnEnable ) { delete me . needsValidateOnEnable ; 
function ( readOnly ) { var me = this , inputEl = me . inputEl ; readOnly = ! ! readOnly ; me [ readOnly ? 'addCls' : 'removeCls' ] ( me . readOnlyCls ) ; me . readOnly = readOnly ; if ( inputEl ) { inputEl . dom . readOnly = readOnly ; } else if ( me . rendering ) { me . setReadOnlyOnBoxReady = true ; } me . fireEvent ( 'writeablechange' , me , readOnly ) ; } 
function ( ) { var me = this , inputEl = me . inputEl , onChangeTask , onChangeEvent , events = me . checkChangeEvents , e , eLen = events . length , event ; 
function ( ) { var me = this , disabled = me . disabled , validate = me . forceValidation || ! disabled ; return validate ? me . validateValue ( me . processRawValue ( me . getRawValue ( ) ) ) : disabled ; } 
function ( value ) { var me = this , errors = me . getErrors ( value ) , isValid = Ext . isEmpty ( errors ) ; if ( ! me . preventMark ) { if ( isValid ) { me . clearInvalid ( ) ; } else { me . markInvalid ( errors ) ; } } return isValid ; } 
function ( errors ) { 
function ( active ) { var me = this , msgTarget = me . msgTarget , prop ; if ( me . rendered ) { if ( msgTarget == 'title' || msgTarget == 'qtip' ) { if ( me . rendered ) { prop = msgTarget == 'qtip' ? 'data-errorqtip' : 'title' ; } me . getActionEl ( ) . dom . setAttribute ( prop , active || '' ) ; } else { me . updateLayout ( ) ; } } } 
function ( filePath , opts ) { if ( filePath . isDirectory ) { return true ; } if ( ! check ( opts ) . has ( 'ignore' ) || check ( opts . ignore ) . is . not ( 'array' ) ) { return false ; } return opts . ignore . some ( function ( directory ) { return _ . isString ( directory ) && directory === filePath . relative || _ . isRegExp ( directory ) && directory . test ( filePath . relative ) ; } ) ; } 
function ( sorters , direction , where , doSort ) { var me = this , sorter , newSorters ; if ( Ext . isArray ( sorters ) ) { doSort = where ; where = direction ; newSorters = sorters ; } else if ( Ext . isObject ( sorters ) ) { doSort = where ; where = direction ; newSorters = [ sorters ] ; } else if ( Ext . isString ( sorters ) ) { sorter = me . sorters . get ( sorters ) ; if ( ! sorter ) { sorter = { property : sorters , direction : direction } ; newSorters = [ sorter ] ; } else if ( direction === undefined ) { sorter . toggle ( ) ; } else { sorter . setDirection ( direction ) ; } } if ( newSorters && newSorters . length ) { newSorters = me . decodeSorters ( newSorters ) ; if ( Ext . isString ( where ) ) { if ( where === 'prepend' ) { me . sorters . insert ( 0 , newSorters ) ; } else { me . sorters . addAll ( newSorters ) ; } } else { me . sorters . clear ( ) ; me . sorters . addAll ( newSorters ) ; } } if ( doSort !== false ) { me . fireEvent ( 'beforesort' , me , newSorters ) ; me . onBeforeSort ( newSorters ) ; sorters = me . sorters . items ; if ( sorters . length ) { 
function ( ) { var sorters = this . sorters . items , len = sorters . length , i = 0 , sorter ; for ( ; i < len ; ++ i ) { sorter = sorters [ i ] ; if ( ! sorter . isGrouper ) { return sorter ; } } return null ; } 
function ( err ) { err = err || { } ; if ( Ext . isString ( err ) ) { err = { msg : err } ; } var method = this . raise . caller , msg ; if ( method ) { if ( method . $name ) { err . sourceMethod = method . $name ; } if ( method . $owner ) { err . sourceClass = method . $owner . $className ; } } if ( Ext . Error . handle ( err ) !== true ) { msg = Ext . Error . prototype . toString . call ( err ) ; Ext . log ( { msg : msg , level : 'error' , dump : err , stack : true } ) ; throw new Ext . Error ( err ) ; } } 
function ( ) { var me = this , className = me . sourceClass ? me . sourceClass : '' , methodName = me . sourceMethod ? '.' + me . sourceMethod + '(): ' : '' , msg = me . msg || '(No description provided)' ; return className + methodName + msg ; } 
function booleanF ( bindings ) { var value = valueExpr ( bindings ) value = ! ! value 
function saveEdit ( typeCode , id , op , e , syncId , timestamp ) { _ . assertNumber ( timestamp ) _ . assertInt ( op ) if(e.id < 0) e.id = translateTemporary(e.id, syncId) }else if(op === editCodes.selectSubObject){ if(e.id < 0) e.id = translateTemporary(e.id, syncId) }else if(op === editCodes.selectObjectKey){ if(e.key < 0) e.key = translateTemporary(e.key, syncId) }*/ if ( currentId !== id && id !== - 1 ) { ap . selectTopObject ( { id : id } ) 
function getPreviewCss ( ed , fmt ) { var name , previewElm , dom = ed . dom , previewCss = '' , parentFontSize , previewStylesName ; previewStyles = ed . settings . preview_styles ; // No preview forced if ( previewStyles === false ) return '' ; // Default preview if ( ! previewStyles ) previewStyles = 'font-family font-size font-weight text-decoration text-transform color background-color' ; // Removes any variables since these can't be previewed function removeVars ( val ) { return val . replace ( / %(\w+) / g , '' ) ; } ; // Create block/inline element to use for preview name = fmt . block || fmt . inline || 'span' ; previewElm = dom . create ( name ) ; // Add format styles to preview element each ( fmt . styles , function ( value , name ) { value = removeVars ( value ) ; if ( value ) dom . setStyle ( previewElm , name , value ) ; } ) ; // Add attributes to preview element each ( fmt . attributes , function ( value , name ) { value = removeVars ( value ) ; if ( value ) dom . setAttrib ( previewElm , name , value ) ; } ) ; // Add classes to preview element each ( fmt . classes , function ( value ) { value = removeVars ( value ) ; if ( ! dom . hasClass ( previewElm , value ) ) dom . addClass ( previewElm , value ) ; } ) ; // Add the previewElm outside the visual area dom . setStyles ( previewElm , { position : 'absolute' , left : - 0xFFFF } ) ; ed . getBody ( ) . appendChild ( previewElm ) ; // Get parent container font size so we can compute px values out of em/% for older IE:s parentFontSize = dom . getStyle ( ed . getBody ( ) , 'fontSize' , true ) ; parentFontSize = / px$ / . test ( parentFontSize ) ? parseInt ( parentFontSize , 10 ) : 0 ; each ( previewStyles . split ( ' ' ) , function ( name ) { var value = dom . getStyle ( previewElm , name , true ) ; // If background is transparent then check if the body has a background color we can use if ( name == 'background-color' && / transparent|rgba\s*\([^)]+,\s*0\) / . test ( value ) ) { value = dom . getStyle ( ed . getBody ( ) , name , true ) ; // Ignore white since it's the default color, not the nicest fix if ( dom . toHex ( value ) . toLowerCase ( ) == '#ffffff' ) { return ; } } // Old IE won't calculate the font size so we need to do that manually if ( name == 'font-size' ) { if ( / em|%$ / . test ( value ) ) { if ( parentFontSize === 0 ) { return ; } // Convert font size from em/% to px value = parseFloat ( value , 10 ) / ( / %$ / . test ( value ) ? 100 : 1 ) ; value = ( value * parentFontSize ) + 'px' ; } } previewCss += name + ':' + value + ';' ; } ) ; dom . remove ( previewElm ) ; return previewCss ; } 
function ( s , tb , o , p ) { var t = this , ed = t . editor , lo = s . theme_advanced_toolbar_location , sl = s . theme_advanced_statusbar_location , n , ic , etb , c ; if ( s . readonly ) { n = DOM . add ( tb , 'tr' ) ; n = ic = DOM . add ( n , 'td' , { 'class' : 'mceIframeContainer' } ) ; return ic ; } // Create toolbar container at top if ( lo == 'top' ) t . _addToolbars ( tb , o ) ; // Create external toolbar if ( lo == 'external' ) { n = c = DOM . create ( 'div' , { style : 'position:relative' } ) ; n = DOM . add ( n , 'div' , { id : ed . id + '_external' , 'class' : 'mceExternalToolbar' } ) ; DOM . add ( n , 'a' , { id : ed . id + '_external_close' , href : 'javascript:;' , 'class' : 'mceExternalClose' } ) ; n = DOM . add ( n , 'table' , { id : ed . id + '_tblext' , cellSpacing : 0 , cellPadding : 0 } ) ; etb = DOM . add ( n , 'tbody' ) ; if ( p . firstChild . className == 'mceOldBoxModel' ) p . firstChild . appendChild ( c ) ; else p . insertBefore ( c , p . firstChild ) ; t . _addToolbars ( etb , o ) ; ed . onMouseUp . add ( function ( ) { var e = DOM . get ( ed . id + '_external' ) ; DOM . show ( e ) ; DOM . hide ( lastExtID ) ; var f = Event . add ( ed . id + '_external_close' , 'click' , function ( ) { DOM . hide ( ed . id + '_external' ) ; Event . remove ( ed . id + '_external_close' , 'click' , f ) ; return false ; } ) ; DOM . show ( e ) ; DOM . setStyle ( e , 'top' , 0 - DOM . getRect ( ed . id + '_tblext' ) . h - 1 ) ; // Fixes IE rendering bug DOM . hide ( e ) ; DOM . show ( e ) ; e . style . filter = '' ; lastExtID = ed . id + '_external' ; e = null ; } ) ; } if ( sl == 'top' ) t . _addStatusBar ( tb , o ) ; // Create iframe container if ( ! s . theme_advanced_toolbar_container ) { n = DOM . add ( tb , 'tr' ) ; n = ic = DOM . add ( n , 'td' , { 'class' : 'mceIframeContainer' } ) ; } // Create toolbar container at bottom if ( lo == 'bottom' ) t . _addToolbars ( tb , o ) ; if ( sl == 'bottom' ) t . _addStatusBar ( tb , o ) ; return ic ; } 
function HTTPError ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( ! ( this instanceof HTTPError ) ) { var self = new HTTPError ( ) ; return FUNCTION ( self ) . apply ( self , args ) ; } var headers , msg , code ; ARRAY ( args ) . forEach ( function HTTPError_foreach ( arg ) { if ( typeof arg === 'object' ) { headers = arg ; } if ( typeof arg === 'string' ) { msg = arg ; } if ( typeof arg === 'number' ) { code = arg ; } } ) ; code = code || 500 ; msg = msg || ( '' + code + ' ' + require ( 'http' ) . STATUS_CODES [ code ] ) ; headers = headers || { } ; Error . call ( this ) ; Error . captureStackTrace ( this , this ) ; this . code = code ; this . message = msg ; this . headers = headers ; } 
function ( ) { var me = this , strategies = me . labelStrategies , labelAlign = me . owner . labelAlign ; return strategies [ labelAlign ] || strategies . base ; } 
function ( ) { var me = this , owner = me . owner , strategies = me . errorStrategies , msgTarget = owner . msgTarget ; return ! owner . preventMark && Ext . isString ( msgTarget ) ? ( strategies [ msgTarget ] || strategies . elementId ) : strategies . none ; } 
function ( ) { var tip = this . tip ; if ( ! tip ) { tip = this . tip = Ext . create ( 'Ext.tip.QuickTip' , { ui : 'form-invalid' } ) ; tip . tagConfig = Ext . apply ( { } , { attribute : 'errorqtip' } , tip . tagConfig ) ; } } 
function ( ) { var doc = me . getDoc ( ) ; if ( doc . body || doc . readyState === 'complete' ) { Ext . TaskManager . stop ( task ) ; me . setDesignMode ( true ) ; Ext . defer ( me . initEditor , 10 , me ) ; } } 
function ( sourceEditMode ) { var me = this , iframe = me . iframeEl , textarea = me . textareaEl , hiddenCls = Ext . baseCSSPrefix + 'hidden' , btn = me . getToolbar ( ) . getComponent ( 'sourceedit' ) ; if ( ! Ext . isBoolean ( sourceEditMode ) ) { sourceEditMode = ! me . sourceEditMode ; } me . sourceEditMode = sourceEditMode ; if ( btn . pressed !== sourceEditMode ) { btn . toggle ( sourceEditMode ) ; } if ( sourceEditMode ) { me . disableItems ( true ) ; me . syncValue ( ) ; iframe . addCls ( hiddenCls ) ; textarea . removeCls ( hiddenCls ) ; textarea . dom . removeAttribute ( 'tabIndex' ) ; textarea . focus ( ) ; me . inputEl = textarea ; } else { if ( me . initialized ) { me . disableItems ( me . readOnly ) ; } me . pushValue ( ) ; iframe . removeCls ( hiddenCls ) ; textarea . addCls ( hiddenCls ) ; textarea . dom . setAttribute ( 'tabIndex' , - 1 ) ; me . deferFocus ( ) ; me . inputEl = iframe ; } me . fireEvent ( 'editmodechange' , me , sourceEditMode ) ; me . updateLayout ( ) ; } 
function ( ) { var me = this , i , l , btns , doc , name , queriedName , fontSelect , toolbarSubmenus ; if ( me . readOnly ) { return ; } if ( ! me . activated ) { me . onFirstFocus ( ) ; return ; } btns = me . getToolbar ( ) . items . map ; doc = me . getDoc ( ) ; if ( me . enableFont && ! Ext . isSafari2 ) { 
function ( cmd , value ) { Ext . defer ( function ( ) { var me = this ; if ( ! this . isDestroyed ) { me . win . focus ( ) ; me . execCmd ( cmd , value ) ; me . updateToolbar ( ) ; } } , 10 , this ) ; } 
function ( cmd , value ) { var me = this , doc = me . getDoc ( ) ; doc . execCommand ( cmd , false , ( value == undefined ? null : value ) ) ; me . syncValue ( ) ; } 
function ( text ) { var me = this , range ; if ( me . activated ) { me . win . focus ( ) ; if ( Ext . isIE ) { range = me . getDoc ( ) . selection . createRange ( ) ; if ( range ) { range . pasteHTML ( text ) ; me . syncValue ( ) ; me . deferFocus ( ) ; } } else { me . execCmd ( 'InsertHTML' , text ) ; me . deferFocus ( ) ; } } } 
function getLevelStr ( opts ) { var lvlStr = _ . invert ( LEVELS ) [ opts . level ] , useColours = opts . colourise || true ; if ( useColours ) { switch ( opts . level ) { case LEVELS . DBG : lvlStr = colours . magenta ( lvlStr ) ; break ; case LEVELS . INF : lvlStr = colours . green ( lvlStr ) ; break ; case LEVELS . WRN : lvlStr = colours . yellow ( lvlStr ) ; break ; case LEVELS . ERR : lvlStr = colours . red ( lvlStr ) ; break ; } } return lvlStr ; } 
function ( input ) { this . reset ( ) ; 
function ( type ) { var ctl = { type : type } ; var idx = this . form . controls . length ; var id = this . form . signature + ':' + idx ; ctl . id = 'c-' + utils . sha256 ( id ) . substring ( 0 , 8 ) ; this . form . controls . push ( ctl ) ; return ctl ; } 
function ( ctl ) { var len = ctl . items && ctl . items . length ; return utils . sha256 ( ctl . id + ':' + len ) . substring ( 0 , 8 ) ; } 
function ( attrs ) { for ( var k in attrs ) if ( attrs . hasOwnProperty ( k ) ) this . out . push ( ' ' + k + '="' + attrs [ k ] + '"' ) ; } 
function ( walk ) { var _super = BlockCompiler . prototype . emitParagraph . bind ( this ) ; if ( this . tryGroup ( 'checkbox' , walk ) ) return ; if ( this . tryGroup ( 'radio' , walk ) ) return ; if ( this . trySortableGroup ( walk ) ) return ; if ( this . tryAssociativeGroup ( walk ) ) return ; return _super ( walk ) ; } 
function ( type , walk ) { if ( ! this . atGroupMarker ( type , walk ) ) return false ; 
function ( type , walk ) { var ctl = this . createCtl ( type + 'Group' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( ! walk . at ( '^ ' ) ) return false ; 
function ( walk ) { var ctl = this . createCtl ( 'sortableGroup' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( ! walk . at ( '@ ' ) ) return false ; 
function ( walk ) { var i , item ; var ctl = this . createCtl ( 'associativeGroup' ) ; ctl . items = [ ] ; 
function ( walk ) { if ( this . emitText ( walk ) ) return ; if ( this . tryInputText ( walk ) ) return ; if ( this . tryInputRegex ( walk ) ) return ; if ( this . tryInputTextWithDefault ( walk ) ) return ; if ( this . trySelectMenu ( walk ) ) return ; var _super = InlineCompiler . prototype . emitNormal . bind ( this ) ; return _super ( walk ) ; } 
function ( walk ) { if ( ! walk . at ( '{{' ) ) return false ; var endIdx = walk . indexOf ( '}}' ) ; if ( endIdx === null ) return false ; 
function ( walk ) { if ( ! walk . at ( '{{' ) ) return false ; var endIdx = walk . indexOf ( ']}' ) ; if ( endIdx === null ) return false ; var str = walk . substring ( walk . position + 2 , endIdx ) ; var data = str . split ( '}[' ) ; if ( data . length != 2 ) return false ; var size = data [ 0 ] . length ; var value = data [ 0 ] . trim ( ) ; var defaultValue = data [ 1 ] . trim ( ) ; if ( ! defaultValue ) return false ; var ctl = this . formCompiler . createCtl ( 'inputText' ) ; ctl . value = value ; ctl . defaultValue = defaultValue ; this . out . push ( '<input' ) ; this . emitAttrs ( { id : ctl . id , name : ctl . id , class : ctl . type , type : 'text' , size : size , value : defaultValue } ) ; this . out . push ( '/>' ) ; walk . startFrom ( endIdx ) . skip ( 2 ) ; } 
function ( walk ) { if ( ! walk . at ( '{/' ) ) return false ; var endIdx = walk . indexOf ( '}' ) ; if ( endIdx === null ) return false ; var source = walk . substring ( walk . position , endIdx + 1 ) ; 
function ( walk ) { if ( ! walk . at ( '({' ) ) return false ; var endIdx = walk . indexOf ( '})' ) ; if ( endIdx === null ) return false ; 
function ( ) { 
function ( ) { var values = this . getValue ( ) , key ; for ( key in values ) { if ( values [ key ] !== undefined ) { return true ; } } return false ; } 
function ( record ) { var val = record . get ( this . dataIndex ) , values = this . getValue ( ) , isNumber = Ext . isNumber ; if ( isNumber ( values . eq ) && val != values . eq ) { return false ; } if ( isNumber ( values . lt ) && val >= values . lt ) { return false ; } if ( isNumber ( values . gt ) && val <= values . gt ) { return false ; } return true ; } 
function ( ) { var right = this . statusAlign === 'right' ; this . callParent ( arguments ) ; this . currIconCls = this . iconCls || this . defaultIconCls ; this . statusEl = Ext . create ( 'Ext.toolbar.TextItem' , { cls : 'x-status-text ' + ( this . currIconCls || '' ) , text : this . text || this . defaultText || '' } ) ; if ( right ) { this . cls += ' x-status-right' ; this . add ( '->' ) ; this . add ( this . statusEl ) ; } else { this . insert ( 0 , this . statusEl ) ; this . insert ( 1 , '->' ) ; } } 
function ( o ) { var me = this ; o = o || { } ; Ext . suspendLayouts ( ) ; if ( Ext . isString ( o ) ) { o = { text : o } ; } if ( o . text !== undefined ) { me . setText ( o . text ) ; } if ( o . iconCls !== undefined ) { me . setIcon ( o . iconCls ) ; } if ( o . clear ) { var c = o . clear , wait = me . autoClear , defaults = { useDefaults : true , anim : true } ; if ( Ext . isObject ( c ) ) { c = Ext . applyIf ( c , defaults ) ; if ( c . wait ) { wait = c . wait ; } } else if ( Ext . isNumber ( c ) ) { wait = c ; c = defaults ; } else if ( Ext . isBoolean ( c ) ) { c = defaults ; } c . threadId = this . activeThreadId ; Ext . defer ( me . clearStatus , wait , me , [ c ] ) ; } Ext . resumeLayouts ( true ) ; return me ; } 
function ( o ) { o = o || { } ; var me = this , statusEl = me . statusEl ; if ( o . threadId && o . threadId !== me . activeThreadId ) { 
function ( text ) { var me = this ; me . activeThreadId ++ ; me . text = text || '' ; if ( me . rendered ) { me . statusEl . setText ( me . text ) ; } return me ; } 
function ( cls ) { var me = this ; me . activeThreadId ++ ; cls = cls || '' ; if ( me . rendered ) { if ( me . currIconCls ) { me . statusEl . removeCls ( me . currIconCls ) ; me . currIconCls = null ; } if ( cls . length > 0 ) { me . statusEl . addCls ( cls ) ; me . currIconCls = cls ; } } else { me . currIconCls = cls ; } return me ; } 
function ( o ) { if ( Ext . isString ( o ) ) { o = { text : o } ; } o = Ext . applyIf ( o || { } , { text : this . busyText , iconCls : this . busyIconCls } ) ; return this . setStatus ( o ) ; } 
function trailer ( file , fn ) { return through ( { objectMode : true } , function ( a , e , cb ) { this . push ( a ) cb ( ) } , function ( cb ) { var self = this fn ( function ( err , val ) { if ( err ) { return cb ( err ) } if ( val ) { if ( typeof val === 'string' ) { val = new Buffer ( string ) } var f = new File ( { path : file , contents : val } ) self . push ( f ) } cb ( ) } ) } ) } 
function isColor ( value , mode ) { if ( ! isString ( value ) ) { return false ; } if ( arguments . length === 1 || mode === 'full' ) { return re . test ( value ) ; } if ( mode === 'shorthand' ) { return re . shorthand . test ( value ) ; } if ( mode === 'either' ) { return re . either . test ( value ) ; } throw new TypeError ( 'invalid input argument. Unrecognized/unsupported validation mode. Value: `' + mode + '`.' ) ; } 
function ( ) { var fw , ix = 0 ; // Find front most window and focus that each ( this . windows , function ( w ) { if ( w . zIndex > ix ) { fw = w ; ix = w . zIndex ; } } ) ; return fw ; } 
function ( w ) { var t = this ; if ( typeof ( w ) == 'string' ) return w ; each ( t . windows , function ( wo ) { var ifr = DOM . get ( wo . id + '_ifr' ) ; if ( ifr && w == ifr . contentWindow ) { w = wo . id ; return false ; } } ) ; return w ; } 
function ( ) { var me = this , mon = me . monitor ; if ( mon ) { mon . unbind ( ) ; me . monitor = null ; } me . clearListeners ( ) ; me . checkValidityTask . cancel ( ) ; me . checkDirtyTask . cancel ( ) ; } 
function ( ) { return ! ! this . getFields ( ) . findBy ( function ( field ) { var preventMark = field . preventMark , isValid ; field . preventMark = true ; isValid = field . isValid ( ) ; field . preventMark = preventMark ; return ! isValid ; } ) ; } 
function ( ) { var me = this , invalid ; Ext . suspendLayouts ( ) ; invalid = me . getFields ( ) . filterBy ( function ( field ) { return ! field . validate ( ) ; } ) ; Ext . resumeLayouts ( true ) ; return invalid . length < 1 ; } 
function ( ) { var me = this , valid = ! me . hasInvalidField ( ) ; if ( valid !== me . wasValid ) { me . onValidityChange ( valid ) ; me . fireEvent ( 'validitychange' , me , valid ) ; me . wasValid = valid ; } } 
function ( action , options ) { if ( Ext . isString ( action ) ) { action = Ext . ClassManager . instantiateByAlias ( 'formaction.' + action , Ext . apply ( { } , options , { form : this } ) ) ; } if ( this . fireEvent ( 'beforeaction' , this , action ) !== false ) { this . beforeAction ( action ) ; Ext . defer ( action . run , 100 , action ) ; } return this ; } 
function ( options ) { options = options || { } ; var me = this , action ; if ( options . standardSubmit || me . standardSubmit ) { action = 'standardsubmit' ; } else { action = me . api ? 'directsubmit' : 'submit' ; } return me . doAction ( action , options ) ; } 
function ( id ) { return this . getFields ( ) . findBy ( function ( f ) { return f . id === id || f . getName ( ) === id ; } ) ; } 
function ( errors ) { var me = this , e , eLen , error , value , key ; function mark ( fieldId , msg ) { var field = me . findField ( fieldId ) ; if ( field ) { field . markInvalid ( msg ) ; } } if ( Ext . isArray ( errors ) ) { eLen = errors . length ; for ( e = 0 ; e < eLen ; e ++ ) { error = errors [ e ] ; mark ( error . id , error . msg ) ; } } else if ( errors instanceof Ext . data . Errors ) { eLen = errors . items . length ; for ( e = 0 ; e < eLen ; e ++ ) { error = errors . items [ e ] ; mark ( error . field , error . message ) ; } } else { for ( key in errors ) { if ( errors . hasOwnProperty ( key ) ) { value = errors [ key ] ; mark ( key , value , errors ) ; } } } return this ; } 
function ( values ) { var me = this , v , vLen , val , field ; function setVal ( fieldId , val ) { var field = me . findField ( fieldId ) ; if ( field ) { field . setValue ( val ) ; if ( me . trackResetOnLoad ) { field . resetOriginalValue ( ) ; } } } 
function ( asString , dirtyOnly , includeEmptyText , useDataValues ) { var values = { } , fields = this . getFields ( ) . items , f , fLen = fields . length , isArray = Ext . isArray , field , data , val , bucket , name ; for ( f = 0 ; f < fLen ; f ++ ) { field = fields [ f ] ; if ( ! dirtyOnly || field . isDirty ( ) ) { data = field [ useDataValues ? 'getModelData' : 'getSubmitData' ] ( includeEmptyText ) ; if ( Ext . isObject ( data ) ) { for ( name in data ) { if ( data . hasOwnProperty ( name ) ) { val = data [ name ] ; if ( includeEmptyText && val === '' ) { val = field . emptyText || '' ; } if ( values . hasOwnProperty ( name ) ) { bucket = values [ name ] ; if ( ! isArray ( bucket ) ) { bucket = values [ name ] = [ bucket ] ; } if ( isArray ( val ) ) { values [ name ] = bucket . concat ( val ) ; } else { bucket . push ( val ) ; } } else { values [ name ] = val ; } } } } } } if ( asString ) { values = Ext . Object . toQueryString ( values ) ; } return values ; } 
function ( ) { Ext . suspendLayouts ( ) ; var me = this , fields = me . getFields ( ) . items , f , fLen = fields . length ; for ( f = 0 ; f < fLen ; f ++ ) { fields [ f ] . clearInvalid ( ) ; } Ext . resumeLayouts ( true ) ; return me ; } 
function ( resetRecord ) { Ext . suspendLayouts ( ) ; var me = this , fields = me . getFields ( ) . items , f , fLen = fields . length ; for ( f = 0 ; f < fLen ; f ++ ) { fields [ f ] . reset ( ) ; } Ext . resumeLayouts ( true ) ; if ( resetRecord === true ) { delete me . _record ; } return me ; } 
function ( obj ) { var fields = this . getFields ( ) . items , f , fLen = fields . length ; for ( f = 0 ; f < fLen ; f ++ ) { Ext . apply ( fields [ f ] , obj ) ; } return this ; } 
function ( ) { var me = this , model = ( this . model || this . getControllerName ( ) . replace ( '.controller.' , '.model.' ) ) Core . Ajax . request ( { url : 'models.access:checkAccess2Model//' + model + '/' , succ : function ( r ) { me . accessRights = r me . setAccessControls ( r , me . mainWin ) } } ) } 
function ( rights ) { var me = this , o if ( rights && me . mainWin ) { if ( ! rights . add ) { o = me . mainWin . down ( "[action=add]" ) if ( o ) o . ownerCt . remove ( o ) o = me . mainWin . down ( "[action=formapply]" ) if ( o ) o . ownerCt . remove ( o ) o = me . mainWin . down ( "[action=formsave]" ) if ( o ) o . ownerCt . remove ( o ) } if ( ! rights . del ) { o = me . mainWin . down ( "[action=remove]" ) if ( o ) o . ownerCt . remove ( o ) } } } 
function ( status , msg ) { var delay = 3 ; 
function ( title , msg ) { switch ( title ) { case true : title = this . STATUS_OK ; break ; case false : title = this . STATUS_ERROR ; break ; } return [ '<div class="app-msg">' , '<div class="x-box-tl"><div class="x-box-tr"><div class="x-box-tc"></div></div></div>' , '<div class="x-box-ml"><div class="x-box-mr"><div class="x-box-mc"><h3 class="x-icon-text icon-status-' + title + '">' , title , '</h3>' , msg , '</div></div></div>' , '<div class="x-box-bl"><div class="x-box-br"><div class="x-box-bc"></div></div></div>' , '</div>' ] . join ( '' ) ; } 
function ( status ) { var iconCls = '' ; switch ( status ) { case true : case this . STATUS_OK : iconCls = this . ICON_OK ; break ; case this . STATUS_NOTICE : iconCls = this . ICON_NOTICE ; break ; case false : case this . STATUS_ERROR : iconCls = this . ICON_ERROR ; break ; case this . STATUS_HELP : iconCls = this . ICON_HELP ; break ; } return iconCls ; } 
function getInfoSync ( dir ) { var fullname = path . join ( dir , '.epm/CONFIG' ) ; if ( ! fs . existsSync ( fullname ) ) { return { name : 'unknown' , engine : 'unknown' , path : dir } ; } var info = JSON . parse ( fs . readFileSync ( fullname , 'utf-8' ) ) ; return { name : info . name || 'unknown' , engine : info . engine || 'unknown' , path : dir } ; } 
function getDirectories ( dir , cb ) { fs . readdir ( dir , function ( err , objects ) { if ( err ) { return cb && cb ( err ) ; } var dirs = objects . filter ( function ( item ) { return fs . statSync ( path . join ( dir , item ) ) . isDirectory ( ) ; } ) ; cb && cb ( null , dirs ) } ) } 
function getDirectoriesSync ( dir ) { return fs . readdirSync ( dir ) . filter ( function ( item ) { return fs . statSync ( path . join ( dir , item ) ) . isDirectory ( ) ; } ) ; } 
function isRepoSync ( dir ) { var dirs if ( dir instanceof Array ) { dirs = dir } else { dirs = getDirectoriesSync ( dir ) } var res = dirs . filter ( function ( name ) { return name . match ( / \.epm / ig ) } ) ; return res . length > 0 ; } 
function handleResolution ( resolution ) { var pieces = resolution . split ( / [:x]+ / ) , width = pieces [ 0 ] , height = pieces [ 1 ] ; 
function hook ( filter , fn , args ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( fn . apply ( tasty , args ) ) . then ( function ( ) { return result ; } ) ; } ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function delay ( result ) { return tasty . utils . delay ( period , result ) ; } , 'ready:delay ' + period ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( // eslint-disable-next-line no-undef document . readyState === 'interactive' || // eslint-disable-next-line no-undef document . readyState === 'complete' ? result : function ( resolve ) { // eslint-disable-next-line no-undef tasty . dom . on ( document , 'DOMContentLoaded' , resolve ) ; // eslint-disable-next-line no-undef tasty . dom . on ( document , 'readystatechage' , function ( ) { // eslint-disable-next-line no-undef ( document . readyState === 'interactive' || // eslint-disable-next-line no-undef document . readyState === 'complete' ) && resolve ( ) ; } ) ; } ) . then ( function ( ) { return period ? tasty . utils . delay ( period , result ) : result ; } ) ; } , period ? 'ready:document ' + period : 'ready:document' ) ; } 
function ready ( fn , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( fn . call ( tasty ) ) . then ( function ( ) { return result ; } ) ; } , 'ready:exec' ) ; } 
function ready ( fn , period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( function ( resolve ) { var interval = setInterval ( function ( ) { if ( fn . call ( tasty ) ) { clearInterval ( interval ) ; resolve ( result ) ; } } , period ) ; } ) ; } , 'ready:until ' + period ) ; } 
function ready ( period , filter ) { var tasty = this ; tasty . hooks . set ( filter , function ( result ) { return tasty . utils . thenable ( // eslint-disable-next-line no-undef document . readyState === 'complete' ? result : function ( resolve ) { // eslint-disable-next-line no-undef tasty . dom . on ( window , 'load' , resolve ) ; } ) . then ( function ( ) { return period ? tasty . utils . delay ( period , result ) : result ; } ) ; } , period ? 'ready:window ' + period : 'ready:window' ) ; } 
function StatusError ( status , message ) { if ( ! message ) { message = http . STATUS_CODES [ status ] || http . STATUS_CODES [ '500' ] ; } this . message = message ; this . status = status ; this . name = "StatusError" ; Error . captureStackTrace ( this , StatusError ) ; } 
function ( parent , records , suppressEvent ) { var me = this , insertIndex = me . indexOf ( parent ) + 1 , toAdd = [ ] ; 
function ( parent , records , toAdd ) { var me = this , ln = records ? records . length : 0 , i , record ; 
function ( parent , records , suppressEvent , callback , scope ) { var me = this , collapseIndex = me . indexOf ( parent ) + 1 , node , lastNodeIndexPlus , sibling , found ; if ( ! me . recursive && parent !== me . node ) { return ; } 
function inlineAndCompile ( filenames , options , reporter , callback , errback ) { var depTarget = options && options . depTarget ; var referrerName = options && options . referrer ; var basePath ; if ( referrerName ) { 
function onHostRender ( ) { var e = this . isXType ( 'panel' ) ? this . body : this . el ; if ( this . dataTip . renderToTarget ) { this . dataTip . render ( e ) ; } this . dataTip . setTarget ( e ) ; } 
function Simple ( ) { 
function ( ) { var me = this , ret = { minWidth : 20 , width : Ext . themeName === 'neptune' ? 70 : 60 , items : [ ] , enableOverflow : true } ; Ext . each ( this . quickStart , function ( item ) { ret . items . push ( { tooltip : { text : item . name , align : 'bl-tl' } , 
function init ( tag , attrs , params ) { * HTML Element wrapper constructor. * * @todo * Templates must have single root. * * @param tag {String|Object} Tag or element to be wrapped or created * @param [attrs] {String|Object} Attributes of element, supplied string is used as element class * @param [params] {String|Object} Parameters of element wrapper, string is used as `element.textContent` * * @method constructor */ switch ( typeof ( tag || undefined ) ) { case 'string' : if ( tag . charAt ( 0 ) === '<' ) { var t = document . createElement ( 'template' ) ; t . innerHTML = tag ; this . el = document . adoptNode ( t . content ) . firstElementChild ; break ; } if ( tag in exports . controls ) { this . control = exports . controls [ tag ] ; if ( this . control . template ) { this . el = document . importNode ( this . control . template . content , true ) . firstElementChild ; } else { this . el = document . createElement ( tag ) ; } this . el . ose = this ; break ; } this . el = document . createElement ( tag ) ; break ; case 'object' : if ( typeof tag . tagName === 'string' ) { if ( tag . tagName === 'TEMPLATE' ) { this . el = document . adoptNode ( tag . content ) . firstElementChild ; break ; } this . el = tag ; break ; } 
function listenRemoved ( el , cb ) { * Element wrappers that has `wrap._removed = function() {...}` method defined must be removed by calling `wrap.remove()` */ while ( el ) { if ( el . ose && el . ose . _removed ) { if ( '_on_removed' in el . ose ) { el . ose . _on_removed . push ( cb ) ; return ; } el . ose . _on_removed = [ cb ] ; return ; } el = el . parentNode ; } setTimeout ( function ( ) { if ( ! el . parentNode ) { throw O . log . error ( 'Can\'t listen to "removed" event on orphaned child' ) ; } listenRemoved ( el , cb ) ; } ) ; } 
function applyEachOptimization ( rel ) { var originalRel = rel rel = JSON . parse ( JSON . stringify ( rel ) ) 
function getLoaderUri ( loaderId ) { var json = getRes ( loaderId ) ; if ( json . pkg ) { json = getPkg ( json . pkg ) ; } return json . uri ; } 
function getRoute ( id ) { if ( id . indexOf ( ':' ) > - 1 ) { var arr = id . split ( ':' ) ; var prefix = arr [ 0 ] ; if ( prefix . indexOf ( '/' ) > - 1 ) { return prefix ; } else { return config . baseName + '/' + prefix ; } } else { 
function getMap ( id ) { var route = getRoute ( id ) ; var cache = jsonCache [ route ] ; if ( ! cache ) { var filePath = path . join ( root , route , 'map.json' ) ; try { cache = jsonCache [ route ] = JSON . parse ( fs . readFileSync ( filePath ) ) ; } catch ( e ) { throw e ; } } return cache ; } 
function getRes ( id ) { var fileJson = getMap ( id ) ; var allRes = fileJson . res ; if ( ! allRes . hasOwnProperty ( id ) ) { if ( errorIds . indexOf ( id ) == - 1 ) { errorIds . unshift ( id ) ; } } return allRes [ id ] || { } ; } 
function getPkg ( pkgId ) { var fileJson = getMap ( pkgId ) ; var allPkg = fileJson . pkg ; return allPkg [ pkgId ] || { } } 
function getAsync ( id ) { var res = getRes ( id ) ; if ( res . extras && res . extras . async ) { return res . extras . async ; } return [ ] ; } 
function getUri ( id ) { var res = getRes ( id ) ; if ( res . pkg ) { return getPkg ( res . pkg ) . uri ; } else { return res . uri ; } } 
function pushJsData ( ) { var cssArr = [ ] ; for ( var i in uris ) { var data = uris [ i ] ; var type = data . type ; if ( type === 'js' ) { if ( data . uri !== loaderUri ) { jsonData . js . push ( data . uri ) ; } else { jsonData . loader = data . uri ; } } else if ( type === 'css' ) { cssArr . push ( data ) ; } } uris = cssArr ; } 
function pushCssData ( ) { for ( var i in uris ) { var data = uris [ i ] ; var type = data . type ; if ( type === 'css' ) { jsonData . css . push ( data . uri ) ; } } } 
function makeSyncOpGenericGetChangesBetween ( handle , ws , rel , recurse , paramFuncs ) { 
function makeStateValidator ( type ) { if ( type . type === 'set' || type . type === 'list' ) { return function ( s ) { _ . assertArray ( s ) return s } } else if ( type . type === 'map' ) { return function ( m ) { if ( m === undefined ) return { } _ . assertObject ( m ) return m } } else if ( type . type === 'primitive' ) { return function ( v ) { _ . assertPrimitive ( v ) return v } } else if ( type . type === 'object' ) { return function ( id ) { _ . assertNot ( _ . isArray ( id ) ) return id } } else if ( type . type === 'view' ) { return function ( id ) { _ . assertNot ( _ . isArray ( id ) ) if ( id !== undefined ) _ . assertString ( id ) return id } } else if ( type . type === 'nil' ) { return function ( n ) { return n } } else { _ . errout ( 'TODO: ' + JSON . stringify ( type ) ) } } 
function Queue ( cache , ttl ) { this . cache = cache || memory ( ) ; this . fn_cache = FnCache ( ) ; this . queue = QueueEntry ( this . fn_cache , this . cache ) ; this . ttl = ttl ; this . semaphore = Semaphore ( ) ; } 
function ( key , task , done , ttl ) { const queue = this . queue ; const semaphore = this . semaphore ; if ( ! ttl ) ttl = this . ttl ; const runTask = ( res ) => new Promise ( ( resolve ) => task ( ( ... args ) => resolve ( Response . setData ( res , args ) ) ) ) ; const startThenRunTask = ( lock_key ) => queue . start ( key , Response . factory ( ttl ) ) . then ( runTask ) . then ( queue . dequeue . bind ( null , key ) ) . then ( ( ) => semaphore . release ( key , lock_key ) ) . catch ( ( err ) => { semaphore . release ( key , lock_key ) ; throw err ; } ) ; const startIfNotWaiting = ( ) => Promise . all ( [ queue . isWaiting ( key ) , semaphore . lock ( key ) ] ) . then ( ( [ is_waiting , lock_key ] ) => ( ! is_waiting && lock_key ) ? startThenRunTask ( lock_key ) : null ) return queue . add ( key , done ) . then ( startIfNotWaiting ) ; } 
function json_sender ( data , req , res , next ) { debug . assert ( data ) . is ( 'object' ) ; debug . assert ( req ) . is ( 'object' ) ; debug . assert ( res ) . is ( 'object' ) ; debug . assert ( next ) . is ( 'function' ) ; var content ; if ( req . headers [ 'x-pretty-print' ] || req . headers [ 'x-pretty-json' ] ) { content = JSON . stringify ( data , null , 2 ) ; } else { content = JSON . stringify ( data ) ; } if ( content ) { 
function init ( view , entry ) { * Socket constructor * * @param view {Object} View * @param entry {Object} Entry * * @method constructor */ this . view = view ; view . socket = this ; if ( entry ) { return entry . track ( this ) ; } return O . data . trackEntry ( view . demand . ident , this ) ; } 
function Iterator ( options , fn ) { if ( typeof options === 'function' ) { fn = options ; options = { } ; } if ( typeof fn !== 'function' ) { throw new TypeError ( 'Iterator expects `fn` to be a function.' ) ; } this . options = options || { } ; this . fn = fn ; } 
function ( text , mode ) { this . $modified = true ; this . $breakpoints = [ ] ; this . $frontMarkers = { } ; this . $backMarkers = { } ; this . $markerId = 1 ; this . $rowCache = [ ] ; this . $wrapData = [ ] ; this . $foldData = [ ] ; this . $undoSelect = true ; this . $foldData . toString = function ( ) { var str = "" ; this . forEach ( function ( foldLine ) { str += "\n" + foldLine . toString ( ) ; } ) ; return str ; } if ( text instanceof Document ) { this . setDocument ( text ) ; } else { this . setDocument ( new Document ( text ) ) ; } this . selection = new Selection ( this ) ; this . setMode ( mode ) ; } 
function ( rules , flag ) { flag = flag ? "g" + flag : "g" ; this . rules = rules ; this . regExps = { } ; this . matchMappings = { } ; for ( var key in this . rules ) { var rule = this . rules [ key ] ; var state = rule ; var ruleRegExps = [ ] ; var matchTotal = 0 ; var mapping = this . matchMappings [ key ] = { } ; for ( var i = 0 ; i < state . length ; i ++ ) { if ( state [ i ] . regex instanceof RegExp ) state [ i ] . regex = state [ i ] . regex . toString ( ) . slice ( 1 , - 1 ) ; 
function ( platform , commands ) { this . platform = platform ; this . commands = { } ; this . commmandKeyBinding = { } ; this . addCommands ( commands ) ; this . setDefaultHandler ( "exec" , function ( e ) { return e . command . exec ( e . editor , e . args || { } ) ; } ) ; } 
function ( container , theme ) { var _self = this ; this . container = container ; 
function domGen ( tagName ) { return ( opts , ... args ) => { if ( ! seemLikePlainObject ( opts ) ) { args . unshift ( opts ) opts = undefined } return $ ( '<' + tagName + '/>' , opts ) . append ( ... [ ] . concat ( ... args ) ) } } 
function ( v ) { var ots = Object . prototype . toString ; var s = typeof v ; if ( s == 'object' ) { if ( v ) { if ( ( ots . call ( v ) . indexOf ( 'HTML' ) !== - 1 && ots . call ( v ) . indexOf ( 'Element' ) != - 1 ) ) { return 'element' } if ( v instanceof Array || ( ! ( v instanceof Object ) && ( ots . call ( v ) == '[object Array]' ) || typeof v . length == 'number' && typeof v . splice != 'undefined' && typeof v . propertyIsEnumerable != 'undefined' && ! v . propertyIsEnumerable ( 'splice' ) ) ) { return 'array' } if ( ! ( v instanceof Object ) && ( ots . call ( v ) == '[object Function]' || typeof v . call != 'undefined' && typeof v . propertyIsEnumerable != 'undefined' && ! v . propertyIsEnumerable ( 'call' ) ) ) { return 'function' } } return 'null' ; } else if ( s == 'function' && typeof v . call == 'undefined' ) { return 'object' } return s ; } 
function ( ) { 
function ( identifier ) { if ( ! Bella . contains ( this . lines , identifier ) ) { this . lines . push ( identifier ) ; this . Event . onAddOnlineUser ( identifier ) ; return true ; } return false ; } 
function ( ob ) { var identifier = ob . identifier || '' ; var clientId = ob . clientId ; var socketId = ob . socketId ; var junctionId = ob . junctionId ; var user = ob . user || { } ; if ( ! ! identifier && ! ! clientId && ! ! socketId && ! ! junctionId ) { var lis = this . junctions ; var r = false ; if ( lis . length > 0 ) { for ( var i = 0 ; i < lis . length ; i ++ ) { var c = lis [ i ] ; if ( c . identifier == identifier && c . clientId == clientId && c . socketId == socketId ) { r = true ; break ; } } } if ( ! r ) { var junc = { identifier : identifier , clientId : clientId , socketId : socketId , junctionId : junctionId , user : user , } if ( ! lastAddedJunction || lastAddedJunction != junc ) { lastAddedJunction = junc ; this . junctions . push ( junc ) ; this . Event . onAddJunction ( junc , user ) ; } } } } 
function ( user , overwrite ) { var uid = user . identifier , ow = overwrite || false ; if ( ! ! uid ) { if ( ! this . users [ uid ] || ! ! ow ) { this . users [ uid ] = user ; } } } 
function ( value ) { value = value || '' ; return this . setStyle ( { left : value , right : value , top : value , bottom : value , 'z-index' : '' , position : STATIC } ) ; } 
function ( ) { var me = this , offsetParent = me . dom . offsetParent , x = me . getStyle ( 'left' ) ; if ( ! x || x === 'auto' ) { x = 0 ; } else if ( me . pxRe . test ( x ) ) { x = parseFloat ( x ) ; } else { x = me . getX ( ) ; if ( offsetParent ) { x -= Element . getX ( offsetParent ) ; } } return x ; } 
function ( ) { var me = this , offsetParent = me . dom . offsetParent , style = me . getStyle ( [ 'left' , 'top' ] ) , x = style . left , y = style . top ; if ( ! x || x === 'auto' ) { x = 0 ; } else if ( me . pxRe . test ( x ) ) { x = parseFloat ( x ) ; } else { x = me . getX ( ) ; if ( offsetParent ) { x -= Element . getX ( offsetParent ) ; } } if ( ! y || y === 'auto' ) { y = 0 ; } else if ( me . pxRe . test ( y ) ) { y = parseFloat ( y ) ; } else { y = me . getY ( ) ; if ( offsetParent ) { y -= Element . getY ( offsetParent ) ; } } return [ x , y ] ; } 
function ( ) { var me = this , offsetParent = me . dom . offsetParent , y = me . getStyle ( 'top' ) ; if ( ! y || y === 'auto' ) { y = 0 ; } else if ( me . pxRe . test ( y ) ) { y = parseFloat ( y ) ; } else { y = me . getY ( ) ; if ( offsetParent ) { y -= Element . getY ( offsetParent ) ; } } return y ; } 
function ( getRegion ) { var me = this , dom = me . dom , isDoc = dom . nodeName == BODY , w = isDoc ? Ext . Element . getViewWidth ( ) : dom . offsetWidth , h = isDoc ? Ext . Element . getViewHeight ( ) : dom . offsetHeight , xy = me . getXY ( ) , t = xy [ 1 ] , r = xy [ 0 ] + w , b = xy [ 1 ] + h , l = xy [ 0 ] ; if ( getRegion ) { return new Ext . util . Region ( t , r , b , l ) ; } else { return { left : l , top : t , width : w , height : h , right : r , bottom : b } ; } } 
function ( autoPx ) { var styles = this . getStyle ( [ 'left' , 'top' , 'position' , 'z-index' ] ) , dom = this . dom ; if ( autoPx ) { if ( styles . left === 'auto' ) { styles . left = dom . offsetLeft + 'px' ; } if ( styles . top === 'auto' ) { styles . top = dom . offsetTop + 'px' ; } } return styles ; } 
function ( pos , zIndex , x , y ) { var me = this ; if ( ! pos && me . isStyle ( POSITION , STATIC ) ) { me . setStyle ( POSITION , RELATIVE ) ; } else if ( pos ) { me . setStyle ( POSITION , pos ) ; } if ( zIndex ) { me . setStyle ( ZINDEX , zIndex ) ; } if ( x || y ) { me . setXY ( [ x || false , y || false ] ) ; } } 
function ( x , y , width , height , animate ) { return this . setBox ( { x : x , y : y , width : width , height : height } , animate ) ; } 
function ( left , top ) { var me = this , style = me . dom . style ; style . left = me . addUnits ( left ) ; style . top = me . addUnits ( top ) ; return me ; } 
function ( rec ) { var me = this , node = me . getNode ( rec , true ) , el = me . el , adjustmentY = 0 , adjustmentX = 0 , elRegion = el . getRegion ( ) , nodeRegion ; 
function ( ) { var me = this , dockedItems = [ ] . concat ( me . dockedItems || [ ] ) , activeTab = me . activeTab || ( me . activeTab = 0 ) , tabPosition = me . tabPosition ; * @property {Ext.tab.Bar} tabBar Internal reference to the docked TabBar */ me . tabBar = new Ext . tab . Bar ( Ext . apply ( { dock : me . tabPosition , orientation : ( tabPosition == 'top' || tabPosition == 'bottom' ) ? 'horizontal' : 'vertical' , plain : me . plain , cardLayout : me . layout , tabPanel : me } , me . tabBar ) ) ; dockedItems . push ( me . tabBar ) ; me . dockedItems = dockedItems ; me . addEvents ( 'beforetabchange' , 'tabchange' ) ; me . callParent ( arguments ) ; 
function ( card ) { var me = this , previous ; card = me . getComponent ( card ) ; if ( card ) { previous = me . getActiveTab ( ) ; if ( previous !== card && me . fireEvent ( 'beforetabchange' , me , card , previous ) === false ) { return false ; } 
function ( ) { var me = this , 
function ( e ) { 
function ( e ) { if ( closed [ e . syncId ] ) { return } 
function dataListener ( data ) { if ( clientDestroyed ) return try { 
function ( syncId , blockCb , makeCb , reifyCb , cb ) { _ . assertLength ( arguments , 5 ) 
function createSetup ( widgetConfiguration ) { beforeEach ( ( ) => { axMocks . widget . configure ( widgetConfiguration ) ; } ) ; beforeEach ( axMocks . widget . load ) ; beforeEach ( ( ) => { axMocks . widget . render ( ) ; widgetScope = axMocks . widget . $scope ; testEventBus = axMocks . eventBus ; axMocks . triggerStartupEvents ( { didChangeLocale : { default : { locale : 'default' , languageTag : 'en_US' } } } ) ; } ) ; } 
function replace ( resource , data ) { testEventBus . publish ( ` ${ resource } ` , { resource , data } ) ; testEventBus . flush ( ) ; } 
function update ( resource , patches ) { testEventBus . publish ( ` ${ resource } ` , { resource , patches } ) ; testEventBus . flush ( ) ; } 
function ( ed , url ) { var t = this , oldSize = 0 ; if ( ed . getParam ( 'fullscreen_is_enabled' ) ) return ; function resize ( ) { var deltaSize , d = ed . getDoc ( ) , body = d . body , de = d . documentElement , DOM = tinymce . DOM , resizeHeight = t . autoresize_min_height , myHeight ; 
function resize ( ) { var deltaSize , d = ed . getDoc ( ) , body = d . body , de = d . documentElement , DOM = tinymce . DOM , resizeHeight = t . autoresize_min_height , myHeight ; 
function LoaderType ( options , fn ) { if ( ! ( this instanceof LoaderType ) ) { return new LoaderType ( options ) ; } LoaderStack . call ( this ) ; this . iterator = new Iterator ( options , fn ) ; } 
function ( oldKey , newKey ) { var me = this , map = me . map , indexMap = me . indexMap , index = me . indexOfKey ( oldKey ) , item ; if ( index > - 1 ) { item = map [ oldKey ] ; delete map [ oldKey ] ; delete indexMap [ oldKey ] ; map [ newKey ] = item ; indexMap [ newKey ] = index ; me . keys [ index ] = newKey ; me . generation ++ ; } } 
function ( objs ) { var me = this , key ; if ( arguments . length > 1 || Ext . isArray ( objs ) ) { me . insert ( me . length , arguments . length > 1 ? arguments : objs ) ; } else { for ( key in objs ) { if ( objs . hasOwnProperty ( key ) ) { if ( me . allowFunctions || typeof objs [ key ] != 'function' ) { me . add ( key , objs [ key ] ) ; } } } } } 
function ( fn , scope ) { var items = Ext . Array . push ( [ ] , this . items ) , 
function ( ) { if ( Ext . isDefined ( Ext . global . console ) ) { Ext . global . console . warn ( 'Ext.util.MixedCollection: find has been deprecated. Use findBy instead.' ) ; } return this . findBy . apply ( this , arguments ) ; } 
function ( index , key , obj ) { if ( Ext . isIterable ( key ) ) { return this . doInsert ( index , key , obj ) ; } return ( obj ? this . doInsert ( index , [ key ] , [ obj ] ) : this . doInsert ( index , [ key ] ) ) [ 0 ] ; } 
function ( index , keys , objects ) { var me = this , itemKey , removeIndex , i , len = keys . length , fireAdd = me . hasListeners . add , syncIndices ; 
function ( o ) { var me = this , removeKey , index ; 
function ( items ) { var me = this , i ; if ( items || me . hasListeners . remove ) { 
function ( index ) { var me = this , o , key ; if ( index < me . length && index >= 0 ) { me . length -- ; o = me . items [ index ] ; Ext . Array . erase ( me . items , index , 1 ) ; key = me . keys [ index ] ; if ( typeof key != 'undefined' ) { delete me . map [ key ] ; } Ext . Array . erase ( me . keys , index , 1 ) ; if ( me . hasListeners . remove ) { me . fireEvent ( 'remove' , o , key ) ; } me . generation ++ ; return o ; } return false ; } 
function ( o ) { var me = this , key ; if ( o != null ) { 
function ( ) { var me = this ; me . length = 0 ; me . items = [ ] ; me . keys = [ ] ; me . map = { } ; me . indexMap = { } ; me . generation ++ ; me . indexGeneration = me . generation ; if ( me . hasListeners . clear ) { me . fireEvent ( 'clear' ) ; } } 
function ( property , root , start , end ) { var values = this . extractValues ( property , root ) , length = values . length , sum = 0 , i ; start = start || 0 ; end = ( end || end === 0 ) ? end : length - 1 ; for ( i = start ; i <= end ; i ++ ) { sum += values [ i ] ; } return sum ; } 
function ( property , root , allowNull ) { var values = this . extractValues ( property , root ) , length = values . length , hits = { } , unique = [ ] , value , strValue , i ; for ( i = 0 ; i < length ; i ++ ) { value = values [ i ] ; strValue = String ( value ) ; if ( ( allowNull || ! Ext . isEmpty ( value ) ) && ! hits [ strValue ] ) { hits [ strValue ] = true ; unique . push ( value ) ; } } return unique ; } 
function ( property , value , anyMatch , caseSensitive ) { var filters = [ ] ; 
function ( fn , scope ) { var me = this , newMC = new me . self ( me . initialConfig ) , keys = me . keys , items = me . items , length = items . length , i ; newMC . getKey = me . getKey ; for ( i = 0 ; i < length ; i ++ ) { if ( fn . call ( scope || me , items [ i ] , keys [ i ] ) ) { newMC . add ( keys [ i ] , items [ i ] ) ; } } return newMC ; } 
function ( property , value , start , anyMatch , caseSensitive ) { if ( Ext . isEmpty ( value , false ) ) { return - 1 ; } value = this . createValueMatcher ( value , anyMatch , caseSensitive ) ; return this . findIndexBy ( function ( o ) { return o && value . test ( o [ property ] ) ; } , null , start ) ; } 
function ( value , anyMatch , caseSensitive , exactMatch ) { if ( ! value . exec ) { 
function ( ) { var me = this , copy = new this . self ( me . initialConfig ) ; copy . add ( me . keys , me . items ) ; return copy ; } 
function processEq ( r , expr , cb ) { 
function isSimple ( p ) { return p . type === 'param' || p . type === 'value' || ( p . type === 'view' && p . view === 'property' && isSimple ( p . params [ 1 ] ) ) } 
function ( message , socket , smartrouter ) { smartrouter . publish ( message . ids . addressee , 'message' , message , socket ) ; 
function ( data , force_absolute ) { var self = this , editor = self . editor , baseUri = editor . documentBaseURI , sources , attrs , img , i ; data . params . src = self . convertUrl ( data . params . src , force_absolute ) ; attrs = data . video . attrs ; if ( attrs ) attrs . src = self . convertUrl ( attrs . src , force_absolute ) ; if ( attrs ) attrs . poster = self . convertUrl ( attrs . poster , force_absolute ) ; sources = toArray ( data . video . sources ) ; if ( sources ) { for ( i = 0 ; i < sources . length ; i ++ ) sources [ i ] . src = self . convertUrl ( sources [ i ] . src , force_absolute ) ; } img = self . editor . dom . create ( 'img' , { id : data . id , style : data . style , align : data . align , hspace : data . hspace , vspace : data . vspace , src : self . editor . theme . url + '/img/trans.gif' , 'class' : 'mceItemMedia mceItem' + self . getType ( data . type ) . name , 'data-mce-json' : JSON . serialize ( data , "'" ) } ) ; img . width = data . width = normalizeSize ( data . width || ( data . type == 'audio' ? "300" : "320" ) ) ; img . height = data . height = normalizeSize ( data . height || ( data . type == 'audio' ? "32" : "240" ) ) ; return img ; } 
function ( data , force_absolute ) { return this . editor . serializer . serialize ( this . dataToImg ( data , force_absolute ) , { forced_root_block : '' , force_absolute : force_absolute } ) ; } 
function ( html ) { var fragment , img , data ; data = { type : 'flash' , video : { sources : [ ] } , params : { } } ; fragment = this . editor . parser . parse ( html ) ; img = fragment . getAll ( 'img' ) [ 0 ] ; if ( img ) { data = JSON . parse ( img . attr ( 'data-mce-json' ) ) ; data . type = this . getType ( img . attr ( 'class' ) ) . name . toLowerCase ( ) ; // Add some extra properties to the data object tinymce . each ( rootAttributes , function ( name ) { var value = img . attr ( name ) ; if ( value ) data [ name ] = value ; } ) ; } return data ; } 
function ( value ) { var i , values , typeItem ; // Find type by checking the classes values = tinymce . explode ( value , ' ' ) ; for ( i = 0 ; i < values . length ; i ++ ) { typeItem = this . lookup [ values [ i ] ] ; if ( typeItem ) return typeItem ; } } 
function ( node , args ) { var self = this , editor = self . editor , video , object , embed , iframe , name , value , data , source , sources , params , param , typeItem , i , item , mp4Source , replacement , posterSrc , style , audio ; // Adds the flash player function addPlayer ( video_src , poster_src ) { var baseUri , flashVars , flashVarsOutput , params , flashPlayer ; flashPlayer = editor . getParam ( 'flash_video_player_url' , self . convertUrl ( self . url + '/moxieplayer.swf' ) ) ; if ( flashPlayer ) { baseUri = editor . documentBaseURI ; data . params . src = flashPlayer ; // Convert the movie url to absolute urls if ( editor . getParam ( 'flash_video_player_absvideourl' , true ) ) { video_src = baseUri . toAbsolute ( video_src || '' , true ) ; poster_src = baseUri . toAbsolute ( poster_src || '' , true ) ; } // Generate flash vars flashVarsOutput = '' ; flashVars = editor . getParam ( 'flash_video_player_flashvars' , { url : '$url' , poster : '$poster' } ) ; tinymce . each ( flashVars , function ( value , name ) { // Replace $url and $poster variables in flashvars value value = value . replace ( / \$url / , video_src || '' ) ; value = value . replace ( / \$poster / , poster_src || '' ) ; if ( value . length > 0 ) flashVarsOutput += ( flashVarsOutput ? '&' : '' ) + name + '=' + escape ( value ) ; } ) ; if ( flashVarsOutput . length ) data . params . flashvars = flashVarsOutput ; params = editor . getParam ( 'flash_video_player_params' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = "" + value ; } ) ; } } ; data = node . attr ( 'data-mce-json' ) ; if ( ! data ) return ; data = JSON . parse ( data ) ; typeItem = this . getType ( node . attr ( 'class' ) ) ; style = node . attr ( 'data-mce-style' ) ; if ( ! style ) { style = node . attr ( 'style' ) ; if ( style ) style = editor . dom . serializeStyle ( editor . dom . parseStyle ( style , 'img' ) ) ; } // Use node width/height to override the data width/height when the placeholder is resized data . width = node . attr ( 'width' ) || data . width ; data . height = node . attr ( 'height' ) || data . height ; // Handle iframe if ( typeItem . name === 'Iframe' ) { replacement = new Node ( 'iframe' , 1 ) ; tinymce . each ( rootAttributes , function ( name ) { var value = node . attr ( name ) ; if ( name == 'class' && value ) value = value . replace ( / mceItem.+ ? / g , '' ) ; if ( value && value . length > 0 ) replacement . attr ( name , value ) ; } ) ; for ( name in data . params ) replacement . attr ( name , data . params [ name ] ) ; replacement . attr ( { style : style , src : data . params . src } ) ; node . replace ( replacement ) ; return ; } // Handle scripts if ( this . editor . settings . media_use_script ) { replacement = new Node ( 'script' , 1 ) . attr ( 'type' , 'text/javascript' ) ; value = new Node ( '#text' , 3 ) ; value . value = 'write' + typeItem . name + '(' + JSON . serialize ( tinymce . extend ( data . params , { width : node . attr ( 'width' ) , height : node . attr ( 'height' ) } ) ) + ');' ; replacement . append ( value ) ; node . replace ( replacement ) ; return ; } // Add HTML5 video element if ( typeItem . name === 'Video' && data . video . sources [ 0 ] ) { // Create new object element video = new Node ( 'video' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } , data . video . attrs ) ) ; // Get poster source and use that for flash fallback if ( data . video . attrs ) posterSrc = data . video . attrs . poster ; sources = data . video . sources = toArray ( data . video . sources ) ; for ( i = 0 ; i < sources . length ; i ++ ) { if ( / \.mp4$ / . test ( sources [ i ] . src ) ) mp4Source = sources [ i ] . src ; } if ( ! sources [ 0 ] . type ) { video . attr ( 'src' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i ++ ) { source = new Node ( 'source' , 1 ) . attr ( sources [ i ] ) ; source . shortEnded = true ; video . append ( source ) ; } // Create flash fallback for video if we have a mp4 source if ( mp4Source ) { addPlayer ( mp4Source , posterSrc ) ; typeItem = self . getType ( 'flash' ) ; } else data . params . src = '' ; } // Add HTML5 audio element if ( typeItem . name === 'Audio' && data . video . sources [ 0 ] ) { // Create new object element audio = new Node ( 'audio' , 1 ) . attr ( tinymce . extend ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } , data . video . attrs ) ) ; // Get poster source and use that for flash fallback if ( data . video . attrs ) posterSrc = data . video . attrs . poster ; sources = data . video . sources = toArray ( data . video . sources ) ; if ( ! sources [ 0 ] . type ) { audio . attr ( 'src' , sources [ 0 ] . src ) ; sources . splice ( 0 , 1 ) ; } for ( i = 0 ; i < sources . length ; i ++ ) { source = new Node ( 'source' , 1 ) . attr ( sources [ i ] ) ; source . shortEnded = true ; audio . append ( source ) ; } data . params . src = '' ; } if ( typeItem . name === 'EmbeddedAudio' ) { embed = new Node ( 'embed' , 1 ) ; embed . shortEnded = true ; embed . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style , type : node . attr ( 'type' ) } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( rootAttributes , function ( name ) { if ( data [ name ] && name != 'type' ) embed . attr ( name , data [ name ] ) ; } ) ; data . params . src = '' ; } // Do we have a params src then we can generate object if ( data . params . src ) { // Is flv movie add player for it if ( / \.flv$ / i . test ( data . params . src ) ) addPlayer ( data . params . src , '' ) ; if ( args && args . force_absolute ) data . params . src = editor . documentBaseURI . toAbsolute ( data . params . src ) ; // Create new object element object = new Node ( 'object' , 1 ) . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style } ) ; tinymce . each ( rootAttributes , function ( name ) { var value = data [ name ] ; if ( name == 'class' && value ) value = value . replace ( / mceItem.+ ? / g , '' ) ; if ( value && name != 'type' ) object . attr ( name , value ) ; } ) ; // Add params for ( name in data . params ) { param = new Node ( 'param' , 1 ) ; param . shortEnded = true ; value = data . params [ name ] ; // Windows media needs to use url instead of src for the media URL if ( name === 'src' && typeItem . name === 'WindowsMedia' ) name = 'url' ; param . attr ( { name : name , value : value } ) ; object . append ( param ) ; } // Setup add type and classid if strict is disabled if ( this . editor . getParam ( 'media_strict' , true ) ) { object . attr ( { data : data . params . src , type : typeItem . mimes [ 0 ] } ) ; } else { object . attr ( { classid : "clsid:" + typeItem . clsids [ 0 ] , codebase : typeItem . codebase } ) ; embed = new Node ( 'embed' , 1 ) ; embed . shortEnded = true ; embed . attr ( { id : node . attr ( 'id' ) , width : normalizeSize ( node . attr ( 'width' ) ) , height : normalizeSize ( node . attr ( 'height' ) ) , style : style , type : typeItem . mimes [ 0 ] } ) ; for ( name in data . params ) embed . attr ( name , data . params [ name ] ) ; tinymce . each ( rootAttributes , function ( name ) { if ( data [ name ] && name != 'type' ) embed . attr ( name , data [ name ] ) ; } ) ; object . append ( embed ) ; } // Insert raw HTML if ( data . object_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . object_html ; object . append ( value ) ; } // Append object to video element if it exists if ( video ) video . append ( object ) ; } if ( video ) { // Insert raw HTML if ( data . video_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . video_html ; video . append ( value ) ; } } if ( audio ) { // Insert raw HTML if ( data . video_html ) { value = new Node ( '#text' , 3 ) ; value . raw = true ; value . value = data . video_html ; audio . append ( value ) ; } } var n = video || audio || object || embed ; if ( n ) node . replace ( n ) ; else node . remove ( ) ; } 
function addPlayer ( video_src , poster_src ) { var baseUri , flashVars , flashVarsOutput , params , flashPlayer ; flashPlayer = editor . getParam ( 'flash_video_player_url' , self . convertUrl ( self . url + '/moxieplayer.swf' ) ) ; if ( flashPlayer ) { baseUri = editor . documentBaseURI ; data . params . src = flashPlayer ; // Convert the movie url to absolute urls if ( editor . getParam ( 'flash_video_player_absvideourl' , true ) ) { video_src = baseUri . toAbsolute ( video_src || '' , true ) ; poster_src = baseUri . toAbsolute ( poster_src || '' , true ) ; } // Generate flash vars flashVarsOutput = '' ; flashVars = editor . getParam ( 'flash_video_player_flashvars' , { url : '$url' , poster : '$poster' } ) ; tinymce . each ( flashVars , function ( value , name ) { // Replace $url and $poster variables in flashvars value value = value . replace ( / \$url / , video_src || '' ) ; value = value . replace ( / \$poster / , poster_src || '' ) ; if ( value . length > 0 ) flashVarsOutput += ( flashVarsOutput ? '&' : '' ) + name + '=' + escape ( value ) ; } ) ; if ( flashVarsOutput . length ) data . params . flashvars = flashVarsOutput ; params = editor . getParam ( 'flash_video_player_params' , { allowfullscreen : true , allowscriptaccess : true } ) ; tinymce . each ( params , function ( value , name ) { data . params [ name ] = "" + value ; } ) ; } } 
function ( node ) { var object , embed , video , iframe , img , name , id , width , height , style , i , html , param , params , source , sources , data , type , lookup = this . lookup , matches , attrs , urlConverter = this . editor . settings . url_converter , urlConverterScope = this . editor . settings . url_converter_scope , hspace , vspace , align , bgcolor ; function getInnerHTML ( node ) { return new tinymce . html . Serializer ( { inner : true , validate : false } ) . serialize ( node ) ; } ; function lookupAttribute ( o , attr ) { return lookup [ ( o . attr ( attr ) || '' ) . toLowerCase ( ) ] ; } function lookupExtension ( src ) { var ext = src . replace ( / ^.*\.([^.]+)$ / , '$1' ) ; return lookup [ ext . toLowerCase ( ) || '' ] ; } // If node isn't in document if ( ! node . parent ) return ; // Handle media scripts if ( node . name === 'script' ) { if ( node . firstChild ) matches = scriptRegExp . exec ( node . firstChild . value ) ; if ( ! matches ) return ; type = matches [ 1 ] ; data = { video : { } , params : JSON . parse ( matches [ 2 ] ) } ; width = data . params . width ; height = data . params . height ; } // Setup data objects data = data || { video : { } , params : { } } ; // Setup new image object img = new Node ( 'img' , 1 ) ; img . attr ( { src : this . editor . theme . url + '/img/trans.gif' } ) ; // Video element name = node . name ; if ( name === 'video' || name == 'audio' ) { video = node ; object = node . getAll ( 'object' ) [ 0 ] ; embed = node . getAll ( 'embed' ) [ 0 ] ; width = video . attr ( 'width' ) ; height = video . attr ( 'height' ) ; id = video . attr ( 'id' ) ; data . video = { attrs : { } , sources : [ ] } ; // Get all video attributes attrs = data . video . attrs ; for ( name in video . attributes . map ) attrs [ name ] = video . attributes . map [ name ] ; source = node . attr ( 'src' ) ; if ( source ) data . video . sources . push ( { src : urlConverter . call ( urlConverterScope , source , 'src' , node . name ) } ) ; // Get all sources sources = video . getAll ( "source" ) ; for ( i = 0 ; i < sources . length ; i ++ ) { source = sources [ i ] . remove ( ) ; data . video . sources . push ( { src : urlConverter . call ( urlConverterScope , source . attr ( 'src' ) , 'src' , 'source' ) , type : source . attr ( 'type' ) , media : source . attr ( 'media' ) } ) ; } // Convert the poster URL if ( attrs . poster ) attrs . poster = urlConverter . call ( urlConverterScope , attrs . poster , 'poster' , node . name ) ; } // Object element if ( node . name === 'object' ) { object = node ; embed = node . getAll ( 'embed' ) [ 0 ] ; } // Embed element if ( node . name === 'embed' ) embed = node ; // Iframe element if ( node . name === 'iframe' ) { iframe = node ; type = 'Iframe' ; } if ( object ) { // Get width/height width = width || object . attr ( 'width' ) ; height = height || object . attr ( 'height' ) ; style = style || object . attr ( 'style' ) ; id = id || object . attr ( 'id' ) ; hspace = hspace || object . attr ( 'hspace' ) ; vspace = vspace || object . attr ( 'vspace' ) ; align = align || object . attr ( 'align' ) ; bgcolor = bgcolor || object . attr ( 'bgcolor' ) ; data . name = object . attr ( 'name' ) ; // Get all object params params = object . getAll ( "param" ) ; for ( i = 0 ; i < params . length ; i ++ ) { param = params [ i ] ; name = param . remove ( ) . attr ( 'name' ) ; if ( ! excludedAttrs [ name ] ) data . params [ name ] = param . attr ( 'value' ) ; } data . params . src = data . params . src || object . attr ( 'data' ) ; } if ( embed ) { // Get width/height width = width || embed . attr ( 'width' ) ; height = height || embed . attr ( 'height' ) ; style = style || embed . attr ( 'style' ) ; id = id || embed . attr ( 'id' ) ; hspace = hspace || embed . attr ( 'hspace' ) ; vspace = vspace || embed . attr ( 'vspace' ) ; align = align || embed . attr ( 'align' ) ; bgcolor = bgcolor || embed . attr ( 'bgcolor' ) ; // Get all embed attributes for ( name in embed . attributes . map ) { if ( ! excludedAttrs [ name ] && ! data . params [ name ] ) data . params [ name ] = embed . attributes . map [ name ] ; } } if ( iframe ) { // Get width/height width = normalizeSize ( iframe . attr ( 'width' ) ) ; height = normalizeSize ( iframe . attr ( 'height' ) ) ; style = style || iframe . attr ( 'style' ) ; id = iframe . attr ( 'id' ) ; hspace = iframe . attr ( 'hspace' ) ; vspace = iframe . attr ( 'vspace' ) ; align = iframe . attr ( 'align' ) ; bgcolor = iframe . attr ( 'bgcolor' ) ; tinymce . each ( rootAttributes , function ( name ) { img . attr ( name , iframe . attr ( name ) ) ; } ) ; // Get all iframe attributes for ( name in iframe . attributes . map ) { if ( ! excludedAttrs [ name ] && ! data . params [ name ] ) data . params [ name ] = iframe . attributes . map [ name ] ; } } // Use src not movie if ( data . params . movie ) { data . params . src = data . params . src || data . params . movie ; delete data . params . movie ; } // Convert the URL to relative/absolute depending on configuration if ( data . params . src ) data . params . src = urlConverter . call ( urlConverterScope , data . params . src , 'src' , 'object' ) ; if ( video ) { if ( node . name === 'video' ) type = lookup . video . name ; else if ( node . name === 'audio' ) type = lookup . audio . name ; } if ( object && ! type ) type = ( lookupAttribute ( object , 'clsid' ) || lookupAttribute ( object , 'classid' ) || lookupAttribute ( object , 'type' ) || { } ) . name ; if ( embed && ! type ) type = ( lookupAttribute ( embed , 'type' ) || lookupExtension ( data . params . src ) || { } ) . name ; // for embedded audio we preserve the original specified type if ( embed && type == 'EmbeddedAudio' ) { data . params . type = embed . attr ( 'type' ) ; } // Replace the video/object/embed element with a placeholder image containing the data node . replace ( img ) ; // Remove embed if ( embed ) embed . remove ( ) ; // Serialize the inner HTML of the object element if ( object ) { html = getInnerHTML ( object . remove ( ) ) ; if ( html ) data . object_html = html ; } // Serialize the inner HTML of the video element if ( video ) { html = getInnerHTML ( video . remove ( ) ) ; if ( html ) data . video_html = html ; } data . hspace = hspace ; data . vspace = vspace ; data . align = align ; data . bgcolor = bgcolor ; // Set width/height of placeholder img . attr ( { id : id , 'class' : 'mceItemMedia mceItem' + ( type || 'Flash' ) , style : style , width : width || ( node . name == 'audio' ? "300" : "320" ) , height : height || ( node . name == 'audio' ? "32" : "240" ) , hspace : hspace , vspace : vspace , align : align , bgcolor : bgcolor , "data-mce-json" : JSON . serialize ( data , "'" ) } ) ; } 
function ( binding ) { var me = this , keyCode = binding . key , i , len ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } if ( Ext . isArray ( binding ) ) { for ( i = 0 , len = binding . length ; i < len ; i ++ ) { me . addBinding ( binding [ i ] ) ; } return ; } me . bindings . push ( Ext . apply ( { keyCode : me . processKeys ( keyCode ) } , binding ) ) ; } 
function ( binding ) { var me = this , bindings = me . bindings , len = bindings . length , i , item , keys ; if ( me . processing ) { me . bindings = bindings . slice ( 0 ) ; } keys = me . processKeys ( binding . key ) ; for ( i = 0 ; i < len ; ++ i ) { item = bindings [ i ] ; if ( item . fn === binding . fn && item . scope === binding . scope ) { if ( binding . alt == item . alt && binding . crtl == item . crtl && binding . shift == item . shift ) { if ( Ext . Array . equals ( item . keyCode , keys ) ) { Ext . Array . erase ( me . bindings , i , 1 ) ; return ; } } } } } 
function ( binding , event ) { if ( this . checkModifiers ( binding , event ) ) { var key = event . getKey ( ) , handler = binding . fn || binding . handler , scope = binding . scope || this , keyCode = binding . keyCode , defaultEventAction = binding . defaultEventAction , i , len , keydownEvent = new Ext . EventObjectImpl ( event ) ; for ( i = 0 , len = keyCode . length ; i < len ; ++ i ) { if ( key === keyCode [ i ] ) { if ( handler . call ( scope , key , event ) !== true && defaultEventAction ) { keydownEvent [ defaultEventAction ] ( ) ; } break ; } } } } 
function ( binding , e ) { var keys = [ 'shift' , 'ctrl' , 'alt' ] , i = 0 , len = keys . length , val , key ; for ( ; i < len ; ++ i ) { key = keys [ i ] ; val = binding [ key ] ; if ( ! ( val === undefined || ( val === e [ key + 'Key' ] ) ) ) { return false ; } } return true ; } 
function ( key , fn , scope ) { var keyCode , shift , ctrl , alt ; if ( Ext . isObject ( key ) && ! Ext . isArray ( key ) ) { keyCode = key . key ; shift = key . shift ; ctrl = key . ctrl ; alt = key . alt ; } else { keyCode = key ; } this . addBinding ( { key : keyCode , shift : shift , ctrl : ctrl , alt : alt , fn : fn , scope : scope } ) ; } 
function ( ) { var me = this ; if ( ! me . enabled ) { me . target . on ( me . eventName , me . handleTargetEvent , me ) ; me . enabled = true ; } } 
function ( ) { var me = this ; if ( me . enabled ) { me . target . removeListener ( me . eventName , me . handleTargetEvent , me ) ; me . enabled = false ; } } 
function ( removeTarget ) { var me = this , target = me . target ; me . bindings = [ ] ; me . disable ( ) ; if ( removeTarget === true ) { if ( target . isComponent ) { target . destroy ( ) ; } else { target . remove ( ) ; } } delete me . target ; } 
function ( ) { var wrap = arguments [ 0 ] , items = this . getLayoutItems ( ) , index = Ext . Array . indexOf ( items , this . activeItem ) ; return items [ index + 1 ] || ( wrap ? items [ 0 ] : false ) ; } 
function ( ) { var el = Ext . getBody ( ) . createChild ( { tag : 'div' , style : 'position:absolute;overflow:auto;height:100px;width:100px;' , children : [ { tag : 'div' , style : 'height:30px;width:150px;' } ] } ) , dom = el . dom , flag = 2 ; if ( dom . scrollLeft === 50 ) { flag = 1 ; } else { dom . scrollLeft = - 1 ; if ( dom . scrollLeft ) { flag = 0 ; } } el . remove ( ) ; return flag ; } 
function ( xtype ) { var me = this ; if ( Ext . isArray ( xtype ) ) { Ext . Array . forEach ( xtype , me . addXTypeToWhitelist , me ) ; return ; } if ( ! Ext . Array . contains ( me . whitelist , xtype ) ) { me . whitelist . push ( xtype ) ; } } 
function ( xtype ) { var me = this ; if ( Ext . isArray ( xtype ) ) { Ext . Array . forEach ( xtype , me . removeXTypeFromWhitelist , me ) ; return ; } Ext . Array . remove ( me . whitelist , xtype ) ; } 
function ( ) { var me = this , items = me . flushQueue . clear ( ) , length = items . length , i ; if ( length ) { ++ me . flushCount ; for ( i = 0 ; i < length ; ++ i ) { items [ i ] . flush ( ) ; } } } 
function ( parent , el ) { var id = el . id , children = parent . children , items = this . items ; if ( children ) { Ext . Array . remove ( children , items [ id ] ) ; } delete items [ id ] ; } 
function ( ) { var me = this , layouts = me . layoutQueue . clear ( ) , length = layouts . length , i ; ++ me . cycleCount ; 
function ( layout ) { var me = this , ownerContext = me . getCmp ( layout . owner ) ; layout . pending = false ; if ( ownerContext . state . blocks ) { return ; } 
function ( item , width , height ) { var items = item , len = 1 , contextItem , i ; 
function Strategy ( options , validate ) { options = options || { } ; options . providerURL = options . providerURL || 'https://api.screenname.aol.com/auth/openid/xrds' ; 
function parse ( argv , options ) { options = Object . assign ( { } , constants_1 . PARSER_DEFAULTS , options ) ; var _result = { _ : [ ] , __ : [ ] } ; var _configs , _aliases , _indexed , _maxIndex ; function handleError ( message ) { var args = [ ] ; for ( var _i = 1 ; _i < arguments . length ; _i ++ ) { args [ _i - 1 ] = arguments [ _i ] ; } var template = message ; message = util_1 . format . apply ( void 0 , [ message ] . concat ( args ) ) ; var err = new Error ( message ) ; if ( ! options . onParserError ) throw err ; options . onParserError ( err , template , args ) ; } function getConfig ( key ) { 
function ( model , setOnStore ) { var me = this ; me . model = Ext . ModelManager . getModel ( model ) ; me . setReader ( this . reader ) ; me . setWriter ( this . writer ) ; if ( setOnStore && me . store ) { me . store . setModel ( me . model ) ; } } 
function ( reader ) { var me = this , needsCopy = true , current = me . reader ; if ( reader === undefined || typeof reader == 'string' ) { reader = { type : reader } ; needsCopy = false ; } if ( reader . isReader ) { reader . setModel ( me . model ) ; } else { if ( needsCopy ) { reader = Ext . apply ( { } , reader ) ; } Ext . applyIf ( reader , { proxy : me , model : me . model , type : me . defaultReaderType } ) ; reader = Ext . createByAlias ( 'reader.' + reader . type , reader ) ; } if ( reader !== current && reader . onMetaChange ) { reader . onMetaChange = Ext . Function . createSequence ( reader . onMetaChange , this . onMetaChange , this ) ; } me . reader = reader ; return me . reader ; } 
function ( writer ) { var me = this , needsCopy = true ; if ( writer === undefined || typeof writer == 'string' ) { writer = { type : writer } ; needsCopy = false ; } if ( ! writer . isWriter ) { if ( needsCopy ) { writer = Ext . apply ( { } , writer ) ; } Ext . applyIf ( writer , { model : me . model , type : me . defaultWriterType } ) ; writer = Ext . createByAlias ( 'writer.' + writer . type , writer ) ; } me . writer = writer ; return me . writer ; } 
function evict ( newId ) { _.errout(JSON.stringify(edits)) } _.assertEqual(edits[1].edit.id, evictedId)*/ if ( ob . isNew ( evictedId ) ) { ob . write ( evictedId , edits ) } else { ob . append ( evictedId , edits ) } delete cache [ evictedId ] _.assertInt(order[i]) _.assert(order[i] !== evictedId) }*/ } 
function getOldestFilename ( callback ) { getLogFiles ( function ( err , files ) { if ( err ) { callback ( err , null ) ; } else if ( ! files || files . length === 0 ) { return callback ( null , Date . now ( ) . toString ( ) . concat ( FILE_EXT ) ) ; } else { var file = _ . min ( files , function ( f ) { 
function getMostRecentFilename ( callback ) { getLogFiles ( function ( err , files ) { if ( err ) { callback ( err , null ) ; } else if ( ! files || files . length === 0 ) { return callback ( null , Date . now ( ) . toString ( ) . concat ( FILE_EXT ) ) ; } else { var file = _ . max ( files , function ( f ) { var n = ( f && typeof f . name === 'string' ) ? f . name : f ; 
function getRequiredFilename ( name , callback ) { var filepath = path . join ( LOG_DIR , name ) ; function getStats ( ) { fs . stat ( filepath , function ( err , stats ) { if ( err ) { callback ( err , null ) ; } else if ( stats && stats . size >= MAX_FILE_SIZE ) { createFile ( ) ; } else { callback ( null , name ) ; } } ) ; } function createFile ( ) { fs . writeFile ( filepath , '[]' , function ( err ) { if ( err ) { callback ( err , null ) ; } else { callback ( null , name ) ; } } ) ; } fs . exists ( filepath , function ( exists ) { if ( exists ) { getStats ( ) ; } else { createFile ( ) ; } } ) ; } 
function getWriteFunction ( log ) { return function writeLogFile ( name , qcb ) { var dir = path . join ( LOG_DIR , name ) ; function readFile ( cb ) { fs . readFile ( dir , cb ) ; } function updateLogs ( logs , cb ) { logs . push ( log . toJSON ( ) ) ; cb ( null , logs ) ; } function writeFile ( str , cb ) { fs . writeFile ( dir , str , cb ) ; } async . waterfall ( [ readFile , safejson . parse , updateLogs , safejson . stringify , writeFile ] , qcb ) ; } ; } 
function getLogsObject ( name , callback ) { fs . readFile ( path . join ( LOG_DIR , name ) , function ( err , data ) { if ( err ) { return callback ( err , null ) ; } safejson . parse ( data , function ( err , logArray ) { if ( err ) { return callback ( err , null ) ; } callback ( null , { logs : logArray } ) ; } ) ; } ) ; } 
function deleteFile ( name , callback ) { fs . unlink ( path . join ( LOG_DIR , name ) , callback ) ; } 
function ( ) { this . port = DEFAULT_STUBBATTI_PORT ; this . app = express ( ) ; this . console = global . console ; var stubbatti = this ; this . app [ KILL_METHOD ] ( KILL_PATH , function ( req , res ) { res . set ( 'Connection' , 'close' ) ; res . end ( ) ; stubbatti . stop ( ) ; } ) ; } 
function bravojs_init ( bravojs , window ) { try { bravojs . window = window ; if ( ! bravojs . hasOwnProperty ( "errorReporter" ) ) { bravojs . errorReporter = function bravojs_defaultDrrorReporter ( e ) { if ( typeof alert != "undefined" ) alert ( " * BravoJS: " + e + "\n" + e . stack ) ; throw ( e ) ; } } bravojs . reset = function bravojs_reset ( mainModuleDir , plugins ) { if ( ! mainModuleDir ) { if ( typeof bravojs . mainModuleDir != "undefined" ) mainModuleDir = bravojs . mainModuleDir ; else mainModuleDir = bravojs . dirname ( bravojs . URL_toId ( window . location . href + ".js" , true ) ) ; } bravojs . requireMemo = { } ; bravojs . pendingModuleDeclarations = { } ; bravojs . mainModuleDir = mainModuleDir ; bravojs . plugins = plugins || [ ] ; bravojs . contexts = { } ; bravojs . activeContexts = [ ] ; delete bravojs . Module . prototype . main ; delete bravojs . scriptTagMemo ; delete bravojs . scriptTagMemoIE ; bravojs . makeContext ( "_" ) ; bravojs . module = window . module = new bravojs . Module ( '' , [ ] ) ; bravojs . require = window . require = bravojs . requireFactory ( bravojs . mainModuleDir , [ ] , bravojs . module ) ; bravojs . module . declare = function main_module_declare ( dependencies , moduleFactory ) { if ( typeof dependencies === "function" ) { moduleFactory = dependencies ; dependencies = [ ] ; } bravojs . initializeMainModule ( dependencies , moduleFactory , '' ) ; } } function bravojs_print ( ) { var output = "" ; var i ; var stdout ; for ( i = 0 ; i < arguments . length ; i ++ ) output += arguments [ i ] + ( i === arguments . length - 1 ? "" : " " ) ; output . replace ( / \t / , " " ) ; if ( typeof window . document != "undefined" && ( stdout = window . document . getElementById ( 'stdout' ) ) ) { output += "\n" ; if ( typeof stdout . value !== "undefined" ) { stdout . value += output ; if ( stdout . focus ) stdout . focus ( ) ; if ( stdout . tagName === "TEXTAREA" ) stdout . scrollTop = stdout . scrollHeight ; } else { if ( typeof stdout . innerText !== "undefined" ) { stdout . innerText = stdout . innerText . slice ( 0 , - 1 ) + output + " " ; } else stdout . textContent += output ; } } else if ( typeof console === "object" && console . print ) { console . print ( output ) ; } else if ( typeof console === "object" && console . log ) { console . log ( output ) ; } * Treats paths with trailing slashes as though they end with INDEX instead. * Not rigorous. */ bravojs . realpath = function bravojs_realpath ( path , index ) { if ( typeof index === "undefined" ) index = "INDEX" ; if ( typeof path !== "string" ) path = path . toString ( ) ; var oldPath = path . split ( '/' ) ; var newPath = [ ] ; var i ; if ( path . charAt ( path . length - 1 ) === '/' && index ) oldPath . push ( index ) ; for ( i = 0 ; i < oldPath . length ; i ++ ) { if ( oldPath [ i ] == '.' || ! oldPath [ i ] . length ) continue ; if ( oldPath [ i ] == '..' ) { if ( ! newPath . length ) throw new Error ( "Invalid module path: " + path ) ; newPath . pop ( ) ; continue ; } newPath . push ( oldPath [ i ] ) ; } newPath . unshift ( '' ) ; return newPath . join ( '/' ) ; } bravojs . basename = function bravojs_basename ( path ) { if ( typeof path !== "string" ) path = path . toString ( ) ; var s = path . split ( '/' ) . slice ( - 1 ) . join ( '/' ) ; if ( ! s ) return path ; return s ; } bravojs . dirname = function bravojs_dirname ( path ) { if ( typeof path !== "string" ) path = path . toString ( ) ; if ( path . charAt ( path . length - 1 ) === '/' ) return path . slice ( 0 , - 1 ) ; var s = path . split ( '/' ) . slice ( 0 , - 1 ) . join ( '/' ) ; if ( ! s ) return "." ; return s ; } bravojs . makeModuleId = function makeModuleId ( relativeModuleDir , moduleIdentifier ) { return bravojs . contextForId ( relativeModuleDir , true ) . resolveId ( moduleIdentifier , relativeModuleDir ) ; } bravojs . URL_toId = function URL_toId ( moduleURL , relaxValidation ) { var i ; i = moduleURL . indexOf ( "://" ) ; if ( i == - 1 ) throw new Error ( "Invalid module URL: " + moduleURL ) ; id = moduleURL . slice ( i + 2 ) ; id = bravojs . realpath ( id ) ; if ( ( i = id . indexOf ( '?' ) ) != - 1 ) id = id . slice ( 0 , i ) ; if ( ( i = id . indexOf ( '#' ) ) != - 1 ) id = id . slice ( 0 , i ) ; if ( ! relaxValidation && ( id . slice ( - 3 ) != ".js" ) ) throw new Error ( "Invalid module URL: " + moduleURL ) ; id = id . slice ( 0 , - 3 ) ; return id ; } bravojs . normalizeDependencyArray = function bravojs_normalizeDependencyArray ( dependencies , relativeModuleDir ) { var normalizedDependencies = [ ] ; var i , label ; function addNormal ( moduleIdentifier ) { var id = moduleIdentifier ; if ( typeof id != "string" || id . charAt ( 0 ) != "/" ) id = bravojs . contextForId ( relativeModuleDir , true ) . resolveId ( id , relativeModuleDir ) ; if ( id === null ) return ; if ( bravojs . requireMemo [ id ] || bravojs . pendingModuleDeclarations [ id ] ) return ; normalizedDependencies . push ( id ) ; } for ( i = 0 ; i < dependencies . length ; i ++ ) { if ( dependencies [ i ] ) { switch ( typeof dependencies [ i ] ) { case "object" : for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . hasOwnProperty ( label ) ) addNormal ( dependencies [ i ] [ label ] ) ; } break ; case "string" : addNormal ( dependencies [ i ] ) ; break ; default : throw new Error ( "Invalid dependency array value at position " + ( i + 1 ) ) ; } } } return normalizedDependencies ; } bravojs . contextForId = function bravojs_contextForId ( id , onlyCreateIfDelimited ) { return bravojs . contexts [ "_" ] ; } bravojs . makeContext = function bravojs_makeContext ( id ) { return bravojs . contexts [ id ] = new bravojs . Context ( id ) ; } bravojs . Context = function bravojs_Context ( id ) { this . id = id ; } bravojs . Context . prototype . resolveId = function bravojs_Context_resolveId ( moduleIdentifier , relativeModuleDir ) { var id ; if ( moduleIdentifier === '' ) return '' ; if ( typeof moduleIdentifier !== "string" ) throw new Error ( "Invalid module identifier: " + moduleIdentifier ) ; if ( moduleIdentifier . charAt ( 0 ) === '/' ) { id = moduleIdentifier ; } else if ( ( moduleIdentifier . indexOf ( "./" ) == 0 ) || ( moduleIdentifier . indexOf ( "../" ) == 0 ) ) { id = relativeModuleDir + "/" + moduleIdentifier ; } else { id = bravojs . mainModuleDir + "/" + moduleIdentifier ; } return bravojs . realpath ( id ) ; } bravojs . provideModule = function bravojs_provideModule ( dependencies , moduleFactory , id , callback ) { if ( moduleFactory ) bravojs . require . memoize ( id , dependencies , moduleFactory ) ; if ( dependencies ) { bravojs . module . provide ( bravojs . normalizeDependencyArray ( dependencies , id ? bravojs . dirname ( id ) : bravojs . mainModuleDir ) , callback ) ; } else { if ( callback ) callback ( ) ; } } bravojs . initializeModule = function bravojs_initializeModule ( id ) { var moduleDir = id ? bravojs . dirname ( id ) : bravojs . mainModuleDir ; var moduleFactory = bravojs . pendingModuleDeclarations [ id ] . moduleFactory ; var dependencies = bravojs . pendingModuleDeclarations [ id ] . dependencies ; var require , exports , module ; delete bravojs . pendingModuleDeclarations [ id ] ; exports = bravojs . requireMemo [ id ] = { } ; module = new bravojs . Module ( id , dependencies ) ; if ( typeof module . augment == "function" ) module . augment ( ) ; require = bravojs . requireFactory ( moduleDir , dependencies , module ) ; moduleFactory ( require , exports , module ) ; } bravojs . requireModule = function bravojs_requireModule ( parentModuleDir , moduleIdentifier ) { bravojs . activeContexts = [ ] ; var id = bravojs . makeModuleId ( parentModuleDir , moduleIdentifier ) ; var exports = bravojs . callPlugins ( "requireModule" , [ id ] ) ; if ( typeof exports != "undefined" ) { if ( exports === true ) return bravojs . requireMemo [ id ] ; return bravojs . requireMemo [ id ] = exports ; } if ( id === false ) return null ; if ( ! bravojs . requireMemo [ id ] && bravojs . pendingModuleDeclarations [ id ] ) bravojs . initializeModule ( id ) ; if ( id === null || ! bravojs . requireMemo [ id ] ) throw new Error ( "Module " + id + " is not available." ) ; return bravojs . requireMemo [ id ] ; } bravojs . requireFactory = function bravojs_requireFactory ( moduleDir , dependencies , module ) { var deps , i , label ; function getContextSensitiveModuleDir ( ) { var contextId ; if ( bravojs . activeContexts . length > 0 ) contextId = bravojs . activeContexts [ bravojs . activeContexts . length - 1 ] . id ; if ( typeof contextId == "undefined" || ! contextId ) contextId = moduleDir ; else if ( contextId == "_" ) contextId = bravojs . mainModuleDir ; return contextId ; } function addLabeledDep ( moduleIdentifier ) { deps [ label ] = function bravojs_labeled_dependency ( ) { return bravojs . requireModule ( getContextSensitiveModuleDir ( ) , moduleIdentifier ) ; } } if ( dependencies ) { for ( i = 0 ; i < dependencies . length ; i ++ ) { if ( typeof dependencies [ i ] !== "object" ) continue ; for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . hasOwnProperty ( label ) ) { if ( ! deps ) deps = { } ; addLabeledDep ( dependencies [ i ] [ label ] ) ; } } } } var newRequire = function require ( moduleIdentifier ) { if ( deps && deps [ moduleIdentifier ] ) return deps [ moduleIdentifier ] ( ) ; return bravojs . requireModule ( getContextSensitiveModuleDir ( ) , moduleIdentifier ) ; } ; var ret = bravojs . callPlugins ( "newRequire" , [ { module : module , deps : deps , getContextSensitiveModuleDir : getContextSensitiveModuleDir } ] ) ; if ( typeof ret != "undefined" ) newRequire = ret ; newRequire . paths = [ bravojs . mainModuleDir ] ; if ( typeof bravojs . platform != "undefined" ) newRequire . platform = bravojs . platform ; newRequire . id = function require_id ( moduleIdentifier , unsanitized ) { var contextId = getContextSensitiveModuleDir ( ) , context = bravojs . contextForId ( contextId , true ) ; id = context . resolveId ( moduleIdentifier , contextId ) ; if ( unsanitized ) return id ; return bravojs . callPlugins ( "sanitizeId" , [ id ] ) || id ; } newRequire . uri = function require_uri ( moduleIdentifierPath ) { var basename = bravojs . basename ( moduleIdentifierPath ) , parts = basename . split ( "." ) ; var uri = window . location . protocol + "/" + newRequire . id ( moduleIdentifierPath , true ) ; if ( parts . length > 1 ) uri += "." + parts . slice ( 1 ) . join ( "." ) ; return uri ; } newRequire . canonicalize = function require_canonicalize ( moduleIdentifier ) { var id = bravojs . makeModuleId ( getContextSensitiveModuleDir ( ) , moduleIdentifier ) ; if ( id === '' ) throw new Error ( "Cannot canonically name the resource bearing this main module" ) ; return window . location . protocol + "/" + id + ".js" ; } newRequire . memoize = function require_memoize ( id , dependencies , moduleFactory ) { bravojs . pendingModuleDeclarations [ id ] = { moduleFactory : moduleFactory , dependencies : dependencies } ; } newRequire . isMemoized = function require_isMemoized ( id ) { return ( bravojs . pendingModuleDeclarations [ id ] || bravojs . requireMemo [ id ] ) ? true : false ; } newRequire . getMemoized = function require_getMemoized ( id ) { return bravojs . pendingModuleDeclarations [ id ] || bravojs . requireMemo [ id ] ; } bravojs . callPlugins ( "augmentNewRequire" , [ newRequire , { module : module , getContextSensitiveModuleDir : getContextSensitiveModuleDir } ] ) ; return newRequire ; } bravojs . Module = function bravojs_Module ( id , dependencies ) { this . _id = id ; this . id = bravojs . callPlugins ( "sanitizeId" , [ id ] ) || id ; this [ "protected" ] = void 0 ; this . dependencies = dependencies ; this . print = bravojs . print ; var i , label ; this . deps = { } ; for ( i = 0 ; i < dependencies . length ; i ++ ) { if ( typeof dependencies [ i ] === "string" ) continue ; if ( typeof dependencies [ i ] !== "object" ) throw new Error ( "Invalid " + typeof dependencies [ i ] + " element in dependency array at position " + i ) ; for ( label in dependencies [ i ] ) { if ( dependencies [ i ] . hasOwnProperty ( label ) ) { this . deps [ label ] = function bravojs_lambda_module_deps ( ) { bravojs . requireModule ( bravojs . dirname ( id ) , dependencies [ i ] [ label ] ) ; } ; } } } } bravojs . Module . prototype . declare = function bravojs_Module_declare ( dependencies , moduleFactory ) { var stm ; if ( typeof dependencies === "function" ) { moduleFactory = dependencies ; dependencies = [ ] ; } stm = bravojs . scriptTagMemo ; if ( stm && stm . id === '' ) { delete bravojs . scriptTagMemo ; bravojs . provideModule ( dependencies , moduleFactory , stm . id , stm . callback ) ; return ; } if ( stm ) throw new Error ( "Bug" ) ; if ( document . addEventListener ) { bravojs . scriptTagMemo = { dependencies : dependencies , moduleFactory : moduleFactory } ; return ; } stm = bravojs . scriptTagMemoIE ; delete bravojs . scriptTagMemoIE ; if ( stm && stm . id ) { bravojs . provideModule ( dependencies , moduleFactory , stm . id , stm . callback ) ; return ; } var scripts = document . getElementsByTagName ( "SCRIPT" ) ; var i ; for ( i = 0 ; i < scripts . length ; i ++ ) { if ( scripts [ i ] . readyState === "interactive" ) { bravojs . provideModule ( dependencies , moduleFactory , bravojs . URL_toId ( scripts [ i ] . src ) , stm . callback ) ; return ; } } throw new Error ( "Could not determine module's canonical name from script-tag loader" ) ; } bravojs . Module . prototype . provide = function bravojs_Module_provide ( dependencies , callback ) { var self = arguments . callee ; if ( ( typeof dependencies !== "object" ) || ( dependencies . length !== 0 && ! dependencies . length ) ) throw new Error ( "Invalid dependency array: " + dependencies . toString ( ) ) ; dependencies = bravojs . normalizeDependencyArray ( dependencies , ( this . _id ) ? this . _id : bravojs . mainModuleDir ) ; if ( dependencies . length === 0 ) { if ( callback ) callback ( ) ; return ; } bravojs . activeContexts . push ( bravojs . contextForId ( dependencies [ 0 ] , true ) ) ; bravojs . module . load ( dependencies [ 0 ] , function bravojs_lambda_provideNextDep ( ) { self ( dependencies . slice ( 1 ) , callback ) } ) ; bravojs . activeContexts . pop ( ) ; } bravojs . Module . prototype . load = function bravojs_Module_load ( moduleIdentifier , callback ) { if ( window . module . hasOwnProperty ( "declare" ) ) delete window . module . declare ; var script = document . createElement ( 'SCRIPT' ) ; script . setAttribute ( "type" , "text/javascript" ) ; script . setAttribute ( "src" , bravojs . require . canonicalize ( moduleIdentifier ) + "?1" ) ; if ( document . addEventListener ) { script . onload = function bravojs_lambda_script_onload ( ) { var stm = bravojs . scriptTagMemo ; if ( typeof stm === "undefined" ) throw new Error ( "Module '" + moduleIdentifier + "' did not invoke module.declare!" ) ; delete bravojs . scriptTagMemo ; if ( typeof moduleIdentifier == "object" ) { moduleIdentifier = bravojs . makeModuleId ( bravojs . mainModuleDir , moduleIdentifier ) ; } bravojs . activeContexts . push ( bravojs . contextForId ( moduleIdentifier , true ) ) ; bravojs . provideModule ( stm . dependencies , stm . moduleFactory , bravojs . require . id ( moduleIdentifier , true ) , function ( ) { callback ( moduleIdentifier ) ; } ) ; bravojs . activeContexts . pop ( ) ; } script . onerror = function bravojs_lambda_script_onerror ( ) { var id = bravojs . require . id ( moduleIdentifier , true ) ; bravojs . pendingModuleDeclarations [ id ] = null ; callback ( ) ; } } else { bravojs . scriptTagMemoIE = { moduleIdentifier : moduleIdentifier , callback : callback } ; script . onreadystatechange = function bravojs_lambda_script_onreadystatechange ( ) { if ( this . readyState != "loaded" ) return ; var id = bravojs . require . id ( moduleIdentifier , true ) ; if ( ! bravojs . pendingModuleDeclarations [ id ] && ! bravojs . requireMemo [ id ] && id === bravojs . scriptTagMemoIE . moduleIdentifier ) { bravojs . pendingModuleDeclarations [ id ] = null ; callback ( ) ; } } } document . getElementsByTagName ( "HEAD" ) [ 0 ] . appendChild ( script ) ; } bravojs . Module . prototype . eventually = function ( cb ) { cb ( ) ; } ; bravojs . es5_shim_then = function bravojs_es5_shim_then ( callback ) { if ( ! Array . prototype . indexOf ) { var script = document . createElement ( 'SCRIPT' ) ; script . setAttribute ( "type" , "text/javascript" ) ; script . setAttribute ( "src" , bravojs . dirname ( bravojs . url ) + "/global-es5.js?1" ) ; if ( document . addEventListener ) script . onload = callback ; else { script . onreadystatechange = function ( ) { if ( this . readyState === "loaded" ) callback ( ) ; } } document . getElementsByTagName ( "HEAD" ) [ 0 ] . appendChild ( script ) ; } else { callback ( ) ; } } bravojs . reloadModule = function ( id , callback ) { delete bravojs . pendingModuleDeclarations [ id ] ; delete bravojs . requireMemo [ id ] ; bravojs . module . provide ( [ id ] , callback ) ; } bravojs . initializeMainModule = function bravojs_initializeMainModule ( dependencies , moduleFactory , moduleIdentifier ) { if ( bravojs . module . hasOwnProperty ( "declare" ) ) delete bravojs . module . declare ; if ( bravojs . module . constructor . prototype . main ) throw new Error ( "Main module has already been initialized!" ) ; bravojs . es5_shim_then ( ( function ( ) { bravojs . provideModule ( dependencies , moduleFactory , moduleIdentifier , function bravojs_lambda_requireMain ( ) { bravojs . module . constructor . prototype . main = bravojs . require ( moduleIdentifier ) ; } ) } ) ) ; } bravojs . runExternalMainModule = function bravojs_runExternalProgram ( dependencies , moduleIdentifier , callback ) { if ( arguments . length === 1 || typeof moduleIdentifier === "function" ) { callback = moduleIdentifier ; moduleIdentifier = dependencies ; dependencies = [ ] ; } delete bravojs . module . declare ; if ( moduleIdentifier . charAt ( 0 ) === '/' ) bravojs . mainModuleDir = bravojs . dirname ( moduleIdentifier ) ; else bravojs . mainModuleDir = bravojs . dirname ( bravojs . URL_toId ( window . location . href + ".js" ) , true ) + "/" + bravojs . dirname ( moduleIdentifier ) ; moduleIdentifier = bravojs . basename ( moduleIdentifier ) ; bravojs . es5_shim_then ( function ( ) { bravojs . module . provide ( dependencies . concat ( [ moduleIdentifier ] ) , function bravojs_runMainModule ( ) { bravojs . initializeMainModule ( dependencies , '' , moduleIdentifier ) ; if ( callback ) callback ( ) ; } ) } ) ; } bravojs . reset ( ) ; if ( typeof bravojs . url === "undefined" ) { ( function bravojs_setURL ( ) { var i ; var checkBasename = false ; var script ; script = document . getElementById ( "BravoJS" ) ; if ( ! script ) { checkBasename = true ; script = document . getElementsByTagName ( "SCRIPT" ) [ 0 ] ; } bravojs . url = script . src ; i = bravojs . url . indexOf ( "?" ) ; if ( i !== - 1 ) bravojs . url = bravojs . url . slice ( 0 , i ) ; i = bravojs . url . indexOf ( "#" ) ; if ( i !== - 1 ) bravojs . url = bravojs . url . slice ( 0 , i ) ; if ( checkBasename && bravojs . basename ( bravojs . url ) !== "bravo.js" ) throw new Error ( "Could not determine BravoJS URL. BravoJS must be the first script, or have id='BravoJS'" ) ; } ) ( ) ; } var print = bravojs . print ; if ( ! window . onerror ) { window . onerror = function window_onerror ( message , url , line ) { var scripts , i ; print ( "\n * Error: " + message + "\n" + " in: " + url + "\n" + " line: " + line ) ; } } } catch ( e ) { bravojs . errorReporter ( e ) ; } } 
function bravojs_print ( ) { var output = "" ; var i ; var stdout ; for ( i = 0 ; i < arguments . length ; i ++ ) output += arguments [ i ] + ( i === arguments . length - 1 ? "" : " " ) ; output . replace ( / \t / , " " ) ; if ( typeof window . document != "undefined" && ( stdout = window . document . getElementById ( 'stdout' ) ) ) { output += "\n" ; if ( typeof stdout . value !== "undefined" ) { stdout . value += output ; if ( stdout . focus ) stdout . focus ( ) ; if ( stdout . tagName === "TEXTAREA" ) stdout . scrollTop = stdout . scrollHeight ; } else { if ( typeof stdout . innerText !== "undefined" ) { stdout . innerText = stdout . innerText . slice ( 0 , - 1 ) + output + " " ; } else stdout . textContent += output ; } } else if ( typeof console === "object" && console . print ) { console . print ( output ) ; } else if ( typeof console === "object" && console . log ) { console . log ( output ) ; } 
function str2blks_MD5 ( str ) { nblk = ( ( str . length + 8 ) >> 6 ) + 1 ; blks = new Array ( nblk * 16 ) ; for ( i = 0 ; i < nblk * 16 ; i ++ ) blks [ i ] = 0 ; for ( i = 0 ; i < str . length ; i ++ ) blks [ i >> 2 ] |= str . charCodeAt ( i ) << ( ( i % 4 ) * 8 ) ; blks [ i >> 2 ] |= 0x80 << ( ( i % 4 ) * 8 ) ; blks [ nblk * 16 - 2 ] = str . length * 8 ; return blks ; } 
function cmn ( q , a , b , x , s , t ) { return add ( rol ( add ( add ( a , q ) , add ( x , t ) ) , s ) , b ) ; } 
function bound ( ) { if ( this instanceof bound ) { 
function Setting ( settingSpec , settings ) { this . _settings = settings ; Object . keys ( settingSpec ) . forEach ( function ( key ) { this [ key ] = settingSpec [ key ] ; } , this ) ; this . type = types . getType ( this . type ) ; if ( this . type == null ) { throw new Error ( 'In ' + this . name + ': can\'t find type for: ' + JSON . stringify ( settingSpec . type ) ) ; } if ( ! this . name ) { throw new Error ( 'Setting.name == undefined. Ignoring.' , this ) ; } if ( ! this . defaultValue === undefined ) { throw new Error ( 'Setting.defaultValue == undefined' , this ) ; } if ( this . onChange ) { this . on ( 'change' , this . onChange . bind ( this ) ) } this . set ( this . defaultValue ) ; } 
function ( settingSpec ) { var setting = new Setting ( settingSpec , this ) ; this . _settings [ setting . name ] = setting ; this . _settingNames . push ( setting . name ) ; this . _settingNames . sort ( ) ; } 
function ( ) { var reply = [ ] ; this . getSettingNames ( ) . forEach ( function ( setting ) { reply . push ( { 'key' : setting , 'value' : this . getSetting ( setting ) . get ( ) } ) ; } , this ) ; return reply ; } 
function ( data ) { 
function ( ) { return this . getSettingNames ( ) . map ( function ( key ) { return this . _settings [ key ] . type . stringify ( this . get ( key ) ) ; } . bind ( this ) ) ; } 
function ( statuses ) { var combined = Status . VALID ; for ( var i = 0 ; i < statuses . length ; i ++ ) { if ( statuses [ i ] . valueOf ( ) > combined . valueOf ( ) ) { combined = statuses [ i ] ; } } return combined ; } 
function Conversion ( value , status , message , predictions ) { this . value = value ; this . status = status || Status . VALID ; this . message = message ; this . predictions = predictions || [ ] ; } 
function reconstituteType ( name , typeSpec ) { if ( name . substr ( - 2 ) === '[]' ) { 
function addCommand ( command ) { if ( ! command . name ) { throw new Error ( 'All registered commands must have a name' ) ; } if ( command . params == null ) { command . params = [ ] ; } if ( ! Array . isArray ( command . params ) ) { throw new Error ( 'command.params must be an array in ' + command . name ) ; } 
function defaultArgsProvider ( request , callback ) { var args = request . args , params = request . command . params ; for ( var i = 0 ; i < params . length ; i ++ ) { var param = params [ i ] ; 
function exec ( command , env , sender , args , typed ) { if ( typeof command === 'string' ) { command = commands [ command ] ; } if ( ! command ) { * Executes the command and ensures request.done is called on the request in * case it's not marked to be done already or async. */ function execute ( ) { command . exec ( env , request . args , request ) ; // If the request isn't asnync and isn't done, then make it done. if ( ! request . isAsync && ! request . isDone ) { request . done ( ) ; } } if ( request . getStatus ( ) == Status . INVALID ) { console . error ( "Canon.exec: Invalid parameter(s) passed to " + command . name ) ; return false ; } // If the request isn't complete yet, try to complete it. else if ( request . getStatus ( ) == Status . INCOMPLETE ) { 
function execute ( ) { command . exec ( env , request . args , request ) ; 
function Request ( options ) { options = options || { } ; 
function ( editor ) { this . editor = editor ; event . addListener ( editor . container , "mousedown" , function ( e ) { editor . focus ( ) ; return event . preventDefault ( e ) ; } ) ; event . addListener ( editor . container , "selectstart" , function ( e ) { return event . preventDefault ( e ) ; } ) ; var mouseTarget = editor . renderer . getMouseEventTarget ( ) ; event . addListener ( mouseTarget , "mousedown" , this . onMouseDown . bind ( this ) ) ; event . addMultiMouseDownListener ( mouseTarget , 0 , 2 , 500 , this . onMouseDoubleClick . bind ( this ) ) ; event . addMultiMouseDownListener ( mouseTarget , 0 , 3 , 600 , this . onMouseTripleClick . bind ( this ) ) ; event . addMultiMouseDownListener ( mouseTarget , 0 , 4 , 600 , this . onMouseQuadClick . bind ( this ) ) ; event . addMouseWheelListener ( mouseTarget , this . onMouseWheel . bind ( this ) ) ; } 
function changeOnPath ( local , op , edit , syncId , editId ) { _ . assertInt ( op ) We need: - an index of every existing inner object by id */ console.log(index + ' ' + editNames[e.op] + ' ' + JSON.stringify(e)) })*/ _.errout('invalid inputObject: ' + local.inputObject + '\t' + editId + ' !== ' + local.getEditingId()) }*/ if ( local . objectApiCache ) { ch = local . objectApiCache [ local . inputObject ] } if ( ! ch ) { console . log ( 'WARNING: not found ' + local . inputObject + ', only got: ' + JSON . stringify ( Object . keys ( local . objectApiCache || { } ) ) + ' in ' + local . objectId + ' --- ' + editId ) console . log ( JSON . stringify ( local . edits , null , 2 ) ) throw new Error ( 'here' ) return } _ . assertObject ( ch ) } var property = ch . typeSchema . propertiesByCode [ local . inputProperty ] if ( property === undefined ) { var candidates = ' ' + JSON . stringify ( _ . map ( Object . keys ( ch . typeSchema . propertiesByCode ) , function ( p ) { return ch . typeSchema . propertiesByCode [ p ] . name + ':' + ch . typeSchema . propertiesByCode [ p ] . code } ) ) if ( TopObjectHandle . prototype . errorOnWarn ) { _ . errout ( 'WARNING: logic error or removed property, ' + ch . typeSchema . name + ' cannot find property with code: ' + local . inputProperty + candidates ) } else { console . log ( 'WARNING: logic error or removed property, ' + ch . typeSchema . name + ' cannot find property with code: ' + local . inputProperty + candidates ) } return } 
function sameState ( a , b ) { return a . object === b . object && a . property === b . property } 
function thing ( type , value ) { if ( arguments . length < 2 ) { if ( instance ( type , Thing ) ) { return type ; } value = type ; type = typeof value === 'string' || typeof value === 'number' || instance ( value , RegExp ) ? 'text' : 'unknown' ; } return instance ( value , Promise ) ? value . then ( thing . bind ( null , type ) ) : new Thing ( type , value ) ; } 
function ( viewName , params , cb ) { _ . assertLength ( arguments , 3 ) _ . assertDefined ( params ) var s = schema [ viewName ] ; if ( s === undefined ) _ . errout ( 'unknown view: ' + viewName ) var viewCode = s . code ; 
function ( viewCode , snapshotId , previousId , paramsStr , cb ) { _ . assertLength ( arguments , 5 ) var s = schema . _byCode [ viewCode ] ; var parsedParams = doParseParams ( paramsStr , s ) var snapReq = { typeCode : viewCode , params : pu . paramsStr ( parsedParams , s . viewSchema . params ) , latestVersionId : snapshotId , previousVersionId : previousId } ; cc . getSnapshot ( snapReq , function ( err , response ) { if ( err ) { cb ( err ) } else { 
function consume_doctype_or_comment ( proc_stack ) { let html = "<!" ; proc_stack . tSkip ( 2 ) ; html += proc_stack . tAcceptUntil ( ">" ) + proc_stack . tAccept ( ) ; return html ; } 
function consume_char_data_with_entity_directives ( proc_stack , decode_entities , break_on_a , break_on_b ) { let parts = [ ] ; let cur_literal = "" ; while ( ! proc_stack . tMatches ( break_on_a ) && ( ! break_on_b || ! proc_stack . tMatches ( break_on_b ) ) ) { let matched = false ; if ( proc_stack . tMatches ( "&zc-" ) ) { if ( decode_entities ) { cur_literal = htmlEntities . decode ( cur_literal ) ; } parts . push ( cur_literal ) ; cur_literal = "" ; parts . push ( consume_directive_entity ( proc_stack ) ) ; matched = true ; break ; } else { cur_literal += proc_stack . tAccept ( ) ; } } if ( decode_entities ) { cur_literal = htmlEntities . decode ( cur_literal ) ; } parts . push ( cur_literal ) ; return parts ; } 
function consume_directive_tag ( proc_stack , tag_name ) { let pos = proc_stack . _tGetNPos ( ) - tag_name . length ; let directive_name = tag_name . slice ( 3 ) ; let raw_args = { } ; proc_stack . tSkipWhile ( WHITESPACE ) ; while ( ! proc_stack . tSkipIf ( ">" ) ) { let arg_name = proc_stack . tAcceptUntil ( "=" ) ; proc_stack . tSkip ( ) ; if ( ! proc_stack . tSkipIf ( "\"" ) ) { throw new SyntaxError ( ` ` ) ; } raw_args [ arg_name ] = consume_char_data_with_entity_directives ( proc_stack , true , "\"" ) ; proc_stack . tSkip ( ) ; proc_stack . tSkipWhile ( WHITESPACE ) ; } let closing_tag = ` ${ directive_name } ` ; 
function consume_opening_or_closing_tag ( proc_stack ) { proc_stack . tSkip ( ) ; let is_closing = proc_stack . tSkipIf ( "/" ) ; let tag_name = proc_stack . tAcceptUntilSet ( TAG_NAME_DELIMITER ) . toLocaleLowerCase ( ) ; if ( ! / ^[a-z0-9]+(-[a-z0-9]+)*(:[a-z0-9]+(-[a-z0-9]+)*)?$ / . test ( tag_name ) ) { throw new SyntaxError ( ` ${ tag_name } ` ) ; } if ( ! is_closing && / ^zc- / . test ( tag_name ) ) { return consume_directive_tag ( proc_stack , tag_name ) ; } let parts = [ ] ; 
function consume_directive_entity ( proc_stack ) { let pos = proc_stack . _tGetNPos ( ) ; proc_stack . tSkip ( 4 ) ; let directive_name = proc_stack . tAcceptUntil ( "(" ) ; proc_stack . tSkip ( ) ; let raw_args = { } ; do { proc_stack . tSkipWhile ( WHITESPACE ) ; if ( proc_stack . tPeek ( ) == ")" ) { break ; } let arg_name = proc_stack . tAcceptUntil ( "=" ) ; proc_stack . tSkip ( ) ; raw_args [ arg_name ] = consume_char_data_with_entity_directives ( proc_stack , true , "," , ")" ) ; } while ( proc_stack . tSkipIf ( "," ) ) ; if ( ! proc_stack . tSkipIf ( ")" ) ) { throw new SyntaxError ( ` ` ) ; } proc_stack . tSkipIf ( ";" ) ; return new DirectiveExpr ( proc_stack , pos , directive_name , raw_args ) ; } 
function ( method , path , cb ) { http . request ( { hostname : DEFAULT_HOST , port : DEFAULT_PORT , path : path , method : method } , function ( res ) { res . pipe ( concat ( { encoding : 'string' } , function ( data ) { cb ( data , res . headers , res . statusCode ) ; } ) ) ; } ) . end ( ) ; } 
function init ( ) { SXE . initElementDialog ( 'del' ) ; if ( SXE . currentAction == "update" ) { setFormValue ( 'datetime' , tinyMCEPopup . editor . dom . getAttrib ( SXE . updateElement , 'datetime' ) ) ; setFormValue ( 'cite' , tinyMCEPopup . editor . dom . getAttrib ( SXE . updateElement , 'cite' ) ) ; SXE . showRemoveButton ( ) ; } } 
function ( operation , callback , scope ) { var me = this , records = operation . records , ids = me . getIds ( ) , idLength = ids . length , newIds = [ ] , removedHash = { } , i = records . length , id ; operation . setStarted ( ) ; for ( ; i -- ; ) { Ext . apply ( removedHash , me . removeRecord ( records [ i ] ) ) ; } for ( i = 0 ; i < idLength ; i ++ ) { id = ids [ i ] ; if ( ! removedHash [ id ] ) { newIds . push ( id ) ; } } me . setIds ( newIds ) ; operation . setCompleted ( ) ; operation . setSuccessful ( ) ; if ( typeof callback == 'function' ) { callback . call ( scope || me , operation ) ; } } 
function ( ) { var me = this , obj = me . getStorageObject ( ) , ids = me . getIds ( ) , len = ids . length , i ; 
function setUp ( ) { function refit ( ) { if ( ! resizeToFit ( iframe ) ) { 
function resizeToFit ( iframe ) { if ( ! iframe ) { 
function setPixelDimensions ( iframe , width , height ) { if ( width ) { iframe . style . width = ` ${ width } ` ; } if ( height ) { iframe . style . height = ` ${ height } ` ; } } 
function ( z , id ) { if ( id === undefined ) { return } var typeCode = z . objectState . getObjectType ( id ) 
function ( version ) { var parts , releaseStartIndex ; if ( version instanceof Version ) { return version ; } this . version = this . shortVersion = String ( version ) . toLowerCase ( ) . replace ( / _ / g , '.' ) . replace ( / [\-+] / g , '' ) ; releaseStartIndex = this . version . search ( / ([^\d\.]) / ) ; if ( releaseStartIndex !== - 1 ) { this . release = this . version . substr ( releaseStartIndex , version . length ) ; this . shortVersion = this . version . substr ( 0 , releaseStartIndex ) ; } this . shortVersion = this . shortVersion . replace ( / [^\d] / g , '' ) ; parts = this . version . split ( '.' ) ; this . major = parseInt ( parts . shift ( ) || 0 , 10 ) ; this . minor = parseInt ( parts . shift ( ) || 0 , 10 ) ; this . patch = parseInt ( parts . shift ( ) || 0 , 10 ) ; this . build = parseInt ( parts . shift ( ) || 0 , 10 ) ; return this ; } 
function ( current , target ) { var currentValue , targetValue , i ; current = new Version ( current ) . toArray ( ) ; target = new Version ( target ) . toArray ( ) ; for ( i = 0 ; i < Math . max ( current . length , target . length ) ; i ++ ) { currentValue = this . getComponentValue ( current [ i ] ) ; targetValue = this . getComponentValue ( target [ i ] ) ; if ( currentValue < targetValue ) { return - 1 ; } else if ( currentValue > targetValue ) { return 1 ; } } return 0 ; } 
function ( packageName , version ) { Ext . versions [ packageName ] = new Version ( version ) ; Ext . lastRegisteredVersion = Ext . versions [ packageName ] ; return this ; } 
function ( packageName , since , closure , scope ) { if ( Version . compare ( Ext . getVersion ( packageName ) , since ) < 1 ) { closure . call ( scope ) ; } } 
function setFromObject ( object ) { Object . keys ( object ) . forEach ( ( name ) => { options [ name ] = object [ name ] ; } ) ; } 
function addOptions ( flags ) { Object . keys ( options ) . forEach ( function ( name ) { var dashedName = toDashCase ( name ) ; if ( ( name in parseOptions ) && ( name in transformOptions ) ) { flags . option ( '--' + dashedName + ' [true|false|parse]' , descriptions [ name ] ) ; flags . on ( dashedName , ( value ) => setOption ( dashedName , value ) ) ; } 
function addFeatureOption ( name , kind ) { if ( kind === EXPERIMENTAL ) experimentalOptions [ name ] = true ; Object . defineProperty ( parseOptions , name , { get : function ( ) { return ! ! options [ name ] ; } , enumerable : true , configurable : true } ) ; Object . defineProperty ( transformOptions , name , { get : function ( ) { var v = options [ name ] ; if ( v === 'parse' ) return false ; return v ; } , enumerable : true , configurable : true } ) ; var defaultValue = options [ name ] || kind === ON_BY_DEFAULT ; options [ name ] = defaultValue ; defaultValues [ name ] = defaultValue ; } 
function ( ) { this . addEvents ( 'change' , 'validitychange' , 'dirtychange' ) ; this . initValue ( ) ; 
function ( value1 , value2 ) { return String ( Ext . value ( value1 , '' ) ) === String ( Ext . value ( value2 , '' ) ) ; } 
function ( ) { var me = this , data = null ; if ( ! me . disabled && me . submitValue && ! me . isFileUpload ( ) ) { data = { } ; data [ me . getName ( ) ] = '' + me . getValue ( ) ; } return data ; } 
function ( ) { if ( ! this . suspendCheckChange ) { var me = this , newVal = me . getValue ( ) , oldVal = me . lastValue ; if ( ! me . isEqual ( newVal , oldVal ) && ! me . isDestroyed ) { me . lastValue = newVal ; me . fireEvent ( 'change' , me , newVal , oldVal ) ; me . onChange ( newVal , oldVal ) ; } } } 
function ( ) { var me = this , isDirty = me . isDirty ( ) ; if ( isDirty !== me . wasDirty ) { me . fireEvent ( 'dirtychange' , me , isDirty ) ; me . onDirtyChange ( isDirty ) ; me . wasDirty = isDirty ; } } 
function ( ) { var me = this , isValid = me . isValid ( ) ; if ( isValid !== me . wasValid ) { me . wasValid = isValid ; me . fireEvent ( 'validitychange' , me , isValid ) ; } return isValid ; } 
function munge ( str , options ) { var aMunged = [ ] ; var aChars , i ; 
function Exclude ( config , options ) { this . _config = config ; this . paths = [ ] ; for ( var index in this . _config ) { var key = this . _config [ index ] ; var keys = key . split ( '.' ) ; this . paths . push ( keys ) ; } } 
function ( ) { var headerFragment = this . _parseHeader ( ) , data = { } , nodes , elm , matches , editor = this . editor ; function getAttr ( elm , name ) { var value = elm . attr ( name ) ; return value || '' ; } ; // Default some values data . fontface = editor . getParam ( "fullpage_default_fontface" , "" ) ; data . fontsize = editor . getParam ( "fullpage_default_fontsize" , "" ) ; // Parse XML PI elm = headerFragment . firstChild ; if ( elm . type == 7 ) { data . xml_pi = true ; matches = / encoding="([^"]+)" / . exec ( elm . value ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } // Parse doctype elm = headerFragment . getAll ( '#doctype' ) [ 0 ] ; if ( elm ) data . doctype = '<!DOCTYPE' + elm . value + ">" ; // Parse title element elm = headerFragment . getAll ( 'title' ) [ 0 ] ; if ( elm && elm . firstChild ) { data . metatitle = elm . firstChild . value ; } // Parse meta elements each ( headerFragment . getAll ( 'meta' ) , function ( meta ) { var name = meta . attr ( 'name' ) , httpEquiv = meta . attr ( 'http-equiv' ) , matches ; if ( name ) data [ 'meta' + name . toLowerCase ( ) ] = meta . attr ( 'content' ) ; else if ( httpEquiv == "Content-Type" ) { matches = / charset\s*=\s*(.*)\s* / gi . exec ( meta . attr ( 'content' ) ) ; if ( matches ) data . docencoding = matches [ 1 ] ; } } ) ; // Parse html attribs elm = headerFragment . getAll ( 'html' ) [ 0 ] ; if ( elm ) data . langcode = getAttr ( elm , 'lang' ) || getAttr ( elm , 'xml:lang' ) ; // Parse stylesheet elm = headerFragment . getAll ( 'link' ) [ 0 ] ; if ( elm && elm . attr ( 'rel' ) == 'stylesheet' ) data . stylesheet = elm . attr ( 'href' ) ; // Parse body parts elm = headerFragment . getAll ( 'body' ) [ 0 ] ; if ( elm ) { data . langdir = getAttr ( elm , 'dir' ) ; data . style = getAttr ( elm , 'style' ) ; data . visited_color = getAttr ( elm , 'vlink' ) ; data . link_color = getAttr ( elm , 'link' ) ; data . active_color = getAttr ( elm , 'alink' ) ; } return data ; } 
function ( ) { var me = this , menuTrigger = me . menuTrigger , names = me . layout . names ; 
function ( width , height ) { var me = this ; me . target . setSize ( width , height ) ; me . fireEvent ( 'resize' , me , width , height , null ) ; } 
function getter ( bindings ) { var set = computeSet ( bindings ) var resultSet = [ ] for ( var i = 0 ; i < set . length ; ++ i ) { var v = set [ i ] var fv = filteredLookupIndex [ v ] if ( fv === undefined ) { bindings [ computeForName ] = v fv = filteredLookupIndex [ v ] = computeFor ( bindings ) } 
function ( xhr ) { var me = this , ret = { } , method = 'do' + Ext . String . capitalize ( xhr . method . toLowerCase ( ) ) , 
function ( character , currentGroup ) { 
function ( name ) { 
function ( input , format , strict ) { var p = utilDate . parseFunctions ; if ( p [ format ] == null ) { utilDate . createParser ( format ) ; } return p [ format ] . call ( utilDate , input , Ext . isDefined ( strict ) ? strict : utilDate . useStrict ) ; } 
function ( character ) { var f = utilDate . formatCodes [ character ] ; if ( f ) { f = typeof f == 'function' ? f ( ) : f ; utilDate . formatCodes [ character ] = f ; 
function ( date , format ) { var formatFunctions = utilDate . formatFunctions ; if ( ! Ext . isDate ( date ) ) { return '' ; } if ( formatFunctions [ format ] == null ) { utilDate . createFormat ( format ) ; } return formatFunctions [ format ] . call ( date ) + '' ; } 
function ( date , colon ) { var offset = date . getTimezoneOffset ( ) ; return ( offset > 0 ? "-" : "+" ) + Ext . String . leftPad ( Math . floor ( Math . abs ( offset ) / 60 ) , 2 , "0" ) + ( colon ? ":" : "" ) + Ext . String . leftPad ( Math . abs ( offset % 60 ) , 2 , "0" ) ; } 
function ( date ) { var num = 0 , d = Ext . Date . clone ( date ) , m = date . getMonth ( ) , i ; for ( i = 0 , d . setDate ( 1 ) , d . setMonth ( 0 ) ; i < m ; d . setMonth ( ++ i ) ) { num += utilDate . getDaysInMonth ( d ) ; } return num + date . getDate ( ) - 1 ; } 
function ( ) { var nativeDate = window . Date , p , statics = [ 'useStrict' , 'formatCodeToRegex' , 'parseFunctions' , 'parseRegexes' , 'formatFunctions' , 'y2kYear' , 'MILLI' , 'SECOND' , 'MINUTE' , 'HOUR' , 'DAY' , 'MONTH' , 'YEAR' , 'defaults' , 'dayNames' , 'monthNames' , 'monthNumbers' , 'getShortMonthName' , 'getShortDayName' , 'getMonthNumber' , 'formatCodes' , 'isValid' , 'parseDate' , 'getFormatCode' , 'createFormat' , 'createParser' , 'parseCodes' ] , proto = [ 'dateFormat' , 'format' , 'getTimezone' , 'getGMTOffset' , 'getDayOfYear' , 'getWeekOfYear' , 'isLeapYear' , 'getFirstDayOfMonth' , 'getLastDayOfMonth' , 'getDaysInMonth' , 'getSuffix' , 'clone' , 'isDST' , 'clearTime' , 'add' , 'between' ] , sLen = statics . length , pLen = proto . length , stat , prot , s ; 
function delegateEventsOnSubviews ( ) { this . delegateEvents ( ) ; if ( ! _ . isUndefined ( this . subviews ) ) { _ . each ( this . subviews , function ( subview ) { subview . delegateEventsOnSubviews ( ) ; } ) ; } } 
function close ( ) { this . undelegateEvents ( ) ; if ( ! _ . isUndefined ( this . subviews ) ) { _ . each ( this . subviews , function ( subview ) { subview . close ( ) ; } ) ; } this . $el . empty ( ) ; this . unbind ( ) ; } 
function ( grid ) { var me = this ; grid . on ( { columnresize : me . resizeContainer , columnhide : me . resizeContainer , columnshow : me . resizeContainer , beforedestroy : me . unsetup , reconfigure : me . resetup , scope : me } ) ; grid . addEvents ( 'filterupdated' ) ; Ext . apply ( grid , { filterBar : me , getFilterBar : function ( ) { return this . filterBar ; } } ) ; me . setup ( grid ) ; } 
function ( grid ) { var me = this ; me . grid = grid ; me . visible = ! me . renderHidden ; me . autoStores = Ext . create ( 'Ext.util.MixedCollection' ) ; me . autoStoresLoaded = false ; me . columns = Ext . create ( 'Ext.util.MixedCollection' ) ; me . containers = Ext . create ( 'Ext.util.MixedCollection' ) ; me . fields = Ext . create ( 'Ext.util.MixedCollection' ) ; me . actionColumn = me . grid . down ( 'actioncolumn' ) || me . grid . down ( 'actioncolumnpro' ) ; me . extraColumn = null ; me . clearAllEl = null ; me . showHideEl = null ; me . task = Ext . create ( 'Ext.util.DelayedTask' ) ; me . filterArray = [ ] ; me . overrideProxy ( ) ; me . parseFiltersConfig ( ) ; // sets me.columns and me.autoStores me . parseInitialFilters ( ) ; // sets me.filterArray with the store previous filters if any (adds operator and type if missing) me . renderExtraColumn ( ) ; // sets me.extraColumn if applicable // renders the filter's bar if ( grid . rendered ) { me . renderFilterBar ( grid ) ; } else { grid . on ( 'afterrender' , me . renderFilterBar , me , { single : true } ) ; } } 
function ( grid ) { var me = this ; if ( me . autoStores . getCount ( ) ) { me . grid . store . un ( 'load' , me . fillAutoStores , me ) ; } me . autoStores . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . autoStores . clear ( ) ; me . autoStores = null ; me . columns . each ( function ( column ) { if ( column . rendered ) { if ( column . getEl ( ) . hasCls ( me . columnFilteredCls ) ) { column . getEl ( ) . removeCls ( me . columnFilteredCls ) ; } } } , me ) ; me . columns . clear ( ) ; me . columns = null ; me . fields . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . fields . clear ( ) ; me . fields = null ; me . containers . each ( function ( item ) { Ext . destroy ( item ) ; } ) ; me . containers . clear ( ) ; me . containers = null ; if ( me . clearAllEl ) { Ext . destroy ( me . clearAllEl ) ; me . clearAllEl = null ; } if ( me . showHideEl ) { Ext . destroy ( me . showHideEl ) ; me . showHideEl = null ; } if ( me . extraColumn ) { me . grid . headerCt . items . remove ( me . extraColumn ) ; Ext . destroy ( me . extraColumn ) ; me . extraColumn = null ; } me . task = null ; me . filterArray = null ; } 
function ( ) { var me = this ; // override encodeFilters to append type and operator in remote filtering Ext . apply ( me . grid . store . proxy , { encodeFilters : function ( filters ) { var min = [ ] , length = filters . length , i = 0 ; for ( ; i < length ; i ++ ) { min [ i ] = { property : filters [ i ] . property , value : filters [ i ] . value } ; if ( filters [ i ] . type ) { min [ i ] . type = filters [ i ] . type ; } if ( filters [ i ] . operator ) { min [ i ] . operator = filters [ i ] . operator ; } } return this . applyEncoding ( min ) ; } } ) ; } 
function ( ) { var me = this ; var columns = this . grid . headerCt . getGridColumns ( ) ; me . columns . clear ( ) ; me . autoStores . clear ( ) ; Ext . each ( columns , function ( column ) { if ( column . filter ) { if ( column . filter === true || column . filter === 'auto' ) { // automatic types configuration (store based) var type = 'auto' //me.grid.store.model.prototype.fields.get(column.dataIndex).type.type; if ( type == 'auto' ) type = 'string' ; column . filter = type ; } if ( Ext . isString ( column . filter ) ) { column . filter = { type : column . filter // only set type to then use templates } ; } if ( column . filter . type ) { column . filter = Ext . applyIf ( column . filter , me [ column . filter . type + 'Tpl' ] ) ; // also use templates but with user configuration } if ( column . filter . xtype == 'combo' && ! column . filter . store ) { column . autoStore = true ; column . filter . store = Ext . create ( 'Ext.data.ArrayStore' , { fields : [ { name : 'text' } , { name : 'id' } ] } ) ; me . autoStores . add ( column . dataIndex , column . filter . store ) ; column . filter = Ext . apply ( column . filter , { displayField : 'text' , valueField : 'id' } ) ; } if ( ! column . filter . type ) { switch ( column . filter . xtype ) { case 'combo' : column . filter . type = ( column . filter . multiSelect ? 'list' : 'combo' ) ; break ; case 'datefield' : column . filter . type = 'date' ; break ; case 'numberfield' : column . filter . type = ( column . filter . allowDecimals ? 'float' : 'int' ) ; break ; default : column . filter . type = 'string' } } if ( ! column . filter . operator ) { column . filter . operator = me [ column . filter . type + 'Tpl' ] . operator ; } me . columns . add ( column . dataIndex , column ) ; } } , me ) ; if ( me . autoStores . getCount ( ) ) { if ( me . grid . store . getCount ( ) > 0 ) { me . fillAutoStores ( me . grid . store ) ; } if ( me . grid . store . remoteFilter ) { var autoStores = [ ] ; me . autoStores . eachKey ( function ( key , item ) { autoStores . push ( key ) ; } ) ; me . grid . store . proxy . extraParams = me . grid . store . proxy . extraParams || { } ; me . grid . store . proxy . extraParams [ me . autoStoresRemoteProperty ] = autoStores ; } me . grid . store . on ( 'load' , me . fillAutoStores , me ) ; } } 
function ( store ) { var me = this ; if ( ! me . autoUpdateAutoStores && me . autoStoresLoaded ) return ; me . autoStores . eachKey ( function ( key , item ) { var field = me . fields . get ( key ) ; if ( field ) { field . suspendEvents ( ) ; var fieldValue = field . getValue ( ) ; } if ( ! store . remoteFilter ) { // values from local store var data = store . collect ( key , true , false ) . sort ( ) ; var records = [ ] ; Ext . each ( data , function ( txt ) { if ( Ext . isEmpty ( txt ) ) { Ext . Array . insert ( records , 0 , [ { text : me . autoStoresNullText , id : me . autoStoresNullValue } ] ) ; } else { records . push ( { text : txt , id : txt } ) ; } } ) ; item . loadData ( records ) ; } else { // values from server if ( store . proxy . reader . rawData [ me . autoStoresRemoteProperty ] ) { var data = store . proxy . reader . rawData [ me . autoStoresRemoteProperty ] ; if ( data [ key ] ) { var records = [ ] ; Ext . each ( data [ key ] . sort ( ) , function ( txt ) { if ( Ext . isEmpty ( txt ) ) { Ext . Array . insert ( records , 0 , [ { text : me . autoStoresNullText , id : me . autoStoresNullValue } ] ) ; } else { records . push ( { text : txt , id : txt } ) ; } } ) ; item . loadData ( records ) ; } } } if ( field ) { field . setValue ( fieldValue ) ; field . resumeEvents ( ) ; } } , me ) ; me . autoStoresLoaded = true ; if ( me . grid . store . remoteFilter && ! me . autoUpdateAutoStores ) { delete me . grid . store . proxy . extraParams [ me . autoStoresRemoteProperty ] ; } } 
function ( ) { var me = this ; me . filterArray = [ ] ; me . grid . store . filters . each ( function ( filter ) { // try to parse initial filters, for now filterFn is unsuported if ( filter . property && ! Ext . isEmpty ( filter . value ) && me . columns . get ( filter . property ) ) { if ( ! filter . type ) filter . type = me . columns . get ( filter . property ) . filter . type ; if ( ! filter . operator ) filter . operator = me . columns . get ( filter . property ) . filter . operator ; me . filterArray . push ( filter ) ; } } , me ) ; } 
function ( ) { var me = this ; if ( me . columns . getCount ( ) && ! me . actionColumn && ( me . showClearAllButton || me . showShowHideButton ) ) { var extraColumnCssClass = Ext . baseCSSPrefix + 'filter-bar-extra-column-hack' ; if ( ! document . getElementById ( extraColumnCssClass ) ) { var style = document . createElement ( 'style' ) ; var css = 'tr.' + Ext . baseCSSPrefix + 'grid-row td.' + extraColumnCssClass + ' { background-color: #ffffff !important; border-color: #ffffff !important; }' ; style . setAttribute ( 'type' , 'text/css' ) ; style . setAttribute ( 'id' , extraColumnCssClass ) ; document . body . appendChild ( style ) ; if ( style . styleSheet ) { // IE style . styleSheet . cssText = css ; } else { // others var cssNode = document . createTextNode ( css ) ; style . appendChild ( cssNode ) ; } } me . extraColumn = Ext . create ( 'Ext.grid.column.Column' , { draggable : false , hideable : false , menuDisabled : true , sortable : false , resizable : false , fixed : true , width : 28 , minWidth : 28 , maxWidth : 28 , header : '&nbsp;' , tdCls : extraColumnCssClass } ) ; me . grid . headerCt . add ( me . extraColumn ) ; } } 
function ( grid ) { var me = this ; me . containers . clear ( ) ; me . fields . clear ( ) ; me . columns . eachKey ( function ( key , column ) { var listConfig = column . filter . listConfig || { } ; listConfig = Ext . apply ( listConfig , { style : 'border-top-width: 1px' } ) ; var plugins = [ ] ; if ( me . showClearButton ) { plugins . push ( { ptype : 'clearbutton' } ) ; } if ( me . enableOperators && ( column . filter . type == 'date' || column . filter . type == 'int' || column . filter . type == 'float' ) ) { plugins . push ( { ptype : 'operatorbutton' , listeners : { operatorchanged : function ( txt ) { if ( Ext . isEmpty ( txt . getValue ( ) ) ) return ; me . applyInstantFilters ( txt ) ; } } } ) ; } var field = Ext . widget ( column . filter . xtype , Ext . apply ( column . filter , { dataIndex : key , flex : 1 , margin : 0 , fieldStyle : 'border-left-width: 0px; border-bottom-width: 0px;' , listConfig : listConfig , preventMark : true , msgTarget : 'none' , checkChangeBuffer : 50 , enableKeyEvents : true , listeners : { change : me . applyDelayedFilters , select : me . applyInstantFilters , keypress : function ( txt , e ) { if ( e . getCharCode ( ) == 13 ) { e . stopEvent ( ) ; me . applyInstantFilters ( txt ) ; } return false ; } , scope : me } , plugins : plugins } ) ) ; me . fields . add ( column . dataIndex , field ) ; var container = Ext . create ( 'Ext.container.Container' , { dataIndex : key , layout : 'hbox' , bodyStyle : 'background-color: "transparent";' , width : column . getWidth ( ) , items : [ field ] , listeners : { scope : me , element : 'el' , mousedown : function ( e ) { e . stopPropagation ( ) ; } , click : function ( e ) { e . stopPropagation ( ) ; } , dblclick : function ( e ) { e . stopPropagation ( ) ; } , keydown : function ( e ) { e . stopPropagation ( ) ; } , keypress : function ( e ) { e . stopPropagation ( ) ; } , keyup : function ( e ) { e . stopPropagation ( ) ; } } } ) ; me . containers . add ( column . dataIndex , container ) ; container . render ( Ext . get ( column . id ) ) ; } , me ) ; var excludedCols = [ ] ; if ( me . actionColumn ) excludedCols . push ( me . actionColumn . id ) ; if ( me . extraColumn ) excludedCols . push ( me . extraColumn . id ) ; Ext . each ( me . grid . headerCt . getGridColumns ( ) , function ( column ) { if ( ! Ext . Array . contains ( excludedCols , column . id ) ) { column . setPadding = Ext . Function . createInterceptor ( column . setPadding , function ( h ) { if ( column . hasCls ( Ext . baseCSSPrefix + 'column-header-checkbox' ) ) { //checkbox column this . titleEl . setStyle ( { paddingTop : '4px' } ) ; } return false ; } ) ; } } ) ; me . setVisible ( me . visible ) ; me . renderButtons ( ) ; me . showInitialFilters ( ) ; } 
function ( ) { var me = this ; if ( me . showShowHideButton && me . columns . getCount ( ) ) { var column = me . actionColumn || me . extraColumn ; var buttonEl = column . el . first ( ) . first ( ) ; me . showHideEl = Ext . get ( Ext . core . DomHelper . append ( buttonEl , { tag : 'div' , style : 'position: absolute; width: 16px; height: 16px; top: 3px; cursor: pointer; left: ' + parseInt ( ( column . el . getWidth ( ) - 16 ) / 2 ) + 'px' , cls : me . showHideButtonIconCls , 'data-qtip' : ( me . renderHidden ? me . showHideButtonTooltipDo : me . showHideButtonTooltipUndo ) } ) ) ; me . showHideEl . on ( 'click' , function ( ) { me . setVisible ( ! me . isVisible ( ) ) ; me . showHideEl . set ( { 'data-qtip' : ( ! me . isVisible ( ) ? me . showHideButtonTooltipDo : me . showHideButtonTooltipUndo ) } ) ; } ) ; } if ( me . showClearAllButton && me . columns . getCount ( ) ) { var column = me . actionColumn || me . extraColumn ; var buttonEl = column . el . first ( ) . first ( ) ; me . clearAllEl = Ext . get ( Ext . core . DomHelper . append ( buttonEl , { tag : 'div' , style : 'position: absolute; width: 16px; height: 16px; top: 25px; cursor: pointer; left: ' + parseInt ( ( column . el . getWidth ( ) - 16 ) / 2 ) + 'px' , cls : me . clearAllButtonIconCls , 'data-qtip' : me . clearAllButtonTooltip } ) ) ; me . clearAllEl . hide ( ) ; me . clearAllEl . on ( 'click' , function ( ) { me . clearFilters ( ) ; } ) ; } } 
function ( ) { var me = this ; Ext . each ( me . filterArray , function ( filter ) { var column = me . columns . get ( filter . property ) ; var field = me . fields . get ( filter . property ) ; if ( ! column . getEl ( ) . hasCls ( me . columnFilteredCls ) ) { column . getEl ( ) . addCls ( me . columnFilteredCls ) ; } field . suspendEvents ( ) ; field . setValue ( filter . value ) ; field . resumeEvents ( ) ; } ) ; if ( me . filterArray . length && me . showClearAllButton ) { me . clearAllEl . show ( { duration : 1000 } ) ; } } 
function ( headerCt , col ) { var me = this ; var dataIndex = col . dataIndex ; if ( ! dataIndex ) return ; var item = me . containers . get ( dataIndex ) ; if ( item && item . rendered ) { var itemWidth = item . getWidth ( ) ; var colWidth = me . columns . get ( dataIndex ) . getWidth ( ) ; if ( itemWidth != colWidth ) { item . setWidth ( me . columns . get ( dataIndex ) . getWidth ( ) ) ; item . doLayout ( ) ; } } } 
function ( field ) { if ( ! field . isValid ( ) ) return ; var me = this , grid = me . grid , column = me . columns . get ( field . dataIndex ) , newVal = ( grid . store . remoteFilter ? field . getSubmitValue ( ) : field . getValue ( ) ) ; if ( Ext . isArray ( newVal ) && newVal . length == 0 ) { newVal = '' ; } var myIndex = - 1 ; Ext . each ( me . filterArray , function ( item2 , index , allItems ) { if ( item2 . property === column . dataIndex ) { myIndex = index ; } } ) ; if ( myIndex != - 1 ) { me . filterArray . splice ( myIndex , 1 ) ; } if ( ! Ext . isEmpty ( newVal ) ) { if ( ! grid . store . remoteFilter ) { var operator = field . operator || column . filter . operator , filterFn ; switch ( operator ) { case 'eq' : filterFn = function ( item ) { if ( column . filter . type == 'date' ) { return Ext . Date . clearTime ( item . get ( column . dataIndex ) , true ) . getTime ( ) == Ext . Date . clearTime ( newVal , true ) . getTime ( ) ; } else { return ( Ext . isEmpty ( item . get ( column . dataIndex ) ) ? me . autoStoresNullValue : item . get ( column . dataIndex ) ) == ( Ext . isEmpty ( newVal ) ? me . autoStoresNullValue : newVal ) ; } } ; break ; case 'gte' : filterFn = function ( item ) { if ( column . filter . type == 'date' ) { return Ext . Date . clearTime ( item . get ( column . dataIndex ) , true ) . getTime ( ) >= Ext . Date . clearTime ( newVal , true ) . getTime ( ) ; } else { return ( Ext . isEmpty ( item . get ( column . dataIndex ) ) ? me . autoStoresNullValue : item . get ( column . dataIndex ) ) >= ( Ext . isEmpty ( newVal ) ? me . autoStoresNullValue : newVal ) ; } } ; break ; case 'lte' : filterFn = function ( item ) { if ( column . filter . type == 'date' ) { return Ext . Date . clearTime ( item . get ( column . dataIndex ) , true ) . getTime ( ) <= Ext . Date . clearTime ( newVal , true ) . getTime ( ) ; } else { return ( Ext . isEmpty ( item . get ( column . dataIndex ) ) ? me . autoStoresNullValue : item . get ( column . dataIndex ) ) <= ( Ext . isEmpty ( newVal ) ? me . autoStoresNullValue : newVal ) ; } } ; break ; case 'ne' : filterFn = function ( item ) { if ( column . filter . type == 'date' ) { return Ext . Date . clearTime ( item . get ( column . dataIndex ) , true ) . getTime ( ) != Ext . Date . clearTime ( newVal , true ) . getTime ( ) ; } else { return ( Ext . isEmpty ( item . get ( column . dataIndex ) ) ? me . autoStoresNullValue : item . get ( column . dataIndex ) ) != ( Ext . isEmpty ( newVal ) ? me . autoStoresNullValue : newVal ) ; } } ; break ; case 'like' : filterFn = function ( item ) { var re = new RegExp ( newVal , 'i' ) ; return re . test ( item . get ( column . dataIndex ) ) ; } ; break ; case 'in' : filterFn = function ( item ) { var re = new RegExp ( '^' + newVal . join ( '|' ) + '$' , 'i' ) ; return re . test ( ( Ext . isEmpty ( item . get ( column . dataIndex ) ) ? me . autoStoresNullValue : item . get ( column . dataIndex ) ) ) ; } ; break ; } me . filterArray . push ( Ext . create ( 'Ext.util.Filter' , { property : column . dataIndex , filterFn : filterFn , me : me } ) ) ; } else { me . filterArray . push ( Ext . create ( 'Ext.util.Filter' , { property : column . dataIndex , value : newVal , type : column . filter . type , operator : ( field . operator || column . filter . operator ) } ) ) ; } if ( ! column . getEl ( ) . hasCls ( me . columnFilteredCls ) ) { column . getEl ( ) . addCls ( me . columnFilteredCls ) ; } } else { if ( column . getEl ( ) . hasCls ( me . columnFilteredCls ) ) { column . getEl ( ) . removeCls ( me . columnFilteredCls ) ; } } grid . store . currentPage = 1 ; if ( me . filterArray . length > 0 ) { if ( ! grid . store . remoteFilter ) grid . store . clearFilter ( ) ; grid . store . filters . clear ( ) ; grid . store . filter ( me . filterArray ) ; if ( me . clearAllEl ) { me . clearAllEl . show ( { duration : 1000 } ) ; } } else { grid . store . clearFilter ( ) ; if ( me . clearAllEl ) { me . clearAllEl . hide ( { duration : 1000 } ) ; } } if ( ! grid . store . remoteFilter && me . autoUpdateAutoStores ) { me . fillAutoStores ( ) ; } me . fireEvent ( 'filterupdated' , me . filterArray ) ; } 
function ( field ) { if ( ! field . isValid ( ) ) return ; var me = this ; me . task . delay ( me . updateBuffer , me . applyFilters , me , [ field ] ) ; } 
function ( ) { var me = this , field = undefined ; Ext . each ( me . grid . headerCt . getGridColumns ( ) , function ( col ) { if ( col . filter ) { field = me . fields . get ( col . dataIndex ) ; return false ; } } ) ; return field ; } 
function readSync ( ) { const TLS_CERT = process . env . TLS_CERT ; const TLS_KEY = process . env . TLS_KEY ; const TLS_CA = process . env . TLS_CA ; const tls_cert = readOpt ( "--tls-cert" ) ; const tls_key = readOpt ( "--tls-key" ) ; const tls_ca = readOpt ( "--tls-ca" ) ; const result = { secureOptions : constants . SSL_OP_NO_TLSv1 } ; if ( tls_cert ) { if ( tls_key ) { result . cert = fs . readFileSync ( tls_cert ) ; result . key = fs . readFileSync ( tls_key ) ; if ( tls_ca ) { result . ca = fs . readFileSync ( tls_ca ) ; } } else { result . pfx = fs . readFileSync ( tls_cert ) ; } } else if ( TLS_CERT ) { if ( TLS_KEY ) { result . cert = fs . readFileSync ( TLS_CERT ) ; result . key = fs . readFileSync ( TLS_KEY ) ; if ( TLS_CA ) { result . ca = fs . readFileSync ( TLS_CA ) ; } } else { result . pfx = fs . readFileSync ( TLS_CERT ) ; } } return result ; } 
function read ( ) { const TLS_CERT = process . env . TLS_CERT ; const TLS_KEY = process . env . TLS_KEY ; const TLS_CA = process . env . TLS_CA ; const tls_cert = readOpt ( "--tls-cert" ) ; const tls_key = readOpt ( "--tls-key" ) ; const tls_ca = readOpt ( "--tls-ca" ) ; const result = { } ; if ( tls_cert ) { if ( tls_key ) { result . cert = readFile ( tls_cert ) ; result . key = readFile ( tls_key ) ; if ( tls_ca ) { result . ca = readFile ( tls_ca ) ; } } else { result . pfx = readFile ( tls_cert ) ; } } else if ( TLS_CERT ) { if ( TLS_KEY ) { result . cert = readFile ( TLS_CERT ) ; result . key = readFile ( TLS_KEY ) ; if ( TLS_CA ) { result . ca = readFile ( TLS_CA ) ; } } else { result . pfx = readFile ( TLS_CERT ) ; } } return Promise . all ( keys ( result ) . map ( key => result [ key ] . then ( data => { return result [ key ] = data ; } ) ) ) . then ( ( ) => result ) ; } 
function readOpt ( option ) { const prefix = ` ${ option } ` ; for ( let i = 0 , len = process . argv . length , arg ; i < len ; i ++ ) { arg = process . argv [ i ] ; if ( arg === option ) { return process . argv [ i + 1 ] ; } else if ( arg . indexOf ( prefix ) === 0 ) { return arg . substr ( prefix . length ) ; } } } 
function checkParams ( typeCode , params , errCb ) { _ . assertFunction ( errCb ) var viewSchema = schema . _byCode [ typeCode ] var failed = false var e = new Error('parameters include an invalid object id') e.code = 'InvalidParamId' errCb(e) return false }else */ if ( objectState . isDeleted ( params [ i ] ) ) { var e = new Error ( 'parameters include a object id for a deleted object' ) e . code = 'InvalidParamId' errCb ( e ) return false } } } return true } 
function ( typeCode , params , historicalKey , cb ) { var c = objectState . getCurrentEditId ( ) var realVersions = [ c - 1 ] 
function LLog ( opts ) { var options = opts || { } , level = defaultLevel , stdout ; if ( typeof opts === 'object' && opts != null ) { level = opts . level || level ; stdout = opts . stdout ; } else { if ( typeof opts !== 'undefined' ) { level = opts ; } if ( arguments . length > 1 ) { stdout = arguments [ 1 ] ; } } this . level = handleLevel ( level ) || level ; if ( stdout ) { this . stdout = stdout ; } else if ( typeof process !== 'undefined' && process . stdout && typeof LLOG_SKIP_USING_PROCESS === 'undefined' ) { 
function sendfile ( req , res ) { 
function ( target ) { var me = this , anims = [ ] , timeline = me . timeline , ln = timeline . length , anim , easing , damper , attrs , i ; if ( me . fireEvent ( 'beforeanimate' , me ) !== false ) { for ( i = 0 ; i < ln ; i ++ ) { anim = timeline [ i ] ; attrs = anim . attrs ; easing = attrs . easing || me . easing ; damper = attrs . damper || me . damper ; delete attrs . easing ; delete attrs . damper ; anim = new Ext . fx . Anim ( { target : target , easing : easing , damper : damper , duration : anim . duration , paused : true , to : attrs } ) ; anims . push ( anim ) ; } me . animations = anims ; me . target = anim . target ; for ( i = 0 ; i < ln - 1 ; i ++ ) { anim = anims [ i ] ; anim . nextAnim = anims [ i + 1 ] ; anim . on ( 'afteranimate' , function ( ) { this . nextAnim . paused = false ; } ) ; anim . on ( 'afteranimate' , function ( ) { this . fireEvent ( 'keyframe' , this , ++ this . keyframeStep ) ; } , me ) ; } anims [ ln - 1 ] . on ( 'afteranimate' , function ( ) { this . lastFrame ( ) ; } , me ) ; } } 
function Set ( iter , options ) { if ( ! ( this instanceof Set ) ) return new Set ( iter , options ) ; this . _o = { } ; this . length = 0 ; 
function ( el , html , returnElement ) { var newNode ; el = Ext . getDom ( el ) ; html = this . markup ( html ) ; 
function ( ) { var me = this , chart = me . chart , store = chart . getChartStore ( ) , data = store . data . items , count = me . getRecordCount ( ) , i , ln , record , min , max , xField = me . xField , xValue ; if ( count > 0 ) { min = Infinity ; max = - min ; for ( i = 0 , ln = data . length ; i < ln ; i ++ ) { record = data [ i ] ; xValue = record . get ( xField ) ; if ( xValue > max ) { max = xValue ; } if ( xValue < min ) { min = xValue ; } } 
function ( ) { var me = this , chart = me . chart , store = chart . getChartStore ( ) , data = store . data . items , count = me . getRecordCount ( ) , i , ln , record , stacked = me . stacked , min , max , positiveTotal , negativeTotal ; function eachYValueStacked ( yValue , i ) { if ( ! me . isExcluded ( i ) ) { if ( yValue < 0 ) { negativeTotal += yValue ; } else { positiveTotal += yValue ; } } } function eachYValue ( yValue , i ) { if ( ! me . isExcluded ( i ) ) { if ( yValue > max ) { max = yValue ; } if ( yValue < min ) { min = yValue ; } } } if ( count > 0 ) { min = Infinity ; max = - min ; for ( i = 0 , ln = data . length ; i < ln ; i ++ ) { record = data [ i ] ; if ( stacked ) { positiveTotal = 0 ; negativeTotal = 0 ; me . eachYValue ( record , eachYValueStacked ) ; if ( positiveTotal > max ) { max = positiveTotal ; } if ( negativeTotal < min ) { min = negativeTotal ; } } else { me . eachYValue ( record , eachYValue ) ; } } 
function ( cls ) { var me = this , result = me . callParent ( arguments ) , classes = [ me . baseCls + '-body-' + cls , me . baseCls + '-body-' + me . ui + '-' + cls ] , array , i ; if ( me . bodyCls ) { array = me . bodyCls . split ( ' ' ) ; for ( i = 0 ; i < classes . length ; i ++ ) { if ( ! Ext . Array . contains ( array , classes [ i ] ) ) { array . push ( classes [ i ] ) ; } } me . bodyCls = array . join ( ' ' ) ; } else { me . bodyCls = classes . join ( ' ' ) ; } return result ; } 
function ( ) { var me = this , array , cls ; me . callParent ( arguments ) ; cls = me . baseCls + '-body-' + me . ui ; if ( me . rendered ) { if ( me . bodyCls ) { me . body . addCls ( me . bodyCls ) ; } else { me . body . addCls ( cls ) ; } } else { if ( me . bodyCls ) { array = me . bodyCls . split ( ' ' ) ; if ( ! Ext . Array . contains ( array , cls ) ) { array . push ( cls ) ; } me . bodyCls = array . join ( ' ' ) ; } else { me . bodyCls = cls ; } } if ( me . titleCmp && me . titleCmp . rendered ) { me . titleCmp . addCls ( me . baseCls + '-text-container-' + me . ui ) ; } } 
function ( ) { var me = this , array , cls ; me . callParent ( arguments ) ; cls = me . baseCls + '-body-' + me . ui ; if ( me . rendered ) { if ( me . bodyCls ) { me . body . removeCls ( me . bodyCls ) ; } else { me . body . removeCls ( cls ) ; } } else { if ( me . bodyCls ) { array = me . bodyCls . split ( ' ' ) ; Ext . Array . remove ( array , cls ) ; me . bodyCls = array . join ( ' ' ) ; } else { me . bodyCls = cls ; } } if ( me . titleCmp && me . titleCmp . rendered ) { me . titleCmp . removeCls ( me . baseCls + '-text-container-' + me . ui ) ; } } 
function ( title ) { var me = this , titleCmp = me . titleCmp ; me . title = title ; if ( titleCmp . rendered ) { titleCmp . textEl . update ( me . title || '&#160;' ) ; titleCmp . updateLayout ( ) ; } else { me . titleCmp . on ( { render : function ( ) { me . setTitle ( title ) ; } , single : true } ) ; } } 
function ( cls ) { var me = this , isEmpty = ! cls || ! cls . length , iconCmp = me . iconCmp ; me . iconCls = cls ; if ( ! me . iconCmp && ! isEmpty ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( isEmpty ) { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } else { iconCmp . removeCls ( iconCmp . iconCls ) ; iconCmp . addCls ( cls ) ; iconCmp . iconCls = cls ; } } } 
function ( icon ) { var me = this , isEmpty = ! icon || ! icon . length , iconCmp = me . iconCmp ; me . icon = icon ; if ( ! me . iconCmp && ! isEmpty ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( isEmpty ) { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } else { iconCmp . setSrc ( me . icon ) ; } } } 
function ( glyph ) { var me = this , iconCmp = me . iconCmp ; if ( ! me . iconCmp ) { me . initIconCmp ( ) ; me . insert ( 0 , me . iconCmp ) ; } else if ( iconCmp ) { if ( glyph ) { me . iconCmp . setGlyph ( glyph ) ; } else { me . iconCmp . destroy ( ) ; delete me . iconCmp ; } } } 
function classCall ( func , object , staticObject , superClass ) { if ( superClass ) { return parseExpression ` ${ func } ${ object } ${ staticObject } ${ superClass } ` ; } return parseExpression ` ${ func } ${ object } ${ staticObject } ` ; } 
function ( ) { var me = this ; if ( me . loadOnShow && ! me . loaded && ! me . store . loading ) { me . store . load ( ) ; } me . callParent ( ) ; } 
function ( item , checked ) { var value = [ ] ; this . items . each ( function ( item ) { if ( item . checked ) { value . push ( item . value ) ; } } ) ; this . selected = value ; this . fireEvent ( 'checkchange' , item , checked ) ; } 
function isType ( type , val ) { return ( type == Any ) || ( type == Object && is . object ( val ) ) || ( type == Function && is . function ( val ) ) || ( type == String && is . string ( val ) ) || ( type == Error && is . error ( val ) ) || ( type == Number && is . number ( val ) ) || ( type == Array && is . array ( val ) ) || ( type == Boolean && is . boolean ( val ) ) || ( type == RegExp && is . regExp ( val ) ) || ( type == Date && is . date ( val ) ) || ( type == null && is . nullOrUndefined ( val ) ) || ( val instanceof type ) } 
function findMorph ( args , morphs ) { for ( var i = 0 ; i < morphs . length ; i ++ ) { var sig = morphs [ i ] . sig if ( args . length == sig . length ) { var matched = true for ( var j = 0 ; j < sig . length ; j ++ ) { if ( ! isType ( sig [ j ] , args [ j ] ) ) { matched = false break } } if ( matched ) { return morphs [ i ] } } } throw new Error ( 'No matching function signature' ) } 
function subscribe ( callback ) { 
function save ( ) { 
function convertJsonToEdits ( dbSchema , type , json , topTemporaryId ) { 
function ( ed ) { var t = this , showMenu , contextmenuNeverUseNative , realCtrlKey , hideMenu ; t . editor = ed ; contextmenuNeverUseNative = ed . settings . contextmenu_never_use_native ; t . onContextMenu = new tinymce . util . Dispatcher ( this ) ; hideMenu = function ( e ) { hide ( ed , e ) ; } ; showMenu = ed . onContextMenu . add ( function ( ed , e ) { // Block TinyMCE menu on ctrlKey and work around Safari issue if ( ( realCtrlKey !== 0 ? realCtrlKey : e . ctrlKey ) && ! contextmenuNeverUseNative ) return ; Event . cancel ( e ) ; // Select the image if it's clicked. WebKit would other wise expand the selection if ( e . target . nodeName == 'IMG' ) ed . selection . select ( e . target ) ; t . _getMenu ( ed ) . showMenu ( e . clientX || e . pageX , e . clientY || e . pageY ) ; Event . add ( ed . getDoc ( ) , 'click' , hideMenu ) ; ed . nodeChanged ( ) ; } ) ; ed . onRemove . add ( function ( ) { if ( t . _menu ) t . _menu . removeAll ( ) ; } ) ; function hide ( ed , e ) { realCtrlKey = 0 ; // Since the contextmenu event moves // the selection we need to store it away if ( e && e . button == 2 ) { realCtrlKey = e . ctrlKey ; return ; } if ( t . _menu ) { t . _menu . removeAll ( ) ; t . _menu . destroy ( ) ; Event . remove ( ed . getDoc ( ) , 'click' , hideMenu ) ; t . _menu = null ; } } ; ed . onMouseDown . add ( hide ) ; ed . onKeyDown . add ( hide ) ; ed . onKeyDown . add ( function ( ed , e ) { if ( e . shiftKey && ! e . ctrlKey && ! e . altKey && e . keyCode === 121 ) { Event . cancel ( e ) ; showMenu ( ed , e ) ; } } ) ; } 
function generateAssignStateOutOfFinally ( enclosingFinally , destination ) { var finallyState = enclosingFinally . finallyState ; 
function directory_path ( ) { pending ++ readdir ( entry , ( err , children ) => { if ( err ) return done ( err ) 
function file_path ( ) { pending ++ for ( var i = globs . length ; i -- ; ) { const glob = globs [ i ] const glob_full = glob . glob const glob_base = glob . base const glob_negated = glob . negated const glob_pattern = glob . pattern if ( entry === glob_full || mm . isMatch ( entry , glob_pattern , ALLOW ) ) { return done ( null , file ) } } 
function get ( key ) { debug ( 'getting `%s`' , key ) ; var value ; if ( this . cookies && _ . has ( this . cookies , key ) ) { value = this . cookies [ key ] ; } return value ; } 
function set ( key , value ) { debug ( 'setting `%s` to `%j`' , key , value ) ; if ( _ . isUndefined ( this . cookies ) ) { this . cookies = { } ; } this . cookies [ key ] = value ; } 
function processArguments ( argv ) { 
function extend ( a , b , noClone ) { 
function clone ( o ) { var c = { } ; var h = Object . keys ( o ) ; for ( var i = 0 , co = h . length ; i < co ; i ++ ) { c [ h [ i ] ] = o [ h [ i ] ] ; } return c ; } 
function fixPath ( string ) { if ( string . length < 1 ) { return string ; } if ( string . charAt ( string . length - 1 ) !== path . sep ) { string += path . sep ; } return string ; } 
function stringify ( string , params , noError ) { var arr = string . split ( ':' ) ; var param ; for ( var i = 0 , c = arr . length ; i < c ; i ++ ) { param = arr [ i ] ; if ( i % 2 ) { if ( ! ( typeof params [ param ] === 'string' || typeof params [ param ] === 'number' ) ) { if ( ! noError ) { throw new Error ( 'Variable ' + param + ' not defined' ) ; } } else { arr [ i ] = params [ param ] ; } } } return arr . join ( '' ) ; } 
function cleanCallback ( errorCallback , callback ) { var self = this || { } ; if ( ! callback ) { return function ( err ) { 
function iterateElements ( array ) { var index = 0 ; var rv = { } ; rv [ Symbol . iterator ] = { next ( ) { if ( index < array . length ) return { value : array [ index ++ ] , done : false } ; return { done : true } ; } } } 
function couldChain ( r , manyIndexes ) { manyIndexes = manyIndexes || 0 var subParam = couldChain(r.params[1].expr, 2) if(subParam.name === r.params[1].implicits[0]){ } }else if(r.type === 'view'){ var allParams = [] var has = {} r.params.forEach(function(p){ var pm = couldChain(p, 2) if(!pm) allParams = undefined if(allParams && !has[pm.name]){ allParams.push(pm) has[pm.name] = true } }) if(allParams && allParams.length === 1){ return allParams[0] } }*/ } 
function PingPong ( intervalMs , retryLimit , ping , onTimeout ) { if ( typeof intervalMs !== 'number' || intervalMs < 0 ) throw new Error ( 'intervalMs must be an integer >= 0 but was:' + intervalMs ) ; if ( typeof retryLimit !== 'number' || retryLimit < 0 ) throw new Error ( 'retryLimit must be an integer >= 0 but was:' + retryLimit ) ; 
function clear ( timer ) { log ( 'stop' ) ; timer . state . intervalTimer = clearInterval ( timer . state . intervalTimer ) ; timer . state . retryCounter . clear ( ) ; return timer ; } 
function pong ( timer ) { if ( ! timer . state . receivedPong ) { log ( '< pong' ) ; timer . state . receivedPong = true ; timer . state . retryCounter . reset ( ) ; timer . state . roundsCount ++ ; } return timer ; } 
function _start ( timer ) { log ( 'start %j' , timer . conf ) ; timer . state . intervalTimer = setInterval ( _onInterval , timer . conf . intervalMs , timer ) ; return _ping ( timer ) ; } 
function compute2 ( a , b ) { if ( ! a || ! b ) return [ ] if ( a . length > b . length ) { var t = b b = a a = t } if ( a . length === 0 ) return [ ] if ( a . length === 1 ) { if ( b . indexOf ( a [ 0 ] ) === - 1 ) { return [ ] } else { return a } } var ma = { } for ( var j = 0 ; j < a . length ; ++ j ) { ma [ a [ j ] ] = true } var result = [ ] for ( var j = 0 ; j < b . length ; ++ j ) { var v = b [ j ] if ( ma [ v ] ) { result . push ( v ) } } 
function xgettext ( template , options ) { options = options || { } ; var identifiers = options . identifiers || Catalog . DEFAULT_IDENTIFIERS ; var defaultDomain = options . defaultDomain || 'messages' ; var commentIdentifiers = options . commentIdentifiers || [ 'gettext-comment' ] ; var filename = options . filename ; 
function ( fo , clear ) { this . filters = fo ; if ( this . filters && this . filterFields ) { 
function GedcomXDate ( str ) { if ( str == '' ) { throw new Error ( 'Invalid Date' ) ; } if ( str . charAt ( 0 ) == 'R' ) { return new Recurring ( str ) ; } else if ( / \/ / . test ( str ) ) { return new Range ( str ) ; } else if ( str . charAt ( 0 ) == 'A' ) { return new Approximate ( str ) ; } else { return new Simple ( str ) ; } } 
function ( e ) { var me = this , overTab = me . _overTab , tabInfo , tab ; if ( e . getTarget ( '.' + Ext . baseCSSPrefix + 'box-scroller' ) ) { return ; } tabInfo = me . getTabInfoFromPoint ( e . getXY ( ) ) ; tab = tabInfo . tab ; if ( tab !== overTab ) { if ( overTab && overTab . rendered ) { overTab . onMouseLeave ( e ) ; me . _overTab = null ; } if ( tab ) { tab . onMouseEnter ( e ) ; me . _overTab = tab ; if ( ! tab . disabled ) { me . el . setStyle ( 'cursor' , 'pointer' ) ; } } else { me . el . setStyle ( 'cursor' , 'default' ) ; } } } 
function ( toClose ) { var me = this ; if ( toClose . active && me . items . getCount ( ) > 1 ) { return ( me . previousTab && me . previousTab !== toClose && ! me . previousTab . disabled ) ? me . previousTab : ( toClose . next ( 'tab[disabled=false]' ) || toClose . prev ( 'tab[disabled=false]' ) ) ; } } 
function updateLocalization ( ) { const medium = $scope . resources . medium ; if ( ! medium || ! showMedia ) { return ; } if ( medium . i18nName ) { medium . name = axI18n . localize ( medium . i18nName ) ; } if ( medium . i18nDescription ) { medium . description = axI18n . localize ( medium . i18nDescription ) ; } } 
function updateModel ( ) { const medium = $scope . resources . medium ; if ( ! medium || ! showMedia ) { return ; } if ( ! ( medium . mimeType in MEDIA_TYPE_BY_MIME_TYPE ) ) { log . warn ( 'Unsupported mimeType: [0]' , medium . mimeType ) ; } const model = $scope . model ; 
function parseUrl ( url ) { 
function isSameOrigin ( url ) { const frameLoc = parseUrl ( url ) ; const loc = window . location ; 
function ( autoRender , config ) { if ( ! tip ) { if ( ! Ext . isReady ) { Ext . onReady ( function ( ) { Ext . tip . QuickTipManager . init ( autoRender , config ) ; } ) ; return ; } var tipConfig = Ext . apply ( { disabled : disabled , id : 'ext-quicktips-tip' } , config ) , className = tipConfig . className , xtype = tipConfig . xtype ; if ( className ) { delete tipConfig . className ; } else if ( xtype ) { className = 'widget.' + xtype ; delete tipConfig . xtype ; } if ( autoRender !== false ) { tipConfig . renderTo = document . body ; 
function ( ) { var me = this , args = arguments ; if ( me . hasOwnProperty ( 'childEls' ) ) { me . childEls . push . apply ( me . childEls , args ) ; } else { me . childEls = me . getChildEls ( ) . concat ( Array . prototype . slice . call ( args ) ) ; } me . prune ( me . childEls , false ) ; } 
function ( el , id ) { var me = this , childEls = me . getChildEls ( ) , baseId , childName , i , selector , value ; baseId = ( id || me . id ) + '-' ; for ( i = childEls . length ; i -- ; ) { childName = childEls [ i ] ; if ( typeof childName == 'string' ) { 
function ( testFn ) { var me = this , old = me . getChildEls ( ) , keepers = ( me . childEls = [ ] ) , n , i , cel ; for ( i = 0 , n = old . length ; i < n ; ++ i ) { cel = old [ i ] ; if ( ! testFn ( cel ) ) { keepers . push ( cel ) ; } } } 
function multiFieldSort ( array , sortBy ) { array . sort ( ( a , b ) => { for ( let field of sortBy ) { let reverse = field [ 0 ] === '-' ; if ( reverse ) { field = field . slice ( 1 ) ; } let valueA = getPath ( a , field ) ; let valueB = getPath ( b , field ) ; if ( reverse ) { if ( valueA > valueB ) return - 1 ; else if ( valueA < valueB ) return 1 ; } else { if ( valueA > valueB ) return 1 ; else if ( valueA < valueB ) return - 1 ; } } return 0 ; } ) ; return array ; } 
function ( bookmark ) { var t = this , ed = t . editor , nl , i , h , d = ed . getDoc ( ) , b = ed . getBody ( ) , nv , s = ed . selection , bo , div , bm ; t . state = ! t . state ; ed . controlManager . setActive ( 'visualchars' , t . state ) ; if ( bookmark ) bm = s . getBookmark ( ) ; if ( t . state ) { nl = [ ] ; tinymce . walk ( b , function ( n ) { if ( n . nodeType == 3 && n . nodeValue && n . nodeValue . indexOf ( '\u00a0' ) != - 1 ) nl . push ( n ) ; } , 'childNodes' ) ; for ( i = 0 ; i < nl . length ; i ++ ) { nv = nl [ i ] . nodeValue ; nv = nv . replace ( / (\u00a0) / g , '<span data-mce-bogus="1" class="mceItemHidden mceItemNbsp">$1</span>' ) ; div = ed . dom . create ( 'div' , null , nv ) ; while ( node = div . lastChild ) ed . dom . insertAfter ( node , nl [ i ] ) ; ed . dom . remove ( nl [ i ] ) ; } } else { nl = ed . dom . select ( 'span.mceItemNbsp' , b ) ; for ( i = nl . length - 1 ; i >= 0 ; i -- ) ed . dom . remove ( nl [ i ] , 1 ) ; } s . moveToBookmark ( bm ) ; } 
function GET ( ... args ) { let options = { } ; if ( args [ args . length - 1 ] === 'http' ) { options = { hostname : args [ 0 ] , port : 80 , path : args [ 1 ] ? args [ 1 ] : '/' , method : 'GET' , headers : args [ 2 ] ? args [ 2 ] : { } } ; return new Promise ( ( resolve , reject ) => { let chunk = [ ] ; const req = http . request ( options , ( res ) => { res . on ( 'data' , ( data ) => { chunk . push ( data ) ; } ) ; res . on ( 'end' , ( ) => { let data = Buffer . concat ( chunk ) ; resolve ( JSON . parse ( data . toString ( ) ) ) ; } ) ; } ) ; req . end ( ) ; req . on ( 'error' , ( error ) => { reject ( error ) ; } ) ; } ) ; } else if ( args [ args . length - 1 ] === 'https' ) { options = { hostname : args [ 0 ] , port : 443 , path : args [ 1 ] ? args [ 1 ] : '/' , method : 'GET' , headers : args [ 2 ] ? args [ 2 ] : { } } ; return new Promise ( ( resolve , reject ) => { let chunk = [ ] ; const req = https . request ( options , ( res ) => { res . on ( 'data' , ( data ) => { chunk . push ( data ) ; } ) ; res . on ( 'end' , ( ) => { let data = Buffer . concat ( chunk ) ; resolve ( JSON . parse ( data . toString ( ) ) ) ; } ) ; } ) ; req . end ( ) ; req . on ( 'error' , ( error ) => { reject ( error ) ; } ) ; } ) ; } } 
function ( ) { var me = this ; var menu = new Ext . menu . Menu ( { items : [ { text : D . t ( 'Remove shortcut' ) , handler : function ( ) { me . removeShortcut ( menu ) } } ] } ) ; return { xtype : 'dataview' , overItemCls : 'x-view-over' , trackOver : true , itemSelector : me . shortcutItemSelector , store : me . shortcuts , style : { position : 'absolute' } , x : 0 , y : 0 , tpl : new Ext . XTemplate ( me . shortcutTpl ) , listeners : { itemcontextmenu : function ( view , record , el , index , e , eOpts ) { menu . view = view menu . rec = record menu . showAt ( e . getXY ( ) ) ; e . stopEvent ( ) } } } ; } 
function ( e , x ) { var me = this , menu = me . contextMenu ; e . stopEvent ( ) ; if ( ! menu . rendered ) { menu . on ( 'beforeshow' , me . onDesktopMenuBeforeShow , me ) ; } menu . showAt ( e . getXY ( ) ) ; menu . doConstrain ( ) ; } 
function ( menu ) { var items = menu . items . items , win = menu . theWin ; items [ 0 ] . setDisabled ( win . maximized !== true && win . hidden !== true ) ; 
function ( ) { var x = 0 , y = 0 , zmgr = this . getDesktopZIndexManager ( ) ; zmgr . eachBottomUp ( function ( win ) { if ( win . isWindow && win . isVisible ( ) && ! win . maximized ) { win . setPosition ( x , y ) ; x += 20 ; y += 20 ; } } ) ; } 
function protect_split ( separator , str ) { var sep = '######' ; var string = false ; var nb_brackets = 0 ; var new_str = "" ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! string && / ['"`] / . test ( str [ i ] ) ) string = str [ i ] ; else if ( string && str [ i ] == string ) string = false ; else if ( ! string && str [ i ] == '(' ) nb_brackets ++ ; else if ( ! string && str [ i ] == ')' ) nb_brackets -- ; if ( str [ i ] == separator && ( nb_brackets > 0 || string ) ) new_str += sep ; else new_str += str [ i ] ; } str = new_str ; str = str . split ( separator ) ; str = str . map ( function ( item ) { return trim ( item . replace ( new RegExp ( sep , 'g' ) , separator ) ) ; } ) ; return str ; } 
function protect ( str ) { var result = '#' ; var length = str . length ; for ( var i = 0 ; i < length ; i ++ ) result += str [ i ] + "#" ; return result ; } 
function unprotect ( str ) { var result = '' ; var length = str . length ; for ( var i = 1 ; i < length ; i = i + 2 ) result += str [ i ] ; return result ; } 
function ( ) { if ( / \w / . test ( this . currentChar ) ) return this . readWord ( ) ; if ( / ["'`] / . test ( this . currentChar ) ) return this . readString ( ) ; if ( / [()] / . test ( this . currentChar ) ) return this . readGroupSymbol ( ) ; if ( / [!=<>] / . test ( this . currentChar ) ) return this . readOperator ( ) ; if ( this . currentChar === "" ) return { type : 'eot' , value : '' } ; else { this . readNextChar ( ) ; return { type : 'empty' , value : '' } ; } } 
function ( ) { var leftNode = this . parseConditionExpression ( ) ; while ( this . currentToken . type == 'logic' ) { var logic = this . currentToken . value ; this . readNextToken ( ) ; var rightNode = this . parseConditionExpression ( ) ; 
function ( ) { var leftNode = this . parseBaseExpression ( ) ; if ( this . currentToken . type == 'operator' ) { var operator = this . currentToken . value ; this . readNextToken ( ) ; 
function ( ) { var astNode = "" ; 
function cond2sql ( cond , not_first ) { var result = '' ; 
function partiallyDiffText ( a , b ) { if ( b . length >= a . length ) { for ( var i = 0 ; i < a . length ; ++ i ) { if ( a [ i ] !== b [ i ] ) break } var fi = i if ( fi === a . length ) { return { type : 'add' , index : fi , value : b . substr ( fi ) } } else { var ea = a . substr ( fi ) var eb = b . substr ( fi ) for ( var i = 0 ; i < ea . length ; ++ i ) { if ( ea [ ea . length - i - 1 ] !== eb [ eb . length - i - 1 ] ) { break } } var tailLength = i if ( b . length - tailLength - fi > b . length - a . length ) { 
function diffText ( a , b ) { var changes = [ ] var text = a while ( text !== b ) { var c = partiallyDiffText ( text , b ) if ( c . type === 'add' ) { text = text . substr ( 0 , c . index ) + c . value + text . substr ( c . index ) } else { text = text . substr ( 0 , c . index ) + text . substr ( c . index + c . many ) } changes . push ( c ) } return changes } 
function ( store , initial ) { var me = this ; me . mixins . bindable . bindStore . apply ( me , arguments ) ; if ( me . store && ! initial ) { me . refresh ( ) ; } } 
function ( suppressEvent ) { var me = this , selections = me . store . getRange ( ) , i = 0 , len = selections . length , start = me . getSelection ( ) . length ; me . bulkChange = true ; for ( ; i < len ; i ++ ) { me . doSelect ( selections [ i ] , true , suppressEvent ) ; } delete me . bulkChange ; 
function ( record , e , keepExisting ) { var me = this , isSelected = me . isSelected ( record ) ; switch ( me . selectionMode ) { case 'MULTI' : if ( e . shiftKey && me . selectionStart ) { me . selectRange ( me . selectionStart , record , e . ctrlKey ) ; } else if ( e . ctrlKey && isSelected ) { me . doDeselect ( record , false ) ; } else if ( e . ctrlKey ) { me . doSelect ( record , true , false ) ; } else if ( isSelected && ! e . shiftKey && ! e . ctrlKey && me . selected . getCount ( ) > 1 ) { me . doSelect ( record , keepExisting , false ) ; } else if ( ! isSelected ) { me . doSelect ( record , false ) ; } break ; case 'SIMPLE' : if ( isSelected ) { me . doDeselect ( record ) ; } else { me . doSelect ( record , true ) ; } break ; case 'SINGLE' : 
function ( e , record ) { var me = this , recIdx , fromIdx , isSelected = me . isSelected ( record ) , from = ( me . selectionStart && me . isSelected ( me . lastFocused ) ) ? me . selectionStart : ( me . selectionStart = me . lastFocused ) , key = e . getCharCode ( ) , isSpace = key === e . SPACE , direction = key === e . UP || key === e . PAGE_UP ? 'up' : ( key === e . DOWN || key === e . DOWN ? 'down' : null ) ; switch ( me . selectionMode ) { case 'MULTI' : if ( isSpace ) { 
function ( startRow , endRow , keepExisting ) { var me = this , store = me . store , i , toSelect = [ ] ; if ( me . isLocked ( ) ) { return ; } if ( ! keepExisting ) { me . deselectAll ( true ) ; } if ( ! Ext . isNumber ( startRow ) ) { startRow = store . indexOf ( startRow ) ; } if ( ! Ext . isNumber ( endRow ) ) { endRow = store . indexOf ( endRow ) ; } 
function ( startRow , endRow ) { var me = this , store = me . store , i , tmp , record ; if ( me . isLocked ( ) ) { return ; } if ( ! Ext . isNumber ( startRow ) ) { startRow = store . indexOf ( startRow ) ; } if ( ! Ext . isNumber ( endRow ) ) { endRow = store . indexOf ( endRow ) ; } 
function ( fireEvent ) { var me = this ; if ( fireEvent && ! me . bulkChange ) { me . fireEvent ( 'selectionchange' , me , me . getSelection ( ) ) ; } } 
function ( record ) { record = Ext . isNumber ( record ) ? this . store . getAt ( record ) : record ; return this . selected . contains ( record ) ; } 
function ( store , records , indexes , isMove ) { var me = this ; 
function deployRules ( { client , rules , secret } ) { const lastRequest = rulesRequests . get ( client . projectId ) ; return Promise . resolve ( lastRequest ) . then ( oldRulesHash => { const newRuleHash = hash ( rules ) ; if ( oldRulesHash === newRuleHash ) { return oldRulesHash ; } const request = client . rules ( { rules , secret } ) ; rulesRequests . set ( client . projectId , request . then ( ( ) => newRuleHash , ( ) => oldRulesHash ) ) ; return request ; } ) ; } 
function lock ( client , sequence ) { const lastSequence = sequences . get ( client . projectId ) ; return Promise . resolve ( lastSequence ) . then ( ( ) => { const result = sequence ( ) ; sequences . set ( client . projectId , result . then ( noop , noop ) ) ; return result ; } ) ; } 
function $id ( c ) { if ( isWindow ( c ) ) return document . documentElement ; if ( / string|object / . test ( typeof c ) ) { return typeof c == 'string' ? document . getElementById ( c ) : c . nodeType ? c : '' } } 
function getElementsByClassName ( node , classname ) { if ( node . getElementsByClassName ) { 
function getSiblingElements ( node , select ) { if ( isWindow ( node ) ) node = document . documentElement ; var targets = [ ] var temp = [ ] if ( ! select ) return if ( typeof select == 'string' ) { temp = select . split ( ' ' ) } if ( isArray ( select ) ) { temp = select } temp . forEach ( function ( item ) { var char0 = item . charAt ( 0 ) if ( char0 == '#' ) { targets = targets . concat ( document . getElementById ( item . substring ( 1 ) ) ) } else if ( char0 == '.' ) { targets = targets . concat ( toArray ( getElementsByClassName ( node , item . substring ( 1 ) ) ) ) } else { targets = targets . concat ( toArray ( node . getElementsByTagName ( item ) ) ) } } ) if ( targets . length ) return targets } 
function ( oTarget , sEventType , fnHandler ) { if ( oTarget . listeners && oTarget . listeners [ sEventType ] ) { var listeners = oTarget . listeners [ sEventType ] ; for ( var i = listeners . length - 1 ; i >= 0 && fnHandler ; i -- ) { if ( listeners [ i ] == fnHandler ) { listeners . splice ( i , 1 ) ; } } if ( ( ! listeners . length || ! fnHandler ) && listeners [ "_handler" ] ) { oTarget . removeEventListener ? oTarget . removeEventListener ( sEventType , listeners [ "_handler" ] , false ) : oTarget . detachEvent ( 'on' + sEventType , listeners [ "_handler" ] ) ; delete oTarget . listeners [ sEventType ] ; } } } 
function ( oTarget , sEventType , fnHandler ) { oTarget . listeners = oTarget . listeners || { } ; var listeners = oTarget . listeners [ sEventType ] = oTarget . listeners [ sEventType ] || [ ] ; listeners . push ( fnHandler ) ; if ( ! listeners [ "_handler" ] ) { listeners [ "_handler" ] = function ( e ) { var e = e || window . event ; for ( var i = 0 , fn ; fn = listeners [ i ++ ] ; ) { fn . call ( oTarget , e ) } } oTarget . addEventListener ? oTarget . addEventListener ( sEventType , listeners [ "_handler" ] , false ) : oTarget . attachEvent ( 'on' + sEventType , listeners [ "_handler" ] ) ; } } 
function ( ) { var renderData = this . callParent ( ) ; if ( this . owner . getHierarchyState ( ) . rtl ) { renderData . innerCtCls = ( renderData . innerCtCls || '' ) + ' ' + Ext . baseCSSPrefix + 'rtl' ; } return renderData ; } 
function ( o ) { var me = this ; o . un ( { scope : me , mousedown : me . onMouseDown , mouseup : me . onMouseUp , mouseover : me . onMouseOver , mouseout : me . onMouseOut , click : me . onClick } ) ; return me . callParent ( arguments ) ; } 
function ( ) { var i = 0 , sprite , bb , items = this . items , len = this . length , infinity = Infinity , minX = infinity , maxHeight = - infinity , minY = infinity , maxWidth = - infinity , maxWidthBBox , maxHeightBBox ; for ( ; i < len ; i ++ ) { sprite = items [ i ] ; if ( sprite . el && ! sprite . bboxExcluded ) { bb = sprite . getBBox ( ) ; minX = Math . min ( minX , bb . x ) ; minY = Math . min ( minY , bb . y ) ; maxHeight = Math . max ( maxHeight , bb . height + bb . y ) ; maxWidth = Math . max ( maxWidth , bb . width + bb . x ) ; } } return { x : minX , y : minY , height : maxHeight - minY , width : maxWidth - minX } ; } 
function ( attrs , redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i ++ ) { items [ i ] . setAttributes ( attrs , redraw ) ; } return this ; } 
function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i ++ ) { items [ i ] . hide ( redraw ) ; } return this ; } 
function ( redraw ) { var i = 0 , items = this . items , len = this . length ; for ( ; i < len ; i ++ ) { items [ i ] . show ( redraw ) ; } return this ; } 
function ( ) { var me = this , i = 0 , items = me . items , surface = me . getSurface ( ) , len = me . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . renderItem ( items [ i ] ) ; } } return me ; } 
function ( obj ) { var i = 0 , items = this . items , len = this . length , item , el ; for ( ; i < len ; i ++ ) { item = items [ i ] ; el = item . el ; if ( el ) { el . setStyle ( obj ) ; } } } 
function ( obj ) { var i = 0 , items = this . items , surface = this . getSurface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . addCls ( items [ i ] , obj ) ; } } } 
function ( obj ) { var i = 0 , items = this . items , surface = this . getSurface ( ) , len = this . length ; if ( surface ) { for ( ; i < len ; i ++ ) { surface . removeCls ( items [ i ] , obj ) ; } } } 
function ( ) { var me = this , surface = me . getSurface ( ) , destroySprites = me . autoDestroy , item ; if ( surface ) { while ( me . getCount ( ) > 0 ) { item = me . first ( ) ; me . remove ( item ) ; surface . remove ( item , destroySprites ) ; } } me . clearListeners ( ) ; } 
function ( ) { var me = this ; me . source = me . source || { } ; me . addCls ( me . gridCls ) ; me . plugins = me . plugins || [ ] ; * @event beforepropertychange * Fires before a property value changes. Handlers can return false to cancel the property change * (this will internally call {@link Ext.data.Model#reject} on the property's record). * @param {Object} source The source data object for the grid (corresponds to the same object passed in * as the {@link #source} config property). * @param {String} recordId The record's id in the data store * @param {Object} value The current edited property value * @param {Object} oldValue The original property value prior to editing */ 'beforepropertychange' , 'propertychange' ) ; me . callParent ( ) ; 
function ( config ) { var me = this , o , key , value ; me . copyLegacyObject ( config , me . customRenderers , 'renderer' ) ; me . copyLegacyObject ( config , me . customEditors , 'editor' ) ; me . copyLegacyObject ( config , me . propertyNames , 'displayName' ) ; 
function ( pos , direction , e , preventWrap , verifierFn , scope ) { if ( direction == 'left' ) { direction = 'up' ; } else if ( direction == 'right' ) { direction = 'down' ; } pos = Ext . view . Table . prototype . walkCells . call ( this , pos , direction , e , preventWrap , verifierFn , scope ) ; if ( pos && ! pos . column ) { pos . column = 1 ; } return pos ; } 
function ( source , sourceConfig ) { var me = this ; me . source = source ; if ( sourceConfig !== undefined ) { me . sourceConfig = Ext . apply ( { } , sourceConfig ) ; me . configure ( me . sourceConfig ) ; } me . propStore . setSource ( source ) ; } 
function init ( ) { tinyMCEPopup . resizeToInnerSize ( ) ; var inst = tinyMCEPopup . editor ; var dom = inst . dom ; var elm = inst . selection . getNode ( ) ; var f = document . forms [ 0 ] ; var onclick = dom . getAttrib ( elm , 'onclick' ) ; setFormValue ( 'title' , dom . getAttrib ( elm , 'title' ) ) ; setFormValue ( 'id' , dom . getAttrib ( elm , 'id' ) ) ; setFormValue ( 'style' , dom . getAttrib ( elm , "style" ) ) ; setFormValue ( 'dir' , dom . getAttrib ( elm , 'dir' ) ) ; setFormValue ( 'lang' , dom . getAttrib ( elm , 'lang' ) ) ; setFormValue ( 'tabindex' , dom . getAttrib ( elm , 'tabindex' , typeof ( elm . tabindex ) != "undefined" ? elm . tabindex : "" ) ) ; setFormValue ( 'accesskey' , dom . getAttrib ( elm , 'accesskey' , typeof ( elm . accesskey ) != "undefined" ? elm . accesskey : "" ) ) ; setFormValue ( 'onfocus' , dom . getAttrib ( elm , 'onfocus' ) ) ; setFormValue ( 'onblur' , dom . getAttrib ( elm , 'onblur' ) ) ; setFormValue ( 'onclick' , onclick ) ; setFormValue ( 'ondblclick' , dom . getAttrib ( elm , 'ondblclick' ) ) ; setFormValue ( 'onmousedown' , dom . getAttrib ( elm , 'onmousedown' ) ) ; setFormValue ( 'onmouseup' , dom . getAttrib ( elm , 'onmouseup' ) ) ; setFormValue ( 'onmouseover' , dom . getAttrib ( elm , 'onmouseover' ) ) ; setFormValue ( 'onmousemove' , dom . getAttrib ( elm , 'onmousemove' ) ) ; setFormValue ( 'onmouseout' , dom . getAttrib ( elm , 'onmouseout' ) ) ; setFormValue ( 'onkeypress' , dom . getAttrib ( elm , 'onkeypress' ) ) ; setFormValue ( 'onkeydown' , dom . getAttrib ( elm , 'onkeydown' ) ) ; setFormValue ( 'onkeyup' , dom . getAttrib ( elm , 'onkeyup' ) ) ; className = dom . getAttrib ( elm , 'class' ) ; addClassesToList ( 'classlist' , 'advlink_styles' ) ; selectByValue ( f , 'classlist' , className , true ) ; TinyMCE_EditableSelects . init ( ) ; } 
function ( columns ) { var i , len = columns . length , column ; for ( i = 0 ; i < len ; i ++ ) { column = columns [ i ] ; if ( ! column . processed && column . locked ) { return true ; } } } 
function ( headerCt , header , colsToMove , fromIdx , toIdx ) { var me = this ; 
function ( ) { var me = this ; return me . lhsMarker || ( me . lhsMarker = Ext . DomHelper . append ( me . el , { cls : me . resizeMarkerCls } , true ) ) ; } 
function HotPath ( options ) { if ( ! this ) return new HotPath ( options ) ; options = options || { } ; this . maximum = bytes ( options . maximum || HotPath . maximum ) ; 
function ( baseUri ) { this . option = { common : helper . getCommonOptions ( baseUri ) , current : null } ; this . expect = { common : { } , current : null } ; } 
function ( textField ) { this . isTextArea = ( this . textField . inputEl . dom . type . toLowerCase ( ) == 'textarea' ) ; this . createClearButtonEl ( ) ; this . addListeners ( ) ; this . repositionClearButton ( ) ; this . updateClearButtonVisibility ( ) ; this . addEscListener ( ) ; } 
function ( ) { var animateWithClass = this . animateClearButton && this . animateWithCss3 ; this . clearButtonEl = this . textField . bodyEl . createChild ( { tag : 'div' , cls : this . clearButtonCls } ) ; if ( this . animateClearButton ) { this . animateWithCss3 = this . supportsCssTransition ( this . clearButtonEl ) ; } if ( this . animateWithCss3 ) { this . clearButtonEl . addCls ( this . clearButtonCls + '-off' ) ; } else { this . clearButtonEl . setStyle ( 'visibility' , 'hidden' ) ; } } 
function ( el ) { var styles = [ 'transitionProperty' , 'WebkitTransitionProperty' , 'MozTransitionProperty' , 'OTransitionProperty' , 'msTransitionProperty' , 'KhtmlTransitionProperty' ] ; var style = el . dom . style ; for ( var i = 0 , length = styles . length ; i < length ; ++ i ) { if ( style [ styles [ i ] ] !== 'undefined' ) { 
function ( ) { if ( ! this . clearOnEscape ) { return ; } 
function ( ) { 
function ( event , htmlElement , object ) { if ( ! this . isLeftButton ( event ) ) { return ; } 
function ( ) { var clearButtonEl = this . clearButtonEl ; if ( ! clearButtonEl ) { return ; } var right = 0 ; if ( this . fieldHasScrollBar ( ) ) { right += Ext . getScrollBarWidth ( ) ; } if ( this . textField . triggerWrap ) { right += this . textField . getTriggerWidth ( ) ; } clearButtonEl . alignTo ( this . textField . bodyEl , 'tr-tr' , [ - 1 * ( right + 3 ) , 5 ] ) ; } 
function ( textField ) { var positions = textField . inputEl . getBox ( true , true ) ; var top = positions . y ; var right = positions . x ; if ( this . fieldHasScrollBar ( ) ) { right += Ext . getScrollBarWidth ( ) ; } if ( this . textField . triggerWrap ) { right += this . textField . getTriggerWidth ( ) ; 
function ( ) { if ( ! this . isTextArea ) { return false ; } var inputEl = this . textField . inputEl ; var overflowY = inputEl . getStyle ( 'overflow-y' ) ; if ( overflowY == 'hidden' || overflowY == 'visible' ) { return false ; } if ( overflowY == 'scroll' ) { return true ; } 
function ( ) { if ( this . animateClearButton && this . animateWithCss3 ) { return this . clearButtonEl . hasCls ( this . clearButtonCls + '-on' ) ; } 
function ( ) { if ( this . hideClearButtonWhenEmpty && Ext . isEmpty ( this . textField . getValue ( ) ) ) { return false ; } var clearButtonEl = this . clearButtonEl ; 
function ( ) { var oldVisible = this . isButtonCurrentlyVisible ( ) ; var newVisible = this . shouldButtonBeVisible ( ) ; var clearButtonEl = this . clearButtonEl ; if ( oldVisible != newVisible ) { if ( this . animateClearButton && this . animateWithCss3 ) { this . clearButtonEl . removeCls ( this . clearButtonCls + ( oldVisible ? '-on' : '-off' ) ) ; clearButtonEl . addCls ( this . clearButtonCls + ( newVisible ? '-on' : '-off' ) ) ; } else { clearButtonEl . stopAnimation ( ) ; clearButtonEl . setVisible ( newVisible , this . animateClearButton ) ; } 
function compute ( paramValues ) { 
function quit ( message , line , chr ) { var percentage = Math . floor ( ( line / lines . length ) * 100 ) ; throw { name : 'JSHintError' , line : line , character : chr , message : message + " (" + percentage + "% scanned)." , raw : message } ; } 
function nextLine ( ) { var at , tw ; 
function ( ) { var b , c , captures , d , depth , high , i , l , low , q , t , isLiteral , isInRange , n ; function match ( x ) { var r = x . exec ( s ) , r1 ; if ( r ) { l = r [ 0 ] . length ; r1 = r [ 1 ] ; c = r1 . charAt ( 0 ) ; s = s . substr ( l ) ; from = character + l - r1 . length ; character += l ; return r1 ; } } function string ( x ) { var c , j , r = '' , allowNewLine = false ; if ( jsonmode && x !== '"' ) { warningAt ( "Strings must use doublequote." , line , character ) ; } function esc ( n ) { var i = parseInt ( s . substr ( j + 1 , n ) , 16 ) ; j += n ; if ( i >= 32 && i <= 126 && i !== 34 && i !== 92 && i !== 39 ) { warningAt ( "Unnecessary escapement." , line , character ) ; } character += n ; c = String . fromCharCode ( i ) ; } j = 0 ; unclosedString : for ( ; ; ) { while ( j >= s . length ) { j = 0 ; var cl = line , cf = from ; if ( ! nextLine ( ) ) { errorAt ( "Unclosed string." , cl , cf ) ; break unclosedString ; } if ( allowNewLine ) { allowNewLine = false ; } else { warningAt ( "Unclosed string." , cl , cf ) ; } } c = s . charAt ( j ) ; if ( c === x ) { character += 1 ; s = s . substr ( j + 1 ) ; return it ( '(string)' , r , x ) ; } if ( c < ' ' ) { if ( c === '\n' || c === '\r' ) { break ; } warningAt ( "Control character in string: {a}." , line , character + j , s . slice ( 0 , j ) ) ; } else if ( c === '\\' ) { j += 1 ; character += 1 ; c = s . charAt ( j ) ; n = s . charAt ( j + 1 ) ; switch ( c ) { case '\\' : case '"' : case '/' : break ; case '\'' : if ( jsonmode ) { warningAt ( "Avoid \\'." , line , character ) ; } break ; case 'b' : c = '\b' ; break ; case 'f' : c = '\f' ; break ; case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case '0' : c = '\0' ; // Octal literals fail in strict mode // check if the number is between 00 and 07 // where 'n' is the token next to 'c' if ( n >= 0 && n <= 7 && directive [ "use strict" ] ) { warningAt ( "Octal literals are not allowed in strict mode." , line , character ) ; } break ; case 'u' : esc ( 4 ) ; break ; case 'v' : if ( jsonmode ) { warningAt ( "Avoid \\v." , line , character ) ; } c = '\v' ; break ; case 'x' : if ( jsonmode ) { warningAt ( "Avoid \\x-." , line , character ) ; } esc ( 2 ) ; break ; case '' : // last character is escape character // always allow new line if escaped, but show // warning if option is not set allowNewLine = true ; if ( option . multistr ) { if ( jsonmode ) { warningAt ( "Avoid EOL escapement." , line , character ) ; } c = '' ; character -= 1 ; break ; } warningAt ( "Bad escapement of EOL. Use option multistr if needed." , line , character ) ; break ; default : warningAt ( "Bad escapement." , line , character ) ; } } r += c ; character += 1 ; j += 1 ; } } for ( ; ; ) { if ( ! s ) { return it ( nextLine ( ) ? '(endline)' : '(end)' , '' ) ; } t = match ( tx ) ; if ( ! t ) { t = '' ; c = '' ; while ( s && s < '!' ) { s = s . substr ( 1 ) ; } if ( s ) { errorAt ( "Unexpected '{a}'." , line , character , s . substr ( 0 , 1 ) ) ; s = '' ; } } else { // identifier if ( c . isAlpha ( ) || c === '_' || c === '$' ) { return it ( '(identifier)' , t ) ; } // number if ( c . isDigit ( ) ) { if ( ! isFinite ( Number ( t ) ) ) { warningAt ( "Bad number '{a}'." , line , character , t ) ; } if ( s . substr ( 0 , 1 ) . isAlpha ( ) ) { warningAt ( "Missing space after '{a}'." , line , character , t ) ; } if ( c === '0' ) { d = t . substr ( 1 , 1 ) ; if ( d . isDigit ( ) ) { if ( token . id !== '.' ) { warningAt ( "Don't use extra leading zeros '{a}'." , line , character , t ) ; } } else if ( jsonmode && ( d === 'x' || d === 'X' ) ) { warningAt ( "Avoid 0x-. '{a}'." , line , character , t ) ; } } if ( t . substr ( t . length - 1 ) === '.' ) { warningAt ( "A trailing decimal point can be confused with a dot '{a}'." , line , character , t ) ; } return it ( '(number)' , t ) ; } switch ( t ) { // string case '"' : case "'" : return string ( t ) ; // // comment case ' 
function expression ( rbp , initial ) { var left , isArray = false , isObject = false ; if ( nexttoken . id === '(end)' ) error ( "Unexpected early end of program." , token ) ; advance ( ) ; if ( initial ) { anonname = 'anonymous' ; funct [ '(verb)' ] = token . value ; } if ( initial === true && token . fud ) { left = token . fud ( ) ; } else { if ( token . nud ) { left = token . nud ( ) ; } else { if ( nexttoken . type === '(number)' && token . id === '.' ) { warning ( "A leading decimal point can be confused with a dot: '.{a}'." , token , nexttoken . value ) ; advance ( ) ; return token ; } else { error ( "Expected an identifier and instead saw '{a}'." , token , token . id ) ; } } while ( rbp < nexttoken . lbp ) { isArray = token . value === 'Array' ; isObject = token . value === 'Object' ; advance ( ) ; if ( isArray && token . id === '(' && nexttoken . id === ')' ) warning ( "Use the array literal notation []." , token ) ; if ( isObject && token . id === '(' && nexttoken . id === ')' ) warning ( "Use the object literal notation {}." , token ) ; if ( token . led ) { left = token . led ( left ) ; } else { error ( "Expected an operator and instead saw '{a}'." , token , token . id ) ; } } } return left ; } 
function adjacent ( left , right ) { left = left || token ; right = right || nexttoken ; if ( option . white ) { if ( left . character !== right . from && left . line === right . line ) { left . from += ( left . character - left . from ) ; warning ( "Unexpected space after '{a}'." , left , left . value ) ; } } } 
function optionalidentifier ( fnparam ) { if ( nexttoken . identifier ) { advance ( ) ; if ( token . reserved && ! option . es5 ) { 
function directives ( ) { var i , p , pn ; for ( ; ; ) { if ( nexttoken . id === "(string)" ) { p = peek ( 0 ) ; if ( p . id === "(endline)" ) { i = 1 ; do { pn = peek ( i ) ; i = i + 1 ; } while ( pn . id === "(endline)" ) ; if ( pn . id !== ";" ) { if ( pn . id !== "(string)" && pn . id !== "(number)" && pn . id !== "(regexp)" && pn . identifier !== true && pn . id !== "}" ) { break ; } warning ( "Missing semicolon." , nexttoken ) ; } else { p = pn ; } } else if ( p . id === "}" ) { 
function block ( ordinary , stmt , isfunc ) { var a , b = inblock , old_indent = indent , m , s = scope , t , line , d ; inblock = ordinary ; if ( ! ordinary || ! option . funcscope ) scope = Object . create ( scope ) ; nonadjacent ( token , nexttoken ) ; t = nexttoken ; if ( nexttoken . id === '{' ) { advance ( '{' ) ; line = token . line ; if ( nexttoken . id !== '}' ) { indent += option . indent ; while ( ! ordinary && nexttoken . from > indent ) { indent += option . indent ; } if ( isfunc ) { m = { } ; for ( d in directive ) { if ( is_own ( directive , d ) ) { m [ d ] = directive [ d ] ; } } directives ( ) ; if ( option . strict && funct [ '(context)' ] [ '(global)' ] ) { if ( ! m [ "use strict" ] && ! directive [ "use strict" ] ) { warning ( "Missing \"use strict\" statement." ) ; } } } a = statements ( line ) ; if ( isfunc ) { directive = m ; } indent -= option . indent ; if ( line !== nexttoken . line ) { indentation ( ) ; } } else if ( line !== nexttoken . line ) { indentation ( ) ; } advance ( '}' , t ) ; indent = old_indent ; } else if ( ! ordinary ) { error ( "Expected '{a}' and instead saw '{b}'." , nexttoken , '{' , nexttoken . value ) ; } else { if ( ! stmt || option . curly ) warning ( "Expected '{a}' and instead saw '{b}'." , nexttoken , '{' , nexttoken . value ) ; noreach = true ; indent += option . indent ; 
function saveProperty ( name , token ) { if ( props [ name ] && is_own ( props , name ) ) warning ( "Duplicate member '{a}'." , nexttoken , i ) ; else props [ name ] = { } ; props [ name ] . basic = true ; props [ name ] . basicToken = token ; } 
function ( s , o , g ) { var a , i , k ; JSHINT . errors = [ ] ; JSHINT . undefs = [ ] ; predefined = Object . create ( standard ) ; combine ( predefined , g || { } ) ; if ( o ) { a = o . predef ; if ( a ) { if ( Array . isArray ( a ) ) { for ( i = 0 ; i < a . length ; i += 1 ) { predefined [ a [ i ] ] = true ; } } else if ( typeof a === 'object' ) { k = Object . keys ( a ) ; for ( i = 0 ; i < k . length ; i += 1 ) { predefined [ k [ i ] ] = ! ! a [ k [ i ] ] ; } } } option = o ; } else { option = { } ; } option . indent = option . indent || 4 ; option . maxerr = option . maxerr || 50 ; tab = '' ; for ( i = 0 ; i < option . indent ; i += 1 ) { tab += ' ' ; } indent = 1 ; global = Object . create ( predefined ) ; scope = global ; funct = { '(global)' : true , '(name)' : '(global)' , '(scope)' : scope , '(breakage)' : 0 , '(loopage)' : 0 } ; functions = [ funct ] ; urls = [ ] ; stack = null ; member = { } ; membersOnly = null ; implied = { } ; inblock = false ; lookahead = [ ] ; jsonmode = false ; warnings = 0 ; lex . init ( s ) ; prereg = true ; directive = { } ; prevtoken = token = nexttoken = syntax [ '(begin)' ] ; 
function Pragma ( n ) { if ( n . type === SEMICOLON ) { var e = n . expression ; if ( e . type === STRING && e . value === "use strict" ) { n . pragma = "strict" ; return true ; } } return false ; } 
function SyntheticNode ( init ) { this . children = [ ] ; for ( var prop in init ) this [ prop ] = init [ prop ] ; this . synthetic = true ; } 
function registerExport ( exports , decl ) { function register ( name , exp ) { if ( exports . has ( name ) ) throw new SyntaxError ( "multiple exports of " + name ) ; exports . set ( name , exp ) ; } switch ( decl . type ) { case MODULE : case FUNCTION : register ( decl . name , new Export ( decl , true ) ) ; break ; case VAR : for ( var i = 0 ; i < decl . children . length ; i ++ ) register ( decl . children [ i ] . name , new Export ( decl . children [ i ] , true ) ) ; break ; case LET : case CONST : throw new Error ( "NYI: " + definitions . tokens [ decl . type ] ) ; case EXPORT : for ( var i = 0 ; i < decl . pathList . length ; i ++ ) { var path = decl . pathList [ i ] ; switch ( path . type ) { case OBJECT_INIT : for ( var j = 0 ; j < path . children . length ; j ++ ) { 
function Module ( node ) { var exports = node . body . exports ; var modDefns = node . body . modDefns ; var exportedModules = new Dict ( ) ; exports . forEach ( function ( name , exp ) { var node = exp . node ; if ( node . type === MODULE ) { exportedModules . set ( name , node ) ; } else if ( ! exp . isDefinition && node . type === IDENTIFIER && modDefns . has ( node . value ) ) { var mod = modDefns . get ( node . value ) ; exportedModules . set ( name , mod ) ; } } ) ; this . node = node ; this . exports = exports ; this . exportedModules = exportedModules ; } 
function isPragmaToken ( tt ) { switch ( tt ) { case IDENTIFIER : case STRING : case NUMBER : case NULL : case TRUE : case FALSE : return true ; } return false ; } 
function parse ( s , f , l ) { var t = new Tokenizer ( s , f , l , options . allowHTMLComments ) ; var p = new Parser ( t ) ; return p . Script ( false , false , true ) ; } 
function parseFunction ( s , requireName , form , f , l ) { var t = new Tokenizer ( s , f , l ) ; var p = new Parser ( t ) ; p . x = new StaticContext ( null , null , false , false , false ) ; return p . FunctionDefinition ( requireName , form ) ; } 
function parseStdin ( s , ln , prefix , isCommand ) { 
function parseMultiline ( ln , prefix ) { var s = "" ; for ( ; ; ) { if ( prefix ) putstr ( prefix ) ; var more = readline ( ) ; if ( more === null ) return null ; 
function isValidIdentifierChar ( ch , first ) { 
function Tokenizer ( s , f , l , allowHTMLComments ) { this . cursor = 0 ; this . source = String ( s ) ; this . tokens = [ ] ; this . tokenIndex = 0 ; this . lookahead = 0 ; this . scanNewlines = false ; this . filename = f || "" ; this . lineno = l || 1 ; this . allowHTMLComments = allowHTMLComments ; this . blockComments = null ; } 
function ( ) { var input = this . source ; this . blockComments = [ ] ; for ( ; ; ) { var ch = input [ this . cursor ++ ] ; var next = input [ this . cursor ] ; 
function ( ch , keywordIsName ) { var token = this . token ; var id = ch ; while ( ( ch = this . getValidIdentifierChar ( false ) ) !== null ) { id += ch ; } token . type = IDENTIFIER ; token . value = id ; if ( keywordIsName ) return ; var kw ; if ( this . parser . mozillaMode ) { kw = definitions . mozillaKeywords [ id ] ; if ( kw ) { token . type = kw ; return ; } } if ( this . parser . x . strictMode ) { kw = definitions . strictKeywords [ id ] ; if ( kw ) { token . type = kw ; return ; } } kw = definitions . keywords [ id ] ; if ( kw ) token . type = kw ; } 
function ( first ) { var input = this . source ; if ( this . cursor >= input . length ) return null ; var ch = input [ this . cursor ] ; 
function mixinHandler ( redirect , catchall ) { function targetFor ( name ) { return hasOwn ( redirect , name ) ? redirect [ name ] : catchall ; } function getMuxPropertyDescriptor ( name ) { var desc = getPropertyDescriptor ( targetFor ( name ) , name ) ; if ( desc ) desc . configurable = true ; return desc ; } function getMuxPropertyNames ( ) { var names1 = Object . getOwnPropertyNames ( redirect ) . filter ( function ( name ) { return name in redirect [ name ] ; } ) ; var names2 = getPropertyNames ( catchall ) . filter ( function ( name ) { return ! hasOwn ( redirect , name ) ; } ) ; return names1 . concat ( names2 ) ; } function enumerateMux ( ) { var result = Object . getOwnPropertyNames ( redirect ) . filter ( function ( name ) { return name in redirect [ name ] ; } ) ; for ( name in catchall ) { if ( ! hasOwn ( redirect , name ) ) result . push ( name ) ; } ; return result ; } function hasMux ( name ) { return name in targetFor ( name ) ; } return { getOwnPropertyDescriptor : getMuxPropertyDescriptor , getPropertyDescriptor : getMuxPropertyDescriptor , getOwnPropertyNames : getMuxPropertyNames , defineProperty : function ( name , desc ) { Object . defineProperty ( targetFor ( name ) , name , desc ) ; } , "delete" : function ( name ) { var target = targetFor ( name ) ; return delete target [ name ] ; } , 
function makePow ( left , prev ) { if ( left . isEmpty ( ) ) { return prev ; } const elem = left . first ( ) ; return makePow ( left . remove ( elem ) , prev . union ( prev . map ( e => e . add ( elem ) ) ) ) ; } 
function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; // example: <strong> to [b] rep ( / <a.*?href=\"(.*?)\".*?>(.*?)<\/a> / gi , "[url=$1]$2[/url]" ) ; rep ( / <font.*?color=\"(.*?)\".*?class=\"codeStyle\".*?>(.*?)<\/font> / gi , "[code][color=$1]$2[/color][/code]" ) ; rep ( / <font.*?color=\"(.*?)\".*?class=\"quoteStyle\".*?>(.*?)<\/font> / gi , "[quote][color=$1]$2[/color][/quote]" ) ; rep ( / <font.*?class=\"codeStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[code][color=$1]$2[/color][/code]" ) ; rep ( / <font.*?class=\"quoteStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[quote][color=$1]$2[/color][/quote]" ) ; rep ( / <span style=\"color: ?(.*?);\">(.*?)<\/span> / gi , "[color=$1]$2[/color]" ) ; rep ( / <font.*?color=\"(.*?)\".*?>(.*?)<\/font> / gi , "[color=$1]$2[/color]" ) ; rep ( / <span style=\"font-size:(.*?);\">(.*?)<\/span> / gi , "[size=$1]$2[/size]" ) ; rep ( / <font>(.*?)<\/font> / gi , "$1" ) ; rep ( / <img.*?src=\"(.*?)\".*?\/> / gi , "[img]$1[/img]" ) ; rep ( / <span class=\"codeStyle\">(.*?)<\/span> / gi , "[code]$1[/code]" ) ; rep ( / <span class=\"quoteStyle\">(.*?)<\/span> / gi , "[quote]$1[/quote]" ) ; rep ( / <strong class=\"codeStyle\">(.*?)<\/strong> / gi , "[code][b]$1[/b][/code]" ) ; rep ( / <strong class=\"quoteStyle\">(.*?)<\/strong> / gi , "[quote][b]$1[/b][/quote]" ) ; rep ( / <em class=\"codeStyle\">(.*?)<\/em> / gi , "[code][i]$1[/i][/code]" ) ; rep ( / <em class=\"quoteStyle\">(.*?)<\/em> / gi , "[quote][i]$1[/i][/quote]" ) ; rep ( / <u class=\"codeStyle\">(.*?)<\/u> / gi , "[code][u]$1[/u][/code]" ) ; rep ( / <u class=\"quoteStyle\">(.*?)<\/u> / gi , "[quote][u]$1[/u][/quote]" ) ; rep ( / <\/(strong|b)> / gi , "[/b]" ) ; rep ( / <(strong|b)> / gi , "[b]" ) ; rep ( / <\/(em|i)> / gi , "[/i]" ) ; rep ( / <(em|i)> / gi , "[i]" ) ; rep ( / <\/u> / gi , "[/u]" ) ; rep ( / <span style=\"text-decoration: ?underline;\">(.*?)<\/span> / gi , "[u]$1[/u]" ) ; rep ( / <u> / gi , "[u]" ) ; rep ( / <blockquote[^>]*> / gi , "[quote]" ) ; rep ( / <\/blockquote> / gi , "[/quote]" ) ; rep ( / <br \/> / gi , "\n" ) ; rep ( / <br\/> / gi , "\n" ) ; rep ( / <br> / gi , "\n" ) ; rep ( / <p> / gi , "" ) ; rep ( / <\/p> / gi , "\n" ) ; rep ( / &nbsp;|\u00a0 / gi , " " ) ; rep ( / &quot; / gi , "\"" ) ; rep ( / &lt; / gi , "<" ) ; rep ( / &gt; / gi , ">" ) ; rep ( / &amp; / gi , "&" ) ; return s ; } 
function ( s ) { s = tinymce . trim ( s ) ; function rep ( re , str ) { s = s . replace ( re , str ) ; } ; // example: [b] to <strong> rep ( / \n / gi , "<br />" ) ; rep ( / \[b\] / gi , "<strong>" ) ; rep ( / \[\/b\] / gi , "</strong>" ) ; rep ( / \[i\] / gi , "<em>" ) ; rep ( / \[\/i\] / gi , "</em>" ) ; rep ( / \[u\] / gi , "<u>" ) ; rep ( / \[\/u\] / gi , "</u>" ) ; rep ( / \[url=([^\]]+)\](.*?)\[\/url\] / gi , "<a href=\"$1\">$2</a>" ) ; rep ( / \[url\](.*?)\[\/url\] / gi , "<a href=\"$1\">$1</a>" ) ; rep ( / \[img\](.*?)\[\/img\] / gi , "<img src=\"$1\" />" ) ; rep ( / \[color=(.*?)\](.*?)\[\/color\] / gi , "<font color=\"$1\">$2</font>" ) ; rep ( / \[code\](.*?)\[\/code\] / gi , "<span class=\"codeStyle\">$1</span>&nbsp;" ) ; rep ( / \[quote.*?\](.*?)\[\/quote\] / gi , "<span class=\"quoteStyle\">$1</span>&nbsp;" ) ; return s ; } 
function ( childContext , axis ) { var collapseTarget = childContext . collapseTarget , setSizeMethod = 'set' + axis . sizePropCap , sizeProp = axis . sizeProp , childMarginSize = childContext . getMarginInfo ( ) [ sizeProp ] , region , isBegin , flex , pos , size ; if ( collapseTarget ) { 
function ( ownerContext , axis ) { var size = axis . end - axis . begin , center = ownerContext . centerRegion ; if ( center ) { center [ 'set' + axis . sizePropCap ] ( size - center . getMarginInfo ( ) [ axis . sizeProp ] ) ; center . layoutPos [ axis . posProp ] = axis . begin ; } return Ext . isNumber ( size ) ? 1 : 0 ; } 
function ( childItems ) { var length = childItems . length , index , childContext ; for ( index = 0 ; index < length ; ++ index ) { childContext = childItems [ index ] ; childContext . setProp ( 'x' , childContext . layoutPos . x + childContext . marginInfo . left ) ; childContext . setProp ( 'y' , childContext . layoutPos . y + childContext . marginInfo . top ) ; } } 
function ( item , index , hidden ) { var region = item . region , splitter = { xtype : 'bordersplitter' , collapseTarget : item , id : item . id + '-splitter' , hidden : hidden , canResize : item . splitterResize !== false } , at = index + ( ( region == 'south' || region == 'east' ) ? 0 : 1 ) ; 
function ( item , index ) { var me = this , placeholderFor = item . placeholderFor , region = item . region , split , hidden ; me . callParent ( arguments ) ; if ( region ) { Ext . apply ( item , me . regionFlags [ region ] ) ; if ( region == 'center' ) { 
function array ( x , dtype ) { var ctor , dt ; if ( isNumber ( x ) ) { if ( ! isNonNegativeInteger ( x ) ) { throw new TypeError ( 'invalid input argument. Array length must be a nonnegative integer. Value: `' + x + '`.' ) ; } if ( arguments . length === 1 ) { return new CTOR ( x ) ; } ctor = ctors ( dtype ) ; if ( ctor === null ) { throw new Error ( 'invalid input argument. Unrecognized/unsupported data type. Value: `' + dtype + '`.' ) ; } return new ctor ( x ) ; } if ( ! isArrayLike ( x ) ) { throw new TypeError ( 'invalid input argument. Input data must be either a typed or generic array. Value: `' + x + '`.' ) ; } if ( arguments . length > 1 ) { dt = dtype ; } else { dt = 'float64' ; } return cast ( x , dt ) ; } 
function mapType ( rel , ch ) { var inputType = rel . params [ 0 ] . schemaType 
function Duration ( str ) { 
function ( ) { var result = { } , fields = this . fields , key , field ; for ( key in fields ) { if ( fields . hasOwnProperty ( key ) ) { field = fields [ key ] ; if ( field . isValid ( ) && field . getValue ( ) !== null ) { result [ key ] = field . getValue ( ) ; } } } return result ; } 
function ( data ) { var me = this , fields = me . fields , key , field ; for ( key in fields ) { if ( fields . hasOwnProperty ( key ) ) { 
function addConnection ( c ) { ++ connectionCount if ( ! connections ) { 
function sendReady ( e ) { 
function ( e ) { s . getSnapshots ( e , function ( err , versionList ) { if ( err ) { _ . errout ( 'TODO: ' + err ) } var res = { snapshotVersionIds : serializeSnapshotVersionList ( versionList ) , isHistorical : e . isHistorical } res . requestId = e . requestId ; conn . w . gotSnapshots ( res ) ; conn . w . flush ( ) ; } ) ; } 
function rectConnect ( ) { if ( arguments . length === 3 ) { return _rectConnectRectToPoint . apply ( undefined , arguments ) ; } return _rectConnectRectToRect . apply ( undefined , arguments ) ; } 
function addSubview ( subview ) { debug ( 'add subview `%s`' , this . toString ( ) ) ; if ( _ . isUndefined ( this . subviews ) ) { this . subviews = [ ] ; } subview . parentView = this ; this . subviews . push ( subview ) ; } 
function removeSubview ( subview ) { debug ( 'remove subview `%s`' , this . toString ( ) ) ; subview . close ( ) ; if ( this . subviews ) { this . subviews = _ . without ( this . subviews , subview ) ; } subview . parentView = undefined ; } 
function renderSubviews ( ) { debug ( 'render subviews `%s`' , this . toString ( ) ) ; var self = this , $ = self . $ ; return Q . when ( _ . each ( self . subviews , function ( subview ) { subview . $ = $ ; subview . $el = subview . selectDOMElement ( $ ) ; subview . render . call ( subview ) ; subview . delegateEvents ( ) ; } ) ) ; } 
function render ( ) { debug ( 'render `%s`' , this . toString ( ) ) ; var self = this ; function invokeBeforeRender ( ) { debug ( 'invoke before render `%s`' , self . toString ( ) ) ; var deferBeforeRender = Q . defer ( ) , resolve = deferBeforeRender . resolve , reject = deferBeforeRender . reject ; if ( ! _ . isUndefined ( self . beforeRender ) ) { self . beforeRender ( resolve , reject ) ; } else { resolve ( ) ; } return deferBeforeRender . promise ; } function invokeRender ( ) { debug ( 'invoke render `%s`' , self . toString ( ) ) ; if ( ! _ . isUndefined ( self . renderView ) ) { self . renderView ( ) ; } } function invokeAfterRender ( ) { debug ( 'invoke after render `%s`' , self . toString ( ) ) ; var deferAfterRender = Q . defer ( ) , resolve = deferAfterRender . resolve , reject = deferAfterRender . reject ; if ( ! _ . isUndefined ( self . afterRender ) ) { self . afterRender ( resolve , reject ) ; } else { resolve ( ) ; } return deferAfterRender . promise ; } return invokeBeforeRender ( ) . then ( invokeRender ) . then ( invokeAfterRender ) . then ( self . renderSubviews . bind ( self ) ) ; } 
function selectDOMElement ( $ ) { debug ( 'select dom element `%s`' , this . toString ( ) ) ; var domElement ; if ( ! this . el ) { var attrs = _ . extend ( { } , _ . result ( this , 'attributes' ) ) ; if ( this . id ) { attrs . id = _ . result ( this , 'id' ) ; } if ( this . className ) { attrs [ 'class' ] = _ . result ( this , 'className' ) ; } var selector = '<' + _ . result ( this , 'tagName' ) + '>' ; domElement = $ ( selector ) . attr ( attrs ) ; } else { domElement = $ ( _ . result ( this , 'el' ) ) ; } return domElement ; } 
function ensureDefault ( val , def ) { if ( ( util_1 . isNullOrUndefined ( val ) || val === '' ) && ! chek_1 . isUndefined ( def ) ) return def ; return val ; } 
function isLikeNumber ( val ) { return constants_1 . LIKE_HEX_NUMBER . test ( val ) || constants_1 . LIKE_NUMBER . test ( val ) ; } 
function ( val ) { val = ensureDefault ( val , constants_1 . DEFAULT_TYPE_VALUES . boolean ) ; return Boolean ( / ^false$ / i . test ( val ) ? false : val ) ; } 
function ( val ) { val = ensureDefault ( val , constants_1 . DEFAULT_TYPE_VALUES . array ) ; if ( ! Array . isArray ( val ) ) val = [ val ] ; return val ; } 
function toCamelcase ( val , strict ) { if ( strict === void 0 ) { strict = true ; } if ( ! strict || ! / \S+\.[^\.]\S+ / . test ( val ) ) return chek_1 . camelcase ( val ) ; return val ; } 
function expandArgs ( val , match , safe ) { if ( Array . isArray ( val ) ) return val . slice ( 0 ) ; 
function expandOptions ( val , allowValues ) { val = val || [ ] ; var trail = [ ] ; return val . reduce ( function ( a , c ) { if ( ! constants_1 . FLAG_SHORT . test ( c ) || constants_1 . FLAG_COUNT . test ( c ) ) return a . concat ( c ) ; var split = c . slice ( 1 ) . split ( '' ) . map ( function ( n ) { return "-" + n ; } ) ; if ( allowValues ) return a . concat ( split ) ; trail = trail . concat ( split ) ; 
function isNegateFlag ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; return ( new RegExp ( '^--' + negate ) ) . test ( val ) ; } 
function isArgVariadic ( val , variadic ) { variadic = variadic || constants_1 . VARIADIC_CHAR ; return isArg ( val ) && ( val . endsWith ( variadic + ']' ) || val . endsWith ( variadic + '>' ) ) ; } 
function isArgVariadicRequired ( val , variadic ) { variadic = variadic || constants_1 . VARIADIC_CHAR ; return isArgRequired ( val ) && val . endsWith ( variadic + '>' ) ; } 
function stripFlag ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; return ( val || '' ) . replace ( new RegExp ( '^--?(' + negate + ')?' ) , '' ) ; } 
function stripNegate ( val , negate ) { negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; var exp = new RegExp ( '^' + negate ) ; return val . replace ( exp , '' ) ; } 
function stripVariadic ( val , variadic ) { variadic = escape ( variadic || constants_1 . VARIADIC_CHAR ) ; var exp = new RegExp ( variadic + '$' ) ; return val . replace ( exp , '' ) ; } 
function stripTokens ( val , negate , variadic ) { variadic = escape ( variadic || constants_1 . VARIADIC_CHAR ) ; negate = escape ( negate || constants_1 . NEGATE_CHAR ) ; var argExp = new RegExp ( [ '<' , '>' , '\\[' , '\\]' ] . join ( '|' ) , 'g' ) ; var noExp = new RegExp ( '^' + negate ) ; var variExp = new RegExp ( variadic + '$' ) ; return expandArgs ( val ) . map ( function ( v ) { v = v . replace ( constants_1 . FLAG_EXP , '' ) . replace ( noExp , '' ) . replace ( argExp , '' ) . replace ( variExp , '' ) ; return v ; } ) . join ( ' ' ) ; } 
function ( item ) { if ( ! item ) { return ; } var me = this , sprite = item . sprite , opts = Ext . merge ( { } , me . highlightCfg , me . highlight ) , surface = me . chart . surface , animate = me . chart . animate , p , from , to , pi ; if ( ! me . highlight || ! sprite || sprite . _highlighted ) { return ; } if ( sprite . _anim ) { sprite . _anim . paused = true ; } sprite . _highlighted = true ; if ( ! sprite . _defaults ) { sprite . _defaults = Ext . apply ( { } , sprite . attr ) ; from = { } ; to = { } ; 
function ( ) { if ( ! this . highlight || ! this . items ) { return ; } var me = this , items = me . items , len = items . length , opts = Ext . merge ( { } , me . highlightCfg , me . highlight ) , animate = me . chart . animate , i = 0 , obj , p , sprite ; for ( ; i < len ; i ++ ) { if ( ! items [ i ] ) { continue ; } sprite = items [ i ] . sprite ; if ( sprite && sprite . _highlighted ) { if ( sprite . _anim ) { sprite . _anim . paused = true ; } obj = { } ; for ( p in opts ) { if ( Ext . isObject ( sprite . _defaults [ p ] ) ) { obj [ p ] = Ext . apply ( { } , sprite . _defaults [ p ] ) ; } else { obj [ p ] = sprite . _defaults [ p ] ; } } if ( animate ) { 
function ( component , selector ) { if ( ! selector ) { return true ; } var selectors = selector . split ( ',' ) , length = selectors . length , i = 0 , query ; for ( ; i < length ; i ++ ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . cache [ selector ] || ( this . cache [ selector ] = this . parse ( selector ) ) ; if ( query . is ( component ) ) { return true ; } } return false ; } 
async function getVinylFile ( filePath , options ) { if ( ! isString ( filePath ) ) { if ( ! options . lookup . has ( filePath . path ) ) options . lookup . set ( filePath . path , filePath ) ; return filePath ; } if ( options . lookup . has ( filePath ) ) return options . lookup . get ( filePath ) ; return createVinylFile ( filePath , options ) ; } 
async function createVinylFile ( filePath , options ) { options . lookup . set ( filePath , vinylFile . read ( filePath , options ) ) ; if ( options . debugVcjd ) debug ( ` ${ filePath } ` ) ; return await options . lookup . get ( filePath ) ; } 
function getVinylFiles ( files , options ) { return Promise . all ( files . map ( file => getVinylFile ( file , options ) ) ) ; } 
async function resolveModule ( moduleId , options , root = options . base ) { if ( options . lookup . has ( moduleId ) ) return options . lookup . get ( moduleId ) ; const absolutePath = await options . resolver ( moduleId , root ) ; if ( options . mapper . hasOwnProperty ( absolutePath ) ) return options . mapper [ absolutePath ] ; if ( options . lookup . has ( absolutePath ) ) return options . lookup . get ( absolutePath ) ; return absolutePath ; } 
function getRequires ( file , options ) { return [ ... fileRequires ( file , options ) ] . map ( async ( moduleId ) => { if ( options . internalOnly && ( moduleId . charAt ( 0 ) !== '.' ) && ( moduleId . charAt ( 0 ) !== '/' ) ) { if ( options . mapper [ moduleId ] !== true ) return undefined ; } if ( options . mapper . hasOwnProperty ( moduleId ) && ! ( options . internalOnly && ( options . mapper [ moduleId ] === true ) ) ) { if ( options . mapper [ moduleId ] ) return resolveModule ( options . mapper [ moduleId ] , options ) ; return undefined ; } return resolveModule ( moduleId , options , path . dirname ( file . path ) ) ; } ) ; } 
function filterDuplicateFiles ( ) { const lookup = new Map ( ) ; return value => { if ( lookup . has ( value ) ) return false ; return lookup . set ( value , true ) ; } } 
async function getFiles ( paths , options ) { const files = ( await getVinylFiles ( paths , options ) ) . map ( file => [ file , ... getRequires ( file , options ) ] ) ; return ( await promiseFlatten ( files ) ) . filter ( file => file ) . filter ( filterDuplicateFiles ( ) ) ; } 
async function getAllFiles ( file , options ) { let files = await getFiles ( [ file ] , options ) ; while ( hasUnloaded ( files ) ) files = await getFiles ( files , options ) ; return files ; } 
function srcFilePusher ( options ) { return through . obj ( function ( file , encoding , done ) { getAllFiles ( file , options ) . then ( files => { files . forEach ( file => this . push ( file ) ) ; done ( ) ; } , err => { } ) ; } ) } 
function createResolver ( options ) { return ( moduleId , base ) => new Promise ( ( resolve , reject ) => { const resolver = new Resolver ( options . resolver ? options . resolver : { } ) ; resolver . resolve ( moduleId , base , ( err , absolutePath ) => { if ( err ) { if ( options . debugVcjd ) debug ( ` ${ moduleId } \n \t ${ base } ` ) ; return reject ( err ) ; } if ( options . debugVcjd ) debug ( ` ${ moduleId } \n \t ${ base } \n \t ${ base } ` ) ; return resolve ( absolutePath ) ; } ) ; } ) } 
function parseOptions ( options = { } , vinylCjsDeps ) { const _options = Object . assign ( { gulp : vinylCjsDeps . gulp || require ( 'gulp' ) , base : options . cwd || process . cwd ( ) , cwd : options . base || process . cwd ( ) , internalOnly : false , debugVcjd : false } , options ) ; _options . mapper = Object . assign ( { } , options . mapper || { } ) ; _options . lookup = new Map ( options . lookup || [ ] ) ; _options . resolver = createResolver ( options ) ; return _options ; } 
function ( ed , cm , n ) { var dom = ed . dom , dir ; n = dom . getParent ( n , dom . isBlock ) ; if ( ! n ) { cm . setDisabled ( 'ltr' , 1 ) ; cm . setDisabled ( 'rtl' , 1 ) ; return ; } dir = dom . getAttrib ( n , 'dir' ) ; cm . setActive ( 'ltr' , dir == "ltr" ) ; cm . setDisabled ( 'ltr' , 0 ) ; cm . setActive ( 'rtl' , dir == "rtl" ) ; cm . setDisabled ( 'rtl' , 0 ) ; } 
function newEntry ( that ) { return O . log . todo ( ) ; O . findShard ( that . demand . ident , function ( err , shard ) { if ( err ) return that . endUpdate ( err ) ; shard . embryo ( that . demand . ident . id , that . demand . ident . kind , that . demand . dval , function ( err , entry ) { if ( err ) return that . endUpdate ( err ) ; that . setEntry ( entry ) ; that . fields . startEdit ( true ) ; return ; } ) ; return ; } ) ; } 
function ( ) { var me = this , prev = me . store . currentPage - 1 ; if ( prev > 0 ) { if ( me . fireEvent ( 'beforechange' , me , prev ) !== false ) { me . store . previousPage ( ) ; } } } 
function ( ) { var me = this , total = me . getPageData ( ) . pageCount , next = me . store . currentPage + 1 ; if ( next <= total ) { if ( me . fireEvent ( 'beforechange' , me , next ) !== false ) { me . store . nextPage ( ) ; } } } 
function ( ) { var me = this , last = me . getPageData ( ) . pageCount ; if ( me . fireEvent ( 'beforechange' , me , last ) !== false ) { me . store . loadPage ( last ) ; } } 
function ( ) { var me = this , current = me . store . currentPage ; if ( me . fireEvent ( 'beforechange' , me , current ) !== false ) { me . store . loadPage ( current ) ; } } 
function ( members ) { var member , name ; for ( name in members ) { if ( members . hasOwnProperty ( name ) ) { member = members [ name ] ; if ( typeof member == 'function' && ! member . $isClass && member !== Ext . emptyFn && member !== Ext . identityFn ) { member . $owner = this ; member . $name = name ; 
function ( fromClass , members ) { 
function ( members ) { var me = this , enumerables = Ext . enumerables , target = me . prototype , cloneFunction = Ext . Function . clone , name , index , member , statics , names , previous ; if ( arguments . length === 2 ) { name = members ; members = { } ; members [ name ] = arguments [ 1 ] ; enumerables = null ; } do { names = [ ] ; 
function ( args ) { var method ; 
function ( args ) { var method ; 
function ( name , mixinClass ) { var me = this , mixin = mixinClass . prototype , prototype = me . prototype , key , statics , i , ln , staticName , mixinValue , hookKey , hookFunction ; if ( typeof mixin . onClassMixedIn != 'undefined' ) { mixin . onClassMixedIn . call ( mixinClass , me ) ; } if ( ! prototype . hasOwnProperty ( 'mixins' ) ) { if ( 'mixins' in prototype ) { prototype . mixins = Ext . Object . chain ( prototype . mixins ) ; } else { prototype . mixins = { } ; } } for ( key in mixin ) { mixinValue = mixin [ key ] ; if ( key === 'mixins' ) { Ext . merge ( prototype . mixins , mixinValue ) ; } else if ( key === 'xhooks' ) { for ( hookKey in mixinValue ) { hookFunction = mixinValue [ hookKey ] ; 
function ( args ) { 
function ( config ) { var instanceConfig = config , configNameCache = Ext . Class . configNameCache , defaultConfig = new this . configClass ( ) , defaultConfigList = this . initConfigList , hasConfig = this . configMap , nameMap , i , ln , name , initializedName ; this . initConfig = Ext . emptyFn ; this . initialConfig = instanceConfig || { } ; this . config = config = ( instanceConfig ) ? Ext . merge ( defaultConfig , config ) : defaultConfig ; if ( instanceConfig ) { defaultConfigList = defaultConfigList . slice ( ) ; for ( name in instanceConfig ) { if ( hasConfig [ name ] ) { if ( instanceConfig [ name ] !== null ) { defaultConfigList . push ( name ) ; this [ configNameCache [ name ] . initialized ] = false ; } } } } for ( i = 0 , ln = defaultConfigList . length ; i < ln ; i ++ ) { name = defaultConfigList [ i ] ; nameMap = configNameCache [ name ] ; initializedName = nameMap . initialized ; if ( ! this [ initializedName ] ) { this [ initializedName ] = true ; this [ nameMap . set ] . call ( this , config [ name ] ) ; } } return this ; } 
function getOptions ( opts ) { opts = opts || { } ; 
function getPlugins ( opts ) { var batterRootDir = __dirname . replace ( delim + 'lib' , '' ) ; var batterTasks = { rootDir : batterRootDir } ; var currentProject = { rootDir : opts . rootDir } ; var plugins = opts . plugins || [ ] ; 
function whip ( gulp , taste , opts ) { opts = getOptions ( opts ) ; opts . taste = taste ; var tasks = _ . extend ( { } , opts . tasksets ) ; 
function parse_arguments ( argv ) { var parsed = { } ; var current = false ; var name = false ; var unrecognized = false ; var have_action = false ; var is_global = false ; var name_format , option ; var i , j ; for ( i = 3 , len = argv . length ; i < len ; i ++ ) { 
function ( stdout ) { var files = { } , i = 0 , j = 0 , n = 0 , c , fName , sz , formats = [ [ 0 , 0 ] ] stdout = stdout . split ( '\n' ) while ( stdout [ i ] !== null && stdout [ i ] . substr ( 0 , 7 ) != '-------' ) { i ++ ; } while ( stdout [ i ] && j < stdout [ i ] . length ) { c = stdout [ i ] . charAt ( j ) if ( c != '-' ) { n ++ formats [ n ] = [ j + 1 , 0 ] } else { formats [ n ] [ 1 ] ++ } j ++ ; } i ++ n = pathName . split ( '/' ) . length - 1 while ( stdout [ i ] && stdout [ i ] . substr ( 0 , 7 ) != '-------' ) { fName = stdout [ i ] . substr ( formats [ 4 ] [ 0 ] ) . trim ( ) . split ( '/' ) if ( fName [ n ] && ! files [ fName [ n ] ] ) { c = stdout [ i ] . substr ( formats [ 1 ] [ 0 ] , formats [ 1 ] [ 1 ] ) . trim ( ) sz = parseInt ( stdout [ i ] . substr ( formats [ 2 ] [ 0 ] , formats [ 2 ] [ 1 ] ) . trim ( ) ) if ( c . charAt ( 0 ) != 'D' && n == ( fName . length - 1 ) ) { 
function get ( url , onSuccess , onFailure ) { http ( Method . GET , url , { } , onSuccess , onFailure ) ; } 
function post ( url , data , onSuccess , onFailure ) { http ( Method . POST , url , data , onSuccess , onFailure ) ; } 
function http ( method , url , data , onSuccess , onFailure ) { var qs = [ ] , xhr ; if ( Util . ENV . Node . JS ) { xhr = require ( './xhr' ) . create ( ) ; } else if ( 'undefined' != typeof XDomainRequest ) { xhr = new XDomainRequest ( ) ; xdrs . push ( xhr ) ; } else xhr = new XMLHttpRequest ( ) ; xhr . onload = function ( ) { try { var resp = JSON . parse ( xhr . responseText ) ; if ( 'reason' in resp ) throw new Error ( resp [ 'reason' ] ) ; if ( 'status' in xhr && 200 != xhr . status ) throw new Error ( xhr . statusText ) ; onSuccess ( resp ) ; } catch ( error ) { onFailure ( error , xhr . status ) ; } } ; xhr . onprogress = function ( ) { 
function ConsoleLogger ( ) { this . _l = Util . ILogger . Level . Error ; this . _c = 'undefined' != typeof console ? console : undefined ; } 
function ArrayStream ( arr , options ) { var self = this ; this . _reading = false ; this . _closing = false ; this . _index = 0 ; options = options || { } ; this . _duplex = options . duplex || false ; this . set ( arr ) ; Duplex . call ( this , { objectMode : true , highWaterMark : options . highWaterMark || Math . pow ( 2 , 10 ) } ) ; } 
function ( dir , htm , callback ) { var recur = function ( str ) { return s = str . replace ( / \{\{include[\s]{1,}[\'\"]([\w\.\/]{1,})[\'\"]\}\} / gi , function ( p1 , path ) { if ( fs . existsSync ( dir + path ) ) { return recur ( fs . readFileSync ( dir + path , 'utf8' ) ) ; } return "" ; } ) } callback ( recur ( htm ) ) } 
function ( module , method ) { var all = { urlparams : [ ] } for ( var i = 2 ; i < u . length ; i ++ ) all . urlparams . push ( decodeURIComponent ( u [ i ] ) ) ; req . cookies = { } req . headers . cookie && req . headers . cookie . split ( ';' ) . forEach ( function ( cookie ) { var parts = cookie . split ( '=' ) , key = parts [ 0 ] . trim ( ) , val = decodeURIComponent ( ( parts [ 1 ] || '' ) . trim ( ) ) ; all [ key ] = val ; req . cookies [ key ] = val } ) ; if ( url . query != null ) for ( var i in url . query ) all [ i ] = url . query [ i ] if ( post != null ) for ( var i in post ) all [ i ] = post [ i ] all . response = res all . request = req all . _query = url . query if ( me . config . LOCALE && ! all . locale ) { all . locale = req . url . substr ( 1 , 2 ) if ( ! me . config . LOCALE [ all . locale ] ) delete all . locale } 
function openUid ( dataDir , cb ) { var fn = dataDir + '/minnow_data/server.uid' exists ( fn , function ( exists ) { if ( exists ) { fs . readFile ( fn , 'utf8' , function ( err , uid ) { if ( err ) throw err ; cb ( uid ) } ) } else { var uid = seedrandom . uid ( ) fs . writeFileSync ( fn , uid , 'utf8' ) ; cb ( uid ) } } ) } 
function maintainEditSequence ( up , addEditCb ) { if ( currentSyncId !== up . syncId ) { 
function ( ed , cm , n ) { var ed = this . editor ; if ( ed . getParam ( 'save_enablewhendirty' ) ) { cm . setDisabled ( 'save' , ! ed . isDirty ( ) ) ; cm . setDisabled ( 'cancel' , ! ed . isDirty ( ) ) ; } } 
function ( ) { var ed = this . editor , formObj , os , i , elementId ; formObj = tinymce . DOM . get ( ed . id ) . form || tinymce . DOM . getParent ( ed . id , 'form' ) ; if ( ed . getParam ( "save_enablewhendirty" ) && ! ed . isDirty ( ) ) return ; tinyMCE . triggerSave ( ) ; // Use callback instead if ( os = ed . getParam ( "save_onsavecallback" ) ) { if ( ed . execCallback ( 'save_onsavecallback' , ed ) ) { ed . startContent = tinymce . trim ( ed . getContent ( { format : 'raw' } ) ) ; ed . nodeChanged ( ) ; } return ; } if ( formObj ) { ed . isNotDirty = true ; if ( formObj . onsubmit == null || formObj . onsubmit ( ) != false ) formObj . submit ( ) ; ed . nodeChanged ( ) ; } else ed . windowManager . alert ( "Error: No form element found." ) ; } 
function ( config ) { var me = this , surface , sprites , tipSurface ; if ( config . tips ) { me . tipTimeout = null ; me . tipConfig = Ext . apply ( { } , config . tips , { renderer : Ext . emptyFn , constrainPosition : true , autoHide : true } ) ; me . tooltip = new Ext . tip . ToolTip ( me . tipConfig ) ; me . chart . surface . on ( 'mousemove' , me . tooltip . onMouseMove , me . tooltip ) ; me . chart . surface . on ( 'mouseleave' , function ( ) { me . hideTip ( ) ; } ) ; if ( me . tipConfig . surface ) { 
function start ( ) { var Barefoot = require ( '../' ) ( ) , self = this , originalRender = this . render , originalNavigate = this . navigate ; 
function render ( view ) { if ( ! _ . isUndefined ( this . currentView ) ) { this . currentView . close ( ) ; } this . currentView = view ; view . render ( ) ; } 
function ( request ) { var me = this , requests = me . requests , key ; if ( request ) { if ( ! request . id ) { request = requests [ request ] ; } me . handleAbort ( request ) ; } else { for ( key in requests ) { if ( requests . hasOwnProperty ( key ) ) { me . abort ( requests [ key ] ) ; } } } } 
function ( result , request ) { var success = true ; if ( request . timeout ) { clearTimeout ( request . timeout ) ; } delete this [ request . callbackName ] ; delete this . requests [ request . id ] ; this . cleanupErrorHandling ( request ) ; Ext . fly ( request . script ) . remove ( ) ; if ( request . errorType ) { success = false ; Ext . callback ( request . failure , request . scope , [ request . errorType ] ) ; } else { Ext . callback ( request . success , request . scope , [ result ] ) ; } Ext . callback ( request . callback , request . scope , [ success , result , request . errorType ] ) ; Ext . EventManager . idleEvent . fire ( ) ; } 
function ( url , params , options ) { var script = document . createElement ( 'script' ) ; script . setAttribute ( "src" , Ext . urlAppend ( url , Ext . Object . toQueryString ( params ) ) ) ; script . setAttribute ( "async" , true ) ; script . setAttribute ( "type" , "text/javascript" ) ; return script ; } 
function ( response ) { var data , error ; try { data = Ext . decode ( response . responseText ) ; return this . readRecords ( data ) ; } catch ( ex ) { error = new Ext . data . ResultSet ( { total : 0 , count : 0 , records : [ ] , success : false , message : ex . message } ) ; this . fireEvent ( 'exception' , this , response , error ) ; Ext . Logger . warn ( 'Unable to parse the JSON returned by the server' ) ; return error ; } } 
function ( ) { var me = this , metaProp = me . metaProperty ; me . callParent ( arguments ) ; if ( me . root ) { me . getRoot = me . createAccessor ( me . root ) ; } else { me . getRoot = Ext . identityFn ; } if ( metaProp ) { me . getMeta = me . createAccessor ( metaProp ) ; } } 
function TableGrid ( table , dom , selection ) { var grid , startPos , endPos , selectedCell ; buildGrid ( ) ; selectedCell = dom . getParent ( selection . getStart ( ) , 'th,td' ) ; if ( selectedCell ) { startPos = getPos ( selectedCell ) ; endPos = findEndPos ( ) ; selectedCell = getCell ( startPos . x , startPos . y ) ; } function cloneNode ( node , children ) { node = node . cloneNode ( children ) ; node . removeAttribute ( 'id' ) ; return node ; } function buildGrid ( ) { var startY = 0 ; grid = [ ] ; each ( [ 'thead' , 'tbody' , 'tfoot' ] , function ( part ) { var rows = dom . select ( '> ' + part + ' tr' , table ) ; each ( rows , function ( tr , y ) { y += startY ; each ( dom . select ( '> td, > th' , tr ) , function ( td , x ) { var x2 , y2 , rowspan , colspan ; 
function createTableGrid ( node ) { var selection = ed . selection , tblElm = ed . dom . getParent ( node || selection . getNode ( ) , 'table' ) ; if ( tblElm ) return new TableGrid ( tblElm , ed . dom , selection ) ; } 
function fixTableCellSelection ( ed ) { if ( ! tinymce . isWebKit ) return ; var rng = ed . selection . getRng ( ) ; var n = ed . selection . getNode ( ) ; var currentCell = ed . dom . getParent ( rng . startContainer , 'TD,TH' ) ; if ( ! tableCellSelected ( ed , rng , n , currentCell ) ) return ; if ( ! currentCell ) { currentCell = n ; } 
function fixTableCaretPos ( ) { var last ; 
function CLIProgress ( text , settings ) { var progress = this ; progress . settings = { text : '{{current}} / {{max}} [{{bar}}] {{percent}}%' , current : 0 , max : 100 , stream : process . stderr , render : function ( line ) { progress . settings . stream . cursorTo ( 0 ) ; progress . settings . stream . clearLine ( 1 ) ; progress . settings . stream . write ( line ) ; } , clear : function ( ) { progress . settings . stream . clearLine ( 0 ) ; progress . settings . stream . cursorTo ( 0 ) ; } , width : windowSize . width , completeChar : '=' , incompleteChar : ' ' , percent : function ( ) { var pText = Math . round ( progress . settings . current / progress . settings . max * 100 ) . toString ( ) ; var strLen = stringLength ( pText ) ; if ( strLen > 3 ) return pText ; * Return the output that will be sent to the output stream * return {string} The raw console-suitable output */ progress . format = function ( ) { var text = mustache . render ( progress . settings . text , progress . settings ) ; * Holder for the throttle timeout handle * This will be the setTimeout() response if we are throttling * @var {Object} */ progress . throttleHandle ; progress . update = function ( val ) { progress . set ( val ) ; if ( progress . settings . throttle && progress . settings . throttleSync ) { * The timestamp in milliseconds of the last update event * This is used when employing the synchronous throttling method * @var {date} */ progress . lastUpdate ; progress . updateNow = function ( ) { progress . lastUpdate = Date . now ( ) ; progress . settings . render ( progress . format ( ) ) ; clearTimeout ( progress . throttleHandle ) ; progress . throttleHandle = null ; } ; progress . remove = function ( ) { clearTimeout ( progress . throttleHandle ) ; * Set one or more options or tokens * NOTE: Unlike .set() this function DOES NOT refresh the progress bar * @params {Object|number} Either set a number of properties or the 'current' value if passed a number * @return {Object} This object instance * @see set() */ progress . set = function ( val ) { if ( ! val ) return ; if ( typeof val == 'number' ) { progress . settings . current = val ; } else { for ( var k in val ) { progress . settings [ k ] = val [ k ] ; } if ( val . text ) { 
async function request ( url , options ) { if ( ! options ) { if ( isPlainObject ( url ) ) { options = url url = null } else { options = { url } } } if ( ! isPlainObject ( options ) ) { throw new ParameterException ( 'Options must be an object!' ) } if ( isString ( url ) ) { options . url = url } if ( ! isString ( options . url ) ) { throw new ParameterException ( 'URL is required!' ) } let { interceptors , ... req } = options interceptors = intercept ( interceptors ) req = await parseReq ( req ) req = await iterateInterceptors ( req , interceptors . request ) const res = await fetch ( req . url , req ) let body = await getBody ( res ) body = await iterateInterceptors ( body , interceptors . response ) if ( res . status >= 200 && res . status < 400 ) { return body } throw body } 
function Context ( tasty , client ) { const config = tasty . config , flaws = client . flaws , server = tasty . server , id = client . id ; const tool = new Tool ( id , server , config ) ; const noop = function noop ( ) { } ; const now = function now ( ) { if ( arguments . length ) { enqueue . apply ( null , Array . prototype . map . call ( arguments , ( item ) => { if ( ! instance ( item , Function ) ) { throw new TypeError ( 'pass functions to now()' ) ; } return item ; } ) ) ; } else { const queue = now . queue ; now . queue = [ ] ; return queue . reduce ( ( chain , item ) => chain . then ( item ) , Promise . resolve ( ) ) ; } } ; now . noop = noop ; now . queue = [ ] ; const enqueue = function ( ) { config . slow && now . queue . push ( ( ) => new Promise ( ( resolve ) => setTimeout ( resolve , config . slow ) ) ) ; now . queue . push . apply ( now . queue , arguments ) ; } // NOTE support for get/set/pop/push/during/until. const wrap = ( handle ) => { const wrapped = function ( ) { return new Promise ( ( resolve ) => enqueue ( ( ) => { const result = handle . apply ( id , arguments ) ; if ( ! instance ( result , Promise ) ) { throw new Error ( ` ${ handle . name } ` ) ; } return result . then ( resolve , ( error ) => { resolve ( error ) ; throw error ; } ) ; } ) ) ; } ; wrapped . handle = handle ; return wrapped ; } ; const inject = function inject ( from , to , wrapped ) { Object . keys ( from ) . forEach ( ( name ) => { to [ name ] = wrapped ? util . rename ( wrap ( from [ name ] ) , name ) : from [ name ] ; } ) ; } ; const api = function api ( scope ) { if ( ! scope ) { throw new TypeError ( 'api, scope is required' ) ; } // TODO filter. inject ( tool , scope , true ) ; inject ( thing , scope , false ) ; scope . noop = noop ; scope . now = now ; config . addon && config . addon . split ( ',' ) . sort ( ( a , b ) => a . localeCompare ( b ) ) . forEach ( ( name ) => { const module = require ( util . resolve ( name ) ) ; scope [ name ] = module ; // NOTE support for assterion/expectation libraries. if ( module . assert ) { scope . assert = module . assert ; } if ( module . expect ) { scope . expect = module . expect ; } // TODO support should(); // WORKAROUND for chai plugins. / ^chai- / . test ( name ) && scope . chai && scope . chai . use ( module ) ; } ) ; return scope ; } ; inject ( tool , now , false ) ; const globals = { console : server . logger , tasty : { api : api , config : config , flaws : flaws , now : now , thing : thing , tool : tool , wrap : wrap } } ; config . globals && api ( globals ) ; return { globals : globals } ; } 
function now ( ) { if ( arguments . length ) { enqueue . apply ( null , Array . prototype . map . call ( arguments , ( item ) => { if ( ! instance ( item , Function ) ) { throw new TypeError ( 'pass functions to now()' ) ; } return item ; } ) ) ; } else { const queue = now . queue ; now . queue = [ ] ; return queue . reduce ( ( chain , item ) => chain . then ( item ) , Promise . resolve ( ) ) ; } } 
function api ( scope ) { if ( ! scope ) { throw new TypeError ( 'api, scope is required' ) ; } // TODO filter. inject ( tool , scope , true ) ; inject ( thing , scope , false ) ; scope . noop = noop ; scope . now = now ; config . addon && config . addon . split ( ',' ) . sort ( ( a , b ) => a . localeCompare ( b ) ) . forEach ( ( name ) => { const module = require ( util . resolve ( name ) ) ; scope [ name ] = module ; // NOTE support for assterion/expectation libraries. if ( module . assert ) { scope . assert = module . assert ; } if ( module . expect ) { scope . expect = module . expect ; } // TODO support should(); // WORKAROUND for chai plugins. / ^chai- / . test ( name ) && scope . chai && scope . chai . use ( module ) ; } ) ; return scope ; } 
function ( ) { * @event processcolumns * Fires when the configured (or **reconfigured**) column set is split into two depending on the {@link Ext.grid.column.Column#locked locked} flag. * @param {Ext.grid.column.Column[]} lockedColumns The locked columns. * @param {Ext.grid.column.Column[]} normalColumns The normal columns. */ 'processcolumns' , 'lockcolumn' , 'unlockcolumn' ) ; me . addStateEvents ( [ 'lockcolumn' , 'unlockcolumn' ] ) ; columns = me . processColumns ( me . columns ) ; * @event filterchange * @inheritdoc Ext.data.Store#filterchange */ 'filterchange' ] ) ; me . layout = { type : 'hbox' , align : 'stretch' } ; } 
function ( column ) { var result = column . width || 0 , subcols , len , i ; 
function ( ) { var me = this , lockedView = me . lockedGrid . getView ( ) , lockedViewEl = lockedView . el . dom , spacerHeight = ( me . normalGrid . headerCt . tooNarrow ? Ext . getScrollbarSize ( ) . height : 0 ) ; 
function ( ) { var me = this ; me . lockedGrid . headerCt . getMenuItems = me . getMenuItems ( me . lockedGrid . headerCt . getMenuItems , true ) ; me . normalGrid . headerCt . getMenuItems = me . getMenuItems ( me . normalGrid . headerCt . getMenuItems , false ) ; me . lockedGrid . headerCt . showMenuBy = Ext . Function . createInterceptor ( me . lockedGrid . headerCt . showMenuBy , me . showMenuBy ) ; me . normalGrid . headerCt . showMenuBy = Ext . Function . createInterceptor ( me . normalGrid . headerCt . showMenuBy , me . showMenuBy ) ; } 
function ( activeHd , toIdx ) { var me = this , normalGrid = me . normalGrid , lockedGrid = me . lockedGrid , normalHCt = normalGrid . headerCt , lockedHCt = lockedGrid . headerCt , refreshFlags , ownerCt ; activeHd = activeHd || normalHCt . getMenu ( ) . activeHeader ; ownerCt = activeHd . ownerCt ; 
function ( store , columns ) { var me = this , oldStore = me . store , lockedGrid = me . lockedGrid , normalGrid = me . normalGrid ; Ext . suspendLayouts ( ) ; if ( columns ) { lockedGrid . headerCt . removeAll ( ) ; normalGrid . headerCt . removeAll ( ) ; columns = me . processColumns ( columns ) ; 
function writeLong ( buffer , offset , value ) { var first = value , second = value >= 0 ? Math . floor ( value / 2147483648 ) : Math . ceil ( value / 2147483648 ) ; var sign = first > 0 ? 1 : - 1 ; first = ( sign * first ) % 2147483648 ; first = sign * first ; 
function defaultTransformer ( ... args ) { try { let [ record , ... rest ] = args try { record = typeof record === 'string' ? JSON . parse ( record ) : record } catch ( err ) { return { type : 'bunyan' , record : { err : new Error ( 'Could not parse message.' ) } } } return { type : 'bunyan' , record } } catch ( err ) { return { type : 'bunyan' , record : { err : new Error ( 'Internal error occurred.' ) } } } } 
function print_rr ( objRef , strObjRef ) { converts strObjRef to an Array of the parts of the object i,e ["window", "document", "childNodes", "[", "0", "]"] */ this . parseStrObjRef = function ( ) { this.populateHeader = function () { var strRef = ""; for (var x =0;x<this.arrStrObjRef.length;x++) { if ((this.arrStrObjRef[x].match(/\[/g)) || (this.arrStrObjRef[x].match(/\]/g))) { this.header.appendChild(document.createTextNode(this.arrStrObjRef[x])); if (this.arrStrObjRef[x] == "[") { strRef += "["; } } else { var a = document.createElement('a'); a.href = "javascript:void(0);"; this.applyStyles (styleObj.a , a); a.appendChild(document.createTextNode(this.arrStrObjRef[x])); if (this.arrStrObjRef[x-1] && this.arrStrObjRef[x-1] == "]" && x != (this.arrStrObjRef.length -1)) { this.header.appendChild(document.createTextNode(".")); strRef += "."; } strRef += this.arrStrObjRef[x]; if (this.arrStrObjRef[x+1] == "]") { strRef += "]"; } a.onclick = clickMe(this, strRef); this.header.appendChild(a); if (this.arrStrObjRef[x+1] && this.arrStrObjRef[x+1] != "]" && this.arrStrObjRef[x+1] != "[") { this.header.appendChild(document.createTextNode(".")); strRef += "."; } } } try { if (this.header.lastChild.value == ".") { this.header.removeChild(this.header.lastChild); } } catch (e){} }; */ if ((this.arrStrObjRef[x].match(/\[/g))) { if (this.arrStrObjRef[x] == "[") { strRef += "["; } } else { this.applyStyles (styleObj.a , a); if (this.arrStrObjRef[x-1] && this.arrStrObjRef[x-1] == "]" && x != (this.arrStrObjRef.length -1)) { } strRef += this.arrStrObjRef[x]; if (this.arrStrObjRef[x] == "]") { if (this.arrStrObjRef[x+1] && this.arrStrObjRef[x+1] != "]" && this.arrStrObjRef[x+1] != "[") { this.header.appendChild(document.createTextNode(".")); strRef += "."; } } if (this.arrStrObjRef[x] != "]") { a.onclick = clickMe(this, strRef); a.href = "javascript:void(0);"; } this.header.appendChild(a); if (this.arrStrObjRef[x+1] && this.arrStrObjRef[x+1] != "]" && this.arrStrObjRef[x+1] != "[") { this.header.appendChild(document.createTextNode(".")); strRef += "."; } } */ This is the main function to populate the dom */ this . populateBody = function ( ) { if (properties[prop].name.match(/[^a-zA-Z_\-]/g)) { a.onclick = clickMe(print_r, print_r.strObjRef + "['" + properties[prop].name + "']"); } else { a.onclick = clickMe(print_r, print_r.strObjRef + "." + properties[prop].name); } */ } else { try { var test = eval ( print_r . strObjRef + "." + properties [ prop ] . name ) ; a . onclick = clickMe ( print_r , print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; } catch ( e ) { try { var test = eval ( print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; a . onclick = clickMe ( print_r , print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; } catch ( e ) { a . onclick = clickMe ( print_r , print_r . strObjRef + "['" + properties [ prop ] . name + "']" ) ; } } } } z . appendChild ( a ) ; tdname . appendChild ( z ) ; Since I could not get a css file to work consistently accross browsers in the Bookmarklet edition, I went with this approach so I would not have so many dom.style.***** = "50px"; lines. And also to make it easy to customize */ this . applyStyles = function ( styleObject , domObject ) { for ( prop in styleObject ) { try { domObject . style [ prop ] = styleObject [ prop ] ; } catch ( e ) { } } } ; 
function getString ( ref ) { try { if ( ref ) { try { return ref ; } catch ( e ) { return ref . toString ( ) ; } } else { try { return ref . toString ( ) ; } catch ( e ) { return "undefined" ; } } } catch ( e ) { 
function writeTable ( properties , tbodyprops , name , print_r ) { if (properties[prop].name.match(/[^a-zA-Z_\-]/g)) { a.onclick = clickMe(print_r, print_r.strObjRef + "['" + properties[prop].name + "']"); } else { a.onclick = clickMe(print_r, print_r.strObjRef + "." + properties[prop].name); } */ } else { try { var test = eval ( print_r . strObjRef + "." + properties [ prop ] . name ) ; a . onclick = clickMe ( print_r , print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; } catch ( e ) { try { var test = eval ( print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; a . onclick = clickMe ( print_r , print_r . strObjRef + "[" + properties [ prop ] . name + "]" ) ; } catch ( e ) { a . onclick = clickMe ( print_r , print_r . strObjRef + "['" + properties [ prop ] . name + "']" ) ; } } } } z . appendChild ( a ) ; tdname . appendChild ( z ) ; 
function clickMe ( print_r , str ) { return ( function ( ) { print_r . objRef = eval ( str ) ; print_r . strObjRef = str ; print_r . refresh ( ) ; } ) ; } 
function arrSort ( a , b ) { var acomp = a [ 'name' ] . toString ( 10 ) ; var bcomp = b [ 'name' ] . toString ( 10 ) ; if ( ! isNaN ( Number ( acomp ) ) ) { acomp = Number ( acomp ) ; } if ( ! isNaN ( Number ( bcomp ) ) ) { bcomp = Number ( bcomp ) ; } if ( acomp < bcomp ) { return - 1 ; } if ( acomp > bcomp ) { return 1 ; } return 0 ; } 
function run ( that , config ) { 
function ( filter , index , list ) { 
function ( ed , url ) { // Register the command so that it can be invoked by using tinyMCE.activeEditor.execCommand('mceExample'); ed . addCommand ( 'mceExample' , function ( ) { ed . windowManager . open ( { file : url + '/dialog.htm' , width : 320 + parseInt ( ed . getLang ( 'example.delta_width' , 0 ) ) , height : 120 + parseInt ( ed . getLang ( 'example.delta_height' , 0 ) ) , inline : 1 } , { plugin_url : url , // Plugin absolute URL some_custom_arg : 'custom arg' // Custom argument } ) ; } ) ; // Register example button ed . addButton ( 'example' , { title : 'example.desc' , cmd : 'mceExample' , image : url + '/img/example.gif' } ) ; // Add a node change handler, selects the button in the UI when a image is selected ed . onNodeChange . add ( function ( ed , cm , n ) { cm . setActive ( 'example' , n . nodeName == 'IMG' ) ; } ) ; } 
function getCurrentExpectedTypes ( type ) { var currentType ; var expectedType ; if ( type . name ) { currentType = type . name ; } else if ( type . expression ) { currentType = type . expression . name ; } expectedType = currentType && preferType [ currentType ] ; return { currentType : currentType , expectedType : expectedType } ; } 
function validateType ( jsdocNode , type ) { if ( ! type || ! canTypeBeValidated ( type . type ) ) { return ; } var typesToCheck = [ ] ; var elements = [ ] ; switch ( type . type ) { case 'TypeApplication' : 
function requireJsDoc ( node , isVirtual , paramsToCheck ) { var lines = sourceCode . lines ; var index = node . loc . start . line ; lines = lines . slice ( 0 , index ) ; var matches = lines . filter ( function ( line ) { return line . match ( / \/\*\* / gi ) ; } ) ; var lastIndex = lines . lastIndexOf ( matches [ matches . length - 1 ] ) ; var jsdocComment = findJSDocComment ( sourceCode . ast . comments , lastIndex ) ; if ( ! jsdocComment ) { report ( node ) ; return ; } checkJSDoc ( node , jsdocComment , isVirtual , paramsToCheck ) ; } 
function SelectionType ( typeSpec ) { if ( ! Array . isArray ( typeSpec . data ) && typeof typeSpec . data !== 'function' ) { throw new Error ( 'instances of SelectionType need typeSpec.data to be an array or function that returns an array:' + JSON . stringify ( typeSpec ) ) ; } Object . keys ( typeSpec ) . forEach ( function ( key ) { this [ key ] = typeSpec [ key ] ; } , this ) ; } 
function DeferredType ( typeSpec ) { if ( typeof typeSpec . defer !== 'function' ) { throw new Error ( 'Instances of DeferredType need typeSpec.defer to be a function that returns a type' ) ; } Object . keys ( typeSpec ) . forEach ( function ( key ) { this [ key ] = typeSpec [ key ] ; } , this ) ; } 
function ArrayType ( typeSpec ) { if ( typeSpec instanceof Type ) { this . subtype = typeSpec ; } else if ( typeof typeSpec === 'string' ) { this . subtype = types . getType ( typeSpec ) ; if ( this . subtype == null ) { throw new Error ( 'Unknown array subtype: ' + typeSpec ) ; } } else { throw new Error ( 'Can\' handle array subtype' ) ; } } 
function ( ) { var conversion = this . parse ( '' ) ; if ( lastSetting ) { var current = lastSetting . get ( ) ; if ( conversion . predictions . length === 0 ) { conversion . predictions . push ( current ) ; } else { 
function Hint ( status , message , start , end , predictions ) { this . status = status ; this . message = message ; if ( typeof start === 'number' ) { this . start = start ; this . end = end ; this . predictions = predictions ; } else { var arg = start ; this . start = arg . start ; this . end = arg . end ; this . predictions = arg . predictions ; } } 
function ConversionHint ( conversion , arg ) { this . status = conversion . status ; this . message = conversion . message ; if ( arg ) { this . start = arg . start ; this . end = arg . end ; } else { this . start = 0 ; this . end = 0 ; } this . predictions = conversion . predictions ; } 
function Argument ( emitter , text , start , end , prefix , suffix ) { this . emitter = emitter ; this . setText ( text ) ; this . start = start ; this . end = end ; this . prefix = prefix ; this . suffix = suffix ; } 
function ( following ) { if ( following . emitter != this . emitter ) { throw new Error ( 'Can\'t merge Arguments from different EventEmitters' ) ; } return new Argument ( this . emitter , this . text + this . suffix + following . prefix + following . text , this . start , following . end , this . prefix , following . suffix ) ; } 
function ( text ) { if ( text == null ) { throw new Error ( 'Illegal text for Argument: ' + text ) ; } var ev = { argument : this , oldText : this . text , text : text } ; this . text = text ; this . emitter . _dispatchEvent ( 'argumentChange' , ev ) ; } 
function Assignment ( param , requisition ) { this . param = param ; this . requisition = requisition ; this . setValue ( param . defaultValue ) ; } 
function ( ) { 
function ( position ) { if ( ! this . arg ) { return false ; } 
function ( command , arg ) { var docs = [ ] ; docs . push ( '<strong><tt> &gt; ' ) ; docs . push ( command . name ) ; if ( command . params && command . params . length > 0 ) { command . params . forEach ( function ( param ) { if ( param . defaultValue === undefined ) { docs . push ( ' [' + param . name + ']' ) ; } else { docs . push ( ' <em>[' + param . name + ']</em>' ) ; } } , this ) ; } docs . push ( '</tt></strong><br/>' ) ; docs . push ( command . description ? command . description : '(No description)' ) ; docs . push ( '<br/>' ) ; if ( command . params && command . params . length > 0 ) { docs . push ( '<ul>' ) ; command . params . forEach ( function ( param ) { docs . push ( '<li>' ) ; docs . push ( '<strong><tt>' + param . name + '</tt></strong>: ' ) ; docs . push ( param . description ? param . description : '(No description)' ) ; if ( param . defaultValue === undefined ) { docs . push ( ' <em>[Required]</em>' ) ; } else if ( param . defaultValue === null ) { docs . push ( ' <em>[Optional]</em>' ) ; } else { docs . push ( ' <em>[Default: ' + param . defaultValue + ']</em>' ) ; } docs . push ( '</li>' ) ; } , this ) ; docs . push ( '</ul>' ) ; } return new Hint ( Status . VALID , docs . join ( '' ) , arg ) ; } 
function ( assignment ) { 
function ( nameOrNumber ) { var name = ( typeof nameOrNumber === 'string' ) ? nameOrNumber : Object . keys ( this . _assignments ) [ nameOrNumber ] ; return this . _assignments [ name ] ; } 
function ( ) { 
function ( ) { var args = { } ; this . getAssignments ( ) . forEach ( function ( assignment ) { args [ assignment . param . name ] = assignment . value ; } , this ) ; return args ; } 
function ( includeCommand ) { var args = [ ] ; if ( includeCommand === true ) { args . push ( this . commandAssignment ) ; } Object . keys ( this . _assignments ) . forEach ( function ( name ) { args . push ( this . getAssignment ( name ) ) ; } , this ) ; return args ; } 
function ( ) { var line = [ ] ; line . push ( this . commandAssignment . value . name ) ; Object . keys ( this . _assignments ) . forEach ( function ( name ) { var assignment = this . _assignments [ name ] ; var type = assignment . param . type ; 
function CliRequisition ( env , options ) { Requisition . call ( this , env ) ; if ( options && options . flags ) { this . flags = options . flags ; } } 
function CliView ( cli , env ) { cli . cliView = this ; this . cli = cli ; this . doc = document ; this . win = dom . getParentWindow ( this . doc ) ; this . env = env ; 
function ( ) { var input = this . element ; this . element . spellcheck = false ; this . output = this . doc . getElementById ( 'cockpitOutput' ) ; this . popupOutput = ( this . output == null ) ; if ( ! this . output ) { this . output = this . doc . createElement ( 'div' ) ; this . output . id = 'cockpitOutput' ; this . output . className = 'cptOutput' ; input . parentNode . insertBefore ( this . output , input . nextSibling ) ; var setMaxOutputHeight = function ( ) { this . output . style . maxHeight = this . outputHeight . get ( ) + 'px' ; } . bind ( this ) ; this . outputHeight . addEventListener ( 'change' , setMaxOutputHeight ) ; setMaxOutputHeight ( ) ; } this . completer = this . doc . createElement ( 'div' ) ; this . completer . className = 'cptCompletion VALID' ; this . completer . style . color = dom . computedStyle ( input , "color" ) ; this . completer . style . fontSize = dom . computedStyle ( input , "fontSize" ) ; this . completer . style . fontFamily = dom . computedStyle ( input , "fontFamily" ) ; this . completer . style . fontWeight = dom . computedStyle ( input , "fontWeight" ) ; this . completer . style . fontStyle = dom . computedStyle ( input , "fontStyle" ) ; input . parentNode . insertBefore ( this . completer , input . nextSibling ) ; 
function ( ) { 
function ( ) { var rect = this . element . getClientRects ( ) [ 0 ] ; this . completer . style . top = rect . top + 'px' ; var height = rect . bottom - rect . top ; this . completer . style . height = height + 'px' ; this . completer . style . lineHeight = height + 'px' ; this . completer . style . left = rect . left + 'px' ; var width = rect . right - rect . left ; this . completer . style . width = width + 'px' ; if ( this . hintDirection . get ( ) === 'below' ) { this . hinter . style . top = rect . bottom + 'px' ; this . hinter . style . bottom = 'auto' ; } else { this . hinter . style . top = 'auto' ; this . hinter . style . bottom = ( this . doc . documentElement . clientHeight - rect . top ) + 'px' ; } this . hinter . style . left = ( rect . left + 30 ) + 'px' ; this . hinter . style . maxWidth = ( width - 110 ) + 'px' ; if ( this . popupOutput ) { if ( this . outputDirection . get ( ) === 'below' ) { this . output . style . top = rect . bottom + 'px' ; this . output . style . bottom = 'auto' ; } else { this . output . style . top = 'auto' ; this . output . style . bottom = ( this . doc . documentElement . clientHeight - rect . top ) + 'px' ; } this . output . style . left = rect . left + 'px' ; this . output . style . width = ( width - 80 ) + 'px' ; } } 
function ( ev , hashId , keyCode ) { var stopEvent ; if ( keyCode === keys . TAB || keyCode === keys . UP || keyCode === keys . DOWN ) { stopEvent = true ; } else if ( hashId != 0 || keyCode != 0 ) { stopEvent = canon . execKeyCommand ( this . env , 'cli' , hashId , keyCode ) ; } stopEvent && event . stopEvent ( ev ) ; } 
function ( ev ) { var handled ; 
function ( ) { this . isUpdating = true ; var input = { typed : this . element . value , cursor : { start : dom . getSelectionStart ( this . element ) , end : dom . getSelectionEnd ( this . element . selectionEnd ) } } ; this . cli . update ( input ) ; var display = this . cli . getAssignmentAt ( input . cursor . start ) . getHint ( ) ; 
function ( scores ) { var completion = '' ; 
function ( ev ) { if ( this . isUpdating ) { return ; } var prefix = this . element . value . substring ( 0 , ev . argument . start ) ; var suffix = this . element . value . substring ( ev . argument . end ) ; var insert = typeof ev . text === 'string' ? ev . text : ev . text . name ; this . element . value = prefix + insert + suffix ; 
function imageUrl ( path ) { var dataUrl ; try { dataUrl = require ( 'text!cockpit/ui/' + path ) ; } catch ( e ) { } if ( dataUrl ) { return dataUrl ; } var filename = module . id . split ( '/' ) . pop ( ) + '.js' ; var imagePath ; if ( module . uri . substr ( - filename . length ) !== filename ) { console . error ( 'Can\'t work out path from module.uri/module.id' ) ; return path ; } if ( module . uri ) { var end = module . uri . length - filename . length - 1 ; return module . uri . substr ( 0 , end ) + "/" + path ; } return filename + path ; } 
function RequestView ( request , cliView ) { this . request = request ; this . cliView = cliView ; this . imageUrl = imageUrl ; 
function ( ev ) { this . cliView . cli . update ( { typed : this . request . typed , cursor : { start : 0 , end : 0 } } ) ; this . cliView . cli . exec ( ) ; } 
function ( member , clone , ref ) { ref . parentNode . insertBefore ( clone , ref ) ; data [ paramName ] = member ; self . processNode ( clone , data ) ; delete data [ paramName ] ; } 
function ( scope , member ) { self . scope . push ( scope ) ; try { if ( node . nodeName === 'LOOP' ) { for ( var i = 0 ; i < node . childNodes . length ; i ++ ) { var clone = node . childNodes [ i ] . cloneNode ( true ) ; processSingle ( member , clone , node ) ; } } else { var clone = node . cloneNode ( true ) ; clone . removeAttribute ( 'foreach' ) ; processSingle ( member , clone , node ) ; } } finally { self . scope . pop ( ) ; } } 
function string ( state ) { return [ { token : "string" , regex : '".*?"' } , { token : "string" , 
function ( data , hashId , key ) { 
function ( urlparam , parent , callback , auth ) { if ( ! parent . server . modelsAll ) parent . server . modelsAll = { } var config = parent . server . config var fn = urlparam . split ( '.' ) fn [ 0 ] = config . ADMIN_MODULES_DIR fn = fn . join ( "/" ) 
function ( mdl ) { callback ( mdl ) if ( ! config . DEBUG ) return ; 
function ( model , req ) { if ( ! model ) return { } var fields = { } , queryFieldSet if ( req ) { if ( req . fieldSet ) { queryFieldSet = { } try { queryFieldSet = JSON . parse ( req . fieldSet ) } catch ( e ) { queryFieldSet = null } } else if ( req . urlparams && req . urlparams [ 1 ] ) { queryFieldSet = { } var x = req . urlparams [ 1 ] . split ( ',' ) for ( var i = 0 ; i < x . length ; i ++ ) queryFieldSet [ x [ i ] ] = 1 } } for ( var i in model . fields ) if ( model . fields [ i ] && model . fields [ i ] . visable ) { if ( ! queryFieldSet || queryFieldSet [ model . fields [ i ] . name ] ) fields [ model . fields [ i ] . name ] = 1 } return fields ; } 
function createBackboneRouterWithPreInitialize ( ) { var MonkeyRouter = function ( options ) { if ( ! _ . isUndefined ( this . preInitialize ) ) { this . preInitialize ( options ) ; } return Backbone . Router . call ( this , options ) ; } ; _ . extend ( MonkeyRouter , Backbone . Router ) ; _ . extend ( MonkeyRouter . prototype , Backbone . Router . prototype ) ; return MonkeyRouter ; } 
function applyMixin ( backboneRouter , mixin ) { var Router = backboneRouter . extend ( { } ) ; _ . extend ( Router . prototype , mixin ) ; return Router ; } 
function ( grid ) { var me = this ; if ( grid . rendered ) { me . grid = grid ; grid . getView ( ) . on ( { render : function ( v ) { me . view = v ; Ext . ux . dd . CellFieldDropZone . superclass . constructor . call ( me , me . view . el ) ; } , single : true } ) ; } else { grid . on ( 'render' , me . init , me , { single : true } ) ; } } 
function ( target , dd , e , dragData ) { delete this . dropOK ; if ( ! target ) { return ; } 
function ( target , dd , e , dragData ) { if ( this . dropOK ) { var value = dragData . field . getValue ( ) ; target . record . set ( target . fieldName , value ) ; this . onCellDrop ( target . fieldName , value ) ; return true ; } } 
function typeFunc ( bindings ) { var v = paramFunc ( bindings ) if ( v !== undefined ) { var typeCode = s . objectState . getObjectType ( v ) return s . schema . _byCode [ typeCode ] . name } } 
function ( cssText , id ) { var ss , head = doc . getElementsByTagName ( "head" ) [ 0 ] , styleEl = doc . createElement ( "style" ) ; styleEl . setAttribute ( "type" , "text/css" ) ; if ( id ) { styleEl . setAttribute ( "id" , id ) ; } if ( Ext . isIE ) { head . appendChild ( styleEl ) ; ss = styleEl . styleSheet ; ss . cssText = cssText ; } else { try { styleEl . appendChild ( doc . createTextNode ( cssText ) ) ; } catch ( e ) { styleEl . cssText = cssText ; } head . appendChild ( styleEl ) ; ss = styleEl . styleSheet ? styleEl . styleSheet : ( styleEl . sheet || doc . styleSheets [ doc . styleSheets . length - 1 ] ) ; } CSS . cacheStyleSheet ( ss ) ; return ss ; } 
function ( id ) { var existing = doc . getElementById ( id ) ; if ( existing ) { existing . parentNode . removeChild ( existing ) ; } } 
function ( id , url ) { var ss ; CSS . removeStyleSheet ( id ) ; ss = doc . createElement ( "link" ) ; ss . setAttribute ( "rel" , "stylesheet" ) ; ss . setAttribute ( "type" , "text/css" ) ; ss . setAttribute ( "id" , id ) ; ss . setAttribute ( "href" , url ) ; doc . getElementsByTagName ( "head" ) [ 0 ] . appendChild ( ss ) ; } 
function ( refreshCache ) { var result = { } , selector ; if ( rules === null || refreshCache ) { CSS . refreshCache ( ) ; } for ( selector in rules ) { result [ selector ] = rules [ selector ] . cssRule ; } return result ; } 
function ( selector , refreshCache , rawCache ) { var i , result ; if ( ! rules || refreshCache ) { CSS . refreshCache ( ) ; } if ( ! Ext . isArray ( selector ) ) { result = rules [ selector . toLowerCase ( ) ] if ( result && ! rawCache ) { result = result . cssRule ; } return result || null ; } for ( i = 0 ; i < selector . length ; i ++ ) { if ( rules [ selector [ i ] ] ) { return rawCache ? rules [ selector [ i ] . toLowerCase ( ) ] : rules [ selector [ i ] . toLowerCase ( ) ] . cssRule ; } } return null ; } 
function ( styleSheet , selector , cssText ) { var result , ruleSet = styleSheet . cssRules || styleSheet . rules , index = ruleSet . length ; if ( styleSheet . insertRule ) { styleSheet . insertRule ( selector + '{' + cssText + '}' , index ) ; } else { styleSheet . addRule ( selector , cssText || ' ' ) ; } CSS . cacheRule ( result = ruleSet [ index ] , styleSheet ) ; return result ; } 
function cloneObject ( obj ) { if ( obj === null || typeof obj !== 'object' ) { return obj ; } var temp = obj . constructor ( ) ; 
function ( node , callback , scope , args ) { var me = this , reader , dataRoot , data , callbackArgs ; 
function ( root , preventLoad ) { var me = this , model = me . model , idProperty = model . prototype . idProperty root = root || { } ; if ( ! root . isModel ) { root = Ext . apply ( { } , root ) ; 
function ( node1 , node2 ) { return node1 [ node1 . persistenceProperty ] . index - node2 [ node2 . persistenceProperty ] . index ; } 
function ( operation ) { var me = this , successful = operation . wasSuccessful ( ) , records = operation . getRecords ( ) , node = operation . node ; me . loading = false ; node . set ( 'loading' , false ) ; if ( successful ) { if ( ! me . clearOnLoad ) { records = me . cleanRecords ( node , records ) ; } records = me . fillNode ( node , records ) ; } * @event load * Fires whenever the store reads data from a remote data source. * @param {Ext.data.TreeStore} this * @param {Ext.data.NodeInterface} node The node that was loaded. * @param {Ext.data.Model[]} records An array of records. * @param {Boolean} successful True if the operation was successful. */ 
function init ( tag , attrs , params ) { * View constructor * * @copyParams ose-html5.lib.wrap/constructor * * @method constructor */ O . inherited ( this ) ( tag || 'ul' , attrs , params ) ; this . updating = 0 ; this . hook ( ) ; this . text ( 'Loading ...' ) ; } 
function ( event , opts , fn , anyway ) { 
function ( req , res , runMethod ) { var form = new formidable . IncomingForm ( ) , files = { } , fields = { } , size = 0 for ( var i in formConfig ) { form [ i ] = formConfig [ i ] } form . on ( 'file' , function ( field , file ) { size += file . size if ( size > maxUploadSize ) { return false ; } if ( files [ field ] ) { if ( ! util . isArray ( files [ field ] ) ) files [ field ] = [ files [ field ] ] files [ field ] . push ( file ) } else { files [ field ] = file ; } } ) form . on ( 'field' , function ( field , value ) { if ( fields [ field ] ) { if ( ! util . isArray ( fields [ field ] ) ) fields [ field ] = [ fields [ field ] ] fields [ field ] . push ( value ) } else { fields [ field ] = value ; } } ) form . on ( 'end' , function ( ) { fields . files = files runMethod ( req , res , fields ) ; } ) ; form . parse ( req ) ; } 
function ( serv , conf ) { if ( conf . auth ) { var basicAuth = require ( 'http-auth' ) ; var basic = basicAuth . basic ( { realm : "Closed Area." } , function ( username , password , callback ) { 
function processArgv ( app , argv , options ) { var opts = utils . extend ( { } , options ) ; if ( opts . expand === false || argv . expand === 'false' ) { return argv ; } argv = utils . expandArgs ( argv , opts ) ; return sortArgs ( app , argv , opts ) ; } 
function sortArgs ( app , argv , options ) { options = options || [ ] ; var first = options . first || [ ] ; var last = options . last || [ ] ; var cliKeys = [ ] ; if ( app . cli && app . cli . keys ) { cliKeys = app . cli . keys ; } var keys = utils . union ( first , cliKeys , Object . keys ( argv ) ) ; keys = utils . diff ( keys , last ) ; keys = utils . union ( keys , last ) ; var len = keys . length ; var idx = - 1 ; var res = { } ; while ( ++ idx < len ) { var key = keys [ idx ] ; if ( argv . hasOwnProperty ( key ) ) { res [ key ] = argv [ key ] ; } } return res ; } 
function ( lineNum ) { var Changeset = require ( 'ep_etherpad-lite/static/js/Changeset' ) ; var ChangesetUtils = require ( 'ep_etherpad-lite/static/js/ChangesetUtils' ) ; var _ = require ( 'ep_etherpad-lite/static/js/underscore' ) ; var aline = Cristo . rep . alines [ lineNum ] ; if ( aline ) { var entry = Cristo . rep . lines . atIndex ( lineNum ) ; var text = entry . text ; var opIter = Changeset . opIterator ( aline ) ; var ci = - 1 ; var bci = - 1 ; var attributes = [ ] ; while ( opIter . hasNext ( ) ) { var op = opIter . next ( ) ; bci = ci + 1 ; ci += op . chars ; Changeset . eachAttribNumber ( op . attribs , function ( n ) { if ( bci > text . length ) { return ; } attributes . push ( { name : Cristo . rep . apool . getAttribKey ( n ) , value : Cristo . rep . apool . getAttribValue ( n ) , offset : bci , limit : ci - bci + 1 , charStart : text [ bci ] , charEnd : text [ Math . min ( ci , text . length - 1 ) ] , remove : function ( withChar , limit ) { limit = Math . min ( this . offset + ( limit > 0 ? limit : this . limit ) , entry . width ) ; var builder = Changeset . builder ( Cristo . rep . lines . totalWidth ( ) ) ; if ( withChar ) { ChangesetUtils . buildKeepToStartOfRange ( Cristo . rep , builder , [ lineNum , this . offset ] ) ; ChangesetUtils . buildRemoveRange ( Cristo . rep , builder , [ lineNum , this . offset ] , [ lineNum , limit ] ) ; } else { var attribs = _replaceAttrib ( this ) ; 
function ( lineNum , attributeName ) { var _ = require ( 'ep_etherpad-lite/static/js/underscore' ) ; if ( ! _ . isArray ( attributeName ) ) { attributeName = [ attributeName ] ; } var allAttribs = this . getAllAttributesOnLine ( lineNum ) ; return _ . filter ( allAttribs , function ( a ) { return _ . contains ( attributeName , a . name ) ; } ) ; } 
function ( ) { var me = this , min = me . normalizeDate ( me . minValue || me . absMin ) , max = me . normalizeDate ( me . maxValue || me . absMax ) ; me . rangeFilter . setFilterFn ( function ( record ) { var date = record . get ( 'date' ) ; return date >= min && date <= max ; } ) ; me . store . filter ( ) ; } 
function ( ) { var me = this , picker = new Ext . tree . Panel ( { shrinkWrapDock : 2 , store : me . store , floating : true , displayField : me . displayField , columns : me . columns , minHeight : me . minPickerHeight , maxHeight : me . maxPickerHeight , manageHeight : false , shadow : false , listeners : { scope : me , itemclick : me . onItemClick } , viewConfig : { listeners : { scope : me , render : me . onViewRender } } } ) , view = picker . getView ( ) ; if ( Ext . isIE9 && Ext . isStrict ) { 
function ( ) { var style = this . picker . getView ( ) . getEl ( ) . dom . style ; 
function ( ) { var me = this , picker ; if ( me . isExpanded ) { picker = me . getPicker ( ) ; if ( me . matchFieldWidth ) { 
function ( e , el ) { var key = e . getKey ( ) ; if ( key === e . ENTER || ( key === e . TAB && this . selectOnTab ) ) { this . selectItem ( this . picker . getSelectionModel ( ) . getSelection ( ) [ 0 ] ) ; } } 
function ( record ) { var me = this ; me . setValue ( record . getId ( ) ) ; me . picker . hide ( ) ; me . inputEl . focus ( ) ; me . fireEvent ( 'select' , me , record ) } 
function ( ) { var me = this , picker = me . picker , store = picker . store , value = me . value , node ; if ( value ) { node = store . getNodeById ( value ) ; } if ( ! node ) { node = store . getRootNode ( ) ; } picker . selectPath ( node . getPath ( ) ) ; Ext . defer ( function ( ) { picker . getView ( ) . focus ( ) ; } , 1 ) ; } 
function ( value ) { var me = this , record ; me . value = value ; if ( me . store . loading ) { 
function ( key ) { var pos = key . indexOf ( '[' ) ; if ( pos === - 1 ) return { type : 'string' , val : key } ; return { type : 'array' , val : key . substr ( 0 , pos ) } ; } 
function ( direction ) { var me = this ; me . direction = direction ? direction . toUpperCase ( ) : direction ; me . updateSortFunction ( ) ; } 
function ( ) { var me = this ; me . direction = Ext . String . toggle ( me . direction , "ASC" , "DESC" ) ; me . updateSortFunction ( ) ; } 
function ( fn ) { var me = this ; fn = fn || me . sorterFn || me . defaultSorterFn ; me . sort = me . createSortFunction ( fn ) ; } 
function ( text ) { var me = this , out = me . body ; text = text . replace ( me . aposRe , "\\'" ) . replace ( me . newLineRe , '\\n' ) ; if ( me . useIndex ) { out . push ( 'out[out.length]=\'' , text , '\'\n' ) ; } else { out . push ( 'out.push(\'' , text , '\')\n' ) ; } } 
function Recurring ( str ) { var parts = str . split ( '/' ) ; if ( str . charAt ( 0 ) != 'R' || parts . length != 3 ) { throw new Error ( 'Invalid Recurring Date' ) ; } 
function conditionalRequire ( options ) { 
function readData ( fullPath , data , type , path ) { var vow = VOW . make ( ) ; 
function recast ( args ) { var encoding = args . encoding || undefined ; 
function composeFunction ( flist ) { if ( flist . length === 0 ) return function identity ( data ) { return VOW . kept ( data ) ; } ; else if ( flist . length === 1 ) return flist [ 0 ] ; else if ( flist . length === 2 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) ; } ; else if ( flist . length === 3 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) . when ( flist [ 2 ] ) ; } ; else if ( flist . length === 4 ) return function ( data ) { return flist [ 0 ] ( data ) . when ( flist [ 1 ] ) . when ( flist [ 2 ] ) . when ( flist [ 3 ] ) ; } ; return function ( ) { return VOW . broken ( "Can't have more than four passes!!!. Shouldn't happen!!!" ) ; } ; 
function Room ( host , gapi ) { var hangout = gapi . hangout var id = hangout . getHangoutId ( ) var people = reducible ( function ( next , state ) { var invoke = invoker ( next , state , cleanup ) hangout . onParticipantsAdded . add ( onAdd ) hangout . onParticipantsRemoved . add ( onRemove ) hangout . getParticipants ( ) . forEach ( add ) var timer = setTimeout ( function loop ( ) { hangout . getParticipants ( ) . forEach ( add ) timer = setTimeout ( loop , 1000 ) } , 1000 ) function onAdd ( event ) { event . addedParticipants . forEach ( add ) } function onRemove ( event ) { event . removedParticipants . forEach ( remove ) } function add ( par ) { invoke ( { id : par . person . id , imageUri : par . person . image . url , name : par . person . displayName , online : true , ts : now ( ) } ) } function remove ( par ) { invoke ( { id : par . person . id , online : false } ) } function cleanup ( callback ) { clearTimeout ( timer ) hangout . onParticipantsAdded . remove ( onAdd ) hangout . onParticipantsRemoved . remove ( onRemove ) callback ( null ) } } ) return { id : id , host : host , people : people } } 
function preInitialize ( options ) { debug ( 'pre initialize' ) ; this . app = options . app ; this . layoutTemplate = options . layoutTemplate ; this . startExpressApp = options . startExpressApp ; this . apiAdapter = options . apiAdapter ; this . setupRequestContext = options . setupRequestContext ; } 
function route ( routeUri ) { debug ( 'route `%s`' , routeUri ) ; var self = this , Barefoot = require ( '../' ) ( ) ; 
function render ( view ) { debug ( 'render' ) ; var self = this , $ ; function initDOM ( ) { debug ( 'init DOM' ) ; $ = cheerio . load ( self . layoutTemplate ) ; } function renderMainView ( ) { debug ( 'render main view' ) ; var promise ; if ( ! _ . isUndefined ( self . mainView ) ) { var clonedMainView = _ . clone ( self . mainView ( ) ) ; clonedMainView . $ = $ ; clonedMainView . $el = clonedMainView . selectDOMElement ( $ ) ; promise = clonedMainView . render ( ) ; } return promise ; } function renderView ( ) { debug ( 'render view' ) ; view . $ = $ ; view . $el = view . selectDOMElement ( $ ) ; return view . render ( ) ; } function serializeDataStore ( ) { debug ( 'serialize data store' ) ; if ( ! _ . isUndefined ( self . dataStore ) && _ . keys ( self . dataStore . registeredModelsAndCollections ) . length > 0 ) { var serializiedDataStore = JSON . stringify ( self . dataStore . toJSON ( ) ) , javaScriptElement = '<script>function deserializeDataStore(){' + 'return ' + serializiedDataStore + ';}</script>' ; $ ( 'body' ) . append ( javaScriptElement ) ; } } function writeHTTPResponse ( ) { debug ( 'write http response' ) ; self . res . send ( $ . html ( ) ) ; } function writeHTTPError ( err ) { winston . log ( 'error' , 'Uncatched HTTP Error' , { source : toString ( ) , err : err . toString ( ) || err , stack : err . stack || undefined } ) ; debug ( 'write http error' ) ; self . res . send ( 500 ) ; } Q . fcall ( initDOM ) . then ( renderMainView ) . then ( renderView ) . then ( serializeDataStore ) . done ( writeHTTPResponse , writeHTTPError ) ; } 
function iopaStaticSend ( context , path , opts ) { opts = opts || { } ; return new Promise ( function iopaStaticLoad ( resolve , reject ) { var root = opts . root ? normalize ( pathResolve ( opts . root ) ) : '' ; var index = opts . index ; var maxage = opts . maxage || 0 ; var hidden = opts . hidden || false ; var sync = opts . sync || false ; opts = null ; 
function bindRemoved ( that , content ) { content . on ( 'removed' , function ( ev ) { if ( content === that . content ) { delete that . content ; } if ( ! that . content && that . header ) { that . header . empty ( ) ; } } ) ; } 
function ( ed , url ) { var self = this , settings = ed . settings ; self . editor = ed ; // Parses the specified time string into a milisecond number 10m, 10s etc. function parseTime ( time ) { var multipels = { s : 1000 , m : 60000 } ; time = / ^(\d+)([ms]?)$ / . exec ( '' + time ) ; return ( time [ 2 ] ? multipels [ time [ 2 ] ] : 1 ) * parseInt ( time ) ; } ; // Default config tinymce . each ( { ask_before_unload : TRUE , interval : '30s' , retention : '20m' , minlength : 50 } , function ( value , key ) { key = PLUGIN_NAME + '_' + key ; if ( settings [ key ] === undefined ) settings [ key ] = value ; } ) ; // Parse times settings . autosave_interval = parseTime ( settings . autosave_interval ) ; settings . autosave_retention = parseTime ( settings . autosave_retention ) ; // Register restore button ed . addButton ( RESTORE_DRAFT , { title : PLUGIN_NAME + ".restore_content" , onclick : function ( ) { if ( ed . getContent ( { draft : true } ) . replace ( / \s|&nbsp;|<\/?p[^>]*>|<br[^>]*> / gi , "" ) . length > 0 ) { // Show confirm dialog if the editor isn't empty ed . windowManager . confirm ( PLUGIN_NAME + ".warning_message" , function ( ok ) { if ( ok ) self . restoreDraft ( ) ; } ) ; } else self . restoreDraft ( ) ; } } ) ; // Enable/disable restoredraft button depending on if there is a draft stored or not ed . onNodeChange . add ( function ( ) { var controlManager = ed . controlManager ; if ( controlManager . get ( RESTORE_DRAFT ) ) controlManager . setDisabled ( RESTORE_DRAFT , ! self . hasDraft ( ) ) ; } ) ; ed . onInit . add ( function ( ) { // Check if the user added the restore button, then setup auto storage logic if ( ed . controlManager . get ( RESTORE_DRAFT ) ) { // Setup storage engine self . setupStorage ( ed ) ; // Auto save contents each interval time setInterval ( function ( ) { if ( ! ed . removed ) { self . storeDraft ( ) ; ed . nodeChanged ( ) ; } } , settings . autosave_interval ) ; } } ) ; self . onStoreDraft = new Dispatcher ( self ) ; self . onRestoreDraft = new Dispatcher ( self ) ; self . onRemoveDraft = new Dispatcher ( self ) ; // Add ask before unload dialog only add one unload handler if ( ! unloadHandlerAdded ) { window . onbeforeunload = tinymce . plugins . AutoSave . _beforeUnloadHandler ; unloadHandlerAdded = TRUE ; } } 
function ( ed ) { var self = this , testKey = PLUGIN_NAME + '_test' , testVal = "OK" ; self . key = PLUGIN_NAME + ed . id ; // Loop though each storage engine type until we find one that works tinymce . each ( [ function ( ) { // Try HTML5 Local Storage if ( localStorage ) { localStorage . setItem ( testKey , testVal ) ; if ( localStorage . getItem ( testKey ) === testVal ) { localStorage . removeItem ( testKey ) ; return localStorage ; } } } , function ( ) { // Try HTML5 Session Storage if ( sessionStorage ) { sessionStorage . setItem ( testKey , testVal ) ; if ( sessionStorage . getItem ( testKey ) === testVal ) { sessionStorage . removeItem ( testKey ) ; return sessionStorage ; } } } , function ( ) { // Try IE userData if ( tinymce . isIE ) { ed . getElement ( ) . style . behavior = "url('#default#userData')" ; // Fake localStorage on old IE return { autoExpires : TRUE , setItem : function ( key , value ) { var userDataElement = ed . getElement ( ) ; userDataElement . setAttribute ( key , value ) ; userDataElement . expires = self . getExpDate ( ) ; try { userDataElement . save ( "TinyMCE" ) ; } catch ( e ) { // Ignore, saving might fail if "Userdata Persistence" is disabled in IE } } , getItem : function ( key ) { var userDataElement = ed . getElement ( ) ; try { userDataElement . load ( "TinyMCE" ) ; return userDataElement . getAttribute ( key ) ; } catch ( e ) { // Ignore, loading might fail if "Userdata Persistence" is disabled in IE return null ; } } , removeItem : function ( key ) { ed . getElement ( ) . removeAttribute ( key ) ; } } ; } } , ] , function ( setup ) { // Try executing each function to find a suitable storage engine try { self . storage = setup ( ) ; if ( self . storage ) return false ; } catch ( e ) { // Ignore } } ) ; } 
function ( ) { var self = this , storage = self . storage , editor = self . editor , expires , content ; // Is the contents dirty if ( storage ) { // If there is no existing key and the contents hasn't been changed since // it's original value then there is no point in saving a draft if ( ! storage . getItem ( self . key ) && ! editor . isDirty ( ) ) return ; // Store contents if the contents if longer than the minlength of characters content = editor . getContent ( { draft : true } ) ; if ( content . length > editor . settings . autosave_minlength ) { expires = self . getExpDate ( ) ; // Store expiration date if needed IE userData has auto expire built in if ( ! self . storage . autoExpires ) self . storage . setItem ( self . key + "_expires" , expires ) ; self . storage . setItem ( self . key , content ) ; self . onStoreDraft . dispatch ( self , { expires : expires , content : content } ) ; } } } 
function ( ) { var self = this , storage = self . storage , content ; if ( storage ) { content = storage . getItem ( self . key ) ; if ( content ) { self . editor . setContent ( content ) ; self . onRestoreDraft . dispatch ( self , { content : content } ) ; } } } 
function ( ) { var self = this , storage = self . storage , expDate , exists ; if ( storage ) { // Does the item exist at all exists = ! ! storage . getItem ( self . key ) ; if ( exists ) { // Storage needs autoexpire if ( ! self . storage . autoExpires ) { expDate = new Date ( storage . getItem ( self . key + "_expires" ) ) ; // Contents hasn't expired if ( new Date ( ) . getTime ( ) < expDate . getTime ( ) ) return TRUE ; // Remove it if it has self . removeDraft ( ) ; } else return TRUE ; } } return false ; } 
function ( ) { var self = this , storage = self . storage , key = self . key , content ; if ( storage ) { // Get current contents and remove the existing draft content = storage . getItem ( key ) ; storage . removeItem ( key ) ; storage . removeItem ( key + "_expires" ) ; // Dispatch remove event if we had any contents if ( content ) { self . onRemoveDraft . dispatch ( self , { content : content } ) ; } } } 
function ( e ) { var msg ; tinymce . each ( tinyMCE . editors , function ( ed ) { // Store a draft for each editor instance if ( ed . plugins . autosave ) ed . plugins . autosave . storeDraft ( ) ; // Never ask in fullscreen mode if ( ed . getParam ( "fullscreen_is_enabled" ) ) return ; // Setup a return message if the editor is dirty if ( ! msg && ed . isDirty ( ) && ed . getParam ( "autosave_ask_before_unload" ) ) msg = ed . getLang ( "autosave.unload_msg" ) ; } ) ; return msg ; } 
function request ( url ) { return new Promise ( function ( resolve , reject ) { _request ( url , function ( error , response , body ) { if ( error ) return reject ( error ) ; resolve ( { response , body } ) } ) ; } ) ; } 
function ( ) { if ( typeof objective . promised === 'undefined' ) { debug ( 'Got no promise from objective function' ) ; return pipeline . emit ( 'objective.not.promised' , { config : config , fn : objectiveFn , result : running , deferral : deferral , root : root } , function ( err ) { if ( typeof err !== 'undefined' && err !== null ) { clearRequire ( ) ; objective . currentChild = null ; return deferral . reject ( err ) ; } clearRequire ( ) ; objective . currentChild = null ; deferral . resolve ( ) ; } ) ; } return objective . promised ; } 
function ( grid , state ) { var filters = { } ; this . filters . each ( function ( filter ) { if ( filter . active ) { filters [ filter . dataIndex ] = filter . getValue ( ) ; } } ) ; return ( state . filters = filters ) ; } 
function ( store ) { var me = this ; 
function ( ) { var me = this , headerCt = me . view . headerCt ; if ( headerCt ) { headerCt . items . each ( function ( header ) { var filter = me . getFilter ( header . dataIndex ) ; header [ filter && filter . active ? 'addCls' : 'removeCls' ] ( me . filterCls ) ; } ) ; } } 
function ( ) { var f = [ ] , len , i ; this . filters . each ( function ( filter ) { if ( filter . active ) { f . push ( filter ) ; } } ) ; len = f . length ; return function ( record ) { for ( i = 0 ; i < len ; i ++ ) { if ( ! f [ i ] . validateRecord ( record ) ) { return false ; } } return true ; } ; } 
function ( config ) { var me = this , columns = me . getGridPanel ( ) . columns , i , columnsLength , column , filtersLength , filter ; for ( i = 0 , columnsLength = columns . length ; i < columnsLength ; i ++ ) { column = columns [ i ] ; if ( column . dataIndex === config . dataIndex ) { column . filter = config ; } } if ( me . view . headerCt . menu ) { me . createFilters ( ) ; } else { 
function ( filters ) { if ( filters ) { var me = this , i , filtersLength ; for ( i = 0 , filtersLength = filters . length ; i < filtersLength ; i ++ ) { me . addFilter ( filters [ i ] ) ; } } } 
function ( ) { var items = this . getFilterItems ( ) , filters = [ ] , n , nlen , item , d , i , len ; for ( n = 0 , nlen = items . length ; n < nlen ; n ++ ) { item = items [ n ] ; if ( item . active ) { d = [ ] . concat ( item . serialize ( ) ) ; for ( i = 0 , len = d . length ; i < len ; i ++ ) { filters . push ( { field : item . dataIndex , data : d [ i ] } ) ; } } } return filters ; } 
function ( filters ) { var p = { } , i , f , root , dataPrefix , key , tmp , len = filters . length ; if ( ! this . encode ) { for ( i = 0 ; i < len ; i ++ ) { f = filters [ i ] ; root = [ this . paramPrefix , '[' , i , ']' ] . join ( '' ) ; p [ root + '[field]' ] = f . field ; dataPrefix = root + '[data]' ; for ( key in f . data ) { p [ [ dataPrefix , '[' , key , ']' ] . join ( '' ) ] = f . data [ key ] ; } } } else { tmp = [ ] ; for ( i = 0 ; i < len ; i ++ ) { f = filters [ i ] ; tmp . push ( Ext . apply ( { } , { field : f . field } , f . data ) ) ; } 
function ( p ) { 
function ( record , columnHeader ) { var me = this , grid = me . editingPlugin . grid , store = grid . store , view = grid . getView ( ) , context = me . context = Ext . apply ( me . editingPlugin . context , { view : view , store : store } ) ; if ( ! me . rendered ) { me . render ( view . el ) ; } 
function Approximate ( ) { if ( arguments . length > 0 ) { if ( arguments [ 0 ] . length < 1 || arguments [ 0 ] . charAt ( 0 ) != 'A' ) { throw new Error ( 'Invalid Approximate Date' ) ; } try { Simple . call ( this , arguments [ 0 ] . substr ( 1 ) ) ; } catch ( e ) { throw new Error ( e . message + ' in Approximate Date' ) ; } } else { Simple . call ( this ) ; } } 
function ( asString , dirtyOnly , includeEmptyText , useDataValues ) { return this . getForm ( ) . getValues ( asString , dirtyOnly , includeEmptyText , useDataValues ) ; } 
function ( interval ) { this . stopPolling ( ) ; var task = new Ext . util . TaskRunner ( interval ) ; task . start ( { interval : 0 , run : this . checkChange , scope : this } ) ; this . pollTask = task ; } 
function ( ) { var fields = this . form . getFields ( ) . items , f , fLen = fields . length ; for ( f = 0 ; f < fLen ; f ++ ) { fields [ f ] . checkChange ( ) ; } } 
function ( form , url , params , options ) { form = Ext . getDom ( form ) ; options = options || { } ; var id = Ext . id ( ) , frame = document . createElement ( 'iframe' ) , hiddens = [ ] , encoding = 'multipart/form-data' , buf = { target : form . target , method : form . method , encoding : form . encoding , enctype : form . enctype , action : form . action } , addField = function ( name , value ) { hiddenItem = document . createElement ( 'input' ) ; Ext . fly ( hiddenItem ) . set ( { type : 'hidden' , value : value , name : name } ) ; form . appendChild ( hiddenItem ) ; hiddens . push ( hiddenItem ) ; } , hiddenItem , obj , value , name , vLen , v , hLen , h ; Ext . fly ( frame ) . set ( { id : id , name : id , cls : Ext . baseCSSPrefix + 'hide-display' , src : Ext . SSL_SECURE_URL } ) ; document . body . appendChild ( frame ) ; 
function ( options ) { var form = this . getForm ( options ) ; if ( form ) { return ( options . isUpload || ( / multipart\/form-data / i ) . test ( form . getAttribute ( 'enctype' ) ) ) ; } return false ; } 
function ( options , url ) { var form = this . getForm ( options ) ; if ( form ) { url = url || form . action ; } return url ; } 
function ( options , params ) { var form = this . getForm ( options ) , serializedForm ; if ( form && ! this . isFormUpload ( options ) ) { serializedForm = Ext . Element . serializeForm ( form ) ; params = params ? ( params + '&' + serializedForm ) : serializedForm ; } return params ; } 
function ( ) { var xdr ; if ( Ext . ieVersion >= 8 ) { xdr = new XDomainRequest ( ) ; } else { Ext . Error . raise ( { msg : 'Your browser does not support CORS' } ) ; } return xdr ; } 
function ( request ) { if ( ! request ) { request = this . getLatest ( ) ; } if ( ! ( request && request . xhr ) ) { return false ; } 
function ( request ) { var me = this , xhr ; if ( ! request ) { request = me . getLatest ( ) ; } if ( request && me . isLoading ( request ) ) { xhr = request . xhr ; try { xhr . onreadystatechange = null ; } catch ( e ) { 
function ( ) { var requests = this . requests , id ; for ( id in requests ) { if ( requests . hasOwnProperty ( id ) ) { this . abort ( requests [ id ] ) ; } } } 
function ( request , xdrResult ) { var me = this ; 
function ( request , xdrResult ) { var me = this , options = request . options , result , success , response ; try { result = me . parseStatus ( request . xhr . status ) ; } catch ( e ) { 
function ( status ) { 
function ( request ) { return { request : request , requestId : request . id , status : request . aborted ? - 1 : 0 , statusText : request . aborted ? 'transaction aborted' : 'communication failure' , aborted : request . aborted , timedout : request . timedout } ; } 
function ( ) { var scriptTag = document . createElement ( 'script' ) ; scriptTag . type = 'text/vbscript' ; scriptTag . text = [ 'Function getIEByteArray(byteArray, out)' , 'Dim len, i' , 'len = LenB(byteArray)' , 'For i = 1 to len' , 'out.push(AscB(MidB(byteArray, i, 1)))' , 'Next' , 'End Function' ] . join ( '\n' ) ; Ext . getHead ( ) . dom . appendChild ( scriptTag ) ; this . self . vbScriptInjected = true ; } 
function SyncApi ( schema , sh , logger ) { _ . assertObject ( schema ) ; _ . assertFunction ( logger ) this . log = logger ; this . temporaryIdCounter = - 1 ; this . sh = sh ; 
function daysInMonth ( month , year ) { switch ( month ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : return 31 ; case 4 : case 6 : case 9 : case 11 : return 30 ; case 2 : var leapyear ; if ( year % 4 != 0 ) { leapyear = false ; } else if ( year % 100 != 0 ) { leapyear = true ; } else if ( year % 400 != 0 ) { leapyear = false ; } else { leapyear = true ; } if ( leapyear ) { return 29 ; } else { return 28 ; } default : throw new Error ( 'Unknown Month' ) ; } } 
function setDefaults ( ) { 
function getTimestamp ( ) { 
function getSequence ( ) { var mod = ++ seq % 16 
function assertRange ( name , val , max ) { assert . equal ( typeof val , 'number' , name + ' must be a number' ) assert ( ! isNaN ( val ) , 'number' , name + ' must be a number' ) if ( val > max ) throw new RangeError ( name + ' must be lower than ' + max + ', but is ' + val ) else if ( val < 0 ) throw new RangeError ( name + ' must be greater than or equal to zero, but is ' + val ) else if ( val % 1 ) throw new RangeError ( name + ' must be an integer' ) } 
function proceedToFetch ( loader , load , p ) { proceedToTranslate ( loader , load , p 
function proceedToTranslate ( loader , load , p ) { p 
function asyncStartLoadPartwayThrough ( stepState ) { return function ( resolve , reject ) { var loader = stepState . loader ; var name = stepState . moduleName ; var step = stepState . step ; if ( loader . modules [ name ] ) throw new TypeError ( '"' + name + '" already exists in the module table' ) ; 
function createLinkSet ( loader , startingLoad ) { var linkSet = { loader : loader , loads : [ ] , loadingCount : 0 } ; linkSet . done = new Promise ( function ( resolve , reject ) { linkSet . resolve = resolve ; linkSet . reject = reject ; } ) ; addLoadToLinkSet ( linkSet , startingLoad ) ; return linkSet ; } 
function updateLinkSetOnLoad ( linkSet , load ) { console . assert ( load . status == 'loaded' || load . status == 'linked' , 'loaded or linked' ) ; 
function finishLoad ( loader , load ) { 
function link ( linkSet ) { var loader = linkSet . loader ; 
function linkDeclarativeModule ( load , loads , loader ) { 
function ensureEvaluated ( module , seen , loader ) { if ( module . evaluated || ! module . dependencies ) return ; seen . push ( module ) ; var deps = module . dependencies ; for ( var i = 0 ; i < deps . length ; i ++ ) { var dep = deps [ i ] ; if ( indexOf . call ( seen , dep ) == - 1 ) ensureEvaluated ( dep , seen , loader ) ; } if ( module . evaluated ) return ; module . evaluated = true ; module . execute . call ( __global ) ; module . module = Module ( module . exports ) ; delete module . execute ; } 
function Loader ( options ) { if ( typeof options != 'object' ) throw new TypeError ( 'Options must be an object' ) ; if ( options . normalize ) this . normalize = options . normalize ; if ( options . locate ) this . locate = options . locate ; if ( options . fetch ) this . fetch = options . fetch ; if ( options . translate ) this . translate = options . translate ; if ( options . instantiate ) this . instantiate = options . instantiate ; this . _loader = { loaderObj : this , loads : [ ] , modules : { } } ; defineProperty ( this , 'global' , { get : function ( ) { return global ; } } ) ; defineProperty ( this , 'realm' , { get : function ( ) { throw new TypeError ( 'Realms not implemented in polyfill' ) ; } } ) ; } 
function Module ( obj ) { if ( typeof obj != 'object' ) throw new TypeError ( 'Expected object' ) ; var self = { __esModule : true } ; for ( var key in obj ) { ( function ( key ) { defineProperty ( self , key , { configurable : false , enumerable : true , get : function ( ) { return obj [ key ] ; } } ) ; } ) ( key ) ; } if ( Object . preventExtensions ) Object . preventExtensions ( self ) ; return self ; } 
function ( ) { var me = this , view = me . view ; view . on ( { scope : me , groupclick : me . onGroupClick } ) ; if ( me . enableGroupingMenu ) { me . injectGroupingMenu ( ) ; } me . pruneGroupedHeader ( ) ; me . lastGroupField = me . getGroupField ( ) ; me . block ( ) ; me . onGroupChange ( ) ; me . unblock ( ) ; } 
function ( menuItem , e ) { var me = this , menu = menuItem . parentMenu , hdr = menu . activeHeader , view = me . view , store = view . store ; delete me . lastGroupIndex ; me . block ( ) ; me . enable ( ) ; store . group ( hdr . dataIndex ) ; me . pruneGroupedHeader ( ) ; me . unblock ( ) ; me . refreshIf ( ) ; } 
function ( ) { var me = this , header = me . getGroupedHeader ( ) ; if ( me . hideGroupedHeader && header ) { Ext . suspendLayouts ( ) ; if ( me . prunedHeader && me . prunedHeader !== header ) { me . prunedHeader . show ( ) ; } me . prunedHeader = header ; header . hide ( ) ; Ext . resumeLayouts ( true ) ; } } 
function ( dataIndex ) { var view = this . view , header = view . headerCt . down ( 'gridcolumn[dataIndex=' + dataIndex + ']' ) , menu = view . headerCt . getMenu ( ) ; return header ? menu . down ( 'menuitem[headerId=' + header . id + ']' ) : null ; } 
function ( view , rowElement , groupName , e ) { var me = this , groupCache = me . groupCache , groupIsCollapsed = ! me . isExpanded ( groupName ) , g ; if ( me . collapsible ) { 
function ( record ) { var grouper = this . view . store . groupers . first ( ) ; if ( grouper ) { return this . groupCache [ grouper . getGroupString ( record ) ] ; } } 
function process ( o , force_rich ) { var dom = ed . dom , rng ; // Execute pre process handlers t . onPreProcess . dispatch ( t , o ) ; // Create DOM structure o . node = dom . create ( 'div' , 0 , o . content ) ; // If pasting inside the same element and the contents is only one block // remove the block and keep the text since Firefox will copy parts of pre and h1-h6 as a pre element if ( tinymce . isGecko ) { rng = ed . selection . getRng ( true ) ; if ( rng . startContainer == rng . endContainer && rng . startContainer . nodeType == 3 ) { // Is only one block node and it doesn't contain word stuff if ( o . node . childNodes . length === 1 && / ^(p|h[1-6]|pre)$ / i . test ( o . node . firstChild . nodeName ) && o . content . indexOf ( '__MCE_ITEM__' ) === - 1 ) dom . remove ( o . node . firstChild , true ) ; } } // Execute post process handlers t . onPostProcess . dispatch ( t , o ) ; // Serialize content o . content = ed . serializer . serialize ( o . node , { getInner : 1 , forced_root_block : '' } ) ; // Plain text option active? if ( ( ! force_rich ) && ( ed . pasteAsPlainText ) ) { t . _insertPlainText ( o . content ) ; if ( ! getParam ( ed , "paste_text_sticky" ) ) { ed . pasteAsPlainText = false ; ed . controlManager . setActive ( "pastetext" , false ) ; } } else { t . _insert ( o . content ) ; } } 
function grabContent ( e ) { var n , or , rng , oldRng , sel = ed . selection , dom = ed . dom , body = ed . getBody ( ) , posY , textContent ; // Check if browser supports direct plaintext access if ( e . clipboardData || dom . doc . dataTransfer ) { textContent = ( e . clipboardData || dom . doc . dataTransfer ) . getData ( 'Text' ) ; if ( ed . pasteAsPlainText ) { e . preventDefault ( ) ; process ( { content : dom . encode ( textContent ) . replace ( / \r?\n / g , '<br />' ) } ) ; return ; } } if ( dom . get ( '_mcePaste' ) ) return ; // Create container to paste into n = dom . add ( body , 'div' , { id : '_mcePaste' , 'class' : 'mcePaste' , 'data-mce-bogus' : '1' } , '\uFEFF\uFEFF' ) ; // If contentEditable mode we need to find out the position of the closest element if ( body != ed . getDoc ( ) . body ) posY = dom . getPos ( ed . selection . getStart ( ) , body ) . y ; else posY = body . scrollTop + dom . getViewPort ( ed . getWin ( ) ) . y ; // Styles needs to be applied after the element is added to the document since WebKit will otherwise remove all styles // If also needs to be in view on IE or the paste would fail dom . setStyles ( n , { position : 'absolute' , left : tinymce . isGecko ? - 40 : 0 , // Need to move it out of site on Gecko since it will othewise display a ghost resize rect for the div top : posY - 25 , width : 1 , height : 1 , overflow : 'hidden' } ) ; if ( tinymce . isIE ) { // Store away the old range oldRng = sel . getRng ( ) ; // Select the container rng = dom . doc . body . createTextRange ( ) ; rng . moveToElementText ( n ) ; rng . execCommand ( 'Paste' ) ; // Remove container dom . remove ( n ) ; // Check if the contents was changed, if it wasn't then clipboard extraction failed probably due // to IE security settings so we pass the junk though better than nothing right if ( n . innerHTML === '\uFEFF\uFEFF' ) { ed . execCommand ( 'mcePasteWord' ) ; e . preventDefault ( ) ; return ; } // Restore the old range and clear the contents before pasting sel . setRng ( oldRng ) ; sel . setContent ( '' ) ; // For some odd reason we need to detach the the mceInsertContent call from the paste event // It's like IE has a reference to the parent element that you paste in and the selection gets messed up // when it tries to restore the selection setTimeout ( function ( ) { // Process contents process ( { content : n . innerHTML } ) ; } , 0 ) ; // Block the real paste event return tinymce . dom . Event . cancel ( e ) ; } else { function block ( e ) { e . preventDefault ( ) ; } ; // Block mousedown and click to prevent selection change dom . bind ( ed . getDoc ( ) , 'mousedown' , block ) ; dom . bind ( ed . getDoc ( ) , 'keydown' , block ) ; or = ed . selection . getRng ( ) ; // Move select contents inside DIV n = n . firstChild ; rng = ed . getDoc ( ) . createRange ( ) ; rng . setStart ( n , 0 ) ; rng . setEnd ( n , 2 ) ; sel . setRng ( rng ) ; // Wait a while and grab the pasted contents window . setTimeout ( function ( ) { var h = '' , nl ; // Paste divs duplicated in paste divs seems to happen when you paste plain text so lets first look for that broken behavior in WebKit if ( ! dom . select ( 'div.mcePaste > div.mcePaste' ) . length ) { nl = dom . select ( 'div.mcePaste' ) ; // WebKit will split the div into multiple ones so this will loop through then all and join them to get the whole HTML string each ( nl , function ( n ) { var child = n . firstChild ; // WebKit inserts a DIV container with lots of odd styles if ( child && child . nodeName == 'DIV' && child . style . marginTop && child . style . backgroundColor ) { dom . remove ( child , 1 ) ; } // Remove apply style spans each ( dom . select ( 'span.Apple-style-span' , n ) , function ( n ) { dom . remove ( n , 1 ) ; } ) ; // Remove bogus br elements each ( dom . select ( 'br[data-mce-bogus]' , n ) , function ( n ) { dom . remove ( n ) ; } ) ; // WebKit will make a copy of the DIV for each line of plain text pasted and insert them into the DIV if ( n . parentNode . className != 'mcePaste' ) h += n . innerHTML ; } ) ; } else { // Found WebKit weirdness so force the content into paragraphs this seems to happen when you paste plain text from Nodepad etc // So this logic will replace double enter with paragraphs and single enter with br so it kind of looks the same h = '<p>' + dom . encode ( textContent ) . replace ( / \r?\n\r?\n / g , '</p><p>' ) . replace ( / \r?\n / g , '<br />' ) + '</p>' ; } // Remove the nodes each ( dom . select ( 'div.mcePaste' ) , function ( n ) { dom . remove ( n ) ; } ) ; // Restore the old selection if ( or ) sel . setRng ( or ) ; process ( { content : h } ) ; // Unblock events ones we got the contents dom . unbind ( ed . getDoc ( ) , 'mousedown' , block ) ; dom . unbind ( ed . getDoc ( ) , 'keydown' , block ) ; } , 0 ) ; } } 
function process ( items ) { each ( items , function ( v ) { // Remove or replace if ( v . constructor == RegExp ) h = h . replace ( v , '' ) ; else h = h . replace ( v [ 0 ] , v [ 1 ] ) ; } ) ; } 
function ( pl , o ) { var t = this , ed = t . editor , dom = ed . dom , styleProps ; if ( ed . settings . paste_enable_default_filters == false ) { return ; } if ( o . wordContent ) { // Remove named anchors or TOC links each ( dom . select ( 'a' , o . node ) , function ( a ) { if ( ! a . href || a . href . indexOf ( '#_Toc' ) != - 1 ) dom . remove ( a , 1 ) ; } ) ; if ( getParam ( ed , "paste_convert_middot_lists" ) ) { t . _convertLists ( pl , o ) ; } // Process styles styleProps = getParam ( ed , "paste_retain_style_properties" ) ; // retained properties // Process only if a string was specified and not equal to "all" or "*" if ( ( tinymce . is ( styleProps , "string" ) ) && ( styleProps !== "all" ) && ( styleProps !== "*" ) ) { styleProps = tinymce . explode ( styleProps . replace ( / ^none$ / i , "" ) ) ; // Retains some style properties each ( dom . select ( '*' , o . node ) , function ( el ) { var newStyle = { } , npc = 0 , i , sp , sv ; // Store a subset of the existing styles if ( styleProps ) { for ( i = 0 ; i < styleProps . length ; i ++ ) { sp = styleProps [ i ] ; sv = dom . getStyle ( el , sp ) ; if ( sv ) { newStyle [ sp ] = sv ; npc ++ ; } } } // Remove all of the existing styles dom . setAttrib ( el , 'style' , '' ) ; if ( styleProps && npc > 0 ) dom . setStyles ( el , newStyle ) ; // Add back the stored subset of styles else // Remove empty span tags that do not have class attributes if ( el . nodeName == 'SPAN' && ! el . className ) dom . remove ( el , true ) ; } ) ; } } // Remove all style information or only specifically on WebKit to avoid the style bug on that browser if ( getParam ( ed , "paste_remove_styles" ) || ( getParam ( ed , "paste_remove_styles_if_webkit" ) && tinymce . isWebKit ) ) { each ( dom . select ( '*[style]' , o . node ) , function ( el ) { el . removeAttribute ( 'style' ) ; el . removeAttribute ( 'data-mce-style' ) ; } ) ; } else { if ( tinymce . isWebKit ) { // We need to compress the styles on WebKit since if you paste <img border="0" /> it will become <img border="0" style="... lots of junk ..." /> // Removing the mce_style that contains the real value will force the Serializer engine to compress the styles each ( dom . select ( '*' , o . node ) , function ( el ) { el . removeAttribute ( 'data-mce-style' ) ; } ) ; } } } 
function ( pl , o ) { var dom = pl . editor . dom , listElm , li , lastMargin = - 1 , margin , levels = [ ] , lastType , html ; // Convert middot lists into real semantic lists each ( dom . select ( 'p' , o . node ) , function ( p ) { var sib , val = '' , type , html , idx , parents ; // Get text node value at beginning of paragraph for ( sib = p . firstChild ; sib && sib . nodeType == 3 ; sib = sib . nextSibling ) val += sib . nodeValue ; val = p . innerHTML . replace ( / <\/?\w+[^>]*> / gi , '' ) . replace ( / &nbsp; / g , '\u00a0' ) ; // Detect unordered lists look for bullets if ( / ^(__MCE_ITEM__)+[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*\u00a0* / . test ( val ) ) type = 'ul' ; // Detect ordered lists 1., a. or ixv. if ( / ^__MCE_ITEM__\s*\w+\.\s*\u00a0+ / . test ( val ) ) type = 'ol' ; // Check if node value matches the list pattern: o&nbsp;&nbsp; if ( type ) { margin = parseFloat ( p . style . marginLeft || 0 ) ; if ( margin > lastMargin ) levels . push ( margin ) ; if ( ! listElm || type != lastType ) { listElm = dom . create ( type ) ; dom . insertAfter ( listElm , p ) ; } else { // Nested list element if ( margin > lastMargin ) { listElm = li . appendChild ( dom . create ( type ) ) ; } else if ( margin < lastMargin ) { // Find parent level based on margin value idx = tinymce . inArray ( levels , margin ) ; parents = dom . getParents ( listElm . parentNode , type ) ; listElm = parents [ parents . length - 1 - idx ] || listElm ; } } // Remove middot or number spans if they exists each ( dom . select ( 'span' , p ) , function ( span ) { var html = span . innerHTML . replace ( / <\/?\w+[^>]*> / gi , '' ) ; // Remove span with the middot or the number if ( type == 'ul' && / ^__MCE_ITEM__[\u2022\u00b7\u00a7\u00d8o\u25CF] / . test ( html ) ) dom . remove ( span ) ; else if ( / ^__MCE_ITEM__[\s\S]*\w+\.(&nbsp;|\u00a0)*\s* / . test ( html ) ) dom . remove ( span ) ; } ) ; html = p . innerHTML ; // Remove middot/list items if ( type == 'ul' ) html = p . innerHTML . replace ( / __MCE_ITEM__ / g , '' ) . replace ( / ^[\u2022\u00b7\u00a7\u00d8o\u25CF]\s*(&nbsp;|\u00a0)+\s* / , '' ) ; else html = p . innerHTML . replace ( / __MCE_ITEM__ / g , '' ) . replace ( / ^\s*\w+\.(&nbsp;|\u00a0)+\s* / , '' ) ; // Create li and add paragraph data into the new li li = listElm . appendChild ( dom . create ( 'li' , 0 , html ) ) ; dom . remove ( p ) ; lastMargin = margin ; lastType = type ; } else listElm = lastMargin = 0 ; // End list element } ) ; // Remove any left over makers html = o . node . innerHTML ; if ( html . indexOf ( '__MCE_ITEM__' ) != - 1 ) o . node . innerHTML = html . replace ( / __MCE_ITEM__ / g , '' ) ; } 
function ( h , skip_undo ) { var ed = this . editor , r = ed . selection . getRng ( ) ; // First delete the contents seems to work better on WebKit when the selection spans multiple list items or multiple table cells. if ( ! ed . selection . isCollapsed ( ) && r . startContainer != r . endContainer ) ed . getDoc ( ) . execCommand ( 'Delete' , false , null ) ; ed . execCommand ( 'mceInsertContent' , false , h , { skip_undo : skip_undo } ) ; } 
function ( content ) { var ed = this . editor , linebr = getParam ( ed , "paste_text_linebreaktype" ) , rl = getParam ( ed , "paste_text_replacements" ) , is = tinymce . is ; function process ( items ) { each ( items , function ( v ) { if ( v . constructor == RegExp ) content = content . replace ( v , "" ) ; else content = content . replace ( v [ 0 ] , v [ 1 ] ) ; } ) ; } ; if ( ( typeof ( content ) === "string" ) && ( content . length > 0 ) ) { // If HTML content with line-breaking tags, then remove all cr/lf chars because only tags will break a line if ( / <(?:p|br|h[1-6]|ul|ol|dl|table|t[rdh]|div|blockquote|fieldset|pre|address|center)[^>]*> / i . test ( content ) ) { process ( [ / [\n\r]+ / g ] ) ; } else { // Otherwise just get rid of carriage returns (only need linefeeds) process ( [ / \r+ / g ] ) ; } process ( [ [ / <\/(?:p|h[1-6]|ul|ol|dl|table|div|blockquote|fieldset|pre|address|center)> / gi , "\n\n" ] , // Block tags get a blank line after them [ / <br[^>]*>|<\/tr> / gi , "\n" ] , // Single linebreak for <br /> tags and table rows [ / <\/t[dh]>\s*<t[dh][^>]*> / gi , "\t" ] , // Table cells get tabs betweem them / <[a-z!\/?][^>]*> / gi , // Delete all remaining tags [ / &nbsp; / gi , " " ] , // Convert non-break spaces to regular spaces (remember, *plain text*) [ / (?:(?!\n)\s)*(\n+)(?:(?!\n)\s)* / gi , "$1" ] // Cool little RegExp deletes whitespace around linebreak chars. ] ) ; var maxLinebreaks = Number ( getParam ( ed , "paste_max_consecutive_linebreaks" ) ) ; if ( maxLinebreaks > - 1 ) { var maxLinebreaksRegex = new RegExp ( "\n{" + ( maxLinebreaks + 1 ) + ",}" , "g" ) ; var linebreakReplacement = "" ; while ( linebreakReplacement . length < maxLinebreaks ) { linebreakReplacement += "\n" ; } process ( [ [ maxLinebreaksRegex , linebreakReplacement ] // Limit max consecutive linebreaks ] ) ; } content = ed . dom . decode ( tinymce . html . Entities . encodeRaw ( content ) ) ; // Perform default or custom replacements if ( is ( rl , "array" ) ) { process ( rl ) ; } else if ( is ( rl , "string" ) ) { process ( new RegExp ( rl , "gi" ) ) ; } // Treat paragraphs as specified in the config if ( linebr == "none" ) { // Convert all line breaks to space process ( [ [ / \n+ / g , " " ] ] ) ; } else if ( linebr == "br" ) { // Convert all line breaks to <br /> process ( [ [ / \n / g , "<br />" ] ] ) ; } else if ( linebr == "p" ) { // Convert all line breaks to <p>...</p> process ( [ [ / \n+ / g , "</p><p>" ] , [ / ^(.*<\/p>)(<p>)$ / , '<p>$1' ] ] ) ; } else { // defaults to "combined" // Convert single line breaks to <br /> and double line breaks to <p>...</p> process ( [ [ / \n\n / g , "</p><p>" ] , [ / ^(.*<\/p>)(<p>)$ / , '<p>$1' ] , [ / \n / g , "<br />" ] ] ) ; } ed . execCommand ( 'mceInsertContent' , false , content ) ; } } 
function ( ) { var t = this , ed = t . editor ; // Register command(s) for backwards compatibility ed . addCommand ( "mcePasteWord" , function ( ) { ed . windowManager . open ( { file : t . url + "/pasteword.htm" , width : parseInt ( getParam ( ed , "paste_dialog_width" ) ) , height : parseInt ( getParam ( ed , "paste_dialog_height" ) ) , inline : 1 } ) ; } ) ; if ( getParam ( ed , "paste_text_use_dialog" ) ) { ed . addCommand ( "mcePasteText" , function ( ) { ed . windowManager . open ( { file : t . url + "/pastetext.htm" , width : parseInt ( getParam ( ed , "paste_dialog_width" ) ) , height : parseInt ( getParam ( ed , "paste_dialog_height" ) ) , inline : 1 } ) ; } ) ; } // Register button for backwards compatibility ed . addButton ( "pasteword" , { title : "paste.paste_word_desc" , cmd : "mcePasteWord" } ) ; } 
function applyGenericOperatorIndex ( r , schema , parent ) { if ( r . type === 'view' ) { if ( r . view === 'reducing-index' ) return r if ( r . view !== 'case' && r . view !== 'default' && 
function init ( ) { * Drawer initialization * * @method init */ O . inherited ( this ) ( 'section' , 'drawer' ) ; this . hook ( ) ; this . hide ( true ) ; this . tree ( 'header' , 'row' ) . button ( 'char' , 'left' , this . hide . bind ( this , false ) ) ; ; this . stub ( 'ul' , 'navigation' ) ; } 
function manager ( map , key ) { if ( ! ( key instanceof Object ) ) { throw new TypeError ( 'Key must be an object' ) } let contents = map . get ( key ) if ( ! contents ) { map . set ( key , contents = { } ) } return contents } 
function end ( ) { var transformed ; if ( ignore . some ( minimatch . bind ( null , file ) ) ) { var compiled = coffee . compile ( data , { sourceMap : true , generatedFile : file , inline : true , bare : options . bare , literate : isLiterate ( file ) } ) ; transformed = compiled . js ; } else { var instrumented = instrumentor . instrumentCoffee ( file , data ) ; var js = options . noInit ? instrumented . js : instrumented . init + instrumented . js ; transformed = js ; } this . queue ( transformed ) ; this . queue ( null ) ; } 
function ( view , initial ) { var me = this , checkbox = me . injectCheckbox , headerCt = view . headerCt ; 
function ( isChecked ) { var view = this . views [ 0 ] , headerCt = view . headerCt , checkHd = headerCt . child ( 'gridcolumn[isCheckerHd]' ) , cls = this . checkerOnCls ; if ( checkHd ) { if ( isChecked ) { checkHd . addCls ( cls ) ; } else { checkHd . removeCls ( cls ) ; } } } 
function ( headerCt , header , e ) { if ( header . isCheckerHd ) { e . stopEvent ( ) ; var me = this , isChecked = header . el . hasCls ( Ext . baseCSSPrefix + 'grid-hd-checker-on' ) ; 
function ( ) { var me = this , showCheck = me . showHeaderCheckbox !== false ; return { isCheckerHd : showCheck , text : '&#160;' , width : me . headerWidth , sortable : false , draggable : false , resizable : false , hideable : false , menuDisabled : true , dataIndex : '' , cls : showCheck ? Ext . baseCSSPrefix + 'column-header-checkbox ' : '' , renderer : Ext . Function . bind ( me . renderer , me ) , editRenderer : me . editRenderer || me . renderEmpty , locked : me . hasLockedHeader ( ) } ; } 
function ( value , metaData , record , rowIndex , colIndex , store , view ) { var baseCSSPrefix = Ext . baseCSSPrefix ; metaData . tdCls = baseCSSPrefix + 'grid-cell-special ' + baseCSSPrefix + 'grid-cell-row-checker' ; return '<div class="' + baseCSSPrefix + 'grid-row-checker">&#160;</div>' ; } 
function ( list ) { var store = list . getStore ( ) ; return Ext . Array . sort ( list . getSelectionModel ( ) . getSelection ( ) , function ( a , b ) { a = store . indexOf ( a ) ; b = store . indexOf ( b ) ; if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } return 0 ; } ) ; } 
function ( ) { var me = this ; me . mixins . field . setValue . call ( me , me . setupValue ( me . toField . store . getRange ( ) ) ) ; } 
function errorIs ( error , criteria ) { if ( ! ( error instanceof Error ) ) { return false ; } if ( ! criteria ) { return true ; } if ( typeof criteria === 'function' ) { return error instanceof criteria ; } var name = error . name || error . constructor && error . constructor . name || '' ; if ( typeof criteria === 'string' ) { return name . toLowerCase ( ) === criteria . toLowerCase ( ) ; } if ( criteria instanceof RegExp ) { return criteria . test ( name ) ; } if ( typeof criteria === 'object' ) { return _lodash2 [ 'default' ] . every ( Object . keys ( criteria ) , function ( key ) { return _lodash2 [ 'default' ] . matchesProperty ( key , criteria [ key ] ) ( error ) ; } ) ; } throw new Error ( 'Unexpected criteria type: ' + criteria ) ; } 
function callRequest ( options , body , otherHeaders ) { const { method , route , form , external , others } = options ; const headers = Object . assign ( { } , options . headers , otherHeaders ) ; if ( external ) { return request ( form , method , route , body , headers , others ) ; } return apiRequest ( form , method , route , body , headers , others ) ; } 
function doPublicRequest ( options , params , body = { } , headers = { } ) { const cloned = cloneDeep ( options ) ; if ( params ) { cloned . route = parameterizeRoute ( cloned . route , params ) ; } return callRequest ( cloned , body , headers ) ; } 
function requestWithToken ( options , params , body = { } , headers = { } , customToken = null , tokenType = 'Bearer' ) { const cloned = cloneDeep ( options ) ; if ( params ) { cloned . route = parameterizeRoute ( cloned . route , params ) ; } const requestHeaders = Object . assign ( { } , headers , { Authorization : ( done ) => { if ( customToken !== null ) { done ( ` ${ tokenType } ${ customToken } ` ) ; } else { Storage . getToken ( options . storageOveride ) . then ( ( storedToken ) => { done ( ` ${ tokenType } ${ storedToken } ` ) ; } ) ; } } , } ) ; return callRequest ( cloned , body , requestHeaders ) ; } 
function ( ) { var me = this , cfg = { app : me , taskbarConfig : me . getTaskbarConfig ( ) } ; Ext . apply ( cfg , me . desktopConfig ) ; return cfg ; } 
function ( ) { var me = this , cfg = { app : me , menu : [ ] } , launcher ; Ext . apply ( cfg , me . startConfig ) ; Ext . each ( me . modules , function ( module ) { launcher = module . launcher ; if ( launcher ) { launcher . handler = launcher . handler || Ext . bind ( me . createWindow , me , [ module ] ) ; cfg . menu . push ( module . launcher ) ; } } ) ; return cfg ; } 
function ( ) { var me = this , cfg = { app : me , startConfig : me . getStartConfig ( ) } ; Ext . apply ( cfg , me . taskbarConfig ) ; return cfg ; } 
function ( id , lastEditId , readyCb ) { 
function ( id , lastEditId , endEditId , isHistorical , readyCb ) { getSnapshotInner ( id , lastEditId , endEditId , readyCb ) } 
function replaceSim ( array , index , removeCount , insert ) { var add = insert ? insert . length : 0 , length = array . length , pos = fixArrayIndex ( array , index ) , remove , tailOldPos , tailNewPos , tailCount , lengthAfterRemove , i ; 
function ( array , fn , scope , reverse ) { array = ExtArray . from ( array ) ; var i , ln = array . length ; if ( reverse !== true ) { for ( i = 0 ; i < ln ; i ++ ) { if ( fn . call ( scope || array [ i ] , array [ i ] , i , array ) === false ) { return i ; } } } else { for ( i = ln - 1 ; i > - 1 ; i -- ) { if ( fn . call ( scope || array [ i ] , array [ i ] , i , array ) === false ) { return i ; } } } return true ; } 
function ( iterable , start , end ) { if ( ! iterable || ! iterable . length ) { return [ ] ; } if ( typeof iterable === 'string' ) { iterable = iterable . split ( '' ) ; } if ( supportsSliceOnNodeList ) { return slice . call ( iterable , start || 0 , end || iterable . length ) ; } var array = [ ] , i ; start = start || 0 ; end = end ? ( ( end < 0 ) ? iterable . length + end : end ) : iterable . length ; for ( i = start ; i < end ; i ++ ) { array . push ( iterable [ i ] ) ; } return array ; } 
function ( array , propertyName ) { var ret = [ ] , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i ++ ) { item = array [ i ] ; ret . push ( item [ propertyName ] ) ; } return ret ; } 
function ( array ) { var results = [ ] , i = 0 , ln = array . length , item ; for ( ; i < ln ; i ++ ) { item = array [ i ] ; if ( ! Ext . isEmpty ( item ) ) { results . push ( item ) ; } } return results ; } 
function ( array ) { var clone = [ ] , i = 0 , ln = array . length , item ; for ( ; i < ln ; i ++ ) { item = array [ i ] ; if ( ExtArray . indexOf ( clone , item ) === - 1 ) { clone . push ( item ) ; } } return clone ; } 
function ( array , fn , scope ) { var i = 0 , len = array . length ; for ( ; i < len ; i ++ ) { if ( fn . call ( scope || array , array [ i ] , i ) ) { return array [ i ] ; } } return null ; } 
function ( value , newReference ) { if ( value === undefined || value === null ) { return [ ] ; } if ( Ext . isArray ( value ) ) { return ( newReference ) ? slice . call ( value ) : value ; } var type = typeof value ; 
function ( array , item ) { var index = ExtArray . indexOf ( array , item ) ; if ( index !== - 1 ) { erase ( array , index , 1 ) ; } return array ; } 
function ( ) { var args = slice . call ( arguments ) , array = [ ] , i , ln ; for ( i = 0 , ln = args . length ; i < ln ; i ++ ) { array = array . concat ( args [ i ] ) ; } return ExtArray . unique ( array ) ; } 
function ( ) { var intersection = [ ] , arrays = slice . call ( arguments ) , arraysLength , array , arrayLength , minArray , minArrayIndex , minArrayCandidate , minArrayLength , element , elementCandidate , elementCount , i , j , k ; if ( ! arrays . length ) { return intersection ; } 
function ( arrayA , arrayB ) { var clone = slice . call ( arrayA ) , ln = clone . length , i , j , lnB ; for ( i = 0 , lnB = arrayB . length ; i < lnB ; i ++ ) { for ( j = 0 ; j < ln ; j ++ ) { if ( clone [ j ] === arrayB [ i ] ) { erase ( clone , j , 1 ) ; j -- ; ln -- ; } } } return clone ; } 
function ( array , begin , end ) { 
function ( array ) { var worker = [ ] ; function rFlatten ( a ) { var i , ln , v ; for ( i = 0 , ln = a . length ; i < ln ; i ++ ) { v = a [ i ] ; if ( Ext . isArray ( v ) ) { rFlatten ( v ) ; } else { worker . push ( v ) ; } } return worker ; } return rFlatten ( array ) ; } 
function ( array , comparisonFn ) { var min = array [ 0 ] , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i ++ ) { item = array [ i ] ; if ( comparisonFn ) { if ( comparisonFn ( min , item ) === 1 ) { min = item ; } } else { if ( item < min ) { min = item ; } } } return min ; } 
function ( array ) { var sum = 0 , i , ln , item ; for ( i = 0 , ln = array . length ; i < ln ; i ++ ) { item = array [ i ] ; sum += item ; } return sum ; } 
function ( array , getKey , scope ) { var map = { } , i = array . length ; if ( ! getKey ) { while ( i -- ) { map [ array [ i ] ] = i + 1 ; } } else if ( typeof getKey == 'string' ) { while ( i -- ) { map [ array [ i ] [ getKey ] ] = i + 1 ; } } else { while ( i -- ) { map [ getKey . call ( scope , array [ i ] ) ] = i + 1 ; } } return map ; } 
function ( array ) { var len = arguments . length , i = 1 , newItem ; if ( array === undefined ) { array = [ ] ; } else if ( ! Ext . isArray ( array ) ) { array = [ array ] ; } for ( ; i < len ; i ++ ) { newItem = arguments [ i ] ; Array . prototype . push [ Ext . isIterable ( newItem ) ? 'apply' : 'call' ] ( array , newItem ) ; } return array ; } 
function ( xpath ) { var me = this , parts = xpath . split ( '/' ) , regex = me . tagPathRegEx , i , n , m , count , tag , child , el = me . attachTo . document ; el = ( parts [ 0 ] == '~' ) ? el . body : el . getElementById ( parts [ 0 ] . substring ( 1 ) ) ; 
function ( eventDescriptor ) { var me = this , index = ++ me . queueIndex ; 
function ( ) { var me = this , queue = me . eventQueue , index = me . queueIndex , eventDescriptor = queue [ index ] , type = eventDescriptor && eventDescriptor . type , tmp ; if ( type == 'mduclick' ) { tmp = [ Ext . applyIf ( { type : 'mousedown' } , eventDescriptor ) , Ext . applyIf ( { type : 'mouseup' } , eventDescriptor ) , Ext . applyIf ( { type : 'click' } , eventDescriptor ) ] ; me . replaceEvent ( index , tmp ) ; } return queue [ index ] || null ; } 
function ( ) { var me = this , animations = me . pauseForAnimations && me . attachTo . Ext . fx . Manager . items , eventDescriptor ; while ( ( eventDescriptor = me . peekEvent ( ) ) !== null ) { if ( animations && animations . getCount ( ) ) { return true ; } if ( eventDescriptor . keyframe ) { if ( ! me . processKeyFrame ( eventDescriptor ) ) { return false ; } me . nextEvent ( eventDescriptor ) ; } else if ( eventDescriptor . ts <= me . getTimeIndex ( ) && me . fireEvent ( 'beforeplay' , me , eventDescriptor ) !== false && me . playEvent ( eventDescriptor ) ) { if ( window . __x && eventDescriptor . screenshot ) { __x . poll . sendSyncRequest ( { cmd : 'screenshot' } ) ; } me . nextEvent ( eventDescriptor ) ; } else { return true ; } } me . stop ( ) ; return false ; } 
function ( eventDescriptor ) { var me = this ; 
function getContentEditable ( node ) { var contentEditable ; // Ignore non elements if ( node . nodeType === 1 ) { // Check for fake content editable contentEditable = node . getAttribute ( internalName ) ; if ( contentEditable && contentEditable !== "inherit" ) { return contentEditable ; } // Check for real content editable contentEditable = node . contentEditable ; if ( contentEditable !== "inherit" ) { return contentEditable ; } } return null ; } 
function getNonEditableParent ( node ) { var state ; while ( node ) { state = getContentEditable ( node ) ; if ( state ) { return state === "false" ? node : null ; } node = node . parentNode ; } } 
function insertCaretContainerOrExpandToBlock ( target , before ) { var caretContainer , rng ; // Select block if ( getContentEditable ( target ) === "false" ) { if ( dom . isBlock ( target ) ) { selection . select ( target ) ; return ; } } rng = dom . createRng ( ) ; if ( getContentEditable ( target ) === "true" ) { if ( ! target . firstChild ) { target . appendChild ( ed . getDoc ( ) . createTextNode ( '\u00a0' ) ) ; } target = target . firstChild ; before = true ; } //caretContainer = dom.create('span', {id: caretContainerId, 'data-mce-bogus': true, style:'border: 1px solid red'}, invisibleChar); caretContainer = dom . create ( 'span' , { id : caretContainerId , 'data-mce-bogus' : true } , invisibleChar ) ; if ( before ) { target . parentNode . insertBefore ( caretContainer , target ) ; } else { dom . insertAfter ( caretContainer , target ) ; } rng . setStart ( caretContainer . firstChild , 1 ) ; rng . collapse ( true ) ; selection . setRng ( rng ) ; return caretContainer ; } 
function removeCaretContainer ( caretContainer ) { var child , currentCaretContainer , lastContainer ; if ( caretContainer ) { rng = selection . getRng ( true ) ; rng . setStartBefore ( caretContainer ) ; rng . setEndBefore ( caretContainer ) ; child = findFirstTextNode ( caretContainer ) ; if ( child && child . nodeValue . charAt ( 0 ) == invisibleChar ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( caretContainer , true ) ; selection . setRng ( rng ) ; } else { currentCaretContainer = getParentCaretContainer ( selection . getStart ( ) ) ; while ( ( caretContainer = dom . get ( caretContainerId ) ) && caretContainer !== lastContainer ) { if ( currentCaretContainer !== caretContainer ) { child = findFirstTextNode ( caretContainer ) ; if ( child && child . nodeValue . charAt ( 0 ) == invisibleChar ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( caretContainer , true ) ; } lastContainer = caretContainer ; } } } 
function moveSelection ( ) { var nonEditableStart , nonEditableEnd , isCollapsed , rng , element ; // Checks if there is any contents to the left/right side of caret returns the noneditable element or any editable element if it finds one inside function hasSideContent ( element , left ) { var container , offset , walker , node , len ; container = rng . startContainer ; offset = rng . startOffset ; // If endpoint is in middle of text node then expand to beginning/end of element if ( container . nodeType == 3 ) { len = container . nodeValue . length ; if ( ( offset > 0 && offset < len ) || ( left ? offset == len : offset == 0 ) ) { return ; } } else { // Can we resolve the node by index if ( offset < container . childNodes . length ) { // Browser represents caret position as the offset at the start of an element. When moving right // this is the element we are moving into so we consider our container to be child node at offset-1 var pos = ! left && offset > 0 ? offset - 1 : offset ; container = container . childNodes [ pos ] ; if ( container . hasChildNodes ( ) ) { container = container . firstChild ; } } else { // If not then the caret is at the last position in it's container and the caret container should be inserted after the noneditable element return ! left ? element : null ; } } // Walk left/right to look for contents walker = new TreeWalker ( container , element ) ; while ( node = walker [ left ? 'prev' : 'next' ] ( ) ) { if ( node . nodeType === 3 && node . nodeValue . length > 0 ) { return ; } else if ( getContentEditable ( node ) === "true" ) { // Found contentEditable=true element return this one to we can move the caret inside it return node ; } } return element ; } ; // Remove any existing caret containers removeCaretContainer ( ) ; // Get noneditable start/end elements isCollapsed = selection . isCollapsed ( ) ; nonEditableStart = getNonEditableParent ( selection . getStart ( ) ) ; nonEditableEnd = getNonEditableParent ( selection . getEnd ( ) ) ; // Is any fo the range endpoints noneditable if ( nonEditableStart || nonEditableEnd ) { rng = selection . getRng ( true ) ; // If it's a caret selection then look left/right to see if we need to move the caret out side or expand if ( isCollapsed ) { nonEditableStart = nonEditableStart || nonEditableEnd ; var start = selection . getStart ( ) ; if ( element = hasSideContent ( nonEditableStart , true ) ) { // We have no contents to the left of the caret then insert a caret container before the noneditable element insertCaretContainerOrExpandToBlock ( element , true ) ; } else if ( element = hasSideContent ( nonEditableStart , false ) ) { // We have no contents to the right of the caret then insert a caret container after the noneditable element insertCaretContainerOrExpandToBlock ( element , false ) ; } else { // We are in the middle of a noneditable so expand to select it selection . select ( nonEditableStart ) ; } } else { rng = selection . getRng ( true ) ; // Expand selection to include start non editable element if ( nonEditableStart ) { rng . setStartBefore ( nonEditableStart ) ; } // Expand selection to include end non editable element if ( nonEditableEnd ) { rng . setEndAfter ( nonEditableEnd ) ; } selection . setRng ( rng ) ; } } } 
function hasSideContent ( element , left ) { var container , offset , walker , node , len ; container = rng . startContainer ; offset = rng . startOffset ; // If endpoint is in middle of text node then expand to beginning/end of element if ( container . nodeType == 3 ) { len = container . nodeValue . length ; if ( ( offset > 0 && offset < len ) || ( left ? offset == len : offset == 0 ) ) { return ; } } else { // Can we resolve the node by index if ( offset < container . childNodes . length ) { // Browser represents caret position as the offset at the start of an element. When moving right // this is the element we are moving into so we consider our container to be child node at offset-1 var pos = ! left && offset > 0 ? offset - 1 : offset ; container = container . childNodes [ pos ] ; if ( container . hasChildNodes ( ) ) { container = container . firstChild ; } } else { // If not then the caret is at the last position in it's container and the caret container should be inserted after the noneditable element return ! left ? element : null ; } } // Walk left/right to look for contents walker = new TreeWalker ( container , element ) ; while ( node = walker [ left ? 'prev' : 'next' ] ( ) ) { if ( node . nodeType === 3 && node . nodeValue . length > 0 ) { return ; } else if ( getContentEditable ( node ) === "true" ) { // Found contentEditable=true element return this one to we can move the caret inside it return node ; } } return element ; } 
function convertRegExpsToNonEditable ( ed , args ) { var i = nonEditableRegExps . length , content = args . content , cls = tinymce . trim ( nonEditClass ) ; // Don't replace the variables when raw is used for example on undo/redo if ( args . format == "raw" ) { return ; } while ( i -- ) { content = content . replace ( nonEditableRegExps [ i ] , function ( match ) { var args = arguments , index = args [ args . length - 2 ] ; // Is value inside an attribute then don't replace if ( index > 0 && content . charAt ( index - 1 ) == '"' ) { return match ; } return '<span class="' + cls + '" data-mce-content="' + ed . dom . encode ( args [ 0 ] ) + '">' + ed . dom . encode ( typeof ( args [ 1 ] ) === "string" ? args [ 1 ] : args [ 0 ] ) + '</span>' ; } ) ; } args . content = content ; } 
function ( ) { var grid = this . editingPlugin . grid , view = grid . normalGrid ? grid . normalGrid . view : grid . view , viewSize = view . componentLayout . lastComponentSize , hasOverflow = viewSize . contentHeight > viewSize . height ; 
function ( cfg ) { Ext . ux . form . TinyMCETextAreaWindowManager . superclass . constructor . call ( this , cfg . editor ) ; this . control = cfg . control ; } 
function ( txt , cb , s ) { Ext . MessageBox . alert ( this . editor . getLang ( "Message" , "Message" ) , this . editor . getLang ( txt , txt ) , function ( ) { if ( ! Ext . isEmpty ( cb ) ) { cb . call ( this ) ; } } , s ) ; } 
function ( txt , cb , s ) { Ext . MessageBox . confirm ( this . editor . getLang ( "Question" , "Question" ) , this . editor . getLang ( txt , txt ) , function ( btn ) { if ( ! Ext . isEmpty ( cb ) ) { cb . call ( this , btn === "yes" ) ; } } , s ) ; } 
function ( win , ti ) { var w = Ext . getCmp ( win . tinyMCEPopup . id ) ; if ( w ) { w . setTitle ( ti ) ; } } 
function ( dw , dh , id ) { var w = Ext . getCmp ( id ) ; if ( ! w ) { return ; } // TinyMCE window manager opens the windows in two steps // // 1. displaying and loading iframe // 2. Adjusting the window size to the iframe // // It has an unbeatufiul eefect of resizing by // opening. Thus, we first open the window in the // invisible area, and center it only when resize is done. var size = w . getSize ( ) ; w . setSize ( size . width + dw , size . height + dh ) ; w . center ( ) ; var tinypopupIframe = w . getComponent ( 'tiny_popup_iframe' ) ; if ( ! tinypopupIframe ) { return ; } var doc = tinypopupIframe . getEl ( ) . dom . contentDocument ; if ( ! doc ) { return ; } // We do not focus in the standard way. It does not work under IE. // The standard focusing occurs too early when using ExtJS windows for the popups. // We do focusing here after resize. tinymce . each ( doc . forms , function ( g ) { tinymce . each ( g . elements , function ( f ) { if ( tinymce . DOM . hasClass ( f , "mceFocus" ) && ! f . disabled ) { f . focus ( ) ; return false ; } } ) ; } ) ; // This fixes the bug under IE - after moving the iframe is not visible. // But, we have to add this event after a delay, otherwise it removes the // focus from the field, what is set above. setTimeout ( function ( ) { w . on ( 'move' , function ( win , x , y , opts ) { tinypopupIframe . getEl ( ) . focus ( ) ; } , w ) ; } , 1500 ) ; } 
function ( s , p ) { var me = this ; Ext . util . Observable . capture ( me . control , function ( ) { return false ; } ) ; // Hide intermediate color popup menu if the more color dialog is displayed. // The z-index of the tinymce color popup menu is higher than that of the ExtJS // windows, and the menu overlaps the ExtJS window. if ( me . editor . controlManager . get ( me . control . getInputId ( ) + '_forecolor' ) ) { me . editor . controlManager . get ( me . control . getInputId ( ) + '_forecolor' ) . hideMenu ( ) ; } if ( me . editor . controlManager . get ( 'mce_fullscreen_forecolor' ) ) { me . editor . controlManager . get ( 'mce_fullscreen_forecolor' ) . hideMenu ( ) ; } if ( me . editor . controlManager . get ( me . control . getInputId ( ) + '_backcolor' ) ) { me . editor . controlManager . get ( me . control . getInputId ( ) + '_backcolor' ) . hideMenu ( ) ; } if ( me . editor . controlManager . get ( 'mce_fullscreen_backcolor' ) ) { me . editor . controlManager . get ( 'mce_fullscreen_backcolor' ) . hideMenu ( ) ; } s = s || { } ; p = p || { } ; if ( ! s . type ) { me . bookmark = me . editor . selection . getBookmark ( 'simple' ) ; } s . width = parseInt ( s . width || 320 , 10 ) ; s . height = parseInt ( s . height || 240 , 10 ) ; s . min_width = parseInt ( s . min_width || 150 , 10 ) ; s . min_height = parseInt ( s . min_height || 100 , 10 ) ; s . max_width = parseInt ( s . max_width || 2000 , 10 ) ; s . max_height = parseInt ( s . max_height || 2000 , 10 ) ; s . movable = true ; s . resizable = true ; p . mce_width = s . width ; p . mce_height = s . height ; p . mce_inline = true ; // We do not focus in the standard way. It does not work under IE. // The standard focusing occurs too early when using ExtJS windows for the popups. // We do focusing in the resizeBy method p . mce_auto_focus = false ; this . features = s ; this . params = p ; this . onOpen . dispatch ( this , s , p ) ; var win = Ext . create ( 'widget.window' , { title : s . name , width : s . width , height : s . height , minWidth : s . min_width , minHeight : s . min_height , resizable : false , maximizable : s . maximizable , minimizable : s . minimizable , modal : true , layout : "fit" , items : [ Ext . create ( 'Ext.Component' , { itemId : 'tiny_popup_iframe' , autoEl : { tag : 'iframe' , src : s . url || s . file } , style : 'border-width: 0px;' } ) ] , listeners : { destroy : function ( win , opts ) { me . onClose . dispatch ( me ) ; Ext . util . Observable . releaseCapture ( me . control ) ; setTimeout ( function ( ) { if ( me . editor ) { if ( ! win . closedOverInlineButton && tinymce . isIE ) { me . editor . selection . moveToBookmark ( me . editor . windowManager . bookmark ) ; } me . editor . focus ( ) ; me . control . popupActive = false ; } } , 300 ) ; } } } ) ; p . mce_window_id = win . getId ( ) ; me . control . popupActive = true ; win . show ( null , function ( ) { // TinyMCE window manager opens the windows in two steps // // 1. displaying and loading iframe // 2. Adjusting the window size to the iframe // // It has an unbeatufiul eefect of resizing after // opening. Thus, we first open the window in the // invisible area, and center it only when resize is done. win . setPagePosition ( - 900 , - 900 ) ; } , me ) ; return win ; } 
function ( win ) { var me = this ; if ( ! win || ! win . tinyMCEPopup || ! win . tinyMCEPopup . id ) { return ; } var w = Ext . getCmp ( win . tinyMCEPopup . id ) ; if ( w ) { w . closedOverInlineButton = true ; w . close ( ) ; } } 
function ( ) { var me = this ; me . callParent ( arguments ) ; // If an element is a child of an invisible container like tab, // there are a number of issues which make the life complicated: // // - The element might not be completely rendered; it will be // completely rendered only when the container becomes visible. // - The size of the element might be unknown until the container becomes // visible. If you do size adjustment, while the container is // not visible, the size might be calculated and set incorrectly. // - No show/hide event is fired for the element self if the container // becomes visible or hidden. The event is fired only for that parent // container, which is being actively shown or hidden. // - You have to attach the event handler to the correct parent container // and do size adjustment only if the container becomes visible. // // We check whether our TinyMCETextArea is a child of a tab panel. If yes, // we attach the event handler to the tab change event and do // size adjustment if the parent tab, which contains our TinyMCETextArea, // becomes visible. // // PS: It will not work if you have a tab control within another tab control! var tabpanel = me . findParentByType ( 'tabpanel' ) ; if ( tabpanel ) { tabpanel . on ( 'tabchange' , function ( tabPanel , newCard , oldCard , eOpts ) { var myCard = me . findParentBy ( function ( cont , elm ) { return cont . getId ( ) === newCard . getId ( ) ; } ) ; if ( myCard ) { me . syncEditorSize ( me . lastWidth , me . lastHeight ) ; } } , me ) ; } me . on ( 'blur' , function ( elm , ev , eOpts ) { var ctrl = document . getElementById ( me . getInputId ( ) ) ; if ( me . wysiwygIntialized ) { var ed = tinymce . get ( me . getInputId ( ) ) ; // In the HTML text modus, the contents should be // synchronized upon the blur event. if ( ed && ed . isHidden ( ) ) { if ( ctrl ) { me . positionBeforeBlur = { start : ctrl . selectionStart , end : ctrl . selectionEnd } ; } ed . load ( ) ; } } else { if ( ctrl ) { me . positionBeforeBlur = { start : ctrl . selectionStart , end : ctrl . selectionEnd } ; } } } , me ) ; me . on ( 'resize' , function ( elm , width , height , oldWidth , oldHeight , eOpts ) { if ( elm . hasVisibleLabel ( ) && ( elm . labelAlign === 'left' || elm . labelAlign === 'right' ) ) { width = width - ( elm . labelWidth + elm . labelPad ) ; } me . lastWidth = width ; me . lastHeight = height ; if ( ! me . noWysiwyg && ! me . wysiwygIntialized ) { me . initEditor ( ) ; } else { me . syncEditorSize ( me . lastWidth , me . lastHeight ) ; } } , me ) ; } 
function ( ) { var me = this ; var widthCorrection = 0 ; if ( Ext . isGecko ) { widthCorrection = - 2 ; } if ( Ext . isOpera ) { widthCorrection = - 2 ; } if ( Ext . isIE ) { widthCorrection = - 2 ; } return widthCorrection ; } 
function ( w , h ) { var me = this ; if ( ! me . wysiwygIntialized || ! me . rendered ) { return ; } var ed = tinymce . get ( me . getInputId ( ) ) ; // if the editor is hidden, we do not syncronize // because the size values of the hidden editor // are calculated wrong. if ( ed . isHidden ( ) ) { return ; } // Unfortunately, the TinyMCE has no setSize method // This method would help enormly and make the integration // very easy. // // So, we have to deal with internal issues of the editor. // We get the height of the tool bar and the status bar and // calculate the height of the content frame. var edTable = Ext . get ( me . getInputId ( ) + "_tbl" ) ; var edIframe = Ext . get ( me . getInputId ( ) + "_ifr" ) ; var edToolbar = edTable . down ( ".mceToolbar" ) ; var edStatusbar = edTable . down ( ".mceStatusbar" ) ; var frameHeight = h - 2 ; if ( edToolbar ) { frameHeight -= edToolbar . getHeight ( ) ; } if ( edStatusbar ) { frameHeight -= edStatusbar . getHeight ( ) ; } edIframe . setHeight ( frameHeight ) ; edTable . setWidth ( w + me . getWidthCorrection ( ) ) ; edTable . setHeight ( h ) ; } 
function ( ) { var me = this ; if ( me . noWysiwyg || me . intializationInProgress || me . wysiwygIntialized ) { return ; } me . intializationInProgress = true ; if ( ! me . tinyMCEConfig ) { me . tinyMCEConfig = { } ; } else { // We need clone, not reference. // The configuration of the wysiwyg might be passed as an object to // many editor instances. Through cloning, we prevent // side effects on other editors upon internal modifications // of the tinyMCEConfig var tmp_cfg = me . tinyMCEConfig ; me . tinyMCEConfig = { } ; Ext . Object . merge ( me . tinyMCEConfig , tmp_cfg ) ; } me . tinyMCEConfig . mode = "exact" ; me . tinyMCEConfig . elements = me . getInputId ( ) ; // This type of resizing s very harmful by integration with ExtJS. // The editor should occupy only the place given to it by the // layout manager. me . tinyMCEConfig . theme_advanced_resizing = false ; // we pass the height and width explicitly to the editor me . tinyMCEConfig . width = me . lastWidth + me . getWidthCorrection ( ) ; me . tinyMCEConfig . height = me . lastHeight ; if ( me . readOnly ) { me . tinyMCEConfig . readonly = true ; me . tinyMCEConfig . height -= 3 ; } if ( me . labelEl ) { me . labelEl . on ( 'click' , function ( ev , elm , opts ) { me . focus ( false ) ; } , me . labelEl ) ; } var user_setup = null ; var user_onchange_callback = null ; if ( me . tinyMCEConfig . setup ) { user_setup = me . tinyMCEConfig . setup ; } if ( me . tinyMCEConfig . onchange_callback ) { user_onchange_callback = me . tinyMCEConfig . onchange_callback ; } me . tinyMCEConfig . onchange_callback = function ( ed ) { var oldval = me . getValue ( ) ; var newval = ed . getContent ( ) ; ed . save ( ) ; me . fireEvent ( 'change' , me , newval , oldval , { } ) ; if ( me . validateOnChange ) { me . validate ( ) ; } if ( user_onchange_callback ) { user_onchange_callback ( ed ) ; } } ; me . tinyMCEConfig . setup = function ( ed ) { ed . onExecCommand . add ( function ( ed , cmd , ui , val ) { if ( cmd !== 'mceFullScreen' ) { return ; } var fullscreen_container = document . getElementById ( "mce_fullscreen_container" ) ; if ( ! fullscreen_container ) { return ; } fullscreen_container . style . zIndex = Ext . ZIndexManager . zBase + 2 ; var fullscreen_ed = tinyMCE . get ( ed . getParam ( 'fullscreen_editor_id' ) ) ; if ( fullscreen_ed ) { fullscreen_ed . windowManager = Ext . create ( 'Ext.ux.form.TinyMCETextAreaWindowManager' , { control : me , editor : fullscreen_ed } ) ; } } ) ; ed . onInit . add ( function ( ed ) { me . wysiwygIntialized = true ; me . intializationInProgress = false ; if ( me . isDisabled ( ) ) { me . disableEditor ( ) ; } tinymce . dom . Event . add ( ed . getWin ( ) , 'focus' , function ( e ) { var w = me . findParentByType ( 'window' ) ; if ( w && ! me . popupActive ) { // we use toFront to bring the parent window // to the front when the editor gets focus. // Under IE10, the editor gets focus, even if // a popup like image insert is opened. This is // bad, because the popup goes into the back, and // the editor to the front. // // We have introduced the flag 'popupActive', // which is set when the popup is opened and unset // when the popup is closed. // // We do not do toFront id the popup is active. w . toFront ( true ) ; } } ) ; } ) ; ed . onPostRender . add ( function ( ed , controlManager ) { ed . windowManager = Ext . create ( 'Ext.ux.form.TinyMCETextAreaWindowManager' , { control : me , editor : ed } ) ; } ) ; if ( user_setup ) { user_setup ( ed ) ; } } ; if ( ! tinymce . dom . Event . domLoaded ) { tinymce . dom . Event . domLoaded = true ; } tinymce . init ( me . tinyMCEConfig ) ; } 
function ( ) { var me = this ; if ( ! me . wysiwygIntialized ) { return true ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ! ed ) { return true ; } return ed . isHidden ( ) ; } 
function ( ) { var me = this ; me . storedCursorPosition = null ; if ( ! me . wysiwygIntialized ) { me . noWysiwyg = false ; me . initEditor ( ) ; return ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { ed . show ( ) ; ed . nodeChanged ( ) ; me . syncEditorSize ( me . lastWidth , me . lastHeight ) ; me . focus ( ) ; } } 
function ( ) { var me = this ; if ( ! me . wysiwygIntialized ) { return ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ! ed ) { return ; } var node = ed . selection . getNode ( ) ; me . storedCursorPosition = null ; // no selection, just hide if ( ! node || node . nodeName === "#document" || node . nodeName === "BODY" || node . nodeName === "body" ) { ed . hide ( ) ; return ; } // otherwise try to position the cursor var marker = '<a id="_____sys__11223___"></a>' ; ed . selection . collapse ( true ) ; ed . execCommand ( 'mceInsertContent' , 0 , marker ) ; ed . hide ( ) ; var ctrl = document . getElementById ( me . getInputId ( ) ) ; var pos = - 1 ; var txt = "" ; if ( ctrl ) { txt = ctrl . value ; pos = txt . indexOf ( marker ) ; } if ( pos !== - 1 ) { var re = new RegExp ( marker , "g" ) ; txt = txt . replace ( re , "" ) ; ctrl . value = txt ; if ( ctrl . setSelectionRange ) { ctrl . focus ( ) ; ctrl . setSelectionRange ( pos , pos ) ; } } } 
function ( ) { var me = this ; if ( ! me . wysiwygIntialized ) { me . showEditor ( ) ; return ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed . isHidden ( ) ) { me . showEditor ( ) ; } else { me . hideEditor ( ) ; } } 
function ( ) { var me = this ; if ( me . intializationInProgress ) { return me ; } if ( ! me . wysiwygIntialized ) { return me ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { ed . save ( ) ; } tinyMCE . execCommand ( 'mceRemoveControl' , false , me . getInputId ( ) ) ; me . wysiwygIntialized = false ; return me ; } 
function ( cfg ) { var me = this ; if ( me . noWysiwyg || me . intializationInProgress ) { return me ; } if ( ! me . tinyMCEConfig ) { me . tinyMCEConfig = { } ; } if ( ! cfg ) { cfg = { } ; } Ext . apply ( me . tinyMCEConfig , cfg ) ; if ( ! me . wysiwygIntialized ) { return me ; } var hidden = true ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { hidden = ed . isHidden ( ) ; ed . save ( ) ; } tinyMCE . execCommand ( 'mceRemoveControl' , false , me . getInputId ( ) ) ; me . wysiwygIntialized = false ; if ( ! hidden ) { me . initEditor ( ) ; } return me ; } 
function ( v ) { var me = this ; var res = me . callParent ( arguments ) ; if ( me . wysiwygIntialized ) { // The editor does some preformatting of the HTML text // entered by the user. // The method setValue sets the value of the textarea. // We have to load the text into editor for the // preformatting and then to save it back to the textarea. var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { ed . load ( ) ; ed . save ( ) ; } } return res ; } 
function ( state ) { var me = this ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ! ed ) { return ; } tinymce . each ( ed . controlManager . controls , function ( c ) { c . setDisabled ( ! state ) ; } ) ; } 
function ( silent ) { var me = this ; if ( ! me . isDisabled ( ) ) { return ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { // We restore contentEditable to true var edIframe = Ext . get ( me . getInputId ( ) + "_ifr" ) ; edIframe . dom . contentDocument . body . contentEditable = true ; // We have luck, because there is this useful internal method // to add all events unbound in the disable command ed . bindNativeEvents ( ) ; me . enableEditorControls ( true ) ; // The call above enables ALL tollbar buttons // It is wrong. We fire this event to force adjusting // of the enabled/disabled state of the buttons to the // actual state of the editor. ed . nodeChanged ( ) ; } return me . callParent ( arguments ) ; } 
function ( ) { var me = this ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed ) { // The body cannot be disabled, // So we remove events from the tinymce . dom . Event . clear ( ed . getBody ( ) ) ; tinymce . dom . Event . clear ( ed . getWin ( ) ) ; tinymce . dom . Event . clear ( ed . getDoc ( ) ) ; tinymce . dom . Event . clear ( ed . formElement ) ; ed . onExecCommand . listeners = [ ] ; // We set the contentEditable to false var edIframe = Ext . get ( me . getInputId ( ) + "_ifr" ) ; edIframe . dom . contentDocument . body . contentEditable = false ; // We disable all tool bar controls me . enableEditorControls ( false ) ; } } 
function ( readOnly ) { var me = this ; var result = me . callParent ( arguments ) ; if ( readOnly !== me . tinyMCEConfig . readonly ) { me . reinitEditor ( { readonly : readOnly } ) ; me . syncEditorSize ( me . lastWidth , me . lastHeight ) ; } return result ; } 
function ( selectText , delay ) { var me = this ; if ( me . isDisabled ( ) ) { return me ; } if ( delay ) { if ( isNaN ( delay ) ) { delay = 10 ; } setTimeout ( function ( ) { me . focus . call ( me , selectText , false ) ; } , delay ) ; return me ; } if ( ! me . wysiwygIntialized ) { return me . callParent ( arguments ) ; } var ed = tinymce . get ( me . getInputId ( ) ) ; if ( ed && ! ed . isHidden ( ) ) { me . callParent ( arguments ) ; ed . focus ( ) ; } else { return me . callParent ( arguments ) ; } return me ; } 
function ( ) { var me = this ; var wwg_mode = false ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( me . wysiwygIntialized ) { if ( ed && ! ed . isHidden ( ) ) { wwg_mode = true ; } } var ctrl = document . getElementById ( me . getInputId ( ) ) ; if ( wwg_mode ) { me . storedCursorPosition = ed . selection . getBookmark ( 'simple' ) ; } else if ( ctrl ) { me . storedCursorPosition = me . positionBeforeBlur ; } } 
function ( ) { var me = this ; if ( ! me . storedCursorPosition ) { return ; } var wwg_mode = false ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( me . wysiwygIntialized ) { if ( ed && ! ed . isHidden ( ) ) { wwg_mode = true ; } } var ctrl = document . getElementById ( me . getInputId ( ) ) ; if ( wwg_mode ) { ed . selection . moveToBookmark ( me . storedCursorPosition ) ; } else if ( ctrl ) { ctrl . setSelectionRange ( me . storedCursorPosition . start , me . storedCursorPosition . end ) ; } } 
function ( txt ) { var me = this ; var wwg_mode = false ; var ed = tinymce . get ( me . getInputId ( ) ) ; if ( me . wysiwygIntialized ) { if ( ed && ! ed . isHidden ( ) ) { wwg_mode = true ; } } var ctrl = document . getElementById ( me . getInputId ( ) ) ; if ( wwg_mode ) { ed . focus ( ) ; ed . execCommand ( 'mceInsertContent' , 0 , txt ) ; } else if ( ctrl ) { ctrl . focus ( ) ; var start = ctrl . selectionStart + txt . length ; ctrl . value = ctrl . value . slice ( 0 , ctrl . selectionStart ) + txt + ctrl . value . slice ( ctrl . selectionEnd ) ; ctrl . setSelectionRange ( start , start ) ; } } 
function ( ) { var me = this , activeError = me . getActiveError ( ) , hasError = ! ! activeError ; var edTable = Ext . get ( me . getInputId ( ) + "_tbl" ) ; var edIframe = Ext . get ( me . getInputId ( ) + "_ifr" ) ; if ( ! edTable ) { return me . callParent ( arguments ) ; } var edFrameContainer = edTable . down ( ".mceIframeContainer" ) ; if ( edFrameContainer && me . rendered && ! me . isDestroyed && ! me . preventMark ) { var ed = tinymce . get ( me . getInputId ( ) ) ; var evHandler = function ( ed , e ) { me . clearInvalid ( ) ; } ; // Add/remove invalid class if ( hasError ) { edFrameContainer . addCls ( 'tinymce-error-field' ) ; // this dirty hack is required for WebKit browsers - Safari and Chrome edIframe . setHeight ( edIframe . getHeight ( ) - 1 ) ; edIframe . setHeight ( edIframe . getHeight ( ) + 1 ) ; if ( ed ) { // the invalid mark should be removed after any // change of the contents (ExtJS standard behaviour) ed . onKeyDown . add ( evHandler ) ; } } else { edFrameContainer . removeCls ( 'tinymce-error-field' ) ; // this dirty hack is required for WebKit browsers - Safari and Chrome edIframe . setHeight ( edIframe . getHeight ( ) - 1 ) ; edIframe . setHeight ( edIframe . getHeight ( ) + 1 ) ; if ( ed ) { ed . onKeyDown . remove ( evHandler ) ; ed . onChange . remove ( evHandler ) ; } } } return me . callParent ( arguments ) ; } 
function parseEnvironment ( env , cfg ) { assume ( cfg ) . is . an ( 'object' ) ; let _default = cfg . level || 'info' ; if ( ! env || env === '' ) { return _default ; } assume ( env ) . is . a ( 'string' ) ; let modules = env . split ( ',' ) . map ( x => x . trim ( ) ) ; for ( let x of modules ) { let tokens = x . split ( ':' ) ; if ( tokens . length < 2 ) { let errStr = 'Log levels must use format name:level ' + 'not ' + tokens . join ( ':' ) ; throw new Error ( errStr ) ; } let level = tokens . slice ( tokens . length - 1 ) [ 0 ] ; let name = tokens . slice ( 0 , tokens . length - 1 ) . join ( ':' ) ; if ( allowedLevels . indexOf ( level ) === - 1 ) { let errStr = 'Invalid log level setting: ' + level ; throw new Error ( errStr ) ; } if ( minimatch ( cfg . name , name ) ) { return level ; } } return _default ; } 
function setupLogger ( name , cfg ) { assume ( name ) . is . a ( 'string' ) ; if ( cfg ) { assume ( cfg ) . is . an ( 'object' ) ; assume ( cfg ) . not . includes ( 'name' ) ; } else { cfg = { } ; } cfg . name = name ; 
function makeCompat ( logger ) { return function ( name ) { return function ( ... x ) { assume ( x ) . is . an ( 'array' ) ; assume ( x . length ) . greaterThan ( 0 ) ; let msg = util . format . apply ( null , x ) ; let level = 'warn' ; let msgObj = { dbgname : name , dbgcmpt : true , } ; if ( msg . match ( / \[alert-operator\] / ) ) { level = 'fatal' ; msgObj . alert = true ; } logger [ level ] . call ( logger , msgObj , msg ) ; } ; } ; } 
function ( picker , date ) { var fields = this . fields , field = this . fields [ picker . itemId ] ; field . setChecked ( true ) ; if ( field == fields . on ) { fields . before . setChecked ( false , true ) ; fields . after . setChecked ( false , true ) ; } else { fields . on . setChecked ( false , true ) ; if ( field == fields . after && this . getFieldValue ( 'before' ) < date ) { fields . before . setChecked ( false , true ) ; } else if ( field == fields . before && this . getFieldValue ( 'after' ) > date ) { fields . after . setChecked ( false , true ) ; } } this . fireEvent ( 'update' , this ) ; picker . up ( 'menu' ) . hide ( ) ; } 
function ( width ) { var me = this , isNum = ( typeof width == 'number' ) ; if ( isNum && me . autoBoxAdjust && ! me . isBorderBox ( ) ) { width -= ( me . getBorderWidth ( "lr" ) + me . getPadding ( "lr" ) ) ; } return ( isNum && width < 0 ) ? 0 : width ; } 
function ( height ) { var me = this , isNum = ( typeof height == "number" ) ; if ( isNum && me . autoBoxAdjust && ! me . isBorderBox ( ) ) { height -= ( me . getBorderWidth ( "tb" ) + me . getPadding ( "tb" ) ) ; } return ( isNum && height < 0 ) ? 0 : height ; } 
function ( attr , defaultValue , prefix ) { var v = this . getStyle ( attr ) , color = prefix || prefix === '' ? prefix : '#' , h , len , i = 0 ; if ( ! v || ( / transparent|inherit / . test ( v ) ) ) { return defaultValue ; } if ( / ^r / . test ( v ) ) { v = v . slice ( 4 , v . length - 1 ) . split ( ',' ) ; len = v . length ; for ( ; i < len ; i ++ ) { h = parseInt ( v [ i ] , 10 ) ; color += ( h < 16 ? '0' : '' ) + h . toString ( 16 ) ; } } else { v = v . replace ( '#' , '' ) ; color += v . length == 3 ? v . replace ( / ^(\w)(\w)(\w)$ / , '$1$1$2$2$3$3' ) : v ; } return ( color . length > 5 ? color . toLowerCase ( ) : defaultValue ) ; } 
function ( opacity , animate ) { var me = this ; if ( ! me . dom ) { return me ; } if ( ! animate || ! me . anim ) { me . setStyle ( 'opacity' , opacity ) ; } else { if ( typeof animate != 'object' ) { animate = { duration : 350 , easing : 'ease-in' } ; } me . animate ( Ext . applyIf ( { to : { opacity : opacity } } , animate ) ) ; } return me ; } 
function ( ) { var me = this , data = ( me . $cache || me . getCache ( ) ) . data , style ; if ( ! data [ ISCLIPPED ] ) { data [ ISCLIPPED ] = true ; style = me . getStyle ( [ OVERFLOW , OVERFLOWX , OVERFLOWY ] ) ; data [ ORIGINALCLIP ] = { o : style [ OVERFLOW ] , x : style [ OVERFLOWX ] , y : style [ OVERFLOWY ] } ; me . setStyle ( OVERFLOW , HIDDEN ) ; me . setStyle ( OVERFLOWX , HIDDEN ) ; me . setStyle ( OVERFLOWY , HIDDEN ) ; } return me ; } 
function ( ) { var me = this , data = ( me . $cache || me . getCache ( ) ) . data , clip ; if ( data [ ISCLIPPED ] ) { data [ ISCLIPPED ] = false ; clip = data [ ORIGINALCLIP ] ; if ( clip . o ) { me . setStyle ( OVERFLOW , clip . o ) ; } if ( clip . x ) { me . setStyle ( OVERFLOWX , clip . x ) ; } if ( clip . y ) { me . setStyle ( OVERFLOWY , clip . y ) ; } } return me ; } 
function ( cls ) { cls = cls || Ext . baseCSSPrefix + 'box' ; var el = Ext . get ( this . insertHtml ( "beforeBegin" , "<div class='" + cls + "'>" + Ext . String . format ( Element . boxMarkup , cls ) + "</div>" ) ) ; Ext . DomQuery . selectNode ( '.' + cls + '-mc' , el . dom ) . appendChild ( this . dom ) ; return el ; } 
function ( ) { var me = this , h = Math . max ( me . dom . offsetHeight , me . dom . clientHeight ) ; if ( ! h ) { h = parseFloat ( me . getStyle ( HEIGHT ) ) || 0 ; if ( ! me . isBorderBox ( ) ) { h += me . getFrameWidth ( 'tb' ) ; } } return h ; } 
function ( ) { var me = this , w = Math . max ( me . dom . offsetWidth , me . dom . clientWidth ) ; if ( ! w ) { w = parseFloat ( me . getStyle ( WIDTH ) ) || 0 ; if ( ! me . isBorderBox ( ) ) { w += me . getFrameWidth ( 'lr' ) ; } } return w ; } 
function ( className , testFn , scope ) { var me = this , dom = me . dom , hasTest = Ext . isFunction ( testFn ) ; me . hover ( function ( ) { if ( hasTest && testFn . call ( scope || me , me ) === false ) { return ; } Ext . fly ( dom , INTERNAL ) . addCls ( className ) ; } , function ( ) { Ext . fly ( dom , INTERNAL ) . removeCls ( className ) ; } ) ; return me ; } 
function ( className , testFn , scope ) { var me = this , dom = me . dom , hasTest = Ext . isFunction ( testFn ) ; me . on ( "mousedown" , function ( ) { if ( hasTest && testFn . call ( scope || me , me ) === false ) { return false ; } Ext . fly ( dom , INTERNAL ) . addCls ( className ) ; var d = Ext . getDoc ( ) , fn = function ( ) { Ext . fly ( dom , INTERNAL ) . removeCls ( className ) ; d . removeListener ( "mouseup" , fn ) ; } ; d . on ( "mouseup" , fn ) ; } ) ; return me ; } 
function ( ) { var me = this , cls = me . verticalCls ; delete me . vertical ; if ( cls ) { delete me . verticalCls ; me . removeCls ( cls ) ; } 
function ( config ) { logger . info ( util . format ( 'Starting SmartRouter... Will listen on port %s' , config . port ) ) ; logger . info ( util . format ( 'Using https: %s' , CONFIG . https . use ) ) ; logger . info ( util . format ( 'RabbitMQ url is set to %s' , config . amqp . url ) ) ; logger . debug ( 'Max Channel per RabbitMQ Connection: ' , this . MAX_CHANNEL_PER_CONNECTION ) ; var self = this ; self . config = config ; self . reconnectDelay = CONFIG . rabbitmqReconnectDelay || 10000 ; self . delayBeforeDeletingInactiveQueue = CONFIG . delayBeforeDeletingInactiveQueue || ( 15 * 60 * 1000 ) ; 
function ( ) { var self = this ; self . io . sockets . on ( 'connection' , function ( socket ) { socket . on ( 'registerNewEndpointId' , function ( newEndpoint ) { var endpointFound = false ; logger . info ( util . format ( 'Request received to register new Endpoint: %s' , JSON . stringify ( newEndpoint ) ) ) ; self . config . endpoints . forEach ( function ( endpoint ) { if ( endpoint . name === newEndpoint . name ) { endpointFound = true ; if ( endpoint . sub . indexOf ( newEndpoint . id ) < 0 ) { var socketendpoint = self . io . of ( '/' + newEndpoint . name + '/' + newEndpoint . id ) ; logger . info ( util . format ( 'Endpoint registered on [/%s/%s]' , newEndpoint . name , newEndpoint . id ) ) ; self . registerRoutes ( newEndpoint . name , newEndpoint . id , endpoint . queue , socketendpoint ) ; endpoint . sub . push ( newEndpoint . id ) ; 
function ( ) { var self = this ; self . config . endpoints . forEach ( function ( endpoint ) { logger . info ( util . format ( 'Registering endpoint %s' , endpoint . name ) ) ; endpoint . sub = endpoint . sub || endpoint . ids ; 
function ( endpointname , endpointid , queuebehaviour , socketep ) { var self = this ; socketep . on ( 'connection' , function ( socket ) { logger . info ( util . format ( 'Connection received on /%s/%s' , endpointname , endpointid ) ) ; socket . emit ( 'whoareyou' , { } ) ; socket . on ( 'iam' , function ( actorid ) { var endpointQueue = endpointname + '/' + endpointid ; if ( ! queuebehaviour || ( ( queuebehaviour & QUEUEFLAG . actor ) > 0 ) ) { self . queueSubscribe ( actorid , actorid , socket ) ; } if ( ( queuebehaviour & QUEUEFLAG . endpoint ) > 0 ) { self . queueSubscribe ( actorid , endpointQueue , socket ) ; } } ) ; socket . on ( 'disconnect' , function ( ) { self . queuesUnsubscribe ( socket ) ; } ) ; self . config . routes . forEach ( function ( route ) { if ( route . endpoint === '*' || route . endpoint === endpointname ) { logger . debug ( util . format ( 'Registering route [%s] for endpoint [%s]. Socket= %s' , route . messagetype , route . endpoint , socket . id ) ) ; socket . on ( route . messagetype , function ( message ) { self . check ( socket , route . messagetype , message , function ( err , checked ) { if ( err ) { logger . error ( err ) ; } if ( checked ) { logger . debug ( util . format ( "Routing '%s' from [%s]. Message=%s" , route . messagetype , endpointname , JSON . stringify ( message ) ) ) ; route . action ( message , socket , self ) ; } } ) ; } ) ; } } ) ; } ) ; } 
function ( actorid , queuename , socket ) { logger . info ( util . format ( 'Subscribing to queue. QueueName=%s; Socket=%s' , queuename , socket . id ) ) ; var self = this ; self . amqp . queue ( queuename , { autoDelete : false , closeChannelOnUnsubscribe : true , arguments : { 'x-expires' : self . delayBeforeDeletingInactiveQueue } } , function ( q ) { q . bind ( queuename ) ; q . subscribe ( function ( message , headers , deliveryInfo ) { logger . debug ( util . format ( "Emitting '%s' from queue [%s] on socket %s" , message . type , queuename , socket . id ) ) ; socket . emit ( message . type , message . message ) ; } ) . addCallback ( function ( ok ) { socket . set ( 'actorid' , actorid , function ( ) { logger . info ( util . format ( 'Queue created and actor [%s] registered. Handshaking.' , actorid ) ) ; socket . emit ( 'hello' , { } ) ; } ) ; var data = { queue : q , ctag : ok . consumerTag } ; logger . debug ( util . format ( 'Registering consumerTag [%s] for queue [%s] in socket %s' , ok . consumerTag , queuename , socket . id ) ) ; socket . get ( 'queueData' , function ( err , queueData ) { queueData = queueData || [ ] ; queueData . push ( data ) ; socket . set ( 'queueData' , queueData ) ; } ) ; } ) ; } ) ; if ( this . amqp . channelCounter >= self . MAX_CHANNEL_PER_CONNECTION && ! self . creatingAmqpConnection ) { self . _createAmqpConnection ( ) ; } } 
function ( socket , type , message , callback ) { var self = this ; socket . get ( 'actorid' , function ( err , id ) { if ( ! id ) { var data = { } ; data . type = type ; data . message = message ; var warnMsg = util . format ( "An unidentified actor tried to post the following message on Socket %s : Type='%s' Message=%s" , socket . id , type , JSON . stringify ( message ) ) ; self . _storeNagiosEvent ( new NagiosCheckResponse ( NagiosCheckResponseCodes . WARNING , EVENTS_CONTROLLER_SUBSYSTEM , warnMsg ) ) ; logger . warn ( warnMsg ) ; socket . emit ( 'whoareyou' , data ) ; return callback ( err , false ) ; } 
function ( destactorid , type , message , socket ) { var self = this ; var qmsg = { } ; qmsg . type = type ; qmsg . message = message ; if ( typeof destactorid !== 'string' ) { logger . error ( "Trying to publish on a bad queue: " + JSON . stringify ( destactorid ) ) ; if ( socket ) 
function init ( type ) { 
function removed ( ) { 
function processCallbacks ( namedRouteParameters , data , req , res , successHandler , errorHandler , callbacks ) { debug ( 'processing callbacks (url: `%s`, namedRouteParameters: `%s`,' + ' data: `%j`)' , req . url , namedRouteParameters , data ) ; var callbackScope = { app : req . app , req : req } , handlerScope = { app : req . app , req : req , res : res } , callbackArguments = _ . union ( successHandler . bind ( handlerScope ) , errorHandler . bind ( handlerScope ) , namedRouteParameters , data ) , index = - 1 , executeCallback = function executeCallback ( callback ) { callback . apply ( callbackScope , callbackArguments ) ; } , runner ; if ( ! _ . isArray ( callbacks ) ) { runner = function ( ) { executeCallback ( callbacks ) ; } ; } else { var finalSuccessHandler = callbackArguments [ 0 ] , stackedSuccessHandler = function stackedSuccessHandler ( ) { index += 1 ; if ( index < callbacks . length ) { executeCallback ( callbacks [ index ] ) ; } else { finalSuccessHandler . apply ( handlerScope , arguments ) ; } } ; callbackArguments [ 0 ] = stackedSuccessHandler ; runner = stackedSuccessHandler ; } try { runner ( ) ; } catch ( err ) { winston . log ( 'error' , 'API callback caused exceptional error' , { source : toString ( ) , apiRoute : req . originalUrl , err : err . toString ( ) || err , stack : err . stack || undefined } ) ; errorHandler . call ( handlerScope , err ) ; } } 
function createExpressJsCallback ( successHandler , errorHandler , callbacks ) { debug ( 'creating express.js callback' ) ; return function handler ( req , res ) { debug ( 'express.js callback called for url `%s`' , req . url ) ; processCallbacks ( _ . values ( req . params ) , req . body , req , res , successHandler , errorHandler , callbacks ) ; } ; } 
function createExpressJsRoute ( url , callbacks , expressJsMethod , app ) { debug ( 'creating express.js route for url `%s`' , url ) ; var self = this , expressJsHandler = createExpressJsCallback ( function success ( apiResult , httpStatusCode ) { httpStatusCode = httpStatusCode || 200 ; this . res . send ( httpStatusCode , apiResult ) ; } , function error ( err ) { var message , stack , httpStatusCode = 500 ; if ( ! _ . isUndefined ( err ) ) { if ( _ . has ( err , 'httpStatusCode' ) ) { httpStatusCode = err . httpStatusCode ; } message = err . toString ( ) || err ; stack = err . stack || undefined ; } this . res . send ( httpStatusCode , message ) ; winston . log ( 'error' , 'API callback stopped with error' , { source : self . toString ( ) , apiRoute : url , err : message , stack : stack } ) ; } , callbacks , app ) ; expressJsMethod . call ( app , url , expressJsHandler ) ; } 
function urlRegexp ( url , keys , sensitive , strict ) { if ( url . toString ( ) === '[object RegExp]' ) { return url ; } if ( Array . isArray ( url ) ) { url = '(' + url . join ( '|' ) + ')' ; } url = url . concat ( strict ? '' : '/?' ) . replace ( / \/\( / g , '(?:/' ) . replace ( / (\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)? / g , function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash || '' ; return '' + ( optional ? '' : slash ) + '(?:' + ( optional ? slash : '' ) + ( format || '' ) + ( capture || ( format && '([^/.]+?)' || '([^/]+?)' ) ) + ')' + ( optional || '' ) + ( star ? '(/*)?' : '' ) ; } ) . replace ( / ([\/.]) / g , '\\$1' ) . replace ( / \* / g , '(.*)' ) ; return new RegExp ( '^' + url + '$' , sensitive ? '' : 'i' ) ; } 
function extractParams ( match , keys , params ) { params = params || { } ; for ( var i = 1 , l = match . length ; i < l ; ++ i ) { var key = keys [ i - 1 ] ; var val = 'string' === typeof match [ i ] ? decodeURIComponent ( match [ i ] ) : match [ i ] ; if ( key ) { params [ key . name ] = val ; } else { params . push ( val ) ; } } } 
function matchRoute ( method , url , apiRoutes , params ) { debug ( 'matching route method %s with url %s' , method , url ) ; var routes = apiRoutes [ method ] , matchedRoute ; for ( var routeUrl in routes ) { var route = routes [ routeUrl ] , keys = route . keys , match = route . regexp . exec ( url ) ; if ( match ) { matchedRoute = route ; extractParams ( match , keys , params ) ; break ; } } debug ( 'matched route `%j`' , matchedRoute ) ; return matchedRoute ; } 
function addRoute ( method , url , callbacks ) { debug ( 'adding route (method: `%s`, url: `%s`)' , method , url ) ; var urlParamKeys = [ ] , regexp = urlRegexp ( url , urlParamKeys , true , true ) ; if ( _ . isUndefined ( this . apiRoutes ) ) { this . apiRoutes = { } ; } if ( _ . isUndefined ( this . apiRoutes [ method ] ) ) { this . apiRoutes [ method ] = { } ; } createExpressJsRoute . call ( this , url , callbacks , this . app [ method ] , this . app ) ; this . apiRoutes [ method ] [ url ] = { callback : callbacks , regexp : regexp , keys : urlParamKeys } ; } 
function createRouteFactories ( ) { var self = this ; _ . each ( httpMethods , function ( httpMethod ) { self [ httpMethod ] = function ( url , callback ) { addRoute . call ( self , httpMethod , url , callback ) ; } ; } ) ; if ( _ . has ( self , 'delete' ) ) { self . del = self [ 'delete' ] ; } } 
function dispatchLocalApiCall ( httpMethod , url , data , options ) { debug ( 'dispatching local api call (httpMethod: `%s`, url: `%s`)' , httpMethod , url ) ; var self = this , params = { } , matchedRoute = matchRoute ( httpMethod , url , this . apiRoutes , params ) ; options = options || { } ; if ( _ . isUndefined ( matchedRoute ) ) { if ( _ . has ( options , 'error' ) ) { options . error ( new Error ( 'Could not resolve API route: ' + url ) ) ; } else { winston . log ( 'info' , 'Could not resolve API route' , { source : toString ( ) , apiRoute : url } ) ; } } var successHandler = function successHandler ( apiResult ) { if ( _ . has ( options , 'success' ) ) { options . success ( apiResult ) ; } else { winston . log ( 'info' , 'No success callback defined' , { source : self . toString ( ) , apiRoute : url } ) ; } } , errorHandler = function errorHandler ( err ) { var message , stack ; if ( ! _ . isUndefined ( err ) ) { message = err . toString ( ) || err ; stack = err . stack || undefined ; } if ( _ . has ( options , 'error' ) ) { options . error ( err ) ; } else { winston . log ( 'info' , 'No error callback defined' , { source : toString ( ) , apiRoute : url } ) ; } winston . log ( 'error' , 'API callback stopped with error' , { source : self . toString ( ) , apiRoute : url , err : message , stack : stack } ) ; } ; processCallbacks ( _ . values ( params ) , data , this . req , { } , successHandler , errorHandler , matchedRoute . callback ) ; } 
function sync ( method , model , options ) { var url = options . url || _ . result ( model , 'url' ) , httpMethod = methodMap [ method ] , data ; debug ( 'syncing (method: `%s`, httpMethod: `%s`, url: `%s`, model: `%j`)' , method , httpMethod , url , model ) ; if ( _ . isUndefined ( url ) ) { throw new Error ( 'No url present for syncing!' , model , options ) ; } if ( method !== 'read' && method !== 'delete' ) { data = model . toJSON ( ) ; } this . dispatchLocalApiCall ( httpMethod , url , data , options ) ; } 
function ( e , target ) { var me = this , item , record ; if ( Ext . fly ( target ) . hasCls ( me . labelSelector ) && ! me . editing && ! e . ctrlKey && ! e . shiftKey ) { e . stopEvent ( ) ; item = me . view . findItemByChild ( target ) ; record = me . view . store . getAt ( me . view . indexOf ( item ) ) ; me . startEdit ( target , record . data [ me . dataIndex ] ) ; me . activeRecord = record ; } else if ( me . editing ) { me . field . blur ( ) ; e . preventDefault ( ) ; } } 
function ( dir ) { var cmd = path . normalize ( config . bin ) ; if ( config . jdependChart !== undefined ) { cmd += ' --jdepend-chart=' + config . jdependChart ; } if ( config . jdependXml !== undefined ) { cmd += ' --jdepend-xml=' + config . jdependXml ; } if ( config . overviewPyramid !== undefined ) { cmd += ' --overview-pyramid=' + config . overviewPyramid ; } if ( config . summaryXml !== undefined ) { cmd += ' --summary-xml=' + config . summaryXml ; } if ( config . coderankMode !== undefined ) { cmd += ' --coderank-mode=' + config . coderankMode ; } if ( config . coverageReport !== undefined ) { cmd += ' --coverage-report=' + config . coverageReport ; } if ( config . configuration !== undefined ) { cmd += ' --configuration=' + config . configuration ; } if ( config . ignoreDirectories !== undefined ) { cmd += ' --ignore=' + config . ignoreDirectories ; } if ( config . debug ) { cmd += ' --debug ' ; } return cmd ; } 
function canonicalMd5 ( md5 ) { if ( md5 ) { if ( Buffer . isBuffer ( md5 ) ) md5 = md5 . toString ( 'base64' ) else if ( md5 && md5 . match ( / ^md5- / ) ) md5 = md5 . replace ( / ^md5- / , '' ) if ( md5 . length === 32 ) md5 = new Buffer ( md5 , 'hex' ) . toString ( 'base64' ) } return md5 } 
function ( ) { var me = this ; 
function ( attrs , redraw ) { var me = this , fontProps = me . fontProperties , fontPropsLength = fontProps . length , pathProps = me . pathProperties , pathPropsLength = pathProps . length , hasSurface = ! ! me . surface , custom = hasSurface && me . surface . customAttributes || { } , spriteAttrs = me . attr , dirtyBBox = false , attr , i , newTranslation , translation , newRotate , rotation , newScaling , scaling ; attrs = Ext . apply ( { } , attrs ) ; for ( attr in custom ) { if ( attrs . hasOwnProperty ( attr ) && typeof custom [ attr ] == "function" ) { Ext . apply ( attrs , custom [ attr ] . apply ( me , [ ] . concat ( attrs [ attr ] ) ) ) ; } } 
function ( ) { var me = this ; if ( me . fireEvent ( 'beforedestroy' , me ) !== false ) { me . remove ( ) ; me . surface . onDestroy ( me ) ; me . clearListeners ( ) ; me . fireEvent ( 'destroy' ) ; } } 
function expressify ( fn , ignis ) { var status = arguments . length <= 2 || arguments [ 2 ] === undefined ? 200 : arguments [ 2 ] ; return function ( req , res , next ) { return _bluebird2 [ 'default' ] [ 'try' ] ( function ( ) { return fn ( ignis , req ) ; } ) . then ( function ( data ) { res . status ( status ) . send ( data ) ; next ( ) ; } ) [ 'catch' ] ( next ) ; } ; } 
function ( options ) { this . astStack = new ASTStack ( ) ; this . tags = options . customTags ; this . raw = '' ; this . disableParseTag = false ; this . line = 1 ; this . lineStart = 0 ; this . position = 0 ; this . parseTagStack = [ ] ; this . forItems = [ ] ; this . tablerowItems = [ ] ; this . forItems . test = this . tablerowItems . test = function ( name ) { var name = name . split ( '.' ) [ 0 ] ; return this . indexOf ( name ) === - 1 ? false : true ; } ; } 
function ( text , context ) { var astList = parseVariables ( text , context ) ; if ( Array . isArray ( astList ) ) { if ( astList [ 2 ] === OPCODE . LOCALS ) { return context . astNode ( OPCODE . PRINTLOCALS ) . concat ( astList . slice ( 3 ) ) ; } else { return context . astNode ( OPCODE . PRINT , astList ) ; } } else { return context . astNode ( OPCODE . PRINTSTRING , astList ) ; } } 
function ( context , text ) { var i = text . indexOf ( ' ' ) ; if ( i === - 1 ) { var name = text ; var body = '' ; } else { var name = text . slice ( 0 , i ) . replace ( / ^\s+|\s+$ / g , '' ) ; var body = text . slice ( i + 1 ) . trim ( ) ; } name = name . toLowerCase ( ) ; if ( typeof ( context . tags [ name ] ) === 'function' ) { context . tags [ name ] ( context , name , body ) ; } else { context . astStack . push ( context . astNode ( OPCODE . UNKNOWN_TAG , name , body ) ) ; } } 
function join_plugins ( plugins ) { debug . assert ( plugins ) . is ( 'array' ) ; debug . assert ( ARRAY ( plugins ) . every ( is . func ) ) . equals ( true ) ; return function join_plugins_ ( req , res , next ) { var queue = [ ] . concat ( plugins ) ; function do_iteration_ ( ) { if ( queue . length === 0 ) { next ( ) ; return ; } var plugin = queue . shift ( ) ; debug . assert ( plugin ) . is ( 'function' ) ; plugin ( req , res , function plugin_wrapper ( err ) { if ( err ) { next ( err ) ; return ; } do_iteration_ ( ) ; } ) ; } function do_iteration ( ) { try { do_iteration_ ( ) ; } catch ( err ) { next ( err ) ; return ; } } do_iteration ( ) ; } ; } 
function fix_for_missing_req_route ( target , method ) { debug . assert ( target ) . is ( 'string' ) ; debug . assert ( method ) . is ( 'string' ) ; return function the_fixer ( req , res , next ) { debug . assert ( req ) . is ( 'object' ) ; debug . assert ( res ) . is ( 'object' ) ; debug . assert ( next ) . is ( 'function' ) ; if ( req . route === undefined ) { req . route = { 'path' : target , 'method' : method } ; } next ( ) ; } ; } 
function setup_member ( context , k ) { var handler ; var routes = context . routes ; var opts = context . opts ; var middleware = context . middleware ; var app = context . app ; var target = context . target ; var loop_counter = context . loop_counter ; var v = routes [ k ] ; var v_is_function = is . func ( v ) ? true : false ; 
function accept_file ( filename , state ) { state = state || { } ; debug . assert ( filename ) . is ( 'string' ) ; debug . assert ( state ) . is ( 'object' ) ; if ( ! state . file ) { return ; } var ext = PATH . extname ( filename ) ; return ( ext === '.js' ) ? true : false ; } 
function accept_dir ( filename , state ) { state = state || { } ; debug . assert ( filename ) . is ( 'string' ) ; debug . assert ( state ) . is ( 'object' ) ; if ( ! state . directory ) { return ; } return true ; } 
function accept_multi ( filename , state ) { state = state || { } ; debug . assert ( filename ) . is ( 'string' ) ; debug . assert ( state ) . is ( 'object' ) ; if ( state . directory ) { return accept_dir ( filename , state ) ; } if ( state . file ) { return accept_file ( filename , state ) ; } return ; } 
function makeDefine ( mapping , id ) { var require = function ( id ) { return mapping [ id ] ; } ; var exports = mapping [ id ] = { } ; var module = null ; 
function selectInside ( edits , innerId ) { var inside = false 
function binarySearchNext ( arr , value ) { var low = 0 , high = arr . length - 1 , i , comparison ; while ( low <= high ) { i = Math . floor ( ( low + high ) / 2 ) ; if ( arr [ i ] < value ) { low = i + 1 ; continue ; } ; if ( arr [ i ] > value ) { high = i - 1 ; continue ; } ; return i ; } return i ; } 
function ( template_engine_reference , root_directory , current_directory , template_extensions , delimiter_symbol ) { files = fs . readdirSync ( current_directory ) ; for ( var i = 0 ; i < files . length ; i ++ ) { var fullPath = path . join ( current_directory , files [ i ] ) ; stat = fs . statSync ( fullPath ) ; if ( stat . isFile ( ) ) { var file_extension = path . extname ( fullPath ) . slice ( 1 ) ; if ( _ . indexOf ( template_extensions , file_extension ) != - 1 ) { var template = fs . readFileSync ( fullPath , 'utf8' ) ; var partial_name_space = fsHelper . getDirDifference ( root_directory , fullPath ) ; partial_name_space = partial_name_space . replace ( / \\ / g , delimiter_symbol ) ; console . log ( 'Loading Partial into Handlebars engine.' ) ; console . log ( '\tPartial Name Space: ' + partial_name_space ) ; console . log ( '\tFull Path to NameSpace: ' + fullPath ) ; console . log ( '-----------------------------------------' ) ; template_engine_reference . registerPartial ( partial_name_space , template ) ; } } } var subdirectories = fsHelper . getDirPathsSync ( current_directory ) ; for ( var i = 0 ; i < subdirectories . length ; i ++ ) { loadPartials ( template_engine_reference , root_directory , subdirectories [ i ] , template_extensions , delimiter_symbol ) ; } } 
function ( options ) { // TODO: validate that the strings passed in don't have invalid characters either if ( options . engine_reference ) { validateEngineReference ( options . engine_reference ) } else { new Error ( 'An engine reference is a required property in order to use partial-loader. Please provide this in the functional that calls this.' ) } if ( options . template_root_directories ) { options . template_root_directories = validateTemplateRootDirectories ( options . template_root_directories ) ; } else { new Error ( 'The "template_root_directories" is a required property in order to use partial-loader. Please provide this in the function that calls this.' ) } if ( options . partials_directory_names ) { options . partials_directory_names = validatePartialDirectoryNames ( options . partials_directory_names ) ; } else { new Error ( 'The "template_partials_directory(s)" is a required property in order to use partial-loader. Please provide this in the functional that calls this.' ) } if ( options . template_extensions ) { options . template_extensions = validateTemplateExtensions ( options . template_extensions ) ; } else { new Error ( 'The "template_extensions" is a required property in order to use partial-loader. Please provide this in the functional that calls this.' ) } } 
function ( config , value ) { if ( value === undefined || value === null ) { return false ; } var length = value . length , min = config . min , max = config . max ; if ( ( min && length < min ) || ( max && length > max ) ) { return false ; } else { return true ; } } 
function ( config , value ) { return config . list && Ext . Array . indexOf ( config . list , value ) != - 1 ; } 
function ( root , action ) { var parts , ns , i , l ; root = root || Ext . global ; parts = action . toString ( ) . split ( '.' ) ; for ( i = 0 , l = parts . length ; i < l ; i ++ ) { ns = parts [ i ] ; root = root [ ns ] ; if ( typeof root === 'undefined' ) { return root ; } } return root ; } 
function ( ) { var me = this , actions = me . actions , namespace = me . namespace , action , cls , methods , i , len , method ; for ( action in actions ) { if ( actions . hasOwnProperty ( action ) ) { if ( me . disableNestedActions ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } } else { cls = me . getNamespace ( namespace , action ) ; if ( ! cls ) { cls = me . createNamespaces ( namespace , action ) ; } } methods = actions [ action ] ; for ( i = 0 , len = methods . length ; i < len ; ++ i ) { method = new Ext . direct . RemotingMethod ( methods [ i ] ) ; cls [ method . name ] = me . createHandler ( action , method ) ; } } } } 
function ( action , method ) { var me = this , slice = Array . prototype . slice , handler ; if ( ! method . formHandler ) { handler = function ( ) { me . configureRequest ( action , method , slice . call ( arguments , 0 ) ) ; } ; } else { handler = function ( form , callback , scope ) { me . configureFormRequest ( action , method , form , callback , scope ) ; } ; } handler . directCfg = { action : action , method : method } ; return handler ; } 
function ( transaction , event ) { var success = ! ! event . status , funcName = success ? 'success' : 'failure' , callback , options , result ; if ( transaction && transaction . callback ) { callback = transaction . callback ; options = transaction . callbackOptions ; result = typeof event . result !== 'undefined' ? event . result : event . data ; if ( Ext . isFunction ( callback ) ) { callback ( result , event , success , options ) ; } else { Ext . callback ( callback [ funcName ] , callback . scope , [ result , event , success , options ] ) ; Ext . callback ( callback . callback , callback . scope , [ result , event , success , options ] ) ; } } } 
function ( options , success , response ) { var me = this , i , len , events , event , transaction , transactions ; if ( success ) { events = me . createEvents ( response ) ; for ( i = 0 , len = events . length ; i < len ; ++ i ) { event = events [ i ] ; transaction = me . getTransaction ( event ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction && me . fireEvent ( 'beforecallback' , me , event , transaction ) !== false ) { me . runCallback ( transaction , event , true ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( i = 0 , len = transactions . length ; i < len ; ++ i ) { transaction = me . getTransaction ( transactions [ i ] ) ; if ( transaction && transaction . retryCount < me . maxRetries ) { transaction . retry ( ) ; } else { event = new Ext . direct . ExceptionEvent ( { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server.' , xhr : response } ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction && me . fireEvent ( 'beforecallback' , me , transaction ) !== false ) { me . runCallback ( transaction , event , false ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } } } 
function ( options ) { return options && options . tid ? Ext . direct . Manager . getTransaction ( options . tid ) : null ; } 
function ( action , method , args ) { var me = this , callData , data , callback , scope , opts , transaction , params ; callData = method . getCallData ( args ) ; data = callData . data ; callback = callData . callback ; scope = callData . scope ; opts = callData . options || { } ; params = Ext . apply ( { } , { provider : me , args : args , action : action , method : method . name , data : data , callbackOptions : opts , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( opts . timeout ) { Ext . applyIf ( params , { timeout : opts . timeout } ) ; } ; transaction = new Ext . direct . Transaction ( params ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; me . queueTransaction ( transaction ) ; me . fireEvent ( 'call' , me , transaction , method ) ; } } 
function ( transaction ) { return { action : transaction . action , method : transaction . method , data : transaction . data , type : 'rpc' , tid : transaction . id } ; } 
function ( transaction ) { var me = this , enableBuffer = me . enableBuffer ; if ( transaction . form ) { me . sendFormRequest ( transaction ) ; return ; } if ( typeof transaction . timeout !== 'undefined' ) { me . sendRequest ( transaction ) ; return ; } if ( enableBuffer ) { me . callBuffer . push ( transaction ) ; if ( ! me . callTask ) { me . callTask = new Ext . util . DelayedTask ( me . combineAndSend , me ) ; } me . callTask . delay ( Ext . isNumber ( enableBuffer ) ? enableBuffer : 10 ) ; } else { me . combineAndSend ( ) ; } } 
function ( ) { var me = this , buffer = me . callBuffer , len = buffer . length ; if ( len > 0 ) { me . sendRequest ( len == 1 ? buffer [ 0 ] : buffer ) ; me . callBuffer = [ ] ; } } 
function ( find , replace , str ) { // On IE9 we have to fake $x replacement if ( isRegExpBroken ) { return str . replace ( find , function ( ) { var val = replace , args = arguments , i ; for ( i = 0 ; i < args . length - 2 ; i ++ ) { if ( args [ i ] === undef ) { val = val . replace ( new RegExp ( '\\$' + i , 'g' ) , '' ) ; } else { val = val . replace ( new RegExp ( '\\$' + i , 'g' ) , args [ i ] ) ; } } return val ; } ) ; } return str . replace ( find , replace ) ; } 
function createLookupTable ( option , default_value , extend ) { var value = settings [ option ] ; if ( ! value ) { // Get cached default map or make it if needed value = mapCache [ option ] ; if ( ! value ) { value = makeMap ( default_value , ' ' , makeMap ( default_value . toUpperCase ( ) , ' ' ) ) ; value = tinymce . extend ( value , extend ) ; mapCache [ option ] = value ; } } else { // Create custom map value = makeMap ( value , ',' , makeMap ( value . toUpperCase ( ) , ' ' ) ) ; } return value ; } 
function addCustomElements ( custom_elements ) { var customElementRegExp = / ^(~)?(.+)$ / ; if ( custom_elements ) { each ( split ( custom_elements ) , function ( rule ) { var matches = customElementRegExp . exec ( rule ) , inline = matches [ 1 ] === '~' , cloneName = inline ? 'span' : 'div' , name = matches [ 2 ] ; children [ name ] = children [ cloneName ] ; customElementsMap [ name ] = cloneName ; // If it's not marked as inline then add it to valid block elements if ( ! inline ) { blockElementsMap [ name . toUpperCase ( ) ] = { } ; blockElementsMap [ name ] = { } ; } // Add elements clone if needed if ( ! elements [ name ] ) { elements [ name ] = elements [ cloneName ] ; } // Add custom elements at span/div positions each ( children , function ( element , child ) { if ( element [ cloneName ] ) element [ name ] = element [ cloneName ] ; } ) ; } ) ; } } 
function walk ( node , root_node , prev ) { var sibling , parent , startName = prev ? 'lastChild' : 'firstChild' , siblingName = prev ? 'prev' : 'next' ; // Walk into nodes if it has a start if ( node [ startName ] ) return node [ startName ] ; // Return the sibling if it has one if ( node !== root_node ) { sibling = node [ siblingName ] ; if ( sibling ) return sibling ; // Walk up the parents to look for siblings for ( parent = node . parent ; parent && parent !== root_node ; parent = parent . parent ) { sibling = parent [ siblingName ] ; if ( sibling ) return sibling ; } } } 
function ( node ) { var contentEditable ; // Check type if ( node . nodeType != 1 ) { return null ; } // Check for fake content editable contentEditable = node . getAttribute ( "data-mce-contenteditable" ) ; if ( contentEditable && contentEditable !== "inherit" ) { return contentEditable ; } // Check for real content editable return node . contentEditable !== "inherit" ? node . contentEditable : null ; } 
function getRange ( ) { var ieRange = selection . getRng ( ) , domRange = dom . createRng ( ) , element , collapsed , tmpRange , element2 , bookmark , fail ; // If selection is outside the current document just return an empty range element = ieRange . item ? ieRange . item ( 0 ) : ieRange . parentElement ( ) ; if ( element . ownerDocument != dom . doc ) return domRange ; collapsed = selection . isCollapsed ( ) ; // Handle control selection if ( ieRange . item ) { domRange . setStart ( element . parentNode , dom . nodeIndex ( element ) ) ; domRange . setEnd ( domRange . startContainer , domRange . startOffset + 1 ) ; return domRange ; } function findEndPoint ( start ) { var endPoint = getPosition ( ieRange , start ) , container , offset , textNodeOffset = 0 , sibling , undef , nodeValue ; container = endPoint . node ; offset = endPoint . offset ; if ( endPoint . inside && ! container . hasChildNodes ( ) ) { domRange [ start ? 'setStart' : 'setEnd' ] ( container , 0 ) ; return ; } if ( offset === undef ) { domRange [ start ? 'setStartBefore' : 'setEndAfter' ] ( container ) ; return ; } if ( endPoint . position < 0 ) { sibling = endPoint . inside ? container . firstChild : container . nextSibling ; if ( ! sibling ) { domRange [ start ? 'setStartAfter' : 'setEndAfter' ] ( container ) ; return ; } if ( ! offset ) { if ( sibling . nodeType == 3 ) domRange [ start ? 'setStart' : 'setEnd' ] ( sibling , 0 ) ; else domRange [ start ? 'setStartBefore' : 'setEndBefore' ] ( sibling ) ; return ; } // Find the text node and offset while ( sibling ) { nodeValue = sibling . nodeValue ; textNodeOffset += nodeValue . length ; // We are at or passed the position we where looking for if ( textNodeOffset >= offset ) { container = sibling ; textNodeOffset -= offset ; textNodeOffset = nodeValue . length - textNodeOffset ; break ; } sibling = sibling . nextSibling ; } } else { // Find the text node and offset sibling = container . previousSibling ; if ( ! sibling ) return domRange [ start ? 'setStartBefore' : 'setEndBefore' ] ( container ) ; // If there isn't any text to loop then use the first position if ( ! offset ) { if ( container . nodeType == 3 ) domRange [ start ? 'setStart' : 'setEnd' ] ( sibling , container . nodeValue . length ) ; else domRange [ start ? 'setStartAfter' : 'setEndAfter' ] ( sibling ) ; return ; } while ( sibling ) { textNodeOffset += sibling . nodeValue . length ; // We are at or passed the position we where looking for if ( textNodeOffset >= offset ) { container = sibling ; textNodeOffset -= offset ; break ; } sibling = sibling . previousSibling ; } } domRange [ start ? 'setStart' : 'setEnd' ] ( container , textNodeOffset ) ; } ; try { // Find start point findEndPoint ( true ) ; // Find end point if needed if ( ! collapsed ) findEndPoint ( ) ; } catch ( ex ) { // IE has a nasty bug where text nodes might throw "invalid argument" when you // access the nodeValue or other properties of text nodes. This seems to happend when // text nodes are split into two nodes by a delete/backspace call. So lets detect it and try to fix it. if ( ex . number == - 2147024809 ) { // Get the current selection bookmark = self . getBookmark ( 2 ) ; // Get start element tmpRange = ieRange . duplicate ( ) ; tmpRange . collapse ( true ) ; element = tmpRange . parentElement ( ) ; // Get end element if ( ! collapsed ) { tmpRange = ieRange . duplicate ( ) ; tmpRange . collapse ( false ) ; element2 = tmpRange . parentElement ( ) ; element2 . innerHTML = element2 . innerHTML ; } // Remove the broken elements element . innerHTML = element . innerHTML ; // Restore the selection self . moveToBookmark ( bookmark ) ; // Since the range has moved we need to re-get it ieRange = selection . getRng ( ) ; // Find start point findEndPoint ( true ) ; // Find end point if needed if ( ! collapsed ) findEndPoint ( ) ; } else throw ex ; // Throw other errors } return domRange ; } 
function findTextNodeRelative ( left , startNode ) { var walker , lastInlineElement ; startNode = startNode || container ; walker = new TreeWalker ( startNode , dom . getParent ( startNode . parentNode , dom . isBlock ) || body ) ; // Walk left until we hit a text node we can move to or a block/br/img while ( node = walker [ left ? 'prev' : 'next' ] ( ) ) { // Found text node that has a length if ( node . nodeType === 3 && node . nodeValue . length > 0 ) { container = node ; offset = left ? node . nodeValue . length : 0 ; normalized = true ; return ; } // Break if we find a block or a BR/IMG/INPUT etc if ( dom . isBlock ( node ) || nonEmptyElementsMap [ node . nodeName . toLowerCase ( ) ] ) { return ; } lastInlineElement = node ; } // Only fetch the last inline element when in caret mode for now if ( collapsed && lastInlineElement ) { container = lastInlineElement ; normalized = true ; offset = 0 ; } } 
function done ( ) { dom . remove ( id ) ; if ( elm ) elm . onreadystatechange = elm . onload = elm = null ; callback ( ) ; } 
function ( ) { var contextMenu , menuItems , t = this ; contextMenu = DOM . get ( 'menu_' + t . id ) ; menuItems = DOM . select ( 'a[role=option]' , 'menu_' + t . id ) ; menuItems . splice ( 0 , 0 , contextMenu ) ; t . keyboardNav = new tinymce . ui . KeyboardNavigation ( { root : 'menu_' + t . id , items : menuItems , onCancel : function ( ) { t . hideMenu ( ) ; } , enableUpDown : true } ) ; contextMenu . focus ( ) ; } 
function loadScripts ( ) { if ( s . language && s . language_load !== false ) sl . add ( tinymce . baseURL + '/langs/' + s . language + '.js' ) ; if ( s . theme && typeof s . theme != "function" && s . theme . charAt ( 0 ) != '-' && ! ThemeManager . urls [ s . theme ] ) ThemeManager . load ( s . theme , 'themes/' + s . theme + '/editor_template' + tinymce . suffix + '.js' ) ; each ( explode ( s . plugins ) , function ( p ) { if ( p && ! PluginManager . urls [ p ] ) { if ( p . charAt ( 0 ) == '-' ) { p = p . substr ( 1 , p . length ) ; var dependencies = PluginManager . dependencies ( p ) ; each ( dependencies , function ( dep ) { var defaultSettings = { prefix : 'plugins/' , resource : dep , suffix : '/editor_plugin' + tinymce . suffix + '.js' } ; dep = PluginManager . createUrl ( defaultSettings , dep ) ; PluginManager . load ( dep . resource , dep ) ; } ) ; } else { // Skip safari plugin, since it is removed as of 3.3b1 if ( p == 'safari' ) { return ; } PluginManager . load ( p , { prefix : 'plugins/' , resource : p , suffix : '/editor_plugin' + tinymce . suffix + '.js' } ) ; } } } ) ; // Init when que is loaded sl . loadQueue ( function ( ) { if ( ! t . removed ) t . init ( ) ; } ) ; } 
function ( ) { var self = this , body , parent ; // Check if the editor was hidden and the re-initalize contentEditable mode by removing and adding the body again if ( self . _isHidden ( ) ) { body = self . getBody ( ) ; parent = body . parentNode ; parent . removeChild ( body ) ; parent . appendChild ( body ) ; body . focus ( ) ; } } 
function eventHandler ( evt , args ) { var type = evt . type ; // Don't fire events when it's removed if ( self . removed ) return ; // Sends the native event out to a global dispatcher then to the specific event dispatcher if ( self . onEvent . dispatch ( self , evt , args ) !== false ) { self [ nativeToDispatcherMap [ evt . fakeType || evt . type ] ] . dispatch ( self , evt , args ) ; } } 
function handleShortcut ( e , execute ) { if ( e . altKey || e . ctrlKey || e . metaKey ) { each ( self . shortcuts , function ( shortcut ) { var ctrlState = tinymce . isMac ? e . metaKey : e . ctrlKey ; if ( shortcut . ctrl != ctrlState || shortcut . alt != e . altKey || shortcut . shift != e . shiftKey ) return ; if ( e . keyCode == shortcut . keyCode || ( e . charCode && e . charCode == shortcut . charCode ) ) { e . preventDefault ( ) ; if ( execute ) { shortcut . func . call ( shortcut . scope ) ; } return true ; } } ) ; } } 
function ( command ) { if ( selection . isCollapsed ( ) ) selection . select ( selection . getNode ( ) ) ; execNativeCommand ( command ) ; selection . collapse ( FALSE ) ; } 
function ( command ) { var listElm , listParent ; execNativeCommand ( command ) ; // WebKit produces lists within block elements so we need to split them // we will replace the native list creation logic to custom logic later on // TODO: Remove this when the list creation logic is removed listElm = dom . getParent ( selection . getNode ( ) , 'ol,ul' ) ; if ( listElm ) { listParent = listElm . parentNode ; // If list is within a text block then split that block if ( / ^(H[1-6]|P|ADDRESS|PRE)$ / . test ( listParent . nodeName ) ) { storeSelection ( ) ; dom . split ( listParent , listElm ) ; restoreSelection ( ) ; } } } 
function ( command ) { var name = 'align' + command . substring ( 7 ) ; var nodes = selection . isCollapsed ( ) ? [ dom . getParent ( selection . getNode ( ) , dom . isBlock ) ] : selection . getSelectedBlocks ( ) ; var matches = tinymce . map ( nodes , function ( node ) { return ! ! formatter . matchNode ( node , name ) ; } ) ; return tinymce . inArray ( matches , TRUE ) !== - 1 ; } 
function matchName ( node , format ) { // Check for inline match if ( isEq ( node , format . inline ) ) return TRUE ; // Check for block match if ( isEq ( node , format . block ) ) return TRUE ; // Check for selector match if ( format . selector ) return dom . is ( node , format . selector ) ; } 
function removeCaretContainer ( node , move_caret ) { var child , rng ; if ( ! node ) { node = getParentCaretContainer ( selection . getStart ( ) ) ; if ( ! node ) { while ( node = dom . get ( caretContainerId ) ) { removeCaretContainer ( node , false ) ; } } } else { rng = selection . getRng ( true ) ; if ( isCaretContainerEmpty ( node ) ) { if ( move_caret !== false ) { rng . setStartBefore ( node ) ; rng . setEndBefore ( node ) ; } dom . remove ( node ) ; } else { child = findFirstTextNode ( node ) ; if ( child . nodeValue . charAt ( 0 ) === INVISIBLE_CHAR ) { child = child . deleteData ( 0 , 1 ) ; } dom . remove ( node , 1 ) ; } selection . setRng ( rng ) ; } } 
function unmarkBogusCaretParents ( ) { var i , caretContainer , node ; caretContainer = getParentCaretContainer ( selection . getStart ( ) ) ; if ( caretContainer && ! dom . isEmpty ( caretContainer ) ) { tinymce . walk ( caretContainer , function ( node ) { if ( node . nodeType == 1 && node . id !== caretContainerId && ! dom . isEmpty ( node ) ) { dom . setAttrib ( node , 'data-mce-bogus' , null ) ; } } , 'childNodes' ) ; } } 
function renderBlockOnIE ( block ) { var oldRng ; if ( tinymce . isIE && dom . isBlock ( block ) ) { oldRng = selection . getRng ( ) ; block . appendChild ( dom . create ( 'span' , null , '\u00a0' ) ) ; selection . select ( block ) ; block . lastChild . outerHTML = '' ; selection . setRng ( oldRng ) ; } } 
function trimInlineElementsOnLeftSideOfBlock ( block ) { var node = block , firstChilds = [ ] , i ; // Find inner most first child ex: <p><i><b>*</b></i></p> while ( node = node . firstChild ) { if ( dom . isBlock ( node ) ) { return ; } if ( node . nodeType == 1 && ! nonEmptyElementsMap [ node . nodeName . toLowerCase ( ) ] ) { firstChilds . push ( node ) ; } } i = firstChilds . length ; while ( i -- ) { node = firstChilds [ i ] ; if ( ! node . hasChildNodes ( ) || ( node . firstChild == node . lastChild && node . firstChild . nodeValue === '' ) ) { dom . remove ( node ) ; } else { // Remove <a> </a> see #5381 if ( node . nodeName == "A" && ( node . innerText || node . textContent ) === ' ' ) { dom . remove ( node ) ; } } } } 
function moveToCaretPosition ( root ) { var walker , node , rng , y , viewPort , lastNode = root , tempElm ; rng = dom . createRng ( ) ; if ( root . hasChildNodes ( ) ) { walker = new TreeWalker ( root , root ) ; while ( node = walker . current ( ) ) { if ( node . nodeType == 3 ) { rng . setStart ( node , 0 ) ; rng . setEnd ( node , 0 ) ; break ; } if ( nonEmptyElementsMap [ node . nodeName . toLowerCase ( ) ] ) { rng . setStartBefore ( node ) ; rng . setEndBefore ( node ) ; break ; } lastNode = node ; node = walker . next ( ) ; } if ( ! node ) { rng . setStart ( lastNode , 0 ) ; rng . setEnd ( lastNode , 0 ) ; } } else { if ( root . nodeName == 'BR' ) { if ( root . nextSibling && dom . isBlock ( root . nextSibling ) ) { // Trick on older IE versions to render the caret before the BR between two lists if ( ! documentMode || documentMode < 9 ) { tempElm = dom . create ( 'br' ) ; root . parentNode . insertBefore ( tempElm , root ) ; } rng . setStartBefore ( root ) ; rng . setEndBefore ( root ) ; } else { rng . setStartAfter ( root ) ; rng . setEndAfter ( root ) ; } } else { rng . setStart ( root , 0 ) ; rng . setEnd ( root , 0 ) ; } } selection . setRng ( rng ) ; // Remove tempElm created for old IE:s dom . remove ( tempElm ) ; viewPort = dom . getViewPort ( editor . getWin ( ) ) ; // scrollIntoView seems to scroll the parent window in most browsers now including FF 3.0b4 so it's time to stop using it and do it our selfs y = dom . getPos ( root ) . y ; if ( y < viewPort . y || y + 25 > viewPort . y + viewPort . h ) { editor . getWin ( ) . scrollTo ( 0 , y < viewPort . y ? y : y - viewPort . h + 25 ) ; // Needs to be hardcoded to roughly one line of text if a huge text block is broken into two blocks } } 
function createNewBlock ( name ) { var node = container , block , clonedNode , caretNode ; block = name || parentBlockName == "TABLE" ? dom . create ( name || newBlockName ) : parentBlock . cloneNode ( false ) ; caretNode = block ; // Clone any parent styles if ( settings . keep_styles !== false ) { do { if ( / ^(SPAN|STRONG|B|EM|I|FONT|STRIKE|U)$ / . test ( node . nodeName ) ) { // Never clone a caret containers if ( node . id == '_mce_caret' ) { continue ; } clonedNode = node . cloneNode ( false ) ; dom . setAttrib ( clonedNode , 'id' , '' ) ; // Remove ID since it needs to be document unique if ( block . hasChildNodes ( ) ) { clonedNode . appendChild ( block . firstChild ) ; block . appendChild ( clonedNode ) ; } else { caretNode = clonedNode ; block . appendChild ( clonedNode ) ; } } } while ( node = node . parentNode ) ; } // BR is needed in empty blocks on non IE browsers if ( ! tinymce . isIE ) { caretNode . innerHTML = '<br data-mce-bogus="1">' ; } return block ; } 
function wrapSelfAndSiblingsInDefaultBlock ( container , offset ) { var newBlock , parentBlock , startNode , node , next , blockName = newBlockName || 'P' ; // Not in a block element or in a table cell or caption parentBlock = dom . getParent ( container , dom . isBlock ) ; if ( ! parentBlock || ! canSplitBlock ( parentBlock ) ) { parentBlock = parentBlock || editableRoot ; if ( ! parentBlock . hasChildNodes ( ) ) { newBlock = dom . create ( blockName ) ; parentBlock . appendChild ( newBlock ) ; rng . setStart ( newBlock , 0 ) ; rng . setEnd ( newBlock , 0 ) ; return newBlock ; } // Find parent that is the first child of parentBlock node = container ; while ( node . parentNode != parentBlock ) { node = node . parentNode ; } // Loop left to find start node start wrapping at while ( node && ! dom . isBlock ( node ) ) { startNode = node ; node = node . previousSibling ; } if ( startNode ) { newBlock = dom . create ( blockName ) ; startNode . parentNode . insertBefore ( newBlock , startNode ) ; // Start wrapping until we hit a block node = startNode ; while ( node && ! dom . isBlock ( node ) ) { next = node . nextSibling ; newBlock . appendChild ( node ) ; node = next ; } // Restore range to it's past location rng . setStart ( container , offset ) ; rng . setEnd ( container , offset ) ; } } return container ; } 
function handleEmptyListItem ( ) { function isFirstOrLastLi ( first ) { var node = containerBlock [ first ? 'firstChild' : 'lastChild' ] ; // Find first/last element since there might be whitespace there while ( node ) { if ( node . nodeType == 1 ) { break ; } node = node [ first ? 'nextSibling' : 'previousSibling' ] ; } return node === parentBlock ; } ; newBlock = newBlockName ? createNewBlock ( newBlockName ) : dom . create ( 'BR' ) ; if ( isFirstOrLastLi ( true ) && isFirstOrLastLi ( ) ) { // Is first and last list item then replace the OL/UL with a text block dom . replace ( newBlock , containerBlock ) ; } else if ( isFirstOrLastLi ( true ) ) { // First LI in list then remove LI and add text block before list containerBlock . parentNode . insertBefore ( newBlock , containerBlock ) ; } else if ( isFirstOrLastLi ( ) ) { // Last LI in list then temove LI and add text block after list dom . insertAfter ( newBlock , containerBlock ) ; renderBlockOnIE ( newBlock ) ; } else { // Middle LI in list the split the list and insert a text block in the middle // Extract after fragment and insert it after the current block tmpRng = rng . cloneRange ( ) ; tmpRng . setStartAfter ( parentBlock ) ; tmpRng . setEndAfter ( containerBlock ) ; fragment = tmpRng . extractContents ( ) ; dom . insertAfter ( fragment , containerBlock ) ; dom . insertAfter ( newBlock , containerBlock ) ; } dom . remove ( parentBlock ) ; moveToCaretPosition ( newBlock ) ; undoManager . add ( ) ; } 
function hasRightSideBr ( ) { var walker = new TreeWalker ( container , parentBlock ) , node ; while ( node = walker . current ( ) ) { if ( node . nodeName == 'BR' ) { return true ; } node = walker . next ( ) ; } } 
function insertBr ( ) { var brElm , extraBr , marker ; if ( container && container . nodeType == 3 && offset >= container . nodeValue . length ) { // Insert extra BR element at the end block elements if ( ! tinymce . isIE && ! hasRightSideBr ( ) ) { brElm = dom . create ( 'br' ) ; rng . insertNode ( brElm ) ; rng . setStartAfter ( brElm ) ; rng . setEndAfter ( brElm ) ; extraBr = true ; } } brElm = dom . create ( 'br' ) ; rng . insertNode ( brElm ) ; // Rendering modes below IE8 doesn't display BR elements in PRE unless we have a \n before it if ( tinymce . isIE && parentBlockName == 'PRE' && ( ! documentMode || documentMode < 8 ) ) { brElm . parentNode . insertBefore ( dom . doc . createTextNode ( '\r' ) , brElm ) ; } // Insert temp marker and scroll to that marker = dom . create ( 'span' , { } , '&nbsp;' ) ; brElm . parentNode . insertBefore ( marker , brElm ) ; selection . scrollIntoView ( marker ) ; dom . remove ( marker ) ; if ( ! extraBr ) { rng . setStartAfter ( brElm ) ; rng . setEndAfter ( brElm ) ; } else { rng . setStartBefore ( brElm ) ; rng . setEndBefore ( brElm ) ; } selection . setRng ( rng ) ; undoManager . add ( ) ; } 
function ( el , prefix ) { var me = this , sandboxPrefix = '' ; el = Ext . getDom ( el , true ) || { } ; if ( el === document ) { el . id = me . documentId ; } else if ( el === window ) { el . id = me . windowId ; } if ( ! el . id ) { if ( me . isSandboxed ) { sandboxPrefix = Ext . sandboxName . toLowerCase ( ) + '-' ; } el . id = sandboxPrefix + ( prefix || "ext-gen" ) + ( ++ Ext . idSeed ) ; } return el . id ; } 
function ( ) { var ln = arguments . length , i , arg ; for ( i = 0 ; i < ln ; i ++ ) { arg = arguments [ i ] ; if ( arg ) { if ( Ext . isArray ( arg ) ) { this . destroy . apply ( this , arg ) ; } else if ( Ext . isFunction ( arg . destroy ) ) { arg . destroy ( ) ; } else if ( arg . dom ) { arg . remove ( ) ; } } } } 
function ( callback , scope , args , delay ) { if ( Ext . isFunction ( callback ) ) { args = args || [ ] ; scope = scope || window ; if ( delay ) { Ext . defer ( callback , delay , scope , args ) ; } else { callback . apply ( scope , args ) ; } } } 
function ( is , regex ) { var m ; return ( is && ( m = regex . exec ( Ext . userAgent ) ) ) ? parseFloat ( m [ 1 ] ) : 0 ; } 
function ( o ) { if ( ! Ext . isReady ) { Ext . onReady ( function ( ) { Ext . addBehaviors ( o ) ; } ) ; } else { var cache = { } , 
function ( dest , source , names , usePrototypeKeys ) { if ( typeof names == 'string' ) { names = names . split ( / [,;\s] / ) ; } var n , nLen = names ? names . length : 0 , name ; for ( n = 0 ; n < nLen ; n ++ ) { name = names [ n ] ; if ( usePrototypeKeys || source . hasOwnProperty ( name ) ) { dest [ name ] = source [ name ] ; } } return dest ; } 
function ( o ) { for ( var i = 1 , a = arguments , len = a . length ; i < len ; i ++ ) { Ext . destroy ( o [ a [ i ] ] ) ; delete o [ a [ i ] ] ; } } 
function ( arr , truth ) { var ret = [ [ ] , [ ] ] , a , v , aLen = arr . length ; for ( a = 0 ; a < aLen ; a ++ ) { v = arr [ a ] ; ret [ ( truth && truth ( v , a , arr ) ) || ( ! truth && v ) ? 0 : 1 ] . push ( v ) ; } return ret ; } 
function ( arr , methodName ) { var ret = [ ] , args = Array . prototype . slice . call ( arguments , 2 ) , a , v , aLen = arr . length ; for ( a = 0 ; a < aLen ; a ++ ) { v = arr [ a ] ; if ( v && typeof v [ methodName ] == 'function' ) { ret . push ( v [ methodName ] . apply ( v , args ) ) ; } else { ret . push ( undefined ) ; } } return ret ; } 
function ( ) { var parts = Ext . partition ( arguments , function ( val ) { return typeof val != 'function' ; } ) , arrs = parts [ 0 ] , fn = parts [ 1 ] [ 0 ] , len = Ext . max ( Ext . pluck ( arrs , "length" ) ) , ret = [ ] , i , j , aLen ; for ( i = 0 ; i < len ; i ++ ) { ret [ i ] = [ ] ; if ( fn ) { ret [ i ] = fn . apply ( fn , Ext . pluck ( arrs , i ) ) ; } else { for ( j = 0 , aLen = arrs . length ; j < aLen ; j ++ ) { ret [ i ] . push ( arrs [ j ] [ i ] ) ; } } } return ret ; } 
function ( items , connector ) { var length = items . length , head , tail ; if ( length <= 1 ) { return items [ 0 ] ; } else { head = items . slice ( 0 , length - 1 ) ; tail = items [ length - 1 ] ; return Ext . util . Format . format ( "{0} {1} {2}" , head . join ( ", " ) , connector || 'and' , tail ) ; } } 
function report ( node , needed , gotten , loc , isLastNodeCheck ) { var msgContext = { needed : needed , type : indentType , characters : needed === 1 ? "character" : "characters" , gotten : gotten } ; var indentChar = indentType === "space" ? " " : "\t" ; function getFixerFunction ( ) { var rangeToFix = [ ] ; if ( needed > gotten ) { var spaces = "" + new Array ( needed - gotten + 1 ) . join ( indentChar ) ; 
function getFixerFunction ( ) { var rangeToFix = [ ] ; if ( needed > gotten ) { var spaces = "" + new Array ( needed - gotten + 1 ) . join ( indentChar ) ; 
function getNodeIndent ( node , byLastLine , excludeCommas ) { var token = byLastLine ? context . getLastToken ( node ) : context . getFirstToken ( node ) ; var src = context . getSource ( token , token . loc . start . column ) ; var regExp = excludeCommas ? indentPattern . excludeCommas : indentPattern . normal ; var indent = regExp . exec ( src ) ; return indent ? indent [ 0 ] . length : 0 ; } 
function isNodeFirstInLine ( node , byEndLocation ) { var firstToken = byEndLocation === true ? context . getLastToken ( node , 1 ) : context . getTokenBefore ( node ) , startLine = byEndLocation === true ? node . loc . end . line : node . loc . start . line , endLine = firstToken ? firstToken . loc . end . line : - 1 ; return startLine !== endLine ; } 
function isNodeFirstArgument ( node ) { if ( ! node . parent . arguments ) { return false ; } return equal ( node , node . parent . arguments [ 0 ] ) ; 
function checkNodeIndent ( node , indent , excludeCommas ) { var nodeIndent = getNodeIndent ( node , false , excludeCommas ) ; if ( node . type !== "ArrayExpression" && node . type !== "ObjectExpression" && nodeIndent !== indent && isNodeFirstInLine ( node ) ) { report ( node , indent , nodeIndent ) ; } } 
function checkNodesIndent ( nodes , indent , excludeCommas ) { nodes . forEach ( function ( node ) { if ( node . type === "IfStatement" && node . alternate ) { var elseToken = context . getTokenBefore ( node . alternate ) ; checkNodeIndent ( elseToken , indent , excludeCommas ) ; } checkNodeIndent ( node , indent , excludeCommas ) ; } ) ; } 
function checkLastNodeLineIndent ( node , lastLineIndent ) { var lastToken = context . getLastToken ( node ) ; var endIndent = getNodeIndent ( lastToken , true ) ; if ( endIndent !== lastLineIndent && isNodeFirstInLine ( node , true ) ) { report ( node , lastLineIndent , endIndent , { line : lastToken . loc . start . line , column : lastToken . loc . start . column } , true ) ; } } 
function checkFirstNodeLineIndent ( node , firstLineIndent ) { var startIndent = getNodeIndent ( node , false ) ; if ( startIndent !== firstLineIndent && isNodeFirstInLine ( node ) ) { report ( node , firstLineIndent , startIndent , { line : node . loc . start . line , column : node . loc . start . column } ) ; } } 
function getVariableDeclaratorNode ( node ) { var parent = node . parent ; while ( parent . type !== "VariableDeclarator" && parent . type !== "Program" ) { parent = parent . parent ; } return parent . type === "VariableDeclarator" ? parent : null ; } 
function checkIndentInFunctionBlock ( node ) { 
function isSingleLineNode ( node ) { var lastToken = context . getLastToken ( node ) , startLine = node . loc . start . line , endLine = lastToken . loc . end . line ; return startLine === endLine ; } 
function isFirstArrayElementOnSameLine ( node ) { if ( node . type === "ArrayExpression" && node . elements [ 0 ] ) { return node . elements [ 0 ] . loc . start . line === node . loc . start . line && node . elements [ 0 ] . type === "ObjectExpression" ; } else { return false ; } } 
function checkIndentInArrayOrObjectBlock ( node ) { 
function isNodeBodyBlock ( node ) { return node . type === "BlockStatement" || ( node . body && node . body . type === "BlockStatement" ) || ( node . consequent && node . consequent . type === "BlockStatement" ) ; } 
function blockIndentationCheck ( node ) { 
function checkIndentInVariableDeclarations ( node ) { var elements = filterOutSameLineVars ( node ) ; var nodeIndent = getNodeIndent ( node ) ; var lastElement = elements [ elements . length - 1 ] ; var elementsIndent = nodeIndent + indentSize * options . VariableDeclarator [ node . kind ] ; 
function expectedCaseIndent ( node , switchIndent ) { var switchNode = ( node . type === "SwitchStatement" ) ? node : node . parent ; var caseIndent ; if ( caseIndentStore [ switchNode . loc . start . line ] ) { return caseIndentStore [ switchNode . loc . start . line ] ; } else { if ( typeof switchIndent === "undefined" ) { switchIndent = getNodeIndent ( switchNode ) ; } if ( switchNode . cases . length > 0 && options . SwitchCase === 0 ) { caseIndent = switchIndent ; } else { caseIndent = switchIndent + ( indentSize * options . SwitchCase ) ; } caseIndentStore [ switchNode . loc . start . line ] = caseIndent ; return caseIndent ; } } 
function toJSON ( ) { var self = this , keys = self . keys ( ) , serializedStore = { } ; _ . each ( keys , function ( key ) { var modelOrCollection = self . get ( key ) , jsonRepresentation = modelOrCollection . toJSON ( ) , identifier = self . findRegisteredIdentifier . call ( self , modelOrCollection ) ; if ( identifier ) { var serializedData = { dataStoreModelIdentifier : identifier , data : jsonRepresentation } ; serializedStore [ key ] = serializedData ; } else { throw new Error ( 'Could not serialize DataStore because ' + 'a required modelOrCollection was not registered before!' ) ; } } ) ; debug ( 'to json `%j`' , serializedStore ) ; return serializedStore ; } 
function factory ( name , attrs , fn ) { if ( arguments . length === 2 ) { fn = attrs ; attrs = null ; } factories . get ( name ) . create ( attrs , fn ) ; } 
function define ( type , Model ) { if ( arguments . length === 1 ) { Model = type ; type = Model . prototype . __type || Model . modelName ; } var factory = new Factory ( Model ) ; factories . set ( type , factory ) return factory ; } 
function list ( type , num , fn ) { var records = [ ] ; var bail = false ; var created = function ( err , record ) { if ( bail ) return ; if ( err ) { bail = true ; return fn ( err ) ; } records . push ( record ) ; if ( records . length === num ) { fn ( null , records ) ; } } ; for ( var i = 0 ; i < num ; i ++ ) { factory ( type , created ) ; } } 
function ( size , units ) { 
function ( box , units ) { var a = this . addUnits , b = this . parseBox ( box ) ; return a ( b . top , units ) + ' ' + a ( b . right , units ) + ' ' + a ( b . bottom , units ) + ' ' + a ( b . left , units ) ; } 
function ( prop ) { 
function ( ) { return Math . max ( ! Ext . isStrict ? document . body . scrollHeight : document . documentElement . scrollHeight , this . getViewportHeight ( ) ) ; } 
function makeSelectionRestoreFn ( activeEl , start , end ) { return function ( ) { activeEl . selectionStart = start ; activeEl . selectionEnd = end ; } ; } 
function plugins_render ( req , res ) { 
function ( el , values , returnElement ) { var newNode = Ext . DomHelper . overwrite ( Ext . getDom ( el ) , this . apply ( values ) ) ; return returnElement ? Ext . get ( newNode ) : newNode ; } 
function ( instance , name ) { var tpl = instance [ name ] , 
function ( iterable = null ) { this . front = null ; this . back = null ; this . length = 0 ; if ( iterable !== null ) { for ( let value of iterable ) this . push ( value ) ; } } 
function LoaderCache ( options ) { if ( ! ( this instanceof LoaderCache ) ) { return new LoaderCache ( options ) ; } this . options = options || { } ; this . defaultType = this . options . defaultType || 'sync' ; this . types = [ ] ; this . decorate ( 'resolve' ) ; this . decorate ( 'get' ) ; } 
function ( type , options , fn ) { if ( arguments . length === 1 ) { return this [ type ] . iterator . fn ; } if ( typeof options === 'function' ) { fn = options ; options = { } ; } this [ type ] = new LoaderType ( options , fn . bind ( this ) ) ; this . setLoaderType ( type ) ; return this ; } 
function ( name ) { var args = utils . slice ( arguments , 1 ) ; var opts = args . shift ( ) ; var type = this . getLoaderType ( opts ) ; this [ type ] . set ( name , this [ type ] . resolve ( args ) ) ; return this ; } 
function ( name , options , stack ) { var args = utils . slice ( arguments ) ; var opts = { } ; name = args . shift ( ) ; if ( ! utils . isLoader ( options ) && lazy . isObject ( options ) ) { opts = args . shift ( ) ; } opts = opts || { } ; var type = this . getLoaderType ( opts ) ; opts . loaderType = type ; var inst = this [ type ] ; var iterator = this . iterator ( type ) ; stack = inst . resolve ( inst . get ( name ) . concat ( args ) ) ; var ctx = { app : this } ; ctx . options = opts ; ctx . iterator = inst . iterator ; ctx . loaders = inst ; return function ( ) { var args = [ ] . slice . call ( arguments ) . filter ( Boolean ) ; var len = args . length , loaders = [ ] ; while ( len -- > 1 ) { var arg = args [ len ] ; if ( ! utils . isLoader ( arg ) ) break ; loaders . unshift ( args . pop ( ) ) ; } 
function Asorted ( ) { this . array = [ ] ; this . sortBy = ( arguments [ 0 ] && arguments [ 0 ] . sortBy ) ? arguments [ 0 ] . sortBy : false ; var index = this . sortBy ? 1 : 0 ; var length = arguments . length ; while ( index < length ) { this . insert ( arguments [ index ] ) ; index ++ ; } } 
function ( record ) { var val = record . get ( this . dataIndex ) ; if ( typeof val != 'string' ) { return ( this . getValue ( ) . length === 0 ) ; } return val . toLowerCase ( ) . indexOf ( this . getValue ( ) . toLowerCase ( ) ) > - 1 ; } 
function ( cmp ) { var me = this , newTab = cmp , oldTab ; if ( Ext . isString ( cmp ) ) { newTab = Ext . getCmp ( newTab ) ; } if ( newTab === me . activeTab ) { return false ; } oldTab = me . activeTab ; if ( me . fireEvent ( 'beforetabchange' , me , newTab , oldTab ) !== false ) { me . activeTab = newTab ; if ( me . rendered ) { me . down ( 'container[baseCls=' + Ext . baseCSSPrefix + 'grouptabcontainer' + ']' ) . getLayout ( ) . setActiveItem ( newTab ) ; } me . fireEvent ( 'tabchange' , me , newTab , oldTab ) ; } return true ; } 
function ( cmp ) { var me = this , newGroup = cmp , oldGroup ; if ( Ext . isString ( cmp ) ) { newGroup = Ext . getCmp ( newGroup ) ; } if ( newGroup === me . activeGroup ) { return true ; } oldGroup = me . activeGroup ; if ( me . fireEvent ( 'beforegroupchange' , me , newGroup , oldGroup ) !== false ) { me . activeGroup = newGroup ; me . fireEvent ( 'groupchange' , me , newGroup , oldGroup ) ; } else { return false ; } return true ; } 
function ( ) { var me = this , delimiter = me . delimiter , val = me . getValue ( ) ; return Ext . isString ( delimiter ) ? val . join ( delimiter ) : val ; } 
function compile ( content , options ) { options = merge ( { outputLanguage : 'es5' , modules : 'commonjs' , filename : '<unknown file>' , sourceMap : false , cwd : process . cwd ( ) , moduleName : false } , options || { } ) ; var moduleName = options . moduleName ; traceurOptions . reset ( ) ; merge ( traceurOptions , options ) ; var errorReporter = new ErrorReporter ( ) ; var sourceFile = new SourceFile ( options . filename , content ) ; var parser = new Parser ( sourceFile , errorReporter ) ; var tree = parser . parseModule ( ) ; var transformer ; if ( moduleName === true || options . modules == 'register' || options . modules == 'inline' ) { moduleName = options . filename . replace ( / \.js$ / , '' ) ; moduleName = path . relative ( options . cwd , moduleName ) . replace ( / \\ / g , '/' ) ; } if ( moduleName ) { transformer = new AttachModuleNameTransformer ( moduleName ) ; tree = transformer . transformAny ( tree ) ; } if ( options . outputLanguage . toLowerCase ( ) === 'es6' ) { transformer = new PureES6Transformer ( errorReporter ) ; } else { transformer = new FromOptionsTransformer ( errorReporter ) ; } var transformedTree = transformer . transform ( tree ) ; if ( errorReporter . hadError ( ) ) { return { js : null , errors : errorReporter . errors , sourceMap : null } ; } var treeWriterOptions = { } ; if ( options . sourceMap ) { treeWriterOptions . sourceMapGenerator = new SourceMapGenerator ( { file : options . filename , sourceRoot : null } ) ; } return { js : TreeWriter . write ( transformedTree , treeWriterOptions ) , errors : errorReporter . errors , sourceMap : treeWriterOptions . sourceMap || null } ; } 
function ( date , timepicker ) { var me = this , selection = timepicker . getSelectionModel ( ) . getSelection ( ) , time , len , fn , val , i = 0 , arr = [ ] , timeFns = [ 'setHours' , 'setMinutes' , 'setSeconds' , 'setMilliseconds' ] ; if ( selection . length ) { time = selection [ 0 ] . get ( 'disp' ) ; 
function ( picker , date ) { 
function ( record ) { 
function ( ) { var me = this ; me . tbar = [ 'Search' , { xtype : 'textfield' , name : 'searchField' , hideLabel : true , width : 200 , listeners : { change : { fn : me . onTextFieldChange , scope : this , buffer : 100 } } } , { xtype : 'button' , text : '&lt;' , tooltip : 'Find Previous Row' , handler : me . onPreviousClick , scope : me } , { xtype : 'button' , text : '&gt;' , tooltip : 'Find Next Row' , handler : me . onNextClick , scope : me } , '-' , { xtype : 'checkbox' , hideLabel : true , margin : '0 0 0 4px' , handler : me . regExpToggle , scope : me } , 'Regular expression' , { xtype : 'checkbox' , hideLabel : true , margin : '0 0 0 4px' , handler : me . caseSensitiveToggle , scope : me } , 'Case sensitive' ] ; me . bbar = Ext . create ( 'Ext.ux.StatusBar' , { defaultText : me . defaultStatusText , name : 'searchStatusBar' } ) ; me . callParent ( arguments ) ; } 
function ( ) { var me = this ; me . callParent ( arguments ) ; me . textField = me . down ( 'textfield[name=searchField]' ) ; me . statusBar = me . down ( 'statusbar[name=searchStatusBar]' ) ; } 
function ( ) { var me = this , value = me . textField . getValue ( ) ; if ( value === '' ) { return null ; } if ( ! me . regExpMode ) { value = value . replace ( me . regExpProtect , function ( m ) { return '\\' + m ; } ) ; } else { try { new RegExp ( value ) ; } catch ( error ) { me . statusBar . setStatus ( { text : error . message , iconCls : 'x-status-error' } ) ; return null ; } 
function ( ) { var me = this , count = 0 ; me . view . refresh ( ) ; 
function ( ) { var me = this , idx ; if ( ( idx = Ext . Array . indexOf ( me . indexes , me . currentIndex ) ) !== - 1 ) { me . currentIndex = me . indexes [ idx - 1 ] || me . indexes [ me . indexes . length - 1 ] ; me . getSelectionModel ( ) . select ( me . currentIndex ) ; } } 
function makeCtor ( className ) { function constructor ( ) { 
function ( config , existingEl ) { config = config || { } ; var me = this , dh = Ext . DomHelper , cp = config . parentEl , pel = cp ? Ext . getDom ( cp ) : document . body , hm = config . hideMode , cls = Ext . baseCSSPrefix + ( config . fixed && ! ( Ext . isIE6 || Ext . isIEQuirks ) ? 'fixed-layer' : 'layer' ) ; 
function start ( Router , APIAdapter , startOptions ) { $ ( function ( ) { 
function createQCallback ( bbEmit ) { return function ( ) { 
function ( err ) { if ( err ) { defer . reject ( err ) ; } else { 
function objectChanged ( state , op , edit , syncId , editId ) { _ . assertLength ( arguments , 5 ) ; var already = { } internalObjectChanged ( state , op , edit , syncId , editId , already ) } 
function ( id , listener ) { _ . assertLength ( arguments , 2 ) var list = lazyArray(byObject, id+'') var innerId = id list.push(function(typeCode, id, editPath, op, edit, syncId, editId){ var found for(var i=0;i<editPath.length;++i){ var e = editPath[i] if(e.op === editCodes.selectObject || e.op === editCodes.reselectObject){ if(e.edit.id === innerId.inner){ found = i break; } } } if(found !== undefined && editPath.length > found+1){ listener(typeCode, id, editPath.slice(found+1), op, edit, syncId, editId) } }); }*/ 
function ( typeCode , listener ) { var c = createdByType [ typeCode ] ; if ( c === undefined ) c = createdByType [ typeCode ] = [ ] ; c . push ( listener ) ; } 
function ( typeCode , listener ) { var c = delByType [ typeCode ] ; if ( c === undefined ) c = delByType [ typeCode ] = [ ] ; c . push ( listener ) ; } 
function AnalyserManager ( analyserInstallLocation ) { var self = this ; EventEmitter . call ( self ) ; self . ANALYSER_INSTALL_DIR = analyserInstallLocation ; self . ALL_ANALYSERS = null ; self . init = function ( ) { return exists ( self . ANALYSER_INSTALL_DIR ) . then ( function ( ) { debug ( 'install dir exists' ) ; return canWrite ( self . ANALYSER_INSTALL_DIR ) . then ( function ( ) { debug ( 'install dir writeable' ) ; return self . fetchAnalyserList ( ) ; } ) } , function ( ) { debug ( 'install dir does not exists' ) ; return mkdirs ( self . ANALYSER_INSTALL_DIR ) * Fetch a list of all the analysers that Sidekick supports * @returns {bluebird|exports|module.exports} */ self . fetchAnalyserList = function ( ) { const REPO_SLUG = "sidekickcode/analysers/master/analysers.json" ; const RAWGIT_SK_CENTRAL_ANALYSER_LIST_URL = 'https://cdn.rawgit.com/' + REPO_SLUG ; const SK_CENTRAL_ANALYSER_LIST_URL = 'https://raw.githubusercontent.com/' + REPO_SLUG ; return fetchList ( RAWGIT_SK_CENTRAL_ANALYSER_LIST_URL ) . then ( ( allAnalysers ) => { debug ( 'have analysers list from rawgit: ' ) ; self . ALL_ANALYSERS = allAnalysers ; return doResolve ( self . ALL_ANALYSERS ) ; } , ( ) => { * Fetch the canonical analyser config stored in teh central list of analysers. * @param analyserName the name of the analyser to fetch the config for * @returns Promise {path: [abs path to analyser], config: [analyser config]} */ self . fetchCanonicalAnalyserConfig = function ( analyserName ) { if ( ! self . ALL_ANALYSERS ) { return self . fetchAnalyserList ( ) . then ( function ( ) { return returnConfig ( ) ; } ) } else { return returnConfig ( ) ; } function returnConfig ( ) { var analyserConfig = self . ALL_ANALYSERS [ analyserName ] ; if ( analyserConfig ) { return doResolve ( analyserConfig ) ; } else { return doReject ( ` ${ analyserName } ` ) ; } } } ; self . fetchAnalyser = function ( analyserName , version ) { var pathToAnalyser = path . join ( self . ANALYSER_INSTALL_DIR , ` ${ analyserName } ${ version } ` ) ; return exists ( pathToAnalyser ) . then ( function ( fileStat ) { return readAnalyserConfig ( pathToAnalyser ) . then ( function ( configObj ) { return doResolve ( { path : pathToAnalyser , config : configObj } ) ; } ) ; } , function ( err ) { return doReject ( ` ${ analyserName } ` , err ) ; } ) } ; self . installAnalyser = function ( analyser , force ) { var haveVersion ; if ( ! analyser . version || analyser . version === 'latest' ) { haveVersion = self . isNewerVersionAvailable ( analyser . name ) ; } else { haveVersion = Promise . resolve ( { "latest" : analyser . version } ) ; } return haveVersion . then ( function ( version ) { var versionToInstall = version . latest ; var pathToAnalyser = path . join ( self . ANALYSER_INSTALL_DIR , ` ${ analyser . name } ${ versionToInstall } ` ) ; return exists ( pathToAnalyser ) * Get the latest version info for an analyser {newer: [boolean], latest: [string]} * @param analyserName * @param version * @returns {bluebird|exports|module.exports} */ self . isNewerVersionAvailable = function ( analyserName , version ) { return getAllAnalyserEntry ( analyserName ) . then ( function ( analyserConfig ) { var extractor ; if ( analyserConfig . registry === 'npm' ) { extractor = new npmExtractor ( ) ; } proxyAll ( extractor , self ) ; return extractor . getLatestVersion ( analyserName ) . then ( function ( latestVersion ) { if ( semver . valid ( version ) && semver . valid ( latestVersion ) ) { return doResolve ( { "newer" : semver . lt ( version , latestVersion ) , "latest" : latestVersion } ) ; } else { if ( semver . valid ( latestVersion ) ) { * Validate a list of analysers - removing any unknown analysers * @param analysers Array of possible analysers * @retuns Array of known analysers */ self . validateAnalyserList = function ( analysers ) { var validAnalysers = [ ] ; debug ( 'analysers to validate: ' + JSON . stringify ( analysers ) ) ; return new Promise ( function ( resolve , reject ) { if ( self . ALL_ANALYSERS ) { debug ( 'have analyser list' ) ; doResolve ( ) ; } else { self . fetchAnalyserList ( ) . then ( function ( ALL_ANALYSER ) { debug ( 'have fetched analyser list: ' + ALL_ANALYSER ) ; doResolve ( ) ; } ) ; } function doResolve ( ) { debug ( 'resolving..' ) ; _ . each ( analysers , function ( analyser ) { debug ( 'resolving ' + JSON . stringify ( analyser ) ) ; if ( analyser . name ) { if ( self . ALL_ANALYSERS [ analyser . name ] ) { validAnalysers . push ( analyser ) ; } } } ) ; resolve ( validAnalysers ) ; } } ) ; } ; self . getLatestVersionOfInstalledAnalyser = function ( analyserName ) { * Gets a list of all the installed analysers (name only) * @returns Array */ self . getAllInstalledAnalysers = function ( ) { if ( isDir ( self . ANALYSER_INSTALL_DIR ) ) { return fs . readdirSync ( self . ANALYSER_INSTALL_DIR ) . filter ( function ( file ) { const stat = fs . statSync ( path . join ( self . ANALYSER_INSTALL_DIR , file ) ) ; const re = new RegExp ( ` ` , "i" ) ; return stat . isDirectory ( ) && re . test ( file ) ; } ) ; } else { return [ ] ; } } ; function readAnalyserConfig ( analyserPath ) { var filePath = path . join ( analyserPath , 'config.json' ) ; return readFile ( filePath , { encoding : 'utf8' } ) . then ( function ( fileContents ) { try { return doResolve ( JSON . parse ( jsonWithComments ( fileContents ) ) ) ; } catch ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } } , function ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } ) ; } function _installAnalyser ( analyser , version ) { return getAllAnalyserEntry ( analyser . name ) . then ( function ( analyserConfig ) { var config = analyserConfig . config ; 
function readAnalyserConfig ( analyserPath ) { var filePath = path . join ( analyserPath , 'config.json' ) ; return readFile ( filePath , { encoding : 'utf8' } ) . then ( function ( fileContents ) { try { return doResolve ( JSON . parse ( jsonWithComments ( fileContents ) ) ) ; } catch ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } } , function ( err ) { return doReject ( ` ${ analyserPath } ` , err ) ; } ) ; } 
function array ( x , dtype ) { var ctor ; if ( isNumber ( x ) ) { if ( arguments . length === 1 ) { return new CTOR ( x ) ; } ctor = ctors ( dtype ) ; return new ctor ( x ) ; } return cast ( x , dtype || 'float64' ) ; } 
function notMatch ( key ) { let queryValue = queryTag [ key ] let minus if ( typeof queryValue === 'string' && ( minus = queryValue . match ( minusRe ) ) ) { queryValue = minus [ 1 ] if ( this . _tag [ key ] === queryValue ) { return true * tag: value */ if ( this . _tag [ key ] !== queryValue ) { return true 
function ( v ) { if ( ! me . hiddenInput ) me . hiddenInput = me . down ( '[xtype=textfield]' ) if ( me . setTimer ) clearTimeout ( me . setTimer ) me . setTimer = setTimeout ( function ( ) { me . noChange = true me . hiddenInput . setValue ( v ) } , 1000 ) } 
function build ( mode , system , cdef , out , cb ) { var cmd = cdef . specific . processBuild || cdef . specific . build ; var branch = '' ; logger . info ( 'building' ) ; out . stdout ( 'building' ) ; if ( ! cmd ) { return cb ( null , { } ) ; } if ( ! cdef . specific . repositoryUrl ) { return cb ( new Error ( 'missing repositoryUrl' ) , { } ) ; } 
function start ( mode , target , system , containerDef , container , out , cb ) { proc . start ( mode , target , system , containerDef , container , out , cb ) ; } 
function len ( head ) { var length = 0 ; while ( head !== null ) { ++ length ; head = head . next ; } return length ; } 
function list ( iterable ) { var pt = new Node ( null , undefined ) ; var current = pt ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = iterable [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var value = _step . value ; current = current . next = new Node ( null , value ) ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator [ "return" ] ) { _iterator [ "return" ] ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } return pt . next ; } 
function ( node , callback ) { if ( index === 0 ) { callback ( node ) return false ; } index -- if ( node . isExpanded ( ) ) { for ( var i = 0 ; i < node . childNodes . length ; i ++ ) { if ( ! recur ( node . childNodes [ i ] , callback ) ) return false ; } } return true } 
function ( ) { var me = this ; * @event click * Fires when this button is clicked, before the configured {@link #handler} is invoked. Execution of the * {@link #handler} may be vetoed by returning <code>false</code> to this event. * @param {Ext.button.Button} this * @param {Event} e The click event */ 'click' , 'toggle' , 'mouseover' , 'mouseout' , 'menushow' , 'menuhide' , 'menutriggerover' , 'menutriggerout' , 'textchange' , 'iconchange' , 'glyphchange' ) ; if ( me . menu ) { 
function ( e ) { var me = this ; 
function ( cls ) { cls = cls || '' ; var me = this , btnIconEl = me . btnIconEl , oldCls = me . iconCls || '' ; me . iconCls = cls ; if ( oldCls != cls ) { if ( btnIconEl ) { 
function ( ui ) { var me = this ; 
function isIllegalArguments ( _ref ) { var fn = _ref . fn ; var cb = _ref . cb ; var matcher = _ref . matcher ; if ( typeof fn !== 'function' ) { return Promise . reject ( new Error ( 'Expected fn to be a Function' ) ) ; } if ( typeof cb !== 'undefined' && typeof cb !== 'function' ) { return Promise . reject ( new Error ( 'Expected cb to be a Function' ) ) ; } if ( ! ( matcher instanceof RegExp ) && [ 'function' , 'string' ] . indexOf ( typeof matcher === 'undefined' ? 'undefined' : _typeof ( matcher ) ) === - 1 && matcher . constructor !== Error . constructor ) { return Promise . reject ( new Error ( UNRECOGNISED_MATCHER_ERR ) ) ; } return Promise . resolve ( ) ; } 
function doesMatch ( _ref2 ) { var matcher = _ref2 . matcher ; var err = _ref2 . err ; if ( typeof matcher === 'string' ) { return err . message . indexOf ( matcher ) > - 1 ; } if ( matcher instanceof RegExp ) { return matcher . test ( err . message ) ; } if ( typeof matcher === 'function' ) { return matcher ( err ) ; } if ( matcher . constructor === Error . constructor ) { return err instanceof matcher ; } throw new Error ( UNRECOGNISED_MATCHER_ERR ) ; } 
function catchAndMatch ( fn , matcher , cb ) { return isIllegalArguments ( { fn : fn , matcher : matcher , cb : cb } ) . then ( fn , function ( err ) { throw err ; } ) . then ( function ( ) { 
function unzipInTmpDir ( base64 ) { var mkTempCmd = "mktemp -d XXXXXXXX" ; return exec ( mkTempCmd ) . then ( function ( tmpDir1 ) { return new Promise ( function ( resolve , reject ) { var zipFile = path . join ( tmpDir1 , "action.zip" ) ; fs . writeFile ( zipFile , base64 , "base64" , function ( err ) { if ( err ) { reject ( "There was an error reading the action archive." ) ; } resolve ( zipFile ) ; } ) ; } ) ; } ) . then ( function ( zipFile ) { return exec ( mkTempCmd ) . then ( function ( tmpDir2 ) { return exec ( "unzip -qq " + zipFile + " -d " + tmpDir2 ) . then ( function ( res ) { return path . resolve ( tmpDir2 ) ; } ) . catch ( function ( error ) { return Promise . reject ( "There was an error uncompressing the action archive." ) ; } ) ; } ) ; } ) ; } 
function exec ( cmd ) { return new Promise ( function ( resolve , reject ) { child_process . exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { reject ( stderr . trim ( ) ) ; } else { resolve ( stdout . trim ( ) ) ; } } ) ; } ) ; } 
function listen ( name , callBack ) { function f ( ) { try { callBack . apply ( this , arguments ) ; } catch ( e ) { console . error ( e ) ; 
function ( stroke , convertFrom , convertTo , timing ) { return new Promise ( function ( resolve , reject ) { console . debug ( 'converting ' + stroke + ' @ ' + timing + ' from ' + convertFrom + ' to ' + convertTo ) ; var poolTable = { } ; var strokeTable = { } ; var timingInSeconds = 0 ; 
function ImageDimensions ( assetPath , registeredAssets , callback ) { sassUtils . assertType ( assetPath , "string" ) ; sassUtils . assertType ( registeredAssets , "map" ) ; var self = this ; var getPath = self . checkImagePath ( assetPath . getValue ( ) , registeredAssets ) ; getPath . then ( function ( success ) { var imageDimensions = self . getDimensions ( success ) ; imageDimensions . then ( function ( dimensions ) { callback ( null , dimensions ) ; } , function ( err ) { callback ( err , null ) ; } ) ; } , function ( err ) { callback ( err , null ) ; } ) ; } 
function clientReadyMessage ( cookies , user , pass ) { return { type : 'connected' , user : user , sessionID : cookies . sessionID , pass : pass } } 
function toFloat64 ( high , low ) { UINT32_VIEW [ HIGH ] = high ; UINT32_VIEW [ LOW ] = low ; return FLOAT64_VIEW [ 0 ] ; } 
function analyseComment ( file , comment ) { var reg = / (@require\.async\s+)('[^']+'|"[^"]+"|[^\s;!@#%^&*()]+) / g ; return comment . replace ( reg , function ( m , prefix , value ) { addAsync ( file , value ) ; return '' ; } ) ; } 
function Namespace ( dir , allowedFileExts , ignoredDirs , ignoredFileNames ) { ignoredDirs = Array . isArray ( ignoredDirs ) ? ignoredDirs : null ; ignoredFileNames = Array . isArray ( ignoredFileNames ) ? ignoredFileNames : null ; let self = this , files = fs . readdirSync ( dir ) ; allowedFileExts = allowedFileExts || [ '.js' , '.json' ] ; if ( files && Array . isArray ( files ) && files . length > 0 ) { processFiles ( files , dir , allowedFileExts , ignoredDirs , ignoredFileNames , self ) ; } } 
function CouchDBCache ( options ) { var self = this ; options = options || { } ; this . expireAfterSeconds = options . expireAfterSeconds || 60 ; this . connection = Promise . resolve ( ) . then ( function ( ) { return options . auth ? this . auth ( options . auth . username , options . auth . password ) : null ; } ) . then ( function ( cookie ) { return nano ( { url : options . url || ( options . protocol + '://' + options . host + ':' + options . port ) , cookie : cookie } ) ; } ) ; 
function ( tree ) { var plugs = tree . plugins , dependencies = [ ] , i ; 
function ( obj ) { var res = { } , i ; for ( i in obj ) { res [ i ] = obj [ i ] ; } return res ; } 
function ( route , file , opts ) { var filePath = path . join ( route , file ) , 
function ( rootPath ) { 
function ( plugins , groups ) { var result = [ ] , i ; for ( i in plugins ) { result . push ( i ) ; } for ( i in groups ) { result . push ( i ) ; } return result ; } 
function configure ( pkg , env , target ) { const isModule = target === 'module' ; const input = ` ` ; const deps = [ ] . concat ( pkg . dependencies ? Object . keys ( pkg . dependencies ) : [ ] ) . concat ( pkg . peerDependencies ? Object . keys ( pkg . peerDependencies ) : [ ] ) ; const plugins = [ 
function ( ) { var requiredRules = [ 
function ( headers , callback ) { 
function compose ( ) { var args = argsToArray ( arguments ) ; return function ( arg0 ) { return args . reduceRight ( function ( value , arg ) { return arg ( value ) ; } , arg0 ) ; } ; } 
function curryN ( fn , executeArity ) { var curriedArgs = restArgs ( arguments , 2 ) ; return function ( ) { var args = argsToArray ( arguments ) , concatedArgs = replacePlaceHolders ( curriedArgs , args ) , placeHolders = concatedArgs . filter ( isPlaceholder ) , canBeCalled = ( concatedArgs . length - placeHolders . length >= executeArity ) || ! executeArity ; return ! canBeCalled ? curryN . apply ( null , [ fn , executeArity ] . concat ( concatedArgs ) ) : fn . apply ( null , concatedArgs ) ; } ; } 
function replacePlaceHolders ( array , args ) { var out = array . map ( function ( element ) { return ! ( element instanceof PlaceHolder ) ? element : ( args . length > 0 ? args . shift ( ) : element ) ; } ) ; return args . length > 0 ? out . concat ( args ) : out ; } 
function restArgs ( args , start , end ) { end = end || args . length ; return slice . call ( args , start , end ) ; } 
function extractFromArrayAt ( array , index , type , makeCopyOfArray ) { makeCopyOfArray = isBoolean ( makeCopyOfArray ) ? makeCopyOfArray : true ; var retVal = [ null , array ] , matchesType , foundElement , subject , splicedArray ; if ( array . hasOwnProperty ( index + '' ) ) { subject = makeCopyOfArray ? array . slice ( ) : array ; matchesType = issetAndOfType ( type , _String ) ? classOfIs ( subject [ index ] , type ) : true ; if ( matchesType ) { splicedArray = subject . splice ( index , 1 ) ; foundElement = splicedArray . length > 0 ? splicedArray [ 0 ] : null ; retVal = [ foundElement , subject ] ; } } return retVal ; } 
function classOf ( value ) { var retVal , valueType , toString ; if ( typeof value === _undefined ) { retVal = _Undefined ; } else if ( value === null ) { retVal = _Null ; } else { toString = value . toString . name === 'toString' ? Object . prototype . toString : value . toString ; valueType = toString . call ( value ) ; retVal = valueType . substring ( 8 , valueType . length - 1 ) ; if ( retVal === _Number && isNaN ( value ) ) { retVal = 'NaN' ; } } return retVal ; } 
function classOfIs ( obj , type ) { var classOfType = classOf ( type ) , typeIsFunction = type instanceof Function ; if ( classOfType !== String . name && ! typeIsFunction ) { throw new TypeError ( 'sjl.classOfIs expects it\'s `type` parameter to' + 'be of type `String` or an instance of `Function`. Type received: ' + classOfType + '.' ) ; } return ( typeIsFunction ? obj instanceof type : false ) || classOf ( obj ) === ( classOfType === _String ? type : type . name ) ; } 
function forEach ( arrayLike , callback , context ) { var classOfArrayLike = sjl . classOf ( arrayLike ) ; switch ( classOfArrayLike ) { case _Array : case 'Set' : case 'SjlSet' : case 'SjlMap' : case 'Map' : arrayLike . forEach ( callback , context ) ; break ; case _Object : forEachInObj ( arrayLike , callback , context ) ; break ; default : throw new TypeError ( 'sjl.forEach takes only ' + '`Array`, `Object`, `Map`, `Set`, `SjlSet`, and `SjlMap` objects. ' + 'Type passed in: `' + classOfArrayLike + '`.' ) ; } } 
function classOfIsMulti ( value , type ) { return ( sjl . restArgs ( arguments , 1 ) ) . some ( function ( _type ) { return classOfIs ( value , _type ) ; } ) ; } 
function isEmpty ( value ) { var classOfValue = classOf ( value ) , retVal ; 
function autoNamespace ( ns_string , objToSearch , valueToSet ) { 
function camelCase ( str , upperFirst , replaceStrRegex ) { upperFirst = upperFirst || false ; replaceStrRegex = replaceStrRegex || / [^a-z\d] / i ; var newStr = '' , 
function implode ( list , separator ) { var retVal = '' , prototypeOfList = Object . getPrototypeOf ( list ) ; if ( isArray ( list ) ) { retVal = list . join ( separator ) ; } else if ( prototypeOfList . constructor . name === 'Set' || prototypeOfList . constructor . name === 'SjlSet' ) { retVal = [ ] ; list . forEach ( function ( value ) { retVal . push ( value ) ; } ) ; retVal = retVal . join ( separator ) ; } return retVal ; } 
function searchObj ( ns_string , objToSearch ) { var parts = ns_string . split ( '.' ) , parent = objToSearch , classOfObj = classOf ( objToSearch ) , i ; throwTypeErrorIfNotOfType ( 'sjl.searchObj' , 'ns_string' , ns_string , String ) ; if ( classOfObj !== _Object && objToSearch instanceof Function === false ) { throw new TypeError ( 'sjl.searchObj expects `objToSearch` to be of type object ' + 'or an instance of `Function`. Type received: ' + classOfObj ) ; } for ( i = 0 ; i < parts . length ; i += 1 ) { if ( parts [ i ] in parent === false || isUndefined ( parent [ parts [ i ] ] ) ) { parent = undefined ; break ; } parent = parent [ parts [ i ] ] ; } return parent ; } 
function extend ( o , p , deep ) { 
function extendMulti ( ) { var args = argsToArray ( arguments ) , deep = extractBoolFromArrayStart ( args ) , arg0 = args . shift ( ) ; 
function normalizeArgsForDefineSubClass ( superClass , constructor , methods , statics ) { superClass = superClass || Object . create ( Object . prototype ) ; 
function classicalToStringMethod ( constructor ) { if ( ! constructor . hasOwnProperty ( 'toString' ) || constructor . toString . name === 'toString' ) { constructor . prototype . toString = function toStringOverride ( ) { return '[object ' + constructor . name + ']' ; } ; } return constructor ; } 
function makeExtendableConstructor ( constructor ) { var extender = function ( constructor_ , methods_ , statics_ ) { return defineSubClass ( constructor , constructor_ , methods_ , statics_ ) ; } ; constructor . extend = constructor . extendWith = extender ; 
function defineSubClassPure ( superClass , constructor , methods , statics ) { var normalizedArgs = normalizeArgsForDefineSubClass . apply ( null , arguments ) , _superClass = normalizedArgs . superClass , _statics = normalizedArgs . statics , _constructor = normalizedArgs . constructor , _methods = normalizedArgs . methods ; 
function defineSubClass ( superClass , constructor , methods , statics ) { var _constructor_ = defineSubClassPure . apply ( null , arguments ) ; 
function addRevealingModuleCall ( obj , functionKey , shortFunctionKey ) { functionKey = functionKey || 'module' ; obj [ shortFunctionKey || 'ns' ] = obj [ functionKey ] = function ( nsString , value ) { return sjl . isUndefined ( nsString ) ? obj [ functionKey ] : unConfigurableNamespace ( nsString , obj [ functionKey ] , value ) ; } ; 
function constrainPointer ( pointer , min , max ) { return pointer < min ? min : ( ( pointer > max ) ? max : pointer ) ; } 
function wrapPointer ( pointer , min , max ) { return pointer > max ? min : ( pointer < min ? max : pointer ) ; } 
function throwTypeErrorIfNotOfType ( prefix , paramName , value , type , suffix ) { var classOfValue = classOf ( value ) ; 
function throwTypeErrorIfEmptyOrNotOfType ( prefix , paramName , value , type , suffix ) { var classOfValue = classOf ( value ) , issetType = isset ( type ) ; 
function throwTypeErrorIfEmpty ( prefix , paramName , value , type , suffix ) { throwTypeErrorIfEmptyOrNotOfType ( prefix , paramName , value , type , suffix ) ; } 
function valueOrDefault ( value , defaultValue , type ) { defaultValue = typeof defaultValue === _undefined ? null : defaultValue ; var retVal ; if ( isset ( type ) ) { retVal = issetAndOfType . apply ( null , [ value ] . concat ( sjl . restArgs ( arguments , 2 ) ) ) ? value : defaultValue ; } else { retVal = isset ( value ) ? value : defaultValue ; } return retVal ; } 
function defineEnumProp ( obj , key , value ) { Object . defineProperty ( obj , key , { value : value , enumerable : true } ) ; } 
function unConfigurableNamespace ( ns_string , objToSearch , valueToSet ) { var parent = objToSearch , shouldSetValue = typeof valueToSet !== _undefined , hasOwnProperty ; ns_string . split ( '.' ) . forEach ( function ( key , i , parts ) { hasOwnProperty = parent . hasOwnProperty ( key ) ; if ( i === parts . length - 1 && shouldSetValue && ! hasOwnProperty ) { defineEnumProp ( parent , key , valueToSet ) ; } else if ( typeof parent [ key ] === _undefined && ! hasOwnProperty ) { defineEnumProp ( parent , key , { } ) ; } parent = parent [ key ] ; } ) ; return parent ; } 
function changeCaseOfFirstChar ( str , func , thisFuncsName ) { var search , char , right , left ; 
function extractBoolFromArray ( array , startOrEndBln ) { var extractedValue = extractFromArrayAt ( array , startOrEndBln ? 0 : array . length - 1 , _Boolean , false ) [ 0 ] ; return isBoolean ( extractedValue ) ? extractedValue : false ; } 
function mergeOnProps ( obj1 , obj2 , deep ) { deep = isBoolean ( deep ) ? deep : false ; Object . keys ( obj1 ) . forEach ( function ( key ) { if ( ! obj2 . hasOwnProperty ( key ) ) { return ; } extendMulti ( deep , obj1 [ key ] , obj2 [ key ] ) ; } ) ; return obj1 ; } 
function mergeOnPropsMulti ( obj1 , obj2 ) { var args = argsToArray ( arguments ) , deep = extractBoolFromArrayStart ( args ) , arg0 = args . shift ( ) ; 
function ( keyOrNsKey , value ) { var self = this ; if ( sjl . isObject ( keyOrNsKey ) ) { sjl . extend . apply ( sjl , [ true , self ] . concat ( sjl . argsToArray ( arguments ) ) ) ; } else if ( sjl . isString ( keyOrNsKey ) ) { sjl . autoNamespace ( keyOrNsKey , self , value ) ; } else if ( sjl . isset ( keyOrNsKey ) ) { throw new TypeError ( contextName + '.set only allows strings or objects as it\'s first parameter. ' + 'Param type received: `' + sjl . classOf ( keyOrNsKey ) + '`.' ) ; } return self ; } 
function ( keyOrNsString ) { sjl . throwTypeErrorIfNotOfType ( contextName + '.has' , 'keyOrNsString' , keyOrNsString , String ) ; var searchResult = sjl . searchObj ( keyOrNsString , this ) ; return arguments . length === 1 ? sjl . isset ( searchResult ) : sjl . issetAndOfType . apply ( sjl , [ searchResult ] . concat ( sjl . restArgs ( 1 ) ) ) ; } 
function ( keyOrNsString ) { return sjl . jsonClone ( sjl . notEmptyAndOfType ( keyOrNsString , String ) ? sjl . searchObj ( keyOrNsString , this ) : this ) ; } 
function ( ) { var self = this ; return self . valid ( ) ? { done : false , value : self . _values [ self . pointer ] } : { done : true } ; } 
function ObjectIterator ( keysOrObj , values ) { var obj , classOfParam0 = sjl . classOf ( keysOrObj ) , receivedParamTypesList , _values , _keys ; * Object iterator keys. Set on construction. * @member {Array<*>} sjl.stdlib.ObjectIterator#keys * @readonly */ 
function ( callback , context ) { var self = this , values = self . _values ; context = context || self ; self . _keys . forEach ( function ( key , index , keys ) { callback . call ( context , values [ index ] , key , keys ) ; } ) ; return this ; } 
function SjlSet ( iterable ) { var self = this , _values = [ ] ; * @name _values * @member {Array<*>} sjl.stdlib.SjlSet#_values - Where the values are kept on the Set. Default `[]`. * @readonly */ _values : { value : _values } , size : { get : function ( ) { return _values . length ; } , enumerable : true } } ) ; * Flag for knowing that default es6 iterator was overridden. Set on construction. * @name _iteratorOverridden * @member {Boolean} sjl.stdlib.SjlSet#_iteratorOverridden. Default `true`. * @readonly */ 
function ( value ) { var _index = this . _values . indexOf ( value ) ; if ( _index > - 1 && _index <= this . _values . length ) { this . _values . splice ( _index , 1 ) ; } return this ; } 
function ( value ) { 
function ( key ) { if ( this . has ( key ) ) { var _index = this . _keys . indexOf ( key ) ; this . _values . splice ( _index , 1 ) ; this . _keys . splice ( _index , 1 ) ; } return this ; } 
function ( key , value ) { var index = this . _keys . indexOf ( key ) ; if ( index > - 1 ) { this . _keys [ index ] = key ; this . _values [ index ] = value ; } else { this . _keys . push ( key ) ; this . _values . push ( value ) ; } return this ; } 
function ( array ) { 
function ( object ) { sjl . throwTypeErrorIfNotOfType ( SjlMap . name , 'object' , object , 'Object' , 'Only `Object` types allowed.' ) ; var self = this , entry , objectIt = new ObjectIterator ( object ) ; while ( objectIt . valid ( ) ) { entry = objectIt . next ( ) ; self . set ( entry . value [ 0 ] , entry . value [ 1 ] ) ; } return self ; } 
function ( ) { var self = this , out = { } ; this . _keys . forEach ( function ( key , i ) { out [ key ] = self . _values [ i ] ; } ) ; return out ; } 
function PriorityListItem ( key , value , priority , serial ) { var _priority , _serial , contextName = 'sjl.stdlib.PriorityListItem' ; Object . defineProperties ( this , { key : { value : key , enumerable : true } , serial : { get : function ( ) { return _serial ; } , set : function ( value ) { sjl . throwTypeErrorIfNotOfType ( contextName , 'serial' , value , Number ) ; _serial = value ; } , enumerable : true } , value : { value : value , enumerable : true } , priority : { get : function ( ) { return _priority ; } , set : function ( value ) { sjl . throwTypeErrorIfNotOfType ( contextName , 'priority' , value , Number ) ; _priority = value ; } , enumerable : true } } ) ; this . priority = priority ; this . serial = serial ; } 
function ( ) { var current = Iterator . prototype . current . call ( this ) ; if ( ! current . done && this . wrapItems ) { current . value = current . value . value ; } return current ; } 
function ( ) { var next = Iterator . prototype . next . call ( this ) ; if ( ! next . done && this . wrapItems ) { next . value = next . value . value ; } return next ; } 
function ( ) { return this . sort ( ) . wrapItems ? new ObjectIterator ( this . _keys , this . _values . map ( function ( item ) { return item . value ; } ) ) : new SjlMap . prototype . entries . call ( this . sort ( ) ) ; } 
function ( callback , context ) { SjlMap . prototype . forEach . call ( this . sort ( ) , function ( value , key , map ) { callback . call ( context , this . wrapItems ? value . value : value , key , map ) ; } , this ) ; return this ; } 
function ( ) { if ( this . wrapItems ) { return new Iterator ( this . sort ( ) . _values . map ( function ( item ) { return item . value ; } ) ) ; } return new SjlMap . prototype . values . call ( this . sort ( ) ) ; } 
function ( key ) { var result = SjlMap . prototype . get . call ( this , key ) ; return this . wrapItems && result ? result . value : result ; } 
function ( key , value , priority ) { SjlMap . prototype . set . call ( this , key , this . resolveItemWrapping ( key , value , priority ) ) ; this . _sorted = false ; return this ; } 
function ( ) { var self = this , LIFO_modifier = self . _LIFO_modifier ; 
function ( priority ) { var retVal ; if ( sjl . classOfIs ( priority , Number ) ) { retVal = priority ; } else { this . _internalPriorities += 1 ; retVal = + this . _internalPriorities ; } return retVal ; } 
function ( key , value , priority ) { var normalizedPriority = this . normalizePriority ( priority ) , serial = this . _internalSerialNumbers ++ ; if ( this . wrapItems ) { return new ( this . itemWrapperConstructor ) ( key , value , normalizedPriority , serial ) ; } try { value . key = key ; value . priority = priority ; value . serial = serial ; } catch ( e ) { throw new TypeError ( 'PriorityList can only work in "unwrapped" mode with values/objects' + ' that can have properties created/set on them. Type encountered: `' + sjl . classOf ( value ) + '`;' + ' Original error: ' + e . message ) ; } return value ; } 
function doesSecurityGroupExist ( ec2 , securityGroupName ) { function inspectError ( err ) { if ( err . code === 'InvalidGroup.NotFound' ) { return false } return Bluebird . reject ( err ) } return ec2 . describeSecurityGroupsPromised ( { GroupNames : [ securityGroupName ] } ) . then ( _ . constant ( true ) ) . error ( inspectError ) } 
function next ( n ) { if ( ! n ) { n = 1 ; } for ( let i = 0 ; i < n ; i ++ ) { char = input [ ++ current ] ; } } 
function doesRoleExist ( iam , roleName ) { function inspectError ( err ) { if ( err . code === 'NoSuchEntity' ) { return false } return Bluebird . reject ( err ) } return iam . getRolePromised ( { RoleName : roleName } ) . then ( _ . constant ( true ) ) . error ( inspectError ) } 
function doesAutoScalingGroupExist ( autoScaling , asgName ) { return autoScaling . describeAutoScalingGroupsPromised ( { AutoScalingGroupNames : [ asgName ] } ) . then ( function found ( data ) { return ! _ . isEmpty ( data . AutoScalingGroups ) } ) } 
function Boxcar ( providerKey , providerSecret ) { if ( ! providerKey ) { throw new Error ( 'Must supply a valid API key' ) ; return ; } this . providerKey = providerKey ; this . providerSecret = providerSecret ; this . provider_url = '/devices/providers/' + this . providerKey + '/notifications' ; this . options = { hostname : 'boxcar.io' , port : 443 , method : 'POST' } ; } 
function doesInstanceProfileExist ( iam , instanceProfileName ) { function inspectError ( err ) { if ( err . code === 'NoSuchEntity' ) { return false } return Bluebird . reject ( err ) } return iam . getInstanceProfilePromised ( { InstanceProfileName : instanceProfileName } ) . then ( _ . constant ( true ) ) . error ( inspectError ) } 
function buildParams ( identifier , instanceState ) { var params = { } if ( instanceState ) { params . Filters = [ { Name : 'instance-state-name' , Values : [ instanceState ] } ] } if ( isInstanceId ( identifier ) ) { params . InstanceIds = [ identifier ] return params } params . Filters = params . Filters || [ ] params . Filters . push ( { Name : 'tag:Name' , Values : [ identifier ] } ) return params } 
function doesInstanceExist ( ec2 , identifier , instanceState ) { var params = buildParams ( identifier , instanceState ) function inspectError ( err ) { if ( err . code === 'InvalidInstanceID.NotFound' ) { return false } return Bluebird . reject ( err ) } return ec2 . describeInstancesPromised ( params ) . then ( function checkResult ( data ) { return ! isEmpty ( data . Reservations ) } ) . catch ( inspectError ) } 
function EasyLogger ( configFile ) { 
function ( ) { 
function ( level , text ) { 
function ( transportType , formatter ) { var exists = contains ( cm . config . easylogger . transports , { "key" : "type" , "value" : transportType } , "exists" ) 
function EdmundsClient ( config ) { if ( ! ( this instanceof EdmundsClient ) ) { return new EdmundsClient ( config ) ; } var defaultConfig = { } ; defaultConfig . responseFormat = 'json' ; defaultConfig . baseUrl = 'https://api.edmunds.com' ; this . config = extend ( defaultConfig , config ) ; if ( ! this . config . apiKey ) { throw new Error ( 'API key must be provided' ) ; } } 
function addDefinition ( defName ) { var definition = definitions [ defName ] ; return function ( params , done ) { if ( ! done && typeof params === 'function' ) { done = params ; params = { } ; } var url = this . config . baseUrl + definition . url ; var xtraParams = { } ; xtraParams . fmt = this . config . responseFormat ; xtraParams . api_key = this . config . apiKey ; try { Object . keys ( definition . params ) . forEach ( function ( paramName ) { var paramDef = definition . params [ paramName ] ; if ( ! params [ paramName ] ) { if ( paramDef . required ) { throw new Error ( 'Parameter ' + paramName + ' is required' ) ; } else { return ; } } if ( paramDef . location === 'url' ) { url = url . replace ( new RegExp ( '{' + paramName + '}' , 'g' ) , params [ paramName ] ) ; } else if ( paramDef . location === 'querystring' ) { xtraParams [ paramName ] = params [ paramName ] ; } } ) ; } catch ( e ) { return done ( e ) ; } return request . get ( url ) . query ( xtraParams ) . end ( function onEnd ( err , res ) { return done ( err , res . body ) ; } ) ; } ; } 
function createClient ( host , port , concurrent , frequency , duration , gen , iteration ) { var auth = defaults . auth var getMessage = defaults . getMessage emitter . emit ( 'start' ) if ( typeof gen . authenticate === 'function' ) { auth = gen . authenticate } if ( typeof gen . clientIterateMessage === 'function' ) { getMessage = gen . clientIterateMessage } var postAuth = function ( err , cookies , user , pass ) { ++ clientsAttempted if ( err ) { emitter . emit ( 'error' , err ) if ( clientsAttempted === concurrent && _intervals . length === 0 ) { emitter . emit ( 'end' ) } return } var socketUrl = gen . getSocketURL ( host , port , cookies , user , pass ) || host + ':' + port var socket = io ( socketUrl , { multiplex : false } ) . on ( 'connect' , function ( ) { emitter . emit ( 'client-connected' ) if ( typeof gen . events . connect === 'function' ) { gen . events . connect ( 'connect' , cookies , user , pass , { } , socket , emitter ) } Object . keys ( gen . events ) . forEach ( function ( eventName ) { socket . on ( eventName , function ( data ) { gen . events [ eventName ] . call ( null , eventName , cookies , user , pass , data , socket , emitter ) } ) } ) var sendMessage = function ( ) { var message = getMessage ( cookies , user , pass ) if ( ! Array . isArray ( message ) ) { message = [ message ] } for ( var i = 0 , len = message . length ; i < len ; i ++ ) { if ( message [ i ] ) { socket . json . send ( message [ i ] ) emitter . emit ( 'message' , message [ i ] ) } } } _intervals . push ( setInterval ( sendMessage , frequency ) ) setTimeout ( function ( ) { clearInterval ( _intervals . pop ( ) ) socket . emit ( 'disconnect' ) emitter . emit ( 'disconnect' ) socket . close ( ) if ( _intervals . length === 0 ) { done ( ) } } , duration ) } ) . on ( 'connect_error' , function ( err ) { emitter . emit ( 'error' , err ) if ( clientsAttempted === concurrent && _intervals . length === 0 ) { emitter . emit ( 'end' ) } } ) } auth ( host , port , iteration , postAuth ) } 
function ( file ) { var xml = file . contents ; var xmlDoc = libxmljs . parseXml ( xml ) ; var rootNode = xmlDoc . root ( ) ; var resourceObject = { } ; var valueNodes = rootNode . find ( "data" ) ; valueNodes . forEach ( function ( element ) { var name = element . attr ( "name" ) . value ( ) ; var value = element . get ( "value" ) . text ( ) ; resourceObject [ name ] = value ; } ) ; return JSON . stringify ( resourceObject ) ; } 
function doesLaunchConfigurationExist ( autoScaling , launchConfigurationName ) { return autoScaling . describeLaunchConfigurationsPromised ( { LaunchConfigurationNames : [ launchConfigurationName ] } ) . then ( function found ( data ) { return ! _ . isEmpty ( data . LaunchConfigurations ) } ) } 
function KJU ( configuration ) { var self = this , option ; 
function filter ( err , files ) { if ( err ) return self . emit ( 'error' , err ) ; var kjud = files . filter ( function filterfiles ( file ) { return ( / (\d)\.kju$ / ) . test ( file ) ; } ) ; 
function read ( file , index , files ) { fs . readFile ( self . path + file , function readFile ( err , contents ) { if ( err ) return done ( ) , self . emit ( 'error' , err ) ; 
function ( ) { var s4 = function ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 0x10000 ) . toString ( 16 ) . substring ( 1 ) ; } ; return s4 ( ) + s4 ( ) + '-' + s4 ( ) ; } 
function ( raw ) { if ( typeof raw !== 'object' || raw === null || util . isArray ( raw ) ) { return false ; } if ( raw . wiretree ) { return true ; } return false ; } 
function ( func ) { var fnStr = func . toString ( ) . replace ( / ((\/\/.*$)|(\/\*[\s\S]*?\*\/)) / mg , '' ) ; return fnStr . slice ( fnStr . indexOf ( '(' ) + 1 , fnStr . indexOf ( ')' ) ) . match ( / ([^\s,]+) / g ) || [ ] ; } 
function ( opts , tree ) { var fileName ; this . tree = tree ; this . resolved = false ; this . dependants = [ ] ; 
function ( mod ) { self . res = getProcessed ( self . processing , mod , self . raw . settings ) ; self . resolved = true ; callback ( ) ; } 
function ( width , height , camera ) { var id ; var w = width , h = height ; this . orientation = 'landscape' ; this . listeners = { } ; if ( typeof width !== 'number' ) { var image = width ; camera = height ; w = image . videoWidth || image . width ; h = image . videoHeight || image . height ; this . image = image ; } this . defaultMarkerWidth = 1 ; this . patternMarkers = { } ; this . barcodeMarkers = { } ; this . transform_mat = new Float32Array ( 16 ) ; this . canvas = document . createElement ( 'canvas' ) ; this . canvas . width = w ; this . canvas . height = h ; this . ctx = this . canvas . getContext ( '2d' ) ; this . videoWidth = w ; this . videoHeight = h ; if ( typeof camera === 'string' ) { var self = this ; this . cameraParam = new ARCameraParam ( camera , function ( ) { self . _initialize ( ) ; } , function ( err ) { console . error ( "ARController: Failed to load ARCameraParam" , err ) ; } ) ; } else { this . cameraParam = camera ; this . _initialize ( ) ; } } 
function ( src , onload , onerror ) { this . id = - 1 ; this . _src = '' ; this . complete = false ; this . onload = onload ; this . onerror = onerror ; if ( src ) { this . load ( src ) ; } } 
function writeStringToFS ( target , string , callback ) { var byteArray = new Uint8Array ( string . length ) ; for ( var i = 0 ; i < byteArray . length ; i ++ ) { byteArray [ i ] = string . charCodeAt ( i ) & 0xff ; } writeByteArrayToFS ( target , byteArray , callback ) ; } 
function updateUvs ( modelViewMatrix , cameraProjectionMatrix ) { var transformedUv = new THREE . Vector3 ( ) originalsFaceVertexUvs [ 0 ] . forEach ( function ( faceVertexUvs , faceIndex ) { faceVertexUvs . forEach ( function ( originalUv , uvIndex ) { 
function updateOrtho ( modelViewMatrix , cameraProjectionMatrix ) { 
function appendTableAtRangeEnd ( opts : Options ) : typeRule { return ( rootInsert , change , range , fragment , insertOptions , next ) => { if ( fragment . nodes . size === 0 ) { return next ( insertOptions ) ; } const fragmentTable = fragment . nodes . last ( ) ; if ( fragmentTable . type !== opts . typeTable ) { return next ( insertOptions ) ; } const startPosition = EditTablePosition . create ( { node : change . value . document , range : range . collapseToStart ( ) , opts } ) ; const endPosition = EditTablePosition . create ( { node : change . value . document , range : range . collapseToEnd ( ) , opts } ) ; if ( startPosition . isSameTable ( endPosition ) && ! startPosition . isAtStartOfTable ( ) ) { return next ( insertOptions ) ; } if ( ! endPosition . isInTable ( ) || ! endPosition . isFirstRow ( ) ) { return next ( insertOptions ) ; } const { table , cellIndex , row } = endPosition ; if ( ! isSameWidth ( table , fragmentTable ) ) { return next ( insertOptions ) ; } const { document } = change . value ; const { lastNodeAsText } = insertOptions ; let nextTable = table ; if ( lastNodeAsText ) { const fragmentRow = fragmentTable . nodes . last ( ) ; const nextRow = pasteSingleRow ( row , fragmentRow , 0 , cellIndex , true ) ; nextTable = table . updateNode ( nextRow ) ; } const beforeRows = lastNodeAsText ? fragmentTable . nodes . pop ( ) : fragmentTable . nodes ; nextTable = nextTable . set ( 'nodes' , beforeRows . concat ( nextTable . nodes ) ) ; change . replaceNodeByKey ( nextTable . key , nextTable , { normalize : false } ) ; fragment = fragment . set ( 'nodes' , fragment . nodes . pop ( ) ) ; const prevBlock = document . getPreviousBlock ( table . key ) ; if ( ! prevBlock ) { range = range . collapseToStartOf ( fragmentTable ) ; insertOptions = insertOptions . set ( 'firstNodeAsText' , false ) ; } else { range = range . moveFocusToEndOf ( prevBlock ) ; if ( startPosition . isSameTable ( endPosition ) ) { range = range . moveToFocus ( ) ; } } return rootInsert ( change , range , fragment , insertOptions . set ( 'lastNodeAsText' , false ) ) ; } ; } 
function appendTableAtRangeStart ( opts : Options ) : typeRule { return ( rootInsert , change , range , fragment , insertOptions , next ) => { if ( fragment . nodes . size === 0 ) { return next ( insertOptions ) ; } const fragmentTable = fragment . nodes . first ( ) ; if ( fragmentTable . type !== opts . typeTable ) { return next ( insertOptions ) ; } const startPosition = EditTablePosition . create ( { node : change . value . document , range : range . collapseToStart ( ) , opts } ) ; const endPosition = EditTablePosition . create ( { node : change . value . document , range : range . collapseToEnd ( ) , opts } ) ; if ( ! startPosition . isInTable ( ) || startPosition . isSameTable ( endPosition ) || ! startPosition . isLastRow ( ) ) { return next ( insertOptions ) ; } const { table , cellIndex , row } = startPosition ; if ( ! isSameWidth ( table , fragmentTable ) ) { return next ( insertOptions ) ; } const { document } = change . value ; const { firstNodeAsText } = insertOptions ; let nextTable = table ; if ( firstNodeAsText ) { const fragmentRow = fragmentTable . nodes . first ( ) ; const nextRow = pasteSingleRow ( row , fragmentRow , cellIndex , - 1 ) ; nextTable = table . updateNode ( nextRow ) ; } const afterRows = firstNodeAsText ? fragmentTable . nodes . shift ( ) : fragmentTable . nodes ; nextTable = nextTable . set ( 'nodes' , nextTable . nodes . concat ( afterRows ) ) ; change . replaceNodeByKey ( nextTable . key , nextTable , { normalize : false } ) ; fragment = fragment . deleteIn ( [ 'nodes' , 0 ] ) ; const nextBlock = document . getNextBlock ( table . key ) ; if ( ! nextBlock ) { range = range . collapseToEndOf ( fragmentTable ) ; insertOptions = insertOptions . set ( 'lastNodeAsText' , false ) ; } else { range = range . moveAnchorToStartOf ( nextBlock ) ; if ( startPosition . isSameTable ( endPosition ) ) { range = range . moveToAnchor ( ) ; } } return rootInsert ( change , range , fragment , insertOptions . set ( 'firstNodeAsText' , false ) ) ; } ; } 
function PackageMemberListReadStream ( dirToScan ) { sjl . throwTypeErrorIfEmpty ( 'PackageMemberListReadStream' , 'dirToScan' , dirToScan , String ) ; this . _pathToRead = dirToScan ; Readable . call ( this , { encoding : 'utf8' , objectMode : false , highWaterMark : 100000 , } ) ; } 
function doesLoadBalancerExist ( elb , loadBalancerName ) { function inspectError ( err ) { if ( err . code === 'LoadBalancerNotFound' ) { return false } return Bluebird . reject ( err ) } return elb . describeLoadBalancersPromised ( { LoadBalancerNames : [ loadBalancerName ] } ) . then ( _ . constant ( true ) ) . error ( inspectError ) } 
function lint ( files ) { return gulp . src ( files ) . pipe ( $ . plumber ( ) ) . pipe ( $ . eslint ( ) ) . pipe ( $ . eslint . format ( ) ) . pipe ( $ . eslint . failOnError ( ) ) . pipe ( $ . jscs ( ) ) . pipe ( $ . notify ( _jscsNotify ) ) ; } 
function _browserifyBundle ( ) { let bundler = browserifyBundler ( ) ; 
function ( groupName , tree ) { this . key = groupName ; this . resolved = false ; this . dependants = [ ] ; this . plugins = { } ; this . result = { } ; this . tree = tree ; } 
function PauseCommand ( args , define ) { if ( args . length ) { this . message = new statements . ExpressionStatement ( args , define ) ; if ( this . message . error ) throw this . message . error ; } else this . message = new statements . StringStatement ( "[<< Paused, Press RETURN to Continue >>]" ) ; } 
function ValidationErrors ( errors ) { this . errors = errors ? errors : { } ; this . addError = function ( field , message ) { if ( ! this . errors [ field ] ) { this . errors [ field ] = [ ] ; } this . errors [ field ] . push ( util . format ( message , field ) ) ; } ; 
function LineCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 4 ) throw new SyntaxError ( 'LINE command requires 4 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . width = parsed . args . length > 4 ? parsed . args [ 4 ] : false ; } 
function PointCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'POINT command requires 2 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; if ( parsed . args . length > 2 ) this . size = parsed . args [ 2 ] ; else this . size = false ; } 
function getRandom ( data ) { var x = Math . sin ( data . getPrivate ( 'rnd_seed' ) ) * 10000 ; data . setPrivate ( 'rnd_seed' , data . getPrivate ( 'rnd_seed' ) + 1 ) ; return x - Math . floor ( x ) ; } 
function ForCommand ( args , define ) { var lowerArgs = args . toLowerCase ( ) ; var toIndex = lowerArgs . indexOf ( ' to ' ) ; if ( toIndex === - 1 ) throw new SyntaxError ( 'FOR has no TO' ) ; var assignmentText = args . substring ( 0 , toIndex ) . trim ( ) ; var stepIndex = lowerArgs . indexOf ( ' step ' ) ; var upperLimitText , stepText ; if ( stepIndex === - 1 ) { upperLimitText = args . substring ( toIndex + 4 ) . trim ( ) ; stepText = '1' ; } else { upperLimitText = args . substring ( toIndex + 4 , stepIndex ) . trim ( ) ; stepText = args . substring ( stepIndex + 6 ) . trim ( ) ; } var assignmentEquals = assignmentText . indexOf ( '=' ) ; if ( assignmentEquals === - 1 ) throw new SyntaxError ( 'Expected assignment' ) ; var variableName = assignmentText . substring ( 0 , assignmentEquals ) . trim ( ) ; var equalsExpression = assignmentText . substring ( assignmentEquals + 1 ) . trim ( ) ; var assignmentExpr = new statements . AssignmentStatement ( new statements . VariableStatement ( variableName ) , new statements . ExpressionStatement ( equalsExpression , define ) ) ; var upperLimitExpr = new statements . ExpressionStatement ( upperLimitText , define ) ; if ( upperLimitExpr . error ) throw upperLimitExpr . error ; var stepExpr = new statements . ExpressionStatement ( stepText , define ) ; if ( stepExpr . error ) throw stepExpr . error ; this . assignmentExpr = assignmentExpr ; this . upperLimitExpr = upperLimitExpr ; this . stepExpr = stepExpr ; this . block = define ( { start : 'FOR' , end : 'NEXT' } ) ; this . loopCount = 0 ; } 
function OrderProcessing ( objGoogleCheckout ) { var self = this ; 
function checkSecond ( samasa , second ) { var beg = u . first ( second ) ; var clean = second ; if ( ! inc ( [ c . h , c . S , c . oM ] , beg ) ) return second ; var position = samasa . length - second . length ; var sym = samasa [ position ] ; if ( beg == c . h ) { 
function addOptions ( first , second ) { var first = first . split ( '' ) ; var second = second . split ( '' ) ; var fin = first . slice ( - 1 ) [ 0 ] ; if ( inc ( c . consonants , fin ) ) fin = '' ; var penult = first . slice ( - 2 ) [ 0 ] ; var beg = second [ 0 ] ; var opt ; var candra ; if ( fin == c . virama ) { 
function createMicAnalyser ( engine , callback ) { var entity , node ; if ( ! this . _context ) { this . _context = new ( window . AudioContext || window . webkitAudioContext ) ( ) ; } entity = new Serpentity . Entity ( ) ; this . _getUserMedia ( { audio : true } , this . _onUserMedia . bind ( this , engine , entity , callback ) , this . _onUserMediaError . bind ( this , entity , callback ) ) } 
function _onUserMedia ( engine , entity , callback , localMediaStream ) { var source , analyser ; source = this . _context . createMediaStreamSource ( localMediaStream ) ; analyser = this . _context . createAnalyser ( ) ; source . connect ( analyser ) ; entity . addComponent ( new Serpentity . Contrib . Components . Analyser ( { analyser : analyser } ) ) ; entity . addComponent ( new Serpentity . Contrib . Components . Configuration ( { config : { } } ) ) ; engine . addEntity ( entity ) ; callback ( entity ) ; } 
function makeUploadTask ( cwd , file ) { var key = options . keyGen ( cwd , file ) ; function doUpload ( callback ) { var absolutePath = path . join ( cwd , file ) ; grunt . log . ok ( 'Start uploading the file [' + file + '], qiniu key is: [' + key + ']' ) ; client . uploadFile ( absolutePath , { key : key } , function ( err , result ) { if ( ! err ) { grunt . log . ok ( 'The file [' + file + '] has been uploaded yet.' ) ; } callback ( err , result ) ; } ) ; } return function ( callback ) { if ( options . ignoreDup ) { 
function Emitter ( opts ) { Transform . call ( this ) ; this . _writableState . objectMode = true ; this . _readableState . objectMode = true ; opts = opts || { } ; 
function MQlobberServer ( fsq , stream , options ) { EventEmitter . call ( this ) ; options = options || { } ; this . fsq = fsq ; this . subs = new Set ( ) ; this . _done = false ; this . mux = new BPMux ( stream , util . _extend ( util . _extend ( { } , options ) , { high_channels : true } ) ) ; var ths = this ; function error ( err ) { ths . emit ( 'error' , err , this ) ; } function warning ( err ) { if ( err && ! ths . emit ( 'warning' , err , this ) ) { console . error ( err ) ; } } this . _warning = warning ; this . mux . on ( 'error' , error ) ; function handshake_sent ( duplex , complete ) { if ( ! complete ) { ths . emit ( 'backoff' ) ; } } this . mux . on ( 'handshake_sent' , handshake_sent ) ; this . mux . on ( 'pre_handshake_sent' , handshake_sent ) ; this . mux . on ( 'drain' , function ( ) { ths . emit ( 'drain' ) ; } ) ; this . mux . on ( 'full' , function ( ) { ths . emit ( 'full' ) ; } ) ; this . mux . on ( 'removed' , function ( duplex ) { ths . emit ( 'removed' , duplex ) ; } ) ; this . mux . on ( 'finish' , function ( ) { ths . _done = true ; if ( ! ths . emit ( 'unsubscribe_all_requested' , warning ) ) { ths . default_unsubscribe_all_requested_handler ( ) ; } } ) ; this . relay_error = function ( err ) { switch ( this . _readableState . pipesCount ) { case 0 : break ; case 1 : this . _readableState . pipes . emit ( 'error' , err ) ; break ; default : var dests = new Set ( ) , dest ; for ( dest of this . _readableState . pipes ) { dests . add ( dest ) ; } for ( dest of dests ) { dest . emit ( 'error' , err ) ; } break ; } } ; this . handler = function ( data , info , cb3 ) { var called = false ; function cb ( err , cb2 ) { warning ( err ) ; if ( ! called ) { cb3 . num_handlers -= 1 ; called = true ; } if ( options . defer_to_final_handler && ( cb3 . num_handlers > 0 ) ) { if ( cb2 ) { return cb2 ( err ) ; } return ; } cb3 ( err , cb2 ) ; } data . on ( 'error' , warning ) ; data . on ( 'error' , ths . relay_error ) ; if ( ! info . single ) { data . on ( 'end' , cb ) ; } var hdata = [ new Buffer ( 1 ) ] , buf ; hdata [ 0 ] . writeUInt8 ( ( info . single ? 1 : 0 ) | ( ( options . send_expires ? 1 : 0 ) << 1 ) | ( ( info . existing ? 1 : 0 ) << 2 ) | ( ( options . send_size ? 1 : 0 ) << 3 ) , 0 ) ; if ( options . send_expires ) { buf = new Buffer ( 8 ) ; var expires = Math . floor ( info . expires / 1000 ) ; 
function map ( obj , fn , squash ) { var a = [ ] , key , keys , x , doBreak = false ; if ( Array . isArray ( obj ) ) { for ( key = 0 ; key < obj . length ; key ++ ) { doCall ( key , obj ) if ( doBreak ) { break ; } } } else if ( obj !== null && typeof ( obj ) === 'object' ) { keys = Object . keys ( obj ) ; for ( x = 0 ; x < keys . length ; x ++ ) { doCall ( keys [ x ] , obj ) ; if ( doBreak ) { break ; } } } else if ( typeof ( obj ) === 'string' ) { for ( key in obj ) { doCall ( key , obj ) ; if ( doBreak ) { break ; } } } else { return [ ] ; } return a ; function doCall ( key , obj ) { var t = fn . call ( obj [ key ] , key , obj [ key ] , emit , end ) ; if ( ( t !== undefined && t !== null && squash ) || ! squash ) { a . push ( t ) ; } } function emit ( obj ) { return a . push ( obj ) } function end ( ) { doBreak = true ; } } 
function freeMemory ( mappedVars , step ) { if ( mappedVars . length > 0 ) { let mappedVarsStringify = [ ] for ( let mappedVar of mappedVars ) { if ( mappedVar . hasOwnProperty ( "self" ) && mappedVar . self ) { delete mappedVar . self . code mappedVarsStringify . push ( JSON . stringify ( mappedVar . self ) ) } } return simpleEval ( ` ${ mappedVarsStringify . join ( ',' ) } ` , false , step ) } } 
function ( opts ) { if ( ! navigator . camera ) { return $q . reject ( new Error ( 'Camera module (navigator.camera) not available' ) ) ; } 
function getHashEncodedPair ( n ) { getBytes ( function ( keyBuffer ) { getBytes ( function ( valueBuffer , output ) { object . value [ keyBuffer . toString ( encoding ) ] = raw ? valueBuffer : valueBuffer . toString ( encoding ) ; object . length ++ ; next ( n ) ; } ) ; } ) ; } 
function getListEntry ( n ) { getBytes ( function ( entryBuffer ) { result . push ( raw ? entryBuffer : entryBuffer . toString ( encoding ) ) ; next ( n ) ; } ) ; } 
function DrawtextCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'DRAWTEXT command requires 3 arguments' ) ; else if ( parsed . args . length > 3 && parsed . args . length < 5 ) throw new SyntaxError ( 'DRAWTEXT command requires 5 arguments' ) ; this . text = parsed . args [ 0 ] ; this . x1 = parsed . args [ 1 ] ; this . y1 = parsed . args [ 2 ] ; if ( parsed . args . length > 3 ) { this . x2 = parsed . args [ 3 ] ; this . y2 = parsed . args [ 4 ] ; } else { this . x2 = false ; this . y2 = false ; } } 
function fXMLHttpRequest_send ( oRequest ) { oRequest . _object . send ( oRequest . _data ) ; console && console . log ( 'fXMLHttpRequest_send' , oRequest . readyState ) ; 
function writeLockFile ( path , data , cb ) { 
function Validator ( ) { var self = this , args = fun ( arguments ) ; self . klass = self . klass || Validator ; self . options = Object . merge ( self . klass . defaults . options , args . objects ( ) [ 0 ] || { } , true ) ; self . engine = null ; } 
function callHandlers ( cults , e ) { var broken = false ; for ( var i = 0 ; i < cults . length ; i ++ ) { var cult = cults [ i ] ; var handlers = cult && cult . events && cult . events [ e . type ] ; if ( ! handlers ) continue ; var selectors = Object . keys ( handlers ) ; if ( callHandler ( cult , e , handlers , selectors ) === false ) { broken = true ; break ; } } return broken ; } 
function fn ( modelGetter , opts ) { if ( typeof modelGetter !== 'function' ) { throw new Error ( ` ` ) ; } for ( const key in actions ) { let action = actions [ key ] ; if ( opts . override && ( typeof opts . override [ key ] === 'function' ) ) { action = opts . override [ key ] ; } actions [ key ] = action ( modelGetter , opts ) ; } module . exports = actions ; return actions ; } 
function faviconRequestHandler ( req , res , next ) { var icon = '' if ( typeof req . url !== 'string' ) { return next ( ) } if ( url . parse ( req . url ) . pathname !== '/favicon.ico' ) { return next ( ) } res . setHeader ( 'content-length' , icon . length ) res . setHeader ( 'content-type' , 'image/x-icon' ) res . send ( icon ) } 
function ( def ) { var start = Array . isArray ( def . start ) ? def . start : [ def . start ] ; var end = Array . isArray ( def . end ) ? def . end : [ def . end ] ; var then = def . then ? ( Array . isArray ( def . then ) ? def . then : [ def . then ] ) : [ ] ; var child = new Block ( line , { start : start , end : end , then : then } , self ) ; self . children . push ( child ) ; return child ; } 
function randoService ( incomingPayload , cb ) { var buf = dataUriToBuffer ( incomingPayload . content . data ) randomRevisitor ( buf . imgType , postToRandom ) function postToRandom ( err , randomUrl ) { if ( err ) return cb ( err ) request . post ( { json : true , url : randomUrl + '/service' , body : incomingPayload } , function ( err , response , body ) { if ( body && ! body . content ) console . error ( 'Something went wrong connecting to: ' + randomUrl ) if ( err ) return cb ( err ) return cb ( null , ( body && body . content && body . content . data ) ? body : incomingPayload ) } ) } } 
function entry ( object ) { var buffer ; switch ( object . type ) { case 'header' : buffer = this . header ( object . version ) ; break ; case 'database' : buffer = this . database ( object . number ) ; break ; case 'key' : buffer = this . key ( object ) ; 
function database ( n ) { var dbid = new Buffer ( [ 0xFE ] ) , len = this . getLengthEncoding ( n , false ) ; return Buffer . concat ( [ dbid , len ] , dbid . length + len . length ) ; } 
function key ( obj , vonly ) { var buffer = new Buffer ( 0 ) , item ; if ( obj . expiry !== undefined && ! vonly ) { buffer = this . expiry ( obj . expiry ) ; } item = this [ obj . rtype ] ( obj , vonly ) ; return Buffer . concat ( [ buffer , item ] , buffer . length + item . length ) } 
function expiry ( expires ) { var buffer , int64 ; if ( expires % 1000 === 0 ) { buffer = new Buffer ( 5 ) ; buffer . writeUInt8 ( 0xFD , 0 ) ; buffer . writeInt32LE ( expires / 1000 , 1 ) ; } else { buffer = new Buffer ( 9 ) ; int64 = new Int64 ( expires ) ; buffer . writeUInt8 ( 0xFC , 0 ) ; buffer . writeUInt32LE ( int64 . low32 ( ) , 1 ) ; buffer . writeUInt32LE ( int64 . high32 ( ) , 5 ) ; } return buffer ; } 
function string ( obj , vonly ) { var vtype = this . type ( 0 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , value = this . getStringBuffer ( obj . value ) ; return Buffer . concat ( [ vtype , key , value ] , vtype . length + key . length + value . length ) } 
function list ( obj , vonly ) { var vtype = this . type ( 1 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , len = this . getLengthEncoding ( obj . value . length , false ) , value = this . array ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) } 
function zset ( obj , vonly ) { var vtype = this . type ( 3 ) , key = ! vonly ? this . getStringBuffer ( obj . key ) : new Buffer ( 0 ) , length = obj . length !== undefined ? obj . length : Object . keys ( obj . value ) . length , len = this . getLengthEncoding ( length , false ) , value = this . object ( obj . value ) ; return Buffer . concat ( [ vtype , key , len , value ] , vtype . length + key . length + len . length + value . length ) } 
function array ( arr ) { var buffers = [ ] , buf , i , len = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) { buf = this . getStringBuffer ( arr [ i ] ) ; len += buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; } 
function object ( obj ) { var buffers = [ ] , buf , k , v , len = 0 ; for ( k in obj ) { buf = this . getStringBuffer ( k ) ; len += buf . length ; buffers . push ( buf ) ; buf = this . getStringBuffer ( obj [ k ] ) ; len += buf . length ; buffers . push ( buf ) ; } return Buffer . concat ( buffers , len ) ; } 
function getStringBuffer ( s ) { var buffer , n = typeof s === 'number' ? s : null 
function length ( buffer , n , special ) { var len = this . getLengthEncoding ( n , special ) ; return Buffer . concat ( [ len , buffer ] , len . length + buffer . length ) ; } 
function getLengthEncoding ( n , special ) { if ( n < 0 ) throw new Error ( 'Cannot write negative length encoding: ' + n ) ; if ( ! special ) { if ( n <= 0x3F ) { return new Buffer ( [ n ] ) ; } else if ( n <= 0x3FFF ) { return new Buffer ( [ 0x40 | ( n >> 8 ) , n & 0xFF ] ) ; } else if ( n <= 0xFFFFFFFF ) { var buffer = new Buffer ( 5 ) ; buffer . writeUInt8 ( 0x80 , 0 ) ; buffer . writeUInt32BE ( n , 1 ) ; return buffer ; } throw new Error ( 'Failed to write length encoding: ' + n ) ; } else { if ( n > 0x3F ) { throw new Error ( 'Cannot encode ' + n + ' using special length encoding' ) ; } return new Buffer ( [ 0xC0 | n ] ) ; } } 
function TextfontCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length > 2 ) { this . family = parsed . args [ 0 ] ; this . style = parsed . args [ 1 ] ; this . size = parsed . args [ 2 ] ; } else if ( parsed . args . length > 1 ) { this . familyOrStyle = parsed . args [ 0 ] ; this . size = parsed . args [ 1 ] ; } else if ( parsed . args . length > 0 ) { var arg = parsed . args [ 0 ] ; if ( arg . child . type === 'string' || arg . child instanceof statements . StringStatement ) this . familyOrStyle = arg ; else this . size = arg ; } else { this . reset = true ; } } 
function MerchantCalculations ( objGoogleCheckout ) { var self = this ; 
function replace ( value , configData ) { if ( typeof value != "string" ) { return value ; } else { return value . replace ( propStringTmplRe , function ( match , path ) { var value = get ( configData , path ) ; if ( ! ( value instanceof Error ) ) { return value ; } else { return match ; } } ) ; } } 
function get ( object , path ) { if ( memoGet [ path ] ) { return new Error ( "circular reference for " + path ) ; } var parts = path . split ( "." ) ; var obj = object ; while ( typeof obj === "object" && obj && parts . length ) { var part = parts . shift ( ) ; if ( ! ( part in obj ) ) { return new Error ( "invalid path" ) ; } obj = obj [ part ] ; } memoGet [ path ] = true ; 
function entropy ( sigma , options ) { var opts = { } , ctor , err , out , dt , d ; if ( isNumber ( sigma ) || isnan ( sigma ) ) { return entropy1 ( sigma ) ; } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( isMatrixLike ( sigma ) ) { if ( opts . copy !== false ) { dt = opts . dtype || 'float64' ; ctor = ctors ( dt ) ; if ( ctor === null ) { throw new Error ( 'entropy()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' ) ; } 
function checkBug ( ) { 
function workaround ( ) { var node = document . createElement ( 'div' ) ; function matches ( element , selector ) { if ( method . call ( element , selector ) ) { return true ; } else if ( ! element . parentNode ) { 
function allow ( action , req , res , cb ) { 
function clean ( action , result , req , res , cb ) { 
function performCrudAction ( action , req , res , next ) { allow ( action , req , res , function ( err , isAllowed ) { if ( err ) { return Model . swr . error . serverError ( res ) ; } if ( ! isAllowed ) { return Model . swr . error . forbidden ( res ) ; } switch ( action ) { case options . actions . find : find ( action , req , res , function ( err , result ) { if ( err ) { return Model . swr . error . serverError ( res ) ; } Model . swr . success ( result , res ) ; next ( ) ; } ) ; break ; } } ) ; } 
function find ( action , req , res , cb ) { var result = { } ; 
function ( sentence ) { const split = sentence . toLowerCase ( ) . split ( / \s+ / ) ; for ( const word of split ) { if ( bannedWords . indexOf ( word ) !== - 1 ) return false ; } return true ; } 
function file2obj ( file ) { if ( ! fs . existsSync ( file ) ) { return { } ; } try { var buffer = JSON . parse ( fs . readFileSync ( file ) , { 'encoding' : 'utf8' } ) ; if ( ! ( buffer && ( typeof buffer === 'object' ) ) ) { throw new TypeError ( 'Failed to parse file as an object: ' + file ) ; } return buffer ; } catch ( e ) { throw new TypeError ( "Failed to read file " + file + ": " + e ) ; } } 
function append_to ( config , obj ) { if ( config === undefined ) { 
function dispatch ( ctx ) { if ( _curCtx ) { var ret = _curCtx . route . exit ( { path : _curCtx . path , params : _curCtx . params } , true ) ; if ( ! ret ) { return ; } } _prevCtx = _curCtx ; _curCtx = ctx ; if ( ! _curCtx . route ) { var m = map ( _curCtx . path ) ; _curCtx . route = m . route ; _curCtx . params = m . params ; } var r = _curCtx . route . enter ( { force : _curCtx . force , path : _curCtx . path , params : _curCtx . params } , true ) ; langx . Deferred . when ( r ) . then ( function ( ) { _hub . trigger ( createEvent ( "routing" , { current : _curCtx , previous : _prevCtx } ) ) ; _curCtx . route . enter ( { path : _curCtx . path , params : _curCtx . params } , false ) ; if ( _prevCtx ) { _prevCtx . route . exit ( { path : _prevCtx . path , params : _prevCtx . params } , false ) ; } _hub . trigger ( createEvent ( "routed" , { current : _curCtx , previous : _prevCtx } ) ) ; } ) ; } 
function start ( ) { if ( router . useHashbang == null && router . useHistoryApi == null ) { if ( window . location . host && window . history . pushState ) { eventer.on(document.body, "click", "a[href]", function(e) { var elm = e.currentTarget, url = elm.getAttribute("href"); if (url == "#") { return; } if (url && langx.isSameOrigin(elm.href)) { if (url.indexOf(_baseUrl) === 0) { url = url.substr(_baseUrl.length); eventer.stop(e); url = url.replace('#!', ''); go(url); } } }); */ if ( router . useHistoryApi ) { window . addEventListener ( "popstate" , function ( e ) { if ( e . state ) dispatch ( e . state ) ; e . preventDefault ( ) ; } ) ; } else if ( router . useHashbang ) { window . addEventListener ( "hashchange" , function ( e ) { dispatch ( { path : window . location . hash . replace ( / ^#! / , "" ) } ) ; e . preventDefault ( ) ; } ) ; } go ( initPath ) ; } 
function ( ) { var curCtx = router . current ( ) , prevCtx = router . previous ( ) ; var content = curCtx . route . render ( curCtx ) ; if ( content === undefined || content === null ) { return ; } if ( langx . isString ( content ) ) { this . _rvc . innerHTML = content ; } else { this . _rvc . innerHTML = "" ; this . _rvc . appendChild ( content ) ; } curCtx . route . trigger ( createEvent ( "rendered" , { route : curCtx . route , content : content } ) ) ; } 
function ( key ) { var value ; if ( key . indexOf ( '.' ) == - 1 ) { value = this . configObj [ key ] ; } else { var keyArray = key . split ( '.' ) ; var keyStr = keyArray [ 0 ] ; value = this . configObj [ keyStr ] ; for ( var i = 1 , len = keyArray . length ; i < len ; i ++ ) { if ( ! value && i < len - 1 ) { exitProcess ( 'the var [' + keyStr + '] is empty.' , this . alarm ) ; return undefined ; } var keyNow = keyArray [ i ] ; keyStr += '.' + keyNow ; value = value [ keyNow ] ; } } slogger . debug ( 'load var [' + key + '],value:' , value ) ; return value ; } 
function ( key ) { var value = this . loadVar ( key ) ; if ( typeof ( value ) == 'undefined' ) { exitProcess ( 'the value of ' + key + ' is necessary , but now is undefined' , this . alarm ) ; return false ; } return value ; } 
function ( key ) { var str = this . loadVar ( key ) ; if ( typeof ( str ) != 'string' ) { exitProcess ( 'the value of ' + key + ' is a necessary string, but get ' + str , this . alarm ) ; return false ; } return str ; } 
function ( key ) { var num = parseInt ( this . loadVar ( key ) ) ; if ( isNaN ( num ) ) { exitProcess ( 'the value of ' + key + ' is a necessary int ,but get ' + num , this . alarm ) ; return false ; } return num ; } 
function ( key ) { var obj = this . loadVar ( key ) ; if ( ! obj || typeof ( obj ) != 'object' ) { exitProcess ( 'the value of ' + key + ' is a necessary object ,but get ' + obj , this . alarm ) ; return false ; } return obj ; } 
function ( key , onlyCheckDirectory ) { var filePath = this . loadVar ( key ) ; if ( ! filePath ) { exitProcess ( 'empty file path for ' + key , this . alarm ) ; return false ; } if ( ! onlyCheckDirectory ) { if ( ! fs . existsSync ( filePath ) ) { exitProcess ( 'the value of ' + key + ' is a necessary file ,but not exists in ' + filePath , this . alarm ) ; return false ; } } else { var dirname = path . dirname ( filePath ) ; if ( ! fs . lstatSync ( dirname ) . isDirectory ( ) ) { exitProcess ( 'the path ' + dirname + ' must exist and be a directory' , this . alarm ) ; return false ; } } return filePath ; } 
function ( key , endWithSeparator ) { var filepath = this . loadNecessaryFile ( key ) ; if ( ! filepath ) { exitProcess ( 'empty directory for ' + key , this . alarm ) ; return false ; } if ( ! fs . lstatSync ( filepath ) . isDirectory ( ) ) { exitProcess ( 'the path ' + filepath + ' must be a directory' , this . alarm ) ; return false ; } if ( endWithSeparator && ! filepath . endWith ( path . sep ) ) { exitProcess ( 'the path ' + filepath + ' must be end with a separator' , this . alarm ) ; return false ; } return filepath ; } 
function ( key , endWithSeparator ) { var url = this . loadNecessaryString ( key ) ; if ( ! url ) { exitProcess ( 'empty url for ' + key , this . alarm ) ; return false ; } if ( ! url . startWith ( 'http://' ) && ! url . startWith ( 'https://' ) ) { exitProcess ( 'invalid url:' + url , this . alarm ) ; return false ; } if ( endWithSeparator && ! url . endWith ( '/' ) ) { exitProcess ( 'the url[' + url + '] must be end with /' , this . alarm ) ; return false ; } if ( ! endWithSeparator && url . endWith ( '/' ) ) { exitProcess ( 'the url[' + url + '] must not be end with /' , this . alarm ) ; return false ; } return url ; } 
function VariableStatement ( name ) { var bracketIndex = name . indexOf ( '(' ) ; if ( bracketIndex !== - 1 ) { var endBracketIndex = name . indexOf ( ')' ) ; if ( endBracketIndex === - 1 ) throw new SyntaxError ( 'Expected end bracket' ) ; var arrayName = name . substring ( 0 , bracketIndex ) ; var arrayDimensionsText = name . substring ( bracketIndex + 1 , endBracketIndex ) . trim ( ) ; var arrayDimensions = new statements . ArgumentStatement ( arrayDimensionsText ) ; name = arrayName ; this . isArray = true ; this . dimensions = arrayDimensions . args ; } else this . isArray = false ; if ( name [ name . length - 1 ] === '$' ) { this . type = 'string' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number' ; this . name = name ; } } 
function install ( ) { if ( ! fs . existsSync ( path . resolve ( __dirname , 'vendor' , 'pdfcrop_v0.4b' , 'pdfcrop' ) ) ) { var url = 'http://downloads.sourceforge.net/project/pdfcrop/pdfcrop/PDFCrop%20v0.4b/pdfcrop_v0.4b.tar.gz' var write = targz ( ) . createWriteStream ( path . resolve ( __dirname , 'vendor' ) ) ; var req = http . request ( url , function ( res ) { res . pipe ( write ) write . on ( 'finish' , function ( ) { console . log ( 'pdfcrop installed' ) } ) } ) } if ( process . platform == 'linux' ) { if ( ! spawnSync ( 'apt-get' , [ '-v' ] ) . error ) { console . log ( "apt-get install plotutils perl ghostscript plotutils pdf2svg" ) p = exec ( "apt-get install plotutils perl ghostscript plotutils pdf2svg" ) p . stderr . pipe ( process . stderr ) p . stdout . pipe ( process . stdout ) } else { console . log ( "sorry only apt-get supported right now for automatic install" ) console . log ( "You have to install the following packages:" ) console . log ( " - perl" ) console . log ( " - ghostscript" ) console . log ( " - plotutils" ) console . log ( " - pdf2svg" ) } } else if ( process . platform == 'darwin' ) { if ( ! spawnSync ( 'brew' , [ '-v' ] ) . error ) { console . log ( "brew install plotutils perl ghostscript plotutils pdf2svg" ) p = exec ( "brew install plotutils perl ghostscript plotutils pdf2svg" ) p . stderr . pipe ( process . stderr ) p . stdout . pipe ( process . stdout ) } else { console . log ( "You have to install Homebrew from http://brew.sh first" ) } } else { console . log ( "Sorry, your system is not supported for automatic install" ) console . log ( "You have to install the following packages:" ) console . log ( " - perl" ) console . log ( " - ghostscript" ) console . log ( " - plotutils" ) console . log ( " - pdf2svg" ) } } 
function IOInterface ( output , input , data ) { this . _output = output || function ( ) { } ; this . _input = input || function ( done ) { done ( '\n' ) ; } ; this . _data = data || { } ; } 
function ( url , entry , options ) { if ( ! S . isObj ( options ) ) options = { full : options } ; if ( entry === false || entry === true ) throw new Error ( 'Entry param cannot be false or true' ) ; if ( entry == null ) { entry = this . req . entry ; options . full = ( '/~' + entry || options . full === true ? Config . siteUrl [ entry ] : '' ) ; } else if ( ( entry !== this . req . entry && options . full !== false ) || options . full === true ) options . full = ( '/~' + entry || Config . siteUrl [ entry ] ) ; else options . full = ( '/~' + entry || '' ) ; options . full = '' ; if ( S . isString ( url ) || ! url ) { if ( url ) url = url . trim ( ) ; if ( ! url || url === '/' ) return options . full + '/' ; else { if ( url . contains ( '://' ) ) return url ; if ( url . startsWith ( '\\/' ) ) return url . substr ( 1 ) ; if ( url . charAt ( 0 ) === '/' ) return options . full + this . router . getStringLink ( this . req . lang , entry , url . substr ( 1 ) ) ; } } else { return ( options . full || '' ) + this . router . getArrayLink ( this . req . lang , entry , url ) ; } } 
function ( ) { var versions = [ "Msxml2.XMLHTTP" , "Msxml3.XMLHTTP" , "Microsoft.XMLHTTP" , "MSXML2.XmlHttp.6.0" , "MSXML2.XmlHttp.5.0" , "MSXML2.XmlHttp.4.0" , "MSXML2.XmlHttp.3.0" , "MSXML2.XmlHttp.2.0" ] if ( XMLHttpRequest !== undefined ) { 
function isLikeAFuture ( x ) { return x . isResolved !== undefined && x . queue !== undefined && x . then !== undefined } 
function ( e ) { if ( e [ 'arguments' ] && e . stack ) { return 'chrome' ; } else if ( e . stack && e . sourceURL ) { return 'safari' ; } else if ( e . stack && e . number ) { return 'ie' ; } else if ( typeof e . message === 'string' && typeof window !== 'undefined' && window . opera ) { 
function ( context , functionName , callback ) { context = context || window ; var original = context [ functionName ] ; context [ functionName ] = function instrumented ( ) { callback . call ( this , printStackTrace ( ) . slice ( 4 ) ) ; return context [ functionName ] . _instrumented . apply ( this , arguments ) ; } ; context [ functionName ] . _instrumented = original ; } 
function ( e ) { var stack = ( e . stack + '\n' ) . replace ( / ^\S[^\(]+?[\n$] / gm , '' ) . replace ( / ^\s+(at eval )?at\s+ / gm , '' ) . replace ( / ^([^\(]+?)([\n$]) / gm , '{anonymous}()@$1$2' ) . replace ( / ^Object.<anonymous>\s*\(([^\)]+)\) / gm , '{anonymous}()@$1' ) . split ( '\n' ) ; stack . pop ( ) ; return stack ; } 
function ( e ) { var lineRE = / ^.*at (\w+) \(([^\)]+)\)$ / gm ; return e . stack . replace ( / at Anonymous function / gm , '{anonymous}()@' ) . replace ( / ^(?=\w+Error\:).*$\n / m , '' ) . replace ( lineRE , '$1@$2' ) . split ( '\n' ) ; } 
function ( e ) { 
function ( url ) { 
function recordAndTriggerHandlers ( type , eventData ) { this . history . push ( { type : type , data : eventData } ) this . handlers [ type ] . forEach ( function ( handlerInfo ) { try { handlerInfo . handler . call ( undefined , eventData ) } catch ( e ) { 
function ( name , mainTester , parentTester ) { if ( ! mainTester ) mainTester = this this . id = groupid ( ) this . mainTester = mainTester 
function remove ( array , item ) { console . log ( "attempting to remove " + item ) var index = array . indexOf ( item ) if ( index !== - 1 ) array . splice ( index , 1 ) 
function assert ( that , success , actualValue , expectedValue , type , functionName , lineInfo , stackIncrease ) { if ( ! stackIncrease ) stackIncrease = 1 if ( ! functionName ) functionName = "ok" if ( ! lineInfo ) var lineInfoFuture = getLineInformation ( functionName , stackIncrease , that . doSourcemappery , that . warningHandler ) else var lineInfoFuture = Future ( lineInfo ) 
function getMappedSourceInfo ( sourceMapConsumer , originalFilePath , originalLine , originalColumn , originalFunctionName ) { var sourceMapInfo = sourceMapConsumer . originalPositionFor ( { line : originalLine , column : originalColumn || 0 } ) if(sourceMapConsumer.sourceRoot !== null) { sourceMapInfo.source = sourceMapInfo.source.replace(sourceMapConsumer.sourceRoot, '') }*/ if ( relative ) { var file = Url . resolve ( originalFilePath , path . basename ( sourceMapInfo . source ) ) } else { var file = sourceMapInfo . source } var originalFile = true } else { var file = originalFilePath var originalFile = false } if ( fn === null || ! originalFile ) { fn = originalFunctionName } if ( line === null || ! originalFile ) { line = originalLine column = originalColumn } if ( column === null ) { column = undefined } if ( file != undefined && sourceMapConsumer . sourcesContent != undefined ) { 
function getFunctionCallLines ( sourcesContent , filePath , functionName , lineNumber , multiLineSearch , warningHandler ) { if ( sourcesContent !== undefined ) { var source = Future ( sourcesContent ) } else { var source = options . getScriptSourceLines ( filePath ) } return source . catch ( function ( e ) { warningHandler ( e ) return Future ( undefined ) } ) . then ( function ( fileLines ) { if ( fileLines !== undefined ) { var startLine = findStartLine ( fileLines , functionName , lineNumber ) if ( startLine === 'lineOfCodeNotFound' ) { return Future ( "<line of code not found (possibly an error?)> " ) } else if ( startLine !== 'sourceNotAvailable' ) { if ( multiLineSearch ) { return Future ( findFullSourceLine ( fileLines , startLine ) ) } else { return Future ( fileLines [ startLine ] . trim ( ) ) } } } 
function mapException ( exception , warningHandler ) { try { if ( exception instanceof Error ) { var stacktrace ; return options . getExceptionInfo ( exception ) . then ( function ( trace ) { stacktrace = trace var smcFutures = [ ] for ( var n = 0 ; n < trace . length ; n ++ ) { if ( trace [ n ] . file !== undefined ) { smcFutures . push ( getSourceMapConsumer ( trace [ n ] . file , warningHandler ) ) } else { smcFutures . push ( Future ( undefined ) ) } } return Future . all ( smcFutures ) } ) . then ( function ( sourceMapConsumers ) { var CustomMappedException = proto ( MappedException , function ( ) { 
function findFullSourceLine ( fileLines , startLine ) { var lines = [ ] var parenCount = 0 var mode = 0 
function findStartLine ( fileLines , functionName , lineNumber ) { var startLine = lineNumber - 1 while ( true ) { if ( startLine < 0 ) { return 'lineOfCodeNotFound' 
function ekurtosis ( p , options ) { var opts = { } , ctor , err , out , dt , d ; if ( isNumber ( p ) || isnan ( p ) ) { return ekurtosis1 ( p ) ; } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( isMatrixLike ( p ) ) { if ( opts . copy !== false ) { dt = opts . dtype || 'float64' ; ctor = ctors ( dt ) ; if ( ctor === null ) { throw new Error ( 'ekurtosis()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' ) ; } 
function ( ) { 
function ( string , args ) { string = this . locale ( ) . appTranslations [ string ] || string ; return args ? UString . vformat ( string , args ) : string ; } 
function mul ( s , n ) { var copies = new Array ( n ) ; while ( n -- ) copies [ n ] = s ; return concat ( copies ) ; } 
function palindrome ( s , i , j ) { while ( i < j ) if ( s [ i ++ ] !== s [ -- j ] ) return false ; return true ; } 
function outer ( samasa , next ) { 
function is ( argv , ... args ) { let type = toString . call ( argv ) ; 
function YearMonthForm ( { date , localeUtils , onChange , fromMonth , toMonth } ) { const months = localeUtils . getMonths ( ) ; const years = [ ] ; for ( let i = fromMonth . getFullYear ( ) ; i <= toMonth . getFullYear ( ) ; i += 1 ) { years . push ( i ) ; } const handleChange = function handleChange ( e ) { const { year , month } = e . target . form ; onChange ( new Date ( year . value , month . value ) ) ; } ; return ( < form className = "DayPicker-Caption" > < select name = "month" onChange = { handleChange } value = { date . getMonth ( ) } > { months . map ( ( month , i ) => < option key = { i } value = { i } > { month } < / option > ) } < / select > < select name = "year" onChange = { handleChange } value = { date . getFullYear ( ) } > { years . map ( ( year , i ) => < option key = { i } value = { year } > { year } < / option > ) } < / select > < / form > ) ; } 
function ( url , belong ) { return ( belong . replace ( / (.*[\/|\\]).* / gi , "$1" ) + url . replace ( / \?|\#.* / gi , "" ) ) . replace ( / [\\|\/][^\\|^\/]*[\\|\/]\.{2} / gi , "" ) ; } 
function ( str , dest ) { var _spilt = "cb==cb" , _imgs = str . replace ( / \s+ / gi , " " ) . replace ( / url\(([^\)]*)\) / gi , _spilt + "$1" + _spilt ) . split ( _spilt ) , _md5 , _dest ; for ( var i = _imgs . length ; i -- ; ) { if ( i % 2 ) { _img = tool . get_resource_path ( _imgs [ i ] . replace ( / [\'|\"|\s]* / gi , "" ) , dest ) ; if ( ! grunt . file . exists ( _img ) ) { continue ; } ; if ( ! config . resources [ _img ] ) { _md5 = [ "resources/" , tool . md5 ( config . md5 + new Date ( ) . getTime ( ) + parseInt ( Math . random ( ) * 999999999 ) ) , _img . replace ( / .*(\..*)$ / gi , "$1" ) ] . join ( "" ) ; config . resources [ _img ] = _md5 ; } else { _md5 = config . resources [ _img ] ; } ; _imgs [ i ] = "url('../" + _md5 + "')" ; } ; } ; return _imgs . join ( "" ) ; } 
function ( replace , dest ) { var _buffer = [ ] , _url , _code , _files = replace . css ; for ( var i = _files . length ; i -- ; ) { _url = config . dir . src_dir + _files [ i ] ; if ( grunt . file . exists ( _url ) ) { _code = tool . fix_image_url ( grunt . file . read ( _url ) . toString ( ) , _url ) ; _buffer . push ( _code ) ; } ; } ; _code = new mincss ( config . mincss ) . minify ( _buffer . join ( "" ) ) ; grunt . file . write ( dest , _code ) ; } 
function ( replace , dest ) { var _urls = [ ] ; for ( var i = replace . js . length ; i -- ; ) { _urls . push ( config . dir . src_dir + replace . js [ i ] ) ; } ; try { grunt . file . write ( dest , minjs . minify ( _urls ) . code . toString ( ) ) ; } catch ( e ) { E ( "Error : uglifyJS error. check js files " + _urls . join ( " ; " ) ) ; } } 
function ( files , replace , dest ) { var _url ; for ( var i = files . length ; i -- ; ) { _url = replace . src + files [ i ] ; tool . del_file_from_hash ( _url ) ; } ; } 
function ( ) { var _replace = this . config . tp + "$1" + this . config . tp , _al = this . config . html . replace ( / (<script[^\\>]*src=[^\\>]*><\/script>) / gi , _replace ) . split ( this . config . tp ) , _js = [ ] , _url = "js/" + this . config . md5 + ".js" ; for ( var i = _al . length ; i -- ; ) { if ( i % 2 ) { tool . checkFileStatus ( _al [ i ] . replace ( / .*src=['|"]([^'|^"]*)['|"].* / gi , "$1" ) , function ( exists , filePath ) { if ( exists ) { _js . push ( filePath ) ; _al [ i ] = "" ; } else { if ( ! config . file_path . fetchUrl [ filePath ] ) { config . file_path . fetchUrl [ filePath ] = tool . get_file_ts ( filePath ) ; } _al [ i ] = "<script type='text/javascript' src='" + config . file_path . fetchUrl [ filePath ] + "'></script>" ; } ; } ) ; } ; } ; if ( _js . length ) { _al [ _al . length - 2 ] += "<script type='text/javascript' src='" + config . redirectOrigin + _url + "'></script>" ; this . config . js = _js ; tool . uglify_js ( this . config , config . dir . pub_dir + _url ) ; tool . concat_done ( _js , this . config , config . dir . pub_dir + _url ) ; } ; return _al . join ( "" ) ; } 
function Floodgate ( opts ) { if ( ! ( this instanceof Floodgate ) ) return new Floodgate ( opts ) ; opts = opts || { } ; Transform . call ( this , opts ) ; this . _interval = opts . interval || 0 ; } 
function remove ( obj , path , i ) { i = i || 0 var key = path [ i ] , last = i === path . length - 1 if ( ! obj || typeof obj !== 'object' ) { throw new Error ( 'Can\'t remove key ' + key + ' from non-object' ) } if ( Array . isArray ( obj ) ) { if ( typeof key !== 'number' ) { obj . forEach ( function ( each ) { remove ( each , path , i ) } ) } else if ( key >= 0 && key < obj . length ) { if ( last ) { obj . splice ( key , 1 ) } else { remove ( obj [ key ] , path , i + 1 ) } } else { throw new Error ( 'Can\'t remove index ' + key + ' from an array with ' + obj . length + ' elements' ) } } else { if ( typeof key !== 'string' ) { throw new Error ( 'Can\'t remove the numeric key ' + key + ' from an object' ) } else if ( key in obj ) { if ( last ) { delete obj [ key ] } else { remove ( obj [ key ] , path , i + 1 ) } } else { throw new Error ( 'Can\'t remove key ' + key + ' from the object' ) } } } 
function add ( obj , path , value , i ) { i = i || 0 var key = path [ i ] , last = i === path . length - 1 if ( ! obj || typeof obj !== 'object' ) { throw new Error ( 'Can\'t add key ' + key + ' to non-object' ) } if ( Array . isArray ( obj ) ) { if ( typeof key !== 'number' ) { obj . forEach ( function ( each ) { add ( each , path , value , i ) } ) } else if ( key >= 0 && key <= obj . length ) { if ( last ) { obj [ key ] = value } else { add ( obj [ key ] , path , value , i + 1 ) } } else { throw new Error ( 'Can\'t add index ' + key + ' to an array with ' + obj . length + ' elements' ) } } else { if ( typeof key !== 'string' ) { throw new Error ( 'Can\'t add the numeric key ' + key + ' to an object' ) } else { if ( last ) { obj [ key ] = value } else { if ( ! ( key in obj ) ) { obj [ key ] = Object . create ( null ) } add ( obj [ key ] , path , value , i + 1 ) } } } } 
function ( names ) { var attributes = Array . prototype . slice . call ( arguments ) ; attributes = _ . without ( attributes , this . getMetadataAttributes ( true ) ) ; this . _usergrid . attrs = attributes ; } 
function ( uuid_or_name , cb ) { if ( _ . isObject ( uuid_or_name ) ) { return cb ( new Error ( 'parameter must be a uuid or name' ) ) ; } var self = this ; client . getEntity ( { type : self . _usergrid . type , uuid : uuid_or_name } , translateSDKCallback ( function ( err , entity ) { if ( err ) { return cb ( err ) ; } cb ( null , wrap ( self , entity ) ) ; } ) ) ; } 
function ( criteria , limit , cb ) { if ( _ . isFunction ( limit ) ) { cb = limit ; limit = undefined ; } var self = this ; var query = buildQuery ( criteria , limit ) ; client . createCollection ( options ( self , query ) , translateSDKCallback ( function ( err , collection ) { if ( err ) { return cb ( err ) ; } cb ( null , wrapCollection ( self , collection ) ) ; } ) ) ; } 
function ( attributes , cb ) { if ( _ . isArray ( attributes ) ) { var self = this ; for ( var i = 0 ; i < attributes . length ; i ++ ) { 
function ( attributes , cb ) { var id = attributes . uuid || attributes . name || attributes . username ; this . find ( id , function ( err , entity ) { if ( err ) { return cb ( err ) ; } entity . update ( attributes , cb ) ; } ) ; } 
function ( criteria , cb ) { var self = this ; this . first ( criteria , function ( err , entity ) { if ( err ) { return cb ( err ) ; } if ( entity ) { cb ( null , entity ) ; } else { self . create ( criteria , cb ) ; } } ) ; } 
function ( criteria , cb ) { if ( _ . isFunction ( criteria ) ) { cb = criteria ; criteria = undefined ; } var self = this ; var query = buildQuery ( criteria ) ; client . delete ( options ( self , query ) , translateSDKCallback ( function ( err , data ) { if ( err ) { return cb ( err ) ; } cb ( null , data . entities . length ) ; } ) ) ; } 
function ( criteria , cb ) { if ( _ . isFunction ( criteria ) ) { cb = criteria ; criteria = undefined ; } this . findBy ( criteria , function ( err , entities ) { if ( err ) { return cb ( err ) ; } var deleteEntity = function ( entity , callback ) { entity . delete ( callback ) ; } ; async . each ( entities , deleteEntity , function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function ( attributes ) { if ( _ . isString ( attributes ) ) { attributes = { uuid : attributes } ; } 
function options ( Class , hash ) { var opts ; var type = { type : Class . _usergrid . type } ; if ( hash ) { opts = _ . assign ( { } , hash , type ) ; } else { opts = type ; } return opts ; } 
function wrap ( Class , entity ) { UsergridEntity . prototype = entity ; Class . _usergrid . constructor . prototype = new UsergridEntity ( ) ; entity = new Class . _usergrid . constructor ( ) ; entity . _class = Class ; defineAttributes ( entity ) ; addConnectionFunctions ( entity , Class . _usergrid . connections ) ; return entity ; } 
function ( sender , parent , key , value ) { this . scrubber = sender this . parent = parent this . key = key this . value = value } 
function ( ) { if ( this . ieVersion !== undefined ) return this . ieVersion ; var ua = this . headers [ 'user-agent' ] , m ; if ( ! ua || ! ( m = ua . match ( / MSIE ([\d\.]+) / i ) ) ) return this . ieVersion = false ; return this . ieVersion = m [ 1 ] ; } 
function define ( Class , constructor , type ) { if ( ! client ) { throw new Error ( 'Usergrid not configured' ) ; } if ( typeof Class === 'function' ) { type = constructor ; constructor = Class ; Class = { } ; } Class . _usergrid = { constructor : constructor , type : ( type ) ? type : constructor . name . toLowerCase ( ) } ; _ . mixin ( Class , usergridStatics ( client ) ) ; return Class ; } 
function SavespriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'SAVESPRITE command requires 2 arguments' ) ; this . id = parsed . args [ 0 ] ; this . fileName = parsed . args [ 1 ] ; } 
function tombstoneQuery ( name , query , opts ) { const tombstoneKey = opts && ( typeof opts . tombstoneKeyGetter === 'function' ) ? opts . tombstoneKeyGetter ( name ) : null ; if ( ! tombstoneKey ) return query ; const cond = { [ tombstoneKey ] : { $ne : true } } ; if ( query . _conditions . $and && Array . isArray ( query . _conditions . $and ) ) { query . _conditions . $and . push ( cond ) ; } else { Object . assign ( query . _conditions , cond ) ; } return query ; } 
function findIndexOfSyllable ( splitArray , syllableNumber , splitRegex ) { let syllableCount = 0 ; for ( let i = 0 ; i < splitArray . length ; i ++ ) { if ( ! splitArray [ i ] . match ( splitRegex ) ) { syllableCount ++ ; } 
function defer ( func ) { return new ( class { constructor ( generator ) { this . generator = generator ; } [ Symbol . iterator ] ( ) { return this . generator ( ) [ Symbol . iterator ] ( ) ; } } ) ( func ) ; } 
function range ( start , count , inc = 1 ) { return defer ( function * ( ) { for ( let i = 0 ; i < count ; ++ i ) { yield start + ( i * inc ) ; } } ) ; } 
function fibonacci ( ) { return defer ( function * ( ) { let prev = 1 ; let curr = 1 ; yield prev ; yield curr ; for ( ; ; ) { let temp = prev ; prev = curr ; curr = temp + curr ; yield curr ; } } ) ; } 
function primes ( limit ) { if ( limit != null ) { // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes return defer ( function * ( ) { let set = Array . from ( range ( 3 , ( limit / 2 ) - 1 , 2 ) ) ; let curr = 3 ; const sqrtLimit = Math . sqrt ( limit ) ; yield 2 ; let lastIndex = 0 ; while ( curr <= sqrtLimit ) { yield curr ; set = set . splice ( 0 , lastIndex ) . concat ( set . splice ( lastIndex + 1 ) . filter ( s => s % curr !== 0 ) ) ; lastIndex = set . findIndex ( s => s > curr ) ; if ( lastIndex == null ) { return ; } curr = set [ lastIndex ] ; } yield curr ; yield * set . slice ( lastIndex + 1 ) ; } ) ; } return defer ( function * ( ) { const previousPrimes = [ 2 , 3 ] ; yield 2 ; yield 3 ; for ( let curr = 5 ; ; curr += 2 ) { let allowed = true ; const sqrt = Math . sqrt ( curr ) ; for ( const prime of previousPrimes ) { if ( prime > sqrt ) { break ; } else if ( curr % prime === 0 ) { allowed = false ; break ; } } if ( allowed ) { previousPrimes . push ( curr ) ; yield curr ; } } } ) ; } 
function createRegexp ( s ) { let mExp = / ^\/(.*)\/([gimy]*)$ / . exec ( s ) if ( mExp ) { return new RegExp ( mExp [ 1 ] , mExp [ 2 ] ) } else { return new RegExp ( s ) } } 
function forward ( event , source , target ) { source . on ( event , target . emit . bind ( target , event ) ) ; } 
function ( state , scope , secondaryScope ) { if ( ! validators . isBlockStart ( state ) ) return state . error ( constants . unexpectedToken ) ; state . next ( ) ; 
function ( state , scope , secondaryScope ) { state . createLexicalEnvironment ( ) ; state . levelDown ( scope ) ; if ( secondaryScope ) state . levelDown ( secondaryScope ) ; while ( state . token && ! validators . isBlockEnd ( state ) ) { state . processor . token ( state ) ; } if ( secondaryScope ) state . levelUp ( ) ; state . levelUp ( ) ; state . finalizeLexicalEnvironment ( ) ; } 
function ( state , noError ) { if ( validators . isSemicolon ( state ) ) { state . next ( ) ; } else if ( state . token && ! validators . isBlockEnd ( state ) ) { var lb = state . lookback ( ) ; if ( ! lb || state . token . line === lb . line ) { if ( ! noError ) state . error ( constants . unexpectedToken ) ; return false ; } } return true ; } 
function ReadpixelCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'READPIXEL command requires 2 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; } 
function getValue ( value ) { var data = value , result = value ; if ( typeof data === 'string' ) { try { if ( ! data || data === 'true' ) { result = true ; } else if ( data === 'false' ) { result = false ; } else if ( data === 'null' ) { result = null ; } else if ( + data + '' === data ) { result = + data ; } else { result = rbrace . test ( data ) ? JSON . parse ( data ) : data ; } } catch ( error ) { } } return result ; } 
function ( config ) { if ( ! config ) { return "" ; } var result = [ ] ; for ( var key in config ) { if ( typeof config [ key ] == "undefined" ) { continue ; } result . push ( key + "=" + config [ key ] ) ; } if ( result . length > 0 ) { return "?" + result . join ( "&" ) ; } return "" ; } 
function ( consumerKey , consumerSecret , applicationName , format , useCompression ) { this . eventHandlers = { } ; this . consumerKey = consumerKey ; this . consumerSecret = consumerSecret ; this . useCompression = useCompression || true ; this . format = format || "json" ; this . acceptEncoding = this . useCompression ? 'gzip, deflate' : 'identity' ; this . applicationName = applicationName ? ( applicationName + "/" ) : "" ; if ( ! this . consumerKey || ! this . consumerSecret ) { throw "ConsumerKey and ConsumerSecret should be specified in order to use SDK" ; } this . applicationName += this . tpl ( "JavaScript/{SDK_VERSION}/{format}" , { SDK_VERSION : this . SDK_VERSION , format : this . format } ) ; } 
function debounced ( ... args ) { let now = + new Date ( ) , remaining ; 
function Notification ( objGoogleCheckout ) { var self = this ; 
function save ( file , options ) { var stream = fs . createWriteStream ( file , options ) ; function onSave ( ) { stream . removeAllListeners ( ) ; this . emit ( 'save' ) ; } function onError ( err ) { stream . removeAllListeners ( ) ; this . emit ( 'error' , err ) ; } stream . on ( 'finish' , onSave . bind ( this ) ) ; stream . on ( 'error' , onError . bind ( this ) ) ; this . pipe ( stream ) ; return this ; } 
function findPath ( request , paths ) { if ( paths . length == 1 && / ^\.{2} / . test ( request ) ) { paths [ 0 ] = path . dirname ( paths [ 0 ] ) request = request . slice ( 1 ) } return originalFindPath ( request , paths ) } 
function run ( js , path ) { var m = new Module ( path , module ) Module . _findPath = findPath m . paths = Module . _nodeModulePaths ( dirname ( path ) ) m . id = path m . filename = path js = 'module.return=eval(' + json ( js ) + ')' m . _compile ( js , path ) Module . _findPath = originalFindPath return m } 
function final_s_zero ( hash ) { var stem = [ hash . stem , 'स्'].jo i n ('') ; if ( stem == hash . stem ) return ; if ( ! hash . stems ) hash . stems = [ ] ; hash . stems . push ( stem ) ; } 
function retroflex_k ( hash ) { var stemh = hash . stem . replace ( / क्$/, ' ह ् ); var stemz = hash . stem . replace ( / क्$/,'ष ् ' ); var stemj = hash . stem . replace ( / क्$/,'ज ् ' ); var stemc = hash . stem . replace ( / क्$/,'च ् ' ); if ( stemh == hash . stem && stemz == hash . stem && stemj == hash . stem ) return ; hash . stems = [ stemh , stemz , stemj , stemc ] ; if ( debug ) log ( 'mod: retroflex_k' , hash . stems ) ; } 
function h_like_gh_other ( hash ) { 
function move_aspirate_forward ( hash ) { var asp = u . unasp2asp ( hash . stemUlt ) ; if ( ! asp ) return ; var stem = u . replaceEnd ( hash . stem , hash . stemUlt , asp ) ; if ( ! stem || stem == hash . stem ) return ; hash . stems = [ stem ] ; if ( debug ) log ( 'mod: move_aspirate_forward' , stem ) ; } 
function get ( options , config ) { options = options || found config = config || { } 
function load ( dir , name ) { 
function decorate ( object , values ) { for ( var key in values ) { if ( typeof object [ key ] === 'object' ) { decorate ( object [ key ] , values [ key ] ) } else { object [ key ] = values [ key ] } } } 
function hide ( object , name , value ) { Object . defineProperty ( object , name , { enumerable : false , value : value } ) } 
function _instanceCopy ( sourceRef , copyRef , rc , copier ) { let origIndex = rc . xStack . indexOf ( sourceRef ) ; if ( origIndex === - 1 ) { rc . push ( sourceRef , copyRef ) ; forEach ( sourceRef , function ( value , key ) { copier ( copyRef , value , key ) ; } ) ; rc . pop ( ) ; return copyRef ; } else return rc . yStack [ origIndex ] ; } 
function _objectCopy ( sourceRef , copyRef , rc ) { let origIndex = rc . xStack . indexOf ( sourceRef ) ; if ( origIndex === - 1 ) { rc . push ( sourceRef , copyRef ) ; for ( let [ key , val ] of _entries ( sourceRef ) ) copyRef [ key ] = _clone ( val , rc ) ; let symbols = Object . getOwnPropertySymbols ( sourceRef ) ; for ( let symbol of symbols ) copyRef [ symbol ] = _clone ( sourceRef [ symbol ] , rc ) ; rc . pop ( ) ; return copyRef ; } else return rc . yStack [ origIndex ] ; } 
function _setCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( set , val ) => { set . add ( _clone ( val , rc ) ) ; } ) ; } 
function _mapCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( map , val , key ) => { map . set ( key , _clone ( val , rc ) ) ; } ) ; } 
function _singleCopy ( sourceRef , copyRef , rc ) { return _instanceCopy ( sourceRef , copyRef , rc , ( item , val , key ) => { copyRef [ key ] = _clone ( val , rc ) ; } ) ; } 
function clone ( origSource ) { let origIndex = - 1 ; let rc = new RecurseCounter ( 1000 ) ; return _clone . call ( null , origSource , rc ) ; } 
function _equals ( x , y , rc ) { if ( rc . count > rc . maxStackDepth ) throw new Error ( "Stack depth exceeded: " + rc . maxStackDepth + "!" ) ; // check for reference and primitive equality if ( x === y ) return true ; // check for type equality let xType = getType ( x ) ; let yType = getType ( y ) ; if ( xType !== yType ) return false ; // check for circular references let xIndex = rc . xStack . lastIndexOf ( x ) ; let yIndex = rc . yStack . lastIndexOf ( y ) ; if ( xIndex !== - 1 ) { if ( yIndex === xIndex ) return true ; } // check for inequalities switch ( xType ) { case types . number : if ( x !== y ) { if ( isNaN ( x ) && isNaN ( y ) ) return true ; return false ; } break ; case types . date : if ( x . getTime ( ) !== y . getTime ( ) ) return false ; // check for extra properties stored on the Date object if ( ! _compareObject ( x , y , rc ) ) return false ; break ; case types . array : if ( x . length !== y . length ) return false ; rc . push ( x , y ) ; for ( let i = 0 ; i < x . length ; i ++ ) { if ( ! _equals ( x [ i ] , y [ i ] , rc ) ) return false ; } rc . pop ( ) ; break ; case types . map : if ( x . size !== y . size ) return false ; let xMapArr = [ ... x ] ; // these need to be sorted by key before comparison let yMapArr = [ ... y ] ; // order shouldn't matter, as long as they are the same xMapArr . sort ( ( a , b ) => { return a [ 0 ] > b [ 0 ] ? 1 : a [ 0 ] < b [ 0 ] ? - 1 : 0 ; } ) ; yMapArr . sort ( ( a , b ) => { return a [ 0 ] > b [ 0 ] ? 1 : a [ 0 ] < b [ 0 ] ? - 1 : 0 ; } ) ; if ( ! _equals ( xMapArr , yMapArr , rc ) ) return false ; break ; case types . set : if ( x . size !== y . size ) return false ; let xArr = [ ... x ] ; // consider doing a comparison without converting to array? let yArr = [ ... y ] ; // converting to array may still be the fastest option. if ( ! _equals ( xArr , yArr , rc ) ) return false ; break ; case types . function : if ( ! _compareObject ( x , y , rc ) ) // check for properties on function return false ; if ( x !== y ) return false ; // other than that, just use reference equality for now break ; case types . object : if ( Buffer . isBuffer ( x ) ) { if ( ! Buffer . isBuffer ( y ) ) return false ; if ( x . length !== y . length ) return false ; if ( ! x . equals ( y ) ) return false ; } else { if ( ! _compareObject ( x , y , rc ) ) return false ; } break ; case types . regexp : if ( ! _equals ( x . toString ( ) , y . toString ( ) , rc ) ) return false ; if ( ! _compareObject ( x , y , rc ) ) return false ; break ; case types . boolean : case types . string : case types . symbol : if ( x !== y ) return false ; break ; default : if ( ! _compareObject ( x , y , rc ) ) return false ; break ; } return true ; } 
function _compareObject ( x , y , rc ) { if ( x === y ) return true ; if ( x . constructor && y . constructor && x . constructor !== y . constructor ) return false ; let xKeys = Object . keys ( x ) ; let yKeys = Object . keys ( y ) ; xKeys . sort ( ) ; yKeys . sort ( ) ; if ( ! _equals ( xKeys , yKeys , rc ) ) return false ; rc . push ( x , y ) ; for ( let k in x ) { if ( ! _equals ( x [ k ] , y [ k ] , rc ) ) return false ; } rc . pop ( ) ; return true ; } 
function equals ( x , y ) { let rc = new RecurseCounter ( 1000 ) ; return _equals . call ( null , x , y , rc ) ; } 
function forEach ( item , method , context ) { let type = getType ( item ) ; switch ( type ) { case types . date : case types . function : case types . object : case types . regexp : if ( ! item [ Symbol . iterator ] ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . hasOwnProperty ( key ) ) method . call ( context , value , key , item ) ; } } else { // shenanigans for ( let value of item ) { // do we want to check if value is array, and spread it across value/key? method . call ( context , value , undefined , item ) ; } } break ; case types . arguments : case types . array : for ( let i = 0 ; i < item . length ; i ++ ) method . call ( context , item [ i ] , i , item ) ; break ; case types . map : for ( let [ key , value ] of item ) method . call ( context , value , key , item ) ; break ; case types . set : for ( let value of item ) // treat keys and values as equivalent for sets method . call ( context , value , value , item ) ; break ; default : // if unknown type, then check for Symbol.iterator if ( item [ Symbol . iterator ] ) { for ( let value of item [ Symbol . iterator ] ( ) ) method . call ( context , value , undefined , item ) ; } else if ( ! typeset . has ( type ) && type && type . constructor ) { for ( let [ key , value ] of _entries ( item ) ) { if ( item . hasOwnProperty ( key ) ) // necessary with _entries? method . call ( context , value , key , item ) ; } } break ; } return item ; } 
function _inspect ( inspecting , inspection = '' , seen = [ ] , times = 0 , indent = 2 ) { let type = getType ( inspecting ) ; switch ( type ) { case types . undefined : return 'undefined' ; case types . null : return 'null' ; case types . function : let name = inspecting . name ? ': ' + inspecting . name : '' ; return ` ${ name } ` ; case types . string : return ` ${ inspecting } ` ; case types . array : if ( seen . indexOf ( inspecting ) > - 1 ) return '[Circular]' ; times ++ ; inspection = '[ ' ; seen . push ( inspecting ) ; var inspected = [ ] ; for ( let val of inspecting ) inspected . push ( _inspect ( val , inspection , seen , times ) ) ; if ( inspected . length === 0 ) return '[]' ; let length = inspected . reduce ( ( prev , cur ) => { return prev + cur . length ; } , 0 ) ; if ( length > 60 ) inspection = '[ ' + inspected . join ( ',\n' + ' ' . repeat ( times * indent ) ) + ' ]' ; else inspection = '[ ' + inspected . join ( ', ' ) + ' ]' ; return inspection ; case types . object : if ( seen . indexOf ( inspecting ) > - 1 ) return '[Circular]' ; times ++ ; inspection = '{ ' ; seen . push ( inspecting ) ; let objInspected = [ ] ; if ( inspecting instanceof Error ) // to match nodejs inspect methods objInspected . push ( '[' + inspecting . toString ( ) + ']' ) ; for ( let [ key , val ] of each ( inspecting ) ) objInspected . push ( key + ': ' + _inspect ( val , inspection , seen , times ) ) ; if ( objInspected . length === 0 ) return '{}' ; let objLength = objInspected . reduce ( ( prev , cur ) => { return prev + cur . length ; } , 0 ) ; if ( objLength > 60 ) inspection = '{\n' + ' ' . repeat ( times * indent ) + objInspected . join ( ',\n' + ' ' . repeat ( times * indent ) ) + ' }' ; else inspection = '{ ' + objInspected . join ( ', ' ) + ' }' ; return inspection ; case types . map : case types . set : return _inspect ( [ ... inspecting ] ) ; case types . number : case types . boolean : default : if ( inspecting instanceof Error ) return '[' + inspecting . toString ( ) + ']' ; return inspecting . toString ( ) ; } } 
function typeForExtend ( val ) { // treat unknown types (classes, hopefully?) and functions as objects let type = getType ( val ) ; if ( type === types . function || ! typeset . has ( type ) && type && type . constructor ) type = types . object ; return type ; } 
function isExtendable ( ... args ) { // this is a fairly expensive call. find a way to optimize further? if ( args . length < 1 ) return false ; let baseType = typeForExtend ( args [ 0 ] ) ; if ( ! ( baseType === types . array || baseType === types . object || baseType === types . set || baseType === types . map || baseType === types . function ) ) { return false ; } for ( let i = 1 ; i < args . length ; i ++ ) { let targetType = typeForExtend ( args [ i ] ) ; if ( targetType !== baseType ) return false ; } return true ; } 
function _extend ( a , b ) { forEach ( b , ( bVal , key ) => { let type = typeForExtend ( a ) ; switch ( type ) { case types . array : case types . object : if ( a [ key ] === undefined || a [ key ] === null ) a [ key ] = b [ key ] ; else if ( isExtendable ( a [ key ] , b [ key ] ) ) _extend ( a [ key ] , b [ key ] ) ; break ; case types . set : if ( ! a . has ( bVal ) ) a . add ( bVal ) ; break ; case types . map : if ( ! a . has ( key ) ) a . set ( key , bVal ) ; else { let aVal = a . get ( key ) ; if ( aVal === undefined || aVal === null ) a . set ( key , bVal ) ; else if ( isExtendable ( aVal , bVal ) ) _extend ( aVal , bVal ) ; } break ; } } ) ; return a ; } 
function extend ( a , ... rest ) { rest . forEach ( b => { if ( isExtendable ( a , b ) ) _extend ( a , b ) ; } ) ; return a ; } 
function _smash ( a , b ) { this . forEach ( b , ( val , key ) => { if ( this . isSmashable ( a [ key ] , b [ key ] ) ) // find a way to move isSmashable internal this . _smash ( a [ key ] , b [ key ] ) ; else a [ key ] = this . deepCopy ( b [ key ] ) ; } ) ; return a ; } 
function smash ( a , ... rest ) { rest . forEach ( b => { if ( this . isSmashable ( a , b ) ) // find a way to move isSmashable internal this . _smash ( a , b ) ; } ) ; return a ; } 
function XublitApp ( opts ) { _classCallCheck ( this , XublitApp ) ; var _this = _possibleConstructorReturn ( this , Object . getPrototypeOf ( XublitApp ) . call ( this ) ) ; opts = parseOptions ( _this , opts ) ; initInjector ( _this , { baseDir : opts . baseDir , includeDirs : _this . includeDirs , bootstrapScopeVars : { app : _this } } ) ; return _this ; } 
function File ( name , file , parent ) { this . name = name ; this . file = file ; this . parent = parent ; this . readCursor = 0 ; this . eof = false ; } 
function ( error , cb ) { var doShutdown = function ( ) { var cb0 = function ( err0 ) { if ( err0 ) { $ . _ . $ . log && $ . _ . $ . log . fatal ( 'handleError: Critical shutdown' + ' failed, exiting ' + myUtils . errToPrettyStr ( err0 ) ) ; * * Not enough to abort, force a CA shutdown. * * When this CA recovers from the shutdown, * if the checkpoint made it to persistent * storage it will redo the commit actions (*always* assumed * to be idempotent). * * We cannot imply that `checkpointFailure` means it did * not make it to storage. That's the reason * we have to shutdown, because it may have been logged as * pending to be committed... */ $ . _ . $ . log && $ . _ . $ . log . debug ( 'handleError: SysError shutdown CA: ' + myUtils . errToPrettyStr ( error ) ) ; doShutdown ( ) ; } else { $ . _ . $ . log && $ . _ . $ . log . debug ( 'handleError: SysError aborting: ' + myUtils . errToPrettyStr ( error ) ) ; doAbort ( ) ; } } else { // This is a bug, all the errors should be App or System by now. var msg = ( error && ( typeof error === 'object' ? myUtils . errToPrettyStr ( error ) : JSON . stringify ( error ) ) ) ; $ . _ . $ . log && $ . _ . $ . log . fatal ( 'handleError: error is neither' + ' App or System ' + msg ) ; process . exit ( 1 ) ; } } 
function ( msg , code , errorStr , cb ) { return function ( error , data ) { if ( error ) { error = json_rpc . newSysError ( msg , code , errorStr , error ) ; } cb ( error , data ) ; } ; } 
function getTimeDifference ( timestr1 , timestr2 ) { if ( typeof timestr1 !== 'string' || typeof timestr2 !== 'string' ) { throw new Error ( 'pendel.time() expects string arguments' ) ; } 
function getDateDifference ( timestr1 , timestr2 ) { 
function shortTimeToDateString ( shortTime ) { 
function getTotalResultsFromEpochs ( epoch1 , epoch2 ) { var millisecs = Math . abs ( epoch1 - epoch2 ) ; var seconds = millisecs / 1000 ; return { totalSeconds : seconds , totalMinutes : Math . floor ( seconds / 60 ) , totalHours : Math . floor ( seconds / 60 ) * 60 } ; } 
function InputCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( ! parsed . args . length ) throw new SyntaxError ( 'INPUT requires at least one argument' ) ; var question = "" , placeVar , file ; if ( parsed . args . length === 1 ) placeVar = parsed . args [ 0 ] ; else { if ( parsed . args [ 0 ] . child instanceof statements . PointerStatement ) file = parsed . args [ 0 ] ; else question = parsed . args [ 0 ] ; placeVar = parsed . args [ 1 ] ; } if ( ! ( placeVar . child instanceof statements . VariableStatement || placeVar . child instanceof statements . FunctionStatement ) ) throw new SyntaxError ( 'Expected variable' ) ; this . file = file ; this . question = question ; this . placeVar = placeVar ; } 
function PiechartCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 8 ) throw new SyntaxError ( 'PIECHART command requires 8 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . r = parsed . args [ 2 ] ; this . itemsLength = parsed . args [ 3 ] ; this . percentages = parsed . args [ 4 ] ; this . itemsRed = parsed . args [ 5 ] ; this . itemsGreen = parsed . args [ 6 ] ; this . itemsBlue = parsed . args [ 7 ] ; } 
function utilTickCall ( callback , self , opt ) { var args = opt . args ; if ( args === undefined ) { args = opt ; } args = [ ] . concat ( args ) ; callback . apply ( self , args ) ; if ( isType ( opt . complete , typeNameFunction ) ) { opt . complete . apply ( self , args ) ; } } 
function ( name , obj ) { var parts = name . split ( '.' ) , parent = this , length ; length = parts . length - 1 ; for ( var i = 0 , m = length ; i < m ; i += 1 ) { parent [ parts [ i ] ] = parent [ parts [ i ] ] || { } ; parent = parent [ parts [ i ] ] ; } if ( obj ) { if ( ! isType ( parent [ parts [ length ] ] , typeNameUndefined ) ) { throw new Error ( "Can't overwrite '" + name + "' of defined!" ) ; } parent [ parts [ length ] ] = obj ; } else if ( isType ( parent [ parts [ length ] ] , typeNameUndefined ) ) { parent [ parts [ length ] ] = { } ; } return parent [ parts [ length ] ] ; } 
function ( self , callback , opt , async ) { opt = opt || { } ; self = self || opt . self ; if ( opt . async ) { async = true ; delete opt . async ; } if ( async ) { g . Crisp . nextTick ( utilTickCall , callback , self , opt ) ; return self ; } else { utilTickCall ( callback , self , opt ) ; } return self ; } 
function ( name ) { var args = [ this ] ; arguments . xEach ( { start : 1 } , function ( item ) { args . push ( item ) ; } ) ; return Math [ name ] . apply ( Math , args ) ; } 
function utilTack ( methodCallback , methodSchema ) { function tackDefault ( opt , success , complete ) { var async ; if ( opt . async ) { async = opt . async ; delete opt . async ; } 
function callSchema ( schema , args ) { var key ; var opt = { } ; if ( Crisp . type . call ( args [ 0 ] , 'Object' ) ) { return args [ 0 ] ; } schema = schema || [ ] ; for ( var i = 0 , m = args . length ; i < m ; i += 1 ) { key = schema [ i ] || i ; opt [ key ] = args [ i ] ; } return opt ; } 
function xAddArray ( ) { var i = 0 , m = arguments . length , a ; for ( ; i < m ; i += 1 ) { a = arguments [ i ] ; if ( $$ . type . call ( a , 'Array' ) ) { xAddArray . apply ( this , a ) ; } else if ( a !== undefined ) { this . push ( a ) ; } } return this ; } 
function xEachArray ( option , success , picker ) { var index , i = 0 , reverse = 1 , length = this . length , start = option . start ? Number ( option . start ) : 0 , limit = option . limit === undefined ? length : Number ( option . limit ) ; if ( limit <= 0 ) { limit = length ; } if ( start < 0 ) { start = length + start ; } if ( start + limit > length ) { limit -= start + limit - length ; } if ( start < 0 ) { start = 0 ; limit = length ; } if ( option . reverse ) { reverse = - 1 ; start -= length + reverse ; } for ( ; i < limit ; i += 1 ) { try { index = ( i + start ) * reverse ; success . call ( option . self , this [ index ] , index , picker ) ; } catch ( e ) { if ( e instanceof Break ) { if ( option . limit && ( option . reverse || ( index < length && limit < length ) ) ) { limit += 1 ; } } else if ( e instanceof End || index < 0 ) { return this ; } else { throw e ; } } } return this ; } 
function xEachObject ( option , success , picker ) { var index , keys = Object . keys ( this ) , i = 0 , reverse = 1 , length = keys . length , start = option . start ? Number ( option . start ) : 0 , limit = option . limit === undefined ? length : Number ( option . limit ) , name ; if ( limit <= 0 ) { limit = length ; } if ( start < 0 ) { start = length + start ; } if ( start + limit > length ) { limit -= start + limit - length ; } if ( start < 0 ) { start = 0 ; limit = length ; } if ( option . reverse ) { reverse = - 1 ; start -= length + reverse ; } for ( ; i < limit ; i += 1 ) { try { index = ( i + start ) * reverse ; name = keys [ index ] ; success . call ( option . self , this [ name ] , name , picker ) ; } catch ( e ) { if ( e instanceof Break ) { if ( option . limit && ( option . reverse || ( index < length && limit < length ) ) ) { limit += 1 ; } } else if ( e instanceof End || index < 0 ) { return this ; } else { throw e ; } } } return this ; } 
function tap ( tapper ) { return function * ( it ) { let index = 0 ; for ( const value of it ) { tapper ( value , index ) ; yield value ; index = index + 1 ; } } ; } 
function map ( mapper ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { yield mapper ( value , index ) ; index = index + 1 ; } } ; } 
function flatMap ( mapper ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { const innerIterable = mapper ( value , index ) ; for ( const inner of innerIterable ) { yield inner ; } index = index + 1 ; } } ; } 
function filter ( predicate ) { return function * ( iterable ) { let index = 0 ; for ( const value of iterable ) { if ( predicate ( value , index ) ) { yield value ; } index = index + 1 ; } } ; } 
function reduce ( predicate , initial ) { return function ( iterable ) { let index = 0 ; let prevState = initial ; for ( const value of iterable ) { prevState = predicate ( prevState , value , index ) ; index = index + 1 ; } return prevState ; } ; } 
function take ( count ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( i >= count ) { return ; } yield item ; i = i + 1 ; } } ; } 
function takeLast ( count ) { return function * ( iterable ) { const buffer = [ ] ; for ( const item of iterable ) { buffer . push ( item ) ; if ( buffer . length > count ) { buffer . shift ( ) ; } } return yield * buffer ; } ; } 
function skipLast ( count ) { return function * ( iterable ) { const buffer = [ ] ; for ( const item of iterable ) { buffer . push ( item ) ; } if ( buffer . length < count ) { return ; } yield * buffer . slice ( 0 , buffer . length - count ) ; } ; } 
function last ( iterable ) { let last = undefined ; for ( const item of iterable ) { last = item ; } return last ; } 
function skip ( count ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( i >= count ) { yield item ; } i = i + 1 ; } } ; } 
function takeWhile ( predicate ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( ! predicate ( item , i ) ) { break ; } yield item ; i = i + 1 ; } } ; } 
function takeUntil ( predicate ) { return function * ( iterable ) { let i = 0 ; for ( const item of iterable ) { if ( predicate ( item , i ) ) { return ; } yield item ; i = i + 1 ; } } ; } 
function skipWhile ( predicate ) { return function * ( iterable ) { let i = 0 ; let canReturn = false ; for ( const item of iterable ) { if ( ! canReturn ) { canReturn = ! predicate ( item , i ) ; if ( canReturn ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; } 
function skipUntil ( predicate ) { return function * ( iterable ) { let i = 0 ; let canReturn = false ; for ( const item of iterable ) { if ( ! canReturn ) { canReturn = predicate ( item , i ) ; if ( canReturn ) { yield item ; } i = i + 1 ; } else { yield item ; } } } ; } 
function elementAtOrDefault ( index , or ) { return function ( it ) { let i = 0 ; for ( const item of it ) { if ( i === index ) { return item ; } i = i + 1 ; } return or ; } ; } 
function unshift ( ... next ) { return function * ( it ) { for ( let i = 0 ; i < next . length ; ++ i ) yield next [ next . length - i - 1 ] ; yield * it ; } ; } 
function some ( predicate ) { return it => { let i = 0 ; for ( const item of it ) { if ( predicate ( item , i ) ) { return true ; } i = i + 1 ; } return false ; } ; } 
function every ( predicate ) { return it => { let i = 0 ; for ( const item of it ) { if ( ! predicate ( item , i ) ) { return false ; } i = i + 1 ; } return true ; } ; } 
function distinctUntilKeyChanged ( keySelector ) { return function * ( it ) { let prev = undefined ; for ( const item of it ) { const key = keySelector ( item ) ; if ( key === prev ) { continue ; } prev = key ; yield item ; } } ; } 
function orderBy ( keySelector , comparison ) { const trueKeySelector = keySelector || defaultKeySelector ; const trueComparison = comparison || defaultComparison ; return function * ( item ) { const keyedMapper = map ( ( item , index ) => ( { item , key : trueKeySelector ( item , index ) } ) ) ; const keyed = keyedMapper ( item ) ; const keyedArray = Array . from ( keyed ) ; keyedArray . sort ( ( a , b ) => trueComparison ( a . key , b . key ) ) ; for ( const { item } of keyedArray ) { yield item ; } } ; } 
function repeat ( times ) { return function * ( it ) { const buffer = [ ] ; for ( const item of it ) { buffer . push ( item ) ; yield item ; } for ( let i = 0 ; i < times ; ++ i ) { yield * buffer ; } } ; } 
function shuffle ( it , rand = ( ) => Math . random ( ) ) { return map ( ( x ) => x [ 0 ] ) ( orderBy ( ( x ) => x [ 1 ] ) ( map ( ( x ) => [ x , rand ( ) ] ) ( it ) ) ) ; } 
function or ( other ) { return function * ( source ) { let hasYieldedItem = false ; for ( const item of source ) { yield item ; hasYieldedItem = true ; } if ( ! hasYieldedItem ) { yield * other ; } } ; } 
function updateAt ( index , value ) { return function * ( source ) { let i = 0 ; for ( const item of source ) { if ( i === index ) { yield value ; } else { yield item ; } i = i + 1 ; } } ; } 
function removeAt ( index ) { return function * ( source ) { let i = 0 ; for ( const item of source ) { if ( i !== index ) { yield item ; } i = i + 1 ; } } ; } 
function mochaTask ( target ) { return function ( ) { return _gulp2 [ 'default' ] . src ( '' + opt . testEspowered + '/' + target + '/*.js' ) . pipe ( _mocha2 [ 'default' ] ( { reporter : 'spec' } ) ) . on ( 'error' , function ( err ) { return process . exit ( 1 ) ; } ) ; } ; } 
function ( compressedData ) { var inflatedData = zlib . inflateSync ( new Buffer ( compressedData , 'base64' ) ) ; var outputString = "[" + String . fromCharCode . apply ( null , inflatedData ) + "]" ; var outputArray = JSON . parse ( outputString ) ; return ArrayConverter . diffsToValues ( outputArray ) ; } 
function ( numArray ) { numArray . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , prev = 0 , diff = 0 , result = [ ] , len = numArray . length ; i < len ; i ++ ) { diff = numArray [ i ] - prev ; prev = numArray [ i ] ; result . push ( diff ) ; } return result ; } 
function ( diffArray ) { for ( var i = 0 , head = 0 , result = [ ] , len = diffArray . length ; i < len ; i ++ ) { head = head + diffArray [ i ] ; result . push ( head ) ; } return result ; } 
function ShapeCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'SHAPE command requires 3 arguments' ) ; this . pointsLength = parsed . args [ 0 ] ; this . pointsX = parsed . args [ 1 ] ; this . pointsY = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function ekurtosis ( out , p ) { var len = p . length , i ; for ( i = 0 ; i < len ; i ++ ) { out [ i ] = EKURTOSIS ( p [ i ] ) ; } return out ; } 
function scrollSpy ( ) { var scrollTop = $window . scrollTop ( ) , $anchors = $childMenu . find ( 'a' ) , activeIndex ; $anchors . each ( function ( index ) { var $target = $ ( $ ( this ) . attr ( 'href' ) . replace ( / \. / g , '\\.' ) ) , offsetTop = $target . offset ( ) . top , offsetBottom = offsetTop + $target . outerHeight ( true ) ; if ( offsetTop <= scrollTop && scrollTop < offsetBottom ) { activeIndex = index ; return false ; } } ) ; $childMenuItem . removeClass ( 'kss-active' ) ; if ( typeof activeIndex !== 'undefined' ) { $childMenuItem . eq ( activeIndex ) . addClass ( 'kss-active' ) ; } } 
function fixSidebar ( ) { if ( $sidebarInner . outerHeight ( ) < $content . outerHeight ( ) ) { $sidebar . addClass ( 'kss-fixed' ) ; if ( $sidebarInner . outerHeight ( ) > $window . height ( ) ) { $sidebar . height ( $window . height ( ) ) ; $window . on ( 'scroll' , scrollSidebar ) . trigger ( 'scroll' ) ; } else { $sidebar . height ( 'auto' ) ; $window . off ( 'scroll' , scrollSidebar ) ; } } else { $sidebar . removeClass ( 'kss-fixed' ) ; $sidebar . height ( 'auto' ) ; $window . off ( 'scroll' , scrollSidebar ) ; } } 
function scrollSidebar ( event ) { if ( event . handled !== true ) { var scrollTop = $window . scrollTop ( ) , maxScrollTop = $document . height ( ) - $window . height ( ) ; if ( scrollTop >= 0 && prevScrollTop >= 0 && scrollTop <= maxScrollTop && prevScrollTop <= maxScrollTop ) { 
function forEach ( declarations , reqName , callback ) { var d ; if ( reqName === "*" ) { 
function mkdir ( units , name ) { if ( name !== "" ) { var parts = name . split ( "." ) ; var path = "" ; for ( var i = 0 , len = parts . length ; i < len ; i ++ ) { var part = parts [ i ] ; path += part ; if ( units [ part ] == null ) { units [ part ] = { } ; } else if ( typeof units [ part ] !== "object" ) { error ( "Cann't init unit '" + name + "' because path element '" + path + "' isn't an object" ) ; } units = units [ part ] ; path += "." ; } } return units ; } 
function injectObjects ( dest , settings ) { var injections = settings . injections ; if ( ! isArray ( injections ) ) { error ( "Invalid injections array in inject settings" ) ; } var destDecls = dest . _declarations ; for ( var i = 0 , len = injections . length ; i < len ; i ++ ) { var injection = injections [ i ] ; if ( typeof injection !== "object" ) { error ( "Invalid injection [" + i + "] in inject settings" ) ; } var destName = injection . name ; if ( ! checkUnitName ( destName ) ) { error ( "Invalid injection name '" + destName + "' [" + i + "] in inject settings" ) ; } if ( injection . unit != null && injection . value !== undefined ) { error ( "Unit and value can't be used together [" + i + "] in inject settings" ) ; } if ( injection . unit != null ) { 
function pickUnit ( srcDecls , destDecls , name , picked , stack ) { var decl = srcDecls [ name ] ; if ( ! picked [ name ] ) { if ( stack [ name ] ) { error ( "Recursive dependency '" + name + "'" ) ; } stack [ name ] = true ; for ( var i = 0 , len = decl . _dependencies . length ; i < len ; i ++ ) { var reqName = decl . _dependencies [ i ] ; forEach ( srcDecls , reqName , function ( depName ) { if ( depName !== name ) { pickUnit ( srcDecls , destDecls , depName , picked , stack ) ; } } ) ; } destDecls [ name ] = decl ; picked [ name ] = true ; } } 
function pickUnits ( dest , settings ) { var units = settings . units ; if ( ! isArray ( units ) ) { error ( "Invalid units array in pick settings" ) ; } if ( ! ( settings . namespace instanceof Gumup ) ) { error ( "Invalid namespace in pick settings" ) ; } var picked = { } , srcDecls = settings . namespace . _declarations ; for ( var i = 0 , len = units . length ; i < len ; i ++ ) { var reqName = units [ i ] ; if ( ! checkRequireName ( reqName ) ) { error ( "Invalid unit name '" + reqName + "' in pick settings" ) ; } forEach ( srcDecls , reqName , function ( depName ) { pickUnit ( srcDecls , dest . _declarations , depName , picked , { } ) ; } ) ; } } 
function initialize ( dest , declarations , name , cache , inited ) { var decl = declarations [ name ] ; if ( ! inited [ name ] ) { 
function resolve ( declarations , name , cache , resolved , stack ) { var decl = declarations [ name ] ; if ( ! resolved [ name ] ) { if ( stack [ name ] ) { error ( "Recursive dependency '" + name + "'" ) ; } stack [ name ] = true ; for ( var i = 0 , len = decl . _dependencies . length ; i < len ; i ++ ) { var reqName = decl . _dependencies [ i ] ; forEach ( declarations , reqName , function ( depName ) { if ( depName !== name ) { delete cache . root [ depName ] ; cache . dependencies [ name ] . push ( depName ) ; resolve ( declarations , depName , cache , resolved , stack ) ; } } ) ; } resolved [ name ] = true ; } } 
function getShaSalt ( ) { var shaDeps = [ __filename , __dirname + '/protractor_api.dart' ] ; return shaTextHexDigest . apply ( shaDeps . map ( utils . readTextFile ) ) ; } 
function isBemDecl ( node ) { if ( node . type !== 'CallExpression' ) { return false ; } if ( node . callee . type !== 'MemberExpression' ) { return false ; } if ( node . callee . property . type !== 'Identifier' || node . callee . property . name !== 'decl' ) { return false ; } var obj = node . callee . object ; if ( obj . type === "Identifier" ) { return obj . name === "BEM" ; } if ( obj . type === "MemberExpression" ) { if ( obj . object . type !== "Identifier" ) { return false ; } if ( obj . object . name !== "BEM" ) { return false ; } if ( obj . property . type !== "Identifier" ) { return false ; } return obj . property . name === "DOM" ; } return false ; } 
function getEntity ( decl ) { if ( decl . type === "Literal" ) { return { block : decl . value } ; } if ( decl . type === "ObjectExpression" ) { var base = getProperty ( decl , 'baseBlock' ) , o = { block : getProperty ( decl , 'block' ) , mod : getProperty ( decl , 'modName' ) , val : getProperty ( decl , 'modVal' ) } ; if ( base ) { o . base = base ; } return o ; } } 
function getProperty ( objNode , name ) { for ( var i = 0 ; i < objNode . properties . length ; i ++ ) { if ( getKey ( objNode . properties [ i ] ) === name ) { return getValue ( objNode . properties [ i ] ) ; } } } 
function getKey ( propNode ) { if ( propNode . key . type === "Literal" ) { return propNode . key . value ; } if ( propNode . key . type === "Identifier" ) { return propNode . key . name ; } } 
function getEntityDocComment ( node , entity ) { var comment = [ '/**' ] ; if ( node . leadingComments && node . leadingComments [ 0 ] ) { comment . push ( node . leadingComments [ 0 ] . value ) ; } if ( entity . block ) { comment . push ( '@block' ) ; } if ( entity . mod ) { comment . push ( '@mod' ) ; } if ( entity . val ) { comment . push ( '@val' ) ; } comment . push ( '*/' ) ; return comment . join ( '\n' ) ; } 
function addDocletBemEntity ( e ) { var bemEntity = e . code . bemEntity ; e . doclet . block = bemEntity . block ; if ( bemEntity . base ) { e . doclet . baseBlock = bemEntity . base ; } if ( bemEntity . mod ) { e . doclet . mod = { name : bemEntity . mod , value : bemEntity . val } ; } } 
function isStaticDecl ( node ) { var parent = node . parent ; return hasStatic ( parent ) && parent . arguments [ 2 ] === node ; } 
function hasStatic ( node ) { var args = node . arguments ; if ( ! args ) { return false ; } return args . length >= 3 && args [ 1 ] . type === "ObjectExpression" && args [ 2 ] . type === "ObjectExpression" ; } 
function ( attrs ) { var res = '' ; UObj . forEach ( attrs , function ( k , v ) { res += ' ' + k ; if ( v !== null ) res += '="' + S . escape ( v ) + '"' ; } ) ; return res ; } 
function ( tagName , attrs , content ) { 
function betaln ( x , y ) { 
function ( elt , name ) { if ( elt . nodeType !== NodeTypes . ELEMENT ) throw new Error ( 'getAttr not allowed on non-element nodes' ) ; return elt . getAttribute ( name ) || null ; } 
function ( elt , name , value ) { if ( elt . nodeType !== NodeTypes . ELEMENT ) throw new Error ( 'setAttr not allowed on non-element nodes' ) ; value === null ? elt . removeAttribute ( name ) : elt . setAttribute ( name , value ) ; } 
function ( elt , name ) { if ( elt . nodeType !== NodeTypes . ELEMENT && elt . nodeType !== NodeTypes . DOCUMENT ) throw new Error ( 'getProp not allowed on non-element nodes' ) ; return elt [ name ] ; } 
function ( elt , name , value ) { if ( elt . nodeType !== NodeTypes . ELEMENT ) throw new Error ( 'setProp not allowed on non-element nodes' ) ; return elt [ name ] = value ; } 
function ( elt , _class ) { elt . classList . add . apply ( elt . classList , _class . split ( ' ' ) ) ; } 
function ( elt , _class ) { var oldLength = elt . classList . length ; elt . classList . remove ( _class ) ; return oldLength !== elt . classList . length ; } 
function ( e ) { if ( e . parentNode != null ) { $ . disposeElements ( $ . getAll ( e , false ) ) ; $ . disposeElement ( e ) ; e . parentNode . removeChild ( e ) ; } } 
function getInputArguments ( args ) { var out = { } ; out . localServices = { } ; if ( args . length > 0 ) { out . source = args [ 0 ] ; out . target = args [ 0 ] ; if ( _ . isPlainObject ( args [ 0 ] ) ) { var opts = args [ 0 ] ; out . target = opts . target ; out . source = opts . source ; out . instance = opts . instance ; } 
function findNext ( data , items , index ) { var currentIndex = data . length + 1 , found = '' ; for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; var location = data . indexOf ( item , index ) ; if ( location !== - 1 && location < currentIndex ) { currentIndex = location ; found = item ; } } if ( currentIndex === data . length + 1 ) return { index : - 1 , found : '' } ; return { index : currentIndex , found : found } ; } 
function findLast ( data , items , index ) { var currentIndex = - 1 , found = '' ; for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; var location = data . lastIndexOf ( item , index ) ; if ( location > currentIndex ) { currentIndex = location ; found = item ; } } return { index : currentIndex , found : found } ; } 
function findNextOutside ( data , items , index , exclude ) { var result , positionResult = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = findNext ( data , items , positionResult . end + 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; } 
function findLastOutside ( data , items , index , exclude ) { var result , positionResult = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = findLast ( data , items , positionResult . start - 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; } 
function indexOfOutside ( data , item , index , exclude ) { var result , positionResult = { start : 0 , end : index ? index - 1 : - 1 } ; do { result = data . indexOf ( item , positionResult . end + 1 ) ; } while ( result !== - 1 && ( positionResult = inPosition ( result , exclude ) ) ) ; return result ; } 
function lastIndexOfOutside ( data , item , index , exclude ) { var result , positionResult = { start : index ? index + 1 : data . length + 1 , end : 0 } ; do { result = data . lastIndexOf ( item , positionResult . start - 1 ) ; } while ( result . index !== - 1 && ( positionResult = inPosition ( result . index , exclude ) ) ) ; return result ; } 
function splitOutside ( data , separator , exclude ) { var result = [ ] ; var accumulator = "" ; for ( var i = 0 ; i < data . length ; i ++ ) { accumulator += data [ i ] ; var isInExclusion = inPosition ( i , exclude ) ; if ( ! isInExclusion && endsWith ( accumulator , separator ) ) { result . push ( accumulator . substring ( 0 , accumulator . length - separator . length ) ) ; accumulator = '' ; } } result . push ( accumulator ) ; return result ; } 
function findPositions ( data , items ) { var depth = 0 ; var rootId = - 1 ; var result = [ ] ; var currentItem = { } ; var accumulator = '' ; for ( var ci = 0 ; ci < data . length ; ci ++ ) { accumulator += data [ ci ] ; var matchedItem = false ; for ( var x = 0 ; x < items . length ; x ++ ) { var item = items [ x ] ; if ( depth > 0 && endsWith ( accumulator , item . end ) ) { depth -- ; if ( depth === 0 && rootId === x ) { currentItem . end = ci - item . end . length + 1 ; rootId = - 1 ; accumulator = '' ; result . push ( currentItem ) ; currentItem = { } ; } } else if ( endsWith ( accumulator , item . start ) ) { depth ++ ; if ( depth === 1 && rootId === - 1 ) { currentItem = { startChar : item . start , endChar : item . end , start : ci } ; rootId = x ; accumulator = '' ; } } } } return result ; } 
function inPosition ( index , items ) { for ( var i = 0 ; i < items . length ; i ++ ) { var item = items [ i ] ; if ( index >= item . start && index <= item . end ) return item ; } return false ; } 
function endsWith ( data , str ) { if ( data . length < str . length ) return false ; if ( data === str ) return true ; return data . lastIndexOf ( str ) === data . length - str . length ; } 
function pad ( data , length , pad ) { data = String ( data ) ; pad = pad || ' ' ; while ( data . length < length ) data += pad ; return data ; } 
function shallowClone ( source , obj ) { if ( arguments . length < 2 ) { obj = source ; source = { } ; } for ( var key in obj ) { if ( ! obj . hasOwnProperty ( key ) ) continue ; source [ key ] = obj [ key ] ; } return source ; } 
function ( ) { var args = norma ( 'path:s?' , arguments ) ; var _url = url . format ( _ . clone ( this . url ) ) ; var _path = ( args . path || '' ) . replace ( / ^\/ / , '' ) ; return url . resolve ( _url , _path ) ; } 
function ( ) { var results = [ parseInt ( this . url . port , 10 ) ] ; this . url . hostname && results . push ( this . url . hostname ) ; return results ; } 
function start ( options ) { options = options || { } ; var prompt = options . prompt || '> ' ; var eval = options . eval || run ; var context = new ExecutionContext ( ) ; var manager = new BlockManager ( ) ; var ast = new AbstractSyntaxTree ( [ ] , { } , manager ) ; nextLine ( context , ast , prompt , prompt , - 1 , eval ) ; } 
function run ( cmd , context , ast , cursor , next ) { try { 
function nextLine ( context , ast , prompt , oldPrompt , forceCursor , eval ) { rl . question ( prompt , function ( answer ) { eval ( answer , context , ast , forceCursor === - 1 ? ast . root . length : forceCursor , function ( newPrompt , newCursor ) { nextLine ( context , ast , newPrompt || oldPrompt , oldPrompt , typeof newCursor === 'undefined' ? - 1 : newCursor , eval ) ; } ) ; } ) ; } 
function initialize ( done ) { done = done || function ( ) { } ; if ( fileContents ) done ( ) ; fs . readFile ( __dirname + '/../../data/filesystem.json' , { encoding : 'utf8' } , function ( err , data ) { if ( err ) fileContents = { } ; else fileContents = JSON . parse ( data ) ; done ( ) ; } ) ; } 
function drive ( name , done ) { name = name . toLowerCase ( ) ; done = done || function ( ) { } ; if ( allowedDrives . indexOf ( name ) === - 1 ) return done ( new Error ( "Unknown drive" ) ) ; if ( ! fileContents ) return initialize ( function ( ) { drive ( name , done ) ; } ) ; if ( ! fileContents [ name ] ) fileContents [ name ] = { } ; if ( ! driveCache [ name ] ) driveCache [ name ] = new Drive ( name , fileContents [ name ] ) ; done ( driveCache [ name ] ) ; return driveCache [ name ] ; } 
function save ( done ) { if ( process . browser ) return done ( ) ; fs . writeFile ( __dirname + '/../../data/filesystem.json' , JSON . stringify ( fileContents ) , function ( err ) { if ( done ) done ( err ) ; } ) ; } 
function ( i , validate ) { 
function ( d ) { if ( ! arguments . length ) { if ( typeof _i === 'object' ) { var o = { } ; for ( var prop in _i ) { o [ prop ] = _i [ prop ] ( ) ; } return o ; } else { return _i ; } } _i = validate ( d ) ; 
function argnanmin ( arr ) { if ( ! Array . isArray ( arr ) ) { throw new TypeError ( 'argnanmin()::invalid input argument. Must provide an array.' ) ; } var len = arr . length , min = Number . POSITIVE_INFINITY , idx = [ ] , val ; for ( var i = 0 ; i < len ; i ++ ) { val = arr [ i ] ; if ( typeof val !== 'number' || val !== val ) { continue ; } if ( val < min ) { min = val ; idx . length = 0 ; idx . push ( i ) ; } else if ( val === min ) { idx . push ( i ) ; } } return idx ; } 
function DimCommand ( args ) { var parsed = new statements . ArgumentStatement ( args , { parseArgs : false } ) ; this . creates = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var dimDef = parsed . args [ i ] ; var startBracket = dimDef . indexOf ( '(' ) ; var endBracket = dimDef . indexOf ( ')' ) ; if ( startBracket === - 1 ) throw new SyntaxError ( 'Expected start bracket' ) ; if ( endBracket === - 1 ) throw new SyntaxError ( 'Expected end bracket' ) ; var arrayName = dimDef . substring ( 0 , startBracket ) . trim ( ) ; var arrayLengthName = dimDef . substring ( startBracket + 1 , endBracket ) ; var arrayLengthArg = new statements . ArgumentStatement ( arrayLengthName ) ; this . creates . push ( { name : arrayName , lengths : arrayLengthArg . args } ) } } 
function entropy ( out , arr , clbk ) { var len = arr . length , v , i ; for ( i = 0 ; i < len ; i ++ ) { v = clbk ( arr [ i ] , i ) ; if ( typeof v === 'number' ) { out [ i ] = ENTROPY ( v ) ; } else { out [ i ] = NaN ; } } return out ; } 
function genEntityDescription ( data , kind , entityName ) { return data ( { kind : kind , name : entityName } ) . select ( 'description' ) . join ( '\n\n' ) ; } 
function genBlockMethod ( members , name ) { var res = { name : name , description : '' , params : [ ] , returns : [ ] , deprecated : false , final : false } ; members . filter ( { kind : 'function' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description += doclet . description + '\n' ; } if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( res . returns . length === 0 ) { res . returns = genMethodReturns ( doclet . returns ) ; } if ( res . params . length === 0 ) { res . params = genMethodParams ( doclet . params ) ; } if ( doclet . deprecated ) { res . deprecated = doclet . deprecated ; } if ( doclet . final ) { res . final = doclet . final ; } } ) ; res . scope = res . scope || 'instance' ; res . access = res . access || 'public' ; return res ; } 
function genParam ( param ) { var res = { name : param . name || '' , description : param . description || '' , optional : ! ! param . optional } ; if ( param . type ) { res . types = param . type . names . slice ( 0 ) ; } if ( param . defaultvalue ) { res [ 'default' ] = param . defaultvalue ; } return res ; } 
function genProperty ( members , name ) { var res = { name : name , deprecated : false , description : '' , types : [ ] } ; members . filter ( { kind : 'member' , name : name } ) . each ( function ( doclet ) { if ( doclet . description ) { res . description += doclet . description + '\n' ; } if ( ! res . access ) { res . access = doclet . access ; } if ( ! res . scope ) { res . scope = doclet . scope ; } if ( doclet . deprected ) { res . deprecated = true ; } if ( res . types . length === 0 && doclet . type ) { res . types = doclet . type . names . slice ( 0 ) ; } } ) ; res . scope = res . scope || 'instance' ; res . access = res . acccess || 'public' ; return res ; } 
function processExpr ( exprObj , idx ) { var randExpr = clubexpr . replaceValuesWith ( exprObj . expr , clubexpr . randomNumbers ( 9 ) ) ; var link = '<a href="#e' + ( idx + 1 ) + '">' + ( idx + 1 ) + '.</a>' ; document . write ( '<h2 id="e' + ( idx + 1 ) + '">' + link + ' ' + exprObj . nom + '</h2>' ) ; document . write ( clubexpr . renderExprAsLisp ( randExpr ) ) ; document . write ( "$$" + clubexpr . renderExprAsLaTeX ( randExpr ) + "$$" ) ; if ( exprObj . conv . length ) { document . write ( "conventions : ") ; document . write ( exprObj . conv . join ( ', ' ) ) ; } var props = clubexpr . properties ( randExpr ) ; document . write ( "<h3>Inspection</h3>" ) ; document . write ( "nature: " + props . nature + "<br>" ) ; document . write ( props . nbOps + " operation" + ( props . nbOps > 1 ? "(s)" : "" ) + ": " + props . ops . join ( ', ' ) + "<br>" ) ; document . write ( "unique ops: " + props . uniqueOps . join ( ', ' ) + "<br>" ) ; if ( props . conventions . length ) { document . write ( "computed conventions : ") ; document . write ( props . conventions . join ( ', ' ) ) ; document . write ( "<br>" ) ; } document . write ( "depth: " + props . depth + "<br>" ) ; document . write ( "leaves: " + props . leaves + "<br>" ) ; document . write ( "letters: " + props . letters + "<br>" ) ; document . write ( "numbers: " + props . numbers + "<br>" ) ; } 
function GoogleCheckout ( settings ) { var self = this ; assert . ok ( settings . merchantNumber , 'settings.merchantNumber is required' ) ; assert . ok ( settings . merchantKey , 'settings.merchantKey is required' ) ; assert . ok ( settings . currency , 'settings.currency is required' ) ; self . settings = settings ; self . Polling = new Polling ( self ) ; self . OrderProcessing = new OrderProcessing ( self ) ; self . OrderReporting = new OrderReporting ( self ) ; self . MerchantCalculations = new MerchantCalculations ( self ) ; } 
function camelCaseObjectKeys ( obj ) { var newObj = ( Array . isArray ( obj ) ) ? new Array ( obj . length ) : { } ; utils . map ( obj , function ( key , value ) { var newKey ; if ( typeof ( key ) === 'string' ) { newKey = key . replace ( / -([a-z]{1}) / gi , function ( _ , letter ) { return letter . toUpperCase ( ) } ) } else { newKey = key ; } if ( typeof ( value ) === 'object' ) { newObj [ newKey ] = camelCaseObjectKeys ( value ) ; } else { newObj [ newKey ] = value ; } } ) ; if ( ! Object . keys ( newObj ) . length ) { newObj = null ; } return newObj ; } 
function getBase64 u rl, n, pt) var m = / ^(https?):\/\/([^:\/]+)(?::(\d+))?([^:]*)$ / . exec ( url ) ; if ( ! opt ) opt = { } ; if ( m !== null ) { http . get ( { host : m [ 2 ] , port : parseInt ( m [ 3 ] || 80 ) , path : m [ 4 ] } , function ( res ) { var buf = '' res . setEncoding ( 'binary' ) ; res . on ( 'data' , function ( data ) { buf += data ; } ) ; res . on ( 'end' , function ( ) { 
function IfCommand ( args , define ) { if ( util . endsWith ( args . toLowerCase ( ) , ' then' ) ) args = args . slice ( 0 , args . length - 5 ) . trim ( ) ; else throw new SyntaxError ( 'IF has no THEN' ) ; var parsed = new statements . ArgumentStatement ( args , { separator : false } , define ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'IF' , then : 'ELSE' , end : [ 'ENDIF' , 'RETURN' ] } ) ; } 
function logger ( stream ) { return ( ... text ) => { text . map ( text => { console . log ( text ) stream . write ( ` ${ Date . now ( ) } ${ JSON . stringify ( text ) } \n ` ) } ) } } 
function isNode ( node , type ) { var isNode = true var requiredProps = [ 'attributes' , 'children' , 'type' ] requiredProps . some ( function ( prop ) { if ( ! node [ prop ] ) { isNode = false return true } } ) if ( type && isNode ) return node . type === type return isNode } 
function forward ( receiver , provider , keys ) { keys = keys || allKeys ( provider ) ; keys = Array . isArray ( keys ) ? keys : [ keys ] ; keys . forEach ( function ( key ) { var val = provider [ key ] ; if ( typeof val === 'function' ) { receiver [ key ] = function ( ) { return provider [ key ] . apply ( provider , arguments ) ; } ; } else { receiver [ key ] = val ; } } ) ; return receiver ; } 
function RegexFinderStrategy ( config ) { config = config || { } ; FinderStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function parseName ( name ) { var modName = undefined , ext = undefined , temp = undefined , index = name . indexOf ( '.' ) , isRelative = name . indexOf ( './' ) === 0 || name . indexOf ( '../' ) === 0 ; if ( index !== - 1 && ( ! isRelative || index > 1 ) ) { modName = name . substring ( 0 , index ) ; ext = name . substring ( index + 1 , name . length ) ; } else { modName = name ; } temp = ext || modName ; index = temp . indexOf ( '!' ) ; if ( index !== - 1 ) { temp = temp . substring ( 0 , index ) ; if ( ext ) { ext = temp ; } else { modName = temp ; } } return { moduleName : modName , ext : ext } ; } 
function issorted ( arr , clbk ) { if ( ! Array . isArray ( arr ) ) { throw new TypeError ( 'issorted()::invalid input argument. Must provide an array.' ) ; } if ( arguments . length > 1 ) { if ( typeof clbk !== 'function' ) { throw new TypeError ( 'issorted()::invalid input argument. Comparator must be a function.' ) ; } } var len = arr . length , i ; if ( ! clbk ) { 
function SyncFile ( path , flags , mode ) { flags = flags || 'w' ; this . fd = fs . openSync ( path , flags , mode ) ; this . crc = new Crc64 ( ) ; this . converter = new Converter ( ) ; } 
function write ( obj ) { if ( obj . type === 'crc' ) return this . end ( ) ; var buffer = this . converter . entry ( obj ) ; this . crc . push ( buffer ) ; return this . writeBuffer ( buffer ) ; } 
function writeBuffer ( buffer ) { var written = fs . writeSync ( this . fd , buffer , 0 , buffer . length , null ) ; fs . fsyncSync ( this . fd ) ; return written ; } 
function end ( ) { this . writeBuffer ( this . crc . value ( ) ) ; fs . closeSync ( this . fd ) ; this . fd = null ; this . crc = null ; this . converter = null ; } 
function wrapMiddleware ( fn ) { assert ( typeof fn === 'function' , ` assert ( fn . length >= 2 , ` if ( fn . length === 2 ) { return function ( req , res , next ) { let p = null ; try { p = fn ( req , res ) ; } catch ( err ) { return next ( err ) ; } p . then ( _ => next ( ) ) . catch ( err => next ( err ) ) ; } ; } return fn ; } 
function camelCase ( str ) { return words ( str ) . reduce ( ( result , word , idx ) => { return result + ( idx ? ( isUpperCase ( word ) ? word : capitalize ( word ) ) : lowerCase ( word ) ) ; } , '' ) ; } 
function pascalCase ( str ) { return words ( str ) . reduce ( ( result , word , idx ) => { return result + ( idx && isUpperCase ( word ) ? word : capitalize ( word ) ) ; } , '' ) ; } 
function snakeCase ( str , sep = '_' ) { return words ( str ) . reduce ( ( result , word , idx ) => result + ( idx ? sep : '' ) + lowerCase ( word ) , '' ) ; } 
function ( data ) { var result = { } , attributeCount = 0 ; _ . each ( data , function ( value , key ) { result [ 'Attribute.' + attributeCount + '.Name' ] = key ; result [ 'Attribute.' + attributeCount + '.Value' ] = value ; attributeCount ++ ; } ) ; return result ; } 
function ( key , secret , region ) { this . sdb = aws . load ( 'sdb' , key , secret ) ; this . sdb . setRegion ( region ) ; return this ; } 
function ( DomainName , callback ) { var query = { DomainName : DomainName } ; this . sdb . request ( 'CreateDomain' , query , function ( err , result ) { if ( ! err ) { callback ( false , 'ok' ) ; } else { callback ( err , 'error' ) ; } } ) ; return this ; } 
function AbstractSyntaxTree ( root , labels , manager ) { this . root = root ; this . labels = labels ; this . manager = manager ; manager . parse ( this ) ; } 
function execute ( ast , ctx , done ) { if ( ! done && ! ( ctx instanceof ExecutionContext ) ) { done = ctx ; ctx = new ExecutionContext ( ) ; } ast . execute ( ctx , done ) ; } 
function MarkLogicStore ( options ) { options = options || { } ; var collectionName = options . collection || defaultOptions . collection ; this . baseUri = options . baseUri || encodeURI ( collectionName . replace ( / \s / g , '-' ) ) ; Store . call ( this , options ) ; this . collectionName = collectionName ; this . ttl = options . ttl || defaultOptions . ttl || 0 ; 
function _shellBundle ( { src = 'app/main.js' , dest = 'dist' , baseName = 'build' , ignoreVendors = false , onlyVendors = false } = { } , jspmConfig , useSourcemaps = false ) { 
function _vendorsList ( vendors , ignore = false ) { let vendorsList = '' let sign = ( ignore ) ? '-' : '+' for ( let vendor of vendors ) { vendorsList += ` ${ sign } ${ vendor } ` } return vendorsList } 
function startPollingForErrors ( ) { var checkFunction = ( function ( ) { 
function create ( prototype , properties ) { Ctor . prototype = prototype || { } return properties ? copy ( new Ctor ( ) , properties ) : new Ctor ( ) } 
function copy ( target , source ) { for ( var key in Object ( source ) ) target [ key ] = source [ key ] return target } 
function identity ( iterable ) { return __asyncGenerator ( this , arguments , function * identity_1 ( ) { return yield __await ( yield __await ( yield * __asyncDelegator ( __asyncValues ( iterable ) ) ) ) ; } ) ; } 
function tap ( tapper ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_1 , _a ; let index = 0 ; try { for ( var it_1 = __asyncValues ( it ) , it_1_1 ; it_1_1 = yield __await ( it_1 . next ( ) ) , ! it_1_1 . done ; ) { const value = it_1_1 . value ; yield __await ( tapper ( value , index ) ) ; yield yield __await ( value ) ; index = index + 1 ; } } catch ( e_1_1 ) { e_1 = { error : e_1_1 } ; } finally { try { if ( it_1_1 && ! it_1_1 . done && ( _a = it_1 . return ) ) yield __await ( _a . call ( it_1 ) ) ; } finally { if ( e_1 ) throw e_1 . error ; } } } ) ; } ; } 
function map ( mapper ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_2 , _a ; let index = 0 ; try { for ( var iterable_1 = __asyncValues ( iterable ) , iterable_1_1 ; iterable_1_1 = yield __await ( iterable_1 . next ( ) ) , ! iterable_1_1 . done ; ) { const value = iterable_1_1 . value ; yield yield __await ( mapper ( value , index ) ) ; index = index + 1 ; } } catch ( e_2_1 ) { e_2 = { error : e_2_1 } ; } finally { try { if ( iterable_1_1 && ! iterable_1_1 . done && ( _a = iterable_1 . return ) ) yield __await ( _a . call ( iterable_1 ) ) ; } finally { if ( e_2 ) throw e_2 . error ; } } } ) ; } ; } 
function filter ( predicate ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_5 , _a ; let index = 0 ; try { for ( var iterable_3 = __asyncValues ( iterable ) , iterable_3_1 ; iterable_3_1 = yield __await ( iterable_3 . next ( ) ) , ! iterable_3_1 . done ; ) { const value = iterable_3_1 . value ; if ( yield __await ( predicate ( value , index ) ) ) { yield yield __await ( value ) ; } index = index + 1 ; } } catch ( e_5_1 ) { e_5 = { error : e_5_1 } ; } finally { try { if ( iterable_3_1 && ! iterable_3_1 . done && ( _a = iterable_3 . return ) ) yield __await ( _a . call ( iterable_3 ) ) ; } finally { if ( e_5 ) throw e_5 . error ; } } } ) ; } ; } 
function reduce ( predicate , initial ) { return async function ( iterable ) { var e_6 , _a ; let index = 0 ; let prevState = initial ; try { for ( var iterable_4 = __asyncValues ( iterable ) , iterable_4_1 ; iterable_4_1 = await iterable_4 . next ( ) , ! iterable_4_1 . done ; ) { const value = iterable_4_1 . value ; prevState = await predicate ( prevState , value , index ) ; index = index + 1 ; } } catch ( e_6_1 ) { e_6 = { error : e_6_1 } ; } finally { try { if ( iterable_4_1 && ! iterable_4_1 . done && ( _a = iterable_4 . return ) ) await _a . call ( iterable_4 ) ; } finally { if ( e_6 ) throw e_6 . error ; } } return prevState ; } ; } 
function scan ( predicate , initial ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_7 , _a ; let index = 0 ; let prevState = initial ; try { for ( var iterable_5 = __asyncValues ( iterable ) , iterable_5_1 ; iterable_5_1 = yield __await ( iterable_5 . next ( ) ) , ! iterable_5_1 . done ; ) { const value = iterable_5_1 . value ; prevState = yield __await ( Promise . resolve ( predicate ( prevState , value , index ) ) ) ; yield yield __await ( prevState ) ; index = index + 1 ; } } catch ( e_7_1 ) { e_7 = { error : e_7_1 } ; } finally { try { if ( iterable_5_1 && ! iterable_5_1 . done && ( _a = iterable_5 . return ) ) yield __await ( _a . call ( iterable_5 ) ) ; } finally { if ( e_7 ) throw e_7 . error ; } } return yield __await ( prevState ) ; } ) ; } ; } 
function take ( count ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_9 , _a ; let i = 0 ; try { for ( var iterable_7 = __asyncValues ( iterable ) , iterable_7_1 ; iterable_7_1 = yield __await ( iterable_7 . next ( ) ) , ! iterable_7_1 . done ; ) { const item = iterable_7_1 . value ; if ( i >= count ) { return yield __await ( void 0 ) ; } yield yield __await ( item ) ; i = i + 1 ; } } catch ( e_9_1 ) { e_9 = { error : e_9_1 } ; } finally { try { if ( iterable_7_1 && ! iterable_7_1 . done && ( _a = iterable_7 . return ) ) yield __await ( _a . call ( iterable_7 ) ) ; } finally { if ( e_9 ) throw e_9 . error ; } } } ) ; } ; } 
function takeLast ( count ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_10 , _a ; const buffer = [ ] ; try { for ( var iterable_8 = __asyncValues ( iterable ) , iterable_8_1 ; iterable_8_1 = yield __await ( iterable_8 . next ( ) ) , ! iterable_8_1 . done ; ) { const item = iterable_8_1 . value ; buffer . push ( item ) ; if ( buffer . length > count ) { buffer . shift ( ) ; } } } catch ( e_10_1 ) { e_10 = { error : e_10_1 } ; } finally { try { if ( iterable_8_1 && ! iterable_8_1 . done && ( _a = iterable_8 . return ) ) yield __await ( _a . call ( iterable_8 ) ) ; } finally { if ( e_10 ) throw e_10 . error ; } } return yield __await ( yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer ) ) ) ) ; } ) ; } ; } 
function skipLast ( count ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_11 , _a ; const buffer = [ ] ; try { for ( var iterable_9 = __asyncValues ( iterable ) , iterable_9_1 ; iterable_9_1 = yield __await ( iterable_9 . next ( ) ) , ! iterable_9_1 . done ; ) { const item = iterable_9_1 . value ; buffer . push ( item ) ; } } catch ( e_11_1 ) { e_11 = { error : e_11_1 } ; } finally { try { if ( iterable_9_1 && ! iterable_9_1 . done && ( _a = iterable_9 . return ) ) yield __await ( _a . call ( iterable_9 ) ) ; } finally { if ( e_11 ) throw e_11 . error ; } } if ( buffer . length < count ) { return yield __await ( void 0 ) ; } yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer . slice ( 0 , buffer . length - count ) ) ) ) ; } ) ; } ; } 
async function last ( iterable ) { var e_12 , _a ; let last = undefined ; try { for ( var iterable_10 = __asyncValues ( iterable ) , iterable_10_1 ; iterable_10_1 = await iterable_10 . next ( ) , ! iterable_10_1 . done ; ) { const item = iterable_10_1 . value ; last = item ; } } catch ( e_12_1 ) { e_12 = { error : e_12_1 } ; } finally { try { if ( iterable_10_1 && ! iterable_10_1 . done && ( _a = iterable_10 . return ) ) await _a . call ( iterable_10 ) ; } finally { if ( e_12 ) throw e_12 . error ; } } return last ; } 
async function first ( iterable ) { var e_13 , _a ; try { for ( var iterable_11 = __asyncValues ( iterable ) , iterable_11_1 ; iterable_11_1 = await iterable_11 . next ( ) , ! iterable_11_1 . done ; ) { const item = iterable_11_1 . value ; return item ; } } catch ( e_13_1 ) { e_13 = { error : e_13_1 } ; } finally { try { if ( iterable_11_1 && ! iterable_11_1 . done && ( _a = iterable_11 . return ) ) await _a . call ( iterable_11 ) ; } finally { if ( e_13 ) throw e_13 . error ; } } return undefined ; } 
function skip ( count ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_14 , _a ; let i = 0 ; try { for ( var iterable_12 = __asyncValues ( iterable ) , iterable_12_1 ; iterable_12_1 = yield __await ( iterable_12 . next ( ) ) , ! iterable_12_1 . done ; ) { const item = iterable_12_1 . value ; if ( i >= count ) { yield yield __await ( item ) ; } i = i + 1 ; } } catch ( e_14_1 ) { e_14 = { error : e_14_1 } ; } finally { try { if ( iterable_12_1 && ! iterable_12_1 . done && ( _a = iterable_12 . return ) ) yield __await ( _a . call ( iterable_12 ) ) ; } finally { if ( e_14 ) throw e_14 . error ; } } } ) ; } ; } 
function takeWhile ( predicate ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_15 , _a ; let i = 0 ; try { for ( var iterable_13 = __asyncValues ( iterable ) , iterable_13_1 ; iterable_13_1 = yield __await ( iterable_13 . next ( ) ) , ! iterable_13_1 . done ; ) { const item = iterable_13_1 . value ; if ( ! ( yield __await ( Promise . resolve ( predicate ( item , i ) ) ) ) ) { break ; } yield yield __await ( item ) ; i = i + 1 ; } } catch ( e_15_1 ) { e_15 = { error : e_15_1 } ; } finally { try { if ( iterable_13_1 && ! iterable_13_1 . done && ( _a = iterable_13 . return ) ) yield __await ( _a . call ( iterable_13 ) ) ; } finally { if ( e_15 ) throw e_15 . error ; } } } ) ; } ; } 
function takeUntil ( predicate ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_16 , _a ; let i = 0 ; try { for ( var iterable_14 = __asyncValues ( iterable ) , iterable_14_1 ; iterable_14_1 = yield __await ( iterable_14 . next ( ) ) , ! iterable_14_1 . done ; ) { const item = iterable_14_1 . value ; if ( yield __await ( predicate ( item , i ) ) ) { return yield __await ( void 0 ) ; } yield yield __await ( item ) ; i = i + 1 ; } } catch ( e_16_1 ) { e_16 = { error : e_16_1 } ; } finally { try { if ( iterable_14_1 && ! iterable_14_1 . done && ( _a = iterable_14 . return ) ) yield __await ( _a . call ( iterable_14 ) ) ; } finally { if ( e_16 ) throw e_16 . error ; } } } ) ; } ; } 
function skipUntil ( predicate ) { return function ( iterable ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_18 , _a ; let i = 0 ; let canReturn = false ; try { for ( var iterable_16 = __asyncValues ( iterable ) , iterable_16_1 ; iterable_16_1 = yield __await ( iterable_16 . next ( ) ) , ! iterable_16_1 . done ; ) { const item = iterable_16_1 . value ; if ( ! canReturn ) { canReturn = yield __await ( predicate ( item , i ) ) ; if ( canReturn ) { yield yield __await ( item ) ; } i = i + 1 ; } else { yield yield __await ( item ) ; } } } catch ( e_18_1 ) { e_18 = { error : e_18_1 } ; } finally { try { if ( iterable_16_1 && ! iterable_16_1 . done && ( _a = iterable_16 . return ) ) yield __await ( _a . call ( iterable_16 ) ) ; } finally { if ( e_18 ) throw e_18 . error ; } } } ) ; } ; } 
function elementAtOrDefault ( index , or ) { return async function ( it ) { var e_19 , _a ; let i = 0 ; try { for ( var it_2 = __asyncValues ( it ) , it_2_1 ; it_2_1 = await it_2 . next ( ) , ! it_2_1 . done ; ) { const item = it_2_1 . value ; if ( i === index ) { return item ; } i = i + 1 ; } } catch ( e_19_1 ) { e_19 = { error : e_19_1 } ; } finally { try { if ( it_2_1 && ! it_2_1 . done && ( _a = it_2 . return ) ) await _a . call ( it_2 ) ; } finally { if ( e_19 ) throw e_19 . error ; } } return or ; } ; } 
function concat ( ... iterables ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_20 , _a ; yield __await ( yield * __asyncDelegator ( __asyncValues ( it ) ) ) ; try { for ( var iterables_1 = __asyncValues ( iterables ) , iterables_1_1 ; iterables_1_1 = yield __await ( iterables_1 . next ( ) ) , ! iterables_1_1 . done ; ) { const iterable = iterables_1_1 . value ; yield __await ( yield * __asyncDelegator ( __asyncValues ( iterable ) ) ) ; } } catch ( e_20_1 ) { e_20 = { error : e_20_1 } ; } finally { try { if ( iterables_1_1 && ! iterables_1_1 . done && ( _a = iterables_1 . return ) ) yield __await ( _a . call ( iterables_1 ) ) ; } finally { if ( e_20 ) throw e_20 . error ; } } } ) ; } ; } 
function unshift ( ... next ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { for ( let i = 0 ; i < next . length ; ++ i ) yield yield __await ( next [ next . length - i - 1 ] ) ; yield __await ( yield * __asyncDelegator ( __asyncValues ( it ) ) ) ; } ) ; } ; } 
function some ( predicate ) { return async ( it ) => { var e_22 , _a ; let index = 0 ; try { for ( var it_3 = __asyncValues ( it ) , it_3_1 ; it_3_1 = await it_3 . next ( ) , ! it_3_1 . done ; ) { const item = it_3_1 . value ; if ( await predicate ( item , index ) ) { return true ; } index = index + 1 ; } } catch ( e_22_1 ) { e_22 = { error : e_22_1 } ; } finally { try { if ( it_3_1 && ! it_3_1 . done && ( _a = it_3 . return ) ) await _a . call ( it_3 ) ; } finally { if ( e_22 ) throw e_22 . error ; } } return false ; } ; } 
function every ( predicate ) { return async ( it ) => { var e_23 , _a ; let i = 0 ; try { for ( var it_4 = __asyncValues ( it ) , it_4_1 ; it_4_1 = await it_4 . next ( ) , ! it_4_1 . done ; ) { const item = it_4_1 . value ; if ( ! await Promise . resolve ( predicate ( item , i ) ) ) { return false ; } i = i + 1 ; } } catch ( e_23_1 ) { e_23 = { error : e_23_1 } ; } finally { try { if ( it_4_1 && ! it_4_1 . done && ( _a = it_4 . return ) ) await _a . call ( it_4 ) ; } finally { if ( e_23 ) throw e_23 . error ; } } return true ; } ; } 
function distinct ( it ) { return __asyncGenerator ( this , arguments , function * distinct_1 ( ) { var e_24 , _a ; const resultSet = new Set ( ) ; try { for ( var it_5 = __asyncValues ( it ) , it_5_1 ; it_5_1 = yield __await ( it_5 . next ( ) ) , ! it_5_1 . done ; ) { const item = it_5_1 . value ; if ( ! resultSet . has ( item ) ) { resultSet . add ( item ) ; yield yield __await ( item ) ; } } } catch ( e_24_1 ) { e_24 = { error : e_24_1 } ; } finally { try { if ( it_5_1 && ! it_5_1 . done && ( _a = it_5 . return ) ) yield __await ( _a . call ( it_5 ) ) ; } finally { if ( e_24 ) throw e_24 . error ; } } } ) ; } 
function orderBy ( keySelector , comparison ) { const trueKeySelector = keySelector || defaultKeySelector ; const trueComparison = comparison || defaultComparison ; return function ( item ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_25 , _a ; const keyedMapper = map ( ( item , index ) => ( { item , key : trueKeySelector ( item , index ) } ) ) ; const keyed = keyedMapper ( item ) ; const keyedArray = yield __await ( toWriteableArray ( keyed ) ) ; keyedArray . sort ( ( a , b ) => trueComparison ( a . key , b . key ) ) ; try { for ( var keyedArray_1 = __asyncValues ( keyedArray ) , keyedArray_1_1 ; keyedArray_1_1 = yield __await ( keyedArray_1 . next ( ) ) , ! keyedArray_1_1 . done ; ) { const { item } = keyedArray_1_1 . value ; yield yield __await ( item ) ; } } catch ( e_25_1 ) { e_25 = { error : e_25_1 } ; } finally { try { if ( keyedArray_1_1 && ! keyedArray_1_1 . done && ( _a = keyedArray_1 . return ) ) yield __await ( _a . call ( keyedArray_1 ) ) ; } finally { if ( e_25 ) throw e_25 . error ; } } } ) ; } ; } 
function flip ( it ) { return __asyncGenerator ( this , arguments , function * flip_1 ( ) { yield __await ( yield * __asyncDelegator ( __asyncValues ( yield __await ( reduce ( ( prev , next ) => [ next ] . concat ( prev ) , [ ] ) ( it ) ) ) ) ) ; } ) ; } 
function repeat ( times ) { return function ( it ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_26 , _a ; const buffer = [ ] ; try { for ( var it_6 = __asyncValues ( it ) , it_6_1 ; it_6_1 = yield __await ( it_6 . next ( ) ) , ! it_6_1 . done ; ) { const item = it_6_1 . value ; buffer . push ( item ) ; yield yield __await ( item ) ; } } catch ( e_26_1 ) { e_26 = { error : e_26_1 } ; } finally { try { if ( it_6_1 && ! it_6_1 . done && ( _a = it_6 . return ) ) yield __await ( _a . call ( it_6 ) ) ; } finally { if ( e_26 ) throw e_26 . error ; } } for ( let i = 0 ; i < times ; ++ i ) { yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer ) ) ) ; } } ) ; } ; } 
function doppler ( it ) { return __asyncGenerator ( this , arguments , function * doppler_1 ( ) { var e_27 , _a ; const buffer = [ ] ; try { for ( var it_7 = __asyncValues ( it ) , it_7_1 ; it_7_1 = yield __await ( it_7 . next ( ) ) , ! it_7_1 . done ; ) { const item = it_7_1 . value ; buffer . push ( item ) ; yield yield __await ( item ) ; } } catch ( e_27_1 ) { e_27 = { error : e_27_1 } ; } finally { try { if ( it_7_1 && ! it_7_1 . done && ( _a = it_7 . return ) ) yield __await ( _a . call ( it_7 ) ) ; } finally { if ( e_27 ) throw e_27 . error ; } } buffer . reverse ( ) ; yield __await ( yield * __asyncDelegator ( __asyncValues ( buffer ) ) ) ; } ) ; } 
function or ( other ) { return function ( source ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_28 , _a ; let hasYieldedItem = false ; try { for ( var source_1 = __asyncValues ( source ) , source_1_1 ; source_1_1 = yield __await ( source_1 . next ( ) ) , ! source_1_1 . done ; ) { const item = source_1_1 . value ; yield yield __await ( item ) ; hasYieldedItem = true ; } } catch ( e_28_1 ) { e_28 = { error : e_28_1 } ; } finally { try { if ( source_1_1 && ! source_1_1 . done && ( _a = source_1 . return ) ) yield __await ( _a . call ( source_1 ) ) ; } finally { if ( e_28 ) throw e_28 . error ; } } if ( ! hasYieldedItem ) { yield __await ( yield * __asyncDelegator ( __asyncValues ( other ) ) ) ; } } ) ; } ; } 
async function toArray ( iterable ) { var e_29 , _a ; const blob = [ ] ; try { for ( var iterable_17 = __asyncValues ( iterable ) , iterable_17_1 ; iterable_17_1 = await iterable_17 . next ( ) , ! iterable_17_1 . done ; ) { const it = iterable_17_1 . value ; blob . push ( it ) ; } } catch ( e_29_1 ) { e_29 = { error : e_29_1 } ; } finally { try { if ( iterable_17_1 && ! iterable_17_1 . done && ( _a = iterable_17 . return ) ) await _a . call ( iterable_17 ) ; } finally { if ( e_29 ) throw e_29 . error ; } } return blob ; } 
async function toWriteableArray ( iterable ) { var e_30 , _a ; const blob = [ ] ; try { for ( var iterable_18 = __asyncValues ( iterable ) , iterable_18_1 ; iterable_18_1 = await iterable_18 . next ( ) , ! iterable_18_1 . done ; ) { const it = iterable_18_1 . value ; blob . push ( it ) ; } } catch ( e_30_1 ) { e_30 = { error : e_30_1 } ; } finally { try { if ( iterable_18_1 && ! iterable_18_1 . done && ( _a = iterable_18 . return ) ) await _a . call ( iterable_18 ) ; } finally { if ( e_30 ) throw e_30 . error ; } } return blob ; } 
function updateAt ( index , value ) { return function ( source ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_31 , _a ; let i = 0 ; try { for ( var source_2 = __asyncValues ( source ) , source_2_1 ; source_2_1 = yield __await ( source_2 . next ( ) ) , ! source_2_1 . done ; ) { const item = source_2_1 . value ; if ( i === index ) { yield yield __await ( value ) ; } else { yield yield __await ( item ) ; } i = i + 1 ; } } catch ( e_31_1 ) { e_31 = { error : e_31_1 } ; } finally { try { if ( source_2_1 && ! source_2_1 . done && ( _a = source_2 . return ) ) yield __await ( _a . call ( source_2 ) ) ; } finally { if ( e_31 ) throw e_31 . error ; } } } ) ; } ; } 
function removeAt ( index ) { return function ( source ) { return __asyncGenerator ( this , arguments , function * ( ) { var e_32 , _a ; let i = 0 ; try { for ( var source_3 = __asyncValues ( source ) , source_3_1 ; source_3_1 = yield __await ( source_3 . next ( ) ) , ! source_3_1 . done ; ) { const item = source_3_1 . value ; if ( i !== index ) { yield yield __await ( item ) ; } i = i + 1 ; } } catch ( e_32_1 ) { e_32 = { error : e_32_1 } ; } finally { try { if ( source_3_1 && ! source_3_1 . done && ( _a = source_3 . return ) ) yield __await ( _a . call ( source_3 ) ) ; } finally { if ( e_32 ) throw e_32 . error ; } } } ) ; } ; } 
async function count ( source ) { var e_33 , _a ; let i = 0 ; try { for ( var source_4 = __asyncValues ( source ) , source_4_1 ; source_4_1 = await source_4 . next ( ) , ! source_4_1 . done ; ) { const it = source_4_1 . value ; ++ i ; } } catch ( e_33_1 ) { e_33 = { error : e_33_1 } ; } finally { try { if ( source_4_1 && ! source_4_1 . done && ( _a = source_4 . return ) ) await _a . call ( source_4 ) ; } finally { if ( e_33 ) throw e_33 . error ; } } return i ; } 
async function empty ( source ) { var e_34 , _a ; let i = 0 ; try { for ( var source_5 = __asyncValues ( source ) , source_5_1 ; source_5_1 = await source_5 . next ( ) , ! source_5_1 . done ; ) { const it = source_5_1 . value ; return false ; } } catch ( e_34_1 ) { e_34 = { error : e_34_1 } ; } finally { try { if ( source_5_1 && ! source_5_1 . done && ( _a = source_5 . return ) ) await _a . call ( source_5 ) ; } finally { if ( e_34 ) throw e_34 . error ; } } return true ; } 
function Client ( opts ) { this . id = opts . id ; this . opts = opts ; this . send = send ; this . isConnected = false ; let client = this ; let queue = [ ] ; let callbacks = { } ; let isBusy = true ; let socket ; connect ( opts ) ; function send ( event , data , callback ) { if ( ! client . isConnected && callback ) return callback ( new Error ( 'CONNECTION' ) ) ; queue . push ( { event , data , callback } ) ; next ( ) ; } function next ( ) { if ( isBusy ) return ; isBusy = true ; if ( queue . length == 0 ) return ( isBusy = false ) ; if ( socket ) { let msg = { id : genId ( ) , event : queue [ 0 ] . event , data : queue [ 0 ] . data } socket . write ( ( ! ! opts . cipher ? encode ( JSON . stringify ( msg ) , opts . cipher , opts . password ) : JSON . stringify ( msg ) ) + '|' , function ( err ) { if ( err ) return socket . emit ( 'error' , err ) ; if ( queue [ 0 ] . callback ) callbacks [ msg . id ] = queue [ 0 ] . callback ; client . emit ( 'send' , queue [ 0 ] ) ; queue . shift ( ) ; isBusy = false ; next ( ) ; } ) ; } } function connect ( opts ) { socket = net . connect ( { host : opts . host , port : opts . port } ) ; queue = [ ] ; callbacks = { } ; isBusy = true ; socket . on ( 'connect' , function ( ) { isBusy = false ; client . isConnected = true ; client . emit ( 'connect' , opts . id ) ; } ) ; let buffer = '' ; socket . on ( 'data' , function ( chunk ) { buffer += chunk ; let msgs = buffer . split ( '|' ) ; buffer = msgs . pop ( ) ; msgs . forEach ( function ( packet ) { let msg ; try { msg = JSON . parse ( ! ! opts . cipher ? decode ( packet , opts . cipher , opts . password ) : packet ) ; } catch ( err ) { return socket . emit ( 'error' , err ) ; } client . emit ( 'receive' , msg ) ; if ( msg . id in callbacks ) { callbacks [ msg . id ] ( msg . data ) ; delete callbacks [ msg . id ] ; return ; } if ( msg . event != 'ACK' ) { client . emit ( msg . event , msg . data ) ; send ( 'ACK' , { id : msg . id , event : msg . event } ) ; return ; } } ) ; } ) ; socket . on ( 'close' , ( ) => { setTimeout ( connect , opts [ 'reconnect-delay' ] * 1000 || 30000 , opts ) ; if ( client . isConnected ) { client . isConnected = false ; client . emit ( 'disconnect' , opts . id ) ; } client . isConnected = false ; } ) ; socket . on ( 'error' , ( err ) => client . emit ( 'error' , err ) ) ; } } 
function Server ( opts ) { let server = this ; server . send = send ; let isBusy = true ; let queue = [ ] ; if ( ! ! opts . dir ) { try { fs . mkdirSync ( opts . dir ) ; 
function CloseCommand ( args , define ) { var parsed = new statements . ExpressionStatement ( args , define ) ; if ( ! ( parsed . child instanceof statements . PointerStatement ) ) throw new SyntaxError ( 'Expected pointer' ) ; this . pointer = parsed ; } 
function entropy ( out , x ) { var len = x . length , i ; if ( out . length !== len ) { throw new Error ( 'entropy()::invalid input arguments. Input and output matrices must be the same length.' ) ; } for ( i = 0 ; i < len ; i ++ ) { out . data [ i ] = ENTROPY ( x . data [ i ] ) ; } return out ; } 
function MQlobberClient ( stream , options ) { EventEmitter . call ( this ) ; options = options || { } ; this . _options = options ; this . subs = new Map ( ) ; this . _matcher = new QlobberDedup ( options ) ; this . mux = new BPMux ( stream , options ) ; this . _done = false ; var ths = this ; function error ( err ) { ths . emit ( 'error' , err , this ) ; } function warning ( err ) { if ( ! ths . emit ( 'warning' , err , this ) ) { console . error ( err ) ; } } this . _warning = warning ; this . _unexpected_data = function ( ) { while ( true ) { if ( this . read ( ) === null ) { break ; } warning . call ( this , new Error ( 'unexpected data' ) ) ; } } ; this . mux . on ( 'error' , error ) ; function handshake_sent ( duplex , complete ) { if ( ! complete ) { ths . emit ( 'backoff' ) ; } } this . mux . on ( 'handshake_sent' , handshake_sent ) ; this . mux . on ( 'pre_handshake_sent' , handshake_sent ) ; this . mux . on ( 'drain' , function ( ) { ths . emit ( 'drain' ) ; } ) ; this . mux . on ( 'full' , function ( ) { ths . emit ( 'full' ) ; } ) ; this . mux . on ( 'removed' , function ( duplex ) { ths . emit ( 'removed' , duplex ) ; } ) ; this . mux . on ( 'finish' , function ( ) { ths . _done = true ; } ) ; this . mux . on ( 'end' , function ( ) { ths . subs . clear ( ) ; } ) ; var duplex = this . mux . multiplex ( options ) ; function end ( ) { error . call ( this , new Error ( 'ended before handshaken' ) ) ; } duplex . on ( 'end' , end ) ; duplex . on ( 'error' , error ) ; duplex . on ( 'readable' , this . _unexpected_data ) ; this . mux . on ( 'peer_multiplex' , function ( duplex ) { duplex . on ( 'error' , error ) ; } ) ; this . mux . on ( 'handshake' , function ( dplex , hdata , delay ) { if ( dplex === duplex ) { duplex . removeListener ( 'end' , end ) ; ths . emit ( 'handshake' , hdata ) ; return duplex . end ( ) ; 
function Block ( line , def , parent ) { this . startNames = [ ] ; this . thenNames = [ ] ; this . endNames = [ ] ; for ( var i = 0 ; i < def . start . length ; i ++ ) this . startNames . push ( def . start [ i ] . toLowerCase ( ) ) ; for ( var x = 0 ; x < def . end . length ; x ++ ) this . endNames . push ( def . end [ x ] . toLowerCase ( ) ) ; for ( var y = 0 ; y < def . then . length ; y ++ ) this . thenNames . push ( def . then [ y ] . toLowerCase ( ) ) ; this . line = line ; this . parent = parent ; this . searchIndex = line ; this . start = - 1 ; this . intermediateIndexes = { } ; this . intermediateCursors = { } ; this . end = - 1 ; } 
function ( callback , onEnd ) { 
function align ( key , leftStream , rightStream , epsilon ) { 
function entropy ( arr , path , sep ) { var len = arr . length , opts = { } , dget , dset , v , i ; if ( arguments . length > 2 ) { opts . sep = sep ; } if ( len ) { dget = deepGet ( path , opts ) ; dset = deepSet ( path , opts ) ; for ( i = 0 ; i < len ; i ++ ) { v = dget ( arr [ i ] ) ; if ( typeof v === 'number' ) { dset ( arr [ i ] , ENTROPY ( v ) ) ; } else { dset ( arr [ i ] , NaN ) ; } } } return arr ; } 
function ReadCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var placeVar = parsed . args [ i ] ; if ( ! ( placeVar . child instanceof statements . VariableStatement || placeVar . child instanceof statements . FunctionStatement ) ) throw new SyntaxError ( 'Expected variable' ) ; } this . items = parsed . args ; } 
function next ( ) { var description , firstTopic = topicChain [ 0 ] ; for ( description in context ) { if ( description !== 'topic' && context . hasOwnProperty ( description ) ) { ( function ( description ) { var item = context [ description ] , itemType = typeof item ; 
function renderContent ( tpl , data , isFinal ) { var temp = juicer ( tpl , data , { errorhandling : false } ) if ( temp == null ) { console . log ( "gg-template-engine: render Error tpl: ===========================" ) console . log ( tpl ) console . log ( "data: ===========================================================" ) console . log ( data ) throw new Error ( "gg-template-engine: render Error " ) ; } if ( isFinal ) { 
function compileValue ( value ) { if ( value . subtype === 'array' ) { return compileArray ( value ) } else if ( value . subtype === 'object' ) { return compileObject ( value ) } else if ( value . subtype === 'mixin' ) { return compileMixin ( value ) } else if ( value . subtype === 'js' ) { return compileJS ( value ) } else if ( value . subtype === 'function' ) { return compileFunction ( value ) } throw new Error ( 'Invalid subtype: ' + value . subtype ) } 
function preparePath ( path ) { var parts = path . split ( '.' ) parts = parts . map ( function ( part ) { return numericRegex . test ( part ) ? part : '\'' + escape ( part ) + '\'' } ) return '[' + parts . join ( ', ' ) + ']' } 
function DrawspriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'DRAWSPRITE command requires 3 arguments' ) ; this . id = parsed . args [ 0 ] ; this . x = parsed . args [ 1 ] ; this . y = parsed . args [ 2 ] ; this . scale = parsed . args . length === 4 ? parsed . args [ 3 ] : false ; this . rotation = parsed . args . length === 5 ? parsed . args [ 4 ] : false ; } 
function ( string ) { 
function sprintf ( fstr , array ) { 
function Load ( options ) { var self = this ; self . _path = options . path || './config' ; self . _environment = options . environment || args ( ) . env || 'development' ; self . _reload = options . reload || false ; 
function resolveFilePatterns ( baseDir , patterns , opt_omitWarnings ) { var resolvedFiles = [ ] ; if ( patterns ) { for ( var i = 0 ; i < patterns . length ; ++ i ) { var matches = glob . sync ( patterns [ i ] , { cwd : baseDir } ) ; if ( ! matches . length && ! opt_omitWarnings ) { util . puts ( 'Warning: pattern ' + patterns [ i ] + ' did not match any files.' ) ; } for ( var j = 0 ; j < matches . length ; ++ j ) { resolvedFiles . push ( path . resolve ( baseDir , matches [ j ] ) ) ; } } } return resolvedFiles ; } 
function ekurtosis ( p ) { if ( ! ( isNumber ( p ) && 0 <= p && p <= 1 ) ) { return NaN ; } return 6 + square ( p ) / ( 1 - p ) ; } 
function deepLook ( obj , types ) { if ( typeof ( obj ) !== 'object' ) return obj ; for ( var key in obj ) { if ( ! obj [ key ] . type ) { obj [ key ] = deepLook ( obj [ key ] , types ) ; } else { if ( ! types [ obj [ key ] . type ] ) { throw new Error ( 'No type ' + obj [ key ] . type + ' in Types: key ' + key ) ; } 
function validateObjectRequired ( options , modelObject , entity , parents , errors ) { for ( var key in modelObject ) { if ( ! modelObject [ key ] . type && entity ) { validateObjectRequired ( options , modelObject [ key ] , entity [ key ] , parents + '.' + key , errors ) ; } else if ( ! options . notRequired && modelObject [ key ] . required && ( ! entity || ! entity [ key ] ) ) { if ( ! errors . notFound ) errors . notFound = [ ] ; var fieldName = parents + '.' + key ; errors . notFound . push ( fieldName ) ; errors . text . push ( 'Field ' + fieldName + ' not found' ) ; } } return errors ; } 
function validateObjectEntity ( modelObject , entity , parents , errors ) { if ( ! errors ) errors = { } ; if ( ! errors . text ) errors . text = [ ] ; if ( ! parents ) parents = [ ] ; for ( var key in entity ) { var fieldName = parents + '.' + key ; if ( ! modelObject || ! modelObject [ key ] ) { if ( ! errors . notRequired ) errors . notRequired = [ ] ; errors . notRequired . push ( fieldName ) ; errors . text . push ( 'Field ' + fieldName + ' not required' ) ; } else if ( ! modelObject [ key ] . type ) { validateObjectEntity ( modelObject [ key ] , entity [ key ] , [ parents , key ] , errors ) ; } else if ( ! modelObject [ key ] . check ( entity [ key ] ) ) { if ( ! errors . notMatched ) errors . notMatched = { } ; errors . notMatched [ fieldName ] = modelObject [ key ] . type ; errors . text . push ( 'Field ' + fieldName + ' not matched with type ' + modelObject [ key ] . type ) ; } } return errors ; } 
function ( modelName , modelObject ) { 
function ( params ) { var res = [ ] ; if ( typeof ( params ) === 'undefined' ) params = { displayEverything : false } ; if ( ! this . registeredModels || Object . keys ( this . registeredModels ) . length === 0 ) { res . push ( 'There is no registered models' ) ; } else { res . push ( 'List of registered models' ) ; for ( var modelName in this . registeredModels ) { res . push ( ' - ' + modelName ) ; if ( params . displayEverything ) { for ( var key in this . registeredModels [ modelName ] ) { res . push ( ' ' + key + ' : ' + this . registeredModels [ modelName ] [ key ] . type ) ; } } } } return res . join ( '\n' ) ; } 
function ( modelName , entity , options , next ) { if ( typeof options === 'function' ) next = options ; if ( ! options ) options = { } ; var modelObject = this . registeredModels [ modelName ] ; if ( typeof modelName === 'object' ) { modelObject = deepLook ( modelName , this . types ) ; } else if ( this . types [ modelName ] ) { if ( options . one ) this . types [ modelName ] . one = options . one ; var result = this . types [ modelName ] . check ( entity ) ? null : { notMatched : modelName } ; return typeof next === 'function' ? next ( result ) : result ; } var errors = validateObjectRequired ( options , modelObject , entity , [ ] , validateObjectEntity ( modelObject , entity ) ) ; if ( ! errors . text [ 0 ] ) errors = { } ; if ( errors && errors . text ) errors . text = errors . text . join ( '. ' ) ; if ( typeof next === 'function' ) { next ( Object . keys ( errors ) . length ? errors : null ) ; } else { return Object . keys ( errors ) . length ? errors : { } ; } } 
function ( type ) { var examples = this . getExamples ( type ) ; return examples [ Math . floor ( Math . random ( ) * examples . length ) ] ; } 
function SleepCommand ( args , define ) { this . duration = new statements . ExpressionStatement ( args , define ) ; if ( this . duration . error ) throw this . duration . error ; } 
function ( callback , compilationSource ) { if ( compilationSource && this . cache . compilationSource && this . cache . compilationSource === compilationSource ) return ; var callbackError = function ( type , strOrErr ) { 
function plugin ( opts ) { return function ( files , metalsmith , done ) { async . eachSeries ( Object . keys ( files ) , prerender , done ) ; function prerender ( file , done ) { var data = files [ file ] ; if ( ! data . mathjax ) { done ( ) ; } else { debug ( "Found mathjax in" , file ) ; var contents = data . contents . toString ( 'utf8' ) ; mjAPI . mjpage ( contents , { format : [ "TeX" ] } , { svg : true } , function ( result ) { 
function gulpQiniuCdn ( conf ) { qiniu . conf . ACCESS_KEY = conf . AK ; qiniu . conf . SECRET_KEY = conf . SK ; var putpolicy = new qiniu . rs . PutPolicy ( ) 
function errorHandler ( response , error ) { response . status ( 500 ) . send ( error !== undefined && error !== null ? error . toString ( ) : '' ) } 
function bemRequireLoader ( source ) { const bemFs = nodeEval ( source ) ; const targets = [ ] ; const self = this ; bemFs . forEach ( ( source ) => { if ( source [ 'raw' ] ) { targets . push ( source [ 'raw' ] ) ; } else if ( source [ 'require' ] ) { const modulePath = path . resolve ( source [ 'require' ] ) ; self . addDependency ( modulePath ) ; const request = loaderUtils . stringifyRequest ( self , modulePath ) ; targets . push ( 'require(' + request + ');' ) ; } else { return Error ( 'Wrong input: ' + JSON . stringify ( source ) ) ; } } ) ; return targets . join ( '\n' ) ; } 
function ( cb ) { Person . findOrCreate ( { name : 'Scott' } , function ( err , person ) { assert ( Person . isInstance ( person ) ) ; assert ( person . uuid ) ; assert ( person . name === 'Scott' ) ; cb ( ) ; } ) ; } 
function ( cb ) { Person . find ( 'Scott' , function ( err , person ) { if ( err ) { return cb ( err ) ; } assert ( person . uuid ) ; assert ( person . name === 'Scott' ) ; scott = person ; cb ( ) ; } ) ; } 
function ( cb ) { var calli = Dog . new ( { name : 'Calli' } ) ; 
function ( cb ) { scott . deleteAllDogs ( function ( err ) { if ( err ) { return cb ( err ) ; } scott . delete ( function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function CircleCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'CIRCLE command requires 3 arguments' ) ; this . x = parsed . args [ 0 ] ; this . y = parsed . args [ 1 ] ; this . radius = parsed . args [ 2 ] ; this . stroke = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function Polling ( objGoogleCheckout ) { var self = this ; 
function TriangleCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 6 ) throw new SyntaxError ( 'TRIANGLE command requires 6 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . x3 = parsed . args [ 4 ] ; this . y3 = parsed . args [ 5 ] ; this . stroke = parsed . args . length > 6 ? parsed . args [ 6 ] : false ; } 
function processFile ( file ) { var changed = true ; while ( changed && ! file . processed ) { changed = false ; changed = processWraps ( file ) ; changed = processInserts ( file ) ; } file . processed = true ; } 
function Service ( name ) { debug ( 'new service: %s' , name ) ; assert ( name , "service not supplied with name" ) ; this . name = name ; this . middleware = [ ] ; this . uri = new Uri ( ) ; this . status = new Status ( ) ; this . initialize ( ) ; return this ; } 
function listenFn ( err ) { debug ( '%s: start listening on %o' , this . name , this . uri . get ( ) ) ; this . uri . setPort ( instance . address ( ) . port ) ; this . emit ( 'start' ) ; this . status . state ( ) . go ( 'Running' ) ; } 
function Analyzer ( config , state ) { config = config || { } ; this . state = state ; this . config = extend ( true , { finders : { styl : [ { name : 'regex' , config : { pattern : / ^\s*(?:@import|@require)\s+['"](.+?)['"](?:$|;) / gm , exclude : [ 'nib' ] } } ] , coffee : [ { name : 'regex' , config : { pattern : / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*(?:\()?['"]([^'"]+)['"](?:\))? / gm } } ] , cjsx : [ { name : 'regex' , config : { pattern : / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*(?:\()?['"]([^'"]+)['"](?:\))? / gm } } ] , js : [ { name : 'regex' , config : { pattern : [ / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*\(?['"]([^'"]+)['"]\)? / gm , / \bimport\s+(?:.+\s+from\s+)?[\'"]([^"\']+)["\'] / gm ] } } ] , jsx : [ { name : 'regex' , config : { pattern : [ / ^\s*(?:.+?\s*[=\:\(\{\;])?\s*require\s*\(?['"]([^'"]+)['"]\)? / gm , / \bimport\s+(?:.+\s+from\s+)?[\'"]([^"\']+)["\'] / gm ] } } ] } , resolvers : { styl : [ { name : 'basic' , config : { extensions : [ 'styl' , 'css' ] } } ] , coffee : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , cjsx : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , js : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] , jsx : [ { name : 'common-js' , config : { extensions : [ 'coffee' , 'js' , 'cjsx' , 'jsx' ] } } ] } } , config ) ; this . finders = { } ; this . resolvers = { } ; this . createFinders ( ) ; this . createResolvers ( ) ; } 
function ( duration ) { if ( duration === 0 ) throw new Error ( 'Duration must not be === 0' ) ; if ( ! S . isString ( duration ) ) return duration ; return duration . contains ( 'ms' ) ? parseInt ( duration , 10 ) : parseInt ( duration , 10 ) * 1000 ; } 
function RrectCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 5 ) throw new SyntaxError ( 'RRECT command requires 5 arguments' ) ; this . x1 = parsed . args [ 0 ] ; this . y1 = parsed . args [ 1 ] ; this . x2 = parsed . args [ 2 ] ; this . y2 = parsed . args [ 3 ] ; this . radius = parsed . args [ 4 ] ; this . stroke = parsed . args . length > 5 ? parsed . args [ 5 ] : false ; } 
function ( cmd , parentCmd , pos ) { var S = 'Somme' ; var D = 'Diff' ; var P = 'Produit' ; var Q = 'Quotient' ; var O = 'Opposé'; var I = 'Inverse' ; var C = 'Carré'; var Pu = 'Puissance' ; var R = 'Racine' ; if ( belongsTo ( parentCmd , [ C , Pu ] ) && pos == 0 ) { return belongsTo ( cmd , [ S , D , O , P , Q , I , C , Pu ] ) ; } if ( parentCmd == P ) { return belongsTo ( cmd , [ S , D , O ] ) ; } if ( ( parentCmd == O ) || ( parentCmd == D && pos == 1 ) ) { return belongsTo ( cmd , [ S , D , O ] ) ; } if ( parentCmd == S && cmd == O && pos == 1 ) { return true ; } return false ; } 
function listenOnChanges ( fn ) { var scriptContent = 'var cartId="' + me . cart + '";var extId="' + chrome . runtime . id + '";$(document).bind("MenuDishesChanged QuantityChanged MealDealRemoved DishRemoved TipUpdated DiscounCouponAdded AddressSelected DeliveryMethodChanged", ' + fn + ')' ; var script = document . createElement ( 'script' ) ; script . id = 'tmpScript' ; script . appendChild ( document . createTextNode ( scriptContent ) ) ; ( document . body || document . head || document . documentElement ) . appendChild ( script ) ; $ ( "#tmpScript" ) . remove ( ) ; } 
function main ( ) { var rawData = $ ( '.HeaderTexture[data-login-user-email]' ) . data ( ) ; if ( rawData ) { me = { name : rawData . loginUserName , mail : rawData . loginUserEmail } ; getCartId ( function ( cart ) { me . cart = cart ; injectMenu ( ) ; refreshUsers ( actions . updateUsers ) ; listenOnChanges ( onChange ) ; listenOnOrderConfirm ( onConfirm ) ; } ) ; } else { callback ( 'no user' ) ; } } 
function cons ( b , value , next ) { var free = readValue ( b , 0 ) || 8 updateValue ( b , free , value ) ; updateNext ( b , free , next ) updateValue ( b , 0 , free + 8 ) 
function insert ( b , node , value ) { return updateNext ( b , node , cons ( b , value , readNext ( b , node ) ) ) } 
function entropy ( out , sigma ) { var len = sigma . length , i ; for ( i = 0 ; i < len ; i ++ ) { out [ i ] = ENTROPY ( sigma [ i ] ) ; } return out ; } 
function init ( pathToModels , cb , addToSwagger ) { modelPath = pathToModels ; glob ( modelPath + '/**/*.js' , function ( err , files ) { if ( err ) return cb && cb ( err ) ; files . forEach ( function ( file ) { var Model = require ( file ) ( ) , modelSwagger = null ; if ( Model . init ) { Model . init ( ) ; } modelSwagger = Model . getSwagger ( ) ; if ( modelSwagger && addToSwagger ) { modelSwagger . forEach ( function ( swaggerResource ) { swagger [ swaggerMethodName [ swaggerResource . spec . method . toLowerCase ( ) ] ] ( swaggerResource ) ; } ) ; } models . push ( Model ) ; } ) ; return cb && cb ( null , models ) ; } ) ; } 
function ArgumentStatement ( args , options , define ) { options = options || { } ; this . value = args ; this . flags = { } ; this . args = [ ] ; this . options = options ; if ( typeof options . parse === 'undefined' ) options . parse = true ; if ( typeof options . separator === 'undefined' ) options . separator = ',' ; if ( typeof options . parseArgs === 'undefined' ) options . parseArgs = true ; if ( options . parse ) { if ( options . flags ) { var isFlag = true ; 
function OpenCommand ( args , define ) { var lowerArgs = args . toLowerCase ( ) ; var forIndex = lowerArgs . indexOf ( ' for ' ) ; if ( forIndex === - 1 ) throw new SyntaxError ( 'OPEN without FOR' ) ; var filename = new statements . ExpressionStatement ( args . substring ( 0 , forIndex ) . trim ( ) , define ) ; var asIndex = lowerArgs . indexOf ( ' as ' ) ; if ( asIndex === - 1 ) throw new SyntaxError ( 'OPEN without AS' ) ; var type = args . substring ( forIndex + 5 , asIndex ) . trim ( ) . toLowerCase ( ) ; if ( type !== 'input' && type !== 'output' && type !== 'append' ) throw new SyntaxError ( 'Invalid mode' ) ; var pointer = new statements . ExpressionStatement ( args . substring ( asIndex + 4 ) . trim ( ) , define ) ; if ( ! ( pointer . child instanceof statements . PointerStatement ) ) throw new SyntaxError ( 'Expected pointer' ) ; this . filename = filename ; this . type = type ; this . pointer = pointer ; } 
function ( ) { 
function wrapContext ( context ) { var retObj = { } , reservedRegexp = / ^(topic|beforeEach|afterEach)$ / , key , subcontext , beforeFn = context . beforeEach , afterFn = context . afterEach ; 
function ( engineName ) { var engine = engineName ; 
function CommonJSResolverStrategy ( config ) { BasicResolverStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function WhileCommand ( args , define ) { var parsed = new statements . ArgumentStatement ( args , { separator : false } ) ; this . condition = parsed . args [ 0 ] ; this . block = define ( { start : 'WHILE' , end : 'WEND' } ) ; } 
function before ( op , type , listener ) { if ( ! _ . isFunction ( listener ) ) { throw new Error ( 'Callback must be a function' ) ; } if ( ! registeredListeners [ op ] [ type ] ) { registeredListeners [ op ] [ type ] = [ ] ; } registeredListeners [ op ] [ type ] . push ( listener ) ; } 
function Intent ( subject , op , target , data ) { this . subject = subject ; this . op = op ; 
function verifyIntent ( subject , op , target , data , cb ) { var type = ( _ . isString ( target ) ) ? target : target . type ; var listeners = listenersFor ( op , type ) ; if ( listeners . length === 0 ) { return cb ( ) ; } if ( data && data . uuid ) { delete ( data . uuid ) ; } 
function load ( file , options ) { var stream = fs . createReadStream ( file , options ) ; function onEnd ( ) { this . emit ( 'load' ) ; } function onError ( err ) { this . emit ( 'error' , err ) ; } 
function ( cb ) { 
function ( cb ) { 
function ( ) { 
function ( ) { var mapping = { } ; _ . each ( sails . config . policies , function ( _policy , controllerId ) { 
function ( policy ) { * This line was added to support auto building of policies */ if ( _ . isObject ( policy ) && policy . build ) { policy = policy . build ( ) ; } 
function ( event ) { 
function _bindPolicies ( mapping , middlewareSet ) { _ . each ( middlewareSet , function ( _c , id ) { var topLevelPolicyId = mapping [ id ] ; var actions , actionFn ; var controller = middlewareSet [ id ] ; 
function FunctionStatement ( name , args ) { if ( name [ name . length - 1 ] === '$' ) { this . type = 'string' ; this . name = name . substring ( 0 , name . length - 1 ) ; } else { this . type = 'number' ; this . name = name ; } var positions = util . findPositions ( args , [ { 'start' : '"' , 'end' : '"' } , { 'start' : '(' , 'end' : ')' } ] ) ; var argList = util . splitOutside ( args , "," , positions ) ; this . args = [ ] ; for ( var i = 0 ; i < argList . length ; i ++ ) { this . args . push ( new statements . ExpressionStatement ( argList [ i ] . trim ( ) ) ) ; } } 
function LoadspriteCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 2 ) throw new SyntaxError ( 'LOADSPRITE command requires 2 arguments' ) ; else if ( parsed . args . length > 2 && parsed . args . length < 5 ) throw new SyntaxError ( 'LOADSPRITE command requires 5 arguments' ) ; this . id = parsed . args [ 0 ] ; if ( parsed . args . length > 2 ) { this . x1 = parsed . args [ 1 ] ; this . y1 = parsed . args [ 2 ] ; this . x2 = parsed . args [ 3 ] ; this . y2 = parsed . args [ 4 ] ; } else { this . fileName = parsed . args [ 1 ] ; } } 
function ( verb , path , controller , method ) { 
function ( url , val ) { 
function ( app , route ) { var self = this ; var controller ; var controllerPath = self . options . controllersPath + route . controller ; 
function ( app , route ) { var self = this ; 
function ( app ) { 
function ( url , params ) { 
function ( ) { 
function ( verb , path , controllerName ) { 
function ( path ) { 
function ( action ) { var url ; var error ; 
function ( H , method ) { this . H = H ; S . Elt . WithContent . call ( this ) ; this . attr ( 'method' , method ) ; S . FormValidator && S . FormValidator . getValidator ( this ) ; } 
function ( options ) { var $form = this , submit ; if ( ! S . isObj ( options ) ) options = { success : options } ; this . on ( 'submit' , function ( evt ) { evt . preventDefault ( ) ; evt . stopPropagation ( ) ; submit = this . find ( '[type="submit"]' ) ; this . fadeTo ( 0.4 , 180 ) ; this . fire ( this . _eventBeforeSubmit ) ; if ( options . beforeSubmit && options . beforeSubmit ( ) === false ) this . stop ( ) . style ( 'opacity' , 1 ) && hasPlaceholders && this . resetPlaceholders ( ) ; else { submit . hide ( ) . forEach ( function ( $e ) { $e . insertAfter ( $ . imgLoading ( ) ) ; } ) ; options . success ( this , function ( ) { submit . show ( ) . blur ( ) ; this . find ( '.imgLoading' ) . remove ( ) ; this . fadeTo ( 1 , 150 ) ; this . fire ( this . _eventAfterSubmit ) ; } . bind ( this ) ) ; } return false ; } ) ; return this ; } 
function ( value ) { if ( this . _label ) this . _label . text ( value ) ; else this . _label = $ . create ( 'label' ) . attr ( 'for' , this . getAttr ( 'id' ) ) . prependTo ( this . _container ) . text ( value ) ; return this ; } 
function ( ) { return ( this . _label === false ? '' : this . _label ) + ( this . _between || ' ' ) + S . Elt . toString ( this . tagName , this . _attributes , null ) ; } 
function parse ( code ) { try { var labels = { } ; var root = [ ] ; var manager = new BlockManager ( ) ; var lines = code . split ( '\n' ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { try { var line = parseLine ( lines [ i ] . trim ( ) , i , labels , false , manager ) ; if ( line instanceof SyntaxError ) throw createLineError ( line , i ) ; if ( line . error instanceof SyntaxError ) throw createLineError ( line . error , i ) ; root [ i ] = line ; } catch ( ex ) { throw createLineError ( ex , i ) ; } } return new AbstractSyntaxTree ( root , labels , manager ) ; } catch ( ex ) { return { "error" : ex } ; } } 
function parseLine ( line , i , labels , notLineNumber , manager ) { line = line . trim ( ) ; 
function CommandStatement ( name , args , manager , line ) { this . name = name ; this . args = args ; if ( ! commands [ name ] ) throw new SyntaxError ( 'Unknown command: ' + name ) ; this . command = new commands [ name ] ( args , manager . create ( line ) ) ; } 
function incrmin ( ) { var min = null ; return function incrmin ( x ) { if ( ! arguments . length ) { return min ; } if ( x < min || min === null ) { min = x ; } return min ; } ; } 
function BasicResolverStrategy ( config ) { ResolverStrategy . call ( this , config ) ; this . config = extend ( true , this . config , { } , config ) ; } 
function consrow ( sym ) { return _ . find ( Const . constable , function ( row ) { return ( row . indexOf ( sym ) > - 1 ) ; } ) || '' ; } 
function ( lang , entry , params ) { var plus = '' , route = params . shift ( ) ; if ( route !== true ) { route = this . routes . get ( entry || 'main' ) . get ( route ) ; if ( ! route ) { 
function ( ) { Object . defineProperty ( this , 'listen' , { value : function ( ) { } } ) ; var hasSyncEvent = this . self . store . hasSyncEvent ; this . on ( 'request.started' , function ( ) { S . log ( 'request.started' ) ; this . state = 'pending' ; this . nodes . forEach ( function ( node ) { node . first ( '.state' ) . html ( '<img src="/web/sync-14.gif"/>' ) ; } ) ; } . bind ( this ) ) ; this . on ( 'request.success' , function ( ) { S . log ( 'request.success' ) ; if ( this . state === 'pending' ) this . state = 'saved' ; 
function ( data ) { this . data = UObj . extend ( this . data , data ) ; return this . update ( null , { data : data } ) ; } 
function ( $node , val ) { return ! val . match ( / ^(\d{4}-\d{2}-\d{2})T(.+)(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$ / ) || ! checkDateFormat ( RegExp . $1 ) || ! checkTimeFormat ( RegExp . $2 ) || checkMinAndMax ( $node , Date . parse ( val ) , Date . parse ) ; 
function ( $node , val ) { var valAsNumber = $node . prop ( 'valueAsNumber' ) ; return ! ( ( valAsNumber && ( val = valAsNumber ) ) || ( / ^-?[0-9]+(\.[0-9]*)?(E(-|\+)?[0-9]+)?$ / i . test ( val ) && ( ( val = parseInt ( val , 10 ) ) !== NaN ) ) ) || checkMinAndMax ( $node , val , function ( v ) { return parseInt ( v , 10 ) ; } ) ; } 
function ( ) { var radioNames = [ ] , error ; this . $form . find ( selectorAllElements ) . forEach ( function ( $elt ) { if ( $elt . is ( 'input[type="radio"]' ) ) { var name = $elt . attr ( 'name' ) ; if ( UArray . has ( radioNames , name ) ) return ; radioNames . push ( name ) ; } if ( ! this . checkElement ( $elt , error == undefined ) ) error = true ; } . bind ( this ) ) ; return ! error ; } 
function Stream ( ref , opts ) { var data = { } , emitter = this , mapFn , started , ended , readable , marker ; if ( ! opts ) opts = { } ; if ( ! opts . page ) opts . page = 10 ; * convert internal data object to Array * @return {Array} */ function toArray ( ) { return Object . keys ( data ) . map ( function ( name ) { return data [ name ] ; } ) . sort ( function ( a , b ) { return a . compareTo ( b ) ; } ) ; } function add ( snapshot ) { return Promise . resolve ( mapFn ( snapshot ) ) . then ( function ( val ) { data [ snapshot . key ( ) ] = val ; } ) ; } function emitValue ( ) { var arr = toArray ( ) ; marker = arr [ arr . length - 1 ] ; setTimeout ( function ( ) { emitter . emit ( 'value' , arr ) ; } , 0 ) ; } function onChildRemove ( oldData ) { delete data [ oldData . key ( ) ] ; emitValue ( ) ; } function onChildAdd ( newData ) { * add child to data buffer, and emit value * * @return {Promise} */ function onChildUpdate ( newData ) { return add ( newData ) . then ( emitValue ) ; } function addChildren ( newData ) { var promises = [ ] ; newData . forEach ( function ( child ) { promises . push ( add ( child ) ) ; } ) ; return Promise . all ( promises ) . then ( emitValue ) ; } this . read = function read ( ) { var priority = marker && marker . getPriority ( ) , key = marker && marker . key ( ) , page = marker ? opts . page + 1 : opts . page ; readable = false ; debug ( 'read %s from %s children starting from %s' , page , ref . toString ( ) , key || 'top' ) ; ref . orderByPriority ( ) . startAt ( priority , key ) . limitToFirst ( page ) . exec ( ) . then ( function ( data ) { * is stream readable * * @return {Boolean} */ this . isReadable = function ( ) { return readable ; } ; this . toArray = toArray ; this . isStarted = function ( ) { return started ; } ; this . isEnded = function ( ) { return ended ; } ; this . destroy = function ( ) { emitter . removeAllListeners ( ) ; ref . off ( 'child_added' , onChildAdd ) ; ref . off ( 'child_moved' , onChildUpdate ) ; ref . off ( 'child_changed' , onChildUpdate ) ; ref . off ( 'child_removed' , onChildRemove ) ; } ; this . map = function ( fn ) { mapFn = fn ; return this ; } ; 
function toArray ( ) { return Object . keys ( data ) . map ( function ( name ) { return data [ name ] ; } ) . sort ( function ( a , b ) { return a . compareTo ( b ) ; } ) ; } 
function add ( snapshot ) { return Promise . resolve ( mapFn ( snapshot ) ) . then ( function ( val ) { data [ snapshot . key ( ) ] = val ; } ) ; } 
function emitValue ( ) { var arr = toArray ( ) ; marker = arr [ arr . length - 1 ] ; setTimeout ( function ( ) { emitter . emit ( 'value' , arr ) ; } , 0 ) ; } 
function onChildAdd ( newData ) { 
function addChildren ( newData ) { var promises = [ ] ; newData . forEach ( function ( child ) { promises . push ( add ( child ) ) ; } ) ; return Promise . all ( promises ) . then ( emitValue ) ; } 
function ShoppingCart ( objGoogleCheckout ) { var self = this ; 
function modalOpen ( options ) { if ( isString ( options ) ) options = optionsFromTarget ( options ) ; var modal = select ( '#d3-view-modal' ) ; if ( ! modal . size ( ) ) select ( 'body' ) . append ( 'modal' ) . mount ( options , vm => vm . model . $showModal ( ) ) ; else modal . model ( ) . $update ( options ) . $showModal ( ) ; } 
function ( err , result ) { if ( err ) { cb0 ( err ) ; } else { var retErr = null ; if ( json_rpc . isSystemError ( result ) || ( json_rpc . getAppReplyError ( result ) ) ) { retErr = result ; } async . series ( [ function ( cb2 ) { if ( retErr ) { that . __ca_shutdown__ ( null , cb2 ) ; } else { cb2 ( null ) ; } } ] , function ( errIgnore ) { 
function ColorCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'COLOR command requires 3 arguments' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; this . alpha = parsed . args . length > 3 ? parsed . args [ 3 ] : false ; } 
function onChange ( ) { if ( props . onChange ) { var changeHandlers = [ ... props . onChange ] var value = editor . getValue ( ) return changeHandlers . map ( ( f ) => f ( value ) ) } } 
function PrintCommand ( args , define ) { if ( args [ args . length - 1 ] === ";" ) { this . noLine = true ; args = args . substr ( - 1 ) ; } else this . noLine = false ; var parsed = new statements . ArgumentStatement ( args , { flags : [ 'USING' ] , parseArgs : false } ) ; if ( parsed . flags . USING ) { if ( parsed . args . length !== 1 ) throw new SyntaxError ( 'PRINT USING command requires 1 argument' ) ; if ( parsed . args . length > 1 ) throw new SyntaxError ( 'Unexpected comma' ) ; var semicolonIndex = parsed . args [ 0 ] . indexOf ( ';' ) ; if ( semicolonIndex === - 1 ) throw new SyntaxError ( 'Expected semicolon' ) ; var formatExpression = new statements . ExpressionStatement ( parsed . args [ 0 ] . substring ( 0 , semicolonIndex ) . trim ( ) , define ) ; var numberExpression = new statements . ExpressionStatement ( parsed . args [ 0 ] . substring ( semicolonIndex + 1 ) . trim ( ) , define ) ; if ( formatExpression . error instanceof SyntaxError ) throw formatExpression . error ; if ( numberExpression . error instanceof SyntaxError ) throw numberExpression . error ; this . formatExpr = formatExpression ; this . numberExpr = numberExpression ; } else { var items = [ ] ; for ( var i = 0 ; i < parsed . args . length ; i ++ ) { var expr = new statements . ExpressionStatement ( parsed . args [ i ] , define ) ; if ( expr . error instanceof SyntaxError ) throw expr . error ; items . push ( expr ) ; } this . items = items ; } } 
function Injectables ( deps ) { var self = this ; this . registry = { injector : this } ; Object . keys ( deps || { } ) . forEach ( function ( k ) { if ( k == 'injectables' ) return ; self . registry [ k ] = deps [ k ] ; } ) ; self . basePath = process . cwd ( ) ; } 
function intoExport ( obj ) { for ( var k in obj ) { if ( ! obj . hasOwnProperty ( k ) ) continue ; exports [ k ] = obj [ k ] ; } } 
function ( ) { App . info ( "Listening on port " + port ) ; var notify = require ( 'notify-send' ) ; 
function charAt ( index ) { return value => value . length <= index ? undefined : value . charAt ( index ) ; } 
function replace ( target , replaceWith ) { function escapeRegExp ( str ) { return str . replace ( / [.*+?^${}()|[\]\\] / g , "\\$&" ) ; // $& means the whole matched string } return target instanceof RegExp ? value => value . replace ( target , replaceWith ) : replace ( new RegExp ( escapeRegExp ( target ) , "g" ) , replaceWith ) ; } 
function ExpressionStatement ( data , define ) { this . child = parseExpression ( data , define ? define . line : 'unknown' ) ; if ( this . child instanceof SyntaxError ) throw this . child ; else if ( this . child . error ) throw this . child . error ; } 
function parseExpression ( data , line ) { data = data . trim ( ) ; var lowerData = data . toLowerCase ( ) ; var positions = util . findPositions ( lowerData , [ { 'start' : '"' , 'end' : '"' } , { 'start' : '(' , 'end' : ')' } ] ) ; 
function parseSingularExpression ( data ) { 
function APIs ( config , httpClient ) { let self = this instanceof APIs ? this : Object . create ( APIs . prototype ) ; if ( util . isNullOrUndefined ( config ) ) { return self ; } let defaultHost = { } ; if ( config [ APIs . DEFAULT_HOST ] && / ^http / . test ( config [ APIs . DEFAULT_HOST ] ) ) { defaultHost = URL . parse ( config [ APIs . DEFAULT_HOST ] ) ; } else { defaultHost . host = config [ APIs . DEFAULT_HOST ] ; } for ( let index in config ) { if ( index != APIs . DEFAULT_HOST ) { let api = config [ index ] ; if ( ! api . host && ! api . hostname ) { api . host = defaultHost . host ; if ( defaultHost . protocol ) { api . protocol = defaultHost . protocol ; } } self [ index ] = new Api ( Api . format ( api ) , httpClient ) ; Object . defineProperty ( self , index , { configurable : false , writable : false } ) ; } } return self ; } 
function createEvent ( data = null ) { let isDefaultPrevented = false ; 
function Population ( opts ) { 
function cleanLines ( block , lines ) { var removeFirst = false if ( lines . length && emptyRegex . test ( lines [ 0 ] . str ) ) { block . line += 1 block . size -= 1 removeFirst = true } return lines . filter ( function ( each , i ) { return ! ( ! i && removeFirst ) && ! commentRegex . test ( each . str ) } ) } 
function drawAllDataPoints ( animationDecimal ) { var rotationDegree = ( 2 * Math . PI ) / data . datasets [ 0 ] . data . length ; ctx . save ( ) ; 
function populateLabels ( labelTemplateString , labels , numberOfSteps , graphMin , stepValue ) { if ( labelTemplateString ) { 
function ( path ) { var xhr = new XMLHttpRequest ; xhr . open ( 'GET' , baseUrl + 'web/' + path + '.js' , false ) ; xhr . send ( ) ; if ( xhr . status !== 200 ) new FatalError ( 'Unable to load: ' + path + '.js' ) ; var s = document . createElement ( 'script' ) ; s . type = "text/javascript" ; s . text = xhr . responseText ; document . getElementsByTagName ( 'head' ) [ 0 ] . appendChild ( s ) ; } 
function ( m ) { console . error ( 'S.error' , m ) ; if ( m === S . error . lastError ) return ; S . error . lastError = m ; alert ( m ) ; } 
function ( string , args ) { string = i18n . appTranslations [ string ] || string ; return args ? UString . vformat ( string , args ) : string ; } 
function TcolorCommand ( args ) { var parsed = new statements . ArgumentStatement ( args ) ; if ( parsed . args . length < 3 ) throw new SyntaxError ( 'TCOLOR command requires 3 arguments' ) ; this . red = parsed . args [ 0 ] ; this . green = parsed . args [ 1 ] ; this . blue = parsed . args [ 2 ] ; } 
function ( tag , props ) { var konstructor = Element . Constructors [ tag ] ; if ( konstructor ) return konstructor ( props ) ; if ( typeof tag != 'string' ) return document . id ( tag ) . set ( props ) ; if ( ! props ) props = { } ; if ( ! ( / ^[\w-]+$ / ) . test ( tag ) ) { var parsed = Slick . parse ( tag ) . expressions [ 0 ] [ 0 ] ; tag = ( parsed . tag == '*' ) ? 'div' : parsed . tag ; if ( parsed . id && props . id == null ) props . id = parsed . id ; var attributes = parsed . attributes ; if ( attributes ) for ( var i = 0 , l = attributes . length ; i < l ; i ++ ) { var attr = attributes [ i ] ; if ( props [ attr . key ] != null ) continue ; if ( attr . value != null && attr . operator == '=' ) props [ attr . key ] = attr . value ; else if ( ! attr . value && ! attr . operator ) props [ attr . key ] = true ; } if ( parsed . classList && props [ 'class' ] == null ) props [ 'class' ] = parsed . classList . join ( ' ' ) ; } return document . newElement ( tag , props ) ; } 
function publish ( subject , op , target ) { try { var type = ( _ . isString ( target ) ) ? target : target . type ; var topic = getTopic ( type ) ; 
function ExecutionContext ( options ) { EventEmitter . call ( this ) ; this . stringVars = { } ; this . numberVars = { } ; this . pointers = { } ; this . gosubs = [ ] ; this . private = { rnd_seed : Math . random ( ) , sprites : [ ] , data : [ ] } ; this . constants = require ( './constants' ) ; this . running = false ; options = options || { } ; this . options = options ; if ( typeof options . delay === 'undefined' ) options . delay = false ; 
function setArrayIndexAt ( arr , dimensions , val , data ) { var currentDimension = dimensions [ 0 ] . execute ( data ) ; data . validate ( currentDimension , 'number' ) ; currentDimension -= 1 ; if ( currentDimension < 0 ) currentDimension = 0 ; if ( arr . length <= currentDimension ) throw new Error ( 'Invalid array bounds' ) ; var item = arr [ currentDimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . isArray ( item ) ) throw new Error ( 'Invalid array dimensions' ) ; return setArrayIndexAt ( arr [ currentDimension ] , dimensions . slice ( 1 ) , val , data ) ; } else arr [ currentDimension ] = val ; } 
function getArrayIndexAt ( arr , dimensions , data ) { var currentDimension = dimensions [ 0 ] ; data . validate ( currentDimension , 'number' ) ; currentDimension = Math . max ( 0 , Math . floor ( currentDimension - 1 ) ) ; if ( arr . length <= currentDimension ) throw new Error ( 'Invalid array bounds' ) ; var item = arr [ currentDimension ] ; if ( dimensions . length > 1 ) { if ( ! Array . isArray ( item ) ) throw new Error ( 'Invalid array dimensions' ) ; return getArrayIndexAt ( arr [ currentDimension ] , dimensions . slice ( 1 ) , data ) ; } else return item ; } 
function createArrayDepth ( dimensions , endpoint ) { var currentDimension = dimensions [ 0 ] ; var newArr = new Array ( currentDimension ) ; for ( var i = 0 ; i < currentDimension ; i ++ ) { var value = endpoint ; if ( dimensions . length > 1 ) value = createArrayDepth ( dimensions . slice ( 1 ) , endpoint ) ; newArr [ i ] = value ; } return newArr ; } 
function find ( b , ptr , target , level , compare , gt ) { level = level || r_levels ( b , ptr ) compare = compare || _compare gt = gt !== false var prev_ptr = 0 while ( true ) { if ( level < 0 ) break ; 
function insert ( b , ptr , target , level , compare ) { level = level || r_levels ( b , ptr ) compare = compare || _compare var free = b . readUInt32LE ( 0 ) || 8 
function ( section ) { section . children . forEach ( function ( child ) { if ( child . type === 'section' ) { finalParse ( child ) } else if ( child . type === 'text' || child . type === 'value' || child . type === 'code' ) { var sliceStart = child . line - 1 , sliceEnd = child . line + child . size - 1 , subLines = lines . slice ( sliceStart , sliceEnd ) if ( child . type === 'text' ) { child . content = subLines . join ( '\n' ) } else if ( child . type === 'code' ) { child . language = subLines [ 0 ] . substr ( 3 ) child . content = subLines . slice ( 1 , - 1 ) . join ( '\n' ) } else if ( child . type === 'value' ) { child . content = subLines . join ( '\n' ) 
function takeHeader ( content , level , name ) { var currLevel = sectionStack . length if ( level > currLevel + 1 ) { throwSyntaxError ( 'Unexpected header level ' + level + ' on section level ' + currLevel ) } else if ( level === 1 ) { throwSyntaxError ( 'There can be only one header level 1, the first line of the file' ) } 
function throwSyntaxError ( message , errorLine , size ) { errorLine = errorLine === undefined ? line : errorLine size = size === undefined ? 1 : size var snippet = getSnippet ( source , errorLine , size ) , err = new SyntaxError ( message + '\n' + snippet ) err . line = errorLine throw err } 
function appendLine ( type ) { var len = section . children . length if ( newBlock || ! len || section . children [ len - 1 ] . type !== type ) { section . children . push ( { type : type , line : line , size : 1 } ) } else { section . children [ len - 1 ] . size += 1 } newBlock = false } 
function on ( event , cb , context ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; return dom . on . apply ( false , [ this ] . concat ( args ) ) ; } 
function detach ( node ) { if ( node . placeholder instanceof HTMLElement === false ) { node . placeholder = createPlaceholder ( node . data . tag || node . el . tagName ) ; } if ( node && node . el && node . el . parentNode ) { node . el . parentNode . replaceChild ( node . placeholder , node . el ) ; } } 
function attach ( node ) { if ( node && node . el && node . placeholder && node . placeholder . parentNode ) { node . placeholder . parentNode . replaceChild ( node . el , node . placeholder ) ; } } 
function append ( parent , child ) { if ( parent . el !== undefined && child . el !== undefined ) { parent . el . appendChild ( child . el ) ; } } 
function insertBefore ( parent , child , index ) { var parentEl = parent . el , childEl = child . el ; if ( parentEl !== undefined && childEl !== undefined ) { if ( parentEl . childNodes [ index ] !== undefined ) { parentEl . insertBefore ( childEl , parentEl . childNodes [ index ] ) ; } else { parentEl . appendChild ( childEl ) ; } } } 
function changePosition ( el , index ) { var HTMLElement = el . el ; if ( HTMLElement && HTMLElement . parentNode ) { var parentNode = HTMLElement . parentNode , elGroup = el . elGroup , size = elGroup . size , target = elGroup . getKeyByIndex ( index ) || elGroup . getLast ( ) ; if ( target !== HTMLElement ) { if ( size - 1 >= index ) { parentNode . insertBefore ( HTMLElement , target ) ; } else if ( target . nextSibling !== null ) { parentNode . insertBefore ( HTMLElement , target . nextSibling ) ; } else { parentNode . appendChild ( HTMLElement ) ; } el . elGroup . changeIndex ( HTMLElement , index ) ; } } } 
function text ( node , _text2 ) { if ( node && node . el ) { node . el . innerHTML = _text2 ; } } 
function setAttribute ( node , prop , value ) { if ( node && node . el ) { if ( isObject ( prop ) ) { Object . keys ( prop ) . forEach ( function ( key ) { node . el . setAttribute ( key , prop [ key ] ) ; } ) ; } else { node . el . setAttribute ( prop , value ) ; } } } 
function getAttribute ( node , prop ) { if ( node && node . el ) { return node . el . getAttribute ( prop ) ; } else { return undefined ; } } 
function removeAttribute ( node , prop ) { if ( node && node . el ) { node . el . removeAttribute ( prop ) ; } } 
function setStyle ( node , prop , value ) { if ( node && node . el ) { if ( isObject ( prop ) ) { Object . keys ( prop ) . forEach ( function ( key ) { node . el . style [ key ] = prop [ key ] ; } ) ; } else { node . el . style [ prop ] = value ; } } } 
function getStyle ( node , prop ) { if ( node && node . el ) { if ( node . el !== undefined && node . el . style !== undefined ) { return node . el . style [ prop ] ; } else { return undefined ; } } } 
function removeStyle ( node , prop ) { if ( node && node . el ) { node . el . style [ prop ] = '' ; } } 
function addClass ( node , className ) { if ( node && node . el ) { node . el . classList . add ( className ) ; } } 
function hasClass ( node , className ) { if ( node && node . el ) { return node . el . classList . contains ( className ) ; } else { return false ; } } 
function removeClass ( node , className ) { if ( node && node . el ) { node . el . classList . remove ( className ) ; } } 
function val ( node , _val2 ) { if ( node && node . el ) { var el = node . el ; if ( _val2 !== undefined ) { el . value = _val2 ; } else { return el . value ; } } } 
function on ( element , ev , cb , context ) { for ( var _len = arguments . length , args = Array ( _len > 4 ? _len - 4 : 0 ) , _key = 4 ; _key < _len ; _key ++ ) { args [ _key - 4 ] = arguments [ _key ] ; } var _this = this ; var el = element . el , events = ev . split ( ' ' ) , fn = function fn ( e ) { cb . apply ( context || _this , [ e , element ] . concat ( args ) ) ; } ; events . forEach ( function ( event ) { el . addEventListener ( event , fn ) ; } ) ; var evt = { remove : function remove ( ) { events . forEach ( function ( event ) { return el . removeEventListener ( event , fn ) ; } ) ; var evts = element . _events ; evts . splice ( evts . indexOf ( evt ) , 1 ) ; } } ; element . _events . push ( evt ) ; return evt ; } 
function remove ( el ) { while ( el . _events . length > 0 ) { el . _events . shift ( ) . remove ( ) ; } if ( el . children ) { destroy ( el . children ) ; } if ( el . elGroup !== undefined ) { el . elGroup . delete ( el . el ) ; } if ( el . el !== undefined ) { if ( el . el . remove ) { el . el . remove ( ) ; } else if ( el . el . parentNode ) { el . el . parentNode . removeChild ( el . el ) ; } delete el . el ; } } 
function onDOMAttached ( el ) { var _this2 = this ; var handlers = [ ] , attached = false , _step = undefined ; if ( el . el !== undefined ) { _step = function step ( ) { if ( attached ) { while ( handlers . length > 0 ) { handlers . shift ( ) ( ) ; } } else { window . requestAnimationFrame ( _step ) ; if ( document . body . contains ( el . el ) ) { attached = true ; } } } ; } return { then : function then ( cb , context ) { handlers . push ( cb . bind ( context || _this2 ) ) ; window . requestAnimationFrame ( _step ) ; } } ; } 
function match ( { just , nothing } ) { return function ( maybe ) { for ( const value of maybe ) { return just ( value ) ; } return nothing ( ) ; } ; } 
function flatMap ( mapper ) { return function ( maybe ) { for ( const value of maybe ) { return mapper ( value ) ; } return maybe_1 . nothing ( ) ; } ; } 
function filter ( predicate ) { return flatMap ( value => predicate ( value ) ? maybe_1 . just ( value ) : maybe_1 . nothing ( ) ) ; } 
function or ( defaultValue ) { return function ( maybe ) { for ( const value of maybe ) { return maybe_1 . just ( value ) ; } return defaultValue ; } ; } 
function ( e ) { var history = S . History , current = history . getFragment ( ) ; if ( OLD_IE && current == history . fragment && history . iframe ) current = history . getFragment ( history . getHash ( history . iframe ) ) ; if ( current == history . fragment ) return false ; if ( history . iframe ) history . navigate ( current ) ; history . loadUrl ( ) ; } 
function ( fragmentOverride , state ) { var fragment = baseUrl + ( this . fragment = this . getFragment ( fragmentOverride ) ) ; if ( fragment ) { var a = $ ( 'a[href="' + fragment + '"]' ) ; a . length === 0 ? S . redirect ( fragment ) : a . click ( ) ; } } 

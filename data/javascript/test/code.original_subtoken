function create Instance ( default Config ) { var context = new Axios ( default Config ) ; var instance = bind ( Axios . prototype . request , context ) ; 
function Cancel Token ( executor ) { if ( typeof executor ! = = 'function ' ) { throw new Type Error ( 'executor must be a function . ' ) ; } var resolve Promise ; this . promise = new Promise ( function promise Executor ( resolve ) { resolve Promise = resolve ; } ) ; var token = this ; executor ( function cancel ( message ) { if ( token . reason ) { 
function is Array Buffer View ( val ) { var result ; if ( ( typeof Array Buffer ! = = 'undefined ' ) & & ( Array Buffer . is View ) ) { result = Array Buffer . is View ( val ) ; } else { result = ( val ) & & ( val . buffer ) & & ( val . buffer instanceof Array Buffer ) ; } return result ; } 
function is Standard Browser Env ( ) { if ( typeof navigator ! = = 'undefined ' & & ( navigator . product = = = 'React Native ' | | navigator . product = = = 'Native Script ' | | navigator . product = = = 'NS ' ) ) { return false ; } return ( typeof window ! = = 'undefined ' & & typeof document ! = = 'undefined ' ) ; } 
function for Each ( obj , fn ) { 
function extend ( a , b , this Arg ) { for Each ( b , function assign Value ( val , key ) { if ( this Arg & & typeof val = = = 'function ' ) { a [ key ] = bind ( val , this Arg ) ; } else { a [ key ] = val ; } } ) ; return a ; } 
function fetch Query ( operation , variables , cache Config , uploadables ) { 
function retry Strategy ( times ) { if ( times = = = 1 ) { const error = 'Unable to connect to Redis - please check your Redis config ! ' if ( process . env . NODE _ENV = = = 'test ' ) { console . error ( error ) } else { api . log ( error , 'error ' ) } return 5 0 0 0 } return Math . min ( times * 5 0 , max Backoff ) } 
function write Package Manifest ( package Name ) { const package Path = require . resolve ( package Name + ' /package .json ' ) let { name , main , author , license , types , typings } = require ( package Path ) if ( ! main ) { main = 'index .js ' } let types File = types | | typings if ( types File ) { types File = require . resolve ( join ( package Name , types File ) ) } const compiled Package Path = join ( _ _dirname , ` $ { package Name } ` ) const potential License Path = join ( dirname ( package Path ) , ' . /LICENSE ' ) if ( exists Sync ( potential License Path ) ) { this . _ . files . push ( { dir : compiled Package Path , base : 'LICENSE ' , data : read File Sync ( potential License Path , 'utf 8 ' ) } ) } this . _ . files . push ( { dir : compiled Package Path , base : 'package .json ' , data : JSON . stringify ( Object . assign ( { } , { name , main : ` $ { basename ( main , ' . ' + extname ( main ) ) } ` } , author ? { author } : undefined , license ? { license } : undefined , types File ? { types : relative ( compiled Package Path , types File ) } : undefined ) ) + ' \n ' } ) } 
function supports Preload ( list ) { if ( ! list | | ! list . supports ) { return false } try { return list . supports ( 'preload ' ) } catch ( e ) { return false } } 
function add Entry ( compilation , context , name , entry ) { return new Promise ( ( resolve , reject ) = > { const dep = Dynamic Entry Plugin . create Dependency ( entry , name ) compilation . add Entry ( context , dep , name , ( err ) = > { if ( err ) return reject ( err ) resolve ( ) } ) } ) } 
function handle Warnings ( warnings ) { clear Outdated Errors ( ) 
function handle Errors ( errors ) { clear Outdated Errors ( ) is First Compilation = false has Compile Errors = true 
function process Message ( e ) { const obj = JSON . parse ( e . data ) switch ( obj . action ) { case 'building ' : { console . log ( ' [HMR ] bundle ' + ( obj . name ? " ' " + obj . name + " ' " : ' ' ) + 'rebuilding ' ) break } case 'built ' : case 'sync ' : { clear Outdated Errors ( ) if ( obj . hash ) { handle Available Hash ( obj . hash ) } if ( obj . warnings . length > 0 ) { handle Warnings ( obj . warnings ) } if ( obj . errors . length > 0 ) { 
async function try Apply Updates ( on Hot Update Success ) { if ( ! module . hot ) { 
async function try Apply Updates ( ) { if ( ! is Update Available ( ) | | ! can Apply Updates ( ) ) { return } try { const res = await fetch ( ` $ { hot Update Path } $ { cur Hash } ` ) const data = await res . json ( ) const cur Page = page = = = ' / ' ? 'index ' : page const page Updated = Object . keys ( data . c ) . some ( mod = > { return ( mod . index Of ( ` $ { cur Page . substr ( 0 , 1 ) = = = ' / ' ? cur Page : ` $ { cur Page } ` } ` ) ! = = - 1 | | mod . index Of ( ` $ { cur Page . substr ( 0 , 1 ) = = = ' / ' ? cur Page : ` $ { cur Page } ` } ` . replace ( / \ / / g , ' \ \ ' ) ) ! = = - 1 ) } ) if ( page Updated ) { document . location . reload ( true ) } else { cur Hash = most Recent Hash } } catch ( err ) { console . error ( 'Error occurred checking for update ' , err ) document . location . reload ( true ) } } 
function format Message ( message , is Error ) { let lines = message . split ( ' \n ' ) 
function slide Next ( speed = this . params . speed , run Callbacks = true , internal ) { const swiper = this ; const { params , animating } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loop Fix ( ) ; 
function slide Prev ( speed = this . params . speed , run Callbacks = true , internal ) { const swiper = this ; const { params , animating , snap Grid , slides Grid , rtl Translate , } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loop Fix ( ) ; 
function encode Name ( name ) { var little Endian = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; if ( typeof name ! = = "string " ) throw new Type Error ( "name parameter is a required string " ) ; if ( name . length > 1 3 ) throw new Type Error ( "A name can be up to 1 3 characters long " ) ; var bitstr = " " ; for ( var i = 0 ; i < = 1 2 ; i + + ) { 
function UDecimal String ( value ) { assert ( value ! = null , "value is required " ) ; value = value = = = "object " & & value . to String ? value . to String ( ) : String ( value ) ; if ( value [ 0 ] = = = " . " ) { value = ' 0 ' + value ; } var part = value . split ( " . " ) ; assert ( part . length < = 2 , 'invalid decimal ' + value ) ; assert ( / ^ \d + ( , ? \d ) * \d * $ / . test ( part [ 0 ] ) , 'invalid decimal ' + value ) ; if ( part . length = = = 2 ) { assert ( / ^ \d * $ / . test ( part [ 1 ] ) , 'invalid decimal ' + value ) ; part [ 1 ] = part [ 1 ] . replace ( / 0 + $ / , " " ) ; 
function UDecimal Pad ( num , precision ) { var value = UDecimal String ( num ) ; assert . equal ( "number " , typeof precision = = = 'undefined ' ? 'undefined ' : ( 0 , _typeof 3 . default ) ( precision ) , "precision " ) ; var part = value . split ( " . " ) ; if ( precision = = = 0 & & part . length = = = 1 ) { return part [ 0 ] ; } if ( part . length = = = 1 ) { return part [ 0 ] + ' . ' + " 0 " . repeat ( precision ) ; } else { var pad = precision - part [ 1 ] . length ; assert ( pad > = 0 , 'decimal \ ' ' + value + ' \ ' exceeds precision ' + precision ) ; return part [ 0 ] + ' . ' + part [ 1 ] + " 0 " . repeat ( pad ) ; } } 
function UDecimal Unimply ( value , precision ) { assert ( value ! = null , "value is required " ) ; value = value = = = "object " & & value . to String ? value . to String ( ) : String ( value ) ; assert ( / ^ \d + $ / . test ( value ) , 'invalid whole number ' + value ) ; 
function parse Asset Symbol ( asset Symbol ) { var precision = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : null ; assert . equal ( typeof asset Symbol = = = 'undefined ' ? 'undefined ' : ( 0 , _typeof 3 . default ) ( asset Symbol ) , "string " , "Asset symbol should be string " ) ; if ( asset Symbol . index Of ( " , " ) = = = - 1 ) { asset Symbol = ' , ' + asset Symbol ; 
function encode Address ( str ) { if ( typeof str ! = = "string " | | str . length ! = = 5 3 | | ! str . starts With ( "EVT " ) ) throw new Error ( "EVTAddress should be a string with length 5 3 starts with EVT . " ) ; str = str . substr ( 3 ) ; if ( str = = = " 0 " . repeat ( 5 0 ) ) return Buffer . from ( [ 0 , 0 ] ) ; 
function decode Address ( bytes ) { if ( bytes . length = = = 2 & & bytes . equals ( Buffer . from ( [ 0 , 0 ] ) ) ) return "EVT " + " 0 " . repeat ( 5 0 ) ; 
function create Segment ( type Key , value ) { 
function parse Segment ( buffer , offset ) { let type Key = buffer [ offset ] ; if ( type Key < = 2 0 ) { if ( buffer [ offset + 1 ] = = undefined ) throw new Error ( "Parse Error : No value for uint 8 " ) ; return { type Key : type Key , value : buffer [ offset + 1 ] , buffer Length : 2 } ; } if ( type Key < = 4 0 ) { if ( buffer [ offset + 2 ] = = undefined ) throw new Error ( "Parse Error : Incomplete value for uint 1 6 " ) ; return { type Key : type Key , value : buffer . read UInt 1 6BE ( offset + 1 ) , buffer Length : 3 } ; } else if ( type Key < = 9 0 ) { if ( buffer [ offset + 4 ] = = undefined ) throw new Error ( "Parse Error : Incomplete value for uint 3 2 " ) ; return { type Key : type Key , value : buffer . read UInt 3 2BE ( offset + 1 ) , buffer Length : 5 } ; } else if ( type Key < = 1 5 5 ) { if ( buffer [ offset + 1 ] = = undefined ) throw new Error ( "Parse Error : Incomplete length value for string " ) ; let len = buffer . read UInt 8 ( offset + 1 ) ; if ( buffer [ offset + 1 + len ] = = undefined ) throw new Error ( "Parse Error : Incomplete value for string " ) ; let value = buffer . to String ( "utf 8 " , offset + 2 , offset + 2 + len ) ; return { type Key : type Key , value : value , buffer Length : 2 + len } ; } else if ( type Key < = 1 6 5 ) { if ( buffer [ offset + 1 6 ] = = undefined ) throw new Error ( "Parse Error : Incomplete value for uuid " ) ; let len = 1 6 ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 1 , offset + 1 + len ) ; return { type Key : type Key , value : value , buffer Length : 1 + len } ; } else if ( type Key < = 1 8 0 ) { if ( buffer [ offset + 1 ] = = undefined ) throw new Error ( "Parse Error : Incomplete length value for byte string " ) ; let len = buffer . read UInt 8 ( offset + 1 ) ; if ( buffer [ offset + len + 1 ] = = undefined ) throw new Error ( "Parse Error : Incomplete value for byte string " ) ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 2 , offset + 2 + len ) ; return { type Key : type Key , value : value , buffer Length : 2 + len } ; } else { throw new Error ( "type Key not supported " ) ; } } 
function parse Segments ( buffer ) { if ( buffer . length = = 0 ) throw new Error ( "bad segments stream " ) ; let pointer = 0 ; let segments = [ ] ; while ( pointer < buffer . length ) { let seg = parse Segment ( buffer , pointer ) ; segments . push ( seg ) ; pointer + = seg . buffer Length ; delete seg . buffer Length ; } if ( pointer ! = buffer . length ) { throw new Error ( "Bad / incomplete segments " ) ; } return segments ; } 
function parse QRCode ( text , options ) { if ( text . length < 3 | | text . length > 2 0 0 0 ) throw new Error ( "Invalid length of Evt Link " ) ; let text Splited = text . split ( " _ " ) ; if ( text Splited . length > 2 ) return null ; let raw Text ; if ( text Splited [ 0 ] . starts With ( qr Prefix ) ) { raw Text = text Splited [ 0 ] . substr ( qr Prefix . length ) ; } else { raw Text = text Splited [ 0 ] ; } 
async function _ _calc Key Provider ( key Provider ) { if ( ! key Provider ) { return [ ] ; } 
function random 3 2Byte Buffer ( { cpu Entropy Bits = 0 , safe = true } = { } ) { assert . equal ( typeof cpu Entropy Bits , "number " , "cpu Entropy Bits " ) ; assert . equal ( typeof safe , "boolean " , "boolean " ) ; if ( safe ) { assert ( entropy Count > = 1 2 8 , "Call initialize ( ) to add entropy (current : " + entropy Count + " ) " ) ; } 
function add Entropy ( . . . ints ) { assert . equal ( external Entropy Array . length , 1 0 1 , "external Entropy Array " ) ; entropy Count + = ints . length ; for ( const i of ints ) { const pos = entropy Pos + + % 1 0 1 ; const i 2 = external Entropy Array [ pos ] + = i ; if ( i 2 > 9 0 0 7 1 9 9 2 5 4 7 4 0 9 9 1 ) external Entropy Array [ pos ] = 0 ; } } 
function cpu Entropy ( cpu Entropy Bits = 1 2 8 ) { let collected = [ ] ; let last Count = null ; let low Entropy Samples = 0 ; while ( collected . length < cpu Entropy Bits ) { const count = floating Point Count ( ) ; if ( last Count ! = null ) { const delta = count - last Count ; if ( Math . abs ( delta ) < 1 ) { low Entropy Samples + + ; continue ; } 
function browser Entropy ( ) { let entropy Str = Array ( random Bytes ( 1 0 1 ) ) . join ( ) ; try { entropy Str + = ( new Date ( ) ) . to String ( ) + " " + window . screen . height + " " + window . screen . width + " " + window . screen . color Depth + " " + " " + window . screen . avail Height + " " + window . screen . avail Width + " " + window . screen . pixel Depth + navigator . language + " " + window . location + " " + window . history . length ; for ( let i = 0 , mime Type ; i < navigator . mime Types . length ; i + + ) { mime Type = navigator . mime Types [ i ] ; entropy Str + = mime Type . description + " " + mime Type . type + " " + mime Type . suffixes + " " ; } } catch ( error ) { 
function encrypt ( private _key , public _key , message , nonce = unique Nonce ( ) ) { return crypt ( private _key , public _key , nonce , message ) ; } 
function decrypt ( private _key , public _key , nonce , message , checksum ) { return crypt ( private _key , public _key , nonce , message , checksum ) . message ; } 
function crypto Js Decrypt ( message , key , iv ) { assert ( message , "Missing cipher text " ) ; message = to Binary Buffer ( message ) ; const decipher = crypto . create Decipheriv ( "aes - 2 5 6 -cbc " , key , iv ) ; 
function crypto Js Encrypt ( message , key , iv ) { assert ( message , "Missing plain text " ) ; message = to Binary Buffer ( message ) ; const cipher = crypto . create Cipheriv ( "aes - 2 5 6 -cbc " , key , iv ) ; 
function get Shared Secret ( public _key ) { public _key = Public Key ( public _key ) ; let KB = public _key . to Uncompressed ( ) . to Buffer ( ) ; let KBP = Point . from Affine ( secp 2 5 6k 1 , Big Integer . from Buffer ( KB . slice ( 1 , 3 3 ) ) , 
function get Child Key ( name ) { 
function initialize ( ) { if ( initialized ) { return ; } unit Test ( ) ; key Utils . add Entropy ( . . . key Utils . cpu Entropy ( ) ) ; assert ( key Utils . entropy Count ( ) > = 1 2 8 , "insufficient entropy " ) ; initialized = true ; } 
function am 1 ( i , x , w , j , c , n ) { while ( - - n > = 0 ) { var v = x * this [ i + + ] + w [ j ] + c c = Math . floor ( v / 0x 4 0 0 0 0 0 0 ) w [ j + + ] = v & 0x 3ffffff } return c } 
function am 2 ( i , x , w , j , c , n ) { var xl = x & 0x 7fff , xh = x > > 1 5 while ( - - n > = 0 ) { var l = this [ i ] & 0x 7fff var h = this [ i + + ] > > 1 5 var m = xh * l + h * xl l = xl * l + ( ( m & 0x 7fff ) < < 1 5 ) + w [ j ] + ( c & 0x 3fffffff ) c = ( l > > > 3 0 ) + ( m > > > 1 5 ) + xh * h + ( c > > > 3 0 ) w [ j + + ] = l & 0x 3fffffff } return c } 
function bnp Copy To ( r ) { for ( var i = this . t - 1 ; i > = 0 ; - - i ) r [ i ] = this [ i ] r . t = this . t r . s = this . s } 
function bnp Inv Digit ( ) { if ( this . t < 1 ) return 0 var x = this [ 0 ] if ( ( x & 1 ) = = 0 ) return 0 var y = x & 3 ; 
function Montgomery ( m ) { this . m = m this . mp = m . inv Digit ( ) this . mpl = this . mp & 0x 7fff this . mph = this . mp > > 1 5 this . um = ( 1 < < ( m . DB - 1 5 ) ) - 1 this . mt 2 = 2 * m . t } 
function mont Convert ( x ) { var r = new Big Integer ( ) x . abs ( ) . dl Shift To ( this . m . t , r ) r . div Rem To ( this . m , null , r ) if ( x . s < 0 & & r . compare To ( Big Integer . ZERO ) > 0 ) this . m . sub To ( r , r ) return r } 
function mont Revert ( x ) { var r = new Big Integer ( ) x . copy To ( r ) this . reduce ( r ) return r } 
function bn Not ( ) { var r = new Big Integer ( ) for ( var i = 0 ; i < this . t ; + + i ) r [ i ] = this . DM & ~ this [ i ] r . t = this . t r . s = ~ this . s return r } 
function bn Shift Left ( n ) { var r = new Big Integer ( ) if ( n < 0 ) this . r Shift To ( - n , r ) else this . l Shift To ( n , r ) return r } 
function bn Shift Right ( n ) { var r = new Big Integer ( ) if ( n < 0 ) this . l Shift To ( - n , r ) else this . r Shift To ( n , r ) return r } 
function bnp Change Bit ( n , op ) { var r = Big Integer . ONE . shift Left ( n ) this . bitwise To ( r , op , r ) return r } 
function bn Divide And Remainder ( a ) { var q = new Big Integer ( ) , r = new Big Integer ( ) this . div Rem To ( a , q , r ) return new Array ( q , r ) } 
function barrett Reduce ( x ) { var self = this x . dr Shift To ( self . m . t - 1 , self . r 2 ) if ( x . t > self . m . t + 1 ) { x . t = self . m . t + 1 x . clamp ( ) } self . mu . multiply Upper To ( self . r 2 , self . m . t + 1 , self . q 3 ) self . m . multiply Lower To ( self . q 3 , self . m . t + 1 , self . r 2 ) while ( x . compare To ( self . r 2 ) < 0 ) x . d Add Offset ( 1 , self . m . t + 1 ) x . sub To ( self . r 2 , x ) while ( x . compare To ( self . m ) > = 0 ) x . sub To ( self . m , x ) } 
function bn Mod Pow ( e , m ) { var i = e . bit Length ( ) , k , r = nbv ( 1 ) , z if ( i < = 0 ) return r else if ( i < 1 8 ) k = 1 else if ( i < 4 8 ) k = 3 else if ( i < 1 4 4 ) k = 4 else if ( i < 7 6 8 ) k = 5 else k = 6 if ( i < 8 ) z = new Classic ( m ) else if ( m . is Even ( ) ) z = new Barrett ( m ) else z = new Montgomery ( m ) 
function bn GCD ( a ) { var x = ( this . s < 0 ) ? this . negate ( ) : this . clone ( ) var y = ( a . s < 0 ) ? a . negate ( ) : a . clone ( ) if ( x . compare To ( y ) < 0 ) { var t = x x = y y = t } var i = x . get Lowest Set Bit ( ) , g = y . get Lowest Set Bit ( ) if ( g < 0 ) return x if ( i < g ) g = i if ( g > 0 ) { x . r Shift To ( g , x ) y . r Shift To ( g , y ) } while ( x . signum ( ) > 0 ) { if ( ( i = x . get Lowest Set Bit ( ) ) > 0 ) x . r Shift To ( i , x ) if ( ( i = y . get Lowest Set Bit ( ) ) > 0 ) y . r Shift To ( i , y ) if ( x . compare To ( y ) > = 0 ) { x . sub To ( y , x ) x . r Shift To ( 1 , x ) } else { y . sub To ( x , y ) y . r Shift To ( 1 , y ) } } if ( g > 0 ) y . l Shift To ( g , y ) return y } 
function bnp Mod Int ( n ) { if ( n < = 0 ) return 0 var d = this . DV % n , r = ( this . s < 0 ) ? n - 1 : 0 if ( this . t > 0 ) if ( d = = 0 ) r = this [ 0 ] % n else for ( var i = this . t - 1 ; i > = 0 ; - - i ) r = ( d * r + this [ i ] ) % n return r } 
function bn Is Probable Prime ( t ) { var i , x = this . abs ( ) if ( x . t = = 1 & & x [ 0 ] < = lowprimes [ lowprimes . length - 1 ] ) { for ( i = 0 ; i < lowprimes . length ; + + i ) if ( x [ 0 ] = = lowprimes [ i ] ) return true return false } if ( x . is Even ( ) ) return false i = 1 while ( i < lowprimes . length ) { var m = lowprimes [ i ] , j = i + 1 while ( j < lowprimes . length & & m < lplim ) m * = lowprimes [ j + + ] m = x . mod Int ( m ) while ( i < j ) if ( m % lowprimes [ i + + ] = = 0 ) return false } return x . miller Rabin ( t ) } 
function verify ( data , pubkey , encoding = "utf 8 " ) { if ( typeof data = = = "string " ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . is Buffer ( data ) , "data is a required String or Buffer " ) ; data = hash . sha 2 5 6 ( data ) ; return verify Hash ( data , pubkey ) ; } 
function verify Hash ( data Sha 2 5 6 , pubkey , encoding = "hex " ) { if ( typeof data Sha 2 5 6 = = = "string " ) { data Sha 2 5 6 = Buffer . from ( data Sha 2 5 6 , encoding ) ; } if ( data Sha 2 5 6 . length ! = = 3 2 | | ! Buffer . is Buffer ( data Sha 2 5 6 ) ) throw new Error ( "data Sha 2 5 6 : 3 2 bytes required " ) ; const public Key = Public Key ( pubkey ) ; assert ( public Key , "pubkey required " ) ; return ecdsa . verify ( curve , data Sha 2 5 6 , { r : r , s : s } , public Key . Q ) ; } 
function recover ( data , encoding = "utf 8 " ) { if ( typeof data = = = "string " ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . is Buffer ( data ) , "data is a required String or Buffer " ) ; data = hash . sha 2 5 6 ( data ) ; return recover Hash ( data ) ; } 
function recover Hash ( data Sha 2 5 6 , encoding = "hex " ) { 
function encode Name ( name , little Endian = true ) { if ( typeof name ! = = "string " ) throw new Type Error ( "name parameter is a required string " ) ; if ( name . length > 1 3 ) throw new Type Error ( "A name can be up to 1 3 characters long " ) ; let bitstr = " " ; for ( let i = 0 ; i < = 1 2 ; i + + ) { 
function encode Name 1 2 8 ( name ) { if ( typeof name ! = = 'string ' ) throw new Type Error ( 'name parameter is a required string ' ) ; if ( name . length > 2 1 ) throw new Type Error ( 'A name can be up to 2 1 characters long ' ) ; let bitstr = ' ' ; for ( let i = 0 ; i < 2 1 ; i + + ) { 
function authenticate ( helper , params Values , credentials ) { print ( "Authenticating via Java Script script . . . " ) ; var msg = helper . prepare Message ( ) ; 
function authenticate ( helper , params Values , credentials ) { print ( "Authenticating via Java Script script . . . " ) ; 
function invoke With ( msg ) { 
function scan ( ps , msg , src ) { 
function authenticate ( helper , params Values , credentials ) { print ( "Wordpress Authenticating via Java Script script . . . " ) ; 
function Form Group ( props ) { const { children , class Name , grouped , inline , unstackable , widths } = props const classes = cx ( use Key Only ( grouped , 'grouped ' ) , use Key Only ( inline , 'inline ' ) , use Key Only ( unstackable , 'unstackable ' ) , use Width Prop ( widths , null , true ) , 'fields ' , class Name , ) const rest = get Unhandled Props ( Form Group , props ) const Element Type = get Element Type ( Form Group , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } 
function Loader ( props ) { const { active , children , class Name , content , disabled , indeterminate , inline , inverted , size , } = props const classes = cx ( 'ui ' , size , use Key Only ( active , 'active ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( indeterminate , 'indeterminate ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( children | | content , 'text ' ) , use Key Or Value And Key ( inline , 'inline ' ) , 'loader ' , class Name , ) const rest = get Unhandled Props ( Loader , props ) const Element Type = get Element Type ( Loader , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Form Text Area ( props ) { const { control } = props const rest = get Unhandled Props ( Form Text Area , props ) const Element Type = get Element Type ( Form Text Area , props ) return < Element Type { . . . rest } control = { control } / > } 
function Form Select ( props ) { const { control , options } = props const rest = get Unhandled Props ( Form Select , props ) const Element Type = get Element Type ( Form Select , props ) return < Element Type { . . . rest } control = { control } options = { options } / > } 
function Item Content ( props ) { const { children , class Name , content , description , extra , header , meta , vertical Align } = props const classes = cx ( use Vertical Align Prop ( vertical Align ) , 'content ' , class Name ) const rest = get Unhandled Props ( Item Content , props ) const Element Type = get Element Type ( Item Content , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Item Header . create ( header , { auto Generate Key : false } ) } { Item Meta . create ( meta , { auto Generate Key : false } ) } { Item Description . create ( description , { auto Generate Key : false } ) } { Item Extra . create ( extra , { auto Generate Key : false } ) } { content } < / Element Type > ) } 
function Table ( props ) { const { attached , basic , celled , children , class Name , collapsing , color , columns , compact , definition , fixed , footer Row , header Row , header Rows , inverted , padded , render Body Row , selectable , single Line , size , sortable , stackable , striped , structured , table Data , text Align , unstackable , vertical Align , } = props const classes = cx ( 'ui ' , color , size , use Key Only ( celled , 'celled ' ) , use Key Only ( collapsing , 'collapsing ' ) , use Key Only ( definition , 'definition ' ) , use Key Only ( fixed , 'fixed ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( selectable , 'selectable ' ) , use Key Only ( single Line , 'single line ' ) , use Key Only ( sortable , 'sortable ' ) , use Key Only ( stackable , 'stackable ' ) , use Key Only ( striped , 'striped ' ) , use Key Only ( structured , 'structured ' ) , use Key Only ( unstackable , 'unstackable ' ) , use Key Or Value And Key ( attached , 'attached ' ) , use Key Or Value And Key ( basic , 'basic ' ) , use Key Or Value And Key ( compact , 'compact ' ) , use Key Or Value And Key ( padded , 'padded ' ) , use Text Align Prop ( text Align ) , use Vertical Align Prop ( vertical Align ) , use Width Prop ( columns , 'column ' ) , 'table ' , class Name , ) const rest = get Unhandled Props ( Table , props ) const Element Type = get Element Type ( Table , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } const has Header Rows = header Row | | header Rows const header Shorthand Options = { default Props : { cell As : 'th ' } } const header Element = has Header Rows & & ( < Table Header > { Table Row . create ( header Row , header Shorthand Options ) } { _ . map ( header Rows , ( data ) = > Table Row . create ( data , header Shorthand Options ) ) } < / Table Header > ) return ( < Element Type { . . . rest } class Name = { classes } > { header Element } < Table Body > { render Body Row & & _ . map ( table Data , ( data , index ) = > Table Row . create ( render Body Row ( data , index ) ) ) } < / Table Body > { footer Row & & < Table Footer > { Table Row . create ( footer Row ) } < / Table Footer > } < / Element Type > ) } 
function Rail ( props ) { const { attached , children , class Name , close , content , dividing , internal , position , size , } = props const classes = cx ( 'ui ' , position , size , use Key Only ( attached , 'attached ' ) , use Key Only ( dividing , 'dividing ' ) , use Key Only ( internal , 'internal ' ) , use Key Or Value And Key ( close , 'close ' ) , 'rail ' , class Name , ) const rest = get Unhandled Props ( Rail , props ) const Element Type = get Element Type ( Rail , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Button Group ( props ) { const { attached , basic , buttons , children , class Name , color , compact , content , floated , fluid , icon , inverted , labeled , negative , positive , primary , secondary , size , toggle , vertical , widths , } = props const classes = cx ( 'ui ' , color , size , use Key Only ( basic , 'basic ' ) , use Key Only ( compact , 'compact ' ) , use Key Only ( fluid , 'fluid ' ) , use Key Only ( icon , 'icon ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( labeled , 'labeled ' ) , use Key Only ( negative , 'negative ' ) , use Key Only ( positive , 'positive ' ) , use Key Only ( primary , 'primary ' ) , use Key Only ( secondary , 'secondary ' ) , use Key Only ( toggle , 'toggle ' ) , use Key Only ( vertical , 'vertical ' ) , use Key Or Value And Key ( attached , 'attached ' ) , use Value And Key ( floated , 'floated ' ) , use Width Prop ( widths ) , 'buttons ' , class Name , ) const rest = get Unhandled Props ( Button Group , props ) const Element Type = get Element Type ( Button Group , props ) if ( _ . is Nil ( buttons ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { _ . map ( buttons , button = > Button . create ( button ) ) } < / Element Type > ) } 
function Grid Row ( props ) { const { centered , children , class Name , color , columns , divided , only , reversed , stretched , text Align , vertical Align , } = props const classes = cx ( color , use Key Only ( centered , 'centered ' ) , use Key Only ( divided , 'divided ' ) , use Key Only ( stretched , 'stretched ' ) , use Multiple Prop ( only , 'only ' ) , use Multiple Prop ( reversed , 'reversed ' ) , use Text Align Prop ( text Align ) , use Vertical Align Prop ( vertical Align ) , use Width Prop ( columns , 'column ' , true ) , 'row ' , class Name , ) const rest = get Unhandled Props ( Grid Row , props ) const Element Type = get Element Type ( Grid Row , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } 
function Form Field ( props ) { const { children , class Name , content , control , disabled , error , inline , label , required , type , width , } = props const classes = cx ( use Key Only ( disabled , 'disabled ' ) , use Key Only ( error , 'error ' ) , use Key Only ( inline , 'inline ' ) , use Key Only ( required , 'required ' ) , use Width Prop ( width , 'wide ' ) , 'field ' , class Name , ) const rest = get Unhandled Props ( Form Field , props ) const Element Type = get Element Type ( Form Field , props ) { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { create HTMLLabel ( label , { auto Generate Key : false } ) } < / Element Type > ) } < label > { create Element ( control , control Props ) } { label } < / label > < / Element Type > ) } { create Element ( control , { . . . control Props , label } ) } < / Element Type > ) } { create HTMLLabel ( label , { default Props : { html For : _ . get ( control Props , 'id ' ) } , auto Generate Key : false , } ) } { create Element ( control , control Props ) } < / Element Type > ) } 
function Card Content ( props ) { const { children , class Name , content , description , extra , header , meta , text Align } = props const classes = cx ( use Key Only ( extra , 'extra ' ) , use Text Align Prop ( text Align ) , 'content ' , class Name ) const rest = get Unhandled Props ( Card Content , props ) const Element Type = get Element Type ( Card Content , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { create Shorthand ( Card Header , val = > ( { content : val } ) , header , { auto Generate Key : false } ) } { create Shorthand ( Card Meta , val = > ( { content : val } ) , meta , { auto Generate Key : false } ) } { create Shorthand ( Card Description , val = > ( { content : val } ) , description , { auto Generate Key : false , } ) } < / Element Type > ) } 
function Item ( props ) { const { children , class Name , content , description , extra , header , image , meta } = props const classes = cx ( 'item ' , class Name ) const rest = get Unhandled Props ( Item , props ) const Element Type = get Element Type ( Item , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Item Image . create ( image , { auto Generate Key : false } ) } < Item Content content = { content } description = { description } extra = { extra } header = { header } meta = { meta } / > < / Element Type > ) } 
function Comment Avatar ( props ) { const { class Name , src } = props const classes = cx ( 'avatar ' , class Name ) const rest = get Unhandled Props ( Comment Avatar , props ) const [ image Props , root Props ] = partition HTMLProps ( rest , { html Props : html Image Props } ) const Element Type = get Element Type ( Comment Avatar , props ) return ( < Element Type { . . . root Props } class Name = { classes } > { create HTMLImage ( src , { auto Generate Key : false , default Props : image Props } ) } < / Element Type > ) } 
function Statistic Label ( props ) { const { children , class Name , content } = props const classes = cx ( 'label ' , class Name ) const rest = get Unhandled Props ( Statistic Label , props ) const Element Type = get Element Type ( Statistic Label , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Radio ( props ) { const { slider , toggle , type } = props const rest = get Unhandled Props ( Radio , props ) 
function Form Checkbox ( props ) { const { control } = props const rest = get Unhandled Props ( Form Checkbox , props ) const Element Type = get Element Type ( Form Checkbox , props ) return < Element Type { . . . rest } control = { control } / > } 
function Feed Meta ( props ) { const { children , class Name , content , like } = props const classes = cx ( 'meta ' , class Name ) const rest = get Unhandled Props ( Feed Meta , props ) const Element Type = get Element Type ( Feed Meta , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { create Shorthand ( Feed Like , val = > ( { content : val } ) , like , { auto Generate Key : false } ) } { content } < / Element Type > ) } 
function Container ( props ) { const { children , class Name , content , fluid , text , text Align } = props const classes = cx ( 'ui ' , use Key Only ( text , 'text ' ) , use Key Only ( fluid , 'fluid ' ) , use Text Align Prop ( text Align ) , 'container ' , class Name , ) const rest = get Unhandled Props ( Container , props ) const Element Type = get Element Type ( Container , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Step Group ( props ) { const { attached , children , class Name , content , fluid , items , ordered , size , stackable , unstackable , vertical , widths , } = props const classes = cx ( 'ui ' , size , use Key Only ( fluid , 'fluid ' ) , use Key Only ( ordered , 'ordered ' ) , use Key Only ( unstackable , 'unstackable ' ) , use Key Only ( vertical , 'vertical ' ) , use Key Or Value And Key ( attached , 'attached ' ) , use Value And Key ( stackable , 'stackable ' ) , use Width Prop ( widths ) , 'steps ' , class Name , ) const rest = get Unhandled Props ( Step Group , props ) const Element Type = get Element Type ( Step Group , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { _ . map ( items , item = > Step . create ( item ) ) } < / Element Type > ) } 
function Divider ( props ) { const { children , class Name , clearing , content , fitted , hidden , horizontal , inverted , section , vertical , } = props const classes = cx ( 'ui ' , use Key Only ( clearing , 'clearing ' ) , use Key Only ( fitted , 'fitted ' ) , use Key Only ( hidden , 'hidden ' ) , use Key Only ( horizontal , 'horizontal ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( section , 'section ' ) , use Key Only ( vertical , 'vertical ' ) , 'divider ' , class Name , ) const rest = get Unhandled Props ( Divider , props ) const Element Type = get Element Type ( Divider , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Header ( props ) { const { attached , block , children , class Name , color , content , disabled , dividing , floated , icon , image , inverted , size , sub , subheader , text Align , } = props const classes = cx ( 'ui ' , color , size , use Key Only ( block , 'block ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( dividing , 'dividing ' ) , use Value And Key ( floated , 'floated ' ) , use Key Only ( icon = = = true , 'icon ' ) , use Key Only ( image = = = true , 'image ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( sub , 'sub ' ) , use Key Or Value And Key ( attached , 'attached ' ) , use Text Align Prop ( text Align ) , 'header ' , class Name , ) const rest = get Unhandled Props ( Header , props ) const Element Type = get Element Type ( Header , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } const icon Element = Icon . create ( icon , { auto Generate Key : false } ) const image Element = Image . create ( image , { auto Generate Key : false } ) const subheader Element = Header Subheader . create ( subheader , { auto Generate Key : false } ) if ( icon Element | | image Element ) { return ( < Element Type { . . . rest } class Name = { classes } > { icon Element | | image Element } { ( content | | subheader Element ) & & ( < Header Content > { content } { subheader Element } < / Header Content > ) } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { content } { subheader Element } < / Element Type > ) } 
function Grid ( props ) { const { celled , centered , children , class Name , columns , container , divided , doubling , inverted , padded , relaxed , reversed , stackable , stretched , text Align , vertical Align , } = props const classes = cx ( 'ui ' , use Key Only ( centered , 'centered ' ) , use Key Only ( container , 'container ' ) , use Key Only ( doubling , 'doubling ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( stackable , 'stackable ' ) , use Key Only ( stretched , 'stretched ' ) , use Key Or Value And Key ( celled , 'celled ' ) , use Key Or Value And Key ( divided , 'divided ' ) , use Key Or Value And Key ( padded , 'padded ' ) , use Key Or Value And Key ( relaxed , 'relaxed ' ) , use Multiple Prop ( reversed , 'reversed ' ) , use Text Align Prop ( text Align ) , use Vertical Align Prop ( vertical Align ) , use Width Prop ( columns , 'column ' , true ) , 'grid ' , class Name , ) const rest = get Unhandled Props ( Grid , props ) const Element Type = get Element Type ( Grid , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } 
function Breadcrumb ( props ) { const { children , class Name , divider , icon , sections , size } = props const classes = cx ( 'ui ' , size , 'breadcrumb ' , class Name ) const rest = get Unhandled Props ( Breadcrumb , props ) const Element Type = get Element Type ( Breadcrumb , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } const child Elements = [ ] _ . each ( sections , ( section , index ) = > { { child Elements } < / Element Type > ) } 
function Form Dropdown ( props ) { const { control } = props const rest = get Unhandled Props ( Form Dropdown , props ) const Element Type = get Element Type ( Form Dropdown , props ) return < Element Type { . . . rest } control = { control } / > } 
function Card Description ( props ) { const { children , class Name , content , text Align } = props const classes = cx ( use Text Align Prop ( text Align ) , 'description ' , class Name ) const rest = get Unhandled Props ( Card Description , props ) const Element Type = get Element Type ( Card Description , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Item Group ( props ) { const { children , class Name , content , divided , items , link , relaxed , unstackable } = props const classes = cx ( 'ui ' , use Key Only ( divided , 'divided ' ) , use Key Only ( link , 'link ' ) , use Key Only ( unstackable , 'unstackable ' ) , use Key Or Value And Key ( relaxed , 'relaxed ' ) , 'items ' , class Name , ) const rest = get Unhandled Props ( Item Group , props ) const Element Type = get Element Type ( Item Group , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } const items JSX = _ . map ( items , ( item ) = > { const { child Key , . . . item Props } = item const final Key = child Key | | [ item Props . content , item Props . description , item Props . header , item Props . meta ] . join ( ' - ' ) return < Item { . . . item Props } key = { final Key } / > } ) return ( < Element Type { . . . rest } class Name = { classes } > { items JSX } < / Element Type > ) } 
function Grid Column ( props ) { const { children , class Name , computer , color , floated , large Screen , mobile , only , stretched , tablet , text Align , vertical Align , widescreen , width , } = props const classes = cx ( color , use Key Only ( stretched , 'stretched ' ) , use Multiple Prop ( only , 'only ' ) , use Text Align Prop ( text Align ) , use Value And Key ( floated , 'floated ' ) , use Vertical Align Prop ( vertical Align ) , use Width Prop ( computer , 'wide computer ' ) , use Width Prop ( large Screen , 'wide large screen ' ) , use Width Prop ( mobile , 'wide mobile ' ) , use Width Prop ( tablet , 'wide tablet ' ) , use Width Prop ( widescreen , 'wide widescreen ' ) , use Width Prop ( width , 'wide ' ) , 'column ' , class Name , ) const rest = get Unhandled Props ( Grid Column , props ) const Element Type = get Element Type ( Grid Column , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } 
function Item Image ( props ) { const { size } = props const rest = get Unhandled Props ( Item Image , props ) return < Image { . . . rest } size = { size } ui = { ! ! size } wrapped / > } 
function Card Group ( props ) { const { centered , children , class Name , content , doubling , items , items Per Row , stackable , text Align , } = props const classes = cx ( 'ui ' , use Key Only ( centered , 'centered ' ) , use Key Only ( doubling , 'doubling ' ) , use Key Only ( stackable , 'stackable ' ) , use Text Align Prop ( text Align ) , use Width Prop ( items Per Row ) , 'cards ' , class Name , ) const rest = get Unhandled Props ( Card Group , props ) const Element Type = get Element Type ( Card Group , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } const items JSX = _ . map ( items , ( item ) = > { const key = item . key | | [ item . header , item . description ] . join ( ' - ' ) return < Card key = { key } { . . . item } / > } ) return ( < Element Type { . . . rest } class Name = { classes } > { items JSX } < / Element Type > ) } 
function Table Row ( props ) { const { active , cell As , cells , children , class Name , disabled , error , negative , positive , text Align , vertical Align , warning , } = props const classes = cx ( use Key Only ( active , 'active ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( error , 'error ' ) , use Key Only ( negative , 'negative ' ) , use Key Only ( positive , 'positive ' ) , use Key Only ( warning , 'warning ' ) , use Text Align Prop ( text Align ) , use Vertical Align Prop ( vertical Align ) , class Name , ) const rest = get Unhandled Props ( Table Row , props ) const Element Type = get Element Type ( Table Row , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { _ . map ( cells , cell = > Table Cell . create ( cell , { default Props : { as : cell As } } ) ) } < / Element Type > ) } 
function Form Button ( props ) { const { control } = props const rest = get Unhandled Props ( Form Button , props ) const Element Type = get Element Type ( Form Button , props ) return < Element Type { . . . rest } control = { control } / > } 
function Ref ( props ) { const { children , inner Ref } = props const child = React . Children . only ( children ) const Element Type = is Forward Ref ( child ) ? Ref Forward : Ref Find Node return < Element Type inner Ref = { inner Ref } > { child } < / Element Type > } 
function Feed Event ( props ) { const { content , children , class Name , date , extra Images , extra Text , image , icon , meta , summary , } = props const classes = cx ( 'event ' , class Name ) const rest = get Unhandled Props ( Feed Event , props ) const Element Type = get Element Type ( Feed Event , props ) const has Content Prop = content | | date | | extra Images | | extra Text | | meta | | summary const content Props = { content , date , extra Images , extra Text , meta , summary } return ( < Element Type { . . . rest } class Name = { classes } > { create Shorthand ( Feed Label , val = > ( { icon : val } ) , icon , { auto Generate Key : false } ) } { create Shorthand ( Feed Label , val = > ( { image : val } ) , image , { auto Generate Key : false } ) } { has Content Prop & & < Feed Content { . . . content Props } / > } { children } < / Element Type > ) } 
function Tab Pane ( props ) { const { active , children , class Name , content , loading } = props const classes = cx ( use Key Only ( active , 'active ' ) , use Key Only ( loading , 'loading ' ) , 'tab ' , class Name ) const rest = get Unhandled Props ( Tab Pane , props ) const Element Type = get Element Type ( Tab Pane , props ) const calculated Default Props = { } if ( Element Type = = = Segment ) { calculated Default Props . attached = 'bottom ' } return ( < Element Type { . . . calculated Default Props } { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function List Content ( props ) { const { children , class Name , content , description , floated , header , vertical Align } = props const classes = cx ( use Value And Key ( floated , 'floated ' ) , use Vertical Align Prop ( vertical Align ) , 'content ' , class Name , ) const rest = get Unhandled Props ( List Content , props ) const Element Type = get Element Type ( List Content , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { List Header . create ( header ) } { List Description . create ( description ) } { content } < / Element Type > ) } 
function Button Or ( props ) { const { class Name , text } = props const classes = cx ( 'or ' , class Name ) const rest = get Unhandled Props ( Button Or , props ) const Element Type = get Element Type ( Button Or , props ) return < Element Type { . . . rest } class Name = { classes } data -text = { text } / > } 
function Table Cell ( props ) { const { active , children , class Name , collapsing , content , disabled , error , icon , negative , positive , selectable , single Line , text Align , vertical Align , warning , width , } = props const classes = cx ( use Key Only ( active , 'active ' ) , use Key Only ( collapsing , 'collapsing ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( error , 'error ' ) , use Key Only ( negative , 'negative ' ) , use Key Only ( positive , 'positive ' ) , use Key Only ( selectable , 'selectable ' ) , use Key Only ( single Line , 'single line ' ) , use Key Only ( warning , 'warning ' ) , use Text Align Prop ( text Align ) , use Vertical Align Prop ( vertical Align ) , use Width Prop ( width , 'wide ' ) , class Name , ) const rest = get Unhandled Props ( Table Cell , props ) const Element Type = get Element Type ( Table Cell , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Icon . create ( icon ) } { content } < / Element Type > ) } 
function Breadcrumb Divider ( props ) { const { children , class Name , content , icon } = props const classes = cx ( 'divider ' , class Name ) const rest = get Unhandled Props ( Breadcrumb Divider , props ) const Element Type = get Element Type ( Breadcrumb Divider , props ) if ( ! _ . is Nil ( icon ) ) { return Icon . create ( icon , { default Props : { . . . rest , class Name : classes } , auto Generate Key : false , } ) } if ( ! _ . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? ' / ' : children } < / Element Type > ) } 
function Message List ( props ) { const { children , class Name , items } = props const classes = cx ( 'list ' , class Name ) const rest = get Unhandled Props ( Message List , props ) const Element Type = get Element Type ( Message List , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? _ . map ( items , Message Item . create ) : children } < / Element Type > ) } 
function Table Footer ( props ) { const { as } = props const rest = get Unhandled Props ( Table Footer , props ) return < Table Header { . . . rest } as = { as } / > } 
function Comment Group ( props ) { const { class Name , children , collapsed , content , minimal , size , threaded } = props const classes = cx ( 'ui ' , size , use Key Only ( collapsed , 'collapsed ' ) , use Key Only ( minimal , 'minimal ' ) , use Key Only ( threaded , 'threaded ' ) , 'comments ' , class Name , ) const rest = get Unhandled Props ( Comment Group , props ) const Element Type = get Element Type ( Comment Group , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Reveal ( props ) { const { active , animated , children , class Name , content , disabled , instant } = props const classes = cx ( 'ui ' , animated , use Key Only ( active , 'active ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( instant , 'instant ' ) , 'reveal ' , class Name , ) const rest = get Unhandled Props ( Reveal , props ) const Element Type = get Element Type ( Reveal , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Segment ( props ) { const { attached , basic , children , circular , class Name , clearing , color , compact , content , disabled , floated , inverted , loading , placeholder , padded , piled , raised , secondary , size , stacked , tertiary , text Align , vertical , } = props const classes = cx ( 'ui ' , color , size , use Key Only ( basic , 'basic ' ) , use Key Only ( circular , 'circular ' ) , use Key Only ( clearing , 'clearing ' ) , use Key Only ( compact , 'compact ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( loading , 'loading ' ) , use Key Only ( placeholder , 'placeholder ' ) , use Key Only ( piled , 'piled ' ) , use Key Only ( raised , 'raised ' ) , use Key Only ( secondary , 'secondary ' ) , use Key Only ( stacked , 'stacked ' ) , use Key Only ( tertiary , 'tertiary ' ) , use Key Only ( vertical , 'vertical ' ) , use Key Or Value And Key ( attached , 'attached ' ) , use Key Or Value And Key ( padded , 'padded ' ) , use Text Align Prop ( text Align ) , use Value And Key ( floated , 'floated ' ) , 'segment ' , class Name , ) const rest = get Unhandled Props ( Segment , props ) const Element Type = get Element Type ( Segment , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Form Input ( props ) { const { control } = props const rest = get Unhandled Props ( Form Input , props ) const Element Type = get Element Type ( Form Input , props ) return < Element Type { . . . rest } control = { control } / > } 
function Placeholder Line ( props ) { const { class Name , length } = props const classes = cx ( 'line ' , length , class Name ) const rest = get Unhandled Props ( Placeholder Line , props ) const Element Type = get Element Type ( Placeholder Line , props ) return < Element Type { . . . rest } class Name = { classes } / > } 
function Reveal Content ( props ) { const { children , class Name , content , hidden , visible } = props const classes = cx ( 'ui ' , use Key Only ( hidden , 'hidden ' ) , use Key Only ( visible , 'visible ' ) , 'content ' , class Name , ) const rest = get Unhandled Props ( Reveal Content , props ) const Element Type = get Element Type ( Reveal Content , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Feed Like ( props ) { const { children , class Name , content , icon } = props const classes = cx ( 'like ' , class Name ) const rest = get Unhandled Props ( Feed Like , props ) const Element Type = get Element Type ( Feed Like , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Icon . create ( icon , { auto Generate Key : false } ) } { content } < / Element Type > ) } 
function Placeholder ( props ) { const { children , class Name , content , fluid , inverted } = props const classes = cx ( 'ui ' , use Key Only ( fluid , 'fluid ' ) , use Key Only ( inverted , 'inverted ' ) , 'placeholder ' , class Name , ) const rest = get Unhandled Props ( Placeholder , props ) const Element Type = get Element Type ( Placeholder , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Accordion ( props ) { const { class Name , fluid , inverted , styled } = props const classes = cx ( 'ui ' , use Key Only ( fluid , 'fluid ' ) , use Key Only ( inverted , 'inverted ' ) , use Key Only ( styled , 'styled ' ) , class Name , ) const rest = get Unhandled Props ( Accordion , props ) return < Accordion Accordion { . . . rest } class Name = { classes } / > } 
function Placeholder Image ( props ) { const { class Name , square , rectangular } = props const classes = cx ( use Key Only ( square , 'square ' ) , use Key Only ( rectangular , 'rectangular ' ) , 'image ' , class Name , ) const rest = get Unhandled Props ( Placeholder Image , props ) const Element Type = get Element Type ( Placeholder Image , props ) return < Element Type { . . . rest } class Name = { classes } / > } 
function Dropdown Menu ( props ) { const { children , class Name , content , direction , open , scrolling } = props const classes = cx ( direction , use Key Only ( open , 'visible ' ) , use Key Only ( scrolling , 'scrolling ' ) , 'menu transition ' , class Name , ) const rest = get Unhandled Props ( Dropdown Menu , props ) const Element Type = get Element Type ( Dropdown Menu , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function List Icon ( props ) { const { class Name , vertical Align } = props const classes = cx ( use Vertical Align Prop ( vertical Align ) , class Name ) const rest = get Unhandled Props ( List Icon , props ) return < Icon { . . . rest } class Name = { classes } / > } 
function Advertisement ( props ) { const { centered , children , class Name , content , test , unit } = props const classes = cx ( 'ui ' , unit , use Key Only ( centered , 'centered ' ) , use Key Only ( test , 'test ' ) , 'ad ' , class Name , ) const rest = get Unhandled Props ( Advertisement , props ) const Element Type = get Element Type ( Advertisement , props ) return ( < Element Type { . . . rest } class Name = { classes } data -text = { test } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Statistic Group ( props ) { const { children , class Name , color , content , horizontal , inverted , items , size , widths } = props const classes = cx ( 'ui ' , color , size , use Key Only ( horizontal , 'horizontal ' ) , use Key Only ( inverted , 'inverted ' ) , use Width Prop ( widths ) , 'statistics ' , class Name , ) const rest = get Unhandled Props ( Statistic Group , props ) const Element Type = get Element Type ( Statistic Group , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { _ . map ( items , item = > Statistic . create ( item ) ) } < / Element Type > ) } 
function Statistic ( props ) { const { children , class Name , color , content , floated , horizontal , inverted , label , size , text , value , } = props const classes = cx ( 'ui ' , color , size , use Value And Key ( floated , 'floated ' ) , use Key Only ( horizontal , 'horizontal ' ) , use Key Only ( inverted , 'inverted ' ) , 'statistic ' , class Name , ) const rest = get Unhandled Props ( Statistic , props ) const Element Type = get Element Type ( Statistic , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Statistic Value . create ( value , { default Props : { text } , auto Generate Key : false , } ) } { Statistic Label . create ( label , { auto Generate Key : false } ) } < / Element Type > ) } 
function get Element Type ( Component , props , get Default ) { const { default Props = { } } = Component 
function Segment Group ( props ) { const { children , class Name , compact , content , horizontal , piled , raised , size , stacked } = props const classes = cx ( 'ui ' , size , use Key Only ( compact , 'compact ' ) , use Key Only ( horizontal , 'horizontal ' ) , use Key Only ( piled , 'piled ' ) , use Key Only ( raised , 'raised ' ) , use Key Only ( stacked , 'stacked ' ) , 'segments ' , class Name , ) const rest = get Unhandled Props ( Segment Group , props ) const Element Type = get Element Type ( Segment Group , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Table Header Cell ( props ) { const { as , class Name , sorted } = props const classes = cx ( use Value And Key ( sorted , 'sorted ' ) , class Name ) const rest = get Unhandled Props ( Table Header Cell , props ) return < Table Cell { . . . rest } as = { as } class Name = { classes } / > } 
function Feed ( props ) { const { children , class Name , events , size } = props const classes = cx ( 'ui ' , size , 'feed ' , class Name ) const rest = get Unhandled Props ( Feed , props ) const Element Type = get Element Type ( Feed , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } const event Elements = _ . map ( events , ( event Props ) = > { const { child Key , date , meta , summary , . . . event Data } = event Props const final Key = child Key | | [ date , meta , summary ] . join ( ' - ' ) return < Feed Event date = { date } key = { final Key } meta = { meta } summary = { summary } { . . . event Data } / > } ) return ( < Element Type { . . . rest } class Name = { classes } > { event Elements } < / Element Type > ) } 
function Label Group ( props ) { const { children , circular , class Name , color , content , size , tag } = props const classes = cx ( 'ui ' , color , size , use Key Only ( circular , 'circular ' ) , use Key Only ( tag , 'tag ' ) , 'labels ' , class Name , ) const rest = get Unhandled Props ( Label Group , props ) const Element Type = get Element Type ( Label Group , props ) return ( < Element Type { . . . rest } class Name = { classes } > { children Utils . is Nil ( children ) ? content : children } < / Element Type > ) } 
function Feed Extra ( props ) { const { children , class Name , content , images , text } = props const classes = cx ( use Key Only ( images , 'images ' ) , use Key Only ( content | | text , 'text ' ) , 'extra ' , class Name , ) const rest = get Unhandled Props ( Feed Extra , props ) const Element Type = get Element Type ( Feed Extra , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } { content } { image Elements } < / Element Type > ) } 
function Dropdown Divider ( props ) { const { class Name } = props const classes = cx ( 'divider ' , class Name ) const rest = get Unhandled Props ( Dropdown Divider , props ) const Element Type = get Element Type ( Dropdown Divider , props ) return < Element Type { . . . rest } class Name = { classes } / > } 
function Feed Summary ( props ) { const { children , class Name , content , date , user } = props const classes = cx ( 'summary ' , class Name ) const rest = get Unhandled Props ( Feed Summary , props ) const Element Type = get Element Type ( Feed Summary , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { create Shorthand ( Feed User , val = > ( { content : val } ) , user , { auto Generate Key : false } ) } { content } { create Shorthand ( Feed Date , val = > ( { content : val } ) , date , { auto Generate Key : false } ) } < / Element Type > ) } 
function Step Content ( props ) { const { children , class Name , content , description , title } = props const classes = cx ( 'content ' , class Name ) const rest = get Unhandled Props ( Step Content , props ) const Element Type = get Element Type ( Step Content , props ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } return ( < Element Type { . . . rest } class Name = { classes } > { Step Title . create ( title , { auto Generate Key : false } ) } { Step Description . create ( description , { auto Generate Key : false } ) } < / Element Type > ) } 
function Form Radio ( props ) { const { control } = props const rest = get Unhandled Props ( Form Radio , props ) const Element Type = get Element Type ( Form Radio , props ) return < Element Type { . . . rest } control = { control } / > } 
function Image ( props ) { const { avatar , bordered , centered , children , circular , class Name , content , dimmer , disabled , floated , fluid , hidden , href , inline , label , rounded , size , spaced , vertical Align , wrapped , ui , } = props const classes = cx ( use Key Only ( ui , 'ui ' ) , size , use Key Only ( avatar , 'avatar ' ) , use Key Only ( bordered , 'bordered ' ) , use Key Only ( circular , 'circular ' ) , use Key Only ( centered , 'centered ' ) , use Key Only ( disabled , 'disabled ' ) , use Key Only ( fluid , 'fluid ' ) , use Key Only ( hidden , 'hidden ' ) , use Key Only ( inline , 'inline ' ) , use Key Only ( rounded , 'rounded ' ) , use Key Or Value And Key ( spaced , 'spaced ' ) , use Value And Key ( floated , 'floated ' ) , use Vertical Align Prop ( vertical Align , 'aligned ' ) , 'image ' , class Name , ) const rest = get Unhandled Props ( Image , props ) const [ img Tag Props , root Props ] = partition HTMLProps ( rest , { html Props : html Image Props } ) const Element Type = get Element Type ( Image , props , ( ) = > { if ( ! _ . is Nil ( dimmer ) | | ! _ . is Nil ( label ) | | ! _ . is Nil ( wrapped ) | | ! children Utils . is Nil ( children ) ) { return 'div ' } } ) if ( ! children Utils . is Nil ( children ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { children } < / Element Type > ) } if ( ! children Utils . is Nil ( content ) ) { return ( < Element Type { . . . rest } class Name = { classes } > { content } < / Element Type > ) } if ( Element Type = = = 'img ' ) { return < Element Type { . . . root Props } { . . . img Tag Props } class Name = { classes } / > } return ( < Element Type { . . . root Props } class Name = { classes } href = { href } > { Dimmer . create ( dimmer , { auto Generate Key : false } ) } { Label . create ( label , { auto Generate Key : false } ) } < img { . . . img Tag Props } / > < / Element Type > ) } 
function ( width , height ) { var canvas = document . create Element ( 'canvas ' ) ; canvas . width = width ; canvas . height = height ; canvas . oncontextmenu = function ( ) { return false ; } ; canvas . onselectstart = function ( ) { return false ; } ; return canvas ; } 
function ( canvas ) { var context = canvas . get Context ( ' 2d ' ) , device Pixel Ratio = window . device Pixel Ratio | | 1 , backing Store Pixel Ratio = context . webkit Backing Store Pixel Ratio | | context . moz Backing Store Pixel Ratio | | context . ms Backing Store Pixel Ratio | | context . o Backing Store Pixel Ratio | | context . backing Store Pixel Ratio | | 1 ; return device Pixel Ratio / backing Store Pixel Ratio ; } 
function ( render , image Path ) { var image = render . textures [ image Path ] ; if ( image ) return image ; image = render . textures [ image Path ] = new Image ( ) ; image . src = image Path ; return image ; } 
function ( render , background ) { var css Background = background ; if ( / (jpg |gif |png ) $ / . test ( background ) ) css Background = 'url ( ' + background + ' ) ' ; render . canvas . style . background = css Background ; render . canvas . style . background Size = "contain " ; render . current Background = background ; } 
function ( render , body ) { var body Render = body . render , texture Path = body Render . sprite . texture , texture = _get Texture ( render , texture Path ) , sprite = new PIXI . Sprite ( texture ) ; sprite . anchor . x = body . render . sprite . x Offset ; sprite . anchor . y = body . render . sprite . y Offset ; return sprite ; } 
function ( render , body ) { var body Render = body . render , options = render . options , primitive = new PIXI . Graphics ( ) , fill Style = Common . color To Number ( body Render . fill Style ) , stroke Style = Common . color To Number ( body Render . stroke Style ) , stroke Style Indicator = Common . color To Number ( body Render . stroke Style ) , stroke Style Wireframe = Common . color To Number ( ' #bbb ' ) , stroke Style Wireframe Indicator = Common . color To Number ( ' #CD 5C 5C ' ) , part ; primitive . clear ( ) ; 
function ( render , image Path ) { var texture = render . textures [ image Path ] ; if ( ! texture ) texture = render . textures [ image Path ] = PIXI . Texture . from Image ( image Path ) ; return texture ; } 
function ( body , options ) { options = options | | { } ; 
async function create Pages ( { actions , graphql } ) { const retrieve Markdown Pages = ( ) = > graphql ( ` ` ) const example Template = path . resolve ( ` ` ) const doc Template = path . resolve ( ` ` ) const result = await retrieve Markdown Pages ( ) if ( result . errors ) { console . error ( 'graphql error ' , result . errors ) throw new Error ( 'Error invoking graphql for pages ' ) } result . data . all Markdown Remark . edges . for Each ( ( { node } ) = > { const { frontmatter : { path : page Path } , } = node const category = ( page Path | | ' / ' ) . split ( ' / ' ) . filter ( t = > ! ! t ) [ 0 ] const is Example = category = = = 'examples ' console . log ( ` $ { page Path } $ { category } ` ) actions . create Page ( { path : page Path , component : is Example ? example Template : doc Template , context : { } , 
function parse Month String ( str ) { const matches = month Re . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year < = 0 ) { return null ; } const month = Number ( matches [ 2 ] ) ; if ( month < 1 | | month > 1 2 ) { return null ; } return { year , month } ; } 
function parse Date String ( str ) { const matches = date Re . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year < = 0 ) { return null ; } const month = Number ( matches [ 2 ] ) ; if ( month < 1 | | month > 1 2 ) { return null ; } const day = Number ( matches [ 3 ] ) ; if ( day < 1 | | day > number Of Days In Month Of Year ( month , year ) ) { return null ; } return { year , month , day } ; } 
function parse Yearless Date String ( str ) { const matches = yearless Date Re . exec ( str ) ; if ( ! matches ) { return null ; } const month = Number ( matches [ 1 ] ) ; if ( month < 1 | | month > 1 2 ) { return null ; } const day = Number ( matches [ 2 ] ) ; if ( day < 1 | | day > number Of Days In Month Of Year ( month , 4 ) ) { return null ; } return { month , day } ; } 
function parse Time String ( str ) { const matches = time Re . exec ( str ) ; if ( ! matches ) { return null ; } const hour = Number ( matches [ 1 ] ) ; if ( hour < 0 | | hour > 2 3 ) { return null ; } const minute = Number ( matches [ 2 ] ) ; if ( minute < 0 | | minute > 5 9 ) { return null ; } const second = matches [ 3 ] ! = = undefined ? Math . trunc ( Number ( matches [ 3 ] ) ) : 0 ; if ( second < 0 | | second > = 6 0 ) { return null ; } const millisecond = matches [ 4 ] ! = = undefined ? Number ( matches [ 4 ] ) : 0 ; return { hour , minute , second , millisecond } ; } 
function parse Local Date And Time String ( str , normalized = false ) { let separator Idx = str . index Of ( "T " ) ; if ( separator Idx < 0 & & ! normalized ) { separator Idx = str . index Of ( " " ) ; } if ( separator Idx < 0 ) { return null ; } const date = parse Date String ( str . slice ( 0 , separator Idx ) ) ; if ( date = = = null ) { return null ; } const time = parse Time String ( str . slice ( separator Idx + 1 ) ) ; if ( time = = = null ) { return null ; } return { date , time } ; } 
function week Number Of Last Day ( year ) { const jan 1 = new Date ( year , 0 ) ; return jan 1 . get Day ( ) = = = 4 | | ( is Leap Year ( year ) & & jan 1 . get Day ( ) = = = 3 ) ? 5 3 : 5 2 ; } 
function parse Week String ( str ) { const matches = week Re . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year < = 0 ) { return null ; } const week = Number ( matches [ 2 ] ) ; if ( week < 1 | | week > week Number Of Last Day ( year ) ) { return null ; } return { year , week } ; } 
function wrap Node Canvas Method ( ctx , name ) { const prev = ctx [ name ] ; ctx [ name ] = function ( image ) { const impl = idl Utils . impl For Wrapper ( image ) ; if ( impl ) { arguments [ 0 ] = impl . _image | | impl . _canvas ; } return prev . apply ( ctx , arguments ) ; } ; } 
function Window ( options ) { Event Target . setup ( this ) ; const raw Performance = new Raw Performance ( ) ; const window Initialized = raw Performance . now ( ) ; const window = this ; mixin ( window , Window Event Handlers Impl . prototype ) ; mixin ( window , Global Event Handlers Impl . prototype ) ; this . _init Global Events ( ) ; 
function is Host Inclusive Ancestor ( node Impl A , node Impl B ) { for ( const ancestor of dom Symbol Tree . ancestors Iterator ( node Impl B ) ) { if ( ancestor = = = node Impl A ) { return true ; } } const root Impl B = get Root ( node Impl B ) ; if ( root Impl B . _host ) { return is Host Inclusive Ancestor ( node Impl A , root Impl B . _host ) ; } return false ; } 
function is Window ( val ) { if ( typeof val ! = = "object " ) { return false ; } const wrapper = idl Utils . wrapper For Impl ( val ) ; if ( typeof wrapper = = = "object " ) { return wrapper = = = wrapper . _global Proxy ; } 
function create Client ( xhr ) { const flag = xhr [ xhr Symbols . flag ] ; const properties = xhr [ xhr Symbols . properties ] ; const url Obj = new URL ( flag . uri ) ; const uri = url Obj . href ; const uc Method = flag . method . to Upper Case ( ) ; const { request Manager } = flag ; if ( url Obj . protocol = = = "file : " ) { const response = new Event Emitter ( ) ; response . status Code = 2 0 0 ; response . raw Headers = [ ] ; response . headers = { } ; response . request = { uri : url Obj } ; const file Path = url Obj . pathname . replace ( / ^file : \ / \ / / , " " ) . replace ( / ^ \ / ( [a -z ] ) : \ / / i , " $ 1 : / " ) . replace ( / % 2 0 / g , " " ) ; const client = new Event Emitter ( ) ; const readable Stream = fs . create Read Stream ( file Path , { encoding : null } ) ; readable Stream . on ( "data " , chunk = > { response . emit ( "data " , chunk ) ; client . emit ( "data " , chunk ) ; } ) ; readable Stream . on ( "end " , ( ) = > { response . emit ( "end " ) ; client . emit ( "end " ) ; } ) ; readable Stream . on ( "error " , err = > { client . emit ( "error " , err ) ; } ) ; client . abort = function ( ) { readable Stream . destroy ( ) ; client . emit ( "abort " ) ; } ; if ( request Manager ) { const req = { abort ( ) { properties . abort Error = true ; xhr . abort ( ) ; } } ; request Manager . add ( req ) ; const rm Req = request Manager . remove . bind ( request Manager , req ) ; client . on ( "abort " , rm Req ) ; client . on ( "error " , rm Req ) ; client . on ( "end " , rm Req ) ; } process . next Tick ( ( ) = > client . emit ( "response " , response ) ) ; return client ; } if ( url Obj . protocol = = = "data : " ) { const response = new Event Emitter ( ) ; response . request = { uri : url Obj } ; const client = new Event Emitter ( ) ; let buffer ; try { const parsed = parse Data URL ( uri ) ; const content Type = parsed . mime Type . to String ( ) ; buffer = parsed . body ; response . status Code = 2 0 0 ; response . raw Headers = [ "Content -Type " , content Type ] ; response . headers = { "content -type " : content Type } ; } catch ( err ) { process . next Tick ( ( ) = > client . emit ( "error " , err ) ) ; return client ; } client . abort = ( ) = > { 
function parse Fragment ( markup , context Element ) { const { _parsing Mode } = context Element . _owner Document ; let parse Algorithm ; if ( _parsing Mode = = = "html " ) { parse Algorithm = html Parser . parse Fragment ; } else if ( _parsing Mode = = = "xml " ) { parse Algorithm = xml Parser . parse Fragment ; } 
function on Error ( event ) { const bench = event . target ; console . error ( "Error in benchmark " , bench . name , " : " , bench . error ) ; } 
function report An Error ( line , col , target , error Object , message , location ) { if ( target [ error Reporting Mode ] ) { return false ; } target [ error Reporting Mode ] = true ; const event = create An Event ( "error " , Error Event , { cancelable : true , message , filename : location , lineno : line , colno : col , error : error Object } ) ; try { target . _dispatch ( event ) ; } finally { target [ error Reporting Mode ] = false ; return event . default Prevented ; } } 
function maybe Fetch And Process ( el ) { if ( ! is External Resource Link ( el ) ) { return ; } 
function fetch And Process ( el ) { const href = el . get Attribute NS ( null , "href " ) ; if ( href = = = null | | href = = = " " ) { return ; } const url = parse URLTo Resulting URLRecord ( href , el . _owner Document ) ; if ( url = = = null ) { return ; } 
function is Slotable ( node Impl ) { return node Impl & & ( node Impl . node Type = = = NODE _TYPE . ELEMENT _NODE | | node Impl . node Type = = = NODE _TYPE . TEXT _NODE ) ; } 
function is Shadow Inclusive Ancestor ( ancestor , node ) { while ( is Node ( node ) ) { if ( node = = = ancestor ) { return true ; } if ( is Shadow Root ( node ) ) { node = node . host ; } else { node = dom Symbol Tree . parent ( node ) ; } } return false ; } 
function retarget ( a , b ) { while ( true ) { if ( ! is Node ( a ) ) { return a ; } const a Root = get Root ( a ) ; if ( ! is Shadow Root ( a Root ) | | ( is Node ( b ) & & is Shadow Inclusive Ancestor ( a Root , b ) ) ) { return a ; } a = get Root ( a ) . host ; } } 
function shadow Including Root ( node ) { const root = get Root ( node ) ; return is Shadow Root ( root ) ? shadow Including Root ( root . host ) : root ; } 
function assign Slotable ( slot ) { const slotables = find Slotable ( slot ) ; let should Fire Slot Change = false ; if ( slotables . length ! = = slot . _assigned Nodes . length ) { should Fire Slot Change = true ; } else { for ( let i = 0 ; i < slotables . length ; i + + ) { if ( slotables [ i ] ! = = slot . _assigned Nodes [ i ] ) { should Fire Slot Change = true ; break ; } } } if ( should Fire Slot Change ) { signal Slot Change ( slot ) ; } slot . _assigned Nodes = slotables ; for ( const slotable of slotables ) { slotable . _assigned Slot = slot ; } } 
function assign Slotable For Tree ( root ) { for ( const slot of dom Symbol Tree . tree Iterator ( root ) ) { if ( is Slot ( slot ) ) { assign Slotable ( slot ) ; } } } 
function find Slotable ( slot ) { const result = [ ] ; const root = get Root ( slot ) ; if ( ! is Shadow Root ( root ) ) { return result ; } for ( const slotable of dom Symbol Tree . tree Iterator ( root . host ) ) { const found Slot = find Slot ( slotable ) ; if ( found Slot = = = slot ) { result . push ( slotable ) ; } } return result ; } 
function find Flattened Slotables ( slot ) { const result = [ ] ; const root = get Root ( slot ) ; if ( ! is Shadow Root ( root ) ) { return result ; } const slotables = find Slotable ( slot ) ; if ( slotables . length = = = 0 ) { for ( const child of dom Symbol Tree . children Iterator ( slot ) ) { if ( is Slotable ( child ) ) { slotables . push ( child ) ; } } } for ( const node of slotables ) { if ( is Slot ( node ) & & is Shadow Root ( get Root ( node ) ) ) { const temporary Result = find Flattened Slotables ( node ) ; result . push ( . . . temporary Result ) ; } else { result . push ( node ) ; } } return result ; } 
function find Slot ( slotable , open Flag ) { const { parent Node : parent } = slotable ; if ( ! parent ) { return null ; } const shadow = parent . _shadow Root ; if ( ! shadow | | ( open Flag & & shadow . mode ! = = "open " ) ) { return null ; } for ( const child of dom Symbol Tree . tree Iterator ( shadow ) ) { if ( is Slot ( child ) & & child . name = = = slotable . _slotable Name ) { return child ; } } return null ; } 
function signal Slot Change ( slot ) { if ( ! signal Slot List . some ( entry = > entry = = = slot ) ) { signal Slot List . push ( slot ) ; } queue Mutation Observer Microtask ( ) ; } 
function navigate To Fragment ( window , new URL , flags ) { const document = idl Utils . impl For Wrapper ( window . _document ) ; window . _session History . clear History Traversal Tasks ( ) ; if ( ! flags . replacement ) { 
function invoke Event Listeners ( tuple , event Impl ) { const tuple Index = event Impl . _path . index Of ( tuple ) ; for ( let i = tuple Index ; i > = 0 ; i - - ) { const t = event Impl . _path [ i ] ; if ( t . target ) { event Impl . target = t . target ; break ; } } event Impl . related Target = idl Utils . wrapper For Impl ( tuple . related Target ) ; if ( event Impl . _stop Propagation Flag ) { return ; } event Impl . current Target = idl Utils . wrapper For Impl ( tuple . item ) ; const listeners = tuple . item . _event Listeners ; inner Invoke Event Listeners ( event Impl , listeners ) ; } 
function inner Invoke Event Listeners ( event Impl , listeners ) { let found = false ; const { type , target } = event Impl ; const wrapper = idl Utils . wrapper For Impl ( target ) ; if ( ! listeners | | ! listeners [ type ] ) { return found ; } 
function normalize Event Handler Options ( options , default Bool Keys ) { const return Value = { } ; 
function append To Event Path ( event Impl , target , target Override , related Target , touch Targets , slot In Closed Tree ) { const item In Shadow Tree = is Node ( target ) & & is Shadow Root ( get Root ( target ) ) ; const root Of Closed Tree = is Shadow Root ( target ) & & target . mode = = = "closed " ; event Impl . _path . push ( { item : target , item In Shadow Tree , target : target Override , related Target , touch Targets , root Of Closed Tree , slot In Closed Tree } ) ; } 
function queue Mutation Record ( type , target , name , namespace , old Value , added Nodes , removed Nodes , previous Sibling , next Sibling ) { const interested Observers = new Map ( ) ; const nodes = dom Symbol Tree . ancestors To Array ( target ) ; for ( const node of nodes ) { for ( const registered of node . _registered Observer List ) { const { options , observer : mo } = registered ; if ( ! ( node ! = = target & & options . subtree = = = false ) & & ! ( type = = = MUTATION _TYPE . ATTRIBUTES & & options . attributes ! = = true ) & & ! ( type = = = MUTATION _TYPE . ATTRIBUTES & & options . attribute Filter & & ! options . attribute Filter . some ( value = > value = = = name | | value = = = namespace ) ) & & ! ( type = = = MUTATION _TYPE . CHARACTER _DATA & & options . character Data ! = = true ) & & ! ( type = = = MUTATION _TYPE . CHILD _LIST & & options . child List = = = false ) ) { if ( ! interested Observers . has ( mo ) ) { interested Observers . set ( mo , null ) ; } if ( ( type = = = MUTATION _TYPE . ATTRIBUTES & & options . attribute Old Value = = = true ) | | ( type = = = MUTATION _TYPE . CHARACTER _DATA & & options . character Data Old Value = = = true ) ) { interested Observers . set ( mo , old Value ) ; } } } } for ( const [ observer , mapped Old Value ] of interested Observers . entries ( ) ) { const record = Mutation Record . create Impl ( [ ] , { type , target , attribute Name : name , attribute Namespace : namespace , old Value : mapped Old Value , added Nodes , removed Nodes , previous Sibling , next Sibling } ) ; observer . _record Queue . push ( record ) ; active Mutation Observers . add ( observer ) ; } queue Mutation Observer Microtask ( ) ; } 
function queue Tree Mutation Record ( target , added Nodes , removed Nodes , previous Sibling , next Sibling ) { queue Mutation Record ( MUTATION _TYPE . CHILD _LIST , target , null , null , null , added Nodes , removed Nodes , previous Sibling , next Sibling ) ; } 
function queue Attribute Mutation Record ( target , name , namespace , old Value ) { queue Mutation Record ( MUTATION _TYPE . ATTRIBUTES , target , name , namespace , old Value , [ ] , [ ] , null , null ) ; } 
function notify Mutation Observers ( ) { mutation Observer Microtask Queue Flag = false ; const notify List = [ . . . active Mutation Observers ] . sort ( ( a , b ) = > a . _id - b . _id ) ; active Mutation Observers . clear ( ) ; const signal List = [ . . . signal Slot List ] ; signal Slot List . splice ( 0 , signal Slot List . length ) ; for ( const mo of notify List ) { const records = [ . . . mo . _record Queue ] ; mo . _record Queue = [ ] ; for ( const node of mo . _node List ) { node . _registered Observer List = node . _registered Observer List . filter ( registered Observer = > { return registered Observer . source ! = = mo ; } ) ; if ( records . length ) { try { mo . _callback ( records . map ( idl Utils . wrapper For Impl ) , idl Utils . wrapper For Impl ( mo ) ) ; } catch ( e ) { const { target } = records [ 0 ] ; const window = target . _owner Document . _default View ; report Exception ( window , e ) ; } } } } for ( const slot of signal List ) { const slot Change Event = Event . create Impl ( [ "slotchange " , { bubbles : true } ] , { is Trusted : true } ) ; slot . _dispatch ( slot Change Event ) ; } } 
function add Stylesheet ( sheet , element Impl ) { element Impl . _owner Document . style Sheets . push ( sheet ) ; 
function scan For Import Rules ( element Impl , css Rules , base URL ) { if ( ! css Rules ) { return ; } for ( let i = 0 ; i < css Rules . length ; + + i ) { if ( css Rules [ i ] . css Rules ) { 
function get UTCMs ( year , month = 1 , day = 1 , hour = 0 , minute = 0 , second = 0 , millisecond = 0 ) { if ( year > 9 9 | | year < 0 ) { return Date . UTC ( year , month - 1 , day , hour , minute , second , millisecond ) ; } const d = new Date ( 0 ) ; d . set UTCFull Year ( year ) ; d . set UTCMonth ( month - 1 ) ; d . set UTCDate ( day ) ; d . set UTCHours ( hour ) ; d . set UTCMinutes ( minute ) ; d . set UTCSeconds ( second , millisecond ) ; return d . value Of ( ) ; } 
function sammary ( ) { const node Fn = function ( { parent Paths , lang , item , is Dir , result } ) { const nav Title = generate Nav Title ( { parent Paths , item , sign : is Dir ? ' - ' : ' * ' , lang } ) ; result . push ( nav Title ) ; } ; langs . for Each ( dir = > { const SUMMARY = 'SUMMARY .md ' ; const target File = path . join ( docs Dir , ` $ { dir } $ { SUMMARY } ` ) ; const result = walk ( { catalog : doc Config . catalog , lang : dir , result : [ ] , parent Paths : [ ] , fn : node Fn } ) ; if ( result & & result . length ) { result . unshift ( ' # whistle \n ' ) ; fs . write File Sync ( target File , result . join ( ' \n ' ) ) ; } } ) ; } 
function clear Cache ( ) { var overflow = frames . length - MAX _FRAMES _LENGTH ; overflow > 0 & & frames . splice ( 0 , overflow + 6 0 ) ; var len = ids . length ; if ( len < = MAX _LENGTH ) { return ; } var now = Date . now ( ) ; var _ids = [ ] ; var preserve Len = len ; overflow = - 1 ; if ( len > = OVERFLOW _LENGTH ) { overflow = len - MAX _CACHE _SIZE ; preserve Len = len - PRESERVE _LEN ; } for ( var i = 0 ; i < len ; i + + ) { var id = ids [ i ] ; var cur Data = req Data [ id ] ; if ( i > overflow & & ( i > = preserve Len | | ( cur Data . end Time ? now - cur Data . end Time < CACHE _TIME : now - cur Data . start Time < CACHE _TIMEOUT ) ) ) { if ( cur Data . end Time & & cur Data . abort ) { delete cur Data . abort ; } _ids . push ( id ) ; } else { delete req Data [ id ] ; } } ids = _ids ; } 
function format Filter ( filter , client Ip ) { if ( ! filter . url & & ! filter . name & & ! filter . value & & ! filter . ip ) { return ; } var url = util . trim Str ( filter . url ) . to Lower Case ( ) ; var name = util . trim Str ( filter . name ) . to Lower Case ( ) ; var value = util . trim Str ( filter . value ) . to Lower Case ( ) ; var ip = util . trim Str ( filter . ip ) ; var list = [ ] ; if ( ip = = = 'self ' ) { ip = client Ip ; } else if ( ip & & ! net . is IP ( ip ) ) { ip . split ( ' , ' ) . for Each ( function ( item ) { item = item . trim ( ) ; if ( item = = = 'self ' ) { item = client Ip ; } if ( net . is IP ( item ) & & list . index Of ( item ) = = = - 1 ) { list . push ( item ) ; } } ) ; ip = null ; } var result ; if ( url ) { result = { } ; result . url = url ; } if ( name & & value ) { result = result | | { } ; result . name = name ; result . value = value ; } if ( ip ) { result = result | | { } ; result . ip = ip ; } if ( list . length ) { result = result | | { } ; result . ip List = list . slice ( 0 , 1 6 ) ; } return result ; } 
function resolve Inline Values ( str ) { str = str & & str . replace ( CONTROL _RE , ' ' ) . trim ( ) ; if ( ! str | | str . index Of ( ' ` ` ` ' ) = = = - 1 ) { return str ; } return str . replace ( MULTI _LINE _VALUE _RE , function ( _ , _ _ , key , value ) { inline Values = inline Values | | { } ; if ( ! inline Values [ key ] ) { inline Values [ key ] = value ; } return ' ' ; } ) ; } 
function ( message , filename , lineno , colno , error ) { if ( error ) { w Console . error ( get Error Stack ( error , message ) ) ; } else { w Console . error ( 'Error : ' + message + ' ( ' + filename + ' : ' + lineno + ' : ' + ( colno | | 0 ) + ' ) ' + get Page Info ( ) ) ; } } 
function render Child Nodes ( props , from , to ) { var node Type = props . node Type , data = props . data , collection Limit = props . collection Limit , circular Cache = props . circular Cache , key Path = props . key Path , postprocess Value = props . postprocess Value , sort Object Keys = props . sort Object Keys ; var child Nodes = [ ] ; ( 0 , _get Collection Entries 2 [ 'default ' ] ) ( node Type , data , sort Object Keys , collection Limit , from , to ) . for Each ( function ( entry ) { if ( entry . to ) { child Nodes . push ( _react 2 [ 'default ' ] . create Element ( _Item Range 2 [ 'default ' ] , ( 0 , _extends 3 [ 'default ' ] ) ( { } , props , { key : 'Item Range - - ' + entry . from + ' - ' + entry . to , from : entry . from , to : entry . to , render Child Nodes : render Child Nodes } ) ) ) ; } else { var key = entry . key , value = entry . value ; var is Circular = circular Cache . index Of ( value ) ! = = - 1 ; var node = _react 2 [ 'default ' ] . create Element ( _JSONNode 2 [ 'default ' ] , ( 0 , _extends 3 [ 'default ' ] ) ( { } , props , { postprocess Value : postprocess Value , collection Limit : collection Limit } , { key : 'Node - - ' + key , key Path : [ key ] . concat ( key Path ) , value : postprocess Value ( value ) , circular Cache : [ ] . concat ( circular Cache , [ value ] ) , is Circular : is Circular , hide Root : false } ) ) ; if ( node ! = = false ) { child Nodes . push ( node ) ; } } } ) ; return child Nodes ; } 
function create Item String ( data , limit ) { var count = 0 ; var has More = false ; if ( ( 0 , _is Safe Integer 2 [ 'default ' ] ) ( data . size ) ) { count = data . size ; } else { for ( var _iterator = data , _is Array = Array . is Array ( _iterator ) , _i = 0 , _iterator = _is Array ? _iterator : ( 0 , _get Iterator 3 [ 'default ' ] ) ( _iterator ) ; ; ) { var _ref ; if ( _is Array ) { if ( _i > = _iterator . length ) break ; _ref = _iterator [ _i + + ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var entry = _ref ; 
function JSONIterable Node ( _ref 2 ) { var props = ( 0 , _object Without Properties 3 [ 'default ' ] ) ( _ref 2 , [ ] ) ; return _react 2 [ 'default ' ] . create Element ( _JSONNested Node 2 [ 'default ' ] , ( 0 , _extends 3 [ 'default ' ] ) ( { } , props , { node Type : 'Iterable ' , node Type Indicator : ' ( ) ' , create Item String : create Item String } ) ) ; } 
function join ( first , second ) { if ( ! first | | ! second ) { return first + second ; } var first Index = first . index Of ( ' ? ' ) ; var second Index = second . index Of ( ' ? ' ) ; var first Query = ' ' ; var second Query = ' ' ; if ( first Index ! = - 1 ) { first Query = first . substring ( first Index ) ; first = first . substring ( 0 , first Index ) ; } if ( second Index ! = - 1 ) { second Query = second . substring ( second Index ) ; second = second . substring ( 0 , second Index ) ; } var query = first Query & & second Query ? first Query + second Query . substring ( 1 ) : ( first Query | | second Query ) ; if ( second ) { var last Index = first . length - 1 ; var start With Sep = is Path Separator ( second [ 0 ] ) ; if ( is Path Separator ( first [ last Index ] ) ) { first = start With Sep ? first . substring ( 0 , last Index ) + second : first + second ; } else { first = first + ( start With Sep ? ' ' : ' / ' ) + second ; } } return WEB _PROTOCOL _RE . test ( first ) ? format Url ( first + query ) : first + query ; } 
function handle Req ( req , data ) { var method = util . get Method ( data . method | | req . method ) ; req . method = method ; req . timeout = parse Int ( data . timeout , 1 0 ) ; extend ( req . headers , data . headers ) ; if ( typeof data . charset = = 'string ' ) { var type = req . headers [ 'content -type ' ] ; var charset = ' ; charset = ' + data . charset ; if ( typeof type = = 'string ' ) { req . headers [ 'content -type ' ] = type . split ( ' ; ' ) [ 0 ] + charset ; } else { req . headers [ 'content -type ' ] = charset ; } } else { delete data . charset ; } if ( ! util . has Request Body ( method ) ) { delete data . top ; delete data . bottom ; delete data . body ; delete req . headers [ 'content -length ' ] ; } else if ( data . top | | data . bottom | | data . body ) { delete req . headers [ 'content -length ' ] ; } util . is Whistle Transform Data ( data ) & & req . add Zip Transform ( new Whistle Transform ( data ) ) ; } 
function ( id , options ) { options = options | | { } ; if ( typeof id = = = "object " ) { options = id ; } var _this = this ; var class Prefix = this . class Prefix = editormd . class Prefix ; var settings = this . settings = $ . extend ( true , editormd . defaults , options ) ; id = ( typeof id = = = "object " ) ? settings . id : id ; var editor = this . editor = $ ( " # " + id ) ; this . id = id ; this . lang = settings . lang ; var class Names = this . class Names = { textarea : { html : class Prefix + "html -textarea " , markdown : class Prefix + "markdown -textarea " } } ; settings . plugin Path = ( settings . plugin Path = = = " " ) ? settings . path + " . . /plugins / " : settings . plugin Path ; this . state . watching = ( settings . watch ) ? true : false ; if ( ! editor . has Class ( "editormd " ) ) { editor . add Class ( "editormd " ) ; } editor . css ( { width : ( typeof settings . width = = = "number " ) ? settings . width + "px " : settings . width , height : ( typeof settings . height = = = "number " ) ? settings . height + "px " : settings . height } ) ; if ( settings . auto Height ) { editor . css ( "height " , "auto " ) ; } var markdown Textarea = this . markdown Textarea = editor . children ( "textarea " ) ; if ( markdown Textarea . length < 1 ) { editor . append ( " <textarea > < /textarea > " ) ; markdown Textarea = this . markdown Textarea = editor . children ( "textarea " ) ; } markdown Textarea . add Class ( class Names . textarea . markdown ) . attr ( "placeholder " , settings . placeholder ) ; if ( typeof markdown Textarea . attr ( "name " ) = = = "undefined " | | markdown Textarea . attr ( "name " ) = = = " " ) { markdown Textarea . attr ( "name " , ( settings . name ! = = " " ) ? settings . name : id + " -markdown -doc " ) ; } var append Elements = [ ( ! settings . read Only ) ? " <a href = \ "javascript : ; \ " class = \ "fa fa -close " + class Prefix + "preview -close -btn \ " > < /a > " : " " , ( ( settings . save HTMLTo Textarea ) ? " <textarea class = \ " " + class Names . textarea . html + " \ " name = \ " " + id + " -html -code \ " > < /textarea > " : " " ) , " <div class = \ " " + class Prefix + "preview \ " > <div class = \ "markdown -body " + class Prefix + "preview -container \ " > < /div > < /div > " , " <div class = \ " " + class Prefix + "container -mask \ " style = \ "display :block ; \ " > < /div > " , " <div class = \ " " + class Prefix + "mask \ " > < /div > " ] . join ( " \n " ) ; editor . append ( append Elements ) . add Class ( class Prefix + "vertical " ) ; if ( settings . theme ! = = " " ) { editor . add Class ( class Prefix + "theme - " + settings . theme ) ; } this . mask = editor . children ( " . " + class Prefix + "mask " ) ; this . container Mask = editor . children ( " . " + class Prefix + "container -mask " ) ; if ( settings . markdown ! = = " " ) { markdown Textarea . val ( settings . markdown ) ; } if ( settings . append Markdown ! = = " " ) { markdown Textarea . val ( markdown Textarea . val ( ) + settings . append Markdown ) ; } this . html Textarea = editor . children ( " . " + class Names . textarea . html ) ; this . preview = editor . children ( " . " + class Prefix + "preview " ) ; this . preview Container = this . preview . children ( " . " + class Prefix + "preview -container " ) ; if ( settings . preview Theme ! = = " " ) { this . preview . add Class ( class Prefix + "preview -theme - " + settings . preview Theme ) ; } if ( typeof define = = = "function " & & define . amd ) { if ( typeof katex ! = = "undefined " ) { editormd . $katex = katex ; } if ( settings . search Replace & & ! settings . read Only ) { editormd . load CSS ( settings . path + "codemirror /addon /dialog /dialog " ) ; editormd . load CSS ( settings . path + "codemirror /addon /search /matchesonscrollbar " ) ; } } if ( ( typeof define = = = "function " & & define . amd ) | | ! settings . auto Load Modules ) { if ( typeof Code Mirror ! = = "undefined " ) { editormd . $Code Mirror = Code Mirror ; } if ( typeof marked ! = = "undefined " ) { editormd . $marked = marked ; } this . set Code Mirror ( ) . set Toolbar ( ) . loaded Display ( ) ; } else { this . load Queues ( ) ; } return this ; } 
function ( ) { var _this = this ; var settings = this . settings ; var load Path = settings . path ; var load Flow Chart Or Sequence Diagram = function ( ) { if ( editormd . is IE 8 ) { _this . loaded Display ( ) ; return ; } if ( settings . flow Chart | | settings . sequence Diagram ) { editormd . load Script ( load Path + "raphael .min " , function ( ) { editormd . load Script ( load Path + "underscore .min " , function ( ) { if ( ! settings . flow Chart & & settings . sequence Diagram ) { editormd . load Script ( load Path + "sequence -diagram .min " , function ( ) { _this . loaded Display ( ) ; } ) ; } else if ( settings . flow Chart & & ! settings . sequence Diagram ) { editormd . load Script ( load Path + "flowchart .min " , function ( ) { editormd . load Script ( load Path + "jquery .flowchart .min " , function ( ) { _this . loaded Display ( ) ; } ) ; } ) ; } else if ( settings . flow Chart & & settings . sequence Diagram ) { editormd . load Script ( load Path + "flowchart .min " , function ( ) { editormd . load Script ( load Path + "jquery .flowchart .min " , function ( ) { editormd . load Script ( load Path + "sequence -diagram .min " , function ( ) { _this . loaded Display ( ) ; } ) ; } ) ; } ) ; } } ) ; } ) ; } else { _this . loaded Display ( ) ; } } ; editormd . load CSS ( load Path + "codemirror /codemirror .min " ) ; if ( settings . search Replace & & ! settings . read Only ) { editormd . load CSS ( load Path + "codemirror /addon /dialog /dialog " ) ; editormd . load CSS ( load Path + "codemirror /addon /search /matchesonscrollbar " ) ; } if ( settings . code Fold ) { editormd . load CSS ( load Path + "codemirror /addon /fold /foldgutter " ) ; } editormd . load Script ( load Path + "codemirror /codemirror .min " , function ( ) { editormd . $Code Mirror = Code Mirror ; editormd . load Script ( load Path + "codemirror /modes .min " , function ( ) { editormd . load Script ( load Path + "codemirror /addons .min " , function ( ) { _this . set Code Mirror ( ) ; if ( settings . mode ! = = "gfm " & & settings . mode ! = = "markdown " ) { _this . loaded Display ( ) ; return false ; } _this . set Toolbar ( ) ; editormd . load Script ( load Path + "marked .min " , function ( ) { editormd . $marked = marked ; if ( settings . preview Code Highlight ) { editormd . load Script ( load Path + "prettify .min " , function ( ) { load Flow Chart Or Sequence Diagram ( ) ; } ) ; } else { load Flow Chart Or Sequence Diagram ( ) ; } } ) ; } ) ; } ) ; } ) ; return this ; } 
function ( theme ) { var editor = this . editor ; var old Theme = this . settings . theme ; var theme Prefix = this . class Prefix + "theme - " ; editor . remove Class ( theme Prefix + old Theme ) . add Class ( theme Prefix + theme ) ; this . settings . theme = theme ; return this ; } 
function ( theme ) { var settings = this . settings ; settings . editor Theme = theme ; if ( theme ! = = "default " ) { editormd . load CSS ( settings . path + "codemirror /theme / " + settings . editor Theme ) ; } this . cm . set Option ( "theme " , theme ) ; return this ; } 
function ( theme ) { var preview = this . preview ; var old Theme = this . settings . preview Theme ; var theme Prefix = this . class Prefix + "preview -theme - " ; preview . remove Class ( theme Prefix + old Theme ) . add Class ( theme Prefix + theme ) ; this . settings . preview Theme = theme ; return this ; } 
function ( ) { var settings = this . settings ; var editor = this . editor ; if ( settings . editor Theme ! = = "default " ) { editormd . load CSS ( settings . path + "codemirror /theme / " + settings . editor Theme ) ; } var code Mirror Config = { mode : settings . mode , theme : settings . editor Theme , tab Size : settings . tab Size , drag Drop : false , autofocus : settings . auto Focus , auto Close Tags : settings . auto Close Tags , read Only : ( settings . read Only ) ? "nocursor " : false , indent Unit : settings . indent Unit , line Numbers : settings . line Numbers , line Wrapping : settings . line Wrapping , extra Keys : { "Ctrl -Q " : function ( cm ) { cm . fold Code ( cm . get Cursor ( ) ) ; } } , fold Gutter : settings . code Fold , gutters : [ "Code Mirror -linenumbers " , "Code Mirror -foldgutter " ] , match Brackets : settings . match Brackets , indent With Tabs : settings . indent With Tabs , style Active Line : settings . style Active Line , style Selected Text : settings . style Selected Text , auto Close Brackets : settings . auto Close Brackets , show Trailing Space : settings . show Trailing Space , highlight Selection Matches : ( ( ! settings . match Word Highlight ) ? false : { show Token : ( settings . match Word Highlight = = = "onselected " ) ? false : / \w / } ) } ; this . code Editor = this . cm = editormd . $Code Mirror . from Text Area ( this . markdown Textarea [ 0 ] , code Mirror Config ) ; this . code Mirror = this . cm Element = editor . children ( " .Code Mirror " ) ; if ( settings . value ! = = " " ) { this . cm . set Value ( settings . value ) ; } this . code Mirror . css ( { font Size : settings . font Size , width : ( ! settings . watch ) ? " 1 0 0 % " : " 5 0 % " } ) ; if ( settings . auto Height ) { this . code Mirror . css ( "height " , "auto " ) ; this . cm . set Option ( "viewport Margin " , Infinity ) ; } if ( ! settings . line Numbers ) { this . code Mirror . find ( " .Code Mirror -gutters " ) . css ( "border -right " , "none " ) ; } return this ; } 
function ( line ) { var settings = this . settings ; if ( ! settings . goto Line ) { return this ; } var cm = this . cm ; var editor = this . editor ; var count = cm . line Count ( ) ; var preview = this . preview ; if ( typeof line = = = "string " ) { if ( line = = = "last " ) { line = count ; } if ( line = = = "first " ) { line = 1 ; } } if ( typeof line ! = = "number " ) { alert ( "Error : The line number must be an integer . " ) ; return this ; } line = parse Int ( line ) - 1 ; if ( line > count ) { alert ( "Error : The line number range 1 - " + count ) ; return this ; } cm . set Cursor ( { line : line , ch : 0 } ) ; var scroll Info = cm . get Scroll Info ( ) ; var client Height = scroll Info . client Height ; var coords = cm . char Coords ( { line : line , ch : 0 } , "local " ) ; cm . scroll To ( null , ( coords . top + coords . bottom - client Height ) / 2 ) ; if ( settings . watch ) { var cm Scroll = this . code Mirror . find ( " .Code Mirror -scroll " ) [ 0 ] ; var height = $ ( cm Scroll ) . height ( ) ; var scroll Top = cm Scroll . scroll Top ; var percent = ( scroll Top / cm Scroll . scroll Height ) ; if ( scroll Top = = = 0 ) { preview . scroll Top ( 0 ) ; } else if ( scroll Top + height > = cm Scroll . scroll Height - 1 6 ) { preview . scroll Top ( preview [ 0 ] . scroll Height ) ; } else { preview . scroll Top ( preview [ 0 ] . scroll Height * percent ) ; } } cm . focus ( ) ; return this ; } 
function ( ) { if ( typeof arguments [ 1 ] ! = = "undefined " ) { if ( typeof arguments [ 1 ] = = = "function " ) { arguments [ 1 ] = $ . proxy ( arguments [ 1 ] , this ) ; } this [ arguments [ 0 ] ] = arguments [ 1 ] ; } if ( typeof arguments [ 0 ] = = = "object " & & typeof arguments [ 0 ] . length = = = "undefined " ) { $ . extend ( true , this , arguments [ 0 ] ) ; } return this ; } 
function ( key , value ) { var settings = this . settings ; if ( typeof key = = = "object " ) { settings = $ . extend ( true , settings , key ) ; } if ( typeof key = = = "string " ) { settings [ key ] = value ; } this . settings = settings ; this . recreate ( ) ; return this ; } 
function ( event Type , callback ) { var settings = this . settings ; if ( typeof settings [ "on " + event Type ] ! = = "undefined " ) { settings [ "on " + event Type ] = $ . proxy ( callback , this ) ; } return this ; } 
function ( callback ) { var settings = this . settings ; if ( settings . read Only ) { return this ; } if ( settings . toolbar & & ( this . toolbar . length < 1 | | this . toolbar . find ( " . " + this . class Prefix + "menu " ) . html ( ) = = = " " ) ) { this . set Toolbar ( ) ; } settings . toolbar = true ; this . toolbar . show ( ) ; this . resize ( ) ; $ . proxy ( callback | | function ( ) { } , this ) ( ) ; return this ; } 
function ( callback ) { var settings = this . settings ; settings . toolbar = false ; this . toolbar . hide ( ) ; this . resize ( ) ; $ . proxy ( callback | | function ( ) { } , this ) ( ) ; return this ; } 
function ( fixed ) { var state = this . state ; var editor = this . editor ; var toolbar = this . toolbar ; var settings = this . settings ; if ( typeof fixed ! = = "undefined " ) { settings . toolbar Auto Fixed = fixed ; } var auto Fixed Handle = function ( ) { var $window = $ ( window ) ; var top = $window . scroll Top ( ) ; if ( ! settings . toolbar Auto Fixed ) { return false ; } if ( top - editor . offset ( ) . top > 1 0 & & top < editor . height ( ) ) { toolbar . css ( { position : "fixed " , width : editor . width ( ) + "px " , left : ( $window . width ( ) - editor . width ( ) ) / 2 + "px " } ) ; } else { toolbar . css ( { position : "absolute " , width : " 1 0 0 % " , left : 0 } ) ; } } ; if ( ! state . fullscreen & & ! state . preview & & settings . toolbar & & settings . toolbar Auto Fixed ) { $ ( window ) . bind ( "scroll " , auto Fixed Handle ) ; } return this ; } 
function ( ) { var settings = this . settings ; if ( settings . read Only ) { return this ; } var editor = this . editor ; var preview = this . preview ; var class Prefix = this . class Prefix ; var toolbar = this . toolbar = editor . children ( " . " + class Prefix + "toolbar " ) ; if ( settings . toolbar & & toolbar . length < 1 ) { var toolbar HTML = " <div class = \ " " + class Prefix + "toolbar \ " > <div class = \ " " + class Prefix + "toolbar -container \ " > <ul class = \ " " + class Prefix + "menu \ " > < /ul > < /div > < /div > " ; editor . append ( toolbar HTML ) ; toolbar = this . toolbar = editor . children ( " . " + class Prefix + "toolbar " ) ; } if ( ! settings . toolbar ) { toolbar . hide ( ) ; return this ; } toolbar . show ( ) ; var icons = ( typeof settings . toolbar Icons = = = "function " ) ? settings . toolbar Icons ( ) : ( ( typeof settings . toolbar Icons = = = "string " ) ? editormd . toolbar Modes [ settings . toolbar Icons ] : settings . toolbar Icons ) ; var toolbar Menu = toolbar . find ( " . " + this . class Prefix + "menu " ) , menu = " " ; var pull Right = false ; for ( var i = 0 , len = icons . length ; i < len ; i + + ) { var name = icons [ i ] ; if ( name = = = " | | " ) { pull Right = true ; } else if ( name = = = " | " ) { menu + = " <li class = \ "divider \ " unselectable = \ "on \ " > | < /li > " ; } else { var is Header = ( / h ( \d ) / . test ( name ) ) ; var index = name ; if ( name = = = "watch " & & ! settings . watch ) { index = "unwatch " ; } var title = settings . lang . toolbar [ index ] ; var icon Texts = settings . toolbar Icon Texts [ index ] ; var icon Class = settings . toolbar Icons Class [ index ] ; title = ( typeof title = = = "undefined " ) ? " " : title ; icon Texts = ( typeof icon Texts = = = "undefined " ) ? " " : icon Texts ; icon Class = ( typeof icon Class = = = "undefined " ) ? " " : icon Class ; var menu Item = pull Right ? " <li class = \ "pull -right \ " > " : " <li > " ; if ( typeof settings . toolbar Custom Icons [ name ] ! = = "undefined " & & typeof settings . toolbar Custom Icons [ name ] ! = = "function " ) { menu Item + = settings . toolbar Custom Icons [ name ] ; } else { menu Item + = " <a href = \ "javascript : ; \ " title = \ " " + title + " \ " unselectable = \ "on \ " > " ; menu Item + = " <i class = \ "fa " + icon Class + " \ " name = \ " " + name + " \ " unselectable = \ "on \ " > " + ( ( is Header ) ? name . to Upper Case ( ) : ( ( icon Class = = = " " ) ? icon Texts : " " ) ) + " < /i > " ; menu Item + = " < /a > " ; } menu Item + = " < /li > " ; menu = pull Right ? menu Item + menu : menu + menu Item ; } } toolbar Menu . html ( menu ) ; toolbar Menu . find ( " [title = \ "Lowercase \ " ] " ) . attr ( "title " , settings . lang . toolbar . lowercase ) ; toolbar Menu . find ( " [title = \ "ucwords \ " ] " ) . attr ( "title " , settings . lang . toolbar . ucwords ) ; this . set Toolbar Handler ( ) ; this . set Toolbar Auto Fixed ( ) ; return this ; } 
function ( ) { var _this = this ; var settings = this . settings ; if ( ! settings . toolbar | | settings . read Only ) { return this ; } var toolbar = this . toolbar ; var cm = this . cm ; var class Prefix = this . class Prefix ; var toolbar Icons = this . toolbar Icons = toolbar . find ( " . " + class Prefix + "menu > li > a " ) ; var toolbar Icon Handlers = this . get Toolbar Handles ( ) ; toolbar Icons . bind ( editormd . mouse Or Touch ( "click " , "touchend " ) , function ( event ) { var icon = $ ( this ) . children ( " .fa " ) ; var name = icon . attr ( "name " ) ; var cursor = cm . get Cursor ( ) ; var selection = cm . get Selection ( ) ; if ( name = = = " " ) { return ; } _this . active Icon = icon ; if ( typeof toolbar Icon Handlers [ name ] ! = = "undefined " ) { $ . proxy ( toolbar Icon Handlers [ name ] , _this ) ( cm ) ; } else { if ( typeof settings . toolbar Handlers [ name ] ! = = "undefined " ) { $ . proxy ( settings . toolbar Handlers [ name ] , _this ) ( cm , icon , cursor , selection ) ; } } if ( name ! = = "link " & & name ! = = "reference -link " & & name ! = = "image " & & name ! = = "code -block " & & name ! = = "preformatted -text " & & name ! = = "watch " & & name ! = = "preview " & & name ! = = "search " & & name ! = = "fullscreen " & & name ! = = "info " ) { cm . focus ( ) ; } return false ; } ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var class Prefix = this . class Prefix ; var info Dialog HTML = [ " <div class = \ " " + class Prefix + "dialog " + class Prefix + "dialog -info \ " style = \ " \ " > " , " <div class = \ " " + class Prefix + "dialog -container \ " > " , " <h 1 > <i class = \ "editormd -logo editormd -logo -lg editormd -logo -color \ " > < /i > " + editormd . title + " <small >v " + editormd . version + " < /small > < /h 1 > " , " <p > " + this . lang . description + " < /p > " , " <p style = \ "margin : 1 0px 0 2 0px 0 ; \ " > <a href = \ " " + editormd . home Page + " \ " target = \ " _blank \ " > " + editormd . home Page + " <i class = \ "fa fa -external -link \ " > < /i > < /a > < /p > " , " <p style = \ "font -size : 0 . 8 5em ; \ " >Copyright &copy ; 2 0 1 5 <a href = \ "https : 
function ( ) { var info Dialog = this . info Dialog ; var _info Dialog Position = function ( ) { info Dialog . css ( { top : ( $ ( window ) . height ( ) - info Dialog . height ( ) ) / 2 + "px " , left : ( $ ( window ) . width ( ) - info Dialog . width ( ) ) / 2 + "px " } ) ; } ; _info Dialog Position ( ) ; $ ( window ) . resize ( _info Dialog Position ) ; return this ; } 
function ( ) { $ ( "html ,body " ) . css ( "overflow -x " , "hidden " ) ; var _this = this ; var editor = this . editor ; var settings = this . settings ; var info Dialog = this . info Dialog = editor . children ( " . " + this . class Prefix + "dialog -info " ) ; if ( info Dialog . length < 1 ) { this . create Info Dialog ( ) ; } this . lock Screen ( true ) ; this . mask . css ( { opacity : settings . dialog Mask Opacity , background Color : settings . dialog Mask Bg Color } ) . show ( ) ; info Dialog . css ( "z -index " , editormd . dialog Zindex ) . show ( ) ; this . info Dialog Position ( ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var settings = this . settings ; this . code Mirror . remove ( ) ; this . set Code Mirror ( ) ; if ( ! settings . read Only ) { if ( editor . find ( " .editormd -dialog " ) . length > 0 ) { editor . find ( " .editormd -dialog " ) . remove ( ) ; } if ( settings . toolbar ) { this . get Toolbar Handles ( ) ; this . set Toolbar ( ) ; } } this . loaded Display ( true ) ; return this ; } 
function ( ) { var settings = this . settings ; var preview Container = this . preview Container ; if ( settings . preview Code Highlight ) { preview Container . find ( "pre " ) . add Class ( "prettyprint linenums " ) ; if ( typeof pretty Print ! = = "undefined " ) { pretty Print ( ) ; } } return this ; } 
function ( ) { if ( timer = = = null ) { return this ; } this . preview Container . find ( " . " + editormd . class Names . tex ) . each ( function ( ) { var tex = $ ( this ) ; editormd . $katex . render ( tex . text ( ) , tex [ 0 ] ) ; tex . find ( " .katex " ) . css ( "font -size " , " 1 . 6em " ) ; } ) ; return this ; } 
function ( ) { var $this = this ; var settings = this . settings ; var preview Container = this . preview Container ; if ( editormd . is IE 8 ) { return this ; } if ( settings . flow Chart ) { if ( flowchart Timer = = = null ) { return this ; } preview Container . find ( " .flowchart " ) . flow Chart ( ) ; } if ( settings . sequence Diagram ) { preview Container . find ( " .sequence -diagram " ) . sequence Diagram ( { theme : "simple " } ) ; } var preview = $this . preview ; var code Mirror = $this . code Mirror ; var code View = code Mirror . find ( " .Code Mirror -scroll " ) ; var height = code View . height ( ) ; var scroll Top = code View . scroll Top ( ) ; var percent = ( scroll Top / code View [ 0 ] . scroll Height ) ; var toc Height = 0 ; preview . find ( " .markdown -toc -list " ) . each ( function ( ) { toc Height + = $ ( this ) . height ( ) ; } ) ; var toc Menu Height = preview . find ( " .editormd -toc -menu " ) . height ( ) ; toc Menu Height = ( ! toc Menu Height ) ? 0 : toc Menu Height ; if ( scroll Top = = = 0 ) { preview . scroll Top ( 0 ) ; } else if ( scroll Top + height > = code View [ 0 ] . scroll Height - 1 6 ) { preview . scroll Top ( preview [ 0 ] . scroll Height ) ; } else { preview . scroll Top ( ( preview [ 0 ] . scroll Height + toc Height + toc Menu Height ) * percent ) ; } return this ; } 
function ( key Map ) { var _this = this ; var cm = this . cm ; var settings = this . settings ; var toolbar Handlers = editormd . toolbar Handlers ; var disabled Key Maps = settings . disabled Key Maps ; key Map = key Map | | null ; if ( key Map ) { for ( var i in key Map ) { if ( $ . in Array ( i , disabled Key Maps ) < 0 ) { var map = { } ; map [ i ] = key Map [ i ] ; cm . add Key Map ( key Map ) ; } } } else { for ( var k in editormd . key Maps ) { var _key Map = editormd . key Maps [ k ] ; var handle = ( typeof _key Map = = = "string " ) ? $ . proxy ( toolbar Handlers [ _key Map ] , _this ) : $ . proxy ( _key Map , _this ) ; if ( $ . in Array ( k , [ "F 9 " , "F 1 0 " , "F 1 1 " ] ) < 0 & & $ . in Array ( k , disabled Key Maps ) < 0 ) { var _map = { } ; _map [ k ] = handle ; cm . add Key Map ( _map ) ; } } $ ( window ) . keydown ( function ( event ) { var keymaps = { " 1 2 0 " : "F 9 " , " 1 2 1 " : "F 1 0 " , " 1 2 2 " : "F 1 1 " } ; if ( $ . in Array ( keymaps [ event . key Code ] , disabled Key Maps ) < 0 ) { switch ( event . key Code ) { case 1 2 0 : $ . proxy ( toolbar Handlers [ "watch " ] , _this ) ( ) ; return false ; break ; case 1 2 1 : $ . proxy ( toolbar Handlers [ "preview " ] , _this ) ( ) ; return false ; break ; case 1 2 2 : $ . proxy ( toolbar Handlers [ "fullscreen " ] , _this ) ( ) ; return false ; break ; default : break ; } } } ) ; } return this ; } 
function ( ) { var _this = this ; var preview = this . preview ; var settings = this . settings ; var code Mirror = this . code Mirror ; var mouse Or Touch = editormd . mouse Or Touch ; if ( ! settings . sync Scrolling ) { return this ; } var cm Bind Scroll = function ( ) { code Mirror . find ( " .Code Mirror -scroll " ) . bind ( mouse Or Touch ( "scroll " , "touchmove " ) , function ( event ) { var height = $ ( this ) . height ( ) ; var scroll Top = $ ( this ) . scroll Top ( ) ; var percent = ( scroll Top / $ ( this ) [ 0 ] . scroll Height ) ; var toc Height = 0 ; preview . find ( " .markdown -toc -list " ) . each ( function ( ) { toc Height + = $ ( this ) . height ( ) ; } ) ; var toc Menu Height = preview . find ( " .editormd -toc -menu " ) . height ( ) ; toc Menu Height = ( ! toc Menu Height ) ? 0 : toc Menu Height ; if ( scroll Top = = = 0 ) { preview . scroll Top ( 0 ) ; } else if ( scroll Top + height > = $ ( this ) [ 0 ] . scroll Height - 1 6 ) { preview . scroll Top ( preview [ 0 ] . scroll Height ) ; } else { preview . scroll Top ( ( preview [ 0 ] . scroll Height + toc Height + toc Menu Height ) * percent ) ; } $ . proxy ( settings . onscroll , _this ) ( event ) ; } ) ; } ; var cm Unbind Scroll = function ( ) { code Mirror . find ( " .Code Mirror -scroll " ) . unbind ( mouse Or Touch ( "scroll " , "touchmove " ) ) ; } ; var preview Bind Scroll = function ( ) { preview . bind ( mouse Or Touch ( "scroll " , "touchmove " ) , function ( event ) { var height = $ ( this ) . height ( ) ; var scroll Top = $ ( this ) . scroll Top ( ) ; var percent = ( scroll Top / $ ( this ) [ 0 ] . scroll Height ) ; var code View = code Mirror . find ( " .Code Mirror -scroll " ) ; if ( scroll Top = = = 0 ) { code View . scroll Top ( 0 ) ; } else if ( scroll Top + height > = $ ( this ) [ 0 ] . scroll Height ) { code View . scroll Top ( code View [ 0 ] . scroll Height ) ; } else { code View . scroll Top ( code View [ 0 ] . scroll Height * percent ) ; } $ . proxy ( settings . onpreviewscroll , _this ) ( event ) ; } ) ; } ; var preview Unbind Scroll = function ( ) { preview . unbind ( mouse Or Touch ( "scroll " , "touchmove " ) ) ; } ; code Mirror . bind ( { mouseover : cm Bind Scroll , mouseout : cm Unbind Scroll , touchstart : cm Bind Scroll , touchend : cm Unbind Scroll } ) ; if ( settings . sync Scrolling = = = "single " ) { return this ; } preview . bind ( { mouseover : preview Bind Scroll , mouseout : preview Unbind Scroll , touchstart : preview Bind Scroll , touchend : preview Unbind Scroll } ) ; return this ; } 
function ( recreate ) { recreate = recreate | | false ; var _this = this ; var editor = this . editor ; var preview = this . preview ; var settings = this . settings ; this . container Mask . hide ( ) ; this . save ( ) ; if ( settings . watch ) { preview . show ( ) ; } editor . data ( "old Width " , editor . width ( ) ) . data ( "old Height " , editor . height ( ) ) ; / /    Zepto this . resize ( ) ; this . register Key Maps ( ) ; $ ( window ) . resize ( function ( ) { _this . resize ( ) ; } ) ; this . bind Scroll Event ( ) . bind Change Event ( ) ; if ( ! recreate ) { $ . proxy ( settings . onload , this ) ( ) ; } this . state . loaded = true ; return this ; } 
function ( width , height ) { width = width | | null ; height = height | | null ; var state = this . state ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var code Mirror = this . code Mirror ; if ( width ) { editor . css ( "width " , ( typeof width = = = "number " ) ? width + "px " : width ) ; } if ( settings . auto Height & & ! state . fullscreen & & ! state . preview ) { editor . css ( "height " , "auto " ) ; code Mirror . css ( "height " , "auto " ) ; } else { if ( height ) { editor . css ( "height " , ( typeof height = = = "number " ) ? height + "px " : height ) ; } if ( state . fullscreen ) { editor . height ( $ ( window ) . height ( ) ) ; } if ( settings . toolbar & & ! settings . read Only ) { code Mirror . css ( "margin -top " , toolbar . height ( ) + 1 ) . height ( editor . height ( ) - toolbar . height ( ) ) ; } else { code Mirror . css ( "margin -top " , 0 ) . height ( editor . height ( ) ) ; } } if ( settings . watch ) { code Mirror . width ( editor . width ( ) / 2 ) ; preview . width ( ( ! state . preview ) ? editor . width ( ) / 2 : editor . width ( ) ) ; this . preview Container . css ( "padding " , settings . auto Height ? " 2 0px 2 0px 5 0px 4 0px " : " 2 0px " ) ; if ( settings . toolbar & & ! settings . read Only ) { preview . css ( "top " , toolbar . height ( ) + 1 ) ; } else { preview . css ( "top " , 0 ) ; } if ( settings . auto Height & & ! state . fullscreen & & ! state . preview ) { preview . height ( " " ) ; } else { var preview Height = ( settings . toolbar & & ! settings . read Only ) ? editor . height ( ) - toolbar . height ( ) : editor . height ( ) ; preview . height ( preview Height ) ; } } else { code Mirror . width ( editor . width ( ) ) ; preview . hide ( ) ; } if ( state . loaded ) { $ . proxy ( settings . onresize , this ) ( ) ; } return this ; } 
function ( ) { if ( timer = = = null ) { return this ; } var _this = this ; var state = this . state ; var settings = this . settings ; var cm = this . cm ; var cm Value = cm . get Value ( ) ; var preview Container = this . preview Container ; if ( settings . mode ! = = "gfm " & & settings . mode ! = = "markdown " ) { this . markdown Textarea . val ( cm Value ) ; return this ; } var marked = editormd . $marked ; var markdown To C = this . markdown To C = [ ] ; var renderer Options = this . marked Renderer Options = { toc : settings . toc , tocm : settings . tocm , toc Start Level : settings . toc Start Level , page Break : settings . page Break , task List : settings . task List , emoji : settings . emoji , tex : settings . tex , at Link : settings . at Link , / / for @link email Link : settings . email Link , / / for mail address auto link flow Chart : settings . flow Chart , sequence Diagram : settings . sequence Diagram , preview Code Highlight : settings . preview Code Highlight , } ; var marked Options = this . marked Options = { renderer : editormd . marked Renderer ( markdown To C , renderer Options ) , gfm : true , tables : true , breaks : true , pedantic : false , sanitize : ( settings . html Decode ) ? false : true , / /    HTML        HTML      false smart Lists : true , smartypants : true } ; marked . set Options ( marked Options ) ; var new Markdown Doc = editormd . $marked ( cm Value , marked Options ) ; / /console .info ( "cm Value " , cm Value , new Markdown Doc ) ; new Markdown Doc = editormd . filter HTMLTags ( new Markdown Doc , settings . html Decode ) ; / /console .error ( "cm Value " , cm Value , new Markdown Doc ) ; this . markdown Textarea . text ( cm Value ) ; cm . save ( ) ; if ( settings . save HTMLTo Textarea ) { this . html Textarea . text ( new Markdown Doc ) ; } if ( settings . watch | | ( ! settings . watch & & state . preview ) ) { preview Container . html ( new Markdown Doc ) ; this . preview Code Highlight ( ) ; if ( settings . toc ) { var toc Container = ( settings . toc Container = = = " " ) ? preview Container : $ ( settings . toc Container ) ; var toc Menu = toc Container . find ( " . " + this . class Prefix + "toc -menu " ) ; toc Container . attr ( "preview Container " , ( settings . toc Container = = = " " ) ? "true " : "false " ) ; if ( settings . toc Container ! = = " " & & toc Menu . length > 0 ) { toc Menu . remove ( ) ; } editormd . markdown To CRenderer ( markdown To C , toc Container , settings . toc Dropdown , settings . toc Start Level ) ; if ( settings . toc Dropdown | | toc Container . find ( " . " + this . class Prefix + "toc -menu " ) . length > 0 ) { editormd . toc Dropdown Menu ( toc Container , ( settings . toc Title ! = = " " ) ? settings . toc Title : this . lang . toc Title ) ; } if ( settings . toc Container ! = = " " ) { preview Container . find ( " .markdown -toc " ) . css ( "border " , "none " ) ; } } if ( settings . tex ) { if ( ! editormd . ka Te XLoaded & & settings . auto Load Modules ) { editormd . load Ka Te X ( function ( ) { editormd . $katex = katex ; editormd . ka Te XLoaded = true ; _this . katex Render ( ) ; } ) ; } else { editormd . $katex = katex ; this . katex Render ( ) ; } } if ( settings . flow Chart | | settings . sequence Diagram ) { flowchart Timer = set Timeout ( function ( ) { clear Timeout ( flowchart Timer ) ; _this . flow Chart And Sequence Diagram Render ( ) ; flowchart Timer = null ; } , 1 0 ) ; } if ( state . loaded ) { $ . proxy ( settings . onchange , this ) ( ) ; } } return this ; } 
function ( md ) { var settings = this . settings ; var cm = this . cm ; cm . set Value ( cm . get Value ( ) + md ) ; return this ; } 
function ( callback ) { var settings = this . settings ; if ( $ . in Array ( settings . mode , [ "gfm " , "markdown " ] ) < 0 ) { return this ; } this . state . watching = settings . watch = true ; this . preview . show ( ) ; if ( this . toolbar ) { var watch Icon = settings . toolbar Icons Class . watch ; var un Watch Icon = settings . toolbar Icons Class . unwatch ; var icon = this . toolbar . find ( " .fa [name =watch ] " ) ; icon . parent ( ) . attr ( "title " , settings . lang . toolbar . watch ) ; icon . remove Class ( un Watch Icon ) . add Class ( watch Icon ) ; } this . code Mirror . css ( "border -right " , " 1px solid #ddd " ) . width ( this . editor . width ( ) / 2 ) ; timer = 0 ; this . save ( ) . resize ( ) ; if ( ! settings . onwatch ) { settings . onwatch = callback | | function ( ) { } ; } $ . proxy ( settings . onwatch , this ) ( ) ; return this ; } 
function ( callback ) { var settings = this . settings ; this . state . watching = settings . watch = false ; this . preview . hide ( ) ; if ( this . toolbar ) { var watch Icon = settings . toolbar Icons Class . watch ; var un Watch Icon = settings . toolbar Icons Class . unwatch ; var icon = this . toolbar . find ( " .fa [name =watch ] " ) ; icon . parent ( ) . attr ( "title " , settings . lang . toolbar . unwatch ) ; icon . remove Class ( watch Icon ) . add Class ( un Watch Icon ) ; } this . code Mirror . css ( "border -right " , "none " ) . width ( this . editor . width ( ) ) ; this . resize ( ) ; if ( ! settings . onunwatch ) { settings . onunwatch = callback | | function ( ) { } ; } $ . proxy ( settings . onunwatch , this ) ( ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var code Mirror = this . code Mirror ; var preview Container = this . preview Container ; if ( $ . in Array ( settings . mode , [ "gfm " , "markdown " ] ) < 0 ) { return this ; } if ( settings . toolbar & & toolbar ) { toolbar . toggle ( ) ; toolbar . find ( " .fa [name =preview ] " ) . toggle Class ( "active " ) ; } code Mirror . toggle ( ) ; var esc Handle = function ( event ) { if ( event . shift Key & & event . key Code = = = 2 7 ) { _this . previewed ( ) ; } } ; if ( code Mirror . css ( "display " ) = = = "none " ) / /    Zepto     code Mirror .is ( " :hidden " ) { this . state . preview = true ; if ( this . state . fullscreen ) { preview . css ( "background " , " #fff " ) ; } editor . find ( " . " + this . class Prefix + "preview -close -btn " ) . show ( ) . bind ( editormd . mouse Or Touch ( "click " , "touchend " ) , function ( ) { _this . previewed ( ) ; } ) ; if ( ! settings . watch ) { this . save ( ) ; } else { preview Container . css ( "padding " , " " ) ; } preview Container . add Class ( this . class Prefix + "preview -active " ) ; preview . show ( ) . css ( { position : " " , top : 0 , width : editor . width ( ) , height : ( settings . auto Height & & ! this . state . fullscreen ) ? "auto " : editor . height ( ) } ) ; if ( this . state . loaded ) { $ . proxy ( settings . onpreviewing , this ) ( ) ; } $ ( window ) . bind ( "keyup " , esc Handle ) ; } else { $ ( window ) . unbind ( "keyup " , esc Handle ) ; this . previewed ( ) ; } } 
function ( ) { var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var preview Container = this . preview Container ; var preview Close Btn = editor . find ( " . " + this . class Prefix + "preview -close -btn " ) ; this . state . preview = false ; this . code Mirror . show ( ) ; if ( settings . toolbar ) { toolbar . show ( ) ; } preview [ ( settings . watch ) ? "show " : "hide " ] ( ) ; preview Close Btn . hide ( ) . unbind ( editormd . mouse Or Touch ( "click " , "touchend " ) ) ; preview Container . remove Class ( this . class Prefix + "preview -active " ) ; if ( settings . watch ) { preview Container . css ( "padding " , " 2 0px " ) ; } preview . css ( { background : null , position : "absolute " , width : editor . width ( ) / 2 , height : ( settings . auto Height & & ! this . state . fullscreen ) ? "auto " : editor . height ( ) - toolbar . height ( ) , top : ( settings . toolbar ) ? toolbar . height ( ) : 0 } ) ; if ( this . state . loaded ) { $ . proxy ( settings . onpreviewed , this ) ( ) ; } return this ; } 
function ( ) { var _this = this ; var state = this . state ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var fullscreen Class = this . class Prefix + "fullscreen " ; if ( toolbar ) { toolbar . find ( " .fa [name =fullscreen ] " ) . parent ( ) . toggle Class ( "active " ) ; } var esc Handle = function ( event ) { if ( ! event . shift Key & & event . key Code = = = 2 7 ) { if ( state . fullscreen ) { _this . fullscreen Exit ( ) ; } } } ; if ( ! editor . has Class ( fullscreen Class ) ) { state . fullscreen = true ; $ ( "html ,body " ) . css ( "overflow " , "hidden " ) ; editor . css ( { width : $ ( window ) . width ( ) , height : $ ( window ) . height ( ) } ) . add Class ( fullscreen Class ) ; this . resize ( ) ; $ . proxy ( settings . onfullscreen , this ) ( ) ; $ ( window ) . bind ( "keyup " , esc Handle ) ; } else { $ ( window ) . unbind ( "keyup " , esc Handle ) ; this . fullscreen Exit ( ) ; } return this ; } 
function ( ) { var editor = this . editor ; var settings = this . settings ; var toolbar = this . toolbar ; var fullscreen Class = this . class Prefix + "fullscreen " ; this . state . fullscreen = false ; if ( toolbar ) { toolbar . find ( " .fa [name =fullscreen ] " ) . parent ( ) . remove Class ( "active " ) ; } $ ( "html ,body " ) . css ( "overflow " , " " ) ; editor . css ( { width : editor . data ( "old Width " ) , height : editor . data ( "old Height " ) } ) . remove Class ( fullscreen Class ) ; this . resize ( ) ; $ . proxy ( settings . onfullscreen Exit , this ) ( ) ; return this ; } 
function ( name , path ) { var _this = this ; var cm = this . cm ; var settings = this . settings ; path = settings . plugin Path + path ; if ( typeof define = = = "function " ) { if ( typeof this [ name ] = = = "undefined " ) { alert ( "Error : " + name + " plugin is not found , you are not load this plugin . " ) ; return this ; } this [ name ] ( cm ) ; return this ; } if ( $ . in Array ( path , editormd . load Files . plugin ) < 0 ) { editormd . load Plugin ( path , function ( ) { editormd . load Plugins [ name ] = _this [ name ] ; _this [ name ] ( cm ) ; } ) ; } else { $ . proxy ( editormd . load Plugins [ name ] , this ) ( cm ) ; } return this ; } 
function ( command ) { var settings = this . settings ; if ( ! settings . search Replace ) { alert ( "Error : settings .search Replace = = false " ) ; return this ; } if ( ! settings . read Only ) { this . cm . exec Command ( command | | "find " ) ; } return this ; } 
function kw ( name , options = { } ) { options . keyword = name return keywords [ name ] = new Token Type ( name , options ) } 
function is In Astral Set ( code , set ) { let pos = 0x 1 0 0 0 0 for ( let i = 0 ; i < set . length ; i + = 2 ) { pos + = set [ i ] if ( pos > code ) return false pos + = set [ i + 1 ] if ( pos > = code ) return true } } 
function transform Metadata ( metadata ) { const names Reg Ex = new Reg Exp ( metadata . tokens . map ( token = > token . name ) . join ( ' | ' ) , 'g ' ) ; const replace Map = { } ; metadata . tokens . map ( token = > { replace Map [ token . name ] = format Token Name ( token . name ) ; } ) ; metadata . tokens . for Each ( ( token , i ) = > { 
async function find Package For ( filepath ) { let directory = filepath ; while ( directory ! = = ' / ' ) { const directory To Search = path . dirname ( directory ) ; const files = await fs . readdir ( directory To Search ) ; if ( files . index Of ( 'package .json ' ) ! = = - 1 ) { const package Json = await fs . read Json ( path . join ( directory To Search , 'package .json ' ) ) ; return package Json . name ; } directory = path . resolve ( directory , ' . . ' ) ; } throw new Error ( ` $ { filepath } ` ) ; } 
function svg Toggle Class ( svg , name , force Add ) { const list = svg . get Attribute ( 'class ' ) . trim ( ) . split ( / \s + / ) ; const unique List = Object . keys ( list . reduce ( ( o , item ) = > Object . assign ( o , { [ item ] : 1 } ) , { } ) ) ; const index = unique List . index Of ( name ) ; const found = index > = 0 ; const add = force Add = = = undefined ? ! found : force Add ; if ( found = = = ! add ) { if ( add ) { unique List . push ( name ) ; } else { unique List . splice ( index , 1 ) ; } svg . set Attribute ( 'class ' , unique List . join ( ' ' ) ) ; } } 
function clean Args ( command ) { return command . options . reduce ( ( acc , option ) = > { 
async function flat Map Async ( source , map Fn ) { const results = await Promise . all ( source . map ( map Fn ) ) ; return results . reduce ( ( acc , result ) = > acc . concat ( result ) , [ ] ) ; } 
async function create Json ( source Dir , config ) { config = config | | { } ; return sassdoc . parse ( source Dir , config ) . then ( data = > { return data ; } , err = > { console . error ( err ) ; } ) ; } 
function dedupe Array ( arr ) { return arr . reduce ( ( p , item ) = > { const type = item . type | | item . context . type ; const name = item . name | | item . context . name ; const id = [ type , name ] . join ( ' | ' ) ; if ( p . temp . index Of ( id ) = = = - 1 ) { p . out . push ( item ) ; p . temp . push ( id ) ; } return p ; } , { temp : [ ] , out : [ ] } ) . out ; } 
function create Anchor Link ( name , heading ) { const anchor Link = heading . to Lower Case ( ) . replace ( / / g , ' - ' ) . replace ( / [ ` ~ ! @ # $ % ^ & * ( ) + = < > ? , . / : ; " ' | { } \ [ \ ] \ \   ] /g , ' ' ) . replace ( / [                                    ] /g , ' ' ) ; return ` $ { name } $ { anchor Link } ` ; } 
function create Markdown Item ( item ) { let str = ' ' ; if ( ! item . context ) return ' ' ; let status = item . access = = = 'public ' ? '  ' : ' ' ; if ( item . deprecated | | item . deprecated = = = ' ' ) { status + = '   ' ; } 
async function create Markdown ( source Dir , config ) { config = config | | { } ; return sassdoc . parse ( source Dir , config ) . then ( data = > { let markdown File = ' ' ; const documented Items = data . filter ( ( item , index ) = > item . access = = = 'public ' | | item . access = = = 'private ' ) ; markdown File + = ` ` ; let current Group = ' ' ; documented Items . for Each ( item = > { const item Group = create Group Name ( item . group ) ; if ( item Group ! = = current Group ) { markdown File + = ` \n \n $ { item Group } ` ; current Group = item Group ; } markdown File + = create Markdown Item ( item ) ; } ) ; return prettier . format ( toc . insert ( markdown File , { slugify } ) , prettier Options ) ; } , err = > { console . error ( err ) ; } ) ; } 
async function main ( ) { reporter . info ( 'Building examples . . . ' ) ; await fs . remove ( BUILD _DIR ) ; await fs . ensure Dir ( BUILD _DIR ) ; const package Names = await fs . readdir ( PACKAGES _DIR ) ; const packages = await Promise . all ( package Names . map ( async name = > { 
function flatten Options ( options ) { const o = { } ; 
function append ( str , prefix = ' ' ) { const item = document . create Element ( 'li ' ) ; item . text Content = prefix + str ; list . append Child ( item ) ; } 
function multires Node Sort ( a , b ) { 
function multires Node Render Sort ( a , b ) { 
function multires Draw ( ) { if ( ! program . draw In Progress ) { program . draw In Progress = true ; gl . clear ( gl . COLOR _BUFFER _BIT ) ; for ( var i = 0 ; i < program . current Nodes . length ; i + + ) { if ( program . current Nodes [ i ] . texture Loaded > 1 ) { 
function Multires Node ( vertices , side , level , x , y , path ) { this . vertices = vertices ; this . side = side ; this . level = level ; this . x = x ; this . y = y ; this . path = path . replace ( ' %s ' , side ) . replace ( ' %l ' , level ) . replace ( ' %x ' , x ) . replace ( ' %y ' , y ) ; } 
function rotate Matrix ( m , angle , axis ) { var s = Math . sin ( angle ) ; var c = Math . cos ( angle ) ; if ( axis = = 'x ' ) { return [ m [ 0 ] , c * m [ 1 ] + s * m [ 2 ] , c * m [ 2 ] - s * m [ 1 ] , m [ 3 ] , c * m [ 4 ] + s * m [ 5 ] , c * m [ 5 ] - s * m [ 4 ] , m [ 6 ] , c * m [ 7 ] + s * m [ 8 ] , c * m [ 8 ] - s * m [ 7 ] ] ; } if ( axis = = 'y ' ) { return [ c * m [ 0 ] - s * m [ 2 ] , m [ 1 ] , c * m [ 2 ] + s * m [ 0 ] , c * m [ 3 ] - s * m [ 5 ] , m [ 4 ] , c * m [ 5 ] + s * m [ 3 ] , c * m [ 6 ] - s * m [ 8 ] , m [ 7 ] , c * m [ 8 ] + s * m [ 6 ] ] ; } if ( axis = = 'z ' ) { return [ c * m [ 0 ] + s * m [ 1 ] , c * m [ 1 ] - s * m [ 0 ] , m [ 2 ] , c * m [ 3 ] + s * m [ 4 ] , c * m [ 4 ] - s * m [ 3 ] , m [ 5 ] , c * m [ 6 ] + s * m [ 7 ] , c * m [ 7 ] - s * m [ 6 ] , m [ 8 ] ] ; } } 
function make Matrix 4 ( m ) { return [ m [ 0 ] , m [ 1 ] , m [ 2 ] , 0 , m [ 3 ] , m [ 4 ] , m [ 5 ] , 0 , m [ 6 ] , m [ 7 ] , m [ 8 ] , 0 , 0 , 0 , 0 , 1 ] ; } 
function make Persp ( hfov , aspect , znear , zfar ) { var fovy = 2 * Math . atan ( Math . tan ( hfov / 2 ) * gl . drawing Buffer Height / gl . drawing Buffer Width ) ; var f = 1 / Math . tan ( fovy / 2 ) ; return [ f / aspect , 0 , 0 , 0 , 0 , f , 0 , 0 , 0 , 0 , ( zfar + znear ) / ( znear - zfar ) , ( 2 * zfar * znear ) / ( znear - zfar ) , 0 , 0 , - 1 , 0 ] ; } 
function process Loaded Texture ( img , tex ) { gl . bind Texture ( gl . TEXTURE _ 2D , tex ) ; gl . tex Image 2D ( gl . TEXTURE _ 2D , 0 , gl . RGB , gl . RGB , gl . UNSIGNED _BYTE , img ) ; gl . tex Parameteri ( gl . TEXTURE _ 2D , gl . TEXTURE _MAG _FILTER , gl . LINEAR ) ; gl . tex Parameteri ( gl . TEXTURE _ 2D , gl . TEXTURE _MIN _FILTER , gl . LINEAR ) ; gl . tex Parameteri ( gl . TEXTURE _ 2D , gl . TEXTURE _WRAP _S , gl . CLAMP _TO _EDGE ) ; gl . tex Parameteri ( gl . TEXTURE _ 2D , gl . TEXTURE _WRAP _T , gl . CLAMP _TO _EDGE ) ; gl . bind Texture ( gl . TEXTURE _ 2D , null ) ; } 
function process Next Tile ( node ) { load Texture ( node , encode URI ( node . path + ' . ' + image . extension ) , function ( texture , loaded ) { node . texture = texture ; node . texture Loaded = loaded ? 2 : 1 ; } , global Params . cross Origin ) ; } 
function check Zoom ( hfov ) { 
function rotate Persp ( p , r ) { return [ p [ 0 ] * r [ 0 ] , p [ 0 ] * r [ 1 ] , p [ 0 ] * r [ 2 ] , 0 , p [ 5 ] * r [ 4 ] , p [ 5 ] * r [ 5 ] , p [ 5 ] * r [ 6 ] , 0 , p [ 1 0 ] * r [ 8 ] , p [ 1 0 ] * r [ 9 ] , p [ 1 0 ] * r [ 1 0 ] , p [ 1 1 ] , - r [ 8 ] , - r [ 9 ] , - r [ 1 0 ] , 0 ] ; } 
function apply Rot Persp To Vec ( m , v ) { return [ m [ 0 ] * v [ 0 ] + m [ 1 ] * v [ 1 ] + m [ 2 ] * v [ 2 ] , m [ 4 ] * v [ 0 ] + m [ 5 ] * v [ 1 ] + m [ 6 ] * v [ 2 ] , m [ 1 1 ] + m [ 8 ] * v [ 0 ] + m [ 9 ] * v [ 1 ] + m [ 1 0 ] * v [ 2 ] , 1 / ( m [ 1 2 ] * v [ 0 ] + m [ 1 3 ] * v [ 1 ] + m [ 1 4 ] * v [ 2 ] ) ] ; } 
function check In View ( m , v ) { var vpp = apply Rot Persp To Vec ( m , v ) ; var win X = vpp [ 0 ] * vpp [ 3 ] ; var win Y = vpp [ 1 ] * vpp [ 3 ] ; var win Z = vpp [ 2 ] * vpp [ 3 ] ; var ret = [ 0 , 0 , 0 ] ; if ( win X < - 1 ) ret [ 0 ] = - 1 ; if ( win X > 1 ) ret [ 0 ] = 1 ; if ( win Y < - 1 ) ret [ 1 ] = - 1 ; if ( win Y > 1 ) ret [ 1 ] = 1 ; if ( win Z < - 1 | | win Z > 1 ) ret [ 2 ] = 1 ; return ret ; } 
function check Square In View ( m , v ) { var check 1 = check In View ( m , v . slice ( 0 , 3 ) ) ; var check 2 = check In View ( m , v . slice ( 3 , 6 ) ) ; var check 3 = check In View ( m , v . slice ( 6 , 9 ) ) ; var check 4 = check In View ( m , v . slice ( 9 , 1 2 ) ) ; var test X = check 1 [ 0 ] + check 2 [ 0 ] + check 3 [ 0 ] + check 4 [ 0 ] ; if ( test X = = - 4 | | test X = = 4 ) return false ; var test Y = check 1 [ 1 ] + check 2 [ 1 ] + check 3 [ 1 ] + check 4 [ 1 ] ; if ( test Y = = - 4 | | test Y = = 4 ) return false ; var test Z = check 1 [ 2 ] + check 2 [ 2 ] + check 3 [ 2 ] + check 4 [ 2 ] ; return test Z ! = 4 ; } 
function handle Web GLError 1 2 8 6 ( ) { console . log ( 'Reducing canvas size due to error 1 2 8 6 ! ' ) ; canvas . width = Math . round ( canvas . width / 2 ) ; canvas . height = Math . round ( canvas . height / 2 ) ; } 
function init ( ) { 
function on Image Load ( ) { if ( ! renderer ) renderer = new libpannellum . renderer ( render Container ) ; 
function ( tag ) { var result ; if ( xmp Data . index Of ( tag + ' = " ' ) > = 0 ) { result = xmp Data . substring ( xmp Data . index Of ( tag + ' = " ' ) + tag . length + 2 ) ; result = result . substring ( 0 , result . index Of ( ' " ' ) ) ; } else if ( xmp Data . index Of ( tag + ' > ' ) > = 0 ) { result = xmp Data . substring ( xmp Data . index Of ( tag + ' > ' ) + tag . length + 1 ) ; result = result . substring ( 0 , result . index Of ( ' < ' ) ) ; } if ( result ! = = undefined ) { return Number ( result ) ; } return null ; } 
function an Error ( error Msg ) { if ( error Msg = = = undefined ) error Msg = config . strings . generic Web GLError ; info Display . error Msg . inner HTML = ' <p > ' + error Msg + ' < /p > ' ; controls . load . style . display = 'none ' ; info Display . load . box . style . display = 'none ' ; info Display . error Msg . style . display = 'table ' ; error = true ; render Container . style . display = 'none ' ; fire Event ( 'error ' , error Msg ) ; } 
function clear Error ( ) { if ( error ) { info Display . load . box . style . display = 'none ' ; info Display . error Msg . style . display = 'none ' ; error = false ; fire Event ( 'errorcleared ' ) ; } } 
function about Message ( event ) { var pos = mouse Position ( event ) ; about Msg . style . left = pos . x + 'px ' ; about Msg . style . top = pos . y + 'px ' ; clear Timeout ( about Message . t 1 ) ; clear Timeout ( about Message . t 2 ) ; about Msg . style . display = 'block ' ; about Msg . style . opacity = 1 ; about Message . t 1 = set Timeout ( function ( ) { about Msg . style . opacity = 0 ; } , 2 0 0 0 ) ; about Message . t 2 = set Timeout ( function ( ) { about Msg . style . display = 'none ' ; } , 2 5 0 0 ) ; event . prevent Default ( ) ; } 
function mouse Position ( event ) { var bounds = container . get Bounding Client Rect ( ) ; var pos = { } ; 
function on Document Mouse Down ( event ) { 
function on Document Double Click ( event ) { if ( config . min Hfov = = = config . hfov ) { _this . set Hfov ( orig Hfov , 1 0 0 0 ) ; } else { var coords = mouse Event To Coords ( event ) ; _this . look At ( coords [ 0 ] , coords [ 1 ] , config . min Hfov , 1 0 0 0 ) ; } } 
function mouse Event To Coords ( event ) { var pos = mouse Position ( event ) ; var canvas = renderer . get Canvas ( ) ; var canvas Width = canvas . client Width , canvas Height = canvas . client Height ; var x = pos . x / canvas Width * 2 - 1 ; var y = ( 1 - pos . y / canvas Height * 2 ) * canvas Height / canvas Width ; var focal = 1 / Math . tan ( config . hfov * Math . PI / 3 6 0 ) ; var s = Math . sin ( config . pitch * Math . PI / 1 8 0 ) ; var c = Math . cos ( config . pitch * Math . PI / 1 8 0 ) ; var a = focal * c - y * s ; var root = Math . sqrt ( x * x + a * a ) ; var pitch = Math . atan ( ( y * c + focal * s ) / root ) * 1 8 0 / Math . PI ; var yaw = Math . atan 2 ( x / root , a / root ) * 1 8 0 / Math . PI + config . yaw ; if ( yaw < - 1 8 0 ) yaw + = 3 6 0 ; if ( yaw > 1 8 0 ) yaw - = 3 6 0 ; return [ pitch , yaw ] ; } 
function on Document Mouse Move ( event ) { if ( is User Interacting & & loaded ) { latest Interaction = Date . now ( ) ; var canvas = renderer . get Canvas ( ) ; var canvas Width = canvas . client Width , canvas Height = canvas . client Height ; var pos = mouse Position ( event ) ; 
function on Document Mouse Up ( event ) { if ( ! is User Interacting ) { return ; } is User Interacting = false ; if ( Date . now ( ) - latest Interaction > 1 5 ) { 
function on Document Touch Start ( event ) { 
function on Document Touch Move ( event ) { if ( ! config . draggable ) { return ; } 
function on Document Touch End ( ) { is User Interacting = false ; if ( Date . now ( ) - latest Interaction > 1 5 0 ) { speed . pitch = speed . yaw = 0 ; } on Pointer Down Pointer Dist = - 1 ; latest Interaction = Date . now ( ) ; fire Event ( 'touchend ' , event ) ; } 
function on Document Pointer Down ( event ) { if ( event . pointer Type = = 'touch ' ) { pointer IDs . push ( event . pointer Id ) ; pointer Coordinates . push ( { client X : event . client X , client Y : event . client Y } ) ; event . target Touches = pointer Coordinates ; on Document Touch Start ( event ) ; event . prevent Default ( ) ; } } 
function on Document Pointer Move ( event ) { if ( event . pointer Type = = 'touch ' ) { for ( var i = 0 ; i < pointer IDs . length ; i + + ) { if ( event . pointer Id = = pointer IDs [ i ] ) { pointer Coordinates [ i ] . client X = event . client X ; pointer Coordinates [ i ] . client Y = event . client Y ; event . target Touches = pointer Coordinates ; on Document Touch Move ( event ) ; event . prevent Default ( ) ; return ; } } } } 
function on Document Pointer Up ( event ) { if ( event . pointer Type = = 'touch ' ) { var defined = false ; for ( var i = 0 ; i < pointer IDs . length ; i + + ) { if ( event . pointer Id = = pointer IDs [ i ] ) pointer IDs [ i ] = undefined ; if ( pointer IDs [ i ] ) defined = true ; } if ( ! defined ) { pointer IDs = [ ] ; pointer Coordinates = [ ] ; on Document Touch End ( ) ; } event . prevent Default ( ) ; } } 
function on Document Mouse Wheel ( event ) { 
function on Document Key Press ( event ) { 
function on Document Key Up ( event ) { 
function change Key ( keynumber , value ) { var key Changed = false ; switch ( keynumber ) { 
function key Repeat ( ) { 
function animate Move ( axis ) { var t = animated Move [ axis ] ; var norm Time = Math . min ( 1 , Math . max ( ( Date . now ( ) - t . start Time ) / 1 0 0 0 / ( t . duration / 1 0 0 0 ) , 0 ) ) ; var result = t . start Position + config . animation Timing Function ( norm Time ) * ( t . end Position - t . start Position ) ; if ( ( t . end Position > t . start Position & & result > = t . end Position ) | | ( t . end Position < t . start Position & & result < = t . end Position ) | | t . end Position = = = t . start Position ) { result = t . end Position ; speed [ axis ] = 0 ; delete animated Move [ axis ] ; } config [ axis ] = result ; } 
function animate ( ) { render ( ) ; if ( auto Rotate Start ) clear Timeout ( auto Rotate Start ) ; if ( is User Interacting | | orientation = = = true ) { request Animation Frame ( animate ) ; } else if ( keys Down [ 0 ] | | keys Down [ 1 ] | | keys Down [ 2 ] | | keys Down [ 3 ] | | keys Down [ 4 ] | | keys Down [ 5 ] | | keys Down [ 6 ] | | keys Down [ 7 ] | | keys Down [ 8 ] | | keys Down [ 9 ] | | config . auto Rotate | | animated Move . pitch | | animated Move . yaw | | animated Move . hfov | | Math . abs ( speed . yaw ) > 0 . 0 1 | | Math . abs ( speed . pitch ) > 0 . 0 1 | | Math . abs ( speed . hfov ) > 0 . 0 1 ) { key Repeat ( ) ; if ( config . auto Rotate Inactivity Delay > = 0 & & auto Rotate Speed & & Date . now ( ) - latest Interaction > config . auto Rotate Inactivity Delay & & ! config . auto Rotate ) { config . auto Rotate = auto Rotate Speed ; _this . look At ( orig Pitch , undefined , orig Hfov , 3 0 0 0 ) ; } request Animation Frame ( animate ) ; } else if ( renderer & & ( renderer . is Loading ( ) | | ( config . dynamic = = = true & & update ) ) ) { request Animation Frame ( animate ) ; } else { fire Event ( 'animatefinished ' , { pitch : _this . get Pitch ( ) , yaw : _this . get Yaw ( ) , hfov : _this . get Hfov ( ) } ) ; animating = false ; prev Time = undefined ; var auto Rotate Start Time = config . auto Rotate Inactivity Delay - ( Date . now ( ) - latest Interaction ) ; if ( auto Rotate Start Time > 0 ) { auto Rotate Start = set Timeout ( function ( ) { config . auto Rotate = auto Rotate Speed ; _this . look At ( orig Pitch , undefined , orig Hfov , 3 0 0 0 ) ; animate Init ( ) ; } , auto Rotate Start Time ) ; } else if ( config . auto Rotate Inactivity Delay > = 0 & & auto Rotate Speed ) { config . auto Rotate = auto Rotate Speed ; _this . look At ( orig Pitch , undefined , orig Hfov , 3 0 0 0 ) ; animate Init ( ) ; } } } 
function render ( ) { var tmpyaw ; if ( loaded ) { 
function tait Bryan To Quaternion ( alpha , beta , gamma ) { var r = [ beta ? beta * Math . PI / 1 8 0 / 2 : 0 , gamma ? gamma * Math . PI / 1 8 0 / 2 : 0 , alpha ? alpha * Math . PI / 1 8 0 / 2 : 0 ] ; var c = [ Math . cos ( r [ 0 ] ) , Math . cos ( r [ 1 ] ) , Math . cos ( r [ 2 ] ) ] , s = [ Math . sin ( r [ 0 ] ) , Math . sin ( r [ 1 ] ) , Math . sin ( r [ 2 ] ) ] ; return new Quaternion ( c [ 0 ] * c [ 1 ] * c [ 2 ] - s [ 0 ] * s [ 1 ] * s [ 2 ] , s [ 0 ] * c [ 1 ] * c [ 2 ] - c [ 0 ] * s [ 1 ] * s [ 2 ] , c [ 0 ] * s [ 1 ] * c [ 2 ] + s [ 0 ] * c [ 1 ] * s [ 2 ] , c [ 0 ] * c [ 1 ] * s [ 2 ] + s [ 0 ] * s [ 1 ] * c [ 2 ] ) ; } 
function compute Quaternion ( alpha , beta , gamma ) { 
function orientation Listener ( e ) { var q = compute Quaternion ( e . alpha , e . beta , e . gamma ) . to Euler Angles ( ) ; if ( typeof ( orientation ) = = 'number ' & & orientation < 1 0 ) { 
function render Init ( ) { try { var params = { } ; if ( config . horizon Pitch ! = = undefined ) params . horizon Pitch = config . horizon Pitch * Math . PI / 1 8 0 ; if ( config . horizon Roll ! = = undefined ) params . horizon Roll = config . horizon Roll * Math . PI / 1 8 0 ; if ( config . background Color ! = = undefined ) params . background Color = config . background Color ; renderer . init ( pano Image , config . type , config . dynamic , config . haov * Math . PI / 1 8 0 , config . vaov * Math . PI / 1 8 0 , config . v Offset * Math . PI / 1 8 0 , render Init Callback , params ) ; if ( config . dynamic ! = = true ) { 
function render Init Callback ( ) { 
function create Hot Spot ( hs ) { 
function create Hot Spots ( ) { if ( hotspots Created ) return ; if ( ! config . hot Spots ) { config . hot Spots = [ ] ; } else { 
function destroy Hot Spots ( ) { var hs = config . hot Spots ; hotspots Created = false ; delete config . hot Spots ; if ( hs ) { for ( var i = 0 ; i < hs . length ; i + + ) { var current = hs [ i ] . div ; if ( current ) { while ( current . parent Node & & current . parent Node ! = render Container ) { current = current . parent Node ; } render Container . remove Child ( current ) ; } delete hs [ i ] . div ; } } } 
function render Hot Spot ( hs ) { var hs Pitch Sin = Math . sin ( hs . pitch * Math . PI / 1 8 0 ) , hs Pitch Cos = Math . cos ( hs . pitch * Math . PI / 1 8 0 ) , config Pitch Sin = Math . sin ( config . pitch * Math . PI / 1 8 0 ) , config Pitch Cos = Math . cos ( config . pitch * Math . PI / 1 8 0 ) , yaw Cos = Math . cos ( ( - hs . yaw + config . yaw ) * Math . PI / 1 8 0 ) ; var z = hs Pitch Sin * config Pitch Sin + hs Pitch Cos * yaw Cos * config Pitch Cos ; if ( ( hs . yaw < = 9 0 & & hs . yaw > - 9 0 & & z < = 0 ) | | ( ( hs . yaw > 9 0 | | hs . yaw < = - 9 0 ) & & z < = 0 ) ) { hs . div . style . visibility = 'hidden ' ; } else { var yaw Sin = Math . sin ( ( - hs . yaw + config . yaw ) * Math . PI / 1 8 0 ) , hfov Tan = Math . tan ( config . hfov * Math . PI / 3 6 0 ) ; hs . div . style . visibility = 'visible ' ; 
function merge Config ( scene Id ) { config = { } ; var k , s ; var photo Sphere Excludes = [ 'haov ' , 'vaov ' , 'v Offset ' , 'north Offset ' , 'horizon Pitch ' , 'horizon Roll ' ] ; specified Photo Sphere Excludes = [ ] ; 
function process Options ( is Preview ) { is Preview = is Preview ? is Preview : false ; 
function toggle Fullscreen ( ) { if ( loaded & & ! error ) { if ( ! fullscreen Active ) { try { if ( container . request Fullscreen ) { container . request Fullscreen ( ) ; } else if ( container . moz Request Full Screen ) { container . moz Request Full Screen ( ) ; } else if ( container . ms Request Fullscreen ) { container . ms Request Fullscreen ( ) ; } else { container . webkit Request Full Screen ( ) ; } } catch ( event ) { 
function on Full Screen Change ( resize ) { if ( document . fullscreen Element | | document . fullscreen | | document . moz Full Screen | | document . webkit Is Full Screen | | document . ms Fullscreen Element ) { controls . fullscreen . class List . add ( 'pnlm -fullscreen -toggle -button -active ' ) ; fullscreen Active = true ; } else { controls . fullscreen . class List . remove ( 'pnlm -fullscreen -toggle -button -active ' ) ; fullscreen Active = false ; } if ( resize ! = = 'resize ' ) fire Event ( 'fullscreenchange ' , fullscreen Active ) ; 
function constrain Hfov ( hfov ) { 
function stop Animation ( ) { animated Move = { } ; auto Rotate Speed = config . auto Rotate ? config . auto Rotate : auto Rotate Speed ; config . auto Rotate = false ; } 
function load ( ) { 
function load Scene ( scene Id , target Pitch , target Yaw , target Hfov , fade Done ) { loaded = false ; animated Move = { } ; 
function stop Orientation ( ) { window . remove Event Listener ( 'deviceorientation ' , orientation Listener ) ; controls . orientation . class List . remove ( 'pnlm -orientation -button -active ' ) ; orientation = false ; } 
function escape HTML ( s ) { if ( ! initial Config . escape HTML ) return String ( s ) . split ( ' \n ' ) . join ( ' <br > ' ) ; return String ( s ) . split ( / & / g ) . join ( ' &amp ; ' ) . split ( ' " ' ) . join ( ' &quot ; ' ) . split ( " ' " ) . join ( ' & # 3 9 ; ' ) . split ( ' < ' ) . join ( ' &lt ; ' ) . split ( ' > ' ) . join ( ' &gt ; ' ) . split ( ' / ' ) . join ( ' & #x 2f ; ' ) . split ( ' \n ' ) . join ( ' <br > ' ) ; 
function fire Event ( type ) { if ( type in external Event Listeners ) { 
function ( latch Function , optional _timeout Message , optional _timeout ) { jasmine . get Env ( ) . current Spec . waits For . apply ( jasmine . get Env ( ) . current Spec , arguments ) ; } 
function OAuth Error ( message Or Error , properties ) { var message = message Or Error instanceof Error ? message Or Error . message : message Or Error ; var error = message Or Error instanceof Error ? message Or Error : null ; if ( _ . is Empty ( properties ) ) { properties = { } ; } _ . defaults ( properties , { code : 5 0 0 } ) ; if ( error ) { properties . inner = error ; } if ( _ . is Empty ( message ) ) { message = statuses [ properties . code ] ; } this . code = this . status = this . status Code = properties . code ; this . message = message ; for ( var key in properties ) { if ( key ! = = 'code ' ) { this [ key ] = properties [ key ] ; } } Error . capture Stack Trace ( this , OAuth Error ) ; } 
function Authorization Code Grant Type ( options ) { options = options | | { } ; if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get Authorization Code ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get Authorization Code ( ) ` ' ) ; } if ( ! options . model . revoke Authorization Code ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `revoke Authorization Code ( ) ` ' ) ; } if ( ! options . model . save Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `save Token ( ) ` ' ) ; } Abstract Grant Type . call ( this , options ) ; } 
function Password Grant Type ( options ) { options = options | | { } ; if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get User ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get User ( ) ` ' ) ; } if ( ! options . model . save Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `save Token ( ) ` ' ) ; } Abstract Grant Type . call ( this , options ) ; } 
function Token Handler ( options ) { options = options | | { } ; if ( ! options . access Token Lifetime ) { throw new Invalid Argument Error ( 'Missing parameter : `access Token Lifetime ` ' ) ; } if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . refresh Token Lifetime ) { throw new Invalid Argument Error ( 'Missing parameter : `refresh Token Lifetime ` ' ) ; } if ( ! options . model . get Client ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get Client ( ) ` ' ) ; } this . access Token Lifetime = options . access Token Lifetime ; this . grant Types = _ . assign ( { } , grant Types , options . extended Grant Types ) ; this . model = options . model ; this . refresh Token Lifetime = options . refresh Token Lifetime ; this . allow Extended Token Attributes = options . allow Extended Token Attributes ; this . require Client Authentication = options . require Client Authentication | | { } ; this . always Issue New Refresh Token = options . always Issue New Refresh Token ! = = false ; } 
function Abstract Grant Type ( options ) { options = options | | { } ; if ( ! options . access Token Lifetime ) { throw new Invalid Argument Error ( 'Missing parameter : `access Token Lifetime ` ' ) ; } if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } this . access Token Lifetime = options . access Token Lifetime ; this . model = options . model ; this . refresh Token Lifetime = options . refresh Token Lifetime ; this . always Issue New Refresh Token = options . always Issue New Refresh Token ; } 
function Authenticate Handler ( options ) { options = options | | { } ; if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get Access Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get Access Token ( ) ` ' ) ; } if ( options . scope & & undefined = = = options . add Accepted Scopes Header ) { throw new Invalid Argument Error ( 'Missing parameter : `add Accepted Scopes Header ` ' ) ; } if ( options . scope & & undefined = = = options . add Authorized Scopes Header ) { throw new Invalid Argument Error ( 'Missing parameter : `add Authorized Scopes Header ` ' ) ; } if ( options . scope & & ! options . model . verify Scope ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `verify Scope ( ) ` ' ) ; } this . add Accepted Scopes Header = options . add Accepted Scopes Header ; this . add Authorized Scopes Header = options . add Authorized Scopes Header ; this . allow Bearer Tokens In Query String = options . allow Bearer Tokens In Query String ; this . model = options . model ; this . scope = options . scope ; } 
function Invalid Argument Error ( message , properties ) { properties = _ . assign ( { code : 5 0 0 , name : 'invalid _argument ' } , properties ) ; OAuth Error . call ( this , message , properties ) ; } 
function Refresh Token Grant Type ( options ) { options = options | | { } ; if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get Refresh Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get Refresh Token ( ) ` ' ) ; } if ( ! options . model . revoke Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `revoke Token ( ) ` ' ) ; } if ( ! options . model . save Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `save Token ( ) ` ' ) ; } Abstract Grant Type . call ( this , options ) ; } 
function Request ( options ) { options = options | | { } ; if ( ! options . headers ) { throw new Invalid Argument Error ( 'Missing parameter : `headers ` ' ) ; } if ( ! options . method ) { throw new Invalid Argument Error ( 'Missing parameter : `method ` ' ) ; } if ( ! options . query ) { throw new Invalid Argument Error ( 'Missing parameter : `query ` ' ) ; } this . body = options . body | | { } ; this . headers = { } ; this . method = options . method ; this . query = options . query ; 
function Authorize Handler ( options ) { options = options | | { } ; if ( options . authenticate Handler & & ! options . authenticate Handler . handle ) { throw new Invalid Argument Error ( 'Invalid argument : authenticate Handler does not implement `handle ( ) ` ' ) ; } if ( ! options . authorization Code Lifetime ) { throw new Invalid Argument Error ( 'Missing parameter : `authorization Code Lifetime ` ' ) ; } if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get Client ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get Client ( ) ` ' ) ; } if ( ! options . model . save Authorization Code ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `save Authorization Code ( ) ` ' ) ; } this . allow Empty State = options . allow Empty State ; this . authenticate Handler = options . authenticate Handler | | new Authenticate Handler ( options ) ; this . authorization Code Lifetime = options . authorization Code Lifetime ; this . model = options . model ; } 
function Client Credentials Grant Type ( options ) { options = options | | { } ; if ( ! options . model ) { throw new Invalid Argument Error ( 'Missing parameter : `model ` ' ) ; } if ( ! options . model . get User From Client ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `get User From Client ( ) ` ' ) ; } if ( ! options . model . save Token ) { throw new Invalid Argument Error ( 'Invalid argument : model does not implement `save Token ( ) ` ' ) ; } Abstract Grant Type . call ( this , options ) ; } 
function Bearer Token Type ( access Token , access Token Lifetime , refresh Token , scope , custom Attributes ) { if ( ! access Token ) { throw new Invalid Argument Error ( 'Missing parameter : `access Token ` ' ) ; } this . access Token = access Token ; this . access Token Lifetime = access Token Lifetime ; this . refresh Token = refresh Token ; this . scope = scope ; if ( custom Attributes ) { this . custom Attributes = custom Attributes ; } } 
function Response ( options ) { options = options | | { } ; this . body = options . body | | { } ; this . headers = { } ; this . status = 2 0 0 ; 
function import _hooks ( mod _name , _path , from _stdlib ) { var _meta _path = $B . meta _path . slice ( ) , _sys _modules = $B . imported , _loader , spec if ( from _stdlib = = "static " ) { 
function $get Mouse Offset ( target , ev ) { ev = ev | | _window . event ; var doc Pos = $get Position ( target ) ; var mouse Pos = $mouse Coords ( ev ) ; return { x : mouse Pos . x - doc Pos . x , y : mouse Pos . y - doc Pos . y } ; } 
function jscode _namespace ( iter _name , action , parent _id ) { var _clean = ' ' ; if ( action = = = 'store ' ) { _clean = ' = { } ' } var res = 'for (var attr in this .blocks ) { ' + 'eval ( "var " + attr + " = this .blocks [attr ] " ) ' + ' } ; ' + 'var $locals _ ' + iter _name + ' = this .env ' + _clean + ' , ' + ' $local _name = " ' + iter _name + ' " , ' + ' $locals = $locals _ ' + iter _name + ' ; ' if ( parent _id ) { res + = ' $locals . $parent = $locals _ ' + parent _id . replace ( / \ . / g , " _ " ) + ' ; ' } return res } 
function ( val , flags ) { number _check ( val ) if ( ! flags . precision ) { if ( ! flags . decimal _point ) { flags . precision = 6 } else { flags . precision = 0 } } else { flags . precision = parse Int ( flags . precision , 1 0 ) validate _precision ( flags . precision ) } return parse Float ( val ) } 
function ( val , upper , flags ) { val = _float _helper ( val , flags ) , v = val . to String ( ) , v _len = v . length , dot _idx = v . index Of ( ' . ' ) if ( dot _idx < 0 ) { dot _idx = v _len } if ( val < 1 & & val > - 1 ) { var zeros = leading _zeros . exec ( v ) , numzeros if ( zeros ) { numzeros = zeros [ 1 ] . length } else { numzeros = 0 } if ( numzeros > = 4 ) { val = format _sign ( val , flags ) + format _float _precision ( val , upper , flags , _floating _g _exp _helper ) if ( ! flags . alternate ) { var trl = trailing _zeros . exec ( val ) if ( trl ) { val = trl [ 1 ] . replace ( trailing _dot , " " ) + trl [ 3 ] 
function ( val , upper , flags ) { val = _float _helper ( val , flags ) return format _padding ( format _sign ( val , flags ) + format _float _precision ( val , upper , flags , function ( val , precision , flags ) { val = val . to Fixed ( precision ) if ( precision = = = 0 & & flags . alternate ) { val + = ' . ' } return val } ) , flags ) } 
function ( val , upper , flags ) { val = _float _helper ( val , flags ) return format _padding ( format _sign ( val , flags ) + format _float _precision ( val , upper , flags , _floating _exp _helper ) , flags ) } 
function replace _nested ( name , key ) { if ( / \d + / . exec ( key ) ) { 
function ( self , other ) { if ( _b _ . isinstance ( other , int ) ) { if ( other . _ _class _ _ = = = $B . long _int ) { return $B . long _int . _ _sub _ _ ( $B . long _int . $factory ( self ) , $B . long _int . $factory ( other ) ) } other = int _value ( other ) if ( self > $B . max _int 3 2 | | self < $B . min _int 3 2 | | other > $B . max _int 3 2 | | other < $B . min _int 3 2 ) { return $B . long _int . _ _sub _ _ ( $B . long _int . $factory ( self ) , $B . long _int . $factory ( other ) ) } return self - other } if ( _b _ . isinstance ( other , _b _ . bool ) ) { return self - other } var rsub = $B . $getattr ( other , " _ _rsub _ _ " , _b _ . None ) if ( rsub ! = = _b _ . None ) { return rsub ( self ) } $err ( " - " , other ) } 
function ( self , other ) { if ( _b _ . isinstance ( other , int ) ) { other = int _value ( other ) if ( typeof other = = "number " ) { var res = self . value Of ( ) - other . value Of ( ) if ( res > $B . min _int & & res < $B . max _int ) { return res } else { return $B . long _int . _ _sub _ _ ( $B . long _int . $factory ( self ) , $B . long _int . $factory ( other ) ) } } else if ( typeof other = = "boolean " ) { return other ? self - 1 : self } else { return $B . long _int . _ _sub _ _ ( $B . long _int . $factory ( self ) , $B . long _int . $factory ( other ) ) } } if ( _b _ . isinstance ( other , _b _ . float ) ) { return new Number ( self - other ) } if ( _b _ . isinstance ( other , _b _ . complex ) ) { return $B . make _complex ( self - other . $real , - other . $imag ) } if ( _b _ . isinstance ( other , _b _ . bool ) ) { var bool _value = 0 ; if ( other . value Of ( ) ) { bool _value = 1 } return self - bool _value } if ( _b _ . isinstance ( other , _b _ . complex ) ) { return $B . make _complex ( self . value Of ( ) - other . $real , other . $imag ) } var rsub = $B . $getattr ( other , " _ _rsub _ _ " , _b _ . None ) if ( rsub ! = = _b _ . None ) { return rsub ( self ) } throw $err ( " - " , other ) } 
function ( self , other ) { if ( other . _ _class _ _ = = = $B . long _int ) { return $B . long _int . _ _lt _ _ ( other , $B . long _int . $factory ( self ) ) } if ( _b _ . isinstance ( other , int ) ) { other = int _value ( other ) return self . value Of ( ) > other . value Of ( ) } else if ( _b _ . isinstance ( other , _b _ . float ) ) { return self . value Of ( ) > other . value Of ( ) } else if ( _b _ . isinstance ( other , _b _ . bool ) ) { return self . value Of ( ) > _b _ . bool . _ _hash _ _ ( other ) } if ( _b _ . hasattr ( other , " _ _int _ _ " ) | | _b _ . hasattr ( other , " _ _index _ _ " ) ) { return int . _ _gt _ _ ( self , $B . $Get Int ( other ) ) } return _b _ . Not Implemented } 
function loop ( ) { if ( tasks . length = = 0 ) { 
function ( self , other ) { if ( isinstance ( other , _b _ . int ) ) { if ( typeof other = = "boolean " ) { return other ? self - 1 : self } else if ( other . _ _class _ _ = = = $B . long _int ) { return float . $factory ( self - parse Int ( other . value ) ) } else { return float . $factory ( self - other ) } } if ( isinstance ( other , float ) ) { return float . $factory ( self - other ) } if ( isinstance ( other , _b _ . bool ) ) { var bool _value = 0 if ( other . value Of ( ) ) { bool _value = 1 } return float . $factory ( self - bool _value ) } if ( isinstance ( other , _b _ . complex ) ) { return $B . make _complex ( self - other . $real , - other . $imag ) } if ( hasattr ( other , " _ _rsub _ _ " ) ) { return getattr ( other , " _ _rsub _ _ " ) ( self ) } $err ( " - " , other ) } 
function ( self , other ) { if ( isinstance ( other , _b _ . int ) ) { if ( other . _ _class _ _ = = = $B . long _int ) { return self > parse Int ( other . value ) } return self > other . value Of ( ) } if ( isinstance ( other , float ) ) { return self > other } if ( isinstance ( other , _b _ . bool ) ) { return self . value Of ( ) > _b _ . bool . _ _hash _ _ ( other ) } if ( hasattr ( other , " _ _int _ _ " ) | | hasattr ( other , " _ _index _ _ " ) ) { return _b _ . int . _ _gt _ _ ( self , $B . $Get Int ( other ) ) } 
function $ $eval ( src , _globals , _locals ) { if ( _globals = = = undefined ) { _globals = _b _ . None } if ( _locals = = = undefined ) { _locals = _b _ . None } var current _frame = $B . frames _stack [ $B . frames _stack . length - 1 ] if ( current _frame ! = = undefined ) { var current _locals _id = current _frame [ 0 ] . replace ( / \ . / , ' _ ' ) , current _globals _id = current _frame [ 2 ] . replace ( / \ . / , ' _ ' ) } var stack _len = $B . frames _stack . length var is _exec = arguments [ 3 ] = = 'exec ' if ( src . _ _class _ _ = = = code ) { is _exec = src . mode = = "exec " src = src . source } else if ( typeof src ! = = 'string ' ) { throw _b _ . Type Error . $factory ( "eval ( ) arg 1 must be a string , bytes " + "or code object " ) } 
function input ( msg ) { var stdin = ( $B . imported . sys & & $B . imported . sys . stdin | | $B . stdin ) ; if ( stdin . _ _original _ _ ) { return prompt ( msg | | ' ' ) | | ' ' } msg = msg | | " " if ( msg ) { $B . stdout . write ( msg ) } stdin . msg = msg var val = $B . $getattr ( stdin , 'readline ' ) ( ) val = val . split ( ' \n ' ) [ 0 ] if ( stdin . len = = = stdin . pos ) { $B . $getattr ( stdin , 'close ' ) ( ) } 
function RGBColor ( m ) { this . ok = ! 1 ; m . char At ( 0 ) = = " # " & & ( m = m . substr ( 1 , 6 ) ) ; var m = m . replace ( / / g , " " ) , m = m . to Lower Case ( ) , a = { aliceblue : "f 0f 8ff " , antiquewhite : "faebd 7 " , aqua : " 0 0ffff " , aquamarine : " 7fffd 4 " , azure : "f 0ffff " , beige : "f 5f 5dc " , bisque : "ffe 4c 4 " , black : " 0 0 0 0 0 0 " , blanchedalmond : "ffebcd " , blue : " 0 0 0 0ff " , blueviolet : " 8a 2be 2 " , brown : "a 5 2a 2a " , burlywood : "deb 8 8 7 " , cadetblue : " 5f 9ea 0 " , chartreuse : " 7fff 0 0 " , chocolate : "d 2 6 9 1e " , coral : "ff 7f 5 0 " , cornflowerblue : " 6 4 9 5ed " , cornsilk : "fff 8dc " , crimson : "dc 1 4 3c " , cyan : " 0 0ffff " , darkblue : " 0 0 0 0 8b " , darkcyan : " 0 0 8b 8b " , darkgoldenrod : "b 8 8 6 0b " , darkgray : "a 9a 9a 9 " , darkgreen : " 0 0 6 4 0 0 " , darkkhaki : "bdb 7 6b " , darkmagenta : " 8b 0 0 8b " , darkolivegreen : " 5 5 6b 2f " , darkorange : "ff 8c 0 0 " , darkorchid : " 9 9 3 2cc " , darkred : " 8b 0 0 0 0 " , darksalmon : "e 9 9 6 7a " , darkseagreen : " 8fbc 8f " , darkslateblue : " 4 8 3d 8b " , darkslategray : " 2f 4f 4f " , darkturquoise : " 0 0ced 1 " , darkviolet : " 9 4 0 0d 3 " , deeppink : "ff 1 4 9 3 " , deepskyblue : " 0 0bfff " , dimgray : " 6 9 6 9 6 9 " , dodgerblue : " 1e 9 0ff " , feldspar : "d 1 9 2 7 5 " , firebrick : "b 2 2 2 2 2 " , floralwhite : "fffaf 0 " , forestgreen : " 2 2 8b 2 2 " , fuchsia : "ff 0 0ff " , gainsboro : "dcdcdc " , ghostwhite : "f 8f 8ff " , gold : "ffd 7 0 0 " , goldenrod : "daa 5 2 0 " , gray : " 8 0 8 0 8 0 " , green : " 0 0 8 0 0 0 " , greenyellow : "adff 2f " , honeydew : "f 0fff 0 " , hotpink : "ff 6 9b 4 " , indianred : "cd 5c 5c " , indigo : " 4b 0 0 8 2 " , ivory : "fffff 0 " , khaki : "f 0e 6 8c " , lavender : "e 6e 6fa " , lavenderblush : "fff 0f 5 " , lawngreen : " 7cfc 0 0 " , lemonchiffon : "fffacd " , lightblue : "add 8e 6 " , lightcoral : "f 0 8 0 8 0 " , lightcyan : "e 0ffff " , lightgoldenrodyellow : "fafad 2 " , lightgrey : "d 3d 3d 3 " , lightgreen : " 9 0ee 9 0 " , lightpink : "ffb 6c 1 " , lightsalmon : "ffa 0 7a " , lightseagreen : " 2 0b 2aa " , lightskyblue : " 8 7cefa " , lightslateblue : " 8 4 7 0ff " , lightslategray : " 7 7 8 8 9 9 " , lightsteelblue : "b 0c 4de " , lightyellow : "ffffe 0 " , lime : " 0 0ff 0 0 " , limegreen : " 3 2cd 3 2 " , linen : "faf 0e 6 " , magenta : "ff 0 0ff " , maroon : " 8 0 0 0 0 0 " , mediumaquamarine : " 6 6cdaa " , mediumblue : " 0 0 0 0cd " , mediumorchid : "ba 5 5d 3 " , mediumpurple : " 9 3 7 0d 8 " , mediumseagreen : " 3cb 3 7 1 " , mediumslateblue : " 7b 6 8ee " , mediumspringgreen : " 0 0fa 9a " , mediumturquoise : " 4 8d 1cc " , mediumvioletred : "c 7 1 5 8 5 " , midnightblue : " 1 9 1 9 7 0 " , mintcream : "f 5fffa " , mistyrose : "ffe 4e 1 " , moccasin : "ffe 4b 5 " , navajowhite : "ffdead " , navy : " 0 0 0 0 8 0 " , oldlace : "fdf 5e 6 " , olive : " 8 0 8 0 0 0 " , olivedrab : " 6b 8e 2 3 " , orange : "ffa 5 0 0 " , orangered : "ff 4 5 0 0 " , orchid : "da 7 0d 6 " , palegoldenrod : "eee 8aa " , palegreen : " 9 8fb 9 8 " , paleturquoise : "afeeee " , palevioletred : "d 8 7 0 9 3 " , papayawhip : "ffefd 5 " , peachpuff : "ffdab 9 " , peru : "cd 8 5 3f " , pink : "ffc 0cb " , plum : "dda 0dd " , powderblue : "b 0e 0e 6 " , purple : " 8 0 0 0 8 0 " , red : "ff 0 0 0 0 " , rosybrown : "bc 8f 8f " , royalblue : " 4 1 6 9e 1 " , saddlebrown : " 8b 4 5 1 3 " , salmon : "fa 8 0 7 2 " , sandybrown : "f 4a 4 6 0 " , seagreen : " 2e 8b 5 7 " , seashell : "fff 5ee " , sienna : "a 0 5 2 2d " , silver : "c 0c 0c 0 " , skyblue : " 8 7ceeb " , slateblue : " 6a 5acd " , slategray : " 7 0 8 0 9 0 " , snow : "fffafa " , springgreen : " 0 0ff 7f " , steelblue : " 4 6 8 2b 4 " , tan : "d 2b 4 8c " , teal : " 0 0 8 0 8 0 " , thistle : "d 8bfd 8 " , tomato : "ff 6 3 4 7 " , turquoise : " 4 0e 0d 0 " , violet : "ee 8 2ee " , violetred : "d 0 2 0 9 0 " , wheat : "f 5deb 3 " , white : "ffffff " , whitesmoke : "f 5f 5f 5 " , yellow : "ffff 0 0 " , yellowgreen : " 9acd 3 2 " } , c ; for ( c in a ) m = = c & & ( m = a [ c ] ) ; var d = [ { re : / ^rgb \ ( ( \d { 1 , 3 } ) , \s * ( \d { 1 , 3 } ) , \s * ( \d { 1 , 3 } ) \ ) $ / , example : [ "rgb ( 1 2 3 , 2 3 4 , 4 5 ) " , "rgb ( 2 5 5 , 2 3 4 , 2 4 5 ) " ] , process : function ( b ) { return [ parse Int ( b [ 1 ] ) , parse Int ( b [ 2 ] ) , parse Int ( b [ 3 ] ) ] } } , { re : / ^ ( \w { 2 } ) ( \w { 2 } ) ( \w { 2 } ) $ / , example : [ " # 0 0ff 0 0 " , " 3 3 6 6 9 9 " ] , process : function ( b ) { return [ parse Int ( b [ 1 ] , 1 6 ) , parse Int ( b [ 2 ] , 1 6 ) , parse Int ( b [ 3 ] , 1 6 ) ] } } , { re : / ^ ( \w { 1 } ) ( \w { 1 } ) ( \w { 1 } ) $ / , example : [ " #fb 0 " , "f 0f " ] , process : function ( b ) { return [ parse Int ( b [ 1 ] + b [ 1 ] , 1 6 ) , parse Int ( b [ 2 ] + b [ 2 ] , 1 6 ) , parse Int ( b [ 3 ] + b [ 3 ] , 1 6 ) ] } } ] ; for ( c = 0 ; c < d . length ; c + + ) { var b = d [ c ] . process , k = d [ c ] . re . exec ( m ) ; if ( k ) channels = b ( k ) , this . r = channels [ 0 ] , this . g = channels [ 1 ] , this . b = channels [ 2 ] , this . ok = ! 0 } this . r = this . r < 0 | | is Na N ( this . r ) ? 0 : this . r > 2 5 5 ? 2 5 5 : this . r ; this . g = this . g < 0 | | is Na N ( this . g ) ? 0 : this . g > 2 5 5 ? 2 5 5 : this . g ; this . b = this . b < 0 | | is Na N ( this . b ) ? 0 : this . b > 2 5 5 ? 2 5 5 : this . b ; this . to RGB = function ( ) { return "rgb ( " + this . r + " , " + this . g + " , " + this . b + " ) " } ; this . to Hex = function ( ) { var b = this . r . to String ( 1 6 ) , a = this . g . to String ( 1 6 ) , d = this . b . to String ( 1 6 ) ; b . length = = 1 & & ( b = " 0 " + b ) ; a . length = = 1 & & ( a = " 0 " + a ) ; d . length = = 1 & & ( d = " 0 " + d ) ; return " # " + b + a + d } ; this . get Help XML = function ( ) { for ( var b = [ ] , k = 0 ; k < d . length ; k + + ) for ( var c = d [ k ] . example , j = 0 ; j < c . length ; j + + ) b [ b . length ] = c [ j ] ; for ( var h in a ) b [ b . length ] = h ; c = document . create Element ( "ul " ) ; c . set Attribute ( "id " , "rgbcolor -examples " ) ; for ( k = 0 ; k < b . length ; k + + ) try { var l = document . create Element ( "li " ) , o = new RGBColor ( b [ k ] ) , n = document . create Element ( "div " ) ; n . style . css Text = "margin : 3px ; border : 1px solid black ; background : " + o . to Hex ( ) + " ; color : " + o . to Hex ( ) ; n . append Child ( document . create Text Node ( "test " ) ) ; var q = document . create Text Node ( " " + b [ k ] + " - > " + o . to RGB ( ) + " - > " + o . to Hex ( ) ) ; l . append Child ( n ) ; l . append Child ( q ) ; c . append Child ( l ) } catch ( p ) { } return c } } 
function ( name , path ) { path = path | | ' ' ; return gulp . src ( ` $ { build Folder } $ { path } ` ) 
function promiseify ( fn ) { return function ( ) { const args = [ ] . slice . call ( arguments , 0 ) ; return new Promise ( ( resolve , reject ) = > { fn . apply ( this , args . concat ( [ function ( err , value ) { if ( err ) { reject ( err ) ; } else { resolve ( value ) ; } } ] ) ) ; } ) ; } ; } 
function inline Resources From String ( content , url Resolver ) { 
function inline Style ( content , url Resolver ) { return content . replace ( / style Urls \s * : \s * ( \ [ [ \s \S ] * ? \ ] ) / gm , function ( m , style Urls ) { const urls = eval ( style Urls ) ; return 'styles : [ ' + urls . map ( style Url = > { const style File = url Resolver ( style Url ) ; const origin Content = fs . read File Sync ( style File , 'utf - 8 ' ) ; const style Content = style File . ends With ( ' .scss ' ) ? build Sass ( origin Content , style File ) : origin Content ; const shortened Style = style Content . replace ( / ( [ \n \r ] \s * ) + / gm , ' ' ) . replace ( / " / g , ' \ \ " ' ) ; return ` $ { shortened Style } ` ; } ) . join ( ' , \n ' ) + ' ] ' ; } ) ; } 
function build Sass ( content , source File ) { try { const result = sass . render Sync ( { data : content , file : source File , importer : tilde Importer } ) ; return result . css . to String ( ) } catch ( e ) { console . error ( ' \x 1b [ 4 1m ' ) ; console . error ( 'at ' + source File + ' : ' + e . line + " : " + e . column ) ; console . error ( e . formatted ) ; console . error ( ' \x 1b [ 0m ' ) ; return " " ; } } 
function Formio Resource Routes ( config ) { config = config | | { } ; return [ { path : ' ' , component : config . index | | index _component _ 1 . Formio Resource Index Component } , { path : 'new ' , component : config . create | | create _component _ 1 . Formio Resource Create Component } , { path : ' :id ' , component : config . resource | | resource _component _ 1 . Formio Resource Component , children : [ { path : ' ' , redirect To : 'view ' , path Match : 'full ' } , { path : 'view ' , component : config . view | | view _component _ 1 . Formio Resource View Component } , { path : 'edit ' , component : config . edit | | edit _component _ 1 . Formio Resource Edit Component } , { path : 'delete ' , component : config . delete | | delete _component _ 1 . Formio Resource Delete Component } ] } ] ; } 
function group Partitions By Topic ( topic Partitions ) { assert ( Array . is Array ( topic Partitions ) ) ; return topic Partitions . reduce ( function ( result , tp ) { if ( ! ( tp . topic in result ) ) { result [ tp . topic ] = [ tp . partition ] ; } else { result [ tp . topic ] . push ( tp . partition ) ; } return result ; } , { } ) ; } 
function create Topic Partition List ( topic Partitions ) { var tp List = [ ] ; for ( var topic in topic Partitions ) { if ( ! topic Partitions . has Own Property ( topic ) ) { continue ; } topic Partitions [ topic ] . for Each ( function ( partition ) { tp List . push ( { topic : topic , partition : partition } ) ; } ) ; } return tp List ; } 
function decode Snappy ( buffer , cb ) { if ( is Chunked ( buffer ) ) { var pos = 1 6 ; var max = buffer . length ; var encoded = [ ] ; var size ; while ( pos < max ) { size = buffer . read UInt 3 2BE ( pos ) ; pos + = 4 ; encoded . push ( buffer . slice ( pos , pos + size ) ) ; pos + = size ; } return async . map Series ( encoded , snappy . uncompress , function ( err , decoded Chunks ) { if ( err ) return cb ( err ) ; return cb ( null , Buffer . concat ( decoded Chunks ) ) ; } ) ; } return snappy . uncompress ( buffer , cb ) ; } 
function parse Host ( host String ) { const ip = host String . substring ( 0 , host String . last Index Of ( ' : ' ) ) ; const port = + host String . substring ( host String . last Index Of ( ' : ' ) + 1 ) ; const is Ipv 6 = ip . match ( / \ [ ( . * ) \ ] / ) ; const host = is Ipv 6 ? is Ipv 6 [ 1 ] : ip ; return { host , port } ; } 
function Base Producer ( client , options , default Partitioner Type , custom Partitioner ) { Event Emitter . call ( this ) ; options = options | | { } ; this . ready = false ; this . client = client ; this . require Acks = options . require Acks = = = undefined ? DEFAULTS . require Acks : options . require Acks ; this . ack Timeout Ms = options . ack Timeout Ms = = = undefined ? DEFAULTS . ack Timeout Ms : options . ack Timeout Ms ; if ( custom Partitioner ! = = undefined & & options . partitioner Type ! = = PARTITIONER _TYPES . custom ) { throw new Error ( 'Partitioner Type must be custom if providing a custom Partitioner . ' ) ; } else if ( custom Partitioner = = = undefined & & options . partitioner Type = = = PARTITIONER _TYPES . custom ) { throw new Error ( 'No customer partitioner defined ' ) ; } var partitioner Type = PARTITIONER _MAP [ options . partitioner Type ] | | PARTITIONER _MAP [ default Partitioner Type ] ; 
function encode Group Protocol ( protocol ) { this . Int 1 6BE ( protocol . name . length ) . string ( protocol . name ) . string ( _encode Protocol Data ( protocol ) ) ; } 
function decode Member Assignment ( assignment Bytes ) { var assignment = { partitions : { } } ; Binary . parse ( assignment Bytes ) . word 1 6bs ( 'version ' ) . tap ( function ( vars ) { assignment . version = vars . version ; } ) . word 3 2bs ( 'partition Assignment ' ) . loop ( function ( end , vars ) { if ( vars . partition Assignment - - = = = 0 ) return end ( ) ; var topic ; var partitions = [ ] ; this . word 1 6bs ( 'topic ' ) . tap ( function ( vars ) { this . buffer ( 'topic ' , vars . topic ) ; topic = vars . topic . to String ( ) ; } ) . word 3 2bs ( 'partitions Num ' ) . loop ( function ( end , vars ) { if ( vars . partitions Num - - = = = 0 ) return end ( ) ; this . word 3 2bs ( 'partition ' ) . tap ( function ( vars ) { partitions . push ( vars . partition ) ; } ) ; } ) ; assignment . partitions [ topic ] = partitions ; } ) . word 3 2bs ( 'user Data ' ) . tap ( function ( vars ) { if ( vars . user Data = = null | | vars . user Data = = = - 1 ) { return ; } this . buffer ( 'user Data ' , vars . user Data ) ; try { assignment . user Data = JSON . parse ( vars . user Data . to String ( ) ) ; } catch ( e ) { assignment . user Data = 'JSON Parse error ' ; } } ) ; return assignment ; } 
function encode Join Group Request ( client Id , correlation Id , group Id , member Id , session Timeout , group Protocols ) { var request = encode Request Header ( client Id , correlation Id , REQUEST _TYPE . join Group ) ; request . Int 1 6BE ( group Id . length ) . string ( group Id ) . Int 3 2BE ( session Timeout ) . Int 1 6BE ( member Id . length ) . string ( member Id ) . Int 1 6BE ( GROUPS _PROTOCOL _TYPE . length ) . string ( GROUPS _PROTOCOL _TYPE ) . Int 3 2BE ( group Protocols . length ) ; group Protocols . for Each ( encode Group Protocol . bind ( request ) ) ; return encode Request With Length ( request . make ( ) ) ; } 
function decode Join Group Response ( resp ) { var result = { members : [ ] } ; var error ; Binary . parse ( resp ) . word 3 2bs ( 'size ' ) . word 3 2bs ( 'correlation Id ' ) . word 1 6bs ( 'error Code ' ) . tap ( function ( vars ) { error = create Group Error ( vars . error Code ) ; } ) . word 3 2bs ( 'generation Id ' ) . tap ( function ( vars ) { result . generation Id = vars . generation Id ; } ) . word 1 6bs ( 'group Protocol ' ) . tap ( function ( vars ) { this . buffer ( 'group Protocol ' , vars . group Protocol ) ; result . group Protocol = vars . group Protocol = vars . group Protocol . to String ( ) ; } ) . word 1 6bs ( 'leader Id ' ) . tap ( function ( vars ) { this . buffer ( 'leader Id ' , vars . leader Id ) ; result . leader Id = vars . leader Id = vars . leader Id . to String ( ) ; } ) . word 1 6bs ( 'member Id ' ) . tap ( function ( vars ) { this . buffer ( 'member Id ' , vars . member Id ) ; result . member Id = vars . member Id = vars . member Id . to String ( ) ; } ) . word 3 2bs ( 'member Num ' ) . loop ( function ( end , vars ) { if ( error ) { return end ( ) ; } if ( vars . member Num - - = = = 0 ) return end ( ) ; var member Metadata ; this . word 1 6bs ( 'group Member Id ' ) . tap ( function ( vars ) { this . buffer ( 'group Member Id ' , vars . group Member Id ) ; vars . member Id = vars . group Member Id . to String ( ) ; } ) . word 3 2bs ( 'member Metadata ' ) . tap ( function ( vars ) { if ( vars . member Metadata > - 1 ) { this . buffer ( 'member Metadata ' , vars . member Metadata ) ; member Metadata = decode Group Data ( this . vars . member Metadata ) ; member Metadata . id = vars . member Id ; result . members . push ( member Metadata ) ; } } ) ; } ) ; return error | | result ; } 
function fetch Offsets ( offset , topics , cb , when ) { if ( ! offset . ready ) { if ( when = = = - 1 ) { offset . once ( 'ready ' , ( ) = > offset . fetch Latest Offsets ( topics , cb ) ) ; } else if ( when = = = - 2 ) { offset . once ( 'ready ' , ( ) = > offset . fetch Earliest Offsets ( topics , cb ) ) ; } return ; } async . waterfall ( [ callback = > { offset . client . load Metadata For Topics ( topics , callback ) ; } , ( topics Meta Data , callback ) = > { var payloads = [ ] ; var meta Datas = topics Meta Data [ 1 ] . metadata ; Object . keys ( meta Datas ) . for Each ( function ( topic Name ) { var topic = meta Datas [ topic Name ] ; Object . keys ( topic ) . for Each ( function ( partition ) { payloads . push ( { topic : topic Name , partition : partition , time : when } ) ; } ) ; } ) ; if ( payloads . length = = = 0 ) { return callback ( new Error ( 'Topic (s ) does not exist ' ) ) ; } offset . fetch ( payloads , callback ) ; } , function ( results , callback ) { Object . keys ( results ) . for Each ( function ( topic Name ) { var topic = results [ topic Name ] ; Object . keys ( topic ) . for Each ( function ( partition Name ) { topic [ partition Name ] = topic [ partition Name ] [ 0 ] ; } ) ; } ) ; callback ( null , results ) ; } ] , cb ) ; } 
function wrap ( payloads , cb ) { var out = { } ; var count = Object . keys ( payloads ) . length ; return function ( err , data ) { 
function Context ( options ) { if ( ! options ) options = { body : ' ' , hostname : ' ' } ; const body = options . body ; const href = 'http : / / ' + options . hostname + ' / ' ; const cache = Object . create ( null ) ; const keys = [ ] ; this . atob = function ( str ) { return Buffer . from ( str , 'base 6 4 ' ) . to String ( 'binary ' ) ; } ; 
function handler ( options , { captcha } ) { return new Promise ( ( resolve , reject ) = > { 
function alternative ( options , { captcha : { url , site Key } } ) { 
function perform Request ( options , is First Request ) { 
function on Request Response ( options , error , response , body ) { const callback = options . callback ; 
function on Captcha ( options , response , body ) { const callback = options . callback ; 
function ( error ) { if ( error ) { 
function insert Ts ( name ) { const ts Index Path = path . resolve ( _ _dirname , ' . . /src /index .ts ' ) ; const ts Index File = fs . read File Sync ( ts Index Path , { encoding : 'utf - 8 ' } ) ; const module Exports = ts Index File . trim ( ) . split ( ' \n ' ) ; module Exports . push ( ` $ { name } ` ) ; sort By Module Path ( module Exports ) ; fs . write File Sync ( ts Index Path , ` $ { module Exports . join ( ' \n ' ) } \n ` ) ; } 
function insert Css ( name ) { const css Index Path = path . resolve ( _ _dirname , ' . . /assets /index .scss ' ) ; const css Index File = fs . read File Sync ( css Index Path , { encoding : 'utf - 8 ' } ) ; const css Import Str = ` $ { name } ` ; const css Index File Arr = css Index File . trim ( ) . split ( ' \n ' ) ; css Index File Arr . push ( css Import Str ) ; 
function add Files ( name ) { const packages Dir = path . resolve ( _ _dirname , ' . . /src ' ) ; const assets Dir = path . resolve ( _ _dirname , ' . . /assets ' ) ; const component Dir = ` $ { packages Dir } $ { name } ` ; const upper Component Name = get Component Name ( name ) ; console . log ( ` up per Component Name } ` ) ; if ( ! fs . exists Sync ( component Dir ) ) { fs . mkdir Sync ( component Dir ) ; } else { console . log ( ` $ { upper Component Name } ` ) ; process . exit ( 2 ) ; } fs . write File Sync ( ` $ { component Dir } ` , ` $ { upper Component Name } $ { upper Component Name } \n \n $ { upper Component Name } \n ` ) ; fs . write File Sync ( ` $ { component Dir } ` , ` $ { upper Component Name } $ { name } $ { upper Component Name } $ { upper Component Name } ` ) ; fs . write File Sync ( ` $ { component Dir } ` , ` $ { upper Component Name } $ { name } $ { upper Component Name } om ponent Name }    ` ) ; fs . write File Sync ( ` $ { component Dir } $ { upper Component Name } ` , ' ' ) ; fs . write File Sync ( ` $ { assets Dir } $ { name } ` , ' ' ) ; add Files To Index ( name ) ; } 
function create Mapper ( ) { var packages Dir = path . resolve ( _ _dirname , ' . . /src ' ) ; var packages = fs . readdir Sync ( packages Dir ) ; return packages . filter ( p = > fs . stat Sync ( path . join ( packages Dir , p ) ) . is Directory ( ) ) . reduce ( ( alias , p ) = > { alias [ ` $ { p } ` ] = ` $ { p } ` ; alias [ ` $ { p } ` ] = ` $ { p } ` ; return alias ; } , { } ) ; } 
function ( event ) { var that = $ ( this ) ; that . on ( 'click ' , on Map Click Handler ) ; that . off ( 'mouseleave ' , on Map Mouseleave Handler ) ; that . find ( 'iframe ' ) . css ( "pointer -events " , "none " ) ; } 
function toggle Documentation Sidebar ( ) { const sidebar Nav = document . query Selector ( 'nav .sidebar ' ) ; const trigger = document . query Selector ( ' .sidebar -opener ' ) ; function init ( ) { const body Size = document . body . client Width ; if ( body Size < = 9 6 0 & & sidebar Nav ) { trigger . add Event Listener ( 'click ' , ( ) = > { sidebar Nav . class List . toggle ( 'Showed ' ) ; trigger . class List . toggle ( 'Showed ' ) ; } ) ; } } init ( ) ; } 
function assets ( user Options = { } ) { const options = { . . . defaults , . . . user Options , } ; return ( files , metalsmith , cb ) = > { const src = metalsmith . path ( options . source ) ; const dest = options . destination ; 
function get Start Stop Boundaries ( parent , sidebar , top Offset ) { const bbox = parent . get Bounding Client Rect ( ) ; const sidebar Bbox = sidebar . get Bounding Client Rect ( ) ; const body Bbox = document . body . get Bounding Client Rect ( ) ; const container Absolute Top = bbox . top - body Bbox . top ; const sidebar Absolute Top = sidebar Bbox . top - body Bbox . top ; const margin Top = sidebar Absolute Top - container Absolute Top ; const start = container Absolute Top - top Offset ; const stop = bbox . height + container Absolute Top - sidebar Bbox . height - margin Top - top Offset ; return { start , stop , } ; } 
function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i + + ) args [ i ] = arguments [ i ] return fn . call ( this , old , args ) } } 
function before ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { fn . call ( this ) old . apply ( this , arguments ) } } 
function confirm ( msg , callback ) { var rl = readline . create Interface ( { input : process . stdin , output : process . stdout } ) rl . question ( msg , function ( input ) { rl . close ( ) callback ( / ^y |yes |ok |true $ / i . test ( input ) ) } ) } 
function copy Template ( from , to ) { write ( to , fs . read File Sync ( path . join ( TEMPLATE _DIR , from ) , 'utf - 8 ' ) ) } 
function copy Template Multi ( from Dir , to Dir , name Glob ) { fs . readdir Sync ( path . join ( TEMPLATE _DIR , from Dir ) ) . filter ( minimatch . filter ( name Glob , { match Base : true } ) ) . for Each ( function ( name ) { copy Template ( path . join ( from Dir , name ) , path . join ( to Dir , name ) ) } ) } 
function create Application ( name , dir ) { console . log ( ) 
function create App Name ( path Name ) { return path . basename ( path Name ) . replace ( / [ ^A -Za -z 0 - 9 . - ] + / g , ' - ' ) . replace ( / ^ [ - _ . ] + | - + $ / g , ' ' ) . to Lower Case ( ) } 
function empty Directory ( dir , fn ) { fs . readdir ( dir , function ( err , files ) { if ( err & & err . code ! = = 'ENOENT ' ) throw err fn ( ! files | | ! files . length ) } ) } 
function exit ( code ) { 
function load Template ( name ) { var contents = fs . read File Sync ( path . join ( _ _dirname , ' . . ' , 'templates ' , ( name + ' .ejs ' ) ) , 'utf - 8 ' ) var locals = Object . create ( null ) function render ( ) { return ejs . render ( contents , locals , { escape : util . inspect } ) } return { locals : locals , render : render } } 
function main ( ) { 
function mkdir ( base , dir ) { var loc = path . join ( base , dir ) console . log ( ' \x 1b [ 3 6mcreate \x 1b [ 0m : ' + loc + path . sep ) mkdirp . sync ( loc , MODE _ 0 7 5 5 ) } 
function renamed Option ( original Name , new Name ) { return function ( val ) { warning ( util . format ( "option ` %s ' has been renamed to ` %s ' " , original Name , new Name ) ) return val } } 
function warning ( message ) { console . error ( ) message . split ( ' \n ' ) . for Each ( function ( line ) { console . error ( ' warning : %s ' , line ) } ) console . error ( ) } 
function write ( file , str , mode ) { fs . write File Sync ( file , str , { mode : mode | | MODE _ 0 6 6 6 } ) console . log ( ' \x 1b [ 3 6mcreate \x 1b [ 0m : ' + file ) } 
function get Coordinates For Position ( trigger Bounding , Content Bounding , position , arrow , _ref ) { var offset X = _ref . offset X , offset Y = _ref . offset Y ; var margin = arrow ? 8 : 0 ; var args = position . split ( " " ) ; 
function string _array _to _rgb ( string _array ) { var rgbs = new Float 3 2Array ( string _array . length * 3 ) ; for ( var i = 0 ; i < string _array . length ; i + + ) { var color = new THREE . Color ( string _array [ i ] ) ; rgbs [ i * 3 + 0 ] = color . r ; rgbs [ i * 3 + 1 ] = color . g ; rgbs [ i * 3 + 2 ] = color . b ; } return rgbs ; } 
function bind _d 3 ( f , context ) { return function ( ) { var args = [ this ] . concat ( [ ] . slice . call ( arguments ) ) 
function render To String ( vnode , context , opts , inner , is Svg Mode , select Value ) { if ( vnode = = null | | typeof vnode = = = 'boolean ' ) { return ' ' ; } let node Name = vnode . type , props = vnode . props , is Component = false ; context = context | | { } ; opts = opts | | { } ; let pretty = ENABLE _PRETTY & & opts . pretty , indent Char = pretty & & typeof pretty = = = 'string ' ? pretty : ' \t ' ; 
async function start ( opts : * ) { const is Taken = await is Port Taken ( opts . port ) ; if ( is Taken ) { if ( ! opts . no _interactive ) { const { user Choice } = await inquirer . prompt ( { type : 'list ' , name : 'user Choice ' , message : ` $ { opts . port } ` , choices : [ ` $ { opts . port } ` , 'Quit ' , ] , } ) ; if ( user Choice = = = 'Quit ' ) { process . exit ( ) ; } try { await kill Process ( opts . port ) ; } catch ( e ) { logger . error ( ` \n $ { e . message } ` ) ; process . exit ( 1 ) ; } logger . info ( ` ` ) ; } else { logger . error ( ` $ { opts . port } ` ) ; process . exit ( 1 ) ; } } const directory = process . cwd ( ) ; const config Path = get Webpack Config Path ( directory , opts . config ) ; let assets Dest ; if ( opts . assets Dest ) { assets Dest = path . is Absolute ( opts . assets Dest ) ? opts . assets Dest : path . join ( directory , opts . assets Dest ) ; } else { assets Dest = fs . mkdtemp Sync ( path . join ( os . tmpdir ( ) , 'haul -start - ' ) ) ; } const config Options = { root : directory , assets Dest , dev : opts . dev , minify : opts . minify , port : opts . port , eager : opts . eager , disable Hot Reloading : ! opts . hot Reloading , } ; create Server ( { config Path , config Options , } ) . listen ( opts . port ) ; } 
function is Port Taken ( port : number ) : Promise < boolean > { return new Promise ( resolve = > { const port Tester = net . create Server ( ) . once ( 'error ' , ( ) = > { return resolve ( true ) ; } ) . once ( 'listening ' , ( ) = > { port Tester . close ( ) ; resolve ( false ) ; } ) . listen ( port ) ; } ) ; } 
async function bundle ( opts : * ) { const directory = process . cwd ( ) ; const config Path = get Webpack Config Path ( directory , opts . config ) ; const config = get Config ( config Path , { root : directory , dev : opts . dev , minify : opts . minify , bundle : true , } , opts . platform , logger ) ; if ( opts . assets Dest ) { config . output . path = path . is Absolute ( opts . assets Dest ) ? opts . assets Dest : path . join ( directory , opts . assets Dest ) ; } if ( opts . bundle Output ) { config . output . filename = path . is Absolute ( opts . bundle Output ) ? path . relative ( config . output . path , opts . bundle Output ) : path . relative ( config . output . path , path . join ( directory , opts . bundle Output ) ) ; } logger . info ( ` $ { config . output . path } ` ) ; logger . info ( ` $ { config . output . filename } ` ) ; logger . info ( ` $ { path . resolve ( config . output . filename ) } ` ) ; 
function adjust Options ( options ) { const directory = process . cwd ( ) ; const config Path = get Webpack Config Path ( directory , options . config ) ; const haul Options = get Haul Config ( config Path , logger ) ; if ( haul Options . platforms ) { const platform Option = command . options & & command . options . find ( _ = > _ . name = = = 'platform ' ) ; if ( platform Option ) { platform Option . choices = [ ] ; for ( const platform Name in haul Options . platforms ) { if ( Object . prototype . has Own Property . call ( haul Options . platforms , platform Name ) ) { if ( platform Option . choices ) { platform Option . choices . push ( { value : platform Name , description : ` $ { haul Options . platforms [ platform Name ] } ` , } ) ; } } } } } } 
function exec ( args : string ) : Promise < void > { return new Promise ( ( resolve , reject ) = > { child _process . exec ( args , ( err , stdout , stderr ) = > { if ( err ) { reject ( new Error ( stderr ) ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
function create Label ( platform : string ) { if ( label Options [ platform ] ) { const { color , label } = label Options [ platform ] ; return ` $ { chalk . bold [ color ] ( label ) } ` . pad End ( 3 0 ) ; } return ` $ { chalk . bold . magenta ( platform ) } ` . pad End ( 3 0 ) ; } 
function create Bar Format ( platform : string ) { const label = create Label ( platform ) ; const left Bar = chalk . bold ( ' [ ' ) ; const right Bar = chalk . bold ( ' ] ' ) ; const percent = chalk . bold . blue ( ' :percent ' ) ; return ` $ { label } $ { left Bar } $ { right Bar } $ { percent } ` ; } 
function clean Path Middleware ( req , res , next ) { req . clean Path = req . path . replace ( / \ / $ / , ' ' ) ; next ( ) ; } 
function create Server ( config : { config Path : ? string , config Options : Object } ) { const app Handler = express ( ) ; app Handler . disable ( 'etag ' ) ; const { config Path , config Options } = config ; const compiler = new Compiler ( { config Path , config Options , } ) ; const logger Middleware = init UI ( compiler , config Options ) ; process . on ( 'uncaught Exception ' , err = > { compiler . terminate ( ) ; throw err ; } ) ; process . on ( 'SIGINT ' , ( ) = > { compiler . terminate ( ) ; process . exit ( 0 ) ; } ) ; process . on ( 'SIGTERM ' , ( ) = > { compiler . terminate ( ) ; process . exit ( 2 ) ; } ) ; const compiler Middleware = create Compiler Middleware ( compiler , { config Path , config Options , } ) ; const http Server = http . create Server ( app Handler ) ; const web Socket Server = new Web Socket Server ( { server : http Server } ) ; const debugger Proxy = new Web Socket Debugger Proxy ( web Socket Proxy ( web Socket Server , ' /debugger -proxy ' ) ) ; if ( ! config Options . disable Hot Reloading ) { hot Middleware ( compiler , { native Proxy : web Socket Proxy ( web Socket Server , ' /hot ' ) , haul Proxy : web Socket Proxy ( web Socket Server , ' /haul -hmr ' ) , } ) ; } 
function dev Tools Middleware ( debugger Proxy ) { return ( req , res , next ) = > { switch ( req . clean Path ) { case ' /debugger -ui / ' : case ' /debugger -ui ' : { const read Stream = fs . create Read Stream ( path . join ( _ _dirname , ' . . /assets /debugger .html ' ) ) ; res . write Head ( 2 0 0 , { 'Content -Type ' : 'text /html ' } ) ; read Stream . pipe ( res ) ; break ; } case ' /debugger -ui /debugger Worker .js ' : case ' /debugger Worker .js ' : { const read Stream = fs . create Read Stream ( path . join ( _ _dirname , ' . . /assets /debugger Worker .js ' ) ) ; res . write Head ( 2 0 0 , { 'Content -Type ' : 'application /javascript ' } ) ; read Stream . pipe ( res ) ; break ; } case ' /launch -js -devtools ' : { if ( ! debugger Proxy . is Debugger Connected ( ) ) { launch Browser ( ` $ { req . socket . local Port } ` ) ; } res . end ( 'OK ' ) ; break ; } default : next ( ) ; } } ; } 
function normalize Options ( { path , quiet , overlay , reload , name } ) { const should Log = ! quiet ; const options = { path , overlay : true , reload : false , name : ' ' , logger : { should Log , log ( . . . args ) { if ( should Log ) { console . log ( . . . args ) ; } } , warn ( . . . args ) { if ( should Log ) { console . warn ( . . . args ) ; } } , error ( . . . args ) { if ( should Log ) { console . error ( . . . args ) ; } } , } , } ; if ( overlay ) { options . overlay = overlay ! = = 'false ' ; } if ( reload ) { options . reload = reload ! = = 'false ' ; } if ( name ) { options . name = name ; } return options ; } 
async function create Source Map Consumer ( compiler : Compiler , url : string ) { const response = await fetch ( url ) ; const source Map = await response . text ( ) ; 
function fix Require Issue ( ) { return { visitor : { Assignment Expression ( path ) { if ( path . node . operator = = = ' = ' ) { const { left } = path . node ; if ( left . type ! = = 'Member Expression ' ) { return ; } const { object } = left ; if ( 
function find Index ( predicate , context ) { if ( this = = null ) { throw new Type Error ( 'Array .prototype .find Index called on null or undefined ' ) ; } if ( typeof predicate ! = = 'function ' ) { throw new Type Error ( 'predicate must be a function ' ) ; } const list = Object ( this ) ; const length = list . length > > > 0 ; for ( let i = 0 ; i < length ; i + + ) { if ( predicate . call ( context , list [ i ] , i , list ) ) { return i ; } } return - 1 ; } 
function on Load ( event ) { 
function prefix Substrings ( prefix , substrings , strings ) { let prefixed , reg Exp ; for ( const substring of substrings ) { prefixed = " $ 1 " + prefix + substring . char At ( 0 ) . to Upper Case ( ) + substring . slice ( 1 ) ; reg Exp = new Reg Exp ( " ( [ ^ \ \ . ] ) ( \ \b " + substring + " \ \b ) " , "g " ) ; for ( const entry of strings . entries ( ) ) { if ( entry [ 1 ] ! = = null ) { strings . set ( entry [ 0 ] , entry [ 1 ] . replace ( reg Exp , prefixed ) ) ; } } } } 
function integrate Effect ( prefix , effect , shader Parts , blend Modes , defines , uniforms , attributes ) { const function Reg Exp = / ( ? : \w + \s + ( \w + ) \ ( [ \w \s , ] * \ ) \s * { [ ^ } ] + } ) / g ; const varying Reg Exp = / ( ? :varying \s + \w + \s + ( \w * ) ) / g ; const blend Mode = effect . blend Mode ; const shaders = new Map ( [ [ "fragment " , effect . fragment Shader ] , [ "vertex " , effect . vertex Shader ] ] ) ; const main Image Exists = ( shaders . get ( "fragment " ) ! = = undefined & & shaders . get ( "fragment " ) . index Of ( "main Image " ) > = 0 ) ; const main Uv Exists = ( shaders . get ( "fragment " ) ! = = undefined & & shaders . get ( "fragment " ) . index Of ( "main Uv " ) > = 0 ) ; let varyings = [ ] , names = [ ] ; let transformed Uv = false ; let read Depth = false ; if ( shaders . get ( "fragment " ) = = = undefined ) { console . error ( "Missing fragment shader " , effect ) ; } else if ( main Uv Exists & & ( attributes & Effect Attribute . CONVOLUTION ) ! = = 0 ) { console . error ( "Effects that transform UV coordinates are incompatible with convolution effects " , effect ) ; } else if ( ! main Image Exists & & ! main Uv Exists ) { console . error ( "The fragment shader contains neither a main Image nor a main Uv function " , effect ) ; } else { if ( main Uv Exists ) { shader Parts . set ( Section . FRAGMENT _MAIN _UV , shader Parts . get ( Section . FRAGMENT _MAIN _UV ) + " \t " + prefix + "Main Uv (UV ) ; \n " ) ; transformed Uv = true ; } if ( shaders . get ( "vertex " ) ! = = null & & shaders . get ( "vertex " ) . index Of ( "main Support " ) > = 0 ) { shader Parts . set ( Section . VERTEX _MAIN _SUPPORT , shader Parts . get ( Section . VERTEX _MAIN _SUPPORT ) + " \t " + prefix + "Main Support ( ) ; \n " ) ; varyings = varyings . concat ( find Substrings ( varying Reg Exp , shaders . get ( "vertex " ) ) ) ; names = names . concat ( varyings ) . concat ( find Substrings ( function Reg Exp , shaders . get ( "vertex " ) ) ) ; } names = names . concat ( find Substrings ( function Reg Exp , shaders . get ( "fragment " ) ) ) . concat ( Array . from ( effect . uniforms . keys ( ) ) ) . concat ( Array . from ( effect . defines . keys ( ) ) ) ; 
function create Canvas ( width , height , data , channels ) { const canvas = document . create Element NS ( "http : / /www .w 3 .org / 1 9 9 9 /xhtml " , "canvas " ) ; const context = canvas . get Context ( " 2d " ) ; const image Data = context . create Image Data ( width , height ) ; const target = image Data . data ; let x , y ; let i , j ; for ( y = 0 ; y < height ; + + y ) { for ( x = 0 ; x < width ; + + x ) { i = ( y * width + x ) * 4 ; j = ( y * width + x ) * channels ; target [ i ] = ( channels > 0 ) ? data [ j ] : 0 ; target [ i + 1 ] = ( channels > 1 ) ? data [ j + 1 ] : 0 ; target [ i + 2 ] = ( channels > 2 ) ? data [ j + 2 ] : 0 ; target [ i + 3 ] = ( channels > 3 ) ? data [ j + 3 ] : 2 5 5 ; } } canvas . width = width ; canvas . height = height ; context . put Image Data ( image Data , 0 , 0 ) ; return canvas ; } 
function smooth Area ( d , b ) { const a 1 = b . min ; const a 2 = b . max ; const b 1X = Math . sqrt ( a 1 . x * 2 . 0 ) * 0 . 5 ; const b 1Y = Math . sqrt ( a 1 . y * 2 . 0 ) * 0 . 5 ; const b 2X = Math . sqrt ( a 2 . x * 2 . 0 ) * 0 . 5 ; const b 2Y = Math . sqrt ( a 2 . y * 2 . 0 ) * 0 . 5 ; const p = saturate ( d / SMOOTH _MAX _DISTANCE ) ; a 1 . set ( lerp ( b 1X , a 1 . x , p ) , lerp ( b 1Y , a 1 . y , p ) ) ; a 2 . set ( lerp ( b 2X , a 2 . x , p ) , lerp ( b 2Y , a 2 . y , p ) ) ; return b ; } 
function calculate Diagonal Area For Pixel ( p 1 , p 2 , p X , p Y ) { let a ; let x , y ; let offset X , offset Y ; for ( a = 0 , y = 0 ; y < DIAGONAL _SAMPLES ; + + y ) { for ( x = 0 ; x < DIAGONAL _SAMPLES ; + + x ) { offset X = x / ( DIAGONAL _SAMPLES - 1 . 0 ) ; offset Y = y / ( DIAGONAL _SAMPLES - 1 . 0 ) ; if ( is Inside Area ( p 1 , p 2 , p X + offset X , p Y + offset Y ) ) { + + a ; } } } return a / ( DIAGONAL _SAMPLES * DIAGONAL _SAMPLES ) ; } 
function calculate Diagonal Area ( pattern , p 1 , p 2 , left , offset , result ) { const e = diagonal Edges [ pattern ] ; const e 1 = e [ 0 ] ; const e 2 = e [ 1 ] ; if ( e 1 > 0 ) { p 1 . x + = offset [ 0 ] ; p 1 . y + = offset [ 1 ] ; } if ( e 2 > 0 ) { p 2 . x + = offset [ 0 ] ; p 2 . y + = offset [ 1 ] ; } return result . set ( 1 . 0 - calculate Diagonal Area For Pixel ( p 1 , p 2 , 1 . 0 + left , 0 . 0 + left ) , calculate Diagonal Area For Pixel ( p 1 , p 2 , 1 . 0 + left , 1 . 0 + left ) ) ; } 
function calculate Diagonal Area For Pattern ( pattern , left , right , offset , result ) { const p 1 = b 0 . min ; const p 2 = b 0 . max ; const a 1 = b 1 . min ; const a 2 = b 1 . max ; const d = left + right + 1 ; switch ( pattern ) { case 0 : { * . -  * . -  * . -  * | * | * / calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 0 . 0 + d , 0 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 2 : { calculate Diagonal Area ( pattern , p 1 . set ( 0 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 3 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , result ) ; break ; } case 4 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 0 . 0 + d , 0 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 5 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 0 . 0 + d , 0 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 6 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , result ) ; break ; } case 7 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 8 : { calculate Diagonal Area ( pattern , p 1 . set ( 0 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 9 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , result ) ; break ; } case 1 0 : { calculate Diagonal Area ( pattern , p 1 . set ( 0 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 1 1 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 1 2 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , result ) ; break ; } case 1 3 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 1 4 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } case 1 5 : { calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 1 . 0 ) , p 2 . set ( 1 . 0 + d , 1 . 0 + d ) , left , offset , a 1 ) ; calculate Diagonal Area ( pattern , p 1 . set ( 1 . 0 , 0 . 0 ) , p 2 . set ( 1 . 0 + d , 0 . 0 + d ) , left , offset , a 2 ) ; result . add Vectors ( a 1 , a 2 ) . divide Scalar ( 2 . 0 ) ; break ; } } return result ; } 
function generate Patterns ( patterns , offset , orthogonal ) { const result = new Vector 2 ( ) ; let i , l ; let x , y ; let c ; let pattern ; let data , size ; for ( i = 0 , l = patterns . length ; i < l ; + + i ) { pattern = patterns [ i ] ; data = pattern . data ; size = pattern . width ; for ( y = 0 ; y < size ; + + y ) { for ( x = 0 ; x < size ; + + x ) { if ( orthogonal ) { calculate Orthogonal Area For Pattern ( i , x , y , offset , result ) ; } else { calculate Diagonal Area For Pattern ( i , x , y , offset , result ) ; } c = ( y * size + x ) * 2 ; data [ c ] = result . x * 2 5 5 ; data [ c + 1 ] = result . y * 2 5 5 ; } } } } 
function assemble ( base , patterns , edges , size , orthogonal , target ) { const p = new Vector 2 ( ) ; const dst Data = target . data ; const dst Width = target . width ; let i , l ; let x , y ; let c , d ; let edge ; let pattern ; let src Data , src Width ; for ( i = 0 , l = patterns . length ; i < l ; + + i ) { edge = edges [ i ] ; pattern = patterns [ i ] ; src Data = pattern . data ; src Width = pattern . width ; for ( y = 0 ; y < size ; + + y ) { for ( x = 0 ; x < size ; + + x ) { p . from Array ( edge ) . multiply Scalar ( size ) ; p . add ( base ) ; p . x + = x ; p . y + = y ; c = ( p . y * dst Width + p . x ) * 2 ; d = orthogonal ? ( ( y * y * src Width + x * x ) * 2 ) : ( ( y * src Width + x ) * 2 ) ; dst Data [ c ] = src Data [ d ] ; dst Data [ c + 1 ] = src Data [ d + 1 ] ; } } } } 
function delta Right ( left , top ) { let d = 0 ; crossing edges , continue . * / if ( d = = = 1 & & top [ 2 ] = = = 1 & & left [ 0 ] ! = = 1 & & left [ 2 ] ! = = 1 ) { d + = 1 ; } return d ; } 
function bilinear ( e ) { const a = lerp ( e [ 0 ] , e [ 1 ] , 1 . 0 - 0 . 2 5 ) ; const b = lerp ( e [ 2 ] , e [ 3 ] , 1 . 0 - 0 . 2 5 ) ; return lerp ( a , b , 1 . 0 - 0 . 1 2 5 ) ; } 
function get Keys ( ) { keys = { pageup : 3 3 , pagedown : 3 4 , end : 3 5 , home : 3 6 , left : 3 7 , up : 3 8 , right : 3 9 , down : 4 0 , } return keys } 
function check Form ( that ) { var new Value = $ ( that ) . val ( ) var matches = new Value ! = ' ' ? new Value . match ( time Reg Ex ) : ' ' var error = $ ( that ) . closest ( ' .time -spinner ' ) . find ( ' .error _container ' ) var $closer Time Spinner = $ ( that ) . closest ( ' .time -spinner ' ) . find ( ' .spinner -control ' ) if ( matches ) { $ ( error ) . html ( ' ' ) 
function mc _symbol _clone ( ) { var clone = this . _clone Props ( new this . constructor ( this . mode , this . start Position , this . loop ) ) ; clone . goto And Stop ( this . current Frame ) ; clone . paused = this . paused ; clone . framerate = this . framerate ; return clone ; } 
function reset To Move ( context Control ) { var left = context Control . find ( ' .source .transfer -group ' ) var right = context Control . find ( ' .target .transfer -group ' ) var text Left = context Control . find ( ' .source .transfer -header span .num ' ) var text Right = context Control . find ( ' .target .transfer -header span .num ' ) var header = context Control . find ( ' .transfer -header input ' ) $ ( left ) . html ( elem Left ) $ ( right ) . html ( elem Right ) $ ( text Left ) . text ( elem Left Num ) $ ( text Right ) . text ( elem Right Num ) $ ( header ) . prop ( 'disabled ' , false ) } 
function check If Active ( target Control , target Header Control , container Type Control , add Button Control ) { $ ( target Control ) . each ( function ( el ) { if ( $ ( this ) . prop ( 'checked ' ) ) { if ( ! $ ( target Header Control ) . has Class ( 'semi -checked ' ) ) { $ ( target Header Control ) . add Class ( 'semi -checked ' ) $ ( target Header Control ) . prop ( 'checked ' , false ) if ( container Type Control . has Class ( 'source ' ) ) { $ ( add Button Control ) . add Class ( 'active ' ) } if ( container Type Control . has Class ( 'target ' ) ) { $ ( inverse Button ) . add Class ( 'active ' ) } } return false } else { $ ( target Header Control ) . remove Class ( 'semi -checked ' ) if ( container Type Control . has Class ( 'source ' ) ) { $ ( add Button Control ) . remove Class ( 'active ' ) } if ( container Type Control . has Class ( 'target ' ) ) { $ ( inverse Button ) . remove Class ( 'active ' ) } } } ) } 
function source Control ( context Control ) { var tocheck = context Control . find ( ' .transfer -scroll ' ) . find ( 'input ' ) var checknum = tocheck . length var target Text = context Control . find ( ' .transfer -header ' ) . find ( 'label span .num ' ) var header = context Control . find ( ' .transfer -header input ' ) $ ( header ) . prop ( 'checked ' , false ) . remove Class ( 'semi -checked ' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled ' , true ) } else { $ ( header ) . prop ( 'disabled ' , false ) } $ ( target Text ) . text ( checknum ) } 
function target Control ( target Control ) { var tocheck = target Control . find ( 'input ' ) var checknum = tocheck . length var target Text = tocheck . closest ( ' .it -transfer -wrapper ' ) . find ( ' .transfer -header ' ) . find ( 'label span .num ' ) var header = $ ( target Control ) . find ( ' .transfer -header input ' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled ' , true ) } else { $ ( header ) . prop ( 'disabled ' , false ) } $ ( target Text ) . text ( checknum ) } 
function check To Move ( context Control , target Control ) { var elements = context Control . find ( ' .transfer -group ' ) . find ( 'input :checked ' ) var source Tag = $ ( elements ) . closest ( ' .form -check ' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked ' , false ) $ ( source Tag ) . detach ( ) . append To ( target Control ) . add Class ( 'added ' ) } ) } 
function input Number Resize ( $target ) { var $input Number = $target . closest ( ' .input -number ' ) if ( $input Number . has Class ( 'input -number -adaptive ' ) ) { 
function update Scroll Pos ( ) { if ( ! stickies . length ) { return } last Known Scroll Top = document . document Element . scroll Top | | document . body . scroll Top 
function score Text ( score ) { if ( score = = = - 1 ) { return options . short Pass } score = score < 0 ? 0 : score if ( score < 2 6 ) { return options . short Pass } if ( score < 5 1 ) { return options . bad Pass } if ( score < 7 6 ) { return options . good Pass } return options . strong Pass } 
function calculate Score ( password ) { var score = 0 
function check Repetition ( r Len , str ) { var res = ' ' , repeated = false for ( var i = 0 ; i < str . length ; i + + ) { repeated = true for ( var j = 0 ; j < r Len & & j + i + r Len < str . length ; j + + ) { repeated = repeated & & str . char At ( j + i ) = = = str . char At ( j + i + r Len ) } if ( j < r Len ) { repeated = false } if ( repeated ) { i + = r Len - 1 repeated = false } else { res + = str . char At ( i ) } } return res } 
function init ( ) { var shown = true var $text = options . show Text var $graybar = $ ( ' <div > ' ) . add Class ( 'password -meter progress rounded - 0 position -absolute ' ) $graybar . append ( ` ` ) var $colorbar = $ ( ' <div > ' ) . attr ( { class : 'progress -bar ' , role : 'progressbar ' , 'aria -valuenow ' : ' 0 ' , 'aria -valuemin ' : ' 0 ' , 'aria -valuemax ' : ' 1 0 0 ' , } ) var $insert = $ ( ' <div > ' ) . append ( $graybar . append ( $colorbar ) ) if ( options . show Text ) { $text = $ ( ' <small > ' ) . add Class ( 'form -text text -muted ' ) . html ( options . enter Pass ) $insert . prepend ( $text ) } $object . after ( $insert ) $object . keyup ( function ( ) { var score = calculate Score ( $object . val ( ) ) $object . trigger ( 'password .score ' , [ score ] ) var perc = score < 0 ? 0 : score $colorbar . remove Class ( function ( index , class Name ) { return ( class Name . match ( / ( ^ | \s )bg - \S + / g ) | | [ ] ) . join ( ' ' ) } ) $colorbar . add Class ( 'bg - ' + score Color ( score ) ) $colorbar . css ( { width : perc + ' % ' , } ) $colorbar . attr ( 'aria -valuenow ' , perc ) if ( options . show Text ) { var text = score Text ( score ) if ( ! $object . val ( ) . length & & score < = 0 ) { text = options . enter Pass } if ( $text . html ( ) ! = = $ ( ' <div > ' ) . html ( text ) . html ( ) ) { $text . html ( text ) $text . remove Class ( function ( index , class Name ) { return ( class Name . match ( / ( ^ | \s )text - \S + / g ) | | [ ] ) . join ( ' ' ) } ) $text . add Class ( 'text - ' + score Color ( score ) ) $object . trigger ( 'password .text ' , [ text , score ] ) } } } ) return this } 
function Log ( data ) { var self = this ; Object . keys ( data ) . for Each ( function ( key ) { self [ key ] = data [ key ] ; } ) ; } 
function ( length , rng ) { var buf = [ ] ; for ( var i = 0 ; i < length ; i + + ) { buf . push ( rng ( ) * 2 5 5 ) ; } return Buffer . from ( buf ) ; } 
function Level Up Array Adapter ( name , db , serializer ) { this . db = Sublevel ( db ) ; this . db = this . db . sublevel ( name ) ; this . name = name ; this . serializer = serializer | | { encode : function ( val , callback ) { callback ( null , val ) ; } , decode : function ( val , callback ) { callback ( null , val ) ; } } ; } 
function fix Props ( tx , data ) { * @prop {Buffer } from (read /write ) Set from address to bypass transaction * signing on fake transactions . * / Object . define Property ( tx , "from " , { enumerable : true , configurable : true , get : tx . get Sender Address . bind ( tx ) , set : ( val ) = > { if ( val ) { tx . _from = eth Util . to Buffer ( val ) ; } else { tx . _from = null ; } } } ) ; if ( data & & data . from ) { tx . from = data . from ; } tx . hash = fake Hash ; } } 
function init Data ( tx , data ) { if ( data ) { if ( typeof data = = = "string " ) { data = to . buffer ( data ) ; } if ( Buffer . is Buffer ( data ) ) { data = rlp . decode ( data ) ; } const self = tx ; if ( Array . is Array ( data ) ) { if ( data . length > tx . _fields . length ) { throw new Error ( "wrong number of fields in data " ) ; } 
function TXRejected Error ( message ) { 
function Runtime Error ( transactions , vm Output ) { 
function ( val ) { if ( typeof val = = = "string " ) { if ( val . index Of ( " 0x " ) = = = 0 ) { return val . trim ( ) ; } else { val = new utils . BN ( val ) ; } } if ( typeof val = = = "boolean " ) { val = val ? 1 : 0 ; } if ( typeof val = = = "number " ) { val = utils . int To Hex ( val ) ; } else if ( val = = null ) { return " 0x " ; } else if ( typeof val = = = "object " ) { 
function ( number , done ) { try { number = to . number ( number ) ; } catch ( e ) { 
function Request Funnel ( ) { 
function compile Sass ( _path , ext , data , callback ) { const compiled Css = sass . render Sync ( { data : data , output Style : 'expanded ' , importer : function ( url , prev , done ) { if ( url . starts With ( ' ~ ' ) ) { const new Url = path . join ( _ _dirname , 'node _modules ' , url . substr ( 1 ) ) ; return { file : new Url } ; } else { return { file : url } ; } } } ) ; callback ( null , compiled Css . css ) ; } 
function require Brocfile ( brocfile Path ) { let brocfile ; if ( brocfile Path . match ( / \ .ts $ / ) ) { try { require . resolve ( 'ts -node ' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } try { require . resolve ( 'typescript ' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } 
function State ( rule , dot , reference , wanted By ) { this . rule = rule ; this . dot = dot ; this . reference = reference ; this . data = [ ] ; this . wanted By = wanted By ; this . is Complete = this . dot = = = rule . symbols . length ; } 
function runmath ( s ) { var ans ; try { 
function ( read Field , result , end ) { end = end | | this . length ; while ( this . pos < end ) { var val = this . read Varint ( ) , tag = val > > 3 , start Pos = this . pos ; this . type = val & 0x 7 ; read Field ( tag , result , this ) ; if ( this . pos = = = start Pos ) this . skip ( val ) ; } return result ; } 
function ( ) { var val = read UInt 3 2 ( this . buf , this . pos ) + read UInt 3 2 ( this . buf , this . pos + 4 ) * SHIFT _LEFT _ 3 2 ; this . pos + = 8 ; return val ; } 
function ( arr , is Signed ) { if ( this . type ! = = Pbf . Bytes ) return arr . push ( this . read Varint ( is Signed ) ) ; var end = read Packed End ( this ) ; arr = arr | | [ ] ; while ( this . pos < end ) arr . push ( this . read Varint ( is Signed ) ) ; return arr ; } 
function read UInt 3 2 ( buf , pos ) { return ( ( buf [ pos ] ) | ( buf [ pos + 1 ] < < 8 ) | ( buf [ pos + 2 ] < < 1 6 ) ) + ( buf [ pos + 3 ] * 0x 1 0 0 0 0 0 0 ) ; } 
function stringify Outer Order ( orders , q ) { const conditions = [ ] for ( let condition of orders ) { for ( let column in condition . columns ) { const direction = condition . columns [ column ] conditions . push ( ` $ { q ( condition . table ) } $ { q ( column ) } $ { direction } ` ) } } return conditions . join ( ' , ' ) } 
function handle Union Selections ( sql ASTNode , children , selections , gql Type , namespace , depth , options , context , internal Options = { } ) { for ( let selection of selections ) { 
function handle Selections ( sql ASTNode , children , selections , gql Type , namespace , depth , options , context , internal Options = { } , ) { for ( let selection of selections ) { 
function column To ASTChild ( column Name , namespace ) { return { type : 'column ' , name : column Name , field Name : column Name , as : namespace . generate ( 'column ' , column Name ) } } 
function key To ASTChild ( key , namespace ) { if ( typeof key = = = 'string ' ) { return column To ASTChild ( key , namespace ) } if ( Array . is Array ( key ) ) { const clumsy Name = to Clumsy Name ( key ) return { type : 'composite ' , name : key , field Name : clumsy Name , as : namespace . generate ( 'column ' , clumsy Name ) } } } 
function strip Relay Connection ( gql Type , query ASTNode , fragments ) { 
function spread Fragments ( selections , fragments , type Name ) { return flat Map ( selections , selection = > { switch ( selection . kind ) { case 'Fragment Spread ' : const fragment Name = selection . name . value const fragment = fragments [ fragment Name ] return spread Fragments ( fragment . selection Set . selections , fragments , type Name ) case 'Inline Fragment ' : if ( selection . type Condition . name . value = = = type Name ) { return spread Fragments ( selection . selection Set . selections , fragments , type Name ) } return [ ] default : return selection } } ) } 
async function join Monster ( resolve Info , context , db Call , options = { } ) { 
async function get Node ( type Name , resolve Info , context , condition , db Call , options = { } ) { 
async function next Batch Child ( child AST , data , db Call , context , options ) { if ( child AST . type ! = = 'table ' & & child AST . type ! = = 'union ' ) return const field Name = child AST . field Name 
function arr To Connection ( data , sql AST ) { 
function validate ( rows ) { 
function sort Key To Where Condition ( key Obj , descending , sort Table , dialect ) { const { name , quote : q } = dialect const sort Columns = [ ] const sort Values = [ ] for ( let key in key Obj ) { sort Columns . push ( ` $ { q ( sort Table ) } $ { q ( key ) } ` ) sort Values . push ( maybe Quote ( key Obj [ key ] , name ) ) } const operator = descending ? ' < ' : ' > ' return name = = = 'oracle ' ? recursive Where Join ( sort Columns , sort Values , operator ) : ` $ { sort Columns . join ( ' , ' ) } $ { operator } $ { sort Values . join ( ' , ' ) } ` } 
function ( ) { 
function filter By Store Keys ( store Keys , obj ) { 
function clone ( frm , to ) { if ( frm = = = null | | typeof frm ! = = "object " ) { return frm ; } if ( frm . constructor ! = = Object & & frm . constructor ! = = Array ) { return frm ; } if ( frm . constructor = = = Date | | frm . constructor = = = Reg Exp | | frm . constructor = = = Function | | frm . constructor = = = String | | frm . constructor = = = Number | | frm . constructor = = = Boolean ) { return new frm . constructor ( frm ) ; } to = to | | new frm . constructor ( ) ; for ( var name in frm ) { to [ name ] = typeof to [ name ] = = = "undefined " ? clone ( frm [ name ] , null ) : to [ name ] ; } return to ; } 
function ( ) { for ( var m in Listener Methods ) { if ( this [ m ] ! = = Listener Methods [ m ] ) { if ( this [ m ] ) { throw "Can 't have other property ' " + m + " ' when using Reflux .listen To ! " ; } this [ m ] = Listener Methods [ m ] ; } } this . listen To ( listenable , callback , initial ) ; } 
function ( ) { for ( var m in Listener Methods ) { if ( this [ m ] ! = = Listener Methods [ m ] ) { if ( this [ m ] ) { throw "Can 't have other property ' " + m + " ' when using Reflux .listen To Many ! " ; } this [ m ] = Listener Methods [ m ] ; } } this . listen To Many ( listenables ) ; } 
function ( data ) { var entries var self = this var input = Object . assign ( { } , data ) 
function ( value ) { var safe = / ^ [a -z 0 - 9 - _ / . @ % ^ = : ] + $ / i 
function build String ( length , str ) { return Array . apply ( null , new Array ( length ) ) . map ( String . prototype . value Of , str ) . join ( ' ' ) } 
function concat Array ( arr , pretty , indentation , indent Level ) { var current Indent = build String ( indent Level , indentation ) var closing Brace Indent = build String ( indent Level - 1 , indentation ) var join = pretty ? ' , \n ' + current Indent : ' , ' if ( pretty ) { return ' [ \n ' + current Indent + arr . join ( join ) + ' \n ' + closing Brace Indent + ' ] ' } else { return ' [ ' + arr . join ( join ) + ' ] ' } } 
function ( value , opts , indent Level ) { indent Level = indent Level = = = undefined ? 1 : indent Level + 1 switch ( Object . prototype . to String . call ( value ) ) { case ' [object Number ] ' : return value case ' [object Array ] ' : 
function multipart ( handler , done , opts ) { if ( typeof handler ! = = 'function ' ) { throw new Error ( 'handler must be a function ' ) } if ( typeof done ! = = 'function ' ) { throw new Error ( 'the callback must be a function ' ) } if ( ! this . is Multipart ( ) ) { done ( new Error ( 'the request is not multipart ' ) ) return } const log = this . log log . debug ( 'starting multipart parsing ' ) const req = this . req const busboy Options = deepmerge . all ( [ { headers : req . headers } , options | | { } , opts | | { } ] ) const stream = new Busboy ( busboy Options ) var completed = false var files = 0 var count = 0 var call Done On Next Eos = false req . on ( 'error ' , function ( err ) { stream . destroy ( ) if ( ! completed ) { completed = true done ( err ) } } ) stream . on ( 'finish ' , function ( ) { log . debug ( 'finished multipart parsing ' ) if ( ! completed & & count = = = files ) { completed = true set Immediate ( done ) } else { call Done On Next Eos = true } } ) stream . on ( 'file ' , wrap ) req . pipe ( stream ) function wrap ( field , file , filename , encoding , mimetype ) { log . debug ( { field , filename , encoding , mimetype } , 'parsing part ' ) files + + eos ( file , wait For Files ) handler ( field , file , filename , encoding , mimetype ) } function wait For Files ( err ) { if ( err ) { completed = true done ( err ) return } if ( completed ) { return } + + count if ( call Done On Next Eos & & count = = = files ) { completed = true done ( ) } } return stream } 
function ( text , placeholders ) { if ( text [ text . length - 1 ] = = " ] " & & text . last Index Of ( " [ " ) ! = - 1 ) { 
function ( src , success Callback , error Callback , status Callback ) { argscheck . check Args ( 'SFFF ' , 'Media ' , arguments ) ; this . id = utils . create UUID ( ) ; media Objects [ this . id ] = this ; this . src = src ; this . success Callback = success Callback ; this . error Callback = error Callback ; this . status Callback = status Callback ; this . _duration = - 1 ; this . _position = - 1 ; try { this . node = create Node ( this ) ; } catch ( err ) { Media . on Status ( this . id , Media . MEDIA _ERROR , { code : Media Error . MEDIA _ERR _ABORTED } ) ; } } 
function create Node ( media ) { var node = new Audio ( ) ; node . onplay = function ( ) { Media . on Status ( media . id , Media . MEDIA _STATE , Media . MEDIA _STARTING ) ; } ; node . onplaying = function ( ) { Media . on Status ( media . id , Media . MEDIA _STATE , Media . MEDIA _RUNNING ) ; } ; node . ondurationchange = function ( e ) { Media . on Status ( media . id , Media . MEDIA _DURATION , e . target . duration | | - 1 ) ; } ; node . onerror = function ( e ) { 
function ( win , lose , args ) { var id = args [ 0 ] ; var src Uri = process Uri ( args [ 1 ] ) ; var create Audio Node = ! ! args [ 2 ] ; var this M = Media . get ( id ) ; Media . prototype . node = null ; var prefix = args [ 1 ] . split ( ' : ' ) . shift ( ) ; var extension = src Uri . extension ; if ( this M . node = = = null ) { if ( SUPPORTED _EXTENSIONS . index Of ( extension ) = = = - 1 & & SUPPORTED _PREFIXES . index Of ( prefix ) = = = - 1 ) { if ( lose ) { lose ( { code : Media Error . MEDIA _ERR _ABORTED } ) ; } return false ; 
function ( win , lose , args ) { var id = args [ 0 ] ; 
function ( win , lose , args ) { var id = args [ 0 ] ; var milliseconds = args [ 1 ] ; var this M = Media . get ( id ) ; try { this M . node . current Time = milliseconds / 1 0 0 0 ; win ( this M . node . current Time ) ; } catch ( err ) { lose ( "Failed to seek : " + err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; var this M = Media . get ( id ) ; try { this M . node . pause ( ) ; Media . on Status ( id , Media . MEDIA _STATE , Media . MEDIA _PAUSED ) ; } catch ( err ) { lose ( "Failed to pause : " + err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; try { var p = ( Media . get ( id ) ) . node . current Time ; win ( p ) ; } catch ( err ) { lose ( err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; var src Uri = process Uri ( args [ 1 ] ) ; var dest = parse Uri To Path And Filename ( src Uri ) ; var dest File Name = dest . file Name ; var success = function ( ) { Media . on Status ( id , Media . MEDIA _STATE , Media . MEDIA _RUNNING ) ; } ; var error = function ( reason ) { Media . on Status ( id , Media . MEDIA _ERROR , reason ) ; } ; 
function ( win , lose , args ) { var id = args [ 0 ] ; var this M = Media . get ( id ) ; var src Uri = process Uri ( this M . src ) ; var dest = parse Uri To Path And Filename ( src Uri ) ; var dest Path = dest . path ; var dest File Name = dest . file Name ; var fs Type = dest . fs Type ; var success = function ( ) { Media . on Status ( id , Media . MEDIA _STATE , Media . MEDIA _STOPPED ) ; } ; var error = function ( reason ) { Media . on Status ( id , Media . MEDIA _ERROR , reason ) ; } ; this M . media Capture Mgr . stop Record Async ( ) . done ( function ( ) { if ( fs Type = = = fs Types . TEMPORARY ) { if ( ! dest Path ) { 
function ( win , lose , args ) { var id = args [ 0 ] ; var this M = Media . get ( id ) ; try { if ( this M . node ) { this M . node . onloadedmetadata = null ; 
function set Temporary Fs By Default ( src ) { var uri ; try { uri = new Windows . Foundation . Uri ( src ) ; } catch ( e ) { if ( e . number = = = PARAMETER _IS _INCORRECT ) { 
function full Path To App Data ( uri ) { if ( uri . scheme Name = = = 'file ' ) { if ( uri . raw Uri . index Of ( Windows . Storage . Application Data . current . local Folder . path ) ! = = - 1 ) { 
function cdvfile To App Data ( uri ) { var cdv Fs Root ; if ( uri . scheme Name = = = 'cdvfile ' ) { cdv Fs Root = uri . path . split ( ' / ' ) [ 1 ] ; if ( cdv Fs Root = = = 'temporary ' ) { return new Windows . Foundation . Uri ( temp Folder App Data Base Path , uri . path . split ( ' / ' ) . slice ( 2 ) . join ( ' / ' ) ) ; } else if ( cdv Fs Root = = = 'persistent ' ) { return new Windows . Foundation . Uri ( local Folder App Data Base Path , uri . path . split ( ' / ' ) . slice ( 2 ) . join ( ' / ' ) ) ; } else { throw new Error ( cdv Fs Root + ' cdvfile root is not supported on Windows ' ) ; } } return uri ; } 
function process Uri ( src ) { 
function parse Uri To Path And Filename ( uri ) { 
function ( src , success Callback , error Callback , status Callback ) { argscheck . check Args ( 's FFF ' , 'Media ' , arguments ) ; this . id = utils . create UUID ( ) ; media Objects [ this . id ] = this ; this . src = src ; this . success Callback = success Callback ; this . error Callback = error Callback ; this . status Callback = status Callback ; this . _duration = - 1 ; this . _position = - 1 ; exec ( null , this . error Callback , "Media " , "create " , [ this . id , this . src ] ) ; } 
function proj ( location ) { 
function Context ( hook , opts ) { this . hook = hook ; 
function get Unique Capabilities ( capabilities ) { return capabilities . reduce ( function ( unique Caps , curr Cap ) { var is Repeated = unique Caps . some ( function ( cap ) { return get Capability Name ( cap ) = = = get Capability Name ( curr Cap ) ; } ) ; return is Repeated ? unique Caps : unique Caps . concat ( [ curr Cap ] ) ; } , [ ] ) ; } 
function compare Capabilities ( first Cap , second Cap ) { var first Cap Name = get Capability Name ( first Cap ) ; var second Cap Name = get Capability Name ( second Cap ) ; if ( first Cap Name < second Cap Name ) { return - 1 ; } if ( first Cap Name > second Cap Name ) { return 1 ; } return 0 ; } 
function generate Uap Capabilities ( capabilities ) { function has Capability Change ( change ) { return / ^ \s * < ( \w + : ) ? (Device ) ?Capability \s / . test ( change . xml ) ; } function create Prefixed Capability Change ( change ) { if ( Caps Need Uap Prefix . index Of ( get Capability Name ( change ) ) < 0 ) { return change ; } 
function remove Platform Plugins Json ( project Root , target ) { var plugins _json = path . join ( project Root , 'plugins ' , target + ' .json ' ) ; fs . remove Sync ( plugins _json ) ; } 
function is Cordova ( dir ) { if ( ! dir ) { 
function cd Project Root ( ) { const project Root = this . get Project Root ( ) ; if ( ! orig Cwd ) { orig Cwd = process . env . PWD | | process . cwd ( ) ; } process . env . PWD = project Root ; process . chdir ( project Root ) ; return project Root ; } 
function fix Relative Path ( value , cwd ) { 
function convert To Real Path Safe ( path ) { if ( path & & fs . exists Sync ( path ) ) { return fs . realpath Sync ( path ) ; } return path ; } 
function delete Svn Folders ( dir ) { var contents = fs . readdir Sync ( dir ) ; contents . for Each ( function ( entry ) { var fullpath = path . join ( dir , entry ) ; if ( is Directory ( fullpath ) ) { if ( entry = = = ' .svn ' ) { fs . remove Sync ( fullpath ) ; } else module . exports . delete Svn Folders ( fullpath ) ; } } ) ; } 
function find Plugins ( plugin Dir ) { var plugins = [ ] ; if ( fs . exists Sync ( plugin Dir ) ) { plugins = fs . readdir Sync ( plugin Dir ) . filter ( function ( file Name ) { var plugin Path = path . join ( plugin Dir , file Name ) ; var is Plugin = is Directory ( plugin Path ) | | is Symbolic Link ( plugin Path ) ; return file Name ! = = ' .svn ' & & file Name ! = = 'CVS ' & & is Plugin ; } ) ; } return plugins ; } 
function get Platform Api Function ( dir ) { let Platform Api ; try { Platform Api = exports . require No Cache ( dir ) ; } catch ( err ) { 
function download Platform ( project Root , platform , version , opts ) { var target = version ? ( platform + ' @ ' + version ) : platform ; return Promise . resolve ( ) . then ( function ( ) { 
function Hooks Runner ( project Root ) { var root = cordova Util . is Cordova ( project Root ) ; if ( ! root ) throw new Cordova Error ( 'Not a Cordova project ( " ' + project Root + ' " ) , can \ 't use hooks . ' ) ; else this . project Root = root ; } 
function execute Event Handlers Serially ( hook , opts ) { var handlers = events . listeners ( hook ) ; if ( handlers . length ) { 
function run Scripts Serially ( scripts , context ) { if ( scripts . length = = = 0 ) { events . emit ( 'verbose ' , 'No scripts found for hook " ' + context . hook + ' " . ' ) ; } return scripts . reduce ( function ( prev Script Promise , next Script ) { return prev Script Promise . then ( function ( ) { return run Script ( next Script , context ) ; } ) ; } , Promise . resolve ( ) ) ; } 
function extract She Bang Interpreter ( fullpath ) { 
function is Hook Disabled ( opts , hook ) { if ( opts = = = undefined | | opts . nohooks = = = undefined ) { return false ; } var disabled Hooks = opts . nohooks ; var length = disabled Hooks . length ; for ( var i = 0 ; i < length ; i + + ) { if ( hook . match ( disabled Hooks [ i ] ) ! = = null ) { return true ; } } return false ; } 
function install Platforms From Config XML ( platforms , opts ) { events . emit ( 'verbose ' , 'Checking config .xml and package .json for saved platforms that haven \ 't been added to the project ' ) ; var project Home = cordova _util . cd Project Root ( ) ; var config Path = cordova _util . project Config ( project Home ) ; var cfg = new Config Parser ( config Path ) ; var engines = cfg . get Engines ( ) ; var pkg Json Path = path . join ( project Home , 'package .json ' ) ; var pkg Json ; var pkg Json Platforms ; var combo Array = [ ] ; var config Platforms = [ ] ; var modified Pkg Json = false ; var merged Platform Specs = { } ; var key ; var install All Platforms = ! platforms | | platforms . length = = = 0 ; var file ; var indent ; / / Check if path exists and require pkg Json Path . if ( fs . exists Sync ( pkg Json Path ) ) { pkg Json = require ( pkg Json Path ) ; file = fs . read File Sync ( pkg Json Path , 'utf 8 ' ) ; indent = detect Indent ( file ) . indent | | ' ' ; } if ( pkg Json ! = = undefined & & pkg Json . cordova ! = = undefined & & pkg Json . cordova . platforms ! = = undefined ) { pkg Json Platforms = pkg Json . cordova . platforms ; } if ( cfg ! = = undefined ) { if ( pkg Json Platforms ! = = undefined ) { / / Combining arrays and checking duplicates . combo Array = pkg Json Platforms . slice ( ) ; } engines = cfg . get Engines ( project Home ) ; / / TODO : CB - 1 2 5 9 2 : Eventually refactor out to pacakge manager module . / / If package .json doesn 't exist , auto -create one . if ( engines . length > 0 & & pkg Json = = = undefined ) { pkg Json = { } ; if ( cfg . package Name ( ) ) { pkg Json . name = cfg . package Name ( ) . to Lower Case ( ) ; } if ( cfg . version ( ) ) { pkg Json . version = cfg . version ( ) ; } if ( cfg . name ( ) ) { pkg Json . display Name = cfg . name ( ) ; } fs . write File Sync ( pkg Json Path , JSON . stringify ( pkg Json , null , indent ) , 'utf 8 ' ) ; } config Platforms = engines . map ( function ( Engine ) { var config Plat Name = Engine . name ; 
function install Plugins From Config XML ( args ) { events . emit ( 'verbose ' , 'Checking for saved plugins that haven \ 't been added to the project ' ) ; const project Root = cordova _util . get Project Root ( ) ; const plugins Root = path . join ( project Root , 'plugins ' ) ; const pkg Json Path = path . join ( project Root , 'package .json ' ) ; const conf Xml Path = cordova _util . project Config ( project Root ) ; let pkg Json = { } ; let indent = ' ' ; if ( fs . exists Sync ( pkg Json Path ) ) { const file Data = fs . read File Sync ( pkg Json Path , 'utf 8 ' ) ; indent = detect Indent ( file Data ) . indent ; pkg Json = JSON . parse ( file Data ) ; } pkg Json . dev Dependencies = pkg Json . dev Dependencies | | { } ; pkg Json . cordova = pkg Json . cordova | | { } ; pkg Json . cordova . plugins = pkg Json . cordova . plugins | | { } ; const pkg Plugin IDs = Object . keys ( pkg Json . cordova . plugins ) ; const pkg Specs = Object . assign ( { } , pkg Json . dependencies , pkg Json . dev Dependencies ) ; / / Check for plugins listed in config .xml const cfg = new Config Parser ( conf Xml Path ) ; const cfg Plugin IDs = cfg . get Plugin Id List ( ) ; cfg Plugin IDs . for Each ( pl ID = > { / / If package .json includes the plugin , we use that config / / Otherwise , we need to add the plugin to package .json if ( ! pkg Plugin IDs . includes ( pl ID ) ) { events . emit ( 'info ' , ` $ { pl ID } ` ) ; const cfg Plugin = cfg . get Plugin ( pl ID ) ; / / If config .xml has a spec for the plugin and package .json has not , / / add the spec to dev Dependencies of package .json if ( cfg Plugin . spec & & ! ( pl ID in pkg Specs ) ) { pkg Json . dev Dependencies [ pl ID ] = cfg Plugin . spec ; } pkg Json . cordova . plugins [ pl ID ] = Object . assign ( { } , cfg Plugin . variables ) ; } } ) ; / / Now that plugins have been updated , re -fetch them from package .json const plugin IDs = Object . keys ( pkg Json . cordova . plugins ) ; if ( plugin IDs . length ! = = pkg Plugin IDs . length ) { / / We 've modified package .json and need to save it fs . output Json Sync ( pkg Json Path , pkg Json , { indent : indent , encoding : 'utf 8 ' } ) ; } const specs = Object . assign ( { } , pkg Json . dependencies , pkg Json . dev Dependencies ) ; const plugins = plugin IDs . map ( pl ID = > ( { name : pl ID , spec : specs [ pl ID ] , variables : pkg Json . cordova . plugins [ pl ID ] | | { } } ) ) ; let plugin Name = ' ' ; 
function ( ) { var modulemapper = require ( 'cordova /modulemapper ' ) ; var channel = require ( 'cordova /channel ' ) ; modulemapper . clobbers ( 'cordova /exec /proxy ' , 'cordova .command Proxy ' ) ; channel . on Native Ready . fire ( ) ; document . add Event Listener ( "visibilitychange " , function ( ) { if ( document . hidden ) { channel . on Pause . fire ( ) ; } else { channel . on Resume . fire ( ) ; } } ) ; 
function absolute Path Handler ( request , response , next ) { if ( ! request . headers . referer ) return next ( ) ; 
function ( hook , opts ) { 
function get Application Hook Scripts ( hook , opts ) { 
function get Plugins Hook Scripts ( hook , opts ) { 
function get Application Hook Scripts From Dir ( dir ) { if ( ! ( fs . exists Sync ( dir ) ) ) { return [ ] ; } var compare Numbers = function ( a , b ) { 
function get Scripts From Config Xml ( hook , opts ) { var config Path = cordova Util . project Config ( opts . project Root ) ; var config Xml = new Config Parser ( config Path ) ; return config Xml . get Hook Scripts ( hook , opts . cordova . platforms ) . map ( function ( script Element ) { return { path : script Element . attrib . src , full Path : path . join ( opts . project Root , script Element . attrib . src ) } ; } ) ; } 
function get Plugin Script Files ( plugin , hook , platforms ) { var script Elements = plugin . plugin Info . get Hook Scripts ( hook , platforms ) ; return script Elements . map ( function ( script Element ) { return { path : script Element . attrib . src , full Path : path . join ( plugin . dir , script Element . attrib . src ) , plugin : plugin } ; } ) ; } 
function get All Plugins Hook Script Files ( hook , opts ) { var scripts = [ ] ; var current Plugin Options ; var plugins = ( new Plugin Info Provider ( ) ) . get All Within Search Path ( path . join ( opts . project Root , 'plugins ' ) ) ; plugins . for Each ( function ( plugin Info ) { current Plugin Options = { id : plugin Info . id , plugin Info : plugin Info , dir : plugin Info . dir } ; scripts = scripts . concat ( get Plugin Script Files ( current Plugin Options , hook , opts . cordova . platforms ) ) ; } ) ; return scripts ; } 
function Appx Manifest ( path , prefix ) { this . path = path ; 
function ensure Uap Prefixed Capabilities ( capabilities ) { capabilities . getchildren ( ) . for Each ( function ( el ) { if ( CAPS _NEEDING _UAPNS . index Of ( el . attrib . Name ) > - 1 & & el . tag . index Of ( 'uap : ' ) ! = = 0 ) { el . tag = 'uap : ' + el . tag ; } } ) ; } 
function ensure Unique Capabilities ( capabilities ) { var unique Capabilities = [ ] ; capabilities . getchildren ( ) . for Each ( function ( el ) { var name = el . attrib . Name ; if ( unique Capabilities . index Of ( name ) ! = = - 1 ) { capabilities . remove ( el ) ; } else { unique Capabilities . push ( name ) ; } } ) ; } 
function merge Variables ( plugin Info , cfg , opts ) { 
function copy New File ( plugin _dir , src , project _dir , dest , link ) { var target _path = path . resolve ( project _dir , dest ) ; if ( fs . exists Sync ( target _path ) ) throw new Cordova Error ( ' " ' + target _path + ' " already exists ! ' ) ; copy File ( plugin _dir , src , project _dir , dest , ! ! link ) ; } 
function Plugin Spec ( raw , scope , id , version ) { this . scope = scope | | null ; this . id = id | | raw ; this . version = version | | null ; this . package = ( scope ? scope + id : id ) | | null ; } 
function parse ( raw ) { var split = NPM _SPEC _REGEX . exec ( raw ) ; if ( split ) { return new Plugin Spec ( raw , split [ 1 ] , split [ 2 ] , split [ 3 ] ) ; } return new Plugin Spec ( raw ) ; } 
function get Plugin File Path ( plugin , plugin File , target Dir ) { var src = path . resolve ( plugin . dir , plugin File ) ; return ' $ (Project Dir ) ' + path . relative ( target Dir , src ) ; } 
function Q _chainmap ( args , func ) { return Promise . resolve ( ) . then ( function ( in Value ) { return args . reduce ( function ( so Far , arg ) { return so Far . then ( function ( val ) { return func ( arg , val ) ; } ) ; } , Promise . resolve ( in Value ) ) ; } ) ; } 
function platform ( command , targets , opts ) { 
function ( result , callback Options ) { callback Options = callback Options | | { } ; var callback Status ; 
function get Platforms ( project Root ) { var xml = cordova _util . project Config ( project Root ) ; var cfg = new Config Parser ( xml ) ; 
function get Plugins ( project Root ) { var xml = cordova _util . project Config ( project Root ) ; var cfg = new Config Parser ( xml ) ; 
function get Platform Api ( platform , platform Root Dir ) { 
function ( plugin _id , plugins _dir , platform Json , plugin Info Provider ) { var deps Info ; if ( typeof plugins _dir = = = 'object ' ) { deps Info = plugins _dir ; } else { deps Info = pkg . generate Dependency Info ( platform Json , plugins _dir , plugin Info Provider ) ; } var graph = deps Info . graph ; var tlps = deps Info . top _level _plugins ; var dependents = tlps . filter ( function ( tlp ) { return tlp ! = = plugin _id & & graph . get Chain ( tlp ) . index Of ( plugin _id ) > = 0 ; } ) ; return dependents ; } 
function ( plugin _id , plugins _dir , platform Json , plugin Info Provider ) { var deps Info ; if ( typeof plugins _dir = = = 'object ' ) { deps Info = plugins _dir ; } else { deps Info = pkg . generate Dependency Info ( platform Json , plugins _dir , plugin Info Provider ) ; } var graph = deps Info . graph ; var dependencies = graph . get Chain ( plugin _id ) ; var tlps = deps Info . top _level _plugins ; var diff _arr = [ ] ; tlps . for Each ( function ( tlp ) { if ( tlp ! = = plugin _id ) { diff _arr . push ( graph . get Chain ( tlp ) ) ; } } ) ; 
function create Replacement ( manifest File , original Change ) { var replacement = { target : manifest File , parent : original Change . parent , after : original Change . after , xmls : original Change . xmls , versions : original Change . versions , device Target : original Change . device Target } ; return replacement ; } 
function Plugin Info ( dirname ) { 
function check ID ( expected Id And Version , pinfo ) { if ( ! expected Id And Version ) return ; var parsed Spec = plugin Spec . parse ( expected Id And Version ) ; if ( parsed Spec . id ! = = pinfo . id ) { throw new Error ( 'Expected plugin to have ID " ' + parsed Spec . id + ' " but got " ' + pinfo . id + ' " . ' ) ; } if ( parsed Spec . version & & ! semver . satisfies ( pinfo . version , parsed Spec . version ) ) { throw new Error ( 'Expected plugin ' + pinfo . id + ' to satisfy version " ' + parsed Spec . version + ' " but got " ' + pinfo . version + ' " . ' ) ; } } 
function find Local Plugin ( plugin _src , searchpath , plugin Info Provider ) { load Local Plugins ( searchpath , plugin Info Provider ) ; var parsed Spec = plugin Spec . parse ( plugin _src ) ; var versionspec = parsed Spec . version | | ' * ' ; var latest = null ; var versions = local Plugins . plugins [ parsed Spec . id ] ; if ( ! versions ) return null ; versions . for Each ( function ( pinfo ) { 
function copy Plugin ( pinfo , plugins _dir , link ) { var plugin _dir = pinfo . dir ; var dest = path . join ( plugins _dir , pinfo . id ) ; fs . remove Sync ( dest ) ; if ( ! link & & dest . index Of ( path . resolve ( plugin _dir ) + path . sep ) = = = 0 ) { events . emit ( 'verbose ' , 'Copy plugin destination is child of src . Forcing - -link mode . ' ) ; link = true ; } if ( link ) { var is Relative Path = plugin _dir . char At ( 1 ) ! = = ' : ' & & plugin _dir . char At ( 0 ) ! = = path . sep ; var fixed Path = is Relative Path ? path . join ( path . relative ( plugins _dir , process . env . PWD | | process . cwd ( ) ) , plugin _dir ) : plugin _dir ; events . emit ( 'verbose ' , 'Linking " ' + dest + ' " = > " ' + fixed Path + ' " ' ) ; fs . symlink Sync ( fixed Path , dest , 'junction ' ) ; } else { events . emit ( 'verbose ' , 'Copying plugin " ' + plugin _dir + ' " = > " ' + dest + ' " ' ) ; fs . copy Sync ( plugin _dir , dest , { dereference : true } ) ; } return dest ; } 
function ( id ) { var plugin _dir = path . join ( plugins _dir , id ) ; if ( ! fs . exists Sync ( plugin _dir ) ) { events . emit ( 'verbose ' , 'Plugin " ' + id + ' " already removed ( ' + plugin _dir + ' ) ' ) ; return Promise . resolve ( ) ; } fs . remove Sync ( plugin _dir ) ; events . emit ( 'verbose ' , 'Deleted plugin " ' + id + ' " ' ) ; 
function run Uninstall Platform ( actions , platform , project _dir , plugin _dir , plugins _dir , options ) { var plugin Info Provider = options . plugin Info Provider ; 
function handle Uninstall ( actions , platform , plugin Info , project _dir , www _dir , plugins _dir , is _top _level , options ) { events . emit ( 'log ' , 'Uninstalling ' + plugin Info . id + ' from ' + platform ) ; 
function get Platform Details From Dir ( dir , platform If Known ) { var lib Dir = path . resolve ( dir ) ; var platform ; var version ; 
function platform From Name ( name ) { var plat Name = name ; var plat Match = / ^cordova - ( [a -z 0 - 9 - ] + ) $ / . exec ( name ) ; if ( plat Match & & ( plat Match [ 1 ] in platforms ) ) { plat Name = plat Match [ 1 ] ; events . emit ( 'verbose ' , 'Removing "cordova - " prefix from ' + name ) ; } return plat Name ; } 
function process Message ( message ) { var first Char = message . char At ( 0 ) ; if ( first Char = = 'J ' ) { 
function possibly Fetch ( id , plugins _dir , options ) { var parsed Spec = plugin Spec . parse ( id ) ; 
function call Engine Scripts ( engines , project _dir ) { return Promise . all ( engines . map ( function ( engine ) { 
function copy Plugin ( plugin _src _dir , plugins _dir , link , plugin Info Provider ) { var plugin Info = new Plugin Info ( plugin _src _dir ) ; var dest = path . join ( plugins _dir , plugin Info . id ) ; if ( link ) { events . emit ( 'verbose ' , 'Symlinking from location " ' + plugin _src _dir + ' " to location " ' + dest + ' " ' ) ; fs . remove Sync ( dest ) ; fs . ensure Symlink Sync ( plugin _src _dir , dest , 'junction ' ) ; } else { events . emit ( 'verbose ' , 'Copying from location " ' + plugin _src _dir + ' " to location " ' + dest + ' " ' ) ; fs . copy Sync ( plugin _src _dir , dest ) ; } plugin Info . dir = dest ; plugin Info Provider . put ( plugin Info ) ; return dest ; } 
function Api ( platform , platform Root Dir , events ) { this . platform = PLATFORM ; this . root = path . resolve ( _ _dirname , ' . . ' ) ; setup Events ( events ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'assets /www ' ) , res : path . join ( self . root , 'res ' ) , platform Www : path . join ( self . root , 'platform _www ' ) , config Xml : path . join ( self . root , 'res /xml /config .xml ' ) , default Config Xml : path . join ( self . root , 'cordova /defaults .xml ' ) , strings : path . join ( self . root , 'res /values /strings .xml ' ) , manifest : path . join ( self . root , 'Android Manifest .xml ' ) , build : path . join ( self . root , 'build ' ) , 
function create Package Json ( plugin _path ) { var plugin Info = new Plugin Info ( plugin _path ) ; var defaults = { id : plugin Info . id , version : plugin Info . version , description : plugin Info . description , license : plugin Info . license , keywords : plugin Info . get Keywords And Platforms ( ) , repository : plugin Info . repo , engines : plugin Info . get Engines ( ) , platforms : plugin Info . get Platforms Array ( ) } ; var init File = require . resolve ( ' . /init -defaults ' ) ; return init Pkg Json ( plugin _path , init File , defaults ) . then ( _ = > { events . emit ( 'verbose ' , 'Package .json successfully created ' ) ; } ) ; } 
function prepare Platforms ( platform List , project Root , options ) { return Promise . all ( platform List . map ( function ( platform ) { 
function Api ( platform , platform Root Dir , event Emitter ) { this . platform = PLATFORM ; this . root = path . resolve ( _ _dirname , ' . . ' ) ; setup Events ( event Emitter ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'www ' ) , platform Www : path . join ( self . root , 'platform _www ' ) , config Xml : path . join ( self . root , 'config .xml ' ) , default Config Xml : path . join ( self . root , 'cordova /defaults .xml ' ) , 
function merge Variables ( plugin _dir , platform , options ) { options . plugin Info Provider = options . plugin Info Provider | | new Plugin Info Provider ( ) ; var plugin Info Provider = options . plugin Info Provider ; var plugin Info = plugin Info Provider . get ( plugin _dir ) ; var filtered _variables = { } ; var prefs = plugin Info . get Preferences ( platform ) ; var keys = underscore . keys ( prefs ) ; options . cli _variables = options . cli _variables | | { } ; var missing _vars = underscore . difference ( keys , Object . keys ( options . cli _variables ) ) ; underscore . each ( missing _vars , function ( _key ) { var def = prefs [ _key ] ; if ( def ) { options . cli _variables [ _key ] = def ; } } ) ; 
function default _version Code ( version ) { var nums = version . split ( ' - ' ) [ 0 ] . split ( ' . ' ) ; var version Code = 0 ; if ( + nums [ 0 ] ) { version Code + = + nums [ 0 ] * 1 0 0 0 0 ; } if ( + nums [ 1 ] ) { version Code + = + nums [ 1 ] * 1 0 0 ; } if ( + nums [ 2 ] ) { version Code + = + nums [ 2 ] ; } events . emit ( 'verbose ' , 'android -version Code not found in config .xml . Generating a code based on version in config .xml ( ' + version + ' ) : ' + version Code ) ; return version Code ; } 
function ( icon , icon _size ) { 
function map Image Resources ( root Dir , sub Dir , type , resource Name ) { var path Map = { } ; shell . ls ( path . join ( root Dir , sub Dir , type + ' - * ' ) ) . for Each ( function ( drawable Folder ) { var image Path = path . join ( sub Dir , path . basename ( drawable Folder ) , resource Name ) ; path Map [ image Path ] = null ; } ) ; return path Map ; } 
function find Android Launch Mode Preference ( platform Config ) { var launch Mode = platform Config . get Preference ( 'Android Launch Mode ' ) ; if ( ! launch Mode ) { 
function Android Manifest ( path ) { this . path = path ; this . doc = xml . parse Elementtree Sync ( path ) ; if ( this . doc . getroot ( ) . tag ! = = 'manifest ' ) { throw new Error ( 'Android Manifest at ' + path + ' has incorrect root node name (expected "manifest " ) ' ) ; } } 
function expect Unmet Requirements ( expected ) { const actual = unmet Requirements Collector . store ; expect ( actual ) . to Equal ( jasmine . array With Exact Contents ( expected ) ) ; } 
function get Fetch Version ( project Root , plugin Info , cordova Version ) { 
function determine Plugin Version To Fetch ( plugin Info , plugin Map , platform Map , cordova Version ) { var all Versions = plugin Info . versions ; var engine = plugin Info . engines . cordova Dependencies ; var name = plugin Info . name ; 
function get Failed Requirements ( reqs , plugin Map , platform Map , cordova Version ) { var failed = [ ] ; var version = cordova Version ; if ( semver . prerelease ( version ) ) { 
function find Version ( versions , version ) { var cleaned Version = semver . clean ( version ) ; for ( var i = 0 ; i < versions . length ; i + + ) { if ( semver . clean ( versions [ i ] ) = = = cleaned Version ) { return versions [ i ] ; } } return null ; } 
function list Unmet Requirements ( name , failed Requirements ) { events . emit ( 'warn ' , 'Unmet project requirements for latest version of ' + name + ' : ' ) ; failed Requirements . for Each ( function ( req ) { events . emit ( 'warn ' , ' ' + req . dependency + ' ( ' + req . installed + ' in project , ' + req . required + ' required ) ' ) ; } ) ; } 
function util Exec ( cmd Line ) { var defer = Q . defer ( ) ; shell . exec ( cmd Line , function ( code , output ) { defer . resolve ( { code : code , output : output } ) ; } ) ; return defer . promise ; } 
function ( folder Name , task ) { var defer = Q . defer ( ) ; var vn = ( task . name | | folder Name ) ; if ( ! task . id | | ! check . is UUID ( task . id ) ) { defer . reject ( create Error ( vn + ' : id is a required guid ' ) ) ; } ; if ( ! task . name | | ! check . is Alphanumeric ( task . name ) ) { defer . reject ( create Error ( vn + ' : name is a required alphanumeric string ' ) ) ; } if ( ! task . friendly Name | | ! check . is Length ( task . friendly Name , 1 , 4 0 ) ) { defer . reject ( create Error ( vn + ' : friendly Name is a required string < = 4 0 chars ' ) ) ; } if ( ! task . instance Name Format ) { defer . reject ( create Error ( vn + ' : instance Name Format is required ' ) ) ; } / / resolve if not already rejected defer . resolve ( ) ; return defer . promise ; } 
function set Result ( result , message ) { debug ( 'task result : ' + Task Result [ result ] ) ; command ( 'task .complete ' , { 'result ' : Task Result [ result ] } , message ) ; if ( result = = Task Result . Failed ) { _write Error ( message ) ; } if ( result = = Task Result . Failed ) { process . exit ( 0 ) ; } } 
function get Variable ( name ) { var varval = process . env [ name . replace ( / \ . / g , ' _ ' ) . to Upper Case ( ) ] ; debug ( name + ' = ' + varval ) ; var mocked = mock . get Response ( 'get Variable ' , name ) ; return mocked | | varval ; } 
function get Delimited Input ( name , delim , required ) { var inval = get Input ( name , required ) ; if ( ! inval ) { return [ ] ; } return inval . split ( delim ) ; } 
function get Endpoint Url ( id , optional ) { var urlval = get Variable ( 'ENDPOINT _URL _ ' + id ) ; debug ( id + ' = ' + urlval ) ; if ( ! optional & & ! urlval ) { _write Error ( 'Endpoint not present : ' + id ) ; exit ( 1 ) ; } return urlval ; } 
function command ( command , properties , message ) { var task Cmd = new tcm . Task Command ( command , properties , message ) ; _write Line ( task Cmd . to String ( ) ) ; } 
function check Path ( p , name ) { debug ( 'check path : ' + p ) ; if ( ! p | | ! mock . get Response ( 'check Path ' , p ) ) { set Result ( Task Result . Failed , 'not found ' + name + ' : ' + p ) ; 
function exec ( tool , args , options ) { var tool Path = which ( tool , true ) ; var tr = create Tool Runner ( tool Path ) ; if ( args ) { tr . arg ( args ) ; } return tr . exec ( options ) ; } 
function matches Range ( card Number , min , max ) { var max Length To Check = String ( min ) . length ; var substr = card Number . substr ( 0 , max Length To Check ) ; var integer Representation Of Card Number = parse Int ( substr , 1 0 ) ; min = parse Int ( String ( min ) . substr ( 0 , substr . length ) , 1 0 ) ; max = parse Int ( String ( max ) . substr ( 0 , substr . length ) , 1 0 ) ; return integer Representation Of Card Number > = min & & integer Representation Of Card Number < = max ; } 
function ( files , package Filename ) { const converted Files = _ . flatten ( Object . keys ( files ) . map ( key = > { if ( files [ key ] = = = true ) return key else return files [ key ] } ) ) const has Package Lock = _ . includes ( converted Files , package Filename . replace ( 'package .json ' , 'package -lock .json ' ) ) if ( has Package Lock ) return package Filename . replace ( 'package .json ' , 'package -lock .json ' ) const has Yarn Lock = _ . includes ( converted Files , package Filename . replace ( 'package .json ' , 'yarn .lock ' ) ) if ( has Yarn Lock ) return package Filename . replace ( 'package .json ' , 'yarn .lock ' ) return null } 
function ( version , new Version , new Code Name , version Only = false ) { let matches = [ ` $ { new Code Name } ` , new Code Name , new Version ] 
function ( existing Version Strings , new Version , new Code Name , version Only = false ) { if ( ! existing Version Strings | | existing Version Strings . length = = = 0 ) return - 1 return existing Version Strings . find Index ( ( version ) = > { return has Node Version ( version , new Version , new Code Name , version Only ) } ) } 
function ( travis YML , new Version , new Code Name , existing Versions ) { 
function ( travis YML , new Version , new Code Name , existing Versions ) { 
function has Version Comment ( issue , version ) { if ( ! issue . version & & ! issue . comments ) { log . error ( 'no version information on issue document ' , { issue } ) return false } return issue . version = = = version | | ( issue . comments & & issue . comments . includes ( version ) ) } 
async function update Repo Doc ( { installation Id , doc , file Paths , log } ) { const full Name = doc . full Name const old Greenkeeper Config = doc . greenkeeper 
async function discover Package Files ( { installation Id , full Name , default Branch , log } ) { const ghqueue = github Queue ( installation Id ) const relevant Package File Paths = await discover Package File Paths ( { installation Id , full Name , default Branch , log } ) const [ owner , repo ] = full Name . split ( ' / ' ) 
async function discover Package File Paths ( { installation Id , full Name , default Branch , log } ) { 
function has Lock File Text ( files ) { if ( ! files ) return const lock Files = [ 'package -lock .json ' , 'npm -shrinkwrap .json ' , 'yarn .lock ' ] . filter ( ( key ) = > { if ( _ . is Array ( files [ key ] ) & & files [ key ] . length ) { return true } if ( files [ key ] = = = true ) { return true } return false } ) if ( lock Files . length = = = 0 ) return if ( lock Files . includes ( 'npm -shrinkwrap .json ' ) ) { return md ` .c od e ( 'np m -shrinkwrap .json ' ) } f i l } const lock File = lock Files [ 0 ] return md ` d . co d e (lo c k File ) } f i } 
function travis Transform ( travis YML ) { try { var travis JSON = yaml . safe Load ( travis YML , { schema : yaml . FAILSAFE _SCHEMA } ) } catch ( e ) { 
function get Group For Package File ( groups , package File Path ) { return Object . keys ( groups ) . find ( ( group ) = > { return groups [ group ] . packages & & groups [ group ] . packages . includes ( package File Path ) } ) } 
function is Dependency Ignored In Groups ( groups , package File Path , dependency Name ) { const group Name = get Group For Package File ( groups , package File Path ) return group Name & & _ . includes ( groups [ group Name ] . ignore , dependency Name ) } 
function get Dependency URL ( { repository URL , dependency } ) { 
function get Dependencies From Package Files ( package Paths , package Json Contents ) { return _ . compact ( _ . uniq With ( _ . flatten ( package Paths . map ( path = > { return _ . flatten ( [ 'dependencies ' , 'dev Dependencies ' , 'optional Dependencies ' ] . map ( type = > { if ( package Json Contents [ path ] ) { return _ . map ( package Json Contents [ path ] [ type ] , ( version , name ) = > ( { name , version , type } ) ) } } ) ) } ) ) , _ . is Equal ) ) } 
async function add NPMPackage Data ( dependency Info , registry Get , log ) { return Promise . map Series ( dependency Info , async dep = > { try { dep . data = await registry Get ( registry Url + dep . name . replace ( ' / ' , ' % 2F ' ) , { } ) return dep } catch ( err ) { log . error ( 'npm : Could not get package data ' , { dependency : dep , error : err } ) } } ) } 
async function get Updated Dependencies For Files ( { package Paths , package Json Contents , registry Get , ignore , log } ) { const dependency Info = module . exports . get Dependencies From Package Files ( package Paths , package Json Contents , log ) 
function check For Data ( ) { ph . window Property ( "DATA " ) . then ( function ( data ) { if ( data ! = = undefined ) { write To File ( data ) ; ph . exit ( ) ; } else { set Timeout ( check For Data , 1 0 0 ) ; } } ) ; } 
function extract Apis ( services ) { var filter Types = arguments . length < = 1 | | arguments [ 1 ] = = = undefined ? [ ] : arguments [ 1 ] ; services = Array . is Array ( services ) ? services : [ services ] ; var apis = services . reduce ( function ( total , service ) { var obj = service . constructor = = = Object ? service : Object . get Prototype Of ( service ) ; var keys = aggregate Apis By Type ( obj , total , filter Types ) ; total . push . apply ( total , keys ) ; return total ; } , [ ] ) ; return apis ; } 
function Search Results ( state , results ) { var main Sub Response = results [ 0 ] ; this . _raw Results = results ; this . query = main Sub Response . query ; this . parsed Query = main Sub Response . parsed Query ; this . hits = main Sub Response . hits ; this . index = main Sub Response . index ; this . hits Per Page = main Sub Response . hits Per Page ; this . nb Hits = main Sub Response . nb Hits ; this . nb Pages = main Sub Response . nb Pages ; this . page = main Sub Response . page ; this . processing Time MS = sum By ( results , 'processing Time MS ' ) ; this . around Lat Lng = main Sub Response . around Lat Lng ; this . automatic Radius = main Sub Response . automatic Radius ; this . server Used = main Sub Response . server Used ; this . timeout Counts = main Sub Response . timeout Counts ; this . timeout Hits = main Sub Response . timeout Hits ; this . exhaustive Facets Count = main Sub Response . exhaustive Facets Count ; this . exhaustive Nb Hits = main Sub Response . exhaustive Nb Hits ; this . user Data = main Sub Response . user Data ; this . query ID = main Sub Response . query ID ; this . disjunctive Facets = [ ] ; this . hierarchical Facets = map ( state . hierarchical Facets , function init Future Tree ( ) { return [ ] ; } ) ; this . facets = [ ] ; var disjunctive Facets = state . get Refined Disjunctive Facets ( ) ; var facets Indices = get Indices ( state . facets ) ; var disjunctive Facets Indices = get Indices ( state . disjunctive Facets ) ; var next Disjunctive Result = 1 ; var self = this ; 
function extract Normalized Facet Values ( results , attribute ) { var predicate = { name : attribute } ; if ( results . _state . is Conjunctive Facet ( attribute ) ) { var facet = find ( results . facets , predicate ) ; if ( ! facet ) return [ ] ; return map ( facet . data , function ( v , k ) { return { name : k , count : v , is Refined : results . _state . is Facet Refined ( attribute , k ) , is Excluded : results . _state . is Exclude Refined ( attribute , k ) } ; } ) ; } else if ( results . _state . is Disjunctive Facet ( attribute ) ) { var disjunctive Facet = find ( results . disjunctive Facets , predicate ) ; if ( ! disjunctive Facet ) return [ ] ; return map ( disjunctive Facet . data , function ( v , k ) { return { name : k , count : v , is Refined : results . _state . is Disjunctive Facet Refined ( attribute , k ) } ; } ) ; } else if ( results . _state . is Hierarchical Facet ( attribute ) ) { return find ( results . hierarchical Facets , predicate ) ; } } 
function rec Sort ( sort Fn , node ) { if ( ! node . data | | node . data . length = = = 0 ) { return node ; } var children = map ( node . data , partial ( rec Sort , sort Fn ) ) ; var sorted Children = sort Fn ( children ) ; var new Node = merge ( { } , node , { data : sorted Children } ) ; return new Node ; } 
function Search Parameters ( new Parameters ) { var params = new Parameters ? Search Parameters . _parse Numbers ( new Parameters ) : { } ; this . index = params . index | | ' ' ; * Query string of the instant search . The empty string is a valid query . * @member {string } * @see https : * / this . query = params . query | | ' ' ; * This attribute contains the list of all the conjunctive facets * used . This list will be added to requested facets in the * [facets attribute ] (https : * @member {string [ ] } * / this . facets = params . facets | | [ ] ; this . disjunctive Facets = params . disjunctive Facets | | [ ] ; this . hierarchical Facets = params . hierarchical Facets | | [ ] ; * This attribute contains all the filters that need to be * applied on the conjunctive facets . Each facet must be properly * defined in the `facets ` attribute . * * The key is the name of the facet , and the `Facet List ` contains all * filters selected for the associated facet name . * * When querying algolia , the values stored in this attribute will * be translated into the `facet Filters ` attribute . * @member {Object . <string , Search Parameters .Facet List > } * / this . facets Refinements = params . facets Refinements | | { } ; this . facets Excludes = params . facets Excludes | | { } ; this . disjunctive Facets Refinements = params . disjunctive Facets Refinements | | { } ; this . numeric Refinements = params . numeric Refinements | | { } ; this . tag Refinements = params . tag Refinements | | [ ] ; this . hierarchical Facets Refinements = params . hierarchical Facets Refinements | | { } ; this . numeric Filters = params . numeric Filters ; this . tag Filters = params . tag Filters ; this . optional Tag Filters = params . optional Tag Filters ; this . optional Facet Filters = params . optional Facet Filters ; * Number of hits to be returned by the search API * @member {number } * @see https : * / this . hits Per Page = params . hits Per Page ; this . max Values Per Facet = params . max Values Per Facet ; this . page = params . page | | 0 ; this . query Type = params . query Type ; this . typo Tolerance = params . typo Tolerance ; this . min Word Sizefor 1Typo = params . min Word Sizefor 1Typo ; this . min Word Sizefor 2Typos = params . min Word Sizefor 2Typos ; this . min Proximity = params . min Proximity ; this . allow Typos On Numeric Tokens = params . allow Typos On Numeric Tokens ; this . ignore Plurals = params . ignore Plurals ; this . restrict Searchable Attributes = params . restrict Searchable Attributes ; this . advanced Syntax = params . advanced Syntax ; this . analytics = params . analytics ; this . analytics Tags = params . analytics Tags ; this . synonyms = params . synonyms ; this . replace Synonyms In Highlight = params . replace Synonyms In Highlight ; this . optional Words = params . optional Words ; this . remove Words If No Results = params . remove Words If No Results ; this . attributes To Retrieve = params . attributes To Retrieve ; this . attributes To Highlight = params . attributes To Highlight ; this . highlight Pre Tag = params . highlight Pre Tag ; this . highlight Post Tag = params . highlight Post Tag ; this . attributes To Snippet = params . attributes To Snippet ; this . get Ranking Info = params . get Ranking Info ; this . distinct = params . distinct ; this . around Lat Lng = params . around Lat Lng ; this . around Lat Lng Via IP = params . around Lat Lng Via IP ; this . around Radius = params . around Radius ; this . minimum Around Radius = params . minimum Around Radius ; this . around Precision = params . around Precision ; this . inside Bounding Box = params . inside Bounding Box ; this . inside Polygon = params . inside Polygon ; this . snippet Ellipsis Text = params . snippet Ellipsis Text ; this . disable Exact On Attributes = params . disable Exact On Attributes ; this . enable Exact On Single Word Query = params . enable Exact On Single Word Query ; 
function clear Refinements ( attribute ) { var clear = Refinement List . clear Refinement ; var patch = { numeric Refinements : this . _clear Numeric Refinements ( attribute ) , facets Refinements : clear ( this . facets Refinements , attribute , 'conjunctive Facet ' ) , facets Excludes : clear ( this . facets Excludes , attribute , 'exclude ' ) , disjunctive Facets Refinements : clear ( this . disjunctive Facets Refinements , attribute , 'disjunctive Facet ' ) , hierarchical Facets Refinements : clear ( this . hierarchical Facets Refinements , attribute , 'hierarchical Facet ' ) } ; if ( patch . numeric Refinements = = = this . numeric Refinements & & patch . facets Refinements = = = this . facets Refinements & & patch . facets Excludes = = = this . facets Excludes & & patch . disjunctive Facets Refinements = = = this . disjunctive Facets Refinements & & patch . hierarchical Facets Refinements = = = this . hierarchical Facets Refinements ) { return this ; } return this . set Query Parameters ( patch ) ; } 
function ( attribute , operator , v ) { var value = val To Number ( v ) ; if ( this . is Numeric Refined ( attribute , operator , value ) ) return this ; var mod = merge ( { } , this . numeric Refinements ) ; mod [ attribute ] = merge ( { } , mod [ attribute ] ) ; if ( mod [ attribute ] [ operator ] ) { 
function ( attribute , operator , param Value ) { if ( param Value ! = = undefined ) { var param Value As Number = val To Number ( param Value ) ; if ( ! this . is Numeric Refined ( attribute , operator , param Value As Number ) ) return this ; return this . set Query Parameters ( { numeric Refinements : this . _clear Numeric Refinements ( function ( value , key ) { return key = = = attribute & & value . op = = = operator & & is Equal ( value . val , param Value As Number ) ; } ) } ) ; } else if ( operator ! = = undefined ) { if ( ! this . is Numeric Refined ( attribute , operator ) ) return this ; return this . set Query Parameters ( { numeric Refinements : this . _clear Numeric Refinements ( function ( value , key ) { return key = = = attribute & & value . op = = = operator ; } ) } ) ; } if ( ! this . is Numeric Refined ( attribute ) ) return this ; return this . set Query Parameters ( { numeric Refinements : this . _clear Numeric Refinements ( function ( value , key ) { return key = = = attribute ; } ) } ) ; } 
function _clear Numeric Refinements ( attribute ) { if ( is Undefined ( attribute ) ) { if ( is Empty ( this . numeric Refinements ) ) return this . numeric Refinements ; return { } ; } else if ( is String ( attribute ) ) { if ( is Empty ( this . numeric Refinements [ attribute ] ) ) return this . numeric Refinements ; return omit ( this . numeric Refinements , attribute ) ; } else if ( is Function ( attribute ) ) { var has Changed = false ; var new Numeric Refinements = reduce ( this . numeric Refinements , function ( memo , operators , key ) { var operator List = { } ; for Each ( operators , function ( values , operator ) { var out Values = [ ] ; for Each ( values , function ( value ) { var predicate Result = attribute ( { val : value , op : operator } , key , 'numeric ' ) ; if ( ! predicate Result ) out Values . push ( value ) ; } ) ; if ( ! is Empty ( out Values ) ) { if ( out Values . length ! = = values . length ) has Changed = true ; operator List [ operator ] = out Values ; } else has Changed = true ; } ) ; if ( ! is Empty ( operator List ) ) memo [ key ] = operator List ; return memo ; } , { } ) ; if ( has Changed ) return new Numeric Refinements ; return this . numeric Refinements ; } } 
function add Hierarchical Facet ( hierarchical Facet ) { if ( this . is Hierarchical Facet ( hierarchical Facet . name ) ) { throw new Error ( 'Cannot declare two hierarchical facets with the same name : ` ' + hierarchical Facet . name + ' ` ' ) ; } return this . set Query Parameters ( { hierarchical Facets : this . hierarchical Facets . concat ( [ hierarchical Facet ] ) } ) ; } 
function add Facet Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } if ( Refinement List . is Refined ( this . facets Refinements , facet , value ) ) return this ; return this . set Query Parameters ( { facets Refinements : Refinement List . add Refinement ( this . facets Refinements , facet , value ) } ) ; } 
function add Exclude Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } if ( Refinement List . is Refined ( this . facets Excludes , facet , value ) ) return this ; return this . set Query Parameters ( { facets Excludes : Refinement List . add Refinement ( this . facets Excludes , facet , value ) } ) ; } 
function add Disjunctive Facet Refinement ( facet , value ) { if ( ! this . is Disjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctive Facets attribute of the helper configuration ' ) ; } if ( Refinement List . is Refined ( this . disjunctive Facets Refinements , facet , value ) ) return this ; return this . set Query Parameters ( { disjunctive Facets Refinements : Refinement List . add Refinement ( this . disjunctive Facets Refinements , facet , value ) } ) ; } 
function add Tag Refinement ( tag ) { if ( this . is Tag Refined ( tag ) ) return this ; var modification = { tag Refinements : this . tag Refinements . concat ( tag ) } ; return this . set Query Parameters ( modification ) ; } 
function remove Facet ( facet ) { if ( ! this . is Conjunctive Facet ( facet ) ) { return this ; } return this . clear Refinements ( facet ) . set Query Parameters ( { facets : filter ( this . facets , function ( f ) { return f ! = = facet ; } ) } ) ; } 
function remove Disjunctive Facet ( facet ) { if ( ! this . is Disjunctive Facet ( facet ) ) { return this ; } return this . clear Refinements ( facet ) . set Query Parameters ( { disjunctive Facets : filter ( this . disjunctive Facets , function ( f ) { return f ! = = facet ; } ) } ) ; } 
function remove Hierarchical Facet ( facet ) { if ( ! this . is Hierarchical Facet ( facet ) ) { return this ; } return this . clear Refinements ( facet ) . set Query Parameters ( { hierarchical Facets : filter ( this . hierarchical Facets , function ( f ) { return f . name ! = = facet ; } ) } ) ; } 
function remove Facet Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } if ( ! Refinement List . is Refined ( this . facets Refinements , facet , value ) ) return this ; return this . set Query Parameters ( { facets Refinements : Refinement List . remove Refinement ( this . facets Refinements , facet , value ) } ) ; } 
function remove Exclude Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } if ( ! Refinement List . is Refined ( this . facets Excludes , facet , value ) ) return this ; return this . set Query Parameters ( { facets Excludes : Refinement List . remove Refinement ( this . facets Excludes , facet , value ) } ) ; } 
function remove Disjunctive Facet Refinement ( facet , value ) { if ( ! this . is Disjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctive Facets attribute of the helper configuration ' ) ; } if ( ! Refinement List . is Refined ( this . disjunctive Facets Refinements , facet , value ) ) return this ; return this . set Query Parameters ( { disjunctive Facets Refinements : Refinement List . remove Refinement ( this . disjunctive Facets Refinements , facet , value ) } ) ; } 
function remove Tag Refinement ( tag ) { if ( ! this . is Tag Refined ( tag ) ) return this ; var modification = { tag Refinements : filter ( this . tag Refinements , function ( t ) { return t ! = = tag ; } ) } ; return this . set Query Parameters ( modification ) ; } 
function toggle Facet Refinement ( facet , value ) { if ( this . is Hierarchical Facet ( facet ) ) { return this . toggle Hierarchical Facet Refinement ( facet , value ) ; } else if ( this . is Conjunctive Facet ( facet ) ) { return this . toggle Conjunctive Facet Refinement ( facet , value ) ; } else if ( this . is Disjunctive Facet ( facet ) ) { return this . toggle Disjunctive Facet Refinement ( facet , value ) ; } throw new Error ( 'Cannot refine the undeclared facet ' + facet + ' ; it should be added to the helper options facets , disjunctive Facets or hierarchical Facets ' ) ; } 
function toggle Conjunctive Facet Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } return this . set Query Parameters ( { facets Refinements : Refinement List . toggle Refinement ( this . facets Refinements , facet , value ) } ) ; } 
function toggle Exclude Facet Refinement ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } return this . set Query Parameters ( { facets Excludes : Refinement List . toggle Refinement ( this . facets Excludes , facet , value ) } ) ; } 
function toggle Disjunctive Facet Refinement ( facet , value ) { if ( ! this . is Disjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctive Facets attribute of the helper configuration ' ) ; } return this . set Query Parameters ( { disjunctive Facets Refinements : Refinement List . toggle Refinement ( this . disjunctive Facets Refinements , facet , value ) } ) ; } 
function toggle Hierarchical Facet Refinement ( facet , value ) { if ( ! this . is Hierarchical Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the hierarchical Facets attribute of the helper configuration ' ) ; } var separator = this . _get Hierarchical Facet Separator ( this . get Hierarchical Facet By Name ( facet ) ) ; var mod = { } ; var up One Or Multiple Level = this . hierarchical Facets Refinements [ facet ] ! = = undefined & & this . hierarchical Facets Refinements [ facet ] . length > 0 & & ( 
function ( facet , path ) { if ( this . is Hierarchical Facet Refined ( facet ) ) { throw new Error ( facet + ' is already refined . ' ) ; } var mod = { } ; mod [ facet ] = [ path ] ; return this . set Query Parameters ( { hierarchical Facets Refinements : defaults ( { } , mod , this . hierarchical Facets Refinements ) } ) ; } 
function is Facet Refined ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } return Refinement List . is Refined ( this . facets Refinements , facet , value ) ; } 
function is Exclude Refined ( facet , value ) { if ( ! this . is Conjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration ' ) ; } return Refinement List . is Refined ( this . facets Excludes , facet , value ) ; } 
function is Disjunctive Facet Refined ( facet , value ) { if ( ! this . is Disjunctive Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctive Facets attribute of the helper configuration ' ) ; } return Refinement List . is Refined ( this . disjunctive Facets Refinements , facet , value ) ; } 
function is Hierarchical Facet Refined ( facet , value ) { if ( ! this . is Hierarchical Facet ( facet ) ) { throw new Error ( facet + ' is not defined in the hierarchical Facets attribute of the helper configuration ' ) ; } var refinements = this . get Hierarchical Refinement ( facet ) ; if ( ! value ) { return refinements . length > 0 ; } return index Of ( refinements , value ) ! = = - 1 ; } 
function is Numeric Refined ( attribute , operator , value ) { if ( is Undefined ( value ) & & is Undefined ( operator ) ) { return ! ! this . numeric Refinements [ attribute ] ; } var is Operator Defined = this . numeric Refinements [ attribute ] & & ! is Undefined ( this . numeric Refinements [ attribute ] [ operator ] ) ; if ( is Undefined ( value ) | | ! is Operator Defined ) { return is Operator Defined ; } var parsed Value = val To Number ( value ) ; var is Attribute Value Defined = ! is Undefined ( find Array ( this . numeric Refinements [ attribute ] [ operator ] , parsed Value ) ) ; return is Operator Defined & & is Attribute Value Defined ; } 
function get Refined Disjunctive Facets ( ) { 
function set Parameter ( parameter , value ) { if ( this [ parameter ] = = = value ) return this ; var modification = { } ; modification [ parameter ] = value ; return this . set Query Parameters ( modification ) ; } 
function set Query Parameters ( params ) { if ( ! params ) return this ; var error = Search Parameters . validate ( this , params ) ; if ( error ) { throw error ; } var parsed Params = Search Parameters . _parse Numbers ( params ) ; return this . mutate Me ( function merge With ( new Instance ) { var ks = keys ( params ) ; for Each ( ks , function ( k ) { new Instance [ k ] = parsed Params [ k ] ; } ) ; return new Instance ; } ) ; } 
function ( facet Name ) { if ( ! this . is Hierarchical Facet ( facet Name ) ) { throw new Error ( 'Cannot get the breadcrumb of an unknown hierarchical facet : ` ' + facet Name + ' ` ' ) ; } var refinement = this . get Hierarchical Refinement ( facet Name ) [ 0 ] ; if ( ! refinement ) return [ ] ; var separator = this . _get Hierarchical Facet Separator ( this . get Hierarchical Facet By Name ( facet Name ) ) ; var path = refinement . split ( separator ) ; return map ( path , trim ) ; } 
function Algolia Search Helper ( client , index , options ) { if ( client . add Algolia Agent & & ! does Client Agent Contains Helper ( client ) ) { client . add Algolia Agent ( 'JS Helper ( ' + version + ' ) ' ) ; } this . set Client ( client ) ; var opts = options | | { } ; opts . index = index ; this . state = Search Parameters . make ( opts ) ; this . last Results = null ; this . _query Id = 0 ; this . _last Query Id Received = - 1 ; this . derived Helpers = [ ] ; this . _current Nb Queries = 0 ; } 
function run Command ( cmd , args ) { var prev = null ; console . log ( chalk . cyan Bright ( cmd ) + " " + args . map ( arg = > { if ( arg . starts With ( " - " ) ) return chalk . gray ( " \ \ " ) + " \n " + chalk . bold ( arg ) ; return arg ; } ) . join ( " " ) + " \n " ) ; var proc = child _process . spawn Sync ( cmd , args , { stdio : "inherit " } ) ; if ( proc . error ) throw proc . error ; if ( proc . status ! = = 0 ) throw Error ( "exited with " + proc . status ) ; return proc ; } 
function compile Intrinsics ( ) { var target = path . join ( source Directory , "passes " , "Wasm Intrinsics .cpp " ) ; run Command ( "python " , [ path . join ( binaryen Directory , "scripts " , "embedwast .py " ) , path . join ( source Directory , "passes " , "wasm -intrinsics .wast " ) , target ] ) ; source Files . push ( target ) ; } 
function compile Shared ( ) { run Command ( "python " , [ path . join ( emscripten Directory , "em + + " ) ] . concat ( source Files ) . concat ( common Options ) . concat ( [ " -o " , "shared .bc " ] ) ) ; } 
function compile Js ( options ) { run Command ( "python " , [ path . join ( emscripten Directory , "em + + " ) , "shared .bc " ] . concat ( common Options ) . concat ( [ " - -post -js " , options . post , " - -closure " , " 1 " , " -s " , "WASM = 0 " , " -s " , "EXPORTED _FUNCTIONS = [ " + exported Functions Arg + " ] " , " -s " , "ALLOW _MEMORY _GROWTH = 1 " , " -s " , "ELIMINATE _DUPLICATE _FUNCTIONS = 1 " , " -s " , "MODULARIZE _INSTANCE = 1 " , " -s " , "EXPORT _NAME = \ "Binaryen \ " " , " -o " , options . out , " -Oz " ] ) ) ; } 
function compile Wasm ( options ) { run ( "python " , [ path . join ( emscripten Directory , "em + + " ) , "shared .bc " ] . concat ( common Options ) . concat ( [ " - -post -js " , options . post , " - -closure " , " 1 " , " -s " , "EXPORTED _FUNCTIONS = [ " + exported Functions Arg + " ] " , " -s " , "ALLOW _MEMORY _GROWTH = 1 " , " -s " , "BINARYEN = 1 " , " -s " , "BINARYEN _METHOD = \ "native -wasm \ " " , " -s " , "MODULARIZE _INSTANCE = 1 " , " -s " , "EXPORT _NAME = \ "Binaryen \ " " , " -o " , options . out , " -Oz " ] ) ) ; } 
function plugin State ( ) { return { _sync : { signed In : false , user Id : null , unsubscribe : { } , path Variables : { } , patching : false , sync Stack : { inserts : [ ] , updates : { } , prop Deletions : { } , deletions : [ ] , debounce Timer : null , } , fetched : { } , stop Patching Timeout : null } } ; } 
function helpers ( origin Val , new Val ) { if ( is Array ( origin Val ) & & is Array Helper ( new Val ) ) { new Val = new Val . execute On ( origin Val ) ; } if ( is Number ( origin Val ) & & is Increment Helper ( new Val ) ) { new Val = new Val . execute On ( origin Val ) ; } return new Val ; 
function start Debounce ( ms ) { var start Time = Date . now ( ) ; var done = new Promise ( function ( resolve , reject ) { var interval = set Interval ( function ( _ ) { var now = Date . now ( ) ; var delta T = now - start Time ; if ( delta T > = ms ) { clear Interval ( interval ) ; resolve ( true ) ; } } , 1 0 ) ; } ) ; var refresh = function ( ) { return ( start Time = Date . now ( ) ) ; } ; return { done : done , refresh : refresh } ; } 
function grab Until Api Limit ( sync Stack Prop , count , max Count , state ) { var targets = state . _sync . sync Stack [ sync Stack Prop ] ; 
function make Batch From Syncstack ( state , getters , Firebase , batch Max Count ) { if ( batch Max Count = = = void 0 ) { batch Max Count = 5 0 0 ; } 
function get Path Var Matches ( path Piece ) { var matches = path Piece . match ( / \ { ( [a -z ] + ) \ } / gi ) ; if ( ! matches ) return [ ] ; return matches . map ( function ( key ) { return trim Accolades ( key ) ; } ) ; } 
function create Fetch Identifier ( where Order By ) { if ( where Order By = = = void 0 ) { where Order By = { } ; } var identifier = ' ' ; if ( 'where ' in where Order By ) { identifier + = ' [where ] ' + where Order By . where . map ( function ( where ) { return stringify Params ( where ) ; } ) . join ( ) ; } if ( 'order By ' in where Order By ) { identifier + = ' [order By ] ' + stringify Params ( where Order By . order By ) ; } if ( 'path Variables ' in where Order By ) { delete where Order By . path Variables . where ; delete where Order By . path Variables . order By ; identifier + = ' [path Variables ] ' + JSON . stringify ( where Order By . path Variables ) ; } return identifier ; } 
function get Value From Payload Piece ( payload Piece ) { if ( is Plain Object ( payload Piece ) & & ! payload Piece . id & & Object . keys ( payload Piece ) . length = = = 1 & & is Plain Object ( payload Piece [ Object . keys ( payload Piece ) [ 0 ] ] ) ) { return Object . values ( payload Piece ) [ 0 ] ; } return payload Piece ; } 
function store Update Fn ( _doc ) { switch ( change ) { case 'added ' : commit ( 'INSERT _DOC ' , _doc ) ; break ; case 'removed ' : commit ( 'DELETE _DOC ' , id ) ; break ; default : dispatch ( 'delete Missing Props ' , _doc ) ; commit ( 'PATCH _DOC ' , _doc ) ; break ; } } 
function store Update Fn ( _val ) { commit ( 'PATCH _DOC ' , _val ) ; return dispatch ( 'patch Doc ' , { id : id , doc : copy ( _val ) } ) ; } 
function store Update Fn ( _doc , _ids ) { _ids . for Each ( function ( _id ) { commit ( 'PATCH _DOC ' , _ _assign ( { id : _id } , _doc ) ) ; } ) ; return dispatch ( 'patch Doc ' , { ids : _ids , doc : _doc } ) ; } 
function store Update Fn ( _ids ) { _ids . for Each ( function ( _id ) { 
function error Check ( config ) { var errors = [ ] ; var req Props = [ 'firestore Path ' , 'module Name ' ] ; req Props . for Each ( function ( prop ) { if ( ! config [ prop ] ) { errors . push ( "Missing ` " + prop + " ` in your module ! " ) ; } } ) ; if ( / ( \ . | \ / ) / . test ( config . state Prop Name ) ) { errors . push ( "state Prop Name must only include letters from [a -z ] " ) ; } if ( / \ . / . test ( config . module Name ) ) { errors . push ( "module Name must only include letters from [a -z ] and forward slashes ' / ' " ) ; } var sync Props = [ 'where ' , 'order By ' , 'fillables ' , 'guard ' , 'default Values ' , 'insert Hook ' , 'patch Hook ' , 'delete Hook ' , 'insert Batch Hook ' , 'patch Batch Hook ' , 'delete Batch Hook ' ] ; sync Props . for Each ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found ` " + prop + " ` on your module , are you sure this shouldn 't be inside a prop called `sync ` ? " ) ; } } ) ; var server Change Props = [ 'modified Hook ' , 'default Values ' , 'added Hook ' , 'removed Hook ' ] ; server Change Props . for Each ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found ` " + prop + " ` on your module , are you sure this shouldn 't be inside a prop called `server Change ` ? " ) ; } } ) ; var fetch Props = [ 'doc Limit ' ] ; fetch Props . for Each ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found ` " + prop + " ` on your module , are you sure this shouldn 't be inside a prop called `fetch ` ? " ) ; } } ) ; var number Props = [ 'doc Limit ' ] ; number Props . for Each ( function ( prop ) { var _prop = config . fetch [ prop ] ; if ( ! is Number ( _prop ) ) errors . push ( " ` " + prop + " ` should be a Number , but is not . " ) ; } ) ; var function Props = [ 'insert Hook ' , 'patch Hook ' , 'delete Hook ' , 'insert Batch Hook ' , 'patch Batch Hook ' , 'delete Batch Hook ' , 'added Hook ' , 'modified Hook ' , 'removed Hook ' ] ; function Props . for Each ( function ( prop ) { var _prop = ( sync Props . includes ( prop ) ) ? config . sync [ prop ] : config . server Change [ prop ] ; if ( ! is Function ( _prop ) ) errors . push ( " ` " + prop + " ` should be a Function , but is not . " ) ; } ) ; var object Props = [ 'sync ' , 'server Change ' , 'default Values ' , 'fetch ' ] ; object Props . for Each ( function ( prop ) { var _prop = ( prop = = = 'default Values ' ) ? config . sync [ prop ] : config [ prop ] ; if ( ! is Plain Object ( _prop ) ) errors . push ( " ` " + prop + " ` should be an Object , but is not . " ) ; } ) ; var string Props = [ 'firestore Path ' , 'firestore Ref Type ' , 'module Name ' , 'state Prop Name ' ] ; string Props . for Each ( function ( prop ) { var _prop = config [ prop ] ; if ( ! is String ( _prop ) ) errors . push ( " ` " + prop + " ` should be a String , but is not . " ) ; } ) ; var array Props = [ 'where ' , 'order By ' , 'fillables ' , 'guard ' ] ; array Props . for Each ( function ( prop ) { var _prop = config . sync [ prop ] ; if ( ! is Array ( _prop ) ) errors . push ( " ` " + prop + " ` should be an Array , but is not . " ) ; } ) ; if ( errors . length ) { console . group ( ' [vuex -easy -firestore ] ERRORS : ' ) ; console . error ( "Module : " + config . module Name ) ; errors . for Each ( function ( e ) { return console . error ( ' - ' , e ) ; } ) ; console . group End ( ) ; return false ; } return true ; } 
function ini Module ( user Config , Firebase Dependency ) { 
function defaults ( config ) { 
function plugin Mutations ( user State ) { return { SET _PATHVARS : function ( state , path Vars ) { var self = this ; Object . keys ( path Vars ) . for Each ( function ( key ) { var path Piece = path Vars [ key ] ; self . _vm . $set ( state . _sync . path Variables , key , path Piece ) ; } ) ; } , SET _SYNCFILTERS : function ( state , _a ) { var where = _a . where , order By = _a . order By ; if ( where & & is What . is Array ( where ) ) state . _conf . sync . where = where ; if ( order By & & is What . is Array ( order By ) ) state . _conf . sync . order By = order By ; } , SET _USER _ID : function ( state , user Id ) { if ( ! user Id ) { state . _sync . signed In = false ; state . _sync . user Id = null ; } else { state . _sync . signed In = true ; state . _sync . user Id = user Id ; } } , CLEAR _USER : function ( state ) { state . _sync . signed In = false ; state . _sync . user Id = null ; } , RESET _VUEX _EASY _FIRESTORE _STATE : function ( state ) { 
function convert Timestamps ( origin Val , target Val ) { if ( origin Val = = = ' %convert Timestamp % ' ) { 
function set Default Values ( obj , default Values ) { if ( ! is What . is Plain Object ( default Values ) ) console . error ( ' [vuex -easy -firestore ] Trying to merge target : ' , obj , 'onto a non -object (default Values ) : ' , default Values ) ; if ( ! is What . is Plain Object ( obj ) ) console . error ( ' [vuex -easy -firestore ] Trying to merge a non -object : ' , obj , 'onto the default Values : ' , default Values ) ; var result = merge ( { extensions : [ convert Timestamps ] } , default Values , obj ) ; return find And Replace Anything . find And Replace ( result , ' %convert Timestamp % ' , null , { only Plain Objects : true } ) ; } 
function get Id ( payload Piece , conf , path , full Payload ) { if ( is What . is String ( payload Piece ) ) return payload Piece ; if ( is What . is Plain Object ( payload Piece ) ) { if ( 'id ' in payload Piece ) return payload Piece . id ; var keys = Object . keys ( payload Piece ) ; if ( keys . length = = = 1 ) return keys [ 0 ] ; } return ' ' ; } 
function plugin Actions ( Firebase ) { var _this = this ; return { set User Id : function ( _a , user Id ) { var commit = _a . commit , getters = _a . getters ; if ( user Id = = = undefined ) user Id = null ; 
function plugin Getters ( Firebase ) { return { firestore Path Complete : function ( state , getters ) { var path = state . _conf . firestore Path ; Object . keys ( state . _sync . path Variables ) . for Each ( function ( key ) { var path Piece = state . _sync . path Variables [ key ] ; path = path . replace ( " { " + key + " } " , " " + path Piece ) ; } ) ; var require User = path . includes ( ' {user Id } ' ) ; if ( require User ) { var user Id = state . _sync . user Id ; if ( getters . signed In & & is What . is String ( user Id ) & & user Id ! = = ' ' & & user Id ! = = ' {user Id } ' ) { path = path . replace ( ' {user Id } ' , user Id ) ; } } return path ; } , signed In : function ( state , getters , root State , root Getters ) { var require User = state . _conf . firestore Path . includes ( ' {user Id } ' ) ; if ( ! require User ) return true ; return state . _sync . signed In ; } , db Ref : function ( state , getters , root State , root Getters ) { var path = getters . firestore Path Complete ; return ( getters . collection Mode ) ? Firebase . firestore ( ) . collection ( path ) : Firebase . firestore ( ) . doc ( path ) ; } , store Ref : function ( state , getters , root State ) { var path = ( state . _conf . state Prop Name ) ? state . _conf . module Name + " / " + state . _conf . state Prop Name : state . _conf . module Name ; return vuex Easy Access . get Deep Ref ( root State , path ) ; } , collection Mode : function ( state , getters , root State ) { return ( state . _conf . firestore Ref Type . to Lower Case ( ) = = = 'collection ' ) ; } , doc Mode Id : function ( state , getters ) { return getters . firestore Path Complete . split ( ' / ' ) . pop ( ) ; } , fillables : function ( state ) { var fillables = state . _conf . sync . fillables ; if ( ! fillables . length ) return fillables ; return fillables . concat ( [ 'updated _at ' , 'updated _by ' , 'id ' , 'created _at ' , 'created _by ' ] ) ; } , guard : function ( state ) { return state . _conf . sync . guard . concat ( [ ' _conf ' , ' _sync ' ] ) ; } , default Values : function ( state , getters ) { return merge ( state . _conf . sync . default Values , state . _conf . server Change . default Values 
function vuex Easy Firestore ( easy Firestore Module , _a ) { var _b = _a = = = void 0 ? { logging : false , prevent Initial Doc Insertion : false , Firebase Dependency : Firebase $ 2 } : _a , _c = _b . logging , logging = _c = = = void 0 ? false : _c , _d = _b . prevent Initial Doc Insertion , prevent Initial Doc Insertion = _d = = = void 0 ? false : _d , _e = _b . Firebase Dependency , Firebase Dependency = _e = = = void 0 ? Firebase $ 2 : _e ; if ( Firebase Dependency ) { set Firebase Dependency ( Firebase Dependency ) ; set Firebase Dependency $ 1 ( Firebase Dependency ) ; } return function ( store ) { 
function add Attrs ( element , attrs ) { Object . keys ( attrs ) . for Each ( function ( key ) { element . set Attribute ( key , attrs [ key ] ) ; } ) ; } 
function _transform To Hierarchy ( links , attribute Fields ) { const nodes By Name = { } ; const assign Node = name = > { if ( ! nodes By Name [ name ] ) { nodes By Name [ name ] = { name } ; } return nodes By Name [ name ] ; } ; const assign Node With Attributes = ( name , attributes ) = > { if ( ! nodes By Name [ name ] ) { nodes By Name [ name ] = { name , attributes , } ; } return nodes By Name [ name ] ; } ; 
function parse CSV ( csv File Path , attribute Fields ) { return new Promise ( ( resolve , reject ) = > { try { csv ( csv File Path , data = > resolve ( _transform To Hierarchy ( data , attribute Fields ) ) ) ; 
function parse JSON ( json File Path ) { return new Promise ( ( resolve , reject ) = > { try { json ( json File Path , data = > resolve ( [ data ] ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function parse Flat JSON ( json File Path , attribute Fields ) { return new Promise ( ( resolve , reject ) = > { try { json ( json File Path , data = > resolve ( _transform To Hierarchy ( data , attribute Fields ) ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function check Prop Types ( type Specs , values , location , component Name , get Stack ) { if ( true ) { for ( var type Spec Name in type Specs ) { if ( type Specs . has Own Property ( type Spec Name ) ) { var error ; 
function invoke Guarded Callback ( name , func , context , a , b , c , d , e , f ) { has Error = false ; caught Error = null ; invoke Guarded Callback Impl $ 1 . apply ( reporter , arguments ) ; } 
function invoke Guarded Callback And Catch First Error ( name , func , context , a , b , c , d , e , f ) { invoke Guarded Callback . apply ( this , arguments ) ; if ( has Error ) { var error = clear Caught Error ( ) ; if ( ! has Rethrow Error ) { has Rethrow Error = true ; rethrow Error = error ; } } } 
function get Closest Instance From Node ( node ) { if ( node [ internal Instance Key ] ) { return node [ internal Instance Key ] ; } while ( ! node [ internal Instance Key ] ) { if ( node . parent Node ) { node = node . parent Node ; } else { 
function get Instance From Node $ 1 ( node ) { var inst = node [ internal Instance Key ] ; if ( inst ) { if ( inst . tag = = = Host Component | | inst . tag = = = Host Text ) { return inst ; } else { return null ; } } return null ; } 
function get Node From Instance $ 1 ( inst ) { if ( inst . tag = = = Host Component | | inst . tag = = = Host Text ) { 
function traverse Enter Leave ( from , to , fn , arg From , arg To ) { var common = from & & to ? get Lowest Common Ancestor ( from , to ) : null ; var path From = [ ] ; while ( true ) { if ( ! from ) { break ; } if ( from = = = common ) { break ; } var alternate = from . alternate ; if ( alternate ! = = null & & alternate = = = common ) { break ; } path From . push ( from ) ; from = get Parent ( from ) ; } var path To = [ ] ; while ( true ) { if ( ! to ) { break ; } if ( to = = = common ) { break ; } var _alternate = to . alternate ; if ( _alternate ! = = null & & _alternate = = = common ) { break ; } path To . push ( to ) ; to = get Parent ( to ) ; } for ( var i = 0 ; i < path From . length ; i + + ) { fn ( path From [ i ] , 'bubbled ' , arg From ) ; } for ( var _i = path To . length ; _i - - > 0 ; ) { fn ( path To [ _i ] , 'captured ' , arg To ) ; } } 
function accumulate Directional Dispatches ( inst , phase , event ) { { ! inst ? warning Without Stack $ 1 ( false , 'Dispatching inst must not be null ' ) : void 0 ; } var listener = listener At Phase ( inst , event , phase ) ; if ( listener ) { event . _dispatch Listeners = accumulate Into ( event . _dispatch Listeners , listener ) ; event . _dispatch Instances = accumulate Into ( event . _dispatch Instances , inst ) ; } } 
function make Prefix Map ( style Prop , event Name ) { var prefixes = { } ; prefixes [ style Prop . to Lower Case ( ) ] = event Name . to Lower Case ( ) ; prefixes [ 'Webkit ' + style Prop ] = 'webkit ' + event Name ; prefixes [ 'Moz ' + style Prop ] = 'moz ' + event Name ; return prefixes ; } 
function ( ) { var Interface = this . constructor . Interface ; for ( var prop Name in Interface ) { { Object . define Property ( this , prop Name , get Pooled Warning Property Definition ( prop Name , Interface [ prop Name ] ) ) ; } } this . dispatch Config = null ; this . _target Inst = null ; this . native Event = null ; this . is Default Prevented = function That Returns False ; this . is Propagation Stopped = function That Returns False ; this . _dispatch Listeners = null ; this . _dispatch Instances = null ; { Object . define Property ( this , 'native Event ' , get Pooled Warning Property Definition ( 'native Event ' , null ) ) ; Object . define Property ( this , 'is Default Prevented ' , get Pooled Warning Property Definition ( 'is Default Prevented ' , function That Returns False ) ) ; Object . define Property ( this , 'is Propagation Stopped ' , get Pooled Warning Property Definition ( 'is Propagation Stopped ' , function That Returns False ) ) ; Object . define Property ( this , 'prevent Default ' , get Pooled Warning Property Definition ( 'prevent Default ' , function ( ) { } ) ) ; Object . define Property ( this , 'stop Propagation ' , get Pooled Warning Property Definition ( 'stop Propagation ' , function ( ) { } ) ) ; } } 
function get Composition Event Type ( top Level Type ) { switch ( top Level Type ) { case TOP _COMPOSITION _START : return event Types . composition Start ; case TOP _COMPOSITION _END : return event Types . composition End ; case TOP _COMPOSITION _UPDATE : return event Types . composition Update ; } } 
function is Fallback Composition End ( top Level Type , native Event ) { switch ( top Level Type ) { case TOP _KEY _UP : 
function get Value For Property ( node , name , expected , property Info ) { { if ( property Info . must Use Property ) { var property Name = property Info . property Name ; return node [ property Name ] ; } else { var attribute Name = property Info . attribute Name ; var string Value = null ; if ( property Info . type = = = OVERLOADED _BOOLEAN ) { if ( node . has Attribute ( attribute Name ) ) { var value = node . get Attribute ( attribute Name ) ; if ( value = = = ' ' ) { return true ; } if ( should Remove Attribute ( name , expected , property Info , false ) ) { return value ; } if ( value = = = ' ' + expected ) { return expected ; } return value ; } } else if ( node . has Attribute ( attribute Name ) ) { if ( should Remove Attribute ( name , expected , property Info , false ) ) { 
function set Value For Property ( node , name , value , is Custom Component Tag ) { var property Info = get Property Info ( name ) ; if ( should Ignore Attribute ( name , property Info , is Custom Component Tag ) ) { return ; } if ( should Remove Attribute ( name , value , property Info , is Custom Component Tag ) ) { value = null ; } 
function get Host Props ( element , props ) { var node = element ; var checked = props . checked ; var host Props = _assign ( { } , props , { default Checked : undefined , default Value : undefined , value : undefined , checked : checked ! = null ? checked : node . _wrapper State . initial Checked } ) ; return host Props ; } 
function get Target Inst For Input Event Polyfill ( top Level Type , target Inst ) { if ( top Level Type = = = TOP _SELECTION _CHANGE | | top Level Type = = = TOP _KEY _UP | | top Level Type = = = TOP _KEY _DOWN ) { 
function ( top Level Type , target Inst , native Event , native Event Target ) { var is Over Event = top Level Type = = = TOP _MOUSE _OVER | | top Level Type = = = TOP _POINTER _OVER ; var is Out Event = top Level Type = = = TOP _MOUSE _OUT | | top Level Type = = = TOP _POINTER _OUT ; if ( is Over Event & & ( native Event . related Target | | native Event . from Element ) ) { return null ; } if ( ! is Out Event & & ! is Over Event ) { 
function find Root Container Node ( inst ) { 
function listen To ( registration Name , mount At ) { var is Listening = get Listening For Document ( mount At ) ; var dependencies = registration Name Dependencies [ registration Name ] ; for ( var i = 0 ; i < dependencies . length ; i + + ) { var dependency = dependencies [ i ] ; if ( ! ( is Listening . has Own Property ( dependency ) & & is Listening [ dependency ] ) ) { switch ( dependency ) { case TOP _SCROLL : trap Captured Event ( TOP _SCROLL , mount At ) ; break ; case TOP _FOCUS : case TOP _BLUR : trap Captured Event ( TOP _FOCUS , mount At ) ; trap Captured Event ( TOP _BLUR , mount At ) ; 
function get Event Target Document ( event Target ) { return event Target . window = = = event Target ? event Target . document : event Target . node Type = = = DOCUMENT _NODE ? event Target : event Target . owner Document ; } 
function construct Select Event ( native Event , native Event Target ) { 
function validate Props ( element , props ) { { 
function ( node , text ) { if ( text ) { var first Child = node . first Child ; if ( first Child & & first Child = = = node . last Child & & first Child . node Type = = = TEXT _NODE ) { first Child . node Value = text ; return ; } } node . text Content = text ; } 
function dangerous Style Value ( name , value , is Custom Property ) { 
function create Dangerous String For Styles ( styles ) { { var serialized = ' ' ; var delimiter = ' ' ; for ( var style Name in styles ) { if ( ! styles . has Own Property ( style Name ) ) { continue ; } var style Value = styles [ style Name ] ; if ( style Value ! = null ) { var is Custom Property = style Name . index Of ( ' - - ' ) = = = 0 ; serialized + = delimiter + hyphenate Style Name ( style Name ) + ' : ' ; serialized + = dangerous Style Value ( style Name , style Value , is Custom Property ) ; delimiter = ' ; ' ; } } return serialized | | null ; } } 
function set Value For Styles ( node , styles ) { var style = node . style ; for ( var style Name in styles ) { if ( ! styles . has Own Property ( style Name ) ) { continue ; } var is Custom Property = style Name . index Of ( ' - - ' ) = = = 0 ; { if ( ! is Custom Property ) { warn Valid Style $ 1 ( style Name , styles [ style Name ] ) ; } } var style Value = dangerous Style Value ( style Name , styles [ style Name ] , is Custom Property ) ; if ( style Name = = = 'float ' ) { style Name = 'css Float ' ; } if ( is Custom Property ) { style . set Property ( style Name , style Value ) ; } else { style [ style Name ] = style Value ; } } } 
function create Fiber Root ( container Info , is Async , hydrate ) { 
function mark Pending Priority Level ( root , expiration Time ) { 
function warn On Invalid Key ( child , known Keys ) { { if ( typeof child ! = = 'object ' | | child = = = null ) { return known Keys ; } switch ( child . $ $typeof ) { case REACT _ELEMENT _TYPE : case REACT _PORTAL _TYPE : warn For Missing Key ( child ) ; var key = child . key ; if ( typeof key ! = = 'string ' ) { break ; } if ( known Keys = = = null ) { known Keys = new Set ( ) ; known Keys . add ( key ) ; break ; } if ( ! known Keys . has ( key ) ) { known Keys . add ( key ) ; break ; } warning $ 1 ( false , 'Encountered two children with the same key , ` %s ` . ' + 'Keys should be unique so that components maintain their identity ' + 'across updates . Non -unique keys may cause children to be ' + 'duplicated and /or omitted  the behavior is unsupported and ' + ' ould change in a future version . ' , k y ) ; break ; default : break ; } } return known Keys ; } 
function bailout On Already Finished Work ( current $ $ 1 , work In Progress , render Expiration Time ) { cancel Work Timer ( work In Progress ) ; if ( current $ $ 1 ! = = null ) { 
function ( container Child Set , work In Progress ) { 
function safely Call Component Will Unmount ( current $ $ 1 , instance ) { { invoke Guarded Callback ( null , call Component Will Unmount With Timer , null , current $ $ 1 , instance ) ; if ( has Caught Error ( ) ) { var unmount Error = clear Caught Error ( ) ; capture Commit Phase Error ( current $ $ 1 , unmount Error ) ; } } } 
function commit Unmount ( current $ $ 1 ) { on Commit Unmount ( current $ $ 1 ) ; switch ( current $ $ 1 . tag ) { case Class Component : case Class Component Lazy : { safely Detach Ref ( current $ $ 1 ) ; var instance = current $ $ 1 . state Node ; if ( typeof instance . component Will Unmount = = = 'function ' ) { safely Call Component Will Unmount ( current $ $ 1 , instance ) ; } return ; } case Host Component : { safely Detach Ref ( current $ $ 1 ) ; return ; } case Host Portal : { 
function compute Unique Async Expiration ( ) { var current Time = request Current Time ( ) ; var result = compute Async Expiration ( current Time ) ; if ( result < = last Unique Async Expiration ) { 
function batched Updates $ 1 ( fn , a ) { var previous Is Batching Updates = is Batching Updates ; is Batching Updates = true ; try { return fn ( a ) ; } finally { is Batching Updates = previous Is Batching Updates ; if ( ! is Batching Updates & & ! is Rendering ) { perform Sync Work ( ) ; } } } 
function flush Sync ( fn , a ) { ! ! is Rendering ? invariant ( false , 'flush Sync was called from inside a lifecycle method . It cannot be called when React is already rendering . ' ) : void 0 ; var previous Is Batching Updates = is Batching Updates ; is Batching Updates = true ; try { return sync Updates ( fn , a ) ; } finally { is Batching Updates = previous Is Batching Updates ; perform Sync Work ( ) ; } } 
function create Portal $ 1 ( children , container Info , 
function React Batch ( root ) { var expiration Time = compute Unique Async Expiration ( ) ; this . _expiration Time = expiration Time ; this . _root = root ; this . _next = null ; this . _callbacks = null ; this . _did Complete = false ; this . _has Children = false ; this . _children = null ; this . _defer = true ; } 
function Component ( props , context , updater ) { this . props = props ; this . context = context ; 
function to Array ( children ) { var result = [ ] ; map Into With Key Prefix Internal ( children , result , null , function ( child ) { return child ; } ) ; return result ; } 
function validate Prop Types ( element ) { var type = element . type ; var name = void 0 , prop Types = void 0 ; if ( typeof type = = = 'function ' ) { 
function validate Fragment Props ( fragment ) { set Currently Validating Element ( fragment ) ; var keys = Object . keys ( fragment . props ) ; for ( var i = 0 ; i < keys . length ; i + + ) { var key = keys [ i ] ; if ( key ! = = 'children ' & & key ! = = 'key ' ) { warning $ 1 ( false , 'Invalid prop ` %s ` supplied to `React .Fragment ` . ' + 'React .Fragment can only have `key ` and `children ` props . ' , key ) ; break ; } } if ( fragment . ref ! = = null ) { warning $ 1 ( false , 'Invalid attribute `ref ` supplied to `React .Fragment ` . ' ) ; } set Currently Validating Element ( null ) ; } 
function head Bucket ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Head Bucket ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , method : 'HEAD ' , } , function ( err , data ) { callback ( err , data ) ; } ) ; } 
function get Bucket ( params , callback ) { var req Params = { } ; req Params [ 'prefix ' ] = params [ 'Prefix ' ] | | ' ' ; req Params [ 'delimiter ' ] = params [ 'Delimiter ' ] ; req Params [ 'marker ' ] = params [ 'Marker ' ] ; req Params [ 'max -keys ' ] = params [ 'Max Keys ' ] ; req Params [ 'encoding -type ' ] = params [ 'Encoding Type ' ] ; submit Request . call ( this , { Action : 'name /cos :Get Bucket ' , Resource Key : req Params [ 'prefix ' ] , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , qs : req Params , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var List Bucket Result = data . List Bucket Result | | { } ; var Contents = List Bucket Result . Contents | | [ ] ; var Common Prefixes = List Bucket Result . Common Prefixes | | [ ] ; Contents = util . is Array ( Contents ) ? Contents : [ Contents ] ; Common Prefixes = util . is Array ( Common Prefixes ) ? Common Prefixes : [ Common Prefixes ] ; var result = util . clone ( List Bucket Result ) ; util . extend ( result , { Contents : Contents , Common Prefixes : Common Prefixes , status Code : data . status Code , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function get Bucket Acl ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Get Bucket ACL ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'acl ' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var Access Control Policy = data . Access Control Policy | | { } ; var Owner = Access Control Policy . Owner | | { } ; var Grant = Access Control Policy . Access Control List . Grant | | [ ] ; Grant = util . is Array ( Grant ) ? Grant : [ Grant ] ; var result = decode Acl ( Access Control Policy ) ; if ( data . headers & & data . headers [ 'x -cos -acl ' ] ) { result . ACL = data . headers [ 'x -cos -acl ' ] ; } result = util . extend ( result , { Owner : Owner , Grants : Grant , status Code : data . status Code , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function get Bucket Cors ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Get Bucket CORS ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors ' , } , function ( err , data ) { if ( err ) { if ( err . status Code = = = 4 0 4 & & err . error & & err . error . Code = = = 'No Such CORSConfiguration ' ) { var result = { CORSRules : [ ] , status Code : err . status Code , } ; err . headers & & ( result . headers = err . headers ) ; callback ( null , result ) ; } else { callback ( err ) ; } return ; } var CORSConfiguration = data . CORSConfiguration | | { } ; var CORSRules = CORSConfiguration . CORSRules | | CORSConfiguration . CORSRule | | [ ] ; CORSRules = util . clone ( util . is Array ( CORSRules ) ? CORSRules : [ CORSRules ] ) ; util . each ( CORSRules , function ( rule ) { util . each ( [ 'Allowed Origin ' , 'Allowed Header ' , 'Allowed Method ' , 'Expose Header ' ] , function ( key , j ) { var s Key = key + 's ' ; var val = rule [ s Key ] | | rule [ key ] | | [ ] ; delete rule [ key ] ; rule [ s Key ] = util . is Array ( val ) ? val : [ val ] ; } ) ; } ) ; callback ( null , { CORSRules : CORSRules , status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function put Bucket Cors ( params , callback ) { var CORSConfiguration = params [ 'CORSConfiguration ' ] | | { } ; var CORSRules = CORSConfiguration [ 'CORSRules ' ] | | params [ 'CORSRules ' ] | | [ ] ; CORSRules = util . clone ( util . is Array ( CORSRules ) ? CORSRules : [ CORSRules ] ) ; util . each ( CORSRules , function ( rule ) { util . each ( [ 'Allowed Origin ' , 'Allowed Header ' , 'Allowed Method ' , 'Expose Header ' ] , function ( key , k ) { var s Key = key + 's ' ; var val = rule [ s Key ] | | rule [ key ] | | [ ] ; delete rule [ s Key ] ; rule [ key ] = util . is Array ( val ) ? val : [ val ] ; } ) ; } ) ; var xml = util . json 2xml ( { CORSConfiguration : { CORSRule : CORSRules } } ) ; var headers = params . Headers ; headers [ 'Content -Type ' ] = 'application /xml ' ; headers [ 'Content -MD 5 ' ] = util . binary Base 6 4 ( util . md 5 ( xml ) ) ; submit Request . call ( this , { Action : 'name /cos :Put Bucket CORS ' , method : 'PUT ' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'cors ' , headers : headers , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function delete Bucket Cors ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Delete Bucket CORS ' , method : 'DELETE ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors ' , } , function ( err , data ) { if ( err & & err . status Code = = = 2 0 4 ) { return callback ( null , { status Code : err . status Code } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { status Code : data . status Code | | err . status Code , headers : data . headers , } ) ; } ) ; } 
function get Bucket Location ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Get Bucket Location ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'location ' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , data ) ; } ) ; } 
function get Bucket Policy ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Get Bucket Policy ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'policy ' , raw Body : true , } , function ( err , data ) { if ( err ) { if ( err . status Code & & err . status Code = = = 4 0 3 ) { return callback ( { Error Status : 'Access Denied ' } ) ; } if ( err . status Code & & err . status Code = = = 4 0 5 ) { return callback ( { Error Status : 'Method Not Allowed ' } ) ; } if ( err . status Code & & err . status Code = = = 4 0 4 ) { return callback ( { Error Status : 'Policy Not Found ' } ) ; } return callback ( err ) ; } var Policy = { } ; try { Policy = JSON . parse ( data . body ) ; } catch ( e ) { } callback ( null , { Policy : Policy , status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function get Bucket Tagging ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Get Bucket Tagging ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'tagging ' , } , function ( err , data ) { if ( err ) { if ( err . status Code = = = 4 0 4 & & err . error & & ( err . error = = = "Not Found " | | err . error . Code = = = 'No Such Tag Set ' ) ) { var result = { Tags : [ ] , status Code : err . status Code , } ; err . headers & & ( result . headers = err . headers ) ; callback ( null , result ) ; } else { callback ( err ) ; } return ; } var Tags = [ ] ; try { Tags = data . Tagging . Tag Set . Tag | | [ ] ; } catch ( e ) { } Tags = util . clone ( util . is Array ( Tags ) ? Tags : [ Tags ] ) ; callback ( null , { Tags : Tags , status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function put Bucket Tagging ( params , callback ) { var Tagging = params [ 'Tagging ' ] | | { } ; var Tags = Tagging . Tag Set | | Tagging . Tags | | params [ 'Tags ' ] | | [ ] ; Tags = util . clone ( util . is Array ( Tags ) ? Tags : [ Tags ] ) ; var xml = util . json 2xml ( { Tagging : { Tag Set : { Tag : Tags } } } ) ; var headers = params . Headers ; headers [ 'Content -Type ' ] = 'application /xml ' ; headers [ 'Content -MD 5 ' ] = util . binary Base 6 4 ( util . md 5 ( xml ) ) ; submit Request . call ( this , { Action : 'name /cos :Put Bucket Tagging ' , method : 'PUT ' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'tagging ' , headers : headers , } , function ( err , data ) { if ( err & & err . status Code = = = 2 0 4 ) { return callback ( null , { status Code : err . status Code } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function head Object ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Head Object ' , method : 'HEAD ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , Version Id : params . Version Id , headers : params . Headers , } , function ( err , data ) { if ( err ) { var status Code = err . status Code ; if ( params . Headers [ 'If -Modified -Since ' ] & & status Code & & status Code = = = 3 0 4 ) { return callback ( null , { Not Modified : true , status Code : status Code , } ) ; } return callback ( err ) ; } if ( data . headers & & data . headers . etag ) { data . ETag = data . headers & & data . headers . etag ; } callback ( null , data ) ; } ) ; } 
function get Object ( params , callback ) { var req Params = { } ; req Params [ 'response -content -type ' ] = params [ 'Response Content Type ' ] ; req Params [ 'response -content -language ' ] = params [ 'Response Content Language ' ] ; req Params [ 'response -expires ' ] = params [ 'Response Expires ' ] ; req Params [ 'response -cache -control ' ] = params [ 'Response Cache Control ' ] ; req Params [ 'response -content -disposition ' ] = params [ 'Response Content Disposition ' ] ; req Params [ 'response -content -encoding ' ] = params [ 'Response Content Encoding ' ] ; 
function put Object ( params , callback ) { var self = this ; var File Size = params . Content Length ; var on Progress = util . throttle On Progress . call ( self , File Size , params . on Progress ) ; 
function delete Object ( params , callback ) { submit Request . call ( this , { Action : 'name /cos :Delete Object ' , method : 'DELETE ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , Version Id : params . Version Id , } , function ( err , data ) { if ( err ) { var status Code = err . status Code ; if ( status Code & & status Code = = = 2 0 4 ) { return callback ( null , { status Code : status Code } ) ; } else if ( status Code & & status Code = = = 4 0 4 ) { return callback ( null , { Bucket Not Found : true , status Code : status Code , } ) ; } else { return callback ( err ) ; } } callback ( null , { status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function put Object Acl ( params , callback ) { var headers = params . Headers ; var xml = ' ' ; if ( params [ 'Access Control Policy ' ] ) { var Access Control Policy = util . clone ( params [ 'Access Control Policy ' ] | | { } ) ; var Grants = Access Control Policy . Grants | | Access Control Policy . Grant ; Grants = util . is Array ( Grants ) ? Grants : [ Grants ] ; delete Access Control Policy . Grant ; delete Access Control Policy . Grants ; Access Control Policy . Access Control List = { Grant : Grants } ; xml = util . json 2xml ( { Access Control Policy : Access Control Policy } ) ; headers [ 'Content -Type ' ] = 'application /xml ' ; headers [ 'Content -MD 5 ' ] = util . binary Base 6 4 ( util . md 5 ( xml ) ) ; } 
function options Object ( params , callback ) { var headers = params . Headers ; headers [ 'Origin ' ] = params [ 'Origin ' ] ; headers [ 'Access -Control -Request -Method ' ] = params [ 'Access Control Request Method ' ] ; headers [ 'Access -Control -Request -Headers ' ] = params [ 'Access Control Request Headers ' ] ; submit Request . call ( this , { Action : 'name /cos :Options Object ' , method : 'OPTIONS ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : headers , } , function ( err , data ) { if ( err ) { if ( err . status Code & & err . status Code = = = 4 0 3 ) { return callback ( null , { Options Forbidden : true , status Code : err . status Code } ) ; } return callback ( err ) ; } var headers = data . headers | | { } ; callback ( null , { Access Control Allow Origin : headers [ 'access -control -allow -origin ' ] , Access Control Allow Methods : headers [ 'access -control -allow -methods ' ] , Access Control Allow Headers : headers [ 'access -control -allow -headers ' ] , Access Control Expose Headers : headers [ 'access -control -expose -headers ' ] , Access Control Max Age : headers [ 'access -control -max -age ' ] , status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function multipart Init ( params , callback ) { var xml ; var headers = params . Headers ; var user Agent = navigator & & navigator . user Agent | | ' ' ; var m = user Agent . match ( / TBS \ / ( \d { 6 } ) / ) ; if ( location . protocol = = = 'http : ' & & m & & m [ 1 ] . length < = 6 & & m [ 1 ] < ' 0 4 4 4 2 9 ' ) { xml = util . json 2xml ( { } ) ; headers [ 'Content -MD 5 ' ] = util . binary Base 6 4 ( util . md 5 ( xml ) ) ; 
function multipart Complete ( params , callback ) { var self = this ; var Upload Id = params . Upload Id ; var Parts = params [ 'Parts ' ] ; for ( var i = 0 , len = Parts . length ; i < len ; i + + ) { if ( Parts [ i ] [ 'ETag ' ] . index Of ( ' " ' ) = = = 0 ) { continue ; } Parts [ i ] [ 'ETag ' ] = ' " ' + Parts [ i ] [ 'ETag ' ] + ' " ' ; } var xml = util . json 2xml ( { Complete Multipart Upload : { Part : Parts } } ) ; var headers = params . Headers ; headers [ 'Content -Type ' ] = 'application /xml ' ; headers [ 'Content -MD 5 ' ] = util . binary Base 6 4 ( util . md 5 ( xml ) ) ; submit Request . call ( this , { Action : 'name /cos :Complete Multipart Upload ' , method : 'POST ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , qs : { upload Id : Upload Id } , body : xml , headers : headers , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var url = get Url ( { Force Path Style : self . options . Force Path Style , protocol : self . options . Protocol , domain : self . options . Domain , bucket : params . Bucket , region : params . Region , object : params . Key , is Location : true , } ) ; var Complete Multipart Upload Result = data . Complete Multipart Upload Result | | { } ; var result = util . extend ( Complete Multipart Upload Result , { Location : url , status Code : data . status Code , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipart List ( params , callback ) { var req Params = { } ; req Params [ 'delimiter ' ] = params [ 'Delimiter ' ] ; req Params [ 'encoding -type ' ] = params [ 'Encoding Type ' ] ; req Params [ 'prefix ' ] = params [ 'Prefix ' ] | | ' ' ; req Params [ 'max -uploads ' ] = params [ 'Max Uploads ' ] ; req Params [ 'key -marker ' ] = params [ 'Key Marker ' ] ; req Params [ 'upload -id -marker ' ] = params [ 'Upload Id Marker ' ] ; req Params = util . clear Key ( req Params ) ; submit Request . call ( this , { Action : 'name /cos :List Multipart Uploads ' , Resource Key : req Params [ 'prefix ' ] , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , qs : req Params , action : 'uploads ' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } if ( data & & data . List Multipart Uploads Result ) { var Upload = data . List Multipart Uploads Result . Upload | | [ ] ; var Common Prefixes = data . List Multipart Uploads Result . Common Prefixes | | [ ] ; Common Prefixes = util . is Array ( Common Prefixes ) ? Common Prefixes : [ Common Prefixes ] ; Upload = util . is Array ( Upload ) ? Upload : [ Upload ] ; data . List Multipart Uploads Result . Upload = Upload ; data . List Multipart Uploads Result . Common Prefixes = Common Prefixes ; } var result = util . clone ( data . List Multipart Uploads Result | | { } ) ; util . extend ( result , { status Code : data . status Code , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipart List Part ( params , callback ) { var req Params = { } ; req Params [ 'upload Id ' ] = params [ 'Upload Id ' ] ; req Params [ 'encoding -type ' ] = params [ 'Encoding Type ' ] ; req Params [ 'max -parts ' ] = params [ 'Max Parts ' ] ; req Params [ 'part -number -marker ' ] = params [ 'Part Number Marker ' ] ; submit Request . call ( this , { Action : 'name /cos :List Parts ' , method : 'GET ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , qs : req Params , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var List Parts Result = data . List Parts Result | | { } ; var Part = List Parts Result . Part | | [ ] ; Part = util . is Array ( Part ) ? Part : [ Part ] ; List Parts Result . Part = Part ; var result = util . clone ( List Parts Result ) ; util . extend ( result , { status Code : data . status Code , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipart Abort ( params , callback ) { var req Params = { } ; req Params [ 'upload Id ' ] = params [ 'Upload Id ' ] ; submit Request . call ( this , { Action : 'name /cos :Abort Multipart Upload ' , method : 'DELETE ' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , qs : req Params , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { status Code : data . status Code , headers : data . headers , } ) ; } ) ; } 
function get Auth ( params ) { var self = this ; return util . get Auth ( { Secret Id : params . Secret Id | | this . options . Secret Id | | ' ' , Secret Key : params . Secret Key | | this . options . Secret Key | | ' ' , Method : params . Method , Key : params . Key , Query : params . Query , Headers : params . Headers , Expires : params . Expires , Use Raw Key : self . options . Use Raw Key , System Clock Offset : self . options . System Clock Offset , } ) ; } 
function get Object Url ( params , callback ) { var self = this ; var url = get Url ( { Force Path Style : self . options . Force Path Style , protocol : params . Protocol | | self . options . Protocol , domain : self . options . Domain , bucket : params . Bucket , region : params . Region , object : params . Key , } ) ; if ( params . Sign ! = = undefined & & ! params . Sign ) { callback ( null , { Url : url } ) ; return url ; } var Auth Data = get Authorization Async . call ( this , { Action : ( ( params . Method | | ' ' ) . to Upper Case ( ) = = = 'PUT ' ? 'name /cos :Put Object ' : 'name /cos :Get Object ' ) , Bucket : params . Bucket | | ' ' , Region : params . Region | | ' ' , Method : params . Method | | 'get ' , Key : params . Key , Expires : params . Expires , } , function ( err , Auth Data ) { if ( ! callback ) return ; if ( err ) { callback ( err ) ; return ; } var sign Url = url ; sign Url + = ' ? ' + ( Auth Data . Authorization . index Of ( 'q -signature ' ) > - 1 ? Auth Data . Authorization : 'sign = ' + encode URIComponent ( Auth Data . Authorization ) ) ; Auth Data . XCos Security Token & & ( sign Url + = ' &x -cos -security -token = ' + Auth Data . XCos Security Token ) ; Auth Data . Client IP & & ( sign Url + = ' &client IP = ' + Auth Data . Client IP ) ; Auth Data . Client UA & & ( sign Url + = ' &client UA = ' + Auth Data . Client UA ) ; Auth Data . Token & & ( sign Url + = ' &token = ' + Auth Data . Token ) ; set Timeout ( function ( ) { callback ( null , { Url : sign Url } ) ; } ) ; } ) ; if ( Auth Data ) { return url + ' ? ' + Auth Data . Authorization + ( Auth Data . XCos Security Token ? ' &x -cos -security -token = ' + Auth Data . XCos Security Token : ' ' ) ; } else { return url ; } } 
function decode Acl ( Access Control Policy ) { var result = { Grant Full Control : [ ] , Grant Write : [ ] , Grant Read : [ ] , Grant Read Acp : [ ] , Grant Write Acp : [ ] , ACL : ' ' , } ; var Grant Map = { 'FULL _CONTROL ' : 'Grant Full Control ' , 'WRITE ' : 'Grant Write ' , 'READ ' : 'Grant Read ' , 'READ _ACP ' : 'Grant Read Acp ' , 'WRITE _ACP ' : 'Grant Write Acp ' , } ; var Grant = Access Control Policy . Access Control List . Grant ; if ( Grant ) { Grant = util . is Array ( Grant ) ? Grant : [ Grant ] ; } var Public Acl = { READ : 0 , WRITE : 0 , FULL _CONTROL : 0 } ; Grant . length & & util . each ( Grant , function ( item ) { if ( item . Grantee . ID = = = 'qcs : :cam : :anyone :anyone ' | | item . Grantee . URI = = = 'http : / /cam .qcloud .com /groups /global /All Users ' ) { Public Acl [ item . Permission ] = 1 ; } else if ( item . Grantee . ID ! = = Access Control Policy . Owner . ID ) { result [ Grant Map [ item . Permission ] ] . push ( 'id = " ' + item . Grantee . ID + ' " ' ) ; } } ) ; if ( Public Acl . FULL _CONTROL | | ( Public Acl . WRITE & & Public Acl . READ ) ) { result . ACL = 'public -read -write ' ; } else if ( Public Acl . READ ) { result . ACL = 'public -read ' ; } else { result . ACL = 'private ' ; } util . each ( Grant Map , function ( item ) { result [ item ] = uniq Grant ( result [ item ] . join ( ' , ' ) ) ; } ) ; return result ; } 
function uniq Grant ( str ) { var arr = str . split ( ' , ' ) ; var exist = { } ; var i , item ; for ( i = 0 ; i < arr . length ; ) { item = arr [ i ] . trim ( ) ; if ( exist [ item ] ) { arr . splice ( i , 1 ) ; } else { exist [ item ] = true ; arr [ i ] = item ; i + + ; } } return arr . join ( ' , ' ) ; } 
function get Url ( params ) { var long Bucket = params . bucket ; var short Bucket = long Bucket . substr ( 0 , long Bucket . last Index Of ( ' - ' ) ) ; var app Id = long Bucket . substr ( long Bucket . last Index Of ( ' - ' ) + 1 ) ; var domain = params . domain ; var region = params . region ; var object = params . object ; var protocol = params . protocol | | ( util . is Browser & & location . protocol = = = 'http : ' ? 'http : ' : 'https : ' ) ; if ( ! domain ) { if ( [ 'cn -south ' , 'cn -south - 2 ' , 'cn -north ' , 'cn -east ' , 'cn -southwest ' , 'sg ' ] . index Of ( region ) > - 1 ) { domain = ' {Region } .myqcloud .com ' ; } else { domain = 'cos . {Region } .myqcloud .com ' ; } if ( ! params . Force Path Style ) { domain = ' {Bucket } . ' + domain ; } } domain = domain . replace ( / \ { \ {App Id \ } \ } / ig , app Id ) . replace ( / \ { \ {Bucket \ } \ } / ig , short Bucket ) . replace ( / \ { \ {Region \ } \ } / ig , region ) . replace ( / \ { \ { . * ? \ } \ } / ig , ' ' ) ; domain = domain . replace ( / \ {App Id \ } / ig , app Id ) . replace ( / \ {Bucket Name \ } / ig , short Bucket ) . replace ( / \ {Bucket \ } / ig , long Bucket ) . replace ( / \ {Region \ } / ig , region ) . replace ( / \ { . * ? \ } / ig , ' ' ) ; if ( ! / ^ [a -z A -Z ] + : \ / \ / / . test ( domain ) ) { domain = protocol + ' / / ' + domain ; } 
function submit Request ( params , callback ) { var self = this ; 
function _submit Request ( params , callback ) { var self = this ; var Task Id = params . Task Id ; if ( Task Id & & ! self . _is Running Task ( Task Id ) ) return ; var bucket = params . Bucket ; var region = params . Region ; var object = params . Key ; var method = params . method | | 'GET ' ; var url = params . url ; var body = params . body ; var json = params . json ; var raw Body = params . raw Body ; 
function ( data ) { if ( data . Task Id = = = Task Id ) { sender & & sender . abort & & sender . abort ( ) ; self . off ( 'inner -kill -task ' , kill Task ) ; } } 
function ( opt ) { var pathname = opt . Pathname | | ' / ' ; var expires = opt . Expires ; var Short Bucket Name = ' ' ; var App Id = ' ' ; var match = opt . Bucket . match ( / ^ ( . + ) - ( \d + ) $ / ) ; if ( match ) { Short Bucket Name = match [ 1 ] ; App Id = match [ 2 ] ; } var random = parse Int ( Math . random ( ) * Math . pow ( 2 , 3 2 ) ) ; var now = parse Int ( Date . now ( ) / 1 0 0 0 ) ; var e = now + ( expires = = = undefined ? 9 0 0 : ( expires * 1 | | 0 ) ) ; 
function ( opt ) { if ( ! opt . Secret Id ) return console . error ( 'missing param Secret Id ' ) ; if ( ! opt . Secret Key ) return console . error ( 'missing param Secret Key ' ) ; if ( opt . Version = = = ' 4 . 0 ' ) { return Cos Auth V 4 ( opt ) ; } opt = opt | | { } ; var Secret Id = opt . Secret Id ; var Secret Key = opt . Secret Key ; var method = ( opt . Method | | 'get ' ) . to Lower Case ( ) ; var query = opt . Query | | { } ; var headers = opt . Headers | | { } ; var pathname = opt . Pathname | | ' / ' ; var expires = opt . Expires ; var get Object Keys = function ( obj ) { var list = [ ] ; for ( var key in obj ) { if ( obj . has Own Property ( key ) ) { list . push ( key ) ; } } return list . sort ( function ( a , b ) { a = a . to Lower Case ( ) ; b = b . to Lower Case ( ) ; return a = = = b ? 0 : ( a > b ? 1 : - 1 ) ; } ) ; } ; var obj 2str = function ( obj ) { var i , key , val ; var list = [ ] ; var key List = get Object Keys ( obj ) ; for ( i = 0 ; i < key List . length ; i + + ) { key = key List [ i ] ; val = ( obj [ key ] = = = undefined | | obj [ key ] = = = null ) ? ' ' : ( ' ' + obj [ key ] ) ; key = key . to Lower Case ( ) ; key = cam Safe Url Encode ( key ) ; val = cam Safe Url Encode ( val ) | | ' ' ; list . push ( key + ' = ' + val ) } return list . join ( ' & ' ) ; } ; 
function ( opt ) { opt = opt | | { } ; var Secret Id = opt . Secret Id ; var Secret Key = opt . Secret Key ; var method = ( opt . method | | opt . Method | | 'get ' ) . to Lower Case ( ) ; var query Params = clone ( opt . Query | | opt . params | | { } ) ; var headers = clone ( opt . Headers | | opt . headers | | { } ) ; var Key = opt . Key | | ' ' ; var pathname ; if ( opt . Use Raw Key ) { pathname = opt . Pathname | | opt . pathname | | ' / ' + Key ; } else { pathname = opt . Pathname | | opt . pathname | | Key ; pathname . index Of ( ' / ' ) ! = = 0 & & ( pathname = ' / ' + pathname ) ; } if ( ! Secret Id ) return console . error ( 'missing param Secret Id ' ) ; if ( ! Secret Key ) return console . error ( 'missing param Secret Key ' ) ; var get Object Keys = function ( obj ) { var list = [ ] ; for ( var key in obj ) { if ( obj . has Own Property ( key ) ) { list . push ( key ) ; } } return list . sort ( function ( a , b ) { a = a . to Lower Case ( ) ; b = b . to Lower Case ( ) ; return a = = = b ? 0 : ( a > b ? 1 : - 1 ) ; } ) ; } ; var obj 2str = function ( obj ) { var i , key , val ; var list = [ ] ; var key List = get Object Keys ( obj ) ; for ( i = 0 ; i < key List . length ; i + + ) { key = key List [ i ] ; val = ( obj [ key ] = = = undefined | | obj [ key ] = = = null ) ? ' ' : ( ' ' + obj [ key ] ) ; key = key . to Lower Case ( ) ; key = cam Safe Url Encode ( key ) ; val = cam Safe Url Encode ( val ) | | ' ' ; list . push ( key + ' = ' + val ) } return list . join ( ' & ' ) ; } ; 
function ( obj ) { var ret Obj = { } ; for ( var key in obj ) { if ( obj . has Own Property ( key ) & & obj [ key ] ! = = undefined & & obj [ key ] ! = = null ) { ret Obj [ key ] = obj [ key ] ; } } return ret Obj ; } 
function ( blob , callback ) { read As Binary String ( blob , function ( content ) { var hash = md 5 ( content , true ) ; callback ( null , hash ) ; } ) ; } 
function ( result ) { if ( result & & result . headers ) { result . headers [ 'x -cos -version -id ' ] & & ( result . Version Id = result . headers [ 'x -cos -version -id ' ] ) ; result . headers [ 'x -cos -delete -marker ' ] & & ( result . Delete Marker = result . headers [ 'x -cos -delete -marker ' ] ) ; } return result ; } 
function get Upload Id And Part List ( params , callback ) { var Task Id = params . Task Id ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Storage Class = params . Storage Class ; var self = this ; 
function ( Part List , callback ) { var Part Count = Part List . length ; 
function ( index ) { if ( index < Part Count ) { var Part = Part List [ index ] ; get Chunk ETag ( Part . Part Number , function ( err , chunk ) { if ( chunk & & chunk . ETag = = = Part . ETag & & chunk . Size = = = Part . Size ) { next ( index + 1 ) ; } else { callback ( null , false ) ; } } ) ; } else { callback ( null , true ) ; } } 
function whole Multipart List ( params , callback ) { var self = this ; var Upload List = [ ] ; var send Params = { Bucket : params . Bucket , Region : params . Region , Prefix : params . Key } ; var next = function ( ) { self . multipart List ( send Params , function ( err , data ) { if ( err ) return callback ( err ) ; Upload List . push . apply ( Upload List , data . Upload | | [ ] ) ; if ( data . Is Truncated = = = 'true ' ) { 
function whole Multipart List Part ( params , callback ) { var self = this ; var Part List = [ ] ; var send Params = { Bucket : params . Bucket , Region : params . Region , Key : params . Key , Upload Id : params . Upload Id } ; var next = function ( ) { self . multipart List Part ( send Params , function ( err , data ) { if ( err ) return callback ( err ) ; Part List . push . apply ( Part List , data . Part | | [ ] ) ; if ( data . Is Truncated = = = 'true ' ) { 
function upload Slice List ( params , cb ) { var self = this ; var Task Id = params . Task Id ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Upload Data = params . Upload Data ; var File Size = params . File Size ; var Slice Size = params . Slice Size ; var Chunk Parallel = Math . min ( params . Async Limit | | self . options . Chunk Parallel Limit | | 1 , 2 5 6 ) ; var Body = params . Body ; var Slice Count = Math . ceil ( File Size / Slice Size ) ; var Finish Size = 0 ; var Server Side Encryption = params . Server Side Encryption ; var need Upload Slices = util . filter ( Upload Data . Part List , function ( Slice Item ) { if ( Slice Item [ 'Uploaded ' ] ) { Finish Size + = Slice Item [ 'Part Number ' ] > = Slice Count ? ( File Size % Slice Size | | Slice Size ) : Slice Size ; } return ! Slice Item [ 'Uploaded ' ] ; } ) ; var on Progress = params . on Progress ; Async . each Limit ( need Upload Slices , Chunk Parallel , function ( Slice Item , async Callback ) { if ( ! self . _is Running Task ( Task Id ) ) return ; var Part Number = Slice Item [ 'Part Number ' ] ; var current Size = Math . min ( File Size , Slice Item [ 'Part Number ' ] * Slice Size ) - ( Slice Item [ 'Part Number ' ] - 1 ) * Slice Size ; var pre Add Size = 0 ; upload Slice Item . call ( self , { Task Id : Task Id , Bucket : Bucket , Region : Region , Key : Key , Slice Size : Slice Size , File Size : File Size , Part Number : Part Number , Server Side Encryption : Server Side Encryption , Body : Body , Upload Data : Upload Data , on Progress : function ( data ) { Finish Size + = data . loaded - pre Add Size ; pre Add Size = data . loaded ; on Progress ( { loaded : Finish Size , total : File Size } ) ; } , } , function ( err , data ) { if ( ! self . _is Running Task ( Task Id ) ) return ; if ( util . is Browser & & ! err & & ! data . ETag ) { err = 'get ETag error , please add "ETag " to CORS Expose Header setting . ' ; } if ( err ) { Finish Size - = pre Add Size ; } else { Finish Size + = current Size - pre Add Size ; Slice Item . ETag = data . ETag ; } async Callback ( err | | null , data ) ; } ) ; } , function ( err ) { if ( ! self . _is Running Task ( Task Id ) ) return ; if ( err ) return cb ( err ) ; cb ( null , { Upload Id : Upload Data . Upload Id , Slice List : Upload Data . Part List } ) ; } ) ; } 
function upload Slice Complete ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Upload Id = params . Upload Id ; var Slice List = params . Slice List ; var self = this ; var Chunk Retry Times = this . options . Chunk Retry Times + 1 ; var Parts = Slice List . map ( function ( item ) { return { Part Number : item . Part Number , ETag : item . ETag } ; } ) ; 
function abort Upload Task ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Upload Id = params . Upload Id ; var Level = params . Level | | 'task ' ; var Async Limit = params . Async Limit ; var self = this ; var ep = new Event Proxy ( ) ; ep . on ( 'error ' , function ( err Data ) { return callback ( err Data ) ; } ) ; 
function abort Upload Task Array ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Abort Array = params . Abort Array ; var Async Limit = params . Async Limit | | 1 ; var self = this ; var index = 0 ; var result List = new Array ( Abort Array . length ) ; Async . each Limit ( Abort Array , Async Limit , function ( Abort Item , callback ) { var each Index = index ; if ( Key & & Key ! = = Abort Item . Key ) { result List [ each Index ] = { error : { Key Not Match : true } } ; callback ( null ) ; return ; } var Upload Id = Abort Item . Upload Id | | Abort Item . Upload ID ; self . multipart Abort ( { Bucket : Bucket , Region : Region , Key : Abort Item . Key , Headers : params . Headers , Upload Id : Upload Id } , function ( err , data ) { var task = { Bucket : Bucket , Region : Region , Key : Abort Item . Key , Upload Id : Upload Id } ; result List [ each Index ] = { error : err , task : task } ; callback ( null ) ; } ) ; index + + ; } , function ( err ) { if ( err ) { return callback ( err ) ; } var success List = [ ] ; var error List = [ ] ; for ( var i = 0 , len = result List . length ; i < len ; i + + ) { var item = result List [ i ] ; if ( item [ 'task ' ] ) { if ( item [ 'error ' ] ) { error List . push ( item [ 'task ' ] ) ; } else { success List . push ( item [ 'task ' ] ) ; } } } return callback ( null , { success List : success List , error List : error List } ) ; } ) ; } 
function slice Copy File ( params , callback ) { var ep = new Event Proxy ( ) ; var self = this ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Copy Source = params . Copy Source ; var m = Copy Source . match ( / ^ ( [ ^ . ] + - \d + ) \ .cos (v 6 ) ? \ . ( [ ^ . ] + ) \ . [ ^ / ] + \ / ( . + ) $ / ) ; if ( ! m ) { callback ( { error : 'Copy Source format error ' } ) ; return ; } var Source Bucket = m [ 1 ] ; var Source Region = m [ 3 ] ; var Source Key = decode URIComponent ( m [ 4 ] ) ; var Copy Slice Size = params . Slice Size = = = undefined ? self . options . Copy Slice Size : params . Slice Size ; Copy Slice Size = Math . max ( 0 , Math . min ( Copy Slice Size , 5 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 ) ) ; var Chunk Size = params . Chunk Size | | this . options . Copy Chunk Size ; var Chunk Parallel = this . options . Copy Chunk Parallel Limit ; var Finish Size = 0 ; var File Size ; var on Progress ; 
function copy Slice Item ( params , callback ) { var Task Id = params . Task Id ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var Copy Source = params . Copy Source ; var Upload Id = params . Upload Id ; var Part Number = params . Part Number * 1 ; var Copy Source Range = params . Copy Source Range ; var Chunk Retry Times = this . options . Chunk Retry Times + 1 ; var self = this ; Async . retry ( Chunk Retry Times , function ( try Callback ) { self . upload Part Copy ( { Task Id : Task Id , Bucket : Bucket , Region : Region , Key : Key , Copy Source : Copy Source , Upload Id : Upload Id , Part Number : Part Number , Copy Source Range : Copy Source Range , on Progress : params . on Progress , } , function ( err , data ) { try Callback ( err | | null , data ) ; } ) } , function ( err , data ) { return callback ( err , data ) ; } ) ; } 
function stringify ( content ) { if ( typeof content = = = 'string ' & & stringified Regexp . test ( content ) ) { return content ; } return JSON . stringify ( content , null , 2 ) ; } 
function get Module Chunk ( module , modules ) { let chunks ; if ( webpack Version . IS _ 4 ) { chunks = Array . from ( module . chunks Iterable ) ; } else if ( parse Int ( webpack Version ( ) , 1 0 ) > = 3 ) { chunks = module . map Chunks ( ) ; } else { chunks = module . chunks ; } 
function get Loader Options ( loader Path , rule ) { let multi Rule Prop ; if ( is Webpack 1 ) { multi Rule Prop = 'loaders ' ; } else if ( rule . one Of ) { multi Rule Prop = 'one Of ' ; } else { multi Rule Prop = 'use ' ; } const multi Rule = typeof rule = = = 'object ' & & Array . is Array ( rule [ multi Rule Prop ] ) ? rule [ multi Rule Prop ] : null ; let options ; if ( multi Rule ) { const rules = [ ] . concat ( . . . multi Rule . map ( r = > ( r . use | | r ) ) ) ; options = rules . map ( normalize Rule ) . find ( r = > loader Path . includes ( r . loader ) ) . options ; } else { options = normalize Rule ( rule ) . options ; } return options ; } 
function normalize Rule ( rule ) { if ( ! rule ) { throw new Error ( 'Rule should be string or object ' ) ; } let data ; if ( typeof rule = = = 'string ' ) { const parts = rule . split ( ' ? ' ) ; data = { loader : parts [ 0 ] , options : parts [ 1 ] ? parse Query ( ` $ { parts [ 1 ] } ` ) : null } ; } else { const options = is Webpack 1 ? rule . query : rule . options ; data = { loader : rule . loader , options : options | | null } ; } return data ; } 
function find Child ( info , children , handler , reverse ) { const len = children . length if ( reverse ) { for ( let i = len - 1 ; i > = 0 ; i - - ) { const item = children [ i ] 
function find Parent ( node , handle ) { let current = node while ( current ) { if ( handle ( current ) ) { return current } current = current . parent } } 
function pure ( node , with Children , after ) { var _this 2 = this ; var t = assign $ 1 ( { } , node ) ; delete t . _id ; delete t . parent ; delete t . children ; delete t . open ; delete t . active ; delete t . style ; delete t . class ; delete t . inner Style ; delete t . inner Class ; delete t . inner Back Style ; delete t . inner Back Class ; var _arr = keys $ 1 ( t ) ; for ( var _i = 0 ; _i < _arr . length ; _i + + ) { var key = _arr [ _i ] ; if ( key [ 0 ] = = = ' _ ' ) { delete t [ key ] ; } } if ( with Children & & node . children ) { t . children = node . children . slice ( ) ; t . children . for Each ( function ( v , k ) { t . children [ k ] = _this 2 . pure ( v , with Children ) ; } ) ; } if ( after ) { return after ( t , node ) | | t ; } return t ; } 
function find Child ( info , children , handler , reverse ) { var len = children . length ; if ( reverse ) { for ( var i = len - 1 ; i > = 0 ; i - - ) { var item = children [ i ] ; 
function current Tree Empty ( info ) { return ! find Child ( info , info . current Tree . root Data . children , function ( v ) { return v ; } ) ; } 
function target Node Has Children Excluding Placeholder ( info ) { return find Child ( info , info . target Node . children , function ( v ) { return v ! = = info . dplh ; } ) ; } 
function target Node Is 1st Child ( info ) { return find Child ( info , info . target Node . parent . children , function ( v ) { return v ; } ) = = = info . target Node ; } 
function target Node Is Last Child ( info ) { return find Child ( info , info . target Node . parent . children , function ( v ) { return v ; } , true ) = = = info . target Node ; } 
function at Indent Right ( info ) { return info . offset . x > info . ti Offset . x + info . current Tree . indent ; } 
function auto Move Drag Place Holder ( draggable Helper Info ) { var trees = this . store . trees ; var dh Store = draggable Helper Info . store ; 
function offset 2 ( ) { return { x : this . offset . x + this . node Inner El . offset Width , y : this . offset . y + this . node Inner El . offset Height } ; } 
function offset To View Port ( ) { var r = this . node Inner El . get Bounding Client Rect ( ) ; r . x = r . left ; r . y = r . top ; return r ; } 
function current Tree Root Second Child Excluding Dragging ( ) { var _this = this ; return this . current Tree . root Data . children . slice ( 0 , 3 ) . filter ( function ( v ) { return v ! = = _this . node ; } ) [ 1 ] ; } 
function exec ( rule Id ) { if ( ! executed Rule Cache . has Own Property ( rule Id ) ) { var r ; try { r = rules [ rule Id ] ( info ) ; } catch ( e ) { r = e ; try { if ( process . env . DEVELOPE _SELF ) { 
function append Prev ( info ) { if ( is Node Droppable ( info . target Prev ) ) { th . append To ( info . dplh , info . target Prev ) ; if ( ! info . target Prev . open ) info . store . toggle Open ( info . target Prev ) ; } else { insert Dplh After To ( info . dplh , info . target Prev , info ) ; } } 
function append Current Tree ( info ) { if ( is Node Droppable ( info . current Tree . root Data ) ) { th . append To ( info . dplh , info . current Tree . root Data ) ; } } 
function current Tree ( ) { 
function target Node ( ) { var current Tree = this . current Tree ; if ( ! current Tree ) { throw 'no current Tree ' ; } 
function strip View From Selector ( selector ) { 
async function get Pid Using Pattern ( pgrep Pattern ) { const args = [ ' -nif ' , pgrep Pattern ] ; try { const { stdout } = await exec ( 'pgrep ' , args ) ; const pid = parse Int ( stdout , 1 0 ) ; if ( is Na N ( pid ) ) { log . debug ( ` $ { args . join ( ' ' ) } $ { stdout } ` ) ; return null ; } return ` $ { pid } ` ; } catch ( err ) { log . debug ( ` $ { args . join ( ' ' ) } $ { err . code } ` ) ; return null ; } } 
async function kill App Using Pattern ( pgrep Pattern ) { for ( const signal of [ 2 , 1 5 , 9 ] ) { if ( ! await get Pid Using Pattern ( pgrep Pattern ) ) { return ; } const args = [ ` $ { signal } ` , ' -if ' , pgrep Pattern ] ; try { await exec ( 'pkill ' , args ) ; } catch ( err ) { log . debug ( ` $ { args . join ( ' ' ) } $ { err . message } ` ) ; } await B . delay ( 1 0 0 ) ; } } 
async function get PIDs Listening On Port ( port , filtering Func = null ) { const result = [ ] ; try { 
async function encode Base 6 4Or Upload ( local File , remote Path = null , upload Options = { } ) { if ( ! await fs . exists ( local File ) ) { log . error And Throw ( ` $ { local File } ` ) ; } const { size } = await fs . stat ( local File ) ; log . debug ( ` $ { util . to Readable Size String ( size ) } ` ) ; if ( _ . is Empty ( remote Path ) ) { const max Memory Limit = v 8 . get Heap Statistics ( ) . total _available _size / 2 ; if ( size > = max Memory Limit ) { log . info ( ` ` + ` $ { util . to Readable Size String ( size ) } $ { util . to Readable Size String ( max Memory Limit ) } ` + ` ` + ` ` ) ; } const content = await fs . read File ( local File ) ; return content . to String ( 'base 6 4 ' ) ; } const remote Url = url . parse ( remote Path ) ; let options = { } ; const { user , pass , method } = upload Options ; if ( remote Url . protocol . starts With ( 'http ' ) ) { options = { url : remote Url . href , method : method | | 'PUT ' , multipart : [ { body : _fs . create Read Stream ( local File ) } ] , } ; if ( user & & pass ) { options . auth = { user , pass } ; } } else if ( remote Url . protocol = = = 'ftp : ' ) { options = { host : remote Url . hostname , port : remote Url . port | | 2 1 , } ; if ( user & & pass ) { options . user = user ; options . pass = pass ; } } await net . upload File ( local File , remote Path , options ) ; return ' ' ; } 
async function remove All Session Web Socket Handlers ( server , session Id ) { if ( ! server | | ! _ . is Function ( server . get Web Socket Handlers ) ) { return ; } const active Handlers = await server . get Web Socket Handlers ( session Id ) ; for ( const pathname of _ . keys ( active Handlers ) ) { await server . remove Web Socket Handler ( pathname ) ; } } 
async function verify Application Platform ( app , is Simulator ) { log . debug ( 'Verifying application platform ' ) ; const info Plist = path . resolve ( app , 'Info .plist ' ) ; if ( ! await fs . exists ( info Plist ) ) { log . debug ( ` $ { info Plist } ` ) ; return null ; } const { CFBundle Supported Platforms } = await plist . parse Plist File ( info Plist ) ; log . debug ( ` $ { JSON . stringify ( CFBundle Supported Platforms ) } ` ) ; if ( ! _ . is Array ( CFBundle Supported Platforms ) ) { log . debug ( ` $ { info Plist } ` ) ; return null ; } const is App Supported = ( is Simulator & & CFBundle Supported Platforms . includes ( 'i Phone Simulator ' ) ) | | ( ! is Simulator & & CFBundle Supported Platforms . includes ( 'i Phone OS ' ) ) ; if ( is App Supported ) { return true ; } throw new Error ( ` $ { is Simulator ? 'Simulator ' : 'Real device ' } $ { app } ` + ` ` ) ; } 
function is Local Host ( url String ) { try { const { hostname } = url . parse ( url String ) ; return [ 'localhost ' , ' 1 2 7 . 0 . 0 . 1 ' , ' : : 1 ' , ' : :ffff : 1 2 7 . 0 . 0 . 1 ' ] . includes ( hostname ) ; } catch { log . warn ( ` $ { url String } ` ) ; } return false ; } 
function normalize Platform Version ( original Version ) { const normalized Version = util . coerce Version ( original Version , false ) ; if ( ! normalized Version ) { throw new Error ( ` $ { original Version } ` ) ; } const { major , minor } = new semver . Sem Ver ( normalized Version ) ; return ` $ { major } $ { minor } ` ; } 
async function update Project File ( agent Path , new Bundle Id ) { let project File Path = ` $ { agent Path } $ { PROJECT _FILE } ` ; try { 
async function reset Project File ( agent Path ) { let project File Path = ` $ { agent Path } $ { PROJECT _FILE } ` ; try { 
function get Additional Run Content ( platform Name , wda Remote Port ) { const runner = ` $ { is Tv OS ( platform Name ) ? ' _tv OS ' : ' ' } ` ; return { [ runner ] : { Environment Variables : { USE _PORT : wda Remote Port } } } ; } 
async function get WDAUpgrade Timestamp ( bootstrap Path ) { const carthage Root Path = path . resolve ( bootstrap Path , CARTHAGE _ROOT ) ; if ( await fs . exists ( carthage Root Path ) ) { const { mtime } = await fs . stat ( carthage Root Path ) ; return mtime . get Time ( ) ; } return null ; } 
function to Mobile Config ( cert Buffer , common Name ) { const get UUID = ( ) = > UUID . create ( ) . hex . to Upper Case ( ) ; const content Uuid = get UUID ( ) ; return { Payload Content : [ { Payload Certificate File Name : ` $ { common Name } ` , Payload Content : cert Buffer , Payload Description : 'Adds a CA root certificate ' , Payload Display Name : common Name , Payload Identifier : ` $ { content Uuid } ` , Payload Type : 'com .apple .security .root ' , Payload UUID : content Uuid , Payload Version : 1 } ] , Payload Display Name : common Name , Payload Identifier : ` $ { os . hostname ( ) . split ( ' . ' ) [ 0 ] } $ { get UUID ( ) } ` , Payload Removal Disallowed : false , Payload Type : 'Configuration ' , Payload UUID : get UUID ( ) , Payload Version : 1 } ; } 
function get Tree For XML ( src Tree ) { function get Tree ( element , element Index , parent Path ) { let cur Path = ` $ { parent Path } $ { element Index } ` ; let rect = element . rect | | { } ; let subtree = { ' @ ' : { type : ` $ { element . type } ` , enabled : parse Int ( element . is Enabled , 1 0 ) = = = 1 , visible : parse Int ( element . is Visible , 1 0 ) = = = 1 , x : rect . x , y : rect . y , width : rect . width , height : rect . height , } , ' > ' : [ ] } ; if ( element . name ! = = null ) { subtree [ ' @ ' ] . name = element . name ; } if ( element . label ! = = null ) { subtree [ ' @ ' ] . label = element . label ; } if ( element . value ! = = null ) { subtree [ ' @ ' ] . value = element . value ; } for ( let i = 0 ; i < ( element . children | | [ ] ) . length ; i + + ) { subtree [ ' > ' ] . push ( get Tree ( element . children [ i ] , i , cur Path ) ) ; } return { [ ` $ { element . type } ` ] : subtree } ; } let tree = get Tree ( src Tree , 0 , ' ' ) ; return tree ; } 
async function parse Container Path ( remote Path , container Root Supplier ) { const match = CONTAINER _PATH _PATTERN . exec ( remote Path ) ; if ( ! match ) { log . error And Throw ( ` ` + ` $ { CONTAINER _PATH _MARKER } ` + ` $ { remote Path } ` ) ; } let [ , bundle Id , relative Path ] = match ; let container Type = null ; const type Separator Pos = bundle Id . index Of ( CONTAINER _TYPE _SEPARATOR ) ; 
async function push File To Simulator ( device , remote Path , base 6 4Data ) { const buffer = Buffer . from ( base 6 4Data , 'base 6 4 ' ) ; if ( CONTAINER _PATH _PATTERN . test ( remote Path ) ) { const [ bundle Id , dst Path ] = await parse Container Path ( remote Path , async ( app Bundle , container Type ) = > await get App Container ( device . udid , app Bundle , null , container Type ) ) ; log . info ( ` $ { bundle Id } $ { remote Path } ` + ` $ { dst Path } ` ) ; if ( ! await fs . exists ( path . dirname ( dst Path ) ) ) { log . debug ( ` $ { path . dirname ( dst Path ) } ` ) ; await mkdirp ( path . dirname ( dst Path ) ) ; } await fs . write File ( dst Path , buffer ) ; return ; } const dst Folder = await temp Dir . open Dir ( ) ; const dst Path = path . resolve ( dst Folder , path . basename ( remote Path ) ) ; try { await fs . write File ( dst Path , buffer ) ; await add Media ( device . udid , dst Path ) ; } finally { await fs . rimraf ( dst Folder ) ; } } 
async function push File To Real Device ( device , remote Path , base 6 4Data ) { await verify IFuse Presence ( ) ; const mnt Root = await temp Dir . open Dir ( ) ; let is Unmount Successful = true ; try { let dst Path = path . resolve ( mnt Root , remote Path ) ; let ifuse Args = [ ' -u ' , device . udid , mnt Root ] ; if ( CONTAINER _PATH _PATTERN . test ( remote Path ) ) { const [ bundle Id , path In Container ] = await parse Container Path ( remote Path , mnt Root ) ; dst Path = path In Container ; log . info ( ` $ { bundle Id } $ { remote Path } ` + ` $ { dst Path } ` ) ; ifuse Args = [ ' -u ' , device . udid , ' - -container ' , bundle Id , mnt Root ] ; } else { verify Is Sub Path ( dst Path , mnt Root ) ; } await mount Device ( device , ifuse Args ) ; is Unmount Successful = false ; try { if ( ! await fs . exists ( path . dirname ( dst Path ) ) ) { log . debug ( ` $ { path . dirname ( dst Path ) } ` ) ; await mkdirp ( path . dirname ( dst Path ) ) ; } await fs . write File ( dst Path , Buffer . from ( base 6 4Data , 'base 6 4 ' ) ) ; } finally { await exec ( 'umount ' , [ mnt Root ] ) ; is Unmount Successful = true ; } } finally { if ( is Unmount Successful ) { await fs . rimraf ( mnt Root ) ; } else { log . warn ( ` $ { mnt Root } ` ) ; } } } 
async function pull From Simulator ( device , remote Path , is File ) { let path On Server ; if ( CONTAINER _PATH _PATTERN . test ( remote Path ) ) { const [ bundle Id , dst Path ] = await parse Container Path ( remote Path , async ( app Bundle , container Type ) = > await get App Container ( device . udid , app Bundle , null , container Type ) ) ; log . info ( ` $ { bundle Id } $ { remote Path } ` + ` $ { dst Path } ` ) ; path On Server = dst Path ; } else { const sim Root = device . get Dir ( ) ; path On Server = path . posix . join ( sim Root , remote Path ) ; verify Is Sub Path ( path On Server , sim Root ) ; log . info ( ` $ { path On Server } ` ) ; } if ( ! await fs . exists ( path On Server ) ) { log . error And Throw ( ` $ { is File ? 'file ' : 'folder ' } $ { path On Server } ` ) ; } const buffer = is File ? await fs . read File ( path On Server ) : await zip . to In Memory Zip ( path On Server ) ; return Buffer . from ( buffer ) . to String ( 'base 6 4 ' ) ; } 
async function pull From Real Device ( device , remote Path , is File ) { await verify IFuse Presence ( ) ; const mnt Root = await temp Dir . open Dir ( ) ; let is Unmount Successful = true ; try { let dst Path = path . resolve ( mnt Root , remote Path ) ; let ifuse Args = [ ' -u ' , device . udid , mnt Root ] ; if ( CONTAINER _PATH _PATTERN . test ( remote Path ) ) { const [ bundle Id , path In Container ] = await parse Container Path ( remote Path , mnt Root ) ; dst Path = path In Container ; log . info ( ` $ { bundle Id } $ { remote Path } ` + ` $ { dst Path } ` ) ; ifuse Args = [ ' -u ' , device . udid , ' - -container ' , bundle Id , mnt Root ] ; } else { verify Is Sub Path ( dst Path , mnt Root ) ; } await mount Device ( device , ifuse Args ) ; is Unmount Successful = false ; try { if ( ! await fs . exists ( dst Path ) ) { log . error And Throw ( ` $ { is File ? 'file ' : 'folder ' } $ { dst Path } ` ) ; } const buffer = is File ? await fs . read File ( dst Path ) : await zip . to In Memory Zip ( dst Path ) ; return Buffer . from ( buffer ) . to String ( 'base 6 4 ' ) ; } finally { await exec ( 'umount ' , [ mnt Root ] ) ; is Unmount Successful = true ; } } finally { if ( is Unmount Successful ) { await fs . rimraf ( mnt Root ) ; } else { log . warn ( ` $ { mnt Root } ` ) ; } } } 
async function create Sim ( caps , platform = PLATFORM _NAME _IOS ) { const appium Test Device Name = ` $ { UUID . create ( ) . to String ( ) . to Upper Case ( ) } $ { caps . device Name } ` ; const udid = await create Device ( appium Test Device Name , caps . device Name , caps . platform Version , { platform } ) ; return await get Simulator ( udid ) ; } 
async function get Existing Sim ( opts ) { const devices = await get Devices ( opts . platform Version ) ; const appium Test Device Name = ` $ { opts . device Name } ` ; let appium Test Device ; for ( const device of _ . values ( devices ) ) { if ( device . name = = = opts . device Name ) { return await get Simulator ( device . udid ) ; } if ( device . name = = = appium Test Device Name ) { appium Test Device = device ; } } if ( appium Test Device ) { log . warn ( ` $ { opts . device Name } $ { appium Test Device . name } $ { appium Test Device . udid } ` ) ; return await get Simulator ( appium Test Device . udid ) ; } return null ; } 
function ( ) { const el = this . el ; this . velocity Ctrl = null ; this . velocity = new THREE . Vector 3 ( ) ; this . heading = new THREE . Quaternion ( ) ; 
function ( ) { const data = this . data ; if ( data . enabled ) { for ( let i = 0 , l = data . controls . length ; i < l ; i + + ) { const control = this . el . components [ data . controls [ i ] + COMPONENT _SUFFIX ] ; if ( control & & control . is Velocity Active ( ) ) { this . velocity Ctrl = control ; return ; } } this . velocity Ctrl = null ; } } 
function parse Physics Model ( xml ) { var data = { name : xml . get Attribute ( 'name ' ) | | ' ' , rigid Bodies : { } } ; for ( var i = 0 ; i < xml . child Nodes . length ; i + + ) { var child = xml . child Nodes [ i ] ; if ( child . node Type ! = = 1 ) continue ; switch ( child . node Name ) { case 'rigid _body ' : data . rigid Bodies [ child . get Attribute ( 'name ' ) ] = { } ; parse Physics Rigid Body ( child , data . rigid Bodies [ child . get Attribute ( 'name ' ) ] ) ; break ; } } library . physics Models [ xml . get Attribute ( 'id ' ) ] = data ; } 
function prepare Nodes ( xml ) { var elements = xml . get Elements By Tag Name ( 'node ' ) ; 
function parse Visual Scene ( xml ) { var data = { name : xml . get Attribute ( 'name ' ) , children : [ ] } ; prepare Nodes ( xml ) ; var elements = get Elements By Tag Name ( xml , 'node ' ) ; for ( var i = 0 ; i < elements . length ; i + + ) { data . children . push ( parse Node ( elements [ i ] ) ) ; } library . visual Scenes [ xml . get Attribute ( 'id ' ) ] = data ; } 
function ( ) { const data = this . data ; let object Els ; 
function intersect ( el ) { let radius , mesh , distance , extent ; if ( ! el . is Entity ) { return ; } mesh = el . get Object 3D ( 'mesh ' ) ; if ( ! mesh ) { return ; } box . set From Object ( mesh ) . get Size ( size ) ; extent = Math . max ( size . x , size . y , size . z ) / 2 ; radius = Math . sqrt ( 2 * extent * extent ) ; box . get Center ( mesh Position ) ; if ( ! radius ) { return ; } distance = position . distance To ( mesh Position ) ; if ( distance < radius + collider Radius ) { collisions . push ( el ) ; distance Map . set ( el , distance ) ; } } 
function ( ) { this . system = this . el . scene El . systems . physics ; this . system . add Component ( this ) ; const el = this . el , data = this . data , position = ( new CANNON . Vec 3 ( ) ) . copy ( el . object 3D . get World Position ( new THREE . Vector 3 ( ) ) ) ; this . body = new CANNON . Body ( { material : this . system . get Material ( 'static Material ' ) , position : position , mass : data . mass , linear Damping : data . linear Damping , fixed Rotation : true } ) ; this . body . add Shape ( new CANNON . Sphere ( data . radius ) , new CANNON . Vec 3 ( 0 , data . radius , 0 ) ) ; this . body . el = this . el ; this . el . body = this . body ; this . system . add Body ( this . body ) ; if ( el . has Attribute ( 'wasd -controls ' ) ) { console . warn ( ' [kinematic -body ] Not compatible with wasd -controls , use movement -controls . ' ) ; } } 
function ( t , dt ) { if ( ! dt ) return ; const el = this . el ; const data = this . data const body = this . body ; if ( ! data . enable Jumps ) body . velocity . set ( 0 , 0 , 0 ) ; body . position . copy ( el . get Attribute ( 'position ' ) ) ; } 
function ( ground Body , ground Normal ) { let ray , hit Normal , v From = this . body . position , v To = this . body . position . clone ( ) ; ray = new CANNON . Ray ( v From , v To ) ; ray . _update Direction ( ) ; 
function ( ) { const scene = this . el . scene El ; this . prev Time = window . performance . now ( ) ; 
function ( ) { if ( ! this . data . enabled | | ! this . is Connected ( ) ) return false ; const dpad = this . get Dpad ( ) , joystick 0 = this . get Joystick ( 0 ) , input X = dpad . x | | joystick 0 . x , input Y = dpad . y | | joystick 0 . y ; return Math . abs ( input X ) > JOYSTICK _EPS | | Math . abs ( input Y ) > JOYSTICK _EPS ; } 
function ( ) { if ( ! this . data . enabled | | ! this . is Connected ( ) ) return false ; const joystick 1 = this . get Joystick ( 1 ) ; return Math . abs ( joystick 1 . x ) > JOYSTICK _EPS | | Math . abs ( joystick 1 . y ) > JOYSTICK _EPS ; } 
function ( index ) { const gamepad = this . get Gamepad ( ) ; switch ( index ) { case 0 : return new THREE . Vector 2 ( gamepad . axes [ 0 ] , gamepad . axes [ 1 ] ) ; case 1 : return new THREE . Vector 2 ( gamepad . axes [ 2 ] , gamepad . axes [ 3 ] ) ; default : throw new Error ( 'Unexpected joystick index " %d " . ' , index ) ; } } 
function ( ) { const gamepad = this . get Gamepad ( ) ; if ( ! gamepad . buttons [ Gamepad Button . DPAD _RIGHT ] ) { return new THREE . Vector 2 ( ) ; } return new THREE . Vector 2 ( ( gamepad . buttons [ Gamepad Button . DPAD _RIGHT ] . pressed ? 1 : 0 ) + ( gamepad . buttons [ Gamepad Button . DPAD _LEFT ] . pressed ? - 1 : 0 ) , ( gamepad . buttons [ Gamepad Button . DPAD _UP ] . pressed ? - 1 : 0 ) + ( gamepad . buttons [ Gamepad Button . DPAD _DOWN ] . pressed ? 1 : 0 ) ) ; } 
function ( ) { const el = this . el , data = this . data ; let material = el . components . material ; const geometry = new THREE . Plane Geometry ( data . width , data . depth , data . density , data . density ) ; geometry . merge Vertices ( ) ; this . waves = [ ] ; for ( let v , i = 0 , l = geometry . vertices . length ; i < l ; i + + ) { v = geometry . vertices [ i ] ; this . waves . push ( { z : v . z , ang : Math . random ( ) * Math . PI * 2 , amp : data . amplitude + Math . random ( ) * data . amplitude Variance , speed : ( data . speed + Math . random ( ) * data . speed Variance ) / 1 0 0 0 
function URLSearch Params Polyfill ( search ) { search = search | | " " ; 
function LDAPResult ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional Number ( options . status ) ; assert . optional String ( options . matched DN ) ; assert . optional String ( options . error Message ) ; assert . optional Array Of String ( options . referrals ) ; LDAPMessage . call ( this , options ) ; this . status = options . status | | 0 ; 
function Bind Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _BIND ; LDAPResult . call ( this , options ) ; } 
function Change ( options ) { if ( options ) { assert . object ( options ) ; assert . optional String ( options . operation ) ; } else { options = { } ; } this . _modification = false ; this . operation = options . operation | | options . type | | 'add ' ; this . modification = options . modification | | { } ; } 
function Delete Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _DELETE ; LDAPResult . call ( this , options ) ; } 
function Control ( options ) { assert . optional Object ( options ) ; options = options | | { } ; assert . optional String ( options . type ) ; assert . optional Bool ( options . criticality ) ; if ( options . value ) { assert . buffer ( options . value ) ; } this . type = options . type | | ' ' ; this . criticality = options . critical | | options . criticality | | false ; this . value = options . value | | null ; } 
function Unbind Request ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REQ _UNBIND ; LDAPMessage . call ( this , options ) ; } 
function Search Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _SEARCH ; LDAPResult . call ( this , options ) ; this . attributes = options . attributes ? options . attributes . slice ( ) : [ ] ; this . not Attributes = [ ] ; this . sent Entries = 0 ; } 
function Modify Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _MODIFY ; LDAPResult . call ( this , options ) ; } 
function Request Queue ( opts ) { if ( ! opts | | typeof ( opts ) ! = = 'object ' ) { opts = { } ; } this . size = ( opts . size > 0 ) ? opts . size : Infinity ; this . timeout = ( opts . timeout > 0 ) ? opts . timeout : 0 ; this . _queue = [ ] ; this . _timer = null ; this . _frozen = false ; } 
function Message Tracker ( opts ) { assert . object ( opts ) ; assert . string ( opts . id ) ; assert . object ( opts . parser ) ; this . id = opts . id ; this . _msgid = 0 ; this . _messages = { } ; this . _abandoned = { } ; this . parser = opts . parser ; var self = this ; this . _ _define Getter _ _ ( 'pending ' , function ( ) { return Object . keys ( self . _messages ) ; } ) ; } 
function ge Window ( ref , comp ) { var max = ref + ( MAX _MSGID / 2 ) ; var min = ref ; if ( max > = MAX _MSGID ) { 
function Client ( options ) { assert . ok ( options ) ; Event Emitter . call ( this , options ) ; var self = this ; var _url ; if ( options . url ) _url = url . parse ( options . url ) ; this . host = _url ? _url . hostname : undefined ; this . port = _url ? _url . port : false ; this . secure = _url ? _url . secure : false ; this . url = _url ; this . tls Options = options . tls Options ; this . socket Path = options . socket Path | | false ; this . log = options . log . child ( { clazz : 'Client ' } , true ) ; this . timeout = parse Int ( ( options . timeout | | 0 ) , 1 0 ) ; this . connect Timeout = parse Int ( ( options . connect Timeout | | 0 ) , 1 0 ) ; this . idle Timeout = parse Int ( ( options . idle Timeout | | 0 ) , 1 0 ) ; if ( options . reconnect ) { 
function connect Socket ( cb ) { cb = once ( cb ) ; function on Result ( err , res ) { if ( err ) { if ( self . connect Timer ) { clear Timeout ( self . connect Timer ) ; self . connect Timer = null ; } self . emit ( 'connect Error ' , err ) ; } cb ( err , res ) ; } function on Connect ( ) { if ( self . connect Timer ) { clear Timeout ( self . connect Timer ) ; self . connect Timer = null ; } socket . remove All Listeners ( 'error ' ) . remove All Listeners ( 'connect ' ) . remove All Listeners ( 'secure Connect ' ) ; tracker . id = next Client Id ( ) + ' _ _ ' + tracker . id ; self . log = self . log . child ( { ldap _id : tracker . id } , true ) ; 
function init Socket ( ) { tracker = new Message Tracker ( { id : self . url ? self . url . href : self . socket Path , parser : new Parser ( { log : log } ) } ) ; 
function setup Client ( cb ) { cb = once ( cb ) ; 
function post Setup ( ) { socket . remove All Listeners ( 'error ' ) . remove All Listeners ( 'close ' ) . remove All Listeners ( 'end ' ) . remove All Listeners ( 'timeout ' ) ; 
function Search Entry ( options ) { options = options | | { } ; assert . object ( options ) ; lassert . optional String DN ( options . object Name ) ; options . protocol Op = Protocol . LDAP _REP _SEARCH _ENTRY ; LDAPMessage . call ( this , options ) ; this . object Name = options . object Name | | null ; this . set Attributes ( options . attributes | | [ ] ) ; } 
function Attribute ( options ) { if ( options ) { if ( typeof ( options ) ! = = 'object ' ) throw new Type Error ( 'options must be an object ' ) ; if ( options . type & & typeof ( options . type ) ! = = 'string ' ) throw new Type Error ( 'options .type must be a string ' ) ; } else { options = { } ; } this . type = options . type | | ' ' ; this . _vals = [ ] ; if ( options . vals ! = = undefined & & options . vals ! = = null ) this . vals = options . vals ; } 
function Search Request ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REQ _SEARCH ; LDAPMessage . call ( this , options ) ; if ( options . base Object ! = = undefined ) { this . base Object = options . base Object ; } else { this . base Object = dn . parse ( ' ' ) ; } this . scope = options . scope | | 'base ' ; this . deref Aliases = options . deref Aliases | | Protocol . NEVER _DEREF _ALIASES ; this . size Limit = options . size Limit | | 0 ; this . time Limit = options . time Limit | | 0 ; this . types Only = options . types Only | | false ; this . filter = options . filter | | null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; } 
function merge Function Args ( argv , start , end ) { assert . ok ( argv ) ; if ( ! start ) start = 0 ; if ( ! end ) end = argv . length ; var handlers = [ ] ; for ( var i = start ; i < end ; i + + ) { if ( argv [ i ] instanceof Array ) { var arr = argv [ i ] ; for ( var j = 0 ; j < arr . length ; j + + ) { if ( ! ( arr [ j ] instanceof Function ) ) { throw new Type Error ( 'Invalid argument type : ' + typeof ( arr [ j ] ) ) ; } handlers . push ( arr [ j ] ) ; } } else if ( argv [ i ] instanceof Function ) { handlers . push ( argv [ i ] ) ; } else { throw new Type Error ( 'Invalid argument type : ' + typeof ( argv [ i ] ) ) ; } } return handlers ; } 
function Server ( options ) { if ( options ) { if ( typeof ( options ) ! = = 'object ' ) throw new Type Error ( 'options (object ) required ' ) ; if ( typeof ( options . log ) ! = = 'object ' ) throw new Type Error ( 'options .log must be an object ' ) ; if ( options . certificate | | options . key ) { if ( ! ( options . certificate & & options . key ) | | ( typeof ( options . certificate ) ! = = 'string ' & & ! Buffer . is Buffer ( options . certificate ) ) | | ( typeof ( options . key ) ! = = 'string ' & & ! Buffer . is Buffer ( options . key ) ) ) { throw new Type Error ( 'options .certificate and options .key ' + ' (string or buffer ) are both required for TLS ' ) ; } } } else { options = { } ; } var self = this ; Event Emitter . call ( this , options ) ; this . _chain = [ ] ; this . log = options . log ; this . strict DN = ( options . strict DN ! = = undefined ) ? options . strict DN : true ; var log = this . log ; function setup Connection ( c ) { assert . ok ( c ) ; if ( c . type = = = 'unix ' ) { c . remote Address = self . server . path ; c . remote Port = c . fd ; } else if ( c . socket ) { 
function _assert ( arg , type , name ) { name = name | | type ; throw new assert . Assertion Error ( { message : util . format ( ' %s ( %s ) required ' , name , type ) , actual : typeof ( arg ) , expected : type , operator : ' = = = ' , stack Start Function : _assert . caller } ) ; } 
function Add Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _ADD ; LDAPResult . call ( this , options ) ; } 
function Parser ( options ) { assert . object ( options ) ; assert . object ( options . log ) ; Event Emitter . call ( this ) ; this . buffer = null ; this . log = options . log ; } 
function Modify Request ( options ) { options = options | | { } ; assert . object ( options ) ; lassert . optional String DN ( options . object ) ; lassert . optional Array Of Attribute ( options . attributes ) ; options . protocol Op = Protocol . LDAP _REQ _MODIFY ; LDAPMessage . call ( this , options ) ; this . object = options . object | | null ; this . changes = options . changes ? options . changes . slice ( 0 ) : [ ] ; } 
function Server Side Sorting Request Control ( options ) { assert . optional Object ( options ) ; options = options | | { } ; options . type = Server Side Sorting Request Control . OID ; if ( options . value ) { if ( Buffer . is Buffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( Array . is Array ( options . value ) ) { assert . array Of Object ( options . value , 'options .value must be Objects ' ) ; for ( var i = 0 ; i < options . value . length ; i + + ) { if ( ! options . value [ i ] . has Own Property ( 'attribute Type ' ) ) { throw new Error ( 'Missing required key : attribute Type ' ) ; } } this . _value = options . value ; } else if ( typeof ( options . value ) = = = 'object ' ) { if ( ! options . value . has Own Property ( 'attribute Type ' ) ) { throw new Error ( 'Missing required key : attribute Type ' ) ; } this . _value = [ options . value ] ; } else { throw new Type Error ( 'options .value must be a Buffer , Array or Object ' ) ; } options . value = null ; } Control . call ( this , options ) ; } 
function LDAPError ( message , dn , caller ) { if ( Error . capture Stack Trace ) Error . capture Stack Trace ( this , caller | | LDAPError ) ; this . lde _message = message ; this . lde _dn = dn ; } 
function Unbind Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = 0 ; LDAPMessage . call ( this , options ) ; } 
function Extended Request ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional String ( options . request Name ) ; if ( options . request Value & & ! ( Buffer . is Buffer ( options . request Value ) | | typeof ( options . request Value ) = = = 'string ' ) ) { throw new Type Error ( 'options .request Value must be a buffer or a string ' ) ; } options . protocol Op = Protocol . LDAP _REQ _EXTENSION ; LDAPMessage . call ( this , options ) ; this . request Name = options . request Name | | ' ' ; this . request Value = options . request Value ; } 
function _parse ( ber ) { assert . ok ( ber ) ; function parse Set ( f ) { var end = ber . offset + ber . length ; while ( ber . offset < end ) f . add Filter ( _parse ( ber ) ) ; } var f ; var type = ber . read Sequence ( ) ; switch ( type ) { case Protocol . FILTER _AND : f = new And Filter ( ) ; parse Set ( f ) ; break ; case Protocol . FILTER _APPROX : f = new Approximate Filter ( ) ; f . parse ( ber ) ; break ; case Protocol . FILTER _EQUALITY : f = new Equality Filter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER _EXT : f = new Extensible Filter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER _GE : f = new Greater Than Equals Filter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER _LE : f = new Less Than Equals Filter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER _NOT : var _f = _parse ( ber ) ; f = new Not Filter ( { filter : _f } ) ; break ; case Protocol . FILTER _OR : f = new Or Filter ( ) ; parse Set ( f ) ; break ; case Protocol . FILTER _PRESENT : f = new Presence Filter ( ) ; f . parse ( ber ) ; break ; case Protocol . FILTER _SUBSTRINGS : f = new Substring Filter ( ) ; f . parse ( ber ) ; break ; default : throw new Error ( 'Invalid search filter type : 0x ' + type . to String ( 1 6 ) ) ; } assert . ok ( f ) ; return f ; } 
function Search Reference ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _SEARCH _REF ; LDAPMessage . call ( this , options ) ; this . uris = options . uris | | [ ] ; } 
function Extended Response ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional String ( options . response Name ) ; assert . optional String ( options . responsevalue ) ; this . response Name = options . response Name | | undefined ; this . response Value = options . response Value | | undefined ; options . protocol Op = Protocol . LDAP _REP _EXTENSION ; LDAPResult . call ( this , options ) ; } 
function Compare Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _COMPARE ; LDAPResult . call ( this , options ) ; } 
function Modify DNRequest ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional Bool ( options . delete Old Rdn ) ; lassert . optional String DN ( options . entry ) ; lassert . optional DN ( options . new Rdn ) ; lassert . optional DN ( options . new Superior ) ; options . protocol Op = Protocol . LDAP _REQ _MODRDN ; LDAPMessage . call ( this , options ) ; this . entry = options . entry | | null ; this . new Rdn = options . new Rdn | | null ; this . delete Old Rdn = options . delete Old Rdn | | true ; this . new Superior = options . new Superior | | null ; } 
function Abandon Request ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional Number ( options . abandon ID ) ; options . protocol Op = Protocol . LDAP _REQ _ABANDON ; LDAPMessage . call ( this , options ) ; this . abandon ID = options . abandon ID | | 0 ; } 
function authorize ( req , res , next ) { var is Search = ( req instanceof ldap . Search Request ) ; if ( ! req . connection . ldap . bind DN . equals ( 'cn =root ' ) & & ! is Search ) return next ( new ldap . Insufficient Access Rights Error ( ) ) ; return next ( ) ; } 
function invalid DN ( name ) { var e = new Error ( ) ; e . name = 'Invalid Distinguished Name Error ' ; e . message = name ; return e ; } 
function RDN ( obj ) { var self = this ; this . attrs = { } ; if ( obj ) { Object . keys ( obj ) . for Each ( function ( k ) { self . set ( k , obj [ k ] ) ; } ) ; } } 
function parse ( name ) { if ( typeof ( name ) ! = = 'string ' ) throw new Type Error ( 'name (string ) required ' ) ; var cur = 0 ; var len = name . length ; function parse Rdn ( ) { var rdn = new RDN ( ) ; var order = 0 ; rdn . sp Lead = trim ( ) ; while ( cur < len ) { var opts = { order : order } ; var attr = parse Attr Type ( ) ; trim ( ) ; if ( cur > = len | | name [ cur + + ] ! = = ' = ' ) throw invalid DN ( name ) ; trim ( ) ; 
function Search Pager ( opts ) { assert . object ( opts ) ; assert . func ( opts . callback ) ; assert . number ( opts . page Size ) ; Event Emitter . call ( this , { } ) ; this . callback = opts . callback ; this . controls = opts . controls ; this . page Size = opts . page Size ; this . page Pause = opts . page Pause ; this . controls . for Each ( function ( control ) { if ( control . type = = = Paged Control . OID ) { 
function Modify DNResponse ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REP _MODRDN ; LDAPResult . call ( this , options ) ; } 
function Delete Request ( options ) { options = options | | { } ; assert . object ( options ) ; lassert . optional String DN ( options . entry ) ; options . protocol Op = Protocol . LDAP _REQ _DELETE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry | | null ; } 
function Add Request ( options ) { options = options | | { } ; assert . object ( options ) ; lassert . optional String DN ( options . entry ) ; lassert . optional Array Of Attribute ( options . attributes ) ; options . protocol Op = Protocol . LDAP _REQ _ADD ; LDAPMessage . call ( this , options ) ; this . entry = options . entry | | null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; } 
function xor ( ) { var b = false ; for ( var i = 0 ; i < arguments . length ; i + + ) { if ( arguments [ i ] & & ! b ) { b = true ; } else if ( arguments [ i ] & & b ) { return false ; } } return b ; } 
function Compare Request ( options ) { options = options | | { } ; assert . object ( options ) ; assert . optional String ( options . attribute ) ; assert . optional String ( options . value ) ; lassert . optional String DN ( options . entry ) ; options . protocol Op = Protocol . LDAP _REQ _COMPARE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry | | null ; this . attribute = options . attribute | | ' ' ; this . value = options . value | | ' ' ; } 
function Bind Request ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = Protocol . LDAP _REQ _BIND ; LDAPMessage . call ( this , options ) ; this . version = options . version | | 0x 0 3 ; this . name = options . name | | null ; this . authentication = options . authentication | | LDAP _BIND _SIMPLE ; this . credentials = options . credentials | | ' ' ; } 
function Abandon Response ( options ) { options = options | | { } ; assert . object ( options ) ; options . protocol Op = 0 ; LDAPMessage . call ( this , options ) ; } 
function Paged Results Control ( options ) { assert . optional Object ( options ) ; options = options | | { } ; options . type = Paged Results Control . OID ; if ( options . value ) { if ( Buffer . is Buffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( typeof ( options . value ) = = = 'object ' ) { this . _value = options . value ; } else { throw new Type Error ( 'options .value must be a Buffer or Object ' ) ; } options . value = null ; } Control . call ( this , options ) ; } 
function is Filter ( filter ) { if ( ! filter | | typeof ( filter ) ! = = 'object ' ) { return false ; } 
function LDAPMessage ( options ) { assert . object ( options ) ; this . message ID = options . message ID | | 0 ; this . protocol Op = options . protocol Op | | undefined ; this . controls = options . controls ? options . controls . slice ( 0 ) : [ ] ; this . log = options . log ; } 
function ( graph , start , end , options ) { graph . clean Dirty ( ) ; options = options | | { } ; var heuristic = options . heuristic | | astar . heuristics . manhattan ; var closest = options . closest | | false ; var open Heap = get Heap ( ) ; var closest Node = start ; 
function Graph ( grid In , options ) { options = options | | { } ; this . nodes = [ ] ; this . diagonal = ! ! options . diagonal ; this . grid = [ ] ; for ( var x = 0 ; x < grid In . length ; x + + ) { this . grid [ x ] = [ ] ; for ( var y = 0 , row = grid In [ x ] ; y < row . length ; y + + ) { var node = new Grid Node ( x , y , row [ y ] ) ; this . grid [ x ] [ y ] = node ; this . nodes . push ( node ) ; } } this . init ( ) ; } 
function ( path , i ) { if ( i > = path . length ) { 
function ( model , schema ) { debug ( 'applying virtuals ' ) ; for ( const i in schema . virtuals ) { schema . virtuals [ i ] . apply Virtuals ( model ) ; } } 
function ( model , schema ) { debug ( 'applying methods ' ) ; for ( const i in schema . methods ) { model . prototype [ i ] = schema . methods [ i ] ; } } 
function ( model , schema ) { debug ( 'applying statics ' ) ; for ( const i in schema . statics ) { model [ i ] = schema . statics [ i ] . bind ( model ) ; } } 
function Operations ( ) { this . if Not Exists Set = { } ; this . SET = { } ; this . ADD = { } ; this . REMOVE = { } ; this . LISTAPPEND = { } ; this . add If Not Exists Set = function ( name , item ) { this . if Not Exists Set [ name ] = item ; } ; this . add Set = function ( name , item ) { if ( schema . hash Key . name ! = = name & & ( schema . range Key | | { } ) . name ! = = name ) { this . SET [ name ] = item ; } } ; this . add List Append = function ( name , item ) { if ( schema . hash Key . name ! = = name & & ( schema . range Key | | { } ) . name ! = = name ) { this . LISTAPPEND [ name ] = item ; } } ; this . add Add = function ( name , item ) { if ( schema . hash Key . name ! = = name & & ( schema . range Key | | { } ) . name ! = = name ) { this . ADD [ name ] = item ; } } ; this . add Remove = function ( name , item ) { if ( schema . hash Key . name ! = = name & & ( schema . range Key | | { } ) . name ! = = name ) { this . REMOVE [ name ] = item ; } } ; this . get Update Expression = function ( get Update Req ) { let attr Count = 0 ; let update Expression = ' ' ; let attr Name ; let val Name ; let name ; let item ; const set Expressions = [ ] ; for ( name in this . if Not Exists Set ) { item = this . if Not Exists Set [ name ] ; attr Name = ` $ { attr Count } ` ; val Name = ` $ { attr Count } ` ; get Update Req . Expression Attribute Names [ attr Name ] = name ; get Update Req . Expression Attribute Values [ val Name ] = item ; set Expressions . push ( ` $ { attr Name } $ { attr Name } $ { val Name } ` ) ; attr Count + = 1 ; } for ( name in this . SET ) { item = this . SET [ name ] ; attr Name = ` $ { attr Count } ` ; val Name = ` $ { attr Count } ` ; get Update Req . Expression Attribute Names [ attr Name ] = name ; get Update Req . Expression Attribute Values [ val Name ] = item ; set Expressions . push ( ` $ { attr Name } $ { val Name } ` ) ; attr Count + = 1 ; } for ( name in this . LISTAPPEND ) { item = this . LISTAPPEND [ name ] ; attr Name = ` $ { attr Count } ` ; val Name = ` $ { attr Count } ` ; get Update Req . Expression Attribute Names [ attr Name ] = name ; get Update Req . Expression Attribute Values [ val Name ] = item ; set Expressions . push ( ` $ { attr Name } $ { attr Name } $ { val Name } ` ) ; attr Count + = 1 ; } if ( set Expressions . length > 0 ) { update Expression + = ` $ { set Expressions . join ( ' , ' ) } ` ; } const add Expressions = [ ] ; for ( name in this . ADD ) { item = this . ADD [ name ] ; attr Name = ` $ { attr Count } ` ; val Name = ` $ { attr Count } ` ; get Update Req . Expression Attribute Names [ attr Name ] = name ; get Update Req . Expression Attribute Values [ val Name ] = item ; add Expressions . push ( ` $ { attr Name } $ { val Name } ` ) ; attr Count + = 1 ; } if ( add Expressions . length > 0 ) { update Expression + = ` $ { add Expressions . join ( ' , ' ) } ` ; } const remove Expressions = [ ] ; for ( name in this . REMOVE ) { item = this . REMOVE [ name ] ; attr Name = ` $ { attr Count } ` ; get Update Req . Expression Attribute Names [ attr Name ] = name ; remove Expressions . push ( attr Name ) ; attr Count + = 1 ; } if ( remove Expressions . length > 0 ) { update Expression + = ` $ { remove Expressions . join ( ' , ' ) } ` ; } get Update Req . Update Expression = update Expression ; } ; } 
function create Attr Def From Dynamo ( dynamo Attribute ) { let dynamo Type ; const attr Def = { 'type ' : module . exports . lookup Type ( dynamo Attribute ) } ; if ( attr Def . type = = = Object ) { attr Def . type = 'map ' ; for ( dynamo Type in dynamo Attribute ) { attr Def . map = { } ; for ( const sub Attr Name in dynamo Attribute [ dynamo Type ] ) { attr Def . map [ sub Attr Name ] = create Attr Def From Dynamo ( dynamo Attribute [ dynamo Type ] [ sub Attr Name ] ) ; } } } else if ( attr Def . type = = = Array ) { attr Def . type = 'list ' ; for ( dynamo Type in dynamo Attribute ) { attr Def . list = dynamo Attribute [ dynamo Type ] . map ( create Attr Def From Dynamo ) ; } } return attr Def ; } 
function parse Anchor Option ( anchor ) { let horizontal = anchor . match ( / left |center |right / gi ) | | [ ] ; horizontal = horizontal . length = = = 0 ? 'left ' : horizontal [ 0 ] ; let vertical = anchor . match ( / baseline |top |bottom |middle / gi ) | | [ ] ; vertical = vertical . length = = = 0 ? 'baseline ' : vertical [ 0 ] ; return { horizontal , vertical } ; } 
function for Each ( array , callback ) { if ( array ) { for ( var i = 0 , len = array . length ; i < len ; i + + ) { var result = callback ( array [ i ] , i ) ; if ( result ) { return result ; } } } return undefined ; } 
function binary Search ( array , value ) { var low = 0 ; var high = array . length - 1 ; while ( low < = high ) { var middle = low + ( ( high - low ) > > 1 ) ; var mid Value = array [ middle ] ; if ( mid Value = = = value ) { return middle ; } else if ( mid Value > value ) { high = middle - 1 ; } else { low = middle + 1 ; } } return ~ low ; } 
function array To Map ( array , make Key ) { var result = { } ; for Each ( array , function ( value ) { result [ make Key ( value ) ] = value ; } ) ; return result ; } 
function get Root Length ( path ) { if ( path . char Code At ( 0 ) = = = 4 7 ) { if ( path . char Code At ( 1 ) ! = = 4 7 ) return 1 ; var p 1 = path . index Of ( " / " , 2 ) ; if ( p 1 < 0 ) return 2 ; var p 2 = path . index Of ( " / " , p 1 + 1 ) ; if ( p 2 < 0 ) return p 1 + 1 ; return p 2 + 1 ; } if ( path . char Code At ( 1 ) = = = 5 8 ) { if ( path . char Code At ( 2 ) = = = 4 7 ) return 3 ; return 2 ; } 
function create Watched File Set ( interval , chunk Size ) { if ( interval = = = void 0 ) { interval = 2 5 0 0 ; } if ( chunk Size = = = void 0 ) { chunk Size = 3 0 ; } var watched Files = [ ] ; var next File To Check = 0 ; var watch Timer ; function get Modified Time ( file Name ) { return _fs . stat Sync ( file Name ) . mtime ; } function poll ( checked Index ) { var watched File = watched Files [ checked Index ] ; if ( ! watched File ) { return ; } _fs . stat ( watched File . file Name , function ( err , stats ) { if ( err ) { watched File . callback ( watched File . file Name ) ; } else if ( watched File . mtime . get Time ( ) ! = = stats . mtime . get Time ( ) ) { watched File . mtime = get Modified Time ( watched File . file Name ) ; watched File . callback ( watched File . file Name , watched File . mtime . get Time ( ) = = = 0 ) ; } } ) ; } 
function start Watch Timer ( ) { watch Timer = set Interval ( function ( ) { var count = 0 ; var next To Check = next File To Check ; var first Check = - 1 ; while ( ( count < chunk Size ) & & ( next To Check ! = = first Check ) ) { poll ( next To Check ) ; if ( first Check < 0 ) { first Check = next To Check ; } next To Check + + ; if ( next To Check = = = watched Files . length ) { next To Check = 0 ; } count + + ; } next File To Check = next To Check ; } , interval ) ; } 
function is Unicode Identifier Start ( code , language Version ) { return language Version > = 1 ? lookup In Unicode Map ( code , unicode ES 5Identifier Start ) : lookup In Unicode Map ( code , unicode ES 3Identifier Start ) ; } 
function compute Line Starts ( text ) { var result = new Array ( ) ; var pos = 0 ; var line Start = 0 ; while ( pos < text . length ) { var ch = text . char Code At ( pos + + ) ; switch ( ch ) { case 1 3 : if ( text . char Code At ( pos ) = = = 1 0 ) { pos + + ; } case 1 0 : result . push ( line Start ) ; line Start = pos ; break ; default : if ( ch > 1 2 7 & & is Line Break ( ch ) ) { result . push ( line Start ) ; line Start = pos ; } break ; } } result . push ( line Start ) ; return result ; } 
function compute Position Of Line And Character ( line Starts , line , character ) { ts . Debug . assert ( line > = 0 & & line < line Starts . length ) ; return line Starts [ line ] + character ; } 
function compute Line And Character Of Position ( line Starts , position ) { var line Number = ts . binary Search ( line Starts , position ) ; if ( line Number < 0 ) { 
function create Scanner ( language Version , skip Trivia , language Variant , text , on Error , start , length ) { if ( language Variant = = = void 0 ) { language Variant = 0 ; } * Scans the given number of hexadecimal digits in the text , * returning - 1 if the given number is unavailable . * / function scan Exact Number Of Hex Digits ( count ) { return scan Hex Digits ( count , false ) ; } function scan Minimum Number Of Hex Digits ( count ) { return scan Hex Digits ( count , true ) ; } function scan Hex Digits ( min Count , scan As Many As Possible ) { var digits = 0 ; var value = 0 ; while ( digits < min Count | | scan As Many As Possible ) { var ch = text . char Code At ( pos ) ; if ( ch > = 4 8 & & ch < = 5 7 ) { value = value * 1 6 + ch - 4 8 ; } else if ( ch > = 6 5 & & ch < = 7 0 ) { value = value * 1 6 + ch - 6 5 + 1 0 ; } else if ( ch > = 9 7 & & ch < = 1 0 2 ) { value = value * 1 6 + ch - 9 7 + 1 0 ; } else { break ; } pos + + ; digits + + ; } if ( digits < min Count ) { value = - 1 ; } return value ; } function scan String ( ) { var quote = text . char Code At ( pos + + ) ; var result = " " ; var start = pos ; while ( true ) { if ( pos > = end ) { result + = text . substring ( start , pos ) ; token Is Unterminated = true ; error ( ts . Diagnostics . Unterminated _string _literal ) ; break ; } var ch = text . char Code At ( pos ) ; if ( ch = = = quote ) { result + = text . substring ( start , pos ) ; pos + + ; break ; } if ( ch = = = 9 2 ) { result + = text . substring ( start , pos ) ; result + = scan Escape Sequence ( ) ; start = pos ; continue ; } if ( is Line Break ( ch ) ) { result + = text . substring ( start , pos ) ; token Is Unterminated = true ; error ( ts . Diagnostics . Unterminated _string _literal ) ; break ; } pos + + ; } return result ; } function scan Template And Set Token Value ( ) { var started With Backtick = text . char Code At ( pos ) = = = 9 6 ; pos + + ; var start = pos ; var contents = " " ; var resulting Token ; while ( true ) { if ( pos > = end ) { contents + = text . substring ( start , pos ) ; token Is Unterminated = true ; error ( ts . Diagnostics . Unterminated _template _literal ) ; resulting Token = started With Backtick ? 1 1 : 1 4 ; break ; } var curr Char = text . char Code At ( pos ) ; * Unconditionally back up and scan a template expression portion . * / function re Scan Template Token ( ) { ts . Debug . assert ( token = = = 1 6 , " 're Scan Template Token ' should only be called on a ' } ' " ) ; pos = token Pos ; return token = scan Template And Set Token Value ( ) ; } function re Scan Jsx Token ( ) { pos = token Pos = start Pos ; return token = scan Jsx Token ( ) ; } function scan Jsx Token ( ) { start Pos = token Pos = pos ; if ( pos > = end ) { return token = 1 ; } var char = text . char Code At ( pos ) ; if ( char = = = 6 0 ) { if ( text . char Code At ( pos + 1 ) = = = 4 7 ) { pos + = 2 ; return token = 2 6 ; } pos + + ; return token = 2 5 ; } if ( char = = = 1 2 3 ) { pos + + ; return token = 1 5 ; } while ( pos < end ) { pos + + ; char = text . char Code At ( pos ) ; if ( ( char = = = 1 2 3 ) | | ( char = = = 6 0 ) ) { break ; } } return token = 2 3 6 ; } 
function scan Template And Set Token Value ( ) { var started With Backtick = text . char Code At ( pos ) = = = 9 6 ; pos + + ; var start = pos ; var contents = " " ; var resulting Token ; while ( true ) { if ( pos > = end ) { contents + = text . substring ( start , pos ) ; token Is Unterminated = true ; error ( ts . Diagnostics . Unterminated _template _literal ) ; resulting Token = started With Backtick ? 1 1 : 1 4 ; break ; } var curr Char = text . char Code At ( pos ) ; 
function utf 1 6Encode As String ( code Point ) { ts . Debug . assert ( 0x 0 < = code Point & & code Point < = 0x 1 0FFFF ) ; if ( code Point < = 6 5 5 3 5 ) { return String . from Char Code ( code Point ) ; } var code Unit 1 = Math . floor ( ( code Point - 6 5 5 3 6 ) / 1 0 2 4 ) + 0x D 8 0 0 ; var code Unit 2 = ( ( code Point - 6 5 5 3 6 ) % 1 0 2 4 ) + 0x DC 0 0 ; return String . from Char Code ( code Unit 1 , code Unit 2 ) ; } 
function peek Unicode Escape ( ) { if ( pos + 5 < end & & text . char Code At ( pos + 1 ) = = = 1 1 7 ) { var start _ 1 = pos ; pos + = 2 ; var value = scan Exact Number Of Hex Digits ( 4 ) ; pos = start _ 1 ; return value ; } return - 1 ; } 
function scan Jsx Identifier ( ) { if ( token Is Identifier Or Keyword ( token ) ) { var first Char Position = pos ; while ( pos < end ) { var ch = text . char Code At ( pos ) ; if ( ch = = = 4 5 | | ( ( first Char Position = = = pos ) ? is Identifier Start ( ch , language Version ) : is Identifier Part ( ch , language Version ) ) ) { pos + + ; } else { break ; } } token Value + = text . substr ( first Char Position , pos - first Char Position ) ; } return token ; } 
function get Declaration Name ( node ) { if ( node . name ) { if ( node . kind = = = 2 1 8 & & node . name . kind = = = 9 ) { return " \ " " + node . name . text + " \ " " ; } if ( node . name . kind = = = 1 3 6 ) { var name Expression = node . name . expression ; ts . Debug . assert ( ts . is Well Known Symbol Syntactically ( name Expression ) ) ; return ts . get Property Name For Known Symbol Name ( name Expression . name . text ) ; } return node . name . text ; } switch ( node . kind ) { case 1 4 4 : return " _ _constructor " ; case 1 5 2 : case 1 4 7 : return " _ _call " ; case 1 5 3 : case 1 4 8 : return " _ _new " ; case 1 4 9 : return " _ _index " ; case 2 2 8 : return " _ _export " ; case 2 2 7 : return node . is Export Equals ? "export = " : "default " ; case 2 1 3 : case 2 1 4 : return node . flags & 1 0 2 4 ? "default " : undefined ; } } 
function bind Children ( node ) { 
function node Pos To String ( node ) { var file = get Source File Of Node ( node ) ; var loc = ts . get Line And Character Of Position ( file , node . pos ) ; return file . file Name + " ( " + ( loc . line + 1 ) + " , " + ( loc . character + 1 ) + " ) " ; } 
function node Is Missing ( node ) { if ( ! node ) { return true ; } return node . pos = = = node . end & & node . pos > = 0 & & node . kind ! = = 1 ; } 
function escape Identifier ( identifier ) { return identifier . length > = 2 & & identifier . char Code At ( 0 ) = = = 9 5 & & identifier . char Code At ( 1 ) = = = 9 5 ? " _ " + identifier : identifier ; } 
function unescape Identifier ( identifier ) { return identifier . length > = 3 & & identifier . char Code At ( 0 ) = = = 9 5 & & identifier . char Code At ( 1 ) = = = 9 5 & & identifier . char Code At ( 2 ) = = = 9 5 ? identifier . substr ( 1 ) : identifier ; } 
function get Enclosing Block Scope Container ( node ) { var current = node . parent ; while ( current ) { if ( is Function Like ( current ) ) { return current ; } switch ( current . kind ) { case 2 4 8 : case 2 2 0 : case 2 4 4 : case 2 1 8 : case 1 9 9 : case 2 0 0 : case 2 0 1 : return current ; case 1 9 2 : 
function get Combined Node Flags ( node ) { node = walk Up Binding Elements And Patterns ( node ) ; var flags = node . flags ; if ( node . kind = = = 2 1 1 ) { node = node . parent ; } if ( node & & node . kind = = = 2 1 2 ) { flags | = node . flags ; node = node . parent ; } if ( node & & node . kind = = = 1 9 3 ) { flags | = node . flags ; } return flags ; } 
function for Each Return Statement ( body , visitor ) { return traverse ( body ) ; function traverse ( node ) { switch ( node . kind ) { case 2 0 4 : return visitor ( node ) ; case 2 2 0 : case 1 9 2 : case 1 9 6 : case 1 9 7 : case 1 9 8 : case 1 9 9 : case 2 0 0 : case 2 0 1 : case 2 0 5 : case 2 0 6 : case 2 4 1 : case 2 4 2 : case 2 0 7 : case 2 0 9 : case 2 4 4 : return ts . for Each Child ( node , traverse ) ; } } } 
function is Declaration Name ( name ) { if ( name . kind ! = = 6 9 & & name . kind ! = = 9 & & name . kind ! = = 8 ) { return false ; } var parent = name . parent ; if ( parent . kind = = = 2 2 6 | | parent . kind = = = 2 3 0 ) { if ( parent . property Name ) { return true ; } } if ( is Declaration ( parent ) ) { return parent . name = = = name ; } return false ; } 
function is Identifier Name ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 1 4 1 : case 1 4 0 : case 1 4 3 : case 1 4 2 : case 1 4 5 : case 1 4 6 : case 2 4 7 : case 2 4 5 : case 1 6 6 : 
function is Alias Symbol Declaration ( node ) { return node . kind = = = 2 2 1 | | node . kind = = = 2 2 3 & & ! ! node . name | | node . kind = = = 2 2 4 | | node . kind = = = 2 2 6 | | node . kind = = = 2 3 0 | | node . kind = = = 2 2 7 & & node . expression . kind = = = 6 9 ; } 
function has Dynamic Name ( declaration ) { return declaration . name & & declaration . name . kind = = = 1 3 6 & & ! is Well Known Symbol Syntactically ( declaration . name . expression ) ; } 
function escape String ( s ) { s = escaped Chars Reg Exp . test ( s ) ? s . replace ( escaped Chars Reg Exp , get Replacement ) : s ; return s ; function get Replacement ( c ) { return escaped Chars Map [ c ] | | get 1 6Bit Unicode Escape Sequence ( c . char Code At ( 0 ) ) ; } } 
function get Expanded Char Codes ( input ) { var output = [ ] ; var length = input . length ; for ( var i = 0 ; i < length ; i + + ) { var char Code = input . char Code At ( i ) ; 
function text Span Contains Text Span ( span , other ) { return other . start > = span . start & & text Span End ( other ) < = text Span End ( span ) ; } 
function for Each Child ( node , cb Node , cb Node Array ) { if ( ! node ) { return ; } 
function update Source File ( source File , new Text , text Change Range , aggressive Checks ) { return Incremental Parser . update Source File ( source File , new Text , text Change Range , aggressive Checks ) ; } 
function parse Isolated JSDoc Comment ( content , start , length ) { return Parser . JSDoc Parser . parse Isolated JSDoc Comment ( content , start , length ) ; } 
function create Identifier ( is Identifier , diagnostic Message ) { identifier Count + + ; if ( is Identifier ) { var node = create Node ( 6 9 ) ; 
function is List Terminator ( kind ) { if ( token = = = 1 ) { 
function parse Entity Name ( allow Reserved Words , diagnostic Message ) { var entity = parse Identifier ( diagnostic Message ) ; while ( parse Optional ( 2 1 ) ) { var node = create Node ( 1 3 5 , entity . pos ) ; node . left = entity ; node . right = parse Right Side Of Dot ( allow Reserved Words ) ; entity = finish Node ( node ) ; } return entity ; } 
function parse Type Reference Or Type Predicate ( ) { var type Name = parse Entity Name ( false , ts . Diagnostics . Type _expected ) ; if ( type Name . kind = = = 6 9 & & token = = = 1 2 4 & & ! scanner . has Preceding Line Break ( ) ) { next Token ( ) ; var node _ 1 = create Node ( 1 5 0 , type Name . pos ) ; node _ 1 . parameter Name = type Name ; node _ 1 . type = parse Type ( ) ; return finish Node ( node _ 1 ) ; } var node = create Node ( 1 5 1 , type Name . pos ) ; node . type Name = type Name ; if ( ! scanner . has Preceding Line Break ( ) & & token = = = 2 5 ) { node . type Arguments = parse Bracketed List ( 1 8 , parse Type , 2 5 , 2 7 ) ; } return finish Node ( node ) ; } 
function parse Block ( ignore Missing Open Brace , diagnostic Message ) { var node = create Node ( 1 9 2 ) ; if ( parse Expected ( 1 5 , diagnostic Message ) | | ignore Missing Open Brace ) { node . statements = parse List ( 1 , parse Statement ) ; parse Expected ( 1 6 ) ; } else { node . statements = create Missing List ( ) ; } return finish Node ( node ) ; } 
function parse Try Statement ( ) { var node = create Node ( 2 0 9 ) ; parse Expected ( 1 0 0 ) ; node . try Block = parse Block ( false ) ; node . catch Clause = token = = = 7 2 ? parse Catch Clause ( ) : undefined ; 
function parse Array Binding Element ( ) { if ( token = = = 2 4 ) { return create Node ( 1 8 7 ) ; } var node = create Node ( 1 6 3 ) ; node . dot Dot Dot Token = parse Optional Token ( 2 2 ) ; node . name = parse Identifier Or Pattern ( ) ; node . initializer = parse Binding Element Initializer ( false ) ; return finish Node ( node ) ; } 
function parse JSDoc Type Expression ( start , length ) { scanner . set Text ( source Text , start , length ) ; 
function find Highest List Element That Starts At Position ( position ) { 
function resolve Name ( location , name , meaning , name Not Found Message , name Arg ) { var result ; var last Location ; var property With Invalid Initializer ; var error Location = location ; var grandparent ; loop : while ( location ) { 
function is Same Scope Descendent Of ( initial , parent , stop At ) { if ( ! parent ) { return false ; } for ( var current = initial ; current & & current ! = = stop At & & ! ts . is Function Like ( current ) ; current = current . parent ) { if ( current = = = parent ) { return true ; } } return false ; } 
function combine Value And Type Symbols ( value Symbol , type Symbol ) { if ( value Symbol . flags & ( 7 9 3 0 5 6 | 1 5 3 6 ) ) { return value Symbol ; } var result = create Symbol ( value Symbol . flags | type Symbol . flags , value Symbol . name ) ; result . declarations = ts . concatenate ( value Symbol . declarations , type Symbol . declarations ) ; result . parent = value Symbol . parent | | type Symbol . parent ; if ( value Symbol . value Declaration ) result . value Declaration = value Symbol . value Declaration ; if ( type Symbol . members ) result . members = type Symbol . members ; if ( value Symbol . exports ) result . exports = value Symbol . exports ; return result ; } 
function mark Alias Symbol As Referenced ( symbol ) { var links = get Symbol Links ( symbol ) ; if ( ! links . referenced ) { links . referenced = true ; var node = get Declaration Of Alias Symbol ( symbol ) ; if ( node . kind = = = 2 2 7 ) { 
function get Symbol Of Part Of Right Hand Side Of Import Equals ( entity Name , import Declaration ) { if ( ! import Declaration ) { import Declaration = ts . get Ancestor ( entity Name , 2 2 1 ) ; ts . Debug . assert ( import Declaration ! = = undefined ) ; } 
function resolve Entity Name ( name , meaning , ignore Errors ) { if ( ts . node Is Missing ( name ) ) { return undefined ; } var symbol ; if ( name . kind = = = 6 9 ) { var message = meaning = = = 1 5 3 6 ? ts . Diagnostics . Cannot _find _namespace _ 0 : ts . Diagnostics . Cannot _find _name _ 0 ; symbol = resolve Name ( name , name . text , meaning , ignore Errors ? undefined : message , name ) ; if ( ! symbol ) { return undefined ; } } else if ( name . kind = = = 1 3 5 | | name . kind = = = 1 6 6 ) { var left = name . kind = = = 1 3 5 ? name . left : name . expression ; var right = name . kind = = = 1 3 5 ? name . right : name . name ; var namespace = resolve Entity Name ( left , 1 5 3 6 , ignore Errors ) ; if ( ! namespace | | namespace = = = unknown Symbol | | ts . node Is Missing ( right ) ) { return undefined ; } symbol = get Symbol ( get Exports Of Symbol ( namespace ) , right . text , meaning ) ; if ( ! symbol ) { if ( ! ignore Errors ) { error ( right , ts . Diagnostics . Module _ 0 _has _no _exported _member _ 1 , get Fully Qualified Name ( namespace ) , ts . declaration Name To String ( right ) ) ; } return undefined ; } } else { ts . Debug . fail ( "Unknown entity name kind . " ) ; } ts . Debug . assert ( ( symbol . flags & 1 6 7 7 7 2 1 6 ) = = = 0 , "Should never get an instantiated symbol here . " ) ; return symbol . flags & meaning ? symbol : resolve Alias ( symbol ) ; } 
function resolve ESModule Symbol ( module Symbol , module Reference Expression ) { var symbol = resolve External Module Symbol ( module Symbol ) ; if ( symbol & & ! ( symbol . flags & ( 1 5 3 6 | 3 ) ) ) { error ( module Reference Expression , ts . Diagnostics . Module _ 0 _resolves _to _a _non _module _entity _and _cannot _be _imported _using _this _construct , symbol To String ( module Symbol ) ) ; symbol = undefined ; } return symbol ; } 
function is Reserved Member Name ( name ) { return name . char Code At ( 0 ) = = = 9 5 & & name . char Code At ( 1 ) = = = 9 5 & & name . char Code At ( 2 ) ! = = 9 5 & & name . char Code At ( 2 ) ! = = 6 4 ; } 
function is Symbol Used In Export Assignment ( symbol ) { if ( export Assignment Symbol = = = symbol ) { return true ; } if ( export Assignment Symbol & & ! ! ( export Assignment Symbol . flags & 8 3 8 8 6 0 8 ) ) { 
function get Type Of Property Of Type ( type , name ) { var prop = get Property Of Type ( type , name ) ; return prop ? get Type Of Symbol ( prop ) : undefined ; } 
function get Type For Binding Element Parent ( node ) { var symbol = get Symbol Of Node ( node ) ; return symbol & & get Symbol Links ( symbol ) . type | | get Type For Variable Like Declaration ( node ) ; } 
function get Type For Binding Element ( declaration ) { var pattern = declaration . parent ; var parent Type = get Type For Binding Element Parent ( pattern . parent ) ; 
function get Type For Variable Like Declaration ( declaration ) { 
function get Type From Binding Element ( element , include Pattern In Type ) { if ( element . initializer ) { return get Widened Type ( check Expression Cached ( element . initializer ) ) ; } if ( ts . is Binding Pattern ( element . name ) ) { return get Type From Binding Pattern ( element . name , include Pattern In Type ) ; } return any Type ; } 
function get Type From Object Binding Pattern ( pattern , include Pattern In Type ) { var members = { } ; ts . for Each ( pattern . elements , function ( e ) { var flags = 4 | 6 7 1 0 8 8 6 4 | ( e . initializer ? 5 3 6 8 7 0 9 1 2 : 0 ) ; var name = e . property Name | | e . name ; var symbol = create Symbol ( flags , name . text ) ; symbol . type = get Type From Binding Element ( e , include Pattern In Type ) ; symbol . binding Element = e ; members [ symbol . name ] = symbol ; } ) ; var result = create Anonymous Type ( undefined , members , empty Array , empty Array , undefined , undefined ) ; if ( include Pattern In Type ) { result . pattern = pattern ; } return result ; } 
function get Type From Binding Pattern ( pattern , include Pattern In Type ) { return pattern . kind = = = 1 6 1 ? get Type From Object Binding Pattern ( pattern , include Pattern In Type ) : get Type From Array Binding Pattern ( pattern , include Pattern In Type ) ; } 
function get Widened Type For Variable Like Declaration ( declaration , report Errors ) { var type = get Type For Variable Like Declaration ( declaration ) ; if ( type ) { if ( report Errors ) { report Errors From Widening ( declaration , type ) ; } 
function get Local Type Parameters Of Class Or Interface Or Type Alias ( symbol ) { var result ; for ( var _i = 0 , _a = symbol . declarations ; _i < _a . length ; _i + + ) { var node = _a [ _i ] ; if ( node . kind = = = 2 1 5 | | node . kind = = = 2 1 4 | | node . kind = = = 1 8 6 | | node . kind = = = 2 1 6 ) { var declaration = node ; if ( declaration . type Parameters ) { result = append Type Parameters ( result , declaration . type Parameters ) ; } } } return result ; } 
function get Base Constructor Type Of Class ( type ) { if ( ! type . resolved Base Constructor Type ) { var base Type Node = get Base Type Node Of Class ( type ) ; if ( ! base Type Node ) { return type . resolved Base Constructor Type = undefined Type ; } if ( ! push Type Resolution ( type , 1 ) ) { return unknown Type ; } var base Constructor Type = check Expression ( base Type Node . expression ) ; if ( base Constructor Type . flags & 8 0 8 9 6 ) { 
function is Independent Type Reference ( node ) { if ( node . type Arguments ) { for ( var _i = 0 , _a = node . type Arguments ; _i < _a . length ; _i + + ) { var type Node = _a [ _i ] ; if ( ! is Independent Type ( type Node ) ) { return false ; } } } return true ; } 
function is Independent Variable Like Declaration ( node ) { return node . type & & is Independent Type ( node . type ) | | ! node . type & & ! node . initializer ; } 
function is Independent Function Like Declaration ( node ) { if ( node . kind ! = = 1 4 4 & & ( ! node . type | | ! is Independent Type ( node . type ) ) ) { return false ; } for ( var _i = 0 , _a = node . parameters ; _i < _a . length ; _i + + ) { var parameter = _a [ _i ] ; if ( ! is Independent Variable Like Declaration ( parameter ) ) { return false ; } } return true ; } 
function create Instantiated Symbol Table ( symbols , mapper , mapping This Only ) { var result = { } ; for ( var _i = 0 ; _i < symbols . length ; _i + + ) { var symbol = symbols [ _i ] ; result [ symbol . name ] = mapping This Only & & is Independent Member ( symbol ) ? symbol : instantiate Symbol ( symbol , mapper ) ; } return result ; } 
function get Union Signatures ( types , kind ) { var signature Lists = ts . map ( types , function ( t ) { return get Signatures Of Type ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signature Lists . length ; i + + ) { for ( var _i = 0 , _a = signature Lists [ i ] ; _i < _a . length ; _i + + ) { var signature = _a [ _i ] ; 
function get Property Of Object Type ( type , name ) { if ( type . flags & 8 0 8 9 6 ) { var resolved = resolve Structured Type Members ( type ) ; if ( ts . has Property ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbol Is Value ( symbol ) ) { return symbol ; } } } } 
function get Apparent Type ( type ) { if ( type . flags & 5 1 2 ) { do { type = get Constraint Of Type Parameter ( type ) ; } while ( type & & type . flags & 5 1 2 ) ; if ( ! type ) { type = empty Object Type ; } } if ( type . flags & 2 5 8 ) { type = global String Type ; } else if ( type . flags & 1 3 2 ) { type = global Number Type ; } else if ( type . flags & 8 ) { type = global Boolean Type ; } else if ( type . flags & 1 6 7 7 7 2 1 6 ) { type = global ESSymbol Type ; } return type ; } 
function get Property Of Type ( type , name ) { type = get Apparent Type ( type ) ; if ( type . flags & 8 0 8 9 6 ) { var resolved = resolve Structured Type Members ( type ) ; if ( ts . has Property ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbol Is Value ( symbol ) ) { return symbol ; } } if ( resolved = = = any Function Type | | resolved . call Signatures . length | | resolved . construct Signatures . length ) { var symbol = get Property Of Object Type ( global Function Type , name ) ; if ( symbol ) { return symbol ; } } return get Property Of Object Type ( global Object Type , name ) ; } if ( type . flags & 4 9 1 5 2 ) { return get Property Of Union Or Intersection Type ( type , name ) ; } return undefined ; } 
function get Type Parameters From Declaration ( type Parameter Declarations ) { var result = [ ] ; ts . for Each ( type Parameter Declarations , function ( node ) { var tp = get Declared Type Of Type Parameter ( node . symbol ) ; if ( ! ts . contains ( result , tp ) ) { result . push ( tp ) ; } } ) ; return result ; } 
function get Propagating Flags Of Types ( types ) { var result = 0 ; for ( var _i = 0 ; _i < types . length ; _i + + ) { var type = types [ _i ] ; result | = type . flags ; } return result & 1 4 6 8 0 0 6 4 ; } 
function get Type From Class Or Interface Reference ( node , symbol ) { var type = get Declared Type Of Symbol ( symbol ) ; var type Parameters = type . local Type Parameters ; if ( type Parameters ) { if ( ! node . type Arguments | | node . type Arguments . length ! = = type Parameters . length ) { error ( node , ts . Diagnostics . Generic _type _ 0 _requires _ 1 _type _argument _s , type To String ( type , undefined , 1 ) , type Parameters . length ) ; return unknown Type ; } 
function get Type From Type Alias Reference ( node , symbol ) { var type = get Declared Type Of Symbol ( symbol ) ; var links = get Symbol Links ( symbol ) ; var type Parameters = links . type Parameters ; if ( type Parameters ) { if ( ! node . type Arguments | | node . type Arguments . length ! = = type Parameters . length ) { error ( node , ts . Diagnostics . Generic _type _ 0 _requires _ 1 _type _argument _s , symbol To String ( symbol ) , type Parameters . length ) ; return unknown Type ; } var type Arguments = ts . map ( node . type Arguments , get Type From Type Node ) ; var id = get Type List Id ( type Arguments ) ; return links . instantiations [ id ] | | ( links . instantiations [ id ] = instantiate Type ( type , create Type Mapper ( type Parameters , type Arguments ) ) ) ; } if ( node . type Arguments ) { error ( node , ts . Diagnostics . Type _ 0 _is _not _generic , symbol To String ( symbol ) ) ; return unknown Type ; } return type ; } 
function get Type From Non Generic Type Reference ( node , symbol ) { if ( symbol . flags & 2 6 2 1 4 4 & & is Type Parameter Reference Illegal In Constraint ( node , symbol ) ) { 
function get Exported Type From Namespace ( namespace , name ) { var namespace Symbol = get Global Symbol ( namespace , 1 5 3 6 , undefined ) ; var type Symbol = namespace Symbol & & get Symbol ( namespace Symbol . exports , name , 7 9 3 0 5 6 ) ; return type Symbol & & get Declared Type Of Symbol ( type Symbol ) ; } 
function create Typed Property Descriptor Type ( property Type ) { var global Typed Property Descriptor Type = get Global Typed Property Descriptor Type ( ) ; return global Typed Property Descriptor Type ! = = empty Generic Type ? create Type Reference ( global Typed Property Descriptor Type , [ property Type ] ) : empty Object Type ; } 
function add Types To Set ( type Set , types , type Set Kind ) { for ( var _i = 0 ; _i < types . length ; _i + + ) { var type = types [ _i ] ; add Type To Set ( type Set , type , type Set Kind ) ; } } 
function get Union Type ( types , no Subtype Reduction ) { if ( types . length = = = 0 ) { return empty Object Type ; } var type Set = [ ] ; add Types To Set ( type Set , types , 1 6 3 8 4 ) ; if ( contains Type Any ( type Set ) ) { return any Type ; } if ( no Subtype Reduction ) { remove All But Last ( type Set , undefined Type ) ; remove All But Last ( type Set , null Type ) ; } else { remove Subtypes ( type Set ) ; } if ( type Set . length = = = 1 ) { return type Set [ 0 ] ; } var id = get Type List Id ( type Set ) ; var type = union Types [ id ] ; if ( ! type ) { type = union Types [ id ] = create Object Type ( 1 6 3 8 4 | get Propagating Flags Of Types ( type Set ) ) ; type . types = type Set ; } return type ; } 
function get Intersection Type ( types ) { if ( types . length = = = 0 ) { return empty Object Type ; } var type Set = [ ] ; add Types To Set ( type Set , types , 3 2 7 6 8 ) ; if ( contains Type Any ( type Set ) ) { return any Type ; } if ( type Set . length = = = 1 ) { return type Set [ 0 ] ; } var id = get Type List Id ( type Set ) ; var type = intersection Types [ id ] ; if ( ! type ) { type = intersection Types [ id ] = create Object Type ( 3 2 7 6 8 | get Propagating Flags Of Types ( type Set ) ) ; type . types = type Set ; } return type ; } 
function check Type Related To ( source , target , relation , error Node , head Message , containing Message Chain ) { var error Info ; var source Stack ; var target Stack ; var maybe Stack ; var expanding Flags ; var depth = 0 ; var overflow = false ; var elaborate Errors = false ; ts . Debug . assert ( relation ! = = identity Relation | | ! error Node , "no error reporting in identity checking " ) ; var result = is Related To ( source , target , error Node ! = = undefined , head Message ) ; if ( overflow ) { error ( error Node , ts . Diagnostics . Excessive _stack _depth _comparing _types _ 0 _and _ 1 , type To String ( source ) , type To String ( target ) ) ; } else if ( error Info ) { 
function is Related To ( source , target , report Errors , head Message ) { var result ; 
function is Known Property ( type , name ) { if ( type . flags & 8 0 8 9 6 ) { var resolved = resolve Structured Type Members ( type ) ; if ( relation = = = assignable Relation & & ( type = = = global Object Type | | resolved . properties . length = = = 0 ) | | resolved . string Index Type | | resolved . number Index Type | | get Property Of Type ( type , name ) ) { return true ; } return false ; } if ( type . flags & 4 9 1 5 2 ) { for ( var _i = 0 , _a = type . types ; _i < _a . length ; _i + + ) { var t = _a [ _i ] ; if ( is Known Property ( t , name ) ) { return true ; } } return false ; } return true ; } 
function object Type Related To ( source , target , report Errors ) { if ( overflow ) { return 0 ; } var id = relation ! = = identity Relation | | source . id < target . id ? source . id + " , " + target . id : target . id + " , " + source . id ; var related = relation [ id ] ; if ( related ! = = undefined ) { 
function is Deeply Nested Generic ( type , stack , depth ) { 
function remove Types From Union Type ( type , type Kind , is Of Type Kind , allow Empty Union Result ) { if ( type . flags & 1 6 3 8 4 ) { var types = type . types ; if ( ts . for Each ( types , function ( t ) { return ! ! ( t . flags & type Kind ) = = = is Of Type Kind ; } ) ) { 
function is Variable Assigned Within ( symbol , node ) { var links = get Node Links ( node ) ; if ( links . assignment Checks ) { var cached Result = links . assignment Checks [ symbol . id ] ; if ( cached Result ! = = undefined ) { return cached Result ; } } else { links . assignment Checks = { } ; } return links . assignment Checks [ symbol . id ] = is Assigned In ( node ) ; function is Assigned In Binary Expression ( node ) { if ( node . operator Token . kind > = 5 6 & & node . operator Token . kind < = 6 8 ) { var n = node . left ; while ( n . kind = = = 1 7 2 ) { n = n . expression ; } if ( n . kind = = = 6 9 & & get Resolved Symbol ( n ) = = = symbol ) { return true ; } } return ts . for Each Child ( node , is Assigned In ) ; } function is Assigned In Variable Declaration ( node ) { if ( ! ts . is Binding Pattern ( node . name ) & & get Symbol Of Node ( node ) = = = symbol & & has Initializer ( node ) ) { return true ; } return ts . for Each Child ( node , is Assigned In ) ; } function is Assigned In ( node ) { switch ( node . kind ) { case 1 8 1 : return is Assigned In Binary Expression ( node ) ; case 2 1 1 : case 1 6 3 : return is Assigned In Variable Declaration ( node ) ; case 1 6 1 : case 1 6 2 : case 1 6 4 : case 1 6 5 : case 1 6 6 : case 1 6 7 : case 1 6 8 : case 1 6 9 : case 1 7 1 : case 1 8 9 : case 1 7 2 : case 1 7 9 : case 1 7 5 : case 1 7 8 : case 1 7 6 : case 1 7 7 : case 1 8 0 : case 1 8 4 : case 1 8 2 : case 1 8 5 : case 1 9 2 : case 1 9 3 : case 1 9 5 : case 1 9 6 : case 1 9 7 : case 1 9 8 : case 1 9 9 : case 2 0 0 : case 2 0 1 : case 2 0 4 : case 2 0 5 : case 2 0 6 : case 2 4 1 : case 2 4 2 : case 2 0 7 : case 2 0 8 : case 2 0 9 : case 2 4 4 : case 2 3 3 : case 2 3 4 : case 2 3 8 : case 2 3 9 : case 2 3 5 : case 2 4 0 : return ts . for Each Child ( node , is Assigned In ) ; } return false ; } } 
function get Narrowed Type Of Symbol ( symbol , node ) { var type = get Type Of Symbol ( symbol ) ; 
function narrow Type ( type , expr , assume True ) { switch ( expr . kind ) { case 1 6 8 : return narrow Type By Type Predicate ( type , expr , assume True ) ; case 1 7 2 : return narrow Type ( type , expr . expression , assume True ) ; case 1 8 1 : var operator = expr . operator Token . kind ; if ( operator = = = 3 2 | | operator = = = 3 3 ) { return narrow Type By Equality ( type , expr , assume True ) ; } else if ( operator = = = 5 1 ) { return narrow Type By And ( type , expr , assume True ) ; } else if ( operator = = = 5 2 ) { return narrow Type By Or ( type , expr , assume True ) ; } else if ( operator = = = 9 1 ) { return narrow Type By Instanceof ( type , expr , assume True ) ; } break ; case 1 7 9 : if ( expr . operator = = = 4 9 ) { return narrow Type ( type , expr . operand , ! assume True ) ; } break ; } return type ; } 
function get Contextually Typed Parameter Type ( parameter ) { var func = parameter . parent ; if ( is Function Expression Or Arrow Function ( func ) | | ts . is Object Literal Method ( func ) ) { if ( is Context Sensitive ( func ) ) { var contextual Signature = get Contextual Signature ( func ) ; if ( contextual Signature ) { var func Has Rest Parameters = ts . has Rest Parameter ( func ) ; var len = func . parameters . length - ( func Has Rest Parameters ? 1 : 0 ) ; var index Of Parameter = ts . index Of ( func . parameters , parameter ) ; if ( index Of Parameter < len ) { return get Type At Position ( contextual Signature , index Of Parameter ) ; } 
function get Contextual Type For Initializer Expression ( node ) { var declaration = node . parent ; if ( node = = = declaration . initializer ) { if ( declaration . type ) { return get Type From Type Node ( declaration . type ) ; } if ( declaration . kind = = = 1 3 8 ) { var type = get Contextually Typed Parameter Type ( declaration ) ; if ( type ) { return type ; } } if ( ts . is Binding Pattern ( declaration . name ) ) { return get Type From Binding Pattern ( declaration . name , true ) ; } } return undefined ; } 
function apply To Contextual Type ( type , mapper ) { if ( ! ( type . flags & 1 6 3 8 4 ) ) { return mapper ( type ) ; } var types = type . types ; var mapped Type ; var mapped Types ; for ( var _i = 0 ; _i < types . length ; _i + + ) { var current = types [ _i ] ; var t = mapper ( current ) ; if ( t ) { if ( ! mapped Type ) { mapped Type = t ; } else if ( ! mapped Types ) { mapped Types = [ mapped Type , t ] ; } else { mapped Types . push ( t ) ; } } } return mapped Types ? get Union Type ( mapped Types ) : mapped Type ; } 
function contextual Type Has Index Signature ( type , kind ) { return ! ! ( type . flags & 1 6 3 8 4 ? ts . for Each ( type . types , function ( t ) { return get Index Type Of Structured Type ( t , kind ) ; } ) : get Index Type Of Structured Type ( type , kind ) ) ; } 
function get Contextual Type For Object Literal Method ( node ) { ts . Debug . assert ( ts . is Object Literal Method ( node ) ) ; if ( is Inside With Statement Body ( node ) ) { 
function get Contextual Type For Element Expression ( node ) { var array Literal = node . parent ; var type = get Contextual Type ( array Literal ) ; if ( type ) { var index = ts . index Of ( array Literal . elements , node ) ; return get Type Of Property Of Contextual Type ( type , " " + index ) | | get Index Type Of Contextual Type ( type , 1 ) | | ( language Version > = 2 ? get Element Type Of Iterable ( type , undefined ) : undefined ) ; } return undefined ; } 
function get Contextual Type For Conditional Operand ( node ) { var conditional = node . parent ; return node = = = conditional . when True | | node = = = conditional . when False ? get Contextual Type ( conditional ) : undefined ; } 
function get Non Generic Signature ( type ) { var signatures = get Signatures Of Structured Type ( type , 0 ) ; if ( signatures . length = = = 1 ) { var signature = signatures [ 0 ] ; if ( ! signature . type Parameters ) { return signature ; } } } 
function get Contextual Signature ( node ) { ts . Debug . assert ( node . kind ! = = 1 4 3 | | ts . is Object Literal Method ( node ) ) ; var type = ts . is Object Literal Method ( node ) ? get Contextual Type For Object Literal Method ( node ) : get Contextual Type ( node ) ; if ( ! type ) { return undefined ; } if ( ! ( type . flags & 1 6 3 8 4 ) ) { return get Non Generic Signature ( type ) ; } var signature List ; var types = type . types ; for ( var _i = 0 ; _i < types . length ; _i + + ) { var current = types [ _i ] ; var signature = get Non Generic Signature ( current ) ; if ( signature ) { if ( ! signature List ) { 
function is Assignment Target ( node ) { var parent = node . parent ; if ( parent . kind = = = 1 8 1 & & parent . operator Token . kind = = = 5 6 & & parent . left = = = node ) { return true ; } if ( parent . kind = = = 2 4 5 ) { return is Assignment Target ( parent . parent ) ; } if ( parent . kind = = = 1 6 4 ) { return is Assignment Target ( parent ) ; } return false ; } 
function get Jsx Intrinsic Elements Type ( ) { if ( ! jsx Intrinsic Elements Type ) { jsx Intrinsic Elements Type = get Exported Type From Namespace ( Jsx Names . JSX , Jsx Names . Intrinsic Elements ) | | unknown Type ; } return jsx Intrinsic Elements Type ; } 
function get Jsx Element Tag Symbol ( node ) { var flags = 8 ; var links = get Node Links ( node ) ; if ( ! links . resolved Symbol ) { if ( is Jsx Intrinsic Identifier ( node . tag Name ) ) { links . resolved Symbol = lookup Intrinsic Tag ( node ) ; } else { links . resolved Symbol = lookup Class Tag ( node ) ; } } return links . resolved Symbol ; function lookup Intrinsic Tag ( node ) { var intrinsic Elements Type = get Jsx Intrinsic Elements Type ( ) ; if ( intrinsic Elements Type ! = = unknown Type ) { 
function get Jsx Element Instance Type ( node ) { 
function get Jsx Element Attributes Type ( node ) { var links = get Node Links ( node ) ; if ( ! links . resolved Jsx Type ) { var sym = get Jsx Element Tag Symbol ( node ) ; if ( links . jsx Flags & 4 ) { var elem Instance Type = get Jsx Element Instance Type ( node ) ; if ( is Type Any ( elem Instance Type ) ) { return links . resolved Jsx Type = elem Instance Type ; } var props Name = get Jsx Element Properties Name ( ) ; if ( props Name = = = undefined ) { 
function get Jsx Attribute Property Symbol ( attrib ) { var attributes Type = get Jsx Element Attributes Type ( attrib . parent ) ; var prop = get Property Of Type ( attributes Type , attrib . name . text ) ; return prop | | unknown Symbol ; } 
function check Class Property Access ( node , left , type , prop ) { var flags = get Declaration Flags From Symbol ( prop ) ; var declaring Class = get Declared Type Of Symbol ( prop . parent ) ; if ( left . kind = = = 9 5 ) { var error Node = node . kind = = = 1 6 6 ? node . name : node . right ; 
function get Property Name For Indexed Access ( index Argument Expression , index Argument Type ) { if ( index Argument Expression . kind = = = 9 | | index Argument Expression . kind = = = 8 ) { return index Argument Expression . text ; } if ( index Argument Expression . kind = = = 1 6 7 | | index Argument Expression . kind = = = 1 6 6 ) { var value = get Constant Value ( index Argument Expression ) ; if ( value ! = = undefined ) { return value . to String ( ) ; } } if ( check That Expression Is Proper Symbol Reference ( index Argument Expression , index Argument Type , false ) ) { var right Hand Side Name = index Argument Expression . name . text ; return ts . get Property Name For Known Symbol Name ( right Hand Side Name ) ; } return undefined ; } 
function reorder Candidates ( signatures , result ) { var last Parent ; var last Symbol ; var cutoff Index = 0 ; var index ; var specialized Index = - 1 ; var splice Index ; ts . Debug . assert ( ! result . length ) ; for ( var _i = 0 ; _i < signatures . length ; _i + + ) { var signature = signatures [ _i ] ; var symbol = signature . declaration & & get Symbol Of Node ( signature . declaration ) ; var parent _ 5 = signature . declaration & & signature . declaration . parent ; if ( ! last Symbol | | symbol = = = last Symbol ) { if ( last Parent & & parent _ 5 = = = last Parent ) { index + + ; } else { last Parent = parent _ 5 ; index = cutoff Index ; } } else { 
function get Single Call Signature ( type ) { if ( type . flags & 8 0 8 9 6 ) { var resolved = resolve Structured Type Members ( type ) ; if ( resolved . call Signatures . length = = = 1 & & resolved . construct Signatures . length = = = 0 & & resolved . properties . length = = = 0 & & ! resolved . string Index Type & & ! resolved . number Index Type ) { return resolved . call Signatures [ 0 ] ; } } return undefined ; } 
function instantiate Signature In Context Of ( signature , contextual Signature , contextual Mapper ) { var context = create Inference Context ( signature . type Parameters , true ) ; for Each Matching Parameter Type ( contextual Signature , signature , function ( source , target ) { 
function get Effective Call Arguments ( node ) { var args ; if ( node . kind = = = 1 7 0 ) { var template = node . template ; args = [ undefined ] ; if ( template . kind = = = 1 8 3 ) { ts . for Each ( template . template Spans , function ( span ) { args . push ( span . expression ) ; } ) ; } } else if ( node . kind = = = 1 3 9 ) { 
function get Effective Argument Count ( node , args , signature ) { if ( node . kind = = = 1 3 9 ) { switch ( node . parent . kind ) { case 2 1 4 : case 1 8 6 : 
function get Effective Decorator Second Argument Type ( node ) { 
function get Effective Decorator Argument Type ( node , arg Index ) { if ( arg Index = = = 0 ) { return get Effective Decorator First Argument Type ( node . parent ) ; } else if ( arg Index = = = 1 ) { return get Effective Decorator Second Argument Type ( node . parent ) ; } else if ( arg Index = = = 2 ) { return get Effective Decorator Third Argument Type ( node . parent ) ; } ts . Debug . fail ( "Decorators should not have a fourth synthetic argument . " ) ; return unknown Type ; } 
function get Effective Argument Type ( node , arg Index , arg ) { 
function get Effective Argument ( node , args , arg Index ) { 
function get Effective Argument Error Node ( node , arg Index , arg ) { if ( node . kind = = = 1 3 9 ) { 
function get Diagnostic Head Message For Decorator Resolution ( node ) { switch ( node . parent . kind ) { case 2 1 4 : case 1 8 6 : return ts . Diagnostics . Unable _to _resolve _signature _of _class _decorator _when _called _as _an _expression ; case 1 3 8 : return ts . Diagnostics . Unable _to _resolve _signature _of _parameter _decorator _when _called _as _an _expression ; case 1 4 1 : return ts . Diagnostics . Unable _to _resolve _signature _of _property _decorator _when _called _as _an _expression ; case 1 4 3 : case 1 4 5 : case 1 4 6 : return ts . Diagnostics . Unable _to _resolve _signature _of _method _decorator _when _called _as _an _expression ; } } 
function resolve Decorator ( node , candidates Out Array ) { var func Type = check Expression ( node . expression ) ; var apparent Type = get Apparent Type ( func Type ) ; if ( apparent Type = = = unknown Type ) { return resolve Error Call ( node ) ; } var call Signatures = get Signatures Of Type ( apparent Type , 0 ) ; if ( func Type = = = any Type | | ( ! call Signatures . length & & ! ( func Type . flags & 1 6 3 8 4 ) & & is Type Assignable To ( func Type , global Function Type ) ) ) { return resolve Untyped Call ( node ) ; } var head Message = get Diagnostic Head Message For Decorator Resolution ( node ) ; if ( ! call Signatures . length ) { var error Info ; error Info = ts . chain Diagnostic Messages ( error Info , ts . Diagnostics . Cannot _invoke _an _expression _whose _type _lacks _a _call _signature ) ; error Info = ts . chain Diagnostic Messages ( error Info , head Message ) ; diagnostics . add ( ts . create Diagnostic For Node From Message Chain ( node , error Info ) ) ; return resolve Error Call ( node ) ; } return resolve Call ( node , call Signatures , candidates Out Array , head Message ) ; } 
function get Resolved Signature ( node , candidates Out Array ) { var links = get Node Links ( node ) ; 
function check Call Expression ( node ) { 
function assign Binding Element Types ( node ) { if ( ts . is Binding Pattern ( node . name ) ) { for ( var _i = 0 , _a = node . name . elements ; _i < _a . length ; _i + + ) { var element = _a [ _i ] ; if ( element . kind ! = = 1 8 7 ) { if ( element . name . kind = = = 6 9 ) { get Symbol Links ( get Symbol Of Node ( element ) ) . type = get Type For Binding Element ( element ) ; } assign Binding Element Types ( element ) ; } } } } 
function check If Non Void Function Has Return Expressions Or Single Throw Statment ( func , return Type ) { if ( ! produce Diagnostics ) { return ; } 
function some Constituent Type Has Kind ( type , kind ) { if ( type . flags & kind ) { return true ; } if ( type . flags & 4 9 1 5 2 ) { var types = type . types ; for ( var _i = 0 ; _i < types . length ; _i + + ) { var current = types [ _i ] ; if ( current . flags & kind ) { return true ; } } return false ; } return false ; } 
function check Type Parameter ( node ) { 
function get Promised Type ( promise ) { 
function check Decorator ( node ) { var signature = get Resolved Signature ( node ) ; var return Type = get Return Type Of Signature ( signature ) ; if ( return Type . flags & 1 ) { return ; } var expected Return Type ; var head Message = get Diagnostic Head Message For Decorator Resolution ( node ) ; var error Info ; switch ( node . parent . kind ) { case 2 1 4 : var class Symbol = get Symbol Of Node ( node . parent ) ; var class Constructor Type = get Type Of Symbol ( class Symbol ) ; expected Return Type = get Union Type ( [ class Constructor Type , void Type ] ) ; break ; case 1 3 8 : expected Return Type = void Type ; error Info = ts . chain Diagnostic Messages ( error Info , ts . Diagnostics . The _return _type _of _a _parameter _decorator _function _must _be _either _void _or _any ) ; break ; case 1 4 1 : expected Return Type = void Type ; error Info = ts . chain Diagnostic Messages ( error Info , ts . Diagnostics . The _return _type _of _a _property _decorator _function _must _be _either _void _or _any ) ; break ; case 1 4 3 : case 1 4 5 : case 1 4 6 : var method Type = get Type Of Node ( node . parent ) ; var descriptor Type = create Typed Property Descriptor Type ( method Type ) ; expected Return Type = get Union Type ( [ descriptor Type , void Type ] ) ; break ; } check Type Assignable To ( return Type , expected Return Type , node , head Message , error Info ) ; } 
function check Type Node As Expression ( node ) { 
function check Type Annotation As Expression ( node ) { switch ( node . kind ) { case 1 4 1 : check Type Node As Expression ( node . type ) ; break ; case 1 3 8 : check Type Node As Expression ( node . type ) ; break ; case 1 4 3 : check Type Node As Expression ( node . type ) ; break ; case 1 4 5 : check Type Node As Expression ( node . type ) ; break ; case 1 4 6 : check Type Node As Expression ( ts . get Set Accessor Type Annotation Node ( node ) ) ; break ; } } 
function check Parameter Type Annotations As Expressions ( node ) { 
function check Decorators ( node ) { if ( ! node . decorators ) { return ; } 
function check If This Is Captured In Enclosing Scope ( node ) { var current = node ; while ( current ) { if ( get Node Check Flags ( current ) & 4 ) { var is Declaration _ 1 = node . kind ! = = 6 9 ; if ( is Declaration _ 1 ) { error ( node . name , ts . Diagnostics . Duplicate _identifier _this _Compiler _uses _variable _declaration _this _to _capture _this _reference ) ; } else { error ( node , ts . Diagnostics . Expression _resolves _to _variable _declaration _this _that _compiler _uses _to _capture _this _reference ) ; } return ; } current = current . parent ; } } 
function check Parameter Initializer ( node ) { if ( ts . get Root Declaration ( node ) . kind ! = = 1 3 8 ) { return ; } var func = ts . get Containing Function ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind = = = 6 9 ) { var referenced Symbol = get Node Links ( n ) . resolved Symbol ; 
function check Variable Like Declaration ( node ) { check Decorators ( node ) ; check Source Element ( node . type ) ; 
function check Element Type Of Iterable ( iterable , error Node ) { var element Type = get Element Type Of Iterable ( iterable , error Node ) ; 
function check Type Parameters ( type Parameter Declarations ) { if ( type Parameter Declarations ) { for ( var i = 0 , n = type Parameter Declarations . length ; i < n ; i + + ) { var node = type Parameter Declarations [ i ] ; check Type Parameter ( node ) ; if ( produce Diagnostics ) { for ( var j = 0 ; j < i ; j + + ) { if ( type Parameter Declarations [ j ] . symbol = = = node . symbol ) { error ( node . name , ts . Diagnostics . Duplicate _identifier _ 0 , ts . declaration Name To String ( node . name ) ) ; } } } } } } 
function check Function And Class Expression Bodies ( node ) { switch ( node . kind ) { case 1 7 3 : case 1 7 4 : ts . for Each ( node . parameters , check Function And Class Expression Bodies ) ; check Function Expression Or Object Literal Method Body ( node ) ; break ; case 1 8 6 : ts . for Each ( node . members , check Source Element ) ; ts . for Each Child ( node , check Function And Class Expression Bodies ) ; break ; case 1 4 3 : case 1 4 2 : ts . for Each ( node . decorators , check Function And Class Expression Bodies ) ; ts . for Each ( node . parameters , check Function And Class Expression Bodies ) ; if ( ts . is Object Literal Method ( node ) ) { check Function Expression Or Object Literal Method Body ( node ) ; } break ; case 1 4 4 : case 1 4 5 : case 1 4 6 : case 2 1 3 : ts . for Each ( node . parameters , check Function And Class Expression Bodies ) ; break ; case 2 0 5 : check Function And Class Expression Bodies ( node . expression ) ; break ; case 1 3 9 : case 1 3 8 : case 1 4 1 : case 1 4 0 : case 1 6 1 : case 1 6 2 : case 1 6 3 : case 1 6 4 : case 1 6 5 : case 2 4 5 : case 1 6 6 : case 1 6 7 : case 1 6 8 : case 1 6 9 : case 1 7 0 : case 1 8 3 : case 1 9 0 : case 1 7 1 : case 1 8 9 : case 1 7 2 : case 1 7 6 : case 1 7 7 : case 1 7 8 : case 1 7 5 : case 1 7 9 : case 1 8 0 : case 1 8 1 : case 1 8 2 : case 1 8 5 : case 1 8 4 : case 1 9 2 : case 2 1 9 : case 1 9 3 : case 1 9 5 : case 1 9 6 : case 1 9 7 : case 1 9 8 : case 1 9 9 : case 2 0 0 : case 2 0 1 : case 2 0 2 : case 2 0 3 : case 2 0 4 : case 2 0 6 : case 2 2 0 : case 2 4 1 : case 2 4 2 : case 2 0 7 : case 2 0 8 : case 2 0 9 : case 2 4 4 : case 2 1 1 : case 2 1 2 : case 2 1 4 : case 2 4 3 : case 1 8 8 : case 2 1 7 : case 2 4 7 : case 2 2 7 : case 2 4 8 : case 2 4 0 : case 2 3 3 : case 2 3 4 : case 2 3 8 : case 2 3 9 : case 2 3 5 : ts . for Each Child ( node , check Function And Class Expression Bodies ) ; break ; } } 
function check Source File Worker ( node ) { var links = get Node Links ( node ) ; if ( ! ( links . flags & 1 ) ) { 
function copy Symbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; 
function get Parent Type Of Class Element ( node ) { var class Symbol = get Symbol Of Node ( node . parent ) ; return node . flags & 1 2 8 ? get Type Of Symbol ( class Symbol ) : get Declared Type Of Symbol ( class Symbol ) ; } 
function get Augmented Properties Of Type ( type ) { type = get Apparent Type ( type ) ; var props By Name = create Symbol Table ( get Properties Of Type ( type ) ) ; if ( get Signatures Of Type ( type , 0 ) . length | | get Signatures Of Type ( type , 1 ) . length ) { ts . for Each ( get Properties Of Type ( global Function Type ) , function ( p ) { if ( ! ts . has Property ( props By Name , p . name ) ) { props By Name [ p . name ] = p ; } } ) ; } return get Named Members ( props By Name ) ; } 
function get Referenced Export Container ( node ) { var symbol = get Referenced Value Symbol ( node ) ; if ( symbol ) { if ( symbol . flags & 1 0 4 8 5 7 6 ) { 
function get Referenced Import Declaration ( node ) { var symbol = get Referenced Value Symbol ( node ) ; return symbol & & symbol . flags & 8 3 8 8 6 0 8 ? get Declaration Of Alias Symbol ( symbol ) : undefined ; } 
function get Referenced Nested Redeclaration ( node ) { var symbol = get Referenced Value Symbol ( node ) ; return symbol & & is Nested Redeclaration Symbol ( symbol ) ? symbol . value Declaration : undefined ; } 
function check Grammar Decorators ( node ) { if ( ! node . decorators ) { return false ; } if ( ! ts . node Can Be Decorated ( node ) ) { return grammar Error On First Token ( node , ts . Diagnostics . Decorators _are _not _valid _here ) ; } else if ( node . kind = = = 1 4 5 | | node . kind = = = 1 4 6 ) { var accessors = ts . get All Accessor Declarations ( node . parent . members , node ) ; if ( accessors . first Accessor . decorators & & node = = = accessors . second Accessor ) { return grammar Error On First Token ( node , ts . Diagnostics . Decorators _cannot _be _applied _to _multiple _get _Slashset _accessors _of _the _same _name ) ; } } return false ; } 
function get Export Default Temp Variable Name ( ) { var base Name = " _default " ; if ( ! ts . has Property ( current Source File . identifiers , base Name ) ) { return base Name ; } var count = 0 ; while ( true ) { var name _ 1 8 = base Name + " _ " + ( + + count ) ; if ( ! ts . has Property ( current Source File . identifiers , name _ 1 8 ) ) { return name _ 1 8 ; } } } 
function write Declaration File ( js File Path , source File , host , resolver , diagnostics ) { var emit Declaration Result = emit Declarations ( host , resolver , diagnostics , js File Path , source File ) ; 
function emit Files ( resolver , host , target Source File ) { * This by default writes the text provided with the given token Kind * but if optional emit Fn callback is provided the text is emitted using the callback instead of default text * @param token Kind the kind of the token to search and emit * @param start Pos the position in the source to start searching for the token * @param emit Fn if given will be invoked to emit the text instead of actual token emit * / var emit Token = emit Token Text ; var scope Emit Start = function ( scope Declaration , scope Name ) { } ; var scope Emit End = function ( ) { } ; var source Map Data ; var emit Leading Comments Of Position = compiler Options . remove Comments ? function ( pos ) { } : emit Leading Comments Of Position Worker ; var module Emit Delegates = ( _a = { } , _a [ 5 ] = emit ES 6Module , _a [ 2 ] = emit AMDModule , _a [ 4 ] = emit System Module , _a [ 3 ] = emit UMDModule , _a [ 1 ] = emit Common JSModule , _a ) ; if ( compiler Options . source Map | | compiler Options . inline Source Map ) { initialize Emitter With Source Maps ( ) ; } if ( root ) { * Returns whether the expression has lesser , greater , * or equal precedence to the binary ' + ' operator * / function compare Precedence To Binary Plus ( expression ) { * Checks if given node is a source file level declaration (not nested in module /function ) . * If 'is Exported ' is true - then declaration must also be exported . * This function is used in two cases : * - check if node is a exported source file level value to determine * if we should also export the value after its it changed * - check if node is a source level declaration to emit it differently , * i .e non -exported variable statement 'var x = 1 ' is hoisted so * we we emit variable statement 'var ' should be dropped . * / function is Source File Level Declaration In System Js Module ( node , is Exported ) { if ( ! node | | language Version > = 2 | | ! is Current File System External Module ( ) ) { return false ; } var current = node ; while ( current ) { if ( current . kind = = = 2 4 8 ) { return ! is Exported | | ( ( ts . get Combined Node Flags ( node ) & 1 ) ! = = 0 ) ; } else if ( ts . is Function Like ( current ) | | current . kind = = = 2 1 9 ) { return false ; } else { current = current . parent ; } } } function emit Exponentiation Operator ( node ) { var left Hand Side Expression = node . left ; if ( node . operator Token . kind = = = 6 0 ) { var synthesized LHS ; var should Emit Parentheses = false ; if ( ts . is Element Access Expression ( left Hand Side Expression ) ) { should Emit Parentheses = true ; write ( " ( " ) ; synthesized LHS = ts . create Synthesized Node ( 1 6 7 , false ) ; var identifier = emit Temp Variable Assignment ( left Hand Side Expression . expression , false , false ) ; synthesized LHS . expression = identifier ; if ( left Hand Side Expression . argument Expression . kind ! = = 8 & & left Hand Side Expression . argument Expression . kind ! = = 9 ) { var temp Argument Expression = create And Record Temp Variable ( 2 6 8 4 3 5 4 5 6 ) ; synthesized LHS . argument Expression = temp Argument Expression ; emit Assignment ( temp Argument Expression , left Hand Side Expression . argument Expression , true ) ; } else { synthesized LHS . argument Expression = left Hand Side Expression . argument Expression ; } write ( " , " ) ; } else if ( ts . is Property Access Expression ( left Hand Side Expression ) ) { should Emit Parentheses = true ; write ( " ( " ) ; synthesized LHS = ts . create Synthesized Node ( 1 6 6 , false ) ; var identifier = emit Temp Variable Assignment ( left Hand Side Expression . expression , false , false ) ; synthesized LHS . expression = identifier ; synthesized LHS . dot Token = left Hand Side Expression . dot Token ; synthesized LHS . name = left Hand Side Expression . name ; write ( " , " ) ; } emit ( synthesized LHS | | left Hand Side Expression ) ; write ( " = " ) ; write ( "Math .pow ( " ) ; emit ( synthesized LHS | | left Hand Side Expression ) ; write ( " , " ) ; emit ( node . right ) ; write ( " ) " ) ; if ( should Emit Parentheses ) { write ( " ) " ) ; } } else { write ( "Math .pow ( " ) ; emit ( left Hand Side Expression ) ; write ( " , " ) ; emit ( node . right ) ; write ( " ) " ) ; } } function emit Binary Expression ( node ) { if ( language Version < 2 & & node . operator Token . kind = = = 5 6 & & ( node . left . kind = = = 1 6 5 | | node . left . kind = = = 1 6 4 ) ) { emit Destructuring ( node , node . parent . kind = = = 1 9 5 ) ; } else { var export Changed = node . operator Token . kind > = 5 6 & & node . operator Token . kind < = 6 8 & & is Name Of Exported Source Level Declaration In System External Module ( node . left ) ; if ( export Changed ) { * Returns true if start of variable declaration list was emitted . * Returns false if nothing was written - this can happen for source file level variable declarations * in system modules where such variable declarations are hoisted . * / function try Emit Start Of Variable Declaration List ( decl , start Pos ) { if ( should Hoist Variable ( decl , true ) ) { * Emit an assignment to a given identifier , 'name ' , with a given expression , 'value ' . * @param name an identifier as a left -hand -side operand of the assignment * @param value an expression as a right -hand -side operand of the assignment * @param should Emit Comma Before Assignment a boolean indicating whether to prefix an assignment with comma * / function emit Assignment ( name , value , should Emit Comma Before Assignment ) { if ( should Emit Comma Before Assignment ) { write ( " , " ) ; } var export Changed = is Name Of Exported Source Level Declaration In System External Module ( name ) ; if ( export Changed ) { write ( export Function For File + " ( \ " " ) ; emit Node With Comments And Without Sourcemap ( name ) ; write ( " \ " , " ) ; } var is Variable Declaration Or Binding Element = name . parent & & ( name . parent . kind = = = 2 1 1 | | name . parent . kind = = = 1 6 3 ) ; if ( is Variable Declaration Or Binding Element ) { emit Module Member Name ( name . parent ) ; } else { emit ( name ) ; } write ( " = " ) ; emit ( value ) ; if ( export Changed ) { write ( " ) " ) ; } } function emit Temp Variable Assignment ( expression , can Define Temp Variables In Place , should Emit Comma Before Assignment ) { var identifier = create Temp Variable ( 0 ) ; if ( ! can Define Temp Variables In Place ) { record Temp Declaration ( identifier ) ; } emit Assignment ( identifier , expression , should Emit Comma Before Assignment ) ; return identifier ; } function emit Destructuring ( root , is Assignment Expression Statement , value ) { var emit Count = 0 ; * Ensures that there exists a declared identifier whose value holds the given expression . * This function is useful to ensure that the expression 's value can be read from in subsequent expressions . * Unless 'reuse Identifier Expressions ' is false , 'expr ' will be returned if it is just an identifier . * * @param expr the expression whose value needs to be bound . * @param reuse Identifier Expressions true if identifier expressions can simply be returned ; * false if it is necessary to always emit an identifier . * / function ensure Identifier ( expr , reuse Identifier Expressions ) { if ( expr . kind = = = 6 9 / * Identifier * / & & reuse Identifier Expressions ) { return expr ; } var identifier = emit Temp Variable Assignment ( expr , can Define Temp Variables In Place , emit Count > 0 ) ; emit Count + + ; return identifier ; } function create Default Value Check ( value , default Value ) { / / The value expression will be evaluated twice , so for anything but a simple identifier / / we need to generate a temporary variable value = ensure Identifier ( value , / *reuse Identifier Expressions * / true ) ; / / Return the expression 'value = = = void 0 ? default Value : value ' var equals = ts . create Synthesized Node ( 1 8 1 / * Binary Expression * / ) ; equals . left = value ; equals . operator Token = ts . create Synthesized Node ( 3 2 / * Equals Equals Equals Token * / ) ; equals . right = create Void Zero ( ) ; return create Conditional Expression ( equals , default Value , value ) ; } function create Conditional Expression ( condition , when True , when False ) { var cond = ts . create Synthesized Node ( 1 8 2 / * Conditional Expression * / ) ; cond . condition = condition ; cond . question Token = ts . create Synthesized Node ( 5 3 / * Question Token * / ) ; cond . when True = when True ; cond . colon Token = ts . create Synthesized Node ( 5 4 / * Colon Token * / ) ; cond . when False = when False ; return cond ; } function create Numeric Literal ( value ) { var node = ts . create Synthesized Node ( 8 / * Numeric Literal * / ) ; node . text = " " + value ; return node ; } function create Property Access For Destructuring Property ( object , prop Name ) { / / We create a synthetic copy of the identifier in order to avoid the rewriting that might / / otherwise occur when the identifier is emitted . var synthetic Name = ts . create Synthesized Node ( prop Name . kind ) ; synthetic Name . text = prop Name . text ; if ( synthetic Name . kind ! = = 6 9 / * Identifier * / ) { return create Element Access Expression ( object , synthetic Name ) ; } return create Property Access Expression ( object , synthetic Name ) ; } function create Slice Call ( value , slice Index ) { var call = ts . create Synthesized Node ( 1 6 8 / * Call Expression * / ) ; var slice Identifier = ts . create Synthesized Node ( 6 9 / * Identifier * / ) ; slice Identifier . text = "slice " ; call . expression = create Property Access Expression ( value , slice Identifier ) ; call . arguments = ts . create Synthesized Node Array ( ) ; call . arguments [ 0 ] = create Numeric Literal ( slice Index ) ; return call ; } function emit Object Literal Assignment ( target , value ) { var properties = target . properties ; if ( properties . length ! = = 1 ) { / / For anything but a single element destructuring we need to generate a temporary / / to ensure value is evaluated exactly once . value = ensure Identifier ( value , / *reuse Identifier Expressions * / true ) ; } for ( var _a = 0 ; _a < properties . length ; _a + + ) { var p = properties [ _a ] ; if ( p . kind = = = 2 4 5 / * Property Assignment * / | | p . kind = = = 2 4 6 / * Shorthand Property Assignment * / ) { var prop Name = p . name ; var target _ 1 = p . kind = = = 2 4 6 / * Shorthand Property Assignment * / ? p : p . initializer | | prop Name ; emit Destructuring Assignment ( target _ 1 , create Property Access For Destructuring Property ( value , prop Name ) ) ; } } } function emit Array Literal Assignment ( target , value ) { var elements = target . elements ; if ( elements . length ! = = 1 ) { / / For anything but a single element destructuring we need to generate a temporary / / to ensure value is evaluated exactly once . value = ensure Identifier ( value , / *reuse Identifier Expressions * / true ) ; } for ( var i = 0 ; i < elements . length ; i + + ) { var e = elements [ i ] ; if ( e . kind ! = = 1 8 7 / * Omitted Expression * / ) { if ( e . kind ! = = 1 8 5 / * Spread Element Expression * / ) { emit Destructuring Assignment ( e , create Element Access Expression ( value , create Numeric Literal ( i ) ) ) ; } else if ( i = = = elements . length - 1 ) { emit Destructuring Assignment ( e . expression , create Slice Call ( value , i ) ) ; } } } } function emit Destructuring Assignment ( target , value ) { if ( target . kind = = = 2 4 6 / * Shorthand Property Assignment * / ) { if ( target . object Assignment Initializer ) { value = create Default Value Check ( value , target . object Assignment Initializer ) ; } target = target . name ; } else if ( target . kind = = = 1 8 1 / * Binary Expression * / & & target . operator Token . kind = = = 5 6 / * Equals Token * / ) { value = create Default Value Check ( value , target . right ) ; target = target . left ; } if ( target . kind = = = 1 6 5 / * Object Literal Expression * / ) { emit Object Literal Assignment ( target , value ) ; } else if ( target . kind = = = 1 6 4 / * Array Literal Expression * / ) { emit Array Literal Assignment ( target , value ) ; } else { emit Assignment ( target , value , / *should Emit Comma Before Assignment * / emit Count > 0 ) ; emit Count + + ; } } function emit Assignment Expression ( root ) { var target = root . left ; var value = root . right ; if ( ts . is Empty Object Literal Or Array Literal ( target ) ) { emit ( value ) ; } else if ( is Assignment Expression Statement ) { emit Destructuring Assignment ( target , value ) ; } else { if ( root . parent . kind ! = = 1 7 2 / * Parenthesized Expression * / ) { write ( " ( " ) ; } value = ensure Identifier ( value , / *reuse Identifier Expressions * / true ) ; emit Destructuring Assignment ( target , value ) ; write ( " , " ) ; emit ( value ) ; if ( root . parent . kind ! = = 1 7 2 / * Parenthesized Expression * / ) { write ( " ) " ) ; } } } function emit Binding Element ( target , value ) { if ( target . initializer ) { / / Combine value and initializer value = value ? create Default Value Check ( value , target . initializer ) : target . initializer ; } else if ( ! value ) { / / Use 'void 0 ' in absence of value and initializer value = create Void Zero ( ) ; } if ( ts . is Binding Pattern ( target . name ) ) { var pattern = target . name ; var elements = pattern . elements ; var num Elements = elements . length ; if ( num Elements ! = = 1 ) { / / For anything other than a single -element destructuring we need to generate a temporary / / to ensure value is evaluated exactly once . Additionally , if we have zero elements / / we need to emit *something * to ensure that in case a 'var ' keyword was already emitted , / / so in that case , we 'll intentionally create that temporary . value = ensure Identifier ( value , num Elements ! = = 0 ) ; } for ( var i = 0 ; i < num Elements ; i + + ) { var element = elements [ i ] ; if ( pattern . kind = = = 1 6 1 ) { * Some bundlers (System JS builder ) sometimes want to rename dependencies . * Here we check if alternative name was provided for a given module Name and return it if possible . * / function try Rename External Module ( module Name ) { if ( current Source File . renamed Dependencies & & ts . has Property ( current Source File . renamed Dependencies , module Name . text ) ) { return " \ " " + current Source File . renamed Dependencies [ module Name . text ] + " \ " " ; } return undefined ; } function emit Require ( module Name ) { if ( module Name . kind = = = 9 ) { write ( "require ( " ) ; var text = try Rename External Module ( module Name ) ; if ( text ) { write ( text ) ; } else { emit Start ( module Name ) ; emit Literal ( module Name ) ; emit End ( module Name ) ; } emit Token ( 1 8 , module Name . end ) ; } else { write ( "require ( ) " ) ; } } function get Namespace Declaration Node ( node ) { if ( node . kind = = = 2 2 1 ) { return node ; } var import Clause = node . import Clause ; if ( import Clause & & import Clause . named Bindings & & import Clause . named Bindings . kind = = = 2 2 4 ) { return import Clause . named Bindings ; } } function is Default Import ( node ) { return node . kind = = = 2 2 2 & & node . import Clause & & ! ! node . import Clause . name ; } function emit Export Import Assignments ( node ) { if ( ts . is Alias Symbol Declaration ( node ) & & resolver . is Value Alias Declaration ( node ) ) { emit Export Member Assignments ( node . name ) ; } ts . for Each Child ( node , emit Export Import Assignments ) ; } function emit Import Declaration ( node ) { if ( modulekind ! = = 5 ) { return emit External Import Declaration ( node ) ; } * Determine if the given comment is a triple -slash * * @return true if the comment is a triple -slash comment else false * * / function is Triple Slash Comment ( comment ) { * Emit comments associated with node that will not be emitted into JS file * / function emit Comments On Not Emitted Node ( node ) { emit Leading Comments Worker ( node , false ) ; } function emit Leading Comments ( node ) { return emit Leading Comments Worker ( node , true ) ; } function emit Leading Comments Worker ( node , is Emitted Node ) { if ( compiler Options . remove Comments ) { return ; } var leading Comments ; if ( is Emitted Node ) { leading Comments = get Leading Comments To Emit ( node ) ; } else { * Emit trailing comments at the position . The term trailing comment is used here to describe following comment : * x , /comment 1 / y * ^ = > pos ; the function will emit "comment 1 " in the emit JS * / function emit Trailing Comments Of Position ( pos ) { if ( compiler Options . remove Comments ) { return ; } var trailing Comments = ts . get Trailing Comment Ranges ( current Source File . text , pos ) ; 
function make Temp Variable Name ( flags ) { if ( flags & & ! ( temp Flags & flags ) ) { var name _ 1 9 = flags = = = 2 6 8 4 3 5 4 5 6 ? " _i " : " _n " ; if ( is Unique Name ( name _ 1 9 ) ) { temp Flags | = flags ; return name _ 1 9 ; } } while ( true ) { var count = temp Flags & 2 6 8 4 3 5 4 5 5 ; temp Flags + + ; 
function make Unique Name ( base Name ) { 
function encode Last Recorded Source Map Span ( ) { if ( ! last Recorded Source Map Span | | last Recorded Source Map Span = = = last Encoded Source Map Span ) { return ; } var prev Encoded Emitted Column = last Encoded Source Map Span . emitted Column ; 
function create Temp Variable ( flags ) { var result = ts . create Synthesized Node ( 6 9 ) ; result . text = make Temp Variable Name ( flags ) ; return result ; } 
function emit Tag Name ( name ) { if ( name . kind = = = 6 9 & & ts . is Intrinsic Jsx Name ( name . text ) ) { write ( " \ " " ) ; emit ( name ) ; write ( " \ " " ) ; } else { emit ( name ) ; } } 
function emit Expression For Property Name ( node ) { ts . Debug . assert ( node . kind ! = = 1 6 3 ) ; if ( node . kind = = = 9 ) { emit Literal ( node ) ; } else if ( node . kind = = = 1 3 6 ) { 
function indent If On Different Lines ( parent , node 1 , node 2 , value To Write When Not Indenting ) { var real Nodes Are On Different Lines = ! ts . node Is Synthesized ( parent ) & & ! node End Is On Same Line As Node Start ( node 1 , node 2 ) ; 
function is Source File Level Declaration In System Js Module ( node , is Exported ) { if ( ! node | | language Version > = 2 | | ! is Current File System External Module ( ) ) { return false ; } var current = node ; while ( current ) { if ( current . kind = = = 2 4 8 ) { return ! is Exported | | ( ( ts . get Combined Node Flags ( node ) & 1 ) ! = = 0 ) ; } else if ( ts . is Function Like ( current ) | | current . kind = = = 2 1 9 ) { return false ; } else { current = current . parent ; } } } 
function emit Exponentiation Operator ( node ) { var left Hand Side Expression = node . left ; if ( node . operator Token . kind = = = 6 0 ) { var synthesized LHS ; var should Emit Parentheses = false ; if ( ts . is Element Access Expression ( left Hand Side Expression ) ) { should Emit Parentheses = true ; write ( " ( " ) ; synthesized LHS = ts . create Synthesized Node ( 1 6 7 , false ) ; var identifier = emit Temp Variable Assignment ( left Hand Side Expression . expression , false , false ) ; synthesized LHS . expression = identifier ; if ( left Hand Side Expression . argument Expression . kind ! = = 8 & & left Hand Side Expression . argument Expression . kind ! = = 9 ) { var temp Argument Expression = create And Record Temp Variable ( 2 6 8 4 3 5 4 5 6 ) ; synthesized LHS . argument Expression = temp Argument Expression ; emit Assignment ( temp Argument Expression , left Hand Side Expression . argument Expression , true ) ; } else { synthesized LHS . argument Expression = left Hand Side Expression . argument Expression ; } write ( " , " ) ; } else if ( ts . is Property Access Expression ( left Hand Side Expression ) ) { should Emit Parentheses = true ; write ( " ( " ) ; synthesized LHS = ts . create Synthesized Node ( 1 6 6 , false ) ; var identifier = emit Temp Variable Assignment ( left Hand Side Expression . expression , false , false ) ; synthesized LHS . expression = identifier ; synthesized LHS . dot Token = left Hand Side Expression . dot Token ; synthesized LHS . name = left Hand Side Expression . name ; write ( " , " ) ; } emit ( synthesized LHS | | left Hand Side Expression ) ; write ( " = " ) ; write ( "Math .pow ( " ) ; emit ( synthesized LHS | | left Hand Side Expression ) ; write ( " , " ) ; emit ( node . right ) ; write ( " ) " ) ; if ( should Emit Parentheses ) { write ( " ) " ) ; } } else { write ( "Math .pow ( " ) ; emit ( left Hand Side Expression ) ; write ( " , " ) ; emit ( node . right ) ; write ( " ) " ) ; } } 
function try Emit Start Of Variable Declaration List ( decl , start Pos ) { if ( should Hoist Variable ( decl , true ) ) { 
function emit Assignment ( name , value , should Emit Comma Before Assignment ) { if ( should Emit Comma Before Assignment ) { write ( " , " ) ; } var export Changed = is Name Of Exported Source Level Declaration In System External Module ( name ) ; if ( export Changed ) { write ( export Function For File + " ( \ " " ) ; emit Node With Comments And Without Sourcemap ( name ) ; write ( " \ " , " ) ; } var is Variable Declaration Or Binding Element = name . parent & & ( name . parent . kind = = = 2 1 1 | | name . parent . kind = = = 1 6 3 ) ; if ( is Variable Declaration Or Binding Element ) { emit Module Member Name ( name . parent ) ; } else { emit ( name ) ; } write ( " = " ) ; emit ( value ) ; if ( export Changed ) { write ( " ) " ) ; } } 
function emit Temp Variable Assignment ( expression , can Define Temp Variables In Place , should Emit Comma Before Assignment ) { var identifier = create Temp Variable ( 0 ) ; if ( ! can Define Temp Variables In Place ) { record Temp Declaration ( identifier ) ; } emit Assignment ( identifier , expression , should Emit Comma Before Assignment ) ; return identifier ; } 
function ensure Identifier ( expr , reuse Identifier Expressions ) { if ( expr . kind = = = 6 9 & & reuse Identifier Expressions ) { return expr ; } var identifier = emit Temp Variable Assignment ( expr , can Define Temp Variables In Place , emit Count > 0 ) ; emit Count + + ; return identifier ; } 
function emit Serialized Type Of Node ( node ) { 
function emit Serialized Return Type Of Node ( node ) { if ( node & & ts . is Function Like ( node ) & & node . type ) { emit Serialized Type Node ( node . type ) ; return ; } write ( "void 0 " ) ; } 
function try Rename External Module ( module Name ) { if ( current Source File . renamed Dependencies & & ts . has Property ( current Source File . renamed Dependencies , module Name . text ) ) { return " \ " " + current Source File . renamed Dependencies [ module Name . text ] + " \ " " ; } return undefined ; } 
function emit Trailing Comments Of Position ( pos ) { if ( compiler Options . remove Comments ) { return ; } var trailing Comments = ts . get Trailing Comment Ranges ( current Source File . text , pos ) ; 
function find Source File ( file Name , is Default Lib , ref File , ref Pos , ref End ) { if ( files By Name . contains ( file Name ) ) { 
function get Option Name Map ( ) { if ( option Name Map Cache ) { return option Name Map Cache ; } var option Name Map = { } ; var short Option Names = { } ; ts . for Each ( ts . option Declarations , function ( option ) { option Name Map [ option . name . to Lower Case ( ) ] = option ; if ( option . short Name ) { short Option Names [ option . short Name ] = option . name ; } } ) ; option Name Map Cache = { option Name Map : option Name Map , short Option Names : short Option Names } ; return option Name Map Cache ; } 
function read Config File ( file Name , read File ) { var text = " " ; try { text = read File ( file Name ) ; } catch ( e ) { return { error : ts . create Compiler Diagnostic ( ts . Diagnostics . Cannot _read _file _ 0 _Colon _ 1 , file Name , e . message ) } ; } return parse Config File Text To Json ( file Name , text ) ; } 
function parse Config File Text To Json ( file Name , json Text ) { try { return { config : / \S / . test ( json Text ) ? JSON . parse ( json Text ) : { } } ; } catch ( e ) { return { error : ts . create Compiler Diagnostic ( ts . Diagnostics . Failed _to _parse _file _ 0 _Colon _ 1 , file Name , e . message ) } ; } } 
function parse Json Config File Content ( json , host , base Path ) { var errors = [ ] ; return { options : get Compiler Options ( ) , file Names : get File Names ( ) , errors : errors } ; function get Compiler Options ( ) { var options = { } ; var option Name Map = { } ; ts . for Each ( ts . option Declarations , function ( option ) { option Name Map [ option . name ] = option ; } ) ; var json Options = json [ "compiler Options " ] ; if ( json Options ) { for ( var id in json Options ) { if ( ts . has Property ( option Name Map , id ) ) { var opt = option Name Map [ id ] ; var opt Type = opt . type ; var value = json Options [ id ] ; var expected Type = typeof opt Type = = = "string " ? opt Type : "string " ; if ( typeof value = = = expected Type ) { if ( typeof opt Type ! = = "string " ) { var key = value . to Lower Case ( ) ; if ( ts . has Property ( opt Type , key ) ) { value = opt Type [ key ] ; } else { errors . push ( ts . create Compiler Diagnostic ( opt . error ) ) ; value = 0 ; } } if ( opt . is File Path ) { value = ts . normalize Path ( ts . combine Paths ( base Path , value ) ) ; if ( value = = = " " ) { value = " . " ; } } options [ opt . name ] = value ; } else { errors . push ( ts . create Compiler Diagnostic ( ts . Diagnostics . Compiler _option _ 0 _requires _a _value _of _type _ 1 , id , expected Type ) ) ; } } else { errors . push ( ts . create Compiler Diagnostic ( ts . Diagnostics . Unknown _compiler _option _ 0 , id ) ) ; } } } return options ; } function get File Names ( ) { var file Names = [ ] ; if ( ts . has Property ( json , "files " ) ) { if ( json [ "files " ] instanceof Array ) { file Names = ts . map ( json [ "files " ] , function ( s ) { return ts . combine Paths ( base Path , s ) ; } ) ; } else { errors . push ( ts . create Compiler Diagnostic ( ts . Diagnostics . Compiler _option _ 0 _requires _a _value _of _type _ 1 , "files " , "Array " ) ) ; } } else { var exclude = json [ "exclude " ] instanceof Array ? ts . map ( json [ "exclude " ] , ts . normalize Slashes ) : undefined ; var sys Files = host . read Directory ( base Path , " .ts " , exclude ) . concat ( host . read Directory ( base Path , " .tsx " , exclude ) ) ; for ( var i = 0 ; i < sys Files . length ; i + + ) { var name _ 2 8 = sys Files [ i ] ; if ( ts . file Extension Is ( name _ 2 8 , " .d .ts " ) ) { var base Name = name _ 2 8 . substr ( 0 , name _ 2 8 . length - " .d .ts " . length ) ; if ( ! ts . contains ( sys Files , base Name + " .tsx " ) & & ! ts . contains ( sys Files , base Name + " .ts " ) ) { file Names . push ( name _ 2 8 ) ; } } else if ( ts . file Extension Is ( name _ 2 8 , " .ts " ) ) { if ( ! ts . contains ( sys Files , name _ 2 8 + "x " ) ) { file Names . push ( name _ 2 8 ) ; } } else { file Names . push ( name _ 2 8 ) ; } } } return file Names ; } } 
function remove Dynamically Named Properties ( node ) { return ts . filter ( node . members , function ( member ) { return ! ts . has Dynamic Name ( member ) ; } ) ; } 
function pattern Match Compare To ( match 1 , match 2 ) { return compare Type ( match 1 , match 2 ) | | compare Camel Case ( match 1 , match 2 ) | | compare Case ( match 1 , match 2 ) | | compare Punctuation ( match 1 , match 2 ) ; } 
function index Of Ignoring Case ( string , value ) { for ( var i = 0 , n = string . length - value . length ; i < = n ; i + + ) { if ( starts With Ignoring Case ( string , value , i ) ) { return i ; } } return - 1 ; } 
function starts With Ignoring Case ( string , value , start ) { for ( var i = 0 , n = value . length ; i < n ; i + + ) { var ch 1 = to Lower Case ( string . char Code At ( i + start ) ) ; var ch 2 = value . char Code At ( i ) ; if ( ch 1 ! = = ch 2 ) { return false ; } } return true ; } 
function get Immediately Containing Argument Info ( node ) { if ( node . parent . kind = = = 1 6 8 | | node . parent . kind = = = 1 6 9 ) { var call Expression = node . parent ; 
function select Best Invalid Overload Index ( candidates , argument Count ) { var max Params Signature Index = - 1 ; var max Params = - 1 ; for ( var i = 0 ; i < candidates . length ; i + + ) { var candidate = candidates [ i ] ; if ( candidate . has Rest Parameter | | candidate . parameters . length > = argument Count ) { return i ; } if ( candidate . parameters . length > max Params ) { max Params = candidate . parameters . length ; max Params Signature Index = i ; } } return max Params Signature Index ; } 
function node Ends With ( n , expected Last Token , source File ) { var children = n . get Children ( source File ) ; if ( children . length ) { var last = ts . last Or Undefined ( children ) ; if ( last . kind = = = expected Last Token ) { return true ; } else if ( last . kind = = = 2 3 & & children . length ! = = 1 ) { return children [ children . length - 2 ] . kind = = = expected Last Token ; } } return false ; } 
function get Touching Word ( source File , position ) { return get Touching Token ( source File , position , function ( n ) { return is Word ( n . kind ) ; } ) ; } 
function get Touching Property Name ( source File , position ) { return get Touching Token ( source File , position , function ( n ) { return is Property Name ( n . kind ) ; } ) ; } 
function get Token At Position Worker ( source File , position , allow Position In Leading Trivia , include Item At End Position ) { var current = source File ; outer : while ( true ) { if ( is Token ( current ) ) { 
function find Token On Left Of Position ( file , position ) { 
function find Rightmost Child Node With Tokens ( children , exclusive Start Position ) { for ( var i = exclusive Start Position - 1 ; i > = 0 ; - - i ) { if ( node Has Tokens ( children [ i ] ) ) { return children [ i ] ; } } } 
function get Js Doc Tag At Position ( source File , position ) { var node = ts . get Token At Position ( source File , position ) ; if ( is Token ( node ) ) { switch ( node . kind ) { case 1 0 2 : case 1 0 8 : case 7 4 : 
function strip Quotes ( name ) { var length = name . length ; if ( length > = 2 & & name . char Code At ( 0 ) = = = name . char Code At ( length - 1 ) & & ( name . char Code At ( 0 ) = = = 3 4 | | name . char Code At ( 0 ) = = = 3 9 ) ) { return name . substring ( 1 , length - 1 ) ; } ; return name ; } 
function fix Token Kind ( token Info , container ) { if ( ts . is Token ( container ) & & token Info . token . kind ! = = container . kind ) { token Info . token . kind = container . kind ; } return token Info ; } 
function is List Element ( parent , node ) { switch ( parent . kind ) { case 2 1 4 : case 2 1 5 : return ts . range Contains Range ( parent . members , node ) ; case 2 1 8 : var body = parent . body ; return body & & body . kind = = = 1 9 2 & & ts . range Contains Range ( body . statements , node ) ; case 2 4 8 : case 1 9 2 : case 2 1 9 : return ts . range Contains Range ( parent . statements , node ) ; case 2 4 4 : return ts . range Contains Range ( parent . block . statements , node ) ; } return false ; } 
function find Enclosing Node ( range , source File ) { return find ( source File ) ; function find ( n ) { var candidate = ts . for Each Child ( n , function ( c ) { return ts . start End Contains Range ( c . get Start ( source File ) , c . end , range ) & & c ; } ) ; if ( candidate ) { var result = find ( candidate ) ; if ( result ) { return result ; } } return n ; } } 
function prepare Range Contains Error Function ( errors , original Range ) { if ( ! errors . length ) { return range Has No Errors ; } 
function get Own Or Inherited Delta ( n , options , source File ) { var previous Line = - 1 ; var child Kind = 0 ; while ( n ) { var line = source File . get Line And Character Of Position ( n . get Start ( source File ) ) . line ; if ( previous Line ! = = - 1 & & line ! = = previous Line ) { break ; } if ( formatting . Smart Indenter . should Indent Child Node ( n . kind , child Kind ) ) { return options . Indent Size ; } previous Line = line ; child Kind = n . kind ; n = n . parent ; } return 0 ; } 
function get Actual Indentation For List Item Before Comma ( comma Token , source File , options ) { 
function get Actual Indentation For Node ( current , parent , current Line And Char , parent And Child Share Line , source File , options ) { 
function find First Non Whitespace Character And Column ( start Pos , end Pos , source File , options ) { var character = 0 ; var column = 0 ; for ( var pos = start Pos ; pos < end Pos ; + + pos ) { var ch = source File . text . char Code At ( pos ) ; if ( ! ts . is White Space ( ch ) ) { break ; } if ( ch = = = 9 ) { column + = options . Tab Size + ( column % options . Tab Size ) ; } else { column + + ; } character + + ; } return { column : column , character : character } ; } 
function transpile Module ( input , transpile Options ) { var options = transpile Options . compiler Options ? ts . clone ( transpile Options . compiler Options ) : get Default Compiler Options ( ) ; options . isolated Modules = true ; 
function transpile ( input , compiler Options , file Name , diagnostics , module Name ) { var output = transpile Module ( input , { compiler Options : compiler Options , file Name : file Name , report Diagnostics : ! ! diagnostics , module Name : module Name } ) ; 
function get Target Label ( reference Node , label Name ) { while ( reference Node ) { if ( reference Node . kind = = = 2 0 7 & & reference Node . label . text = = = label Name ) { return reference Node . label ; } reference Node = reference Node . parent ; } return undefined ; } 
function is Name Of Property Assignment ( node ) { return ( node . kind = = = 6 9 | | node . kind = = = 9 | | node . kind = = = 8 ) & & ( node . parent . kind = = = 2 4 5 | | node . parent . kind = = = 2 4 6 ) & & node . parent . name = = = node ; } 
function is Inside Comment ( source File , token , position ) { 
function get Semantic Diagnostics ( file Name ) { synchronize Host Data ( ) ; var target Source File = get Valid Source File ( file Name ) ; 
function get Completion Entry Display Name ( name , target , perform Character Checks ) { if ( ! name ) { return undefined ; } name = ts . strip Quotes ( name ) ; if ( ! name ) { return undefined ; } 
function get Scope Node ( initial Token , position , source File ) { var scope = initial Token ; while ( scope & & ! ts . position Belongs To Node ( scope , position , source File ) ) { scope = scope . parent ; } return scope ; } 
function try Get Object Like Completion Symbols ( object Like Container ) { 
function try Get Import Or Export Clause Completion Symbols ( named Imports Or Exports ) { var declaration Kind = named Imports Or Exports . kind = = = 2 2 5 ? 2 2 2 : 2 2 8 ; var import Or Export Declaration = ts . get Ancestor ( named Imports Or Exports , declaration Kind ) ; var module Specifier = import Or Export Declaration . module Specifier ; if ( ! module Specifier ) { return false ; } is Member Completion = true ; is New Identifier Location = false ; var exports ; var module Specifier Symbol = type Checker . get Symbol At Location ( import Or Export Declaration . module Specifier ) ; if ( module Specifier Symbol ) { exports = type Checker . get Exports Of Module ( module Specifier Symbol ) ; } symbols = exports ? filter Named Import Or Export Completion Items ( exports , named Imports Or Exports . elements ) : empty Array ; return true ; } 
function try Get Object Like Completion Container ( context Token ) { if ( context Token ) { switch ( context Token . kind ) { case 1 5 : 
function filter Named Import Or Export Completion Items ( exports Of Module , named Imports Or Exports ) { var exising Imports Or Exports = { } ; for ( var _i = 0 ; _i < named Imports Or Exports . length ; _i + + ) { var element = named Imports Or Exports [ _i ] ; 
function filter Object Members List ( contextual Member Symbols , existing Members ) { if ( ! existing Members | | existing Members . length = = = 0 ) { return contextual Member Symbols ; } var existing Member Names = { } ; for ( var _i = 0 ; _i < existing Members . length ; _i + + ) { var m = existing Members [ _i ] ; 
function filter Jsx Attributes ( symbols , attributes ) { var seen Names = { } ; for ( var _i = 0 ; _i < attributes . length ; _i + + ) { var attr = attributes [ _i ] ; 
function get Symbol Kind ( symbol , location ) { var flags = symbol . get Flags ( ) ; if ( flags & 3 2 ) return ts . get Declaration Of Kind ( symbol , 1 8 6 ) ? Script Element Kind . local Class Element : Script Element Kind . class Element ; if ( flags & 3 8 4 ) return Script Element Kind . enum Element ; if ( flags & 5 2 4 2 8 8 ) return Script Element Kind . type Element ; if ( flags & 6 4 ) return Script Element Kind . interface Element ; if ( flags & 2 6 2 1 4 4 ) return Script Element Kind . type Parameter Element ; var result = get Symbol Kind Of Constructor Property Method Accessor Function Or Var ( symbol , flags , location ) ; if ( result = = = Script Element Kind . unknown ) { if ( flags & 2 6 2 1 4 4 ) return Script Element Kind . type Parameter Element ; if ( flags & 8 ) return Script Element Kind . variable Element ; if ( flags & 8 3 8 8 6 0 8 ) return Script Element Kind . alias ; if ( flags & 1 5 3 6 ) return Script Element Kind . module Element ; } return result ; } 
function get Definition At Position ( file Name , position ) { synchronize Host Data ( ) ; var source File = get Valid Source File ( file Name ) ; var node = ts . get Touching Property Name ( source File , position ) ; if ( ! node ) { return undefined ; } 
function aggregate Owned Throw Statements ( node ) { var statement Accumulator = [ ] ; aggregate ( node ) ; return statement Accumulator ; function aggregate ( node ) { if ( node . kind = = = 2 0 8 ) { statement Accumulator . push ( node ) ; } else if ( node . kind = = = 2 0 9 ) { var try Statement = node ; if ( try Statement . catch Clause ) { aggregate ( try Statement . catch Clause ) ; } else { 
function get Throw Statement Owner ( throw Statement ) { var child = throw Statement ; while ( child . parent ) { var parent _ 1 2 = child . parent ; if ( ts . is Function Block ( parent _ 1 2 ) | | parent _ 1 2 . kind = = = 2 4 8 ) { return parent _ 1 2 ; } 
function get References In Node ( container , search Symbol , search Text , search Location , search Meaning , find In Strings , find In Comments , result , symbol To Index ) { var source File = container . get Source File ( ) ; var triple Slash Directive Prefix Regex = / ^ \ / \ / \ / \s * < / ; var possible Positions = get Possible Symbol Reference Positions ( source File , search Text , container . get Start ( ) , container . get End ( ) ) ; if ( possible Positions . length ) { 
function get Intersecting Meaning From Declarations ( meaning , declarations ) { if ( declarations ) { var last Iteration Meaning ; do { 
function is Write Access ( node ) { if ( node . kind = = = 6 9 & & ts . is Declaration Name ( node ) ) { return true ; } var parent = node . parent ; if ( parent ) { if ( parent . kind = = = 1 8 0 | | parent . kind = = = 1 7 9 ) { return true ; } else if ( parent . kind = = = 1 8 1 & & parent . left = = = node ) { var operator = parent . operator Token . kind ; return 5 6 < = operator & & operator < = 6 8 ; } } return false ; } 
function get Navigate To Items ( search Value , max Result Count ) { synchronize Host Data ( ) ; return ts . Navigate To . get Navigate To Items ( program , cancellation Token , search Value , max Result Count ) ; } 
function get Signature Help Items ( file Name , position ) { synchronize Host Data ( ) ; var source File = get Valid Source File ( file Name ) ; return ts . Signature Help . get Signature Help Items ( program , source File , position , cancellation Token ) ; } 
function has Value Side Module ( symbol ) { return ts . for Each ( symbol . declarations , function ( declaration ) { return declaration . kind = = = 2 1 8 & & ts . get Module Instance State ( declaration ) = = = 1 ; } ) ; } 
function classify Token Type ( token Kind , token ) { if ( ts . is Keyword ( token Kind ) ) { return 3 ; } 
function get Parameters From Right Hand Side Of Assignment ( right Hand Side ) { while ( right Hand Side . kind = = = 1 7 2 ) { right Hand Side = right Hand Side . expression ; } switch ( right Hand Side . kind ) { case 1 7 3 : case 1 7 4 : return right Hand Side . parameters ; case 1 8 6 : for ( var _i = 0 , _a = right Hand Side . members ; _i < _a . length ; _i + + ) { var member = _a [ _i ] ; if ( member . kind = = = 1 4 4 ) { return member . parameters ; } } break ; } return empty Array ; } 
function get Default Lib File Path ( options ) { 
function span In Open Brace Token ( node ) { switch ( node . parent . kind ) { case 2 1 7 : var enum Declaration = node . parent ; return span In Node If Starts On Same Line ( ts . find Preceding Token ( node . pos , source File , node . parent ) , enum Declaration . members . length ? enum Declaration . members [ 0 ] : enum Declaration . get Last Token ( source File ) ) ; case 2 1 4 : var class Declaration = node . parent ; return span In Node If Starts On Same Line ( ts . find Preceding Token ( node . pos , source File , node . parent ) , class Declaration . members . length ? class Declaration . members [ 0 ] : class Declaration . get Last Token ( source File ) ) ; case 2 2 0 : return span In Node If Starts On Same Line ( node . parent . parent , node . parent . clauses [ 0 ] ) ; } 
async function serve GUI ( url ) { let res , file Type ; const header Content Types = { 'html ' : 'text /html ' , 'js ' : 'application /javascript ' , 'css ' : 'text /css ' } const pathname = ( url . pathname = = = ' / ' ) ? ' /index .html ' : url . pathname ; res = await fetch ( 'file : / /build ' + pathname ) ; file Type = pathname . split ( ' . ' ) . pop ( ) ; if ( res . status = = = 2 0 0 & & Object . keys ( header Content Types ) . includes ( file Type ) ) { let file Text = await res . text ( ) ; return { data : file Text , status : 2 0 0 , content Type : header Content Types [ file Type ] } ; } return { data : " <p >Not found . < /p > " , status : 4 0 4 , content Type : "text /html " } ; } 
async function get Git Hub Data ( req , url ) { let cache Key = " " , query String = " " ; let req String = await req . text ( ) ; const client = new Graph QLClient ( 'https : / /api .github .com /graphql ' , { headers : { 'User -Agent ' : req . headers . get ( 'User -Agent ' ) | | app . config . user Agent , 'Authorization ' : req . headers . get ( 'Authorization ' ) | | 'Bearer ' + app . config . user Token } } ) ; 
function add Required Query Fields ( query ) { let string Condensed = query . replace ( / \s + / g , " " ) ; let starti = string Condensed . index Of ( 'node { ' ) + 6 ; let endi = string Condensed . index Of ( ' } ' , starti ) ; let current Params = ( string Condensed . substring ( starti , endi ) ) . split ( " " ) ; const required Params = [ "id " , "number " , "title " , "body Text " ] ; required Params . for Each ( function ( p ) { if ( ! current Params . includes ( p ) ) { current Params . push ( p ) } } ) ; current Params = current Params . join ( " " ) ; return string Condensed . substr ( 0 , starti ) + current Params + string Condensed . substr ( endi ) ; } 
async function get Issues ( query , client , cache Key ) { let data , data String , data Json , status , cached Response = null ; if ( cache Key ) { cached Response = await cache . get String ( cache Key ) ; } if ( cached Response ! = = null ) { status = 2 0 0 ; data String = cached Response ; return { data String , status } ; } else { 
function get Sentiment ( response ) { const issues To Evaluate = response . repository . issues . edges ; for ( let i = issues To Evaluate . length - 1 ; i > = 0 ; i - - ) { let sent = polarity ( ( issues To Evaluate [ i ] . node . title + " " + issues To Evaluate [ i ] . node . body Text ) . split ( " " ) ) ; issues To Evaluate [ i ] . node . sentiment = sent ; } ; return response ; } 
function balancer ( backends ) { const tracked = backends . map ( ( h ) = > { if ( typeof h ! = = "function " ) { throw Error ( "Backend must be a fetch like function " ) ; } return { proxy : h , request Count : 0 , scored Request Count : 0 , statuses : Array ( 1 0 ) , last Error : 0 , health Score : 1 , error Count : 0 } ; } ) ; const fn = async function fetch Balancer ( req , init ) { if ( typeof req = = = "string " ) { req = new Request ( req ) ; } const attempted = new Set ( ) ; while ( attempted . size < tracked . length ) { let backend = null ; const [ backend A , backend B ] = choose Backends ( tracked , attempted ) ; if ( ! backend A ) { return new Response ( "No backend available " , { status : 5 0 2 } ) ; } if ( ! backend B ) { backend = backend A ; } else { 
function score ( backend , error Basis ) { if ( typeof error Basis ! = = "number " & & ! error Basis ) error Basis = Date . now ( ) ; const time Since Error = ( error Basis - backend . last Error ) ; const statuses = backend . statuses ; const time Weight = ( backend . last Error = = = 0 & & 0 ) | | ( ( time Since Error < 1 0 0 0 ) & & 1 ) | | ( ( time Since Error < 3 0 0 0 ) & & 0 . 8 ) | | ( ( time Since Error < 5 0 0 0 ) & & 0 . 3 ) | | ( ( time Since Error < 1 0 0 0 0 ) & & 0 . 1 ) | | 0 ; if ( statuses . length = = 0 ) return 0 ; let requests = 0 ; let errors = 0 ; for ( let i = 0 ; i < statuses . length ; i + + ) { const status = statuses [ i ] ; if ( status & & ! is Na N ( status ) ) { requests + = 1 ; if ( status > = 5 0 0 & & status < 6 0 0 ) { errors + = 1 ; } } } const score = ( 1 - ( time Weight * ( errors / requests ) ) ) ; backend . health Score = score ; backend . scored Request Count = backend . request Count ; return score ; } 
async function origin ( req , init ) { const url = new URL ( req . url ) const status = parse Int ( url . search Params . get ( 'status ' ) | | ' 2 0 0 ' ) if ( status = = = 2 0 0 ) { return new Response ( ` $ { req . url } $ { new Date ( ) } ` ) } else { return new Response ( ` $ { status } ` , { status : status } ) } } 
async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case " / " : return new Response ( ` $ { new Date ( ) } ` , { headers : { "Cache -Control " : "max -age = 6 0 0 " } } ) case " /never -cache " : return new Response ( ` $ { new Date ( ) } ` ) } return new Response ( "not found " , { status : 4 0 4 } ) } 
function ( dest , src ) { return gulp . src ( src ) . pipe ( sourcemaps . init ( ) ) . pipe ( concat ( dest ) ) . pipe ( gulp . dest ( path . join ( 'dist ' , 'js ' ) ) ) . pipe ( uglify ( ) ) . pipe ( rename ( { suffix : ' .min ' } ) ) . pipe ( sourcemaps . write ( ' . ' ) ) . pipe ( gulp . dest ( path . join ( 'dist ' , 'js ' ) ) ) ; } 
function ( element , transform , touch ) { 
function ( scope , id , options ) { options = options | | { } ; var is New Scope = scopes [ scope ] = = = undefined ; var default Value = options . default Value ; var exclusion Group = options . exclusion Group ; scopes [ scope . $id ] = scopes [ scope . $id ] | | [ ] ; scopes [ scope . $id ] . push ( id ) ; if ( ! statuses Meta [ id ] ) { 
function ( id , value ) { if ( statuses Meta [ id ] ! = = undefined ) { var prev = values [ id ] ; values [ id ] = value ; if ( prev ! = = value ) { $root Scope . $broadcast ( 'mobile -angular -ui .state .changed . ' + id , value , prev ) ; } return value ; } $log . warn ( 'Warning : Attempt to set uninitialized shared state : ' + id ) ; } 
function ( id Or Map , value ) { if ( ! id Or Map ) { return ; } else if ( angular . is Object ( id Or Map ) ) { this . set Many ( id Or Map ) ; } else { this . set One ( id Or Map , value ) ; } } 
function ( id ) { 
function ( elem , attrs ) { var attr = attrs [ directive Name ] ; var needs Interpolation = attr . match ( / \ { \ { / ) ; var expr Fn = function ( $scope ) { var res = attr ; if ( needs Interpolation ) { var interpolate Fn = $interpolate ( res ) ; res = interpolate Fn ( $scope ) ; } if ( method Name = = = 'set ' ) { res = ( $parse ( res ) ) ( $scope ) ; } return res ; } ; return function ( scope , elem , attrs ) { var callback = function ( ) { var arg = expr Fn ( scope ) ; return method . call ( Shared State , arg ) ; } ; ui Bind Event ( scope , elem , attrs . ui Triggers , callback ) ; } ; } 
function ( attr ) { if ( ! attr | | attr = = = ' ' ) { return [ ] ; } var vars = attr ? attr . trim ( ) . split ( / * , * / ) : [ ] ; var res = [ ] ; for ( var i = 0 ; i < vars . length ; i + + ) { var item = vars [ i ] . split ( / *as * / ) ; if ( item . length > 2 | | item . length < 1 ) { throw new Error ( 'Error parsing ui Scope Context = " ' + attr + ' " ' ) ; } res . push ( item ) ; } return res ; } 
function ( val ) { inputs = elem . query Selector All ( "textarea , input " ) ; for ( var i = 0 , il = inputs . length ; i < il ; i + + ) { inputs [ i ] . style . pointer Events = val ; } } 
function ( start Event , ascend ) { if ( doc . create Event ) { var new Target = ( ! ascend | | ascend = = = undefined ) & & elem . parent Node | | elem . touchchild | | elem , t End ; if ( new Target ! = = elem ) { t End = doc . create Event ( "HTMLEvents " ) ; t End . init Event ( "touchend " , true , true ) ; elem . dispatch Event ( t End ) ; new Target . touchchild = elem ; elem = new Target ; new Target . dispatch Event ( start Event ) ; } } } 
function ( e ) { 
function ( $element , drag Options , touch Options ) { $element = angular . element ( $element ) ; drag Options = drag Options | | { } ; touch Options = touch Options | | { } ; var start Event Handler = drag Options . start ; var end Event Handler = drag Options . end ; var move Event Handler = drag Options . move ; var cancel Event Handler = drag Options . cancel ; var transform Event Handler = drag Options . transform | | this . TRANSLATE _BOTH ; var dom Element = $element [ 0 ] ; var t O = $transform . get ( $element ) ; 
function ( t ) { var abs Angle = abs ( t . angle ) ; abs Angle = abs Angle > = 9 0 ? abs Angle - 9 0 : abs Angle ; var valid Distance = t . total - t . distance < = TURNAROUND _MAX ; var valid Angle = abs Angle < = ANGLE _THRESHOLD | | abs Angle > = 9 0 - ANGLE _THRESHOLD ; var valid Velocity = t . average Velocity > = VELOCITY _THRESHOLD ; return valid Distance & & valid Angle & & valid Velocity ; } 
function ( element , event Handlers , options ) { options = angular . extend ( { } , default Options , options | | { } ) ; return $touch . bind ( element , event Handlers , options ) ; } 
function ( type , c , t 0 , tl ) { 
function ( event ) { 
function ( e ) { e = e . length ? e [ 0 ] : e ; var tr = window . get Computed Style ( e , null ) . get Property Value ( transform Property ) ; return tr ; } 
function ( elem , value ) { elem = elem . length ? elem [ 0 ] : elem ; elem . style [ style Property ] = value ; } 
function ( e , t ) { var str = ( typeof t = = = 'string ' ) ? t : this . to Css ( t ) ; set Element Transform Property ( e , str ) ; } 
function ( _path ) { if ( / ^ ( (pre |post ) ?loader )s ? / ig . test ( _path ) ) { return _path . replace ( / ^ ( (pre |post ) ?loader )s ? / ig , 'module . $ 1s ' ) } if ( / ^ (plugin )s ? / g . test ( _path ) ) { return _path . replace ( / ^ (plugin )s ? / g , ' $ 1s ' ) } return _path } 
function ( extend , cooking , options ) { require ( ` $ { extend } ` ) ( cooking , options ) logger . success ( ` $ { extend } ` ) } 
function get Payload ( token ) { const payload Base 6 4 = token . split ( " . " ) [ 1 ] . replace ( " - " , " + " ) . replace ( " _ " , " / " ) ; const payload Decoded = base 6 4 . decode ( payload Base 6 4 ) ; const payload Object = JSON . parse ( payload Decoded ) ; if ( AV . is Number ( payload Object . exp ) ) { payload Object . exp = new Date ( payload Object . exp * 1 0 0 0 ) ; } return payload Object ; } 
function SDK ( options = { } ) { let token ; let url ; let project = " _ " ; let local Exp ; let token Expiry Time = 5 ; if ( options . storage ) { let stored Info = options . storage . get Item ( "directus -sdk -js " ) ; if ( stored Info ) { stored Info = JSON . parse ( stored Info ) ; token = stored Info . token ; url = stored Info . url ; project = stored Info . project ; local Exp = stored Info . local Exp ; } } if ( options . token ) { token = options . token ; } if ( options . url ) { url = options . url ; } if ( options . project ) { project = options . project ; } if ( options . local Exp ) { local Exp = options . local Exp ; } if ( options . token Expiry Time ) { token Expiry Time = options . token Expiry Time ; } const SDK = { url : url , token : token , project : project , * Directus API request promise * @promise Request Promise * @fulfill {object } Directus data * @reject {Error } Network error (if no connection to API ) * @reject {Error } Directus error (eg not logged in or 4 0 4 ) * / request ( method , endpoint , params = { } , data = { } , no Env = false , headers = { } , ignore Json = false ) { AV . string ( method , "method " ) ; AV . string ( endpoint , "endpoint " ) ; AV . object Or Empty ( params , "params " ) ; Array . is Array ( data ) ? AV . array Or Empty ( data , "data " ) : AV . object Or Empty ( data , "data " ) ; AV . string ( this . url , "this .url " ) ; let base URL = ` $ { this . url } ` ; if ( no Env = = = false ) { base URL + = ` $ { this . project } ` ; } const request Options = { url : endpoint , method , base URL , params , data } ; if ( this . token & & typeof this . token = = = "string " & & this . token . length > 0 ) { request Options . headers = headers ; request Options . headers . Authorization = ` $ { this . token } ` ; } return this . axios . request ( request Options ) . then ( res = > res . data ) . then ( data = > { if ( ! data | | data . length = = = 0 ) return data ; if ( ignore Json ) return data ; if ( typeof data ! = = "object " ) { try { return JSON . parse ( data ) ; } catch ( error ) { throw { json : true , error , data } ; } } return data ; } ) . catch ( error = > { if ( error . response ) { throw error . response . data . error ; } else if ( error . json = = = true ) { throw { * GET convenience method . Calls the request method for you * @param {string } endpoint The endpoint to get * @param {Object } [params = { } ] The HTTP query parameters (GET only ) * @return {Request Promise } * / get ( endpoint , params = { } ) { AV . string ( endpoint , "endpoint " ) ; AV . object Or Empty ( params , "params " ) ; return this . request ( "get " , endpoint , params ) ; } , post ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint " ) ; Array . is Array ( body ) ? AV . array Or Empty ( body , "body " ) : AV . object Or Empty ( body , "body " ) ; return this . request ( "post " , endpoint , params , body ) ; } , patch ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint " ) ; Array . is Array ( body ) ? AV . array Or Empty ( body , "body " ) : AV . object Or Empty ( body , "body " ) ; return this . request ( "patch " , endpoint , params , body ) ; } , put ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint " ) ; Array . is Array ( body ) ? AV . array Or Empty ( body , "body " ) : AV . object Or Empty ( body , "body " ) ; return this . request ( "put " , endpoint , params , body ) ; } , delete ( endpoint ) { AV . string ( endpoint , "endpoint " ) ; return this . request ( "delete " , endpoint ) ; } , * Logging in promise * @promise Login Promise * @fulfill {Object } Object containing URL , ENV , and TOKEN * @reject {Error } Network error (if no connection to API ) * @reject {Error } Directus error (eg not logged in or 4 0 4 ) * / login ( credentials , options = { persist : true } ) { AV . object ( credentials , "credentials " ) ; AV . keys With String ( credentials , [ "email " , "password " ] , "credentials " ) ; this . token = null ; if ( AV . has Keys With String ( credentials , [ "url " ] ) ) { this . url = credentials . url ; } if ( AV . has Keys With String ( credentials , [ "project " ] ) ) { this . project = credentials . project ; } if ( credentials . persist | | options . persist ) { this . start Interval ( ) ; } return new Promise ( ( resolve , reject ) = > { this . post ( " /auth /authenticate " , { email : credentials . email , password : credentials . password } ) . then ( res = > res . data . token ) . then ( token = > { this . token = token ; * Logs the user out by "forgetting " the token , and clearing the refresh interval * / logout ( ) { this . token = null ; if ( this . refresh Interval ) { this . stop Interval ( ) ; } if ( this . storage ) { this . storage . remove Item ( "directus -sdk -js " ) ; } } , reset ( ) { this . logout ( ) ; this . url = null ; this . project = null ; } , start Interval ( fire Immediately ) { if ( fire Immediately ) this . refresh If Needed ( ) ; this . refresh Interval = set Interval ( this . refresh If Needed . bind ( this ) , 1 0 0 0 0 ) ; } , stop Interval ( ) { clear Interval ( this . refresh Interval ) ; this . refresh Interval = null ; } , refresh If Needed ( ) { if ( ! AV . has String Keys ( this , [ "token " , "url " , "project " ] ) ) return ; if ( ! this . payload | | ! this . payload . exp ) return ; const time Diff = this . local Exp - Date . now ( ) ; if ( time Diff < = 0 ) { if ( AV . is Function ( this . on Auto Refresh Error ) ) { this . on Auto Refresh Error ( { message : "auth _expired _token " , code : 1 0 2 } ) ; } return ; } if ( time Diff < 3 0 0 0 0 ) { this . refresh ( this . token ) . then ( res = > { this . token = res . data . token ; this . local Exp = new Date ( Date . now ( ) + this . token Expiry Time * 6 0 0 0 0 ) . get Time ( ) ; if ( AV . is Function ( this . on Auto Refresh Success ) ) { this . on Auto Refresh Success ( { url : this . url , project : this . project , token : this . token , local Exp : this . local Exp } ) ; } if ( this . storage ) { this . storage . set Item ( "directus -sdk -js " , JSON . stringify ( { token : this . token , url : this . url , project : this . project , local Exp : this . local Exp } ) ) ; } } ) . catch ( error = > { if ( AV . is Function ( this . on Auto Refresh Error ) ) { this . on Auto Refresh Error ( error ) ; } } ) ; } } , refresh ( token ) { AV . string ( token , "token " ) ; return this . post ( " /auth /refresh " , { token } ) ; } , request Password Reset ( email ) { AV . string ( email , "email " ) ; return this . post ( " /auth /password /request " , { email : email } ) ; } , * Get activity * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Activity ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /activity " , params ) ; } , * Get the bookmarks of the current user * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get My Bookmarks ( params = { } ) { AV . string ( this . token , "this .token " ) ; AV . object Or Empty ( params ) ; return Promise . all ( [ this . get ( " /collection _presets " , { "filter [title ] [nnull ] " : 1 , "filter [user ] [eq ] " : this . payload . id } ) , this . get ( " /collection _presets " , { "filter [title ] [nnull ] " : 1 , "filter [role ] [eq ] " : this . payload . role , "filter [user ] [null ] " : 1 } ) ] ) . then ( values = > { const [ user , role ] = values ; * Get all available collections * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Collections ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /collections " , params ) ; } , get Collection ( collection , params = { } ) { AV . string ( collection , "collection " ) ; AV . object Or Empty ( params , "params " ) ; return this . get ( ` $ { collection } ` , params ) ; } , create Collection ( data ) { AV . object ( data , "data " ) ; return this . post ( " /collections " , data ) ; } , update Collection ( collection , data ) { AV . string ( collection , "collection " ) ; AV . object ( data , "data " ) ; return this . patch ( ` $ { collection } ` , data ) ; } , delete Collection ( collection ) { AV . string ( collection , "collection " ) ; return this . delete ( ` $ { collection } ` ) ; } , * Create a new collection preset (bookmark / listing preferences ) * @param {Object } data The bookmark info * @return {Request Promise } * / create Collection Preset ( data ) { AV . object ( data ) ; return this . post ( " /collection _presets " , data ) ; } , update Collection Preset ( primary Key , data ) { AV . not Null ( primary Key , "primary Key " ) ; AV . object ( data , "data " ) ; return this . patch ( ` $ { primary Key } ` , data ) ; } , delete Collection Preset ( primary Key ) { AV . not Null ( primary Key , "primary Key " ) ; return this . delete ( ` $ { primary Key } ` ) ; } , * This will update the database of the API instance to the latest version * using the migrations in the API * @return {Request Promise } * / update Database ( ) { return this . post ( " /update " ) ; } , * Get the meta information of all installed interfaces * @return {Request Promise } * / get Interfaces ( ) { return this . request ( "get " , " /interfaces " , { } , { } , true ) ; } , get Layouts ( ) { return this . request ( "get " , " /layouts " , { } , { } , true ) ; } , get Pages ( ) { return this . request ( "get " , " /pages " , { } , { } , true ) ; } , * Get all fields that are in Directus * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get All Fields ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /fields " , params ) ; } , get Fields ( collection , params = { } ) { AV . string ( collection , "collection " ) ; AV . object Or Empty ( params , "params " ) ; return this . get ( ` $ { collection } ` , params ) ; } , get Field ( collection , field Name , params = { } ) { AV . string ( collection , "collection " ) ; AV . string ( field Name , "field Name " ) ; AV . object Or Empty ( params , "params " ) ; return this . get ( ` $ { collection } $ { field Name } ` , params ) ; } , create Field ( collection , field Info ) { AV . string ( collection , "collection " ) ; AV . object ( field Info , "field Info " ) ; return this . post ( ` $ { collection } ` , field Info ) ; } , update Field ( collection , field Name , field Info ) { AV . string ( collection , "collection " ) ; AV . string ( field Name , "field Name " ) ; AV . object ( field Info , "field Info " ) ; return this . patch ( ` $ { collection } $ { field Name } ` , field Info ) ; } , update Fields ( collection , fields Info Or Field Names , field Info = null ) { AV . string ( collection , "collection " ) ; AV . array ( fields Info Or Field Names , "fields Info Or Field Names " ) ; if ( field Info ) { AV . object ( field Info ) ; } if ( field Info ) { return this . patch ( ` $ { collection } $ { fields Info Or Field Names . join ( " , " ) } ` , field Info ) ; } return this . patch ( ` $ { collection } ` , fields Info Or Field Names ) ; } , delete Field ( collection , field Name ) { AV . string ( collection , "collection " ) ; AV . string ( field Name , "field Name " ) ; return this . delete ( ` $ { collection } $ { field Name } ` ) ; } , * Upload multipart files in multipart /form -data * @param {Object } data Form Data object containing files * @return {Request Promise } * / upload Files ( data , on Upload Progress = ( ) = > { } ) { const headers = { "Content -Type " : "multipart /form -data " , Authorization : ` $ { this . token } ` } ; return this . axios . post ( ` $ { this . url } $ { this . project } ` , data , { headers , on Upload Progress } ) . then ( res = > res . data ) . catch ( error = > { if ( error . response ) { throw error . response . data . error ; } else { throw { * Update an existing item * @param {String } collection The collection to add the item to * @param {String |Number } primary Key Primary key of the item * @param {Object } body The item 's field values * @param {Object } params Query parameters * @return {Request Promise } * / update Item ( collection , primary Key , body , params = { } ) { AV . string ( collection , "collection " ) ; AV . not Null ( primary Key , "primary Key " ) ; AV . object ( body , "body " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . patch ( ` $ { collection . substring ( 9 ) } $ { primary Key } ` , body , params ) ; } return this . patch ( ` $ { collection } $ { primary Key } ` , body , params ) ; } , / * * * Update multiple items * @param {String } collection The collection to add the item to * @param {Array } body The item 's field values * @param {Object } params Query Parameters * @return {Request Promise } * / update Items ( collection , body , params = { } ) { AV . string ( collection , "collection " ) ; AV . array ( body , "body " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . patch ( ` $ { collection . substring ( 9 ) } ` , body , params ) ; } return this . patch ( ` $ { collection } ` , body , params ) ; } , create Item ( collection , body ) { AV . string ( collection , "collection " ) ; AV . object ( body , "body " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . post ( ` $ { collection . substring ( 9 ) } ` , body ) ; } return this . post ( ` $ { collection } ` , body ) ; } , create Items ( collection , body ) { AV . string ( collection , "collection " ) ; AV . array ( body , "body " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . post ( ` $ { collection . substring ( 9 ) } ` , body ) ; } return this . post ( ` $ { collection } ` , body ) ; } , get Items ( collection , params = { } ) { AV . string ( collection , "collection " ) ; AV . object Or Empty ( params , "params " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . get ( ` $ { collection . substring ( 9 ) } ` , params ) ; } return this . get ( ` $ { collection } ` , params ) ; } , get Item ( collection , primary Key , params = { } ) { AV . string ( collection , "collection " ) ; AV . not Null ( primary Key , "primary Key " ) ; AV . object Or Empty ( params , "params " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . get ( ` $ { collection . substring ( 9 ) } $ { primary Key } ` , params ) ; } return this . get ( ` $ { collection } $ { primary Key } ` , params ) ; } , delete Item ( collection , primary Key ) { AV . string ( collection , "collection " ) ; AV . not Null ( primary Key , "primary Key " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . delete ( ` $ { collection . substring ( 9 ) } $ { primary Key } ` ) ; } return this . delete ( ` $ { collection } $ { primary Key } ` ) ; } , delete Items ( collection , primary Keys ) { AV . string ( collection , "collection " ) ; AV . array ( primary Keys , "primary Keys " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . delete ( ` $ { collection . substring ( 9 ) } $ { primary Keys . join ( ) } ` ) ; } return this . delete ( ` $ { collection } $ { primary Keys . join ( ) } ` ) ; } , * Get the collection presets of the current user for a single collection * @param {String } collection Collection to fetch the preferences for * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get My Listing Preferences ( collection , params = { } ) { AV . string ( this . token , "this .token " ) ; AV . object Or Empty ( params , "params " ) ; return Promise . all ( [ this . get ( " /collection _presets " , { limit : 1 , "filter [title ] [null ] " : 1 , "filter [collection ] [eq ] " : collection , "filter [role ] [null ] " : 1 , "filter [user ] [null ] " : 1 , sort : " -id " } ) , this . get ( " /collection _presets " , { limit : 1 , "filter [title ] [null ] " : 1 , "filter [collection ] [eq ] " : collection , "filter [role ] [eq ] " : this . payload . role , "filter [user ] [null ] " : 1 , sort : " -id " } ) , this . get ( " /collection _presets " , { limit : 1 , "filter [title ] [null ] " : 1 , "filter [collection ] [eq ] " : collection , "filter [role ] [eq ] " : this . payload . role , "filter [user ] [eq ] " : this . payload . id , sort : " -id " } ) ] ) . then ( values = > { const [ collection , role , user ] = values ; * Get permissions * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Permissions ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get Items ( "directus _permissions " , params ) ; } , get My Permissions ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /permissions /me " , params ) ; } , create Permissions ( data ) { AV . array ( data ) ; return this . post ( " /permissions " , data ) ; } , update Permissions ( data ) { AV . array ( data ) ; return this . patch ( " /permissions " , data ) ; } , * Get all relationships * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Relations ( params = { } ) { AV . object Or Empty ( params ) ; return this . get ( " /relations " , params ) ; } , create Relation ( data ) { return this . post ( " /relations " , data ) ; } , update Relation ( primary Key , data ) { return this . patch ( ` $ { primary Key } ` , data ) ; } , get Collection Relations ( collection , params = { } ) { AV . string ( collection , "collection " ) ; AV . object Or Empty ( params ) ; return Promise . all ( [ this . get ( " /relations " , { "filter [collection _a ] [eq ] " : collection } ) , this . get ( " /relations " , { "filter [collection _b ] [eq ] " : collection } ) ] ) ; } , * Get a single item 's revisions by primary key * @param {String } collection The collection to fetch the revisions from * @param {String |Number } primary Key Primary key of the item * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Item Revisions ( collection , primary Key , params = { } ) { AV . string ( collection , "collection " ) ; AV . not Null ( primary Key , "primary Key " ) ; AV . object Or Empty ( params , "params " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . get ( ` $ { collection . substring ( 9 ) } $ { primary Key } ` , params ) ; } return this . get ( ` $ { collection } $ { primary Key } ` , params ) ; } , / * * * revert an item to a previous state * @param {String } collection The collection to fetch the revisions from * @param {String |Number } primary Key Primary key of the item * @param {Number } revision ID The ID of the revision to revert to * @return {Request Promise } * / revert ( collection , primary Key , revision ID ) { AV . string ( collection , "collection " ) ; AV . not Null ( primary Key , "primary Key " ) ; AV . number ( revision ID , "revision ID " ) ; if ( collection . starts With ( "directus _ " ) ) { return this . patch ( ` $ { collection . substring ( 9 ) } $ { primary Key } $ { revision ID } ` ) ; } return this . patch ( ` $ { collection } $ { primary Key } $ { revision ID } ` ) ; } , / / ROLES / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - / * * * Get a single user role * @param {Number } primary Key The id of the user rol to get * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Role ( primary Key , params = { } ) { AV . number ( primary Key , "primary Key " ) ; AV . object Or Empty ( params , "params " ) ; return this . get ( ` $ { primary Key } ` , params ) ; } , / * * * Get the user roles * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Roles ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /roles " , params ) ; } , / * * * Update a user role * @param {Number } primary Key The ID of the role * @param {Object } body The fields to update * @return {Request Promise } * / update Role ( primary Key , body ) { AV . not Null ( primary Key , "primary Key " ) ; AV . object ( body , "body " ) ; return this . update Item ( "directus _roles " , primary Key , body ) ; } , / * * * Create a new user role * @param {Object } body The role information * @return {Request Promise } * / create Role ( body ) { AV . object ( body , "body " ) ; return this . create Item ( "directus _roles " , body ) ; } , / * * * Delete a user rol by primary key * @param {Number | String } primary Key Primary key of the user role * @return {Request Promise } * / delete Role ( primary Key ) { AV . not Null ( primary Key , "primary Key " ) ; return this . delete Item ( "directus _roles " , primary Key ) ; } , / / SETTINGS / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - / * * * Get Directus ' global settings * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Settings ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /settings " , params ) ; } , get Settings Fields ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /settings /fields " , params ) ; } , * Get a list of available users in Directus * @param {Object } [params = { } ] Query parameters * @return {Request Promise } * / get Users ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /users " , params ) ; } , get User ( primary Key , params = { } ) { AV . not Null ( primary Key , "primary Key " ) ; AV . object Or Empty ( params , "params " ) ; return this . get ( ` $ { primary Key } ` , params ) ; } , get Me ( params = { } ) { AV . object Or Empty ( params , "params " ) ; return this . get ( " /users /me " , params ) ; } , update User ( primary Key , body ) { AV . not Null ( primary Key , "primary Key " ) ; AV . object ( body , "body " ) ; return this . update Item ( "directus _users " , primary Key , body ) ; } , * Ping the API to check if it exists / is up and running * @return {Request Promise } * / ping ( ) { return this . request ( "get " , " /server /ping " , { } , { } , true , true ) ; } , server Info ( ) { return this . request ( "get " , " / " , { } , { } , true ) ; } , project Info ( ) { return this . request ( "get " , " / " ) ; } , get Third Party Auth Providers ( ) { return this . get ( " /auth /sso " ) ; } } ; 
function scroll To Hash ( hash ) { var $scroller = get Scroller ( ) , dest = 0 ; 
function get Element Top Position ( id ) { 
function set Chapter Active ( $chapter , hash ) { 
function get Chapter Hash ( $chapter ) { var $link = $chapter . children ( 'a ' ) , hash = $link . attr ( 'href ' ) . split ( ' # ' ) [ 1 ] ; if ( hash ) hash = ' # ' + hash ; return ( ! ! hash ) ? hash : ' ' ; } 
function handle Scrolling ( ) { 
function handle Link Click ( e ) { var $this = $ ( this ) ; var target = $this . attr ( 'target ' ) ; if ( is Modified Event ( e ) | | ! is Left Click Event ( e ) | | target ) { return ; } e . stop Propagation ( ) ; e . prevent Default ( ) ; var url = $this . attr ( 'href ' ) ; if ( url ) handle Navigation ( url , true ) ; } 
function insert At ( parent , selector , index , element ) { var last Index = parent . children ( selector ) . length ; if ( index < 0 ) { index = Math . max ( 0 , last Index + 1 + index ) ; } parent . append ( element ) ; if ( index < last Index ) { parent . children ( selector ) . eq ( index ) . before ( parent . children ( selector ) . last ( ) ) ; } } 
function create Dropdown Menu ( dropdown ) { var $menu = $ ( ' <div > ' , { 'class ' : 'dropdown -menu ' , 'html ' : ' <div class = "dropdown -caret " > <span class = "caret -outer " > < /span > <span class = "caret -inner " > < /span > < /div > ' } ) ; if ( typeof dropdown = = 'string ' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . is Array ( group ) ) return group ; else return [ group ] ; } ) ; 
function create Button ( opts ) { opts = $ . extend ( { 
function remove Button ( id ) { buttons = $ . grep ( buttons , function ( button ) { return button . id ! = id ; } ) ; update All Buttons ( ) ; } 
function remove Buttons ( ids ) { buttons = $ . grep ( buttons , function ( button ) { return ids . index Of ( button . id ) = = - 1 ; } ) ; update All Buttons ( ) ; } 
function toggle Sidebar ( _state , animation ) { if ( gitbook . state ! = null & & is Open ( ) = = _state ) return ; if ( animation = = null ) animation = true ; gitbook . state . $book . toggle Class ( 'without -animation ' , ! animation ) ; gitbook . state . $book . toggle Class ( 'with -summary ' , _state ) ; gitbook . storage . set ( 'sidebar ' , is Open ( ) ) ; } 
function init ( ) { 
function filter Summary ( paths ) { var $summary = $ ( ' .book -summary ' ) ; $summary . find ( 'li ' ) . each ( function ( ) { var path = $ ( this ) . data ( 'path ' ) ; var st = paths = = null | | paths . index Of ( path ) ! = = - 1 ; $ ( this ) . toggle ( st ) ; if ( st ) $ ( this ) . parents ( 'li ' ) . show ( ) ; } ) ; } 
function init ( ) { $ ( document ) . on ( 'click ' , ' .toggle -dropdown ' , toggle Dropdown ) ; $ ( document ) . on ( 'click ' , ' .dropdown -menu ' , function ( e ) { e . stop Propagation ( ) ; } ) ; $ ( document ) . on ( 'click ' , close Dropdown ) ; } 
function init ( ) { 
function has Changed ( ctx ) { console . log ( 'page has changed ' , ctx ) ; 
function set State ( new State ) { 
function add Directive ( type ) { return function ( name , directive ) { if ( typeof name = = = 'function ' ) { directive = name } if ( typeof directive ! = = 'function ' ) { throw new Type Error ( 'Directive must be a function ' ) } name = typeof name = = = 'string ' ? name : directive . name if ( ! name ) { throw new Type Error ( 'Directive function must have a name ' ) } directive . $name = name Toxy [ type ] [ name ] = directive return Toxy } } 
function outgoing Interceptor ( proxy ) { const response Body = rocky . middleware . response Body response Body . $name = ' $outgoing Interceptor $ ' const interceptor = response Body ( function ( req , res , next ) { proxy . _out Poisons . run ( req , res , next ) } ) proxy . _outgoing Enabled = true proxy . poison ( interceptor ) } 
function Directive ( directive ) { Rule . call ( this ) this . enabled = true this . directive = directive this . name = directive . $name | | directive . name } 
function Toxy ( opts ) { if ( ! ( this instanceof Toxy ) ) return new Toxy ( opts ) opts = Object . assign ( { } , Toxy . defaults , opts ) Proxy . call ( this , opts ) this . routes = [ ] this . _rules = midware ( ) this . _in Poisons = midware ( ) this . _out Poisons = midware ( ) setup Middleware ( this ) } 
function final Handler ( route ) { var is Final Handler = false route . use ( function ( req , res , next ) { if ( ! is Final Handler ) { is Final Handler = true use Route Final Handler ( route ) } next ( ) } ) } 
function append Row ( row ) { var that = this ; function exists ( item ) { return that . identifier & & item [ that . identifier ] = = = row [ that . identifier ] ; } if ( ! this . rows . contains ( exists ) ) { this . rows . push ( row ) ; return true ; } return false ; } 
function load Data ( ) { var that = this ; this . element . _bg Busy Aria ( true ) . trigger ( "load " + namespace ) ; show Loading . call ( this ) ; function contains Phrase ( row ) { var column , search Pattern = new Reg Exp ( that . search Phrase , ( that . options . case Sensitive ) ? "g " : "gi " ) ; for ( var i = 0 ; i < that . columns . length ; i + + ) { column = that . columns [ i ] ; if ( column . searchable & & column . visible & & column . converter . to ( row [ column . id ] ) . search ( search Pattern ) > - 1 ) { return true ; } } return false ; } function update ( rows , total ) { that . current Rows = rows ; set Totals . call ( that , total ) ; if ( ! that . options . keep Selection ) { that . selected Rows = [ ] ; } render Rows . call ( that , rows ) ; render Infos . call ( that ) ; render Pagination . call ( that ) ; that . element . _bg Busy Aria ( false ) . trigger ( "loaded " + namespace ) ; } if ( this . options . ajax ) { var request = get Request . call ( this ) , url = get Url . call ( this ) ; if ( url = = null | | typeof url ! = = "string " | | url . length = = = 0 ) { throw new Error ( "Url setting must be a none empty string or a function that returns one . " ) ; } 
function ( element , options ) { this . element = $ ( element ) ; this . origin = this . element . clone ( ) ; this . options = $ . extend ( true , { } , Grid . defaults , this . element . data ( ) , options ) ; 
function get Modified Config Module Index ( file Str , snaked Env , classed Env ) { 
function ( path ) { const data = fs . read File Sync ( path , 'utf 8 ' ) ; const ast = esprima . parse ( data ) ; 
function ( e ) { if ( e . code = = = 'EADDRINUSE ' ) { logger . error ( 'Error : Port ' + port + ' is already in use . ' ) ; logger . error ( 'Try another one , e .g . pouchdb -server -p ' + ( parse Int ( port ) + 1 ) + ' \n ' ) ; } else { logger . error ( 'Uncaught error : ' + e ) ; logger . error ( e . stack ) ; } } 
function redirect To Skimdb ( req , res ) { var skim Url = 'http : / /localhost : ' + pouch Port + ' /skimdb ' ; var get = request . get ( req . original Url . replace ( / ^ \ / _skimdb / , skim Url ) ) ; get . on ( 'error ' , ( err ) = > { logger . warn ( "couldn 't proxy to skimdb " ) ; logger . warn ( err ) ; } ) ; get . pipe ( res ) ; } 
function Metadata ( options , control Connection ) { if ( ! options ) { throw new errors . Argument Error ( 'Options are not defined ' ) ; } Object . define Property ( this , 'options ' , { value : options , enumerable : false , writable : false } ) ; Object . define Property ( this , 'control Connection ' , { value : control Connection , enumerable : false , writable : false } ) ; this . keyspaces = { } ; this . initialized = false ; this . _schema Parser = schema Parser Factory . get By Version ( options , control Connection , this . get Udt . bind ( this ) ) ; const self = this ; this . _prepared Queries = new Prepared Queries ( options . max Prepared , function ( ) { self . log . apply ( self , arguments ) ; } ) ; } 
function check Udt Types ( type ) { if ( type . code = = = types . data Types . udt ) { const udt Name = type . info . split ( ' . ' ) ; type . info = { keyspace : udt Name [ 0 ] , name : udt Name [ 1 ] } ; if ( ! type . info . name ) { if ( ! keyspace ) { throw new Type Error ( 'No keyspace specified for udt : ' + udt Name . join ( ' . ' ) ) ; } 
function Prepared Queries ( max Prepared , logger ) { this . length = 0 ; this . _max Prepared = max Prepared ; this . _map By Key = { } ; this . _map By Id = { } ; this . _logger = logger ; } 
function Driver Error ( message ) { Error . call ( this , message ) ; Error . capture Stack Trace ( this , this . constructor ) ; this . name = this . constructor . name ; this . info = 'Cassandra Driver Error ' ; 
function No Host Available Error ( inner Errors , message ) { Driver Error . call ( this , message ) ; this . inner Errors = inner Errors ; this . info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver . ' ; if ( ! message ) { this . message = 'All host (s ) tried for query failed . ' ; if ( inner Errors ) { const host List = Object . keys ( inner Errors ) ; if ( host List . length > 0 ) { const host = host List [ 0 ] ; this . message + = util . format ( ' First host tried , %s : %s . See inner Errors . ' , host , inner Errors [ host ] ) ; } } } } 
function Operation Timed Out Error ( message , host ) { Driver Error . call ( this , message , this . constructor ) ; this . info = 'Represents a client -side error that is raised when the client did not hear back from the server ' + 'within socket Options .read Timeout ' ; this . host = host ; } 
function Busy Connection Error ( address , max Requests Per Connection , connection Length ) { const message = util . format ( 'All connections to host %s are busy , %d requests are in -flight on %s ' , address , max Requests Per Connection , connection Length = = = 1 ? 'a single connection ' : 'each connection ' ) ; Driver Error . call ( this , message , this . constructor ) ; this . info = 'Represents a client -side error indicating that all connections to a certain host have reached ' + 'the maximum amount of in -flight requests supported (pooling .max Requests Per Connection ) ' ; } 
function extend ( base Options , user Options ) { if ( arguments . length = = = 1 ) { user Options = arguments [ 0 ] ; base Options = { } ; } const options = utils . deep Extend ( base Options , default Options ( ) , user Options ) ; if ( ! util . is Array ( options . contact Points ) | | options . contact Points . length = = = 0 ) { throw new Type Error ( 'Contacts points are not defined . ' ) ; } for ( let i = 0 ; i < options . contact Points . length ; i + + ) { const host Name = options . contact Points [ i ] ; if ( ! host Name ) { throw new Type Error ( util . format ( 'Contact point %s ( %s ) is not a valid host name , ' + 'the following values are valid contact points : ip Address , host Name or ip Address :port ' , i , host Name ) ) ; } } if ( ! options . log Emitter ) { options . log Emitter = function ( ) { } ; } if ( ! options . query Options ) { throw new Type Error ( 'query Options not defined in options ' ) ; } if ( options . request Tracker ! = = null & & ! ( options . request Tracker instanceof tracker . Request Tracker ) ) { throw new Type Error ( 'request Tracker must be an instance of Request Tracker ' ) ; } if ( ! ( options . metrics instanceof metrics . Client Metrics ) ) { throw new Type Error ( 'metrics must be an instance of Client Metrics ' ) ; } validate Policies Options ( options . policies ) ; validate Protocol Options ( options . protocol Options ) ; validate Socket Options ( options . socket Options ) ; options . encoding = options . encoding | | { } ; validate Encoding Options ( options . encoding ) ; if ( options . profiles & & ! util . is Array ( options . profiles ) ) { throw new Type Error ( 'profiles must be an Array of Execution Profile instances ' ) ; } return options ; } 
function validate Policies Options ( policies Options ) { if ( ! policies Options ) { throw new Type Error ( 'policies not defined in options ' ) ; } if ( ! ( policies Options . load Balancing instanceof policies . load Balancing . Load Balancing Policy ) ) { throw new Type Error ( 'Load balancing policy must be an instance of Load Balancing Policy ' ) ; } if ( ! ( policies Options . reconnection instanceof policies . reconnection . Reconnection Policy ) ) { throw new Type Error ( 'Reconnection policy must be an instance of Reconnection Policy ' ) ; } if ( ! ( policies Options . retry instanceof policies . retry . Retry Policy ) ) { throw new Type Error ( 'Retry policy must be an instance of Retry Policy ' ) ; } if ( ! ( policies Options . address Resolution instanceof policies . address Resolution . Address Translator ) ) { throw new Type Error ( 'Address resolution policy must be an instance of Address Translator ' ) ; } if ( policies Options . timestamp Generation ! = = null & & ! ( policies Options . timestamp Generation instanceof policies . timestamp Generation . Timestamp Generator ) ) { throw new Type Error ( 'Timestamp generation policy must be an instance of Timestamp Generator ' ) ; } } 
function validate Protocol Options ( protocol Options ) { if ( ! protocol Options ) { throw new Type Error ( 'protocol Options not defined in options ' ) ; } const version = protocol Options . max Version ; if ( version & & ( typeof version ! = = 'number ' | | ! types . protocol Version . is Supported ( version ) ) ) { throw new Type Error ( util . format ( 'protocol Options .max Version provided ( %s ) is invalid ' , version ) ) ; } } 
function validate Socket Options ( socket Options ) { if ( ! socket Options ) { throw new Type Error ( 'socket Options not defined in options ' ) ; } if ( typeof socket Options . read Timeout ! = = 'number ' ) { throw new Type Error ( 'socket Options .read Timeout must be a Number ' ) ; } if ( typeof socket Options . coalescing Threshold ! = = 'number ' | | socket Options . coalescing Threshold < = 0 ) { throw new Type Error ( 'socket Options .coalescing Threshold must be a positive Number ' ) ; } } 
function validate Encoding Options ( encoding Options ) { if ( encoding Options . map ) { const map Constructor = encoding Options . map ; if ( typeof map Constructor ! = = 'function ' | | typeof map Constructor . prototype . for Each ! = = 'function ' | | typeof map Constructor . prototype . set ! = = 'function ' ) { throw new Type Error ( 'Map constructor not valid ' ) ; } } if ( encoding Options . set ) { const set Constructor = encoding Options . set ; if ( typeof set Constructor ! = = 'function ' | | typeof set Constructor . prototype . for Each ! = = 'function ' | | typeof set Constructor . prototype . add ! = = 'function ' ) { throw new Type Error ( 'Set constructor not valid ' ) ; } } if ( ( encoding Options . use Big Int As Long | | encoding Options . use Big Int As Varint ) & & typeof Big Int = = = 'undefined ' ) { throw new Type Error ( 'Big Int is not supported by the Java Script engine ' ) ; } } 
function set Protocol Dependent Defaults ( options , version ) { let core Connections Per Host = core Connections Per Host V 3 ; let max Requests Per Connection = max Requests Per Connection V 3 ; if ( ! types . protocol Version . uses 2Bytes Stream Ids ( version ) ) { core Connections Per Host = core Connections Per Host V 2 ; max Requests Per Connection = max Requests Per Connection V 2 ; } options . pooling = utils . deep Extend ( { } , { core Connections Per Host , max Requests Per Connection } , options . pooling ) ; } 
function ( name ) { name = name . to Lower Case ( ) ; if ( name . index Of ( ' < ' ) > 0 ) { const list Matches = / ^ (list |set ) < ( . + ) > $ / . exec ( name ) ; if ( list Matches ) { return { code : this [ list Matches [ 1 ] ] , info : this . get By Name ( list Matches [ 2 ] ) } ; } const map Matches = / ^ (map ) < * ( . + ) * , * ( . + ) > $ / . exec ( name ) ; if ( map Matches ) { return { code : this [ map Matches [ 1 ] ] , info : [ this . get By Name ( map Matches [ 2 ] ) , this . get By Name ( map Matches [ 3 ] ) ] } ; } const udt Matches = / ^ (udt ) < ( . + ) > $ / . exec ( name ) ; if ( udt Matches ) { 
function timeuuid ( options , buffer , offset ) { let date ; let ticks ; let node Id ; let clock Id ; if ( options ) { if ( typeof options . msecs = = = 'number ' ) { date = new Date ( options . msecs ) ; } if ( options . msecs instanceof Date ) { date = options . msecs ; } if ( util . is Array ( options . node ) ) { node Id = utils . alloc Buffer From Array ( options . node ) ; } if ( typeof options . clockseq = = = 'number ' ) { clock Id = utils . alloc Buffer Unsafe ( 2 ) ; clock Id . write UInt 1 6BE ( options . clockseq , 0 ) ; } if ( typeof options . nsecs = = = 'number ' ) { ticks = options . nsecs ; } } const uuid = new Time Uuid ( date , ticks , node Id , clock Id ) ; if ( buffer instanceof Buffer ) { 
function uuid ( options , buffer , offset ) { let uuid ; if ( options ) { if ( util . is Array ( options . random ) ) { uuid = new Uuid ( utils . alloc Buffer From Array ( options . random ) ) ; } } if ( ! uuid ) { uuid = Uuid . random ( ) ; } if ( buffer instanceof Buffer ) { 
function get Data Type Name By Code ( item ) { if ( ! item | | typeof item . code ! = = 'number ' ) { throw new errors . Argument Error ( 'Invalid signature type definition ' ) ; } const type Name = _data Types By Code [ item . code ] ; if ( ! type Name ) { throw new errors . Argument Error ( util . format ( 'Type with code %d not found ' , item . code ) ) ; } if ( ! item . info ) { return type Name ; } if ( util . is Array ( item . info ) ) { return ( type Name + ' < ' + item . info . map ( function ( t ) { return get Data Type Name By Code ( t ) ; } ) . join ( ' , ' ) + ' > ' ) ; } if ( typeof item . info . code = = = 'number ' ) { return type Name + ' < ' + get Data Type Name By Code ( item . info ) + ' > ' ; } return type Name ; } 
function Frame Header ( version , flags , stream Id , opcode , body Length ) { this . version = version ; this . flags = flags ; this . stream Id = stream Id ; this . opcode = opcode ; this . body Length = body Length ; } 
function generate Timestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let long Micro = Long . ZERO ; if ( typeof microseconds = = = 'number ' & & microseconds > = 0 & & microseconds < 1 0 0 0 ) { long Micro = Long . from Int ( microseconds ) ; } else { if ( _timestamp Ticks > 9 9 9 ) { _timestamp Ticks = 0 ; } long Micro = Long . from Int ( _timestamp Ticks ) ; _timestamp Ticks + + ; } return Long . from Number ( date . get Time ( ) ) . multiply ( _long One Thousand ) . add ( long Micro ) ; } 
function Query Parser Error ( e ) { Query Parser Error . super _ . call ( this , e . message , this . constructor ) ; this . internal Error = e ; } 
function Mutable Long ( b 0 0 , b 1 6 , b 3 2 , b 4 8 ) { 
function Aggregate ( ) { this . name = null ; this . keyspace Name = null ; this . signature = null ; this . argument Types = null ; this . state Function = null ; this . state Type = null ; this . final Function = null ; this . init Condition Raw = null ; this . init Condition = null ; this . return Type = null ; } 
function Host ( address , protocol Version , options , metadata ) { events . Event Emitter . call ( this ) ; this . address = address ; this . set Down At = 0 ; this . is Up Since = null ; Object . define Property ( this , 'options ' , { value : options , enumerable : false , writable : false } ) ; Object . define Property ( this , 'pool ' , { value : new Host Connection Pool ( this , protocol Version ) , enumerable : false } ) ; const self = this ; this . pool . on ( 'open ' , this . _on New Connection Open . bind ( this ) ) ; this . pool . on ( 'remove ' , function on Connection Removed From Pool ( ) { self . _check Pool State ( ) ; } ) ; this . cassandra Version = null ; this . datacenter = null ; this . rack = null ; this . tokens = null ; this . host Id = null ; 
function Host Map ( ) { events . Event Emitter . call ( this ) ; this . _items = { } ; this . _values = null ; Object . define Property ( this , 'length ' , { get : function ( ) { return this . values ( ) . length ; } , enumerable : true } ) ; } 
function Constant Speculative Execution Policy ( delay , max Speculative Executions ) { if ( ! ( delay > = 0 ) ) { throw new errors . Argument Error ( 'delay must be a positive number or zero ' ) ; } if ( ! ( max Speculative Executions > 0 ) ) { throw new errors . Argument Error ( 'max Speculative Executions must be a positive number ' ) ; } this . _delay = delay ; this . _max Speculative Executions = max Speculative Executions ; } 
function Materialized View ( name ) { Data Collection . call ( this , name ) ; this . table Name = null ; this . where Clause = null ; this . include All Columns = false ; } 
function Execution Profile ( name , options ) { if ( typeof name ! = = 'string ' ) { throw new Type Error ( 'Execution profile name must be a string ' ) ; } options = options | | utils . empty Object ; this . name = name ; this . consistency = options . consistency ; this . load Balancing = options . load Balancing ; this . read Timeout = options . read Timeout ; this . retry = options . retry ; this . serial Consistency = options . serial Consistency ; } 
function is Valid IPv 4Mapped ( buffer ) { 
function Data Collection ( name ) { events . Event Emitter . call ( this ) ; this . set Max Listeners ( 0 ) ; * Name of the object * @type {String } * / this . name = name ; this . bloom Filter False Positive Chance = 0 ; this . caching = null ; this . comment = null ; this . gc Grace Seconds = 0 ; this . compaction Class = null ; this . compaction Options = null ; this . compression = null ; this . local Read Repair Chance = 0 ; this . read Repair Chance = 0 ; this . extensions = null ; this . crc Check Chance = null ; this . populate Cache On Flush = false ; this . default Ttl = 0 ; this . speculative Retry = 'NONE ' ; this . min Index Interval = 1 2 8 ; this . max Index Interval = 2 0 4 8 ; this . columns = null ; this . columns By Name = null ; this . partition Keys = [ ] ; this . clustering Keys = [ ] ; this . clustering Order = [ ] ; } 
function Integer ( bits , sign ) { this . bits _ = [ ] ; this . sign _ = sign ; 
function Protocol ( options ) { Transform . call ( this , options ) ; this . header = null ; this . body Length = 0 ; this . clear Header Chunks ( ) ; this . version = 0 ; this . header Size = 0 ; } 
async function example ( ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; 
function Table Metadata ( name ) { Data Collection . call ( this , name ) ; this . replicate On Write = true ; this . memtable Flush Period = 0 ; this . index Interval = null ; this . is Compact = false ; this . indexes = null ; this . cdc = null ; this . virtual = false ; } 
function Schema Parser V 1 ( options , cc ) { Schema Parser . call ( this , options , cc ) ; this . select Table = _select Table V 1 ; this . select Columns = _select Columns V 1 ; this . select Udt = _select Udt V 1 ; this . select Aggregates = _select Aggregates V 1 ; this . select Functions = _select Functions V 1 ; } 
function Schema Parser V 2 ( options , cc , udt Resolver ) { Schema Parser . call ( this , options , cc ) ; this . udt Resolver = udt Resolver ; this . select Table = _select Table V 2 ; this . select Columns = _select Columns V 2 ; this . select Udt = _select Udt V 2 ; this . select Aggregates = _select Aggregates V 2 ; this . select Functions = _select Functions V 2 ; this . select Indexes = _select Indexes V 2 ; } 
function Schema Parser V 3 ( options , cc , udt Resolver ) { Schema Parser V 2 . call ( this , options , cc , udt Resolver ) ; this . supports Virtual = true ; } 
function prune Static Compact Table Columns ( table Info ) { let i ; let c ; 
function prune Dense Table Columns ( table Info ) { let i = table Info . columns . length ; while ( i - - ) { const c = table Info . columns [ i ] ; if ( ! c . is Static & & c . type . code = = = types . data Types . custom & & c . type . info = = = 'empty ' ) { 
function get By Version ( options , cc , udt Resolver , version , current Instance ) { let parser Constructor = Schema Parser V 1 ; if ( version & & version [ 0 ] = = = 3 ) { parser Constructor = Schema Parser V 2 ; } else if ( version & & version [ 0 ] > = 4 ) { parser Constructor = Schema Parser V 3 ; } if ( ! current Instance | | ! ( current Instance instanceof parser Constructor ) ) { return new parser Constructor ( options , cc , udt Resolver ) ; } return current Instance ; } 
function Client ( options ) { events . Event Emitter . call ( this ) ; this . options = client Options . extend ( { log Emitter : this . emit . bind ( this ) } , options ) ; Object . define Property ( this , 'profile Manager ' , { value : new Profile Manager ( this . options ) } ) ; Object . define Property ( this , 'control Connection ' , { value : new Control Connection ( this . options , this . profile Manager ) , writable : true } ) ; * Gets the name of the active keyspace . * @type {String } * / this . keyspace = options . keyspace ; this . metadata = this . control Connection . metadata ; this . hosts = this . control Connection . hosts ; this . metrics = this . options . metrics ; } 
function encode Routing Key ( from User ) { const encoder = self . _get Encoder ( ) ; try { if ( from User ) { encoder . set Routing Key From User ( params , exec Options ) ; } else { encoder . set Routing Key From Meta ( meta , params , exec Options ) ; } } catch ( err ) { return callback ( err ) ; } callback ( ) ; } 
function get Js Files ( dir , file Array ) { const files = fs . readdir Sync ( dir ) ; file Array = file Array | | [ ] ; files . for Each ( function ( file ) { if ( file = = = 'node _modules ' ) { return ; } if ( fs . stat Sync ( dir + file ) . is Directory ( ) ) { get Js Files ( dir + file + ' / ' , file Array ) ; return ; } if ( file . substring ( file . length - 3 , file . length ) ! = = ' .js ' ) { return ; } file Array . push ( dir + file ) ; } ) ; return file Array ; } 
async function example ( ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; 
function Schema Function ( ) { this . name = null ; this . keyspace Name = null ; this . signature = null ; this . argument Names = null ; this . argument Types = null ; this . body = null ; this . called On Null Input = null ; this . language = null ; this . return Type = null ; } 
function execute Concurrent ( client , query , parameters , options ) { if ( ! client ) { throw new Type Error ( 'Client instance is not defined ' ) ; } if ( typeof query = = = 'string ' ) { if ( Array . is Array ( parameters ) ) { return new Array Based Executor ( client , query , parameters , options ) . execute ( ) ; } if ( parameters instanceof Stream ) { return new Stream Based Executor ( client , query , parameters , options ) . execute ( ) ; } throw new Type Error ( 'parameters should be an Array or a Stream instance ' ) ; } if ( Array . is Array ( query ) ) { options = parameters ; return new Array Based Executor ( client , null , query , options ) . execute ( ) ; } throw new Type Error ( 'A string query or query and parameters array should be provided ' ) ; } 
function copy Buffer ( buf ) { const target Buffer = alloc Buffer Unsafe ( buf . length ) ; buf . copy ( target Buffer ) ; return target Buffer ; } 
function fix Stack ( stack Trace , error ) { if ( stack Trace ) { error . stack + = ' \n (event loop ) \n ' + stack Trace . substr ( stack Trace . index Of ( " \n " ) + 1 ) ; } return error ; } 
function log ( type , info , further Info ) { if ( ! this . log Emitter ) { if ( ! this . options | | ! this . options . log Emitter ) { throw new Error ( 'Log emitter not defined ' ) ; } this . log Emitter = this . options . log Emitter ; } this . log Emitter ( 'log ' , type , this . constructor . name , info , further Info | | ' ' ) ; } 
function extend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . for Each ( function ( source ) { if ( ! source ) { return ; } const keys = Object . keys ( source ) ; for ( let i = 0 ; i < keys . length ; i + + ) { const key = keys [ i ] ; const value = source [ key ] ; if ( value = = = undefined ) { continue ; } target [ key ] = value ; } } ) ; return target ; } 
function to Lower Case Properties ( obj ) { const keys = Object . keys ( obj ) ; const result = { } ; for ( let i = 0 ; i < keys . length ; i + + ) { const k = keys [ i ] ; result [ k . to Lower Case ( ) ] = obj [ k ] ; } return result ; } 
function deep Extend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . for Each ( function ( source ) { for ( const prop in source ) { if ( ! source . has Own Property ( prop ) ) { continue ; } const target Prop = target [ prop ] ; const target Type = ( typeof target Prop ) ; 
function array Iterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index > = arr . length ) { return { done : true } ; } return { value : arr [ index + + ] , done : false } ; } } ; } 
function iterator To Array ( iterator ) { const values = [ ] ; let item = iterator . next ( ) ; while ( ! item . done ) { values . push ( item . value ) ; item = iterator . next ( ) ; } return values ; } 
function binary Search ( arr , key , compare Func ) { let low = 0 ; let high = arr . length - 1 ; while ( low < = high ) { const mid = ( low + high ) > > > 1 ; const mid Val = arr [ mid ] ; const cmp = compare Func ( mid Val , key ) ; if ( cmp < 0 ) { low = mid + 1 ; } else if ( cmp > 0 ) { high = mid - 1 ; } else { 
function insert Sorted ( arr , item , compare Func ) { if ( arr . length = = = 0 ) { return arr . push ( item ) ; } let position = binary Search ( arr , item , compare Func ) ; if ( position < 0 ) { position = ~ position ; } arr . splice ( position , 0 , item ) ; } 
function validate Fn ( fn , name ) { if ( typeof fn ! = = 'function ' ) { throw new errors . Argument Error ( util . format ( ' %s is not a function ' , name | | 'callback ' ) ) ; } return fn ; } 
function adapt Named Params Prepared ( params , columns ) { if ( ! params | | util . is Array ( params ) | | ! columns | | columns . length = = = 0 ) { 
function adapt Named Params With Hints ( params , exec Options ) { if ( ! params | | util . is Array ( params ) ) { 
function string Repeat ( val , times ) { if ( ! times | | times < 0 ) { return null ; } if ( times = = = 1 ) { return val ; } return new Array ( times + 1 ) . join ( val ) ; } 
function object Values ( obj ) { if ( ! obj ) { return exports . empty Array ; } const keys = Object . keys ( obj ) ; const values = new Array ( keys . length ) ; for ( let i = 0 ; i < keys . length ; i + + ) { values [ i ] = obj [ keys [ i ] ] ; } return values ; } 
function promise Wrapper ( options , original Callback , handler ) { if ( typeof original Callback = = = 'function ' ) { 
function series ( arr , callback ) { if ( ! Array . is Array ( arr ) ) { throw new Type Error ( 'First parameter must be an Array ' ) ; } callback = callback | | noop ; let index = 0 ; let sync ; next ( ) ; function next ( err , result ) { if ( err ) { return callback ( err ) ; } if ( index = = = arr . length ) { return callback ( null , result ) ; } if ( sync ) { return process . next Tick ( function ( ) { sync = true ; arr [ index + + ] ( next ) ; sync = false ; } ) ; } sync = true ; arr [ index + + ] ( next ) ; sync = false ; } } 
function Token Aware Iterator ( keyspace , exec Options , replicas , child Policy ) { this . keyspace = keyspace ; this . child Policy = child Policy ; this . options = exec Options ; this . local Replicas = [ ] ; this . replica Index = 0 ; this . replica Map = { } ; this . child Iterator = null ; 
function White List Policy ( child Policy , white List ) { if ( ! child Policy ) { throw new Error ( "You must specify a child load balancing policy " ) ; } if ( ! util . is Array ( white List ) ) { throw new Error ( "You must provide the white list of host addresses " ) ; } this . child Policy = child Policy ; const map = { } ; white List . for Each ( function ( address ) { map [ address ] = true ; } ) ; this . white List = map ; } 
function Monotonic Timestamp Generator ( warning Threshold , min Log Interval ) { if ( warning Threshold < 0 ) { throw new errors . Argument Error ( 'warning Threshold can not be lower than 0 ' ) ; } this . _warning Threshold = warning Threshold | | 1 0 0 0 ; this . _min Log Interval = 1 0 0 0 ; if ( typeof min Log Interval = = = 'number ' ) { 
function Exponential Reconnection Policy ( base Delay , max Delay , start With No Delay ) { this . base Delay = base Delay ; this . max Delay = max Delay ; this . start With No Delay = start With No Delay ; } 
function Control Connection ( options , profile Manager , context ) { this . protocol Version = null ; this . hosts = new Host Map ( ) ; this . set Max Listeners ( 0 ) ; Object . define Property ( this , "options " , { value : options , enumerable : false , writable : false } ) ; this . metadata = new Metadata ( this . options , this ) ; this . address Translator = this . options . policies . address Resolution ; this . reconnection Policy = this . options . policies . reconnection ; this . reconnection Schedule = this . reconnection Policy . new Schedule ( ) ; this . initialized = false ; this . is Shutting Down = false ; this . host = null ; this . connection = null ; this . encoder = null ; this . debouncer = new Event Debouncer ( options . refresh Schema Delay , this . log . bind ( this ) ) ; this . profile Manager = profile Manager ; this . topology Change Timeout = null ; this . node Status Change Timeout = null ; this . reconnection Timeout = null ; this . host Iterator = null ; this . tried Hosts = null ; this . _resolved Contact Points = new Map ( ) ; this . _contact Points = new Set ( ) ; if ( context & & context . borrow Host Connection ) { this . borrow Host Connection = context . borrow Host Connection ; } if ( context & & context . create Connection ) { this . create Connection = context . create Connection ; } } 
function resolve All ( name , callback ) { const addresses = [ ] ; utils . parallel ( [ function resolve 4 ( next ) { dns . resolve 4 ( name , function resolve 4Callback ( err , arr ) { if ( arr ) { arr . for Each ( address = > addresses . push ( { address , is IPv 6 : false } ) ) ; } 
function Client State ( hosts , open Connections , in Flight Queries ) { this . _hosts = hosts ; this . _open Connections = open Connections ; this . _in Flight Queries = in Flight Queries ; } 
function Event Debouncer ( delay , logger ) { this . _delay = delay ; this . _logger = logger ; this . _queue = null ; this . _timeout = null ; } 
function Frame Reader ( header , body , offset ) { this . header = header ; this . opcode = header . opcode ; this . offset = offset | | 0 ; this . buf = body ; } 
function Connection ( endpoint , protocol Version , options ) { events . Event Emitter . call ( this ) ; this . set Max Listeners ( 0 ) ; if ( ! options ) { throw new Error ( 'options is not defined ' ) ; } this . endpoint = endpoint ; this . endpoint Friendly Name = endpoint ; if ( ! this . endpoint | | this . endpoint . index Of ( ' : ' ) < 0 ) { throw new Error ( 'End Point must contain the ip address and port separated by : symbol ' ) ; } const port Separator Index = this . endpoint . last Index Of ( ' : ' ) ; this . address = this . endpoint . substr ( 0 , port Separator Index ) ; this . port = this . endpoint . substr ( port Separator Index + 1 ) ; Object . define Property ( this , "options " , { value : options , enumerable : false , writable : false } ) ; if ( protocol Version = = = null ) { * The timeout state for the idle request (heartbeat ) * / this . _idle Timeout = null ; this . timed Out Operations = 0 ; this . _stream Ids = new Stream Id Stack ( this . protocol Version ) ; this . _metrics = options . metrics ; this . encoder = new Encoder ( protocol Version , options ) ; this . keyspace = null ; this . emit Drain = false ; this . connected = false ; this . is Socket Open = false ; } 
function Time Uuid ( value , ticks , node Id , clock Id ) { let buffer ; if ( value instanceof Buffer ) { if ( value . length ! = = 1 6 ) { throw new Error ( 'Buffer for v 1 uuid not valid ' ) ; } buffer = value ; } else { buffer = generate Buffer ( value , ticks , node Id , clock Id ) ; } Uuid . call ( this , buffer ) ; } 
function get Clock Id ( clock Id ) { let buffer = clock Id ; if ( typeof clock Id = = = 'string ' ) { buffer = utils . alloc Buffer From String ( clock Id , 'ascii ' ) ; } if ( ! ( buffer instanceof Buffer ) ) { 
function get Node Id ( node Id ) { let buffer = node Id ; if ( typeof node Id = = = 'string ' ) { buffer = utils . alloc Buffer From String ( node Id , 'ascii ' ) ; } if ( ! ( buffer instanceof Buffer ) ) { 
function get Ticks ( ticks ) { if ( typeof ticks ! = = 'number ' | | ticks > = _ticks In Ms ) { _ticks + + ; if ( _ticks > = _ticks In Ms ) { _ticks = 0 ; } ticks = _ticks ; } return ticks ; } 
function get Time With Ticks ( date , ticks ) { if ( ! ( date instanceof Date ) | | is Na N ( date . get Time ( ) ) ) { 
function generate Buffer ( date , ticks , node Id , clock Id ) { const time With Ticks = get Time With Ticks ( date , ticks ) ; node Id = get Node Id ( node Id ) ; clock Id = get Clock Id ( clock Id ) ; const buffer = utils . alloc Buffer Unsafe ( 1 6 ) ; 
function Encoder ( protocol Version , options ) { this . encoding Options = options . encoding | | utils . empty Object ; define Instance Members . call ( this ) ; this . set Protocol Version ( protocol Version ) ; set Encoders . call ( this ) ; if ( this . encoding Options . copy Buffer ) { this . handle Buffer = handle Buffer Copy ; } else { this . handle Buffer = handle Buffer Ref ; } } 
function define Instance Members ( ) { this . set Protocol Version = function ( value ) { this . protocol Version = value ; * Reads a list from bytes * / this . decode List = function ( bytes , subtype ) { const total Items = this . decode Collection Length ( bytes , 0 ) ; let offset = this . collection Length Size ; const list = new Array ( total Items ) ; for ( let i = 0 ; i < total Items ; i + + ) { * Reads a Set from bytes * / this . decode Set = function ( bytes , subtype ) { const arr = this . decode List ( bytes , subtype ) ; if ( this . encoding Options . set ) { const set Constructor = this . encoding Options . set ; return new set Constructor ( arr ) ; } return arr ; } ; this . decode Map = function ( bytes , subtypes ) { let map ; const total Items = this . decode Collection Length ( bytes , 0 ) ; let offset = this . collection Length Size ; const self = this ; function read Values ( callback , this Arg ) { for ( let i = 0 ; i < total Items ; i + + ) { const key Length = self . decode Collection Length ( bytes , offset ) ; offset + = self . collection Length Size ; const key = self . decode ( bytes . slice ( offset , offset + key Length ) , subtypes [ 0 ] ) ; offset + = key Length ; const value Length = self . decode Collection Length ( bytes , offset ) ; offset + = self . collection Length Size ; if ( value Length < 0 ) { callback . call ( this Arg , key , null ) ; continue ; } const value = self . decode ( bytes . slice ( offset , offset + value Length ) , subtypes [ 1 ] ) ; offset + = value Length ; callback . call ( this Arg , key , value ) ; } } if ( this . encoding Options . map ) { const map Constructor = this . encoding Options . map ; map = new map Constructor ( ) ; read Values ( map . set , map ) ; } else { map = { } ; read Values ( function ( key , value ) { map [ key ] = value ; } ) ; } return map ; } ; this . decode Uuid = function ( bytes ) { return new types . Uuid ( this . handle Buffer ( bytes ) ) ; } ; this . decode Time Uuid = function ( bytes ) { return new types . Time Uuid ( this . handle Buffer ( bytes ) ) ; } ; this . decode Inet = function ( bytes ) { return new types . Inet Address ( this . handle Buffer ( bytes ) ) ; } ; this . decode Udt = function ( bytes , udt Info ) { const result = { } ; let offset = 0 ; for ( let i = 0 ; i < udt Info . fields . length & & offset < bytes . length ; i + + ) { * @param {Date |String |Long |Number } value * @private * / this . encode Timestamp = function ( value ) { const original Value = value ; if ( typeof value = = = 'string ' ) { value = new Date ( value ) ; } if ( value instanceof Date ) { * @param {Date |String |Local Date } value * @returns {Buffer } * @throws {Type Error } * @private * / this . encode Date = function ( value ) { const original Value = value ; try { if ( typeof value = = = 'string ' ) { value = types . Local Date . from String ( value ) ; } if ( value instanceof Date ) { value = types . Local Date . from Date ( value ) ; } } catch ( err ) { * @param {String |Local Date } value * @returns {Buffer } * @throws {Type Error } * @private * / this . encode Time = function ( value ) { const original Value = value ; try { if ( typeof value = = = 'string ' ) { value = types . Local Time . from String ( value ) ; } } catch ( err ) { * @param {Uuid |String |Buffer } value * @private * / this . encode Uuid = function ( value ) { if ( typeof value = = = 'string ' ) { try { value = types . Uuid . from String ( value ) . get Buffer ( ) ; } catch ( err ) { throw new Type Error ( err . message ) ; } } else if ( value instanceof types . Uuid ) { value = value . get Buffer ( ) ; } else { throw new Type Error ( 'Not a valid Uuid , expected Uuid /String /Buffer , obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . encode Inet = function ( value ) { if ( typeof value = = = 'string ' ) { value = types . Inet Address . from String ( value ) ; } if ( value instanceof types . Inet Address ) { value = value . get Buffer ( ) ; } if ( ! ( value instanceof Buffer ) ) { throw new Type Error ( 'Not a valid Inet , expected Inet Address /Buffer , obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . _encode Big Int From Long = function ( value ) { if ( typeof value = = = 'number ' ) { value = Long . from Number ( value ) ; } else if ( typeof value = = = 'string ' ) { value = Long . from String ( value ) ; } let buf = null ; if ( value instanceof Long ) { buf = Long . to Buffer ( value ) ; } else if ( value instanceof Mutable Long ) { buf = Long . to Buffer ( value . to Immutable ( ) ) ; } if ( buf = = = null ) { throw new Type Error ( 'Not a valid bigint , expected Long /Number /String /Buffer , obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . _encode Big Int From Big Int = function ( value ) { * @param {Integer |Buffer |String |Number } value * @returns {Buffer } * @private * / this . _encode Varint From Integer = function ( value ) { if ( typeof value = = = 'number ' ) { value = Integer . from Number ( value ) ; } if ( typeof value = = = 'string ' ) { value = Integer . from String ( value ) ; } let buf = null ; if ( value instanceof Buffer ) { buf = value ; } if ( value instanceof Integer ) { buf = Integer . to Buffer ( value ) ; } if ( buf = = = null ) { throw new Type Error ( 'Not a valid varint , expected Integer /Number /String /Buffer , obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . _encode Varint From Big Int = function ( value ) { * @param {Big Decimal |Buffer |String |Number } value * @returns {Buffer } * @private * / this . encode Decimal = function ( value ) { if ( typeof value = = = 'number ' ) { value = Big Decimal . from Number ( value ) ; } else if ( typeof value = = = 'string ' ) { value = Big Decimal . from String ( value ) ; } let buf = null ; if ( value instanceof Big Decimal ) { buf = Big Decimal . to Buffer ( value ) ; } else { throw new Type Error ( 'Not a valid varint , expected Big Decimal /Number /String /Buffer , obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . encode String = function ( value , encoding ) { if ( typeof value ! = = 'string ' ) { throw new Type Error ( 'Not a valid text value , expected String obtained ' + util . inspect ( value ) ) ; } return utils . alloc Buffer From String ( value , encoding ) ; } ; this . encode Utf 8String = function ( value ) { return this . encode String ( value , 'utf 8 ' ) ; } ; this . encode Ascii String = function ( value ) { return this . encode String ( value , 'ascii ' ) ; } ; this . encode Blob = function ( value ) { if ( ! ( value instanceof Buffer ) ) { throw new Type Error ( 'Not a valid blob , expected Buffer obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . encode Custom = function ( value , name ) { const handler = custom Encoders [ name ] ; if ( handler ) { return handler . call ( this , value ) ; } throw new Type Error ( 'No encoding handler found for type ' + name ) ; } ; this . encode Duration = function ( value ) { if ( ! ( value instanceof types . Duration ) ) { throw new Type Error ( 'Not a valid duration , expected Duration /Buffer obtained ' + util . inspect ( value ) ) ; } return value . to Buffer ( ) ; } ; this . encode Boolean = function ( value ) { return value ? buffers . int 8One : buffers . int 8Zero ; } ; this . encode Int = function ( value ) { if ( is Na N ( value ) ) { throw new Type Error ( 'Expected Number , obtained ' + util . inspect ( value ) ) ; } const buf = utils . alloc Buffer Unsafe ( 4 ) ; buf . write Int 3 2BE ( value , 0 ) ; return buf ; } ; this . encode Smallint = function ( value ) { if ( is Na N ( value ) ) { throw new Type Error ( 'Expected Number , obtained ' + util . inspect ( value ) ) ; } const buf = utils . alloc Buffer Unsafe ( 2 ) ; buf . write Int 1 6BE ( value , 0 ) ; return buf ; } ; this . encode Tinyint = function ( value ) { if ( is Na N ( value ) ) { throw new Type Error ( 'Expected Number , obtained ' + util . inspect ( value ) ) ; } const buf = utils . alloc Buffer Unsafe ( 1 ) ; buf . write Int 8 ( value , 0 ) ; return buf ; } ; this . encode List = function ( value , subtype ) { if ( ! util . is Array ( value ) ) { throw new Type Error ( 'Not a valid list value , expected Array obtained ' + util . inspect ( value ) ) ; } if ( value . length = = = 0 ) { return null ; } const parts = [ ] ; parts . push ( this . get Length Buffer ( value ) ) ; for ( let i = 0 ; i < value . length ; i + + ) { const val = value [ i ] ; if ( val = = = null | | typeof val = = = 'undefined ' | | val = = = types . unset ) { throw new Type Error ( 'A collection can \ 't contain null or unset values ' ) ; } const bytes = this . encode ( val , subtype ) ; / /include item byte length parts . push ( this . get Length Buffer ( bytes ) ) ; / /include item parts . push ( bytes ) ; } return Buffer . concat ( parts ) ; } ; this . encode Set = function ( value , subtype ) { if ( this . encoding Options . set & & value instanceof this . encoding Options . set ) { const arr = [ ] ; value . for Each ( function ( x ) { arr . push ( x ) ; } ) ; return this . encode List ( arr , subtype ) ; } return this . encode List ( value , subtype ) ; } ; / * * * Serializes a map into a Buffer * @param value * @param {Array } [subtypes ] * @returns {Buffer } * @private * / this . encode Map = function ( value , subtypes ) { const parts = [ ] ; let prop Counter = 0 ; let key Subtype = null ; let value Subtype = null ; const self = this ; if ( subtypes ) { key Subtype = subtypes [ 0 ] ; value Subtype = subtypes [ 1 ] ; } function add Item ( val , key ) { if ( key = = = null | | typeof key = = = 'undefined ' | | key = = = types . unset ) { throw new Type Error ( 'A map can \ 't contain null or unset keys ' ) ; } if ( val = = = null | | typeof val = = = 'undefined ' | | val = = = types . unset ) { throw new Type Error ( 'A map can \ 't contain null or unset values ' ) ; } const key Buffer = self . encode ( key , key Subtype ) ; / /include item byte length parts . push ( self . get Length Buffer ( key Buffer ) ) ; / /include item parts . push ( key Buffer ) ; / /value const value Buffer = self . encode ( val , value Subtype ) ; / /include item byte length parts . push ( self . get Length Buffer ( value Buffer ) ) ; / /include item if ( value Buffer ! = = null ) { parts . push ( value Buffer ) ; } prop Counter + + ; } if ( this . encoding Options . map & & value instanceof this . encoding Options . map ) { / /Use Map #for Each ( ) method to iterate value . for Each ( add Item ) ; } else { / /Use object for ( const key in value ) { if ( ! value . has Own Property ( key ) ) { continue ; } const val = value [ key ] ; add Item ( val , key ) ; } } parts . unshift ( this . get Length Buffer ( prop Counter ) ) ; return Buffer . concat ( parts ) ; } ; this . encode Udt = function ( value , udt Info ) { const parts = [ ] ; let total Length = 0 ; for ( let i = 0 ; i < udt Info . fields . length ; i + + ) { const field = udt Info . fields [ i ] ; const item = this . encode ( value [ field . name ] , field . type ) ; if ( ! item ) { parts . push ( null Value Buffer ) ; total Length + = 4 ; continue ; } if ( item = = = types . unset ) { parts . push ( unset Value Buffer ) ; total Length + = 4 ; continue ; } const length Buffer = utils . alloc Buffer Unsafe ( 4 ) ; length Buffer . write Int 3 2BE ( item . length , 0 ) ; parts . push ( length Buffer ) ; parts . push ( item ) ; total Length + = item . length + 4 ; } return Buffer . concat ( parts , total Length ) ; } ; this . encode Tuple = function ( value , tuple Info ) { const parts = [ ] ; let total Length = 0 ; for ( let i = 0 ; i < tuple Info . length ; i + + ) { const type = tuple Info [ i ] ; const item = this . encode ( value . get ( i ) , type ) ; if ( ! item ) { parts . push ( null Value Buffer ) ; total Length + = 4 ; continue ; } if ( item = = = types . unset ) { parts . push ( unset Value Buffer ) ; total Length + = 4 ; continue ; } const length Buffer = utils . alloc Buffer Unsafe ( 4 ) ; length Buffer . write Int 3 2BE ( item . length , 0 ) ; parts . push ( length Buffer ) ; parts . push ( item ) ; total Length + = item . length + 4 ; } return Buffer . concat ( parts , total Length ) ; } ; / * * * If not provided , it uses the array of buffers or the parameters and hints to build the routing Key * @param {Array } params * @param {Execution Options } exec Options * @param [keys ] parameter keys and positions in the params array * @throws Type Error * @internal * @ignore * / this . set Routing Key From User = function ( params , exec Options , keys ) { let total Length = 0 ; const user Routing Key = exec Options . get Routing Key ( ) ; if ( util . is Array ( user Routing Key ) ) { if ( user Routing Key . length = = = 1 ) { exec Options . set Routing Key ( user Routing Key [ 0 ] ) ; return ; } / / Its a composite routing key total Length = 0 ; for ( let i = 0 ; i < user Routing Key . length ; i + + ) { const item = user Routing Key [ i ] ; if ( ! item ) { / / Invalid routing key part provided by the user , clear the value exec Options . set Routing Key ( null ) ; return ; } total Length + = item . length + 3 ; } exec Options . set Routing Key ( concat Routing Key ( user Routing Key , total Length ) ) ; return ; } / / If routing Key is present , ensure it is a Buffer , Token , or Token Range . Otherwise throw an error . if ( user Routing Key ) { if ( user Routing Key instanceof Buffer | | user Routing Key instanceof token . Token | | user Routing Key instanceof token . Token Range ) { return ; } throw new Type Error ( ` $ { util . inspect ( user Routing Key ) } ` + ` ` ) ; } / / If no params are present , return as routing key cannot be determined . if ( ! params | | params . length = = = 0 ) { return ; } let routing Indexes = exec Options . get Routing Indexes ( ) ; if ( exec Options . get Routing Names ( ) ) { routing Indexes = exec Options . get Routing Names ( ) . map ( k = > keys [ k ] ) ; } if ( ! routing Indexes ) { return ; } const parts = [ ] ; const hints = exec Options . get Hints ( ) | | utils . empty Array ; const encode Param = ! keys ? ( i = > this . encode ( params [ i ] , hints [ i ] ) ) : ( i = > this . encode ( params [ i ] . value , hints [ i ] ) ) ; try { total Length = this . _encode Routing Key Parts ( parts , routing Indexes , encode Param ) ; } catch ( e ) { / / There was an error encoding a parameter that is part of the routing key , / / ignore now to fail afterwards } if ( total Length = = = 0 ) { return ; } exec Options . set Routing Key ( concat Routing Key ( parts , total Length ) ) ; } ; / * * * Sets the routing key in the options based on the prepared statement metadata . * @param {Object } meta Prepared metadata * @param {Array } params Array of parameters * @param {Execution Options } exec Options * @throws Type Error * @internal * @ignore * / this . set Routing Key From Meta = function ( meta , params , exec Options ) { const routing Indexes = exec Options . get Routing Indexes ( ) ; if ( ! routing Indexes ) { return ; } const parts = new Array ( routing Indexes . length ) ; const encode Param = i = > { const column Info = meta . columns [ i ] ; return this . encode ( params [ i ] , column Info ? column Info . type : null ) ; } ; let total Length = 0 ; try { total Length = this . _encode Routing Key Parts ( parts , routing Indexes , encode Param ) ; } catch ( e ) { / / There was an error encoding a parameter that is part of the routing key , / / ignore now to fail afterwards } if ( total Length = = = 0 ) { return ; } exec Options . set Routing Key ( concat Routing Key ( parts , total Length ) ) ; } ; / * * * @param {Array } parts * @param {Array } routing Indexes * @param {Function } encode Param * @returns {Number } The total length * @private * / this . _encode Routing Key Parts = function ( parts , routing Indexes , encode Param ) { let total Length = 0 ; for ( let i = 0 ; i < routing Indexes . length ; i + + ) { const param Index = routing Indexes [ i ] ; if ( param Index = = = undefined ) { / / Bad input from the user , ignore return 0 ; } const item = encode Param ( param Index ) ; if ( item = = = null | | item = = = undefined | | item = = = types . unset ) { / / The encoded partition key should an instance of Buffer / / Let it fail later in the pipeline for null /undefined parameter values return 0 ; } / / Per each part of the routing key , 3 extra bytes are needed total Length + = item . length + 3 ; parts [ i ] = item ; } return total Length ; } ; / * * * Parses a CQL name string into data type information * @param {String } keyspace * @param {String } type Name * @param {Number } start Index * @param {Number |null } length * @param {Function } udt Resolver * @param {Function } callback Callback invoked with err and { {code : number , info : Object |Array |null , options : {frozen : Boolean } } } * @internal * @ignore * / this . parse Type Name = function ( keyspace , type Name , start Index , length , udt Resolver , callback ) { start Index = start Index | | 0 ; if ( ! length ) { length = type Name . length ; } const data Type = { code : 0 , info : null , options : { frozen : false } } ; let inner Types ; if ( type Name . index Of ( " ' " , start Index ) = = = start Index ) { / /If quoted , this is a custom type . data Type . info = type Name . substr ( start Index + 1 , length - 2 ) ; return callback ( null , data Type ) ; } if ( ! length ) { length = type Name . length ; } if ( type Name . index Of ( cql Names . frozen , start Index ) = = = start Index ) { / /Remove the frozen token start Index + = cql Names . frozen . length + 1 ; length - = cql Names . frozen . length + 2 ; data Type . options . frozen = true ; } if ( type Name . index Of ( cql Names . list , start Index ) = = = start Index ) { / /move cursor across the name and bypass the angle brackets start Index + = cql Names . list . length + 1 ; length - = cql Names . list . length + 2 ; inner Types = parse Params ( type Name , start Index , length , ' < ' , ' > ' ) ; if ( inner Types . length ! = = 1 ) { return callback ( new Type Error ( 'Not a valid type ' + type Name ) ) ; } data Type . code = data Types . list ; return this . parse Type Name ( keyspace , inner Types [ 0 ] , 0 , null , udt Resolver , function ( err , child Type ) { if ( err ) { return callback ( err ) ; } data Type . info = child Type ; callback ( null , data Type ) ; } ) ; } if ( type Name . index Of ( cql Names . set , start Index ) = = = start Index ) { / /move cursor across the name and bypass the angle brackets start Index + = cql Names . set . length + 1 ; length - = cql Names . set . length + 2 ; inner Types = parse Params ( type Name , start Index , length , ' < ' , ' > ' ) ; if ( inner Types . length ! = = 1 ) { return callback ( new Type Error ( 'Not a valid type ' + type Name ) ) ; } data Type . code = data Types . set ; return this . parse Type Name ( keyspace , inner Types [ 0 ] , 0 , null , udt Resolver , function ( err , child Type ) { if ( err ) { return callback ( err ) ; } data Type . info = child Type ; callback ( null , data Type ) ; } ) ; } if ( type Name . index Of ( cql Names . map , start Index ) = = = start Index ) { / /move cursor across the name and bypass the angle brackets start Index + = cql Names . map . length + 1 ; length - = cql Names . map . length + 2 ; inner Types = parse Params ( type Name , start Index , length , ' < ' , ' > ' ) ; / /It should contain the key and value types if ( inner Types . length ! = = 2 ) { return callback ( new Type Error ( 'Not a valid type ' + type Name ) ) ; } data Type . code = data Types . map ; return this . _parse Child Types ( keyspace , data Type , inner Types , udt Resolver , callback ) ; } if ( type Name . index Of ( cql Names . tuple , start Index ) = = = start Index ) { / /move cursor across the name and bypass the angle brackets start Index + = cql Names . tuple . length + 1 ; length - = cql Names . tuple . length + 2 ; inner Types = parse Params ( type Name , start Index , length , ' < ' , ' > ' ) ; if ( inner Types . length < 1 ) { throw new Type Error ( 'Not a valid type ' + type Name ) ; } data Type . code = data Types . tuple ; return this . _parse Child Types ( keyspace , data Type , inner Types , udt Resolver , callback ) ; } const quoted = type Name . index Of ( ' " ' , start Index ) = = = start Index ; if ( quoted ) { / /Remove quotes start Index + + ; length - = 2 ; } / /Quick check if its a single type if ( start Index > 0 ) { type Name = type Name . substr ( start Index , length ) ; } / / Un -escape double quotes if quoted . if ( quoted ) { type Name = type Name . replace ( ' " " ' , ' " ' ) ; } const type Code = data Types [ type Name ] ; if ( typeof type Code = = = 'number ' ) { data Type . code = type Code ; return callback ( null , data Type ) ; } if ( type Name = = = cql Names . duration ) { data Type . info = duration Type Name ; return callback ( null , data Type ) ; } if ( type Name = = = cql Names . empty ) { / /set as custom data Type . info = 'empty ' ; return callback ( null , data Type ) ; } udt Resolver ( keyspace , type Name , function ( err , udt Info ) { if ( err ) { return callback ( err ) ; } if ( udt Info ) { data Type . code = data Types . udt ; data Type . info = udt Info ; return callback ( null , data Type ) ; } callback ( new Type Error ( 'Not a valid type " ' + type Name + ' " ' ) ) ; } ) ; } ; / * * * @param {String } keyspace * @param data Type * @param {Array } type Names * @param {Function } udt Resolver * @param {Function } callback * @private * / this . _parse Child Types = function ( keyspace , data Type , type Names , udt Resolver , callback ) { const self = this ; utils . map Series ( type Names , function ( name , next ) { self . parse Type Name ( keyspace , name . trim ( ) , 0 , null , udt Resolver , next ) ; } , function ( err , child Types ) { if ( err ) { return callback ( err ) ; } data Type . info = child Types ; callback ( null , data Type ) ; } ) ; } ; / * * * Parses a Cassandra fully -qualified class name string into data type information * @param {String } type Name * @param {Number } [start Index ] * @param {Number } [length ] * @throws Type Error * @returns { {code : number , info : Object |Array |null , options : {frozen : Boolean , reversed : Boolean } } } * @internal * @ignore * / this . parse Fq Type Name = function ( type Name , start Index , length ) { const data Type = { code : 0 , info : null , options : { reversed : false , frozen : false } } ; start Index = start Index | | 0 ; let inner Types ; if ( ! length ) { length = type Name . length ; } if ( length > complex Type Names . reversed . length & & type Name . index Of ( complex Type Names . reversed ) = = = start Index ) { / /Remove the reversed token start Index + = complex Type Names . reversed . length + 1 ; length - = complex Type Names . reversed . length + 2 ; data Type . options . reversed = true ; } if ( length > complex Type Names . frozen . length & & type Name . index Of ( complex Type Names . frozen , start Index ) = = = start Index ) { / /Remove the frozen token start Index + = complex Type Names . frozen . length + 1 ; length - = complex Type Names . frozen . length + 2 ; data Type . options . frozen = true ; } if ( type Name = = = complex Type Names . empty ) { / /set as custom data Type . info = 'empty ' ; return data Type ; } / /Quick check if its a single type if ( length < = single Fq Type Names Length ) { if ( start Index > 0 ) { type Name = type Name . substr ( start Index , length ) ; } const type Code = single Type Names [ type Name ] ; if ( typeof type Code = = = 'number ' ) { data Type . code = type Code ; return data Type ; } throw new Type Error ( 'Not a valid type " ' + type Name + ' " ' ) ; } if ( type Name . index Of ( complex Type Names . list , start Index ) = = = start Index ) { / /Its a list / /org .apache .cassandra .db .marshal .List Type (inner Type ) / /move cursor across the name and bypass the parenthesis start Index + = complex Type Names . list . length + 1 ; length - = complex Type Names . list . length + 2 ; inner Types = parse Params ( type Name , start Index , length ) ; if ( inner Types . length ! = = 1 ) { throw new Type Error ( 'Not a valid type ' + type Name ) ; } data Type . code = data Types . list ; data Type . info = this . parse Fq Type Name ( inner Types [ 0 ] ) ; return data Type ; } if ( type Name . index Of ( complex Type Names . set , start Index ) = = = start Index ) { / /Its a set / /org .apache .cassandra .db .marshal .Set Type (inner Type ) / /move cursor across the name and bypass the parenthesis start Index + = complex Type Names . set . length + 1 ; length - = complex Type Names . set . length + 2 ; inner Types = parse Params ( type Name , start Index , length ) ; if ( inner Types . length ! = = 1 ) { throw new Type Error ( 'Not a valid type ' + type Name ) ; } data Type . code = data Types . set ; data Type . info = this . parse Fq Type Name ( inner Types [ 0 ] ) ; return data Type ; } if ( type Name . index Of ( complex Type Names . map , start Index ) = = = start Index ) { / /org .apache .cassandra .db .marshal .Map Type (key Type ,value Type ) / /move cursor across the name and bypass the parenthesis start Index + = complex Type Names . map . length + 1 ; length - = complex Type Names . map . length + 2 ; inner Types = parse Params ( type Name , start Index , length ) ; / /It should contain the key and value types if ( inner Types . length ! = = 2 ) { throw new Type Error ( 'Not a valid type ' + type Name ) ; } data Type . code = data Types . map ; data Type . info = [ this . parse Fq Type Name ( inner Types [ 0 ] ) , this . parse Fq Type Name ( inner Types [ 1 ] ) ] ; return data Type ; } if ( type Name . index Of ( complex Type Names . udt , start Index ) = = = start Index ) { / /move cursor across the name and bypass the parenthesis start Index + = complex Type Names . udt . length + 1 ; length - = complex Type Names . udt . length + 2 ; return this . _parse Udt Name ( type Name , start Index , length ) ; } if ( type Name . index Of ( complex Type Names . tuple , start Index ) = = = start Index ) { / /move cursor across the name and bypass the parenthesis start Index + = complex Type Names . tuple . length + 1 ; length - = complex Type Names . tuple . length + 2 ; inner Types = parse Params ( type Name , start Index , length ) ; if ( inner Types . length < 1 ) { throw new Type Error ( 'Not a valid type ' + type Name ) ; } data Type . code = data Types . tuple ; data Type . info = inner Types . map ( x = > this . parse Fq Type Name ( x ) ) ; return data Type ; } / / Assume custom type if cannot be parsed up to this point . data Type . info = type Name . substr ( start Index , length ) ; return data Type ; } ; / * * * Parses type names with composites * @param {String } types String * @returns { {types : Array , is Composite : Boolean , has Collections : Boolean } } * @internal * @ignore * / this . parse Key Types = function ( types String ) { let i = 0 ; let length = types String . length ; const is Composite = types String . index Of ( complex Type Names . composite ) = = = 0 ; if ( is Composite ) { i = complex Type Names . composite . length + 1 ; length - - ; } const types = [ ] ; let start Index = i ; let nested = 0 ; let in Collection Type = false ; let has Collections = false ; / /as collection types are not allowed , it is safe to split by , while ( + + i < length ) { switch ( types String [ i ] ) { case ' , ' : if ( nested > 0 ) { break ; } if ( in Collection Type ) { / /remove type id start Index = types String . index Of ( ' : ' , start Index ) + 1 ; } types . push ( types String . substring ( start Index , i ) ) ; start Index = i + 1 ; break ; case ' ( ' : if ( nested = = = 0 & & types String . index Of ( complex Type Names . collection , start Index ) = = = start Index ) { in Collection Type = true ; has Collections = true ; / /skip collection type i + + ; start Index = i ; break ; } nested + + ; break ; case ' ) ' : if ( in Collection Type & & nested = = = 0 ) { types . push ( types String . substring ( types String . index Of ( ' : ' , start Index ) + 1 , i ) ) ; start Index = i + 1 ; break ; } nested - - ; break ; } } if ( start Index < length ) { types . push ( types String . substring ( start Index , length ) ) ; } return { types : types . map ( name = > this . parse Fq Type Name ( name ) ) , has Collections : has Collections , is Composite : is Composite } ; } ; this . _parse Udt Name = function ( type Name , start Index , length ) { const udt Params = parse Params ( type Name , start Index , length ) ; if ( udt Params . length < 2 ) { / /It should contain at least the keyspace , name of the udt and a type throw new Type Error ( 'Not a valid type ' + type Name ) ; } const data Type = { code : data Types . udt , info : null } ; const udt Info = { keyspace : udt Params [ 0 ] , name : utils . alloc Buffer From String ( udt Params [ 1 ] , 'hex ' ) . to String ( ) , fields : [ ] } ; for ( let i = 2 ; i < udt Params . length ; i + + ) { const p = udt Params [ i ] ; const separator Index = p . index Of ( ' : ' ) ; const field Type = this . parse Fq Type Name ( p , separator Index + 1 , p . length - ( separator Index + 1 ) ) ; udt Info . fields . push ( { name : utils . alloc Buffer From String ( p . substr ( 0 , separator Index ) , 'hex ' ) . to String ( ) , type : field Type } ) ; } data Type . info = udt Info ; return data Type ; } ; custom Decoders [ duration Type Name ] = this . decode Duration ; custom Encoders [ duration Type Name ] = this . encode Duration ; } 
function set Encoders ( ) { this . decoders = { [ data Types . custom ] : this . decode Custom , [ data Types . ascii ] : this . decode Ascii String , [ data Types . bigint ] : this . decode Long , [ data Types . blob ] : this . decode Blob , [ data Types . boolean ] : this . decode Boolean , [ data Types . counter ] : this . decode Long , [ data Types . decimal ] : this . decode Decimal , [ data Types . double ] : this . decode Double , [ data Types . float ] : this . decode Float , [ data Types . int ] : this . decode Int , [ data Types . text ] : this . decode Utf 8String , [ data Types . timestamp ] : this . decode Timestamp , [ data Types . uuid ] : this . decode Uuid , [ data Types . varchar ] : this . decode Utf 8String , [ data Types . varint ] : this . decode Varint , [ data Types . timeuuid ] : this . decode Time Uuid , [ data Types . inet ] : this . decode Inet , [ data Types . date ] : this . decode Date , [ data Types . time ] : this . decode Time , [ data Types . smallint ] : this . decode Smallint , [ data Types . tinyint ] : this . decode Tinyint , [ data Types . list ] : this . decode List , [ data Types . map ] : this . decode Map , [ data Types . set ] : this . decode Set , [ data Types . udt ] : this . decode Udt , [ data Types . tuple ] : this . decode Tuple } ; this . encoders = { [ data Types . custom ] : this . encode Custom , [ data Types . ascii ] : this . encode Ascii String , [ data Types . bigint ] : this . encode Long , [ data Types . blob ] : this . encode Blob , [ data Types . boolean ] : this . encode Boolean , [ data Types . counter ] : this . encode Long , [ data Types . decimal ] : this . encode Decimal , [ data Types . double ] : this . encode Double , [ data Types . float ] : this . encode Float , [ data Types . int ] : this . encode Int , [ data Types . text ] : this . encode Utf 8String , [ data Types . timestamp ] : this . encode Timestamp , [ data Types . uuid ] : this . encode Uuid , [ data Types . varchar ] : this . encode Utf 8String , [ data Types . varint ] : this . encode Varint , [ data Types . timeuuid ] : this . encode Uuid , [ data Types . inet ] : this . encode Inet , [ data Types . date ] : this . encode Date , [ data Types . time ] : this . encode Time , [ data Types . smallint ] : this . encode Smallint , [ data Types . tinyint ] : this . encode Tinyint , [ data Types . list ] : this . encode List , [ data Types . map ] : this . encode Map , [ data Types . set ] : this . encode Set , [ data Types . udt ] : this . encode Udt , [ data Types . tuple ] : this . encode Tuple } ; } 
function get Length Buffer V 2 ( value ) { if ( ! value ) { return buffers . int 1 6Zero ; } const length Buffer = utils . alloc Buffer Unsafe ( 2 ) ; if ( typeof value = = = 'number ' ) { length Buffer . write UInt 1 6BE ( value , 0 ) ; } else { length Buffer . write UInt 1 6BE ( value . length , 0 ) ; } return length Buffer ; } 
function get Length Buffer V 3 ( value ) { if ( ! value ) { return buffers . int 3 2Zero ; } const length Buffer = utils . alloc Buffer Unsafe ( 4 ) ; if ( typeof value = = = 'number ' ) { length Buffer . write Int 3 2BE ( value , 0 ) ; } else { length Buffer . write Int 3 2BE ( value . length , 0 ) ; } return length Buffer ; } 
function Duration ( months , days , nanoseconds ) { this . months = months ; this . days = days ; this . nanoseconds = typeof nanoseconds = = = 'number ' ? Long . from Number ( nanoseconds ) : nanoseconds ; } 
function number Of Leading Zeros ( value ) { if ( value . equals ( Long . ZERO ) ) { return 6 4 ; } let n = 1 ; let x = value . get High Bits ( ) ; if ( x = = = 0 ) { n + = 3 2 ; x = value . get Low Bits ( ) ; } if ( x > > > 1 6 = = = 0 ) { n + = 1 6 ; x < < = 1 6 ; } if ( x > > > 2 4 = = = 0 ) { n + = 8 ; x < < = 8 ; } if ( x > > > 2 8 = = = 0 ) { n + = 4 ; x < < = 4 ; } if ( x > > > 3 0 = = = 0 ) { n + = 2 ; x < < = 2 ; } n - = x > > > 3 1 ; return n ; } 
function Index ( name , target , kind , options ) { this . name = name ; this . target = target ; this . kind = typeof kind = = = 'string ' ? get Kind By Name ( kind ) : kind ; this . options = options ; } 
function ( key ) { return _ . sort By ( files , function ( el ) { return Number ( $ ( el ) . find ( 'span [data -lint ] ' ) . attr ( key ) ) * - 1 ; } ) ; } 
function ( ) { $this . css ( 'font -size ' , Math . max ( Math . min ( $this . width ( ) / ( compressor * 1 0 ) , parse Float ( settings . max Font Size ) ) , parse Float ( settings . min Font Size ) ) ) ; } 
function Code Mirror ( place , options ) { if ( ! ( this instanceof Code Mirror ) ) return new Code Mirror ( place , options ) ; this . options = options = options | | { } ; 
function make Display ( place ) { var d = { } ; var input = d . input = elt ( "textarea " , null , null , "position : absolute ; padding : 0 ; width : 1px ; height : 1em ; outline : none ; " ) ; input . set Attribute ( "wrap " , "off " ) ; input . set Attribute ( "autocorrect " , "off " ) ; input . set Attribute ( "autocapitalize " , "off " ) ; 
function make View ( doc ) { var sel Pos = { line : 0 , ch : 0 } ; return { doc : doc , 
function load Mode ( cm ) { var doc = cm . view . doc ; cm . view . mode = Code Mirror . get Mode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . state After = null ; } ) ; cm . view . frontier = 0 ; start Worker ( cm , 1 0 0 ) ; } 
function update Scrollbars ( d , doc Height ) { var total Height = doc Height + 2 * padding Top ( d ) ; d . sizer . style . min Height = d . height Forcer . style . top = total Height + "px " ; var scroll Height = Math . max ( total Height , d . scroller . scroll Height ) ; var needs H = d . scroller . scroll Width > d . scroller . client Width ; var needs V = scroll Height > d . scroller . client Height ; if ( needs V ) { d . scrollbar V . style . display = "block " ; d . scrollbar V . style . bottom = needs H ? scrollbar Width ( d . measure ) + "px " : " 0 " ; d . scrollbar V . first Child . style . height = ( scroll Height - d . scroller . client Height + d . scrollbar V . client Height ) + "px " ; } else d . scrollbar V . style . display = " " ; if ( needs H ) { d . scrollbar H . style . display = "block " ; d . scrollbar H . style . right = needs V ? scrollbar Width ( d . measure ) + "px " : " 0 " ; d . scrollbar H . first Child . style . width = ( d . scroller . scroll Width - d . scroller . client Width + d . scrollbar H . client Width ) + "px " ; } else d . scrollbar H . style . display = " " ; if ( needs H & & needs V ) { d . scrollbar Filler . style . display = "block " ; d . scrollbar Filler . style . height = d . scrollbar Filler . style . width = scrollbar Width ( d . measure ) + "px " ; } else d . scrollbar Filler . style . display = " " ; if ( mac _ge Lion & & scrollbar Width ( d . measure ) = = = 0 ) d . scrollbar V . style . min Width = d . scrollbar H . style . min Height = mac _ge Mountain Lion ? " 1 8px " : " 1 2px " ; } 
function update Display ( cm , changes , view Port ) { var old From = cm . display . showing From , old To = cm . display . showing To ; var updated = update Display Inner ( cm , changes , view Port ) ; if ( updated ) { signal Later ( cm , cm , "update " , cm ) ; if ( cm . display . showing From ! = old From | | cm . display . showing To ! = old To ) signal Later ( cm , cm , "viewport Change " , cm , cm . display . showing From , cm . display . showing To ) ; } update Selection ( cm ) ; update Scrollbars ( cm . display , cm . view . doc . height ) ; return updated ; } 
function update Display Inner ( cm , changes , view Port ) { var display = cm . display , doc = cm . view . doc ; if ( ! display . wrapper . client Width ) { display . showing From = display . showing To = display . view Offset = 0 ; return ; } 
function update Selection Range ( cm ) { var display = cm . display , doc = cm . view . doc , sel = cm . view . sel ; var fragment = document . create Document Fragment ( ) ; var client Width = display . line Space . offset Width , pl = padding Left ( cm . display ) ; function add ( left , top , width , bottom ) { if ( top < 0 ) top = 0 ; fragment . append Child ( elt ( "div " , null , "Code Mirror -selected " , "position : absolute ; left : " + left + "px ; top : " + top + "px ; width : " + ( width = = null ? client Width - left : width ) + "px ; height : " + ( bottom - top ) + "px " ) ) ; } function draw For Line ( line , from Arg , to Arg , ret Top ) { var line Obj = get Line ( doc , line ) ; var line Len = line Obj . text . length , r Val = ret Top ? Infinity : - Infinity ; function coords ( ch ) { return char Coords ( cm , { line : line , ch : ch } , "div " , line Obj ) ; } iterate Bidi Sections ( get Order ( line Obj ) , from Arg | | 0 , to Arg = = null ? line Len : to Arg , function ( from , to , dir ) { var left Pos = coords ( dir = = "rtl " ? to - 1 : from ) ; var right Pos = coords ( dir = = "rtl " ? from : to - 1 ) ; var left = left Pos . left , right = right Pos . right ; if ( right Pos . top - left Pos . top > 3 ) { 
function restart Blink ( cm ) { var display = cm . display ; clear Interval ( display . blinker ) ; var on = true ; display . cursor . style . visibility = display . other Cursor . style . visibility = " " ; display . blinker = set Interval ( function ( ) { if ( ! display . cursor . offset Height ) return ; display . cursor . style . visibility = display . other Cursor . style . visibility = ( on = ! on ) ? " " : "hidden " ; } , cm . options . cursor Blink Rate ) ; } 
function start Worker ( cm , time ) { if ( cm . view . frontier < cm . display . showing To ) cm . view . highlight . set ( time , bind ( highlight Worker , cm ) ) ; } 
function into Coord System ( cm , line Obj , rect , context ) { if ( line Obj . widgets ) for ( var i = 0 ; i < line Obj . widgets . length ; + + i ) if ( line Obj . widgets [ i ] . above ) { var size = line Obj . widgets [ i ] . node . offset Height ; rect . top + = size ; rect . bottom + = size ; } if ( context = = "line " ) return rect ; if ( ! context ) context = "local " ; var y Off = height At Line ( cm , line Obj ) ; if ( context ! = "local " ) y Off - = cm . display . view Offset ; if ( context = = "page " ) { var l Off = cm . display . line Space . get Bounding Client Rect ( ) ; y Off + = l Off . top + ( window . page YOffset | | ( document . document Element | | document . body ) . scroll Top ) ; var x Off = l Off . left + ( window . page XOffset | | ( document . document Element | | document . body ) . scroll Left ) ; rect . left + = x Off ; rect . right + = x Off ; } rect . top + = y Off ; rect . bottom + = y Off ; return rect ; } 
function coords Char ( cm , x , y ) { var doc = cm . view . doc ; y + = cm . display . view Offset ; if ( y < 0 ) return { line : 0 , ch : 0 , outside : true } ; var line No = line At Height ( doc , y ) ; if ( line No > = doc . size ) return { line : doc . size - 1 , ch : get Line ( doc , doc . size - 1 ) . text . length } ; if ( x < 0 ) x = 0 ; for ( ; ; ) { var line Obj = get Line ( doc , line No ) ; var found = coords Char Inner ( cm , line Obj , line No , x , y ) ; var merged = collapsed Span At End ( line Obj ) ; if ( merged & & found . ch = = line Right ( line Obj ) ) line No = merged . find ( ) . to . line ; else return found ; } } 
function start Operation ( cm ) { if ( cm . cur Op ) + + cm . cur Op . depth ; else cm . cur Op = { 
function read Input ( cm ) { var input = cm . display . input , prev Input = cm . display . prev Input , view = cm . view , sel = view . sel ; if ( ! view . focused | | has Selection ( input ) | | is Read Only ( cm ) ) return false ; var text = input . value ; if ( text = = prev Input & & pos Eq ( sel . from , sel . to ) ) return false ; start Operation ( cm ) ; view . sel . shift = false ; var same = 0 , l = Math . min ( prev Input . length , text . length ) ; while ( same < l & & prev Input [ same ] = = text [ same ] ) + + same ; var from = sel . from , to = sel . to ; if ( same < prev Input . length ) from = { line : from . line , ch : from . ch - ( prev Input . length - same ) } ; else if ( view . overwrite & & pos Eq ( from , to ) & & ! cm . display . paste Incoming ) to = { line : to . line , ch : Math . min ( get Line ( cm . view . doc , to . line ) . text . length , to . ch + ( text . length - same ) ) } ; var update Input = cm . cur Op . update Input ; update Doc ( cm , from , to , split Lines ( text . slice ( same ) ) , "end " , cm . display . paste Incoming ? "paste " : "input " , { from : from , to : to } ) ; cm . cur Op . update Input = update Input ; if ( text . length > 1 0 0 0 ) input . value = cm . display . prev Input = " " ; else cm . display . prev Input = text ; end Operation ( cm ) ; cm . display . paste Incoming = false ; return true ; } 
function register Event Handlers ( cm ) { var d = cm . display ; on ( d . scroller , "mousedown " , operation ( cm , on Mouse Down ) ) ; on ( d . scroller , "dblclick " , operation ( cm , e _prevent Default ) ) ; on ( d . line Space , "selectstart " , function ( e ) { if ( ! mouse Event In Widget ( d , e ) ) e _prevent Default ( e ) ; } ) ; 
function update Doc ( cm , from , to , new Text , sel Update , origin ) { 
function set Selection ( cm , anchor , head , bias , check Atomic ) { cm . view . goal Column = null ; var sel = cm . view . sel ; 
function ( pos ) { var doc = this . view . doc ; pos = clip Pos ( doc , pos ) ; var state = get State Before ( this , pos . line ) , mode = this . view . mode ; var line = get Line ( doc , pos . line ) ; var stream = new String Stream ( line . text , this . options . tab Size ) ; while ( stream . pos < pos . ch & & ! stream . eol ( ) ) { stream . start = stream . pos ; var style = mode . token ( stream , state ) ; } return { start : stream . start , end : stream . pos , string : stream . current ( ) , class Name : style | | null , 
function make Line ( text , marked Spans , height ) { var line = { text : text , height : height } ; attach Marked Spans ( line , marked Spans ) ; if ( line Is Hidden ( line ) ) line . height = 0 ; return line ; } 
function highlight Line ( cm , line , state ) { var mode = cm . view . mode , flatten Spans = cm . options . flatten Spans ; var changed = ! line . styles , pos = 0 , cur Text = " " , cur Style = null ; var stream = new String Stream ( line . text , cm . options . tab Size ) , st = line . styles | | ( line . styles = [ ] ) ; if ( line . text = = " " & & mode . blank Line ) mode . blank Line ( state ) ; while ( ! stream . eol ( ) ) { var style = mode . token ( stream , state ) , substr = stream . current ( ) ; stream . start = stream . pos ; if ( ! flatten Spans | | cur Style ! = style ) { if ( cur Text ) { changed = changed | | pos > = st . length | | cur Text ! = st [ pos ] | | cur Style ! = st [ pos + 1 ] ; st [ pos + + ] = cur Text ; st [ pos + + ] = cur Style ; } cur Text = substr ; cur Style = style ; } else cur Text = cur Text + substr ; 
function e _prop ( e , prop ) { var overridden = e . override & & e . override . has Own Property ( prop ) ; return overridden ? e . override [ prop ] : e [ prop ] ; } 
function move Visually ( line , start , dir , by Unit ) { var bidi = get Order ( line ) ; if ( ! bidi ) return move Logically ( line , start , dir , by Unit ) ; var move One Unit = by Unit ? function ( pos , dir ) { do pos + = dir ; while ( pos > 0 & & is Extending Char . test ( line . text . char At ( pos ) ) ) ; return pos ; } : function ( pos , dir ) { return pos + dir ; } ; var linedir = bidi [ 0 ] . level ; for ( var i = 0 ; i < bidi . length ; + + i ) { var part = bidi [ i ] , sticky = part . level % 2 = = linedir ; if ( ( part . from < start & & part . to > start ) | | ( sticky & & ( part . from = = start | | part . to = = start ) ) ) break ; } var target = move One Unit ( start , part . level % 2 ? - dir : dir ) ; while ( target ! = null ) { if ( part . level % 2 = = linedir ) { if ( target < part . from | | target > part . to ) { part = bidi [ i + = dir ] ; target = part & & ( dir > 0 = = part . level % 2 ? move One Unit ( part . to , - 1 ) : move One Unit ( part . from , 1 ) ) ; } else break ; } else { if ( target = = bidi Left ( part ) ) { part = bidi [ - - i ] ; target = part & & bidi Right ( part ) ; } else if ( target = = bidi Right ( part ) ) { part = bidi [ + + i ] ; target = part & & bidi Left ( part ) ; } else break ; } } return target < 0 | | target > line . text . length ? null : target ; } 
function Flow ( opts ) { this . support = ( typeof File ! = = 'undefined ' & & typeof Blob ! = = 'undefined ' & & typeof File List ! = = 'undefined ' & & ( ! ! Blob . prototype . slice | | ! ! Blob . prototype . webkit Slice | | ! ! Blob . prototype . moz Slice | | false ) * Check if directory upload is supported * @type {boolean } * / this . support Directory = ( / Chrome / . test ( window . navigator . user Agent ) | | / Firefox / . test ( window . navigator . user Agent ) | | / Edge / . test ( window . navigator . user Agent ) ) ; this . files = [ ] ; this . defaults = { chunk Size : 1 0 2 4 * 1 0 2 4 , force Chunk Size : false , simultaneous Uploads : 3 , single File : false , file Parameter Name : 'file ' , progress Callbacks Interval : 5 0 0 , speed Smoothing Factor : 0 . 1 , query : { } , headers : { } , with Credentials : false , preprocess : null , method : 'multipart ' , test Method : 'GET ' , upload Method : 'POST ' , prioritize First And Last Chunk : false , allow Duplicate Uploads : false , target : ' / ' , test Chunks : true , generate Unique Identifier : null , max Chunk Retries : 0 , chunk Retry Interval : null , permanent Errors : [ 4 0 4 , 4 1 3 , 4 1 5 , 5 0 0 , 5 0 1 ] , success Statuses : [ 2 0 0 , 2 0 1 , 2 0 2 ] , on Drop Stop Propagation : false , init File Fn : null , read File Fn : web APIFile Read } ; this . opts = { } ; this . events = { } ; var $ = this ; this . on Drop = function ( event ) { if ( $ . opts . on Drop Stop Propagation ) { event . stop Propagation ( ) ; } event . prevent Default ( ) ; var data Transfer = event . data Transfer ; if ( data Transfer . items & & data Transfer . items [ 0 ] & & data Transfer . items [ 0 ] . webkit Get As Entry ) { $ . webkit Read Data Transfer ( event ) ; } else { $ . add Files ( data Transfer . files , event ) ; } } ; this . prevent Event = function ( event ) { event . prevent Default ( ) ; } ; this . opts = Flow . extend ( { } , this . defaults , opts | | { } ) ; } 
function ( event , callback ) { event = event . to Lower Case ( ) ; if ( ! this . events . has Own Property ( event ) ) { this . events [ event ] = [ ] ; } this . events [ event ] . push ( callback ) ; } 
function ( event , fn ) { if ( event ! = = undefined ) { event = event . to Lower Case ( ) ; if ( fn ! = = undefined ) { if ( this . events . has Own Property ( event ) ) { array Remove ( this . events [ event ] , fn ) ; } } else { delete this . events [ event ] ; } } else { this . events = { } ; } } 
function ( event , args ) { 
function ( event ) { var $ = this ; var queue = event . data Transfer . items . length ; var files = [ ] ; each ( event . data Transfer . items , function ( item ) { var entry = item . webkit Get As Entry ( ) ; if ( ! entry ) { decrement ( ) ; return ; } if ( entry . is File ) { 
function ( file ) { var custom = this . opts . generate Unique Identifier ; if ( typeof custom = = = 'function ' ) { return custom ( file ) ; } 
function ( prevent Events ) { 
function ( dom Nodes , is Directory , single File , attributes ) { if ( dom Nodes instanceof Element ) { dom Nodes = [ dom Nodes ] ; } each ( dom Nodes , function ( dom Node ) { var input ; if ( dom Node . tag Name = = = 'INPUT ' & & dom Node . type = = = 'file ' ) { input = dom Node ; } else { input = document . create Element ( 'input ' ) ; input . set Attribute ( 'type ' , 'file ' ) ; 
function ( dom Nodes ) { if ( typeof dom Nodes . length = = = 'undefined ' ) { dom Nodes = [ dom Nodes ] ; } each ( dom Nodes , function ( dom Node ) { dom Node . add Event Listener ( 'dragover ' , this . prevent Event , false ) ; dom Node . add Event Listener ( 'dragenter ' , this . prevent Event , false ) ; dom Node . add Event Listener ( 'drop ' , this . on Drop , false ) ; } , this ) ; } 
function ( dom Nodes ) { if ( typeof dom Nodes . length = = = 'undefined ' ) { dom Nodes = [ dom Nodes ] ; } each ( dom Nodes , function ( dom Node ) { dom Node . remove Event Listener ( 'dragover ' , this . prevent Event ) ; dom Node . remove Event Listener ( 'dragenter ' , this . prevent Event ) ; dom Node . remove Event Listener ( 'drop ' , this . on Drop ) ; } , this ) ; } 
function ( ) { var uploading = false ; each ( this . files , function ( file ) { if ( file . is Uploading ( ) ) { uploading = true ; return false ; } } ) ; return uploading ; } 
function ( ) { var num = 0 ; var should = true ; var simultaneous Uploads = this . opts . simultaneous Uploads ; each ( this . files , function ( file ) { each ( file . chunks , function ( chunk ) { if ( chunk . status ( ) = = = 'uploading ' ) { num + + ; if ( num > = simultaneous Uploads ) { should = false ; return false ; } } } ) ; } ) ; 
function ( ) { 
function ( file List , event ) { var files = [ ] ; each ( file List , function ( file ) { 
function ( file ) { for ( var i = this . files . length - 1 ; i > = 0 ; i - - ) { if ( this . files [ i ] = = = file ) { this . files . splice ( i , 1 ) ; file . abort ( ) ; this . fire ( 'file Removed ' , file ) ; } } } 
function ( unique Identifier ) { var ret = false ; each ( this . files , function ( file ) { if ( file . unique Identifier = = = unique Identifier ) { ret = file ; } } ) ; return ret ; } 
function ( ) { var size Delta = 0 ; var average Speed = 0 ; each ( this . files , function ( file ) { if ( ! file . paused & & ! file . error ) { size Delta + = file . size - file . size Uploaded ( ) ; average Speed + = file . average Speed ; } } ) ; if ( size Delta & & ! average Speed ) { return Number . POSITIVE _INFINITY ; } if ( ! size Delta & & ! average Speed ) { return 0 ; } return Math . floor ( size Delta / average Speed ) ; } 
function Flow File ( flow Obj , file , unique Identifier ) { this . flow Obj = flow Obj ; this . bytes = null ; this . file = file ; this . name = file . file Name | | file . name ; this . size = file . size ; this . relative Path = file . relative Path | | file . webkit Relative Path | | this . name ; this . unique Identifier = ( unique Identifier = = = undefined ? flow Obj . generate Unique Identifier ( file ) : unique Identifier ) ; this . chunks = [ ] ; this . paused = false ; this . error = false ; this . average Speed = 0 ; this . current Speed = 0 ; this . _last Progress Callback = Date . now ( ) ; this . _prev Uploaded Size = 0 ; this . _prev Progress = 0 ; this . bootstrap ( ) ; } 
function ( ) { var time Span = Date . now ( ) - this . _last Progress Callback ; if ( ! time Span ) { return ; } var smoothing Factor = this . flow Obj . opts . speed Smoothing Factor ; var uploaded = this . size Uploaded ( ) ; 
function ( chunk , event , message ) { switch ( event ) { case 'progress ' : if ( Date . now ( ) - this . _last Progress Callback < this . flow Obj . opts . progress Callbacks Interval ) { break ; } this . measure Speed ( ) ; this . flow Obj . fire ( 'file Progress ' , this , chunk ) ; this . flow Obj . fire ( 'progress ' ) ; this . _last Progress Callback = Date . now ( ) ; break ; case 'error ' : this . error = true ; this . abort ( true ) ; this . flow Obj . fire ( 'file Error ' , this , message , chunk ) ; this . flow Obj . fire ( 'error ' , message , this , chunk ) ; break ; case 'success ' : if ( this . error ) { return ; } this . measure Speed ( ) ; this . flow Obj . fire ( 'file Progress ' , this , chunk ) ; this . flow Obj . fire ( 'progress ' ) ; this . _last Progress Callback = Date . now ( ) ; if ( this . is Complete ( ) ) { this . current Speed = 0 ; this . average Speed = 0 ; this . flow Obj . fire ( 'file Success ' , this , message , chunk ) ; } break ; case 'retry ' : this . flow Obj . fire ( 'file Retry ' , this , chunk ) ; break ; } } 
function ( reset ) { this . current Speed = 0 ; this . average Speed = 0 ; var chunks = this . chunks ; if ( reset ) { this . chunks = [ ] ; } each ( chunks , function ( c ) { if ( c . status ( ) = = = 'uploading ' ) { c . abort ( ) ; this . flow Obj . upload Next Chunk ( ) ; } } , this ) ; } 
function ( ) { if ( typeof this . flow Obj . opts . init File Fn = = = "function " ) { this . flow Obj . opts . init File Fn ( this ) ; } this . abort ( true ) ; this . error = false ; 
function ( ) { if ( this . error ) { return 1 ; } if ( this . chunks . length = = = 1 ) { this . _prev Progress = Math . max ( this . _prev Progress , this . chunks [ 0 ] . progress ( ) ) ; return this . _prev Progress ; } 
function ( ) { var outstanding = false ; each ( this . chunks , function ( chunk ) { var status = chunk . status ( ) ; if ( status = = = 'pending ' | | status = = = 'uploading ' | | status = = = 'reading ' | | chunk . preprocess State = = = 1 | | chunk . read State = = = 1 ) { outstanding = true ; return false ; } } ) ; return ! outstanding ; } 
function ( ) { if ( this . paused | | this . error ) { return 0 ; } var delta = this . size - this . size Uploaded ( ) ; if ( delta & & ! this . average Speed ) { return Number . POSITIVE _INFINITY ; } if ( ! delta & & ! this . average Speed ) { return 0 ; } return Math . floor ( delta / this . average Speed ) ; } 
function web APIFile Read ( file Obj , start Byte , end Byte , file Type , chunk ) { var function _name = 'slice ' ; if ( file Obj . file . slice ) function _name = 'slice ' ; else if ( file Obj . file . moz Slice ) function _name = 'moz Slice ' ; else if ( file Obj . file . webkit Slice ) function _name = 'webkit Slice ' ; chunk . read Finished ( file Obj . file [ function _name ] ( start Byte , end Byte , file Type ) ) ; } 
function Flow Chunk ( flow Obj , file Obj , offset ) { this . flow Obj = flow Obj ; this . file Obj = file Obj ; this . offset = offset ; this . tested = false ; this . retries = 0 ; this . pending Retry = false ; this . preprocess State = 0 ; this . read State = 0 ; this . loaded = 0 ; this . total = 0 ; this . chunk Size = this . flow Obj . opts . chunk Size ; this . start Byte = this . offset * this . chunk Size ; this . compute End Byte = function ( ) { var end Byte = Math . min ( this . file Obj . size , ( this . offset + 1 ) * this . chunk Size ) ; if ( this . file Obj . size - end Byte < this . chunk Size & & ! this . flow Obj . opts . force Chunk Size ) { * Chunk end byte in a file * @type {number } * / this . end Byte = this . compute End Byte ( ) ; this . xhr = null ; var $ = this ; this . event = function ( event , args ) { args = Array . prototype . slice . call ( arguments ) ; args . unshift ( $ ) ; $ . file Obj . chunk Event . apply ( $ . file Obj , args ) ; } ; this . progress Handler = function ( event ) { if ( event . length Computable ) { $ . loaded = event . loaded ; $ . total = event . total ; } $ . event ( 'progress ' , event ) ; } ; this . test Handler = function ( event ) { var status = $ . status ( true ) ; if ( status = = = 'error ' ) { $ . event ( status , $ . message ( ) ) ; $ . flow Obj . upload Next Chunk ( ) ; } else if ( status = = = 'success ' ) { $ . tested = true ; $ . event ( status , $ . message ( ) ) ; $ . flow Obj . upload Next Chunk ( ) ; } else if ( ! $ . file Obj . paused ) { * Upload has stopped * @param {Event } event * / this . done Handler = function ( event ) { var status = $ . status ( ) ; if ( status = = = 'success ' | | status = = = 'error ' ) { delete this . data ; $ . event ( status , $ . message ( ) ) ; $ . flow Obj . upload Next Chunk ( ) ; } else { $ . event ( 'retry ' , $ . message ( ) ) ; $ . pending Retry = true ; $ . abort ( ) ; $ . retries + + ; var retry Interval = $ . flow Obj . opts . chunk Retry Interval ; if ( retry Interval ! = = null ) { set Timeout ( function ( ) { $ . send ( ) ; } , retry Interval ) ; } else { $ . send ( ) ; } } } ; } 
function ( ) { 
function ( ) { var preprocess = this . flow Obj . opts . preprocess ; var read = this . flow Obj . opts . read File Fn ; if ( typeof preprocess = = = 'function ' ) { switch ( this . preprocess State ) { case 0 : this . preprocess State = 1 ; preprocess ( this ) ; return ; case 1 : return ; } } switch ( this . read State ) { case 0 : this . read State = 1 ; read ( this . file Obj , this . start Byte , this . end Byte , this . file Obj . file . type , this ) ; return ; case 1 : return ; } if ( this . flow Obj . opts . test Chunks & & ! this . tested ) { this . test ( ) ; return ; } this . loaded = 0 ; this . total = 0 ; this . pending Retry = false ; 
function ( is Test ) { if ( this . read State = = = 1 ) { return 'reading ' ; } else if ( this . pending Retry | | this . preprocess State = = = 1 ) { 
function ( method , is Test , params Method , blob ) { 
function eval Opts ( data , args ) { if ( typeof data = = = "function " ) { 
function extend ( dst , src ) { each ( arguments , function ( obj ) { if ( obj ! = = dst ) { each ( obj , function ( value , key ) { dst [ key ] = value ; } ) ; } } ) ; return dst ; } 
function each ( obj , callback , context ) { if ( ! obj ) { return ; } var key ; 
function create Table ( ) { table Name = arguments [ 0 ] ; var fname = ' ' ; var callback ; if ( arguments . length = = = 2 ) { callback = arguments [ 1 ] ; fname = path . join ( user Data , table Name + ' .json ' ) ; } else if ( arguments . length = = = 3 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; callback = arguments [ 2 ] ; } 
function valid ( ) { var f Name = ' ' if ( arguments . length = = 2 ) { 
function insert Table Content ( ) { let table Name = arguments [ 0 ] ; var fname = ' ' ; var callback ; var table Row ; if ( arguments . length = = = 3 ) { callback = arguments [ 2 ] ; fname = path . join ( user Data , arguments [ 0 ] + ' .json ' ) ; table Row = arguments [ 1 ] ; } else if ( arguments . length = = = 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; callback = arguments [ 3 ] ; table Row = arguments [ 2 ] ; } let exists = fs . exists Sync ( fname ) ; if ( exists ) { 
function get All ( ) { var fname = ' ' ; var callback ; var table Name = arguments [ 0 ] ; if ( arguments . length = = = 2 ) { fname = path . join ( user Data , table Name + ' .json ' ) ; callback = arguments [ 1 ] ; } else if ( arguments . length = = = 3 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; callback = arguments [ 2 ] ; } let exists = fs . exists Sync ( fname ) ; if ( exists ) { try { let table = JSON . parse ( fs . read File Sync ( fname ) ) ; callback ( true , table [ table Name ] ) ; return ; } catch ( e ) { callback ( false , [ ] ) ; return ; } } else { callback ( false , 'Table file does not exist ! ' ) ; return ; } } 
function get Field ( ) { let fname = ' ' let table Name = arguments [ 0 ] let callback let key if ( arguments . length = = = 3 ) { fname = path . join ( user Data , table Name + ' .json ' ) ; callback = arguments [ 2 ] ; key = arguments [ 1 ] } else if ( arguments . length = = = 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; callback = arguments [ 3 ] ; key = arguments [ 2 ] } let exists = fs . exists Sync ( fname ) if ( exists ) { let table = JSON . parse ( fs . read File Sync ( fname ) ) ; const rows = table [ table Name ] let data = [ ] for ( let i = 0 ; i < rows . length ; i + + ) { if ( rows [ i ] . has Own Property ( key ) ) { data . push ( rows [ i ] [ key ] ) } } callback ( true , data ) } else { callback ( false , 'The table you are trying to access does not exist . ' ) return } } 
function count ( ) { let table Name = arguments [ 0 ] let callback if ( arguments . length = = = 2 ) { callback = arguments [ 1 ] get All ( table Name , ( succ , data ) = > { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else if ( arguments . length = = = 3 ) { callback = arguments [ 2 ] get All ( table Name , arguments [ 1 ] , ( succ , data ) = > { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else { callback ( false , 'Wrong number of arguments . Must be either 2 or 3 arguments including callback function . ' ) return } } 
function get Rows ( ) { let table Name = arguments [ 0 ] ; var fname = ' ' ; var callback ; var where ; if ( arguments . length = = = 3 ) { fname = path . join ( user Data , table Name + ' .json ' ) ; where = arguments [ 1 ] ; callback = arguments [ 2 ] ; } else if ( arguments . length = = = 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; where = arguments [ 2 ] ; callback = arguments [ 3 ] ; } let exists = fs . exists Sync ( fname ) ; let where Keys ; 
function update Row ( ) { let table Name = arguments [ 0 ] ; var fname = ' ' ; var where ; var set ; var callback ; if ( arguments . length = = = 4 ) { fname = path . join ( user Data , table Name + ' .json ' ) ; where = arguments [ 1 ] ; set = arguments [ 2 ] ; callback = arguments [ 3 ] ; } else if ( arguments . length = = = 5 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; where = arguments [ 2 ] ; set = arguments [ 3 ] ; callback = arguments [ 4 ] ; } let exists = fs . exists Sync ( fname ) ; let where Keys = Object . keys ( where ) ; let set Keys = Object . keys ( set ) ; if ( exists ) { let table = JSON . parse ( fs . read File Sync ( fname ) ) ; let rows = table [ table Name ] ; let matched = 0 ; 
function search ( ) { let table Name = arguments [ 0 ] ; var fname = ' ' ; var field ; var keyword ; var callback ; if ( arguments . length = = = 4 ) { fname = path . join ( user Data , table Name + ' .json ' ) ; field = arguments [ 1 ] ; keyword = arguments [ 2 ] ; callback = arguments [ 3 ] ; } else if ( arguments . length = = = 5 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + ' .json ' ) ; field = arguments [ 2 ] ; keyword = arguments [ 3 ] ; callback = arguments [ 4 ] ; } let exists = fs . exists Sync ( fname ) ; if ( exists ) { let table = JSON . parse ( fs . read File Sync ( fname ) ) ; let rows = table [ table Name ] ; if ( rows . length > 0 ) { 
function create Header Getter ( str ) { var name = str . to Lower Case ( ) return function ( req , res ) { 
function assign Not Null ( target , . . . sources ) { sources . for Each ( source = > { Object . keys ( source ) . for Each ( key = > { if ( source [ key ] ! = null ) { target [ key ] = source [ key ] ; } } ) } ) ; return target ; } 
function Layer ( options ) { this . options = { } ; if ( options ! = null ) { [ "resource Type " , "type " , "public Id " , "format " ] . for Each ( ( function ( _this ) { return function ( key ) { var ref ; return _this . options [ key ] = ( ref = options [ key ] ) ! = null ? ref : options [ Util . snake Case ( key ) ] ; } ; } ) ( this ) ) ; } } 
function Param ( name , short Name , process ) { if ( process = = null ) { process = cloudinary . Util . identity ; } this . name = name ; this . short Name = short Name ; this . process = process ; } 
function Array Param ( name , short Name , sep , process ) { if ( sep = = null ) { sep = ' . ' ; } this . sep = sep ; Array Param . _ _super _ _ . constructor . call ( this , name , short Name , process ) ; } 
function Transformation Param ( name , short Name , sep , process ) { if ( short Name = = null ) { short Name = "t " ; } if ( sep = = null ) { sep = ' . ' ; } this . sep = sep ; Transformation Param . _ _super _ _ . constructor . call ( this , name , short Name , process ) ; } 
function Range Param ( name , short Name , process ) { if ( process = = null ) { process = this . norm _range _value ; } Range Param . _ _super _ _ . constructor . call ( this , name , short Name , process ) ; } 
function Expression ( expression Str ) { this . expressions = [ ] ; if ( expression Str ! = null ) { this . expressions . push ( Expression . normalize ( expression Str ) ) ; } } 
function Configuration ( options ) { if ( options = = null ) { options = { } ; } this . configuration = Util . clone Deep ( options ) ; Util . defaults ( this . configuration , DEFAULT _CONFIGURATION _PARAMS ) ; } 
function Transformation Base ( options ) { var parent , trans ; if ( options = = null ) { options = { } ; } parent = void 0 ; trans = { } ; this . to Options | | ( this . to Options = function ( with Chain ) { var key , list , opt , ref , ref 1 , tr , value ; if ( with Chain = = null ) { with Chain = true ; } opt = { } ; for ( key in trans ) { value = trans [ key ] ; opt [ key ] = value . orig Value ; } ref = this . other Options ; for ( key in ref ) { value = ref [ key ] ; if ( value ! = = void 0 ) { opt [ key ] = value ; } } if ( with Chain & & ! Util . is Empty ( this . chained ) ) { list = ( function ( ) { var j , len , ref 1 , results ; ref 1 = this . chained ; results = [ ] ; for ( j = 0 , len = ref 1 . length ; j < len ; j + + ) { tr = ref 1 [ j ] ; results . push ( tr . to Options ( ) ) ; } return results ; } ) . call ( this ) ; list . push ( opt ) ; opt = { } ; ref 1 = this . other Options ; for ( key in ref 1 ) { value = ref 1 [ key ] ; if ( value ! = = void 0 ) { opt [ key ] = value ; } } opt . transformation = list ; } return opt ; } ) ; this . set Parent | | ( this . set Parent = function ( object ) { parent = object ; if ( object ! = null ) { this . from Options ( typeof object . to Options = = = "function " ? object . to Options ( ) : void 0 ) ; } return this ; } ) ; this . get Parent | | ( this . get Parent = function ( ) { return parent ; } ) ; this . param | | ( this . param = function ( value , name , abbr , default Value , process ) { if ( process = = null ) { if ( Util . is Function ( default Value ) ) { process = default Value ; } else { process = Util . identity ; } } trans [ name ] = new Param ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . raw Param | | ( this . raw Param = function ( value , name , abbr , default Value , process ) { if ( process = = null ) { process = Util . identity ; } process = last Arg Callback ( arguments ) ; trans [ name ] = new Raw Param ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . range Param | | ( this . range Param = function ( value , name , abbr , default Value , process ) { if ( process = = null ) { process = Util . identity ; } process = last Arg Callback ( arguments ) ; trans [ name ] = new Range Param ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . array Param | | ( this . array Param = function ( value , name , abbr , sep , default Value , process ) { if ( sep = = null ) { sep = " : " ; } if ( default Value = = null ) { default Value = [ ] ; } if ( process = = null ) { process = Util . identity ; } process = last Arg Callback ( arguments ) ; trans [ name ] = new Array Param ( name , abbr , sep , process ) . set ( value ) ; return this ; } ) ; this . transformation Param | | ( this . transformation Param = function ( value , name , abbr , sep , default Value , process ) { if ( sep = = null ) { sep = " . " ; } if ( process = = null ) { process = Util . identity ; } process = last Arg Callback ( arguments ) ; trans [ name ] = new Transformation Param ( name , abbr , sep , process ) . set ( value ) ; return this ; } ) ; this . layer Param | | ( this . layer Param = function ( value , name , abbr ) { trans [ name ] = new Layer Param ( name , abbr ) . set ( value ) ; return this ; } ) ; this . get Value | | ( this . get Value = function ( name ) { var ref , ref 1 ; return ( ref = ( ref 1 = trans [ name ] ) ! = null ? ref 1 . value ( ) : void 0 ) ! = null ? ref : this . other Options [ name ] ; } ) ; this . get | | ( this . get = function ( name ) { return trans [ name ] ; } ) ; this . remove | | ( this . remove = function ( name ) { var temp ; switch ( false ) { case trans [ name ] = = null : temp = trans [ name ] ; delete trans [ name ] ; return temp . orig Value ; case this . other Options [ name ] = = null : temp = this . other Options [ name ] ; delete this . other Options [ name ] ; return temp ; default : return null ; } } ) ; this . keys | | ( this . keys = function ( ) { var key ; return ( ( function ( ) { var results ; results = [ ] ; for ( key in trans ) { if ( key ! = null ) { results . push ( key . match ( VAR _NAME _RE ) ? key : Util . snake Case ( key ) ) ; } } return results ; } ) ( ) ) . sort ( ) ; } ) ; this . to Plain Object | | ( this . to Plain Object = function ( ) { var hash , key , list , tr ; hash = { } ; for ( key in trans ) { hash [ key ] = trans [ key ] . value ( ) ; if ( Util . is Plain Object ( hash [ key ] ) ) { hash [ key ] = Util . clone Deep ( hash [ key ] ) ; } } if ( ! Util . is Empty ( this . chained ) ) { list = ( function ( ) { var j , len , ref , results ; ref = this . chained ; results = [ ] ; for ( j = 0 , len = ref . length ; j < len ; j + + ) { tr = ref [ j ] ; results . push ( tr . to Plain Object ( ) ) ; } return results ; } ) . call ( this ) ; list . push ( hash ) ; hash = { transformation : list } ; } return hash ; } ) ; this . chain | | ( this . chain = function ( ) { var names , tr ; names = Object . get Own Property Names ( trans ) ; if ( names . length ! = = 0 ) { tr = new this . constructor ( this . to Options ( false ) ) ; this . reset Transformations ( ) ; this . chained . push ( tr ) ; } return this ; } ) ; this . reset Transformations | | ( this . reset Transformations = function ( ) { trans = { } ; return this ; } ) ; this . other Options | | ( this . other Options = { } ) ; this . chained = [ ] ; if ( ! Util . is Empty ( options ) ) { this . from Options ( options ) ; } } 
function Transformation ( options ) { if ( options = = null ) { options = { } ; } Transformation . _ _super _ _ . constructor . call ( this , options ) ; this ; } 
function Image Tag ( public Id , options ) { if ( options = = null ) { options = { } ; } Image Tag . _ _super _ _ . constructor . call ( this , "img " , public Id , options ) ; } 
function Video Tag ( public Id , options ) { if ( options = = null ) { options = { } ; } options = Util . defaults ( { } , options , Cloudinary . DEFAULT _VIDEO _PARAMS ) ; Video Tag . _ _super _ _ . constructor . call ( this , "video " , public Id . replace ( / \ . (mp 4 |ogv |webm ) $ / , ' ' ) , options ) ; } 
function Client Hints Meta Tag ( options ) { Client Hints Meta Tag . _ _super _ _ . constructor . call ( this , 'meta ' , void 0 , Util . assign ( { "http -equiv " : "Accept -CH " , content : "DPR , Viewport -Width , Width " } , options ) ) ; } 
function Cloudinary ( options ) { var configuration ; this . device Pixel Ratio Cache = { } ; this . responsive Config = { } ; this . responsive Resize Initialized = false ; configuration = new Configuration ( options ) ; this . config = function ( new Config , new Value ) { return configuration . config ( new Config , new Value ) ; } ; this . from Document = function ( ) { configuration . from Document ( ) ; return this ; } ; this . from Environment = function ( ) { configuration . from Environment ( ) ; return this ; } ; this . init = function ( ) { configuration . init ( ) ; return this ; } ; } 
function get Mode ( env , argv ) { 
function resolve Lodash ( context , request , callback ) { if ( / ^lodash \ / / . test ( request ) ) { callback ( null , { commonjs : request , commonjs 2 : request , amd : request , root : [ ' _ ' , request . split ( ' / ' ) [ 1 ] ] } ) ; } else { callback ( ) ; } } 
function base Config ( name , mode ) { const config = { name : ` $ { name } $ { mode } ` , mode , output : { library : 'cloudinary ' , library Target : 'umd ' , global Object : "this " , pathinfo : false } , optimization : { concatenate Modules : true , module Ids : 'named ' , used Exports : true , minimizer : [ new Terser Plugin ( { terser Options : { mangle : { keep _classnames : true , reserved : reserved , ie 8 : true } } , } ) ] } , resolve : { extensions : [ ' .js ' ] } , externals : [ { jquery : 'j Query ' } ] , node : { Buffer : false , process : false } , devtool : "source -map " , module : { rules : [ { test : / \ .m ?js $ / , exclude : / (node _modules |bower _components ) / , use : { loader : 'babel -loader ' } } ] } , plugins : [ new webpack . Banner Plugin ( { banner : ` $ { version } ` , 
function cloudinary Url Prefix ( public Id , options ) { var cdn Part , host , path , protocol , ref , subdomain ; if ( ( ( ref = options . cloud _name ) ! = null ? ref . index Of ( " / " ) : void 0 ) = = = 0 ) { return ' /res ' + options . cloud _name ; } 
function finalize Resource Type ( resource Type = "image " , type = "upload " , url Suffix , use Root Path , shorten ) { var options ; resource Type = resource Type = = null ? "image " : resource Type ; type = type = = null ? "upload " : type ; if ( is Plain Object ( resource Type ) ) { options = resource Type ; resource Type = options . resource _type ; type = options . type ; url Suffix = options . url _suffix ; use Root Path = options . use _root _path ; shorten = options . shorten ; } if ( type = = null ) { type = 'upload ' ; } if ( url Suffix ! = null ) { resource Type = SEO _TYPES [ ` $ { resource Type } $ { type } ` ] ; type = null ; if ( resource Type = = null ) { throw new Error ( ` $ { Object . keys ( SEO _TYPES ) . join ( ' , ' ) } ` ) ; } } if ( use Root Path ) { if ( resource Type = = = 'image ' & & type = = = 'upload ' | | resource Type = = = "images " ) { resource Type = null ; type = null ; } else { throw new Error ( "Root path only supported for image /upload " ) ; } } if ( shorten & & resource Type = = = 'image ' & & type = = = 'upload ' ) { resource Type = 'iu ' ; type = null ; } return [ resource Type , type ] . join ( " / " ) ; } 
function Wheel ( parent , options ) { _class Call Check ( this , Wheel ) ; var _this = _possible Constructor Return ( this , ( Wheel . _ _proto _ _ | | Object . get Prototype Of ( Wheel ) ) . call ( this , parent ) ) ; options = options | | { } ; _this . percent = options . percent | | 0 . 1 ; _this . center = options . center ; _this . reverse = options . reverse ; _this . smooth = options . smooth ; _this . interrupt = typeof options . interrupt = = = 'undefined ' ? true : options . interrupt ; return _this ; } 
function Mouse Edges ( parent , options ) { _class Call Check ( this , Mouse Edges ) ; var _this = _possible Constructor Return ( this , ( Mouse Edges . _ _proto _ _ | | Object . get Prototype Of ( Mouse Edges ) ) . call ( this , parent ) ) ; options = options | | { } ; _this . options = options ; _this . reverse = options . reverse ? 1 : - 1 ; _this . no Decelerate = options . no Decelerate ; _this . linear = options . linear ; _this . radius Squared = Math . pow ( options . radius , 2 ) ; _this . resize ( ) ; _this . speed = options . speed | | 8 ; return _this ; } 
function Drag ( parent , options ) { _class Call Check ( this , Drag ) ; options = options | | { } ; var _this = _possible Constructor Return ( this , ( Drag . _ _proto _ _ | | Object . get Prototype Of ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheel Active = utils . defaults ( options . wheel , true ) ; _this . wheel Scroll = options . wheel Scroll | | 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clamp Wheel = options . clamp Wheel ; _this . factor = options . factor | | 1 ; _this . x Direction = ! options . direction | | options . direction = = = 'all ' | | options . direction = = = 'x ' ; _this . y Direction = ! options . direction | | options . direction = = = 'all ' | | options . direction = = = 'y ' ; _this . parse Underflow ( options . underflow | | 'center ' ) ; _this . mouse Buttons ( options . mouse Buttons ) ; return _this ; } 
function Snap Zoom ( parent , options ) { _class Call Check ( this , Snap Zoom ) ; var _this = _possible Constructor Return ( this , ( Snap Zoom . _ _proto _ _ | | Object . get Prototype Of ( Snap Zoom ) ) . call ( this , parent ) ) ; options = options | | { } ; _this . width = options . width ; _this . height = options . height ; if ( _this . width > 0 ) { _this . x _scale = parent . _screen Width / _this . width ; } if ( _this . height > 0 ) { _this . y _scale = parent . _screen Height / _this . height ; } _this . x Independent = utils . exists ( _this . x _scale ) ; _this . y Independent = utils . exists ( _this . y _scale ) ; _this . x _scale = _this . x Independent ? _this . x _scale : _this . y _scale ; _this . y _scale = _this . y Independent ? _this . y _scale : _this . x _scale ; _this . time = utils . defaults ( options . time , 1 0 0 0 ) ; _this . ease = utils . ease ( options . ease , 'ease In Out Sine ' ) ; _this . center = options . center ; _this . no Move = options . no Move ; _this . stop On Resize = options . stop On Resize ; _this . remove On Interrupt = options . remove On Interrupt ; _this . remove On Complete = utils . defaults ( options . remove On Complete , true ) ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; if ( _this . time = = = 0 ) { parent . container . scale . x = _this . x _scale ; parent . container . scale . y = _this . y _scale ; if ( _this . remove On Complete ) { _this . parent . remove Plugin ( 'snap -zoom ' ) ; } } else if ( options . force Start ) { _this . create Snapping ( ) ; } return _this ; } 
function Snap ( parent , x , y , options ) { _class Call Check ( this , Snap ) ; var _this = _possible Constructor Return ( this , ( Snap . _ _proto _ _ | | Object . get Prototype Of ( Snap ) ) . call ( this , parent ) ) ; options = options | | { } ; _this . friction = options . friction | | 0 . 8 ; _this . time = options . time | | 1 0 0 0 ; _this . ease = utils . ease ( options . ease , 'ease In Out Sine ' ) ; _this . x = x ; _this . y = y ; _this . top Left = options . top Left ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; _this . remove On Complete = options . remove On Complete ; _this . remove On Interrupt = options . remove On Interrupt ; if ( options . force Start ) { _this . start Ease ( ) ; } return _this ; } 
function each ( object , fn ) { keys ( object ) . for Each ( function ( key ) { return fn ( object [ key ] , key ) ; } ) ; } 
function reduce ( object , fn ) { var initial = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : 0 ; return keys ( object ) . reduce ( function ( accum , key ) { return fn ( accum , object [ key ] , key ) ; } , initial ) ; } 
function assign ( target ) { for ( var _len = arguments . length , sources = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key + + ) { sources [ _key - 1 ] = arguments [ _key ] ; } if ( Object . assign ) { return Object . assign . apply ( Object , [ target ] . concat ( sources ) ) ; } sources . for Each ( function ( source ) { if ( ! source ) { return ; } each ( source , function ( value , key ) { target [ key ] = value ; } ) ; } ) ; return target ; } 
function is Plain ( value ) { return is Object ( value ) & & to String . call ( value ) = = = ' [object Object ] ' & & value . constructor = = = Object ; } 
function log By Type ( type , args ) { var stringify = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : ! ! IE _VERSION & & IE _VERSION < 1 1 ; var lvl = log . levels [ level ] ; var lvl Reg Exp = new Reg Exp ( ' ^ ( ' + lvl + ' ) $ ' ) ; if ( type ! = = 'log ' ) { 
function computed Style ( el , prop ) { if ( ! el | | ! prop ) { return ' ' ; } if ( typeof window . get Computed Style = = = 'function ' ) { var cs = window . get Computed Style ( el ) ; return cs ? cs [ prop ] : ' ' ; } return el . current Style [ prop ] | | ' ' ; } 
function create El ( ) { var tag Name = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 'div ' ; var properties = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; var attributes = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : { } ; var content = arguments [ 3 ] ; var el = document . create Element ( tag Name ) ; Object . get Own Property Names ( properties ) . for Each ( function ( prop Name ) { var val = properties [ prop Name ] ; 
function add Class ( element , class To Add ) { if ( element . class List ) { element . class List . add ( class To Add ) ; 
function toggle Class ( element , class To Toggle , predicate ) { 
function get Bounding Client Rect ( el ) { if ( el & & el . get Bounding Client Rect & & el . parent Node ) { var rect = el . get Bounding Client Rect ( ) ; var result = { } ; [ 'bottom ' , 'height ' , 'left ' , 'right ' , 'top ' , 'width ' ] . for Each ( function ( k ) { if ( rect [ k ] ! = = undefined ) { result [ k ] = rect [ k ] ; } } ) ; if ( ! result . height ) { result . height = parse Float ( computed Style ( el , 'height ' ) ) ; } if ( ! result . width ) { result . width = parse Float ( computed Style ( el , 'width ' ) ) ; } return result ; } } 
function get Pointer Position ( el , event ) { var position = { } ; var box = find Position ( el ) ; var box W = el . offset Width ; var box H = el . offset Height ; var box Y = box . top ; var box X = box . left ; var page Y = event . page Y ; var page X = event . page X ; if ( event . changed Touches ) { page X = event . changed Touches [ 0 ] . page X ; page Y = event . changed Touches [ 0 ] . page Y ; } position . y = Math . max ( 0 , Math . min ( 1 , ( box Y - page Y + box H ) / box H ) ) ; position . x = Math . max ( 0 , Math . min ( 1 , ( page X - box X ) / box W ) ) ; return position ; } 
function append Content ( el , content ) { normalize Content ( content ) . for Each ( function ( node ) { return el . append Child ( node ) ; } ) ; return el ; } 
function get Data ( el ) { var id = el [ el Id Attr ] ; if ( ! id ) { id = el [ el Id Attr ] = new GUID ( ) ; } if ( ! el Data [ id ] ) { el Data [ id ] = { } ; } return el Data [ id ] ; } 
function has Data ( el ) { var id = el [ el Id Attr ] ; if ( ! id ) { return false ; } return ! ! Object . get Own Property Names ( el Data [ id ] ) . length ; } 
function remove Data ( el ) { var id = el [ el Id Attr ] ; if ( ! id ) { return ; } 
function _clean Up Events ( elem , type ) { var data = get Data ( elem ) ; 
function _handle Multiple Events ( fn , elem , types , callback ) { types . for Each ( function ( type ) { 
function on ( elem , type , fn ) { if ( Array . is Array ( type ) ) { return _handle Multiple Events ( on , elem , type , fn ) ; } var data = get Data ( elem ) ; 
function off ( elem , type , fn ) { 
function one ( elem , type , fn ) { if ( Array . is Array ( type ) ) { return _handle Multiple Events ( one , elem , type , fn ) ; } var func = function func ( ) { off ( elem , type , func ) ; fn . apply ( this , arguments ) ; } ; 
function auto Setup ( ) { 
function auto Setup Timeout ( wait , vjs ) { if ( vjs ) { videojs $ 2 = vjs ; } window . set Timeout ( auto Setup , wait ) ; } 
function set Text Content ( el , content ) { if ( el . style Sheet ) { el . style Sheet . css Text = content ; } else { el . text Content = content ; } } 
function bind ( context , fn , uid ) { 
function throttle ( fn , wait ) { var last = Date . now ( ) ; var throttled = function throttled ( ) { var now = Date . now ( ) ; if ( now - last > = wait ) { fn . apply ( undefined , arguments ) ; last = now ; } } ; return throttled ; } 
function is Evented ( object ) { return object instanceof Event Target | | ! ! object . event Bus El _ & & [ 'on ' , 'one ' , 'off ' , 'trigger ' ] . every ( function ( k ) { return typeof object [ k ] = = = 'function ' ; } ) ; } 
function is Valid Event Type ( type ) { return ( 
function normalize Listen Args ( self , args ) { 
function listen ( target , method , type , listener ) { validate Target ( target ) ; if ( target . node Name ) { Events [ method ] ( target , type , listener ) ; } else { target [ method ] ( type , listener ) ; } } 
function on $ $ 1 ( ) { var _this = this ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } var _normalize Listen Args = normalize Listen Args ( this , args ) , is Targeting Self = _normalize Listen Args . is Targeting Self , target = _normalize Listen Args . target , type = _normalize Listen Args . type , listener = _normalize Listen Args . listener ; listen ( target , 'on ' , type , listener ) ; 
function one $ $ 1 ( ) { var _this 2 = this ; for ( var _len 2 = arguments . length , args = Array ( _len 2 ) , _key 2 = 0 ; _key 2 < _len 2 ; _key 2 + + ) { args [ _key 2 ] = arguments [ _key 2 ] ; } var _normalize Listen Args 2 = normalize Listen Args ( this , args ) , is Targeting Self = _normalize Listen Args 2 . is Targeting Self , target = _normalize Listen Args 2 . target , type = _normalize Listen Args 2 . type , listener = _normalize Listen Args 2 . listener ; 
function off $ $ 1 ( target Or Type , type Or Listener , listener ) { 
function evented ( target ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; var event Bus Key = options . event Bus Key ; 
function set State ( state Updates ) { var _this = this ; * An event triggered on an object that is both * { @link module :stateful |stateful } and { @link module :evented |evented } * indicating that its state has changed . * * @event module :stateful ~Stateful Mixin #statechanged * @type {Object } * @property {Object } changes * A hash containing the properties that were changed and * the values they were changed `from ` and `to ` . * / this . trigger ( { changes : changes , type : 'statechanged ' } ) ; } return changes ; } 
function stateful ( target , default State ) { assign ( target , Stateful Mixin ) ; 
function merge Options ( ) { var result = { } ; for ( var _len = arguments . length , sources = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { sources [ _key ] = arguments [ _key ] ; } sources . for Each ( function ( source ) { if ( ! source ) { return ; } each ( source , function ( value , key ) { if ( ! is Plain ( value ) ) { result [ key ] = value ; return ; } if ( ! is Plain ( result [ key ] ) ) { result [ key ] = { } ; } result [ key ] = merge Options ( result [ key ] , value ) ; } ) ; } ) ; return result ; } 
function Component ( player , options , ready ) { class Call Check ( this , Component ) ; 
function range Check ( fn Name , index , max Index ) { if ( typeof index ! = = 'number ' | | index < 0 | | index > max Index ) { throw new Error ( 'Failed to execute \ ' ' + fn Name + ' \ ' on \ 'Time Ranges \ ' : The index provided ( ' + index + ' ) is non -numeric or out of bounds ( 0 - ' + max Index + ' ) . ' ) ; } } 
function get Range ( fn Name , value Index , ranges , range Index ) { range Check ( fn Name , range Index , ranges . length - 1 ) ; return ranges [ range Index ] [ value Index ] ; } 
function create Time Ranges Obj ( ranges ) { if ( ranges = = = undefined | | ranges . length = = = 0 ) { return { length : 0 , start : function start ( ) { throw new Error ( 'This Time Ranges object is empty ' ) ; } , end : function end ( ) { throw new Error ( 'This Time Ranges object is empty ' ) ; } } ; } return { length : ranges . length , start : get Range . bind ( null , 'start ' , 0 , ranges ) , end : get Range . bind ( null , 'end ' , 1 , ranges ) } ; } 
function create Time Ranges ( start , end ) { if ( Array . is Array ( start ) ) { return create Time Ranges Obj ( start ) ; } else if ( start = = = undefined | | end = = = undefined ) { return create Time Ranges Obj ( ) ; } return create Time Ranges Obj ( [ [ start , end ] ] ) ; } 
function buffered Percent ( buffered , duration ) { var buffered Duration = 0 ; var start = void 0 ; var end = void 0 ; if ( ! duration ) { return 0 ; } if ( ! buffered | | ! buffered . length ) { buffered = create Time Ranges ( 0 , 0 ) ; } for ( var i = 0 ; i < buffered . length ; i + + ) { start = buffered . start ( i ) ; end = buffered . end ( i ) ; 
function Media Error ( value ) { 
function track To Json _ ( track ) { var ret = [ 'kind ' , 'label ' , 'language ' , 'id ' , 'in Band Metadata Track Dispatch Type ' , 'mode ' , 'src ' ] . reduce ( function ( acc , prop , i ) { if ( track [ prop ] ) { acc [ prop ] = track [ prop ] ; } return acc ; } , { cues : track . cues & & Array . prototype . map . call ( track . cues , function ( cue ) { return { start Time : cue . start Time , end Time : cue . end Time , text : cue . text , id : cue . id } ; } ) } ) ; return ret ; } 
function text Tracks To Json ( tech ) { var track Els = tech . $ $ ( 'track ' ) ; var track Objs = Array . prototype . map . call ( track Els , function ( t ) { return t . track ; } ) ; var tracks = Array . prototype . map . call ( track Els , function ( track El ) { var json = track To Json _ ( track El . track ) ; if ( track El . src ) { json . src = track El . src ; } return json ; } ) ; return tracks . concat ( Array . prototype . filter . call ( tech . text Tracks ( ) , function ( track ) { return track Objs . index Of ( track ) = = = - 1 ; } ) . map ( track To Json _ ) ) ; } 
function json To Text Tracks ( json , tech ) { json . for Each ( function ( track ) { var added Track = tech . add Remote Text Track ( track ) . track ; if ( ! track . src & & track . cues ) { track . cues . for Each ( function ( cue ) { return added Track . add Cue ( cue ) ; } ) ; } } ) ; return tech . text Tracks ( ) ; } 
function Track List ( ) { var tracks = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : [ ] ; var _ret ; var list = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : null ; class Call Check ( this , Track List ) ; var _this = possible Constructor Return ( this , _Event Target . call ( this ) ) ; if ( ! list ) { list = _this ; * @memberof Track List * @member {number } length * The current number of `Track `s in the this Trackist . * @instance * / Object . define Property ( list , 'length ' , { get : function get $ $ 1 ( ) { return this . tracks _ . length ; } } ) ; for ( var i = 0 ; i < tracks . length ; i + + ) { list . add Track ( tracks [ i ] ) ; } 
function Audio Track List ( ) { var _this , _ret ; var tracks = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : [ ] ; class Call Check ( this , Audio Track List ) ; var list = void 0 ; 
function disable Others ( list , track ) { for ( var i = 0 ; i < list . length ; i + + ) { if ( ! Object . keys ( list [ i ] ) . length | | track . id = = = list [ i ] . id ) { continue ; } 
function Video Track List ( ) { var _this , _ret ; var tracks = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : [ ] ; class Call Check ( this , Video Track List ) ; var list = void 0 ; * @member {number } Video Track List #selected Index * The current index of the selected { @link Video Track ` } . * / Object . define Property ( list , 'selected Index ' , { get : function get $ $ 1 ( ) { for ( var _i = 0 ; _i < this . length ; _i + + ) { if ( this [ _i ] . selected ) { return _i ; } } return - 1 ; } , set : function set $ $ 1 ( ) { } } ) ; return _ret = list , possible Constructor Return ( _this , _ret ) ; } 
function Text Track List ( ) { var _this , _ret ; var tracks = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : [ ] ; class Call Check ( this , Text Track List ) ; var list = void 0 ; 
function Html Track Element List ( ) { var track Elements = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : [ ] ; class Call Check ( this , Html Track Element List ) ; var list = this ; * @memberof Html Track Element List * @member {number } length * The current number of `Track `s in the this Trackist . * @instance * / Object . define Property ( list , 'length ' , { get : function get $ $ 1 ( ) { return this . track Elements _ . length ; } } ) ; for ( var i = 0 , length = track Elements . length ; i < length ; i + + ) { list . add Track Element _ ( track Elements [ i ] ) ; } if ( IS _IE 8 ) { return list ; } } 
function Text Track Cue List ( cues ) { class Call Check ( this , Text Track Cue List ) ; var list = this ; * @memberof Text Track Cue List * @member {number } length * The current number of `Text Track Cue `s in the Text Track Cue List . * @instance * / Object . define Property ( list , 'length ' , { get : function get $ $ 1 ( ) { return this . length _ ; } } ) ; if ( IS _IE 8 ) { return list ; } } 
function get File Extension ( path ) { if ( typeof path = = = 'string ' ) { var split Path Re = / ^ ( \ / ? ) ( [ \s \S ] * ? ) ( ( ? : \ . { 1 , 2 } | [ ^ \ / ] + ? ) ( \ . ( [ ^ \ . \ / \ ? ] + ) ) ) ( ? : [ \ / ] * | [ \ ? ] . * ) $ / i ; var path Parts = split Path Re . exec ( path ) ; if ( path Parts ) { return path Parts . pop ( ) . to Lower Case ( ) ; } } return ' ' ; } 
function parse Cues ( src Content , track ) { var parser = new window . Web VTT . Parser ( window , window . vttjs , window . Web VTT . String Decoder ( ) ) ; var errors = [ ] ; parser . oncue = function ( cue ) { track . add Cue ( cue ) ; } ; parser . onparsingerror = function ( error ) { errors . push ( error ) ; } ; parser . onflush = function ( ) { track . trigger ( { type : 'loadeddata ' , target : track } ) ; } ; parser . parse ( src Content ) ; if ( errors . length > 0 ) { if ( window . console & & window . console . group Collapsed ) { window . console . group Collapsed ( 'Text Track parsing errors for ' + track . src ) ; } errors . for Each ( function ( error ) { return log $ 1 . error ( error ) ; } ) ; if ( window . console & & window . console . group End ) { window . console . group End ( ) ; } } parser . flush ( ) ; } 
function load Track ( src , track ) { var opts = { uri : src } ; var cross Origin = is Cross Origin ( src ) ; if ( cross Origin ) { opts . cors = cross Origin ; } xhr ( opts , bind ( this , function ( err , response , response Body ) { if ( err ) { return log $ 1 . error ( err , response ) ; } track . loaded _ = true ; 
function create Track Helper ( self , kind , label , language ) { var options = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : { } ; var tracks = self . text Tracks ( ) ; options . kind = kind ; if ( label ) { options . label = label ; } if ( language ) { options . language = language ; } options . tech = self ; var track = new ALL . text . Track Class ( options ) ; tracks . add Track ( track ) ; return track ; } 
function Tech ( ) { var options = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } ; var ready = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : function ( ) { } ; class Call Check ( this , Tech ) ; 
function filter Source ( src ) { 
function Clickable Component ( player , options ) { class Call Check ( this , Clickable Component ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . emit Tap Events ( ) ; _this . enable ( ) ; return _this ; } 
function Poster Image ( player , options ) { class Call Check ( this , Poster Image ) ; var _this = possible Constructor Return ( this , _Clickable Component . call ( this , player , options ) ) ; _this . update ( ) ; player . on ( 'posterchange ' , bind ( _this , _this . update ) ) ; return _this ; } 
function construct Color ( color , opacity ) { return 'rgba ( ' + 
function Text Track Display ( player , options , ready ) { class Call Check ( this , Text Track Display ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options , ready ) ) ; player . on ( 'loadstart ' , bind ( _this , _this . toggle Display ) ) ; player . on ( 'texttrackchange ' , bind ( _this , _this . update Display ) ) ; player . on ( 'loadstart ' , bind ( _this , _this . preselect Track ) ) ; 
function Close Button ( player , options ) { class Call Check ( this , Close Button ) ; var _this = possible Constructor Return ( this , _Button . call ( this , player , options ) ) ; _this . control Text ( options & & options . control Text | | _this . localize ( 'Close ' ) ) ; return _this ; } 
function Play Toggle ( player , options ) { class Call Check ( this , Play Toggle ) ; var _this = possible Constructor Return ( this , _Button . call ( this , player , options ) ) ; _this . on ( player , 'play ' , _this . handle Play ) ; _this . on ( player , 'pause ' , _this . handle Pause ) ; _this . on ( player , 'ended ' , _this . handle Ended ) ; return _this ; } 
function format Time ( seconds ) { var guide = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : seconds ; seconds = seconds < 0 ? 0 : seconds ; var s = Math . floor ( seconds % 6 0 ) ; var m = Math . floor ( seconds / 6 0 % 6 0 ) ; var h = Math . floor ( seconds / 3 6 0 0 ) ; var gm = Math . floor ( guide / 6 0 % 6 0 ) ; var gh = Math . floor ( guide / 3 6 0 0 ) ; 
function Remaining Time Display ( player , options ) { class Call Check ( this , Remaining Time Display ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . throttled Update Content = throttle ( bind ( _this , _this . update Content ) , 2 5 ) ; _this . on ( player , [ 'timeupdate ' , 'durationchange ' ] , _this . throttled Update Content ) ; return _this ; } 
function Live Display ( player , options ) { class Call Check ( this , Live Display ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . update Showing ( ) ; _this . on ( _this . player ( ) , 'durationchange ' , _this . update Showing ) ; return _this ; } 
function Slider ( player , options ) { class Call Check ( this , Slider ) ; 
function Load Progress Bar ( player , options ) { class Call Check ( this , Load Progress Bar ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . part Els _ = [ ] ; _this . on ( player , 'progress ' , _this . update ) ; return _this ; } 
function Mouse Time Display ( player , options ) { class Call Check ( this , Mouse Time Display ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . update = throttle ( bind ( _this , _this . update ) , 2 5 ) ; return _this ; } 
function Seek Bar ( player , options ) { class Call Check ( this , Seek Bar ) ; var _this = possible Constructor Return ( this , _Slider . call ( this , player , options ) ) ; _this . update = throttle ( bind ( _this , _this . update ) , 5 0 ) ; _this . on ( player , [ 'timeupdate ' , 'ended ' ] , _this . update ) ; return _this ; } 
function Progress Control ( player , options ) { class Call Check ( this , Progress Control ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . handle Mouse Move = throttle ( bind ( _this , _this . handle Mouse Move ) , 2 5 ) ; _this . on ( _this . el _ , 'mousemove ' , _this . handle Mouse Move ) ; _this . throttled Handle Mouse Seek = throttle ( bind ( _this , _this . handle Mouse Seek ) , 2 5 ) ; _this . on ( [ 'mousedown ' , 'touchstart ' ] , _this . handle Mouse Down ) ; return _this ; } 
function Fullscreen Toggle ( player , options ) { class Call Check ( this , Fullscreen Toggle ) ; var _this = possible Constructor Return ( this , _Button . call ( this , player , options ) ) ; _this . on ( player , 'fullscreenchange ' , _this . handle Fullscreen Change ) ; return _this ; } 
function check Volume Support ( self , player ) { 
function Volume Bar ( player , options ) { class Call Check ( this , Volume Bar ) ; var _this = possible Constructor Return ( this , _Slider . call ( this , player , options ) ) ; _this . on ( 'slideractive ' , _this . update Last Volume _ ) ; _this . on ( player , 'volumechange ' , _this . update ARIAAttributes ) ; player . ready ( function ( ) { return _this . update ARIAAttributes ( ) ; } ) ; return _this ; } 
function Volume Control ( player ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; class Call Check ( this , Volume Control ) ; options . vertical = options . vertical | | false ; 
function Mute Toggle ( player , options ) { class Call Check ( this , Mute Toggle ) ; 
function Volume Panel ( player ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; class Call Check ( this , Volume Panel ) ; if ( typeof options . inline ! = = 'undefined ' ) { options . inline = options . inline ; } else { options . inline = true ; } 
function Menu ( player , options ) { class Call Check ( this , Menu ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; if ( options ) { _this . menu Button _ = options . menu Button ; } _this . focused Child _ = - 1 ; _this . on ( 'keydown ' , _this . handle Key Press ) ; return _this ; } 
function Menu Button ( player ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; class Call Check ( this , Menu Button ) ; var _this = possible Constructor Return ( this , _Component . call ( this , player , options ) ) ; _this . menu Button _ = new Button ( player , options ) ; _this . menu Button _ . control Text ( _this . control Text _ ) ; _this . menu Button _ . el _ . set Attribute ( 'aria -haspopup ' , 'true ' ) ; 
function Menu Item ( player , options ) { class Call Check ( this , Menu Item ) ; var _this = possible Constructor Return ( this , _Clickable Component . call ( this , player , options ) ) ; _this . selectable = options . selectable ; _this . selected ( options . selected ) ; if ( _this . selectable ) { 
function Text Track Menu Item ( player , options ) { class Call Check ( this , Text Track Menu Item ) ; var track = options . track ; var tracks = player . text Tracks ( ) ; 
function Off Text Track Menu Item ( player , options ) { class Call Check ( this , Off Text Track Menu Item ) ; 
function Text Track Button ( player ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; class Call Check ( this , Text Track Button ) ; options . tracks = player . text Tracks ( ) ; return possible Constructor Return ( this , _Track Button . call ( this , player , options ) ) ; } 
function Chapters Track Menu Item ( player , options ) { class Call Check ( this , Chapters Track Menu Item ) ; var track = options . track ; var cue = options . cue ; var current Time = player . current Time ( ) ; 
function Chapters Button ( player , options , ready ) { class Call Check ( this , Chapters Button ) ; return possible Constructor Return ( this , _Text Track Button . call ( this , player , options , ready ) ) ; } 
function Descriptions Button ( player , options , ready ) { class Call Check ( this , Descriptions Button ) ; var _this = possible Constructor Return ( this , _Text Track Button . call ( this , player , options , ready ) ) ; var tracks = player . text Tracks ( ) ; var change Handler = bind ( _this , _this . handle Tracks Change ) ; tracks . add Event Listener ( 'change ' , change Handler ) ; _this . on ( 'dispose ' , function ( ) { tracks . remove Event Listener ( 'change ' , change Handler ) ; } ) ; return _this ; } 
function Subtitles Button ( player , options , ready ) { class Call Check ( this , Subtitles Button ) ; return possible Constructor Return ( this , _Text Track Button . call ( this , player , options , ready ) ) ; } 
function Caption Settings Menu Item ( player , options ) { class Call Check ( this , Caption Settings Menu Item ) ; options . track = { player : player , kind : options . kind , label : options . kind + ' settings ' , selectable : false , 'default ' : false , mode : 'disabled ' } ; 
function Captions Button ( player , options , ready ) { class Call Check ( this , Captions Button ) ; return possible Constructor Return ( this , _Text Track Button . call ( this , player , options , ready ) ) ; } 
function Audio Track Menu Item ( player , options ) { class Call Check ( this , Audio Track Menu Item ) ; var track = options . track ; var tracks = player . audio Tracks ( ) ; 
function Audio Track Button ( player ) { var options = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : { } ; class Call Check ( this , Audio Track Button ) ; options . tracks = player . audio Tracks ( ) ; return possible Constructor Return ( this , _Track Button . call ( this , player , options ) ) ; } 
function Playback Rate Menu Item ( player , options ) { class Call Check ( this , Playback Rate Menu Item ) ; var label = options . rate ; var rate = parse Float ( label , 1 0 ) ; 
function Playback Rate Menu Button ( player , options ) { class Call Check ( this , Playback Rate Menu Button ) ; var _this = possible Constructor Return ( this , _Menu Button . call ( this , player , options ) ) ; _this . update Visibility ( ) ; _this . update Label ( ) ; _this . on ( player , 'loadstart ' , _this . update Visibility ) ; _this . on ( player , 'ratechange ' , _this . update Label ) ; return _this ; } 
function Error Display ( player , options ) { class Call Check ( this , Error Display ) ; var _this = possible Constructor Return ( this , _Modal Dialog . call ( this , player , options ) ) ; _this . on ( player , 'error ' , _this . open ) ; return _this ; } 
function parse Option Value ( value , parser ) { if ( parser ) { value = parser ( value ) ; } if ( value & & value ! = = 'none ' ) { return value ; } } 
function get Selected Option Value ( el , parser ) { var value = el . options [ el . options . selected Index ] . value ; return parse Option Value ( value , parser ) ; } 
function set Selected Option ( el , value , parser ) { if ( ! value ) { return ; } for ( var i = 0 ; i < el . options . length ; i + + ) { if ( parse Option Value ( el . options [ i ] . value , parser ) = = = value ) { el . selected Index = i ; break ; } } } 
function Text Track Settings ( player , options ) { class Call Check ( this , Text Track Settings ) ; options . temporary = false ; var _this = possible Constructor Return ( this , _Modal Dialog . call ( this , player , options ) ) ; _this . update Display = bind ( _this , _this . update Display ) ; 
function Html 5 ( options , ready ) { class Call Check ( this , Html 5 ) ; var _this = possible Constructor Return ( this , _Tech . call ( this , options , ready ) ) ; var source = options . source ; var crossorigin Tracks = false ; 
function check Progress ( ) { if ( _this 3 . el _ . current Time > 0 ) { 
function Player ( tag , options , ready ) { class Call Check ( this , Player ) ; * Store the internal state of scrubbing * * @private * @return {Boolean } True if the user is scrubbing * / _this . scrubbing _ = false ; _this . el _ = _this . create El ( ) ; 
function find First Passing Tech Source Pair ( outer Array , inner Array , tester ) { var found = void 0 ; outer Array . some ( function ( outer Choice ) { return inner Array . some ( function ( inner Choice ) { found = tester ( outer Choice , inner Choice ) ; if ( found ) { return true ; } } ) ; } ) ; return found ; } 
function mark Plugin As Active ( player , name ) { player [ PLUGIN _CACHE _KEY ] = player [ PLUGIN _CACHE _KEY ] | | { } ; player [ PLUGIN _CACHE _KEY ] [ name ] = true ; } 
function trigger Setup Event ( player , hash , before ) { var event Name = ( before ? 'before ' : ' ' ) + 'pluginsetup ' ; player . trigger ( event Name , hash ) ; player . trigger ( event Name + ' : ' + hash . name , hash ) ; } 
function create Basic Plugin ( name , plugin ) { var basic Plugin Wrapper = function basic Plugin Wrapper ( ) { 
function create Plugin Factory ( name , Plugin Sub Class ) { 
function Plugin ( player ) { class Call Check ( this , Plugin ) ; if ( this . constructor = = = Plugin ) { throw new Error ( 'Plugin must be sub -classed ; not directly instantiated . ' ) ; } this . player = player ; 
function videojs ( id , options , ready ) { var tag = void 0 ; 
function ( component , name , animation ) { var html 5 = exports var transition = { property : html 5 . get Prefixed Name ( 'transition -property ' ) , delay : html 5 . get Prefixed Name ( 'transition -delay ' ) , duration : html 5 . get Prefixed Name ( 'transition -duration ' ) , timing : html 5 . get Prefixed Name ( 'transition -timing -function ' ) } var element = component . element element . force Layout ( ) 
function byte Count ( test Name , len , base Len ) { console . log ( test Name + " Byte Count : " + len + ( base Len ? ' , ' + Math . round ( len / base Len * 1 0 0 ) + ' % ' : ' ' ) ) ; } 
function ( ) { var bytes = this . _message Queue . reduce ( function ( acc , message ) { if ( typeof message = = = 'string ' ) { acc + = message . length ; / / not byte size } else if ( message instanceof Blob ) { acc + = message . size ; } else { acc + = message . byte Length ; } return acc ; } , 0 ) ; return bytes + ( this . _ws ? this . _ws . buffered Amount : 0 ) ; } 
function ( ) { var colors = [ ] var trs = _ $sortable Data List . find ( "li " ) ; for ( var i = 0 ; i < trs . length ; i + + ) { colors . push ( utils . rgb 2hex ( $ ( trs [ i ] ) . find ( " .segment Color " ) . css ( "background -color " ) ) ) ; } colors = utils . shuffle Array ( colors ) ; _set Colors ( colors ) ; } 
function ( module ID , message , data ) { if ( C . DEBUG ) { console . log ( " [ " + module ID + " ] publish ( ) : " , message , data ) ; } for ( var i in _modules ) { var subscriptions = _modules [ i ] . subscriptions ; 
function ( ) { $ ( document ) . on ( "click " , " .select Page " , function ( e ) { e . prevent Default ( ) ; _select Page ( this . hash ) ; } ) ; $ ( window ) . on ( "resize " , function ( ) { var width = $ ( window ) . width ( ) ; var height = $ ( window ) . height ( ) ; var break Point = _update Body Size Class ( width ) ; mediator . publish ( _MODULE _ID , C . EVENT . PAGE . RESIZE , { width : width , height : height , break Point : break Point } ) ; } ) ; } 
function ( width ) { var break Point Index = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i + + ) { if ( width > = C . OTHER . BREAKPOINTS [ i ] ) { break Point Index = i ; } } $ ( "body " ) . remove Class ( "size 7 6 8 size 9 9 2 size 1 2 0 0 " ) ; var break Point = null ; if ( break Point Index ! = = null ) { break Point = C . OTHER . BREAKPOINTS [ break Point Index ] ; $ ( "body " ) . add Class ( "size " + break Point ) ; } return break Point ; } 
function ( page Candidate ) { 
function template ( template Spec , env ) { if ( ! env ) { throw new Exception ( "No environment passed to template " ) ; } 
function ( partial , name , context , helpers , partials , data ) { var result = env . VM . invoke Partial . apply ( this , arguments ) ; if ( result ! = null ) { return result ; } if ( env . compile ) { var options = { helpers : helpers , partials : partials , data : data } ; partials [ name ] = env . compile ( partial , { data : data ! = = undefined } , env ) ; return partials [ name ] ( context , options ) ; } else { throw new Exception ( "The partial " + name + " could not be compiled when running in runtime -only mode " ) ; } } 
function ( ) { var hb = new base . Handlebars Environment ( ) ; Utils . extend ( hb , base ) ; hb . Safe String = Safe String ; hb . Exception = Exception ; hb . Utils = Utils ; hb . VM = runtime ; hb . template = function ( spec ) { return runtime . template ( spec , hb ) ; } ; return hb ; } 
function ( parent , name ) { var wrap , ret ; if ( parent . index Of ( 'depth ' ) = = = 0 ) { wrap = true ; } if ( / ^ [ 0 - 9 ] + $ / . test ( name ) ) { ret = parent + " [ " + name + " ] " ; } else if ( Java Script Compiler . is Valid Java Script Variable Name ( name ) ) { ret = parent + " . " + name ; } else { ret = parent + " [ ' " + name + " ' ] " ; } if ( wrap ) { return ' ( ' + parent + ' & & ' + ret + ' ) ' ; } else { return ret ; } } 
function ( environment , options , context , as Object ) { this . environment = environment ; this . options = options | | { } ; log ( 'debug ' , this . environment . disassemble ( ) + " \n \n " ) ; this . name = this . environment . name ; this . is Child = ! ! context ; this . context = context | | { programs : [ ] , environments : [ ] , aliases : { } } ; this . preamble ( ) ; this . stack Slot = 0 ; this . stack Vars = [ ] ; this . registers = { list : [ ] } ; this . hashes = [ ] ; this . compile Stack = [ ] ; this . inline Stack = [ ] ; this . compile Children ( environment , options ) ; var opcodes = environment . opcodes , opcode ; this . i = 0 ; for ( var l = opcodes . length ; this . i < l ; this . i + + ) { opcode = opcodes [ this . i ] ; if ( opcode . opcode = = = 'DECLARE ' ) { this [ opcode . name ] = opcode . value ; } else { this [ opcode . opcode ] . apply ( this , opcode . args ) ; } 
function ( ) { this . context . aliases . block Helper Missing = 'helpers .block Helper Missing ' ; var params = [ "depth 0 " ] ; this . setup Params ( 0 , params ) ; var current = this . top Stack ( ) ; params . splice ( 1 , 0 , current ) ; this . push Source ( "if ( ! " + this . last Helper + " ) { " + current + " = block Helper Missing .call ( " + params . join ( " , " ) + " ) ; } " ) ; } 
function ( content ) { if ( this . pending Content ) { content = this . pending Content + content ; } if ( this . strip Next ) { content = content . replace ( / ^ \s + / , ' ' ) ; } this . pending Content = content ; } 
function ( string , type ) { this . push Stack Literal ( 'depth ' + this . last Context ) ; this . push String ( type ) ; 
function ( param Size , name , is Root ) { this . context . aliases . helper Missing = 'helpers .helper Missing ' ; this . use Register ( 'helper ' ) ; var helper = this . last Helper = this . setup Helper ( param Size , name , true ) ; var non Helper = this . name Lookup ( 'depth ' + this . last Context , name , 'context ' ) ; var lookup = 'helper = ' + helper . name + ' | | ' + non Helper ; if ( helper . params Init ) { lookup + = ' , ' + helper . params Init ; } this . push ( ' ( ' + lookup + ' ,helper ' + ' ? helper .call ( ' + helper . call Params + ' ) ' + ' : helper Missing .call ( ' + helper . helper Missing Params + ' ) ) ' ) ; 
function ( param Size , name ) { var helper = this . setup Helper ( param Size , name ) ; this . push ( helper . name + " .call ( " + helper . call Params + " ) " ) ; } 
function ( name , helper Call ) { this . context . aliases . function Type = ' "function " ' ; this . use Register ( 'helper ' ) ; this . empty Hash ( ) ; var helper = this . setup Helper ( 0 , name , helper Call ) ; var helper Name = this . last Helper = this . name Lookup ( 'helpers ' , name , 'helper ' ) ; var non Helper = this . name Lookup ( 'depth ' + this . last Context , name , 'context ' ) ; var next Stack = this . next Stack ( ) ; if ( helper . params Init ) { this . push Source ( helper . params Init ) ; } this . push Source ( 'if (helper = ' + helper Name + ' ) { ' + next Stack + ' = helper .call ( ' + helper . call Params + ' ) ; } ' ) ; this . push Source ( 'else { helper = ' + non Helper + ' ; ' + next Stack + ' = typeof helper = = = function Type ? helper .call ( ' + helper . call Params + ' ) : helper ; } ' ) ; } 
function ( key ) { var value = this . pop Stack ( ) , context , type ; if ( this . options . string Params ) { type = this . pop Stack ( ) ; context = this . pop Stack ( ) ; } var hash = this . hash ; if ( context ) { hash . contexts . push ( " ' " + key + " ' : " + context ) ; } if ( type ) { hash . types . push ( " ' " + key + " ' : " + type ) ; } hash . values . push ( " ' " + key + " ' : ( " + value + " ) " ) ; } 
function ( param Size , params , use Register ) { var options = ' { ' + this . setup Options ( param Size , params ) . join ( ' , ' ) + ' } ' ; if ( use Register ) { this . use Register ( 'options ' ) ; params . push ( 'options ' ) ; return 'options = ' + options ; } else { params . push ( options ) ; return ' ' ; } } 
function ( msg ) { _canvas Width = msg . data . config . size . canvas Width ; _canvas Height = msg . data . config . size . canvas Height ; } 
function ( ) { var scope = this ; THREE . Geometry . call ( this ) ; v ( 5 , 0 , 0 ) ; v ( - 5 , - 2 , 1 ) ; v ( - 5 , 0 , 0 ) ; v ( - 5 , - 2 , - 1 ) ; v ( 0 , 2 , - 6 ) ; v ( 0 , 2 , 6 ) ; v ( 2 , 0 , 0 ) ; v ( - 3 , 0 , 0 ) ; f 3 ( 0 , 2 , 1 ) ; f 3 ( 4 , 7 , 6 ) ; f 3 ( 5 , 6 , 7 ) ; this . compute Centroids ( ) ; this . compute Face Normals ( ) ; function v ( x , y , z ) { scope . vertices . push ( new THREE . Vector 3 ( x , y , z ) ) ; } function f 3 ( a , b , c ) { scope . faces . push ( new THREE . Face 3 ( a , b , c ) ) ; } } 
function ( ) { var vector = new THREE . Vector 3 ( ) , _acceleration , _width = 5 0 0 , _height = 5 0 0 , _depth = 2 0 0 , _goal , _neighborhood Radius = 1 0 0 , _max Speed = 4 , _max Steer Force = 0 . 1 , _avoid Walls = false ; this . position = new THREE . Vector 3 ( ) ; this . velocity = new THREE . Vector 3 ( ) ; _acceleration = new THREE . Vector 3 ( ) ; this . set Goal = function ( target ) { _goal = target ; } ; this . set Avoid Walls = function ( value ) { _avoid Walls = value ; } ; this . set World Size = function ( width , height , depth ) { _width = width ; _height = height ; _depth = depth ; } ; this . run = function ( boids ) { if ( _avoid Walls ) { vector . set ( - _width , this . position . y , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( _width , this . position . y , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , - _height , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , _height , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , this . position . y , - _depth ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , this . position . y , _depth ) ; vector = this . avoid ( vector ) ; vector . multiply Scalar ( 5 ) ; _acceleration . add ( vector ) ; } if ( Math . random ( ) > 0 . 5 ) { this . flock ( boids ) ; } this . move ( ) ; } this . flock = function ( boids ) { if ( _goal ) { _acceleration . add ( this . reach ( _goal , 0 . 0 0 5 ) ) ; } _acceleration . add ( this . alignment ( boids ) ) ; _acceleration . add ( this . cohesion ( boids ) ) ; _acceleration . add ( this . separation ( boids ) ) ; } this . move = function ( ) { this . velocity . add ( _acceleration ) ; var l = this . velocity . length ( ) ; if ( l > _max Speed ) { this . velocity . divide Scalar ( l / _max Speed ) ; } this . position . add ( this . velocity ) ; _acceleration . set ( 0 , 0 , 0 ) ; } this . check Bounds = function ( ) { if ( this . position . x > _width ) this . position . x = - _width ; if ( this . position . x < - _width ) this . position . x = _width ; if ( this . position . y > _height ) this . position . y = - _height ; if ( this . position . y < - _height ) this . position . y = _height ; if ( this . position . z > _depth ) this . position . z = - _depth ; if ( this . position . z < - _depth ) this . position . z = _depth ; } this . avoid = function ( target ) { var steer = new THREE . Vector 3 ( ) ; steer . copy ( this . position ) ; steer . sub ( target ) ; steer . multiply Scalar ( 1 / this . position . distance To Squared ( target ) ) ; return steer ; } this . repulse = function ( target ) { var distance = this . position . distance To ( target ) ; if ( distance < 1 5 0 ) { var steer = new THREE . Vector 3 ( ) ; steer . sub Vectors ( this . position , target ) ; steer . multiply Scalar ( 0 . 5 / distance ) ; _acceleration . add ( steer ) ; } } this . reach = function ( target , amount ) { var steer = new THREE . Vector 3 ( ) ; steer . sub Vectors ( target , this . position ) ; steer . multiply Scalar ( amount ) ; return steer ; } this . alignment = function ( boids ) { var boid , vel Sum = new THREE . Vector 3 ( ) , count = 0 ; for ( var i = 0 , il = boids . length ; i < il ; i + + ) { if ( Math . random ( ) > 0 . 6 ) continue ; boid = boids [ i ] ; distance = boid . position . distance To ( this . position ) ; if ( distance > 0 & & distance < = _neighborhood Radius ) { vel Sum . add ( boid . velocity ) ; count + + ; } } if ( count > 0 ) { vel Sum . divide Scalar ( count ) ; var l = vel Sum . length ( ) ; if ( l > _max Steer Force ) { vel Sum . divide Scalar ( l / _max Steer Force ) ; } } return vel Sum ; } this . cohesion = function ( boids ) { var boid , distance , pos Sum = new THREE . Vector 3 ( ) , steer = new THREE . Vector 3 ( ) , count = 0 ; for ( var i = 0 , il = boids . length ; i < il ; i + + ) { if ( Math . random ( ) > 0 . 6 ) continue ; boid = boids [ i ] ; distance = boid . position . distance To ( this . position ) ; if ( distance > 0 & & distance < = _neighborhood Radius ) { pos Sum . add ( boid . position ) ; count + + ; } } if ( count > 0 ) { pos Sum . divide Scalar ( count ) ; } steer . sub Vectors ( pos Sum , this . position ) ; var l = steer . length ( ) ; if ( l > _max Steer Force ) { steer . divide Scalar ( l / _max Steer Force ) ; } return steer ; } this . separation = function ( boids ) { var boid , distance , pos Sum = new THREE . Vector 3 ( ) , repulse = new THREE . Vector 3 ( ) ; for ( var i = 0 , il = boids . length ; i < il ; i + + ) { if ( Math . random ( ) > 0 . 6 ) continue ; boid = boids [ i ] ; distance = boid . position . distance To ( this . position ) ; if ( distance > 0 & & distance < = _neighborhood Radius ) { repulse . sub Vectors ( this . position , boid . position ) ; repulse . normalize ( ) ; repulse . divide Scalar ( distance ) ; pos Sum . add ( repulse ) ; } } return pos Sum ; } } 
function ( msg ) { if ( ! _first Page Loaded ) { _first Page = msg . data . page ; _first Page Loaded = true ; if ( _first Page = = = "about " ) { set Timeout ( function ( ) { _render Content ( ) ; var width = $ ( window ) . width ( ) ; var break Point Index = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i + + ) { if ( width > = C . OTHER . BREAKPOINTS [ i ] ) { break Point Index = i ; } } if ( break Point Index = = = null ) { _handle Viewport ( "small " ) ; } } , 1 0 ) ; } return ; } if ( msg . data . page = = = "about " ) { if ( ! _is Rendered ) { _render Content ( ) ; } $ ( " #about Page Slides " ) . slidesjs ( "refresh " ) ; } } 
function ( number ) { switch ( number ) { case 1 : _demo Pie 2 . redraw ( ) ; _demo Pie 3 . redraw ( ) ; break ; case 2 : _demo Pie 1 . redraw ( ) ; _demo Pie 3 . redraw ( ) ; break ; case 3 : _demo Pie 1 . redraw ( ) ; _demo Pie 2 . redraw ( ) ; break ; } } 
function ( ) { config . template . index File . options . data . C = _CONSTANTS . DEV ; config . template . index File . options . data . D 3PIE _VERSION = package File . version ; config . template . dev Require Config . options . data . handlebars Lib = _CONSTANTS . DEV . HANDLEBARS _LIB ; config . template . dev Require Config . options . data . base Url = _CONSTANTS . DEV . BASE _URL ; var lines = [ ] ; for ( var i in _require JSModule Paths ) { var file = _require JSModule Paths [ i ] . replace ( / \ .js $ / , " " ) ; lines . push ( ' \t \t " ' + i + ' " : " ' + file + ' " ' ) ; } config . template . dev Require Config . options . data . module Str = lines . join ( " , \n " ) ; config . template . constants . options . data . VERSION = package File . version ; config . template . constants . options . data . MINIMIZED = _CONSTANTS . DEV . MINIMIZED ; config . template . constants . options . data . DEBUG = _CONSTANTS . DEV . DEBUG ; } 
function ( ) { mediator . register ( _MODULE _ID ) ; var subscriptions = { } ; subscriptions [ C . EVENT . DEMO _PIE . SEND _DATA ] = _on Select Tab ; mediator . subscribe ( _MODULE _ID , subscriptions ) ; } 
function ( all Settings ) { var final Obj = { } ; 
function ( ) { _add Tab Event Handlers ( ) ; var config = { hide Main Content : false } ; if ( document . location . hash = = = " #generator -result " ) { config = { hide Main Content : true } } $ ( " #generator " ) . html ( generator Page Template ( config ) ) ; 
function ( ) { return { header : title Tab . get Tab Data ( ) , footer : footer Tab . get Tab Data ( ) , size : size Tab . get Tab Data ( ) , data : data Tab . get Tab Data ( ) , labels : labels Tab . get Tab Data ( ) , tooltips : tooltips Tab . get Tab Data ( ) , effects : effects Tab . get Tab Data ( ) , callbacks : events Tab . get Tab Data ( ) , misc : misc Tab . get Tab Data ( ) } ; } 
function ( msg ) { if ( ! _first Page Loaded ) { if ( msg . data . page Hash ! = = "generator -result " ) { _first Page = msg . data . page ; } _first Page Loaded = true ; } if ( msg . data . page ! = = "generator " ) { return ; } var page Hash = msg . data . page Hash ; var tab = ( _current Tab ) ? _current Tab : "generator -start " ; if ( $ . in Array ( page Hash , _tabs ) ! = = - 1 ) { tab = page Hash ; } if ( page Hash = = = "generator -result " ) { _send Demo Pie Data ( ) ; $ ( " #sidebar , #pie Chart Div " ) . add Class ( "fade Out " ) ; set Timeout ( function ( ) { $ ( " #sidebar , #pie Chart Div " ) . add Class ( "hidden " ) . remove Class ( "fade Out " ) ; $ ( " #generator -result " ) . remove Class ( "hidden fade Out " ) . add Class ( "fade In " ) ; } , C . OTHER . PAGE _LOAD _SPEED ) ; } else if ( page Hash = = = "generator " & & tab = = = "generator -result " ) { 
function get Or Def ( obj , prop ) { return obj [ prop ] = = = undefined ? options [ prop ] : obj [ prop ] ; } 
function trigger Event ( event , $el ) { var handler = options [ 'on ' + event ] ; if ( handler ) { if ( $is Function ( handler ) ) { handler . call ( $el [ 0 ] ) ; } else { if ( handler . add Class ) { $el . add Class ( handler . add Class ) ; } if ( handler . remove Class ) { $el . remove Class ( handler . remove Class ) ; } } } $el . trigger ( 'lazy ' + event , [ $el ] ) ; 
function check Lazy Elements ( force ) { if ( ! elements . length ) { return ; } force = force | | options . force Load ; top Lazy = Infinity ; var viewport Top = scroll Top ( ) , viewport Height = window . inner Height | | doc Element . client Height , viewport Width = window . inner Width | | doc Element . client Width , i , length ; for ( i = 0 , length = elements . length ; i < length ; i + + ) { var $el = elements [ i ] , el = $el [ 0 ] , obj Data = $el [ lazy Load XT ] , remove Node = false , visible = force | | $data ( el , data Lazied ) < 0 , top Edge ; 
function queue Check Lazy Elements ( e ) { if ( ! elements . length ) { return ; } 
function calc Viewport ( ) { var scroll Top = $window . scroll Top ( ) , scroll Left = window . page XOffset | | 0 , edge X = options . edge X , edge Y = options . edge Y ; viewport Top = scroll Top - edge Y ; viewport Bottom = scroll Top + ( window . inner Height | | $window . height ( ) ) + edge Y ; viewport Left = scroll Left - edge X ; viewport Right = scroll Left + ( window . inner Width | | $window . width ( ) ) + edge X ; } 
function check Lazy Elements ( ) { if ( ! elements . length ) { return ; } top Lazy = Infinity ; calc Viewport ( ) ; var i = elements . length - 1 , src Attr = options . src Attr ; for ( ; i > = 0 ; i - - ) { var $el = elements [ i ] , el = $el [ 0 ] ; 
function queue Check Lazy Elements ( e ) { if ( ! elements . length ) { return ; } 
function check Version ( ) { var next Version Check Timestamp = parse Int ( Cookies . get ( 'next Version Check Timestamp ' ) ) | | 0 ; if ( ! next Version Check Timestamp | | ( Date . now ( ) > = next Version Check Timestamp ) ) { $http . get ( ' /api /build -info ' ) . then ( function success ( res ) { var current Version = parse Version ( res . data & & res . data . version ) ; $http . get ( 'https : / /api .github .com /repos /mcdcorp /opentest /releases ' ) . then ( function success ( res ) { var eight Days Later = Date . now ( ) + ( 8 * 2 4 * 6 0 * 6 0 * 1 0 0 0 ) ; Cookies . set ( 'next Version Check Timestamp ' , eight Days Later ) ; var latest Version Str = res . data & & res . data [ 0 ] & & res . data [ 0 ] . tag _name ; var latest Version Url = res . data & & res . data [ 0 ] & & res . data [ 0 ] . html _url ; var latest Version = parse Version ( latest Version Str ) ; if ( latest Version & & ( compare Versions ( latest Version , current Version ) = = = 1 ) ) { $ . notify ( { message : 'A new Open Test version is now available : <a href = " ' + latest Version Url + ' " target = " _blank " > ' + latest Version Str + ' < /a > . ' + 'You should always stay on the latest version to benefit from new features and security updates . ' } , { type : 'info ' , delay : 0 , placement : { from : 'bottom ' } } ) } } , function error ( res ) { var one Hour Later = Date . now ( ) + ( 6 0 * 6 0 * 1 0 0 0 ) ; Cookies . set ( 'next Version Check Timestamp ' , one Hour Later ) ; } ) ; } ) ; } } 
function parse Version ( version String ) { if ( typeof version String ! = = 'string ' ) { return null ; } var version Regex Match = version String . match ( / v ? ( \d + ) \ . ( \d + ) \ . ( \d + ) / i ) ; if ( version Regex Match ) { return [ parse Int ( version Regex Match [ 1 ] ) , parse Int ( version Regex Match [ 2 ] ) , parse Int ( version Regex Match [ 3 ] ) ] ; } else { return null ; } } 
function $random String ( length , character Pool ) { if ( typeof character Pool ! = = 'string ' ) { character Pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 0 1 2 3 4 5 6 7 8 9 " ; } var text = " " ; for ( var i = 0 ; i < length ; i + + ) { text + = character Pool . char At ( Math . floor ( Math . random ( ) * character Pool . length ) ) ; } return text ; } 
function $range ( start , length ) { if ( arguments . length = = = 1 ) { length = arguments [ 0 ] ; start = 0 ; } return Array . apply ( null , Array ( length ) ) . map ( function ( _ , index ) { return index + start ; } ) ; } 
function remove Invalid Xml ( str ) { return Array . from ( str ) . map ( c = > { const cp = c . code Point At ( 0 ) ; if ( cp > = 6 5 5 3 6 & & cp < = 1 1 1 4 1 1 1 ) { return c } else if ( c . match ( valid Xml Regex ) ) { return c ; } else { return ' ' ; } } ) . join ( ' ' ) ; } 
function cell Accessor ( row 1 , col 1 , row 2 , col 2 , is Merged ) { let these Cells = new cell Block ( ) ; these Cells . ws = this ; row 2 = row 2 ? row 2 : row 1 ; col 2 = col 2 ? col 2 : col 1 ; if ( row 2 > this . last Used Row ) { this . last Used Row = row 2 ; } if ( col 2 > this . last Used Col ) { this . last Used Col = col 2 ; } for ( let r = row 1 ; r < = row 2 ; r + + ) { for ( let c = col 1 ; c < = col 2 ; c + + ) { let ref = ` $ { utils . get Excel Alpha ( c ) } $ { r } ` ; if ( ! this . cells [ ref ] ) { this . cells [ ref ] = new Cell ( r , c ) ; } if ( ! this . rows [ r ] ) { this . rows [ r ] = new Row ( r , this ) ; } if ( this . rows [ r ] . cell Refs . index Of ( ref ) < 0 ) { this . rows [ r ] . cell Refs . push ( ref ) ; } these Cells . cells . push ( this . cells [ ref ] ) ; these Cells . excel Refs . push ( ref ) ; } } if ( is Merged ) { these Cells . merged = true ; merge Cells ( these Cells ) ; } return these Cells ; } 
function add ( project , email , access Level , inviter , done ) { User . find One ( { email : email } , function ( err , user ) { if ( err ) { return done ( err ) ; } if ( user ) { var p = _ . find ( user . projects , function ( p ) { return p . name = = = project . to Lower Case ( ) ; } ) ; if ( p ) { return done ( 'user already a collaborator ' , true ) ; } User . update ( { email : email } , { $push : { 'projects ' : { name : project . to Lower Case ( ) , display _name : project , access _level : access Level } } } , function ( err ) { if ( err ) return done ( err , true ) ; done ( null , true ) ; } ) ; } else { var collaboration = { project : project , invited _by : inviter . _id , access _level : access Level } ; Invite Code . find One ( { emailed _to : email , consumed _timestamp : null } , function ( err , invite ) { if ( err ) return done ( err ) ; if ( invite ) { return update Invite ( invite , collaboration , done ) ; } send Invite ( inviter , email , collaboration , done ) ; } ) ; } } ) ; } 
function all Projects ( done ) { User . find ( { } , function ( err , users ) { if ( err ) return done ( err ) ; Project . find ( ) . sort ( { _id : - 1 } ) . exec ( function ( err , projects ) { if ( err ) return done ( err ) ; done ( null , projects . map ( function ( project ) { project = utils . sanitize Project ( project ) ; project . created _date = utils . time From Id ( project . _id ) ; project . users = [ ] ; for ( var i = 0 ; i < users . length ; i + + ) { if ( 'undefined ' ! = = typeof users [ i ] . projects [ project . name ] ) { project . users . push ( { email : users [ i ] . email , access : users [ i ] . projects [ project . name ] } ) ; } } return project ; } ) ) ; } ) ; } ) ; } 
function get Config ( ) { process . env = filter Env ( deprecated ( process . env ) , env Defaults ) ; var rc = require ( 'rc ' ) ( 'strider ' , defaults ) ; if ( ! rc . smtp ) rc . smtp = smtp ( rc ) ; if ( ! rc . smtp ) rc . stub Smtp = true ; rc . ldap = get Config By Name ( 'ldap ' ) ; add Plugins ( rc , process . env ) ; 
function filter Env ( env , defaults ) { var res = { } ; for ( var k in env ) { if ( defaults [ k . to Lower Case ( ) ] ! = = undefined ) { res [ ` $ { k . to Lower Case ( ) } ` ] = env [ k ] ; } else { res [ k ] = env [ k ] ; } } return res ; } 
function merge Plugins ( branch , sjson ) { if ( ! branch ) return sjson ; if ( ! sjson ) return branch ; 
function multijob ( req , res ) { var type = req . accepts ( 'html ' , 'json ' , 'plain ' ) ; switch ( type ) { case 'json ' : return data ( req , res ) ; case 'plain ' : return output ( req , res ) ; default : return html ( req , res ) ; } } 
function require Body ( key , req , res ) { var val = req . body [ key ] ; if ( val = = = undefined ) { return res . status ( 4 0 0 ) . json ( { status : 'error ' , errors : [ ` $ { key } ` ] } ) ; } return val ; } 
function load Templates ( list , type ) { if ( ! list ) { return ; } var result = { } ; type = type | | 'plaintext ' ; list . for Each ( function ( name ) { var template Path = path . join ( template Base Path , type , ` $ { name } ` ) ; result [ name ] = render Pug ( template Path ) ; } ) ; return result ; } 
function register Template ( name , template , dir ) { cache [ name ] = function ( context , cb ) { if ( / \ .html $ / . test ( template ) ) { dir = dir | | ' . ' ; template = fs . read File Sync ( path . join ( dir , template ) , 'utf 8 ' ) ; } cb ( null , template ) ; } ; } 
function get Plugin Template ( name , context ) { return function ( cb ) { if ( cache [ name ] ) { cache [ name ] ( context , function ( err , res ) { if ( err ) return cb ( err ) ; cb ( null , [ name , res ] ) ; } ) ; } else { cb ( null , null ) ; } } ; } 
function engine ( path , options , fn ) { options . filename = path ; fs . read File ( path , 'utf 8 ' , function ( err , str ) { if ( err ) return fn ( err ) ; engine . render ( str , options , fn ) ; } ) ; } 
function User Sockets ( sio , session Store ) { this . sio = sio ; this . sockets = { } ; this . session Store = session Store ; 
function ( uid , socket ) { var socks = this . sockets [ uid ] ; if ( ! socks ) return false ; return socks . remove ( socket ) ; } 
function ( socket ) { var session = socket . handshake . session ; if ( session & & session . passport ) { this . add Socket ( session . passport . user , socket ) ; } else { console . debug ( 'Websocket connection does not have authorization - nothing to do . ' ) ; } } 
function ( users , args ) { for ( var i = 0 ; i < users . length ; i + + ) { if ( ! this . sockets [ users [ i ] ] ) continue ; this . sockets [ users [ i ] ] . emit ( args ) ; } } 
function ( users , fn ) { for ( var i = 0 ; i < users . length ; i + + ) { if ( ! this . sockets [ users [ i ] ] | | ! this . sockets [ users [ i ] ] . user ) continue ; this . sockets [ users [ i ] ] . emit ( fn ( this . sockets [ users [ i ] ] . user ) ) ; } } 
function ( users , args ) { for ( var id in this . sockets ) { if ( users . index Of ( id ) ! = = - 1 ) continue ; this . sockets [ id ] . emit ( args ) ; } } 
function status ( job ) { if ( job . errored ) return 'errored ' ; if ( ! job . started ) return 'submitted ' ; if ( ! job . finished ) return 'running ' ; if ( job . test _exitcode ! = = 0 ) return 'failed ' ; if ( job . type ! = = TEST _ONLY & & job . deploy _exitcode ! = = 0 ) return 'failed ' ; return 'passed ' ; } 
function Dashboard ( socket , $scope ) { Job Monitor . call ( this , socket , $scope . $digest . bind ( $scope ) ) ; this . scope = $scope ; this . scope . loading Jobs = false ; this . scope . jobs = global . jobs ; } 
function prepare Job ( emitter , job ) { Project . find One ( { name : job . project } ) . populate ( 'creator ' ) . exec ( function ( err , project ) { if ( err | | ! project ) return debug ( 'job .prepare - failed to get project ' , job . project , err ) ; 
function ( project , event , args ) { if ( this . waiting [ project ] ) { return this . waiting [ project ] . push ( [ event , args ] ) ; } this . send ( project , event , args ) ; if ( event = = = 'job .status .started ' ) { Job . find By Id ( args [ 0 ] , function ( err , job ) { if ( err ) return debug ( ' [backchannel ] [job .status .started ] error getting job ' , args [ 0 ] , err ) ; if ( ! job ) return debug ( ' [backchannel ] [job .status .started ] job not found ' , args [ 0 ] ) ; job . started = args [ 1 ] ; job . save ( ) ; } ) ; } } 
function normalize ( val , single ) { var margin = 0 . 1 ; if ( val > = single & & val < = single * ( 1 + margin ) ) { return single ; } return val ; } 
function kill Attrs ( model , attrs ) { for ( var i = 0 ; i < attrs . length ; i + + ) { delete model [ attrs [ i ] ] ; } } 
function body Setter ( req , res , next ) { if ( req . _post _body ) { return next ( ) ; } req . post _body = req . post _body | | ' ' ; if ( 'POST ' ! = = req . method ) { return next ( ) ; } req . _post _body = true ; req . on ( 'data ' , function ( chunk ) { req . post _body + = chunk ; } ) ; next ( ) ; } 
function require Body ( params List ) { return function ( req , res , next ) { var errors = [ ] ; var status = 'ok ' ; for ( var i = 0 ; i < params List . length ; i + + ) { var val = req . body [ params List [ i ] ] ; if ( ! val ) { errors . push ( ` \ ` $ { params List [ i ] } \ ` ` ) ; status = 'error ' ; } } if ( errors . length = = = 0 ) { next ( ) ; } else { return res . status ( 4 0 0 ) . json ( { errors : errors , status : status } ) ; } } ; } 
function project Provider ( req , res , next ) { var project = req . project ; req . provider Config = function ( config , next ) { if ( arguments . length = = = 0 ) { return project . provider . config ; } project . provider . config = config ; project . mark Modified ( 'provider ' ) ; project . save ( next ) ; } ; 
function project Plugin ( req , res , next ) { var pluginid ; 
function anon Project ( req , res , next ) { var name = ` $ { req . params . org } $ { req . params . repo } ` ; name = name . to Lower Case ( ) ; Project . find One ( { name : name } ) . populate ( 'creator ' ) . exec ( function ( err , project ) { if ( err ) { return res . status ( 5 0 0 ) . send ( { error : 'Failed to find project ' , info : err } ) ; } if ( ! project ) { return res . status ( 4 0 4 ) . send ( 'Project not found ' ) ; } if ( ! project . creator ) { return res . status ( 4 0 0 ) . send ( 'Project malformed ; project creator user is missing . ' ) ; } req . project = project ; req . access Level = User . project Access Level ( req . user , project ) ; if ( req . user & & project . creator ) { req . user . is Project Creator = project . creator . _id . to String ( ) = = = req . user . _id . to String ( ) ; } next ( ) ; } ) ; } 
function project ( req , res , next ) { if ( req . params . org = = = 'auth ' ) { return next ( ) ; } anon Project ( req , res , function ( ) { if ( req . access Level > - 1 ) { return next ( ) ; } if ( ! req . user ) { req . session . return _to = req . url ; return res . redirect ( ' /login ' ) ; } res . status ( 4 0 1 ) . send ( 'Not authorized ' ) ; } ) ; } 
function ( req , res , next ) { get Plugin List ( function ( err , list ) { if ( err ) return next ( err ) ; res . render ( 'admin /plugins .html ' , { plugins : list } ) ; } ) ; } 
function ( req , res ) { plugin Manager [ req . body . action ] ( req . body . id , function ( err ) { if ( err ) return res . status ( 5 0 0 ) . end ( err . message ) ; res . json ( { ok : 'restarting strider ' } ) ; restart ( ) ; } ) ; } 
function require User ( req , res , next ) { if ( req . user ) { next ( ) ; } else { req . session . return _to = req . url ; res . redirect ( ' /login ' ) ; } } 
function require Admin Or 4 0 1 ( req , res , next ) { if ( ! req . user | | ! req . user [ 'account _level ' ] | | req . user . account _level < 1 ) { res . status ( 4 0 1 ) . send ( 'not authorized ' ) ; } else { next ( ) ; } } 
function require Project Admin ( req , res , next ) { if ( ! req . project ) return res . status ( 4 0 4 ) . send ( 'Project not loaded ' ) ; if ( ! req . user ) return res . status ( 4 0 1 ) . send ( 'No user ' ) ; var is Admin = req . user . account _level & & req . user . account _level > 0 ; var not Authed = ( ! req . access Level | | req . access Level < 2 ) & & ! is Admin ; if ( not Authed ) return res . status ( 4 0 1 ) . send ( 'Not authorized for configuring this project ' ) ; next ( ) ; } 
function plugin Block ( indent , parser ) { var template = this . args [ 0 ] ; var output = ' ' ; 
function find Anchor By Content ( content , cb ) { element . all ( by . css ( 'a ' ) ) . then ( function ( anchors ) { anchors . for Each ( function ( anchor ) { anchor . get Text ( ) . then ( function ( anchor Text ) { if ( anchor Text = = = content ) { cb ( anchor ) ; } } ) ; } ) ; } ) ; } 
function ( fun ) { var ret = fun . to String ( ) ; ret = ret . substr ( 'function ' . length ) ; ret = ret . substr ( 0 , ret . index Of ( ' ( ' ) ) ; return ret ? ret . trim ( ) : ret ; } 
function get Inner Library Method ( name , lib Name ) { lib Name = lib Name | | config . lib ; var library = inner Auth 0library Configuration [ lib Name ] . library ( ) ; return library [ inner Auth 0library Configuration [ lib Name ] [ name ] ] ; } 
function get Inner Library Config Field ( name , lib Name ) { lib Name = lib Name | | config . lib ; return inner Auth 0library Configuration [ lib Name ] [ name ] ; } 
function constructor Name ( fun ) { if ( fun ) { return { lib : auth Utils Provider . fn Name ( fun ) , constructor : fun } ; } if ( null ! = window . Auth 0Lock ) { return { lib : 'Auth 0Lock ' , constructor : window . Auth 0Lock } ; } if ( null ! = window . Auth 0 ) { return { lib : 'Auth 0 ' , constructor : window . Auth 0 } ; } if ( typeof Auth 0Widget ! = = 'undefined ' ) { throw new Error ( 'Auth 0Widget is not supported with this version of auth 0 -angular ' + 'anymore . Please try with an older one ' ) ; } throw new Error ( 'Cannot initialize Auth 0Angular . Auth 0Lock or Auth 0 must be available ' ) ; } 
function ( id Token , access Token , state , refresh Token , profile , is Refresh ) { id Token = id Token | | ( profile ? profile . id Token : null ) ; access Token = access Token | | ( profile ? profile . access Token : null ) ; state = state | | ( profile ? profile . state : null ) ; refresh Token = refresh Token | | ( profile ? profile . refresh Token : null ) ; var profile Promise = auth . get Profile ( id Token ) ; var response = { id Token : id Token , access Token : access Token , state : state , refresh Token : refresh Token , profile : profile , is Authenticated : true } ; $root Scope . is Authenticated = true ; angular . extend ( auth , response ) ; call Handler ( ! is Refresh ? 'login Success ' : 'authenticated ' , angular . extend ( { profile Promise : profile Promise } , response ) ) ; return profile Promise ; } 
function verify Route ( requires Login , e , get State , redirect To Login ) { if ( ! auth . is Authenticated & & ! auth . refresh Token Promise ) { if ( config . sso ) { if ( requires Login ) { e . prevent Default ( ) ; } config . auth 0js . get SSOData ( auth Utils . applied ( function ( err , sso Data ) { if ( sso Data . sso ) { var login Options = { popup : false , callback On Location Hash : true , connection : sso Data . last Used Connection . name , auth Params : { state : get State ( ) } } ; call Handler ( 'sso Login ' , { login Options : login Options } ) ; auth . signin ( login Options , null , null , 'Auth 0 ' ) ; } else if ( requires Login ) { e . prevent Default ( ) ; redirect To Login ( ) ; } } ) ) ; } else if ( requires Login ) { e . prevent Default ( ) ; redirect To Login ( ) ; } } } 
function string _of _enum ( e , value ) { for ( var k in e ) if ( e [ k ] = = value ) return k ; return "Unknown ( " + value + " ) " ; } 
function ( ) { this . init = function ( blynk ) { } ; this . process = function ( values ) { switch ( values [ 0 ] ) { case 'pm ' : return true ; case 'dw ' : case 'dr ' : case 'aw ' : case 'ar ' : console . log ( "No direct pin operations available . " ) ; console . log ( "Maybe you need to install mraa or onoff modules ? " ) ; return true ; } } ; } 
function ( auth , options ) { var self = this ; if ( needs Emitter ( ) ) { events . Event Emitter . call ( this ) ; } this . auth = auth ; var options = options | | { } ; this . heartbeat = options . heartbeat | | 1 0 0 0 0 ; console . log ( " \n \ _ _ _ _ _ _ _ \n \ / _ ) / / _ _ _ _ _ _ / / _ _ \n \ / _ / / / / / _ \ \ / ' _ / \n \ / _ _ _ _ / _ / \ \ _ , / _ / / _ / _ / \ \ _ \ \ \n \ / _ _ _ / \n \ \n \ Give Blynk a Github star ! = > https : / /github .com /vshymanskyy /blynk -library -js \n \ " ) ; 
function ( auth , options ) { var self = this ; this . auth = auth ; var options = options | | { } ; this . heartbeat = options . heartbeat | | 1 0 0 0 0 ; 
function orphaned Libraries ( src , dst ) { 
function _find Nested ( d ) { let nested = [ ] ; walk . walk Sync ( d , ( basedir , filename , stat ) = > { const file = path . join ( basedir , filename ) ; if ( file . index Of ( ' .app /Info .plist ' ) ! = = - 1 ) { const nest = file . last Index Of ( ' .app / ' ) ; nested . push ( file . substring ( 0 , nest + 4 ) ) ; } } ) ; return nested ; } 
function bin Abs Libs ( file , o ) { try { return bin . enumerate Libraries ( file ) . filter ( ( l ) = > { return ! ( l . starts With ( ' / ' ) ) ; } ) . map ( ( l ) = > { if ( l [ 0 ] = = = ' @ ' ) { const ll = dep Solver . resolve Path ( o . exe , file , l , o . libs ) ; if ( ll ) { l = ll ; } else { console . error ( 'Warning : Cannot resolve dependency library : ' + file ) ; } } return l ; } ) ; } catch ( e ) { console . error ( 'Warning : missing file : ' , file ) ; return [ ] ; } } 
function _find Libraries ( appdir , appbin , disklibs ) { const exe = path . join ( appdir , appbin ) ; const o = { exe : exe , lib : exe , libs : disklibs } ; const libraries = [ ] ; const pending = [ exe ] ; while ( pending . length > 0 ) { const target = pending . pop ( ) ; if ( libraries . index Of ( target ) = = = - 1 ) { libraries . push ( target ) ; } let res = bin Abs Libs ( target , o ) ; const unexplored = res . filter ( l = > libraries . index Of ( l ) = = = - 1 ) ; pending . push ( . . . unexplored . filter ( l = > pending . index Of ( l ) = = = - 1 ) ) ; libraries . push ( . . . unexplored ) ; } return libraries ; } 
function fix ( file , options , emit ) { const { appdir , bundleid , force Family , allow Http } = options ; if ( ! file | | ! appdir ) { throw new Error ( 'Invalid parameters for fix Plist ' ) ; } let changed = false ; const data = plist . read File Sync ( file ) ; delete data [ ' ' ] ; if ( allow Http ) { emit ( 'message ' , 'Adding NSAllow Arbitrary Loads ' ) ; if ( ! Object . is Object ( data [ 'NSApp Transport Security ' ] ) ) { data [ 'NSApp Transport Security ' ] = { } ; } data [ 'NSApp Transport Security ' ] [ 'NSAllows Arbitrary Loads ' ] = true ; changed = true ; } if ( force Family ) { if ( perform Force Family ( data , emit ) ) { changed = true ; } } if ( bundleid ) { set Bundle Id ( data , bundleid ) ; changed = true ; } if ( changed ) { plist . write File Sync ( file , data ) ; } } 
function get Resigned Filename ( input ) { if ( ! input ) { return null ; } const pos = input . last Index Of ( path . sep ) ; if ( pos ! = = - 1 ) { const tmp = input . substring ( pos + 1 ) ; const dot = tmp . last Index Of ( ' . ' ) ; input = ( dot ! = = - 1 ) ? tmp . substring ( 0 , dot ) : tmp ; } else { const dot = input . last Index Of ( ' . ' ) ; if ( dot ! = = - 1 ) { input = input . substring ( 0 , dot ) ; } } return input + ' -resigned .ipa ' ; } 
function generate Accessor ( accessor ) { return function ( ) { let value = container [ var Name ] if ( typeof value = = = 'undefined ' ) { if ( typeof def Value = = = 'undefined ' ) { 
function ( is Required ) { if ( is Required = = = false ) { return accessors } if ( typeof container [ var Name ] = = = 'undefined ' & & typeof def Value = = = 'undefined ' ) { throw new Env Var Error ( ` $ { var Name } ` ) } return accessors } 
function get Ref Text ( ast ) { var ret = ast . leader ; var is Fn = ast . args ! = = undefined ; if ( ast . type = = = 'macro _call ' ) { ret = ' # ' ; } if ( ast . is Wraped ) ret + = ' { ' ; if ( is Fn ) { ret + = get Method Text ( ast ) ; } else { ret + = ast . id ; } utils . for Each ( ast . path , function ( ref ) { 
function convert ( str ) { if ( typeof str ! = = 'string ' ) return str ; var result = " " var escape = false var i , c , cstr ; for ( i = 0 ; i < str . length ; i + + ) { c = str . char At ( i ) ; if ( ( ' ' < = c & & c < = ' ~ ' ) | | ( c = = = ' \r ' ) | | ( c = = = ' \n ' ) ) { if ( c = = = ' & ' ) { cstr = " &amp ; " escape = true } else if ( c = = = ' < ' ) { cstr = " &lt ; " escape = true } else if ( c = = = ' > ' ) { cstr = " &gt ; " escape = true } else { cstr = c . to String ( ) } } else { cstr = " & # " + c . char Code At ( ) . to String ( ) + " ; " } result = result + cstr } return escape ? result : str } 
function ( key ) { if ( ! utils . is Array ( key ) ) key = [ key ] utils . for Each ( key , function ( key ) { this . config . unescape [ key ] = true } , this ) } 
function ( ast , is Val ) { if ( ast . prue ) { var define = this . defines [ ast . id ] ; if ( utils . is Array ( define ) ) { return this . _render ( define ) ; } if ( ast . id in this . config . unescape ) ast . prue = false ; } var escape = this . config . escape ; var is Silent = this . silence | | ast . leader = = = " $ ! " ; var isfn = ast . args ! = = undefined ; var context = this . context ; var ret = context [ ast . id ] ; var local = this . get Local ( ast ) ; var text = Velocity . Helper . get Ref Text ( ast ) ; if ( text in context ) { return ( ast . prue & & escape ) ? convert ( context [ text ] ) : context [ text ] ; } if ( ret ! = = undefined & & isfn ) { ret = this . get Prop Method ( ast , context , ast ) ; } if ( local . is Localed ) ret = local [ 'value ' ] ; if ( ast . path ) { utils . some ( ast . path , function ( property , i , len ) { if ( ret = = = undefined ) { this . _throw ( ast , property ) ; } 
function ( ast ) { var id = ast . id ; var local = this . local ; var ret = false ; var is Localed = utils . some ( this . conditions , function ( context Id ) { var _local = local [ context Id ] ; if ( id in _local ) { ret = _local [ id ] ; return true ; } return false ; } , this ) ; return { value : ret , is Localed : is Localed } ; } 
function ( property , base Ref , ast ) { * type   velocity .yy  attribute      : method , index , property * / var type = property . type ; var ret ; var id = property . id ; if ( type = = = 'method ' ) { ret = this . get Prop Method ( property , base Ref , ast ) ; } else if ( type = = = 'property ' ) { ret = base Ref [ id ] ; } else { ret = this . get Prop Index ( property , base Ref ) ; } return ret ; } 
function ( property , base Ref ) { var ast = property . id ; var key ; if ( ast . type = = = 'references ' ) { key = this . get References ( ast ) ; } else if ( ast . type = = = 'integer ' ) { key = ast . value ; } else { key = ast . value ; } return base Ref [ key ] ; } 
function ( property , base Ref , ast ) { var id = property . id ; var ret = ' ' ; 
function ( literal ) { var type = literal . type ; var ret = ' ' ; if ( type = = = 'string ' ) { ret = this . get String ( literal ) ; } else if ( type = = = 'integer ' ) { ret = parse Int ( literal . value , 1 0 ) ; } else if ( type = = = 'decimal ' ) { ret = parse Float ( literal . value , 1 0 ) ; } else if ( type = = = 'array ' ) { ret = this . get Array ( literal ) ; } else if ( type = = = 'map ' ) { ret = { } ; var map = literal . value ; utils . for Each ( map , function ( exp , key ) { ret [ key ] = this . get Literal ( exp ) ; } , this ) ; } else if ( type = = = 'bool ' ) { if ( literal . value = = = "null " ) { ret = null ; } else if ( literal . value = = = 'false ' ) { ret = false ; } else if ( literal . value = = = 'true ' ) { ret = true ; } } else { return this . get References ( literal ) ; } return ret ; } 
function ( literal ) { var val = literal . value ; var ret = val ; if ( literal . is Eval & & ( val . index Of ( ' # ' ) ! = = - 1 | | val . index Of ( " $ " ) ! = = - 1 ) ) { ret = this . eval Str ( val ) ; } return ret ; } 
function ( literal ) { var ret = [ ] ; if ( literal . is Range ) { var begin = literal . value [ 0 ] ; if ( begin . type = = = 'references ' ) { begin = this . get References ( begin ) ; } var end = literal . value [ 1 ] ; if ( end . type = = = 'references ' ) { end = this . get References ( end ) ; } end = parse Int ( end , 1 0 ) ; begin = parse Int ( begin , 1 0 ) ; var i ; if ( ! is Na N ( begin ) & & ! is Na N ( end ) ) { if ( begin < end ) { for ( i = begin ; i < = end ; i + + ) ret . push ( i ) ; } else { for ( i = begin ; i > = end ; i - - ) ret . push ( i ) ; } } } else { utils . for Each ( literal . value , function ( exp ) { ret . push ( this . get Literal ( exp ) ) ; } , this ) ; } return ret ; } 
function ( block ) { var ast = block [ 0 ] ; var ret = ' ' ; switch ( ast . type ) { case 'if ' : ret = this . get Block If ( block ) ; break ; case 'foreach ' : ret = this . get Block Each ( block ) ; break ; case 'macro ' : this . set Block Macro ( block ) ; break ; case 'noescape ' : ret = this . _render ( block . slice ( 1 ) ) ; break ; case 'define ' : this . set Block Define ( block ) ; break ; case 'macro _body ' : ret = this . get Macro Body ( block ) ; break ; default : ret = this . _render ( block ) ; } return ret | | ' ' ; } 
function ( block ) { var ast = block [ 0 ] ; var _block = block . slice ( 1 ) ; var defines = this . defines ; defines [ ast . id ] = _block ; } 
function ( block ) { var ast = block [ 0 ] ; var _block = block . slice ( 1 ) ; var macros = this . macros ; macros [ ast . id ] = { asts : _block , args : ast . args } ; } 
function ( ast , body Content ) { var macro = this . macros [ ast . id ] ; var ret = ' ' ; if ( ! macro ) { var jsmacros = this . jsmacros ; macro = jsmacros [ ast . id ] ; var js Args = [ ] ; if ( macro & & macro . apply ) { utils . for Each ( ast . args , function ( a ) { js Args . push ( this . get Literal ( a ) ) ; } , this ) ; var self = this ; 
function ( str , local , context Id ) { if ( ! local ) { if ( utils . is Array ( str ) ) { return this . _render ( str ) ; } else { return this . eval Str ( str ) ; } } else { var asts = [ ] ; var parse = Velocity . parse ; context Id = context Id | | ( 'eval : ' + utils . guid ( ) ) ; if ( utils . is Array ( str ) ) { asts = str ; } else if ( parse ) { asts = parse ( str ) ; } if ( asts . length ) { this . local [ context Id ] = local ; var ret = this . _render ( asts , context Id ) ; this . local [ context Id ] = { } ; this . conditions . shift ( ) ; this . condition = this . conditions [ 0 ] | | ' ' ; return ret ; } } } 
function ( block ) { var ast = block [ 0 ] ; var _from = this . get Literal ( ast . from ) ; var _block = block . slice ( 1 ) ; var _to = ast . to ; var local = { foreach : { count : 0 } } ; var ret = ' ' ; var guid = utils . guid ( ) ; var context Id = 'foreach : ' + guid ; var type = ( { } ) . to String . call ( _from ) ; if ( ! _from | | ( type ! = = ' [object Array ] ' & & type ! = = ' [object Object ] ' ) ) { return ' ' ; } if ( utils . is Array ( _from ) ) { var len = _from . length ; utils . for Each ( _from , function ( val , i ) { if ( this . _state . break ) { return ; } 
function ( block ) { var received = false ; var asts = [ ] ; utils . some ( block , function ( ast ) { if ( ast . condition ) { if ( received ) { return true ; } received = this . get Expression ( ast . condition ) ; } else if ( ast . type = = = 'else ' ) { if ( received ) { return true ; } received = true ; } else if ( received ) { asts . push ( ast ) ; } return false ; } , this ) ; 
function ( ast ) { var local = this . get Local ( ast ) ; var real = local . real | | ast ; var ret = { ignore : false , type : 'string ' , real : real , foreach : false } ; if ( local . real = = = undefined & & local . is Global ! = = true ) { ret . ignore = true ; } var m = this . has Method ( real ) ; var each To ; if ( local . type = = 'foreach ' ) { if ( ast . id = = local . ast . to ) { 
function ( ast ) { var exp = ast . expression ; var ret ; if ( ast . type = = = 'math ' ) { switch ( ast . operator ) { case ' + ' : ret = this . get Expression ( exp [ 0 ] ) + this . get Expression ( exp [ 1 ] ) ; break ; case ' - ' : ret = this . get Expression ( exp [ 0 ] ) - this . get Expression ( exp [ 1 ] ) ; break ; case ' / ' : ret = this . get Expression ( exp [ 0 ] ) / this . get Expression ( exp [ 1 ] ) ; break ; case ' % ' : ret = this . get Expression ( exp [ 0 ] ) % this . get Expression ( exp [ 1 ] ) ; break ; case ' * ' : ret = this . get Expression ( exp [ 0 ] ) * this . get Expression ( exp [ 1 ] ) ; break ; case ' | | ' : ret = this . get Expression ( exp [ 0 ] ) | | this . get Expression ( exp [ 1 ] ) ; break ; case ' & & ' : ret = this . get Expression ( exp [ 0 ] ) & & this . get Expression ( exp [ 1 ] ) ; break ; case ' > ' : ret = this . get Expression ( exp [ 0 ] ) > this . get Expression ( exp [ 1 ] ) ; break ; case ' < ' : ret = this . get Expression ( exp [ 0 ] ) < this . get Expression ( exp [ 1 ] ) ; break ; case ' = = ' : ret = this . get Expression ( exp [ 0 ] ) = = this . get Expression ( exp [ 1 ] ) ; break ; case ' > = ' : ret = this . get Expression ( exp [ 0 ] ) > = this . get Expression ( exp [ 1 ] ) ; break ; case ' < = ' : ret = this . get Expression ( exp [ 0 ] ) < = this . get Expression ( exp [ 1 ] ) ; break ; case ' ! = ' : ret = this . get Expression ( exp [ 0 ] ) ! = this . get Expression ( exp [ 1 ] ) ; break ; case 'minus ' : ret = - this . get Expression ( exp [ 0 ] ) ; break ; case 'not ' : ret = ! this . get Expression ( exp [ 0 ] ) ; break ; case 'parenthesis ' : ret = this . get Expression ( exp [ 0 ] ) ; break ; default : return ; 
function ( asts , context Id ) { var str = ' ' ; asts = asts | | this . asts ; if ( context Id ) { if ( context Id ! = = this . condition & & utils . index Of ( context Id , this . conditions ) = = = - 1 ) { this . conditions . unshift ( context Id ) ; } this . condition = context Id ; } else { this . condition = null ; } utils . for Each ( asts , function ( ast ) { 
function get All Modules ( compilation ) { let modules = compilation . modules ; * @see https : * In webpack @ 3 . 5 . 1 `modules ` public property was removed * To workaround this private ` _ordered Concatenation List ` property is used to collect modules * / const sub Modules = 'modules ' in m ? m . modules : m . _ordered Concatenation List . map ( entry = > entry . module ) ; return acc . concat ( sub Modules ) ; } , [ ] ) ; if ( concatenated Modules . length > 0 ) { modules = modules . concat ( concatenated Modules ) ; } } return modules . filter ( m = > m . raw Request ) ; } 
function get Module Chunk ( module ) { let chunks ; const webpack Version = get Webpack Major Version ( ) ; if ( webpack Version > = 4 ) { chunks = Array . from ( module . chunks Iterable ) ; } else if ( webpack Version > = 3 ) { chunks = module . map Chunks ( ) ; } else { chunks = module . chunks ; } if ( Array . is Array ( chunks ) & & chunks . length > 0 ) { return chunks [ chunks . length - 1 ] ; } else if ( module . issuer ) { return get Module Chunk ( module . issuer ) ; } return null ; } 
function check Bin References _ ( file , data , warn , cb ) { if ( ! ( data . bin instanceof Object ) ) return cb ( ) var keys = Object . keys ( data . bin ) var keys Left = keys . length if ( ! keys Left ) return cb ( ) function handle Exists ( rel Name , result ) { keys Left - - if ( ! result ) warn ( 'No bin file found at ' + rel Name ) if ( ! keys Left ) cb ( ) } keys . for Each ( function ( key ) { var dir Name = path . dirname ( file ) var rel Name = data . bin [ key ] try { var bin Path = path . resolve ( dir Name , rel Name ) fs . stat ( bin Path , ( err ) = > handle Exists ( rel Name , ! err ) ) } catch ( error ) { if ( error . message = = = 'Arguments to path .resolve must be strings ' | | error . message . index Of ( 'Path must be a string ' ) = = = 0 ) { warn ( 'Bin filename for ' + key + ' is not a string : ' + util . inspect ( rel Name ) ) handle Exists ( rel Name , true ) } else { cb ( error ) } } } ) } 
function parse Index ( data ) { data = data . split ( / ^ \ / \ * \ *package ( ? : \s | $ ) / m ) if ( data . length < 2 ) return null data = data [ 1 ] data = data . split ( / \ * \ * \ / $ / m ) if ( data . length < 2 ) return null data = data [ 0 ] data = data . replace ( / ^ \s * \ * / mg , ' ' ) try { return safe JSON ( data ) } catch ( er ) { return null } } 
function ( ) { var self = this ; self . bind ( 'Runtime Init ' , function ( e , runtime ) { self . ruid = runtime . uid ; self . shimid = runtime . shimid ; self . bind ( "Ready " , function ( ) { self . trigger ( "Refresh " ) ; } , 9 9 9 ) ; 
function ( name , value ) { if ( ! options . has Own Property ( name ) ) { return ; } var old Value = options [ name ] ; switch ( name ) { case 'accept ' : if ( typeof ( value ) = = = 'string ' ) { value = Mime . mimes 2ext List ( value ) ; } break ; case 'container ' : case 'required _caps ' : throw new x . File Exception ( x . File Exception . NO _MODIFICATION _ALLOWED _ERR ) ; } options [ name ] = value ; this . exec ( 'File Input ' , 'set Option ' , name , value ) ; this . trigger ( 'Option Changed ' , name , value , old Value ) ; } 
function ( mime Data ) { var items = mime Data . split ( / , / ) , i , ii , ext ; for ( i = 0 ; i < items . length ; i + = 2 ) { ext = items [ i + 1 ] . split ( / / ) ; 
function ( from , to , text , all ) { var pos = text . index Of ( from ) ; if ( pos = = - 1 ) { return text ; } text = text . substring ( 0 , pos ) + to + text . substring ( pos + from . length ) ; return ! all ? text : replace . call ( null , from , to , text , all ) ; } 
function ( e , runtime ) { self . unbind ( "Runtime Init " , cb ) ; _run . call ( self , type , runtime ) ; } 
function ( ) { this . result = null ; if ( Basic . in Array ( this . ready State , [ File Reader . EMPTY , File Reader . DONE ] ) ! = = - 1 ) { return ; } else if ( this . ready State = = = File Reader . LOADING ) { this . ready State = File Reader . DONE ; } this . exec ( 'File Reader ' , 'abort ' ) ; this . trigger ( 'abort ' ) ; this . trigger ( 'loadend ' ) ; } 
function ( uastring ) { var ua = uastring | | ( ( window & & window . navigator & & window . navigator . user Agent ) ? window . navigator . user Agent : EMPTY ) ; this . get Browser = function ( ) { return mapper . rgx . apply ( this , regexes . browser ) ; } ; this . get Engine = function ( ) { return mapper . rgx . apply ( this , regexes . engine ) ; } ; this . get OS = function ( ) { return mapper . rgx . apply ( this , regexes . os ) ; } ; this . get Result = function ( ) { return { ua : this . get UA ( ) , browser : this . get Browser ( ) , engine : this . get Engine ( ) , os : this . get OS ( ) } ; } ; this . get UA = function ( ) { return ua ; } ; this . set UA = function ( uastring ) { ua = uastring ; return this ; } ; this . set UA ( ua ) ; } 
function ( v ) { v = ( ' ' + v ) . replace ( / [ _ \ - + ] / g , ' . ' ) ; v = v . replace ( / ( [ ^ . \d ] + ) / g , ' . $ 1 . ' ) . replace ( / \ . { 2 , } / g , ' . ' ) ; return ( ! v . length ? [ - 8 ] : v . split ( ' . ' ) ) ; } 
function ( type ) { var list ; if ( type ) { type = type . to Lower Case ( ) ; list = eventpool [ this . uid ] & & eventpool [ this . uid ] [ type ] ; } else { list = eventpool [ this . uid ] ; } return list ? list : false ; } 
function ( type , fn ) { var self = this , list , i ; type = type . to Lower Case ( ) ; if ( / \s / . test ( type ) ) { 
function ( type , fn , priority , scope ) { var self = this ; self . bind . call ( this , type , function cb ( ) { self . unbind ( type , cb ) ; return fn . apply ( this , arguments ) ; } , priority , scope ) ; } 
function ( dispatches ) { var self = this ; this . bind ( dispatches . join ( ' ' ) , function ( e ) { var prop = 'on ' + e . type . to Lower Case ( ) ; if ( Basic . type Of ( this [ prop ] ) = = = 'function ' ) { this [ prop ] . apply ( this , arguments ) ; } } ) ; 
function ( cap , value ) { var ref Caps = arguments [ 2 ] | | caps ; 
function ( component , action ) { var args = [ ] . slice . call ( arguments , 2 ) ; return self . get Shim ( ) . exec . call ( this , this . uid , component , action , args ) ; } 
function ( component , action ) { 
function ( ) { if ( ! self ) { return ; 
function get Shim Version ( ) { var version ; try { version = navigator . plugins [ 'Shockwave Flash ' ] ; version = version . description ; } catch ( e 1 ) { try { version = new Active XObject ( 'Shockwave Flash .Shockwave Flash ' ) . Get Variable ( ' $version ' ) ; } catch ( e 2 ) { version = ' 0 . 0 ' ; } } version = version . match ( / \d + / g ) ; return parse Float ( version [ 0 ] + ' . ' + version [ 1 ] ) ; } 
function remove SWF ( id ) { var obj = Dom . get ( id ) ; if ( obj & & obj . node Name = = "OBJECT " ) { if ( Env . browser = = = 'IE ' ) { obj . style . display = "none " ; ( function on Init ( ) { 
function ( url ) { function origin ( url ) { return [ url . scheme , url . host , url . port ] . join ( ' / ' ) ; } if ( typeof url = = = 'string ' ) { url = parse Url ( url ) ; } return origin ( parse Url ( ) ) = = = origin ( url ) ; } 
function inherit ( child , parent ) { 
function ctor ( ) { this . constructor = child ; if ( MXI _DEBUG ) { var get Ctor Name = function ( fn ) { var m = fn . to String ( ) . match ( / ^function \s ( [ ^ \ ( \s ] + ) / ) ; return m ? m [ 1 ] : false ; } ; this . ctor Name = get Ctor Name ( child ) ; } } 
function in Array ( needle , array ) { if ( array ) { if ( Array . prototype . index Of ) { return Array . prototype . index Of . call ( array , needle ) ; } for ( var i = 0 , length = array . length ; i < length ; i + + ) { if ( array [ i ] = = = needle ) { return i ; } } } return - 1 ; } 
function array Diff ( needles , array ) { var diff = [ ] ; if ( type Of ( needles ) ! = = 'array ' ) { needles = [ needles ] ; } if ( type Of ( array ) ! = = 'array ' ) { array = [ array ] ; } for ( var i in needles ) { if ( in Array ( needles [ i ] , array ) = = = - 1 ) { diff . push ( needles [ i ] ) ; } } return diff . length ? diff : false ; } 
function array Intersect ( array 1 , array 2 ) { var result = [ ] ; each ( array 1 , function ( item ) { if ( in Array ( item , array 2 ) ! = = - 1 ) { result . push ( item ) ; } } ) ; return result . length ? result : null ; } 
function parse Size Str ( size ) { if ( typeof ( size ) ! = = 'string ' ) { return size ; } var muls = { t : 1 0 9 9 5 1 1 6 2 7 7 7 6 , g : 1 0 7 3 7 4 1 8 2 4 , m : 1 0 4 8 5 7 6 , k : 1 0 2 4 } , mul ; size = / ^ ( [ 0 - 9 \ . ] + ) ( [tmgk ] ? ) $ / . exec ( size . to Lower Case ( ) . replace ( / [ ^ 0 - 9 \ .tmkg ] / g , ' ' ) ) ; mul = size [ 2 ] ; size = + size [ 1 ] ; if ( muls . has Own Property ( mul ) ) { size * = muls [ mul ] ; } return Math . floor ( size ) ; } 
function sprintf ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; return str . replace ( / % ( [a -z ] ) / g , function ( $ 0 , $ 1 ) { var value = args . shift ( ) ; switch ( $ 1 ) { case 's ' : return value + ' ' ; case 'd ' : return parse Int ( value , 1 0 ) ; case 'f ' : return parse Float ( value ) ; case 'c ' : return ' ' ; default : return value ; } } ) ; } 
function ( name , value ) { var self = this , value Type = Basic . type Of ( value ) ; 
function ( cb ) { Basic . each ( _fields , function ( field ) { cb ( field . value , field . name ) ; } ) ; if ( _blob ) { cb ( _blob . value , _blob . name ) ; } } 
function ( obj , name ) { if ( ! obj . class Name ) { return false ; } var reg Exp = new Reg Exp ( " ( ^ | \ \s + ) " + name + " ( \ \s + | $ ) " ) ; return reg Exp . test ( obj . class Name ) ; } 
function ( obj , name ) { if ( ! has Class ( obj , name ) ) { obj . class Name = ! obj . class Name ? name : obj . class Name . replace ( / \s + $ / , ' ' ) + ' ' + name ; } } 
function ( obj , name ) { if ( obj . class Name ) { var reg Exp = new Reg Exp ( " ( ^ | \ \s + ) " + name + " ( \ \s + | $ ) " ) ; obj . class Name = obj . class Name . replace ( reg Exp , function ( $ 0 , $ 1 , $ 2 ) { return $ 1 = = = ' ' & & $ 2 = = = ' ' ? ' ' : ' ' ; } ) ; } } 
function ( obj , name ) { if ( obj . current Style ) { return obj . current Style [ name ] ; } else if ( window . get Computed Style ) { return window . get Computed Style ( obj , null ) [ name ] ; } } 
function ( node , root ) { var x = 0 , y = 0 , parent , doc = document , node Rect , root Rect ; node = node ; root = root | | doc . body ; 
function get IEPos ( node ) { var body Elm , rect , x = 0 , y = 0 ; if ( node ) { rect = node . get Bounding Client Rect ( ) ; body Elm = doc . compat Mode = = = "CSS 1Compat " ? doc . document Element : doc . body ; x = rect . left + body Elm . scroll Left ; y = rect . top + body Elm . scroll Top ; } return { x : x , y : y } ; } 
function ( node ) { return { w : node . offset Width | | node . client Width , h : node . offset Height | | node . client Height } ; } 
function ( obj , name , callback , key ) { var func , events ; name = name . to Lower Case ( ) ; 
function ( obj , name , callback ) { var type , undef ; name = name . to Lower Case ( ) ; if ( obj [ uid ] & & eventhash [ obj [ uid ] ] & & eventhash [ obj [ uid ] ] [ name ] ) { type = eventhash [ obj [ uid ] ] [ name ] ; } else { return ; } for ( var i = type . length - 1 ; i > = 0 ; i - - ) { 
function ( obj , key ) { if ( ! obj | | ! obj [ uid ] ) { return ; } Basic . each ( eventhash [ obj [ uid ] ] , function ( events , name ) { remove Event ( obj , name , key ) ; } ) ; } 
function _preload And Send ( meta , data ) { var target = this , blob , fr ; 
function _rotate To Orientaion ( img , orientation ) { var RADIANS = Math . PI / 1 8 0 ; var canvas = document . create Element ( 'canvas ' ) ; var ctx = canvas . get Context ( ' 2d ' ) ; var width = img . width ; var height = img . height ; if ( Basic . in Array ( orientation , [ 5 , 6 , 7 , 8 ] ) > - 1 ) { canvas . width = height ; canvas . height = width ; } else { canvas . width = width ; canvas . height = height ; } switch ( orientation ) { case 2 : 
function ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; return str . replace ( / % [a -z ] / g , function ( ) { var value = args . shift ( ) ; return Basic . type Of ( value ) ! = = 'undefined ' ? value : ' ' ; } ) ; } 
function get Entries ( cbcb ) { dir Reader . read Entries ( function ( more Entries ) { if ( more Entries . length ) { [ ] . push . apply ( entries , more Entries ) ; get Entries ( cbcb ) ; } else { cbcb ( ) ; } } , cbcb ) ; } 
function ( method , url , async , user , password ) { var urlp ; 
function ( header , value ) { var ua Headers = [ if ( / [ \u 0 1 0 0 - \uffff ] / .test (value ) | | Encode .utf 8 _encode (value ) ! = = value ) { throw new x .DOMException (x .DOMException .SYNTAX _ERR ) ; } * / header = Basic . trim ( header ) . to Lower Case ( ) ; 
function ( header ) { header = header . to Lower Case ( ) ; if ( _error _flag | | ! ! ~ Basic . in Array ( header , [ 'set -cookie ' , 'set -cookie 2 ' ] ) ) { return null ; } if ( _response Headers & & _response Headers ! = = ' ' ) { 
function ( mime ) { var matches , charset ; 
function ( data , options ) { if ( Basic . type Of ( options ) = = = 'string ' ) { _options = { ruid : options } ; } else if ( ! options ) { _options = { } ; } else { _options = options ; } 
function ( ) { _error _flag = true ; _sync _flag = false ; if ( ! ~ Basic . in Array ( _p ( 'ready State ' ) , [ XMLHttp Request . UNSENT , XMLHttp Request . OPENED , XMLHttp Request . DONE ] ) ) { _p ( 'ready State ' , XMLHttp Request . DONE ) ; _send _flag = false ; if ( _xhr ) { _xhr . get Runtime ( ) . exec . call ( _xhr , 'XMLHttp Request ' , 'abort ' , _upload _complete _flag ) ; } else { throw new x . DOMException ( x . DOMException . INVALID _STATE _ERR ) ; } _upload _complete _flag = true ; } else { _p ( 'ready State ' , XMLHttp Request . UNSENT ) ; } } 
function _p ( prop , value ) { if ( ! props . has Own Property ( prop ) ) { return ; } if ( arguments . length = = = 1 ) { 
function add Input ( ) { var comp = this , I = comp . get Runtime ( ) , shim Container , browse Button , curr Form , form , input , uid ; uid = Basic . guid ( 'uid _ ' ) ; shim Container = I . get Shim Container ( ) ; 
function ( obj , callback ) { var length , key , i ; if ( obj ) { length = obj . length ; if ( length = = = undefined ) { 
function ( target ) { var undef ; each ( arguments , function ( arg , i ) { if ( i > 0 ) { each ( arg , function ( value , key ) { if ( value ! = = undef ) { if ( typeof ( target [ key ] ) = = = typeof ( value ) & & ( typeof ( value ) = = = 'object ' | | util . is Array ( value ) ) ) { extend ( target [ key ] , value ) ; } else { target [ key ] = value ; } } } ) ; } } ) ; return target ; } 
function ( options ) { var self = this ; var orientation ; var scale ; var src Rect = { x : 0 , y : 0 , width : self . width , height : self . height } ; var opts = Basic . extend If ( { width : self . width , height : self . height , type : self . type | | 'image /jpeg ' , quality : 9 0 , crop : false , fit : true , preserve Headers : true , resample : 'default ' , multipass : true } , options ) ; try { if ( ! self . size ) { 
function ( options ) { var defaults = { width : this . width , height : this . height , type : this . type | | 'image /jpeg ' , quality : 9 0 , crop : false , fit : false , preserve Headers : true , resample : 'default ' } , opts ; if ( typeof ( options ) = = = 'object ' ) { opts = Basic . extend ( defaults , options ) ; } else { 
function ( type , quality ) { if ( ! this . size ) { throw new x . DOMException ( x . DOMException . INVALID _STATE _ERR ) ; } return this . exec ( 'Image ' , 'get As Blob ' , type | | 'image /jpeg ' , quality | | 9 0 ) ; } 
function ( type , quality ) { var data Url = this . get As Data URL ( type , quality ) ; return Encode . atob ( data Url . substring ( data Url . index Of ( 'base 6 4 , ' ) + 7 ) ) ; } 
function ( el , options ) { var self = this , runtime tr .destroy ( ) ; runtime .destroy ( ) ; on Resize .call (self ) ; } ) ; * / runtime = null ; 
function ( ) { if ( this . ruid ) { this . get Runtime ( ) . exec . call ( this , 'Image ' , 'destroy ' ) ; this . disconnect Runtime ( ) ; } if ( this . meta & & this . meta . thumb ) { 
function ( obj , prop , desc ) { if ( o . type Of ( desc ) = = = 'object ' ) { define GSetter . call ( obj , prop , desc , 'get ' ) ; if ( ! Object . define Property ) { 
function ( prop , desc , type ) { var defaults = { enumerable : true , configurable : true } , fn , camel Type , self = this ; type = type . to Lower Case ( ) ; camel Type = type . replace ( / ^ [gs ] / , function ( $ 1 ) { return $ 1 . to Upper Case ( ) ; } ) ; 
function initialize Watchers ( ) { var watcher = chokidar . watch ( ' * * / * .js ' , { ignored : 'node _modules ' } ) ; watcher . on ( 'change ' , main ) . on ( 'unlink ' , main ) ; watchers Initialized = true ; console . log ( 'Watchers initialized ' ) ; } 
function Syntax Error ( message , expected , found , offset , line , column ) { Error . call ( this , message ) this . name = 'Syntax Error ' this . message = message this . expected = expected this . found = found this . offset = offset this . line = line this . column = column } 
function Message Format ( pattern , locales , options ) { if ( ! ( this instanceof Message Format ) | | internals . has ( this ) ) { throw new Type Error ( 'calling Message Format constructor without new is invalid ' ) } var ast = parse ( pattern ) internals . set ( this , { ast : ast , format : interpret ( ast , locales , options & & options . types ) , locale : Message Format . supported Locales Of ( locales ) [ 0 ] | | 'en ' , locales : locales , options : options } ) } 
function ( twist ) { var i , m , o , ori , parity , v ; if ( twist ! = null ) { parity = 0 ; for ( i = m = 6 ; m > = 0 ; i = - - m ) { ori = twist % 3 ; twist = ( twist / 3 ) | 0 ; this . co [ i ] = ori ; parity + = ori ; } this . co [ 7 ] = ( 3 - parity % 3 ) % 3 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o < = 6 ; i = + + o ) { v = 3 * v + this . co [ i ] ; } return v ; } } 
function ( flip ) { var i , m , o , ori , parity , v ; if ( flip ! = null ) { parity = 0 ; for ( i = m = 1 0 ; m > = 0 ; i = - - m ) { ori = flip % 2 ; flip = flip / 2 | 0 ; this . eo [ i ] = ori ; parity + = ori ; } this . eo [ 1 1 ] = ( 2 - parity % 2 ) % 2 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o < = 1 0 ; i = + + o ) { v = 2 * v + this . eo [ i ] ; } return v ; } } 
function ( ) { var i , j , m , o , ref , ref 1 , ref 2 , ref 3 , s ; s = 0 ; for ( i = m = ref = DRB , ref 1 = URF + 1 ; ( ref < = ref 1 ? m < = ref 1 : m > = ref 1 ) ; i = ref < = ref 1 ? + + m : - - m ) { for ( j = o = ref 2 = i - 1 , ref 3 = URF ; ( ref 2 < = ref 3 ? o < = ref 3 : o > = ref 3 ) ; j = ref 2 < = ref 3 ? + + o : - - o ) { if ( this . cp [ j ] > this . cp [ i ] ) { s + + ; } } } return s % 2 ; } 
function ( ) { var i , j , m , o , ref , ref 1 , ref 2 , ref 3 , s ; s = 0 ; for ( i = m = ref = BR , ref 1 = UR + 1 ; ( ref < = ref 1 ? m < = ref 1 : m > = ref 1 ) ; i = ref < = ref 1 ? + + m : - - m ) { for ( j = o = ref 2 = i - 1 , ref 3 = UR ; ( ref 2 < = ref 3 ? o < = ref 3 : o > = ref 3 ) ; j = ref 2 < = ref 3 ? + + o : - - o ) { if ( this . ep [ j ] > this . ep [ i ] ) { s + + ; } } } return s % 2 ; } 
function parse XY ( config , _chart Props , callback , parse Opts ) { 
function parse Chartgrid ( config , _chart Props , callback , parse Opts ) { 
function make _mults ( Outer , outer Props , data , grid Scales , render Data Func ) { var col Domain = grid Scales . cols . domain ( ) ; var num Cols = col Domain [ col Domain . length - 1 ] + 1 ; 
function all _modulo ( tick Values , interval ) { 
function detect Delimiter ( input ) { var num Rows = input . split ( / \r \n | \r | \n / ) . length ; var num Tabs = input . replace ( tab Regex , " " ) . length ; if ( num Tabs > = num Rows - 1 ) { return " \t " ; } else { return " , " ; } } 
function auto Date Format And Frequency ( min Date , max Date , date Format , available Width ) { var timespan = Math . abs ( max Date - min Date ) ; var years = timespan / 3 1 5 3 6 0 0 0 0 0 0 ; var months = timespan / 2 6 2 8 0 0 0 0 0 0 ; var days = timespan / 8 6 4 0 0 0 0 0 ; var year Gap ; var hour Gap ; var interval ; var target Pixel Gap = 6 4 ; var maximum _ticks = Math . max ( Math . floor ( available Width / target Pixel Gap ) , 1 ) ; var time _gap = timespan / maximum _ticks ; if ( date Format = = "auto " ) { 
function validate _chart _model ( model Str ) { var parsed ; try { parsed = JSON . parse ( model Str ) ; } catch ( e ) { throw new Type Error ( "Chart model is not valid JSON " ) ; } var is Valid Chart Model = ( parsed . has Own Property ( "chart Props " ) & & parsed . has Own Property ( "metadata " ) ) ; if ( is Valid Chart Model ) { return parsed ; } else { throw new Type Error ( "Not a valid Chartbuilder model " ) ; } } 
function chart Grid Dimensions ( width , opts ) { var height ; var metadata = opts . metadata ; var grid = opts . grid ; if ( metadata . size = = "auto " | | opts . enable Responsive ) { 
function registered Callback ( payload ) { var action = payload . action ; var data ; switch ( action . event Name ) { case "receive -model " : Dispatcher . wait For ( [ Chart Properties Store . dispatch Token ] ) ; _metadata = action . model . metadata ; data = Chart Properties Store . get ( "data " ) ; _metadata . title = default Title ( data ) ; Chart Metadata Store . emit Change ( ) ; break ; case "update -metadata " : _metadata [ action . key ] = action . value ; 
function exact _ticks ( domain , numticks ) { numticks - = 1 ; var ticks = [ ] ; var delta = domain [ 1 ] - domain [ 0 ] ; var i ; for ( i = 0 ; i < numticks ; i + + ) { ticks . push ( domain [ 0 ] + ( delta / numticks ) * i ) ; } ticks . push ( domain [ 1 ] ) ; if ( domain [ 1 ] * domain [ 0 ] < 0 ) { 
function compute _scale _domain ( scale Obj , data , opts ) { 
function round _to _precision ( num , precision , supress _thou _sep ) { 
function combine _margin _pading ( m , p ) { return { top : m . top + p . top , right : m . right + p . right , bottom : m . bottom + p . bottom , left : m . left + p . left } ; } 
function precision ( a ) { 
function transform _coords ( transform String ) { 
function merge _or _apply ( defaults , source ) { var default Keys = keys ( defaults ) ; var source Keys = keys ( source ) ; return reduce ( default Keys , function ( result , key ) { if ( source Keys . index Of ( key ) > - 1 ) { result [ key ] = source [ key ] ; return result ; } else { result [ key ] = defaults [ key ] ; return result ; } } , { } ) ; } 
function suggest _tick _num ( domain ) { var MAX _TICKS = 1 0 ; var INTERVAL _BASE _VALS = [ 1 , 2 , 2 . 5 , 5 , 1 0 , 2 5 ] ; var range = Math . abs ( domain [ 0 ] - domain [ 1 ] ) var minimum = range / MAX _TICKS ; var digits = Math . floor ( range ) . to String ( ) . length ; var multiplier = Math . pow ( 1 0 , ( digits - 2 ) ) ; var acceptable _intervals = reduce ( INTERVAL _BASE _VALS , function ( prev , curr ) { var mult = curr * multiplier ; if ( mult > = minimum ) { prev = prev . concat ( [ mult ] ) ; } return prev ; } , [ ] ) ; for ( var i = 0 ; i < acceptable _intervals . length ; i + + ) { var interval = acceptable _intervals [ i ] if ( range % interval = = 0 ) { return ( range / interval ) + 1 } } ; return 1 1 ; } 
function tz _offset _to _minutes ( offset ) { if ( offset = = "Z " ) { return 0 } var offset = offset . split ( " : " ) if ( offset . length = = 1 ) { offset = offset [ 0 ] split _loc = offset . length - 2 offset = [ offset . substring ( 0 , split _loc ) , offset . substring ( split _loc ) ] } sign = offset [ 0 ] . index Of ( " - " ) > - 1 ? - 1 : 1 offset = offset . map ( parse Float ) return ( offset [ 0 ] * 6 0 ) + ( sign * offset [ 1 ] ) } 
function Chart Config ( settings ) { this . display Name = settings . display Name ; this . parser = settings . parser ; this . calculate Dimensions = settings . calculate Dimensions ; this . display = settings . display ; this . default Props = settings . default Props ; } 
function data By Series ( input , opts ) { var series ; opts = opts | | { } ; var parsed Input = parse Delim Input ( input , { check For Date : opts . check For Date , type : opts . type } ) ; var column Names = parsed Input . column Names ; var key Column = column Names . shift ( ) ; if ( column Names . length = = = 0 ) { series = [ { name : key Column , values : parsed Input . data . map ( function ( d ) { return { name : key Column , value : d [ key Column ] } ; } ) } ] ; } else { series = column Names . map ( function ( header , i ) { return { name : header , values : parsed Input . data . map ( function ( d ) { return { name : header , entry : d [ key Column ] , value : d [ header ] } ; } ) } ; } ) ; } return { series : series , input : { raw : input , type : opts . type } , has Date : parsed Input . has Date & & ( ! opts . type | | opts . type = = "date " ) , is Numeric : parsed Input . is Numeric & & ( ! opts . type | | opts . type = = "numeric " ) } ; } 
function generate _scale ( type , scale Options , data , range , additional Opts ) { if ( ! scale Options ) return { } ; return scale _types [ type ] ( scale Options , data , range , additional Opts ) ; } 
function _ordinal Adjust ( scale , value ) { var is Ordinal = scale . has Own Property ( "bandwidth " ) ; if ( is Ordinal ) { return scale ( value ) + scale . bandwidth ( ) / 2 ; } else { return scale ( value ) ; } } 
function get _tick _widths ( scale Options , font ) { if ( ! scale Options ) return { width : [ ] , max : 0 } ; var num Ticks = scale Options . tick Values . length - 1 ; var formatted Ticks = reduce ( scale Options . tick Values , function ( prev , tick , i ) { if ( i = = = num Ticks ) { return prev . concat ( [ scale Options . prefix , help . round To Precision ( tick , scale Options . precision ) , scale Options . suffix ] . join ( " " ) ) ; } else { return prev . concat ( help . round To Precision ( tick , scale Options . precision ) ) ; } } , [ ] ) ; var widths = map ( formatted Ticks , function ( text ) { return help . compute Text Width ( text , font ) ; } ) ; return { widths : widths , max : d 3 . max ( widths . slice ( 0 , - 1 ) ) 
function detect Number Separators ( ) { var n = 1 0 0 0 . 5 0 ; var l = n . to Locale String ( ) ; var s = n . to String ( ) ; var o = { decimal : l . substring ( 5 , 6 ) , thousands : l . substring ( 1 , 2 ) } ; if ( l . substring ( 5 , 6 ) = = s . substring ( 5 , 6 ) ) { o . decimal = " . " ; } if ( l . substring ( 1 , 2 ) = = s . substring ( 1 , 2 ) ) { o . thousands = " , " ; } return o ; } 
function validate Data Input ( chart Props ) { var input = chart Props . input . raw ; var series = chart Props . data ; var has Date = chart Props . scale . has Date ; var is Numeric = chart Props . scale . is Numeric ; var type = chart Props . input . type ; var scale = chart Props . scale ; var input Errors = [ ] ; 
function registered Callback ( payload ) { var action = payload . action ; var chart Props ; var error _messages ; var input _errors ; switch ( action . event Name ) { case "update -data -input " : case "update -and -reparse " : Dispatcher . wait For ( [ Chart Properties Store . dispatch Token ] ) ; chart Props = Chart Properties Store . get All ( ) ; error _messages = [ ] ; input _errors = validate Data Input ( chart Props ) ; error _messages = error _messages . concat ( input _errors ) ; _errors . messages = error _messages . map ( function ( err _name ) { return error Names [ err _name ] ; } ) ; var is Invalid = some ( _errors . messages , { type : "error " } ) ; _errors . valid = ! is Invalid ; Error Store . emit Change ( ) ; break ; default : 
function calculate _xy _dimensions ( width , opts ) { var height ; var aspect Ratio = opts . display Config . aspect Ratio ; var metadata = opts . metadata ; if ( metadata . size = = "auto " | | opts . enable Responsive ) { 
function get Error Message ( key , action ) { var action Type = action & & action . type ; var action Name = action Type & & ` $ { action Type . to String ( ) } ` | | 'an action ' ; return ( ` $ { key } $ { action Name } ` + ` ` ) ; } 
function cli Completer ( set , done ) { var exposed = { } set . value Of ( ) . for Each ( expose ) set . value Of ( ) . for Each ( check Factory ( exposed ) ) done ( ) function expose ( file ) { var landmarks = file . data [ landmark Id ] if ( landmarks ) { xtend ( exposed , landmarks ) } } } 
function transformer Factory ( file Set , info ) { return transformer 
function validate ( exposed , file ) { var references = file . data [ reference Id ] var file Path = file . path var reference var nodes var real var hash var pathname var warning var suggestion var rule Id for ( reference in references ) { nodes = references [ reference ] real = exposed [ reference ] hash = get Hash ( reference ) 
function gather References ( file , tree , info , file Set ) { var cache = { } var get Definition = definitions ( tree ) var prefix = ' ' var heading Prefix = ' # ' var lines if ( info & & info . type in view Paths ) { prefix = ' / ' + info . path ( ) + ' / ' + view Paths [ info . type ] + ' / ' } if ( info & & info . type in heading Prefixes ) { heading Prefix = heading Prefixes [ info . type ] } lines = info & & info . type in line Links ? line Links [ info . type ] : false visit ( tree , [ 'link ' , 'image ' , 'link Reference ' , 'image Reference ' ] , onresource ) return cache 
function onresource ( node ) { var link = node . url var definition var index var uri var pathname var hash 
function warn All ( file , nodes , reason , rule Id ) { nodes . for Each ( one ) function one ( node ) { file . message ( reason , node , [ source Id , rule Id ] . join ( ' : ' ) ) } } 
function get Closest ( pathname , references ) { var hash = get Hash ( pathname ) var base = get Pathname ( pathname ) var dictionary = [ ] var reference var subhash var subbase for ( reference in references ) { subbase = get Pathname ( reference ) subhash = get Hash ( reference ) if ( get Pathname ( reference ) = = = base ) { if ( subhash & & hash ) { dictionary . push ( subhash ) } } else if ( ! subhash & & ! hash ) { dictionary . push ( subbase ) } } return propose ( hash ? hash : base , dictionary , { threshold : 0 . 7 } ) } 
function get Hash ( uri ) { var hash = parse ( uri ) . hash return hash ? hash . slice ( 1 ) : null } 
function get Prev Map ( from ) { if ( typeof options . map . prev = = = 'string ' ) { var map Path = options . map . prev + path . basename ( from ) + ' .map ' ; if ( grunt . file . exists ( map Path ) ) { return grunt . file . read ( map Path ) ; } } } 
function ( req , res , next ) { if ( req . url . index Of ( ' . ' ) = = = - 1 & & req . url . index Of ( start Dir ) > - 1 ) { req . url = start Path ; } return next ( ) ; } 
function one ( node ) { var type = node & & node . type if ( type in map ) { node = map [ type ] ( node ) } if ( 'length ' in node ) { node = all ( node ) } if ( node . children ) { node . children = all ( node . children ) } return node } 
function Server ( options ) { if ( typeof ( options ) ! = = 'object ' ) throw new Type Error ( 'options (object ) is required ' ) ; this . _log = options . log . child ( { component : 'agent ' } , true ) ; this . _name = options . name | | "named " ; this . _socket = null ; } 
function parse IPv 4 ( addr ) { if ( typeof ( addr ) ! = = 'string ' ) throw new Type Error ( 'addr (string ) is required ' ) ; var octets = addr . split ( / \ . / ) . map ( function ( octet ) { return ( parse Int ( octet , 1 0 ) ) ; } ) ; if ( octets . length ! = = 4 ) throw new Type Error ( 'valid IP address required ' ) ; var uint 3 2 = ( ( octets [ 0 ] * Math . pow ( 2 5 6 , 3 ) ) + ( octets [ 1 ] * Math . pow ( 2 5 6 , 2 ) ) + ( octets [ 2 ] * 2 5 6 ) + octets [ 3 ] ) ; return ( uint 3 2 ) ; } 
function get Nested ( obj , prop ) { var service = obj [ prop ] ; if ( service = = = undefined & & Bottle . config . strict ) { throw new Error ( 'Bottle was unable to resolve a service . ` ' + prop + ' ` is undefined . ' ) ; } return service ; } 
function get Nested Bottle ( name ) { var bottle ; if ( ! this . nested [ name ] ) { bottle = Bottle . pop ( ) ; this . nested [ name ] = bottle ; this . factory ( name , function Sub Provider Factory ( ) { return bottle . container ; } ) ; } return this . nested [ name ] ; } 
function apply Middleware ( middleware , name , instance , container ) { var descriptor = { configurable : true , enumerable : true } ; if ( middleware . length ) { descriptor . get = function get With Middlewear ( ) { var index = 0 ; var next = function next Middleware ( err ) { if ( err ) { throw err ; } if ( middleware [ index ] ) { middleware [ index + + ] ( instance , next ) ; } } ; next ( ) ; return instance ; } ; } else { descriptor . value = instance ; descriptor . writable = true ; } Object . define Property ( container , name , descriptor ) ; return container [ name ] ; } 
function middleware ( fullname , func ) { var parts , name ; if ( typeof fullname = = = FUNCTION _TYPE ) { func = fullname ; fullname = GLOBAL _NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { get Nested Bottle . call ( this , name ) . middleware ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . middlewares [ name ] ) { this . middlewares [ name ] = [ ] ; } this . middlewares [ name ] . push ( func ) ; } return this ; } 
function create Provider ( name , Provider ) { var provider Name , properties , container , id , decorators , middlewares ; id = this . id ; container = this . container ; decorators = this . decorators ; middlewares = this . middlewares ; provider Name = name + PROVIDER _SUFFIX ; properties = Object . create ( null ) ; properties [ provider Name ] = { configurable : true , enumerable : true , get : function get Provider ( ) { var instance = new Provider ( ) ; delete container [ provider Name ] ; container [ provider Name ] = instance ; return instance ; } } ; properties [ name ] = { configurable : true , enumerable : true , get : function get Service ( ) { var provider = container [ provider Name ] ; var instance ; if ( provider ) { 
function provider ( fullname , Provider ) { var parts , name ; parts = fullname . split ( DELIMITER ) ; if ( this . provider Map [ fullname ] & & parts . length = = = 1 & & ! this . container [ fullname + PROVIDER _SUFFIX ] ) { return console . error ( fullname + ' provider already instantiated . ' ) ; } this . original Providers [ fullname ] = Provider ; this . provider Map [ fullname ] = true ; name = parts . shift ( ) ; if ( parts . length ) { get Nested Bottle . call ( this , name ) . provider ( parts . join ( DELIMITER ) , Provider ) ; return this ; } return create Provider . call ( this , name , Provider ) ; } 
function create Service ( name , Service , is Class ) { var deps = arguments . length > 3 ? slice . call ( arguments , 3 ) : [ ] ; var bottle = this ; return factory . call ( this , name , function Generic Factory ( ) { var service Factory = Service ; 
function service ( name , Service ) { return create Service . apply ( this , [ name , Service , true ] . concat ( slice . call ( arguments , 2 ) ) ) ; } 
function service Factory ( name , factory Service ) { return create Service . apply ( this , [ name , factory Service , false ] . concat ( slice . call ( arguments , 2 ) ) ) ; } 
function define Value ( name , val ) { Object . define Property ( this , name , { configurable : true , enumerable : true , value : val , writable : true } ) ; } 
function set Value Object ( container , name ) { var nested Container = container [ name ] ; if ( ! nested Container ) { nested Container = { } ; define Value . call ( container , name , nested Container ) ; } return nested Container ; } 
function value ( name , val ) { var parts ; parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; define Value . call ( parts . reduce ( set Value Object , this . container ) , name , val ) ; return this ; } 
function constant ( name , value ) { var parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; define Constant . call ( parts . reduce ( set Value Object , this . container ) , name , value ) ; return this ; } 
function decorator ( fullname , func ) { var parts , name ; if ( typeof fullname = = = FUNCTION _TYPE ) { func = fullname ; fullname = GLOBAL _NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { get Nested Bottle . call ( this , name ) . decorator ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . decorators [ name ] ) { this . decorators [ name ] = [ ] ; } this . decorators [ name ] . push ( func ) ; } return this ; } 
function instance Factory ( name , Factory ) { return factory . call ( this , name , function Generic Instance Factory ( container ) { return { instance : Factory . bind ( Factory , container ) } ; } ) ; } 
function pop ( name ) { var instance ; if ( typeof name = = = STRING _TYPE ) { instance = bottles [ name ] ; if ( ! instance ) { bottles [ name ] = instance = new Bottle ( ) ; instance . constant ( 'BOTTLE _NAME ' , name ) ; } return instance ; } return new Bottle ( ) ; } 
function register ( Obj ) { var value = Obj . $value = = = undefined ? Obj : Obj . $value ; return this [ Obj . $type | | 'service ' ] . apply ( this , [ Obj . $name , value ] . concat ( Obj . $inject | | [ ] ) ) ; } 
function reset Providers ( names ) { var temp Providers = this . original Providers ; var should Filter = Array . is Array ( names ) ; Object . keys ( this . original Providers ) . for Each ( function reset Provider ( original Provider Name ) { if ( should Filter & & names . index Of ( original Provider Name ) = = = - 1 ) { return ; } var parts = original Provider Name . split ( DELIMITER ) ; if ( parts . length > 1 ) { parts . for Each ( remove Provider Map , get Nested Bottle . call ( this , parts [ 0 ] ) ) ; } remove Provider Map . call ( this , original Provider Name ) ; this . provider ( original Provider Name , temp Providers [ original Provider Name ] ) ; } , this ) ; } 
function determination Coefficient ( data , results ) { const predictions = [ ] ; const observations = [ ] ; data . for Each ( ( d , i ) = > { if ( d [ 1 ] ! = = null ) { observations . push ( d ) ; predictions . push ( results [ i ] ) ; } } ) ; const sum = observations . reduce ( ( a , observation ) = > a + observation [ 1 ] , 0 ) ; const mean = sum / observations . length ; const ssyy = observations . reduce ( ( a , observation ) = > { const difference = observation [ 1 ] - mean ; return a + ( difference * difference ) ; } , 0 ) ; const sse = observations . reduce ( ( accum , observation , index ) = > { const prediction = predictions [ index ] ; const residual = observation [ 1 ] - prediction [ 1 ] ; return accum + ( residual * residual ) ; } , 0 ) ; return 1 - ( sse / ssyy ) ; } 
function gaussian Elimination ( input , order ) { const matrix = input ; const n = input . length - 1 ; const coefficients = [ order ] ; for ( let i = 0 ; i < n ; i + + ) { let maxrow = i ; for ( let j = i + 1 ; j < n ; j + + ) { if ( Math . abs ( matrix [ i ] [ j ] ) > Math . abs ( matrix [ i ] [ maxrow ] ) ) { maxrow = j ; } } for ( let k = i ; k < n + 1 ; k + + ) { const tmp = matrix [ k ] [ i ] ; matrix [ k ] [ i ] = matrix [ k ] [ maxrow ] ; matrix [ k ] [ maxrow ] = tmp ; } for ( let j = i + 1 ; j < n ; j + + ) { for ( let k = n ; k > = i ; k - - ) { matrix [ k ] [ j ] - = ( matrix [ k ] [ i ] * matrix [ i ] [ j ] ) / matrix [ i ] [ i ] ; } } } for ( let j = n - 1 ; j > = 0 ; j - - ) { let total = 0 ; for ( let k = j + 1 ; k < n ; k + + ) { total + = matrix [ k ] [ j ] * coefficients [ k ] ; } coefficients [ j ] = ( matrix [ n ] [ j ] - total ) / matrix [ j ] [ j ] ; } return coefficients ; } 
function throw If Invalid Node ( node , function Name ) { if ( ! exports . is ASTNode ( node ) ) { throw new Error ( function Name + " ( ) : " + util . inspect ( node ) + " is not a valid AST node . " ) ; } } 
function create ( context ) { const events = [ ] , call Expressions = [ ] , source Code = context . get Source Code ( ) ; 
function is Event ( expr , event Declarations ) { for ( let { node , enclosing Contract } of event Declarations ) { if ( expr . callee . name = = = node . name & & source Code . is AChild Of ( expr , enclosing Contract ) ) { return true ; } } return false ; } 
function register Event Name ( emitted ) { const { node } = emitted ; ( ! emitted . exit ) & & events . push ( { node , enclosing Contract : source Code . get Parent ( node ) } ) ; } 
function inspect Variable Declarator ( emitted ) { let node = emitted . node ; if ( ! emitted . exit ) { all Variable Declarations [ node . id . name ] = node ; } } 
function inspect Program ( emitted ) { if ( emitted . exit ) { Object . keys ( all Variable Declarations ) . for Each ( function ( name ) { context . report ( { node : all Variable Declarations [ name ] , message : "Variable ' " + name + " ' is declared but never used . " } ) ; } ) ; } } 
function inspect Identifier ( emitted ) { if ( ! emitted . exit ) { let node = emitted . node , source Code = context . get Source Code ( ) ; if ( all Variable Declarations [ node . name ] & & source Code . get Parent ( node ) . type ! = = "Variable Declarator " ) { delete all Variable Declarations [ node . name ] ; } } } 
function inspect Functions Of Contract ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , { body } = node ; let cursor = 0 ; 
function inspect Modifier Declaration ( emitted ) { let node = emitted . node ; if ( emitted . exit ) { return ; } 
function inspect Call Expression ( emitted ) { let node = emitted . node , call Args = node . arguments ; if ( emitted . exit ) { return ; } let node Code = source Code . get Text ( node ) ; 
function inspect Program ( emitted ) { let node = emitted . node , body = node . body ; if ( ! emitted . exit | | missing Node On Top Error Reported ) { return ; } ( body . length > 0 ) & & ( body [ 0 ] . type ! = = "Pragma Statement " ) & & context . report ( { node : node , message : "No Pragma directive found at the top of file . " } ) ; } 
function inspect Experimental Pragma Statement ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , nodes Allowed Above = [ "Experimental Pragma Statement " , "Pragma Statement " ] , program Node = context . get Source Code ( ) . get Parent ( node ) ; for ( let child Node of program Node . body ) { 
function ( source Code , error Messages ) { let fixed Source Code = " " , fixes = [ ] , fixes Applied = [ ] , remaining Messages = [ ] ; let cursor = Number . NEGATIVE _INFINITY ; function attempt Fix ( fix ) { let start = fix . range [ 0 ] , end = fix . range [ 1 ] ; 
function get Indent Description ( indent Style , level ) { 
function inspect Program ( emitted ) { let node = emitted . node ; if ( emitted . exit ) { return ; } function inspect Program Child ( program Child ) { 
function inspect Top Level Declaration ( emitted ) { let body = emitted . node . body | | [ ] , level One Indent Reg Exp = new Reg Exp ( " ^ \ \n " + BASE _INDENTATION _STYLE + " $ " ) , ending Line Reg Exp = new Reg Exp ( " ^ " + BASE _INDENTATION _STYLE + " ( \ \S | \ \ * ) $ " ) , 
function inspect Block Statement ( emitted ) { let node = emitted . node ; * If the block item spans over multiple lines , make sure the ending line also follows the indent rule * An exception to this is the if -else statements when they don 't have Block Statement as their body * eg - * if (a ) * foo ( ) ; * else * bar ( ) ; * * Another exception is chaining . * eg - * function ( ) { * my Object * .func A ( ) * .func B ( ) * [ 0 ] ; * } * Ending line has 1 extra indentation but this is acceptable . * / if ( block Item . type ! = = "If Statement " & & source Code . get Line ( block Item ) ! = = ending Line Num & & ! ending Line Reg Exp . test ( source Code . get Text On Line ( ending Line Num ) ) ) { context . report ( { node : block Item , location : { line : ending Line Num , column : 0 } , message : ` $ { block Indent Desc } ` } ) ; } } current Indent = parent Declaration Line Text . slice ( 0 , parent Declaration Line Text . index Of ( parent Declaration Line Text . trim ( ) ) ) ; / /in case of no match , match ( ) returns null . Return [ ] instead to avoid crash current Indent Level = ( current Indent . match ( BASE _INDENTATION _STYLE _REGEXP _GLOBAL ) | | [ ] ) . length ; / /ensure that there is only whitespace of correct level before the block 's parent 's code if ( get Indent String ( BASE _INDENTATION _STYLE , current Indent Level ) ! = = current Indent ) { return ; / /exit now , we can ' proceed further unless this is fixed } 
function inspect Function Declaration ( emitted ) { let node = emitted . node , params = node . params | | [ ] ; let start Line = source Code . get Line ( node ) , last Arg Line = params . length ? source Code . get Ending Line ( params . slice ( - 1 ) [ 0 ] ) : start Line , function Declaration Line Text , current Indent , current Indent Level ; function inspect Param ( param Indent , param Indent Desc , param ) { let indent Reg Exp = new Reg Exp ( " ^ " + param Indent + " [ ^ \ \s ( \ / \ * ) ] " ) , param Line Text = source Code . get Text On Line ( source Code . get Line ( param ) ) ; 
function check Nodes ( nodes ) { if ( ! Array . is Array ( nodes ) ) { nodes = [ nodes ] ; } nodes . for Each ( node = > { let line Number = source Code . get Line ( node ) - 1 ; if ( line Number > last Line & & lines [ line Number ] . length > max Line Length ) { context . report ( { node , message : ` $ { max Line Length } ` } ) ; last Line = line Number ; } check Nodes ( node . body | | [ ] ) ; } ) ; } 
function ( node , before Count , after Count ) { let source Code Text = this . text ; if ( node ) { if ( ast Utils . is ASTNode ( node ) ) { return this . text . slice ( Math . max ( 0 , node . start - ( Math . abs ( before Count ) | | 0 ) ) , node . end + ( Math . abs ( after Count ) | | 0 ) ) ; } throw new Error ( "Invalid Node object " ) ; } return source Code Text ; } 
function ( prev Node , current Node ) { if ( prev Node & & ast Utils . is ASTNode ( prev Node ) & & current Node & & ast Utils . is ASTNode ( current Node ) & & prev Node . start < = current Node . start ) { return this . text . slice ( prev Node . end , current Node . start ) ; } throw new Error ( "Invalid argument for one or both nodes " ) ; } 
function ( line Number ) { 
function inspect Variable Declaration ( emitted ) { let node = emitted . node , code = source Code . get Text ( node ) ; if ( emitted . exit ) { return ; } 
function Rule Context ( rule Name , rule Desc , rule Meta , Solium ) { let context Object = this ; * wrapper around Solium .report ( ) which adds some additional information to the error object * @param {Object } error An object describing the lint error , sent by the rule currently running * / context Object . report = function ( error ) { if ( ! is Err Object Valid ( error ) ) { throw new Error ( ` $ { rule Name } $ { EOL } $ { util . inspect ( is Err Object Valid . errors ) } ` ) ; } Object . assign ( error , { rule Name : rule Name , rule Meta : rule Meta , type : context Object . meta . type } ) ; Solium . report ( error ) ; } ; } 
function resolve Upstream ( upstream ) { let core Ruleset Reg Exp = / ^solium : [a -z _ ] + $ / ; 
function resolve Plugin Config ( name , plugin ) { let config = { } ; Object . keys ( plugin . rules ) . for Each ( function ( rule Name ) { config [ name + " / " + rule Name ] = plugin . rules [ rule Name ] . meta . docs . type ; } ) ; return config ; } 
function load ( list Of Rules ) { let rule Defs = { } ; list Of Rules . for Each ( function ( name ) { 
function write Config File ( config ) { try { fs . write File Sync ( SOLIUMRC _FILENAME _ABSOLUTE , JSON . stringify ( config , null , 2 ) ) ; } catch ( e ) { error Reporter . report Fatal ( ` $ { SOLIUMRC _FILENAME _ABSOLUTE } $ { EOL } $ { e . message } ` ) ; process . exit ( error Codes . WRITE _FAILED ) ; } } 
function create Default Solium Ignore ( ) { try { fs . write File Sync ( SOLIUMIGNORE _FILENAME _ABSOLUTE , fs . read File Sync ( DEFAULT _SOLIUMIGNORE _PATH ) ) ; } catch ( e ) { error Reporter . report Fatal ( ` $ { SOLIUMIGNORE _FILENAME _ABSOLUTE } $ { EOL } $ { e . message } ` ) ; process . exit ( error Codes . WRITE _FAILED ) ; } } 
function lint String ( source Code , user Config , error Reporter , file Name ) { let lint Errors , fixes Applied ; try { if ( user Config . options . autofix | | user Config . options . autofix Dryrun ) { let result = solium . lint And Fix ( source Code , user Config ) ; lint Errors = result . error Messages ; if ( user Config . options . autofix ) { apply Fixes ( file Name , result ) ; fixes Applied = result . fixes Applied ; } else { error Reporter . report Diff ( file Name , source Code , result . fixed Source Code , result . fixes Applied . length ) ; } } else { lint Errors = solium . lint ( source Code , user Config ) ; } } catch ( e ) { 
function lint File ( file Name , user Config , error Reporter ) { let source Code ; try { source Code = fs . read File Sync ( file Name , "utf 8 " ) ; } catch ( e ) { error Reporter . report Fatal ( "Unable to read " + file Name + " : " + e . message ) ; process . exit ( error Codes . FILE _NOT _FOUND ) ; } return lint String ( source Code , user Config , error Reporter , file Name ) ; } 
function lint ( user Config , input , ignore , error Reporter ) { let files To Lint , error Count ; 
function create Cli Options ( cli Object ) { function collect ( val , memo ) { memo . push ( val ) ; return memo ; } cli Object . version ( ` $ { version } ` ) . description ( "Linter to find & fix style and security issues in Solidity smart contracts . " ) . usage ( " [options ] <keyword > " ) . option ( " -i , - -init " , "Create default rule configuration files " ) . option ( " -f , - -file [filepath : :String ] " , "Solidity file to lint " ) . option ( " -d , - -dir [dirpath : :String ] " , "Directory containing Solidity files to lint " ) . option ( " -R , - -reporter [name : :String ] " , "Format to report lint issues in (pretty | gcc ) " , "pretty " ) . option ( " -c , - -config [filepath : :String ] " , "Path to the .soliumrc configuration file " ) . option ( " - , - -stdin " , "Read input file from stdin " ) . option ( " - -fix " , "Fix Lint issues where possible " ) . option ( " - -fix -dry -run " , "Output fix diff without applying it " ) . option ( " - -debug " , "Display debug information " ) . option ( " - -watch " , "Watch for file changes " ) . option ( " - -hot " , " (Deprecated ) Same as - -watch " ) . option ( " - -no -soliumignore " , "Do not look for .soliumignore file " ) . option ( " - -no -soliumrc " , "Do not look for soliumrc configuration file " ) . option ( " - -rule [rule ] " , "Rule to execute . This overrides the specified rule 's configuration in soliumrc if present " , collect , [ ] ) . option ( " - -plugin [plugin ] " , "Plugin to execute . This overrides the specified plugin 's configuration in soliumrc if present " , collect , [ ] ) ; } 
function execute ( program Args ) { let user Config = { } , ignore , error Reporter ; create Cli Options ( cli ) ; program Args . length = = = 2 ? cli . help ( ) : cli . parse ( program Args ) ; if ( cli . init ) { return setup Default User Config ( ) ; } try { error Reporter = get Error Reporter ( cli . reporter ) ; } catch ( e ) { process . stderr . write ( ` $ { e . message } $ { EOL } ` ) ; process . exit ( error Codes . INVALID _PARAMS ) ; } if ( cli . soliumrc ) { const soliumrc Abs Path = cli . config ? ( path . is Absolute ( cli . config ) ? cli . config : path . join ( CWD , cli . config ) ) : SOLIUMRC _FILENAME _ABSOLUTE ; try { user Config = require ( soliumrc Abs Path ) ; } catch ( e ) { 
function ( options , list Items Schema ) { let validate Options List = Schema Validator . compile ( { type : "array " , min Items : list Items Schema . length , additional Items : false , items : list Items Schema } ) ; return validate Options List ( options ) ; } 
function inspect FD ( emitted ) { const { node } = emitted , visibility Modifiers = [ "public " , "external " , "internal " , "private " ] ; const modifiers = ( node . modifiers | | [ ] ) , first Visibility Modifier Index = modifiers . find Index ( m = > visibility Modifiers . includes ( m . name ) ) ; 
function inspect Function Declaration ( emitted ) { let node = emitted . node , params = node . params | | [ ] ; let start Line = source Code . get Line ( node ) , last Arg Line = params . length ? source Code . get Ending Line ( params . slice ( - 1 ) [ 0 ] ) : start Line ; if ( emitted . exit ) { return ; } if ( start Line = = = last Arg Line ) { if ( params . length > MAX _IN _SINGLE _LINE ) { context . report ( { node : node , message : "In case of more than " + MAX _IN _SINGLE _LINE + " parameters , drop each into its own line . " } ) ; } return ; } } 
function is Hex ( literal ) { let reg = / ^ [ 0 - 9a -f ] + $ / i ; 
function Soundfont ( ctx , name To Url ) { console . warn ( 'new Soundfont ( ) is deprected ' ) console . log ( 'Please use Soundfont .instrument ( ) instead of new Soundfont ( ) .instrument ( ) ' ) if ( ! ( this instanceof Soundfont ) ) return new Soundfont ( ctx ) this . name To Url = name To Url | | Soundfont . name To Url this . ctx = ctx this . instruments = { } this . promises = [ ] } 
function load Buffers ( ac , name , options ) { console . warn ( 'Soundfont .load Buffers is deprecate . ' ) console . log ( 'Use Soundfont .instrument ( . . ) and get buffers properties from the result . ' ) return Soundfont . instrument ( ac , name , options ) . then ( function ( inst ) { return inst . buffers } ) } 
function oscillator Player ( ctx , default Options ) { default Options = default Options | | { } return function ( note , time , duration , options ) { console . warn ( 'The oscillator player is deprecated . ' ) console . log ( 'Starting with version 0 . 9 . 0 you will have to wait until the soundfont is loaded to play sounds . ' ) var midi = note > 0 & & note < 1 2 9 ? + note : parser . midi ( note ) var freq = midi ? parser . midi To Freq ( midi , 4 4 0 ) : null if ( ! freq ) return duration = duration | | 0 . 2 options = options | | { } var destination = options . destination | | default Options . destination | | ctx . destination var vco Type = options . vco Type | | default Options . vco Type | | 'sine ' var gain = options . gain | | default Options . gain | | 0 . 4 var vco = ctx . create Oscillator ( ) vco . type = vco Type vco . frequency . value = freq var vca = ctx . create Gain ( ) vca . gain . value = gain vco . connect ( vca ) vca . connect ( destination ) vco . start ( time ) if ( duration > 0 ) vco . stop ( time + duration ) return vco } } 
function instrument ( ac , name , options ) { if ( arguments . length = = = 1 ) return function ( n , o ) { return instrument ( ac , n , o ) } var opts = options | | { } var is Url = opts . is Soundfont URL | | is Soundfont URL var to Url = opts . name To Url | | name To Url var url = is Url ( name ) ? name : to Url ( name , opts . soundfont , opts . format ) return load ( ac , url , { only : opts . only | | opts . notes } ) . then ( function ( buffers ) { var p = player ( ac , buffers , opts ) . connect ( opts . destination ? opts . destination : ac . destination ) p . url = url p . name = name return p } ) } 
function name To Url ( name , sf , format ) { format = format = = = 'ogg ' ? format : 'mp 3 ' sf = sf = = = 'Fluid R 3 _GM ' ? sf : 'Musyng Kite ' return 'https : / /gleitz .github .io /midi -js -soundfonts / ' + sf + ' / ' + name + ' - ' + format + ' .js ' } 
function has System Lib ( lib ) { var lib Name = 'lib ' + lib + ' . + (so |dylib ) ' var lib Name Regex = new Reg Exp ( lib Name ) 
function has Ldconfig ( ) { try { 
async function thenify ( fn ) { return await new Promise ( function ( resolve , reject ) { function callback ( err , res ) { if ( err ) return reject ( err ) ; return resolve ( res ) ; } fn ( callback ) ; } ) ; } 
function start Watching ( opts ) { var chokidar Opts = create Chokidar Opts ( opts ) ; var watcher = chokidar . watch ( opts . patterns , chokidar Opts ) ; var throttled Run = _ . throttle ( run , opts . throttle ) ; var debounced Run = _ . debounce ( throttled Run , opts . debounce ) ; watcher . on ( 'all ' , function ( event , path ) { var description = EVENT _DESCRIPTIONS [ event ] + ' : ' ; if ( opts . verbose ) { console . error ( description , path ) ; } else { if ( ! opts . silent ) { console . log ( event + ' : ' + path ) ; } } 
function _resolve Ignore Opt ( ignore Opt ) { if ( ! ignore Opt ) { return ignore Opt ; } var ignores = ! _ . is Array ( ignore Opt ) ? [ ignore Opt ] : ignore Opt ; return _ . map ( ignores , function ( ignore ) { var is Regex = ignore [ 0 ] = = = ' / ' & & ignore [ ignore . length - 1 ] = = = ' / ' ; if ( is Regex ) { 
function run ( cmd , opts ) { if ( ! SHELL _PATH ) { 
function require Prop ( props , prop Name , component Name ) { return is Empty ( props [ prop Name ] ) ? new Error ( ` \ ` $ { prop Name } \ ` \ ` $ { component Name } \ ` ` ) : null } 
function _ 0to 1 ( props , prop Name , component Name ) { if ( is Empty ( props [ prop Name ] ) ) { return null } if ( typeof props [ prop Name ] = = = 'number ' & & props [ prop Name ] > = 0 & & props [ prop Name ] < = 1 ) { return null } return new Error ( ` \ ` $ { prop Name } \ ` \ ` $ { component Name } \ ` ` ) } 
function babel ( options = { } ) { return ( context , { add Loader } ) = > add Loader ( { 
function extract Css ( ) { return ( context , { add Loader } ) = > add Loader ( { test : / \ .css $ / , use : [ { loader : Mini Css Extract Plugin . loader , } , ] , . . . context . match , } ) } 
function image Loader ( ) { return ( context , { add Loader } ) = > add Loader ( { test : / \ . (gif |ico |jpg |jpeg |png |webp ) $ / , loader : 'url -loader ' , options : { limit : 1 0 0 0 0 , name : file Name Template , } , } ) } 
function csv Loader ( ) { return ( context , { add Loader } ) = > add Loader ( { test : / \ .csv $ / , loader : 'csv -loader ' , options : { dynamic Typing : true , header : true , skip Empty Lines : true , } , } ) } 
function react Svg Loader ( ) { return ( context , { add Loader } ) = > add Loader ( { test : / \ .svg $ / , issuer : { test : / \ . (js |jsx |ts |tsx ) $ / , } , use : [ 
function css Svg Loader ( ) { return ( context , { add Loader } ) = > add Loader ( { 
function prepend Entry ( entry ) { const block Function = ( context , util ) = > { if ( ! context . entries To Prepend ) context . entries To Prepend = [ ] context . entries To Prepend . unshift ( entry ) return config = > config } return Object . assign ( block Function , { post : prepend Entry Post Hook , } ) } 
function build ( ) { log . info ( ` ` ) const compiler = create Webpack Compiler ( ( ) = > { log . ok ( ` $ { chalk . cyan ( relative App Build Path ) } ` ) } , ( ) = > { log . err ( ` ` ) process . exit ( 2 ) } ) return new Promise ( ( resolve , reject ) = > { compiler . run ( ( err , stats ) = > { if ( err ) { return reject ( err ) } return resolve ( stats ) } ) } ) } 
function create Webpack Compiler ( on First Ready Callback = ( ) = > { } , on Error = ( ) = > { } ) { let compiler try { const config = read Webpack Config ( ) compiler = webpack ( config ) } catch ( err ) { log . err ( ` \n $ { err . message | | err } ` ) process . exit ( 1 ) } const use Type Script = fs . exists Sync ( ` $ { app Dir } ` ) 
function merge Data ( to , from ) { if ( ! from ) { return to } var key , to Val , from Val ; var keys = Object . keys ( from ) ; for ( var i = 0 ; i < keys . length ; i + + ) { key = keys [ i ] ; to Val = to [ key ] ; from Val = from [ key ] ; if ( ! has Own ( to , key ) ) { set ( to , key , from Val ) ; } else if ( to Val ! = = from Val & & is Plain Object ( to Val ) & & is Plain Object ( from Val ) ) { merge Data ( to Val , from Val ) ; } } return to } 
function with Macro Task ( fn ) { return fn . _with Task | | ( fn . _with Task = function ( ) { use Macro Task = true ; try { return fn . apply ( null , arguments ) } finally { use Macro Task = false ; } } ) } 
function transform Node ( el , options ) { var warn = options . warn | | base Warn ; var static Class = get And Remove Attr ( el , 'class ' ) ; if ( static Class ) { var res = parse Text ( static Class , options . delimiters ) ; if ( res ) { warn ( "class = \ " " + static Class + " \ " : " + 'Interpolation inside attributes has been removed . ' + 'Use v -bind or the colon shorthand instead . For example , ' + 'instead of <div class = " { { val } } " > , use <div :class = "val " > . ' ) ; } } if ( static Class ) { el . static Class = JSON . stringify ( static Class ) ; } var class Binding = get Binding Attr ( el , 'class ' , false ) ; if ( class Binding ) { el . class Binding = class Binding ; } } 
function transform Node $ 1 ( el , options ) { var warn = options . warn | | base Warn ; var static Style = get And Remove Attr ( el , 'style ' ) ; if ( static Style ) { { var res = parse Text ( static Style , options . delimiters ) ; if ( res ) { warn ( "style = \ " " + static Style + " \ " : " + 'Interpolation inside attributes has been removed . ' + 'Use v -bind or the colon shorthand instead . For example , ' + 'instead of <div style = " { { val } } " > , use <div :style = "val " > . ' ) ; } } el . static Style = JSON . stringify ( parse Style Text ( static Style ) ) ; } var style Binding = get Binding Attr ( el , 'style ' , false ) ; if ( style Binding ) { el . style Binding = style Binding ; } } 
function is Plain Object ( value ) { if ( ! is Object Like _ 1 ( value ) | | _base Get Tag ( value ) ! = object Tag ) { return false ; } var proto = _get Prototype ( value ) ; if ( proto = = = null ) { return true ; } var Ctor = has Own Property $ 1 . call ( proto , 'constructor ' ) & & proto . constructor ; return typeof Ctor = = 'function ' & & Ctor instanceof Ctor & & func To String . call ( Ctor ) = = object Ctor String ; } 
function get Type ( fn ) { var type = fn ! = = null & & fn ! = = undefined ? fn . type ? fn . type : fn : null ; var match = type & & type . to String ( ) . match ( FN _MATCH _REGEXP ) ; return match & & match [ 1 ] ; } 
function with Default ( type ) { return Object . define Property ( type , 'def ' , { value : function value ( def ) { if ( def = = = undefined & & ! this . default ) { return this ; } if ( ! is Function ( def ) & & ! validate Type ( this , def ) ) { warn ( this . _vue Types _name + " - invalid default value : \ " " + def + " \ " " , def ) ; return this ; } if ( is Array ( def ) ) { this . default = function ( ) { return [ ] . concat ( def ) ; } ; } else if ( is Plain Object _ 1 ( def ) ) { this . default = function ( ) { return Object . assign ( { } , def ) ; } ; } else { this . default = def ; } return this ; } , enumerable : false , writable : false } ) ; } 
function with Required ( type ) { return Object . define Property ( type , 'is Required ' , { get : function get ( ) { this . required = true ; return this ; } , enumerable : false } ) ; } 
function with Validate ( type ) { return Object . define Property ( type , 'validate ' , { value : function value ( fn ) { this . validator = fn . bind ( this ) ; return this ; } , enumerable : false } ) ; } 
function to Type ( name , obj , validate Fn ) { if ( validate Fn = = = void 0 ) { validate Fn = false ; } Object . define Property ( obj , ' _vue Types _name ' , { enumerable : false , writable : false , value : name } ) ; with Default ( with Required ( obj ) ) ; if ( validate Fn ) { with Validate ( obj ) ; } if ( is Function ( obj . validator ) ) { obj . validator = obj . validator . bind ( obj ) ; } return obj ; } 
function validate Type ( type , value , silent ) { if ( silent = = = void 0 ) { silent = false ; } var type To Check = type ; var valid = true ; var expected Type ; if ( ! is Plain Object _ 1 ( type ) ) { type To Check = { type : type } ; } var name Prefix = type To Check . _vue Types _name ? type To Check . _vue Types _name + ' - ' : ' ' ; if ( has Own . call ( type To Check , 'type ' ) & & type To Check . type ! = = null ) { if ( is Array ( type To Check . type ) ) { valid = type To Check . type . some ( function ( type ) { return validate Type ( type , value , true ) ; } ) ; expected Type = type To Check . type . map ( function ( type ) { return get Type ( type ) ; } ) . join ( ' or ' ) ; } else { expected Type = get Type ( type To Check ) ; if ( expected Type = = = 'Array ' ) { valid = is Array ( value ) ; } else if ( expected Type = = = 'Object ' ) { valid = is Plain Object _ 1 ( value ) ; } else if ( expected Type = = = 'String ' | | expected Type = = = 'Number ' | | expected Type = = = 'Boolean ' | | expected Type = = = 'Function ' ) { valid = get Native Type ( value ) = = = expected Type ; } else { valid = value instanceof type To Check . type ; } } } if ( ! valid ) { silent = = = false & & warn ( name Prefix + "value \ " " + value + " \ " should be of type \ " " + expected Type + " \ " " ) ; return false ; } if ( has Own . call ( type To Check , 'validator ' ) & & is Function ( type To Check . validator ) ) { 
function Custom Event ( type , event Init Dict ) { var event = document . create Event ( event Name ) ; if ( typeof type ! = 'string ' ) { throw new Error ( 'An event name must be provided ' ) ; } if ( event Name = = 'Event ' ) { event . init Custom Event = init Custom Event ; } if ( event Init Dict = = null ) { event Init Dict = default Init Dict ; } event . init Custom Event ( type , event Init Dict . bubbles , event Init Dict . cancelable , event Init Dict . detail ) ; return event ; } 
function init Custom Event ( type , bubbles , cancelable , detail ) { this . init Event ( type , bubbles , cancelable ) ; this . detail = detail ; } 
function create Event Listener ( type , callback , options ) { function event Listener ( e ) { if ( event Listener . once ) { e . current Target . remove Event Listener ( e . type , callback , event Listener ) ; event Listener . removed = true ; } if ( event Listener . passive ) { e . prevent Default = create Event Listener . prevent Default ; } if ( typeof event Listener . callback = = = 'function ' ) { event Listener . callback . call ( this , e ) ; } else if ( event Listener . callback ) { event Listener . callback . handle Event ( e ) ; } if ( event Listener . passive ) { delete e . prevent Default ; } } event Listener . type = type ; event Listener . callback = callback ; event Listener . capture = ! ! options . capture ; event Listener . passive = ! ! options . passive ; event Listener . once = ! ! options . once ; 
function clean Up Runtime Events ( ) { 
function add Runtime Events ( ) { clean Up Runtime Events ( ) ; 
function normalize Event ( ev ) { if ( ev . type = = = 'touchmove ' | | ev . type = = = 'touchstart ' | | ev . type = = = 'touchend ' ) { var touch = ev . target Touches [ 0 ] | | ev . changed Touches [ 0 ] ; return { x : touch . client X , y : touch . client Y , id : touch . identifier } ; } else { 
function on Down ( ev ) { var event = normalize Event ( ev ) ; if ( ! pointer Active & & ! paused ) { pointer Active = true ; decelerating = false ; pointer Id = event . id ; pointer Last X = pointer Current X = event . x ; pointer Last Y = pointer Current Y = event . y ; tracking Points = [ ] ; add Tracking Point ( pointer Last X , pointer Last Y ) ; add Runtime Events ( ) ; } } 
function on Move ( ev ) { ev . prevent Default ( ) ; var event = normalize Event ( ev ) ; if ( pointer Active & & event . id = = = pointer Id ) { pointer Current X = event . x ; pointer Current Y = event . y ; add Tracking Point ( pointer Last X , pointer Last Y ) ; request Tick ( ) ; } } 
function on Up ( ev ) { var event = normalize Event ( ev ) ; if ( pointer Active & & event . id = = = pointer Id ) { stop Tracking ( ) ; } } 
function add Tracking Point ( x , y ) { var time = Date . now ( ) ; while ( tracking Points . length > 0 ) { if ( time - tracking Points [ 0 ] . time < = 1 0 0 ) { break ; } tracking Points . shift ( ) ; } tracking Points . push ( { x : x , y : y , time : time } ) ; } 
function update And Render ( ) { var pointer Change X = pointer Current X - pointer Last X ; var pointer Change Y = pointer Current Y - pointer Last Y ; target X + = pointer Change X * multiplier ; target Y + = pointer Change Y * multiplier ; if ( bounce ) { var diff = check Bounds ( ) ; if ( diff . x ! = = 0 ) { target X - = pointer Change X * drag Out Of Bounds Multiplier ( diff . x ) * multiplier ; } if ( diff . y ! = = 0 ) { target Y - = pointer Change Y * drag Out Of Bounds Multiplier ( diff . y ) * multiplier ; } } else { check Bounds ( true ) ; } call Update Callback ( ) ; pointer Last X = pointer Current X ; pointer Last Y = pointer Current Y ; ticking = false ; } 
function start Decel Anim ( ) { var first Point = tracking Points [ 0 ] ; var last Point = tracking Points [ tracking Points . length - 1 ] ; var x Offset = last Point . x - first Point . x ; var y Offset = last Point . y - first Point . y ; var time Offset = last Point . time - first Point . time ; var D = time Offset / 1 5 / multiplier ; dec Vel X = x Offset / D | | 0 ; 
function step Decel Anim ( ) { if ( ! decelerating ) { return ; } dec Vel X * = friction ; dec Vel Y * = friction ; target X + = dec Vel X ; target Y + = dec Vel Y ; var diff = check Bounds ( ) ; if ( Math . abs ( dec Vel X ) > stop Threshold | | Math . abs ( dec Vel Y ) > stop Threshold | | ! diff . in Bounds ) { if ( bounce ) { var rebound Adjust = 2 . 5 ; if ( diff . x ! = = 0 ) { if ( diff . x * dec Vel X < = 0 ) { dec Vel X + = diff . x * bounce Deceleration ; } else { var adjust = diff . x > 0 ? rebound Adjust : - rebound Adjust ; dec Vel X = ( diff . x + adjust ) * bounce Acceleration ; } } if ( diff . y ! = = 0 ) { if ( diff . y * dec Vel Y < = 0 ) { dec Vel Y + = diff . y * bounce Deceleration ; } else { var adjust = diff . y > 0 ? rebound Adjust : - rebound Adjust ; dec Vel Y = ( diff . y + adjust ) * bounce Acceleration ; } } } else { if ( diff . x ! = = 0 ) { if ( diff . x > 0 ) { target X = bound Xmin ; } else { target X = bound Xmax ; } dec Vel X = 0 ; } if ( diff . y ! = = 0 ) { if ( diff . y > 0 ) { target Y = bound Ymin ; } else { target Y = bound Ymax ; } dec Vel Y = 0 ; } } call Update Callback ( ) ; request Anim Frame ( step Decel Anim ) ; } else { decelerating = false ; } } 
function check Bounds ( restrict ) { var x Diff = 0 ; var y Diff = 0 ; if ( bound Xmin ! = = undefined & & target X < bound Xmin ) { x Diff = bound Xmin - target X ; } else if ( bound Xmax ! = = undefined & & target X > bound Xmax ) { x Diff = bound Xmax - target X ; } if ( bound Ymin ! = = undefined & & target Y < bound Ymin ) { y Diff = bound Ymin - target Y ; } else if ( bound Ymax ! = = undefined & & target Y > bound Ymax ) { y Diff = bound Ymax - target Y ; } if ( restrict ) { if ( x Diff ! = = 0 ) { target X = ( x Diff > 0 ) ? bound Xmin : bound Xmax ; } if ( y Diff ! = = 0 ) { target Y = ( y Diff > 0 ) ? bound Ymin : bound Ymax ; } } return { x : x Diff , y : y Diff , in Bounds : x Diff = = = 0 & & y Diff = = = 0 } ; } 
function values ( obj ) { var keys = Object . keys ( obj ) ; var length = keys . length ; var vals = new Array ( length ) ; for ( var i = 0 ; i < length ; i + + ) { vals [ i ] = obj [ keys [ i ] ] ; } return vals ; } 
function imgpath ( browser ) { var a = browser . options . desired Capabilities ; var meta = [ a . platform ] ; meta . push ( a . browser Name ? a . browser Name : 'any ' ) ; meta . push ( a . version ? a . version : 'any ' ) ; meta . push ( a . name ) ; 
function ( req , res , next ) { var file Path = req . original Url . replace ( ' /abe /editor ' , ' ' ) if ( file Path = = = ' ' | | file Path = = = ' / ' ) { file Path = null } if ( file Path ! = null & & path . extname ( file Path ) ! = ` $ { config . files . templates . extension } ` & & path . extname ( file Path ) ! = ' .json ' ) { next ( ) return } if ( file Path ! = null ) { var test XSS = xss ( file Path , { white List : [ ] , strip Ignore Tag : true } ) if ( test XSS ! = = file Path ) { file Path = test XSS } } abe Extend . hooks . instance . trigger ( 'before Route ' , req , res , next ) if ( typeof res . _header ! = = 'undefined ' & & res . _header ! = = null ) return var is Home = true var json Path = null var template = null var file Name = null var folder Path = null var Editor Variables = { user : res . user , slugs : Manager . instance . get Slugs ( ) , express : { res : res , req : req } , filename : file Name , folder Path : folder Path , abe Url : ' /abe /editor / ' , is Home : is Home , config : config , Locales : core Utils . locales . instance . i 1 8n , abe Version : pkg . version } let p = new Promise ( resolve = > { if ( file Path ! = null ) { file Name = path . basename ( file Path ) folder Path = path . dirname ( file Path ) Editor Variables . is Home = false Editor Variables . is Editor = true var file Path Test = cms Data . revision . get Document Revision ( file Path ) if ( typeof file Path Test ! = = 'undefined ' & & file Path Test ! = = null ) { json Path = file Path Test . path template = file Path Test . abe _meta . template } if ( json Path = = = null | | ! core Utils . file . exist ( json Path ) ) { res . redirect ( ' /abe /editor ' ) return } var json = { } if ( core Utils . file . exist ( json Path ) ) { json = cms Data . file . get ( json Path , 'utf 8 ' ) } var text = cms Templates . template . get Template ( template , json ) cms Editor . editor . create ( text , json ) . then ( result = > { resolve ( result ) } ) . catch ( function ( e ) { console . error ( e ) } ) } else { resolve ( { json : { } , manager : { } } ) } } ) . catch ( function ( e ) { console . error ( e ) 
function stringify ( obj , replacer , spaces , cycle Replacer ) { if ( typeof replacer ! = = 'function ' ) { replacer = null ; } return JSON . stringify ( obj , serializer ( replacer , cycle Replacer ) , spaces ) ; } 
function get IEVersion ( ) { var agent = navigator . user Agent var reg = / MSIE \s ? ( \d + ) ( ? : \ . ( \d + ) ) ? / i var matches = agent . match ( reg ) if ( matches ! = null ) { return { major : matches [ 1 ] , minor : matches [ 2 ] } } return { major : ' - 1 ' , minor : ' - 1 ' } } 
function init Comp Dirs ( ) { var comp Root = path . resolve ( process . cwd ( ) , 'src /components ' ) , comp Reg = / ^ [A -Z ] \w + $ / ; 
function append Log To File Stream ( file Name , new Log , header Line Count ) { const file Path = path . join ( _ _dirname , ' . . / . . / ' , file Name ) const old Changelog = grunt . file . read ( file Path ) . to String ( ) . split ( ' \n ' ) ; let w Str = fs . create Write Stream ( file Path ) let log Header = old Changelog . slice ( 0 , header Line Count ) ; let prev Logs = old Changelog . slice ( header Line Count ) ; var s = new Readable ; s . pipe ( w Str ) ; s . push ( log Header . join ( ' \n ' ) + ' \n ' ) ; s . push ( new Log ) ; s . push ( prev Logs . join ( ' \n ' ) ) ; s . push ( null ) ; 
function Inf Tree ( ) { var that = this ; var hn ; 
function Inf Codes ( ) { var that = this ; var mode ; 
function inflate _fast ( bl , bd , tl , tl _index , td , td _index , s , z ) { var t ; 
function Inflater ( ) { var that = this ; var z = new ZStream ( ) ; var bufsize = 5 1 2 ; var flush = Z _NO _FLUSH ; var buf = new Uint 8Array ( bufsize ) ; var nomoreinput = false ; z . inflate Init ( ) ; z . next _out = buf ; that . append = function ( data , onprogress ) { var err , buffers = [ ] , last Index = 0 , buffer Index = 0 , buffer Size = 0 , array ; if ( data . length = = = 0 ) return ; z . next _in _index = 0 ; z . next _in = data ; z . avail _in = data . length ; do { z . next _out _index = 0 ; z . avail _out = bufsize ; if ( ( z . avail _in = = = 0 ) & & ( ! nomoreinput ) ) { 
function launch Worker Process ( worker , initial Message , reader , writer , offset , size , onprogress , onend , onreaderror , onwriteerror ) { var chunk Index = 0 , index , output Size , sn = initial Message . sn , crc ; function onflush ( ) { worker . remove Event Listener ( 'message ' , onmessage , false ) ; onend ( output Size , crc ) ; } function onmessage ( event ) { var message = event . data , data = message . data , err = message . error ; if ( err ) { err . to String = function ( ) { return 'Error : ' + this . message ; } ; onreaderror ( err ) ; return ; } if ( message . sn ! = = sn ) return ; if ( typeof message . codec Time = = = 'number ' ) worker . codec Time + = message . codec Time ; 
function decode ASCII ( str ) { var i , out = " " , char Code , extended ASCII = [ ' \u 0 0C 7 ' , ' \u 0 0FC ' , ' \u 0 0E 9 ' , ' \u 0 0E 2 ' , ' \u 0 0E 4 ' , ' \u 0 0E 0 ' , ' \u 0 0E 5 ' , ' \u 0 0E 7 ' , ' \u 0 0EA ' , ' \u 0 0EB ' , ' \u 0 0E 8 ' , ' \u 0 0EF ' , ' \u 0 0EE ' , ' \u 0 0EC ' , ' \u 0 0C 4 ' , ' \u 0 0C 5 ' , ' \u 0 0C 9 ' , ' \u 0 0E 6 ' , ' \u 0 0C 6 ' , ' \u 0 0F 4 ' , ' \u 0 0F 6 ' , ' \u 0 0F 2 ' , ' \u 0 0FB ' , ' \u 0 0F 9 ' , ' \u 0 0FF ' , ' \u 0 0D 6 ' , ' \u 0 0DC ' , ' \u 0 0F 8 ' , ' \u 0 0A 3 ' , ' \u 0 0D 8 ' , ' \u 0 0D 7 ' , ' \u 0 1 9 2 ' , ' \u 0 0E 1 ' , ' \u 0 0ED ' , ' \u 0 0F 3 ' , ' \u 0 0FA ' , ' \u 0 0F 1 ' , ' \u 0 0D 1 ' , ' \u 0 0AA ' , ' \u 0 0BA ' , ' \u 0 0BF ' , ' \u 0 0AE ' , ' \u 0 0AC ' , ' \u 0 0BD ' , ' \u 0 0BC ' , ' \u 0 0A 1 ' , ' \u 0 0AB ' , ' \u 0 0BB ' , ' _ ' , ' _ ' , ' _ ' , ' \u 0 0A 6 ' , ' \u 0 0A 6 ' , ' \u 0 0C 1 ' , ' \u 0 0C 2 ' , ' \u 0 0C 0 ' , ' \u 0 0A 9 ' , ' \u 0 0A 6 ' , ' \u 0 0A 6 ' , ' + ' , ' + ' , ' \u 0 0A 2 ' , ' \u 0 0A 5 ' , ' + ' , ' + ' , ' - ' , ' - ' , ' + ' , ' - ' , ' + ' , ' \u 0 0E 3 ' , ' \u 0 0C 3 ' , ' + ' , ' + ' , ' - ' , ' - ' , ' \u 0 0A 6 ' , ' - ' , ' + ' , ' \u 0 0A 4 ' , ' \u 0 0F 0 ' , ' \u 0 0D 0 ' , ' \u 0 0CA ' , ' \u 0 0CB ' , ' \u 0 0C 8 ' , 'i ' , ' \u 0 0CD ' , ' \u 0 0CE ' , ' \u 0 0CF ' , ' + ' , ' + ' , ' _ ' , ' _ ' , ' \u 0 0A 6 ' , ' \u 0 0CC ' , ' _ ' , ' \u 0 0D 3 ' , ' \u 0 0DF ' , ' \u 0 0D 4 ' , ' \u 0 0D 2 ' , ' \u 0 0F 5 ' , ' \u 0 0D 5 ' , ' \u 0 0B 5 ' , ' \u 0 0FE ' , ' \u 0 0DE ' , ' \u 0 0DA ' , ' \u 0 0DB ' , ' \u 0 0D 9 ' , ' \u 0 0FD ' , ' \u 0 0DD ' , ' \u 0 0AF ' , ' \u 0 0B 4 ' , ' \u 0 0AD ' , ' \u 0 0B 1 ' , ' _ ' , ' \u 0 0BE ' , ' \u 0 0B 6 ' , ' \u 0 0A 7 ' , ' \u 0 0F 7 ' , ' \u 0 0B 8 ' , ' \u 0 0B 0 ' , ' \u 0 0A 8 ' , ' \u 0 0B 7 ' , ' \u 0 0B 9 ' , ' \u 0 0B 3 ' , ' \u 0 0B 2 ' , ' _ ' , ' ' ] ; for ( i = 0 ; i < str . length ; i + + ) { char Code = str . char Code At ( i ) & 0x FF ; if ( char Code > 1 2 7 ) out + = extended ASCII [ char Code - 1 2 8 ] ; else out + = String . from Char Code ( char Code ) ; } return out ; } 
function do Seek ( length , eocdr Not Found Callback ) { reader . read Uint 8Array ( reader . size - length , length , function ( bytes ) { for ( var i = bytes . length - EOCDR _MIN ; i > = 0 ; i - - ) { if ( bytes [ i ] = = = 0x 5 0 & & bytes [ i + 1 ] = = = 0x 4b & & bytes [ i + 2 ] = = = 0x 0 5 & & bytes [ i + 3 ] = = = 0x 0 6 ) { eocdr Callback ( new Data View ( bytes . buffer , i , EOCDR _MIN ) ) ; return ; } } eocdr Not Found Callback ( ) ; } , function ( ) { onerror ( ERR _READ ) ; } ) ; } 
function Card Js ( elem ) { this . elem = j Query ( elem ) ; this . capture Name = this . elem . data ( "capture -name " ) ? this . elem . data ( "capture -name " ) : false ; this . icon Colour = this . elem . data ( "icon -colour " ) ? this . elem . data ( "icon -colour " ) : false ; this . stripe = this . elem . data ( "stripe " ) ? this . elem . data ( "stripe " ) : false ; if ( this . stripe ) { this . capture Name = false ; } 
function ( err , in Data ) { 
function DBGet Row Array Native ( cursor ) { 
function DBGet Row Array String ( cursor ) { 
function DBGet Row Object String ( cursor ) { 
function Database ( dbname , options , callback ) { if ( ! this instanceof Database ) { 
function to Char Ptr ( str ) { const objc Str = NSString . string With String ( str ) ; const buffer Size = strlen ( objc Str . UTF 8String ) + 1 ; const buffer = interop . alloc ( buffer Size ) ; objc Str . get CString Max Length Encoding ( buffer , buffer Size , NSUTF 8String Encoding ) ; return buffer ; } 
function Cursor Statement ( statement , result Type , values Type ) { this . statement = statement ; this . result Type = result Type ; this . values Type = values Type ; this . built = false ; this . columns = [ ] ; } 
function Database ( dbname , options , callback ) { if ( ! this instanceof Database ) { 
function Cron Job ( sandbox , job ) { assign ( this , job ) ; if ( job . token ) { this . claims = Decode ( job . token ) ; } else { this . claims = { jtn : job . name , ten : this . container , } ; } this . sandbox = sandbox ; Object . define Property ( this , 'url ' , { enumerable : true , get : function ( ) { return this . sandbox . url + ' /api /run / ' + this . container + ' / ' + this . name ; } } ) ; } 
function Sandbox ( options ) { var security Version = 'v 1 ' ; this . url = options . url ; this . container = options . container ; this . token = options . token ; this . on Before Request = [ ] . concat ( options . on Before Request ) . filter ( hook = > typeof hook = = = 'function ' ) ; try { var typ = Decode ( options . token , { header : true } ) . typ ; if ( typ & & typ . to Lower Case ( ) = = = 'jwt ' ) { security Version = 'v 2 ' ; } } catch ( _ ) { 
function Webtask ( sandbox , token , options ) { if ( ! options ) options = { } ; if ( sandbox . security Version = = = 'v 1 ' ) { try { this . claims = Decode ( token ) ; this . token = token ; } catch ( _ ) { throw new Error ( 'token must be a valid JWT ' ) ; } } if ( sandbox . security Version = = = 'v 2 ' ) { if ( typeof options . name ! = = 'string ' ) { throw new Error ( 'name must be a valid string ' ) ; } this . claims = { jtn : options . name , ten : options . container | | sandbox . container , } } this . sandbox = sandbox ; this . meta = options . meta | | { } ; this . secrets = options . secrets ; this . code = options . code ; Object . define Property ( this , 'container ' , { enumerable : true , get : function ( ) { return options . container | | this . sandbox . container ; } } ) ; Object . define Property ( this , 'url ' , { enumerable : true , get : function ( ) { var url = options . webtask _url ; if ( ! url ) { if ( this . claims . host ) { var surl = Url . parse ( this . sandbox . url ) ; url = surl . protocol + ' / / ' + this . claims . host + ( surl . port ? ( ' : ' + surl . port ) : ' ' ) + ' / ' + this . sandbox . container ; } else { url = this . sandbox . url + ' /api /run / ' + this . sandbox . container ; } if ( this . claims . jtn ) url + = ' / ' + this . claims . jtn ; else url + = ' ?key = ' + this . token ; } return url ; } } ) ; } 
function Cc Znp ( ) { Event Emitter . call ( this ) ; var self = this ; this . MT = MT ; 
function Zpi Object ( subsys , cmd , args ) { 
function wrapped Promise ( executor ) { if ( ! ( this instanceof wrapped Promise ) ) { return Promise ( executor ) ; } if ( typeof executor ! = = 'function ' ) { return new Promise ( executor ) ; } var context , args ; var promise = new Promise ( wrapped Executor ) ; promise . _ _proto _ _ = wrapped Promise . prototype ; try { executor . apply ( context , args ) ; } catch ( err ) { args [ 1 ] ( err ) ; } return promise ; function wrapped Executor ( resolve , reject ) { context = this ; args = [ wrapped Resolve , wrapped Reject ] ; 
function bind ( fn ) { if ( typeof fn ! = = 'function ' ) return fn ; return wrap Callback ( function ( val ) { var result = ( promise . _ _asl _wrapper | | propagate Asl Wrapper ) ( this , fn , val , next ) ; if ( result . error ) { throw result . error Val } else { return result . return Val } } ) ; } 
function union ( dest , added ) { var dest Length = dest . length ; var added Length = added . length ; var returned = [ ] ; if ( dest Length = = = 0 & & added Length = = = 0 ) return returned ; for ( var j = 0 ; j < dest Length ; j + + ) returned [ j ] = dest [ j ] ; if ( added Length = = = 0 ) return returned ; for ( var i = 0 ; i < added Length ; i + + ) { var missing = true ; for ( j = 0 ; j < dest Length ; j + + ) { if ( dest [ j ] . uid = = = added [ i ] . uid ) { missing = false ; break ; } } if ( missing ) returned . push ( added [ i ] ) ; } return returned ; } 
function simple Wrap ( original , list , length ) { in Async Tick = true ; for ( var i = 0 ; i < length ; + + i ) { var listener = list [ i ] ; if ( listener . create ) listener . create ( listener . data ) ; } in Async Tick = false ; 
function wrap Callback ( original ) { var length = listeners . length ; 
function ( dir , options , internal ) { 
function make Async Func ( config ) { 
function make Async Iterator ( body Func , config , semaphore ) { 
function ( expr ) { 
function make Async Non Iterator ( body Func , config , semaphore ) { 
function make Func With Arity ( fn , arity ) { 
function run In Fiber ( run Ctx ) { try { try Block ( run Ctx ) ; } catch ( err ) { catch Block ( run Ctx , err ) ; } finally { finally Block ( run Ctx ) ; } } 
function adjust Fiber Count ( delta ) { active Fiber Count + = delta ; if ( active Fiber Count > = fiber Pool Size ) { fiber Pool Size + = 1 0 0 ; Fiber . pool Size = fiber Pool Size ; } } 
function make Await Func ( variant ) { 
function get Extra Info ( traverse , top N ) { return function await ( ) { 
function traverse In Place ( o , visitor ) { if ( _ . is Array ( o ) ) { var len = o . length ; for ( var i = 0 ; i < len ; + + i ) { traverse In Place ( o [ i ] , visitor ) ; visitor ( o , i ) ; } } else if ( _ . is Plain Object ( o ) ) { for ( var key in o ) { if ( ! o . has Own Property ( key ) ) continue ; traverse In Place ( o [ key ] , visitor ) ; visitor ( o , key ) ; } } return o ; } 
function traverse Clone ( o , visitor ) { var result ; if ( _ . is Array ( o ) ) { var len = o . length ; result = new Array ( len ) ; for ( var i = 0 ; i < len ; + + i ) { result [ i ] = traverse Clone ( o [ i ] , visitor ) ; visitor ( result , i ) ; } } else if ( _ . is Plain Object ( o ) ) { result = { } ; for ( var key in o ) { if ( o . has Own Property ( key ) ) { result [ key ] = traverse Clone ( o [ key ] , visitor ) ; visitor ( result , key ) ; } } } else { result = o ; } return result ; } 
function thunk To Promise ( thunk ) { return new Promise ( function ( resolve , reject ) { var callback = function ( err , val ) { return ( err ? reject ( err ) : resolve ( val ) ) ; } ; thunk ( callback ) ; } ) ; } 
function ( dir ) { var files = fs . readdir Sync ( dir ) ; 
function request Done ( method , where , cb ) { return function ( er , response , data ) { if ( er ) return cb ( er ) var url Obj = url . parse ( where ) if ( url Obj . auth ) url Obj . auth = ' * * * ' this . log . http ( response . status Code , url . format ( url Obj ) ) if ( Buffer . is Buffer ( data ) ) { data = data . to String ( ) } var parsed if ( data & & typeof data = = = 'string ' & & response . status Code ! = = 3 0 4 ) { try { parsed = JSON . parse ( data ) } catch ( ex ) { ex . message + = ' \n ' + data this . log . verbose ( 'bad json ' , data ) this . log . error ( 'registry ' , 'error parsing json ' ) return cb ( ex , null , data , response ) } } else if ( data ) { parsed = data data = JSON . stringify ( parsed ) } 
function get ( uri , params , cb ) { assert ( typeof uri = = = 'string ' , 'must pass registry URI to get ' ) assert ( params & & typeof params = = = 'object ' , 'must pass params to get ' ) assert ( typeof cb = = = 'function ' , 'must pass callback to get ' ) var parsed = url . parse ( uri ) assert ( parsed . protocol = = = 'http : ' | | parsed . protocol = = = 'https : ' , 'must have a URL that starts with http : or https : ' ) this . request ( uri , params , cb ) } 
async function scoped Copy Index ( client , source Index , target Index ) { const { task ID } = await client . copy Index ( source Index . index Name , target Index . index Name , [ 'settings ' , 'synonyms ' , 'rules ' ] ) ; return target Index . wait Task ( task ID ) ; } 
async function move Index ( client , source Index , target Index ) { const { task ID } = await client . move Index ( source Index . index Name , target Index . index Name ) ; return target Index . wait Task ( task ID ) ; } 
async function index Exists ( index ) { try { const { nb Hits } = await index . search ( ) ; return nb Hits > 0 ; } catch ( e ) { return false ; } } 
function set Status ( activity , status ) { if ( activity & & activity . set Status ) { activity . set Status ( status ) ; } else { console . log ( 'Algolia : ' , status ) ; } } 
function load Module ( module Name ) { var module = modules [ module Name ] ; if ( module ! = = undefined ) { return module ; } 
function parse Accept Language ( accept ) { var accepts = accept . split ( ' , ' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i + + ) { var language = parse Language ( accepts [ i ] . trim ( ) , i ) ; if ( language ) { accepts [ j + + ] = language ; } } 
function parse Language ( str , i ) { var match = simple Language Reg Exp . exec ( str ) ; if ( ! match ) return null ; var prefix = match [ 1 ] , suffix = match [ 2 ] , full = prefix ; if ( suffix ) full + = " - " + suffix ; var q = 1 ; if ( match [ 3 ] ) { var params = match [ 3 ] . split ( ' ; ' ) for ( var j = 0 ; j < params . length ; j + + ) { var p = params [ j ] . split ( ' = ' ) ; if ( p [ 0 ] = = = 'q ' ) q = parse Float ( p [ 1 ] ) ; } } return { prefix : prefix , suffix : suffix , q : q , i : i , full : full } ; } 
function get Language Priority ( language , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i + + ) { var spec = specify ( language , accepted [ i ] , index ) ; if ( spec & & ( priority . s - spec . s | | priority . q - spec . q | | priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( language , spec , index ) { var p = parse Language ( language ) if ( ! p ) return null ; var s = 0 ; if ( spec . full . to Lower Case ( ) = = = p . full . to Lower Case ( ) ) { s | = 4 ; } else if ( spec . prefix . to Lower Case ( ) = = = p . full . to Lower Case ( ) ) { s | = 2 ; } else if ( spec . full . to Lower Case ( ) = = = p . prefix . to Lower Case ( ) ) { s | = 1 ; } else if ( spec . full ! = = ' * ' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } } 
function preferred Languages ( accept , provided ) { 
function compare Specs ( a , b ) { return ( b . q - a . q ) | | ( b . s - a . s ) | | ( a . o - b . o ) | | ( a . i - b . i ) | | 0 ; } 
function parse Accept Charset ( accept ) { var accepts = accept . split ( ' , ' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i + + ) { var charset = parse Charset ( accepts [ i ] . trim ( ) , i ) ; if ( charset ) { accepts [ j + + ] = charset ; } } 
function parse Charset ( str , i ) { var match = simple Charset Reg Exp . exec ( str ) ; if ( ! match ) return null ; var charset = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ' ; ' ) for ( var j = 0 ; j < params . length ; j + + ) { var p = params [ j ] . trim ( ) . split ( ' = ' ) ; if ( p [ 0 ] = = = 'q ' ) { q = parse Float ( p [ 1 ] ) ; break ; } } } return { charset : charset , q : q , i : i } ; } 
function get Charset Priority ( charset , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i + + ) { var spec = specify ( charset , accepted [ i ] , index ) ; if ( spec & & ( priority . s - spec . s | | priority . q - spec . q | | priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( charset , spec , index ) { var s = 0 ; if ( spec . charset . to Lower Case ( ) = = = charset . to Lower Case ( ) ) { s | = 1 ; } else if ( spec . charset ! = = ' * ' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } } 
function preferred Charsets ( accept , provided ) { 
function parse Encoding ( str , i ) { var match = simple Encoding Reg Exp . exec ( str ) ; if ( ! match ) return null ; var encoding = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ' ; ' ) ; for ( var j = 0 ; j < params . length ; j + + ) { var p = params [ j ] . trim ( ) . split ( ' = ' ) ; if ( p [ 0 ] = = = 'q ' ) { q = parse Float ( p [ 1 ] ) ; break ; } } } return { encoding : encoding , q : q , i : i } ; } 
function get Encoding Priority ( encoding , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i + + ) { var spec = specify ( encoding , accepted [ i ] , index ) ; if ( spec & & ( priority . s - spec . s | | priority . q - spec . q | | priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function preferred Encodings ( accept , provided ) { var accepts = parse Accept Encoding ( accept | | ' ' ) ; if ( ! provided ) { 
function parse Accept ( accept ) { var accepts = split Media Types ( accept ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i + + ) { var media Type = parse Media Type ( accepts [ i ] . trim ( ) , i ) ; if ( media Type ) { accepts [ j + + ] = media Type ; } } 
function parse Media Type ( str , i ) { var match = simple Media Type Reg Exp . exec ( str ) ; if ( ! match ) return null ; var params = Object . create ( null ) ; var q = 1 ; var subtype = match [ 2 ] ; var type = match [ 1 ] ; if ( match [ 3 ] ) { var kvps = split Parameters ( match [ 3 ] ) . map ( split Key Value Pair ) ; for ( var j = 0 ; j < kvps . length ; j + + ) { var pair = kvps [ j ] ; var key = pair [ 0 ] . to Lower Case ( ) ; var val = pair [ 1 ] ; 
function get Media Type Priority ( type , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i + + ) { var spec = specify ( type , accepted [ i ] , index ) ; if ( spec & & ( priority . s - spec . s | | priority . q - spec . q | | priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( type , spec , index ) { var p = parse Media Type ( type ) ; var s = 0 ; if ( ! p ) { return null ; } if ( spec . type . to Lower Case ( ) = = p . type . to Lower Case ( ) ) { s | = 4 } else if ( spec . type ! = ' * ' ) { return null ; } if ( spec . subtype . to Lower Case ( ) = = p . subtype . to Lower Case ( ) ) { s | = 2 } else if ( spec . subtype ! = ' * ' ) { return null ; } var keys = Object . keys ( spec . params ) ; if ( keys . length > 0 ) { if ( keys . every ( function ( k ) { return spec . params [ k ] = = ' * ' | | ( spec . params [ k ] | | ' ' ) . to Lower Case ( ) = = ( p . params [ k ] | | ' ' ) . to Lower Case ( ) ; } ) ) { s | = 1 } else { return null } } return { i : index , o : spec . i , q : spec . q , s : s , } } 
function preferred Media Types ( accept , provided ) { 
function quote Count ( string ) { var count = 0 ; var index = 0 ; while ( ( index = string . index Of ( ' " ' , index ) ) ! = = - 1 ) { count + + ; index + + ; } return count ; } 
function split Key Value Pair ( str ) { var index = str . index Of ( ' = ' ) ; var key ; var val ; if ( index = = = - 1 ) { key = str ; } else { key = str . substr ( 0 , index ) ; val = str . substr ( index + 1 ) ; } return [ key , val ] ; } 
function split Media Types ( accept ) { var accepts = accept . split ( ' , ' ) ; for ( var i = 1 , j = 0 ; i < accepts . length ; i + + ) { if ( quote Count ( accepts [ j ] ) % 2 = = 0 ) { accepts [ + + j ] = accepts [ i ] ; } else { accepts [ j ] + = ' , ' + accepts [ i ] ; } } 
function split Parameters ( str ) { var parameters = str . split ( ' ; ' ) ; for ( var i = 1 , j = 0 ; i < parameters . length ; i + + ) { if ( quote Count ( parameters [ j ] ) % 2 = = 0 ) { parameters [ + + j ] = parameters [ i ] ; } else { parameters [ j ] + = ' ; ' + parameters [ i ] ; } } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version ' ) . use ( Version ) , this . key ( 'private Key Algorithm ' ) . use ( Algorithm Identifier ) , this . key ( 'private Key ' ) . octstr ( ) , this . key ( 'attributes ' ) . optional ( ) . any ( ) ) ; } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version ' ) . use ( Version ) , this . key ( 'private Key ' ) . octstr ( ) , this . key ( 'parameters ' ) . explicit ( 0 ) . optional ( ) . any ( ) , this . key ( 'public Key ' ) . explicit ( 1 ) . optional ( ) . bitstr ( ) ) ; } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version ' ) . use ( Version ) , this . key ( 'modulus ' ) . int ( ) , this . key ( 'public Exponent ' ) . int ( ) , this . key ( 'private Exponent ' ) . int ( ) , this . key ( 'prime 1 ' ) . int ( ) , this . key ( 'prime 2 ' ) . int ( ) , this . key ( 'exponent 1 ' ) . int ( ) , this . key ( 'exponent 2 ' ) . int ( ) , this . key ( 'coefficient ' ) . int ( ) ) ; } 
function Module ( process , name , path , base , size ) { 
function Hash ( data ) { 
function ( details ) { console . warn ( m Colors . yellow . bold ( "WARNING : robot -js precompiled binaries could " + "not be downloaded , an attempt to compile them " + " manually will be made . For more information , " + " please visit http : / /getrobot .net /docs /node .html . " + " Details : " + details ) ) ; try { 
function ( details ) { console . error ( m Colors . red . bold ( "ERROR : robot -js precompiled binaries could not " + "be verified . This could be a result of a man -in " + " -the -middle attack . If you want to continue " + "anyway , use the following command to disable " + " verification : 'npm config set robot -js :verify " + "false ' . Details : " + details ) ) ; try { 
function ( url , success , failure ) { 
function Size ( aw , ah ) { 
function Screen ( bounds , usable ) { 
function Region ( ) { 
function load Webpack Config ( ) { var webpack Config = require ( ' . /webpack .config .js ' ) ; webpack Config . devtool = 'inline -source -map ' ; webpack Config . module . pre Loaders = [ { test : / \ .jsx ? $ / , include : path . resolve ( 'lib ' ) , loader : 'isparta ' } ] ; return webpack Config ; } 
function assign ( obj , key Path , value ) { const last Key Index = key Path . length - 1 for ( let i = 0 ; i < last Key Index ; + + i ) { const key = key Path [ i ] if ( ! ( key in obj ) ) obj [ key ] = { } obj = obj [ key ] } obj [ key Path [ last Key Index ] ] = value } 
function get Filter String ( selected Values ) { if ( selected Values & & Object . keys ( selected Values ) . length ) { return Object 
function evaluate Page ( page , fn ) { var args = Array . prototype . slice . call ( arguments , 2 ) ; return this . ready . then ( function ( ) { var stack ; page = page | | this . page ; var res = Horseman Promise . from Callback ( function ( done ) { 
function wait For Page ( page , opts Or Fn ) { var self = this ; var args , value , fname , timeout = self . options . timeout , fn ; if ( typeof opts Or Fn = = = "function " ) { fn = opts Or Fn ; args = Array . prototype . slice . call ( arguments ) ; value = args . pop ( ) ; fname = fn . name | | ' <anonymous > ' ; } else if ( typeof opts Or Fn = = = "object " ) { fn = opts Or Fn . fn ; args = [ page , fn ] . concat ( opts Or Fn . args | | [ ] ) ; value = opts Or Fn . value ; fname = fn . name | | ' <anonymous > ' ; if ( opts Or Fn . timeout ) { timeout = opts Or Fn . timeout ; } } debug . apply ( debug , [ ' .wait For ( ) ' , fname ] . concat ( args . slice ( 2 ) ) ) ; return this . ready . then ( function ( ) { return new Horseman Promise ( function ( resolve , reject ) { var start = Date . now ( ) ; var check Interval = set Interval ( function wait For Check ( ) { var _page = page | | self . page ; var diff = Date . now ( ) - start ; if ( diff > timeout ) { clear Interval ( check Interval ) ; debug ( ' .wait For ( ) timed out ' ) ; if ( typeof _page . on Timeout = = = 'function ' ) { _page . on Timeout ( 'wait For ' ) ; } reject ( new Timeout Error ( 'timeout during .wait For ( ) after ' + diff + ' ms ' ) ) ; } else { return evaluate Page . apply ( self , args ) . tap ( function ( res ) { debugv ( ' .wait For ( ) iteration ' , fname , res , diff , self . id ) ; } ) . then ( function ( res ) { if ( res = = = value ) { debug ( ' .wait For ( ) completed successfully ' ) ; clear Interval ( check Interval ) ; resolve ( ) ; } } ) . catch ( function ( err ) { clear Interval ( check Interval ) ; reject ( err ) ; } ) ; } } , self . options . interval ) ; } ) ; } ) ; } 
function Horseman ( options ) { this . ready = false ; if ( ! ( this instanceof Horseman ) ) { return new Horseman ( options ) ; } this . options = defaults ( clone ( options ) | | { } , DEFAULTS ) ; this . id = + + instance Id ; debug ( ' .setup ( ) creating phantom instance %s ' , this . id ) ; var phantom Options = { 'load -images ' : this . options . load Images , 'ssl -protocol ' : this . options . ssl Protocol } ; if ( typeof this . options . ignore SSLErrors ! = = 'undefined ' ) { phantom Options [ 'ignore -ssl -errors ' ] = this . options . ignore SSLErrors ; } if ( typeof this . options . web Security ! = = 'undefined ' ) { phantom Options [ 'web -security ' ] = this . options . web Security ; } if ( typeof this . options . proxy ! = = 'undefined ' ) { phantom Options . proxy = this . options . proxy ; } if ( typeof this . options . proxy Type ! = = 'undefined ' ) { phantom Options [ 'proxy -type ' ] = this . options . proxy Type ; } if ( typeof this . options . proxy Auth ! = = 'undefined ' ) { phantom Options [ 'proxy -auth ' ] = this . options . proxy Auth ; } if ( typeof this . options . disk Cache ! = = 'undefined ' ) { phantom Options [ 'disk -cache ' ] = this . options . disk Cache ; } if ( typeof this . options . disk Cache Path ! = = 'undefined ' ) { phantom Options [ 'disk -cache -path ' ] = this . options . disk Cache Path ; } if ( typeof this . options . cookies File ! = = 'undefined ' ) { phantom Options [ 'cookies -file ' ] = this . options . cookies File ; } if ( this . options . debug Port ) { phantom Options [ 'remote -debugger -port ' ] = this . options . debug Port ; phantom Options [ 'remote -debugger -autorun ' ] = 'no ' ; if ( this . options . debug Autorun ! = = false ) { phantom Options [ 'remote -debugger -autorun ' ] = 'yes ' ; } } Object . keys ( this . options . phantom Options | | { } ) . for Each ( function ( key ) { if ( typeof phantom Options [ key ] ! = = 'undefined ' ) { debug ( 'Horseman option ' + key + ' overridden by phantom Options ' ) ; } phantom Options [ key ] = this . options . phantom Options [ key ] ; } . bind ( this ) ) ; var instantiation Options = { parameters : phantom Options } ; if ( typeof this . options . phantom Path ! = = 'undefined ' ) { instantiation Options [ 'path ' ] = this . options . phantom Path ; } 
function load Finished Setup ( status ) { var args = arguments ; self . page Cnt + + ; debug ( 'phantomjs on Load Finished triggered ' , status , self . page Cnt ) ; return self . ready = Horseman Promise . try ( function check Status ( ) { if ( status ! = = 'success ' ) { var err = new Error ( 'Failed to load url ' ) ; return Horseman Promise . reject ( err ) ; } } ) . then ( function inject JQuery ( ) { if ( ! self . options . inject Jquery ) { return ; } return Horseman Promise . from Callback ( function has JQuery ( done ) { return page . evaluate ( function has JQuery ( ) { return ( typeof window . j Query ! = = 'undefined ' ) ; } , done ) ; } ) . then ( function ( has Jquery ) { if ( has Jquery ) { debug ( 'j Query not injected - already exists on page ' ) ; return ; } var j Query Location = path . join ( _ _dirname , ' . . /files /jquery - 2 . 1 . 1 .min .js ' ) ; return Horseman Promise . from Callback ( function ( done ) { return page . inject Js ( j Query Location , done ) ; } ) . tap ( function ( successful ) { if ( ! successful ) { var err = new Error ( 'j Query injection failed ' ) ; return Horseman Promise . reject ( err ) ; } debug ( 'injected j Query ' ) ; } ) ; } ) ; } ) . then ( function inject Bluebird ( ) { var inject = self . options . inject Bluebird ; if ( ! inject ) { return ; } return Horseman Promise . from Callback ( function has Promise ( done ) { return page . evaluate ( function has Promise ( ) { return ( typeof window . Promise ! = = 'undefined ' ) ; } , done ) ; } ) . then ( function ( has Promise ) { if ( has Promise & & inject ! = = 'bluebird ' ) { debug ( 'bluebird not injected - ' + 'Promise already exists on page ' ) ; return ; } var bb Loc = 'bluebird /js /browser /bluebird ' + ( self . options . bluebird Debug ? ' ' : ' .min ' ) + ' .js ' ; return Horseman Promise . from Callback ( function ( done ) { return page . inject Js ( require . resolve ( bb Loc ) , done ) ; } ) . tap ( function ( successful ) { if ( ! successful ) { var err = new Error ( 'bluebird injection failed ' ) ; return Horseman Promise . reject ( err ) ; } debug ( 'injected bluebird ' ) ; } ) ; } ) . then ( function config Bluebird ( ) { return Horseman Promise . from Callback ( function ( done ) { return page . evaluate ( function config Bluebird ( no Conflict , debug ) { if ( debug ) { 
function get Colors ( image , cb ) { var data = [ ] ; var img = create Image ( image ) ; var promise = new Promise ( function ( resolve ) { img . onload = function ( ) { var canvas = document . create Element ( 'canvas ' ) ; canvas . width = img . width ; canvas . height = img . height ; canvas . get Context ( ' 2d ' ) . draw Image ( img , 0 , 0 , img . width , img . height ) ; var ctx = canvas . get Context ( ' 2d ' ) ; var image Data = ctx . get Image Data ( 0 , 0 , img . width , 1 ) . data ; for ( var i = 0 ; i < img . width ; i + + ) { data . push ( [ image Data [ i * 4 ] / 2 5 5 , image Data [ i * 4 + 1 ] / 2 5 5 , image Data [ i * 4 + 2 ] / 2 5 5 ] ) ; } resolve ( data ) ; } ; } ) ; return promise ; } 
function create Cubehelix ( steps , opts ) { var data = [ ] ; for ( var i = 0 ; i < steps ; i + + ) { data . push ( cubehelix . rgb ( i / steps , opts ) . map ( ( v ) = > v / 2 5 5 ) ) ; } return data ; } 
function to Image Data ( colors ) { return colors . map ( ( color ) = > color . map ( ( v ) = > v * 2 5 5 ) . concat ( 2 5 5 ) ) . reduce ( ( prev , curr ) = > prev . concat ( curr ) ) ; } 
function compress ( colors , factor ) { var data = [ ] ; var len = ( colors . length ) / factor ; var step = ( colors . length - 1 ) / len ; for ( var i = 0 ; i < colors . length ; i + = step ) { data . push ( colors [ i | 0 ] ) ; } return data ; } 
function to Colormap ( data ) { var stops = [ ] ; for ( var i = 0 ; i < data . length ; i + + ) { stops . push ( { index : Math . round ( i * 1 0 0 / ( data . length - 1 ) ) / 1 0 0 , rgb : data [ i ] . map ( ( v ) = > Math . round ( v * 2 5 5 ) ) } ) ; } return stops ; } 
function show ( pixels , title ) { if ( typeof pixels = = = 'string ' ) { var img = create Image ( pixels ) ; img . style . height = ' 4 0px ' ; img . style . width = ' 1 0 0 % ' ; title & & img . set Attribute ( 'title ' , title ) ; document . body . append Child ( img ) ; return ; } var canvas = document . create Element ( 'canvas ' ) ; var w = ( pixels . length / 4 ) | 0 ; canvas . width = w ; canvas . height = 1 ; canvas . style . height = ' 4 0px ' ; canvas . style . width = ' 1 0 0 % ' ; var ctx = canvas . get Context ( ' 2d ' ) ; var image Data = ctx . create Image Data ( w , 1 ) ; image Data . data . set ( pixels ) ; ctx . put Image Data ( image Data , 0 , 0 ) ; title & & canvas . set Attribute ( 'title ' , title ) ; document . body . append Child ( canvas ) ; document . body . append Child ( document . create Element ( 'br ' ) ) ; } 
function ( ) { var prop = 'page YOffset ' , method = 'scroll Top ' ; return win ? ( prop in win ) ? win [ prop ] : win . document . document Element [ method ] : win . document . body [ method ] ; } 
function get Real Width ( element ) { var width = 0 ; var $target = element ; var css _class = 'hidden _element ' ; $target = $target . clone ( ) . attr ( 'class ' , css _class ) . append To ( 'body ' ) ; width = $target . width ( true ) ; $target . remove ( ) ; return width ; } 
function upsert Inner ( db , doc Id , diff Fun ) { if ( typeof doc Id ! = = 'string ' ) { return Pouch Promise . reject ( new Error ( 'doc id is required ' ) ) ; } return db . get ( doc Id ) . catch ( function ( err ) { if ( err . status ! = = 4 0 4 ) { throw err ; } return { } ; } ) . then ( function ( doc ) { 
function start Download ( src , storage File ) { var uri = Windows . Foundation . Uri ( src ) ; var downloader = new Windows . Networking . Background Transfer . Background Downloader ( ) ; var download = downloader . create Download ( uri , storage File ) ; return download . start Async ( ) ; } 
function ( options ) { this . _handlers = { 'progress ' : [ ] , 'cancel ' : [ ] , 'error ' : [ ] , 'complete ' : [ ] } ; 
function ( file Url , dir Url , callback , progress Callback ) { var win = function ( result ) { if ( result & & result . progress ) { if ( progress Callback ) { progress Callback ( result ) ; } } else if ( callback ) { callback ( 0 ) ; } } ; var fail = function ( result ) { if ( callback ) { callback ( - 1 ) ; } } ; exec ( win , fail , 'Zip ' , 'unzip ' , [ file Url , dir Url ] ) ; } 
function ( url , headers , cb ) { var callback = ( typeof headers = = "function " ? headers : cb ) ; exec ( callback , callback , 'Sync ' , 'download ' , [ url , null , headers ] ) ; } 
function create App Channel ( app , key ) { assert ( ~ [ 'consumer Channel ' , 'publisher Channel ' ] . index Of ( key ) , 'Channel key must be "consumer Channel " or "publisher Channel " ' ) assert ( app . connection , 'Cannot create a channel without a connection ' ) assert ( ! app [ key ] , 'Channel " ' + key + ' " already exists ' ) return co ( function * ( ) { const channel = app [ key ] = yield app . connection . create Channel ( ) channel . _ _coworkers Close Handler = module . exports . close Handler . bind ( null , app , key ) channel . _ _coworkers Error Handler = module . exports . error Handler . bind ( null , app , key ) channel . once ( 'close ' , channel . _ _coworkers Close Handler ) channel . once ( 'error ' , channel . _ _coworkers Error Handler ) app . emit ( 'channel :create ' , channel ) 
function error Handler ( app , key , err ) { 
function create App Connection ( app , url , socket Options ) { assert ( ! app . connection , 'Cannot create connection if it already exists ' ) return co ( function * ( ) { const conn = app . connection = yield amqplib . connect ( url , socket Options ) conn . _ _coworkers Close Handler = module . exports . close Handler . bind ( null , app ) conn . _ _coworkers Error Handler = module . exports . error Handler . bind ( null , app ) conn . once ( 'close ' , conn . _ _coworkers Close Handler ) conn . once ( 'error ' , conn . _ _coworkers Error Handler ) app . emit ( 'connection :create ' , conn ) return conn } ) } 
function error Handler ( app , err ) { delete app . connection 
function respond ( ) { const context = this const consume Opts = context . consume Opts const channel = context . consumer Channel let method let args const methods = [ 'ack ' , 'nack ' , 'ack All ' , 'nack All ' , 'reject ' ] method = methods . find ( function ( method ) { if ( context [ method ] ) { args = context [ method ] return true } } ) if ( method ) { args = values ( pick ( args , [ 'all Up To ' , 'requeue ' ] ) ) if ( method = = = 'ack ' | | method = = = 'nack ' ) { args . unshift ( context . message ) } channel [ method ] . apply ( channel , args ) } else if ( ! consume Opts . no Ack ) { 
function Application ( options ) { if ( ! ( this instanceof Application ) ) return new Application ( options ) Event Emitter . call ( this ) this .connection = <amqplib Connection > this .consumer Channel = <amqplib Channel > this .publisher Channel = <amqplib Channel > this .consumer Tags = [ . . . ] * / } 
function assert And Consume App Queue ( app , queue Name ) { return co ( function * ( ) { const queue = app . queue Middlewares [ queue Name ] const queue Opts = queue . queue Opts const consume Opts = queue . consume Opts const handler = app . message Handler ( queue Name ) yield app . consumer Channel . assert Queue ( queue Name , queue Opts ) return yield app . consumer Channel . consume ( queue Name , handler , consume Opts ) } ) } 
function get Selection ( el ) { var start = 0 , end = 0 , normalized Value , range , text Input Range , len , end Range ; if ( typeof el . selection Start = = "number " & & typeof el . selection End = = "number " ) { start = el . selection Start ; end = el . selection End ; } else { range = document . selection . create Range ( ) ; if ( range & & range . parent Element ( ) = = el ) { len = el . value . length ; normalized Value = el . value . replace ( / \r \n / g , " \n " ) ; 
function parse Shard Fun ( str ) { str = str . trim ( ) if ( str . length = = = 0 ) { throw new Error ( 'empty shard string ' ) } if ( ! str . starts With ( PREFIX ) ) { throw new Error ( ` $ { str } ` ) } const parts = str . slice ( PREFIX . length ) . split ( ' / ' ) const version = parts [ 0 ] if ( version ! = = 'v 1 ' ) { throw new Error ( ` $ { version } ` ) } const name = parts [ 1 ] if ( ! parts [ 2 ] ) { throw new Error ( 'missing param ' ) } const param = parse Int ( parts [ 2 ] , 1 0 ) switch ( name ) { case 'prefix ' : return new Prefix ( param ) case 'suffix ' : return new Suffix ( param ) case 'next -to -last ' : return new Next To Last ( param ) default : throw new Error ( ` $ { name } ` ) } } 
function set DOM ( old Node , new Node ) { 
function set Node ( old Node , new Node ) { if ( old Node . node Type = = = new Node . node Type ) { 
function set Attributes ( old Attributes , new Attributes ) { var i , a , b , ns , name 
function set Child Nodes ( old Parent , new Parent ) { var check Old , old Key , check New , new Key , found Node , keyed Nodes var old Node = old Parent . first Child var new Node = new Parent . first Child var extra = 0 
function get Key ( node ) { if ( node . node Type ! = = ELEMENT _TYPE ) return var key = node . get Attribute ( set DOM . KEY ) | | node . id if ( key ) return KEY _PREFIX + key } 
function is Equal Node ( a , b ) { return ( 
function dispatch ( node , type ) { 
function join ( socket , multiaddr , pub , cb ) { const log = socket . log = config . log . bind ( config . log , ' [ ' + socket . id + ' ] ' ) if ( get Config ( ) . strict Multiaddr & & ! util . validate Ma ( multiaddr ) ) { joins Total . inc ( ) joins Failure Total . inc ( ) return cb ( 'Invalid multiaddr ' ) } if ( get Config ( ) . crypto Challenge ) { if ( ! pub . length ) { joins Total . inc ( ) joins Failure Total . inc ( ) return cb ( 'Crypto Challenge required but no Id provided ' ) } if ( ! nonces [ socket . id ] ) { nonces [ socket . id ] = { } } if ( nonces [ socket . id ] [ multiaddr ] ) { log ( 'response crypto Challenge ' , multiaddr ) nonces [ socket . id ] [ multiaddr ] . key . verify ( Buffer . from ( nonces [ socket . id ] [ multiaddr ] . nonce ) , Buffer . from ( pub , 'hex ' ) , ( err , ok ) = > { if ( err | | ! ok ) { joins Total . inc ( ) joins Failure Total . inc ( ) } if ( err ) { return cb ( 'Crypto error ' ) } 
function ( reference , options ) { reference = reference . trim ( ) if ( reference . last Index Of ( ' # ' , 0 ) < 0 ) { console . warn ( 'Remote references not supported yet . Reference must start with " # " (but was ' + reference + ' ) ' ) return { } } var components = reference . split ( ' # ' ) 
function data Type ( value ) { if ( ! value ) return null if ( value [ 'any Of ' ] | | value [ 'all Of ' ] | | value [ 'one Of ' ] ) { return ' ' } if ( ! value . type ) { return 'object ' } if ( value . type = = = 'array ' ) { return data Type ( value . items | | { } ) + ' [ ] ' } return value . type } 
function connect ( ) { const args = normalize Connect Args ( arguments ) ; const options = { host : 'localhost ' , port : 6 1 6 1 3 , timeout : 3 0 0 0 , connect Headers : { } , . . . args [ 0 ] } ; const connect Listener = args [ 1 ] ; let client = null ; let socket = null ; let timeout = null ; let original Socket Destroy = null ; const cleanup = function ( ) { if ( timeout ) { clear Timeout ( timeout ) ; } client . remove Listener ( 'error ' , on Error ) ; client . remove Listener ( 'connect ' , on Connected ) ; } ; const on Error = function ( error ) { cleanup ( ) ; error . connect Args = options ; if ( typeof connect Listener = = = 'function ' ) { connect Listener ( error ) ; } } ; const on Connected = function ( ) { if ( original Socket Destroy ) { socket . destroy = original Socket Destroy ; } cleanup ( ) ; client . emit ( 'socket -connect ' ) ; const connect Opts = Object . assign ( { host : options . host } , options . connect Headers ) ; client . connect ( connect Opts , connect Listener ) ; } ; let transport Connect = net . connect ; if ( 'connect ' in options ) { transport Connect = options . connect ; } else { if ( 'ssl ' in options ) { if ( typeof options . ssl = = = 'boolean ' ) { if ( options . ssl = = = true ) { transport Connect = tls . connect ; } } else { if ( options . ssl ! = = void 0 ) { throw new Error ( 'expected ssl property to have boolean value ' ) ; } } } } socket = transport Connect ( options , on Connected ) ; if ( options . timeout > 0 ) { timeout = set Timeout ( function ( ) { client . destroy ( client . create Transport Error ( 'connect timed out ' ) ) ; } , options . timeout ) ; original Socket Destroy = socket . destroy ; socket . destroy = function ( ) { clear Timeout ( timeout ) ; socket . destroy = original Socket Destroy ; original Socket Destroy . apply ( socket , arguments ) ; } ; } client = new Client ( socket , options ) ; client . on ( 'error ' , on Error ) ; return client ; } 
function parse Server Uri ( uri ) { const comps = uri . match ( / ^ \s * ( ( \w + ) : \ / \ / ) ? ( ( [ ^ : ] + ) : ( [ ^ @ ] + ) @ ) ? ( [ \w - . ] + ) ( : ( \d + ) ) ? \s * $ / ) ; if ( ! comps ) { throw new Error ( 'could not parse server uri \ ' ' + uri + ' \ ' ' ) ; } const scheme = comps [ 2 ] ; const login = comps [ 4 ] ; const passcode = comps [ 5 ] ; const hostname = comps [ 6 ] ; const port = comps [ 8 ] ; const server = { host : hostname , connect Headers : { } } ; if ( scheme ! = = void 0 ) { server . ssl = scheme = = = 'ssl ' | | scheme = = = 'stomp +ssl ' ; } if ( port ! = = void 0 ) { server . port = parse Int ( port , 1 0 ) ; } if ( login ! = = void 0 ) { server . connect Headers . login = login ; } if ( passcode ! = = void 0 ) { server . connect Headers . passcode = passcode ; } if ( scheme = = = 'unix ' | | hostname [ 0 ] = = = ' / ' ) { if ( port ! = = void 0 ) { throw new Error ( 'invalid server uri \ ' ' + uri + ' \ ' ' ) ; } server . path = hostname ; server . ssl = false ; } return server ; } 
function get Address Info ( args ) { let info ; if ( typeof args . connect = = = 'function ' & & typeof args . connect . get Address Info = = = 'function ' ) { info = args . connect . get Address Info ( args ) ; } const has Path = typeof args . path = = = 'string ' ; const has Host = typeof args . host = = = 'string ' ; const has Port = ! is Na N ( args . port ) ; const has SSL = args . ssl = = = true ; const has Connect Headers = typeof args . connect Headers = = = 'object ' ; const login = has Connect Headers & & args . connect Headers . login ; const has Host Header = has Connect Headers & & typeof args . connect Headers . host = = = 'string ' & & args . connect Headers . host . length > 0 ; let transport ; if ( has Host ) { transport = has SSL ? 'ssl ' : 'tcp ' ; } else if ( has Path ) { transport = 'unix ' ; } let pseudo Uri = 'stomp + ' + transport + ' : / / ' ; if ( login ) { pseudo Uri + = login + ' @ ' ; } let transport Path = ' ' ; if ( has Host ) { transport Path + = args . host ; } else if ( has Path ) { transport Path + = args . path ; } if ( has Host & & has Port ) { transport Path + = ' : ' + args . port ; } pseudo Uri + = transport Path ; if ( has Host Header ) { pseudo Uri + = ' / ' + args . connect Headers . host ; } return Object . assign ( { connect Args : args , transport : transport , transport Path : transport Path , path : args . path , host : args . host , port : args . port , pseudo Uri : pseudo Uri } , info | | { } ) ; } 
function ( err , images ) { var alert = $ ( ' <div class = "alert alert -dismissable fade show " > ' ) ; alert . append ( ' <button type = "button " class = "close " data -dismiss = "alert " aria -label = "Close " > <span aria -hidden = "true " > &times ; < /span > < /button > ' ) ; if ( err ) { alert . add Class ( 'alert -danger ' ) ; alert . append ( ' <p class = "mb - 0 " > <strong >Error : < /strong > ' + err . message + ' < /p > ' ) ; } else { alert . add Class ( 'alert -success ' ) ; alert . append ( ' <p > <strong >Success : < /strong > < /p > ' ) ; images . for Each ( function ( image , index ) { var text = image . width + 'x ' + image . height + ' , ' + image . bpp + 'bit ' ; var url = URL . create Object URL ( new Blob ( [ image . buffer ] , { type : mime } ) ) ; alert . append ( ' <p class = "mb - ' + ( index = = = images . length - 1 ? 0 : 3 ) + ' " > <a href = " ' + url + ' " target = " _blank " > <img src = " ' + url + ' " / > ' + text + ' < /a > < /p > ' ) ; } ) ; } alert . prepend To ( ' #demos -parse -results ' ) ; } 
function force Update Suite Data ( suites , test ) { const id = get Suite Id ( test ) ; suites [ id ] = clone Deep ( suites [ id ] ) ; } 
function pd ( event ) { const retv = private Data . get ( event ) ; console . assert ( retv ! = null , " 'this ' is expected an Event object , but got " , event ) ; return retv } 
function set Cancel Flag ( data ) { if ( data . passive Listener ! = null ) { if ( typeof console ! = = "undefined " & & typeof console . error = = = "function " ) { console . error ( "Unable to prevent Default inside passive event listener invocation . " , data . passive Listener ) ; } return } if ( ! data . event . cancelable ) { return } data . canceled = true ; if ( typeof data . event . prevent Default = = = "function " ) { data . event . prevent Default ( ) ; } } 
function define Redirect Descriptor ( key ) { return { get ( ) { return pd ( this ) . event [ key ] } , set ( value ) { pd ( this ) . event [ key ] = value ; } , configurable : true , enumerable : true , } } 
function define Call Descriptor ( key ) { return { value ( ) { const event = pd ( this ) . event ; return event [ key ] . apply ( event , arguments ) } , configurable : true , enumerable : true , } } 
function define Wrapper ( Base Event , proto ) { const keys = Object . keys ( proto ) ; if ( keys . length = = = 0 ) { return Base Event } function Custom Event ( event Target , event ) { Base Event . call ( this , event Target , event ) ; } Custom Event . prototype = Object . create ( Base Event . prototype , { constructor : { value : Custom Event , configurable : true , writable : true } , } ) ; 
function get Wrapper ( proto ) { if ( proto = = null | | proto = = = Object . prototype ) { return Event } let wrapper = wrappers . get ( proto ) ; if ( wrapper = = null ) { wrapper = define Wrapper ( get Wrapper ( Object . get Prototype Of ( proto ) ) , proto ) ; wrappers . set ( proto , wrapper ) ; } return wrapper } 
function wrap Event ( event Target , event ) { const Wrapper = get Wrapper ( Object . get Prototype Of ( event ) ) ; return new Wrapper ( event Target , event ) } 
function get Listeners ( event Target ) { const listeners = listeners Map . get ( event Target ) ; if ( listeners = = null ) { throw new Type Error ( " 'this ' is expected an Event Target object , but got another value . " ) } return listeners } 
function define Event Attribute Descriptor ( event Name ) { return { get ( ) { const listeners = get Listeners ( this ) ; let node = listeners . get ( event Name ) ; while ( node ! = null ) { if ( node . listener Type = = = ATTRIBUTE ) { return node . listener } node = node . next ; } return null } , set ( listener ) { if ( typeof listener ! = = "function " & & ! is Object ( listener ) ) { listener = null ; 
function define Custom Event Target ( event Names ) { function Custom Event Target ( ) { Event Target . call ( this ) ; } Custom Event Target . prototype = Object . create ( Event Target . prototype , { constructor : { value : Custom Event Target , configurable : true , writable : true , } , } ) ; for ( let i = 0 ; i < event Names . length ; + + i ) { define Event Attribute ( Custom Event Target . prototype , event Names [ i ] ) ; } return Custom Event Target } 
function Event Target ( ) { if ( this instanceof Event Target ) { listeners Map . set ( this , new Map ( ) ) ; return } if ( arguments . length = = = 1 & & Array . is Array ( arguments [ 0 ] ) ) { return define Custom Event Target ( arguments [ 0 ] ) } if ( arguments . length > 0 ) { const types = new Array ( arguments . length ) ; for ( let i = 0 ; i < arguments . length ; + + i ) { types [ i ] = arguments [ i ] ; } return define Custom Event Target ( types ) } throw new Type Error ( "Cannot call a class as a function " ) } 
function ( file Name , retrying ) { let file = assets [ file Name ] | | { } ; let key = path . posix . join ( upload Path , file Name ) ; let put Policy = new qiniu . rs . Put Policy ( { scope : bucket + ' : ' + key } ) ; let upload Token = put Policy . upload Token ( mac ) ; let form Uploader = new qiniu . form _up . Form Uploader ( qiniu Config ) ; let put Extra = new qiniu . form _up . Put Extra ( ) ; return new Promise ( ( resolve ) = > { let begin = Date . now ( ) ; form Uploader . put File ( upload Token , key , file . exists At , put Extra , function ( err , body ) { 
function ( err ) { if ( err ) { 
function ( ev ) { var cts , i , next Pointers if ( ! ev . default Prevented ) { if ( _prevent Default ) { ev . prevent Default ( ) } next Pointers = utils . clone ( _curr Pointers ) 
function ( ev ) { var next Pointers if ( ! ev . default Prevented ) { if ( _prevent Default ) { ev . prevent Default ( ) } if ( ! _mouse Down ) { _mouse Down = true next Pointers = utils . clone ( _curr Pointers ) 
function ( space ) { 
function ( select 2 _data ) { var model ; if ( opts . simple _tags ) { model = [ ] ; angular . for Each ( select 2 _data , function ( value , index ) { model . push ( value . id ) ; } ) ; } else { model = select 2 _data ; } return model ; } 
function ( angular _data ) { var model = [ ] ; if ( ! angular _data ) { return model ; } if ( opts . simple _tags ) { model = [ ] ; angular . for Each ( angular _data , function ( value , index ) { model . push ( { 'id ' : value , 'text ' : value } ) ; } ) ; } else { model = angular _data ; } return model ; } 
function teamcity ( runner ) { Base . call ( this , runner ) ; var stats = this . stats ; var flow Id = document . title | | new Date ( ) . get Time ( ) ; runner . on ( 'suite ' , function ( suite ) { if ( suite . root ) return ; suite . start Date = new Date ( ) ; log ( ' # #teamcity [test Suite Started name = \ ' ' + escape ( suite . title ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' ] ' ) ; } ) ; runner . on ( 'test ' , function ( test ) { log ( ' # #teamcity [test Started name = \ ' ' + escape ( test . title ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' capture Standard Output = \ 'true \ ' ] ' ) ; } ) ; runner . on ( 'fail ' , function ( test , err ) { log ( ' # #teamcity [test Failed name = \ ' ' + escape ( test . title ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' message = \ ' ' + escape ( err . message ) + ' \ ' capture Standard Output = \ 'true \ ' details = \ ' ' + escape ( err . stack ) + ' \ ' ] ' ) ; } ) ; runner . on ( 'pending ' , function ( test ) { log ( ' # #teamcity [test Ignored name = \ ' ' + escape ( test . title ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' message = \ 'pending \ ' ] ' ) ; } ) ; runner . on ( 'test end ' , function ( test ) { log ( ' # #teamcity [test Finished name = \ ' ' + escape ( test . title ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' duration = \ ' ' + test . duration + ' \ ' ] ' ) ; } ) ; runner . on ( 'suite end ' , function ( suite ) { if ( suite . root ) return ; log ( ' # #teamcity [test Suite Finished name = \ ' ' + escape ( suite . title ) + ' \ ' duration = \ ' ' + ( new Date ( ) - suite . start Date ) + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' ] ' ) ; } ) ; runner . on ( 'end ' , function ( ) { log ( ' # #teamcity [test Suite Finished name = \ 'mocha .suite \ ' duration = \ ' ' + stats . duration + ' \ ' flow Id = \ ' ' + flow Id + ' \ ' ] ' ) ; } ) ; } 
function Teamcity ( runner , options ) { options = options | | { } ; const reporter Options = options . reporter Options | | { } ; let flow Id , use Std Error , record Hook Failures ; ( reporter Options . flow Id ) ? flow Id = reporter Options . flow Id : flow Id = process . env [ 'MOCHA _TEAMCITY _FLOWID ' ] | | process PID ; ( reporter Options . use Std Error ) ? use Std Error = reporter Options . use Std Error : use Std Error = process . env [ 'USE _STD _ERROR ' ] ; ( reporter Options . record Hook Failures ) ? record Hook Failures = reporter Options . record Hook Failures : record Hook Failures = process . env [ 'RECORD _HOOK _FAILURES ' ] ; ( use Std Error ) ? use Std Error = ( use Std Error . to Lower Case ( ) = = = 'true ' ) : use Std Error = false ; ( record Hook Failures ) ? record Hook Failures = ( record Hook Failures . to Lower Case ( ) = = = 'true ' ) : record Hook Failures = false ; Base . call ( this , runner ) ; let stats = this . stats ; const top Level Suite = reporter Options . top Level Suite | | process . env [ 'MOCHA _TEAMCITY _TOP _LEVEL _SUITE ' ] ; runner . on ( 'suite ' , function ( suite ) { if ( suite . root ) { if ( top Level Suite ) { log ( format String ( SUITE _START , top Level Suite , flow Id ) ) ; } return ; } suite . start Date = new Date ( ) ; log ( format String ( SUITE _START , suite . title , flow Id ) ) ; } ) ; runner . on ( 'test ' , function ( test ) { log ( format String ( TEST _START , test . title , flow Id ) ) ; } ) ; runner . on ( 'fail ' , function ( test , err ) { if ( use Std Error ) { log Error ( format String ( TEST _FAILED , test . title , err . message , err . stack , flow Id ) ) ; } else { log ( format String ( TEST _FAILED , test . title , err . message , err . stack , flow Id ) ) ; } } ) ; runner . on ( 'pending ' , function ( test ) { log ( format String ( TEST _IGNORED , test . title , test . title , flow Id ) ) ; } ) ; runner . on ( 'test end ' , function ( test ) { log ( format String ( TEST _END , test . title , test . duration , flow Id ) ) ; } ) ; runner . on ( 'hook ' , function ( test ) { if ( record Hook Failures ) { log ( format String ( TEST _START , test . title , flow Id ) ) ; } } ) ; runner . on ( 'suite end ' , function ( suite ) { if ( suite . root ) return ; log ( format String ( SUITE _END , suite . title , new Date ( ) - suite . start Date , flow Id ) ) ; } ) ; runner . on ( 'end ' , function ( ) { if ( top Level Suite ) { log ( format String ( SUITE _END , top Level Suite , stats . duration , flow Id ) ) ; } log ( format String ( SUITE _END , 'mocha .suite ' , stats . duration , flow Id ) ) ; } ) ; } 
function convert ( integer ) { var str = Number ( integer ) . to String ( 1 6 ) ; return str . length = = = 1 ? ' 0 ' + str : str ; } 
function parse ( text , options ) { options = Object . assign ( { } , { relaxed : true } , options ) ; 
function stringify ( value , replacer , space , options ) { if ( space ! = null & & typeof space = = = 'object ' ) ( options = space ) , ( space = 0 ) ; if ( replacer ! = null & & typeof replacer = = = 'object ' ) ( options = replacer ) , ( replacer = null ) , ( space = 0 ) ; options = Object . assign ( { } , { relaxed : true } , options ) ; const doc = Array . is Array ( value ) ? serialize Array ( value , options ) : serialize Document ( value , options ) ; return JSON . stringify ( doc , replacer , space ) ; } 
function serialize ( bson , options ) { options = options | | { } ; return JSON . parse ( stringify ( bson , options ) ) ; } 
function deserialize ( ejson , options ) { options = options | | { } ; return parse ( JSON . stringify ( ejson ) , options ) ; } 
function Facade ( obj , opts ) { opts = opts | | { } ; if ( ! ( 'clone ' in opts ) ) opts . clone = true ; if ( opts . clone ) obj = clone ( obj ) ; if ( ! ( 'traverse ' in opts ) ) opts . traverse = true ; if ( ! ( 'timestamp ' in obj ) ) obj . timestamp = new Date ( ) ; else obj . timestamp = new Date ( obj . timestamp ) ; if ( opts . traverse ) traverse ( obj ) ; this . opts = opts ; this . obj = obj ; } 
function make Define Virtual Module ( loader , load , add Dep , args ) { function namer ( load Name ) { var base Name = load Name . substr ( 0 , load Name . index Of ( " ! " ) ) ; return function ( part , plugin ) { return base Name + " - " + part + ( plugin ? ( " . " + plugin ) : " " ) ; } ; } function addresser ( load Address ) { return function ( part , plugin ) { var base = load Address + " . " + part ; return base + ( plugin ? ( " . " + plugin ) : " " ) ; } ; } var name = namer ( load . name ) ; var address = addresser ( load . address ) ; 
function get Filename ( name ) { var hash = name . index Of ( ' # ' ) ; var bang = name . index Of ( ' ! ' ) ; return name . slice ( hash < bang ? ( hash + 1 ) : 0 , bang ) ; } 
function translate ( load ) { var filename ; 
function ( dep Name , is Virtual ) { deps . push ( dep Name ) ; if ( is Virtual ! = = false ) load . metadata . virtual Deps . push ( dep Name ) ; } 
function MIDIFile ( buffer , strict Mode ) { var track ; var cur Index ; var i ; var j ; 
function MIDIFile Track ( buffer , start ) { let a ; let track Length ; 
function match Semver ( my Protocol , sender Protocol , callback ) { const mps = my Protocol . split ( ' / ' ) const sps = sender Protocol . split ( ' / ' ) const my Name = mps [ 1 ] const my Version = mps [ 2 ] const sender Name = sps [ 1 ] const sender Version = sps [ 2 ] if ( my Name ! = = sender Name ) { return callback ( null , false ) } 
function encode ( msg , callback ) { pull ( values ( Buffer . is Buffer ( msg ) ? [ msg ] : [ Buffer . from ( msg ) ] ) , pull LP . encode ( ) , collect ( ( err , encoded ) = > { if ( err ) { return callback ( err ) } callback ( null , encoded [ 0 ] ) } ) ) } 
function match Exact ( my Protocol , sender Protocol , callback ) { const result = my Protocol = = = sender Protocol callback ( null , result ) } 
function diff Arrays ( arr 1 , arr 2 ) { if ( ! Array . is Array ( arr 1 ) | | ! Array . is Array ( arr 2 ) ) { return true ; } if ( arr 1 . length ! = = arr 2 . length ) { return true ; } for ( var i = 0 , len = arr 1 . length ; i < len ; i + + ) { if ( arr 1 [ i ] ! = = arr 2 [ i ] ) { return true ; } } return false ; } 
function get Source Rule String ( source Rule ) { function get Rule String ( rule ) { if ( rule . length = = = 1 ) { return ' " ' + rule + ' " ' ; } return ' ( " ' + rule . join ( ' " AND " ' ) + ' " ) ' ; } return source Rule . map ( get Rule String ) . join ( ' OR ' ) ; } 
function get Timeline Args ( scope ) { var timeline Args = { source Type : scope . source Type } ; 
function ( method , klass ) { while ( ! ! klass ) { var key = null , pro = klass . prototype ; 
function ( config ) { _logger . info ( 'begin dump files . . . ' ) ; var map = { } ; [ 'file Include ' , 'file Exclude ' ] . for Each ( function ( name ) { var value = config [ name ] ; if ( ! ! value ) { if ( typeof value = = = 'string ' ) { var reg = new Reg Exp ( value , 'i ' ) ; config [ name ] = function ( file ) { return reg . test ( file ) ; } ; } else if ( ! ! value . test ) { config [ name ] = function ( file ) { return value . test ( file ) ; } } } if ( ! _util . is Function ( config [ name ] ) ) { var flag = name ! = = 'file Exclude ' ; config [ name ] = function ( file ) { return flag ; } ; } } ) ; ( config . res Root | | ' ' ) . split ( ' , ' ) . for Each ( function ( dir ) { if ( ! dir ) { return ; } var ret = _fs . lsfile ( dir , function ( name , file ) { return ! config . file Exclude ( file ) & & config . file Include ( file ) ; } ) ; ret . for Each ( function ( v ) { map [ v ] = v . replace ( config . web Root , config . temp ) ; } ) ; } ) ; _logger . debug ( 'package file map - > %j ' , map ) ; Object . keys ( map ) . for Each ( function ( src ) { var dst = map [ src ] ; _fs . copy ( src , dst , function ( a ) { _logger . info ( 'copy file %s ' , a ) ; } ) ; } ) ; } 
function ( config ) { _logger . info ( 'begin zip package . . . ' ) ; var cmd = [ 'java ' , ' -jar ' , JSON . stringify ( config . zip ) , JSON . stringify ( config . temp ) , JSON . stringify ( config . output ) ] . join ( ' ' ) ; _logger . debug ( 'do command : %s ' , cmd ) ; exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { _logger . error ( 'zip package error for reason : \n %s ' , error . stack ) ; process . abort ( ) ; return ; } if ( stdout ) { _logger . info ( stdout ) ; } if ( stderr ) { _logger . error ( stderr ) ; } upload To Server ( config ) ; } ) ; } 
function ( config ) { if ( ! _fs . exist ( config . output ) ) { return abort Process ( config , 'no package to be uploaded ' ) ; } _logger . info ( 'begin build upload form . . . ' ) ; var form = new Form Data ( ) ; var ex = _util . merge ( { version : ' 0 . 1 ' , platform : 'ios &android ' } , config . extension ) ; 
function ( config ) { _logger . info ( 'clear temporary directory and files ' ) ; _fs . rmdir ( config . temp ) ; _fs . rm ( config . output ) ; } 
function ( config ) { var args = [ ] . slice . call ( arguments , 0 ) ; clear Temp ( args . shift ( ) ) ; _logger . error . apply ( _logger , args ) ; process . abort ( ) ; } 
function ( content ) { var ret , handler = function ( map ) { ret = map ; } , sandbox = { NEJ : { deps : handler , config : handler } } ; 
function ( patform , deps , func ) { var args = exports . format ARG . apply ( exports , arguments ) ; if ( ! this . patches ) { this . patches = [ ] ; } 
function ( content ) { 
function ( uri , deps , func ) { var args = exports . format ARG . apply ( exports , arguments ) ; this . is NEJ = ! 0 ; this . dependency = args [ 1 ] ; this . source = ( args [ 2 ] | | ' ' ) . to String ( ) ; } 
function ( result , exp ) { switch ( exp . op ) { case ' < ' : case ' < = ' : result . lower = exp ; break ; case ' > ' : case ' > = ' : result . upper = exp ; break ; case ' = ' : case ' = = ' : result . midle = exp ; break ; } delete exp . op ; } 
function ( result , exp ) { switch ( exp . op ) { case ' < ' : case ' < = ' : 
function ( name , config ) { var patch = config . patch ; if ( ! patch ) { return ; } 
function ( name , config , plugins ) { var plugin = config . plugin ; if ( ! plugin ) { return ; } 
function ( event ) { if ( event . type = = 'script ' ) { event . value = this . _check Res In Script ( event . file , event . content , options ) ; } } 
function ( uri , config ) { 
function ( uri , config ) { config = _util . merge ( config , { domain : config . cs Domain } ) ; return this . _format RSURI ( uri , ' .css ' , config ) ; } 
function ( uri , config ) { config = _util . merge ( config , { domain : config . js Domain } ) ; return this . _format RSURI ( uri , ' .js ' , config ) ; } 
function ( uri , config ) { return this . _format URI ( uri , { from Page : config . from Page , path Root : config . output , web Root : config . web Root } ) ; } 
function ( uri , config ) { _io . resource ( 'manifested ' , ! 0 ) ; return this . _format URI ( config . man Output , { path Root : config . output , web Root : config . web Root , domain : config . man Root } ) ; } 
function ( uri , config ) { uri = uri . replace ( config . src Root , config . out Html Root ) ; return this . _format URI ( uri , { path Root : config . output , web Root : config . web Root , domain : config . mdl Root } ) ; } 
function ( uri , config ) { return uri . replace ( config . src Root , config . out Html Root ) . replace ( config . web Root , ' / ' ) ; } 
function global ( map ) { Object . keys ( map ) . for Each ( function ( key ) { var file = map [ key ] , arr = file . split ( ' # ' ) , mdl = require ( ' . /lib / ' + arr [ 0 ] + ' .js ' ) ; 
function ( src , events ) { 
function fmix 3 2 ( hash ) { hash ^ = hash > > > 1 6 hash = multiply ( hash , 0x 8 5ebca 6b ) hash ^ = hash > > > 1 3 hash = multiply ( hash , 0xc 2b 2ae 3 5 ) hash ^ = hash > > > 1 6 return hash } 
function fmix 3 2 _pure ( hash ) { hash = ( hash ^ ( hash > > > 1 6 ) ) > > > 0 hash = multiply ( hash , 0x 8 5ebca 6b ) hash = ( hash ^ ( hash > > > 1 3 ) ) > > > 0 hash = multiply ( hash , 0xc 2b 2ae 3 5 ) hash = ( hash ^ ( hash > > > 1 6 ) ) > > > 0 return hash } 
function Strata ( options ) { this . options = options this . options . comparator = options . comparator | | compare this . journalist = new Journalist ( this , options ) this . housekeeper = new Turnstile this . writer = new Turnstile this . _cursors = [ ] } 
function bind Keys ( scope , obj , def , parent Node , path ) { var meta , key if ( typeof obj ! = = 'object ' | | obj = = = null ) throw new Type Error ( 'Invalid type of value " ' + obj + ' " , object expected . ' ) Object . define Property ( obj , memoized Object Key , { value : { } , configurable : true } ) Object . define Property ( obj , meta Key , { value : { } , configurable : true } ) meta = obj [ meta Key ] for ( key in def ) { meta [ key ] = { key Path : { key : key , root : path . root , target : obj } , active Nodes : [ ] , previous Values : [ ] , 
function bind Key ( scope , obj , def , key , parent Node ) { var memoized Object = obj [ memoized Object Key ] var meta = obj [ meta Key ] [ key ] var branch = def [ key ] var node = branch [ 0 ] var change = ! branch [ has Definition Key ] & & branch [ 1 ] var definition = branch [ has Definition Key ] & & branch [ 1 ] var mount = branch [ 2 ] var is Marker Last = branch [ is Marker Last Key ] 
function parent Setter ( x ) { var previous Value = memoized Object [ key ] var return Value 
function replace Node ( value , previous Value , i ) { var active Node = active Nodes [ i ] var current Node = node var return Value 
function pop ( ) { var i = this . length - 1 var previous Value = previous Values [ i ] var value = Array . prototype . pop . call ( this ) remove Node ( null , previous Value , i ) previous Values . length = active Nodes . length = this . length return value } 
function change Value ( node , value , attribute ) { var first Child switch ( attribute ) { case 'text Content ' : first Child = node . first Child if ( first Child & & ! first Child . next Sibling & & first Child . node Type = = = TEXT _NODE ) first Child . text Content = value else node . text Content = value break case 'checked ' : node . checked = Boolean ( value ) break case 'value ' : 
function get Next Node ( index , active Nodes ) { var i , j , next Node for ( i = index , j = active Nodes . length ; i < j ; i + + ) if ( active Nodes [ i ] ) { next Node = active Nodes [ i ] break } return next Node } 
function update Change ( target Key , path , key ) { var target = path . target var index = path . index var replace Key = key if ( typeof index = = = 'number ' ) { target = target [ key ] replace Key = index } return function handle Change ( event ) { target [ replace Key ] = event . target [ target Key ] } } 
function simulacra ( obj , def , match Node ) { var document = this ? this . document : window . document var Node = this ? this . Node : window . Node var node , query 
function ensure Nodes ( parent Node , def ) { var adjacent Nodes = [ ] var i , j , key , query , branch , bound Node , matched Nodes var adjacent Node , adjacent Key if ( typeof def ! = = 'object ' ) throw new Type Error ( 'The second position must be an object . ' ) for ( key in def ) { branch = def [ key ] 
function clean Node ( scope , node ) { 
function process Nodes ( scope , node , def ) { var document = scope ? scope . document : window . document var key , branch , result , mirror Node , parent , marker , indices var i , j , tree Walker , ordered Keys result = def [ template Key ] if ( ! result ) { node = node . clone Node ( true ) indices = [ ] match Nodes ( scope , node , def ) ordered Keys = Object . keys ( def ) . sort ( function ( a , b ) { var node A = def [ a ] [ 0 ] [ matched Node Key ] var node B = def [ b ] [ 0 ] [ matched Node Key ] if ( node A & & node B ) return node A . index - node B . index return 0 } ) for ( i = 0 ; i < ordered Keys . length ; i + + ) { key = ordered Keys [ i ] branch = def [ key ] if ( branch [ is Bound To Parent Key ] ) continue result = branch [ 0 ] [ matched Node Key ] indices . push ( result . index ) mirror Node = result . node parent = mirror Node . parent Node 
function match Nodes ( scope , node , def ) { var document = scope ? scope . document : window . document var tree Walker = document . create Tree Walker ( node , show All , accept Node , false ) var nodes = [ ] var i , j , key , current Node , child Walker var node Index = 0 
function rehydrate ( scope , obj , def , node , match Node ) { var document = scope ? scope . document : window . document var key , branch , x , value , change , definition , mount , key Path var meta , value Is Array , active Nodes , index , tree Walker , current Node for ( key in def ) { branch = def [ key ] meta = obj [ meta Key ] [ key ] change = ! branch [ has Definition Key ] & & branch [ 1 ] definition = branch [ has Definition Key ] & & branch [ 1 ] mount = branch [ 2 ] key Path = meta . key Path if ( branch [ is Bound To Parent Key ] ) { x = obj [ key ] if ( definition & & x ! = = null & & x ! = = void 0 ) bind Keys ( scope , x , definition , match Node , key Path ) else if ( change ) change ( match Node , x , null , key Path ) continue } active Nodes = meta . active Nodes if ( ! active Nodes . length ) continue value Is Array = meta . value Is Array x = value Is Array ? obj [ key ] : [ obj [ key ] ] index = 0 tree Walker = document . create Tree Walker ( match Node , what To Show , accept Node , false ) while ( index < active Nodes . length & & tree Walker . next Node ( ) ) { current Node = active Nodes [ index ] if ( tree Walker . current Node . is Equal Node ( current Node ) ) { active Nodes . splice ( index , 1 , tree Walker . current Node ) value = x [ index ] if ( value Is Array ) key Path . index = index else delete key Path . index if ( definition ) { rehydrate ( scope , value , definition , current Node , tree Walker . current Node ) if ( mount ) { key Path . target = value mount ( tree Walker . current Node , value , null , key Path ) } } else if ( change ) change ( tree Walker . current Node , value , null , key Path ) index + + } } if ( index ! = = active Nodes . length ) throw new Error ( 'Matching nodes could not be found on key " ' + key + ' " , expected ' + active Nodes . length + ' , found ' + index + ' . ' ) 
function render ( obj , def , html ) { var i , nodes , handler , parser , element , element Prototype 
function feature Check ( global Scope , features ) { var i , j , k , l , feature , path for ( i = 0 , j = features . length ; i < j ; i + + ) { path = features [ i ] if ( typeof path [ 0 ] = = = 'string ' ) { feature = global Scope for ( k = 0 , l = path . length ; k < l ; k + + ) { if ( ! ( path [ k ] in feature ) ) throw new Error ( 'Missing ' + path . slice ( 0 , k + 1 ) . join ( ' . ' ) + ' feature which is required . ' ) feature = feature [ path [ k ] ] } } else { feature = path [ 0 ] for ( k = 1 , l = path . length ; k < l ; k + + ) { if ( k > 1 ) feature = feature [ path [ k ] ] if ( typeof feature = = = 'undefined ' ) throw new Error ( 'Missing ' + path [ 0 ] . name + path . slice ( 1 , k + 1 ) . join ( ' . ' ) + ' feature which is required . ' ) } } } } 
function bem Names ( entitys , delimiters ) { var result String = ' ' ; var names = entitys | | { mods : { } , mixin : ' ' } ; var delims = _extends ( { ns : ' ' , el : ' _ _ ' , mod : ' - - ' , mod Val : ' - ' } , delimiters ) ; var mixin = is String ( names . mixin ) ? ' ' + names . mixin : ' ' ; if ( ! names . block ) return ' ' ; result String = delims . ns ? delims . ns + names . block : names . block ; if ( names . el ) result String + = delims . el + names . el ; if ( is PObject ( names . mods ) ) { result String + = Object . keys ( names . mods ) . reduce ( function ( prev , name ) { var val = names . mods [ name ] ; if ( val = = = true ) { prev + = ' ' + result String + delims . mod + name ; } else if ( is String ( val ) | | is Number ( val ) ) { prev + = ' ' + result String + delims . mod + name + delims . mod Val + names . mods [ name ] ; } return prev ; } , ' ' ) ; } return result String + mixin ; } 
function write ( dest , code ) { return new Promise ( function ( resolve , reject ) { fs . write File ( dest , code , function ( err ) { if ( err ) return reject ( err ) 
function deep Merge Configs ( configs , options ) { return merge . all ( configs . filter ( config = > config ) , options ) ; } 
async function load Yaml ( context , params ) { try { const response = await context . github . repos . get Contents ( params ) ; return parse Config ( response . data . content ) ; } catch ( e ) { if ( e . code = = = 4 0 4 ) { return null ; } throw e ; } } 
function get Base Params ( params , base ) { if ( typeof base ! = = 'string ' ) { throw new Error ( ` $ { BASE _KEY } ` ) ; } const match = base . match ( BASE _REGEX ) ; if ( match = = null ) { throw new Error ( ` $ { BASE _KEY } $ { base } ` ) ; } return { owner : match [ 1 ] | | params . owner , repo : match [ 2 ] , path : match [ 3 ] | | params . path , } ; } 
async function get Config ( context , file Name , default Config , deep Merge Options ) { const file Path = path . posix . join ( CONFIG _PATH , file Name ) ; const params = context . repo ( { path : file Path , } ) ; const config = await load Yaml ( context , params ) ; let base Repo ; if ( config = = null ) { base Repo = DEFAULT _BASE ; } else if ( config ! = null & & BASE _KEY in config ) { base Repo = config [ BASE _KEY ] ; delete config [ BASE _KEY ] ; } let base Config ; if ( base Repo ) { const base Params = get Base Params ( params , base Repo ) ; base Config = await load Yaml ( context , base Params ) ; } if ( config = = null & & base Config = = null & & ! default Config ) { return null ; } return deep Merge Configs ( [ default Config , base Config , config ] , deep Merge Options ) ; } 
function define Property ( obj , name , value ) { var enumerable = ! ! obj [ name ] & & obj . property Is Enumerable ( name ) Object . define Property ( obj , name , { configurable : true , enumerable : enumerable , writable : true , value : value } ) } 
function shimmer ( options ) { if ( options & & options . logger ) { if ( ! is Function ( options . logger ) ) logger ( "new logger isn 't a function , not replacing " ) else logger = options . logger } } 
function inject Manifest ( data ) { let manifest Html = ` $ { hexo . config . pwa . manifest . path } ` ; if ( data . index Of ( manifest Html ) = = = - 1 ) { data = data . replace ( ' <head > ' , manifest Html ) ; } return data ; } 
function inject SWRegister ( data ) { let sw Html = ` $ { compiled SWReg Tpl } ` ; if ( data . index Of ( compiled SWReg Tpl ) = = = - 1 ) { data = data . replace ( ' < /body > ' , sw Html ) ; } return data ; } 
function inject Async Load Page JS ( data ) { let inject Html = ` $ { async Load Page JSTpl } ` ; if ( data . index Of ( inject Html ) = = = - 1 ) { data = data . replace ( ' < /head > ' , inject Html ) ; } return data ; } 
function rehype 2react ( options ) { var settings = options | | { } ; var create Element = settings . create Element ; var components = settings . components | | { } ; this . Compiler = compiler ; function compiler ( node ) { if ( node . type = = = 'root ' ) { if ( node . children . length = = = 1 & & node . children [ 0 ] . type = = = 'element ' ) { node = node . children [ 0 ] ; } else { node = { type : 'element ' , tag Name : 'div ' , properties : node . properties | | { } , children : node . children } ; } } return to H ( h , table Cell Style ( node ) , settings . prefix ) ; } function h ( name , props , children ) { var component = has ( components , name ) ? components [ name ] : name ; return create Element ( component , props , children ) ; } } 
function compiler ( node ) { if ( node . type = = = 'root ' ) { if ( node . children . length = = = 1 & & node . children [ 0 ] . type = = = 'element ' ) { node = node . children [ 0 ] ; } else { node = { type : 'element ' , tag Name : 'div ' , properties : node . properties | | { } , children : node . children } ; } } return to H ( h , table Cell Style ( node ) , settings . prefix ) ; } 
function h ( name , props , children ) { var component = has ( components , name ) ? components [ name ] : name ; return create Element ( component , props , children ) ; } 
function do Exec ( method , args ) { var cp ; var cp Promise = new Child Process Promise ( ) ; var reject = cp Promise . _cp Reject ; var resolve = cp Promise . _cp Resolve ; var final Args = slice . call ( args , 0 ) ; final Args . push ( callback ) ; cp = child _process [ method ] . apply ( child _process , final Args ) ; function callback ( err , stdout , stderr ) { if ( err ) { var command Str = args [ 0 ] + ( Array . is Array ( args [ 1 ] ) ? ( ' ' + args [ 1 ] . join ( ' ' ) ) : ' ' ) ; err . message + = ' ` ' + command Str + ' ` (exited with error code ' + err . code + ' ) ' ; err . stdout = stdout ; err . stderr = stderr ; var cp Error = new Child Process Error ( err . message , err . code , child _process , stdout , stderr ) ; reject ( cp Error ) ; } else { resolve ( { child Process : cp , stdout : stdout , stderr : stderr } ) ; } } cp Promise . child Process = cp ; return cp Promise ; } 
function do Spawn ( method , command , args , options ) { var result = { } ; var cp ; var cp Promise = new Child Process Promise ( ) ; var reject = cp Promise . _cp Reject ; var resolve = cp Promise . _cp Resolve ; var successful Exit Codes = ( options & & options . successful Exit Codes ) | | [ 0 ] ; cp = method ( command , args , options ) ; 
function slope 3 ( that , x 2 , y 2 ) { var h 0 = that . _x 1 - that . _x 0 , h 1 = x 2 - that . _x 1 , s 0 = ( that . _y 1 - that . _y 0 ) / ( h 0 | | h 1 < 0 & & - 0 ) , s 1 = ( y 2 - that . _y 1 ) / ( h 1 | | h 0 < 0 & & - 0 ) , p = ( s 0 * h 1 + s 1 * h 0 ) / ( h 0 + h 1 ) ; return ( sign ( s 0 ) + sign ( s 1 ) ) * Math . min ( Math . abs ( s 0 ) , Math . abs ( s 1 ) , 0 . 5 * Math . abs ( p ) ) | | 0 ; } 
function slope 2 ( that , t ) { var h = that . _x 1 - that . _x 0 ; return h ? ( 3 * ( that . _y 1 - that . _y 0 ) / h - t ) / 2 : t ; } 
function point ( that , t 0 , t 1 ) { var x 0 = that . _x 0 , y 0 = that . _y 0 , x 1 = that . _x 1 , y 1 = that . _y 1 , dx = ( x 1 - x 0 ) / 3 ; that . _context . bezier Curve To ( x 0 + dx , y 0 + dx * t 0 , x 1 - dx , y 1 - dx * t 1 , x 1 , y 1 ) ; } 
function should Set Attribute ( name , value ) { if ( is Reserved Prop ( name ) ) { return false ; } if ( name . length > 2 & & ( name [ 0 ] = = = 'o ' | | name [ 0 ] = = = 'O ' ) & & ( name [ 1 ] = = = 'n ' | | name [ 1 ] = = = 'N ' ) ) { return false ; } if ( value = = = null ) { return true ; } switch ( typeof value ) { case 'boolean ' : return should Attribute Accept Boolean Value ( name ) ; case 'undefined ' : case 'number ' : case 'string ' : case 'object ' : return true ; default : 
function create Markup For Property ( name , value ) { var property Info = get Property Info ( name ) ; if ( property Info ) { if ( should Ignore Value ( property Info , value ) ) { return ' ' ; } var attribute Name = property Info . attribute Name ; if ( property Info . has Boolean Value | | property Info . has Overloaded Boolean Value & & value = = = true ) { return attribute Name + ' = " " ' ; } else if ( typeof value ! = = 'boolean ' | | should Attribute Accept Boolean Value ( name ) ) { return attribute Name + ' = ' + quote Attribute Value For Browser ( value ) ; } } else if ( should Set Attribute ( name , value ) ) { if ( value = = null ) { return ' ' ; } return name + ' = ' + quote Attribute Value For Browser ( value ) ; } return null ; } 
function render To String ( element ) { var renderer = new React DOMServer Renderer $ 1 ( element , false ) ; var markup = renderer . read ( Infinity ) ; return markup ; } 
function render To Static Markup ( element ) { var renderer = new React DOMServer Renderer $ 1 ( element , true ) ; var markup = renderer . read ( Infinity ) ; return markup ; } 
function trap Bubbled Event ( top Level Type , handler Base Name , element ) { if ( ! element ) { return null ; } return Event Listener . listen ( element , handler Base Name , dispatch Event . bind ( null , top Level Type ) ) ; } 
function get Modern Offsets From Points ( outer Node , anchor Node , anchor Offset , focus Node $ $ 1 , focus Offset ) { var length = 0 ; var start = - 1 ; var end = - 1 ; var index Within Anchor = 0 ; var index Within Focus = 0 ; var node = outer Node ; var parent Node = null ; outer : while ( true ) { var next = null ; while ( true ) { if ( node = = = anchor Node & & ( anchor Offset = = = 0 | | node . node Type = = = TEXT _NODE ) ) { start = length + anchor Offset ; } if ( node = = = focus Node $ $ 1 & & ( focus Offset = = = 0 | | node . node Type = = = TEXT _NODE ) ) { end = length + focus Offset ; } if ( node . node Type = = = TEXT _NODE ) { length + = node . node Value . length ; } if ( ( next = node . first Child ) = = = null ) { break ; } 
function create Update Queue ( base State ) { var queue = { base State : base State , expiration Time : No Work , first : null , last : null , callback List : null , has Force Update : false , is Initialized : false } ; { queue . is Processing = false ; } return queue ; } 
function mount Class Instance ( work In Progress , render Expiration Time ) { var current = work In Progress . alternate ; { check Class Instance ( work In Progress ) ; } var instance = work In Progress . state Node ; var state = instance . state | | null ; var props = work In Progress . pending Props ; ! props ? invariant ( false , 'There must be pending props for an initial mount . This error is likely caused by a bug in React . Please file an issue . ' ) : void 0 ; var unmasked Context = get Unmasked Context ( work In Progress ) ; instance . props = props ; instance . state = work In Progress . memoized State = state ; instance . refs = empty Object ; instance . context = get Masked Context ( work In Progress , unmasked Context ) ; if ( enable Async Subtree API & & work In Progress . type ! = null & & work In Progress . type . prototype ! = null & & work In Progress . type . prototype . unstable _is Async React Component = = = true ) { work In Progress . internal Context Tag | = Async Updates ; } if ( typeof instance . component Will Mount = = = 'function ' ) { call Component Will Mount ( work In Progress , instance ) ; 
function commit Unmount ( current ) { if ( typeof on Commit Unmount = = = 'function ' ) { on Commit Unmount ( current ) ; } switch ( current . tag ) { case Class Component : { safely Detach Ref ( current ) ; var instance = current . state Node ; if ( typeof instance . component Will Unmount = = = 'function ' ) { safely Call Component Will Unmount ( current , instance ) ; } return ; } case Host Component : { safely Detach Ref ( current ) ; return ; } case Call Component : { commit Nested Unmounts ( current . state Node ) ; return ; } case Host Portal : { 
function request Work ( root , expiration Time ) { if ( nested Update Count > NESTED _UPDATE _LIMIT ) { invariant ( false , 'Maximum update depth exceeded . This can happen when a component repeatedly calls set State inside component Will Update or component Did Update . React limits the number of nested updates to prevent infinite loops . ' ) ; } 
function should Yield ( ) { if ( deadline = = = null ) { return false ; } if ( deadline . time Remaining ( ) > time Heuristic For Unit Of Work ) { return false ; } deadline Did Expire = true ; return true ; } 
function batched Updates ( fn , a ) { var previous Is Batching Updates = is Batching Updates ; is Batching Updates = true ; try { return fn ( a ) ; } finally { is Batching Updates = previous Is Batching Updates ; if ( ! is Batching Updates & & ! is Rendering ) { perform Work ( Sync , null ) ; } } } 
function unbatched Updates ( fn ) { if ( is Batching Updates & & ! is Unbatching Updates ) { is Unbatching Updates = true ; try { return fn ( ) ; } finally { is Unbatching Updates = false ; } } return fn ( ) ; } 
function flush Sync ( fn ) { var previous Is Batching Updates = is Batching Updates ; is Batching Updates = true ; try { return sync Updates ( fn ) ; } finally { is Batching Updates = previous Is Batching Updates ; ! ! is Rendering ? invariant ( false , 'flush Sync was called from inside a lifecycle method . It cannot be called when React is already rendering . ' ) : void 0 ; perform Work ( Sync , null ) ; } } 
function set Value For Property ( node , name , value ) { var property Info = get Property Info ( name ) ; if ( property Info & & should Set Attribute ( name , value ) ) { var mutation Method = property Info . mutation Method ; if ( mutation Method ) { mutation Method ( node , value ) ; } else if ( should Ignore Value ( property Info , value ) ) { delete Value For Property ( node , name ) ; return ; } else if ( property Info . must Use Property ) { 
function delete Value For Property ( node , name ) { var property Info = get Property Info ( name ) ; if ( property Info ) { var mutation Method = property Info . mutation Method ; if ( mutation Method ) { mutation Method ( node , undefined ) ; } else if ( property Info . must Use Property ) { var prop Name = property Info . property Name ; if ( property Info . has Boolean Value ) { node [ prop Name ] = false ; } else { node [ prop Name ] = ' ' ; } } else { node . remove Attribute ( property Info . attribute Name ) ; } } else { node . remove Attribute ( name ) ; } } 
function get Host Props ( element , props ) { var node = element ; var value = props . value ; var checked = props . checked ; var host Props = _assign ( { 
function update Properties $ 1 ( dom Element , update Payload , tag , last Raw Props , next Raw Props ) { var was Custom Component Tag = is Custom Component ( tag , last Raw Props ) ; var is Custom Component Tag = is Custom Component ( tag , next Raw Props ) ; 
function Pure Component ( props , context , updater ) { 
function clone Element ( element , config , children ) { var prop Name ; 
function validate Prop Types ( element ) { var component Class = element . type ; if ( typeof component Class ! = = 'function ' ) { return ; } var name = component Class . display Name | | component Class . name ; var prop Types = component Class . prop Types ; if ( prop Types ) { currently Validating Element = element ; check Prop Types ( prop Types , element . props , 'prop ' , name , get Stack Addendum ) ; currently Validating Element = null ; } if ( typeof component Class . get Default Props = = = 'function ' ) { warning ( component Class . get Default Props . is React Class Approved , 'get Default Props is only used on classic React .create Class ' + 'definitions . Use a static property named `default Props ` instead . ' ) ; } } 
function validate Fragment Props ( fragment ) { currently Validating Element = fragment ; var _iterator Normal Completion = true ; var _did Iterator Error = false ; var _iterator Error = undefined ; try { for ( var _iterator = Object . keys ( fragment . props ) [ Symbol . iterator ] ( ) , _step ; ! ( _iterator Normal Completion = ( _step = _iterator . next ( ) ) . done ) ; _iterator Normal Completion = true ) { var key = _step . value ; if ( ! VALID _FRAGMENT _PROPS . has ( key ) ) { warning ( false , 'Invalid prop ` %s ` supplied to `React .Fragment ` . ' + 'React .Fragment can only have `key ` and `children ` props . %s ' , key , get Stack Addendum ( ) ) ; break ; } } } catch ( err ) { _did Iterator Error = true ; _iterator Error = err ; } finally { try { if ( ! _iterator Normal Completion & & _iterator [ 'return ' ] ) { _iterator [ 'return ' ] ( ) ; } } finally { if ( _did Iterator Error ) { throw _iterator Error ; } } } if ( fragment . ref ! = = null ) { warning ( false , 'Invalid attribute `ref ` supplied to `React .Fragment ` . %s ' , get Stack Addendum ( ) ) ; } currently Validating Element = null ; } 
async function sympact ( code , options ) { if ( typeof code ! = = 'string ' ) { throw new Type Error ( "The 'code ' paramater must a string ' " ) ; } if ( typeof options = = = 'undefined ' ) { options = { } ; } if ( typeof options ! = = 'object ' ) { throw new Type Error ( "The 'options ' paramater must an object ' " ) ; } const interval = options . interval | | 1 2 5 ; const cwd = options . cwd | | path . dirname ( caller ( ) ) ; if ( interval < 1 ) { throw new Type Error ( "The 'interval ' paramater must be greater than 0 ' " ) ; } return new Promise ( ( resolve , reject ) = > { const slave = new Worker ( code , cwd ) ; const probe = new Profiler ( slave . pid ( ) , interval ) ; slave . on ( 'ready ' , async ( ) = > { await probe . watch ( ) ; slave . run ( ) ; } ) ; slave . on ( 'after ' , async ( start , end ) = > { await probe . unwatch ( ) ; slave . kill ( ) ; resolve ( probe . report ( start , end ) ) ; } ) ; slave . on ( 'error ' , async err = > { await probe . unwatch ( ) ; slave . kill ( ) ; reject ( err ) ; } ) ; } ) ; } 
function Backoff Strategy ( options ) { options = options | | { } ; if ( is Def ( options . initial Delay ) & & options . initial Delay < 1 ) { throw new Error ( 'The initial timeout must be greater than 0 . ' ) ; } else if ( is Def ( options . max Delay ) & & options . max Delay < 1 ) { throw new Error ( 'The maximal timeout must be greater than 0 . ' ) ; } this . initial Delay _ = options . initial Delay | | 1 0 0 ; this . max Delay _ = options . max Delay | | 1 0 0 0 0 ; if ( this . max Delay _ < = this . initial Delay _ ) { throw new Error ( 'The maximal backoff delay must be ' + 'greater than the initial backoff delay . ' ) ; } if ( is Def ( options . randomisation Factor ) & & ( options . randomisation Factor < 0 | | options . randomisation Factor > 1 ) ) { throw new Error ( 'The randomisation factor must be between 0 and 1 . ' ) ; } this . randomisation Factor _ = options . randomisation Factor | | 0 ; } 
function Exponential Backoff Strategy ( options ) { Backoff Strategy . call ( this , options ) ; this . backoff Delay _ = 0 ; this . next Backoff Delay _ = this . get Initial Delay ( ) ; this . factor _ = Exponential Backoff Strategy . DEFAULT _FACTOR ; if ( options & & options . factor ! = = undefined ) { precond . check Argument ( options . factor > 1 , 'Exponential factor should be greater than 1 but got %s . ' , options . factor ) ; this . factor _ = options . factor ; } } 
function Backoff ( backoff Strategy ) { events . Event Emitter . call ( this ) ; this . backoff Strategy _ = backoff Strategy ; this . max Number Of Retry _ = - 1 ; this . backoff Number _ = 0 ; this . backoff Delay _ = 0 ; this . timeout ID _ = - 1 ; this . handlers = { backoff : this . on Backoff _ . bind ( this ) } ; } 
function Function Call ( fn , args , callback ) { events . Event Emitter . call ( this ) ; precond . check Is Function ( fn , 'Expected fn to be a function . ' ) ; precond . check Is Array ( args , 'Expected args to be an array . ' ) ; precond . check Is Function ( callback , 'Expected callback to be a function . ' ) ; this . function _ = fn ; this . arguments _ = args ; this . callback _ = callback ; this . last Result _ = [ ] ; this . num Retries _ = 0 ; this . backoff _ = null ; this . strategy _ = null ; this . fail After _ = - 1 ; this . retry Predicate _ = Function Call . DEFAULT _RETRY _PREDICATE _ ; this . state _ = Function Call . State _ . PENDING ; } 
function Channel ( connection , name , options ) { options | | ( options = { } ) ; options . capped = true ; 
function Connection ( uri , options ) { var self = this ; options | | ( options = { } ) ; options . auto Reconnect ! = null | | ( options . auto Reconnect = true ) ; 
function add Load Event ( func ) { 'use strict ' ; var oldonload = window . onload ; if ( typeof window . onload ! = = 'function ' ) { window . onload = func ; } else { window . onload = function ( ) { oldonload ( ) ; func ( ) ; } ; } } 
function is Try Body ( path , { stack Offset = 0 } = { } ) { const node = path . get Parent Node ( stack Offset - 1 ) const parent = path . get Parent Node ( stack Offset ) const grandparent = path . get Parent Node ( stack Offset + 1 ) const greatgrandparent = path . get Parent Node ( stack Offset + 2 ) if ( parent . type = = = 'Try Statement ' & & node = = = parent . block ) { return true } if ( single Expression Block ( parent ) & & grandparent . type = = = 'Try Statement ' & & parent = = = grandparent . block ) { return true } if ( parent . type = = = 'Expression Statement ' & & single Expression Block ( grandparent ) & & greatgrandparent . type = = = 'Try Statement ' & & grandparent = = = greatgrandparent . block ) { return true } return false } 
function handle If Statement Comments ( text , preceding Node , enclosing Node , following Node , comment ) { if ( ! enclosing Node | | ! ( enclosing Node . type = = = 'If Statement ' | | enclosing Node . type = = = 'Conditional Expression ' ) | | ! following Node ) { return false } if ( preceding Node = = = enclosing Node . consequent & & following Node = = = enclosing Node . alternate ) { 
function parse ( text ) { 
function Draggable ( target , options ) { if ( ! ( this instanceof Draggable ) ) { return new Draggable ( target , options ) ; } var that = this ; 
function q ( str ) { if ( Array . is Array ( str ) ) { return str . map ( q ) . reduce ( function ( prev , curr ) { return prev . concat ( curr ) ; } , [ ] ) ; } else if ( str instanceof HTMLElement ) { return [ str ] ; } else { return [ ] . slice . call ( document . query Selector All ( str ) ) ; } } 
function Functor ( name , args ) { let _name = name ; let _args = args ; let _args Count = 0 ; let _variable Hash = null ; if ( typeof _args = = = 'undefined ' ) { _args = [ ] ; } else { _args Count = args . length ; } this . get Name = function get Name ( ) { return _name ; } ; this . get Id = function get Id ( ) { return _name + ' / ' + _args Count ; } ; this . evaluate = function evaluate ( ) { return this . to String ( ) ; } ; this . get Goal = function get Goal ( ) { return this ; } ; this . get Argument Count = function get Argument Count ( ) { return _args Count ; } ; this . get Variables = function get Variables ( ) { return Object . keys ( this . get Variable Hash ( ) ) ; } ; this . get Variable Hash = function get Variable Hash ( existing Hash ) { let hash = existing Hash ; if ( _variable Hash ! = = null ) { if ( hash = = = undefined ) { return _variable Hash ; } Object . keys ( _variable Hash ) . for Each ( ( v ) = > { hash [ v ] = true ; } ) ; return hash ; } if ( hash = = = undefined ) { hash = { } ; } let stored Hash = { } ; _args . for Each ( ( arg ) = > { arg . get Variable Hash ( hash ) ; arg . get Variable Hash ( stored Hash ) ; } ) ; _variable Hash = stored Hash ; return hash ; } ; this . is Ground = function is Ground ( ) { let result = true ; for ( let i = 0 ; i < _args Count ; i + = 1 ) { let arg = _args [ i ] ; if ( ! arg . is Ground ( ) ) { result = false ; break ; } } return result ; } ; this . get Arguments = function get Arguments ( ) { 
function Conjunction Map ( ) { let _conjunctions = [ ] ; this . add = function add ( conjunction , value ) { if ( value = = = undefined ) { return ; } let map = new Literal Tree Map ( ) ; conjunction . for Each ( ( conjunct ) = > { map . add ( conjunct ) ; } ) ; _conjunctions . push ( [ map . size ( ) , map , value ] ) ; } ; this . get = function get ( conjunction ) { let result ; for ( let i = 0 ; i < _conjunctions . length ; i + = 1 ) { let pair = _conjunctions [ i ] ; let contain Mismatch = false ; if ( conjunction . length ! = = pair [ 0 ] ) { continue ; } for ( let j = 0 ; j < conjunction . length ; j + = 1 ) { let conjunct = conjunction [ j ] ; if ( ! pair [ 1 ] . contains ( conjunct ) ) { contain Mismatch = true ; break ; } } if ( ! contain Mismatch ) { result = pair [ 2 ] ; break ; } } return result ; } ; } 
function Profiler ( ) { let _values = { } ; this . reset = function reset ( key ) { _values [ key ] = 0 ; } ; this . increment = function increment ( key ) { if ( _values [ key ] = = = undefined | | typeof _values [ key ] ! = = 'number ' ) { return ; } _values [ key ] + = 1 ; } ; this . increase By = function increase By ( key , value ) { if ( _values [ key ] = = = undefined | | typeof _values [ key ] ! = = 'number ' ) { return ; } _values [ key ] + = value ; } ; this . set = function set ( key , value ) { _values [ key ] = value ; } ; this . add = function add ( key , value ) { if ( _values [ key ] = = = undefined | | ! Array . is Array ( _values [ key ] ) ) { return ; } _values [ key ] . push ( value ) ; } ; this . get = function get ( key ) { return _values [ key ] ; } ; } 
function sort Timables ( conjunction , for Time ) { let early Conjuncts = [ ] ; let later Conjuncts = [ ] ; let dependent Time Variables = { } ; 
function Ast Node ( type , token ) { let _type = type ; let _token = token ; let _children = [ ] ; this . get Type = function get Type ( ) { return _type ; } ; this . get Token = function get Token ( ) { return _token ; } ; this . get Children = function get Children ( ) { return _children ; } ; this . set Token = function set Token ( t ) { _token = t ; } ; this . is Leaf = function is Leaf ( ) { return _children . length = = = 0 ; } ; this . add Child = function add Child ( child Node ) { _children . push ( child Node ) ; } ; this . print = function print ( n Arg ) { let n = n Arg ; if ( ! n ) { n = 0 ; } console . log ( ' ' . repeat ( n ) + String ( _type ) + ( _token ? ( ' : ' + _token . value ) : ' ' ) ) ; n + = 1 ; _children . for Each ( ( child ) = > { child . print ( n ) ; } ) ; } ; } 
function ( program Args ) { let _program Args = program Args ; if ( program Args = = = undefined ) { _program Args = [ ] ; } 
function create Program Args Updater Func ( program Args ) { return ( program ) = > { let program Args Fact = build Program Args Predicate ( program Args ) ; program . get Facts ( ) . add ( program Args Fact ) ; return Promise . resolve ( program ) ; } ; } 
function List ( head , tail ) { let _head = head ; let _tail = tail ; let _variable Hash = null ; if ( tail = = = undefined ) { * Get the head of the list * @return {Array } Return the array representing the head of the list * / this . get Head = function get Head ( ) { return _head . concat ( ) ; } ; this . get Tail = function get Tail ( ) { return _tail ; } ; this . is Ground = function is Ground ( ) { if ( _tail ! = = null ) { return _tail . is Ground ( ) ; } for ( let i = 0 ; i < _head . length ; i + = 1 ) { if ( ! _head [ i ] . is Ground ( ) ) { return false ; } } return true ; } ; this . get Variables = function get Variables ( ) { return Object . keys ( this . get Variable Hash ( ) ) ; } ; this . get Variable Hash = function get Variable Hash ( existing Hash ) { let hash = existing Hash ; if ( _variable Hash ! = = null ) { if ( hash = = = undefined ) { return _variable Hash ; } Object . keys ( _variable Hash ) . for Each ( ( v ) = > { hash [ v ] = true ; } ) ; return hash ; } * Perform a substitution on this term . * @param {Object } theta The substitution theta * @return {List } Return the substituted list * / this . substitute = function substitute ( theta ) { let new Head = head . map ( ( element ) = > { return element . substitute ( theta ) ; } ) ; let new Tail = _tail ; if ( new Tail instanceof List | | new Tail instanceof Variable ) { new Tail = new Tail . substitute ( theta ) ; } return new List ( new Head , new Tail ) ; } ; this . flatten = function flatten ( ) { let result = [ ] ; if ( _head . length > 0 ) { result = result . concat ( _head ) ; if ( _tail instanceof List ) { result = result . concat ( _tail . flatten ( ) ) ; } } return result ; } ; this . is Empty = function is Empty ( ) { return _head . length = = = 0 & & ( _tail instanceof List & & _tail . is Empty ( ) ) ; } ; this . to String = function to String ( ) { let result = ' ' ; result + = ' [ ' ; for ( let j = 0 ; j < _head . length ; j + = 1 ) { result + = _head [ j ] ; if ( j < _head . length - 1 ) { result + = ' , ' ; } } if ( _tail ! = = null & & ( ! ( _tail instanceof List ) | | ! _tail . is Empty ( ) ) ) { result + = ' | ' + _tail . to String ( ) ; } result + = ' ] ' ; return result ; } ; } 
function observe Processor ( engine , program ) { let result = engine . query ( observe Literal ) ; result . for Each ( ( r ) = > { if ( r . theta . O = = = undefined | | r . theta . ST = = = undefined | | r . theta . ET = = = undefined ) { 
function Manager ( ) { let _events = { } ; this . add Listener = function add Listener ( event , listener ) { if ( _events [ event ] = = = undefined ) { _events [ event ] = [ ] ; } _events [ event ] . push ( listener ) ; } ; this . clear Listeners = function clear Listeners ( event ) { delete _events [ event ] ; } ; this . notify = function notify ( event , sender ) { if ( _events [ event ] = = = undefined ) { return Promise . resolve ( ) ; } _events [ event ] . for Each ( ( listener ) = > { listener ( sender ) ; } ) ; return Promise . resolve ( ) ; } ; } 
function process Cycle Observations ( ) { let active Observations = new Literal Tree Map ( ) ; if ( _observations [ _current Time ] = = = undefined ) { 
function actions Selector ( goal Trees ) { const recursive Actions Selector = ( actions So Far , program So Far , l ) = > { if ( l > = goal Trees . length ) { let actions = new Literal Tree Map ( ) ; actions So Far . for Each ( ( map ) = > { map . for Each ( ( literal ) = > { actions . add ( literal ) ; } ) ; } ) ; return actions ; } let goal Tree = goal Trees [ l ] ; let result Set = null ; goal Tree . for Each Candidate Actions ( _current Time , ( candidate Actions ) = > { let clone Program = program So Far . clone ( ) ; let clone Executed Actions = clone Program . get Executed Actions ( ) ; candidate Actions . for Each ( ( a ) = > { clone Executed Actions . add ( a ) ; } ) ; 
function perform Cycle ( ) { _current Time + = 1 ; let selected And Executed Actions = new Literal Tree Map ( ) ; let executed Observations = new Literal Tree Map ( ) ; 
function apply Args ( func , this Obj , args ) { return func . apply ( this Obj , Array . prototype . slice . call ( args ) ) ; } 
function define ( ) { var this Flow = function ( ) { apply Args ( this Flow . exec , this Flow , arguments ) ; } this Flow . blocks = arguments ; this Flow . exec = function ( ) { 
function ( ) { if ( flow State . _ _frozen ) return ; if ( flow State . _ _timeout Id ) { clear Timeout ( flow State . _ _timeout Id ) ; delete flow State . _ _timeout Id ; } var block Idx = flow State . _ _next Block Idx + + ; var block = this Flow . blocks [ block Idx ] ; if ( block = = = undefined ) { return ; } else { apply Args ( block , flow State , arguments ) ; } } 
function exec ( ) { var flow = typeof exports ! = 'undefined ' ? exports : window . flow ; apply Args ( flow . define , flow , arguments ) ( ) ; } 
function any Error ( results ) { var r , _i , _len ; for ( _i = 0 , _len = results . length ; _i < _len ; _i + + ) { r = results [ _i ] ; if ( r [ 0 ] ) { return r [ 0 ] ; } } return null ; } 
function pad Start ( str , length , pad Char ) { if ( str . length > = length ) { return str ; } else { return pad Char . repeat ( length - str . length ) + str ; } } 
function SM 2Curve ( params ) { if ( ! ( this instanceof SM 2Curve ) ) { return new SM 2Curve ( params ) ; } elliptic . curve . short . call ( this , params ) ; } 
function _sm 2Point ( x , y , parity ) { if ( x = = null ) { return SM 2 . point ( ) ; } var pt ; if ( y ! = null ) { pt = SM 2 . point ( x , y ) ; if ( ! SM 2 . validate ( pt ) ) { throw 'point is not on curve ' ; } } else { var px = new BN ( x , 1 6 ) . to Red ( SM 2 . red ) ; var py = px . red Sqr ( ) . red Mul ( px ) ; py = py . red IAdd ( px . red Mul ( SM 2 . a ) ) . red IAdd ( SM 2 . b ) . red Sqrt ( ) ; if ( ( parity = = = 'odd ' ) ! = py . from Red ( ) . is Odd ( ) ) { py = py . red Neg ( ) ; } pt = SM 2 . point ( px , py ) ; } return pt ; } 
function SM 2Key Pair ( pub , pri ) { if ( ! ( this instanceof SM 2Key Pair ) ) { return new SM 2Key Pair ( pub , pri ) ; } this . curve = SM 2 ; 
function ( ) { this . _default _baud _rate = 5 7 6 0 0 ; this . _baud _rate = 5 7 6 0 0 ; this . _path = ' ' ; this . _devices = { } ; this . _port = null ; this . _telegram _buffer = null ; this . _gateway = null ; m Event Emitter . call ( this ) ; } 
function gulp Static I 1 8n ( options ) { return through . obj ( function ( target , encoding , cb ) { var stream = this ; var build = new Static I 1 8n ( target , options , stream ) ; build . translate ( cb ) ; } ) ; } 
function ( obj , type , fn , scope ) { scope = scope | | obj ; var wrapped Fn = function ( e ) { fn . call ( scope , e ) ; } ; obj . add Event Listener ( type , wrapped Fn , false ) ; cache . push ( [ obj , type , fn , wrapped Fn ] ) ; } 
function ( obj , type , fn ) { var wrapped Fn , item , len = cache . length , i ; for ( i = 0 ; i < len ; i + + ) { item = cache [ i ] ; if ( item [ 0 ] = = = obj & & item [ 1 ] = = = type & & item [ 2 ] = = = fn ) { wrapped Fn = item [ 3 ] ; if ( wrapped Fn ) { obj . remove Event Listener ( type , wrapped Fn , false ) ; cache = cache . slice ( i ) ; return true ; } } } } 
function ( obj , type , fn , scope ) { scope = scope | | obj ; var wrapped Fn = function ( ) { var e = window . event ; e . target = e . target | | e . src Element ; e . prevent Default = function ( ) { e . return Value = false ; } ; fn . call ( scope , e ) ; } ; obj . attach Event ( 'on ' + type , wrapped Fn ) ; cache . push ( [ obj , type , fn , wrapped Fn ] ) ; } 
function ( obj , type , fn ) { var wrapped Fn , item , len = cache . length , i ; for ( i = 0 ; i < len ; i + + ) { item = cache [ i ] ; if ( item [ 0 ] = = = obj & & item [ 1 ] = = = type & & item [ 2 ] = = = fn ) { wrapped Fn = item [ 3 ] ; if ( wrapped Fn ) { obj . detach Event ( 'on ' + type , wrapped Fn ) ; cache = cache . slice ( i ) ; return true ; } } } } 
function View ( model ) { var wrapper ; this . el = wrapper = document . create Element ( 'div ' ) ; this . model = model ; this . is Showing = false ; 
function Product ( data ) { data . quantity = parser . quantity ( data . quantity ) ; data . amount = parser . amount ( data . amount ) ; data . href = parser . href ( data . href ) ; this . _data = data ; this . _options = null ; this . _discount = null ; this . _amount = null ; this . _total = null ; Pubsub . call ( this ) ; } 
function Cart ( name , duration ) { var data , items , settings , len , i ; this . _items = [ ] ; this . _settings = { bn : constants . BN } ; Pubsub . call ( this ) ; Storage . call ( this , name , duration ) ; if ( ( data = this . load ( ) ) ) { items = data . items ; settings = data . settings ; if ( settings ) { this . _settings = settings ; } if ( items ) { for ( i = 0 , len = items . length ; i < len ; i + + ) { this . add ( items [ i ] ) ; } } } } 
function ( opts ) { 
function ( opts ) { var wrapper = path . join ( ROOT , 'gradlew ' ) ; var args = this . get Args ( opts . build Type = = 'debug ' ? 'debug ' : 'release ' , opts ) ; return Q ( ) . then ( function ( ) { console . log ( 'Running : ' + wrapper + ' ' + args . join ( ' ' ) ) ; return spawn ( wrapper , args ) ; } ) ; } 
function on Rejected ( error ) { attemts _left - = 1 ; if ( attemts _left < 1 ) { throw error ; } console . log ( "A retried call failed . Retrying " + attemts _left + " more time (s ) . " ) ; 
function collect Dependencies ( bower Json , dependencies ) { if ( bower Json ! = null & & bower Json ! = undefined ) { if ( bower Json . has Own Property ( "dependencies " ) ) { var dependencies Json = bower Json . dependencies ; var dependencis Keys = Object . keys ( dependencies Json ) ; var key ; for ( key in dependencis Keys ) { var dependecy Json = dependencies Json [ dependencis Keys [ key ] ] ; var dependency = create Dependency ( dependecy Json ) ; if ( dependency ! = null ) { dependencies . push ( dependency ) ; collect Dependencies ( dependecy Json , dependencies ) ; } } } } } 
function create Tree ( entries , callback ) { if ( ! callback ) return create Tree . bind ( repo , entries ) ; var to Delete = entries . base & & entries . filter ( function ( entry ) { return ! entry . mode ; } ) . map ( function ( entry ) { return entry . path ; } ) ; var to Create = entries . filter ( function ( entry ) { return bodec . is Binary ( entry . content ) ; } ) ; if ( ! to Create . length ) return next ( ) ; var done = false ; var left = entries . length ; to Create . for Each ( function ( entry ) { repo . save As ( "blob " , entry . content , function ( err , hash ) { if ( done ) return ; if ( err ) { done = true ; return callback ( err ) ; } delete entry . content ; entry . hash = hash ; left - - ; if ( ! left ) next ( ) ; } ) ; } ) ; function next ( err ) { if ( err ) return callback ( err ) ; if ( to Delete & & to Delete . length ) { return slow Update Tree ( entries , to Delete , callback ) ; } return fast Update Tree ( entries , callback ) ; } } 
function slow Update Tree ( entries , to Delete , callback ) { callback = single Call ( callback ) ; var root = entries . base ; var left = 0 ; 
function fix Date ( type , value , hash ) { if ( type ! = = "commit " & & type ! = = "tag " ) return ; 
function to Global Coordinates ( svgdoc : any , elem : any , x : number , y : number ) { var offset = svgdoc . get Bounding Client Rect ( ) ; var matrix = elem . get Screen CTM ( ) ; return { x : matrix . a * x + matrix . c * y + matrix . e - offset . left , y : matrix . b * x + matrix . d * y + matrix . f - offset . top } ; } 
function get Angle For Point ( x : number , y : number ) { if ( x = = 0 & & y = = 0 ) return 0 ; const angle = Math . atan ( x / y ) ; let angle Deg = angle * 1 8 0 / Math . PI ; 
function transform Bounding Client Rect To Document ( box ) { var t ; const scroll X = ( ( ( t = document . document Element ) | | ( t = document . body . parent Node ) ) & & typeof t . scroll Left = = "number " ? t : document . body ) . scroll Left ; const scroll Y = ( ( ( t = document . document Element ) | | ( t = document . body . parent Node ) ) & & typeof t . scroll Top = = "number " ? t : document . body ) . scroll Top ; 
function ( position , handle Width ) { if ( position = = = "stick To Sides " ) { _naked _bar _deltas = { to End Width : handle Width , to Begin Left : 0 , to Begin Width : handle Width } ; } else if ( position = = = "middle " ) { 
function ( next Left Grip Position Px , next Right Grip Position Px ) { var $this = this ; var draggable Area Length Px = _methods . get Slider Width Px . call ( $this ) - $this . data ( 'left _grip _width ' ) ; 
function ( ) { var $this = this , settings = $this . data ( 'settings ' ) , $left Grip = $this . find ( settings . left _grip _selector ) ; 
function ( ) { var $this = this , settings = $this . data ( 'settings ' ) ; if ( $this . data ( 'has _right _grip ' ) ) { return _methods . get Grip Position Px . call ( $this , $this . find ( settings . right _grip _selector ) ) ; } 
function ( array , search Element , get Element Func , compare Func ) { var min Index = 0 ; var max Index = array . length - 1 ; var current Index ; var current Element ; while ( min Index < = max Index ) { current Index = ( min Index + max Index ) / 2 | 0 ; current Element = get Element Func ( array , current Index ) ; 
function ( ) { var $this = this , lower Limit = $this . data ( 'lower -limit ' ) , upper Limit = $this . data ( 'upper -limit ' ) , have Limits = false ; if ( typeof lower Limit ! = = 'undefined ' & & typeof upper Limit ! = = 'undefined ' ) { have Limits = true ; } return have Limits ; } 
function ( ) { var $this = this , settings = $this . data ( 'settings ' ) ; 
function ( cur _min , cur _max ) { var $this = this ; 
function ( left Px , right Px ) { var $this = this ; 
function ( left Px , right Px ) { var $this = this ; var settings = $this . data ( 'settings ' ) ; var left _grip _selector = settings . left _grip _selector , right _grip _selector = settings . right _grip _selector , value _bar _selector = settings . value _bar _selector ; var handle Width = $this . data ( 'left _grip _width ' ) ; 
function ( search , array , current Idx ) { 
function ( is Left Grip ) { var $this = this , current _min _value = methods . get _current _min _value . call ( $this ) , current _max _value = methods . get _current _max _value . call ( $this ) , did Values Change = false ; 
function ( cause , prev Min , prev Max ) { var $this = this ; var force = false ; if ( cause = = = 'init ' | | cause = = = 'refresh ' ) { force = true ; } var cur Min = methods . get _current _min _value . call ( $this ) , cur Max = methods . get _current _max _value . call ( $this ) ; if ( ! force ) { prev Min = methods . round _value _according _to _rounding . call ( $this , prev Min ) ; prev Max = methods . round _value _according _to _rounding . call ( $this , prev Max ) ; } if ( force | | cur Min ! = = prev Min | | cur Max ! = = prev Max ) { _methods . notify _changed _explicit . call ( $this , cause , prev Min , prev Max , cur Min , cur Max ) ; force = 1 ; } return force ; } 
function ( val , n ) { var $this = this ; var range Min = $this . data ( 'range _min ' ) ; var range Max = $this . data ( 'range _max ' ) ; if ( val < = range Min ) { return 0 ; } if ( val > = range Max ) { return n ; } return Math . floor ( ( n * val - n * range Min ) / ( range Max - range Min ) ) ; } 
function ( val , max ) { var $this = this ; var range Min = $this . data ( 'range _min ' ) ; var range Max = $this . data ( 'range _max ' ) ; if ( val < = 0 ) { return range Min ; } if ( val > = max ) { return range Max ; } 
function ( ) { var $this = this ; 
function ( ) { var $this = this ; 
function ( min , max ) { var $this = this ; var prev _min = $this . data ( 'cur _min ' ) , prev _max = $this . data ( 'cur _max ' ) ; if ( min > max ) { _methods . set _position _from _val . call ( $this , max , min ) ; } else { _methods . set _position _from _val . call ( $this , min , max ) ; } 
function ( histogram ) { var $this = this ; $this . data ( 'last _step _histogram ' , histogram ) ; if ( typeof histogram = = = 'undefined ' ) { $ . error ( 'got an undefined histogram in set _step _histogram ' ) ; _methods . unset _step _histogram . call ( $this ) ; } var slider Width Px = _methods . get Slider Width Px . call ( $this ) - $this . data ( 'left _grip _width ' ) , nbuckets = histogram . length ; if ( slider Width Px < = 0 ) { 
function ( range Min , range Max ) { var $this = this ; var settings = $this . data ( 'settings ' ) ; if ( typeof settings . highlight = = = "undefined " ) { $ . error ( 'you cannot call highlight _range if you haven \ ' specified the "highlight " parameter in construction ! ' ) ; } / / avoid empty string if ( ! range Min ) { range Min = 0 ; } if ( ! range Max ) { range Max = 0 ; } / / we need to map range Min and range Max into pixels . var left Px = methods . value _to _px . call ( $this , range Min ) , right Px = methods . value _to _px . call ( $this , range Max ) , bar Width = right Px - left Px + $this . data ( 'left _grip _width ' ) ; / / set position var $highlight Panel = $this . find ( settings . highlight . panel _selector ) ; $highlight Panel . css ( 'left ' , left Px + "px " ) ; $highlight Panel . css ( 'width ' , bar Width + "px " ) ; / / keep the latest highlighted range , because if set _range is called / / we must be able to update the highlighting . $this . data ( 'highlighted Range Min ' , range Min ) ; $this . data ( 'highlighted Range Max ' , range Max ) ; 
function ( rounding ) { var $this = this ; if ( typeof rounding = = = 'string ' & & rounding . index Of ( ' { ' ) > - 1 ) { 
function ( v ) { var $this = this ; var rounding = _methods . get _rounding _for _value . call ( $this , v ) ; if ( rounding > 0 ) { 
function ( value ) { var $this = this , value _to _pixel _mapping _func = $this . data ( 'value _to _pixel _mapping ' ) ; 
function append ( field Name , props , append Token ) { var params = ' ' ; var not First = false ; field Name + = ' . ' ; for ( var key in props ) { var obj = props [ key ] ; if ( not First ) params + = append Token ; else not First = true ; params + = field Name + key + ' = { ' + key + ' } ' ; } return params ; } 
function remove ( field Name , props ) { var removes = ' ' , not First = false , i = props . length ; field Name + = ' . ' ; while ( i - - ) { if ( not First ) { removes + = ' , ' ; } else { not First = true ; } removes + = field Name + props [ i ] ; } return removes ; } 
function where Set Properties ( field Name , old Props , new Props ) { var prefix = 'x Q _ ' , where Clause = ' ' , set Clause = ' ' , not First = false , props = { } , i = 0 , obj ; field Name + = ' . ' ; 
function labels ( array ) { var res = ' ' ; if ( typeof array = = = 'string ' ) { return ' : ' + array ; } for ( var i = 0 ; i < array . length ; i + + ) { res + = ' : ' + array [ i ] ; } return res ; } 
function ( node _id , node _data , callback ) { var that = this ; request . put ( that . url + ' /db /data /node / ' + node _id + ' /properties ' ) . set ( this . header ) . send ( that . stringify Value Objects ( that . replace Null With String ( node _data ) ) ) . end ( function ( result ) { switch ( result . status Code ) { case 2 0 4 : callback ( null , true ) ; break ; case 4 0 4 : callback ( null , false ) ; break ; default : callback ( new Error ( 'HTTP Error ' + result . status Code + ' when updating a Node . ' ) , null ) ; } } ) ; } 
function ( label , property _key , callback ) { var that = this ; var val = new Validator ( ) ; val . label ( label ) . property ( property _key ) ; if ( val . has Errors ) { return callback ( val . error ( ) , null ) ; } request . post ( that . url + ' /db /data /schema /constraint / ' + label + ' /uniqueness ' ) . set ( this . header ) . send ( { 'property _keys ' : [ property _key ] } ) . end ( function ( result ) { switch ( result . status Code ) { case 2 0 0 : callback ( null , result . body ) ; break ; case 4 0 9 : callback ( null , false ) ; 
function ( node _id , options , callback ) { var that = this ; if ( typeof options = = = 'function ' ) { callback = options ; } var url = that . url + ' /db /data /node / ' + node _id + ' /relationships / ' ; 
function Client ( options ) { if ( ! ( this instanceof Client ) ) { return new Client ( options ) ; } const self = this ; this . set Option = function ( option , value ) { self . options [ option ] = value ; } ; this . set Position = function ( latitude , longitude , accuracy , altitude ) { if ( typeof latitude = = = 'object ' ) { const pos = latitude ; latitude = pos . latitude ; longitude = pos . longitude ; accuracy = pos . accuracy ; altitude = pos . altitude ; } self . player Latitude = latitude ; self . player Longitude = longitude ; self . player Location Accuracy = accuracy | | 0 ; self . player Altitude = altitude | | 0 ; } ; this . init = function ( download Settings ) { * Sets batch mode . All further API requests will be held and executed in one RPC call when * { @link #batch Call } is called . * @return {Client } this * / this . batch Start = function ( ) { if ( ! self . batch Requests ) { self . batch Requests = [ ] ; } return self ; } ; this . batch Clear = function ( ) { delete self . batch Requests ; } ; this . batch Call = function ( ) { var p = self . call RPC ( self . batch Requests | | [ ] ) ; self . batch Clear ( ) ; return p ; } ; this . get Signature Rate Info = function ( ) { return self . signature Builder . rate Infos ; } ; this . get Player = function ( country , language , timezone ) { return self . call Or Chain ( { type : Request Type . GET _PLAYER , message : new Request Messages . Get Player Message ( { player _locale : { country : country , language : language , timezone : timezone } } ) , response Type : Responses . Get Player Response } ) ; } ; this . get Inventory = function ( last Timestamp ) { return self . call Or Chain ( { type : Request Type . GET _INVENTORY , message : new Request Messages . Get Inventory Message ( { last _timestamp _ms : last Timestamp } ) , response Type : Responses . Get Inventory Response } ) ; } ; this . download Settings = function ( hash ) { return self . call Or Chain ( { type : Request Type . DOWNLOAD _SETTINGS , message : new Request Messages . Download Settings Message ( { hash : hash } ) , response Type : Responses . Download Settings Response } ) ; } ; this . download Item Templates = function ( paginate , page Offset , page Timestamp ) { return self . call Or Chain ( { type : Request Type . DOWNLOAD _ITEM _TEMPLATES , message : new Request Messages . Download Item Templates Message ( { paginate : paginate , page _offset : page Offset , page _timestamp : page Timestamp } ) , response Type : Responses . Download Item Templates Response } ) ; } ; this . download Remote Config Version = function ( platform , device Manufacturer , device Model , locale , app Version ) { return self . call Or Chain ( { type : Request Type . DOWNLOAD _REMOTE _CONFIG _VERSION , message : new Request Messages . Download Remote Config Version Message ( { platform : platform , device _manufacturer : device Manufacturer , device _model : device Model , locale : locale , app _version : app Version } ) , response Type : Responses . Download Remote Config Version Response } ) ; } ; this . register Background Device = function ( device Type , device ID ) { return self . call Or Chain ( { type : Request Type . REGISTER _BACKGROUND _DEVICE , message : new Request Messages . Register Background Device Message ( { device _type : device Type , device _id : device ID } ) , response Type : Responses . Register Background Device Response } ) ; } ; this . fort Search = function ( fort ID , fort Latitude , fort Longitude ) { return self . call Or Chain ( { type : Request Type . FORT _SEARCH , message : new Request Messages . Fort Search Message ( { fort _id : fort ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude , fort _latitude : fort Latitude , fort _longitude : fort Longitude } ) , response Type : Responses . Fort Search Response } ) ; } ; this . encounter = function ( encounter ID , spawn Point ID ) { return self . call Or Chain ( { type : Request Type . ENCOUNTER , message : new Request Messages . Encounter Message ( { encounter _id : encounter ID , spawn _point _id : spawn Point ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Encounter Response } ) ; } ; this . catch Pokemon = function ( encounter ID , pokeball Item ID , normalized Reticle Size , spawn Point ID , hit Pokemon , spin Modifier , normalized Hit Position ) { return self . call Or Chain ( { type : Request Type . CATCH _POKEMON , message : new Request Messages . Catch Pokemon Message ( { encounter _id : encounter ID , pokeball : pokeball Item ID , normalized _reticle _size : normalized Reticle Size , spawn _point _id : spawn Point ID , hit _pokemon : hit Pokemon , spin _modifier : spin Modifier , normalized _hit _position : normalized Hit Position } ) , response Type : Responses . Catch Pokemon Response } ) ; } ; this . fort Details = function ( fort ID , fort Latitude , fort Longitude ) { return self . call Or Chain ( { type : Request Type . FORT _DETAILS , message : new Request Messages . Fort Details Message ( { fort _id : fort ID , latitude : fort Latitude , longitude : fort Longitude } ) , response Type : Responses . Fort Details Response } ) ; } ; this . get Map Objects = function ( cell IDs , since Timestamps ) { return self . call Or Chain ( { type : Request Type . GET _MAP _OBJECTS , message : new Request Messages . Get Map Objects Message ( { cell _id : cell IDs , since _timestamp _ms : since Timestamps , latitude : self . player Latitude , longitude : self . player Longitude } ) , response Type : Responses . Get Map Objects Response } ) ; } ; this . fort Deploy Pokemon = function ( fort ID , pokemon ID ) { return self . call Or Chain ( { type : Request Type . FORT _DEPLOY _POKEMON , message : new Request Messages . Fort Deploy Pokemon Message ( { fort _id : fort ID , pokemon _id : pokemon ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Fort Deploy Pokemon Response } ) ; } ; this . fort Recall Pokemon = function ( fort ID , pokemon ID ) { return self . call Or Chain ( { type : Request Type . FORT _RECALL _POKEMON , message : new Request Messages . Fort Recall Pokemon Message ( { fort _id : fort ID , pokemon _id : pokemon ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Fort Recall Pokemon Response } ) ; } ; this . release Pokemon = function ( pokemon IDs ) { if ( ! Array . is Array ( pokemon IDs ) ) pokemon IDs = [ pokemon IDs ] ; return self . call Or Chain ( { type : Request Type . RELEASE _POKEMON , message : new Request Messages . Release Pokemon Message ( { pokemon _id : pokemon IDs . length = = = 1 ? pokemon IDs [ 0 ] : undefined , pokemon _ids : pokemon IDs . length > 1 ? pokemon IDs : undefined } ) , response Type : Responses . Release Pokemon Response } ) ; } ; this . use Item Potion = function ( item ID , pokemon ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _POTION , message : new Request Messages . Use Item Potion Message ( { item _id : item ID , pokemon _id : pokemon ID } ) , response Type : Responses . Use Item Potion Response } ) ; } ; this . use Item Capture = function ( item ID , encounter ID , spawn Point ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _CAPTURE , message : new Request Messages . Use Item Capture Message ( { item _id : item ID , encounter _id : encounter ID , spawn _point _id : spawn Point ID } ) , response Type : Responses . Use Item Capture Response } ) ; } ; this . use Item Revive = function ( item ID , pokemon ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _REVIVE , message : new Request Messages . Use Item Revive Message ( { item _id : item ID , pokemon _id : pokemon ID } ) , response Type : Responses . Use Item Revive Response } ) ; } ; this . get Player Profile = function ( player Name ) { return self . call Or Chain ( { type : Request Type . GET _PLAYER _PROFILE , message : new Request Messages . Get Player Profile Message ( { player _name : player Name } ) , response Type : Responses . Get Player Profile Response } ) ; } ; this . evolve Pokemon = function ( pokemon ID , evolution Requirement Item ID ) { return self . call Or Chain ( { type : Request Type . EVOLVE _POKEMON , message : new Request Messages . Evolve Pokemon Message ( { pokemon _id : pokemon ID , evolution _item _requirement : evolution Requirement Item ID } ) , response Type : Responses . Evolve Pokemon Response } ) ; } ; this . get Hatched Eggs = function ( ) { return self . call Or Chain ( { type : Request Type . GET _HATCHED _EGGS , response Type : Responses . Get Hatched Eggs Response } ) ; } ; this . encounter Tutorial Complete = function ( pokemon ID ) { return self . call Or Chain ( { type : Request Type . ENCOUNTER _TUTORIAL _COMPLETE , message : new Request Messages . Encounter Tutorial Complete Message ( { pokemon _id : pokemon ID } ) , response Type : Responses . Encounter Tutorial Complete Response } ) ; } ; this . level Up Rewards = function ( level ) { return self . call Or Chain ( { type : Request Type . LEVEL _UP _REWARDS , message : new Request Messages . Level Up Rewards Message ( { level : level } ) , response Type : Responses . Level Up Rewards Response } ) ; } ; this . check Awarded Badges = function ( ) { return self . call Or Chain ( { type : Request Type . CHECK _AWARDED _BADGES , response Type : Responses . Check Awarded Badges Response } ) ; } ; this . use Item Gym = function ( item ID , gym ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _GYM , message : new Request Messages . Use Item Gym Message ( { item _id : item ID , gym _id : gym ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Use Item Gym Response } ) ; } ; this . get Gym Details = function ( gym ID , gym Latitude , gym Longitude , client Version ) { return self . call Or Chain ( { type : Request Type . GET _GYM _DETAILS , message : new Request Messages . Get Gym Details Message ( { gym _id : gym ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude , gym _latitude : gym Latitude , gym _longitude : gym Longitude , client _version : client Version } ) , response Type : Responses . Get Gym Details Response } ) ; } ; this . start Gym Battle = function ( gym ID , attacking Pokemon IDs , defending Pokemon ID ) { return self . call Or Chain ( { type : Request Type . START _GYM _BATTLE , message : new Request Messages . Start Gym Battle Message ( { gym _id : gym ID , attacking _pokemon _ids : attacking Pokemon IDs , defending _pokemon _id : defending Pokemon ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Start Gym Battle Response } ) ; } ; this . attack Gym = function ( gym ID , battle ID , attack Actions , last Retrieved Action ) { return self . call Or Chain ( { type : Request Type . ATTACK _GYM , message : new Request Messages . Attack Gym Message ( { gym _id : gym ID , battle _id : battle ID , attack _actions : attack Actions , last _retrieved _action : last Retrieved Action , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Attack Gym Response } ) ; } ; this . recycle Inventory Item = function ( item ID , count ) { return self . call Or Chain ( { type : Request Type . RECYCLE _INVENTORY _ITEM , message : new Request Messages . Recycle Inventory Item Message ( { item _id : item ID , count : count } ) , response Type : Responses . Recycle Inventory Item Response } ) ; } ; this . collect Daily Bonus = function ( ) { return self . call Or Chain ( { type : Request Type . COLLECT _DAILY _BONUS , response Type : Responses . Collect Daily Bonus Response } ) ; } ; this . use Item XPBoost = function ( item ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _XP _BOOST , message : new Request Messages . Use Item Xp Boost Message ( { item _id : item ID } ) , response Type : Responses . Use Item Xp Boost Response } ) ; } ; this . use Item Egg Incubator = function ( item ID , pokemon ID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _EGG _INCUBATOR , message : new Request Messages . Use Item Egg Incubator Message ( { item _id : item ID , pokemon _id : pokemon ID } ) , response Type : Responses . Use Item Egg Incubator Response } ) ; } ; this . use Incense = function ( item ID ) { return self . call Or Chain ( { type : Request Type . USE _INCENSE , message : new Request Messages . Use Incense Message ( { incense _type : item ID } ) , response Type : Responses . Use Incense Response } ) ; } ; this . get Incense Pokemon = function ( ) { return self . call Or Chain ( { type : Request Type . GET _INCENSE _POKEMON , message : new Request Messages . Get Incense Pokemon Message ( { player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Get Incense Pokmeon Response } ) ; } ; this . incense Encounter = function ( encounter ID , encounter Location ) { return self . call Or Chain ( { type : Request Type . INCENSE _ENCOUNTER , message : new Request Messages . Incense Encounter Message ( { encounter _id : encounter ID , encounter _location : encounter Location } ) , response Type : Responses . Incense Encounter Response } ) ; } ; this . add Fort Modifier = function ( modifier Item ID , fort ID ) { return self . call Or Chain ( { type : Request Type . ADD _FORT _MODIFIER , message : new Request Messages . Add Fort Modifier Message ( { modifier _type : modifier Item ID , fort _id : fort ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) } ) ; } ; this . disk Encounter = function ( encounter ID , fort ID ) { return self . call Or Chain ( { type : Request Type . DISK _ENCOUNTER , message : new Request Messages . Disk Encounter Message ( { encounter _id : encounter ID , fort _id : fort ID , player _latitude : self . player Latitude , player _longitude : self . player Longitude } ) , response Type : Responses . Disk Encounter Response } ) ; } ; this . collect Daily Defender Bonus = function ( ) { return self . call Or Chain ( { type : Request Type . COLLECT _DAILY _DEFENDER _BONUS , response Type : Responses . Collect Daily Defender Bonus Response } ) ; } ; this . upgrade Pokemon = function ( pokemon ID ) { return self . call Or Chain ( { type : Request Type . UPGRADE _POKEMON , message : new Request Messages . Upgrade Pokemon Message ( { pokemon _id : pokemon ID } ) , response Type : Responses . Upgrade Pokemon Response } ) ; } ; this . set Favorite Pokemon = function ( pokemon ID , is Favorite ) { return self . call Or Chain ( { type : Request Type . SET _FAVORITE _POKEMON , message : new Request Messages . Set Favorite Pokemon Message ( { pokemon _id : pokemon ID , is _favorite : is Favorite } ) , response Type : Responses . Set Favorite Pokemon Response } ) ; } ; this . nickname Pokemon = function ( pokemon ID , nickname ) { return self . call Or Chain ( { type : Request Type . NICKNAME _POKEMON , message : new Request Messages . Nickname Pokemon Message ( { pokemon _id : pokemon ID , nickname : nickname } ) , response Type : Responses . Nickname Pokemon Response } ) ; } ; this . equip Badge = function ( badge Type ) { return self . call Or Chain ( { type : Request Type . EQUIP _BADGE , message : new Request Messages . Equip Badge Message ( { badge _type : badge Type } ) , response Type : Responses . Equip Badge Response } ) ; } ; this . set Contact Settings = function ( send Marketing Emails , send Push Notifications ) { return self . call Or Chain ( { type : Request Type . SET _CONTACT _SETTINGS , message : new Request Messages . Set Contact Settings Message ( { contact _settings : { send _marketing _emails : send Marketing Emails , send _push _notifications : send Push Notifications } } ) , response Type : Responses . Set Contact Settings Response } ) ; } ; this . set Buddy Pokemon = function ( pokemon ID ) { return self . call Or Chain ( { type : Request Type . SET _BUDDY _POKEMON , message : new Request Messages . Set Buddy Pokemon Message ( { pokemon _id : pokemon ID } ) , response Type : Responses . Set Buddy Pokemon Response } ) ; } ; this . get Buddy Walked = function ( ) { return self . call Or Chain ( { type : Request Type . GET _BUDDY _WALKED , response Type : Responses . Get Buddy Walked Response } ) ; } ; this . use Item Encounter = function ( item ID , encounter ID , spawn Point GUID ) { return self . call Or Chain ( { type : Request Type . USE _ITEM _ENCOUNTER , message : new Request Messages . Use Item Encounter Message ( { item : item ID , encounter _id : encounter ID , spawn _point _guid : spawn Point GUID } ) , response Type : Responses . Use Item Encounter Response } ) ; } ; this . get Asset Digest = function ( platform , device Manufacturer , device Model , locale , app Version ) { return self . call Or Chain ( { type : Request Type . GET _ASSET _DIGEST , message : new Request Messages . Get Asset Digest Message ( { platform : platform , device _manufacturer : device Manufacturer , device _model : device Model , locale : locale , app _version : app Version } ) , response Type : Responses . Get Asset Digest Response } ) ; } ; this . get Download URLs = function ( asset IDs ) { return self . call Or Chain ( { type : Request Type . GET _DOWNLOAD _URLS , message : new Request Messages . Get Download Urls Message ( { asset _id : asset IDs } ) , response Type : Responses . Get Download Urls Response } ) ; } ; this . claim Codename = function ( codename ) { return self . call Or Chain ( { type : Request Type . CLAIM _CODENAME , message : new Request Messages . Claim Codename Message ( { codename : codename } ) , response Type : Responses . Claim Codename Response } ) ; } ; this . set Avatar = function ( player Avatar ) { return self . call Or Chain ( { type : Request Type . SET _AVATAR , message : new Request Messages . Set Avatar Message ( { player _avatar : player Avatar } ) , response Type : Responses . Set Avatar Response } ) ; } ; this . set Player Team = function ( team Color ) { return self . call Or Chain ( { type : Request Type . SET _PLAYER _TEAM , message : new Request Messages . Set Player Team Message ( { team : team Color } ) , response Type : Responses . Set Player Team Response } ) ; } ; this . mark Tutorial Complete = function ( tutorials Completed , send Marketing Emails , send Push Notifications ) { return self . call Or Chain ( { type : Request Type . MARK _TUTORIAL _COMPLETE , message : new Request Messages . Mark Tutorial Complete Message ( { tutorials _completed : tutorials Completed , send _marketing _emails : send Marketing Emails , send _push _notifications : send Push Notifications } ) , response Type : Responses . Mark Tutorial Complete Response } ) ; } ; this . check Challenge = function ( is Debug Request ) { return self . call Or Chain ( { type : Request Type . CHECK _CHALLENGE , message : new Request Messages . Check Challenge Message ( { debug _request : is Debug Request } ) , response Type : Responses . Check Challenge Response } ) ; } ; this . verify Challenge = function ( token ) { return self . call Or Chain ( { type : Request Type . VERIFY _CHALLENGE , message : new Request Messages . Verify Challenge Message ( { token : token } ) , response Type : Responses . Verify Challenge Response } ) ; } ; this . echo = function ( ) { return self . call Or Chain ( { type : Request Type . ECHO , response Type : Responses . Echo Response } ) ; } ; this . sfida Action Log = function ( ) { return self . call Or Chain ( { type : Request Type . SFIDA _ACTION _LOG , response Type : Responses . Sfida Action Log Response } ) ; } ; this . list Avatar Customizations = function ( avatar Type , slots , filters , start , limit ) { return self . call Or Chain ( { type : Request Type . LIST _AVATAR _CUSTOMIZATIONS , message : new Request Messages . List Avatar Customizations Message ( { avatar _type : avatar Type , slot : slots , filters : filters , start : start , limit : limit } ) , response Type : Responses . List Avatar Customizations Response } ) ; } ; this . set Avatar Item As Viewed = function ( avatar Template IDs ) { return self . call Or Chain ( { type : Request Type . SET _AVATAR _ITEM _AS _VIEWED , message : new Request Messages . Set Avatar Item As Viewed Message ( { avatar _template _id : avatar Template IDs } ) , response Type : Responses . Set Avatar Item As Viewd Response } ) ; } ; this . request = request . defaults ( { headers : { 'User -Agent ' : 'Niantic App ' , 'Accept ' : ' * / * ' , 'Content -Type ' : 'application /x -www -form -urlencoded ' } , encoding : null } ) ; this . options = Object . assign ( { } , default Options , options | | { } ) ; this . auth Ticket = null ; this . rpc Id = 2 ; this . last Hashing Key Index = 0 ; this . first Get Map Objects = true ; this . lehmer = new Lehmer ( 1 6 8 0 7 ) ; this . ptr 8 = INITIAL _PTR 8 ; this . call Or Chain = function ( request Message ) { if ( self . batch Requests ) { self . batch Requests . push ( request Message ) ; return self ; } else { return self . call RPC ( [ request Message ] ) ; } } ; this . get Request ID = function ( ) { return new Long ( self . rpc Id + + , this . lehmer . next Int ( ) ) ; } ; this . build Envelope = function ( requests ) { var envelope Data = { status _code : 2 , request _id : self . get Request ID ( ) , ms _since _last _locationfix : 1 0 0 + Math . floor ( Math . random ( ) * 9 0 0 ) } ; if ( self . player Latitude ) envelope Data . latitude = self . player Latitude ; if ( self . player Longitude ) envelope Data . longitude = self . player Longitude ; if ( self . player Location Accuracy ) { envelope Data . accuracy = self . player Location Accuracy ; } else { const values = [ 5 , 5 , 5 , 5 , 1 0 , 1 0 , 1 0 , 3 0 , 3 0 , 5 0 , 6 5 ] ; values . unshift ( Math . floor ( Math . random ( ) * ( 8 0 - 6 6 ) ) + 6 6 ) ; envelope Data . accuracy = values [ Math . floor ( values . length * Math . random ( ) ) ] ; } if ( self . auth Ticket ) { envelope Data . auth _ticket = self . auth Ticket ; } else if ( ! self . options . auth Type | | ! self . options . auth Token ) { throw Error ( 'No auth info provided ' ) ; } else { let unknown 2 = 0 ; if ( self . options . auth Type = = = 'ptc ' ) { const values = [ 2 , 8 , 2 1 , 2 1 , 2 1 , 2 8 , 3 7 , 5 6 , 5 9 , 5 9 , 5 9 ] ; unknown 2 = values [ Math . floor ( values . length * Math . random ( ) ) ] ; } envelope Data . auth _info = { provider : self . options . auth Type , token : { contents : self . options . auth Token , unknown 2 : unknown 2 , } } ; } if ( requests ) { self . emit ( 'request ' , { request _id : envelope Data . request _id . to String ( ) , requests : requests . map ( r = > ( { name : Utils . get Enum Key By Value ( Request Type , r . type ) , type : r . type , data : r . message } ) ) } ) ; envelope Data . requests = requests . map ( r = > { var request Data = { request _type : r . type } ; if ( r . message ) { request Data . request _message = r . message . encode ( ) ; } return request Data ; } ) ; } self . emit ( 'raw -request ' , envelope Data ) ; return new POGOProtos . Networking . Envelopes . Request Envelope ( envelope Data ) ; } ; this . add Platform Request To Envelope = function ( envelope , request Type , request Message ) { envelope . platform _requests . push ( new POGOProtos . Networking . Envelopes . Request Envelope . Platform Request ( { type : request Type , request _message : request Message . encode ( ) } ) ) ; return envelope ; } ; this . needs Ptr 8 = function ( requests ) { * Creates an RPC envelope with the given list of requests and adds the encrypted signature , * or adds the signature to an existing envelope . * @private * @param {Object [ ] } requests - Array of requests to build * @param {Request Envelope } [envelope ] - Pre -built request envelope to sign * @return {Promise } - A Promise that will be resolved with a Request Envelope instance * / this . build Signed Envelope = function ( requests , envelope ) { if ( ! envelope ) { try { envelope = self . build Envelope ( requests ) ; } catch ( e ) { throw new retry . Stop Error ( e ) ; } } if ( self . needs Ptr 8 ( requests ) ) { self . add Platform Request To Envelope ( envelope , Platform Request Type . UNKNOWN _PTR _ 8 , new Platform Request Messages . Unknown Ptr 8Request ( { message : self . ptr 8 , } ) ) ; } let auth Ticket = envelope . auth _ticket ; if ( ! auth Ticket ) { auth Ticket = envelope . auth _info ; } if ( ! auth Ticket ) { * Executes an RPC call with the given list of requests , retrying if necessary . * @private * @param {Object [ ] } requests - Array of requests to send * @param {Request Envelope } [envelope ] - Pre -built request envelope to use * @return {Promise } - A Promise that will be resolved with the (list of ) response messages , * or true if there aren 't any * / this . call RPC = function ( requests , envelope ) { / / If the requests include a map objects request , make sure the minimum delay / / since the last call has passed if ( requests . some ( r = > r . type = = = Request Type . GET _MAP _OBJECTS ) ) { var now = new Date ( ) . get Time ( ) , delay Needed = self . last Map Objects Call + self . options . map Objects Min Delay - now ; if ( delay Needed > 0 & & self . options . map Objects Throttling ) { return Promise . delay ( delay Needed ) . then ( ( ) = > self . call RPC ( requests , envelope ) ) ; } self . last Map Objects Call = now ; } if ( self . options . max Tries < = 1 ) return self . try Call RPC ( requests , envelope ) ; return retry ( ( ) = > self . try Call RPC ( requests , envelope ) , { interval : 3 0 0 , backoff : 2 , max _tries : self . options . max Tries } ) ; } ; / * * * Handle redirection to new API endpoint and resend last request to new endpoint . * @private * @param {Object [ ] } requests - Array of requests * @param {Request Envelope } signed Envelope - Request envelope * @param {Response Envelope } response Envelope - Result from API call * @return {Promise } * / this . redirect = function ( requests , signed Envelope , response Envelope ) { return new Promise ( ( resolve , reject ) = > { if ( ! response Envelope . api _url ) { reject ( Error ( 'Fetching RPC endpoint failed , none supplied in response ' ) ) ; return ; } self . endpoint = 'https : * Executes an RPC call with the given list of requests . * @private * @param {Object [ ] } requests - Array of requests to send * @param {Request Envelope } [envelope ] - Pre -built request envelope to use * @return {Promise } - A Promise that will be resolved with the (list of ) response messages , * or true if there aren 't any * / this . try Call RPC = function ( requests , envelope ) { return self . build Signed Envelope ( requests , envelope ) . then ( signed Envelope = > new Promise ( ( resolve , reject ) = > { self . request ( { method : 'POST ' , url : self . endpoint , proxy : self . options . proxy , body : signed Envelope . to Buffer ( ) } , ( err , response , body ) = > { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . status Code ! = = 2 0 0 ) { if ( response . status Code > = 4 0 0 & & response . status Code < 5 0 0 ) { / * These are permanent errors so throw Stop Error * / reject ( new retry . Stop Error ( ` $ { response . status Code } ` ) ) ; } else { / * Anything else might be recoverable so throw regular Error * / reject ( Error ( ` $ { response . status Code } ` ) ) ; } return ; } var response Envelope ; try { response Envelope = POGOProtos . Networking . Envelopes . Response Envelope . decode ( body ) ; } catch ( e ) { self . emit ( 'parse -envelope -error ' , body , e ) ; if ( e . decoded ) { response Envelope = e . decoded ; } else { reject ( new retry . Stop Error ( e ) ) ; return ; } } self . emit ( 'raw -response ' , response Envelope ) ; if ( response Envelope . error ) { reject ( new retry . Stop Error ( response Envelope . error ) ) ; return ; } if ( response Envelope . auth _ticket ) self . auth Ticket = response Envelope . auth _ticket ; if ( response Envelope . status _code = = = 5 3 | | ( response Envelope . status _code = = = 2 & & self . endpoint = = = INITIAL _ENDPOINT ) ) { resolve ( self . redirect ( requests , signed Envelope , response Envelope ) ) ; return ; } response Envelope . platform _returns . for Each ( platform Return = > { if ( platform Return . type = = = Platform Request Type . UNKNOWN _PTR _ 8 ) { const ptr 8 = Platform Responses . Unknown Ptr 8Response . decode ( platform Return . response ) ; if ( ptr 8 ) self . ptr 8 = ptr 8 . message ; } } ) ; / * Throttling , retry same request later * / if ( response Envelope . status _code = = = 5 2 ) { signed Envelope . platform _requests = [ ] ; Promise . delay ( 2 0 0 0 ) . then ( ( ) = > { resolve ( self . call RPC ( requests , signed Envelope ) ) ; } ) ; return ; } / * These codes indicate invalid input , no use in retrying so throw Stop Error * / if ( response Envelope . status _code = = = 3 | | response Envelope . status _code = = = 5 1 | | response Envelope . status _code > = 1 0 0 ) { reject ( new retry . Stop Error ( ` $ { response Envelope . status _code } ` ) ) ; } / * These can be temporary so throw regular Error * / if ( response Envelope . status _code ! = = 2 & & response Envelope . status _code ! = = 1 ) { reject ( Error ( ` $ { response Envelope . status _code } ` ) ) ; return ; } var responses = [ ] ; if ( requests ) { if ( requests . length ! = = response Envelope . returns . length ) { reject ( Error ( 'Request count does not match response count ' ) ) ; return ; } for ( var i = 0 ; i < response Envelope . returns . length ; i + + ) { if ( ! requests [ i ] . response Type ) continue ; var response Message ; try { response Message = requests [ i ] . response Type . decode ( response Envelope . returns [ i ] ) ; } catch ( e ) { self . emit ( 'parse -response -error ' , response Envelope . returns [ i ] . to Buffer ( ) , e ) ; reject ( new retry . Stop Error ( e ) ) ; return ; } if ( self . options . include Request Type In Response ) { / / eslint -disable -next -line no -underscore -dangle response Message . _request Type = requests [ i ] . type ; } responses . push ( response Message ) ; } } self . emit ( 'response ' , { status _code : response Envelope . status _code , request _id : response Envelope . request _id . to String ( ) , responses : responses . map ( ( r , h ) = > ( { name : Utils . get Enum Key By Value ( Request Type , requests [ h ] . type ) , type : requests [ h ] . type , data : r } ) ) } ) ; if ( self . options . automatic Long Conversion ) { responses = Utils . convert Longs ( responses ) ; } if ( ! responses . length ) resolve ( true ) ; else if ( responses . length = = = 1 ) resolve ( responses [ 0 ] ) ; else resolve ( responses ) ; } ) ; } ) ) ; } ; / * * * Processes the data received from the download Settings API call during init ( ) . * @private * @param {Object } settings Response - Response from API call * @return {Object } response - Unomdified response (to send back to Promise ) * / this . process Settings Response = function ( settings Response ) { / / Extract the minimum delay of get Map Objects ( ) if ( settings Response & & ! settings Response . error & & settings Response . settings & & settings Response . settings . map _settings & & settings Response . settings . map _settings . get _map _objects _min _refresh _seconds ) { self . set Option ( 'map Objects Min Delay ' , settings Response . settings . map _settings . get _map _objects _min _refresh _seconds * 1 0 0 0 ) ; } return settings Response ; } ; / * * * Makes an initial call to the hashing server to verify API version . * @private * @return {Promise } * / this . initialize Hashing Server = function ( ) { if ( ! self . options . hashing Server ) throw new Error ( 'Hashing server enabled without host ' ) ; if ( ! self . options . hashing Key ) throw new Error ( 'Hashing server enabled without key ' ) ; if ( self . options . hashing Server . slice ( - 1 ) ! = = ' / ' ) { self . set Option ( 'hashing Server ' , self . options . hashing Server + ' / ' ) ; } return Signature . versions . get Hashing Endpoint ( self . options . hashing Server , self . options . version ) . then ( version = > { self . hashing Version = version ; } ) ; } ; / * * DEPRECATED METHODS * / / * * * Sets the auth Type and auth Token options . * @deprecated Use options object or set Option ( ) instead * @param {string } auth Type * @param {string } auth Token * / this . set Auth Info = function ( auth Type , auth Token ) { self . set Option ( 'auth Type ' , auth Type ) ; self . set Option ( 'auth Token ' , auth Token ) ; } ; / * * * Sets the include Request Type In Response option . * @deprecated Use options object or set Option ( ) instead * @param {bool } include Request Type In Response * / this . set Include Request Type In Response = function ( include Request Type In Response ) { self . set Option ( 'include Request Type In Response ' , include Request Type In Response ) ; } ; / * * * Sets the max Tries option . * @deprecated Use options object or set Option ( ) instead * @param {integer } max Tries * / this . set Max Tries = function ( max Tries ) { self . set Option ( 'max Tries ' , max Tries ) ; } ; / * * * Sets the proxy option . * @deprecated Use options object or set Option ( ) instead * @param {string } proxy * / this . set Proxy = function ( proxy ) { self . set Option ( 'proxy ' , proxy ) ; } ; / * * * Sets the map Objects Throttling option . * @deprecated Use options object or set Option ( ) instead * @param {boolean } enable * / this . set Map Objects Throttling Enabled = function ( enable ) { self . set Option ( 'map Objects Throttling ' , enable ) ; } ; / * * * Sets a callback to be called for any envelope or request just before it is sent to * the server (mostly for debugging purposes ) . * @deprecated Use the raw -request event instead * @param {function } callback - function to call on requests * / this . set Request Callback = function ( callback ) { self . on ( 'raw -request ' , callback ) ; } ; / * * * Sets a callback to be called for any envelope or response just after it has been * received from the server (mostly for debugging purposes ) . * @deprecated Use the raw -response event instead * @param {function } callback - function to call on responses * / this . set Response Callback = function ( callback ) { self . on ( 'raw -response ' , callback ) ; } ; / * * * Sets the automatic Long Conversion option . * @deprecated Use options object or set Option ( ) instead * @param {boolean } enable * / this . set Automatic Long Conversion Enabled = function ( enable ) { if ( typeof enable ! = = 'boolean ' ) return ; self . set Option ( 'automatic Long Conversion ' , enable ) ; } ; } 
function PTCLogin ( ) { if ( ! ( this instanceof PTCLogin ) ) { return new PTCLogin ( ) ; } const self = this ; self . request = request . defaults ( { headers : { 'User -Agent ' : 'pokemongo / 1 CFNetwork / 8 0 8 . 2 . 1 6 Darwin / 1 6 . 3 . 0 ' } , jar : request . jar ( ) } ) ; this . login = function ( username , password ) { return self . get Session ( ) . then ( session Data = > self . get Ticket ( session Data , username , password ) ) . then ( self . get Token ) ; } ; this . get Session = function ( ) { return new Promise ( ( resolve , reject ) = > { self . request ( { method : 'GET ' , url : 'https : / /sso .pokemon .com /sso /login ' , qs : { service : 'https : / /sso .pokemon .com /sso /oauth 2 . 0 /callback Authorize ' } } , ( err , response , body ) = > { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . status Code ! = = 2 0 0 ) { reject ( Error ( ` $ { response . status Code } ` ) ) ; return ; } var session Response = null ; try { session Response = JSON . parse ( body ) ; } catch ( e ) { reject ( Error ( 'Unexpected response received from PTC login ' ) ) ; return ; } if ( ! session Response | | ! session Response . lt & & ! session Response . execution ) { reject ( Error ( 'No session data received from PTC login ' ) ) ; return ; } resolve ( { lt : session Response . lt , execution : session Response . execution } ) ; } ) ; } ) ; } ; this . get Ticket = function ( session Data , username , password ) { return new Promise ( ( resolve , reject ) = > { self . request ( { method : 'POST ' , url : 'https : / /sso .pokemon .com /sso /login ' , qs : { service : 'https : / /sso .pokemon .com /sso /oauth 2 . 0 /callback Authorize ' } , form : { 'lt ' : session Data . lt , 'execution ' : session Data . execution , ' _event Id ' : 'submit ' , 'username ' : username , 'password ' : password } } , ( err , response ) = > { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . status Code ! = = 3 0 2 | | ! response . headers . location ) { reject ( Error ( 'Invalid response received from PTC login ' ) ) ; return ; } var ticket URL = url . parse ( response . headers . location , true ) ; if ( ! ticket URL | | ! ticket URL . query . ticket ) { reject ( Error ( 'No login ticket received from PTC login ' ) ) ; return ; } resolve ( ticket URL . query . ticket ) ; } ) ; } ) ; } ; this . get Token = function ( ticket ) { return new Promise ( ( resolve , reject ) = > { self . request ( { method : 'POST ' , url : 'https : / /sso .pokemon .com /sso /oauth 2 . 0 /access Token ' , form : { client _id : 'mobile -app _pokemon -go ' , client _secret : 'w 8Sc CUXJQc 6k XKw 8Fi Ohd 8Fixzht 1 8Dq 3PEVk UCP 5ZPxtgy Wsb Tv WHFLm 2w NY 0JR ' , redirect _uri : 'https : / /www .nianticlabs .com /pokemongo /error ' , grant _type : 'refresh _token ' , code : ticket } } , ( err , response , body ) = > { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . status Code ! = = 2 0 0 ) { reject ( Error ( ` $ { response . status Code } ` ) ) ; return ; } var qs = querystring . parse ( body ) ; if ( ! qs | | ! qs . access _token ) { reject ( Error ( 'Invalid data received from PTC OAuth ' ) ) ; return ; } resolve ( qs . access _token ) ; } ) ; } ) ; } ; this . set Proxy = function ( proxy ) { self . request = self . request . defaults ( { proxy : proxy } ) ; } ; } 
function Google Login ( ) { if ( ! ( this instanceof Google Login ) ) { return new Google Login ( ) ; } const self = this ; const GOOGLE _LOGIN _ANDROID _ID = ' 9 7 7 4d 5 6d 6 8 2e 5 4 9c ' ; const GOOGLE _LOGIN _SERVICE = 'audience :server :client _id : 8 4 8 2 3 2 5 1 1 2 4 0 - 7so 4 2 1jotr 2 6 0 9rmqakceuu 1luuq 0ptb .apps .googleusercontent .com ' ; const GOOGLE _LOGIN _APP = 'com .nianticlabs .pokemongo ' ; const GOOGLE _LOGIN _CLIENT _SIG = ' 3 2 1 1 8 7 9 9 5bc 7cdc 2b 5fc 9 1b 1 1a 9 6e 2baa 8 6 0 2c 6 2 ' ; this . set Proxy = function ( proxy ) { google . set Proxy ( proxy ) ; } ; this . login = function ( username , password ) { return self . get Master Token ( username , password ) . then ( login Data = > self . get Token ( username , login Data ) ) . then ( auth Data = > auth Data . Auth ) ; } ; this . login With Token = function ( username , token ) { var login Data = { android Id : GOOGLE _LOGIN _ANDROID _ID , master Token : token } ; return self . get Token ( username , login Data ) . then ( auth Data = > auth Data . Auth ) ; } ; this . get Master Token = function ( username , password ) { return new Promise ( ( resolve , reject ) = > { google . login ( username , password , GOOGLE _LOGIN _ANDROID _ID , ( err , data ) = > { if ( err ) { if ( err . response . status Code = = = 4 0 3 ) { reject ( Error ( 'Received code 4 0 3 from Google login . This could be because your account has ' + ' 2 -Step -Verification enabled . If that is the case , you need to generate an ' + 'App Password and use that instead of your regular password : ' + 'https : / /security .google .com /settings /security /apppasswords ' ) ) ; } else { reject ( Error ( err . response . status Code + ' : ' + err . response . status Message ) ) ; } return ; } resolve ( data ) ; } ) ; } ) ; } ; this . get Token = function ( username , login Data ) { return new Promise ( ( resolve , reject ) = > { google . oauth ( username , login Data . master Token , login Data . android Id , GOOGLE _LOGIN _SERVICE , GOOGLE _LOGIN _APP , GOOGLE _LOGIN _CLIENT _SIG , ( err , data ) = > { if ( err ) { reject ( Error ( err . response . status Code + ' : ' + err . response . status Message ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; } ; } 
function ( lat , lng , radius , level ) { if ( typeof radius = = = 'undefined ' ) radius = 3 ; if ( typeof level = = = 'undefined ' ) level = 1 5 ; var origin = s 2 . S 2Cell . From Lat Lng ( { lat : lat , lng : lng } , level ) ; var cells = [ ] ; cells . push ( origin . to Hilbert Quadkey ( ) ) ; 
function ( inventory ) { if ( ! inventory | | ! inventory . success | | ! inventory . inventory _delta | | ! inventory . inventory _delta . inventory _items ) { return { } ; } var ret = { pokemon : [ ] , removed _pokemon : [ ] , items : [ ] , pokedex : [ ] , player : null , currency : [ ] , camera : null , inventory _upgrades : [ ] , applied _items : [ ] , egg _incubators : [ ] , candies : [ ] , quests : [ ] } ; inventory . inventory _delta . inventory _items . for Each ( item = > { if ( item . inventory _item _data ) { const itemdata = item . inventory _item _data ; if ( itemdata . pokemon _data ) { ret . pokemon . push ( itemdata . pokemon _data ) ; } if ( itemdata . item ) { ret . items . push ( itemdata . item ) ; } if ( itemdata . pokedex _entry ) { ret . pokedex . push ( itemdata . pokedex _entry ) ; } if ( itemdata . player _stats ) { ret . player = itemdata . player _stats ; } if ( itemdata . player _currency ) { ret . currency . push ( itemdata . player _currency ) ; } if ( itemdata . player _camera ) { ret . camera = itemdata . player _camera ; } if ( itemdata . inventory _upgrades ) { ret . inventory _upgrades . push ( itemdata . inventory _upgrades ) ; } if ( itemdata . applied _items ) { ret . applied _items . push ( itemdata . applied _items ) ; } if ( itemdata . egg _incubators ) { const incubators = itemdata . egg _incubators . egg _incubator | | [ ] ; ret . egg _incubators = ret . egg _incubators . concat ( incubators ) ; } if ( itemdata . candy ) { ret . candies . push ( itemdata . candy ) ; } if ( itemdata . quest ) { ret . quests . push ( itemdata . quest ) ; } } if ( item . deleted _item & & item . deleted _item . pokemon _id ) { ret . removed _pokemon . push ( item . deleted _item . pokemon _id ) ; } } ) ; return ret ; } 
function ( templates ) { if ( ! templates | | ! templates . success | | ! templates . item _templates ) return { } ; var ret = { pokemon _settings : [ ] , item _settings : [ ] , move _settings : [ ] , move _sequence _settings : [ ] , type _effective _settings : [ ] , badge _settings : [ ] , camera _settings : null , player _level _settings : null , gym _level _settings : null , battle _settings : null , encounter _settings : null , iap _item _display : [ ] , iap _settings : null , pokemon _upgrade _settings : null , equipped _badge _settings : null } ; templates . item _templates . for Each ( template = > { if ( template . pokemon _settings ) { ret . pokemon _settings . push ( template . pokemon _settings ) ; } if ( template . item _settings ) { ret . item _settings . push ( template . item _settings ) ; } if ( template . move _settings ) { ret . move _settings . push ( template . move _settings ) ; } if ( template . move _sequence _settings ) { ret . move _sequence _settings . push ( template . move _sequence _settings . sequence ) ; } if ( template . type _effective ) { ret . type _effective _settings . push ( template . type _effective ) ; } if ( template . badge _settings ) { ret . badge _settings . push ( template . badge _settings ) ; } if ( template . camera ) { ret . camera _settings = template . camera ; } if ( template . player _level ) { ret . player _level _settings = template . player _level ; } if ( template . gym _level ) { ret . gym _level _settings = template . gym _level ; } if ( template . battle _settings ) { ret . battle _settings = template . battle _settings ; } if ( template . encounter _settings ) { ret . encounter _settings = template . encounter _settings ; } if ( template . iap _item _display ) { ret . iap _item _display . push ( template . iap _item _display ) ; } if ( template . iap _settings ) { ret . iap _settings = template . iap _settings ; } if ( template . pokemon _upgrades ) { ret . pokemon _upgrade _settings = template . pokemon _upgrades ; } if ( template . equipped _badges ) { ret . equipped _badge _settings = template . equipped _badges ; } } ) ; return ret ; } 
function ( enum Obj , val ) { for ( var key of Object . keys ( enum Obj ) ) { if ( enum Obj [ key ] = = = val ) { return key . split ( ' _ ' ) . map ( word = > word . char At ( 0 ) . to Upper Case ( ) + word . slice ( 1 ) . to Lower Case ( ) ) . join ( ' ' ) ; } } return null ; } 
function ( pokemon , decimals ) { if ( typeof decimals = = = 'undefined ' ) decimals = - 1 ; decimals = Math . min ( decimals , 2 0 ) ; var att = pokemon . individual _attack , def = pokemon . individual _defense , stam = pokemon . individual _stamina ; var unrounded Percentage = ( att + def + stam ) / 4 5 * 1 0 0 ; var percent = decimals < 0 ? unrounded Percentage : + unrounded Percentage . to Fixed ( decimals ) ; return { att : att , def : def , stam : stam , percent : percent } ; } 
function ( object ) { if ( ! object | | typeof object ! = = 'object ' ) return object ; if ( object instanceof Byte Buffer ) return object ; if ( Long . is Long ( object ) ) { return object . less Than Or Equal ( Number . MAX _SAFE _INTEGER ) & & object . greater Than Or Equal ( Number . MIN _SAFE _INTEGER ) ? object . to Number ( ) : object . to String ( ) ; } for ( var i in object ) { if ( object . has Own Property ( i ) ) { if ( Long . is Long ( object [ i ] ) ) { object [ i ] = object [ i ] . less Than Or Equal ( Number . MAX _SAFE _INTEGER ) & & object [ i ] . greater Than Or Equal ( Number . MIN _SAFE _INTEGER ) ? object [ i ] . to Number ( ) : object [ i ] . to String ( ) ; } else if ( typeof object [ i ] = = = 'object ' ) { object [ i ] = this . convert Longs ( object [ i ] ) ; } } } return object ; } 
function Random ( seed ) { this . multiplier = 1 6 8 0 7 ; this . modulus = 0x 7fffffff ; this . seed = seed ; this . mq = Math . floor ( this . modulus / this . multiplier ) ; this . mr = this . modulus % this . multiplier ; } 
function pretty Date ( time ) { var diff = ( ( ( new Date ( ) ) . get Time ( ) - time ) / 1 0 0 0 ) , day _diff = Math . floor ( diff / 8 6 4 0 0 ) ; if ( is Na N ( day _diff ) | | day _diff < 0 | | day _diff > = 3 1 ) return ; return day _diff = = 0 & & ( diff < 6 0 & & "just now " | | diff < 1 2 0 & & " 1 minute ago " | | diff < 3 6 0 0 & & Math . floor ( diff / 6 0 ) + " minutes ago " | | diff < 7 2 0 0 & & " 1 hour ago " | | diff < 8 6 4 0 0 & & Math . floor ( diff / 3 6 0 0 ) + " hours ago " ) | | day _diff = = 1 & & "Yesterday " | | day _diff < 7 & & day _diff + " days ago " | | day _diff < 3 1 & & Math . ceil ( day _diff / 7 ) + " weeks ago " ; } 
function ( content , options ) { this . settings = $ . extend ( { } , $ . fn . alert . defaults , options ) this . $element = $ ( content ) . delegate ( this . settings . selector , 'click ' , this . close ) } 
function Logger Factory ( options ) { options = options | | { prefix : true } ; 
function run Request Queue ( socket ) { var queue = socket . request Queue ; if ( ! queue ) return ; for ( var i in queue ) { 
function jsonp ( opts , cb ) { opts = opts | | { } ; if ( typeof window = = = 'undefined ' ) { 
function JWR ( response Ctx ) { this . body = response Ctx . body ; this . headers = response Ctx . headers | | { } ; this . status Code = ( typeof response Ctx . status Code = = = 'undefined ' ) ? 2 0 0 : response Ctx . status Code ; 
function _emit From ( socket , request Ctx ) { if ( ! socket . _raw ) { throw new Error ( 'Failed to emit from socket - raw SIO socket is missing . ' ) ; } 
function Sails Socket ( opts ) { var self = this ; opts = opts | | { } ; 
function _after Replacing All Collections ( err ) { if ( err ) { return done ( err ) ; } 
function _constructor ( host , port , schema , adapter , user , password , database , identity ) { if ( _self . clean Arguments ( arguments ) . length = = 1 & & typeof arguments [ 0 ] = = = 'object ' ) { _self . host = arguments [ 0 ] . host ; _self . port = arguments [ 0 ] . port ; _self . schema = arguments [ 0 ] . schema ; _self . adapter = arguments [ 0 ] . adapter ; _self . user = arguments [ 0 ] . user ; _self . password = arguments [ 0 ] . password ; _self . database = arguments [ 0 ] . database ; _self . identity = arguments [ 0 ] . identity ; _self . validate ( ) ; } else { _self . host = host ; _self . port = port ; _self . schema = schema ; _self . adapter = adapter ; _self . user = user ; _self . password = password ; _self . database = database ; if ( identity ) _self . identity = identity ; } } 
function _begin Batch Maybe ( next ) { 
function validate Parameter Value ( parameter , type , format , value ) { if ( type = = = 'integer ' ) { const parsed Value = Number . parse Int ( value ) if ( _ . is Na N ( parsed Value ) ) { throw new Error ( ` $ { parameter } $ { value } ` ) } return parsed Value } else if ( type = = = 'number ' ) { const parsed Value = Number . parse Float ( value ) if ( _ . is Na N ( parsed Value ) ) { throw new Error ( ` $ { parameter } $ { value } ` ) } return Number . is Integer ( parsed Value ) ? Number . parse Int ( value ) : parsed Value } else if ( type = = = 'string ' & & format ) { if ( format = = = 'date -time ' & & ! moment ( value , moment . ISO _ 8 6 0 1 ) . is Valid ( ) ) { throw new Error ( ` $ { parameter } $ { value } ` ) } else if ( format = = = 'date ' & & ! moment ( value , 'YYYY -MM -DD ' ) . is Valid ( ) ) { throw new Error ( ` $ { parameter } $ { value } ` ) } return value } return value } 
function parameter Declaration To Yargs ( yargs , parameter , declaration ) { const option Name = _ . kebab Case ( parameter ) let option = { } if ( declaration . description ) { option . describe = declaration . description } if ( declaration . type ) { if ( declaration . type = = = 'integer ' ) { option . type = 'number ' } else { option . type = declaration . type } } if ( declaration . enum ) { option . choices = declaration . enum } if ( declaration . default ) { option . default = declaration . default } if ( declaration . required ) { option . demand Option = declaration . required } if ( declaration . conflicts ) { option . conflicts = declaration . conflicts } yargs . option ( option Name , option ) yargs . coerce ( option Name , ( value ) = > { if ( declaration . type = = = 'array ' ) { return _ . map ( value , ( value ) = > { return validate Parameter Value ( ` $ { option Name } ` , declaration . item , declaration . format , value ) } ) } return validate Parameter Value ( option Name , declaration . type , declaration . format , value ) } ) } 
function config Declaration To Yargs ( yargs , config Declaration ) { _ . for Own ( config Declaration , ( parameter , parameter Name ) = > { parameter Declaration To Yargs ( yargs , parameter Name , parameter ) } ) return yargs } 
function create Modal ( id , title , body , footer ) { var $modal Header Button = $ ( ' <button type = "button " class = "close " data -dismiss = "modal " aria -hidden = "true " > &times ; < /button > ' ) ; var $modal Header Title = $ ( ' <h 4 class = "modal -title " id = " ' + id + ' _modal _title " > ' + title + ' < /h 4 > ' ) ; var $modal Header = $ ( ' <div class = "modal -header " > < /div > ' ) ; $modal Header . append ( $modal Header Button ) ; $modal Header . append ( $modal Header Title ) ; var $modal Body = $ ( ' <div class = "modal -body " id = " ' + id + ' _modal _body " > ' + body + ' < /div > ' ) ; var $modal Footer = $ ( ' <div class = "modal -footer " id = " ' + id + ' _modal _footer " > < /div > ' ) ; if ( typeof ( footer ) ! = = 'undefined ' ) { var $modal Footer Add On = $ ( ' <div > ' + footer + ' < /div > ' ) ; $modal Footer . append ( $modal Footer Add On ) ; } var $modal Content = $ ( ' <div class = "modal -content " > < /div > ' ) ; $modal Content . append ( $modal Header ) ; $modal Content . append ( $modal Body ) ; $modal Content . append ( $modal Footer ) ; var $modal Dialog = $ ( ' <div class = "modal -dialog " > < /div > ' ) ; $modal Dialog . append ( $modal Content ) ; var $modal Fade = $ ( ' <div class = "modal fade " id = " ' + id + ' _modal " tabindex = " - 1 " role = "dialog " aria -labelledby = " ' + id + ' _modal _title " aria -hidden = "true " > < /div > ' ) ; $modal Fade . append ( $modal Dialog ) ; $modal Fade . data ( 'date Id ' , id ) ; $modal Fade . attr ( "date Id " , id ) ; return $modal Fade ; } 
function check Events ( $calendar Element , year , month ) { var json Data = $calendar Element . data ( 'json Data ' ) ; var ajax Settings = $calendar Element . data ( 'ajax Settings ' ) ; $calendar Element . data ( 'events ' , false ) ; if ( false ! = = json Data ) { return json Events ( $calendar Element ) ; } else if ( false ! = = ajax Settings ) { return ajax Events ( $calendar Element , year , month ) ; } return true ; } 
function is Today ( year , month , day ) { var today Obj = new Date ( ) ; var date Obj = new Date ( year , month , day ) ; return ( date Obj . to Date String ( ) = = today Obj . to Date String ( ) ) ; } 
function ensure Secure ( req , res , next ) { if ( req . headers [ "x -forwarded -proto " ] = = = "https " ) { 
function signup Email ( user ) { var port = process . env . MAIL _PORT var useremail = process . env . MAIL _USERNAME var passwords = process . env . MAIL _PASSWORD var host = process . env . MAIL _HOST var temp = { } 'use strict ' ; var nodemailer = require ( 'nodemailer ' ) ; 
function binary Search ( arr , search Value ) { function find ( arr , search Value , left , right ) { if ( right < left ) return - 1 ; var mid = Math . floor ( ( left + right ) > > > 1 ) ; if ( search Value > arr [ mid ] ) return find ( arr , search Value , mid + 1 , right ) ; if ( search Value < arr [ mid ] ) return find ( arr , search Value , left , mid - 1 ) ; return mid ; } ; return find ( arr , search Value , 0 , arr . length - 1 ) ; } 
function Iterated Char ( ) { this . char Value = 0 ; 
function NGram Parser ( the Ngram List , the Byte Map ) { var N _GRAM _MASK = 0x FFFFFF ; this . byte Index = 0 ; this . ngram = 0 ; this . ngram List = the Ngram List ; this . byte Map = the Byte Map ; this . ngram Count = 0 ; this . hit Count = 0 ; this . space Char ; this . search = function ( table , value ) { var index = 0 ; if ( table [ index + 3 2 ] < = value ) index + = 3 2 ; if ( table [ index + 1 6 ] < = value ) index + = 1 6 ; if ( table [ index + 8 ] < = value ) index + = 8 ; if ( table [ index + 4 ] < = value ) index + = 4 ; if ( table [ index + 2 ] < = value ) index + = 2 ; if ( table [ index + 1 ] < = value ) index + = 1 ; if ( table [ index ] > value ) index - = 1 ; if ( index < 0 | | table [ index ] ! = value ) return - 1 ; return index ; } ; this . lookup = function ( this Ngram ) { this . ngram Count + = 1 ; if ( this . search ( this . ngram List , this Ngram ) > = 0 ) { this . hit Count + = 1 ; } } ; this . add Byte = function ( b ) { this . ngram = ( ( this . ngram < < 8 ) + ( b & 0x FF ) ) & N _GRAM _MASK ; this . lookup ( this . ngram ) ; } this . next Byte = function ( det ) { if ( this . byte Index > = det . f Input Len ) return - 1 ; return det . f Input Bytes [ this . byte Index + + ] & 0x FF ; } this . parse = function ( det , space Ch ) { var b , ignore Space = false ; this . space Char = space Ch ; while ( ( b = this . next Byte ( det ) ) > = 0 ) { var mb = this . byte Map [ b ] ; 
function Iconic ( ) { * Sets the path used to locate the iconic SVG files * @param {string } path - the base path used to locate the iconic SVG files * / this . set Asset Path = function ( path ) { asset Path = angular . is String ( path ) ? path : asset Path ; } ; this . $get = function ( ) { var iconic Object = new Iconic JS ( ) ; var service = { get Access : get Access , get Asset Path : get Asset Path } ; return service ; function get Access ( ) { return iconic Object ; } function get Asset Path ( ) { return asset Path ; } } ; } 
function get Parents Until ( elem , parent ) { for ( ; elem & & elem ! = = document . body ; elem = elem . parent Node ) { if ( elem . has Attribute ( parent ) ) { if ( elem . class List . contains ( 'is -active ' ) ) { return elem ; } break ; } } return false ; } 
function collect Scenarios From Element ( parent Element ) { var scenarios = [ ] ; var templates = [ ] ; var elements = parent Element . children ( ) ; var i = 0 ; angular . for Each ( elements , function ( el ) { var elem = angular . element ( el ) ; 
function zf Accordion Item ( ) { var directive = { restrict : 'EA ' , template Url : 'components /accordion /accordion -item .html ' , transclude : true , scope : { title : ' @ ' } , require : ' ^zf Accordion ' , replace : true , controller : function ( ) { } , link : link } ; return directive ; function link ( scope , element , attrs , controller , transclude ) { scope . active = false ; controller . add Section ( scope ) ; scope . activate = function ( ) { controller . select ( scope ) ; } ; } } 
function watch Path ( root Path , options , event Callback ) { const watcher = Path Watcher Manager . instance ( ) . create Watcher ( root Path , options , event Callback ) return watcher . get Start Promise ( ) . then ( ( ) = > watcher ) } 
function absolute ( . . . parts ) { let candidate = parts . length ! = = 1 ? path . join ( . . . parts ) : parts [ 0 ] if ( process . platform = = = 'win 3 2 ' & & / ^ [A -Z ] : $ / . test ( candidate ) ) candidate + = ' \ \ ' return path . is Absolute ( candidate ) ? candidate : path . join ( path . sep , candidate ) } 
function middleware ( opts ) { const srv = new Server ( opts ) ; servers . push ( srv ) ; return function tinylr ( req , res , next ) { srv . handler ( req , res , next ) ; } ; } 
function changed ( done ) { const files = [ ] . slice . call ( arguments ) ; if ( typeof files [ files . length - 1 ] = = = 'function ' ) done = files . pop ( ) ; done = typeof done = = = 'function ' ? done : ( ) = > { } ; debug ( 'Notifying %d servers - Files : ' , servers . length , files ) ; servers . for Each ( srv = > { const params = { params : { files : files } } ; srv & & srv . changed ( params ) ; } ) ; done ( ) ; } 
function initialize ( app Id ) { if ( Platform . OS = = 'android ' ) { usabilla Event Emitter . add Listener ( 'UBForm Not Found Fragment Activity ' , ( ) = > console . log ( "The Activity does not extend Fragment Activity and cannot call get Support Fragment Manager ( ) " ) ) } Usabilla Bridge . initialize ( app Id ) } 
function ( children , element ) { this . portal Node = document . create Element ( 'div ' ) ; ( element | | document . body ) . append Child ( this . portal Node ) ; React DOM . render ( children , this . portal Node ) ; } 
function ( ) { var close = typeof this . portal Confirm On Close Message = = = 'string ' ? confirm ( this . portal Confirm On Close Message ) : true ; if ( this . portal Node & & this . portal Node . parent Node & & close ) { React DOM . unmount Component At Node ( this . portal Node ) ; this . portal Node . parent Node . remove Child ( this . portal Node ) ; this . portal Node = null ; } } 
function ( id , definition , data Formatter ) { this . id = id ; this . url = definition . url ; this . cols = definition . cols ; this . sort Col Index = definition . sort Col Index ; this . pagination = definition . pagination ; this . cursor = definition . cursor ; this . row Click = definition . row Click ; this . advanced Filters = definition . advanced Filters ; this . data = null ; this . filtered Data = null ; this . displayed Data = null ; this . data Count = null ; this . data Formatter = data Formatter ; this . selected Items = { } ; this . select Data Property = _ . result ( _ . find ( this . cols , { 'data Type ' : 'select ' } ) , 'data Property ' ) ; } 
function ( data ) { this . data = _ . values ( _ . clone Deep ( data ) ) ; 
function ( ) { this . data Count = this . data . length ; this . filtered Data = this . filter Data ( this . data ) ; this . displayed Data = this . pagination ? this . slice Data ( this . filtered Data ) : this . filtered Data ; return this . displayed Data ; } 
function ( data ) { if ( this . filter Value ) { data = this . quick Filter Data ( data , this . filter Value ) ; } if ( this . advanced Filters ) { data = this . advanced Filter Data ( data , this . advanced Filters ) ; } this . data Count = data . length ; return data ; } 
function ( data , filter Value ) { var filter Col ; filter Value = filter Value . to String ( ) . to Lower Case ( ) . split ( ' : ' ) ; if ( filter Value . length > 1 ) { filter Col = filter Value [ 0 ] ; filter Value = filter Value [ 1 ] ; } else { filter Value = filter Value [ 0 ] ; } var filter Properties = [ ] ; 
function ( data , filters ) { return _ . filter ( _ . map ( data , function ( item ) { var shown = true ; _ . each ( filters , function ( filter ) { if ( item [ filter . data Property ] = = = filter . filter Value ) { if ( filter . checked ) { item = _ . clone Deep ( item ) ; 
function ( col Index , direction ) { this . sort Col Index = col Index ; this . cols [ col Index ] . sort Direction = direction ; var default Direction = this . cols [ col Index ] . default Sort Direction ; var data Type = this . cols [ this . sort Col Index ] . data Type ; var key = this . cols [ this . sort Col Index ] . data Property ; if ( this . pagination ) { this . reset Pagination ( ) ; } this . data . sort ( function ( a , b ) { var first = a [ key ] ; var second = b [ key ] ; 
function ( deselect ) { _ . for Each ( this . filtered Data , function ( data ) { if ( deselect ) { delete this . selected Items [ data [ this . select Data Property ] ] ; } else { this . selected Items [ data [ this . select Data Property ] ] = data ; } } , this ) ; } 
function ( row Index ) { var key = this . displayed Data [ row Index ] [ this . select Data Property ] ; if ( this . selected Items [ key ] ) { delete this . selected Items [ key ] ; } else { this . selected Items [ key ] = this . displayed Data [ row Index ] ; } } 
function ( id , definition , data Formatter ) { this . collection [ id ] = new Table ( id , definition , data Formatter ) ; return this . collection [ id ] ; } 
function ( payload ) { var action = payload . action ; if ( ! this . should Handle Action ( action . component ) ) { return ; } switch ( action . action Type ) { case Action Types . REQUEST _DATA : this . handle Request Data Action ( action ) ; break ; case Action Types . TABLE _SORT : this . collection [ action . id ] . sort Data ( action . data . col Index , action . data . direction ) ; this . emit Change ( action . id ) ; break ; case Action Types . FILTER : this . collection [ action . id ] . set Filter Value ( action . data . value ) ; this . emit Change ( action . id ) ; break ; case Action Types . ADVANCED _FILTER : this . collection [ action . id ] . set Advanced Filters ( action . data . advanced Filters ) ; this . emit Change ( action . id ) ; break ; case Action Types . PAGINATE : this . collection [ action . id ] . paginate ( action . data . direction ) ; this . emit Change ( action . id ) ; break ; case Action Types . TOGGLE _BULK _SELECT : this . collection [ action . id ] . update Bulk Selection ( action . data . deselect ) ; this . emit Change ( action . id ) ; break ; case Action Types . TOGGLE _ROW _SELECT : this . collection [ action . id ] . update Row Selection ( action . data . row Index ) ; this . emit Change ( action . id ) ; break ; case Action Types . DESTROY _INSTANCE : this . destroy Instance ( action . id ) ; break ; } } 
function ( next Props ) { if ( this . props . filters ! = = next Props . filters & & JSON . stringify ( this . props . filters ) ! = = JSON . stringify ( next Props . filters ) ) { set Timeout ( function ( ) { this . request Data ( ) ; } . bind ( this ) , 0 ) ; } } 
function ( store ) { return { component Did Mount : function ( ) { store . on ( 'change : ' + this . props . component Id , this . on Data Received ) ; store . on ( 'fail : ' + this . props . component Id , this . on Error ) ; } , component Will Unmount : function ( ) { store . remove Listener ( 'change : ' + this . props . component Id , this . on Data Received ) ; store . remove Listener ( 'fail : ' + this . props . component Id , this . on Error ) ; } } ; } 
function ( ) { store . on ( 'change : ' + this . props . component Id , this . on Data Received ) ; store . on ( 'fail : ' + this . props . component Id , this . on Error ) ; } 
function ( ) { store . remove Listener ( 'change : ' + this . props . component Id , this . on Data Received ) ; store . remove Listener ( 'fail : ' + this . props . component Id , this . on Error ) ; } 
function ( id , definition , data Formatter , filters ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . REQUEST _DATA , component : 'Table ' , id : id , data : { definition : definition , data Formatter : data Formatter , filters : filters } } ) ; } 
function ( id , value ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . FILTER , component : 'Table ' , id : id , data : { value : value } } ) ; } 
function ( id , advanced Filters ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . ADVANCED _FILTER , component : 'Table ' , id : id , data : { advanced Filters : advanced Filters } } ) ; } 
function ( id , direction ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . PAGINATE , component : 'Table ' , id : id , data : { direction : direction } } ) ; } 
function ( id , col Index , direction ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . TABLE _SORT , component : 'Table ' , id : id , data : { col Index : col Index , direction : direction } } ) ; } 
function ( id , deselect ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . TOGGLE _BULK _SELECT , component : 'Table ' , id : id , data : { deselect : deselect } } ) ; } 
function ( id , row Index ) { App Dispatcher . dispatch Action ( { action Type : this . action Types . TOGGLE _ROW _SELECT , component : 'Table ' , id : id , data : { row Index : row Index } } ) ; } 
function extract Value ( attr , node ) { if ( attr = = = 'translate ' ) { return node . html ( ) | | get Attr ( attr ) | | ' ' ; } return get Attr ( attr ) | | node . html ( ) | | ' ' ; } 
function cleaner Eval $ 6 2 4 ( str $ 6 2 9 , old Console $ 6 3 0 ) { var log Arr $ 6 3 1 = [ ] ; var console $ 6 3 2 = { log : function ( msg $ 6 3 3 ) { log Arr $ 6 3 1 . push ( msg $ 6 3 3 ) ; old Console $ 6 3 0 . log ( msg $ 6 3 3 ) ; } } ; eval ( str $ 6 2 9 ) ; return log Arr $ 6 3 1 ; } 
function ( obj , callback , this Arg ) { return obj . map ? obj . map . call ( obj , callback , this Arg ) : map . call ( obj , callback , this Arg ) ; } 
function ( obj , callback , this Arg ) { return obj . filter ? obj . filter . call ( obj , callback , this Arg ) : filter . call ( obj , callback , this Arg ) ; } 
function ( obj , elements ) { return elements = = = undefined ? [ ] : utils . map ( elements , function ( item ) { return utils . index Of ( obj , item ) ; } ) ; } 
function ( array , item ) { var index = utils . index Of ( array , item ) ; if ( index = = = - 1 ) { array . push ( item ) ; } } 
function ( array , idx , amt , objects ) { if ( array . replace ) { return array . replace ( idx , amt , objects ) ; } else { return utils . _replace ( array , idx , amt , objects ) ; } } 
function ( array 1 , array 2 ) { var intersection = [ ] ; utils . for Each ( array 1 , function ( element ) { if ( utils . index Of ( array 2 , element ) > = 0 ) { intersection . push ( element ) ; } } ) ; return intersection ; } 
function remove Listener ( obj , event Name , target , method ) { Ember . assert ( "You must pass at least an object and event name to Ember .remove Listener " , ! ! obj & & ! ! event Name ) ; if ( ! method & & 'function ' = = = typeof target ) { method = target ; target = null ; } function _remove Listener ( target , method ) { var actions = actions For ( obj , event Name ) , action Index = index Of ( actions , target , method ) ; 
function suspend Listener ( obj , event Name , target , method , callback ) { if ( ! method & & 'function ' = = = typeof target ) { method = target ; target = null ; } var actions = actions For ( obj , event Name ) , action Index = index Of ( actions , target , method ) ; if ( action Index ! = = - 1 ) { actions [ action Index + 2 ] | = SUSPENDED ; 
function dependent Keys Did Change ( obj , dep Key , meta ) { if ( obj . is Destroying ) { return ; } var seen = DID _SEEN , top = ! seen ; if ( top ) { seen = DID _SEEN = { } ; } iter Deps ( property Did Change , obj , dep Key , seen , meta ) ; if ( top ) { DID _SEEN = null ; } } 
function set ( obj , key Name , value , tolerant ) { if ( typeof obj = = = 'string ' ) { Ember . assert ( "Path ' " + obj + " ' must be global if no obj is given . " , IS _GLOBAL . test ( obj ) ) ; value = key Name ; key Name = obj ; obj = null ; } Ember . assert ( "Cannot call set with " + key Name + " key . " , ! ! key Name ) ; if ( ! obj | | key Name . index Of ( ' . ' ) ! = = - 1 ) { return set Path ( obj , key Name , value , tolerant ) ; } Ember . assert ( "You need to provide an object and key to `set ` . " , ! ! obj & & key Name ! = = undefined ) ; Ember . assert ( 'calling set on destroyed object ' , ! obj . is Destroyed ) ; var meta = obj [ META _KEY ] , desc = meta & & meta . descs [ key Name ] , is Unknown , current Value ; if ( desc ) { desc . set ( obj , key Name , value ) ; } else { is Unknown = 'object ' = = = typeof obj & & ! ( key Name in obj ) ; 
function ( key , value ) { var keys = this . keys , values = this . values , guid = guid For ( key ) ; keys . add ( key ) ; values [ guid ] = value ; set ( this , 'length ' , keys . list . length ) ; } 
function ( key ) { 
function ( callback , self ) { var keys = this . keys , values = this . values ; keys . for Each ( function ( key ) { var guid = guid For ( key ) ; callback . call ( self , key , values [ guid ] ) ; } ) ; } 
function Computed Property ( func , opts ) { this . func = func ; if ( Ember . FEATURES . is Enabled ( 'composable -computed -properties ' ) ) { set Dependent Keys ( this , opts & & opts . dependent Keys ) ; } else { this . _dependent Keys = opts & & opts . dependent Keys ; } this . _cacheable = ( opts & & opts . cacheable ! = = undefined ) ? opts . cacheable : true ; this . _read Only = opts & & ( opts . read Only ! = = undefined | | ! ! opts . read Only ) ; } 
function ( ) { var queue = this . _queue , options = this . options , before = options & & options . before , after = options & & options . after , target , method , args , stack , i , l = queue . length ; if ( l & & before ) { before ( ) ; } for ( i = 0 ; i < l ; i + = 4 ) { target = queue [ i ] ; method = queue [ i + 1 ] ; args = queue [ i + 2 ] ; stack = queue [ i + 3 ] ; 
function ( to Path , from Path ) { this . _direction = 'fwd ' ; this . _from = from Path ; this . _to = to Path ; this . _direction Map = Ember . Map . create ( ) ; } 
function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember .Binding .connect ( ) ' , ! ! obj ) ; var from Path = this . _from , to Path = this . _to ; Ember . try Set ( obj , to Path , get With Globals ( obj , from Path ) ) ; 
function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember .Binding .disconnect ( ) ' , ! ! obj ) ; var two Way = ! this . _one Way ; 
function ( from , flag ) { var C = this , binding = new C ( null , from ) ; return binding . one Way ( flag ) ; } 
function filter ( promises , filter Fn , label ) { return all ( promises , label ) . then ( function ( values ) { if ( ! is Array ( promises ) ) { throw new Type Error ( 'You must pass an array to filter . ' ) ; } if ( ! is Function ( filter Fn ) ) { throw new Type Error ( "You must pass a function to filter 's second argument . " ) ; } return map ( promises , filter Fn , label ) . then ( function ( filter Results ) { var i , values Len = values . length , filtered = [ ] ; for ( i = 0 ; i < values Len ; i + + ) { if ( filter Results [ i ] ) filtered . push ( values [ i ] ) ; } return filtered ; } ) ; } ) ; } 
function Container ( parent ) { this . parent = parent ; this . children = [ ] ; this . resolver = parent & & parent . resolver | | function ( ) { } ; this . registry = new Inheriting Dict ( parent & & parent . registry ) ; this . cache = new Inheriting Dict ( parent & & parent . cache ) ; this . factory Cache = new Inheriting Dict ( parent & & parent . factory Cache ) ; this . resolve Cache = new Inheriting Dict ( parent & & parent . resolve Cache ) ; this . type Injections = new Inheriting Dict ( parent & & parent . type Injections ) ; this . injections = { } ; this . factory Type Injections = new Inheriting Dict ( parent & & parent . factory Type Injections ) ; this . factory Injections = { } ; this . _options = new Inheriting Dict ( parent & & parent . _options ) ; this . _type Options = new Inheriting Dict ( parent & & parent . _type Options ) ; } 
function ( full Name , factory , options ) { validate Full Name ( full Name ) ; if ( factory = = = undefined ) { throw new Type Error ( 'Attempting to register an unknown factory : ` ' + full Name + ' ` ' ) ; } var normalized Name = this . normalize ( full Name ) ; if ( this . cache . has ( normalized Name ) ) { throw new Error ( 'Cannot re -register : ` ' + full Name + ' ` , as it has already been looked up . ' ) ; } this . registry . set ( normalized Name , factory ) ; this . _options . set ( normalized Name , options | | { } ) ; } 
function ( full Name ) { validate Full Name ( full Name ) ; var normalized Name = this . normalize ( full Name ) ; this . registry . remove ( normalized Name ) ; this . cache . remove ( normalized Name ) ; this . factory Cache . remove ( normalized Name ) ; this . resolve Cache . remove ( normalized Name ) ; this . _options . remove ( normalized Name ) ; } 
function ( full Name ) { validate Full Name ( full Name ) ; var normalized Name = this . normalize ( full Name ) ; var cached = this . resolve Cache . get ( normalized Name ) ; if ( cached ) { return cached ; } var resolved = this . resolver ( normalized Name ) | | this . registry . get ( normalized Name ) ; this . resolve Cache . set ( normalized Name , resolved ) ; return resolved ; } 
function ( type , property , full Name ) { validate Full Name ( full Name ) ; if ( this . parent ) { illegal Child Operation ( 'type Injection ' ) ; } add Type Injection ( this . type Injections , type , property , full Name ) ; } 
function ( full Name , property , injection Name ) { if ( this . parent ) { illegal Child Operation ( 'injection ' ) ; } validate Full Name ( injection Name ) ; var normalized Injection Name = this . normalize ( injection Name ) ; if ( full Name . index Of ( ' : ' ) = = = - 1 ) { return this . type Injection ( full Name , property , normalized Injection Name ) ; } validate Full Name ( full Name ) ; var normalized Name = this . normalize ( full Name ) ; add Injection ( this . injections , normalized Name , property , normalized Injection Name ) ; } 
function ( type , property , full Name ) { if ( this . parent ) { illegal Child Operation ( 'factory Type Injection ' ) ; } add Type Injection ( this . factory Type Injections , type , property , this . normalize ( full Name ) ) ; } 
function ( key ) { var dict = this . dict ; if ( dict . has Own Property ( key ) ) { return dict [ key ] ; } if ( this . parent ) { return this . parent . get ( key ) ; } } 
function ( key ) { var dict = this . dict ; if ( dict . has Own Property ( key ) ) { return true ; } if ( this . parent ) { return this . parent . has ( key ) ; } return false ; } 
function ( callback , binding ) { var dict = this . dict ; for ( var prop in dict ) { if ( dict . has Own Property ( prop ) ) { callback . call ( binding , prop , dict [ prop ] ) ; } } } 
function ( str , formats ) { 
function ( str , formats ) { str = Ember . STRINGS [ str ] | | str ; return Ember . String . fmt ( str , formats ) ; } 
function ( str ) { var cache = STRING _DASHERIZE _CACHE , hit = cache . has Own Property ( str ) , ret ; if ( hit ) { return cache [ str ] ; } else { ret = Ember . String . decamelize ( str ) . replace ( STRING _DASHERIZE _REGEXP , ' - ' ) ; cache [ str ] = ret ; } return ret ; } 
function ( key Name , increment ) { if ( Ember . is None ( increment ) ) { increment = 1 ; } Ember . assert ( "Must pass a numeric value to increment Property " , ( ! is Na N ( parse Float ( increment ) ) & & is Finite ( increment ) ) ) ; set ( this , key Name , ( get ( this , key Name ) | | 0 ) + increment ) ; return get ( this , key Name ) ; } 
function ( key Name , decrement ) { if ( Ember . is None ( decrement ) ) { decrement = 1 ; } Ember . assert ( "Must pass a numeric value to decrement Property " , ( ! is Na N ( parse Float ( decrement ) ) & & is Finite ( decrement ) ) ) ; set ( this , key Name , ( get ( this , key Name ) | | 0 ) - decrement ) ; return get ( this , key Name ) ; } 
function ( ) { var Class = make Ctor ( ) , proto ; Class . Class Mixin = Mixin . create ( this . Class Mixin ) ; Class . Prototype Mixin = Mixin . create ( this . Prototype Mixin ) ; Class . Class Mixin . owner Constructor = Class ; Class . Prototype Mixin . owner Constructor = Class ; reopen . apply ( Class . Prototype Mixin , arguments ) ; Class . superclass = this ; Class . _ _super _ _ = this . prototype ; proto = Class . prototype = o _create ( this . prototype ) ; proto . constructor = Class ; generate Guid ( proto ) ; meta ( proto ) . proto = proto ; 
function ( key ) { var meta = this . proto ( ) [ META _KEY ] , desc = meta & & meta . descs [ key ] ; Ember . assert ( "meta For Property ( ) could not find a computed property with key ' " + key + " ' . " , ! ! desc & & desc instanceof Ember . Computed Property ) ; return desc . _meta | | { } ; } 
function ( callback , binding ) { var proto = this . proto ( ) , descs = meta ( proto ) . descs , empty = { } , property ; for ( var name in descs ) { property = descs [ name ] ; if ( property instanceof Ember . Computed Property ) { callback . call ( binding | | this , name , property . _meta | | empty ) ; } } } 
function ( key , value ) { var exact Value = function ( item ) { return get ( item , key ) = = = value ; } , has Value = function ( item ) { return ! ! get ( item , key ) ; } , use = ( arguments . length = = = 2 ? exact Value : has Value ) ; return this . reject ( use ) ; } 
function ( value ) { if ( ! this . contains ( value ) ) return this ; 
function ( ) { var ret = Ember . A ( ) ; this . for Each ( function ( k ) { if ( a _index Of ( ret , k ) < 0 ) ret . push ( k ) ; } ) ; return ret ; } 
function ( target , opts ) { var will Change = ( opts & & opts . will Change ) | | 'array Will Change ' , did Change = ( opts & & opts . did Change ) | | 'array Did Change ' ; var has Observers = get ( this , 'has Array Observers ' ) ; if ( ! has Observers ) Ember . property Will Change ( this , 'has Array Observers ' ) ; Ember . add Listener ( this , ' @array :before ' , target , will Change ) ; Ember . add Listener ( this , ' @array :change ' , target , did Change ) ; if ( ! has Observers ) Ember . property Did Change ( this , 'has Array Observers ' ) ; return this ; } 
function ( start Idx , remove Amt , add Amt ) { 
function ( start Idx , remove Amt , add Amt ) { 
function Reduce Computed Property ( options ) { var cp = this ; this . options = options ; this . _dependent Keys = null ; 
function ( objects ) { Ember . begin Property Changes ( this ) ; for Each ( objects , function ( obj ) { this . add Object ( obj ) ; } , this ) ; Ember . end Property Changes ( this ) ; return this ; } 
function ( objects ) { Ember . begin Property Changes ( this ) ; for Each ( objects , function ( obj ) { this . remove Object ( obj ) ; } , this ) ; Ember . end Property Changes ( this ) ; return this ; } 
function ( idx , object ) { if ( idx > get ( this , 'length ' ) ) throw new Ember . Error ( OUT _OF _RANGE _EXCEPTION ) ; this . replace ( idx , 0 , [ object ] ) ; return this ; } 
function ( ) { var len = get ( this , 'length ' ) ; if ( len = = = 0 ) return null ; var ret = this . object At ( len - 1 ) ; this . remove At ( len - 1 , 1 ) ; return ret ; } 
function ( obj ) { var loc = get ( this , 'length ' ) | | 0 ; while ( - - loc > = 0 ) { var cur Object = this . object At ( loc ) ; if ( cur Object = = = obj ) this . remove At ( loc ) ; } return this ; } 
function ( opts ) { opts = opts | | { } ; var action = opts . action | | get ( this , 'action ' ) , target = opts . target | | get ( this , 'target Object ' ) , action Context = opts . action Context ; function args ( options , action Name ) { var ret = [ ] ; if ( action Name ) { ret . push ( action Name ) ; } return ret . concat ( options ) ; } if ( typeof action Context = = = 'undefined ' ) { action Context = get ( this , 'action Context Object ' ) | | this ; } if ( target & & action ) { var ret ; if ( target . send ) { ret = target . send . apply ( target , args ( action Context , action ) ) ; } else { Ember . assert ( "The action ' " + action + " ' did not exist on " + target , typeof target [ action ] = = = 'function ' ) ; ret = target [ action ] . apply ( target , args ( action Context ) ) ; } if ( ret ! = = false ) ret = true ; return ret ; } else { return false ; } } 
function ( name ) { var args = [ ] , i , l ; for ( i = 1 , l = arguments . length ; i < l ; i + + ) { args . push ( arguments [ i ] ) ; } Ember . send Event ( this , name , args ) ; } 
function ( resolve , reject , label ) { var deferred , promise , entity ; entity = this ; deferred = get ( this , ' _deferred ' ) ; promise = deferred . promise ; function fulfillment Handler ( fulfillment ) { if ( fulfillment = = = promise ) { return resolve ( entity ) ; } else { return resolve ( fulfillment ) ; } } return promise . then ( resolve & & fulfillment Handler , reject , label ) ; } 
function ( value ) { var deferred , promise ; deferred = get ( this , ' _deferred ' ) ; promise = deferred . promise ; if ( value = = = this ) { deferred . resolve ( promise ) ; } else { deferred . resolve ( value ) ; } } 
function ( props ) { var hash Name ; if ( ! props . _actions ) { Ember . assert ( " 'actions ' should not be a function " , typeof ( props . actions ) ! = = 'function ' ) ; if ( type Of ( props . actions ) = = = 'object ' ) { hash Name = 'actions ' ; } else if ( type Of ( props . events ) = = = 'object ' ) { Ember . deprecate ( 'Action handlers contained in an `events ` object are deprecated in favor of putting them in an `actions ` object ' , false ) ; hash Name = 'events ' ; } if ( hash Name ) { props . _actions = Ember . merge ( props . _actions | | { } , props [ hash Name ] ) ; } delete props [ hash Name ] ; } } 
function ( action Name ) { var args = [ ] . slice . call ( arguments , 1 ) , target ; if ( this . _actions & & this . _actions [ action Name ] ) { if ( this . _actions [ action Name ] . apply ( this , args ) = = = true ) { 
function ( index , new Items ) { var count = get ( new Items , 'length ' ) ; if ( count < 1 ) { return ; } var match = this . _find Array Operation ( index ) , array Operation = match . operation , array Operation Index = match . index , array Operation Range Start = match . range Start , compose Index , split Index , split Items , split Array Operation , new Array Operation ; new Array Operation = new Array Operation ( INSERT , count , new Items ) ; if ( array Operation ) { if ( ! match . split ) { 
function ( index , count ) { if ( count < 1 ) { return ; } var match = this . _find Array Operation ( index ) , array Operation = match . operation , array Operation Index = match . index , array Operation Range Start = match . range Start , new Array Operation , compose Index ; new Array Operation = new Array Operation ( DELETE , count ) ; if ( ! match . split ) { 
function ( callback ) { var items = [ ] , offset = 0 ; for Each ( this . _operations , function ( array Operation ) { callback ( array Operation . items , offset , array Operation . type ) ; if ( array Operation . type ! = = DELETE ) { offset + = array Operation . count ; items = items . concat ( array Operation . items ) ; } } ) ; this . _operations = [ new Array Operation ( RETAIN , items . length , items ) ] ; } 
function ( index ) { var new Array Operation = this . _operations [ index ] , left Array Operation = this . _operations [ index - 1 ] , 
function Array Operation ( operation , count , items ) { this . type = operation ; 
function Array Operation Match ( operation , index , split , range Start ) { this . operation = operation ; this . index = index ; this . split = split ; this . range Start = range Start ; } 
function ( index , match ) { var return Value = - 1 , item Type = match ? RETAIN : FILTER , self = this ; this . _find Operation ( index , function ( operation , operation Index , range Start , range End , seen In Sub Array ) { var new Operation , split Operation ; if ( item Type = = = operation . type ) { + + operation . count ; } else if ( index = = = range Start ) { 
function ( index ) { var return Value = - 1 , self = this ; this . _find Operation ( index , function ( operation , operation Index , range Start , range End , seen In Sub Array ) { if ( operation . type = = = RETAIN ) { return Value = seen In Sub Array + ( index - range Start ) ; } if ( operation . count > 1 ) { - - operation . count ; } else { self . _operations . splice ( operation Index , 1 ) ; self . _compose At ( operation Index ) ; } } , function ( ) { throw new Ember . Error ( "Can 't remove an item that has never been added . " ) ; } ) ; return return Value ; } 
function ( key Name , value ) { var ret ; ret = new Each Array ( this . _content , key Name , this ) ; Ember . define Property ( this , key Name , null , ret ) ; this . begin Observing Content Key ( key Name ) ; return ret ; } 
function ( idx , amt , objects ) { if ( this . is Frozen ) throw Ember . FROZEN _ERROR ; 
function ( ) { if ( this . is Frozen ) { throw new Ember . Error ( Ember . FROZEN _ERROR ) ; } var len = get ( this , 'length ' ) ; if ( len = = = 0 ) { return this ; } var guid ; this . enumerable Content Will Change ( len , 0 ) ; Ember . property Will Change ( this , 'first Object ' ) ; Ember . property Will Change ( this , 'last Object ' ) ; for ( var i = 0 ; i < len ; i + + ) { guid = guid For ( this [ i ] ) ; delete this [ guid ] ; delete this [ i ] ; } set ( this , 'length ' , 0 ) ; Ember . property Did Change ( this , 'first Object ' ) ; Ember . property Did Change ( this , 'last Object ' ) ; this . enumerable Content Did Change ( len , 0 ) ; return this ; } 
function ( ) { if ( get ( this , 'is Frozen ' ) ) throw new Ember . Error ( Ember . FROZEN _ERROR ) ; var obj = this . length > 0 ? this [ this . length - 1 ] : null ; this . remove ( obj ) ; return obj ; } 
function ( element , id ) { if ( element . get Attribute ( 'id ' ) = = = id ) { return element ; } var len = element . child Nodes . length , idx , node , found ; for ( idx = 0 ; idx < len ; idx + + ) { node = element . child Nodes [ idx ] ; found = node . node Type = = = 1 & & find Child By Id ( node , id ) ; if ( found ) { return found ; } } } 
function ( class Name ) { 
function ( name , value ) { var attributes = this . element Attributes = ( this . element Attributes | | { } ) ; if ( arguments . length = = = 1 ) { return attributes [ name ] ; } else { attributes [ name ] = value ; } return this ; } 
function ( name , value ) { var properties = this . element Properties = ( this . element Properties | | { } ) ; if ( arguments . length = = = 1 ) { return properties [ name ] ; } else { properties [ name ] = value ; } return this ; } 
function ( ) { if ( this . _has Element & & this . _element ) { 
function ( added Events , root Element ) { var event , events = get ( this , 'events ' ) ; Ember . $ . extend ( events , added Events | | { } ) ; if ( ! Ember . is None ( root Element ) ) { set ( this , 'root Element ' , root Element ) ; } root Element = Ember . $ ( get ( this , 'root Element ' ) ) ; Ember . assert ( fmt ( 'You cannot use the same root element ( % @ ) multiple times in an Ember .Application ' , [ root Element . selector | | root Element [ 0 ] . tag Name ] ) , ! root Element . is ( ' .ember -application ' ) ) ; Ember . assert ( 'You cannot make a new Ember .Application using a root element that is a descendent of an existing Ember .Application ' , ! root Element . closest ( ' .ember -application ' ) . length ) ; Ember . assert ( 'You cannot make a new Ember .Application using a root element that is an ancestor of an existing Ember .Application ' , ! root Element . find ( ' .ember -application ' ) . length ) ; root Element . add Class ( 'ember -application ' ) ; Ember . assert ( 'Unable to add "ember -application " class to root Element . Make sure you set root Element to the body or an element in the body . ' , root Element . is ( ' .ember -application ' ) ) ; for ( event in events ) { if ( events . has Own Property ( event ) ) { this . setup Handler ( root Element , event , events [ event ] ) ; } } } 
function ( root Element , event , event Name ) { var self = this ; root Element . on ( event + ' .ember ' , ' .ember -view ' , function ( evt , triggering Manager ) { var view = Ember . View . views [ this . id ] , result = true , manager = null ; manager = self . _find Nearest Event Manager ( view , event Name ) ; if ( manager & & manager ! = = triggering Manager ) { result = self . _dispatch Event ( manager , evt , event Name , view ) ; } else if ( view ) { result = self . _bubble Event ( view , evt , event Name ) ; } else { evt . stop Propagation ( ) ; } return result ; } ) ; root Element . on ( event + ' .ember ' , ' [data -ember -action ] ' , function ( evt ) { var action Id = Ember . $ ( evt . current Target ) . attr ( 'data -ember -action ' ) , action = Ember . Handlebars . Action Helper . registered Actions [ action Id ] ; 
function ( parent Buffer , buffer Operation ) { var name = 'render . ' + this . instrument Name , details = { } ; this . instrument Details ( details ) ; return Ember . instrument ( name , details , function instrument Render To Buffer ( ) { return this . _render To Buffer ( parent Buffer , buffer Operation ) ; } , this ) ; } 
function ( name ) { this . _super . apply ( this , arguments ) ; var method = this [ name ] ; if ( method ) { var args = [ ] , i , l ; for ( i = 1 , l = arguments . length ; i < l ; i + + ) { args . push ( arguments [ i ] ) ; } return method . apply ( this , args ) ; } } 
function ( klass ) { Ember . deprecate ( "nearest Instance Of is deprecated and will be removed from future releases . Use nearest Of Type . " ) ; var view = get ( this , 'parent View ' ) ; while ( view ) { if ( view instanceof klass ) { return view ; } view = get ( view , 'parent View ' ) ; } } 
function ( property ) { var view = get ( this , 'parent View ' ) ; while ( view ) { if ( property in view ) { return view ; } view = get ( view , 'parent View ' ) ; } } 
function ( klass ) { var view = get ( this , 'parent View ' ) ; while ( view ) { if ( get ( view , 'parent View ' ) instanceof klass ) { return view ; } view = get ( view , 'parent View ' ) ; } } 
function ( buffer ) { 
function ( ) { 
function ( buffer , attribute Bindings ) { var attribute Value , unspecified Attribute Bindings = this . _unspecified Attribute Bindings = this . _unspecified Attribute Bindings | | { } ; a _for Each ( attribute Bindings , function ( binding ) { var split = binding . split ( ' : ' ) , property = split [ 0 ] , attribute Name = split [ 1 ] | | property ; if ( property in this ) { this . _setup Attribute Binding Observation ( property , attribute Name ) ; 
function ( key , value ) { var attribute Name = this . _unspecified Attribute Bindings & & this . _unspecified Attribute Bindings [ key ] ; if ( attribute Name ) { this . _setup Attribute Binding Observation ( key , attribute Name ) ; } define Property ( this , key ) ; return set ( this , key , value ) ; } 
function ( fn , include Self ) { var child Views = ( include Self = = = false ) ? this . _child Views : [ this ] ; var current Views , view , current Child Views ; while ( child Views . length ) { current Views = child Views . slice ( ) ; child Views = [ ] ; for ( var i = 0 , l = current Views . length ; i < l ; i + + ) { view = current Views [ i ] ; current Child Views = view . _child Views ? view . _child Views . slice ( 0 ) : null ; fn ( view ) ; if ( current Child Views ) { child Views . push . apply ( child Views , current Child Views ) ; } } } } 
function ( ) { this . element Id = this . element Id | | guid For ( this ) ; this . _super ( ) ; 
function ( ) { var child Views = this . _child Views , 
function ( view , attrs ) { if ( ! view ) { throw new Type Error ( "create Child Views first argument must exist " ) ; } if ( view . is View & & view . _parent View = = = this & & view . container = = = this . container ) { return view ; } attrs = attrs | | { } ; attrs . _parent View = this ; if ( Ember . Core View . detect ( view ) ) { attrs . template Data = attrs . template Data | | get ( this , 'template Data ' ) ; attrs . container = this . container ; view = view . create ( attrs ) ; 
function ( path ) { var split = path . split ( ' : ' ) , property Path = split [ 0 ] , class Names = " " , class Name , falsy Class Name ; 
function ( view , fn ) { view . create Element ( ) ; var view Collection = view . view Hierarchy Collection ( ) ; view Collection . trigger ( 'will Insert Element ' ) ; fn . call ( view ) ; 
function ( view , child View , options ) { var buffer = view . buffer , _child Views = view . _child Views ; child View = view . create Child View ( child View , options ) ; if ( ! _child Views . length ) { _child Views = view . _child Views = _child Views . slice ( ) ; } _child Views . push ( child View ) ; child View . render To Buffer ( buffer ) ; view . property Did Change ( 'child Views ' ) ; return child View ; } 
function ( view ) { view . clear Buffer ( ) ; var view Collection = view . _notify Will Destroy Element ( ) ; view Collection . transition To ( 'pre Render ' , false ) ; return view ; } 
function ( view ) { view . trigger Recursively ( 'will Clear Render ' ) ; view . clear Rendered Children ( ) ; view . dom Manager . replace ( view ) ; return view ; } 
function ( view ) { view . _notify Will Destroy Element ( ) ; view . dom Manager . remove ( view ) ; set ( view , 'element ' , null ) ; if ( view . _scheduled Insert ) { Ember . run . cancel ( view . _scheduled Insert ) ; view . _scheduled Insert = null ; } return view ; } 
function ( view , event Name , evt ) { if ( view . has ( event Name ) ) { 
function ( views , start , removed ) { this . property Will Change ( 'child Views ' ) ; if ( removed > 0 ) { var changed Views = views . slice ( start , start + removed ) ; 
function ( views , start , removed , added ) { if ( added > 0 ) { var changed Views = views . slice ( start , start + added ) ; this . initialize Views ( changed Views , this , get ( this , 'template Data ' ) ) ; this . current State . child Views Did Change ( this , views , start , added ) ; } this . property Did Change ( 'child Views ' ) ; } 
function ( content , start , removed Count ) { 
function ( content , start , removed , added ) { var added Views = [ ] , view , item , idx , len , item View Class , empty View ; len = content ? get ( content , 'length ' ) : 0 ; if ( len ) { item View Class = get ( this , 'item View Class ' ) ; if ( 'string ' = = = typeof item View Class ) { item View Class = get ( item View Class ) | | item View Class ; } Ember . assert ( fmt ( "item View Class must be a subclass of Ember .View , not % @ " , [ item View Class ] ) , 'string ' = = = typeof item View Class | | Ember . View . detect ( item View Class ) ) ; for ( idx = start ; idx < start + added ; idx + + ) { item = content . object At ( idx ) ; view = this . create Child View ( item View Class , { content : item , content Index : idx } ) ; added Views . push ( view ) ; } } else { empty View = get ( this , 'empty View ' ) ; if ( ! empty View ) { return ; } if ( 'string ' = = = typeof empty View ) { empty View = get ( empty View ) | | empty View ; } empty View = this . create Child View ( empty View ) ; added Views . push ( empty View ) ; set ( this , 'empty View ' , empty View ) ; if ( Ember . Core View . detect ( empty View ) ) { this . _created Empty View = empty View ; } } this . replace ( start , 0 , added Views ) ; } 
function ( props ) { 
function ( action ) { var action Name , contexts = a _slice . call ( arguments , 1 ) ; 
function ( html ) { var self ; if ( this instanceof Metamorph ) { self = this ; } else { self = new K ( ) ; } self . inner HTML = html ; var my Guid = 'metamorph - ' + ( guid + + ) ; self . start = my Guid + ' -start ' ; self . end = my Guid + ' -end ' ; return self ; } 
function ( parent Node , html ) { var arr = wrap Map [ parent Node . tag Name . to Lower Case ( ) ] | | wrap Map . _default ; var depth = arr [ 0 ] , start = arr [ 1 ] , end = arr [ 2 ] ; if ( needs Shy ) { html = ' &shy ; ' + html ; } var element = document . create Element ( 'div ' ) ; set Inner HTML ( element , start + html + end ) ; for ( var i = 0 ; i < = depth ; i + + ) { element = element . first Child ; } 
function ( start , end ) { if ( start . parent Node ! = = end . parent Node ) { end . parent Node . insert Before ( start , end . parent Node . first Child ) ; } } 
function evaluate Unbound Helper ( context , fn , normalized Properties , options ) { var args = [ ] , hash = options . hash , bound Options = hash . bound Options , types = slice . call ( options . types , 1 ) , loc , len , property , property Type , bound Option ; for ( bound Option in bound Options ) { if ( ! bound Options . has Own Property ( bound Option ) ) { continue ; } hash [ bound Option ] = Ember . Handlebars . get ( context , bound Options [ bound Option ] , options ) ; } for ( loc = 0 , len = normalized Properties . length ; loc < len ; + + loc ) { property = normalized Properties [ loc ] ; property Type = types [ loc ] ; if ( property Type = = = "ID " ) { args . push ( Ember . Handlebars . get ( property . root , property . path , options ) ) ; } else { args . push ( property . path ) ; } } args . push ( options ) ; return fn . apply ( context , args ) ; } 
function ( view ) { var morph = view . morph ; view . transition To ( 'pre Render ' ) ; Ember . run . schedule ( 'render ' , this , function render Metamorph View ( ) { if ( view . is Destroying ) { return ; } view . clear Rendered Children ( ) ; var buffer = view . render To Buffer ( ) ; view . invoke Recursively ( function ( view ) { view . property Will Change ( 'element ' ) ; } ) ; view . trigger Recursively ( 'will Insert Element ' ) ; morph . replace With ( buffer . string ( ) ) ; view . transition To ( 'in DOM ' ) ; view . invoke Recursively ( function ( view ) { view . property Did Change ( 'element ' ) ; } ) ; view . trigger Recursively ( 'did Insert Element ' ) ; notify Mutation Listeners ( ) ; } ) ; } 
function bind ( property , options , preserve Context , should Display , value Normalizer , child Properties ) { var data = options . data , fn = options . fn , inverse = options . inverse , view = data . view , current Context = this , normalized , observer , i ; normalized = normalize Path ( current Context , property , data ) ; 
function ( path , data ) { var normalized = Ember . Handlebars . normalize Path ( null , path , data ) ; if ( normalized . is Keyword ) { return 'template Data .keywords . ' + path ; } else if ( Ember . is Global Path ( path ) ) { return null ; } else if ( path = = = 'this ' | | path = = = ' ' ) { return ' _parent View .context ' ; } else { return ' _parent View .context . ' + path ; } } 
function _add Metamorph Check ( ) { Ember . Handlebars . Each View . reopen ( { _check Metamorph : Ember . on ( 'did Insert Element ' , function ( ) { Ember . assert ( "The metamorph tags , " + this . morph . start + " and " + this . morph . end + " , have different parents . \n The browser has fixed your template to output valid HTML (for example , check that you have properly closed all tags and have used a TBODY tag when creating a table with ' { { #each } } ' ) " , document . get Element By Id ( this . morph . start ) . parent Node = = = document . get Element By Id ( this . morph . end ) . parent Node ) ; } ) } ) ; } 
function ( intent , is Intermediate ) { var was Transitioning = ! ! this . active Transition ; var old State = was Transitioning ? this . active Transition . state : this . state ; var new Transition ; var router = this ; try { var new State = intent . apply To State ( old State , this . recognizer , this . get Handler , is Intermediate ) ; if ( handler Infos Equal ( new State . handler Infos , old State . handler Infos ) ) { 
function ( ) { if ( this . state ) { for Each ( this . state . handler Infos , function ( handler Info ) { var handler = handler Info . handler ; if ( handler . exit ) { handler . exit ( ) ; } } ) ; } this . state = new Transition State ( ) ; this . current Handler Infos = null ; } 
function ( url ) { 
function setup Contexts ( router , new State , transition ) { var partition = partition Handlers ( router . state , new State ) ; for Each ( partition . exited , function ( handler Info ) { var handler = handler Info . handler ; delete handler . context ; if ( handler . exit ) { handler . exit ( ) ; } } ) ; var old State = router . old State = router . state ; router . state = new State ; var current Handler Infos = router . current Handler Infos = partition . unchanged . slice ( ) ; try { for Each ( partition . updated Context , function ( handler Info ) { return handler Entered Or Updated ( current Handler Infos , handler Info , false , transition ) ; } ) ; for Each ( partition . entered , function ( handler Info ) { return handler Entered Or Updated ( current Handler Infos , handler Info , true , transition ) ; } ) ; } catch ( e ) { router . state = old State ; router . current Handler Infos = old State . handler Infos ; throw e ; } router . state . query Params = finalize Query Param Change ( router , current Handler Infos , new State . query Params ) ; } 
function handler Entered Or Updated ( current Handler Infos , handler Info , enter , transition ) { var handler = handler Info . handler , context = handler Info . context ; if ( enter & & handler . enter ) { handler . enter ( transition ) ; } if ( transition & & transition . is Aborted ) { throw new Transition Aborted ( ) ; } handler . context = context ; if ( handler . context Did Change ) { handler . context Did Change ( ) ; } if ( handler . setup ) { handler . setup ( context , transition ) ; } if ( transition & & transition . is Aborted ) { throw new Transition Aborted ( ) ; } current Handler Infos . push ( handler Info ) ; return true ; } 
function do Transition ( router , args , is Intermediate ) { 
function ( ) { if ( this . is Aborted ) { return this ; } log ( this . router , this . sequence , this . target Name + " : transition was aborted " ) ; this . is Aborted = true ; this . is Active = false ; this . router . active Transition = null ; return this ; } 
function ( ) { var router = this . router ; return this . promise [ 'catch ' ] ( function ( reason ) { if ( router . active Transition ) { return router . active Transition . follow Redirects ( ) ; } return reject ( reason ) ; } ) ; } 
function extract Query Params ( array ) { var len = ( array & & array . length ) , head , query Params ; if ( len & & len > 0 & & array [ len - 1 ] & & array [ len - 1 ] . has Own Property ( 'query Params ' ) ) { query Params = array [ len - 1 ] . query Params ; head = slice . call ( array , 0 , len - 1 ) ; return [ head , query Params ] ; } else { return [ array , null ] ; } } 
function serialize ( handler , model , names ) { var object = { } ; if ( is Param ( model ) ) { object [ names [ 0 ] ] = model ; return object ; } 
function ( ) { this . router = this . router | | this . constructor . map ( Ember . K ) ; var router = this . router , location = get ( this , 'location ' ) , container = this . container , self = this , initial URL = get ( this , 'initial URL ' ) ; 
function ( results , query Params , callback ) { for ( var name in query Params ) { var parts = name . split ( ' : ' ) ; var controller = controller Or Proto For ( parts [ 0 ] , this . container ) ; Ember . assert ( fmt ( "Could not lookup controller ' % @ ' while setting up query params " , [ controller ] ) , controller ) ; 
function ( context , transition ) { var controller Name = this . controller Name | | this . route Name , controller = this . controller For ( controller Name , true ) ; if ( ! controller ) { controller = this . generate Controller ( controller Name , context ) ; } 
function ( params , transition ) { var match , name , saw Params , value ; for ( var prop in params ) { if ( prop = = = 'query Params ' ) { continue ; } if ( match = prop . match ( / ^ ( . * ) _id $ / ) ) { name = match [ 1 ] ; value = params [ prop ] ; } saw Params = true ; } if ( ! name & & saw Params ) { return Ember . copy ( params ) ; } else if ( ! name ) { if ( transition . resolve Index ! = = transition . state . handler Infos . length - 1 ) { return ; } var parent Model = transition . state . handler Infos [ transition . resolve Index - 1 ] . context ; return parent Model ; } return this . find Model ( name , value ) ; } 
function ( model , params ) { if ( params . length < 1 ) { return ; } if ( ! model ) { return ; } var name = params [ 0 ] , object = { } ; if ( / _id $ / . test ( name ) & & params . length = = = 1 ) { object [ name ] = get ( model , "id " ) ; } else { object = get Properties ( model , params ) ; } return object ; } 
function ( name , _skip Assert ) { var container = this . container , route = container . lookup ( 'route : ' + name ) , controller ; if ( route & & route . controller Name ) { name = route . controller Name ; } controller = container . lookup ( 'controller : ' + name ) ; 
function ( options ) { if ( ! options | | typeof options = = = "string " ) { var outlet Name = options ; options = { } ; options . outlet = outlet Name ; } options . parent View = options . parent View ? options . parent View . replace ( / \ / / g , ' . ' ) : parent Template ( this ) ; options . outlet = options . outlet | | 'main ' ; var parent View = this . router . _lookup Active View ( options . parent View ) ; if ( parent View ) { parent View . disconnect Outlet ( options . outlet ) ; } } 
function ( ) { 
function ( ) { var helper Parameters = this . parameters , link Text Path = helper Parameters . options . link Text Path , paths = get Resolved Paths ( helper Parameters ) , length = paths . length , path , i , normalized Path ; if ( link Text Path ) { normalized Path = Ember . Handlebars . normalize Path ( helper Parameters . context , link Text Path , helper Parameters . options . data ) ; this . register Observer ( normalized Path . root , normalized Path . path , this , this . rerender ) ; } for ( i = 0 ; i < length ; i + + ) { path = paths [ i ] ; if ( null = = = path ) { 
function ( event ) { if ( ! is Simple Click ( event ) ) { return true ; } if ( this . prevent Default ! = = false ) { event . prevent Default ( ) ; } if ( this . bubbles = = = false ) { event . stop Propagation ( ) ; } if ( get ( this , ' _is Disabled ' ) ) { return false ; } if ( get ( this , 'loading ' ) ) { Ember . Logger . warn ( "This link -to is in an inactive loading state because at least one of its parameters presently has a null /undefined value , or the provided route name is invalid . " ) ; return false ; } var router = get ( this , 'router ' ) , route Args = get ( this , 'route Args ' ) ; var transition ; if ( get ( this , 'replace ' ) ) { transition = router . replace With . apply ( router , route Args ) ; } else { transition = router . transition To . apply ( router , route Args ) ; } 
function ( ) { 
function ( ) { 
function ( outlet Name , view ) { var existing View = get ( this , ' _outlets . ' + outlet Name ) ; return existing View & & existing View . constructor = = = view . constructor & & existing View . get ( 'template ' ) = = = view . get ( 'template ' ) & & existing View . get ( 'context ' ) = = = view . get ( 'context ' ) ; } 
function ( ) { if ( this . is Destroyed ) return ; 
function ( ) { 
function ( path ) { var state = { path : path } ; get ( this , 'history ' ) . replace State ( state , null , path ) ; 
function ( callback ) { var guid = Ember . guid For ( this ) , self = this ; Ember . $ ( window ) . on ( 'popstate .ember -location - ' + guid , function ( e ) { 
function ( ) { 
function ( ) { var window = this . _window , document Mode = window . document . document Mode ; return ( 'onhashchange ' in window & & ( document Mode = = = undefined | | document Mode > 7 ) ) ; } 
function ( options ) { if ( options & & options . root URL ) { Ember . assert ( 'root URL must end with a trailing forward slash e .g . " /app / " ' , options . root URL . char At ( options . root URL . length - 1 ) = = = ' / ' ) ; this . root URL = options . root URL ; } var history Path , hash Path , cancel Router Setup = false , implementation Class = this . _None Location , current Path = this . _get Full Path ( ) ; if ( this . _get Supports History ( ) ) { history Path = this . _get History Path ( ) ; 
function ( full Name ) { var parsed Name = this . parse Name ( full Name ) , resolve Method Name = parsed Name . resolve Method Name ; if ( ! ( parsed Name . name & & parsed Name . type ) ) { throw new Type Error ( "Invalid full Name : ` " + full Name + " ` , must be of the form `type :name ` " ) ; } if ( this [ resolve Method Name ] ) { var resolved = this [ resolve Method Name ] ( parsed Name ) ; if ( resolved ) { return resolved ; } } return this . resolve Other ( parsed Name ) ; } 
function ( full Name ) { var name Parts = full Name . split ( " : " ) , type = name Parts [ 0 ] , full Name Without Type = name Parts [ 1 ] , name = full Name Without Type , namespace = get ( this , 'namespace ' ) , root = namespace ; if ( type ! = = 'template ' & & name . index Of ( ' / ' ) ! = = - 1 ) { var parts = name . split ( ' / ' ) ; name = parts [ parts . length - 1 ] ; var namespace Name = capitalize ( parts . slice ( 0 , - 1 ) . join ( ' . ' ) ) ; root = Ember . Namespace . by Name ( namespace Name ) ; Ember . assert ( 'You are looking for a ' + name + ' ' + type + ' in the ' + namespace Name + ' namespace , but the namespace could not be found ' , root ) ; } return { full Name : full Name , type : type , full Name Without Type : full Name Without Type , name : name , root : root , resolve Method Name : "resolve " + classify ( type ) } ; } 
function ( parsed Name ) { var template Name = parsed Name . full Name Without Type . replace ( / \ . / g , ' / ' ) ; if ( Ember . TEMPLATES [ template Name ] ) { return Ember . TEMPLATES [ template Name ] ; } template Name = decamelize ( template Name ) ; if ( Ember . TEMPLATES [ template Name ] ) { return Ember . TEMPLATES [ template Name ] ; } } 
function ( ) { if ( this . Router = = = false ) { return ; } var container = this . _ _container _ _ ; if ( this . Router ) { container . unregister ( 'router :main ' ) ; container . register ( 'router :main ' , this . Router ) ; } return container . lookup Factory ( 'router :main ' ) ; } 
function ( ) { var self = this ; if ( ! this . $ | | this . $ . is Ready ) { Ember . run . schedule ( 'actions ' , self , ' _initialize ' ) ; } else { this . $ ( ) . ready ( function run Initialize ( ) { Ember . run ( self , ' _initialize ' ) ; } ) ; } } 
function ( ) { Ember . assert ( "You must call advance Readiness on an instance of Ember .Application " , this instanceof Ember . Application ) ; this . _readiness Deferrals - - ; if ( this . _readiness Deferrals = = = 0 ) { Ember . run . once ( this , this . did Become Ready ) ; } } 
function ( ) { this . _readiness Deferrals = 1 ; function handle Reset ( ) { var router = this . _ _container _ _ . lookup ( 'router :main ' ) ; router . reset ( ) ; Ember . run ( this . _ _container _ _ , 'destroy ' ) ; this . build Container ( ) ; Ember . run . schedule ( 'actions ' , this , function ( ) { this . _initialize ( ) ; } ) ; } Ember . run . join ( this , handle Reset ) ; } 
function ( ) { var custom Events = get ( this , 'custom Events ' ) , root Element = get ( this , 'root Element ' ) , dispatcher = this . _ _container _ _ . lookup ( 'event _dispatcher :main ' ) ; set ( this , 'event Dispatcher ' , dispatcher ) ; dispatcher . setup ( custom Events , root Element ) ; } 
function ( namespace ) { var container = new Ember . Container ( ) ; Ember . Container . default Container = new Deprecated Container ( container ) ; container . set = Ember . set ; container . resolver = resolver For ( namespace ) ; container . normalize = container . resolver . normalize ; container . describe = container . resolver . describe ; container . make To String = container . resolver . make To String ; container . options For Type ( 'component ' , { singleton : false } ) ; container . options For Type ( 'view ' , { singleton : false } ) ; container . options For Type ( 'template ' , { instantiate : false } ) ; container . options For Type ( 'helper ' , { instantiate : false } ) ; container . register ( 'application :main ' , namespace , { instantiate : false } ) ; container . register ( 'controller :basic ' , Ember . Controller , { instantiate : false } ) ; container . register ( 'controller :object ' , Ember . Object Controller , { instantiate : false } ) ; container . register ( 'controller :array ' , Ember . Array Controller , { instantiate : false } ) ; container . register ( 'route :basic ' , Ember . Route , { instantiate : false } ) ; container . register ( 'event _dispatcher :main ' , Ember . Event Dispatcher ) ; container . register ( 'router :main ' , Ember . Router ) ; container . injection ( 'router :main ' , 'namespace ' , 'application :main ' ) ; container . register ( 'location :auto ' , Ember . Auto Location ) ; container . register ( 'location :hash ' , Ember . Hash Location ) ; container . register ( 'location :history ' , Ember . History Location ) ; container . register ( 'location :none ' , Ember . None Location ) ; container . injection ( 'controller ' , 'target ' , 'router :main ' ) ; container . injection ( 'controller ' , 'namespace ' , 'application :main ' ) ; container . injection ( 'route ' , 'router ' , 'router :main ' ) ; container . injection ( 'location ' , 'root URL ' , ' -location -setting :root -url ' ) ; 
function ( type , records Added , records Updated , records Removed ) { var self = this , release Methods = Ember . A ( ) , records = this . get Records ( type ) , release ; var record Updated = function ( updated Record ) { records Updated ( [ updated Record ] ) ; } ; var records To Send = records . map ( function ( record ) { release Methods . push ( self . observe Record ( record , record Updated ) ) ; return self . wrap Record ( record ) ; } ) ; var content Did Change = function ( array , idx , removed Count , added Count ) { for ( var i = idx ; i < idx + added Count ; i + + ) { var record = array . object At ( i ) ; var wrapped = self . wrap Record ( record ) ; release Methods . push ( self . observe Record ( record , record Updated ) ) ; records Added ( [ wrapped ] ) ; } if ( removed Count ) { records Removed ( idx , removed Count ) ; } } ; var observer = { did Change : content Did Change , will Change : Ember . K } ; records . add Array Observer ( self , observer ) ; release = function ( ) { release Methods . for Each ( function ( fn ) { fn ( ) ; } ) ; records . remove Array Observer ( self , observer ) ; self . release Methods . remove Object ( release ) ; } ; records Added ( records To Send ) ; this . release Methods . push Object ( release ) ; return release ; } 
function ( type , types Updated ) { var self = this , records = this . get Records ( type ) ; var on Change = function ( ) { types Updated ( [ self . wrap Model Type ( type ) ] ) ; } ; var observer = { did Change : function ( ) { Ember . run . schedule Once ( 'actions ' , this , on Change ) ; } , will Change : Ember . K } ; records . add Array Observer ( this , observer ) ; var release = function ( ) { records . remove Array Observer ( self , observer ) ; } ; return release ; } 
function ( ) { var namespaces = Ember . A ( Ember . Namespace . NAMESPACES ) , types = Ember . A ( ) ; namespaces . for Each ( function ( namespace ) { for ( var key in namespace ) { if ( ! namespace . has Own Property ( key ) ) { continue ; } var name = Ember . String . dasherize ( key ) ; if ( ! ( namespace instanceof Ember . Application ) & & namespace . to String ( ) ) { name = namespace + ' / ' + name ; } types . push ( name ) ; } } ) ; return types ; } 
function ( context , callback ) { if ( arguments . length = = = 1 ) { callback = context ; context = null ; } if ( ! this . waiters ) { this . waiters = Ember . A ( ) ; } this . waiters . push ( [ context , callback ] ) ; } 
function ( context , callback ) { var pair ; if ( ! this . waiters ) { return ; } if ( arguments . length = = = 1 ) { callback = context ; context = null ; } pair = [ context , callback ] ; this . waiters = Ember . A ( this . waiters . filter ( function ( elt ) { return Ember . compare ( elt , pair ) ! = = 0 ; } ) ) ; } 
function ( helper Container ) { if ( helper Container ) { this . helper Container = helper Container ; } this . test Helpers = { } ; for ( var name in helpers ) { this . original Methods [ name ] = this . helper Container [ name ] ; this . test Helpers [ name ] = this . helper Container [ name ] = helper ( this , name ) ; proto Wrap ( Ember . Test . Promise . prototype , name , helper ( this , name ) , helpers [ name ] . meta . wait ) ; } for ( var i = 0 , l = inject Helpers Callbacks . length ; i < l ; i + + ) { inject Helpers Callbacks [ i ] ( this ) ; } } 
function ( ) { for ( var name in helpers ) { this . helper Container [ name ] = this . original Methods [ name ] ; delete this . test Helpers [ name ] ; delete this . original Methods [ name ] ; } } 
function proto Wrap ( proto , name , callback , is Async ) { proto [ name ] = function ( ) { var args = arguments ; if ( is Async ) { return callback . apply ( this , args ) ; } else { return this . then ( function ( ) { return callback . apply ( this , args ) ; } ) ; } } ; } 
function cleaner Eval ( str , old Console ) { var log Arr = [ ] ; var console = { log : function ( msg ) { log Arr . push ( msg ) ; old Console . log ( msg ) ; } } ; eval ( str ) ; return log Arr ; } 
function to Property Descriptor ( obj ) { if ( Object ( obj ) ! = = obj ) { throw new Type Error ( "property descriptor should be an Object , given : " + obj ) ; } var desc = { } ; if ( 'enumerable ' in obj ) { desc . enumerable = ! ! obj . enumerable ; } if ( 'configurable ' in obj ) { desc . configurable = ! ! obj . configurable ; } if ( 'value ' in obj ) { desc . value = obj . value ; } if ( 'writable ' in obj ) { desc . writable = ! ! obj . writable ; } if ( 'get ' in obj ) { var getter = obj . get ; if ( getter ! = = undefined & & typeof getter ! = = "function " ) { throw new Type Error ( "property descriptor 'get ' attribute must be " + "callable or undefined , given : " + getter ) ; } desc . get = getter ; } if ( 'set ' in obj ) { var setter = obj . set ; if ( setter ! = = undefined & & typeof setter ! = = "function " ) { throw new Type Error ( "property descriptor 'set ' attribute must be " + "callable or undefined , given : " + setter ) ; } desc . set = setter ; } if ( 'get ' in desc | | 'set ' in desc ) { if ( 'value ' in desc | | 'writable ' in desc ) { throw new Type Error ( "property descriptor cannot be both a data and an " + "accessor descriptor : " + obj ) ; } } return desc ; } 
function normalize And Complete Property Descriptor ( attributes ) { if ( attributes = = = undefined ) { return undefined ; } var desc = to Complete Property Descriptor ( attributes ) ; 
function normalize Property Descriptor ( attributes ) { var desc = to Property Descriptor ( attributes ) ; 
function is Compatible Descriptor ( extensible , current , desc ) { if ( current = = = undefined & & extensible = = = false ) { return false ; } if ( current = = = undefined & & extensible = = = true ) { return true ; } if ( is Empty Descriptor ( desc ) ) { return true ; } if ( is Equivalent Descriptor ( current , desc ) ) { return true ; } if ( current . configurable = = = false ) { if ( desc . configurable = = = true ) { return false ; } if ( 'enumerable ' in desc & & desc . enumerable ! = = current . enumerable ) { return false ; } } if ( is Generic Descriptor ( desc ) ) { return true ; } if ( is Data Descriptor ( current ) ! = = is Data Descriptor ( desc ) ) { if ( current . configurable = = = false ) { return false ; } return true ; } if ( is Data Descriptor ( current ) & & is Data Descriptor ( desc ) ) { if ( current . configurable = = = false ) { if ( current . writable = = = false & & desc . writable = = = true ) { return false ; } if ( current . writable = = = false ) { if ( 'value ' in desc & & ! same Value ( desc . value , current . value ) ) { return false ; } } } return true ; } if ( is Accessor Descriptor ( current ) & & is Accessor Descriptor ( desc ) ) { if ( current . configurable = = = false ) { if ( 'set ' in desc & & ! same Value ( desc . set , current . set ) ) { return false ; } if ( 'get ' in desc & & ! same Value ( desc . get , current . get ) ) { return false ; } } } return true ; } 
function ( trap Name ) { var trap = this . handler [ trap Name ] ; if ( trap = = = undefined ) { 
function ( name ) { "use strict " ; var trap = this . get Trap ( "get Own Property Descriptor " ) ; if ( trap = = = undefined ) { return Reflect . get Own Property Descriptor ( this . target , name ) ; } name = String ( name ) ; var desc = trap . call ( this . handler , this . target , name ) ; desc = normalize And Complete Property Descriptor ( desc ) ; var target Desc = Object . get Own Property Descriptor ( this . target , name ) ; var extensible = Object . is Extensible ( this . target ) ; if ( desc = = = undefined ) { if ( is Sealed Desc ( target Desc ) ) { throw new Type Error ( "cannot report non -configurable property ' " + name + " ' as non -existent " ) ; } if ( ! extensible & & target Desc ! = = undefined ) { 
function ( name ) { var handler = this ; if ( ! handler . has ( name ) ) return undefined ; return { get : function ( ) { return handler . get ( this , name ) ; } , set : function ( val ) { if ( handler . set ( this , name , val ) ) { return val ; } else { throw new Type Error ( "failed assignment to " + name ) ; } } , enumerable : true , configurable : true } ; } 
function ( ) { var trap = this . get Trap ( "freeze " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "seal " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "prevent Extensions " ) ; if ( trap = = = undefined ) { 
function ( name ) { "use strict " ; var trap = this . get Trap ( "delete Property " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "is Extensible " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "get Prototype Of " ) ; if ( trap = = = undefined ) { 
function ( new Proto ) { var trap = this . get Trap ( "set Prototype Of " ) ; if ( trap = = = undefined ) { 
function ( name ) { "use strict " ; var trap = this . get Trap ( "has Own " ) ; if ( trap = = = undefined ) { 
function ( receiver , name ) { if (name = = = ' _ _no Such Method _ _ ' ) { var handler = this ; return function (name , args ) { return handler .invoke (receiver , name , args ) ; } } * / var trap = this . get Trap ( "get " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "iterate " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "keys " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "own Keys " ) ; if ( trap = = = undefined ) { 
function ( target , this Binding , args ) { var trap = this . get Trap ( "apply " ) ; if ( trap = = = undefined ) { return Reflect . apply ( target , this Binding , args ) ; } if ( typeof this . target = = = "function " ) { return trap . call ( this . handler , target , this Binding , args ) ; } else { throw new Type Error ( "apply : " + target + " is not a function " ) ; } } 
function ( target , args ) { var trap = this . get Trap ( "construct " ) ; if ( trap = = = undefined ) { return Reflect . construct ( target , args ) ; } if ( typeof this . target = = = "function " ) { return trap . call ( this . handler , target , args ) ; } else { throw new Type Error ( "new : " + target + " is not a function " ) ; } } 
function ( ) { var trap = this . get Trap ( "is Sealed " ) ; if ( trap = = = undefined ) { 
function ( ) { var trap = this . get Trap ( "is Frozen " ) ; if ( trap = = = undefined ) { 
function make Unwrapping 0Arg Method ( primitive ) { return function builtin ( ) { var v Handler = safe Weak Map Get ( direct Proxies , this ) ; if ( v Handler ! = = undefined ) { return builtin . call ( v Handler . target ) ; } else { return primitive . call ( this ) ; } } } 
function ( target ) { var handler = direct Proxies . get ( target ) ; if ( handler ! = = undefined ) { return handler . own Keys ( handler . target ) ; } var result = Reflect . get Own Property Names ( target ) ; var l = + result . length ; var idx = 0 ; return { next : function ( ) { if ( idx = = = l ) throw Stop Iteration ; return result [ idx + + ] ; } } ; } 
function ( target ) { var success = this . prevent Extensions ( target ) ; success = ! ! success ; 
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; return v Handler . apply ( target , this , args ) ; } 
function load ( obj ) { var name , root ; root = typeof global ! = = "undefined " & & global ! = = null ? global : this ; for ( name in obj ) { if ( obj . has Own Property ( name ) ) { root [ name ] = obj [ name ] ; } } } 
function ( type , data ) { type . each Transformed Attribute ( function ( key , type ) { var transform = this . transform For ( type ) ; data [ key ] = transform . deserialize ( data [ key ] ) ; } , this ) ; return data ; } 
function ( record , options ) { var json = { } ; if ( options & & options . include Id ) { var id = get ( record , 'id ' ) ; if ( id ) { json [ get ( this , 'primary Key ' ) ] = id ; } } record . each Attribute ( function ( key , attribute ) { this . serialize Attribute ( record , json , key , attribute ) ; } , this ) ; record . each Relationship ( function ( key , relationship ) { if ( relationship . kind = = = 'belongs To ' ) { this . serialize Belongs To ( record , json , relationship ) ; } else if ( relationship . kind = = = 'has Many ' ) { this . serialize Has Many ( record , json , relationship ) ; } } , this ) ; return json ; } 
function ( record , json , key , attribute ) { var attrs = get ( this , 'attrs ' ) ; var value = get ( record , key ) , type = attribute . type ; if ( type ) { var transform = this . transform For ( type ) ; value = transform . serialize ( value ) ; } 
function ( record , json , relationship ) { var key = relationship . key ; var belongs To = get ( record , key ) ; key = this . key For Relationship ? this . key For Relationship ( key , "belongs To " ) : key ; if ( is None ( belongs To ) ) { json [ key ] = belongs To ; } else { json [ key ] = get ( belongs To , 'id ' ) ; } if ( relationship . options . polymorphic ) { this . serialize Polymorphic Type ( record , json , relationship ) ; } } 
function ( record , json , relationship ) { var key = relationship . key ; var relationship Type = DS . Relationship Change . determine Relationship Type ( record . constructor , relationship ) ; if ( relationship Type = = = 'many To None ' | | relationship Type = = = 'many To Many ' ) { json [ key ] = get ( record , key ) . map By ( 'id ' ) ; 
function ( store , type , payload , id , request Type ) { this . extract Meta ( store , type , payload ) ; var specific Extract = "extract " + request Type . char At ( 0 ) . to Upper Case ( ) + request Type . substr ( 1 ) ; return this [ specific Extract ] ( store , type , payload , id , request Type ) ; } 
function ( store , type , payload ) { if ( payload & & payload . meta ) { store . meta For Type ( type , payload . meta ) ; delete payload . meta ; } } 
function ( attribute Type , skip Assertion ) { var transform = this . container . lookup ( 'transform : ' + attribute Type ) ; Ember . assert ( "Unable to find transform for ' " + attribute Type + " ' " , skip Assertion | | ! ! transform ) ; return transform ; } 
function ( ) { var promise Label = "DS : Record Array #save " + get ( this , 'type ' ) ; var promise = Ember . RSVP . all ( this . invoke ( "save " ) , promise Label ) . then ( function ( array ) { return Ember . A ( array ) ; } , null , "DS : Record Array #save apply Ember .Native Array " ) ; return DS . Promise Array . create ( { promise : promise } ) ; } 
function ( index , removed , added ) { 
function ( hash ) { var owner = get ( this , 'owner ' ) , store = get ( owner , 'store ' ) , type = get ( this , 'type ' ) , record ; Ember . assert ( "You cannot add ' " + type . type Key + " ' records to this polymorphic relationship . " , ! get ( this , 'is Polymorphic ' ) ) ; record = store . create Record . call ( store , type , hash ) ; this . push Object ( record ) ; return record ; } 
function ( type , properties ) { type = this . model For ( type ) ; properties = copy ( properties ) | | { } ; 
function ( type ) { var adapter = this . adapter For ( type ) ; if ( adapter & & adapter . generate Id For Record ) { return adapter . generate Id For Record ( this ) ; } return null ; } 
function ( type , id ) { if ( id = = = undefined ) { return this . find All ( type ) ; } 
function ( type , id ) { type = this . model For ( type ) ; var record = this . record For Id ( type , id ) ; var promise = this . fetch Record ( record ) | | resolve ( record , "DS : Store #find By Id " + type + " with id : " + id ) ; return promise Object ( promise ) ; } 
function ( type , ids ) { var store = this ; var promise Label = "DS : Store #find By Ids " + type ; return promise Array ( Ember . RSVP . all ( map ( ids , function ( id ) { return store . find By Id ( type , id ) ; } ) ) . then ( Ember . A , null , "DS : Store #find By Ids of " + type + " complete " ) ) ; } 
function ( record ) { if ( is None ( record ) ) { return null ; } if ( record . _loading Promise ) { return record . _loading Promise ; } if ( ! get ( record , 'is Empty ' ) ) { return null ; } var type = record . constructor , id = get ( record , 'id ' ) ; var adapter = this . adapter For ( type ) ; Ember . assert ( "You tried to find a record but you have no adapter (for " + type + " ) " , adapter ) ; Ember . assert ( "You tried to find a record but your adapter (for " + type + " ) does not implement 'find ' " , adapter . find ) ; var promise = _find ( adapter , this , type , id ) ; record . loading Data ( promise ) ; return promise ; } 
function ( record ) { var type = record . constructor , adapter = this . adapter For ( type ) , id = get ( record , 'id ' ) ; Ember . assert ( "You cannot reload a record without an ID " , id ) ; Ember . assert ( "You tried to reload a record but you have no adapter (for " + type + " ) " , adapter ) ; Ember . assert ( "You tried to reload a record but your adapter does not implement `find ` " , adapter . find ) ; return _find ( adapter , this , type , id ) ; } 
function ( records , owner , resolver ) { if ( ! records . length ) { return ; } 
function ( type , id ) { id = coerce Id ( id ) ; type = this . model For ( type ) ; return ! ! this . type Map For ( type ) . id To Record [ id ] ; } 
function ( type , id ) { type = this . model For ( type ) ; id = coerce Id ( id ) ; var record = this . type Map For ( type ) . id To Record [ id ] ; if ( ! record ) { record = this . build Record ( type , id ) ; } return record ; } 
function ( owner , link , relationship , resolver ) { var adapter = this . adapter For ( owner . constructor ) ; Ember . assert ( "You tried to load a has Many relationship but you have no adapter (for " + owner . constructor + " ) " , adapter ) ; Ember . assert ( "You tried to load a has Many relationship from a specified `link ` in the original payload but your adapter does not implement `find Has Many ` " , adapter . find Has Many ) ; var records = this . record Array Manager . create Many Array ( relationship . type , Ember . A ( [ ] ) ) ; resolver . resolve ( _find Has Many ( adapter , this , owner , link , relationship ) ) ; return records ; } 
function ( type , query ) { type = this . model For ( type ) ; var array = this . record Array Manager . create Adapter Populated Record Array ( type , query ) ; var adapter = this . adapter For ( type ) , promise Label = "DS : Store #find Query " + type , resolver = Ember . RSVP . defer ( promise Label ) ; Ember . assert ( "You tried to load a query but you have no adapter (for " + type + " ) " , adapter ) ; Ember . assert ( "You tried to load a query but your adapter does not implement `find Query ` " , adapter . find Query ) ; resolver . resolve ( _find Query ( adapter , this , type , query , array ) ) ; return promise Array ( resolver . promise ) ; } 
function ( type ) { type = this . model For ( type ) ; var type Map = this . type Map For ( type ) , find All Cache = type Map . find All Cache ; if ( find All Cache ) { return find All Cache ; } var array = this . record Array Manager . create Record Array ( type ) ; type Map . find All Cache = array ; return array ; } 
function ( type ) { type = this . model For ( type ) ; var type Map = this . type Map For ( type ) , records = type Map . records , record ; while ( record = records . pop ( ) ) { record . unload Record ( ) ; } type Map . find All Cache = null ; } 
function ( type , query , filter ) { var promise ; 
function ( type , id ) { if ( ! this . has Record For Id ( type , id ) ) { return false ; } return ! get ( this . record For Id ( type , id ) , 'is Empty ' ) ; } 
function ( ) { var pending = this . _pending Save . slice ( ) ; this . _pending Save = [ ] ; for Each ( pending , function ( tuple ) { var record = tuple [ 0 ] , resolver = tuple [ 1 ] , adapter = this . adapter For ( record . constructor ) , operation ; if ( get ( record , 'is New ' ) ) { operation = 'create Record ' ; } else if ( get ( record , 'is Deleted ' ) ) { operation = 'delete Record ' ; } else { operation = 'update Record ' ; } resolver . resolve ( _commit ( adapter , this , operation , record ) ) ; } , this ) ; } 
function ( record , data ) { if ( data ) { 
function ( record , data ) { var old Id = get ( record , 'id ' ) , id = coerce Id ( data . id ) ; Ember . assert ( "An adapter cannot assign a new id to a record that already has an id . " + record + " had id : " + old Id + " and you tried to update it with " + id + " . This likely happened because your server returned data in response to a find or update that had a different id than the one you sent . " , old Id = = = null | | id = = = old Id ) ; this . type Map For ( record . constructor ) . id To Record [ id ] = record ; set ( record , 'id ' , id ) ; } 
function ( type ) { var type Maps = get ( this , 'type Maps ' ) , guid = Ember . guid For ( type ) , type Map ; type Map = type Maps [ guid ] ; if ( type Map ) { return type Map ; } type Map = { id To Record : { } , records : [ ] , metadata : { } } ; type Maps [ guid ] = type Map ; return type Map ; } 
function ( type , data , partial ) { var id = coerce Id ( data . id ) , record = this . record For Id ( type , id ) ; record . setup Data ( data , partial ) ; this . record Array Manager . record Did Change ( record ) ; return record ; } 
function ( key ) { var factory ; if ( typeof key = = = 'string ' ) { var normalized Key = this . container . normalize ( 'model : ' + key ) ; factory = this . container . lookup Factory ( normalized Key ) ; if ( ! factory ) { throw new Ember . Error ( "No model was found for ' " + key + " ' " ) ; } factory . type Key = normalized Key . split ( ' : ' , 2 ) [ 1 ] ; } else { 
function ( type , data , _partial ) { 
function ( type , payload ) { var serializer ; if ( ! payload ) { payload = type ; serializer = default Serializer ( this . container ) ; Ember . assert ( "You cannot use `store #push Payload ` without a type unless your default serializer defines `push Payload ` " , serializer . push Payload ) ; } else { serializer = this . serializer For ( type ) ; } serializer . push Payload ( this , payload ) ; } 
function ( type , metadata ) { type = this . model For ( type ) ; Ember . merge ( this . type Map For ( type ) . metadata , metadata ) ; } 
function ( type , id , data ) { var type Map = this . type Map For ( type ) , id To Record = type Map . id To Record ; Ember . assert ( 'The id ' + id + ' has already been used with another record of type ' + type . to String ( ) + ' . ' , ! id | | ! id To Record [ id ] ) ; 
function ( record ) { var type = record . constructor , type Map = this . type Map For ( type ) , id = get ( record , 'id ' ) ; record . update Record Arrays ( ) ; if ( id ) { delete type Map . id To Record [ id ] ; } var loc = index Of ( type Map . records , record ) ; type Map . records . splice ( loc , 1 ) ; } 
function ( child Record , child Key , parent Record , parent Key , change ) { var client Id = child Record . client Id , parent Client Id = parent Record ? parent Record : parent Record ; var key = child Key + parent Key ; var changes = this . _relationship Changes ; if ( ! ( client Id in changes ) ) { changes [ client Id ] = { } ; } if ( ! ( parent Client Id in changes [ client Id ] ) ) { changes [ client Id ] [ parent Client Id ] = { } ; } if ( ! ( key in changes [ client Id ] [ parent Client Id ] ) ) { changes [ client Id ] [ parent Client Id ] [ key ] = { } ; } changes [ client Id ] [ parent Client Id ] [ key ] [ change . change Type ] = change ; } 
function ( type ) { var container = this . container , adapter ; if ( container ) { adapter = container . lookup ( 'adapter : ' + type . type Key ) | | container . lookup ( 'adapter :application ' ) ; } return adapter | | get ( this , 'default Adapter ' ) ; } 
function ( type ) { type = this . model For ( type ) ; var adapter = this . adapter For ( type ) ; return serializer For ( this . container , type . type Key , adapter & & adapter . default Serializer ) ; } 
function add Unsaved Records ( record , key , data ) { if ( record ) { data . push Objects ( record . get ( key ) . filter By ( 'is New ' ) ) ; } } 
function ( object ) { 
function deep Clone ( object ) { var clone = { } , value ; for ( var prop in object ) { value = object [ prop ] ; if ( value & & typeof value = = = 'object ' ) { clone [ prop ] = deep Clone ( value ) ; } else { clone [ prop ] = value ; } } return clone ; } 
function ( attribute , messages ) { var was Empty = get ( this , 'is Empty ' ) ; messages = this . _find Or Create Messages ( attribute , messages ) ; get ( this , 'content ' ) . add Objects ( messages ) ; this . notify Property Change ( attribute ) ; this . enumerable Content Did Change ( ) ; if ( was Empty & & ! get ( this , 'is Empty ' ) ) { this . trigger ( 'became Invalid ' ) ; } } 
function ( attribute ) { if ( get ( this , 'is Empty ' ) ) { return ; } var content = get ( this , 'content ' ) . reject By ( 'attribute ' , attribute ) ; get ( this , 'content ' ) . set Objects ( content ) ; this . notify Property Change ( attribute ) ; this . enumerable Content Did Change ( ) ; if ( get ( this , 'is Empty ' ) ) { this . trigger ( 'became Valid ' ) ; } } 
function ( options ) { 
function ( ) { var old Data = get ( this , ' _data ' ) , new Data = get ( this , ' _attributes ' ) , diff Data = { } , prop ; for ( prop in new Data ) { diff Data [ prop ] = [ old Data [ prop ] , new Data [ prop ] ] ; } return diff Data ; } 
function ( data ) { set ( this , 'is Error ' , false ) ; if ( data ) { this . _data = data ; } else { Ember . mixin ( this . _data , this . _in Flight Attributes ) ; } this . _in Flight Attributes = { } ; this . send ( 'did Commit ' ) ; this . update Record Arrays Later ( ) ; if ( ! data ) { return ; } this . suspend Relationship Observers ( function ( ) { this . notify Property Change ( 'data ' ) ; } ) ; } 
function ( ) { this . _attributes = { } ; if ( get ( this , 'is Error ' ) ) { this . _in Flight Attributes = { } ; set ( this , 'is Error ' , false ) ; } if ( ! get ( this , 'is Valid ' ) ) { this . _in Flight Attributes = { } ; } this . send ( 'rolled Back ' ) ; this . suspend Relationship Observers ( function ( ) { this . notify Property Change ( 'data ' ) ; } ) ; } 
function ( callback , binding ) { var observers = get ( this . constructor , 'relationship Names ' ) . belongs To ; var self = this ; try { this . _suspended Relationships = true ; Ember . _suspend Observers ( self , observers , null , 'belongs To Did Change ' , function ( ) { Ember . _suspend Before Observers ( self , observers , null , 'belongs To Will Change ' , function ( ) { callback . call ( binding | | self ) ; } ) ; } ) ; } finally { this . _suspended Relationships = false ; } } 
function ( ) { var promise Label = "DS : Model #save " + this ; var resolver = Ember . RSVP . defer ( promise Label ) ; this . get ( 'store ' ) . schedule Save ( this , resolver ) ; this . _in Flight Attributes = this . _attributes ; this . _attributes = { } ; return DS . Promise Object . create ( { promise : resolver . promise } ) ; } 
function ( ) { set ( this , 'is Reloading ' , true ) ; var record = this ; var promise Label = "DS : Model #reload of " + this ; var promise = new Ember . RSVP . Promise ( function ( resolve ) { record . send ( 'reload Record ' , resolve ) ; } , promise Label ) . then ( function ( ) { record . set ( 'is Reloading ' , false ) ; record . set ( 'is Error ' , false ) ; return record ; } , function ( reason ) { record . set ( 'is Error ' , true ) ; throw reason ; } , "DS : Model #reload complete , update flags " ) ; return DS . Promise Object . create ( { promise : promise } ) ; } 
function ( attribute Name , value ) { 
function ( name ) { Ember . try Invoke ( this , name , [ ] . slice . call ( arguments , 1 ) ) ; this . _super . apply ( this , arguments ) ; } 
function ( callback , binding ) { get ( this , 'attributes ' ) . for Each ( function ( name , meta ) { callback . call ( binding , name , meta ) ; } , binding ) ; } 
function ( callback , binding ) { get ( this , 'transformed Attributes ' ) . for Each ( function ( name , type ) { callback . call ( binding , name , type ) ; } ) ; } 
function ( proto , key , value ) { 
function ( callback , binding ) { get ( this , 'relationships By Name ' ) . for Each ( function ( name , relationship ) { callback . call ( binding , name , relationship ) ; } ) ; } 
function ( ) { for Each ( this . changed Records , function ( record ) { if ( get ( record , 'is Deleted ' ) ) { this . _record Was Deleted ( record ) ; } else { this . _record Was Changed ( record ) ; } } , this ) ; this . changed Records = [ ] ; } 
function ( array , filter , type , record ) { var should Be In Array ; if ( ! filter ) { should Be In Array = true ; } else { should Be In Array = filter ( record ) ; } var record Arrays = this . record Arrays For Record ( record ) ; if ( should Be In Array ) { record Arrays . add ( array ) ; array . add Record ( record ) ; } else if ( ! should Be In Array ) { record Arrays . remove ( array ) ; array . remove Record ( record ) ; } } 
function ( array , type , filter ) { var type Map = this . store . type Map For ( type ) , records = type Map . records , record ; for ( var i = 0 , l = records . length ; i < l ; i + + ) { record = records [ i ] ; if ( ! get ( record , 'is Deleted ' ) & & ! get ( record , 'is Empty ' ) ) { this . update Record Array ( array , filter , type , record ) ; } } } 
function ( type , records ) { var many Array = DS . Many Array . create ( { type : type , content : records , store : this . store } ) ; for Each ( records , function ( record ) { var arrays = this . record Arrays For Record ( record ) ; arrays . add ( many Array ) ; } , this ) ; return many Array ; } 
function ( type ) { var array = DS . Record Array . create ( { type : type , content : Ember . A ( ) , store : this . store , is Loaded : true } ) ; this . register Filtered Record Array ( array , type ) ; return array ; } 
function ( type , filter ) { var array = DS . Filtered Record Array . create ( { type : type , content : Ember . A ( ) , store : this . store , manager : this , filter Function : filter } ) ; this . register Filtered Record Array ( array , type , filter ) ; return array ; } 
function ( type , query ) { return DS . Adapter Populated Record Array . create ( { type : type , query : query , content : Ember . A ( ) , store : this . store } ) ; } 
function ( array , type , filter ) { var record Arrays = this . filtered Record Arrays . get ( type ) ; record Arrays . push ( array ) ; this . update Filter ( array , type , filter ) ; } 
function ( record , array ) { var loading Record Arrays = record . _loading Record Arrays | | [ ] ; loading Record Arrays . push ( array ) ; record . _loading Record Arrays = loading Record Arrays ; } 
function ( record , options ) { return get ( record , 'store ' ) . serializer For ( record . constructor . type Key ) . serialize ( record , options ) ; } 
function ( store , type , ids ) { var promises = map . call ( ids , function ( id ) { return this . find ( store , type , id ) ; } , this ) ; return Ember . RSVP . all ( promises ) ; } 
function ( type ) { if ( type . FIXTURES ) { var fixtures = Ember . A ( type . FIXTURES ) ; return fixtures . map ( function ( fixture ) { var fixture Id Type = typeof fixture . id ; if ( fixture Id Type ! = = "number " & & fixture Id Type ! = = "string " ) { throw new Error ( fmt ( 'the id property must be defined as a number or string for fixture % @ ' , [ fixture ] ) ) ; } fixture . id = fixture . id + ' ' ; return fixture ; } ) ; } return null ; } 
function ( store , type , record ) { return store . serializer For ( type ) . serialize ( record , { include Id : true } ) ; } 
function ( type , record ) { var existing Fixture = this . find Existing Fixture ( type , record ) ; if ( existing Fixture ) { var index = index Of ( type . FIXTURES , existing Fixture ) ; type . FIXTURES . splice ( index , 1 ) ; return true ; } } 
function ( type , record ) { var fixtures = this . fixtures For Type ( type ) ; var id = get ( record , 'id ' ) ; return this . find Fixture By Id ( fixtures , id ) ; } 
function ( fixtures , id ) { return Ember . A ( fixtures ) . find ( function ( r ) { if ( ' ' + get ( r , 'id ' ) = = = ' ' + id ) { return true ; } else { return false ; } } ) ; } 
function ( type , hash , prop ) { this . normalize Id ( hash ) ; this . normalize Attributes ( type , hash ) ; this . normalize Relationships ( type , hash ) ; this . normalize Using Declared Mapping ( type , hash ) ; if ( this . normalize Hash & & this . normalize Hash [ prop ] ) { this . normalize Hash [ prop ] ( hash ) ; } return this . _super ( type , hash , prop ) ; } 
function ( store , primary Type , payload , record Id , request Type ) { payload = this . normalize Payload ( primary Type , payload ) ; var primary Type Name = primary Type . type Key , primary Record ; for ( var prop in payload ) { var type Name = this . type For Root ( prop ) , is Primary = type Name = = = primary Type Name ; 
function ( store , primary Type , payload ) { payload = this . normalize Payload ( primary Type , payload ) ; var primary Type Name = primary Type . type Key , primary Array ; for ( var prop in payload ) { var type Key = prop , forced Secondary = false ; if ( prop . char At ( 0 ) = = = ' _ ' ) { forced Secondary = true ; type Key = prop . substr ( 1 ) ; } var type Name = this . type For Root ( type Key ) , type = store . model For ( type Name ) , type Serializer = store . serializer For ( type ) , is Primary = ( ! forced Secondary & & ( type Name = = = primary Type Name ) ) ; var normalized Array = map . call ( payload [ prop ] , function ( hash ) { return type Serializer . normalize ( type , hash , prop ) ; } , this ) ; if ( is Primary ) { primary Array = normalized Array ; } else { store . push Many ( type Name , normalized Array ) ; } } return primary Array ; } 
function ( store , payload ) { payload = this . normalize Payload ( null , payload ) ; for ( var prop in payload ) { var type Name = this . type For Root ( prop ) , type = store . model For ( type Name ) ; var normalized Array = map . call ( Ember . make Array ( payload [ prop ] ) , function ( hash ) { return this . normalize ( type , hash , prop ) ; } , this ) ; store . push Many ( type Name , normalized Array ) ; } } 
function ( hash , type , record , options ) { hash [ type . type Key ] = this . serialize ( record , options ) ; } 
function ( record , json , relationship ) { var key = relationship . key , belongs To = get ( record , key ) ; key = this . key For Attribute ? this . key For Attribute ( key ) : key ; json [ key + "Type " ] = belongs To . constructor . type Key ; } 
function ( store , type , since Token ) { var query ; if ( since Token ) { query = { since : since Token } ; } return this . ajax ( this . build URL ( type . type Key ) , 'GET ' , { data : query } ) ; } 
function ( store , type , ids ) { return this . ajax ( this . build URL ( type . type Key ) , 'GET ' , { data : { ids : ids } } ) ; } 
function ( store , record , url ) { var host = get ( this , 'host ' ) , id = get ( record , 'id ' ) , type = record . constructor . type Key ; if ( host & & url . char At ( 0 ) = = = ' / ' & & url . char At ( 1 ) ! = = ' / ' ) { url = host + url ; } return this . ajax ( this . url Prefix ( url , this . build URL ( type , id ) ) , 'GET ' ) ; } 
function ( store , record , url ) { var id = get ( record , 'id ' ) , type = record . constructor . type Key ; return this . ajax ( this . url Prefix ( url , this . build URL ( type , id ) ) , 'GET ' ) ; } 
function ( store , type , record ) { var data = { } ; var serializer = store . serializer For ( type . type Key ) ; serializer . serialize Into Hash ( data , type , record , { include Id : true } ) ; return this . ajax ( this . build URL ( type . type Key ) , "POST " , { data : data } ) ; } 
function ( store , type , record ) { var data = { } ; var serializer = store . serializer For ( type . type Key ) ; serializer . serialize Into Hash ( data , type , record ) ; var id = get ( record , 'id ' ) ; return this . ajax ( this . build URL ( type . type Key , id ) , "PUT " , { data : data } ) ; } 
function ( store , type , record ) { var id = get ( record , 'id ' ) ; return this . ajax ( this . build URL ( type . type Key , id ) , "DELETE " ) ; } 
function ( type , id ) { var url = [ ] , host = get ( this , 'host ' ) , prefix = this . url Prefix ( ) ; if ( type ) { url . push ( this . path For Type ( type ) ) ; } if ( id ) { url . push ( id ) ; } if ( prefix ) { url . unshift ( prefix ) ; } url = url . join ( ' / ' ) ; if ( ! host & & url ) { url = ' / ' + url ; } return url ; } 
function ( url , type , hash ) { var adapter = this ; return new Ember . RSVP . Promise ( function ( resolve , reject ) { hash = adapter . ajax Options ( url , type , hash ) ; hash . success = function ( json ) { Ember . run ( null , resolve , json ) ; } ; hash . error = function ( jq XHR , text Status , error Thrown ) { Ember . run ( null , reject , adapter . ajax Error ( jq XHR ) ) ; } ; Ember . $ . ajax ( hash ) ; } , "DS : Rest Adapter #ajax " + type + " to " + url ) ; } 
function Inflector ( rule Set ) { rule Set = rule Set | | { } ; rule Set . uncountable = rule Set . uncountable | | { } ; rule Set . irregular Pairs = rule Set . irregular Pairs | | { } ; var rules = this . rules = { plurals : rule Set . plurals | | [ ] , singular : rule Set . singular | | [ ] , irregular : { } , irregular Inverse : { } , uncountable : { } } ; load Uncountable ( rules , rule Set . uncountable ) ; load Irregular ( rules , rule Set . irregular Pairs ) ; } 
function ( word , type Rules , irregular ) { var inflection , substitution , result , lowercase , is Blank , is Uncountable , is Irregular , is Irregular Inverse , rule ; is Blank = BLANK _REGEX . test ( word ) ; if ( is Blank ) { return word ; } lowercase = word . to Lower Case ( ) ; is Uncountable = this . rules . uncountable [ lowercase ] ; if ( is Uncountable ) { return word ; } is Irregular = irregular & & irregular [ lowercase ] ; if ( is Irregular ) { return is Irregular ; } for ( var i = type Rules . length , min = 0 ; i > min ; i - - ) { inflection = type Rules [ i - 1 ] ; rule = inflection [ 0 ] ; if ( rule . test ( word ) ) { break ; } } inflection = inflection | | [ ] ; rule = inflection [ 0 ] ; substitution = inflection [ 1 ] ; result = word . replace ( rule , substitution ) ; return result ; } 
function ( key , kind ) { key = Ember . String . decamelize ( key ) ; if ( kind = = = "belongs To " ) { return key + " _id " ; } else if ( kind = = = "has Many " ) { return Ember . String . singularize ( key ) + " _ids " ; } else { return key ; } } 
function ( data , type , record , options ) { var root = Ember . String . decamelize ( type . type Key ) ; data [ root ] = this . serialize ( record , options ) ; } 
function ( record , json , relationship ) { var key = relationship . key , belongs To = get ( record , key ) ; key = this . key For Attribute ( key ) ; json [ key + " _type " ] = Ember . String . capitalize ( belongs To . constructor . type Key ) ; } 
function ( root ) { var camelized = Ember . String . camelize ( root ) ; return Ember . String . singularize ( camelized ) ; } 
function ( data ) { if ( data . links ) { var links = data . links ; for ( var link in links ) { var camelized Link = Ember . String . camelize ( link ) ; if ( camelized Link ! = = link ) { links [ camelized Link ] = links [ link ] ; delete links [ link ] ; } } } } 
function ( type , hash ) { var payload Key , payload ; if ( this . key For Relationship ) { type . each Relationship ( function ( key , relationship ) { if ( relationship . options . polymorphic ) { payload Key = this . key For Attribute ( key ) ; payload = hash [ payload Key ] ; if ( payload & & payload . type ) { payload . type = this . type For Root ( payload . type ) ; } else if ( payload & & relationship . kind = = = "has Many " ) { var self = this ; for Each ( payload , function ( single ) { single . type = self . type For Root ( single . type ) ; } ) ; } } else { payload Key = this . key For Relationship ( key , relationship . kind ) ; payload = hash [ payload Key ] ; } hash [ key ] = payload ; if ( key ! = = payload Key ) { delete hash [ payload Key ] ; } } , this ) ; } } 
function ( record , json , relationship ) { var key = relationship . key , attrs = get ( this , 'attrs ' ) , embed = attrs & & attrs [ key ] & & attrs [ key ] . embedded = = = 'always ' ; if ( embed ) { json [ this . key For Attribute ( key ) ] = get ( record , key ) . map ( function ( relation ) { var data = relation . serialize ( ) , primary Key = get ( this , 'primary Key ' ) ; data [ primary Key ] = get ( relation , primary Key ) ; return data ; } , this ) ; } } 
function ( store , primary Type , payload , record Id , request Type ) { var root = this . key For Attribute ( primary Type . type Key ) , partial = payload [ root ] ; update Payload With Embedded ( store , this , primary Type , partial , payload ) ; return this . _super ( store , primary Type , payload , record Id , request Type ) ; } 
function ( store , type , payload ) { var root = this . key For Attribute ( type . type Key ) , partials = payload [ Ember . String . pluralize ( root ) ] ; for Each ( partials , function ( partial ) { update Payload With Embedded ( store , this , type , partial , payload ) ; } , this ) ; return this . _super ( store , type , payload ) ; } 
function ( type ) { var decamelized = Ember . String . decamelize ( type ) ; return Ember . String . pluralize ( decamelized ) ; } 
function ( jq XHR ) { var error = this . _super ( jq XHR ) ; if ( jq XHR & & jq XHR . status = = = 4 2 2 ) { var json Errors = Ember . $ . parse JSON ( jq XHR . response Text ) [ "errors " ] , errors = { } ; for Each ( Ember . keys ( json Errors ) , function ( key ) { errors [ Ember . String . camelize ( key ) ] = json Errors [ key ] ; } ) ; return new DS . Invalid Error ( errors ) ; } else { return error ; } } 
function extend ( dst ) { var h = dst . $ $hash Key ; for Each ( arguments , function ( obj ) { if ( obj ! = = dst ) { for Each ( obj , function ( value , key ) { dst [ key ] = value ; } ) ; } } ) ; set Hash Key ( dst , h ) ; return dst ; } 
function copy ( source , destination ) { if ( is Window ( source ) | | is Scope ( source ) ) { throw ng Min Err ( 'cpws ' , "Can 't copy ! Making copies of Window or Scope instances is not supported . " ) ; } if ( ! destination ) { destination = source ; if ( source ) { if ( is Array ( source ) ) { destination = copy ( source , [ ] ) ; } else if ( is Date ( source ) ) { destination = new Date ( source . get Time ( ) ) ; } else if ( is Reg Exp ( source ) ) { destination = new Reg Exp ( source . source ) ; } else if ( is Object ( source ) ) { destination = copy ( source , { } ) ; } } } else { if ( source = = = destination ) throw ng Min Err ( 'cpi ' , "Can 't copy ! Source and destination are identical . " ) ; if ( is Array ( source ) ) { destination . length = 0 ; for ( var i = 0 ; i < source . length ; i + + ) { destination . push ( copy ( source [ i ] ) ) ; } } else { var h = destination . $ $hash Key ; for Each ( destination , function ( value , key ) { delete destination [ key ] ; } ) ; for ( var key in source ) { destination [ key ] = copy ( source [ key ] ) ; } set Hash Key ( destination , h ) ; } } return destination ; } 
function parse Key Value ( key Value ) { var obj = { } , key _value , key ; for Each ( ( key Value | | " " ) . split ( ' & ' ) , function ( key Value ) { if ( key Value ) { key _value = key Value . split ( ' = ' ) ; key = try Decode URIComponent ( key _value [ 0 ] ) ; if ( is Defined ( key ) ) { var val = is Defined ( key _value [ 1 ] ) ? try Decode URIComponent ( key _value [ 1 ] ) : true ; if ( ! obj [ key ] ) { obj [ key ] = val ; } else if ( is Array ( obj [ key ] ) ) { obj [ key ] . push ( val ) ; } else { obj [ key ] = [ obj [ key ] , val ] ; } } } } ) ; return obj ; } 
function load Modules ( modules To Load ) { var run Blocks = [ ] ; for Each ( modules To Load , function ( module ) { if ( loaded Modules . get ( module ) ) return ; loaded Modules . put ( module , true ) ; try { if ( is String ( module ) ) { var module Fn = angular Module ( module ) ; run Blocks = run Blocks . concat ( load Modules ( module Fn . requires ) ) . concat ( module Fn . _run Blocks ) ; for ( var invoke Queue = module Fn . _invoke Queue , i = 0 , ii = invoke Queue . length ; i < ii ; i + + ) { var invoke Args = invoke Queue [ i ] , provider = provider Injector . get ( invoke Args [ 0 ] ) ; provider [ invoke Args [ 1 ] ] . apply ( provider , invoke Args [ 2 ] ) ; } } else if ( is Function ( module ) ) { run Blocks . push ( provider Injector . invoke ( module ) ) ; } else if ( is Array ( module ) ) { run Blocks . push ( provider Injector . invoke ( module ) ) ; } else { assert Arg Fn ( module , 'module ' ) ; } } catch ( e ) { if ( is Array ( module ) ) { module = module [ module . length - 1 ] ; } if ( e . message & & e . stack & & e . stack . index Of ( e . message ) = = - 1 ) { 
function $Anchor Scroll Provider ( ) { var auto Scrolling Enabled = true ; this . disable Auto Scrolling = function ( ) { auto Scrolling Enabled = false ; } ; this . $get = [ ' $window ' , ' $location ' , ' $root Scope ' , function ( $window , $location , $root Scope ) { var document = $window . document ; 
function ( element , parent , after , done ) { var after Node = after & & after [ after . length - 1 ] ; var parent Node = parent & & parent [ 0 ] | | after Node & & after Node . parent Node ; 
function ( element , class Name , done ) { class Name = is String ( class Name ) ? class Name : is Array ( class Name ) ? class Name . join ( ' ' ) : ' ' ; for Each ( element , function ( element ) { JQLite Add Class ( element , class Name ) ; } ) ; done & & $timeout ( done , 0 , false ) ; } 
function Browser ( window , document , $log , $sniffer ) { var self = this , raw Document = document [ 0 ] , location = window . location , history = window . history , set Timeout = window . set Timeout , clear Timeout = window . clear Timeout , pending Defer Ids = { } ; self . is Mock = false ; var outstanding Request Count = 0 ; var outstanding Request Callbacks = [ ] ; * Executes the `fn ` function (supports currying ) and decrements the `outstanding Request Callbacks ` * counter . If the counter reaches 0 , all the `outstanding Request Callbacks ` are executed . * / function complete Outstanding Request ( fn ) { try { fn . apply ( null , slice Args ( arguments , 1 ) ) ; } finally { outstanding Request Count - - ; if ( outstanding Request Count = = = 0 ) { while ( outstanding Request Callbacks . length ) { try { outstanding Request Callbacks . pop ( ) ( ) ; } catch ( e ) { $log . error ( e ) ; } } } } } self . notify When No Outstanding Requests = function ( callback ) { * @name ng . $browser #add Poll Fn * @method Of ng . $browser * * @param {function ( ) } fn Poll function to add * * @description * Adds a function to the list of functions that poller periodically executes , * and starts polling if not started yet . * * @returns {function ( ) } the added function * / self . add Poll Fn = function ( fn ) { if ( is Undefined ( poll Timeout ) ) start Poller ( 1 0 0 , set Timeout ) ; poll Fns . push ( fn ) ; return fn ; } ; function start Poller ( interval , set Timeout ) { ( function check ( ) { for Each ( poll Fns , function ( poll Fn ) { poll Fn ( ) ; } ) ; poll Timeout = set Timeout ( check , interval ) ; } ) ( ) ; } * @name ng . $browser #url * @method Of ng . $browser * * @description * GETTER : * Without any argument , this method just returns current value of location .href . * * SETTER : * With at least one argument , this method sets url to new value . * If html 5 history api supported , push State /replace State is used , otherwise * location .href /location .replace is used . * Returns its own instance to allow chaining * * NOTE : this api is intended for use only by the $location service . Please use the * { @link ng . $location $location service } to change url . * * @param {string } url New url (when used as setter ) * @param {boolean = } replace Should new url replace current history record ? * / self . url = function ( url , replace ) { * @name ng . $browser #on Url Change * @method Of ng . $browser * @TODO (vojta ) : refactor to use node 's syntax for events * * @description * Register callback function that will be called , when url changes . * * It 's only called when the url is changed by outside of angular : * - user types different url into address bar * - user clicks on history (forward /back ) button * - user clicks on a link * * It 's not called when url is changed by $browser .url ( ) method * * The listener gets called with new url as parameter . * * NOTE : this api is intended for use only by the $location service . Please use the * { @link ng . $location $location service } to monitor url changes in angular apps . * * @param {function (string ) } listener Listener function to be called when url changes . * @return {function (string ) } Returns the registered listener fn - handy if the fn is anonymous . * / self . on Url Change = function ( callback ) { if ( ! url Change Init ) { / / We listen on both (hashchange /popstate ) when available , as some browsers (e .g . Opera ) / / don 't fire popstate when user change the address bar and don 't fire hashchange when url / / changed by push /replace State / / html 5 history api - popstate event if ( $sniffer . history ) jq Lite ( window ) . on ( 'popstate ' , fire Url Change ) ; / / hashchange event if ( $sniffer . hashchange ) jq Lite ( window ) . on ( 'hashchange ' , fire Url Change ) ; / / polling else self . add Poll Fn ( fire Url Change ) ; url Change Init = true ; } url Change Listeners . push ( callback ) ; return callback ; } ; / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / Misc API / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / * * * @name ng . $browser #base Href * @method Of ng . $browser * * @description * Returns current <base href > * (always relative - without domain ) * * @returns {string = } current <base href > * / self . base Href = function ( ) { var href = base Element . attr ( 'href ' ) ; return href ? href . replace ( / ^https ? \ : \ / \ / [ ^ \ / ] * / , ' ' ) : ' ' ; } ; / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / Cookies API / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / var last Cookies = { } ; var last Cookie String = ' ' ; var cookie Path = self . base Href ( ) ; / * * * @name ng . $browser #cookies * @method Of ng . $browser * * @param {string = } name Cookie name * @param {string = } value Cookie value * * @description * The cookies method provides a 'private ' low level access to browser cookies . * It is not meant to be used directly , use the $cookie service instead . * * The return values vary depending on the arguments that the method was called with as follows : * <ul > * <li >cookies ( ) - > hash of all cookies , this is NOT a copy of the internal state , so do not modify it < /li > * <li >cookies (name , value ) - > set name to value , if value is undefined delete the cookie < /li > * <li >cookies (name ) - > the same as (name , undefined ) = = DELETES (no one calls it right now that way ) < /li > * < /ul > * * @returns {Object } Hash of all cookies (if called without any parameter ) * / self . cookies = function ( name , value ) { var cookie Length , cookie Array , cookie , i , index ; if ( name ) { if ( value = = = undefined ) { raw Document . cookie = escape ( name ) + " = ;path = " + cookie Path + " ;expires =Thu , 0 1 Jan 1 9 7 0 0 0 : 0 0 : 0 0 GMT " ; } else { if ( is String ( value ) ) { cookie Length = ( raw Document . cookie = escape ( name ) + ' = ' + escape ( value ) + ' ;path = ' + cookie Path ) . length + 1 ; / / per http : / /www .ietf .org /rfc /rfc 2 1 0 9 .txt browser must allow at minimum : / / - 3 0 0 cookies / / - 2 0 cookies per unique domain / / - 4 0 9 6 bytes per cookie if ( cookie Length > 4 0 9 6 ) { $log . warn ( "Cookie ' " + name + " ' possibly not set or overflowed because it was too large ( " + cookie Length + " > 4 0 9 6 bytes ) ! " ) ; } } } } else { if ( raw Document . cookie ! = = last Cookie String ) { last Cookie String = raw Document . cookie ; cookie Array = last Cookie String . split ( " ; " ) ; last Cookies = { } ; for ( i = 0 ; i < cookie Array . length ; i + + ) { cookie = cookie Array [ i ] ; index = cookie . index Of ( ' = ' ) ; if ( index > 0 ) { / /ignore nameless cookies var name = unescape ( cookie . substring ( 0 , index ) ) ; / / the first value that is seen for a cookie is the most / / specific one . values for the same cookie name that / / follow are for less specific paths . if ( last Cookies [ name ] = = = undefined ) { last Cookies [ name ] = unescape ( cookie . substring ( index + 1 ) ) ; } } } } return last Cookies ; } } ; / * * * @name ng . $browser #defer * @method Of ng . $browser * @param {function ( ) } fn A function , who 's execution should be deferred . * @param {number = } [delay = 0 ] of milliseconds to defer the function execution . * @returns { * } Defer Id that can be used to cancel the task via ` $browser .defer .cancel ( ) ` . * * @description * Executes a fn asynchronously via `set Timeout (fn , delay ) ` . * * Unlike when calling `set Timeout ` directly , in test this function is mocked and instead of using * `set Timeout ` in tests , the fns are queued in an array , which can be programmatically flushed * via ` $browser .defer .flush ( ) ` . * * / self . defer = function ( fn , delay ) { var timeout Id ; outstanding Request Count + + ; timeout Id = set Timeout ( function ( ) { delete pending Defer Ids [ timeout Id ] ; complete Outstanding Request ( fn ) ; } , delay | | 0 ) ; pending Defer Ids [ timeout Id ] = true ; return timeout Id ; } ; self . defer . cancel = function ( defer Id ) { if ( pending Defer Ids [ defer Id ] ) { delete pending Defer Ids [ defer Id ] ; clear Timeout ( defer Id ) ; complete Outstanding Request ( noop ) ; return true ; } return false ; } ; } 
function ( key , value , write Attr , attr Name ) { 
function compile Nodes ( node List , transclude Fn , $root Element , max Priority , ignore Directive ) { var link Fns = [ ] , node Link Fn , child Link Fn , directives , attrs , link Fn Found ; for ( var i = 0 ; i < node List . length ; i + + ) { attrs = new Attributes ( ) ; 
function group Elements Link Fn Wrapper ( link Fn , attr Start , attr End ) { return function ( scope , element , attrs , controllers ) { element = group Scan ( element [ 0 ] , attr Start , attr End ) ; return link Fn ( scope , element , attrs , controllers ) ; } } 
function add Link Fns ( pre , post , attr Start , attr End ) { if ( pre ) { if ( attr Start ) pre = group Elements Link Fn Wrapper ( pre , attr Start , attr End ) ; pre . require = directive . require ; pre Link Fns . push ( pre ) ; } if ( post ) { if ( attr Start ) post = group Elements Link Fn Wrapper ( post , attr Start , attr End ) ; post . require = directive . require ; post Link Fns . push ( post ) ; } } 
function replace With ( $root Element , elements To Remove , new Node ) { var first Element To Remove = elements To Remove [ 0 ] , remove Count = elements To Remove . length , parent = first Element To Remove . parent Node , i , ii ; if ( $root Element ) { for ( i = 0 , ii = $root Element . length ; i < ii ; i + + ) { if ( $root Element [ i ] = = first Element To Remove ) { $root Element [ i + + ] = new Node ; for ( var j = i , j 2 = j + remove Count - 1 , jj = $root Element . length ; j < jj ; j + + , j 2 + + ) { if ( j 2 < jj ) { $root Element [ j ] = $root Element [ j 2 ] ; } else { delete $root Element [ j ] ; } } $root Element . length - = remove Count - 1 ; break ; } } } if ( parent ) { parent . replace Child ( new Node , first Element To Remove ) ; } var fragment = document . create Document Fragment ( ) ; fragment . append Child ( first Element To Remove ) ; new Node [ jq Lite . expando ] = first Element To Remove [ jq Lite . expando ] ; for ( var k = 1 , kk = elements To Remove . length ; k < kk ; k + + ) { var element = elements To Remove [ k ] ; jq Lite ( element ) . remove ( ) ; 
function $Controller Provider ( ) { var controllers = { } , CNTRL _REG = / ^ ( \S + ) ( \s +as \s + ( \w + ) ) ? $ / ; this . register = function ( name , constructor ) { if ( is Object ( name ) ) { extend ( controllers , name ) } else { controllers [ name ] = constructor ; } } ; this . $get = [ ' $injector ' , ' $window ' , function ( $injector , $window ) { return function ( expression , locals ) { var instance , match , constructor , identifier ; if ( is String ( expression ) ) { match = expression . match ( CNTRL _REG ) , constructor = match [ 1 ] , identifier = match [ 3 ] ; expression = controllers . has Own Property ( constructor ) ? controllers [ constructor ] : getter ( locals . $scope , constructor , true ) | | getter ( $window , constructor , true ) ; assert Arg Fn ( expression , constructor , true ) ; } instance = $injector . instantiate ( expression , locals ) ; if ( identifier ) { if ( ! ( locals & & typeof locals . $scope = = 'object ' ) ) { throw min Err ( ' $controller ' ) ( 'noscp ' , "Cannot export controller ' { 0 } ' as ' { 1 } ' ! No $scope object provided via `locals ` . " , constructor | | expression . name , identifier ) ; } locals . $scope [ identifier ] = instance ; } return instance ; } ; } ] ; } 
function Location Html 5Url ( app Base , base Prefix ) { this . $ $html 5 = true ; base Prefix = base Prefix | | ' ' ; var app Base No File = strip File ( app Base ) ; this . $ $parse = function ( url ) { var parsed = { } match Url ( url , parsed ) ; var path Url = begins With ( app Base No File , url ) ; if ( ! is String ( path Url ) ) { throw $location Min Err ( 'ipthprfx ' , 'Invalid url " { 0 } " , missing path prefix " { 1 } " . ' , url , app Base No File ) ; } match App Url ( path Url , parsed ) ; extend ( this , parsed ) ; if ( ! this . $ $path ) { this . $ $path = ' / ' ; } this . $ $compose ( ) ; } ; this . $ $compose = function ( ) { var search = to Key Value ( this . $ $search ) , hash = this . $ $hash ? ' # ' + encode Uri Segment ( this . $ $hash ) : ' ' ; this . $ $url = encode Path ( this . $ $path ) + ( search ? ' ? ' + search : ' ' ) + hash ; this . $ $abs Url = app Base No File + this . $ $url . substr ( 1 ) ; 
function Location Hashbang Url ( app Base , hash Prefix ) { var app Base No File = strip File ( app Base ) ; match Url ( app Base , this ) ; this . $ $parse = function ( url ) { var without Base Url = begins With ( app Base , url ) | | begins With ( app Base No File , url ) ; var without Hash Url = without Base Url . char At ( 0 ) = = ' # ' ? begins With ( hash Prefix , without Base Url ) : ( this . $ $html 5 ) ? without Base Url : ' ' ; if ( ! is String ( without Hash Url ) ) { throw $location Min Err ( 'ihshprfx ' , 'Invalid url " { 0 } " , missing hash prefix " { 1 } " . ' , url , hash Prefix ) ; } match App Url ( without Hash Url , this ) ; this . $ $compose ( ) ; } ; this . $ $compose = function ( ) { var search = to Key Value ( this . $ $search ) , hash = this . $ $hash ? ' # ' + encode Uri Segment ( this . $ $hash ) : ' ' ; this . $ $url = encode Path ( this . $ $path ) + ( search ? ' ? ' + search : ' ' ) + hash ; this . $ $abs Url = app Base + ( this . $ $url ? hash Prefix + this . $ $url : ' ' ) ; } ; this . $ $rewrite = function ( url ) { if ( strip Hash ( app Base ) = = strip Hash ( url ) ) { return url ; } } } 
function Location Hashbang In Html 5Url ( app Base , hash Prefix ) { this . $ $html 5 = true ; Location Hashbang Url . apply ( this , arguments ) ; var app Base No File = strip File ( app Base ) ; this . $ $rewrite = function ( url ) { var app Url ; if ( app Base = = strip Hash ( url ) ) { return url ; } else if ( ( app Url = begins With ( app Base No File , url ) ) ) { return app Base + hash Prefix + app Url ; } else if ( app Base No File = = = url + ' / ' ) { return app Base No File ; } } } 
function ( search , param Value ) { switch ( arguments . length ) { case 0 : return this . $ $search ; case 1 : if ( is String ( search ) ) { this . $ $search = parse Key Value ( search ) ; } else if ( is Object ( search ) ) { this . $ $search = search ; } else { throw $location Min Err ( 'isrcharg ' , 'The first argument of the ` $location #search ( ) ` call must be a string or an object . ' ) ; } break ; default : if ( param Value = = undefined | | param Value = = null ) { delete this . $ $search [ search ] ; } else { this . $ $search [ search ] = param Value ; } } this . $ $compose ( ) ; return this ; } 
function array Declaration ( ) { var element Fns = [ ] ; var all Constant = true ; if ( peek Token ( ) . text ! = ' ] ' ) { do { var element Fn = expression ( ) ; element Fns . push ( element Fn ) ; if ( ! element Fn . constant ) { all Constant = false ; } } while ( expect ( ' , ' ) ) ; } consume ( ' ] ' ) ; return extend ( function ( self , locals ) { var array = [ ] ; for ( var i = 0 ; i < element Fns . length ; i + + ) { array . push ( element Fns [ i ] ( self , locals ) ) ; } return array ; } , { literal : true , constant : all Constant } ) ; } 
function setter ( obj , path , set Value , full Exp ) { var element = path . split ( ' . ' ) , key ; for ( var i = 0 ; element . length > 1 ; i + + ) { key = ensure Safe Member Name ( element . shift ( ) , full Exp ) ; var property Obj = obj [ key ] ; if ( ! property Obj ) { property Obj = { } ; obj [ key ] = property Obj ; } obj = property Obj ; if ( obj . then ) { if ( ! ( " $ $v " in obj ) ) { ( function ( promise ) { promise . then ( function ( val ) { promise . $ $v = val ; } ) ; } ) ( obj ) ; } if ( obj . $ $v = = = undefined ) { obj . $ $v = { } ; } obj = obj . $ $v ; } } key = ensure Safe Member Name ( element . shift ( ) , full Exp ) ; obj [ key ] = set Value ; return set Value ; } 
function ( reason ) { return { then : function ( callback , errback ) { var result = defer ( ) ; next Tick ( function ( ) { try { result . resolve ( ( is Function ( errback ) ? errback : default Errback ) ( reason ) ) ; } catch ( e ) { result . reject ( e ) ; exception Handler ( e ) ; } } ) ; return result . promise ; } } ; } 
function ( value , callback , errback , progressback ) { var result = defer ( ) , done ; var wrapped Callback = function ( value ) { try { return ( is Function ( callback ) ? callback : default Callback ) ( value ) ; } catch ( e ) { exception Handler ( e ) ; return reject ( e ) ; } } ; var wrapped Errback = function ( reason ) { try { return ( is Function ( errback ) ? errback : default Errback ) ( reason ) ; } catch ( e ) { exception Handler ( e ) ; return reject ( e ) ; } } ; var wrapped Progressback = function ( progress ) { try { return ( is Function ( progressback ) ? progressback : default Callback ) ( progress ) ; } catch ( e ) { exception Handler ( e ) ; } } ; next Tick ( function ( ) { ref ( value ) . then ( function ( value ) { if ( done ) return ; done = true ; result . resolve ( ref ( value ) . then ( wrapped Callback , wrapped Errback , wrapped Progressback ) ) ; } , function ( reason ) { if ( done ) return ; done = true ; result . resolve ( wrapped Errback ( reason ) ) ; } , function ( progress ) { if ( done ) return ; result . notify ( wrapped Progressback ( progress ) ) ; } ) ; } ) ; return result . promise ; } 
function ( isolate ) { var Child , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; 
function ( watch Exp , listener , object Equality ) { var scope = this , get = compile To Fn ( watch Exp , 'watch ' ) , array = scope . $ $watchers , watcher = { fn : listener , last : init Watch Val , get : get , exp : watch Exp , eq : ! ! object Equality } ; 
function ( obj , listener ) { var self = this ; var old Value ; var new Value ; var change Detected = 0 ; var obj Getter = $parse ( obj ) ; var internal Array = [ ] ; var internal Object = { } ; var old Length = 0 ; function $watch Collection Watch ( ) { new Value = obj Getter ( self ) ; var new Length , key ; if ( ! is Object ( new Value ) ) { if ( old Value ! = = new Value ) { old Value = new Value ; change Detected + + ; } } else if ( is Array Like ( new Value ) ) { if ( old Value ! = = internal Array ) { 
function ( name , listener ) { var named Listeners = this . $ $listeners [ name ] ; if ( ! named Listeners ) { this . $ $listeners [ name ] = named Listeners = [ ] ; } named Listeners . push ( listener ) ; return function ( ) { named Listeners [ index Of ( named Listeners , listener ) ] = null ; } ; } 
function ( name , args ) { var empty = [ ] , named Listeners , scope = this , stop Propagation = false , event = { name : name , target Scope : scope , stop Propagation : function ( ) { stop Propagation = true ; } , prevent Default : function ( ) { event . default Prevented = true ; } , default Prevented : false } , listener Args = concat ( [ event ] , arguments , 1 ) , i , length ; do { named Listeners = scope . $ $listeners [ name ] | | empty ; event . current Scope = scope ; for ( i = 0 , length = named Listeners . length ; i < length ; i + + ) { 
function trust As ( type , trusted Value ) { var constructor = ( by Type . has Own Property ( type ) ? by Type [ type ] : null ) ; if ( ! constructor ) { throw $sce Min Err ( 'icontext ' , 'Attempted to trust a value in invalid context . Context : { 0 } ; Value : { 1 } ' , type , trusted Value ) ; } if ( trusted Value = = = null | | trusted Value = = = undefined | | trusted Value = = = ' ' ) { return trusted Value ; } 
function resolve ( url , parse ) { var href = url ; if ( msie < = 1 1 ) { 
function is Same Origin ( request Url ) { var parsed = ( typeof request Url = = = 'string ' ) ? resolve ( request Url , true ) : request Url ; return ( parsed . protocol = = = origin Url . protocol & & parsed . host = = = origin Url . host ) ; } 
function Consuming Matcher ( matchers ) { return _ . create ( { } , { unmatched Matchers : _ . clone ( matchers ) , matches : function ( actual ) { let matched = false ; _ . for Each ( this . unmatched Matchers , ( matcher , index ) = > { if ( matcher . matches ( actual ) ) { matched = true ; this . unmatched Matchers . splice ( index , 1 ) ; return false ; } } , this ) ; return matched ; } } ) ; } 
function traverse ( node , opt _on Enter , opt _on Leave ) { if ( opt _on Enter ) opt _on Enter ( node ) ; var child Nodes = _collect Child Nodes ( node ) ; child Nodes . for Each ( function ( child Node ) { traverse ( child Node , opt _on Enter , opt _on Leave ) ; } ) ; if ( opt _on Leave ) opt _on Leave ( node ) ; } 
function Client ( ) { logger ( 'new Client ' ) ; this . type = 'client ' ; this . id = uuid ( ) ; this . browser = ( Web Socket . Server = = = undefined ) ; Base . call ( this ) ; } 
function json Parse ( data ) { var payload ; try { payload = JSON . parse ( data ) ; } catch ( error ) { logger ( error ) ; payload = null ; } return payload ; } 
function Connection ( socket , parent ) { logger ( 'new Connection to %s ' , parent . type ) ; this . id = uuid ( ) ; this . socket = socket ; this . parent = parent ; this . response Handlers = { } ; if ( this . parent . browser ) { this . socket . onmessage = this . message . bind ( this ) ; this . socket . onclose = socket Closed . bind ( this ) ; this . socket . onerror = socket Error . bind ( this ) ; } else { this . socket . on ( 'message ' , this . message . bind ( this ) ) ; this . socket . once ( 'close ' , this . close . bind ( this ) ) ; this . socket . once ( 'error ' , this . close . bind ( this ) ) ; } } 
function escape JSDiff ( s ) { var n = s ; n = n . replace ( / & / g , " &amp ; " ) ; n = n . replace ( / < / g , " &lt ; " ) ; n = n . replace ( / > / g , " &gt ; " ) ; n = n . replace ( / " / g , " &quot ; " ) ; return n ; } 
function Dialog ( opts ) { var self = this , options = this . options = angular . extend ( { } , defaults , global Options , opts ) ; this . _open = false ; this . backdrop El = create Element ( options . backdrop Class ) ; if ( options . backdrop Fade ) { this . backdrop El . add Class ( options . transition Class ) ; this . backdrop El . remove Class ( options . trigger Class ) ; } this . modal El = create Element ( options . dialog Class ) ; if ( options . dialog Fade ) { this . modal El . add Class ( options . transition Class ) ; this . modal El . remove Class ( options . trigger Class ) ; } this . handled Escape Key = function ( e ) { if ( e . which = = = 2 7 ) { self . close ( ) ; e . prevent Default ( ) ; self . $scope . $apply ( ) ; } } ; this . handle Back Drop Click = function ( e ) { self . close ( ) ; e . prevent Default ( ) ; self . $scope . $apply ( ) ; } ; this . handle Location Change = function ( ) { self . close ( ) ; } ; } 
function ( title , message , buttons ) { return new Dialog ( { template Url : 'plugins /ui -bootstrap /html /message .html ' , controller : 'Message Box Controller ' , resolve : { model : function ( ) { return { title : title , message : message , buttons : buttons } ; } } } ) ; } 
function block ( type , attrs ) { let result = function ( . . . args ) { let my Attrs = take Attrs ( attrs , args ) let { nodes , tag } = flatten ( type . schema , args , id ) let node = type . create ( my Attrs , nodes ) if ( tag ! = no Tag ) node . tag = tag return node } if ( type . is Leaf ) try { result . flat = [ type . create ( attrs ) ] } catch ( _ ) { } return result } 
function mark ( type , attrs ) { return function ( . . . args ) { let mark = type . create ( take Attrs ( attrs , args ) ) let { nodes , tag } = flatten ( type . schema , args , n = > mark . type . is In Set ( n . marks ) ? n : n . mark ( mark . add To Set ( n . marks ) ) ) return { flat : nodes , tag } } } 
function _create Store ( ) { 
function server Request ( config ) { var defer = $q . defer ( ) ; if ( provider . debug ) $log . info ( ' $sails ' + config . method + ' ' + config . url , config . data | | ' ' ) ; if ( config . timeout > 0 ) { $timeout ( timeout Request , config . timeout ) ; } else if ( is Promise Like ( config . timeout ) ) { config . timeout . then ( timeout Request ) ; } socket [ 'legacy _ ' + config . method . to Lower Case ( ) ] ( config . url , config . data , server Response ) ; function timeout Request ( ) { server Response ( null ) ; } function server Response ( result , jwr ) { if ( ! jwr ) { jwr = { body : result , headers : result . headers | | { } , status Code : result . status Code | | result . status | | 0 , error : ( function ( ) { if ( this . status Code < 2 0 0 | | this . status Code > = 4 0 0 ) { return this . body | | this . status Code ; } } ) ( ) } ; } jwr . data = jwr . body ; 
function figure Out Root Component ( ) { var root Components = [ ' . . / . . / . . /src /app /app .module .ts ' , ' . . / . . / . . /src /app .ts ' , ' . . / . . / . . /boot .ts ' , ' . . / . . / . . /src /main .ts ' ] ; for ( var i = 0 ; i < root Components . length ; i + + ) { if ( fs . exists Sync ( root Components [ i ] ) ) { var result = process Boot Strap ( root Components [ i ] ) ; if ( result ) { return result ; } } } 
function process Boot Strap ( file ) { var data = fs . read File Sync ( file ) . to String ( ) ; var idx = data . index Of ( 'bootstrap ( ' ) ; if ( idx = = = - 1 ) { return null ; } else { idx + = 1 0 ; } var odx 1 = data . index Of ( ' , ' , idx ) ; var odx 2 = data . index Of ( ' ) ' , idx ) ; if ( odx 2 < odx 1 & & odx 2 ! = = - 1 | | odx 1 = = = - 1 ) { odx 1 = odx 2 ; } if ( odx 1 = = = - 1 ) { return null ; } var component Ref = data . substring ( idx , odx 1 ) ; var exp = "import \ \s + \ \ { ( " + component Ref + " ) \ \ } \ \s +from + \ \s + [ \ ' | \ " ] ( \ \S + ) [ \ ' | \ " ] [ ; ? ] " ; if ( debugging ) { console . log ( "Searching for " , exp ) ; } var result = function ( r ) { return { name : r [ 1 ] , path : r [ r . length - 1 ] } ; } ; / /noinspection JSPotentially Invalid Constructor Usage var r = Reg Exp ( exp , 'i ' ) . exec ( data ) ; if ( r = = = null | | r . length < = 1 ) { / / check if using current style guide with spaces exp = "import \ \s + \ \ { \ \s + ( " + component Ref + " ) \ \ , \ \s + ( [A -Z ] { 0 , 3 0 0 } ) \ \w + \ \s + \ \ } \ \s +from + \ \s + [ \ ' | \ " ] ( \ \S + ) [ \ ' | \ " ] [ ; ? ] " ; if ( debugging ) { console . log ( "Searching for " , exp ) ; } r = Reg Exp ( exp , 'i ' ) . exec ( data ) ; if ( r = = = null | | r . length < = 1 ) { / / try just spaces with no angular cli style ( , environment ) etc . exp = "import \ \s + \ \ { \ \s + ( " + component Ref + " ) \ \s + \ \ } \ \s +from + \ \s + [ \ ' | \ " ] ( \ \S + ) [ \ ' | \ " ] [ ; ? ] " ; if ( debugging ) { console . log ( "Searching for " , exp ) ; } r = Reg Exp ( exp , 'i ' ) . exec ( data ) ; if ( r ! = = null & & r . length > 1 ) { return result ( r ) ; } } else { 
function create Sym Link ( ) { if ( debugging ) { console . log ( "Attempting to Symlink " , angular Seed Path , nativescript Client Path ) ; } fs . symlink Sync ( resolve ( angular Seed Path ) , resolve ( nativescript Client Path ) , 'junction ' ) ; } 
function fix Ts Config ( ) { var ts Config = { } , ts File = ' . . / . . /tsconfig .json ' ; if ( fs . exists Sync ( ts File ) ) { ts Config = require ( ts File ) ; } if ( ! ts Config . compiler Options | | ! ts Config . compiler Options . type Roots ) { ts Config . compiler Options = { target : "es 5 " , module : "commonjs " , declaration : false , remove Comments : true , no Lib : false , emit Decorator Metadata : true , experimental Decorators : true , lib : [ "dom " ] , source Map : true , pretty : true , allow Unreachable Code : false , allow Unused Labels : false , no Implicit Any : false , no Implicit Returns : true , no Implicit Use Strict : false , no Fallthrough Cases In Switch : true , type Roots : [ "node _modules / @types " , "node _modules " ] , types : [ "jasmine " ] } ; } 
function fix Ref File ( ) { var existing Ref = ' ' , ref File = ' . . / . . /references .d .ts ' ; if ( fs . exists Sync ( ref File ) ) { existing Ref = fs . read File Sync ( ref File ) . to String ( ) ; } if ( existing Ref . index Of ( 'typescript /lib /lib .d .ts ' ) = = = - 1 ) { 
function fix Native Script Package ( ) { var package JSON = { } , package File = ' . . / . . /package .json ' ; package JSON . name = "Native Script App " ; package JSON . version = " 0 . 0 . 0 " ; 
function fix Angular Package ( ) { var package JSON = { } , package File = ' . . / . . / . . /package .json ' ; if ( fs . exists Sync ( package File ) ) { package JSON = require ( package File ) ; } else { console . log ( "This should not happen , your are missing your main package .json file ! " ) ; return ; } if ( ! package JSON . scripts ) { package JSON . scripts = { } ; } package JSON . scripts [ "start .ios " ] = "cd nativescript & & tns emulate ios " ; package JSON . scripts [ "start .livesync .ios " ] = "cd nativescript & & tns livesync ios - -emulator - -watch " ; package JSON . scripts [ "start .android " ] = "cd nativescript & & tns emulate android " ; package JSON . scripts [ "start .livesync .android " ] = "cd nativescript & & tns livesync android - -emulator - -watch " ; fs . write File Sync ( package File , JSON . stringify ( package JSON , null , 4 ) , 'utf 8 ' ) ; } 
function fix Main File ( component ) { var main TS = ' ' , main File = ' . . / . . /app /main .ts ' ; if ( fs . exists Sync ( main File ) ) { main TS = fs . read File Sync ( main File ) . to String ( ) ; } if ( main TS . index Of ( 'Magic Service ' ) = = = - 1 ) { 
function fix Git Ignore ( ignore Pattern ) { var file String = ' ' , ignore File = ' . . / . . / . . / .gitignore ' ; if ( fs . exists Sync ( ignore File ) ) { file String = fs . read File Sync ( ignore File ) . to String ( ) ; } if ( file String . index Of ( ignore Pattern ) = = = - 1 ) { 
function display Final Help ( ) { console . log ( " - - - - - - - - - - - - - - Welcome to the Magical World of Native Script - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; console . log ( "To finish , follow this guide https : / /github .com /Nathan Walker /nativescript -ng 2 -magic #usage " ) ; console . log ( "After you have completed the steps in the usage guide , you can then : " ) ; console . log ( " " ) ; console . log ( "Run your app in the i OS Simulator with these options : " ) ; console . log ( " npm run start .ios " ) ; console . log ( " npm run start .livesync .ios " ) ; console . log ( " " ) ; console . log ( "Run your app in an Android emulator with these options : " ) ; console . log ( " npm run start .android " ) ; console . log ( " npm run start .livesync .android " ) ; console . log ( " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; console . log ( " " ) ; } 
function bind ( func , this Object , var _args ) { var args = slice ( arguments , 2 ) ; function bound ( var _args ) { return Injected Script Host . call Function ( func , this Object , concat ( args , slice ( arguments ) ) ) ; } bound . to String = function ( ) { return "bound : " + to String ( func ) ; } ; return bound ; } 
function ( object , object Group Name , force Value Type , generate Preview , column Names , is Table , do Not Bind , custom Object Config ) { try { return new Injected Script . Remote Object ( object , object Group Name , do Not Bind , force Value Type , generate Preview , column Names , is Table , undefined , custom Object Config ) ; } catch ( e ) { try { var description = injected Script . _describe ( e ) ; } catch ( ex ) { var description = " <failed to convert exception to string > " ; } return new Injected Script . Remote Object ( description ) ; } } 
function ( call Argument Json ) { call Argument Json = nullify Object Proto ( call Argument Json ) ; var object Id = call Argument Json . object Id ; if ( object Id ) { var parsed Arg Id = this . _parse Object Id ( object Id ) ; if ( ! parsed Arg Id | | parsed Arg Id [ "injected Script Id " ] ! = = injected Script Id ) throw "Arguments should belong to the same Java Script world as the target object . " ; var resolved Arg = this . _object For Id ( parsed Arg Id ) ; if ( ! this . _is Defined ( resolved Arg ) ) throw "Could not find object with given id " ; return resolved Arg ; } else if ( "value " in call Argument Json ) { var value = call Argument Json . value ; if ( call Argument Json . type = = = "number " & & typeof value ! = = "number " ) value = Number ( value ) ; return value ; } return undefined ; } 
function ( top Call Frame , call Frame Id , function Object Id , scope Number , variable Name , new Value Json String ) { try { var new Value Json = ( Injected Script Host . eval ( " ( " + new Value Json String + " ) " ) ) ; var resolved Value = this . _resolve Call Argument ( new Value Json ) ; if ( typeof call Frame Id = = = "string " ) { var call Frame = this . _call Frame For Id ( top Call Frame , call Frame Id ) ; if ( ! call Frame ) return "Could not find call frame with given id " ; call Frame . set Variable Value ( scope Number , variable Name , resolved Value ) } else { var parsed Function Id = this . _parse Object Id ( ( function Object Id ) ) ; var func = this . _object For Id ( parsed Function Id ) ; if ( typeof func ! = = "function " ) return "Could not resolve function by id " ; Injected Script Host . set Function Variable Value ( func , scope Number , variable Name , resolved Value ) ; } } catch ( e ) { return to String ( e ) ; } return undefined ; } 
function validate ( tj ) { if ( Object . prototype . has Own Property . call ( tj , 'tilejson ' ) ) { if ( tj . tilejson ! = = ' 2 . 2 . 0 ' ) { return false ; } } else { return false ; } if ( Object . prototype . has Own Property . call ( tj , 'name ' ) ) { if ( typeof tj . name ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'description ' ) ) { if ( typeof tj . description ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'version ' ) ) { if ( typeof tj . version ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'attribution ' ) ) { if ( typeof tj . attribution ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'template ' ) ) { if ( typeof tj . template ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'legend ' ) ) { if ( typeof tj . legend ! = = 'string ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'scheme ' ) ) { if ( typeof tj . scheme ! = = 'string ' ) { return false ; } if ( tj . scheme ! = = 'xyz ' & & tj . scheme ! = = 'tms ' ) { return false ; } } if ( Object . prototype . has Own Property . call ( tj , 'tiles ' ) ) { if ( tj . tiles . constructor ! = = Array ) { return false ; } if ( tj . tiles . length < 1 ) { return false ; } for ( let i = 0 ; i < tj . tiles . length ; i + = 1 ) { if ( typeof tj . tiles [ i ] ! = = 'string ' ) { return false ; } } } else { return false ; } if ( Object . prototype . has Own Property . call ( tj , 'grids ' ) ) { if ( tj . grids . constructor ! = = Array ) { return false ; } for ( let i = 0 ; i < tj . grids . length ; i + = 1 ) { if ( typeof tj . grids [ i ] ! = = 'string ' ) { return false ; } } } if ( Object . prototype . has Own Property . call ( tj , 'data ' ) ) { if ( tj . data . constructor ! = = Array ) { return false ; } for ( let i = 0 ; i < tj . data . length ; i + = 1 ) { if ( typeof tj . data [ i ] ! = = 'string ' ) { return false ; } } } let minzoom = 0 ; if ( Object . prototype . has Own Property . call ( tj , 'minzoom ' ) ) { if ( typeof tj . minzoom ! = = 'number ' ) { return false ; } if ( ! Number . is Integer ( tj . minzoom ) ) { return false ; } if ( tj . minzoom < 0 | | tj . minzoom > 3 0 ) { return false ; } minzoom = tj . minzoom ; } let maxzoom = 3 0 ; if ( Object . prototype . has Own Property . call ( tj , 'maxzoom ' ) ) { if ( typeof tj . maxzoom ! = = 'number ' ) { return false ; } if ( ! Number . is Integer ( tj . maxzoom ) ) { return false ; } if ( tj . maxzoom < 0 | | tj . maxzoom > 3 0 ) { return false ; } maxzoom = tj . maxzoom ; } if ( minzoom > maxzoom ) { return false ; } if ( Object . prototype . has Own Property . call ( tj , 'bounds ' ) ) { if ( tj . bounds . constructor ! = = Array ) { return false ; } for ( let i = 0 ; i < tj . bounds . length ; i + = 1 ) { if ( typeof tj . bounds [ i ] ! = = 'number ' ) { return false ; } } } if ( Object . prototype . has Own Property . call ( tj , 'center ' ) ) { if ( tj . center . constructor ! = = Array ) { return false ; } for ( let i = 0 ; i < tj . center . length ; i + = 1 ) { if ( typeof tj . center [ i ] ! = = 'number ' ) { return false ; } } } return true ; } 
function validate ( str ) { let tj ; if ( typeof str = = = 'object ' ) { tj = str ; } else if ( typeof str = = = 'string ' ) { try { tj = jsonlint . parse ( str ) ; } catch ( err ) { return false ; } } else { return false ; } return tilejson Validate Object . validate ( tj ) ; } 
function validates Number ( ) { var names = Array . from ( arguments ) , opts = util . type ( names [ names . length - 1 ] ) = = = 'object ' ? names . pop ( ) : { } ; names . for Each ( function ( name ) { this . validate ( name , function ( ) { this . validate Number ( name , opts ) ; } ) ; } , this ) ; return this ; } 
function validates Date ( ) { Array . from ( arguments ) . for Each ( function ( name ) { this . validate ( name , function ( ) { this . validate Date ( name ) ; } ) ; } , this ) ; } 
function validates Email ( ) { Array . from ( arguments ) . for Each ( function ( name ) { this . validate ( name , function ( ) { this . validate Email ( name ) ; } ) ; } , this ) ; return this ; } 
function validates Phone ( ) { Array . from ( arguments ) . for Each ( function ( name ) { this . validate ( name , function ( ) { this . validate Phone ( name ) ; } ) ; } , this ) ; return this ; } 
function validates Duration ( ) { Array . from ( arguments ) . for Each ( function ( name ) { this . validate ( name , function ( ) { this . validate Duration ( name ) ; } ) ; } , this ) ; return this ; } 
function parse Number ( s ) { s = String ( s ) . replace ( / [ ^ \d - . ] / g , ' ' ) . replace ( / \ . $ / , ' ' ) ; if ( ! s . match ( NUMBER _RE ) ) { return null ; } return parse Float ( s , 1 0 ) ; } 
function parse Percent ( s ) { var n = parse Number ( String ( s ) . replace ( ' % ' , ' ' ) ) ; return n = = null ? null : n / 1 0 0 ; } 
function parse Date ( s ) { var m , d , y , date , parts ; s = String ( s ) . replace ( / \s / g , ' ' ) ; if ( parts = s . match ( ISO 8 6 0 1 _DATE _RE ) ) { y = parse Int ( parts [ 1 ] , 1 0 ) ; m = parse Int ( parts [ 2 ] , 1 0 ) - 1 ; d = parse Int ( parts [ 3 ] , 1 0 ) ; date = new Date ( y , m , d ) ; return date . get Month ( ) = = = m ? date : null ; } else if ( parts = s . match ( MDY _DATE _RE ) ) { m = parse Int ( parts [ 1 ] , 1 0 ) - 1 ; d = parse Int ( parts [ 2 ] , 1 0 ) ; y = parts [ 3 ] ? parse Int ( parts [ 3 ] , 1 0 ) : new Date ( ) . get Full Year ( ) ; if ( 0 < = y & & y < = 6 8 ) { y + = 2 0 0 0 ; } if ( 6 9 < = y & & y < = 9 9 ) { y + = 1 9 0 0 ; } date = new Date ( y , m , d ) ; return date . get Month ( ) = = = m ? date : null ; } else { return null ; } } 
function parse Date Time ( s ) { var n ; s = String ( s ) ; if ( s . match ( NO _TZ _RE ) ) { s + = 'Z ' ; } return ( n = Date . parse ( s ) ) ? new Date ( n ) : null ; } 
function parse Email ( s ) { s = String ( s ) ; return EMAIL _FORMAT . test ( s ) ? s : null ; } 
function parse Phone ( s ) { s = String ( s ) ; return PHONE _FORMAT . test ( s . replace ( PHONE _CHARS , ' ' ) ) ? s : null ; } 
function parse Duration ( s ) { s = String ( s ) ; if ( ! DURATION _RE . test ( s ) ) { return null ; } var parts = s . split ( ' : ' ) . map ( function ( p ) { return + p ; } ) ; if ( parts . length = = = 3 ) { return parts [ 0 ] * 3 6 0 0 + parts [ 1 ] * 6 0 + parts [ 2 ] ; } else if ( parts . length = = = 2 ) { return parts [ 0 ] * 6 0 + parts [ 1 ] ; } else { return parts [ 0 ] ; } } 
function seen ( o 1 , o 2 ) { var i , len ; for ( i = 0 , len = seen Objects . length ; i < len ; i + + ) { if ( seen Objects [ i ] [ 0 ] = = = o 1 & & seen Objects [ i ] [ 1 ] = = = o 2 ) { return true ; } } return false ; } 
function unmark ( o 1 , o 2 ) { var i , n ; for ( i = 0 , n = seen Objects . length ; i < n ; i + + ) { if ( seen Objects [ i ] [ 0 ] = = = o 1 & & seen Objects [ i ] [ 1 ] = = = o 2 ) { seen Objects . splice ( i , 1 ) ; return ; } } } 
function _get Path ( o , path Segments ) { if ( o = = null ) { return undefined ; } var head = path Segments [ 0 ] , tail = path Segments . slice ( 1 ) ; if ( Array . is Array ( o ) & & ! ( head in o ) ) { o = o . reduce ( function ( acc , x ) { if ( ! x ) { return acc ; } var y = x [ head ] ; if ( Array . is Array ( y ) ) { acc . push . apply ( acc , y ) ; } else { acc . push ( y ) ; } return acc ; } , [ ] ) ; } else { o = o [ head ] ; } if ( ! tail . length ) { return o ; } else { return o ? _get Path ( o , tail ) : undefined ; } } 
function detect Recursion ( o 1 , o 2 , f ) { if ( arguments . length = = = 2 ) { f = o 2 ; o 2 = undefined ; } if ( seen ( o 1 , o 2 ) ) { return true ; } else { mark ( o 1 , o 2 ) ; try { f ( ) ; } finally { unmark ( o 1 , o 2 ) ; } return false ; } } 
function type ( o ) { if ( o = = = null ) { return 'null ' ; } if ( o = = = undefined ) { return 'undefined ' ; } switch ( to String . call ( o ) ) { case ' [object Array ] ' : return 'array ' ; case ' [object Arguments ] ' : return 'arguments ' ; case ' [object Function ] ' : return 'function ' ; case ' [object String ] ' : return 'string ' ; case ' [object Number ] ' : return 'number ' ; case ' [object Boolean ] ' : return 'boolean ' ; case ' [object Date ] ' : return 'date ' ; case ' [object Reg Exp ] ' : return 'regexp ' ; case ' [object Object ] ' : if ( o . has Own Property ( 'callee ' ) ) { return 'arguments ' ; } 
function eq ( a , b ) { var atype , btype ; 
function array Eq ( a , b ) { var r ; if ( ! Array . is Array ( a ) | | ! Array . is Array ( b ) ) { return false ; } if ( a . length ! = = b . length ) { return false ; } r = true ; detect Recursion ( a , b , function ( ) { var i , len ; for ( i = 0 , len = a . length ; i < len ; i + + ) { if ( ! eq ( a [ i ] , b [ i ] ) ) { r = false ; break ; } } } ) ; return r ; } 
function object Eq ( a , b ) { var akeys = Object . keys ( a ) , bkeys = Object . keys ( b ) , r ; if ( akeys . length ! = = bkeys . length ) { return false ; } r = true ; detect Recursion ( a , b , function ( ) { var i , len , key ; for ( i = 0 , len = akeys . length ; i < len ; i + + ) { key = akeys [ i ] ; if ( ! b . has Own Property ( key ) ) { r = false ; break ; } if ( ! eq ( a [ key ] , b [ key ] ) ) { r = false ; break ; } } } ) ; return r ; } 
function camelize ( s ) { return typeof s = = = 'string ' ? s . replace ( / ( ? : [ - _ ] ) ( \w ) / g , function ( _ , c ) { return c ? c . to Upper Case ( ) : ' ' ; } ) : s ; } 
function underscore ( s ) { return typeof s = = = 'string ' ? s . replace ( / ( [a -z \d ] ) ( [A -Z ] + ) / g , ' $ 1 _ $ 2 ' ) . replace ( / [ - \s ] + / g , ' _ ' ) . to Lower Case ( ) : s ; } 
function capitalize ( s ) { return typeof s = = = 'string ' & & s . length ? s [ 0 ] . to Upper Case ( ) + s . slice ( 1 ) : s ; } 
function resolve ( name ) { var raise = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : true ; var klass = typeof name = = = 'function ' ? name : subclasses [ name ] ; if ( ! klass & & raise ) { throw new Error ( "Transis .Model .resolve : could not resolve subclass : ` " + name + " ` " ) ; } return klass ; } 
function check Associated Type ( desc , o ) { var klass = resolve ( desc . klass ) ; if ( o & & ! ( o instanceof klass ) ) { throw new Error ( desc . debug Name + " : expected an object of type ` " + desc . klass + " ` but received ` " + o + " ` instead " ) ; } } 
function wrap Promise ( promise ) { return promise . then ( function ( value ) { return new Promise ( function ( resolve , reject ) { _object 2 . default . delay ( function ( ) { resolve ( value ) ; } ) ; _object 2 . default . _queue Flush ( ) ; } ) ; } , function ( reason ) { return new Promise ( function ( resolve , reject ) { _object 2 . default . delay ( function ( ) { reject ( reason ) ; } ) ; _object 2 . default . _queue Flush ( ) ; } ) ; } ) ; } 
function has Many Splice ( i , n , added ) { var owner = this . _ _owner _ _ , desc = this . _ _desc _ _ , inverse = desc . inverse , name = desc . name , removed , changes , i ; added . for Each ( function ( o ) { return check Associated Type ( desc , o ) ; } ) ; removed = _array 2 . default . prototype . _splice . call ( this , i , n , added ) ; if ( inverse & & ! this . _ _handling Inverse _ _ ) { removed . for Each ( function ( model ) { model . _inverse Removed ( inverse , owner ) ; } , this ) ; added . for Each ( function ( model ) { model . _inverse Added ( inverse , owner ) ; } , this ) ; } if ( desc . owner & & ! loads . length ) { changes = owner . own Changes [ name ] = owner . own Changes [ name ] | | { added : [ ] , removed : [ ] } ; removed . for Each ( function ( m ) { if ( ( i = changes . added . index Of ( m ) ) ! = = - 1 ) { changes . added . splice ( i , 1 ) ; } else if ( changes . removed . index Of ( m ) = = = - 1 ) { changes . removed . push ( m ) ; } } ) ; added . for Each ( function ( m ) { if ( ( i = changes . removed . index Of ( m ) ) ! = = - 1 ) { changes . removed . splice ( i , 1 ) ; } else if ( changes . added . index Of ( m ) = = = - 1 ) { changes . added . push ( m ) ; } } ) ; if ( ! changes . added . length & & ! changes . removed . length ) { owner . _clear Change ( name ) ; } else { owner . _set Change ( name , changes ) ; } } return removed ; } 
function has Many Inverse Remove ( model ) { var i = this . index Of ( model ) ; if ( i > = 0 ) { this . _ _handling Inverse _ _ = true ; this . splice ( i , 1 ) ; this . _ _handling Inverse _ _ = false ; } } 
function has Many Array ( owner , desc ) { var a = _array 2 . default . of ( ) ; a . proxy ( owner , desc . name ) ; a . _ _owner _ _ = owner ; a . _ _desc _ _ = desc ; a . _splice = has Many Splice ; a . _inverse Add = has Many Inverse Add ; a . _inverse Remove = has Many Inverse Remove ; return a ; } 
function query Array Query ( ) { var _this = this ; var query Opts = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : { } ; var opts = Object . assign ( { } , this . base Opts , query Opts ) ; if ( this . is Paged ) { opts . page = opts . page | | 1 ; } if ( this . is Busy ) { if ( util . eq ( opts , this . current Opts ) ) { return this ; } if ( ! this . _ _queued _ _ ) { this . _ _promise _ _ = this . _ _promise _ _ . then ( function ( ) { _this . query ( _this . _ _queued _ _ ) ; _this . _ _queued _ _ = undefined ; return _this . _ _promise _ _ ; } ) ; } this . _ _queued _ _ = opts ; } else { this . is Busy = true ; this . current Opts = opts ; this . _ _promise _ _ = wrap Promise ( this . _ _model Class _ _ . _call Mapper ( 'query ' , [ opts ] ) . then ( function ( result ) { var results = Array . is Array ( result ) ? result : result . results ; var meta = Array . is Array ( result ) ? { } : result . meta ; _this . is Busy = false ; _this . meta = meta ; _this . error = undefined ; if ( ! results ) { throw new Error ( _this + " #query : mapper failed to return any results " ) ; } if ( _this . is Paged & & typeof meta . total Count ! = = 'number ' ) { throw new Error ( _this + " #query : mapper failed to return total count for paged query " ) ; } try { var models = _this . _ _model Class _ _ . load All ( results ) ; if ( _this . is Paged ) { _this . length = meta . total Count ; _this . splice . apply ( _this , [ ( opts . page - 1 ) * _this . base Opts . page Size , models . length ] . concat ( models ) ) ; } else { _this . replace ( models ) ; } } catch ( e ) { console . error ( e ) ; throw e ; } } , function ( e ) { _this . is Busy = false ; _this . error = e ; return Promise . reject ( e ) ; } ) ) ; } return this ; } 
function query Array At ( i ) { var r = _array 2 . default . prototype . at . apply ( this , arguments ) ; var page Size = this . base Opts & & this . base Opts . page Size ; if ( arguments . length = = = 1 & & ! r & & page Size ) { this . query ( { page : Math . floor ( i / page Size ) + 1 } ) ; } return r ; } 
function mapper Delete Success ( ) { var _this 2 = this ; _id _map 2 . default . delete ( this ) ; this . is Busy = false ; this . source State = DELETED ; this . _clear Errors ( ) ; var _loop = function _loop ( name ) { var desc = _this 2 . associations [ name ] ; if ( ! desc . inverse ) { return "continue " ; } if ( desc . type = = = 'has One ' ) { var m = void 0 ; if ( m = _this 2 [ name ] ) { m . _inverse Removed ( desc . inverse , _this 2 ) ; } } else if ( desc . type = = = 'has Many ' ) { _this 2 [ name ] . slice ( 0 ) . for Each ( function ( m ) { m . _inverse Removed ( desc . inverse , _this 2 ) ; } ) ; } } ; for ( var name in this . associations ) { var _ret = _loop ( name ) ; if ( _ret = = = "continue " ) continue ; } } 
function _loop 2 ( _name ) { var klass = resolve ( associations [ _name ] . klass ) ; var data = associated [ _name ] ; 
function propagate Changes ( ) { var seen = { } ; var head = void 0 ; for ( var id in changed Objects ) { var _changed Objects $id = changed Objects [ id ] , object = _changed Objects $id . object , props = _changed Objects $id . props ; for ( var k in props ) { head = { object : object , name : k , next : head } ; seen [ id + k ] = true ; } } while ( head ) { var _head = head , name = _head . name , object = _head . object , _head $object = _head . object , _object Id = _head $object . object Id , _ _deps _ _ = _head $object . _ _deps _ _ , _ _proxies _ _ = _head $object . _ _proxies _ _ ; var deps = _ _deps _ _ & & _ _deps _ _ [ name ] ; head = head . next ; register Change ( object , name ) ; if ( object . _ _cache _ _ ) { var val = object . _ _cache _ _ [ name ] ; if ( val & & typeof val . unproxy = = = 'function ' ) { val . unproxy ( object , name ) ; } delete object . _ _cache _ _ [ name ] ; } if ( deps ) { for ( var i = 0 , n = deps . length ; i < n ; i + + ) { var seen Key = _object Id + deps [ i ] ; if ( ! seen [ seen Key ] ) { head = { object : object , name : deps [ i ] , next : head } ; seen [ seen Key ] = true ; } } } if ( _ _proxies _ _ & & name . index Of ( ' . ' ) = = = - 1 ) { for ( var _k in _ _proxies _ _ ) { var proxy = _ _proxies _ _ [ _k ] ; var proxy Object = proxy . object ; var proxy Name = proxy . name + ' . ' + name ; var proxy Seen Key = proxy Object . object Id + proxy Name ; if ( ! seen [ proxy Seen Key ] ) { head = { object : proxy Object , name : proxy Name , next : head } ; seen [ proxy Seen Key ] = true ; } } } } } 
function flush ( ) { var f = void 0 ; while ( f = delay Pre Flush Callbacks . shift ( ) ) { f ( ) ; } propagate Changes ( ) ; var cur Changed Objects = changed Objects ; changed Objects = { } ; flush Timer = null ; for ( var id in cur Changed Objects ) { var _cur Changed Objects $id = cur Changed Objects [ id ] , object = _cur Changed Objects $id . object , props = _cur Changed Objects $id . props ; var star = false ; for ( var k in props ) { if ( k . index Of ( ' . ' ) = = = - 1 ) { star = true ; } object . notify ( 
function define Prop ( object , name , opts = { } ) { validate Options ( opts ) ; var descriptor = Object . assign ( { name : name , get : null , set : null , default : undefined , on : [ ] , cache : false , pure : ! ! ( opts . get & & opts . on & & ! opts . set ) , } , opts , { readonly : opts . get & & ! opts . set } ) ; if ( ! object . has Own Property ( ' _ _props _ _ ' ) ) { object . _ _props _ _ = Object . create ( object . _ _props _ _ | | null ) ; } object . _ _props _ _ [ name ] = descriptor ; if ( ! object . has Own Property ( ' _ _deps _ _ ' ) ) { object . _ _deps _ _ = Object . create ( object . _ _deps _ _ | | null ) ; } descriptor . on . for Each ( function ( prop ) { ( object . _ _deps _ _ [ prop ] = object . _ _deps _ _ [ prop ] | | [ ] ) . push ( name ) ; if ( prop . index Of ( ' . ' ) ! = = - 1 ) { let segments = prop . split ( ' . ' ) , first = segments [ 0 ] , last = segments [ 1 ] ; if ( segments . length > 2 ) { throw new Error ( ` \ ` $ { prop } \ ` ` ) ; } ( object . _ _deps _ _ [ first ] = object . _ _deps _ _ [ first ] | | [ ] ) . push ( name ) ; ( object . _ _deps _ _ [ ` $ { first } ` ] = object . _ _deps _ _ [ ` $ { first } ` ] | | [ ] ) . push ( name ) ; ( object . _ _deps _ _ [ ` $ { first } $ { last } ` ] = object . _ _deps _ _ [ ` $ { first } $ { last } ` ] | | [ ] ) . push ( name ) ; } else { ( object . _ _deps _ _ [ ` $ { prop } ` ] = object . _ _deps _ _ [ ` $ { prop } ` ] | | [ ] ) . push ( name ) ; } } ) ; Object . define Property ( object , name , { get : function ( ) { return this . _get Prop ( name ) ; } , set : descriptor . readonly ? undefined : function ( value ) { this . _set Prop ( name , value ) ; } , configurable : false , enumerable : true } ) ; } 
function resolve ( name , raise = true ) { var klass = ( typeof name = = = 'function ' ) ? name : subclasses [ name ] ; if ( ! klass & & raise ) { throw new Error ( ` \ ` $ { name } \ ` ` ) ; } return klass ; } 
function has One Set ( desc , v , sync ) { var name = desc . name , k = ` $ { name } ` , prev = this [ k ] , inv = desc . inverse ; check Associated Type ( desc , v ) ; this [ k ] = v ; if ( sync & & inv & & prev ) { prev . _inverse Removed ( inv , this ) ; } if ( sync & & inv & & v ) { v . _inverse Added ( inv , this ) ; } if ( prev ) { prev . unproxy ( this , name ) ; } if ( v ) { v . proxy ( this , name ) ; } } 
function mapper Delete Success ( ) { Id Map . delete ( this ) ; this . is Busy = false ; this . source State = DELETED ; this . _clear Errors ( ) ; for ( let name in this . associations ) { let desc = this . associations [ name ] ; if ( ! desc . inverse ) { continue ; } if ( desc . type = = = 'has One ' ) { let m ; if ( m = this [ name ] ) { m . _inverse Removed ( desc . inverse , this ) ; } } else if ( desc . type = = = 'has Many ' ) { this [ name ] . slice ( 0 ) . for Each ( ( m ) = > { m . _inverse Removed ( desc . inverse , this ) ; } ) ; } } } 
function file ( relpath ) { return { name : basename ( relpath ) , path : ` $ { relpath } ` , size : 1 2 3 , type : vcard . FILE _TYPES [ 0 ] } } 
function handle Errors ( errors , data ) { const message = errors [ 0 ] . message ; const error = new Error ( ` $ { message } ` ) ; error . raw Error = errors ; error . raw Data = data ; throw error ; } 
function zip ( zip File , src List , dst Path ) { if ( ! dst Path ) { dst Path = false ; } const output = fs . create Write Stream ( zip File ) ; const archive = archiver ( 'zip ' , { zlib : { level : 9 } 
function exec ( cmd , verbose ) { verbose = verbose = = = false ? verbose : true ; const stdout = exec Sync ( cmd ) ; if ( verbose ) { console . log ( stdout . to String ( ) ) ; } return stdout ; } 
function configure Aws ( region , profile , role ) { if ( region ) { AWS . config . update ( { region } ) ; } if ( profile ) { AWS . config . credentials = new AWS . Shared Ini File Credentials ( { profile } ) ; } if ( role ) { AWS . config . credentials = new AWS . Temporary Credentials ( { Role Arn : role } ) ; } } 
function file To String ( file ) { try { const stat = fs . lstat Sync ( file ) ; if ( stat . is File ( ) ) { const content = fs . read File Sync ( file , 'utf 8 ' ) ; return content . to String ( ) ; } } catch ( e ) { if ( ! e . message . includes ( 'ENOENT ' ) & & ! e . message . includes ( 'name too long , lstat ' ) ) { throw e ; } } return file ; } 
function merge Yamls ( file 1 , file 2 ) { const obj 1 = yaml . safe Load ( file To String ( file 1 ) , { schema : yamlfiles . YAML _FILES _SCHEMA } ) ; const obj 2 = yaml . safe Load ( file To String ( file 2 ) , { schema : yamlfiles . YAML _FILES _SCHEMA } ) ; return yaml . safe Dump ( merge ( { } , obj 1 , obj 2 ) ) ; } 
function load Kes Override ( kes Folder , kes Class = 'kes .js ' ) { let kes Override Path = path . resolve ( kes Folder , kes Class ) ; let Kes Override ; try { Kes Override = require ( kes Override Path ) ; } catch ( e ) { 
function determine Kes Class ( options , Kes ) { let Kes Override ; 
function failure ( e ) { if ( e . message ) { console . log ( e . message ) ; } else { console . log ( e ) ; } process . exit ( 1 ) ; } 
function get System Bucket ( config ) { let bucket = get ( config , 'buckets .internal ' ) ; if ( bucket & & typeof bucket = = = 'string ' ) { return bucket ; } bucket = get ( config , 'system _bucket ' ) ; if ( bucket & & typeof bucket = = = 'string ' ) { return bucket ; } return undefined ; } 
function build Nested Cfs ( config , Kes Class , options ) { const limit = p Limit ( 1 ) ; if ( config . nested _templates ) { const nested = config . nested _templates ; console . log ( 'Nested templates are found ! ' ) ; const ps = Object . keys ( nested ) . map ( ( name ) = > limit ( ( ) = > { console . log ( ` $ { name } ` ) ; const new Options = Object . assign ( { } , options ) ; new Options . cf File = nested [ name ] . cf File ; new Options . config File = nested [ name ] . config File ; 
function build Cf ( options , cmd ) { const Kes Class = utils . determine Kes Class ( options , Kes ) ; let parent Config ; try { parent Config = new Config ( options ) ; } catch ( e ) { return Promise . reject ( e ) ; } return build Nested Cfs ( parent Config , Kes Class , options ) . then ( ( config ) = > { const kes = new Kes Class ( config ) ; switch ( cmd ) { case 'create ' : deprecate ( ' "kes cf create " command is deprecated . Use "kes cf deploy " instead ' ) ; return kes . create Stack ( ) ; case 'update ' : deprecate ( ' "kes cf update " command is deprecated . Use "kes cf deploy " instead ' ) ; return kes . update Stack ( ) ; case 'upsert ' : deprecate ( ' "kes cf upsert " command is deprecated . Use "kes cf deploy " instead ' ) ; return kes . upsert Stack ( ) ; case 'deploy ' : return kes . deploy Stack ( ) ; case 'validate ' : return kes . validate Template ( ) ; case 'compile ' : return kes . compile CF ( ) ; case 'delete ' : return kes . delete Stack ( ) ; default : console . log ( 'Wrong choice . Accepted arguments : [create |update |upsert |deploy |validate |compile ] ' ) ; } } ) ; } 
function build Lambda ( options , cmd ) { if ( cmd ) { const Kes Class = utils . determine Kes Class ( options , Kes ) ; const config = new Config ( options ) ; const kes = new Kes Class ( config ) ; kes . update Single Lambda ( cmd ) . then ( r = > utils . success ( r ) ) . catch ( e = > utils . failure ( e ) ) ; } else { utils . failure ( new Error ( 'Lambda name is missing ' ) ) ; } } 
function send Response ( event , context , response Status , response Data ) { const response Body = JSON . stringify ( { Status : response Status , Reason : 'See the details in Cloud Watch Log Stream : ' + context . log Stream Name , Physical Resource Id : context . log Stream Name , Stack Id : event . Stack Id , Request Id : event . Request Id , Logical Resource Id : event . Logical Resource Id , Data : response Data } ) ; console . log ( 'RESPONSE BODY : \n ' , response Body ) ; const https = require ( 'https ' ) ; const url = require ( 'url ' ) ; const parsed Url = url . parse ( event . Response URL ) ; const options = { hostname : parsed Url . hostname , port : 4 4 3 , path : parsed Url . path , method : 'PUT ' , headers : { 'content -type ' : ' ' , 'content -length ' : response Body . length } } ; console . log ( 'SENDING RESPONSE . . . \n ' ) ; const request = https . request ( options , function ( response ) { console . log ( 'STATUS : ' + response . status Code ) ; console . log ( 'HEADERS : ' + JSON . stringify ( response . headers ) ) ; 
function options To String ( options ) { return Object . keys ( options ) . map ( function process Option ( key ) { return key + " = " + options [ key ] ; } ) . join ( " , " ) ; } 
function options Resolve Centered ( options ) { var result = options ; var width = window . outer Width - options . width ; var height = window . outer Height - options . height ; if ( options . centered ) { result . left = options . left | | Math . round ( window . screen X + width / 2 ) ; result . top = options . top | | Math . round ( window . screen Y + height / 2 . 5 ) ; delete result . centered ; } return result ; } 
function assign ( target ) { var sources = Array . prototype . slice . call ( arguments , 1 ) ; function assign Argument ( previous , source ) { Object . keys ( source ) . for Each ( function assign Item ( key ) { previous [ key ] = source [ key ] ; 
function open Popup With Post ( url , post Data , name , options ) { var form = document . create Element ( "form " ) ; var win ; form . set Attribute ( "method " , "post " ) ; form . set Attribute ( "action " , url ) ; form . set Attribute ( "target " , name ) ; Object . keys ( post Data ) . for Each ( function add Form Item ( key ) { var input = document . create Element ( "input " ) ; input . type = "hidden " ; input . name = key ; input . value = post Data [ key ] ; form . append Child ( input ) ; } ) ; document . body . append Child ( form ) ; win = window . open ( " / " , name , options ) ; win . document . write ( "Loading . . . " ) ; form . submit ( ) ; document . body . remove Child ( form ) ; return win ; } 
function popup Execute ( execute , url , name , options , callback ) { var popup Name = name | | default Popup Name ( ) ; var popup Options = options Resolve Centered ( assign ( { } , default Options , options ) ) ; var popup Callback = callback | | function noop ( ) { } ; var options String = options To String ( popup Options ) ; var win = execute ( url , popup Name , options String ) ; var is Message Sent = false ; var interval ; function popup Callback Once ( err , data ) { if ( ! is Message Sent ) { is Message Sent = true ; popup Callback ( err , data ) ; } } function on Message ( message ) { var data = message ? message . data : undefined ; if ( data ) { popup Callback Once ( undefined , data ) ; window . remove Event Listener ( "message " , on Message ) ; } } window . add Event Listener ( "message " , on Message , false ) ; if ( win ) { interval = set Interval ( function close Popup Callback ( ) { if ( win = = null | | win . closed ) { set Timeout ( function delay Window Closing ( ) { clear Interval ( interval ) ; popup Callback Once ( new Error ( "Popup closed " ) ) ; } , 5 0 0 ) ; } } , 1 0 0 ) ; } else { popup Callback Once ( new Error ( "Popup blocked " ) ) ; } return win ; } 
function popup ( url , name , options , callback ) { return popup Execute ( window . open , url , name , options , callback ) ; } 
function popup With Post ( url , post Data , name , options , callback ) { function open With Post Data ( popup Url , popup Name , options String ) { return open Popup With Post ( popup Url , post Data , popup Name , options String ) ; } return popup Execute ( open With Post Data , url , name , options , callback ) ; } 
function Selector ( filter , timeout , window , http , q ) { this . restrict = 'EAC ' ; this . replace = true ; this . transclude = true ; this . scope = { name : ' @ ? ' , value : ' =model ' , disabled : ' = ?disable ' , disable Search : ' = ? ' , required : ' = ?require ' , multiple : ' = ?multi ' , placeholder : ' @ ? ' , value Attr : ' @ ' , label Attr : ' @ ? ' , group Attr : ' @ ? ' , options : ' = ? ' , debounce : ' = ? ' , create : ' & ? ' , limit : ' = ? ' , rtl : ' = ? ' , api : ' = ? ' , change : ' & ? ' , remote : ' & ? ' , remote Param : ' @ ? ' , remote Validation : ' & ? ' , remote Validation Param : ' @ ? ' , remove Button : ' = ? ' , soft Delete : ' = ? ' , close After Selection : ' = ? ' , view Item Template : ' = ? ' , dropdown Item Template : ' = ? ' , dropdown Create Template : ' = ? ' , dropdown Group Template : ' = ? ' } ; this . template Url = 'selector /selector .html ' ; $filter = filter ; $timeout = timeout ; $window = window ; $http = http ; $q = q ; } 
function get Syntax ( editor ) { const mode = editor . get Mode ( ) ; if ( mode . name = = = 'htmlmixed ' ) { return 'html ' ; } return mode . name = = = 'xml ' ? mode . configuration : mode . name ; } 
function get Wrapping Content Range ( editor ) { if ( editor . something Selected ( ) ) { const sel = editor . list Selections ( ) . filter ( sel = > sel . anchor ! = = sel . head ) [ 0 ] ; if ( sel ) { return compare Pos ( sel . anchor , sel . head ) < 0 ? { from : sel . anchor , to : sel . head } : { from : sel . head , to : sel . anchor } ; } } 
function get Tag Range For Pos ( editor , pos ) { const model = editor . get Emmet Document Model ( ) ; const tag = model & & model . node For Point ( pos ) ; if ( ! tag ) { return null ; } 
function between Tags ( editor , range ) { if ( equal Cursor Pos ( range . anchor , range . head ) ) { const cursor = range . anchor ; const mode = editor . get Mode At ( cursor ) ; if ( mode . name = = = 'xml ' ) { const left = editor . get Token At ( cursor ) ; const right = editor . get Token At ( Object . assign ( { } , cursor , { ch : cursor . ch + 1 } ) ) ; return left . type = = = 'tag bracket ' & & left . string = = = ' > ' & & right . type = = = 'tag bracket ' & & right . string = = = ' < / ' ; } } } 
function can Extract ( editor , pos , config ) { const token Type = editor . get Token Type At ( pos ) ; if ( config . type = = = 'stylesheet ' ) { return token Type ! = = 'comment ' & & token Type ! = = 'string ' ; } if ( config . syntax = = = 'html ' ) { return token Type = = = null ; } if ( config . syntax = = = 'slim ' | | config . syntax = = = 'pug ' ) { return token Type = = = null | | token Type = = = 'tag ' | | ( token Type & & / attribute / . test ( token Type ) ) ; } if ( config . syntax = = = 'haml ' ) { return token Type = = = null | | token Type = = = 'attribute ' ; } if ( config . syntax = = = 'jsx ' ) { 
function get Markup Completions ( editor , pos , config ) { const line = editor . get Line ( pos . line ) . slice ( 0 , pos . ch ) ; const prefix = extract Prefix ( line , / [ \w : \ - $ @ ] / ) ; 
function get Stylesheet Completions ( editor , pos , config ) { const line = editor . get Line ( pos . line ) . slice ( 0 , pos . ch ) ; const prefix = extract Prefix ( line , / [ \w - @ $ ] / ) ; if ( prefix ) { 
function get Snippet Completions ( editor , pos , config ) { const { type , syntax } = config ; if ( ! editor . state . emmet Completions ) { editor . state . emmet Completions = { } ; } const cache = editor . state . emmet Completions ; if ( ! ( syntax in cache ) ) { const registry = create Snippets Registry ( type , syntax , config . snippets ) ; cache [ syntax ] = type = = = 'stylesheet ' ? get Stylesheet Snippets ( registry , config ) : get Markup Snippets ( registry , config ) ; } return cache [ syntax ] ; } 
function get Stylesheet Snippets ( registry ) { return convert To CSSSnippets ( registry ) . map ( snippet = > { let preview = snippet . property ; const keywords = snippet . keywords ( ) ; if ( keywords . length ) { preview + = ` $ { remove Fields ( keywords . join ( ' | ' ) ) } ` ; } else if ( snippet . value ) { preview + = ` $ { remove Fields ( snippet . value ) } ` ; } return { key : snippet . key , value : snippet . value , snippet : snippet . key , property : snippet . property , keywords : keywords . map ( kw = > { const m = kw . match ( / ^ [ \w - ] + / ) ; return m & & { key : m [ 0 ] , preview : remove Fields ( kw ) , snippet : kw } ; } ) . filter ( Boolean ) , preview } ; } ) ; } 
function get Markup Snippets ( registry , config ) { return registry . all ( { type : 'string ' } ) . map ( snippet = > ( { key : snippet . key , value : snippet . value , preview : remove Fields ( expand ( snippet . value , config ) ) , snippet : snippet . key } ) ) ; } 
function extract Prefix ( str , match ) { let offset = str . length ; while ( offset > 0 ) { if ( ! match . test ( str [ offset - 1 ] ) ) { break ; } offset - - ; } return str . slice ( offset ) ; } 
function is Valid Marker ( editor , marker ) { const range = marker . find ( ) ; 
function ( property ) { var def = this . _definition [ property ] ; if ( def . type = = = 'boolean ' ) { 
function ( attr ) { if ( attr = = null ) return ! ! Object . keys ( this . _changed ) . length ; if ( has ( this . _derived , attr ) ) { return this . _derived [ attr ] . dep List . some ( function ( dep ) { return this . has Changed ( dep ) ; } , this ) ; } return has ( this . _changed , attr ) ; } 
function ( property Name ) { if ( ! this . _event Bubbling Handler Cache [ property Name ] ) { this . _event Bubbling Handler Cache [ property Name ] = function ( name , model , new Value ) { if ( change RE . test ( name ) ) { this . trigger ( 'change : ' + property Name + ' . ' + name . split ( ' : ' ) [ 1 ] , model , new Value ) ; } else if ( name = = = 'change ' ) { this . trigger ( 'change ' , this ) ; } } . bind ( this ) ; } return this . _event Bubbling Handler Cache [ property Name ] ; } 
function create Property Definition ( object , name , desc , is Session ) { var def = object . _definition [ name ] = { } ; var type , desc Array ; if ( is String ( desc ) ) { 
function create Derived Property ( model Proto , name , definition ) { var def = model Proto . _derived [ name ] = { fn : is Function ( definition ) ? definition : definition . fn , cache : ( definition . cache ! = = false ) , dep List : definition . deps | | [ ] } ; 
function queue ( ) { while ( current < config . concur Limit & & files . length > 0 ) { var file = files . shift ( ) all Files . push ( Promise . resolve ( file ) . then ( function ( file ) { return clean . process One Clean ( file ) . then ( function ( file Path ) { if ( typeof file Path = = = 'string ' ) { files Cleaned . push ( file Path ) } proceed ( ) } ) . catch ( function ( err ) { proceed ( ) functions . log Error ( err ) throw err } ) } ) ) current + + } } 
function re Writer ( go Crazy , file Path , data ) { if ( go Crazy ) { data = data | | 'changed data ' fs . write File Sync ( file Path , data ) re Write Timer = set Timeout ( function ( ) { re Writer ( go Crazy , file Path , data ) } , 5 0 0 ) } else { clear Timeout ( re Write Timer ) } } 
function missing Source ( ) { let preferred Path = path . basename ( config . path . source ) let source = obj . source source = source . replace ( config . path . source , preferred Path ) source = source . replace ( config . path . dest , preferred Path ) source = source . replace ( path . basename ( config . path . dest ) , preferred Path ) if ( source . to Lower Case ( ) . ends With ( ' .map ' ) ) { source = functions . remove Ext ( source ) } if ( shared . slash ! = = ' / ' ) { 
function queue ( ) { while ( current < config . concur Limit & & files . length > 0 ) { var file = files . shift ( ) all Files . push ( Promise . resolve ( file ) . then ( function ( file ) { return build . process One Build ( file ) . then ( function ( file Path ) { if ( typeof file Path = = = 'string ' ) { files Built . push ( file Path ) } proceed ( ) } ) . catch ( function ( err ) { proceed ( ) functions . log Error ( err ) throw err } ) } ) ) current + + } } 
function Image ( image , address ) { var at = this . attributes = image . attribs ; this . name = path . basename ( at . src , path . extname ( at . src ) ) ; this . save To = path . dirname ( require . main . filename ) + " / " ; this . extension = path . extname ( at . src ) ; this . address = url . resolve ( address , at . src ) ; this . from Address = address ; } 
function shipit Task ( grunt ) { 'use strict ' ; 
function inject Template ( s , node , offset , id ) { const t = node . src ? read Src ( id , node . src ) : node . content 
function listen ( ) { if ( state . listening ) return Ejs Electron 
function stop Listening ( ) { if ( ! state . listening ) return Ejs Electron 
function compile Ejs ( pathname , content Buffer ) { state . data . ejse = Ejs Electron state . options . filename = pathname let content String = content Buffer . to String ( ) let compiled Ejs = ejs . render ( content String , state . data , state . options ) return new Buffer ( compiled Ejs ) } 
function _default Check Size ( size ) { return function ( raw ) { if ( raw . length < size ) { return false ; } this . buffer = raw . substr ( size ) ; return raw . substr ( 0 , size ) ; } ; } 
function rstr _hmac _sha 5 1 2 ( key , data ) { var bkey = rstr 2binb ( key ) ; if ( bkey . length > 3 2 ) bkey = binb _sha 5 1 2 ( bkey , key . length * 8 ) ; var ipad = Array ( 3 2 ) , opad = Array ( 3 2 ) ; for ( var i = 0 ; i < 3 2 ; i + + ) { ipad [ i ] = bkey [ i ] ^ 0x 3 6 3 6 3 6 3 6 ; opad [ i ] = bkey [ i ] ^ 0x 5C 5C 5C 5C ; } var hash = binb _sha 5 1 2 ( ipad . concat ( rstr 2binb ( data ) ) , 1 0 2 4 + data . length * 8 ) ; return binb 2rstr ( binb _sha 5 1 2 ( opad . concat ( hash ) , 1 0 2 4 + 5 1 2 ) ) ; } 
function int 6 4add 5 ( dst , a , b , c , d , e ) { var w 0 = ( a . l & 0xffff ) + ( b . l & 0xffff ) + ( c . l & 0xffff ) + ( d . l & 0xffff ) + ( e . l & 0xffff ) ; var w 1 = ( a . l > > > 1 6 ) + ( b . l > > > 1 6 ) + ( c . l > > > 1 6 ) + ( d . l > > > 1 6 ) + ( e . l > > > 1 6 ) + ( w 0 > > > 1 6 ) ; var w 2 = ( a . h & 0xffff ) + ( b . h & 0xffff ) + ( c . h & 0xffff ) + ( d . h & 0xffff ) + ( e . h & 0xffff ) + ( w 1 > > > 1 6 ) ; var w 3 = ( a . h > > > 1 6 ) + ( b . h > > > 1 6 ) + ( c . h > > > 1 6 ) + ( d . h > > > 1 6 ) + ( e . h > > > 1 6 ) + ( w 2 > > > 1 6 ) ; dst . l = ( w 0 & 0xffff ) | ( w 1 < < 1 6 ) ; dst . h = ( w 2 & 0xffff ) | ( w 3 < < 1 6 ) ; } 
function ( config File , options ) { Data Stream . call ( this ) ; this . options = options | | { } ; var self = this ; 
function get Sandbox Map ( ast ) { var map = { } ; walker . with _walkers ( { 
function ( vars ) { for ( var i = 0 , c = vars . length , var Item ; i < c ; i + + ) { var Item = vars [ i ] ; if ( var Item [ 0 ] = = = 'sandbox ' ) { var Item [ 1 ] [ 1 ] . for Each ( function ( object Var ) { map [ object Var [ 0 ] ] = object Var [ 1 ] [ 1 ] ; } ) ; throw 0 ; } } } 
function break Sandbox ( ast , replace Map ) { var sandbox Name = ast [ 2 ] [ 0 ] | | 'sb ' ; var new Ast = walker . with _walkers ( { 
function brake Sandboxes ( ast ) { var map = get Sandbox Map ( ast ) , is Sandbox Variable Wiped = false ; return walker . with _walkers ( { 
function ( ) { if ( is Sandbox Variable Wiped ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , var Item ; i < c ; i + + ) { var Item = this [ 1 ] [ i ] ; if ( var Item [ 0 ] = = = 'sandbox ' ) { is Sandbox Variable Wiped = true ; this [ 1 ] . splice ( i , 1 ) ; return this ; } } } 
function get Events ( ast ) { var usage = { } , event Index = 0 ; walker . with _walkers ( { 
function ( ) { if ( this [ 1 ] & & this [ 2 ] [ 0 ] ) { var function Name = this [ 1 ] [ 1 ] ; switch ( function Name ) { case "lmd _on " : case "lmd _trigger " : var event Name = this [ 2 ] [ 0 ] [ 1 ] ; if ( ! usage [ event Name ] ) { usage [ event Name ] = { on : 0 , trigger : 0 , event Index : event Index } ; event Index + + ; } if ( function Name = = = "lmd _on " ) { usage [ event Name ] . on + + ; } else { usage [ event Name ] . trigger + + ; } break ; } } } 
function wipe Lmd Events ( ast ) { var items To Wipe = [ 'lmd _on ' , 'lmd _trigger ' , 'lmd _events ' ] ; return walker . with _walkers ( { 
function ( ) { if ( ! items To Wipe . length ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , var Item ; i < c ; i + + ) { var Item = this [ 1 ] [ i ] ; if ( var Item ) { var item Index = items To Wipe . index Of ( var Item [ 0 ] ) ; if ( item Index ! = = - 1 ) { items To Wipe . splice ( item Index , 1 ) ; this [ 1 ] . splice ( i , 1 ) ; i - - ; } } } } 
function reduce And Shorten Lmd Events ( ast ) { var events = get Events ( ast ) , is Wipe Lmd Events = true ; for ( var event Name in events ) { if ( is Wipe Lmd Events ) { if ( events [ event Name ] . on ! = = 0 & & events [ event Name ] . trigger ! = = 0 ) { [ "call " , [ "name " , "lmd _trigger " ] , [ [ "string " , "lmd -register :call -sandboxed -module " ] , [ "name " , "module Name " ] , [ "name " , "require " ] ] ] - - - > [ "array " , [ [ "name " , "module Name " ] , [ "name " , "require " ] ] ] * / return [ "array " , this [ 2 ] . slice ( 1 ) ] ; } [main ] [ 0 ] - - - > main * / return this [ 1 ] [ 1 ] [ index ] ; } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; return ast ; } 
function ( ) { if ( this [ 1 ] & & this [ 2 ] [ 0 ] ) { var function Name = this [ 1 ] [ 1 ] , event Name , event Descriptor ; switch ( function Name ) { case "lmd _on " : event Name = this [ 2 ] [ 0 ] [ 1 ] ; event Descriptor = events [ event Name ] ; [ "call " , [ "name " , "lmd _trigger " ] , [ [ "string " , "lmd -register :call -sandboxed -module " ] , [ "name " , "module Name " ] , [ "name " , "require " ] ] ] - - - > [ "array " , [ [ "name " , "module Name " ] , [ "name " , "require " ] ] ] * / return [ "array " , this [ 2 ] . slice ( 1 ) ] ; } 
function ( option Name , is Apply , is Inline ) { 
function ( e ) { if ( is Not Loaded ) { is Not Loaded = 0 ; 
function d 3 _layout _hierarchy Rebind ( object , hierarchy ) { object . sort = d 3 . rebind ( object , hierarchy . sort ) ; object . children = d 3 . rebind ( object , hierarchy . children ) ; object . links = d 3 _layout _hierarchy Links ; object . value = d 3 . rebind ( object , hierarchy . value ) ; 
function position ( row , u , rect , flush ) { var i = - 1 , n = row . length , x = rect . x , y = rect . y , v = u ? round ( row . area / u ) : 0 , o ; if ( u = = rect . dx ) { 
function ( classes ) { var map = { } ; function find ( name , data ) { var node = map [ name ] , i ; if ( ! node ) { node = map [ name ] = data | | { name : name , children : [ ] } ; if ( name . length ) { node . parent = find ( " " ) ; node . parent . children . push ( node ) ; node . name = name ; node . key = escape Id ( name ) ; } } return node ; } classes . for Each ( function ( d ) { find ( d . name , d ) ; } ) ; return map [ " " ] ; } 
function stringify ( object ) { var properties = [ ] ; for ( var key in object ) { if ( object . has Own Property ( key ) ) { properties . push ( quote ( key ) + ' : ' + get Value ( object [ key ] ) ) ; } } return " { " + properties . join ( " , " ) + " } " ; } 
function ( ) { this . input = this . $ ( ' #new -todo ' ) ; this . all Checkbox = this . $ ( ' #toggle -all ' ) [ 0 ] ; this . $footer = this . $ ( ' #footer ' ) ; this . $main = this . $ ( ' #main ' ) ; todos . on ( 'add ' , this . add One , this ) ; todos . on ( 'reset ' , this . add All , this ) ; todos . on ( 'change :completed ' , this . filter One , this ) ; todos . on ( "filter " , this . filter All , this ) ; todos . on ( 'all ' , this . render , this ) ; todos . fetch ( ) ; } 
function ( ) { var completed = todos . completed ( ) . length ; var remaining = todos . remaining ( ) . length ; if ( todos . length ) { this . $main . show ( ) ; this . $footer . show ( ) ; this . $footer . html ( this . template ( { completed : completed , remaining : remaining } ) ) ; this . $ ( ' #filters li a ' ) . remove Class ( 'selected ' ) . filter ( ' [href = " # / ' + ( common . Todo Filter | | ' ' ) + ' " ] ' ) . add Class ( 'selected ' ) ; } else { this . $main . hide ( ) ; this . $footer . hide ( ) ; } this . all Checkbox . checked = ! remaining ; } 
function ( e ) { if ( e . which ! = = common . ENTER _KEY | | ! this . input . val ( ) . trim ( ) ) { return ; } todos . create ( this . new Attributes ( ) ) ; this . input . val ( ' ' ) ; } 
function count Line ( ) { var ret ; 
function count If ( ) { var self = this , ret ; if ( self [ 0 ] . start & & analyzing . index Of ( self ) < 0 ) { var decision = self [ 1 ] ; var line Id = self [ 0 ] . name + ' : ' + ( self [ 0 ] . start . line + line Offset ) ; self [ 1 ] = wrap Condition ( decision , line Id ) ; 
function wrap Condition ( decision , line Id , parent Pos ) { if ( options . condition = = = false ) { 
function is Single Condition ( decision ) { if ( decision [ 0 ] . start & & decision [ 0 ] . name ! = "binary " ) { return true ; } else if ( decision [ 1 ] = = " & & " | | decision [ 1 ] = = " | | " ) { return false ; } else { return true ; } } 
function count Label ( ) { var ret ; if ( this [ 0 ] . start & & analyzing . index Of ( this ) < 0 ) { var content = this [ 2 ] ; if ( content [ 0 ] . name = = "for " & & content [ 4 ] & & content [ 4 ] . name ! = "block " ) { content [ 4 ] = [ "block " , [ content [ 4 ] ] ] ; } analyzing . push ( content ) ; var ret = count Line . call ( this ) ; analyzing . pop ( content ) ; } return ret ; } 
function count Function ( ) { var ret ; if ( is First Line ) { is First Line = false ; return ret ; } if ( this [ 0 ] . start & & analyzing . index Of ( this ) < 0 ) { var defun = this [ 0 ] . name = = = "defun " ; var line Id = this [ 0 ] . start . line + line Offset + ' ' ; 
function give Name To Anonymous Function ( ) { var node = this ; if ( node [ 0 ] . name = = "var " | | node [ 0 ] . name = = "object " ) { node [ 1 ] . for Each ( function ( assignemt ) { if ( assignemt [ 1 ] ) { if ( assignemt [ 1 ] [ 0 ] . name = = = "function " ) { assignemt [ 1 ] [ 0 ] . anonymous Name = assignemt [ 0 ] ; } else if ( assignemt [ 1 ] [ 0 ] . name = = = "conditional " ) { if ( assignemt [ 1 ] [ 2 ] [ 0 ] & & assignemt [ 1 ] [ 2 ] [ 0 ] . name = = = "function " ) { assignemt [ 1 ] [ 2 ] [ 0 ] . anonymous Name = assignemt [ 0 ] ; } if ( assignemt [ 1 ] [ 3 ] [ 0 ] & & assignemt [ 1 ] [ 3 ] [ 0 ] . name = = = "function " ) { assignemt [ 1 ] [ 3 ] [ 0 ] . anonymous Name = assignemt [ 0 ] ; } } } } ) ; } else if ( node [ 0 ] . name = = "assign " & & node [ 1 ] = = = true ) { if ( node [ 3 ] [ 0 ] . name = = = "function " ) { node [ 3 ] [ 0 ] . anonymous Name = get Name From Assign ( node ) ; } else if ( node [ 3 ] [ 0 ] = = = "conditional " ) { if ( node [ 3 ] [ 2 ] [ 0 ] & & node [ 3 ] [ 2 ] [ 0 ] . name = = = "function " ) { node [ 3 ] [ 2 ] [ 0 ] . anonymous Name = get Name From Assign ( node ) ; } if ( node [ 3 ] [ 3 ] [ 0 ] & & node [ 3 ] [ 3 ] [ 0 ] . name = = = "function " ) { node [ 3 ] [ 3 ] [ 0 ] . anonymous Name = get Name From Assign ( node ) ; } } } } 
function wrap Conditionals ( ) { if ( options . condition = = = false ) { 
function ( name , deps , module ) { switch ( arguments . length ) { case 1 : 
function stats _calculate _coverage ( module Name ) { var stats = sb . trigger ( ' * :stats -get ' , module Name , null ) [ 1 ] , total , covered , line Id , line Num , parts ; var line Report = { } ; if ( ! stats . lines ) { return ; } stats . coverage = { } ; covered = 0 ; total = stats . lines . length ; for ( line Id in stats . run Lines ) { if ( stats . run Lines [ line Id ] > 0 ) { covered + + ; } else { line Num = line Id ; if ( ! line Report [ line Num ] ) { line Report [ line Num ] = { } ; } line Report [ line Num ] . lines = false ; } } stats . coverage . lines = { total : total , covered : covered , percentage : 1 0 0 . 0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . functions . length ; for ( line Id in stats . run Functions ) { if ( stats . run Functions [ line Id ] > 0 ) { covered + + ; } else { parts = line Id . split ( ' : ' ) ; line Num = parts [ 1 ] ; if ( ! line Report [ line Num ] ) { line Report [ line Num ] = { } ; } if ( ! line Report [ line Num ] . functions ) { line Report [ line Num ] . functions = [ ] ; } line Report [ line Num ] . functions . push ( parts [ 0 ] ) ; } } stats . coverage . functions = { total : total , covered : covered , percentage : 1 0 0 . 0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . conditions . length ; for ( line Id in stats . run Conditions ) { if ( stats . run Conditions [ line Id ] [ 1 ] > 0 ) { covered + = 1 ; } if ( stats . run Conditions [ line Id ] [ 1 ] = = = 0 ) { parts = line Id . split ( ' : ' ) ; line Num = parts [ 1 ] ; if ( ! line Report [ line Num ] ) { line Report [ line Num ] = { } ; } if ( ! line Report [ line Num ] . conditions ) { line Report [ line Num ] . conditions = [ ] ; } line Report [ line Num ] . conditions . push ( stats . run Conditions [ line Id ] ) ; } } stats . coverage . conditions = { total : total , covered : covered , percentage : 1 0 0 . 0 * ( total ? covered / total : 1 ) } ; stats . coverage . report = line Report ; } 
function Roster ( element ) { element . inner HTML + = this . render Wrapper ( ) ; var contacts Html = [ ] ; for ( var i = 1 0 0 ; i - - > 0 ; ) { contacts Html . push ( this . render Item ( ) ) ; } $ ( ' .b -roster ' ) . inner HTML = contacts Html . join ( ' ' ) ; $ ( ' .b -roster ' ) . add Event Listener ( 'click ' , function ( e ) { / / Preload talk for dialog using parallel resource loading require . async ( [ 'js /lmd /modules /b -dialog .min .js ' , 'js /lmd /modules /b -talk .min .js ' ] , function ( Dialog ) { new Dialog ( element ) ; } ) ; } , false ) ; } 
function render Map ( ) { var $map = $ ( ' #map ' ) ; 
function interpolate Config Strings ( config , data ) { data = data | | config ; for ( var key in config ) { var value = config [ key ] ; if ( typeof value = = = "object " ) { config [ key ] = interpolate Config Strings ( value , data ) ; } else if ( typeof value = = = "string " ) { var current Interpolation = 0 ; while ( template Parts . test ( value ) ) { current Interpolation + + ; if ( current Interpolation > max Interpolate Recursion ) { break ; } config [ key ] = value = template ( value , data ) ; } } } return config ; } 
function ( config , mixins ) { if ( Array . is Array ( config . mixins ) & & Array . is Array ( mixins ) ) { config . mixins . push . apply ( config . mixins , mixins ) ; return config ; } return deep Destructable Merge ( config , { mixins : mixins } ) ; } 
function ( left , right ) { for ( var prop in right ) { if ( right . has Own Property ( prop ) ) { if ( typeof left [ prop ] = = = "object " ) { deep Destructable Merge ( left [ prop ] , right [ prop ] ) ; } else { left [ prop ] = right [ prop ] ; } } } return left ; } 
function ( config , config Dir ) { config = config | | { } ; if ( typeof config . extends ! = = "string " ) { return config ; } var parent Config = try Extend ( read Config ( config Dir , config . extends ) , config Dir ) ; return deep Destructable Merge ( parent Config , config ) ; } 
function ( module Path , depends File Mask ) { module Path = [ ] . concat ( module Path ) ; return module Path . map ( function ( module Path ) { var file Name = module Path . replace ( / ^ . * \ / | \ . [a -z 0 - 9 ] + $ / g , ' ' ) ; return path . join ( path . dirname ( module Path ) , depends File Mask . replace ( ' * ' , file Name ) ) ; } ) ; } 
function ( config A , config B , flags Names , is Master Config ) { 
function ( config A , config B , flags Names , inheritable Fields , is Master Config , context ) { if ( is Master Config ) { 
function ( raw Config , config File , config Dir , flags Names , extra Options , used Configs ) { flags Names = flags Names | | Object . keys ( LMD _PLUGINS ) ; var is First Run = typeof used Configs = = = "undefined " ; used Configs = used Configs | | { } ; used Configs [ config File ] = true ; 
function ( config File , flags Names , extra Options , used Configs ) { var config Dir = path . dirname ( config File ) , raw Config = read Config ( config File ) ; config File = fs . realpath Sync ( config File ) ; return assemble Lmd Config As Object ( raw Config , config File , config Dir , flags Names , extra Options , used Configs ) ; } 
function add Plugins From Bundles ( result Config ) { if ( result Config . bundles ) { var bundles = Object . keys ( result Config . bundles ) , lmd Plugins = Object . keys ( LMD _PLUGINS ) ; 
function ( config , config Dir ) { var modules = { } , global Lazy = config . lazy | | false , global Depends = ( config . depends = = = true ? DEFAULT _DEPENDS _MASK : config . depends ) | | false , module Lazy = false , module Type Hint , module Name , module Path , module Real Path , module Exists , module Exports , module Require , module Bind , module File Name , module File Path , module Desciptor , wildcard Regex , is Multi Path Module , module Data , is Third Party Module , modules Dir Path = config . root | | config . path | | ' ' ; modules Dir Path = path . resolve ( config Dir , modules Dir Path ) ; 
function ( code , options ) { var exports = [ ] , requires = [ ] , bind = [ ] , extra _exports = options . extra _exports , extra _require = options . extra _require , extra _bind = options . extra _bind , export Code , bind Module Name ; 
function ( code , module Options , module Type ) { switch ( module Type ) { case " 3 -party " : 
function get Module Type ( code ) { var ast ; if ( typeof code = = = "object " ) { ast = code ; } else { try { JSON . parse ( code ) ; return "json " ; } catch ( e ) { } try { ast = parser . parse ( code ) ; } catch ( e ) { return "string " ; } } 
function get Module File By Short Name ( lmd Dir , short Name ) { var files ; try { files = fs . readdir Sync ( lmd Dir ) ; } catch ( e ) { return void 0 ; } for ( var i = 0 , c = files . length , file Name ; i < c ; i + + ) { file Name = files [ i ] ; var file Extension = ( file Name . match ( re Lmd File ) | | 0 ) [ 0 ] ; if ( file Extension & & path . basename ( file Name , file Extension ) = = = short Name ) { return file Name ; } } } 
function d 3 _transform ( m ) { var r 0 = [ m . a , m . b ] , r 1 = [ m . c , m . d ] , kx = d 3 _transform Normalize ( r 0 ) , kz = d 3 _transform Dot ( r 0 , r 1 ) , ky = d 3 _transform Normalize ( d 3 _transform Combine ( r 1 , r 0 , - kz ) ) ; this . translate = [ m . e , m . f ] ; this . rotate = Math . atan 2 ( m . b , m . a ) * d 3 _transform Degrees ; this . scale = [ kx , ky | | 0 ] ; this . skew = ky ? kz / ky * d 3 _transform Degrees : 0 ; } 
function d 3 _svg _line Points ( self , d , x , y ) { var points = [ ] , i = - 1 , n = d . length , fx = typeof x = = = "function " , fy = typeof y = = = "function " , value ; if ( fx & & fy ) { while ( + + i < n ) points . push ( [ x . call ( self , value = d [ i ] , i ) , y . call ( self , value , i ) ] ) ; } else if ( fx ) { while ( + + i < n ) points . push ( [ x . call ( self , d [ i ] , i ) , y ] ) ; } else if ( fy ) { while ( + + i < n ) points . push ( [ x , y . call ( self , d [ i ] , i ) ] ) ; } else { while ( + + i < n ) points . push ( [ x , y ] ) ; } return points ; } 
function chord ( d , i ) { var s = subgroup ( this , source , d , i ) , t = subgroup ( this , target , d , i ) ; return "M " + s . p 0 + arc ( s . r , s . p 1 ) + ( equals ( s , t ) ? curve ( s . r , s . p 1 , s . r , s . p 0 ) : curve ( s . r , s . p 1 , t . r , t . p 0 ) + arc ( t . r , t . p 1 ) + curve ( t . r , t . p 1 , s . r , s . p 0 ) ) + "Z " ; } 
function brush ( g ) { var resizes = x & & y ? [ "n " , "e " , "s " , "w " , "nw " , "ne " , "se " , "sw " ] : x ? [ "e " , "w " ] : y ? [ "n " , "s " ] : [ ] ; g . each ( function ( ) { var g = d 3 . select ( this ) . on ( "mousedown .brush " , down ) , bg = g . select All ( " .background " ) . data ( [ , ] ) , fg = g . select All ( " .extent " ) . data ( [ , ] ) , tz = g . select All ( " .resize " ) . data ( resizes , String ) , e ; 
function start ( ) { d 3 _behavior _drag Event = event ; d 3 _behavior _drag Event Target = d 3 . event . target ; d 3 _behavior _drag Target = this ; d 3 _behavior _drag Arguments = arguments ; d 3 _behavior _drag Origin = d 3 _behavior _drag Point ( ) ; if ( origin ) { d 3 _behavior _drag Offset = origin . apply ( d 3 _behavior _drag Target , d 3 _behavior _drag Arguments ) ; d 3 _behavior _drag Offset = [ d 3 _behavior _drag Offset . x - d 3 _behavior _drag Origin [ 0 ] , d 3 _behavior _drag Offset . y - d 3 _behavior _drag Origin [ 1 ] ] ; } else { d 3 _behavior _drag Offset = [ 0 , 0 ] ; } d 3 _behavior _drag Moved = 0 ; } 
function start ( ) { d 3 _behavior _zoom Xyz = xyz ; d 3 _behavior _zoom Extent = extent ; d 3 _behavior _zoom Dispatch = event . zoom ; d 3 _behavior _zoom Event Target = d 3 . event . target ; d 3 _behavior _zoom Target = this ; d 3 _behavior _zoom Arguments = arguments ; } 
function mousewheel ( ) { start . apply ( this , arguments ) ; if ( ! d 3 _behavior _zoom Zooming ) d 3 _behavior _zoom Zooming = d 3 _behavior _zoom Location ( d 3 . svg . mouse ( d 3 _behavior _zoom Target ) ) ; d 3 _behavior _zoom To ( d 3 _behavior _zoom Delta ( ) + xyz [ 2 ] , d 3 . svg . mouse ( d 3 _behavior _zoom Target ) , d 3 _behavior _zoom Zooming ) ; } 
function touchstart ( ) { start . apply ( this , arguments ) ; var touches = d 3 _behavior _zoom Touchup ( ) , touch , now = Date . now ( ) ; if ( ( touches . length = = = 1 ) & & ( now - d 3 _behavior _zoom Last < 3 0 0 ) ) { d 3 _behavior _zoom To ( 1 + Math . floor ( xyz [ 2 ] ) , touch = touches [ 0 ] , d 3 _behavior _zoom Locations [ touch . identifier ] ) ; } d 3 _behavior _zoom Last = now ; } 
function d 3 _behavior _zoom Delta ( ) { 
function d 3 _behavior _zoom Touchup ( ) { var touches = d 3 . svg . touches ( d 3 _behavior _zoom Target ) , i = - 1 , n = touches . length , touch ; while ( + + i < n ) d 3 _behavior _zoom Locations [ ( touch = touches [ i ] ) . identifier ] = d 3 _behavior _zoom Location ( touch ) ; return touches ; } 
function ( _main , _modules , _modules _options ) { if ( typeof _main = = = "object " ) { _modules _options = _modules ; _modules = _main ; } for ( var module Name in _modules ) { 
function draw Image On Canvas ( img ) { var ctx = $ ( 'canvas ' ) [ 0 ] . get Context ( ' 2d ' ) ; ctx . draw Image ( img , 0 , 0 ) ; ctx . rotate ( - Math . PI / 1 2 ) ; ctx . translate ( 0 , 1 5 0 ) ; } 
function ( data ) { var config ; 
function still Current ( url Node , options ) { var lesser , greater , o Path ; var now = Date . now ( ) ; var l Mod = _ . first ( url Node . lastmod ) ; var c Freq = _ . first ( url Node . changefreq ) ? _ . first ( url Node . changefreq ) . to Lower Case ( ) : null ; 
function parse ( options , document , callback ) { xml 2js . parse String ( document , { trim : true , normalize Tags : true , normalize : true } , function ( err , result ) { var source = options . source ; if ( ! err ) { 
function convert ( options , buffer , next , callback ) { var gunzip = path . extname ( options . source ) = = = " .gz " ; if ( gunzip ) { zlib . gunzip ( buffer , function ( err , result ) { if ( err ) { callback ( common . prepend Msg To Err ( err , options . source , true ) ) ; } else { next ( options , result & & result . to String ( ) , callback ) ; } } ) ; } else { next ( options , buffer . to String ( ) , callback ) ; } } 
function get Url ( options , parse Fn , callback ) { request ( { url : options . source , encoding : null , timeout : options . timeout ( ) 
function get File ( options , parse Fn , callback ) { fs . read File ( options . source , function ( err , data ) { if ( err ) { callback ( common . prepend Msg To Err ( err , options . source , true ) ) ; } else { convert ( options , data , parse Fn , callback ) ; } } ) ; } 
function ( ) { var options = { } ; var defaults = { 
function ( options , must ) { if ( must ) { for ( var prop in must ) { if ( options [ prop ] = = = void 0 | | options [ prop ] = = = null ) { options [ prop ] = must [ prop ] ; } } } return options ; } 
function ( error , message , quote Input ) { var result , prepend , empty = " " , quote = " ' " ; if ( error ) { if ( message ) { prepend = quote Input ? empty . concat ( quote , message , quote ) : message ; } 
function ( res , media Types ) { var content Type Ok , result = "status : ' " + res . status Code + " ' , GET failed . " ; media Types = ! Array . is Array ( media Types ) ? [ media Types ] : media Types ; if ( res . status Code = = = 2 0 0 ) { 
function node Call ( node Func ) { var node Args = Array . prototype . slice . call ( arguments , 1 ) ; return new Promise ( function ( resolve , reject ) { function node Resolver ( err , value ) { if ( err ) { reject ( err ) ; } else { resolve ( value ) ; } } node Args . push ( node Resolver ) ; node Func . apply ( node Func , node Args ) ; } ) ; } 
function prepare Write ( output Path , callback ) { var path = path Lib . parse ( output Path ) ; var dir = path Lib . join ( path . root , path . dir ) ; mkdirp ( dir , callback ) ; } 
function process Sitemap ( options , document , callback ) { sm Lib . parse ( options , document , function ( err ) { var sitemap Index Opts = options . _ _sitemap Index ; var output Path = base . output File ( sitemap Index Opts , options . source ) ; if ( ! err & & sitemap Index Opts . sitemap Output Dir ) { prepare Write ( output Path , function ( err ) { if ( ! err ) { fs . write File ( output Path , document , callback ) ; } else { callback ( common . prepend Msg To Err ( err , output Path , true ) ) ; } } ) ; } else { callback ( err ) ; } } ) ; } 
function parse ( options , document , callback ) { xml 2js . parse String ( document , { trim : true , normalize Tags : true , normalize : true } , function ( err , result ) { var sitemap Urls = [ ] ; var sitemap Index Options = Object . assign ( { } , options , { output Path : undefined } ) ; if ( ! err ) { 
function generate Input ( options ) { return node Call ( common . is Url ( options . source ) ? sm Lib . get Url : sm Lib . get File , options , parse ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( ) { base . EOI ( sitemap Index ) ; } ) ; } 
function ( options , listener ) { var opts = Object . assign ( { } , base . defaults ( defaults ) , options ) ; return base . run ( opts , generate Input , listener ) ; } 
function generate Input ( options ) { return node Call ( fs . read File , options . source ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( data ) { var error ; if ( data ) { data . to String ( ) . split ( ' \n ' ) . every ( function ( line ) { var page = line . replace ( / ^ \s + | \s + $ / g , " " ) ; if ( ! base . input ( options , page ) ) { error = common . prepend Msg To Err ( base . generator Error ( ) , page , true ) ; return false ; } return true ; } ) ; if ( error ) { console . error ( error ) ; options . _abort ( error ) ; } } base . EOI ( textfile ) ; } ) ; } 
function generate Input ( options ) { var result = new Promise ( function ( resolve , reject ) { var all ; if ( Array . is Array ( options . source ) ) { all = options . source . every ( function ( source Url ) { var url = urlm . parse ( source Url ) ; var opts = Object . assign ( { } , options , { protocol : url . protocol , auth : url . auth , hostname : url . hostname , port : url . port } ) ; if ( ! base . input ( opts , source Url ) ) { reject ( common . prepend Msg To Err ( base . generator Error ( ) , source Url , true ) ) ; return false ; } return true ; } ) ; if ( all ) { resolve ( ) ; } } else { reject ( new Error ( "options .source must be an array " ) ) ; } } ) ; return result . catch ( function ( error ) { options . _abort ( error ) ; } ) . then ( function ( ) { base . EOI ( array ) ; } ) ; } 
function verbose ( page ) { page . on Resource Error = function ( resource Error ) { system . stderr . write Line ( ' = on Resource Error ( ) ' ) ; system . stderr . write Line ( ' - unable to load url : " ' + resource Error . url + ' " ' ) ; system . stderr . write Line ( ' - error code : ' + resource Error . error Code + ' , description : ' + resource Error . error String ) ; } ; page . on Error = function ( msg , trace ) { system . stderr . write Line ( ' = on Error ( ) ' ) ; var msg Stack = [ ' ERROR : ' + msg ] ; if ( trace ) { msg Stack . push ( ' TRACE : ' ) ; trace . for Each ( function ( t ) { msg Stack . push ( ' - > ' + t . file + ' : ' + t . line + ( t . function ? ' (in function " ' + t . function + ' " ) ' : ' ' ) ) ; } ) ; } system . stderr . write Line ( msg Stack . join ( ' \n ' ) ) ; } ; page . on Resource Requested = function ( request ) { system . stderr . write Line ( ' = on Resource Requested ( ) ' ) ; system . stderr . write Line ( ' request : ' + JSON . stringify ( request , undefined , 4 ) ) ; } ; page . on Resource Received = function ( response ) { system . stderr . write Line ( ' = on Resource Received ( ) ' ) ; system . stderr . write Line ( ' id : ' + response . id + ' , stage : " ' + response . stage + ' " , response : ' + JSON . stringify ( response ) ) ; } ; page . on Load Started = function ( ) { system . stderr . write Line ( ' = on Load Started ( ) ' ) ; var current Url = page . evaluate ( function ( ) { return window . location . href ; } ) ; system . stderr . write Line ( ' leaving url : ' + current Url ) ; } ; page . on Navigation Requested = function ( url , type , will Navigate , main ) { system . stderr . write Line ( ' = on Navigation Requested ' ) ; system . stderr . write Line ( ' destination _url : ' + url ) ; system . stderr . write Line ( ' type (cause ) : ' + type ) ; system . stderr . write Line ( ' will navigate : ' + will Navigate ) ; system . stderr . write Line ( ' from page \ 's main frame : ' + main ) ; } ; page . on Load Finished = function ( status ) { system . stderr . write Line ( ' = on Load Finished ( ) ' ) ; system . stderr . write Line ( ' status : ' + status ) ; } ; } 
function ( input ) { var result = { run : function ( ) { return [ ] ; } , _ _null : true } , has Input ; if ( input ) { input = ( " " + input ) . replace ( " " , " " ) . to Lower Case ( ) ; has Input = input & & input . char At ( 0 ) ! = = ' _ ' & & input ! = = "index " ; } try { if ( has Input ) { result = require ( " . / " + input ) ; } } catch ( e ) { console . error ( "Input generator load failed ' " + input + " ' " , e ) } return result ; } 
function normalize ( obj ) { var result = obj ; if ( typeof obj ! = = "function " ) { if ( typeof obj ! = = "undefined " ) { if ( Object . prototype . to String . call ( obj ) ! = = " [object Object ] " ) { result = ( function ( value ) { return function ( ) { return value ; } ; } ( obj ) ) ; } else { result = ( function ( o ) { return function ( key , passthru ) { if ( o [ key ] = = = void 0 ) { return o . _ _default | | ( passthru ? key : undefined ) ; } else { return o [ key ] ; } } ; } ( obj ) ) ; } } else { result = function ( passthru ) { return passthru ; } ; } } return result ; } 
function supply Missing Default ( options , name ) { if ( options [ name ] ( ) = = = void 0 ) { options [ name ] = _ . wrap ( options [ name ] , function ( func , key ) { var res = func ( key ) ; return res = = = void 0 ? defaults [ name ] : res ; } ) ; } } 
function prep Options ( options , listener ) { 
function get Output Path ( options , page , parse ) { var page Part = urlm . parse ( page ) , 
function map Output File ( options , page , parse ) { if ( ! _ . is Function ( options . output Path ) ) { options . output Path = normalize ( options . output Path ) ; } var output Path = get Output Path ( options , page , parse ) ; var output Dir = options . output Dir ; var file Name = "index .html " ; if ( options . sitemap Output Dir ) { output Dir = path . join ( options . output Dir , options . sitemap Output Dir ) ; file Name = " " ; } return ( output Path & & path . join ( output Dir , output Path , file Name ) ) | | false ; } 
function ( options , generator , listener ) { options = options | | { } ; prep Options ( options , listener ) ; return generator ( options ) ; } 
function ( options , page ) { var parse = { } ; var output File = map Output File ( options , page , parse ) ; if ( output File ) { options . _input Emitter . emit ( "input " , { output File : output File , 
function path Exists ( path , options ) { options = options | | { return File : false } ; 
function ( ) { 
function worker ( input , options , notifier , qcb ) { var cp , custom Module , snapshot Script = options . snapshot Script , phantomjs Options = Array . is Array ( input . phantomjs Options ) ? input . phantomjs Options : [ input . phantomjs Options ] ; 
function prep Options ( options ) { 
function ( options , listener ) { var input Generator , notifier , started , result , q , emitter , completion ; options = options | | { } ; prep Options ( options ) ; 
function create Lock Factory ( ) { * Force a serial execution context . * * @param {Function } fn - The function to guard . * @param {Number } timeout - The max time to wait for the lock . * / return function lock Factory ( fn , timeout ) { return function protected Context ( ) { lock . acquire ( "cs -guard - " + rid , function ( done ) { fn ( function ( ) { done ( null , 0 ) ; } ) ; } , NOOP , { timeout : timeout } ) ; } ; } ; } 
function Notifier ( ) { 
function start ( poll Interval , input , listener ) { var result = ( poll Interval > 0 & & typeof listener = = = "function " & & ( ! ! input ) ) ; if ( result ) { if ( this . is Started ( ) ) { throw new Error ( "Notifier already started " ) ; } this . callback = listener ; this . interval = parse Int ( poll Interval , 1 0 ) ; 
function add ( output File , timeout ) { var fail Timeout = timeout ; var timer ; if ( ! this . is Started ( ) ) { throw new Error ( "MUST call `start ` before `add ` " ) ; } if ( ! this . _exists ( output File ) ) { 
function known ( output File ) { var result = false ; this . cs Factory ( function ( done ) { result = this . _exists ( output File ) | | this . files Done . index Of ( output File ) > - 1 ; done ( ) ; } . bind ( this ) , L _WAIT ) ( ) ; return result ; } 
function _remove ( output File , done ) { if ( this . _exists ( output File ) ) { if ( done ) { this . files Done . push ( output File ) ; } else { this . files Not Done . push ( output File ) ; } clear Timeout ( this . files [ output File ] . timer ) ; delete this . files [ output File ] ; } } 
function remove ( output File , done ) { this . cs Factory ( function ( _done ) { this . _remove ( output File , done ) ; _done ( ) ; } . bind ( this ) , L _WAIT ) ( ) ; } 
function abort ( q , err ) { this . cs Factory ( function ( done ) { try { 
function wait For ( test Fx , on Ready , on Timeout , timeout , check Interval ) { var condition = false , interval = set Interval ( function ( ) { if ( ( new Date ( ) . get Time ( ) - start < timeout ) & & ! condition ) { 
function snapshot ( options , detector , filter ) { filter = filter | | function ( content ) { return content ; } ; console . log ( "Creating snapshot for " + options . url + " . . . " ) ; 
function ( time ) { fs . write ( options . output File , filter ( page . content ) , "w " ) ; globals . exit ( 0 , "snapshot for " + options . url + " finished in " + time + " ms \n written to " + options . output File ) ; } 
function oneline ( line , options ) { var key = "Allow : " , index = line . index Of ( key ) ; if ( index ! = = - 1 ) { var page = line . substr ( index + key . length ) . replace ( / ^ \s + | \s + $ / g , " " ) ; return page . index Of ( " * " ) = = = - 1 & & base . input ( options , page ) ; } return true ; } 
function get Robots Url ( options , callback ) { request ( { url : options . source , timeout : options . timeout ( ) } , function ( err , res , body ) { var error = err | | common . check Response ( res , "text /plain " ) ; if ( error ) { callback ( common . prepend Msg To Err ( error , options . source , true ) ) ; } else { body . to String ( ) . split ( ' \n ' ) . every ( function ( line ) { 
function get Robots File ( options , callback ) { fs . read File ( options . source , function ( err , data ) { if ( ! err ) { data . to String ( ) . split ( ' \n ' ) . every ( function ( line ) { 
function generate Input ( options ) { return node Call ( common . is Url ( options . source ) ? get Robots Url : get Robots File , options ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( ) { base . EOI ( robots ) ; } ) ; } 
function ( options ) { var result = false ; var el = document . query Selector ( options . selector ) ; if ( el ) { 
function bubble ( values ) { return values . map ( d = > { if ( d . key & & d . values ) { if ( d . values [ 0 ] . key = = = "undefined " ) return d . values [ 0 ] . values [ 0 ] ; else d . values = bubble ( d . values ) ; } return d ; } ) ; } 
function exclude ( a , b , v ) { const a Start = a . start ( { type : "big Integer " } ) ; const b Start = b . start ( { type : "big Integer " } ) ; const a End = a . end ( { type : "big Integer " } ) ; const b End = b . end ( { type : "big Integer " } ) ; const parts = [ ] ; 
function heart Beat ( ) { var is Empty = true ; 
function log ( ) { if ( conf . debug & & typeof console ! = = "undefined " ) { if ( arguments [ 1 ] & & typeof arguments [ 1 ] = = = "object " ) { arguments [ 1 ] = JSON . stringify ( arguments [ 1 ] ) ; } console . log ( Array . prototype . slice . call ( arguments ) . join ( " \n " ) ) ; } } 
function get Ms Timestamp ( ) { var ts = new Date ( ) . get Time ( ) ; if ( last Ms Ts > = ts ) { last Ms Ts + + ; } else { last Ms Ts = ts ; } return last Ms Ts ; } 
function parse Url ( url ) { var server Options = { host : "localhost " , port : 8 0 } ; if ( url . index Of ( "https " ) = = = 0 ) { server Options . port = 4 4 3 ; } var host = url . split ( " : / / " ) . pop ( ) ; server Options . host = host ; var last Pos = host . index Of ( " : " ) ; if ( last Pos > - 1 ) { server Options . host = host . slice ( 0 , last Pos ) ; server Options . port = Number ( host . slice ( last Pos + 1 , host . length ) ) ; } return server Options ; } 
function prepare Params ( params ) { var str = [ ] ; for ( var i in params ) { str . push ( i + " = " + encode URIComponent ( params [ i ] ) ) ; } return str . join ( " & " ) ; } 
function strip Trailing Slash ( str ) { if ( str . substr ( str . length - 1 ) = = = " / " ) { return str . substr ( 0 , str . length - 1 ) ; } return str ; } 
function get Properties ( orig , props ) { var ob = { } ; var prop ; for ( var i = 0 ; i < props . length ; i + + ) { prop = props [ i ] ; if ( typeof orig [ prop ] ! = = "undefined " ) { ob [ prop ] = orig [ prop ] ; } } return ob ; } 
function add _cly _events ( event ) { if ( ! event . key ) { log ( "Event must have key property " ) ; return ; } if ( cluster . is Master ) { if ( ! event . count ) { event . count = 1 ; } var props = [ "key " , "count " , "sum " , "dur " , "segmentation " ] ; var e = get Properties ( event , props ) ; e . timestamp = get Ms Timestamp ( ) ; var date = new Date ( ) ; e . hour = date . get Hours ( ) ; e . dow = date . get Day ( ) ; log ( "Adding event : " , event ) ; event Queue . push ( e ) ; store Set ( "cly _event " , event Queue ) ; } else { process . send ( { cly : { event : event } } ) ; } } 
function report View Duration ( ) { if ( last View ) { if ( ! platform ) { get Metrics ( ) ; } var segments = { "name " : last View , "segment " : platform } ; 
function prepare Request ( request ) { request . app _key = Countly . app _key ; request . device _id = Countly . device _id ; request . sdk _name = SDK _NAME ; request . sdk _version = SDK _VERSION ; if ( Countly . check _consent ( "location " ) ) { if ( Countly . country _code ) { request . country _code = Countly . country _code ; } if ( Countly . city ) { request . city = Countly . city ; } if ( Countly . ip _address ! = = null ) { request . ip _address = Countly . ip _address ; } } else { request . location = " " ; } request . timestamp = get Ms Timestamp ( ) ; var date = new Date ( ) ; request . hour = date . get Hours ( ) ; request . dow = date . get Day ( ) ; } 
function to Request Queue ( request ) { if ( cluster . is Master ) { if ( ! Countly . app _key | | ! Countly . device _id ) { log ( "app _key or device _id is missing " ) ; return ; } prepare Request ( request ) ; if ( request Queue . length > queue Size ) { request Queue . shift ( ) ; } request Queue . push ( request ) ; store Set ( "cly _queue " , request Queue ) ; } else { process . send ( { cly : { cly _queue : request } } ) ; } } 
function heart Beat ( ) { 
function get Metrics ( ) { var m = JSON . parse ( JSON . stringify ( metrics ) ) ; 
function make Request ( url , path , params , callback ) { try { log ( "Sending HTTP request " ) ; var server Options = parse Url ( url ) ; var data = prepare Params ( params ) ; var method = "GET " ; var options = { host : server Options . host , port : server Options . port , path : path + " ? " + data , method : "GET " } ; if ( data . length > = 2 0 0 0 ) { method = "POST " ; } else if ( Countly . force _post ) { method = "POST " ; } if ( method = = = "POST " ) { options . method = "POST " ; options . path = path ; options . headers = { "Content -Type " : "application /x -www -form -urlencoded " , "Content -Length " : Buffer . byte Length ( data ) } ; } var protocol = http ; if ( url . index Of ( "https " ) = = = 0 ) { protocol = https ; } var req = protocol . request ( options , function ( res ) { var str = " " ; res . on ( "data " , function ( chunk ) { str + = chunk ; } ) ; res . on ( "end " , function ( ) { if ( res . status Code > = 2 0 0 & & res . status Code < 3 0 0 ) { callback ( false , params , str ) ; } else { callback ( true , params ) ; } } ) ; } ) ; if ( method = = = "POST " ) { 
function all Settled ( promises ) { "use strict " ; const wrapped Promises = promises . map ( ( cur Promise ) = > cur Promise . reflect ( ) ) ; return Promise . all ( wrapped Promises ) ; } 
function first Word ( parent , index ) { var siblings = parent . children while ( index - - ) { if ( is ( 'Word Node ' , siblings [ index ] ) ) { return false } } return true } 
function after ( parent , index ) { var siblings = parent . children var sibling = siblings [ + + index ] var other if ( is ( 'White Space Node ' , sibling ) ) { sibling = siblings [ + + index ] if ( is ( 'Punctuation Node ' , sibling ) & & punctuation . test ( to String ( sibling ) ) ) { sibling = siblings [ + + index ] } if ( is ( 'Word Node ' , sibling ) ) { other = sibling } } return other } 
function classify ( value ) { var type = null var normal value = value . replace ( digits , to Words ) . split ( split , 1 ) [ 0 ] normal = lower ( value ) if ( requires A ( value ) ) { type = 'a ' } if ( requires An ( value ) ) { type = type = = = 'a ' ? 'a -or -an ' : 'an ' } if ( ! type & & normal = = = value ) { type = vowel . test ( normal . char At ( 0 ) ) ? 'an ' : 'a ' } return type } 
function factory ( list ) { var expressions = [ ] var sensitive = [ ] var insensitive = [ ] construct ( ) return test function construct ( ) { var length = list . length var index = - 1 var value var normal while ( + + index < length ) { value = list [ index ] normal = value = = = lower ( value ) if ( value . char At ( value . length - 1 ) = = = ' * ' ) { 
function ( dbctrl , forcerebind ) { var octrls = forcerebind ? [ ] : cchistory ; var nctrls = [ ] ; var db Meta = cdb . jb . get DBMeta ( ) ; if ( db Meta & & db Meta . collections ) { for ( var j = 0 ; j < db Meta . collections . length ; + + j ) { var collection = db Meta . collections [ j ] ; var ci ; if ( ( ci = octrls . index Of ( collection . name ) ) ! = - 1 ) { nctrls . push ( collection . name ) ; octrls . splice ( ci , 1 ) ; } else if ( ! dbctrl [ collection . name ] ) { nctrls . push ( collection . name ) ; dbctrl [ collection . name ] = colctl ( dbctrl , collection . name ) ; } } } for ( var i = 0 ; i < octrls . length ; + + i ) { delete dbctrl [ octrls [ i ] ] ; } 
function ( db , cname ) { 
function ( args ) { var result = [ cname ] ; 
function ( db , mname , frc ) { return function ( ) { var cname = arguments [ 0 ] ; var args = [ cname ] ; 
function ( rcb ) { return function ( ) { if ( frc | | ! db [ cname ] ) { bind Col Ctls ( db ) ; } if ( rcb ) { rcb . apply ( this , arguments ) ; } } } 
function ( ) { Object . define Property ( this , " _impl " , { value : new EJDBImpl ( ) , configurable : false , enumerable : false , writable : false } ) ; return this ; } 
function parse Query Args ( args ) { var cname , qobj , orarr , hints , cb ; var i = 0 ; cname = args [ i + + ] ; if ( typeof cname ! = = "string " ) { throw new Error ( "Collection name 'cname ' argument must be specified " ) ; } var next = args [ i + + ] ; if ( typeof next = = = "function " ) { cb = next ; } else { qobj = next ; } next = args [ i + + ] ; if ( next ! = = undefined ) { if ( Array . is Array ( next ) ) { orarr = next ; next = args [ i + + ] ; } else if ( typeof next = = = "object " ) { hints = next ; orarr = null ; next = args [ i + + ] ; } if ( ! hints & & typeof next = = = "object " ) { hints = next ; next = args [ i + + ] ; } if ( typeof next = = = "function " ) { cb = next ; } } return [ cname , ( qobj | | { } ) , ( orarr | | [ ] ) , ( hints | | { } ) , ( cb | | null ) ] ; } 
function dummy Text ( opts ) { var corpus = opts . corpus | | 'lorem ' , i = opts . start , is Random = typeof ( i ) = = = 'undefined ' , must Reset = typeof ( origin ) = = = 'undefined ' , skip = opts . skip | | 1 , sentences = opts . sentences | | 1 , words = opts . words , text = texts [ corpus ] | | texts . lorem , len = text . length , output = [ ] , s ; if ( is Random ) { i = Math . floor ( Math . random ( ) * len ) ; } if ( must Reset ) { origin = i ; } if ( is Random ) { 
function Back ( options ) { if ( ! ( this instanceof Back ) ) { return new Back ( options ) ; } this . settings = extend ( options ) ; this . reconnect = null ; } 
function ( base Map ) { Construct . setup . apply ( this , arguments ) ; this .List = Map .List .extend ( { Map : this } , { } ) ; } * / } 
function ( obj ) { if ( can Reflect . is Observable Like ( obj ) & & typeof obj . serialize = = = "function " ) { obj = obj . serialize ( ) ; } 
function ( ) { this . _computed Attrs = Object . create ( null ) ; var computes = this . constructor . _computed Property Names ; for ( var i = 0 , len = computes . length ; i < len ; i + + ) { var attr Name = computes [ i ] ; map Helpers . add Computed Attr ( this , attr Name , this [ attr Name ] ) ; } } 
function ( attr , val ) { var type = typeof attr ; if ( attr = = = undefined ) { return this . _get Attrs ( ) ; } else if ( type ! = = "string " & & type ! = = "number " ) { 
function ( attr ) { attr = attr + " " ; var dot Index = attr . index Of ( ' . ' ) ; if ( dot Index > = 0 ) { 
function ( attr ) { if ( ! unobservable [ attr ] & & ! this . _computed Attrs [ attr ] ) { Observation Recorder . add ( this , attr ) ; } return this . _ _ _get ( attr ) ; } 
function ( attr ) { if ( attr ! = = undefined ) { var computed Attr = this . _computed Attrs [ attr ] ; if ( computed Attr ) { 
function ( attr , value , keep Key ) { attr = attr + " " ; var dot Index = attr . index Of ( ' . ' ) , current ; if ( dot Index > = 0 & & ! keep Key ) { var first = attr . substr ( 0 , dot Index ) , second = attr . substr ( dot Index + 1 ) ; current = this [ in Setup Symbol ] ? undefined : this . _ _ _get ( first ) ; if ( can Reflect . is Map Like ( current ) ) { can Reflect . set Key Value ( current , second , value ) ; } else { current = this [ in Setup Symbol ] ? undefined : this . _ _ _get ( attr ) ; 
function ( value , prop ) { if ( typeof value = = = "object " & & ! can Reflect . is Observable Like ( value ) & & map Helpers . can Make Observe ( value ) & & ! can Reflect . is List Like ( value ) ) { var cached = map Helpers . get Map From Object ( value ) ; if ( cached ) { return cached ; } var Map Constructor = this . constructor . Map | | Map ; return new Map Constructor ( value ) ; } return value ; } 
function ( prop , value , current ) { if ( value ! = = current | | ! Object . prototype . has Own Property . call ( this . _data , prop ) ) { var computed Attr = this . _computed Attrs [ prop ] ; 
function ( prop , val ) { var computed Attr = this . _computed Attrs [ prop ] ; if ( computed Attr ) { can Reflect . set Value ( computed Attr . compute , val ) ; } else { this . _data [ prop ] = val ; } 
function ( attr ) { 
function ( prop , current ) { if ( prop in this . _data ) { this . _ _ _remove ( prop ) ; 
function ( name , val ) { if ( this . _legacy Attr Behavior ) { return map Helpers . get Value ( this , name , val , "serialize " ) ; } else { return can Reflect . serialize ( val , CIDMap ) ; } } 
function ( props , remove ) { if ( this . _legacy Attr Behavior ) { return this . _ _set Attrs ( props , remove ) ; } if ( remove = = = true | | remove = = = "true " ) { this [ can Symbol . for ( "can .update Deep " ) ] ( props ) ; } else { this [ can Symbol . for ( "can .assign Deep " ) ] ( props ) ; } return this ; } 
function ( attr , how , new Val , old Val , batch Num ) { can Queues . batch . start ( ) ; if ( bubble . is Bubbling ( this , "change " ) ) { can Event . dispatch . call ( this , { type : "change " , target : this , batch Num : batch Num } , [ attr , how , new Val , old Val ] ) ; } can Event . dispatch . call ( this , { type : attr , target : this , batch Num : batch Num , patches : [ { type : "set " , key : attr , value : new Val } ] } , [ new Val , old Val ] ) ; if ( how = = = "remove " | | how = = = "add " ) { can Event . dispatch . call ( this , { type : " _ _keys " , target : this , batch Num : batch Num } ) ; } can Queues . batch . stop ( ) ; } 
function ( prop ) { if ( typeof this . constructor . prototype [ prop ] = = = "function " ) { return can Compute ( this [ prop ] , this ) ; } else { var reads = Observe Reader . reads ( prop ) ; var last = reads . length - 1 ; return can Compute ( function ( new Val ) { if ( arguments . length ) { Observe Reader . write ( this , reads [ last ] . key , new Val , { } ) ; } else { return Observe Reader . get ( this , prop ) ; } } , this ) ; } } 
function ( callback , context ) { var key , item ; var keys = can Reflect . get Own Enumerable Keys ( this ) ; for ( var i = 0 , len = keys . length ; i < len ; i + + ) { key = keys [ i ] ; item = this . attr ( key ) ; if ( callback . call ( context | | item , item , key , this ) = = = false ) { break ; } } return this ; } 
function ( callback ) { var data = this . _ _ _get ( ) ; for ( var prop in data ) { if ( has Own Property . call ( data , prop ) ) { callback ( data [ prop ] , prop ) ; } } } 
function ( ) { if ( ! this [ in Setup Symbol ] ) { Observation Recorder . add ( this , ' _ _keys ' ) ; } var enumerable = this . constructor . enumerable ; if ( enumerable ) { return Object . keys ( this . _data ) . filter ( function ( key ) { return enumerable [ key ] ! = = false ; } , this ) ; } else { return Object . keys ( this . _data ) ; } } 
function ( source ) { can Queues . batch . start ( ) ; 
function ( key , handler , queue ) { var translation Handler = function ( ev , new Value , old Value ) { handler . call ( this , new Value , old Value ) ; } ; single Reference . set ( handler , this , translation Handler , key ) ; this . add Event Listener ( key , translation Handler , queue ) ; } 
function v 1 ( options , buf , offset ) { var i = buf & & offset | | 0 ; var b = buf | | [ ] ; options = options | | { } ; var clockseq = options . clockseq ! = = undefined ? options . clockseq : _clockseq ; 
function css ( files , output , options ) { options = Object . assign ( { banner : false } , options ) ; return ( ) = > { var build = gulp . src ( files ) if ( options . banner ) build = build . pipe ( $ . header ( banner , { pkg } ) ) ; build = build . pipe ( $ . rename ( 'd 3 .compose .css ' ) ) . pipe ( gulp . dest ( output ) ) ; return build ; } ; } 
function series ( ) { const tasks = Array . prototype . slice . call ( arguments ) ; var fn = cb = > cb ( ) ; if ( typeof tasks [ tasks . length - 1 ] = = = 'function ' ) fn = tasks . pop ( ) ; return ( cb ) = > { const tasks _with _cb = tasks . concat ( [ ( err ) = > { if ( err ) return cb ( err ) ; fn ( cb ) ; } ] ) ; run Sequence . apply ( this , tasks _with _cb ) ; } } 
function to Surround ( description ) { if ( ! Array . is Array ( description ) ) { description = [ layered ( description ) ] ; } var positions = extract Surround Positions ( description ) ; var top = positions . top ; var right = positions . right ; var bottom = positions . bottom ; var left = positions . left ; var middle = positions . middle ; var container = { _id : ' _container ' } ; var top Edge = top [ top . length - 1 ] & & constraint . eq ( top [ top . length - 1 ] , 'bottom ' ) | | 0 ; var right Edge = right [ 0 ] & & constraint . eq ( right [ 0 ] , 'left ' ) | | constraint . eq ( container , 'right ' ) ; var bottom Edge = bottom [ 0 ] & & constraint . eq ( bottom [ 0 ] , 'top ' ) | | constraint . eq ( container , 'bottom ' ) ; var left Edge = left [ left . length - 1 ] & & constraint . eq ( left [ left . length - 1 ] , 'right ' ) | | 0 ; top = top . map ( function ( item , i , items ) { var layout = { _position : 'top ' , top : items [ i - 1 ] & & constraint . eq ( items [ i - 1 ] , 'bottom ' ) | | 0 , left : left Edge , right : right Edge , width : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; right = right . map ( function ( item , i , items ) { var layout = { _position : 'right ' , right : items [ i + 1 ] & & constraint . eq ( items [ i + 1 ] , 'left ' ) | | constraint . eq ( container , 'right ' ) , top : top Edge , bottom : bottom Edge , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; bottom = bottom . map ( function ( item , i , items ) { var layout = { _position : 'bottom ' , bottom : items [ i + 1 ] & & constraint . eq ( items [ i + 1 ] , 'top ' ) | | constraint . eq ( container , 'bottom ' ) , left : left Edge , right : right Edge , width : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; left = left . map ( function ( item , i , items ) { var layout = { _position : 'left ' , left : items [ i - 1 ] & & constraint . eq ( items [ i - 1 ] , 'right ' ) | | 0 , top : top Edge , bottom : bottom Edge , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; middle = middle . map ( function ( item ) { var layout = { _position : 'middle ' , top : top Edge , right : right Edge , bottom : bottom Edge , left : left Edge , width : constraint . flex ( ) , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; var all Items = top . concat ( left ) . concat ( middle ) . concat ( right ) . concat ( bottom ) ; var by Id = { } ; var ordered = [ ] ; all Items . for Each ( function ( item ) { by Id [ item . _id ] = item ; ordered . push ( item . _id ) ; } ) ; return { by Id : by Id , ordered : ordered } ; } 
function synctos ( doc , old Doc ) { 
function simple Type Filter ( doc , old Doc , candidate Doc Type ) { if ( old Doc ) { if ( doc . _deleted ) { return old Doc . type = = = candidate Doc Type ; } else { return doc . type = = = old Doc . type & & old Doc . type = = = candidate Doc Type ; } } else { return doc . type = = = candidate Doc Type ; } } 
function pad Right ( value , desired Length , padding ) { while ( value . length < desired Length ) { value + = padding ; } return value ; } 
function resolve Collection Items ( original Items , item Prefix ) { if ( utils . is Value Null Or Undefined ( original Items ) ) { return [ ] ; } else if ( Array . is Array ( original Items ) ) { var result Items = [ ] ; for ( var i = 0 ; i < original Items . length ; i + + ) { var item = original Items [ i ] ; if ( utils . is Value Null Or Undefined ( item ) ) { continue ; } result Items . push ( prefix Item ( item , item Prefix ) ) ; } return result Items ; } else { 
function resolve Collection Definition ( doc , old Doc , collection Definition , item Prefix ) { if ( utils . is Value Null Or Undefined ( collection Definition ) ) { return [ ] ; } else { if ( typeof collection Definition = = = 'function ' ) { var fn Results = collection Definition ( doc , old Doc ) ; return resolve Collection Items ( fn Results , item Prefix ) ; } else { return resolve Collection Items ( collection Definition , item Prefix ) ; } } } 
function assign Channels To Users And Roles ( doc , old Doc , access Assignment Definition ) { var users And Roles = [ ] ; var users = resolve Collection Definition ( doc , old Doc , access Assignment Definition . users ) ; for ( var user Index = 0 ; user Index < users . length ; user Index + + ) { users And Roles . push ( users [ user Index ] ) ; } var roles = resolve Role Collection Definition ( doc , old Doc , access Assignment Definition . roles ) ; for ( var role Index = 0 ; role Index < roles . length ; role Index + + ) { users And Roles . push ( roles [ role Index ] ) ; } var channels = resolve Collection Definition ( doc , old Doc , access Assignment Definition . channels ) ; access ( users And Roles , channels ) ; return { type : 'channel ' , users And Roles : users And Roles , channels : channels } ; } 
function assign Roles To Users ( doc , old Doc , access Assignment Definition ) { var users = resolve Collection Definition ( doc , old Doc , access Assignment Definition . users ) ; var roles = resolve Role Collection Definition ( doc , old Doc , access Assignment Definition . roles ) ; role ( users , roles ) ; return { type : 'role ' , users : users , roles : roles } ; } 
function assign User Access ( doc , old Doc , document Definition ) { var effective Old Doc = utils . resolve Old Doc ( ) ; var access Assignment Definitions = resolve Access Assignments Definition ( doc , effective Old Doc , document Definition . access Assignments ) ; var effective Assignments = [ ] ; for ( var assignment Index = 0 ; assignment Index < access Assignment Definitions . length ; assignment Index + + ) { var definition = access Assignment Definitions [ assignment Index ] ; if ( definition . type = = = 'role ' ) { effective Assignments . push ( assign Roles To Users ( doc , effective Old Doc , definition ) ) ; } else if ( definition . type = = = 'channel ' | | utils . is Value Null Or Undefined ( definition . type ) ) { effective Assignments . push ( assign Channels To Users And Roles ( doc , effective Old Doc , definition ) ) ; } } return effective Assignments ; } 
function append To Authorization List ( all Authorizations , authorizations To Add ) { if ( ! utils . is Value Null Or Undefined ( authorizations To Add ) ) { if ( Array . is Array ( authorizations To Add ) ) { for ( var i = 0 ; i < authorizations To Add . length ; i + + ) { var authorization = authorizations To Add [ i ] ; if ( all Authorizations . index Of ( authorization ) < 0 ) { all Authorizations . push ( authorization ) ; } } } else if ( all Authorizations . index Of ( authorizations To Add ) < 0 ) { all Authorizations . push ( authorizations To Add ) ; } } } 
function get All Doc Channels ( doc Definition ) { var doc Channel Map = utils . resolve Document Constraint ( doc Definition . channels ) ; var all Channels = [ ] ; if ( doc Channel Map ) { append To Authorization List ( all Channels , doc Channel Map . view ) ; append To Authorization List ( all Channels , doc Channel Map . write ) ; append To Authorization List ( all Channels , doc Channel Map . add ) ; append To Authorization List ( all Channels , doc Channel Map . replace ) ; append To Authorization List ( all Channels , doc Channel Map . remove ) ; } return all Channels ; } 
function get Required Authorizations ( doc , old Doc , authorization Definition ) { var authorization Map = utils . resolve Document Constraint ( authorization Definition ) ; if ( utils . is Value Null Or Undefined ( authorization Map ) ) { 
function authorize ( doc , old Doc , doc Definition ) { var authorized Channels = get Required Authorizations ( doc , old Doc , doc Definition . channels ) ; var authorized Roles = get Required Authorizations ( doc , old Doc , doc Definition . authorized Roles ) ; var authorized Users = get Required Authorizations ( doc , old Doc , doc Definition . authorized Users ) ; var channel Match = false ; if ( authorized Channels ) { try { require Access ( authorized Channels ) ; channel Match = true ; } catch ( ex ) { 
function output Help If Necessary ( cmd , options ) { options = options | | [ ] ; for ( var i = 0 ; i < options . length ; i + + ) { if ( options [ i ] = = = ' - -help ' | | options [ i ] = = = ' -h ' ) { cmd . output Help ( ) ; process . exit ( 0 ) ; } } } 
function human Readable Arg Name ( arg ) { var name Output = arg . name + ( arg . variadic = = = true ? ' . . . ' : ' ' ) ; return arg . required ? ' < ' + name Output + ' > ' : ' [ ' + name Output + ' ] ' ; } 
function validate Object Properties ( property Validators , allow Unknown Properties , ignore Internal Properties ) { var current Item Entry = item Stack [ item Stack . length - 1 ] ; var object Value = current Item Entry . item Value ; var old Object Value = current Item Entry . old Item Value ; var supported Properties = [ ] ; for ( var property Validator Name in property Validators ) { var validator = property Validators [ property Validator Name ] ; if ( utils . is Value Null Or Undefined ( validator ) | | utils . is Value Null Or Undefined ( resolve Item Constraint ( validator . type ) ) ) { 
function build Item Path ( item Stack ) { var name Components = [ ] ; for ( var i = 0 ; i < item Stack . length ; i + + ) { var item Name = item Stack [ i ] . item Name ; if ( ! item Name ) { 
function type Specific Constraint Schemas ( ) { return { any : { } , string : { must Not Be Empty : dynamic Constraint Schema ( joi . boolean ( ) ) , must Be Trimmed : dynamic Constraint Schema ( joi . boolean ( ) ) , regex Pattern : dynamic Constraint Schema ( regex Schema ) , minimum Length : dynamic Constraint Schema ( integer Schema . min ( 0 ) ) , maximum Length : maximum Size Constraint Schema ( 'minimum Length ' ) , minimum Value : dynamic Constraint Schema ( joi . string ( ) ) , minimum Value Exclusive : dynamic Constraint Schema ( joi . string ( ) ) , maximum Value : dynamic Constraint Schema ( joi . string ( ) ) , maximum Value Exclusive : dynamic Constraint Schema ( joi . string ( ) ) , must Equal Ignore Case : dynamic Constraint Schema ( joi . string ( ) ) } , integer : { minimum Value : dynamic Constraint Schema ( integer Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( integer Schema ) , maximum Value : maximum Value Inclusive Number Constraint Schema ( integer Schema ) , maximum Value Exclusive : maximum Value Exclusive Number Constraint Schema ( integer Schema ) } , float : { minimum Value : dynamic Constraint Schema ( joi . number ( ) ) , minimum Value Exclusive : dynamic Constraint Schema ( joi . number ( ) ) , maximum Value : maximum Value Inclusive Number Constraint Schema ( joi . number ( ) ) , maximum Value Exclusive : maximum Value Exclusive Number Constraint Schema ( joi . number ( ) ) } , boolean : { } , datetime : { minimum Value : dynamic Constraint Schema ( datetime Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( datetime Schema ) , maximum Value : dynamic Constraint Schema ( datetime Schema ) , maximum Value Exclusive : dynamic Constraint Schema ( datetime Schema ) } , date : { minimum Value : dynamic Constraint Schema ( date Only Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( date Only Schema ) , maximum Value : dynamic Constraint Schema ( date Only Schema ) , maximum Value Exclusive : dynamic Constraint Schema ( date Only Schema ) } , time : { minimum Value : dynamic Constraint Schema ( time Only Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( time Only Schema ) , maximum Value : dynamic Constraint Schema ( time Only Schema ) , maximum Value Exclusive : dynamic Constraint Schema ( time Only Schema ) } , timezone : { minimum Value : dynamic Constraint Schema ( timezone Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( timezone Schema ) , maximum Value : dynamic Constraint Schema ( timezone Schema ) , maximum Value Exclusive : dynamic Constraint Schema ( timezone Schema ) } , enum : { predefined Values : dynamic Constraint Schema ( joi . array ( ) . required ( ) . min ( 1 ) . items ( [ integer Schema , joi . string ( ) ] ) ) } , uuid : { minimum Value : dynamic Constraint Schema ( uuid Schema ) , minimum Value Exclusive : dynamic Constraint Schema ( uuid Schema ) , maximum Value : dynamic Constraint Schema ( uuid Schema ) , maximum Value Exclusive : dynamic Constraint Schema ( uuid Schema ) } , attachment Reference : { maximum Size : dynamic Constraint Schema ( integer Schema . min ( 1 ) . max ( 2 0 9 7 1 5 2 0 ) ) , supported Extensions : dynamic Constraint Schema ( joi . array ( ) . min ( 1 ) . items ( joi . string ( ) ) ) , supported Content Types : dynamic Constraint Schema ( joi . array ( ) . min ( 1 ) . items ( joi . string ( ) . min ( 1 ) ) ) , regex Pattern : dynamic Constraint Schema ( regex Schema ) } , array : { must Not Be Empty : dynamic Constraint Schema ( joi . boolean ( ) ) , minimum Length : dynamic Constraint Schema ( integer Schema . min ( 0 ) ) , maximum Length : maximum Size Constraint Schema ( 'minimum Length ' ) , array Elements Validator : dynamic Constraint Schema ( joi . lazy ( ( ) = > schema ) ) } , object : { allow Unknown Properties : dynamic Constraint Schema ( joi . boolean ( ) ) , property Validators : dynamic Constraint Schema ( joi . object ( ) . min ( 1 ) . pattern ( / ^ . + $ / , joi . lazy ( ( ) = > schema ) ) ) } , hashtable : { minimum Size : dynamic Constraint Schema ( integer Schema . min ( 0 ) ) , maximum Size : maximum Size Constraint Schema ( 'minimum Size ' ) , hashtable Keys Validator : dynamic Constraint Schema ( joi . object ( ) . keys ( { must Not Be Empty : dynamic Constraint Schema ( joi . boolean ( ) ) , regex Pattern : dynamic Constraint Schema ( regex Schema ) } ) ) , hashtable Values Validator : dynamic Constraint Schema ( joi . lazy ( ( ) = > schema ) ) } , conditional : { validation Candidates : dynamic Constraint Schema ( conditional Validation Candidates Schema ( ) ) . required ( ) } } ; } 
function validate Business Id Property ( doc , old Doc , current Item Entry , validation Item Stack ) { var parent Object Element = validation Item Stack [ validation Item Stack . length - 1 ] ; var business Id = current Item Entry . item Value ; var old Business Id = current Item Entry . old Item Value ; var validation Errors = [ ] ; if ( parent Object Element . old Item Value & & old Business Id ! = = business Id ) { validation Errors . push ( 'cannot change "business Id " property ' ) ; } return validation Errors ; } 
function get Business Id ( doc , old Doc ) { var regex = / ^biz \ . ( [A -Za -z 0 - 9 _ - ] + ) ( ? : \ . . + ) ? $ / ; var match Groups = regex . exec ( doc . _id ) ; if ( match Groups ) { return match Groups [ 1 ] ; } else if ( old Doc & & old Doc . business Id ) { 
function to Default Sync Channels ( doc , old Doc , base Privilege Name ) { var business Id = get Business Id ( doc , old Doc ) ; return function ( doc , old Doc ) { return { view : [ to Sync Channel ( business Id , 'VIEW _ ' + base Privilege Name ) ] , add : [ to Sync Channel ( business Id , 'ADD _ ' + base Privilege Name ) ] , replace : [ to Sync Channel ( business Id , 'CHANGE _ ' + base Privilege Name ) ] , remove : [ to Sync Channel ( business Id , 'REMOVE _ ' + base Privilege Name ) ] } ; } ; } 
function is Iso 8 6 0 1Date Time String ( value ) { var date And Time Pieces = split Date And Time ( value ) ; var date = extract Date Structure From Date And Time ( date And Time Pieces ) ; if ( date ) { var time And Timezone = extract Time Structures From Date And Time ( date And Time Pieces ) ; var time = time And Timezone . time ; var timezone = time And Timezone . timezone ; return is Valid Date Structure ( date ) & & is Valid Time Structure ( time ) & & ( timezone = = = null | | is Valid Time Zone Structure ( timezone ) ) ; } else { return false ; } } 
function normalize Iso 8 6 0 1Time ( time , timezone Offset Minutes ) { var ms Per Second = 1 0 0 0 ; var ms Per Minute = 6 0 0 0 0 ; var ms Per Hour = 3 6 0 0 0 0 0 ; var effective Timezone Offset = timezone Offset Minutes | | 0 ; var raw Time Ms = ( time . hour * ms Per Hour ) + ( time . minute * ms Per Minute ) + ( time . second * ms Per Second ) + time . millisecond ; return raw Time Ms - ( effective Timezone Offset * ms Per Minute ) ; } 
function compare Times ( a , b ) { if ( typeof a ! = = 'string ' | | typeof b ! = = 'string ' ) { return Na N ; } return normalize Iso 8 6 0 1Time ( parse Iso 8 6 0 1Time ( a ) ) - normalize Iso 8 6 0 1Time ( parse Iso 8 6 0 1Time ( b ) ) ; } 
function compare Dates ( a , b ) { var a Pieces = extract Date Pieces ( a ) ; var b Pieces = extract Date Pieces ( b ) ; if ( a Pieces = = = null | | b Pieces = = = null ) { return Na N ; } for ( var piece Index = 0 ; piece Index < a Pieces . length ; piece Index + + ) { if ( a Pieces [ piece Index ] < b Pieces [ piece Index ] ) { return - 1 ; } else if ( a Pieces [ piece Index ] > b Pieces [ piece Index ] ) { return 1 ; } } 
function normalize Iso 8 6 0 1Time Zone ( value ) { return value ? value . multiplication Factor * ( ( value . hour * 6 0 ) + value . minute ) : - ( new Date ( ) . get Timezone Offset ( ) ) ; } 
async function initiate ( ) { log . i ( ' - -Nexus /Initiate ' ) ; let Setup = { } ; let Start = { } ; cache Interface = new Cache Interface ( { path : _ _options . cache , log } ) ; let cache = await cache Interface . load Cache ( ) ; Start = cache . start ; Setup = cache . setup ; Stop = Object . assign ( Stop , cache . stop ) ; await setup ( ) ; await start ( ) ; run ( ) ; * Call setup on the required Module Apexes * / async function setup ( ) { log . i ( ' - -Nexus /Setup ' ) ; * Call Start on the required Module Apexes * / async function start ( ) { log . i ( ' - -Nexus /Start ' ) ; * Send Finished command if the process was generated * / function run ( ) { log . i ( ' - -Nexus /Run ' ) ; if ( 'send ' in process ) { process . send ( ' { "Cmd " : "Finished " } ' ) ; } } } 
async function setup ( ) { log . i ( ' - -Nexus /Setup ' ) ; 
async function start ( ) { log . i ( ' - -Nexus /Start ' ) ; 
async function exit ( code = 0 ) { log . i ( ' - -Nexus /Stop ' ) ; 
function send Message ( com , fun = _ = > _ ) { if ( ! ( 'Passport ' in com ) ) { log . w ( 'Message has no Passport , ignored ' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No Passport ' ) ; return ; } if ( ! ( 'To ' in com . Passport ) | | ! com . Passport . To ) { log . w ( 'Message has no destination entity , ignored ' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No recipient in message ' , com ) ; return ; } if ( ! ( 'Pid ' in com . Passport ) ) { log . w ( 'Message has no message id , ignored ' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No message id ' , com ) ; return ; } let pid = com . Passport . To ; let apx = com . Passport . Apex | | pid ; if ( pid in Ent Cache ) { done ( null , Ent Cache [ pid ] ) ; return ; } else { get Entity Context ( pid , done ) ; } async function done ( err , ent Context Volatile ) { let ent Apex = await new Promise ( res = > ent Context Volatile . lock ( ( val ) = > { res ( val . Apex ) ; return val ; } ) ) ; if ( err ) { log . w ( err ) ; log . w ( JSON . stringify ( com , null , 2 ) ) ; fun ( err , com ) ; return ; } 
async function gen Entity ( par , fun = _ = > log . e ( _ ) ) { if ( ! ( 'Entity ' in par ) ) { fun ( 'No Entity defined in Par ' ) ; return ; } par . Pid = par . Pid | | gen Pid ( ) ; let impkey = ( par . Module + ' / ' + par . Entity ) ; let mod = Mod Cache [ par . Module ] ; if ( ! ( par . Entity in mod . files ) ) { log . e ( ' < ' + par . Entity + ' > not in module < ' + par . Module + ' > ' ) ; fun ( 'Null entity ' ) ; return ; } if ( ! ( impkey in Imp Cache ) ) { let ent String = await new Promise ( async ( res , _rej ) = > { mod . file ( par . Entity ) . async ( 'string ' ) . then ( ( string ) = > res ( string ) ) ; } ) ; Imp Cache [ impkey ] = indirect Eval Imp ( impkey , ent String , log , create Require From Module Type ( par . Module ) ) ; } Ent Cache [ par . Pid ] = new Volatile ( new Entity ( Nxs , Imp Cache [ impkey ] , par , log ) ) ; fun ( null , par . Pid ) ; } 
function delete Entity ( pid , fun = ( err , _pid ) = > { if ( err ) log . e ( err ) ; } ) { cache Interface . delete Entity ( pid , ( err , removed Pid Array ) = > { 
async function save Entity ( par , fun = ( err , _pid ) = > { if ( err ) log . e ( err ) ; } ) { let save Entity = ( async ( par ) = > { await new Promise ( ( res , rej ) = > { cache Interface . save Entity Par ( par , ( err , pid ) = > { if ( err ) { log . e ( err , 'saving ' , pid ) ; rej ( err ) ; } log . v ( ` $ { par . Pid } ` ) ; res ( ) ; } ) ; } ) ; } ) ; 
async function add Module ( mod Name , mod Zip , fun ) { 
function get File ( module , filename , fun = _ = > _ ) { let mod = Mod Cache [ module ] ; if ( filename in mod . files ) { mod . file ( filename ) . async ( 'string ' ) . then ( ( dat ) = > { fun ( null , dat ) ; } ) ; return ; } let err = ` $ { filename } $ { module } ` ; log . e ( err ) ; fun ( err ) ; } 
async function get Entity Context ( pid , fun = _ = > _ ) { Ent Cache [ pid ] = new Volatile ( { } ) ; await Ent Cache [ pid ] . lock ( ( _entity Context ) = > { return new Promise ( ( res , _rej ) = > { cache Interface . get Entity Par ( pid , ( err , data ) = > { let par = JSON . parse ( data . to String ( ) ) ; if ( err ) { log . e ( ` $ { data . module Type } $ { pid } ` ) ; log . e ( err ) ; fun ( 'Unavailable ' ) ; return ; } let impkey = par . Module + ' / ' + par . Entity ; if ( impkey in Imp Cache ) { Build Ent ( ) ; return ; } Get Module ( par . Module , async function ( err , mod ) { if ( err ) { log . e ( 'Module < ' + par . Module + ' > not available ' ) ; fun ( 'Module not available ' ) ; return ; } if ( ! ( par . Entity in mod . files ) ) { log . e ( ' < ' + par . Entity + ' > not in module < ' + par . Module + ' > ' ) ; fun ( 'Null entity ' ) ; return ; } let ent String = await new Promise ( async ( res , _rej ) = > { mod . file ( par . Entity ) . async ( 'string ' ) . then ( ( string ) = > res ( string ) ) ; } ) ; log . v ( ` $ { par . Module } $ { par . Entity . split ( ' . ' ) [ 0 ] } ` ) ; Imp Cache [ impkey ] = indirect Eval Imp ( impkey , ent String , log , create Require From Module Type ( par . Module ) ) ; Build Ent ( ) ; } ) ; function Build Ent ( ) { 
async function gen Module ( module Definition , fun = _ = > _ ) { module Definition = JSON . parse ( JSON . stringify ( module Definition ) ) ; let module Definitions = module Definition ; if ( 'Module ' in module Definition & & ( typeof module Definition . Module = = 'string ' ) ) { module Definitions = { 'Top ' : module Definition } ; } let Setup = { } ; let Start = { } ; let Promise Array = [ ] ; let symbols = { } ; * Call setup on the required Module Apexes * / async function setup ( ) { * Call Start on the required Module Apexes * / async function start ( ) { 
async function compile Instance ( pidapx , inst , save Root = false ) { log . v ( 'compile Instance ' , pidapx , JSON . stringify ( inst , null , 2 ) ) ; let Local = { } ; let modnam = ( typeof inst . Module = = 'object ' ) ? inst . Module . Module : inst . Module ; let mod ; let ents = [ ] ; modnam = modnam . replace ( / : \ / / g , ' . ' ) ; if ( modnam in Mod Cache ) { mod = Mod Cache [ modnam ] ; } else { log . e ( 'Module < ' + modnam + ' > not in Mod Cache ' ) ; process . exit ( 1 ) ; return ; } let schema = await new Promise ( async ( res , rej ) = > { if ( 'schema .json ' in mod . files ) { mod . file ( 'schema .json ' ) . async ( 'string ' ) . then ( function ( schema String ) { res ( JSON . parse ( schema String ) ) ; } ) ; } else { log . e ( 'Module < ' + modnam + ' > schema not in Mod Cache ' ) ; process . exit ( 1 ) ; rej ( ) ; return ; } } ) ; let entkeys = Object . keys ( schema ) ; 
function Get Module ( Mod Name , fun = _ = > _ ) { Mod Name = Mod Name . replace ( / : \ / / g , ' . ' ) ; if ( Mod Name in Mod Cache ) return fun ( null , Mod Cache [ Mod Name ] ) ; else cache Interface . get Module ( Mod Name , ( err , module Zip ) = > { if ( err ) return fun ( err ) ; Mod Cache [ Mod Name ] = module Zip ; return fun ( null , Mod Cache [ Mod Name ] ) ; } ) ; } 
function Strategy ( options , verify ) { var supported Api Versions = [ ' 1 ' , ' 2 ' ] , default Options By Api Version = { 1 : { authorization URL : 'https : / /www .dropbox .com / 1 /oauth 2 /authorize ' , token URL : 'https : / /api .dropbox .com / 1 /oauth 2 /token ' , scope Separator : ' , ' , custom Headers : { } } , 2 : { authorization URL : 'https : / /www .dropbox .com /oauth 2 /authorize ' , token URL : 'https : / /api .dropbox .com /oauth 2 /token ' , scope Separator : ' , ' , custom Headers : { 'Content -Type ' : 'application /json ' } } } ; options = options | | { } ; if ( options . api Version ! = null & & supported Api Versions . index Of ( options . api Version . to String ( ) ) = = = - 1 ) { throw new Error ( 'Unsupported Dropbox API version . Supported versions are " 1 " and " 2 " . ' ) ; } this . _api Version = options . api Version | | ' 1 ' ; options . authorization URL = options . authorization URL | | default Options By Api Version [ this . _api Version ] . authorization URL ; options . token URL = options . token URL | | default Options By Api Version [ this . _api Version ] . token URL ; options . scope Separator = options . scope Separator | | default Options By Api Version [ this . _api Version ] . scope Separator ; options . custom Headers = options . custom Headers | | default Options By Api Version [ this . _api Version ] . custom Headers ; OAuth 2Strategy . call ( this , options , verify ) ; this . name = 'dropbox -oauth 2 ' ; } 
async function retrieve Modules ( modules ) { modules = JSON . parse ( JSON . stringify ( modules ) ) ; const xgrls = [ ] ; for ( const module Name in modules ) { const xgrl = Config . Sources [ modules [ module Name ] . Source ] ; if ( xgrls . index Of ( xgrl ) = = = - 1 ) xgrls . push ( xgrl ) ; modules [ module Name ] . Source = xgrl } 
function process Sources ( cfg ) { if ( typeof cfg [ 'Sources ' ] = = = 'undefined ' ) { log . e ( 'You must defined a Sources object . \n ' ) ; reject Setup ( 'You must defined a Sources object . ' ) ; return ; } let val , sources , subval ; for ( let key in cfg ) { val = cfg [ key ] ; if ( key = = 'Sources ' ) { Config . Sources = { } ; sources = cfg [ 'Sources ' ] ; for ( let subkey in sources ) { subval = sources [ subkey ] ; switch ( typeof subval ) { case 'string ' : { Config . Sources [ subkey ] = Macro ( subval ) ; break ; } case 'object ' : { Config . Sources [ subkey ] = { } ; for ( let id in subval ) { Config . Sources [ subkey ] [ id . to Lower Case ( ) ] = ( typeof subval [ id ] = = 'string ' ) ? Macro ( subval [ id ] ) : subval [ id ] ; } if ( ! ( 'port ' in Config . Sources [ subkey ] ) ) { Config . Sources [ subkey ] [ 'port ' ] = 2 7 0 0 0 ; } break ; } default : { log . e ( ` $ { subkey } $ { typeof subval } ` + 'Must be of type string or object ' ) ; } } } } else { Config [ key ] = val ; } } } 
function generate Module Catalog ( ) { * Add the module to the Modules object if unique * @param {object } mod The module object * @param {string } mod .Module The name of the module * @param {object , string } mod .Source The Module broker or path reference * / function log Module ( key , mod ) { let folder = mod . Module . replace ( / [ / : ] / g , ' . ' ) ; if ( ! ( 'Source ' in mod ) ) { log . e ( ` $ { key } $ { mod . Module } ` ) ; reject Setup ( ` $ { key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source ! = source . Source | | ( Modules [ folder ] . Version ! = source . Version ) ) { log . e ( ` $ { key } \n ` + ` $ { JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n $ { JSON . stringify ( source , null , 2 ) } ` ) ; reject Setup ( 'Broker Mismatch Exception ' ) ; return ; } } } } 
function log Module ( key , mod ) { let folder = mod . Module . replace ( / [ / : ] / g , ' . ' ) ; if ( ! ( 'Source ' in mod ) ) { log . e ( ` $ { key } $ { mod . Module } ` ) ; reject Setup ( ` $ { key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source ! = source . Source | | ( Modules [ folder ] . Version ! = source . Version ) ) { log . e ( ` $ { key } \n ` + ` $ { JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n $ { JSON . stringify ( source , null , 2 ) } ` ) ; reject Setup ( 'Broker Mismatch Exception ' ) ; return ; } } } 
async function build Apex Instances ( process Pid References ) { if ( process Pid References ) { 
async function process Apex Par ( apx , inst , process Pid References ) { inst = symbol Phase 0 ( inst ) ; if ( process Pid References ) inst . Par = await symbol Phase 1 ( inst . Par ) ; inst . Par = await symbol Phase 2 ( inst . Par ) ; inst . Par = await symbol Phase 3 ( inst . Par ) ; return ; 
function symbol Phase 0 ( obj ) { for ( let key in obj ) { if ( typeof obj [ key ] = = 'string ' ) obj [ key ] = Macro ( obj [ key ] ) ; else if ( typeof obj [ key ] = = 'object ' ) obj [ key ] = symbol Phase 0 ( obj [ key ] ) ; } return obj ; } 
async function symbol Phase 1 ( val ) { if ( typeof val = = = 'object ' ) { if ( Array . is Array ( val ) ) { val = await Promise . all ( val . map ( v = > symbol Phase 1 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbol Phase 1 ( val [ key ] ) ; } } return val ; } if ( typeof val ! = = 'string ' ) return val ; let sym = val . substr ( 1 ) ; if ( val . char At ( 0 ) = = = ' $ ' ) { if ( sym in Apex ) return Apex [ sym ] ; else { log . v ( sym , Apex ) ; log . e ( ` $ { val } ` ) ; reject Setup ( ` $ { val } ` ) ; return ; } } return val ; } 
async function symbol Phase 2 ( val ) { if ( typeof val = = = 'object ' ) { if ( Array . is Array ( val ) ) { val = await Promise . all ( val . map ( v = > symbol Phase 2 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbol Phase 2 ( val [ key ] ) ; } } return val ; } if ( typeof val ! = = 'string ' | | ( ! val . starts With ( ' @ ' ) ) ) return val ; let [ directive , path ] = val . split ( ' : ' ) . map ( v = > v . to Locale Lower Case ( ) . trim ( ) ) ; if ( directive = = ' @system ' ) { let directive Timer = log . time ( val ) ; let step Timer = log . time ( 'fs ' ) ; let system Path = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( ! ( Path . is Absolute ( path ) ) ) { path = Path . join ( Path . resolve ( system Path ) , path ) ; } let temp Config ; if ( ! fs . exists Sync ( path ) ) { reject Setup ( ` $ { path } ` ) ; return ; } try { temp Config = JSON . parse ( fs . read File Sync ( path ) ) ; } catch ( e ) { reject Setup ( 'Specified configuration file is in an unparsable format . ' ) ; return ; } log . time End ( step Timer ) ; 
async function symbol Phase 3 ( val ) { if ( typeof val = = = 'object ' ) { if ( Array . is Array ( val ) ) { val = await Promise . all ( val . map ( v = > symbol Phase 3 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbol Phase 3 ( val [ key ] ) ; } } return val ; } if ( typeof val ! = = 'string ' | | ( ! val . starts With ( ' @ ' ) ) ) return val ; if ( val . char At ( 0 ) = = = ' @ ' ) { let directive = val . substr ( 0 ) ; val = val . split ( ' : ' ) ; let key = val [ 0 ] . to Locale Lower Case ( ) . trim ( ) ; let encoding = undefined ; if ( key . split ( ' , ' ) . length = = 2 ) { key = key . split ( ' , ' ) [ 0 ] . trim ( ) ; let _encoding = key . split ( ' , ' ) [ 1 ] . trim ( ) ; } val = val . slice ( 1 ) . join ( ' : ' ) . trim ( ) ; let directive Timer = log . time ( directive ) ; switch ( key ) { case ' @filename ' : case ' @file ' : { log . v ( ` $ { directive } ` ) ; let path ; try { let system Path = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( Path . is Absolute ( val ) ) path = val ; else { path = Path . join ( Path . resolve ( system Path ) , val ) ; } log . time End ( directive Timer ) ; return fs . read File Sync ( path ) . to String ( encoding ) ; } catch ( err ) { log . e ( ' @file : (compile Instance ) Error reading file ' , path ) ; log . w ( ` $ { inst . Module } ` ) ; } break ; } case ' @folder ' : case ' @directory ' : { log . v ( ` $ { directive } ` ) ; let dir ; try { let system Path = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( Path . is Absolute ( val ) ) dir = val ; else dir = Path . join ( Path . resolve ( system Path ) , val ) ; let _return = await build Dir ( dir ) ; log . time End ( directive Timer ) ; return _return ; } catch ( err ) { og . e ( 'Error reading directory ' , dir ) ; og . w ( ` $ { inst . Module } ` ) ; } break ; } default : { log . w ( ` $ { key } ` + ` $ { inst . Module } ` ) ; } } log . time End ( directive Timer ) ; } return val ; } 
async function build Dir ( path ) { let dir Obj = { } ; if ( fs . exists Sync ( path ) ) { let files = fs . readdir Sync ( path ) ; let item Promises = [ ] ; for ( let file of files ) { item Promises . push ( new Promise ( async ( resolve ) = > { let cur Path = path + ' / ' + file ; if ( fs . lstat Sync ( cur Path ) . is Directory ( ) ) { 
function gen Pid ( ) { if ( ! Uuid ) { 
function Macro ( str ) { str = str . substr ( 0 ) ; 
async function genesis ( system ) { log . i ( ' [Save Cache ] ' . pad Start ( 8 0 , ' = ' ) ) ; log . i ( 'Genesis Compile Start : ' ) ; let cache State = null ; if ( fs . exists Sync ( Cache Dir ) ) cache State = 'exists ' ; cache Interface = new Cache Interface ( { path : Cache Dir , log } ) ; clean Cache ( ) ; log . i ( 'Saving modules and updating dependencies . . . ' ) ; await cache Modules ( system . Mod Cache ) ; if ( ! ( _ _options . state = = 'update Only ' ) ) { log . i ( 'Saving entities . . . ' ) ; await cache Apexes ( system . Apex , system . Config . Modules ) ; } Stop ( ) ; * Remove the cache if it currently exists in the given directory * / function clean Cache ( ) { * Write the modules to the cache * @param {Object } Mod Cache * / async function cache Modules ( Mod Cache ) { let timer = log . time ( 'cache Modules ' ) ; let Module Promise Array = [ ] ; for ( let folder in Mod Cache ) { Module Promise Array . push ( new Promise ( async ( res ) = > { await cache Interface . add Module ( folder , Mod Cache [ folder ] ) ; log . v ( ` $ { folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( Module Promise Array ) ; log . time End ( timer ) ; } async function cache Apexes ( Apexes , Module Definitions ) { let Module Promise Array = [ ] ; for ( let module Id in Apexes ) { Module Promise Array . push ( await cache Interface . create Instance ( Module Definitions [ module Id ] , Apexes [ module Id ] ) ) ; } await Promise . all ( Module Promise Array ) ; } async function Stop ( ) { log . i ( ` $ { new Date ( ) . to String ( ) } ` ) ; log . i ( ' [Finished ] ' . pad Start ( 8 0 , ' = ' ) ) ; for ( const xgrl in Broker Cache ) { const broker = Broker Cache [ xgrl ] ; broker . cleanup ( ) ; } log . time End ( compile Timer ) ; resolve Main ( ) ; } } 
function clean Cache ( ) { 
async function cache Modules ( Mod Cache ) { let timer = log . time ( 'cache Modules ' ) ; let Module Promise Array = [ ] ; for ( let folder in Mod Cache ) { Module Promise Array . push ( new Promise ( async ( res ) = > { await cache Interface . add Module ( folder , Mod Cache [ folder ] ) ; log . v ( ` $ { folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( Module Promise Array ) ; log . time End ( timer ) ; } 
async function cache Apexes ( Apexes , Module Definitions ) { let Module Promise Array = [ ] ; for ( let module Id in Apexes ) { Module Promise Array . push ( await cache Interface . create Instance ( Module Definitions [ module Id ] , Apexes [ module Id ] ) ) ; } await Promise . all ( Module Promise Array ) ; } 
async function Stop ( ) { log . i ( ` $ { new Date ( ) . to String ( ) } ` ) ; log . i ( ' [Finished ] ' . pad Start ( 8 0 , ' = ' ) ) ; for ( const xgrl in Broker Cache ) { const broker = Broker Cache [ xgrl ] ; broker . cleanup ( ) ; } log . time End ( compile Timer ) ; resolve Main ( ) ; } 
function get Protocol Module ( protocol ) { return new Promise ( function ( resolve , reject ) { let cache Filepath = path . join ( appdata , protocol ) ; if ( fs . exists Sync ( cache Filepath ) ) { return resolve ( JSON . parse ( fs . read File Sync ( cache Filepath ) . to String ( ) ) ) ; } let options = { host : 'protocols .xgraphdev .com ' , port : 4 4 3 , path : ' / ' + protocol , method : 'GET ' , reject Unauthorized : false , } ; let req = https . request ( options , function ( res ) { res . set Encoding ( 'utf 8 ' ) ; let response = ' ' ; res . on ( 'data ' , function ( chunk ) { response + = chunk ; } ) ; res . on ( 'end ' , _ = > { try { resolve ( JSON . parse ( response ) ) ; try { fs . write File Sync ( cache Filepath , response ) ; } catch ( e ) { reject ( { code : 1 , text : ` $ { cache Filepath } ` + ' \n delete file and try again ' } ) ; } } catch ( e ) { reject ( { code : 0 , text : 'try and retrieve locally ' } ) ; } } ) ; } ) ; req . on ( 'error ' , function ( e ) { log . e ( 'problem with request : ' + e . message ) ; reject ( { code : 1 , text : 'problem with request : ' + e . message } ) ; } ) ; 
function rem Dir ( path ) { return ( new Promise ( async ( resolve , _reject ) = > { if ( fs . exists Sync ( path ) ) { let files = fs . readdir Sync ( path ) ; let promise Array = [ ] ; for ( let file Index = 0 ; file Index < files . length ; file Index + + ) { promise Array . push ( new Promise ( async ( resolve 2 , _reject 2 ) = > { let cur Path = path + ' / ' + files [ file Index ] ; if ( fs . lstat Sync ( cur Path ) . is Directory ( ) ) { 
function get Mouse Position ( e ) { var mouse Obj = void 0 , original Event = e . original Event ? e . original Event : e ; mouse Obj = 'changed Touches ' in original Event & & original Event . changed Touches ? original Event . changed Touches [ 0 ] : original Event ; 
function proxy Request ( req , res , rule ) { var router , target , path ; inject Proxy Headers ( req , rule ) ; 
function create Router ( target ) { var key = util . format ( ' %s / / %s : %s ' , target . protocol , target . host , target . port ) , router = routers [ key ] , options ; 
function inject Auth Header ( req ) { if ( use Gateway = = = true & & typeof ( config . gateway . auth ) = = = 'string ' & & req . headers [ 'authorization ' ] = = = undefined ) { req . headers [ 'authorization ' ] = 'Basic ' + new Buffer ( config . gateway . auth ) . to String ( 'base 6 4 ' ) ; } } 
function inject Proxy Headers ( req , rule ) { 
function parse File ( filepath , config ) { var contents ; filepath = filepath | | path . join ( process . cwd ( ) , ' /json -proxy .json ' ) ; 
function parse Config ( contents , config ) { contents . server = contents . server | | { } ; contents . proxy = contents . proxy | | { } ; if ( contents . proxy . gateway & & typeof ( contents . proxy . gateway ) = = = "string " & & contents . proxy . gateway . length > 0 ) { contents . proxy . gateway = parse Gateway ( contents . proxy . gateway ) ; } contents . proxy . forward = parse Config Map ( contents . proxy . forward , parse Forward Rule ) ; contents . proxy . headers = parse Config Map ( contents . proxy . headers , parse Header Rule ) ; 
function parse Config Map ( map , callback ) { var result = [ ] ; if ( ! ( map instanceof Object ) ) { return map ; } for ( var property in map ) { if ( map . has Own Property ( property ) ) { result . push ( callback ( property , map [ property ] ) ) ; } } return result ; } 
function parse Command Line ( argv , config ) { if ( argv ) { 
function parse Command Line Argument ( arg , fn ) { if ( typeof ( fn ) ! = = 'function ' ) return ; if ( Array . is Array ( arg ) ) { arg . for Each ( function ( item ) { fn . call ( null , item ) ; } ) ; } else { if ( arg ! = = null & & arg ! = = undefined ) { fn . call ( null , arg ) ; } } } 
function parse Forward Rule ( ) { var token , rule ; if ( arguments [ 0 ] = = = undefined | | arguments [ 0 ] = = = null ) { return ; } if ( typeof ( arguments [ 0 ] ) = = = "object " ) { return arguments [ 0 ] ; } try { token = tokenize . apply ( null , arguments ) ; rule = { regexp : new Reg Exp ( ' ^ ' + token . name , 'i ' ) , target : parse Target Server ( token . value ) } ; } catch ( e ) { throw new Error ( 'cannot parse the forwarding rule ' + arguments [ 0 ] + ' - ' + e ) ; } return rule ; } 
function parse Target Server ( value ) { var target , path ; 
function tokenize ( ) { var token = { name : null , value : null } , temp = null ; if ( arguments . length ! = = 1 ) { token . name = arguments [ 0 ] ; token . value = arguments [ 1 ] ; return token ; } temp = arguments [ 0 ] ; if ( undefined ! = = temp & & null ! = = temp ) { temp = temp . split ( ' = ' ) ; } if ( Array . is Array ( temp ) & & temp . length > 1 ) { token . name = temp [ 0 ] ; token . value = temp [ 1 ] ; } return token ; } 
function with Code ( code , msg ) { const err = new Error ( msg ) ; err . code = code ; return err ; } 
function update Working State ( repo State , branch , new Working State ) { let working States = repo State . get Working States ( ) ; const key = branch . get Full Name ( ) ; if ( new Working State = = = null ) { 
function fetch Tree ( repo State , driver , branch ) { 
function checkout ( repo State , branch ) { let _branch = branch ; if ( ! ( branch instanceof Branch ) ) { _branch = repo State . get Branch ( branch ) ; if ( branch = = = null ) { throw Error ( 'Unknown branch ' + branch ) ; } } if ( ! repo State . is Fetched ( _branch ) ) { throw Error ( 'Tree for branch ' + _branch . get Full Name ( ) + ' must be fetched first ' ) ; } return repo State . set ( 'current Branch Name ' , _branch . get Full Name ( ) ) ; } 
function fetch Branches ( repo State , driver ) { const old Branches = repo State . get Branches ( ) ; return driver . fetch Branches ( ) . then ( ( branches ) = > { return repo State . set ( 'branches ' , branches ) ; } ) . then ( function refresh Working States ( repo State ) { 
function initialize ( driver ) { const repo State = Repository State . create Empty ( ) ; return fetch Branches ( repo State , driver ) . then ( ( repo State ) = > { const branches = repo State . get Branches ( ) ; const master = branches . find ( function is Master ( branch ) { return branch . get Full Name ( ) = = = 'master ' ; } ) ; const branch = master | | branches . first ( ) ; return fetch Tree ( repo State , driver , branch ) . then ( ( repo State ) = > { return checkout ( repo State , branch ) ; } ) ; } ) ; } 
function enforce Array Buffer ( b , encoding ) { if ( is Array Buffer ( b ) ) return b ; else if ( is Buffer ( b ) ) return from Buffer ( b ) ; else return from String ( b , encoding ) ; } 
function enforce String ( b , encoding ) { if ( is . string ( b ) ) return b ; if ( is Array Buffer ( b ) ) b = to Buffer ( b ) ; return b . to String ( encoding ) ; } 
function equals ( buf 1 , buf 2 ) { if ( buf 1 . byte Length ! = buf 2 . byte Length ) return false ; const dv 1 = new Int 8Array ( buf 1 ) ; const dv 2 = new Int 8Array ( buf 2 ) ; for ( let i = 0 ; i ! = buf 1 . byte Length ; i + + ) { if ( dv 1 [ i ] ! = dv 2 [ i ] ) return false ; } return true ; } 
function get Change ( parent , sha ) { if ( parent = = = sha ) { return CHANGE . IDENTICAL ; } else if ( parent = = = null ) { return CHANGE . ADDED ; } else if ( sha = = = null ) { return CHANGE . DELETED ; } else { 
function get Merged File Set ( working State ) { return Immutable . Set . from Keys ( get Merged Tree Entries ( working State ) . filter ( tree Entry = > tree Entry . get Type ( ) = = = Tree Entry . TYPES . BLOB ) ) ; } 
function get Merged Tree Entries ( working State ) { const removed Or Modified = working State . get Changes ( ) . group By ( ( change , path ) = > { if ( change . get Type ( ) = = = CHANGES . REMOVE ) { return 'remove ' ; } else { 
function has Pending Changes ( working State , filepath ) { 
function find Sha ( working State , filepath ) { 
function prepare ( repo State , opts ) { const working State = repo State . get Current State ( ) ; const changes = working State . get Changes ( ) ; 
function flush ( repo State , driver , commit Builder , options = { } ) { options = Object . assign ( { branch : repo State . get Current Branch ( ) , ignore Empty : true } , options ) ; if ( options . ignore Empty & & commit Builder . is Empty ( ) & & commit Builder . get Parents ( ) . count ( ) < 2 ) { return Q ( repo State ) ; } 
function format ( color , messages ) { var length = messages . length ; if ( length = = = 0 | | typeof ( color ) ! = = 'string ' ) { return ; } return ( util . format . apply ( null , messages ) [ color ] ) ; } 
function push ( repo State , driver , opts = { } ) { opts = Object . assign ( { branch : repo State . get Current Branch ( ) , force : false , remote : { name : 'origin ' } } , opts ) ; return driver . push ( opts ) 
function pull ( repo State , driver , opts = { } ) { opts = Object . assign ( { branch : repo State . get Current Branch ( ) , force : false , remote : { name : 'origin ' } } , opts ) ; return driver . pull ( opts ) 
function sync ( repo State , driver , opts = { } ) { opts = Object . assign ( { branch : repo State . get Current Branch ( ) , force : false , remote : { name : 'origin ' } } , opts ) ; return pull ( repo State , driver , opts ) . fail ( ( err ) = > { if ( err . code = = = ERRORS . REF _NOT _FOUND ) { return Promise ( repo State ) ; } return Promise . reject ( err ) ; } ) . then ( ( new Repo State ) = > { return push ( new Repo State , driver , opts ) ; } ) ; } 
function compare Refs ( driver , base , head ) { const base Ref = base instanceof Branch ? base . get Full Name ( ) : base ; const head Ref = head instanceof Branch ? head . get Full Name ( ) : head ; return driver . find Parent Commit ( base Ref , head Ref ) . then ( ( parent Commit ) = > { 
function solve Tree ( tree Conflict , solved ) { solved = tree Conflict . get Conflicts ( ) . merge ( solved ) 
function merge Commit ( tree Conflict , parents , options ) { options = options | | { } ; const opts = { } ; 
function _compare Trees ( parent Entries , base Entries , head Entries ) { const head Diff = _diff Entries ( parent Entries , head Entries ) ; const base Diff = _diff Entries ( parent Entries , base Entries ) ; 
function _get Solved Entries ( tree Conflict ) { const parent Entries = tree Conflict . get Parent ( ) . get Tree Entries ( ) ; const base Entries = tree Conflict . get Base ( ) . get Tree Entries ( ) ; const head Entries = tree Conflict . get Head ( ) . get Tree Entries ( ) ; const base Diff = _diff Entries ( parent Entries , base Entries ) ; const head Diff = _diff Entries ( parent Entries , head Entries ) ; const resolved Entries = tree Conflict . get Conflicts ( ) . map ( ( solved Conflict ) = > { 
function add Blob ( cache , sha , blob ) { const blobs = cache . get Blobs ( ) ; const new Blobs = blobs . set ( sha , blob ) ; const new Cache = cache . set ( 'blobs ' , new Blobs ) ; return new Cache ; } 
function path To Key Seq ( path ) { 
function get ( repo State , dir Path ) { 
function norm Created Commit ( gh Commit ) { const commit = Commit . create ( { sha : gh Commit . sha , message : gh Commit . message , author : get Simple Author ( gh Commit . author ) , date : gh Commit . author . date , parents : gh Commit . parents . map ( function get Sha ( o ) { return o . sha ; } ) } ) ; return commit ; } 
function norm Listed Commit ( gh Commit ) { const commit = Commit . create ( { sha : gh Commit . sha , message : gh Commit . commit . message , author : get Complete Author ( gh Commit ) , date : gh Commit . commit . author . date , files : gh Commit . files , parents : gh Commit . parents . map ( c = > c . sha ) } ) ; return commit ; } 
function get Simple Author ( author ) { return Author . create ( { name : author . name , email : author . email , date : author . date } ) ; } 
function get Complete Author ( commit ) { const author = get Simple Author ( commit . commit . author ) ; const avatar = commit . author ? commit . author . avatar _url : gravatar . url ( author . get Email ( ) ) ; return author . set ( 'avatar ' , avatar ) ; } 
function fetch ( repo State , driver , filepath ) { if ( is Fetched ( repo State , filepath ) ) { 
function stat ( repo State , filepath ) { const working State = repo State . get Current State ( ) ; 
function read As String ( repo State , filepath , encoding ) { const blob = read ( repo State , filepath ) ; return blob . get As String ( encoding ) ; } 
function exists ( repo State , filepath ) { const working State = repo State . get Current State ( ) ; const merged File Set = Working Utils . get Merged Tree Entries ( working State ) ; return merged File Set . has ( filepath ) ; } 
function create ( repo State , filepath , content ) { content = content | | ' ' ; if ( exists ( repo State , filepath ) ) { throw error . file Already Exist ( filepath ) ; } const change = Change . create Create ( content ) ; return Change Utils . set Change ( repo State , filepath , change ) ; } 
function write ( repo State , filepath , content ) { if ( ! exists ( repo State , filepath ) ) { throw error . file Not Found ( filepath ) ; } const change = Change . create Update ( content ) ; return Change Utils . set Change ( repo State , filepath , change ) ; } 
function remove ( repo State , filepath ) { if ( ! exists ( repo State , filepath ) ) { throw error . file Not Found ( filepath ) ; } const change = Change . create Remove ( ) ; return Change Utils . set Change ( repo State , filepath , change ) ; } 
function move ( repo State , filepath , new Filepath ) { if ( filepath = = = new Filepath ) { return repo State ; } const initial Working State = repo State . get Current State ( ) ; 
function has Changed ( previous State , new State , filepath ) { const previously Exists = exists ( previous State , filepath ) ; const new Exists = exists ( new State , filepath ) ; if ( ! previously Exists & & ! new Exists ) { 
function setup ( connection , done ) { var config = create Default Config ( ) , options = { proxy : false , headers : { } } ; 
function configure Nock ( options , config ) { var result = { } ; 
function configure Express ( config , done ) { var portfinder = require ( 'portfinder ' ) ; tmp . dir ( function ( err , filepath ) { handles . filepath = filepath ; portfinder . get Port ( function ( err , port ) { if ( err ) throw ( err ) ; handles . port = port ; fs . write File Sync ( path . join ( handles . filepath , 'index .txt ' ) , 'hello , world ' ) ; app . use ( proxy . initialize ( config ) ) ; app . use ( express . static ( handles . filepath ) ) ; handles . server = require ( 'http ' ) . create Server ( app ) ; handles . server . listen ( handles . port , function ( ) { done ( null , handles . port ) ; } ) ; } ) ; } ) ; } 
function configure Lan Proxy ( options , config , done ) { var portfinder = require ( 'portfinder ' ) , request = require ( 'request ' ) , credentials = config . proxy . gateway . auth , gateway Port , expected Authorization Header , request Via Header , response Via Header ; handles = handles | | { } ; handles . gateway Server = require ( 'http ' ) . create Server ( function ( req , res ) { expected Authorization Header = 'Basic ' + new Buffer ( credentials ) . to String ( 'base 6 4 ' ) ; 
function cleanup ( done ) { config = null ; rules . for Each ( function ( rule ) { rule . done ( ) ; } ) ; nock . clean All ( ) ; handles . server . close ( ) ; if ( handles . gateway Server ! = = undefined & & handles . gateway Server ! = = null ) { handles . gateway Server . close ( ) ; } fs . unlink Sync ( path . join ( handles . filepath , ' /index .txt ' ) ) ; handles = null ; done ( ) ; } 
function set Change ( repo State , filepath , change ) { let working State = repo State . get Current State ( ) ; let changes = working State . get Changes ( ) ; const type = change . get Type ( ) ; 
function revert All ( repo State ) { let working State = repo State . get Current State ( ) ; 
function revert For File ( repo State , file Path ) { let working State = repo State . get Current State ( ) ; 
function revert For Dir ( repo State , dir Path ) { let working State = repo State . get Current State ( ) ; let changes = working State . get Changes ( ) ; 
function revert All Removed ( repo State ) { let working State = repo State . get Current State ( ) ; const changes = working State . get Changes ( ) . filter ( 
function norm Path ( p ) { p = path . normalize ( p ) ; if ( p [ 0 ] = = ' / ' ) p = p . slice ( 1 ) ; if ( p [ p . length - 1 ] = = ' / ' ) p = p . slice ( 0 , - 1 ) ; if ( p = = ' . ' ) p = ' ' ; return p ; } 
function path Contains ( dir , path ) { dir = dir ? norm Path ( dir ) + ' / ' : dir ; path = norm Path ( path ) ; return path . index Of ( dir ) = = = 0 ; } 
function read ( repo State , dir Name ) { dir Name = Path Utils . norm ( dir Name ) ; const working State = repo State . get Current State ( ) ; const changes = working State . get Changes ( ) ; const tree Entries = Working Utils . get Merged Tree Entries ( working State ) ; const files = [ ] ; tree Entries . for Each ( ( tree Entry , filepath ) = > { 
function read Recursive ( repo State , dir Name ) { 
function read Filenames ( repo State , dir Name ) { const files = read ( repo State , dir Name ) ; return files . map ( ( file ) = > { return file . get Path ( ) ; } ) ; } 
function read Filenames Recursive ( repo State , dir Name ) { dir Name = Path Utils . norm ( dir Name ) ; const working State = repo State . get Current State ( ) ; const file Set = Working Utils . get Merged File Set ( working State ) ; return file Set . filter ( ( path ) = > { return Path Utils . contains ( dir Name , path ) ; } ) . to Array ( ) ; } 
function move ( repo State , dir Name , new Dir Name ) { 
function remove ( repo State , dir Name ) { 
function create ( repository State , driver , name , opts = { } ) { const { 
function update ( repo State , driver , branch Name ) { branch Name = Normalize . branch Name ( branch Name | | repo State . get Current Branch ( ) ) ; return driver . fetch Branches ( ) . then ( ( branches ) = > { const new Branch = branches . find ( ( branch ) = > { return branch . get Full Name ( ) = = = branch Name ; } ) ; if ( ! new Branch ) { return repo State ; } else { return Repo Utils . fetch Tree ( repo State , driver , new Branch ) ; } } ) ; } 
function remove ( repo State , driver , branch ) { return driver . delete Branch ( branch ) . then ( ( ) = > { return repo State . update Branch ( branch , null ) ; } ) ; } 
function merge ( repo State , driver , from , into , options = { } ) { options = Object . assign ( { fetch : true } , options ) ; let updated Into ; 
function fetch ( repo State , driver , sha ) { if ( is Fetched ( repo State , sha ) ) { 
function ( context , options , callback ) { 
function Pokit Dok ( client Id , client Secret , version ) { this . client Id = client Id ; this . client Secret = client Secret ; this . version = version | | 'v 4 ' ; this . refresh Active = false ; this . retry Queue = [ ] ; this . access Token = null ; } 
function find Router Node ( root ) { return root . find ( j . JSXElement , { opening Element : { name : { name : 'Router ' } } } ) . nodes ( ) [ 0 ] ; } 
function _action ( type , payload , checklist , optional = [ ] ) { for ( let checkitem of [ 'namespace ' , . . . checklist ] ) { if ( optional . index Of ( checkitem ) = = = - 1 ) { assert ( payload [ checkitem ] , ` $ { type } $ { checkitem } ` ) ; } } const file Path = join ( payload . source Path , payload . file Path ) ; const source = read File ( file Path ) ; const root = j ( source ) ; const models = root . find Models ( payload . namespace ) ; const args = checklist . map ( checkitem = > payload [ checkitem ] ) ; models [ type ] . apply ( models , args ) ; write File ( file Path , root . to Source ( ) ) ; } 
function feature Array To Feature String ( features , bias , first Feature Number ) { if ( ! Array . is Array ( features ) ) throw new Error ( "Expected an array , but got " + JSON . stringify ( features ) ) var line = ( bias ? " " + first Feature Number + " : " + bias : " " ) ; for ( var feature = 0 ; feature < features . length ; + + feature ) { var value = features [ feature ] ; if ( value ) line + = ( " " + ( feature + first Feature Number + ( bias ? 1 : 0 ) ) + " : " + value . to Precision ( 5 ) ) ; } return line ; } 
function ( feature ) { if ( ! ( feature in this . feature Name To Feature Index ) ) { var new Index = this . feature Index To Feature Name . length ; this . feature Index To Feature Name . push ( feature ) ; this . feature Name To Feature Index [ feature ] = new Index ; } } 
function ( hash ) { if ( hash instanceof Array ) { for ( var index in hash ) this . add Feature ( hash [ index ] ) ; } else if ( hash instanceof Object ) { for ( var feature in hash ) this . add Feature ( feature ) ; } else throw new Error ( "Feature Lookup Table .add Features expects a hash or an array , but got : " + JSON . stringify ( hash ) ) ; } 
function ( hash ) { this . add Features ( hash ) ; var array = [ ] ; for ( var feature Index = 0 ; feature Index < this . feature Index To Feature Name . length ; + + feature Index ) array [ feature Index ] = 0 ; if ( hash instanceof Array ) { for ( var i in hash ) array [ this . feature Name To Feature Index [ hash [ i ] ] ] = true ; } else if ( hash instanceof Object ) { for ( var feature in hash ) array [ this . feature Name To Feature Index [ feature ] ] = hash [ feature ] ; } else throw new Error ( "Unsupported type : " + JSON . stringify ( hash ) ) ; return array ; } 
function ( hashes ) { this . add Featuress ( hashes ) ; var arrays = [ ] ; for ( var i = 0 ; i < hashes . length ; + + i ) { arrays [ i ] = [ ] ; for ( var feature in this . feature Name To Feature Index ) arrays [ i ] [ this . feature Name To Feature Index [ feature ] ] = hashes [ i ] [ feature ] | | 0 ; } return arrays ; } 
function ( array ) { var hash = { } ; for ( var feature in this . feature Name To Feature Index ) { if ( array [ this . feature Name To Feature Index [ feature ] ] ) hash [ feature ] = array [ this . feature Name To Feature Index [ feature ] ] ; } return hash ; } 
function ( arrays ) { var hashes = [ ] ; for ( var i = 0 ; i < arrays . length ; + + i ) hashes [ i ] = this . array To Hash ( arrays [ i ] ) ; return hashes ; } 
function ( opts ) { opts = opts | | { } ; if ( ! opts . multilabel Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .multilabel Classifier Type is null " ) ; } this . multilabel Classifier Type = opts . multilabel Classifier Type ; this . split Label = opts . split Label | | function ( label ) { return label . split ( / @ / ) ; } this . join Label = opts . join Label | | function ( superlabel ) { return superlabel . join ( " @ " ) ; } this . root = { superlabel Classifier : this . new Multilabel Classifier ( ) , map Superlabel To Branch : { } } this . all Classes = { } ; } 
function ( sample , labels ) { labels = multilabelutils . normalize Output Labels ( labels ) ; for ( var i in labels ) this . all Classes [ labels [ i ] ] = true ; return this . train Online Recursive ( sample , labels . map ( this . split Label ) , this . root ) ; } 
function ( sample , split Labels , tree Node ) { var superlabels = { } ; 
function ( dataset ) { dataset = dataset . map ( function ( datum ) { var normalized Labels = multilabelutils . normalize Output Labels ( datum . output ) ; for ( var i in normalized Labels ) this . all Classes [ normalized Labels [ i ] ] = true ; return { input : datum . input , output : normalized Labels . map ( this . split Label ) } } , this ) ; 
function ( dataset , tree Node ) { var superlabels Dataset = [ ] ; var map Superlabel To Rest Dataset = { } ; dataset . for Each ( function ( datum ) { var split Labels = datum . output ; { Offer : [ [ 'Leased Car ' , 'Without leased car ' ] , [ 'Working Hours ' , ' 9 hours ' ] ] } Sample of superlabels Dataset , initial dataset with superlabel instead of entire output ' . [end ] ' : 0 . 9 6 5 0 8 0 8 9 6 0 4 3 5 8 7 } , output : [ 'Offer ' ] } ] * / superlabels Dataset . push ( { input : datum . input , output : Object . keys ( superlabels ) } ) ; for ( var superlabel in map Superlabel To Rest ) { if ( ! ( superlabel in map Superlabel To Rest Dataset ) ) map Superlabel To Rest Dataset [ superlabel ] = [ ] ; map Superlabel To Rest Dataset [ superlabel ] . push ( { input : datum . input , output : map Superlabel To Rest [ superlabel ] } ) ; } } , this ) ; with the dataset from new structure map Superlabel To Rest Dataset (see above ) * / this . train Batch Recursive ( map Superlabel To Rest Dataset [ superlabel ] , tree Node . map Superlabel To Branch [ superlabel ] ) ; } } 
function ( sample , explain ) { var split Labels = this . classify Recursive ( sample , explain , this . root ) ; 
function ( sample , explain , tree Node , depth ) { if ( ! depth ) depth = 1 ; 
function ( feature Lookup Table , tree Node ) { if ( tree Node . superlabel Classifier & & tree Node . superlabel Classifier . set Feature Lookup Table ) tree Node . superlabel Classifier . set Feature Lookup Table ( feature Lookup Table ) ; for ( var superlabel in tree Node . map Superlabel To Branch ) this . set Feature Lookup Table Recursive ( feature Lookup Table , tree Node . map Superlabel To Branch [ superlabel ] ) ; } 
function ( opts ) { if ( ! ( 'binary Classifier Type ' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain binary Classifier Type " ) ; } if ( ! opts . binary Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .binary Classifier Type is null " ) ; } this . binary Classifier Type = opts . binary Classifier Type ; this . classifier = new this . binary Classifier Type ( ) ; switch ( opts . segment Split Strategy ) { case 'shortest Segment ' : this . segment Split Strategy = this . shortest Segment Split Strategy ; break ; case 'longest Segment ' : this . segment Split Strategy = this . longest Segment Split Strategy ; break ; case 'cheapest Segment ' : this . segment Split Strategy = this . cheapest Segment Split Strategy ; break ; default : this . segment Split Strategy = null ; } this . map Classname To Classifier = { } ; } 
function ( sample , classes ) { sample = this . sample To Features ( sample , this . feature Extractors ) ; classes = hash . normalized ( classes ) ; for ( var positive Class in classes ) { this . make Sure Classifier Exists ( positive Class ) ; this . map Classname To Classifier [ positive Class ] . train Online ( sample , 1 ) ; } for ( var negative Class in this . map Classname To Classifier ) { if ( ! classes [ negative Class ] ) this . map Classname To Classifier [ negative Class ] . train Online ( sample , 0 ) ; } } 
function ( dataset ) { 
function ( segment , explain ) { var classes = this . classify Segment ( segment , explain ) ; if ( classes . classes . length = = 0 ) { 
function ( words , accumulated Classes , explain , explanations ) { 
function ( words , accumulated Classes , explain , explanations ) { var current Start = 0 ; for ( var current End = 1 ; current End < = words . length ; + + current End ) { var segment = words . slice ( current Start , current End ) . join ( " " ) ; var segment Classes With Explain = this . classify Segment ( segment , explain ) ; var segment Classes = ( segment Classes With Explain . classes ? segment Classes With Explain . classes : segment Classes With Explain ) ; if ( segment Classes . length = = 1 ) { 
function ( words , accumulated Classes , explain , explanations ) { var current Start = 0 ; var segment = null ; var segment Classes With Explain = null ; var segment Classes = null ; for ( var current End = 1 ; current End < = words . length ; + + current End ) { var next Segment = words . slice ( current Start , current End ) . join ( " " ) ; var next Segment Classes With Explain = this . classify Segment ( next Segment , explain ) ; var next Segment Classes = ( next Segment Classes With Explain . classes ? next Segment Classes With Explain . classes : next Segment Classes With Explain ) ; console .dir (explanations ) ; process .exit ( 1 ) ; } * / } 
function ( sentence , explain ) { 
function ( opts ) { this . retrain _count = opts . retrain _count | | 1 0 ; this . Constant = opts . Constant | | 5 . 0 ; this . weights = { 
function ( sample , classes ) { var classes Set = hash . normalized ( classes ) ; var ranks = this . predict ( sample , false ) ; 
function ( dataset ) { 
function ( features , explain , with Scores ) { this . edit Feature Values ( features , true ) ; var scores Vector = this . predict ( features , true , explain ) ; return multilabelutils . map Scores Vector To Multilabel Result ( scores Vector , explain , with Scores , 0 ) ; } 
function ( classes ) { classes = hash . normalized ( classes ) ; for ( var a Class in classes ) { if ( ! ( a Class in this . weights ) ) { this . weights [ a Class ] = { } ; this . weights _sum [ a Class ] = { } ; } } } 
function ( opts ) { opts = opts | | { } ; if ( ! opts . multilabel Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .multilabel Classifier Type is null " ) ; } if ( ! opts . numberofclassifiers ) { console . dir ( opts ) ; throw new Error ( "opts .numberofclassifiers is null " ) ; } 
function ( ) { this . count = 0 ; this . TP = 0 ; this . TN = 0 ; this . FP = 0 ; this . FN = 0 ; this . TRUE = 0 ; this . start Time = new Date ( ) ; this . labels = { } this . dep = { } this . confusion = { } } 
function ( expected , actual ) { this . count + + ; if ( expected & & actual ) this . TP + + ; if ( ! expected & & actual ) this . FP + + ; if ( expected & & ! actual ) this . FN + + ; if ( ! expected & & ! actual ) this . TN + + ; if ( expected = = actual ) this . TRUE + + ; } 
function ( expected Classes , actual Classes ) { var explanations = [ ] ; actual Classes = hash . normalized ( actual Classes ) ; expected Classes = hash . normalized ( expected Classes ) ; var all True = true ; if ( ! ( Object . keys ( expected Classes ) [ 0 ] in this . confusion ) ) this . confusion [ Object . keys ( expected Classes ) [ 0 ] ] = { } if ( ! ( Object . keys ( actual Classes ) [ 0 ] in this . confusion [ Object . keys ( expected Classes ) [ 0 ] ] ) ) this . confusion [ Object . keys ( expected Classes ) [ 0 ] ] [ Object . keys ( actual Classes ) [ 0 ] ] = 0 this . confusion [ Object . keys ( expected Classes ) [ 0 ] ] [ Object . keys ( actual Classes ) [ 0 ] ] + = 1 for ( var actual Class in actual Classes ) { if ( ! ( actual Class in this . confusion ) ) this . confusion [ actual Class ] = { } if ( ! ( actual Class in this . labels ) ) { this . labels [ actual Class ] = { } this . labels [ actual Class ] [ 'TP ' ] = 0 this . labels [ actual Class ] [ 'FP ' ] = 0 this . labels [ actual Class ] [ 'FN ' ] = 0 } if ( actual Class in expected Classes ) { this . labels [ actual Class ] [ 'TP ' ] + = 1 } else { this . labels [ actual Class ] [ 'FP ' ] + = 1 } } for ( var expected Class in expected Classes ) { if ( ! ( expected Class in this . labels ) ) { this . labels [ expected Class ] = { } this . labels [ expected Class ] [ 'TP ' ] = 0 this . labels [ expected Class ] [ 'FP ' ] = 0 this . labels [ expected Class ] [ 'FN ' ] = 0 } if ( ! ( expected Class in actual Classes ) ) { this . labels [ expected Class ] [ 'FN ' ] + = 1 } } } 
function ( expected Classes , actual Classes , log True Positives ) { var explanations = [ ] ; actual Classes = hash . normalized ( actual Classes ) ; expected Classes = hash . normalized ( expected Classes ) ; var all True = true ; for ( var actual Class in actual Classes ) { if ( actual Class in expected Classes ) { if ( log True Positives ) explanations . push ( " \t \t + + + TRUE POSITIVE : " + actual Class ) ; this . TP + + ; } else { explanations . push ( " \t \t - - - FALSE POSITIVE : " + actual Class ) ; this . FP + + ; all True = false ; } } for ( var expected Class in expected Classes ) { if ( ! ( expected Class in actual Classes ) ) { explanations . push ( " \t \t - - - FALSE NEGATIVE : " + expected Class ) ; this . FN + + ; all True = false ; } } if ( all True ) { if ( log True Positives ) explanations . push ( " \t \t * * * ALL TRUE ! " ) ; this . TRUE + + ; } this . count + + ; return explanations ; } 
function ( expected Classes , actual Classes , log True Positives ) { var explanations = { } ; explanations [ 'TP ' ] = [ ] ; explanations [ 'FP ' ] = [ ] ; explanations [ 'FN ' ] = [ ] ; actual Classes = hash . normalized ( actual Classes ) ; expected Classes = hash . normalized ( expected Classes ) ; var all True = true ; for ( var actual Class in actual Classes ) { if ( actual Class in expected Classes ) { if ( log True Positives ) explanations [ 'TP ' ] . push ( actual Class ) ; this . TP + + ; } else { explanations [ 'FP ' ] . push ( actual Class ) ; this . FP + + ; all True = false ; } } for ( var expected Class in expected Classes ) { if ( ! ( expected Class in actual Classes ) ) { explanations [ 'FN ' ] . push ( expected Class ) ; this . FN + + ; all True = false ; } } if ( all True ) { 
function ( expected Classes , actual Classes , log True Positives ) { var ex = [ ] var ac = [ ] var matchlist = [ ] 
function ( begin , end ) { if ( ( begin [ 0 ] < = end [ 0 ] ) & & ( begin [ 1 ] > = end [ 0 ] ) ) return true if ( ( begin [ 0 ] > = end [ 0 ] ) & & ( begin [ 0 ] < = end [ 1 ] ) ) return true return false } 
function Winnow Hash ( opts ) { if ( ! opts ) opts = { } this . debug = opts . debug | | false ; 
function ( dataset ) { 
function ( dataset ) { if ( this . debug ) console . log ( "train Batch start " ) ; var timestamp = new Date ( ) . get Time ( ) + " _ " + process . pid var learn File = svmcommon . write Dataset To File ( dataset , this . bias , true , this . model _file _prefix + " _ " + timestamp , "Svm Perf " , FIRST _FEATURE _NUMBER ) ; var model File = learn File . replace ( / [ . ]learn / , " .model " ) ; var command = "svm _perf _learn " + this . learn _args + " " + learn File + " " + model File ; if ( this . debug ) console . log ( "running " + command ) ; console . log ( command ) var result = exec Sync ( command ) ; if ( result . code > 0 ) { console . dir ( result ) ; console . log ( fs . read File Sync ( learn File , 'utf - 8 ' ) ) ; throw new Error ( "Failed to execute : " + command ) ; } this . set Model ( fs . read File Sync ( model File , "utf - 8 " ) ) ; if ( this . debug ) console . log ( "train Batch end " ) ; } 
function model String To Model Map ( model String ) { var matches = SVM _PERF _MODEL _PATTERN . exec ( model String ) ; if ( ! matches ) { console . log ( model String ) ; throw new Error ( "Model does not match SVM -perf format " ) ; } ; 
function ( dataset , relation Name , feature Lookup Table ) { var arff = " % Automatically generated by Node .js \n " ; arff + = " @relation " + relation Name + " \n " ; feature Lookup Table . feature Index To Feature Name . for Each ( function ( feature Name ) { if ( _ . is Undefined ( feature Name ) ) arff + = " @attribute undefined { 0 , 1 } " + " \n " ; else if ( ! _ . is String ( feature Name ) ) throw new Error ( "Expected feature Name to be a string , but found " + JSON . stringify ( feature Name ) ) ; else arff + = " @attribute " + feature Name . replace ( / [ ^a -z A -Z 0 - 9 ] / g , " _ " ) + " " + " { 0 , 1 } " + " \n " ; } ) ; arff + = " \n @data \n " ; dataset . for Each ( function ( datum ) { var datum Arff = _ . clone ( datum . input , { } ) ; for ( var i = 0 ; i < datum . output . length ; + + i ) datum Arff [ datum . output [ i ] ] = 1 ; 
function Svm Linear ( opts ) { this . learn _args = opts . learn _args | | " " ; this . model _file _prefix = opts . model _file _prefix | | null ; this . bias = opts . bias | | 1 . 0 ; this . multiclass = opts . multiclass | | false ; this . debug = opts . debug | | false ; this . train _command = opts . train _command | | 'liblinear _train ' ; this . test _command = opts . test _command | | 'liblinear _test ' ; this . timestamp = " " if ( ! Svm Linear . is Installed ( ) ) { var msg = "Cannot find the executable 'liblinear _train ' . Please download it from the Lib Linear website , and put a link to it in your path . " ; console . error ( msg ) throw new Error ( msg ) ; } } 
function ( dataset ) { this . timestamp = new Date ( ) . get Time ( ) + " _ " + process . pid 
function model String To Model Map ( model String ) { var matches = LIB _LINEAR _MODEL _PATTERN . exec ( model String ) ; if ( ! matches ) { console . log ( model String ) ; throw new Error ( "Model does not match SVM -Linear format " ) ; } ; var labels = matches [ 1 ] . split ( / \s + / ) ; var map Label To Map Feature To Weight = { } ; for ( var i Label in labels ) { var label = labels [ i Label ] ; map Label To Map Feature To Weight [ label ] = { } ; } var weights Matrix = matches [ 3 ] ; 
function ( opts ) { if ( ! opts . ranker Type ) { console . dir ( opts ) ; throw new Error ( "opts .ranker Type not found " ) ; } if ( ! opts . counter Type ) { console . dir ( opts ) ; throw new Error ( "opts .counter Type not found " ) ; } this . ranker = new opts . ranker Type ( ) ; this . counter = new opts . counter Type ( ) ; } 
function ( sample , labels ) { 
function ( dataset ) { 
function ( sample , explain ) { var ranked Labels With Explain = this . ranker . classify ( sample , explain , true ) ; var ranked Labels = ( explain > 0 ? ranked Labels With Explain . classes : ranked Labels With Explain ) ; var label Count With Explain = this . counter . classify ( sample , explain , true ) ; var label Count = ( explain > 0 ? label Count With Explain . classes [ 0 ] [ 0 ] : label Count With Explain [ 0 ] [ 0 ] ) ; if ( _ . is String ( label Count ) ) label Count = parse Int ( label Count ) ; 
function ( feature Lookup Table ) { if ( this . ranker . set Feature Lookup Table ) this . ranker . set Feature Lookup Table ( feature Lookup Table ) ; if ( this . counter . set Feature Lookup Table ) this . counter . set Feature Lookup Table ( feature Lookup Table ) ; } 
function ( opts ) { if ( ! opts . binary Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .binary Classifier Type not found " ) ; } this . binary Classifier Type = opts . binary Classifier Type ; this . debug = opts . debug | | false this . map Classname To Classifier = { } ; } 
function ( sample , labels ) { labels = multilabelutils . normalize Output Labels ( labels ) ; for ( var l in labels ) { var positive Label = labels [ l ] ; this . make Sure Classifier Exists ( positive Label ) ; this . map Classname To Classifier [ positive Label ] . train Online ( sample , 1 ) ; } for ( var negative Label in this . map Classname To Classifier ) { if ( labels . index Of ( negative Label ) < 0 ) this . map Classname To Classifier [ negative Label ] . train Online ( sample , 0 ) ; } } 
function ( dataset ) { 
function ( sample , explain , with Scores ) { var labels = [ ] var scores = [ ] var explanations = [ ] ; var positive _explanations = { } ; var negative _explanations = [ ] for ( var label in this . map Classname To Classifier ) { var classifier = this . map Classname To Classifier [ label ] ; if ( this . debug ) console . dir ( "Classify for class = " + label ) 
function ( feature Lookup Table ) { 
function ( label ) { if ( ! this . map Classname To Classifier [ label ] ) { 
function ( opts ) { opts = opts | | { } ; if ( ! ( 'multiclass Classifier Type ' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain multiclass Classifier Type " ) ; } if ( ! opts . multiclass Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .multiclass Classifier Type is null " ) ; } if ( ! ( 'evaluate Measure To Maximize ' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain evaluate Measure To Maximize " ) ; } if ( ! opts . evaluate Measure To Maximize ) { console . dir ( opts ) ; throw new Error ( "opts .evaluate Measure To Maximize is null " ) ; } if ( ! opts . num Of Folds For Threshold Calculation ) { console . dir ( opts ) ; throw new Error ( "opts .num Of Folds For Threshold Calculation is null " ) ; } this . multiclass Classifier = new opts . multiclass Classifier Type ( ) ; 
function ( dataset ) { _ . times ( 3 , function ( n ) { dataset = _ . shuffle ( dataset ) } ) if ( this . num Of Folds For Threshold Calculation > 1 ) { thresholds = [ ] best _performances = [ ] average _performances = [ ] median _performances = [ ] partitions . partitions _consistent ( dataset , this . num Of Folds For Threshold Calculation , ( function ( train Set , test Set , index ) { this . multiclass Classifier . train Batch ( train Set ) ; result = this . receive Scores ( test Set ) performance = this . Calculate Performance ( result [ 0 ] , test Set , result [ 1 ] ) best _performances . push ( performance ) } ) . bind ( this ) ) this . stats = best _performances threshold _average = ulist . average ( _ . pluck ( best _performances , 'Threshold ' ) ) threshold _median = ulist . median ( _ . pluck ( best _performances , 'Threshold ' ) ) Threshold = threshold _median } else { dataset = partitions . partition ( dataset , 1 , Math . round ( dataset . length * this . devsetsize ) ) train Set = dataset [ 'train ' ] test Set = dataset [ 'test ' ] this . multiclass Classifier . train Batch ( train Set ) ; result = this . receive Scores ( test Set ) performance = this . Calculate Performance ( result [ 0 ] , test Set , result [ 1 ] ) Threshold = performance [ 'Threshold ' ] } this . multiclass Classifier . threshold = Threshold } 
function ( dataset ) { list _of _scores = [ ] ; FN = 0 for ( var i = 0 ; i < dataset . length ; + + i ) { var scores Vector = this . multiclass Classifier . classify ( dataset [ i ] . input , false , true ) ; for ( score in scores Vector ) { if ( dataset [ i ] . output . index Of ( scores Vector [ score ] [ 0 ] ) > - 1 ) { scores Vector [ score ] . push ( " + " ) FN + = 1 } else { scores Vector [ score ] . push ( " - " ) } scores Vector [ score ] . push ( i ) } list _of _scores = list _of _scores . concat ( scores Vector ) } 
function ( list _of _scores , test Set , FN ) { current _set = [ ] TRUE = 0 FP = 0 TP = 0 result = [ ] for ( var th = 0 ; th < list _of _scores . length ; + + th ) { if ( list _of _scores [ th ] [ 2 ] = = " + " ) { TP + = 1 ; FN - = 1 } if ( list _of _scores [ th ] [ 2 ] = = " - " ) { FP + = 1 ; } 
function ( opts ) { if ( ! opts . multiclass Classifier Type ) { console . dir ( opts ) ; throw new Error ( "opts .multiclass Classifier Type not found " ) ; } this . multiclass Classifier Type = opts . multiclass Classifier Type ; this . feature Extractor = Features Unit . normalize ( opts . feature Extractor ) ; this . multiclass Classifier = new this . multiclass Classifier Type ( ) ; } 
function ( sample , classes ) { sample = this . sample To Features ( sample , this . feature Extractor ) ; var category = ( Array . is Array ( classes ) ? classes [ 0 ] : classes ) ; this . multiclass Classifier . train Online ( sample , category ) ; } 
function ( dataset ) { for ( var i = 0 ; i < dataset . length ; + + i ) { dataset [ i ] = { input : this . sample To Features ( dataset [ i ] . input , this . feature Extractor ) , output : ( Array . is Array ( dataset [ i ] . output ) ? dataset [ i ] . output [ 0 ] : dataset [ i ] . output ) } ; } this . multiclass Classifier . train Batch ( dataset ) ; } 
function ( segment , explain ) { var sample = this . sample To Features ( segment , this . feature Extractor ) ; return this . multiclass Classifier . classify ( sample , explain ) ; } 
function ( words , accumulated Classes , explain , explanations ) { 
function ( sentence , explain ) { var min Words To Split = 2 ; var words = sentence . split ( / / ) ; if ( words . length > = min Words To Split ) { var accumulated Classes = { } ; var explanations = [ ] ; this . cheapest Segment Split Strategy ( words , accumulated Classes , explain , explanations ) ; var classes = Object . keys ( accumulated Classes ) ; return ( explain > 0 ? { classes : classes , explanation : explanations } : classes ) ; } else { return this . classify Segment ( sentence , explain ) ; } } 
function ( sample , feature Extractor ) { var features = sample ; if ( feature Extractor ) { try { features = { } ; feature Extractor ( sample , features ) ; } catch ( err ) { throw new Error ( "Cannot extract features from ' " + JSON . stringify ( sample ) + " ' : " + JSON . stringify ( err ) ) ; } } return features ; } 
function load Package Properties ( grunt ) { var package File = 'package .json ' ; if ( grunt . file . exists ( package File ) ) { return _ . pick ( grunt . file . read JSON ( package File ) , [ 'name ' , 'version ' , 'description ' ] ) ; } return { } ; } 
function concat Option Data Arrays ( options , data , prop ) { if ( ! _ . has ( options , prop ) & & ! _ . has ( data , prop ) ) { return ; } var combined = [ ] ; if ( _ . is Array ( options [ prop ] ) ) { combined = combined . concat ( options [ prop ] ) ; } if ( _ . is Array ( data [ prop ] ) ) { combined = combined . concat ( data [ prop ] ) ; } options [ prop ] = combined ; } 
function apply Spec Settings ( grunt , options , spec ) { spec . tags . name = options . name | | spec . tags . name ; if ( ! _ . has ( options , 'version ' ) ) { _default Option Notice ( grunt , 'version ' , ' 0 . 0 . 0 ' ) ; } spec . tags . version = options . version | | ' 0 . 0 . 0 ' ; if ( ! _ . has ( options , 'release ' ) ) { _default Option Notice ( grunt , 'release ' , ' 1 ' ) ; } spec . tags . release = options . release | | ' 1 ' ; if ( ! _ . has ( options , 'build Arch ' ) ) { _default Option Notice ( grunt , 'build Arch ' , 'noarch ' ) ; } spec . tags . build Arch = options . build Arch | | 'noarch ' ; if ( ! _ . has ( options , 'description ' ) ) { _default Option Notice ( grunt , 'description ' , 'No Description ' ) ; } spec . tags . description = options . description | | 'No Description ' ; if ( ! _ . has ( options , 'summary ' ) ) { _default Option Notice ( grunt , 'summary ' , 'No Summary ' ) ; } spec . tags . summary = options . summary | | 'No Summary ' ; if ( ! _ . has ( options , 'license ' ) ) { _default Option Notice ( grunt , 'license ' , 'MIT ' ) ; } spec . tags . license = options . license | | 'MIT ' ; spec . tags . epoch = options . epoch | | spec . tags . epoch ; spec . tags . distribution = options . distribution | | spec . tags . distribution ; if ( ! _ . has ( options , 'vendor ' ) ) { _default Option Notice ( grunt , 'vendor ' , 'Vendor ' ) ; } spec . tags . vendor = options . vendor | | 'Vendor ' ; spec . tags . url = options . url | | spec . tags . url ; if ( ! _ . has ( options , 'group ' ) ) { _default Option Notice ( grunt , 'group ' , 'Development /Tools ' ) ; } spec . tags . group = options . group | | 'Development /Tools ' ; spec . tags . packager = options . packager | | spec . tags . packager ; if ( _ . has ( options , 'defines ' ) ) { spec . add Defines . apply ( spec , options . defines ) ; } 
function Couch ( opts ) { var self = this ; self . url = ( typeof opts . url = = = 'string ' ) ? opts . url : null ; self . user Ctx = opts . user Ctx | | null ; self . time _C = opts . time _C | | null ; self . known _dbs = null ; self . log = debug ( 'cqs :couch : ' + self . url ) ; } 
function uuids _for ( couch ) { UUIDS [ couch . url ] = UUIDS [ couch . url ] | | new UUIDGetter ( couch ) ; return UUIDS [ couch . url ] ; } 
function templated _ddoc ( name ) { return stringify _functions ( TEMPLATE ) function stringify _functions ( obj ) { var copy = { } ; if ( Array . is Array ( obj ) ) return obj . map ( stringify _functions ) else if ( typeof obj = = = 'object ' & & obj ! = = null ) { Object . keys ( obj ) . for Each ( function ( key ) { copy [ key ] = stringify _functions ( obj [ key ] ) ; } ) return copy ; } else if ( typeof obj = = = 'function ' ) return func _from _template ( obj ) else return lib . JDUP ( obj ) ; } } 
function pluralize ( number , words ) { var magnitude = number % 1 0 0 ; var plural Word = ' ' if ( ( magnitude > 1 0 & & magnitude < 2 0 ) | | ( number = = = 0 ) ) { plural Word = words [ 2 ] ; } else { switch ( Math . abs ( number % 1 0 ) ) { case 1 : plural Word = words [ 0 ] ; break case 2 : case 3 : case 4 : plural Word = words [ 1 ] ; break default : plural Word = words [ 2 ] ; break } } return [ number , plural Word ] . join ( ' ' ) } 
function Message ( opts ) { var self = this ; events . Event Emitter . call ( self ) ; lib . copy ( opts , self , 'uppercase ' ) ; self . Message Id = opts . Message Id | | opts . _id | | null ; self . Body = opts . Message Body | | opts . Body | | opts . _str | | null ; self . MD 5Of Message Body = null ; self . Id Extra = opts . Id Extra | | null ; self . queue = opts . queue | | null ; self . is _heartbeat = opts . is _heartbeat | | false ; self . seq = opts . seq | | null ; self . log = debug ( 'cqs :message : ' + ( self . Message Id | | 'untitled ' ) ) ; } 
function Queue ( opts ) { var self = this ; if ( typeof opts = = 'string ' ) opts = { 'name ' : opts } ; opts = defaultable . merge ( opts , DEFS ) ; self . name = opts . name | | opts . Queue Name | | opts . _str | | null ; self . time _C = opts . time _C | | null ; self . db = new couch . Database ( { 'couch ' : opts . couch , 'db ' : opts . db , time _C : self . time _C } ) ; self . Visibility Timeout = opts . Default Visibility Timeout | | opts . Visibility Timeout | | DEFS . visibility _timeout ; self . cache _confirmation = true ; self . browser _attachments = ! ! ( opts . browser _attachments ) ; self . allow _foreign _docs = opts . allow _foreign _docs self . log = debug ( 'cqs :queue : ' + ( self . name | | 'untitled ' ) ) ; } 
function preorder ( node , node Index , parent ) { var children var length var index var position var child if ( is ( test , node , node Index , parent ) ) { return null } children = node . children if ( ! children | | children . length = = = 0 ) { return node } 
function as AAAA ( consumer , packet ) { var data = ' ' ; for ( var i = 0 ; i < 7 ; i + + ) { data + = consumer . short ( ) . to String ( 1 6 ) + ' : ' ; } data + = consumer . short ( ) . to String ( 1 6 ) ; packet . address = data ; } 
function filter Relations ( relation ) { var mapped Data = included Data . find ( function ( inc ) { return inc . id = = = relation . id ; } ) ; var Relation Model = get Model ( relation . type ) ; var modeled Data = new Relation Model ( mapped Data ) ; return check For Relations ( modeled Data , modeled Data . data ) ; } 
function Bundle Locator ( options ) { this . _options = options | | { } ; if ( this . _options . application Directory ) { this . _options . application Directory = libpath . resolve ( process . cwd ( ) , this . _options . application Directory ) ; } else { this . _options . application Directory = process . cwd ( ) ; } this . _options . max Package Depth = this . _options . max Package Depth | | DEFAULT _MAX _PACKAGES _DEPTH ; this . _options . exclude = this . _options . exclude | | [ ] ; this . _cache Rules = { } ; 
function ( dir , options ) { var self = this , bundle Seeds ; 
function ( bundle Name , filter ) { var bundle , files = [ ] ; bundle = this . _bundles [ bundle Name ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle " ' + bundle Name + ' " ' ) ; } Object . keys ( bundle . files ) . for Each ( function ( fullpath ) { var res = { ext : libpath . extname ( fullpath ) . substr ( 1 ) } ; if ( this . _filter Resource ( res , filter ) ) { files . push ( fullpath ) ; } } , this ) ; return files ; } 
function ( bundle Name , filter ) { var bundle = this . _bundles [ bundle Name ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle " ' + bundle Name + ' " ' ) ; } return this . _walk Bundle Resources ( bundle , filter ) ; } 
function ( filter ) { var self = this , ress = [ ] ; Object . keys ( this . _bundles ) . for Each ( function ( bundle Name ) { var bundle = self . _bundles [ bundle Name ] ; self . _walk Bundle Resources ( bundle , filter ) . for Each ( function ( res ) { ress . push ( res ) ; } ) ; } ) ; return ress ; } 
function ( filter ) { var bundle Name , bundles = this . _bundles , bundle Names = [ ] ; if ( 'function ' ! = = typeof filter ) { return Object . keys ( this . _bundles ) ; } for ( bundle Name in bundles ) { if ( bundles . has Own Property ( bundle Name ) ) { if ( filter ( bundles [ bundle Name ] ) ) { bundle Names . push ( bundle Name ) ; } } } return bundle Names ; } 
function ( find Path ) { 
function ( base Directory , name , version , pkg , options ) { var seed ; seed = { base Directory : base Directory , name : name , version : version } ; if ( pkg ) { seed . name = ( pkg . locator & & pkg . locator . name ? pkg . locator . name : pkg . name ) ; seed . version = pkg . version ; seed . options = pkg . locator ; seed . pkg = pkg ; } if ( options ) { if ( seed . options ) { 
function ( seed , parent ) { var bundle , ruleset = this . _load Ruleset ( seed ) , msg ; if ( seed . options . location ) { 
function ( full Path ) { var bundle Name , bundle , ruleset , relative Path , path Parts , sub Bundle Seed , res ; bundle Name = this . _get Bundle Name By Path ( full Path ) ; bundle = this . _bundles [ bundle Name ] ; if ( bundle . base Directory = = = full Path . substr ( 0 , bundle . base Directory . length ) ) { relative Path = full Path . substr ( bundle . base Directory . length + 1 ) ; } 
function ( full Path , relative Path , rule ) { var r , regex ; relative Path = Bundle Locator . _to Unix Path ( relative Path ) ; for ( r = 0 ; r < rule . length ; r + = 1 ) { regex = rule [ r ] ; if ( regex . test ( relative Path ) ) { return true ; } } return false ; } 
function ( full Path , relative Path , rule , parent ) { var r , matches , default Version = DEFAULT _VERSION , pkg ; if ( parent ) { default Version = parent . version ; } relative Path = Bundle Locator . _to Unix Path ( relative Path ) ; for ( r = 0 ; r < rule . length ; r + = 1 ) { matches = relative Path . match ( rule [ r ] . regex ) ; if ( matches ) { try { pkg = require ( libpath . resolve ( full Path , 'package .json ' ) ) ; } catch ( package Err ) { 
function ( res , ruleset ) { var bundle = this . _bundles [ res . bundle Name ] , rule Name , rule , relative Path = Bundle Locator . _to Unix Path ( res . relative Path ) , match ; bundle . files [ res . full Path ] = true ; for ( rule Name in ruleset ) { if ( ruleset . has Own Property ( rule Name ) ) { 
function ( res ) { var bundle = this . _bundles [ res . bundle Name ] , type = res . type , subtype , selector = res . selector , name = res . name ; if ( ! bundle . resources [ selector ] ) { bundle . resources [ selector ] = { } ; } if ( ! bundle . resources [ selector ] [ type ] ) { bundle . resources [ selector ] [ type ] = { } ; } if ( res . has Own Property ( 'subtype ' ) ) { subtype = res . subtype ; if ( ! bundle . resources [ selector ] [ type ] [ subtype ] ) { bundle . resources [ selector ] [ type ] [ subtype ] = { } ; } bundle . resources [ selector ] [ type ] [ subtype ] [ name ] = res ; } else { bundle . resources [ selector ] [ type ] [ name ] = res ; } } 
function ( res , filter ) { if ( ! filter | | Object . keys ( filter ) . length = = = 0 ) { return true ; } var prop ; for ( prop in filter ) { if ( 'extensions ' = = = prop ) { 
function ( dir , _depth ) { var self = this , pkg , seed , seeds = [ ] , subdirs ; _depth = _depth | | 0 ; try { pkg = require ( libpath . resolve ( dir , 'package .json ' ) ) ; 
function ( pkg Depths ) { 
function ( all ) { var by Depth = { } ; 
function ( bundle Seed ) { var self = this , parent Name , parent , bundle , filters ; 
function ( bundle ) { var name = ( bundle . options & & bundle . options . ruleset ) | | DEFAULT _RULESET , cache Key = name + ' @ ' + bundle . base Directory , rulesets Path , rulesets , dir , rules ; rules = this . _cache Rules [ cache Key ] ; if ( rules ) { return rules ; } if ( bundle . options & & bundle . options . rulesets ) { try { rulesets Path = libpath . resolve ( bundle . base Directory , bundle . options . rulesets ) ; rulesets = require ( rulesets Path ) ; } catch ( err Local ) { if ( 'MODULE _NOT _FOUND ' ! = = err Local . code ) { throw err Local ; } } if ( ! rulesets ) { dir = bundle . base Directory ; while ( dir ) { try { rulesets Path = libpath . resolve ( dir , bundle . options . rulesets ) ; rulesets = require ( rulesets Path ) ; break ; } catch ( err Dir ) { if ( 'MODULE _NOT _FOUND ' ! = = err Dir . code ) { throw err Dir ; } } try { rulesets Path = libpath . resolve ( dir , 'node _modules ' , bundle . options . rulesets ) ; rulesets = require ( rulesets Path ) ; break ; } catch ( err Dep ) { if ( 'MODULE _NOT _FOUND ' ! = = err Dep . code ) { throw err Dep ; } } 
function ( src Object , exclude Keys ) { var dest Object = { } , key ; for ( key in src Object ) { if ( src Object . has Own Property ( key ) ) { if ( - 1 = = = exclude Keys . index Of ( key ) ) { dest Object [ key ] = src Object [ key ] ; } } } return dest Object ; } 
function Bundle ( base Directory , options ) { this . options = options | | { } ; this . name = libpath . basename ( base Directory ) ; this . base Directory = base Directory ; this . type = undefined ; this . files = { } ; this . resources = { } ; } 
function get Base Scales ( type , domain , range , nice , tick Count ) { const factory = ( type = = = 'time ' & & scale Utc ) | | ( type = = = 'log ' & & scale Log ) | | scale Linear const scale = create Scale ( factory , domain , range ) if ( nice ) scale . nice ( tick Count ) return scale } 
function get Line Render Data ( props , data , idx ) { if ( is Empty ( data ) ) return undefined const path 2D = get Path 2D ( ) const values = get Plot Values ( props , head ( data ) , idx , { hover Alpha : 0 . 2 } ) if ( props . interpolate ) { spline Interpolation ( props , data , path 2D ) } else { path 2D . move To ( values . x , values . y ) reduce ( data , ( should Draw Point , d ) = > { const x = plot Value ( props , d , idx , 'x ' ) const y = plot Value ( props , d , idx , 'y ' ) if ( not Plot Number ( [ x , y ] ) ) return false if ( should Draw Point ) path 2D . line To ( x , y ) else path 2D . move To ( x , y ) return true } , true ) } return { . . . values , data , hover Solver , path 2D , type : 'line ' , } } 
function get Point Render Data ( props , datum , idx ) { const values = get Plot Values ( props , datum , idx , { hover Alpha : 0 . 7 5 , radius : 4 , x : get Mid X ( props . plot Rect ) , y : get Mid Y ( props . plot Rect ) , } ) const path 2D = get Path 2D ( ) const hover 2nd Path 2D = get Path 2D ( ) path 2D . arc ( values . x , values . y , values . radius , 0 , 2 * Math . PI ) hover 2nd Path 2D . arc ( values . x , values . y , values . radius + 8 , 0 , 2 * Math . PI ) return { . . . values , hover 2nd Path 2D , path 2D , type : 'area ' , } } 
function remove Dim Arrays ( props ) { const names = map ( props . grouped Keys , key = > ` $ { key } ` ) return omit ( props , names ) } 
function get Text Render Data ( props , datum , idx ) { const { plot Rect , theme , width , height } = props const values = get Plot Values ( props , datum , idx , { x : get Mid X ( props . plot Rect ) , y : get Mid Y ( props . plot Rect ) , } ) if ( values . text Snap = = = 'top ' ) values . y = get Min Y ( plot Rect ) if ( values . text Snap = = = 'bottom ' ) values . y = get Max Y ( plot Rect ) if ( values . text Snap = = = 'left ' ) values . x = get Min X ( plot Rect ) if ( values . text Snap = = = 'right ' ) values . x = get Max X ( plot Rect ) if ( values . text Snap = = = 'top Left ' ) { values . x = get Min X ( plot Rect ) values . y = get Min Y ( plot Rect ) } if ( values . text Snap = = = 'top Right ' ) { values . x = get Max X ( plot Rect ) values . y = get Min Y ( plot Rect ) } if ( values . text Snap = = = 'bottom Left ' ) { values . x = get Min X ( plot Rect ) values . y = get Max Y ( plot Rect ) } if ( values . text Snap = = = 'bottom Right ' ) { values . x = get Max X ( plot Rect ) values . y = get Max Y ( plot Rect ) } const new Values = fit Check Text ( values , width , height , theme ) return { . . . new Values , type : 'text ' } } 
function Buffering Tracer ( tracer , options ) { options = options | | { } ; var self = this ; this . _tracer = tracer ; this . _max Traces = options . max Traces | | 5 0 ; this . _send Interval = options . send Interval ? ( options . send Interval * 1 0 0 0 ) : 1 0 * 1 0 0 0 ; this . _last Sent Ts = Date . now ( ) ; this . _buffer = [ ] ; this . _stopped = false ; this . _period Send Timeout Id = set Timeout ( this . _periodic Send Function . bind ( this ) , this . _send Interval ) ; } 
function Raw RESTkin HTTPTracer ( trace Url , keystone Client ) { if ( trace Url . char At ( trace Url . length - 1 ) = = = ' / ' ) { trace Url = trace Url . slice ( 0 , - 1 ) ; } this . _trace Url = trace Url ; this . _keystone Client = keystone Client ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function RESTkin HTTPTracer ( trace Url , keystone Client , options ) { var raw Tracer = new module . exports . Raw RESTkin HTTPTracer ( trace Url , keystone Client ) ; this . _tracer = new module . exports . Buffering Tracer ( raw Tracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function Raw Zipkin Query Service HTTPTracer ( trace Url ) { if ( trace Url . char At ( trace Url . length - 1 ) = = = ' / ' ) { trace Url = trace Url . slice ( 0 , - 1 ) ; } this . _trace Url = trace Url ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function Zipkin Query Service HTTPTracer ( service Url , options ) { var raw Tracer = new module . exports . Raw Zipkin Query Service HTTPTracer ( service Url ) ; this . _tracer = new module . exports . Buffering Tracer ( raw Tracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function Raw Zipkin Tracer ( scribe Client , category ) { this . scribe Client = scribe Client ; this . category = ( category ) ? category : 'zipkin ' ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function Zipkin Tracer ( scribe Client , category , options ) { var raw Tracer = new Raw Zipkin Tracer ( scribe Client , category ) ; this . _tracer = new Buffering Tracer ( raw Tracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function Raw RESTkin Scribe Tracer ( scribe Client , category ) { this . scribe Client = scribe Client ; this . category = ( category ) ? category : 'restkin ' ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function RESTkin Scribe Tracer ( scribe Client , category , options ) { var raw Tracer = new Raw RESTkin Scribe Tracer ( scribe Client , category ) ; this . _tracer = new module . exports . Buffering Tracer ( raw Tracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; End Annotation Tracer . call ( this , this . send Traces ) ; } 
function build ( gulp ) { 
function chunk ( str , max Len ) { var len = max Len | | OPTIONS . line Width ; var curr = len ; var prev = 0 ; var out = [ ] ; while ( str [ curr ] ) { if ( str [ curr + + ] = = ' ' ) { out . push ( str . substring ( prev , curr ) ) ; prev = curr ; curr + = len ; } } out . push ( str . substr ( prev ) ) ; return out ; } 
function usage ( gulp , options ) { 
function ( options ) { 
function ( options ) { 
function ( information , images ) { 
function Strategy ( options , verify ) { options = options | | { } ; options . authorization URL = options . authorization URL | | 'https : / /api .weibo .com /oauth 2 /authorize ' ; options . token URL = options . token URL | | 'https : / /api .weibo .com /oauth 2 /access _token ' ; options . scope Separator = options . scope Separator | | ' , ' ; options . custom Headers = options . custom Headers | | { } ; if ( ! options . custom Headers [ 'User -Agent ' ] ) { options . custom Headers [ 'User -Agent ' ] = options . user Agent | | 'passport -weibo ' ; } OAuth 2Strategy . call ( this , options , verify ) ; this . name = 'weibo ' ; this . _getuid API = options . getuid API | | 'https : / /api .weibo .com / 2 /account /get _uid .json ' ; this . _get Profile API = options . get Profile API | | 'https : / /api .weibo .com / 2 /users /show .json ' ; } 
function filter Array ( arr , to Keep ) { var i = 0 while ( i < arr . length ) { if ( to Keep ( arr [ i ] ) ) { i + + } else { arr . splice ( i , 1 ) } } } 
function filter And Sort One ( args , adapters ) { var results = decorate And Filter ( args , adapters ) if ( results . length = = = 0 ) { return } 
function filter And Sort ( args , adapters ) { var results = decorate And Filter ( args , adapters ) 
function get Add ( opts ) { opts = opts | | { } var times = opts . times var does Consume = opts . does Consume return function add ( ) { var last Arg = arguments [ arguments . length - 1 ] var func = typeof last Arg = = = 'function ' ? last Arg : function ( ) { return last Arg } var validators = arguments . length > 1 ? Array . prototype . slice . call ( arguments , 0 , - 1 ) : [ ] var new Adapter = { does Consume : does Consume , 
function adapt ( ) { var context = this var args = ut . get Args ( arguments ) var filtered Adapter = ut . filter And Sort One ( args , _adapters ) 
function all ( ) { var context = this var args = ut . get Args ( arguments ) var filtered Adapters = ut . filter And Sort ( args , _adapters ) 
function trigger ( ) { var context = this var args = ut . get Args ( arguments ) var filtered Adapters = ut . filter And Sort ( args , _adapters ) filtered Adapters . for Each ( ut . countdown ) ut . filter Array ( _adapters , ut . not Exausted ) ut . trigger All ( context , args , filtered Adapters ) return or } 
function stick ( ) { var context = this var args = ut . get Args ( arguments ) var filtered Adapters = ut . filter And Sort ( args , _adapters ) var consume Adapters = filtered Adapters . filter ( function ( adapter ) { return adapter . does Consume } ) 
function css Extract ( bundle , opts ) { opts = opts | | { } var out File = opts . out | | opts . o | | 'bundle .css ' var source Map = d ( opts . source Map , bundle & & bundle . _options & & bundle . _options . debug , false ) assert . equal ( typeof bundle , 'object ' , 'bundle should be an object ' ) assert . equal ( typeof opts , 'object ' , 'opts should be an object ' ) 
function fake Occamsrazor ( hidden Property Name , object Property Name , global Obj , custom Attrs ) { return build Fake Object ( hidden Property Name , object Property Name , global Obj , default Attrs . concat ( custom Attrs ) ) } 
function github Compare Commits ( options , parse Options ) { return compare Commits ( options ) . then ( function ( commits ) { return massage Github Commits ( commits , parse Options ) ; } ) ; } 
function compare Commits ( options ) { assert ( "You MUST include 'project ' in the options passed to compare Commits . " + "It should be the path to the project 's git root . " , options . project ) ; assert ( "You MUST include 'base ' in the options passed to compare Commits . " + "It should be either a branch name or tag name . " , options . base ) ; assert ( "You MUST include 'head ' in the options passed to compare Commits . " + "It should be either a branch name or tag name . " , options . head ) ; assert ( "Branch or Tag names passed to compare Commit via 'options .head ' must be strings . " , typeof options . head = = = 'string ' ) ; assert ( "Branch or Tag names passed to compare Commit via 'options .base ' must be strings . " , typeof options . base = = = 'string ' ) ; return get Repository ( options . project ) . then ( function ( repository ) { return RSVP . hash ( { head : get Reference ( repository , options . head ) , base : get Reference ( repository , options . base ) , repository : repository } ) ; } ) . then ( function ( references ) { return RSVP . hash ( { head : get Target Commit ( references . repository , references . head ) , base : get Target Commit ( references . repository , references . base ) , repository : references . repository } ) ; } ) . then ( function ( heads ) { return walk Commits ( heads . repository , heads . head , heads . base ) ; } ) ; } 
function gen Stringify ( options ) { var stringify Fn ; if ( options . headers [ 'Content -Type ' ] & & options . headers [ 'Content -Type ' ] . to Lower Case ( ) = = = 'application /x -www -form -urlencoded ' ) { stringify Fn = querystring . stringify ; } else { switch ( options . method . to Upper Case ( ) ) { case 'POST ' : case 'PUT ' : stringify Fn = JSON . stringify ; break ; } } return stringify Fn ; } 
function decrement ( count ) { count = count | | 0 ; if ( count < = MINUEND ) { count = 0 ; } else { count - = MINUEND ; } return count ; } 
function ( options , params ) { var self = this ; return this . on Before Handle ( ) . then ( function ( ) { 
function ( ) { var self = this ; if ( this . counted ) { return this . get Request Count ( ) . then ( function ( count ) { count = count | | 0 ; 
function ( count ) { var delay Ms = count * config . request Timeout ; if ( this . counted ) { if ( this . get Request Count & & this . save Request Count ) return this . save Request Count ( count ) . delay ( delay Ms ) . then ( this . get Request Count ) . then ( decrement ) . then ( this . save Request Count ) ; } return Promise . resolve ( ) ; } 
function ( hmac , body Data ) { if ( arguments . length < 2 ) { throw param Error ; } var calculated Hmac = crypto . create Hmac ( 'sha 2 5 6 ' , this . token ) . update ( body Data , 'utf 8 ' ) . digest ( 'base 6 4 ' ) ; return hmac = = = calculated Hmac ; } 
function ( token , fn ) { return function ( ) { 
function ( token , option ) { if ( arguments . length < 1 ) { throw param Error ; } check ( option ) ; this . token = token ; this . host = ( option & & option . host ) | | config . api Host ; 
function ( path , query ) { if ( arguments . length < 1 ) { throw param Error ; } return this . request ( 'GET ' , query ? path + ' ? ' + querystring . stringify ( query ) : path , null ) ; } 
function ( method , path , params ) { return this . _request . request ( { hostname : this . host , path : ' /v 1 / ' + path , method : method , headers : { 'Content -Type ' : 'application /json ' , 'X -API -ACCESS -TOKEN ' : this . token } } , params ) ; } 
function ( options ) { if ( arguments . length < 1 | | ! options . app Key | | ! options . app Secret ) { throw param Error ; } if ( ! options . private ) { if ( ! options . callback Url ) { throw param Error ; } options . scope | | ( options . scope = [ 'read _basic ' ] ) ; } this . app _key = options . app Key | | ' ' ; this . app _secret = options . app Secret | | ' ' ; this . private = options . private | | false ; this . callback _url = options . callback Url | | ' ' ; this . scope = options . scope | | ' ' ; this . redirect _url = options . redirect Url | | ' ' ; this . protocol = options . protocol | | config . http Protocol ; this . host = options . host | | config . app Host ; this . _request = new Request ( { protocol : this . protocol , } ) ; } 
function ( query Obj ) { if ( arguments . length < 1 ) { throw param Error ; } var hmac = query Obj . hmac ; delete query Obj . hmac ; return ( Date . now ( ) - new Date ( query Obj . time _stamp ) . get Time ( ) < time Offset ) & & ( hmac = = = crypto . create Hmac ( 'sha 2 5 6 ' , this . app _secret ) . update ( decode URIComponent ( querystring . stringify ( query Obj ) ) , 'utf 8 ' ) . digest ( 'hex ' ) ) ; } 
function ( shop Key , state ) { if ( arguments . length < 1 ) { throw param Error ; } return this . protocol + ' : / / ' + this . host + ' /oauth 2 /authorize ? ' + querystring . stringify ( { response _type : 'code ' , client _id : this . app _key , shop _key : shop Key , scope : this . scope . join ( ' , ' ) , state : state , redirect _uri : this . redirect _url } , null , null , { encode URIComponent : null } ) ; } 
function ( code ) { var params ; var headers = { 'Content -Type ' : 'application /x -www -form -urlencoded ' } ; if ( this . private ) { headers . Authorization = 'Basic ' + Buffer . from ( this . app _key + ' : ' + this . app _secret ) . to String ( 'base 6 4 ' ) ; params = { grant _type : 'client _credentials ' } ; } else { if ( arguments . length < 1 ) { throw param Error ; } params = { grant _type : 'authorization _code ' , code : code , client _id : this . app _key , redirect _uri : this . redirect _url ? this . redirect _url : this . callback _url } ; } var option = { hostname : this . host , path : ' /oauth 2 /token ' , method : 'POST ' , headers : headers } ; return this . _request . request ( option , params ) . then ( function ( data ) { if ( ! data . token . length ) { throw new Error ( '    token ' ) ; } return data . token ; } ) ; } 
function validate Placeholders ( { id , id Plural , translations } , validation Errors ) { 
function validate Translated Placeholders ( { id , translations } , validation Errors ) { 
function group Gettext Items ( gettext Items ) { return gettext Items . filter ( ( item ) = > item . message Id ) 
function traverse Json ( json , callback ) { let { translations } = json ; Object . keys ( translations ) . for Each ( ( namespace ) = > { Object . keys ( translations [ namespace ] ) . for Each ( ( k ) = > { callback ( translations [ namespace ] [ k ] , translations [ namespace ] , k ) ; } ) ; } ) ; } 
function auto Parse ( value , type ) { if ( type ) { return parse Type ( value , type ) } var orignal Value = value if ( value = = = null ) { return null } if ( value = = = void 0 ) { return undefined } if ( value instanceof Date | | value instanceof Reg Exp ) { return value } if ( typeof value = = = 'number ' | | typeof value = = = 'boolean ' ) { return value } if ( typeof value = = = 'function ' ) { return parse Function ( value ) } if ( typeof value = = = 'object ' ) { return parse Object ( value ) } if ( value = = = 'Na N ' ) { return Na N } var json Parsed = null try { json Parsed = JSON . parse ( value ) } catch ( e ) { try { json Parsed = JSON . parse ( value . trim ( ) . replace ( / ( \ \ \ \ " ) | ( \ \ " ) / gi , ' " ' ) . replace ( / ( \ \n | \ \ \ \n ) / gi , ' ' ) . replace ( / ( ^ " | " $ ) | ( ^ ' | ' $ ) / gi , ' ' ) ) } catch ( e ) { } } if ( json Parsed & & typeof json Parsed = = = 'object ' ) { return auto Parse ( json Parsed ) } value = strip Trim Lower ( value ) if ( value = = = 'undefined ' | | value = = = ' ' ) { return undefined } if ( value = = = 'null ' ) { return null } var num = Number ( value ) if ( typpy ( num , Number ) ) { return num } var boo = check Boolean ( value ) if ( typpy ( boo , Boolean ) ) { return boo } return String ( orignal Value ) } 
function trace Webpack Loader ( file ) { var trace Name = ( _ _webpack _require _ _ . p | | ' / ' ) + ' ' + file + ' .bundle .js ' 
function Arango Store ( options , ready Callback ) { options = options | | { } ; if ( options . hash ) { var default Salt = "connect -arango " ; var default Algorithm = "sha 1 " ; this . hash = { } ; this . hash . salt = options . hash . salt ? options . hash . salt : default Salt ; this . hash . algorithm = options . hash . algorithm ? options . hash . algorithm : default Algorithm ; } Store . call ( this , options ) ; if ( ! options . db ) { throw new Error ( 'Required Arango Store option `db ` missing ' ) ; } this . db _collection _name = options . collection | | default Options . collection ; if ( options . stringify | | ( ! ( 'stringify ' in options ) & & ! ( 'serialize ' in options ) & & ! ( 'unserialize ' in options ) ) ) { this . _serialize _session = JSON . stringify ; this . _unserialize _session = JSON . parse ; } else { this . _serialize _session = options . serialize | | default Serializer ; this . _unserialize _session = options . unserialize | | identity ; } var self = this ; var host = options . host | | default Options . host ; var port = options . port | | default Options . port ; if ( typeof options . db = = = 'object ' ) { this . db Helper = new Database Helper ( options . db , self . db _collection _name ) ; } else { this . db Helper = new Database Helper ( { host : host , port : port , username : options . username , password : options . password } ) ; self . db Helper . use ( options . db ) ; } self . db Helper . ensure Collection ( self . db _collection _name , function ( err , db ) { if ( err ) { if ( ready Callback ) { ready Callback ( err ) ; } else { throw e ; } } else { db . index . create Skip List Index ( self . db _collection _name , [ "expires " ] , false ) . then ( function ( res ) { if ( ready Callback ) { ready Callback ( ) ; } } , function ( err ) { debug ( "Unable to create skip -list " ) ; if ( ready Callback ) { ready Callback ( err ) ; } } ) . catch ( function ( e ) { throw e ; } ) ; } } ) ; this . db _clear _expires _time = 0 ; this . db _clear _expires _interval = options . clear _interval | | default Options . clear _interval ; } 
function find All Dependencies ( file , known Dependencies , source Directories , known Files ) { if ( ! known Dependencies ) { known Dependencies = [ ] ; } if ( typeof known Files = = = "undefined " ) { known Files = [ ] ; } else if ( known Files . index Of ( file ) > - 1 ) { return known Dependencies ; } if ( source Directories ) { return find All Dependencies Help ( file , known Dependencies , source Directories , known Files ) . then ( function ( thing ) { return thing . known Dependencies ; } ) ; } else { return get Base Dir ( file ) . then ( get Elm Package Source Directories ) . then ( function ( new Source Dirs ) { return find All Dependencies Help ( file , known Dependencies , new Source Dirs , known Files ) . then ( function ( thing ) { return thing . known Dependencies ; } ) ; } ) ; } } 
function get Elm Package Source Directories ( base Dir , current Dir ) { if ( typeof current Dir = = = "undefined " ) { base Dir = path . resolve ( base Dir ) ; current Dir = base Dir ; } var elm Package Path = path . join ( current Dir , 'elm .json ' ) ; if ( fs . exists Sync ( elm Package Path ) ) { var source Directories = get Source Directories ( elm Package Path ) ; if ( _ . includes ( source Directories , base Dir ) ) { return source Directories ; } } if ( is Root ( current Dir ) ) { return [ ] ; } return get Elm Package Source Directories ( base Dir , path . dirname ( current Dir ) ) ; } 
function read Imports ( file ) { return new Promise ( function ( resolve , reject ) { 
function inline Style ( file Content , file Path ) { return file Content . replace ( / style Urls \s * : \s * \ [ ( . + ) \ ] / g , ( _match , template Url ) = > { let style Content = ' ' const style List = template Url . replace ( / ' | \s / g , ' ' ) . split ( ' , ' ) style List . for Each ( s = > { const style Path = path . join ( path . dirname ( file Path ) , s ) style Content + = load Resource File ( style Path ) } ) return ` \ [ \ ` $ { style Content } \ ` \ ] ` } ) } 
function change Version ( ) { log . info ( 'Updating version number . . . ' ) ; const package Json = path . join ( _ _dirname , ' . . /components /package .json ' ) ; const current Version = fs . read File Sync ( package Json , 'utf - 8 ' ) . match ( / "version " : " ( [ 0 - 9 . ] + ) " / ) [ 1 ] ; let version Number Valid = false ; let version ; function check Version Number ( cur , next ) { 
function is Element ( node , tag Names ) { var name if ( ! ( tag Names = = = null | | tag Names = = = undefined | | typeof tag Names = = = 'string ' | | ( typeof tag Names = = = 'object ' & & tag Names . length ! = = 0 ) ) ) { throw new Error ( 'Expected `string ` or `Array . <string > ` for `tag Names ` , not ` ' + tag Names + ' ` ' ) } if ( ! node | | typeof node ! = = 'object ' | | node . type ! = = 'element ' | | typeof node . tag Name ! = = 'string ' ) { return false } if ( tag Names = = = null | | tag Names = = = undefined ) { return true } name = node . tag Name if ( typeof tag Names = = = 'string ' ) { return name = = = tag Names } return tag Names . index Of ( name ) ! = = - 1 } 
function parse ( query ) { if ( query [ 0 ] = = " ? " ) query = query . slice ( 1 ) ; var pairs = query . split ( " & " ) , obj = { } ; for ( var i in pairs ) { var pair = pairs [ i ] . split ( " = " ) , key = decode URIComponent ( pair [ 0 ] ) , value = pair [ 1 ] ? decode URIComponent ( pair [ 1 ] ) : " " ; obj [ key ] = value ; } return obj ; } 
function stringify ( obj ) { var arr = [ ] ; for ( var x in obj ) { arr . push ( encode URIComponent ( x ) + " = " + encode URIComponent ( obj [ x ] ) ) ; } return arr . join ( " & " ) ; } 
function replace Link ( target ) { var lang = Query String . parse ( location . search ) . lang ; if ( lang ) { target = target | | $ ( "body " ) ; target . find ( "a " ) . each ( function ( ) { var href = $ ( this ) . attr ( "href " ) , query = Query String . parse ( href ) ; if ( href . index Of ( "javascript : " ) ! = = 0 & & href . index Of ( "http " ) ! = = 0 & & href . index Of ( " # " ) ! = = 0 & & ! query . lang ) { href = Query String . set Url ( href , { lang : lang } ) ; $ ( this ) . attr ( "href " , href ) ; } } ) } } 
function initialize ( middleware Opts ) { const logger = middleware Opts . logger . fork ( 'Bindings Docs ' ) , ensure Authenticated = middleware Opts . ensure Authenticated ; function serve Python Doc File ( root Dir , file Name , res , logger ) { const options = { root : root Dir , dotfiles : 'deny ' , headers : { 'x -timestamp ' : Date . now ( ) , 'x -sent ' : true } } ; res . send File ( file Name , options , function ( err ) { if ( err ) { logger . error ( 'Failed to send ' + file Name , err ) ; res . status ( err . status ) . end ( ) ; } } ) ; } 
function murmurhash ( str ) { let l = str . length | 0 , h = l | 0 , i = 0 , k ; while ( l > = 4 ) { k = ( ( str . char Code At ( i ) & 0xff ) ) | ( ( str . char Code At ( + + i ) & 0xff ) < < 8 ) | ( ( str . char Code At ( + + i ) & 0xff ) < < 1 6 ) | ( ( str . char Code At ( + + i ) & 0xff ) < < 2 4 ) ; k = ( ( ( k & 0xffff ) * 0x 5bd 1e 9 9 5 ) + ( ( ( ( k > > > 1 6 ) * 0x 5bd 1e 9 9 5 ) & 0xffff ) < < 1 6 ) ) ; k ^ = k > > > 2 4 ; k = ( ( ( k & 0xffff ) * 0x 5bd 1e 9 9 5 ) + ( ( ( ( k > > > 1 6 ) * 0x 5bd 1e 9 9 5 ) & 0xffff ) < < 1 6 ) ) ; h = ( ( ( h & 0xffff ) * 0x 5bd 1e 9 9 5 ) + ( ( ( ( h > > > 1 6 ) * 0x 5bd 1e 9 9 5 ) & 0xffff ) < < 1 6 ) ) ^ k ; l - = 4 ; + + i ; } switch ( l ) { case 3 : h ^ = ( str . char Code At ( i + 2 ) & 0xff ) < < 1 6 ; case 2 : h ^ = ( str . char Code At ( i + 1 ) & 0xff ) < < 8 ; case 1 : h ^ = ( str . char Code At ( i ) & 0xff ) ; h = ( ( ( h & 0xffff ) * 0x 5bd 1e 9 9 5 ) + ( ( ( ( h > > > 1 6 ) * 0x 5bd 1e 9 9 5 ) & 0xffff ) < < 1 6 ) ) ; } h ^ = h > > > 1 3 ; h = ( ( ( h & 0xffff ) * 0x 5bd 1e 9 9 5 ) + ( ( ( ( h > > > 1 6 ) * 0x 5bd 1e 9 9 5 ) & 0xffff ) < < 1 6 ) ) ; h ^ = h > > > 1 5 ; return h > > > 0 ; } 
function _set Object ( obj ) { var args = arguments , o = obj , len = args . length , 
function unique Sort ( arr , is Sorted ) { if ( is Sorted = = null ) is Sorted = false if ( ! is Sorted ) arr . sort ( ) var out = [ ] , ix , item for ( ix = 0 ; ix < arr . length ; ix + + ) { item = arr [ ix ] if ( ix > 0 & & arr [ ix - 1 ] = = = arr [ ix ] ) continue out . push ( item ) } return out } 
function _d ( ) { for ( var ix = 0 ; ix < arguments . length ; ix + + ) if ( arguments [ ix ] ! = null ) return arguments [ ix ] return null } 
function _e ( fn , msg ) { msg = _d ( msg , fn , ' ' ) fn = _d ( fn , 0 ) var pfx = "oj : " if ( fn ) pfx = "oj . " + fn + " : " throw new Error ( pfx + msg ) } 
function _v ( fn , n , v , type ) { n = { 1 : 'first ' , 2 : 'second ' , 3 : 'third ' , 4 : 'fourth ' } [ n ] _a ( ! type | | ( typeof v = = = type ) , fn , " " + type + " expected for " + n + " argument " ) } 
function _split And Trim ( str , seperator , limit ) { return str . split ( seperator , limit ) . map ( function ( v ) { return v . trim ( ) } ) } 
function _get Instance On Element ( el ) { if ( ( el ! = null ? el . oj : 0 ) ! = null ) return el . oj else return null } 
function _flatten CSSMap ( css Map ) { var flat Map = { } , plugin , css Map _ for ( plugin in css Map ) { css Map _ = css Map [ plugin ] _flatten CSSMap _ ( css Map _ , flat Map , [ ' ' ] , [ ' ' ] , plugin ) } return flat Map } 
function _flatten CSSMap _ ( css Map , flat Map Acc , selectors Acc , medias Acc , plugin ) { 
function _css From Plugin Object ( flat CSSMap , options ) { options = _d ( options , { } ) var media Map , plugin , minify = options . minify ! = null ? options . minify : 0 , tags = options . tags ! = null ? options . tags : 0 , 
function _compile Any ( any , options ) { 
function _compile Tag ( ojml , options ) { 
function _attributes Processed For OJ ( attr ) { var jq Events = { bind : 1 , on : 1 , off : 1 , live : 1 , blur : 1 , change : 1 , click : 1 , dblclick : 1 , focus : 1 , focusin : 1 , focusout : 1 , hover : 1 , keydown : 1 , keypress : 1 , keyup : 1 , mousedown : 1 , mouseenter : 1 , mouseleave : 1 , mousemove : 1 , mouseout : 1 , mouseup : 1 , ready : 1 , resize : 1 , scroll : 1 , select : 1 , insert : 1 } , events , k , v 
function _attributes Bind Events To DOM ( events , el , inserts ) { var ek , ev , _results = [ ] for ( ek in events ) { ev = events [ ek ] _a ( oj . $ ! = null , "jquery is missing when binding a ' " + ek + " ' event " ) 
function ( k , v ) { var key , obj = k , value 
function ( ) { var json = { } , prop , ix = 0 for ( ; ix < this . properties . length ; ix + + ) { prop = this . properties [ ix ] json [ prop ] = this [ prop ] } return json } 
function ( ) { _a ( oj . is DOM ( this . el ) , this . type Name , 'constructor did not set this .el ' ) 
function ( ) { 
function ( ix , count , message ) { var ix New = ix < 0 ? ix + count : ix if ( ! ( 0 < = ix New & & ix New < count ) ) _e ( this . type Name , message + " is out of bounds ( " + ix + " in [ 0 , " + ( count - 1 ) + " ] ) " ) return ix New } 
function ( ) { if ( ! this . is Constructed ) return 
function ( rx , list OJML ) { rx = this . _bound ( rx , this . row Count , " .row : rx " ) if ( list OJML ! = null ) { _a ( list OJML . length = = = cell Count ( rx ) , this . type Name , "array expected for second argument with length ( " + rx + " ) " ) 
function ( rx , list OJML ) { if ( list OJML = = null ) { list OJML = rx rx = - 1 } rx = this . _bound ( rx , this . row Count + 1 , " .add Row : rx " ) _a ( oj . is Array ( list OJML ) , 'add Row ' , 'expected array for row content ' ) this . _add Row TR ( rx , function ( ) { oj . tr ( function ( ) { list OJML . for Each ( function ( cell ) { oj . td ( cell ) } ) } ) } ) } 
function ( rx , tr ) { 
function ( ix , count , message ) { var ix New = ix < 0 ? ix + count : ix if ( ! ( 0 < = ix New & & ix New < count ) ) { throw new Error ( "oj . " + this . type Name + message + " is out of bounds ( " + ix + " in [ 0 , " + ( count - 1 ) + " ] ) " ) } return ix New } 
function ( $el , args ) { 
function ( attributes ) { var attr = _clone ( attributes ) , events = _attributes Processed For OJ ( attr ) , k , v 
function ( ix , ojml ) { ix = this . _bound ( ix , this . count , " .item : index " ) if ( ojml ! = null ) { if ( typeof ojml = = 'object ' & & ojml . is List Item ) this . $item ( ix ) . oj Replace With ( ojml ) else this . $item ( ix ) . oj ( ojml ) this . items Changed ( ) } else return this . $item ( ix ) . oj Value ( ) } 
function ( model ) { var _t = this if ( oj . is OJType ( _t . each ) ) return new _t . each ( model ) return oj ( function ( ) { return _t . each ( model ) } ) } 
function ( ix , ojml ) { 
function _jq Get Value ( $el , args ) { var el = $el [ 0 ] , child = el . first Child 
function _style From Object ( obj , options ) { options = _extend ( { inline : true , indent : ' ' } , options ) 
function _attributes From Object ( obj ) { if ( ! oj . is Plain Object ( obj ) ) return obj 
function _css From Media Object ( media Map , options ) { options = _d ( options , { } ) var indent , indent Rule , media , rules , selector , selector Map , space , styles , minify = options . minify ! = null ? options . minify : 0 , tags = options . tags ! = null ? options . tags : 0 , 
function _inherit ( Child , Parent ) { var Ctor , prop 
function ( k ) { 
function ( rx ) { if ( rx = = null ) rx = - 1 rx = this . _bound ( rx , this . row Count , " .remove Row : index " ) ; var out = this . row ( rx ) this . $tr ( rx ) . remove ( ) this . body Changed ( ) return out } 
function ( describe , file Buffer ) { if ( describe & & ! util . is Array ( describe ) & & describe . m ) { 
function ( describe , file Info ) { if ( ! describe | | ! util . is Array ( describe ) ) { return when . reject ( 'wrong describe payload given ' ) ; } if ( ! file Info ) { return when . reject ( 'no file Info provided ' ) ; } console . log ( 'resolving dependencies for ' , file Info . filename ) ; var that = this ; return pipeline ( [ function ( ) { 
function ( filename ) { if ( ! fs . exists Sync ( filename ) ) { return false ; } if ( ! this . _module Storage ) { this . _module Storage = [ ] ; } var that = this ; var parser = new Hal Module Parser ( ) ; return parser . parse File ( filename ) . then ( function ( file Info ) { file Info . describe = that . _binary To Describe ( file Info . prefix Info ) ; that . _module Storage . push ( file Info ) ; } , function ( err ) { console . error ( 'assimilate Module err : ' , err ) ; } ) ; } 
function ( modules ) { 
function ( device Modules , binary Info ) { var safe Device Modules = this . _repair Describe Errors ( device Modules ) ; var safe Binary Requires = this . _binary Deps To Describe ( binary Info ) ; var safe Binary Requires 2 = this . _binary Deps To Describe ( binary Info , 2 ) ; var result = this . _walk Chain ( safe Device Modules , safe Binary Requires ) ; this . _walk Chain ( safe Device Modules , safe Binary Requires 2 , result ) ; return result ; } 
function ( device Modules , firmware Module ) { var safe Device Modules = this . _repair Describe Errors ( device Modules ) ; var safe Module Requires = firmware Module . to Describe ( ) ; return this . _walk Chain ( safe Device Modules , safe Module Requires ) ; } 
function ( describe ) { if ( ! Array . is Array ( describe . m ) ) { return when . reject ( 'no modules in describe message ' ) ; } var modules = [ ] ; var user Module = null ; for ( var i = 0 ; i < describe . m . length ; i + + ) { var module = new Firmware Module ( describe . m [ i ] ) ; 
function ( describe ) { if ( ! Array . is Array ( describe . m ) ) { return when . reject ( 'no modules in describe message ' ) ; } var all Deps = [ ] ; var modules = describe . m ; for ( var i = 0 ; i < modules . length ; i + + ) { var check Module = modules [ i ] ; 
function ( modules , needs , arr ) { arr = arr | | [ ] ; 
function ( describe Info ) { var arr = describe Info ; 
function ( module Function ) { var result ; 
function ( binary Info , dep ) { var result = { } ; dep = dep | | 1 ; var dep String = ' ' ; if ( dep > 1 ) { dep String = ' ' + dep ; } if ( ! binary Info ) { return result ; } var keys = Object . keys ( binary Info ) ; 
function ( left , right ) { if ( ( left = = = null ) & & ( right = = = null ) ) { return true ; } else if ( ( left = = = null ) | | ( right = = = null ) ) { return false ; } if ( ! Buffer . is Buffer ( left ) ) { left = new Buffer ( left ) ; } if ( ! Buffer . is Buffer ( right ) ) { right = new Buffer ( right ) ; } var same = ( left . length = = = right . length ) , i = 0 , max = left . length ; while ( i < max ) { same & = ( left [ i ] = = right [ i ] ) ; 
function ( filename , callback ) { var file Info = { filename : filename } ; var that = this ; var all Done = pipeline ( [ function ( ) { return that . _load File ( filename ) ; } , function ( file Buffer ) { file Info . file Buffer = file Buffer ; return that . parse Buffer ( file Info ) ; } ] ) ; if ( callback ) { when ( all Done ) . then ( function ( info ) { callback ( info , null ) ; } , function ( err ) { callback ( null , err ) ; } ) ; } return all Done ; } 
function ( file Info , callback ) { if ( ! Buffer . is Buffer ( file Info . file Buffer ) ) { return when . reject ( 'file Buffer was invalid ' ) ; } var that = this ; var all Done = pipeline ( [ function ( ) { return that . _validate CRC ( file Info . file Buffer ) ; } , function ( crc Info ) { file Info . crc = crc Info ; return that . _read Prefix ( file Info . file Buffer ) ; } , function ( prefix Info ) { file Info . prefix Info = prefix Info ; return that . _read Suffix ( file Info . file Buffer ) ; } , function ( suffix Info ) { file Info . suffix Info = suffix Info ; return when . resolve ( ) ; } , function ( ) { return file Info ; } ] ) ; if ( callback ) { when ( all Done ) . then ( function ( info ) { callback ( info , null ) ; } , function ( err ) { callback ( null , err ) ; } ) ; } return all Done ; } 
function ( filename ) { if ( ! fs . exists Sync ( filename ) ) { return when . reject ( filename + ' doesn \ 't exist ' ) ; } var file Buffer = fs . read File Sync ( filename ) ; if ( ! file Buffer | | ( file Buffer . length = = = 0 ) ) { return when . reject ( filename + ' was empty ! ' ) ; } return when . resolve ( file Buffer ) ; } 
function ( file Buffer ) { if ( ! file Buffer | | ( file Buffer . length = = = 0 ) ) { 
function ( file Buffer ) { 
function ( file Buffer ) { var prefix Offset = this . _divine Module Prefix Offset ( file Buffer ) ; var r = new buffers . Buffer Reader ( file Buffer ) ; 
function ( file Buffer ) { 
async function main ( ) { 
function Shortline ( options ) { const self = this ; self . _input = ( options & & options . input ) | | process . stdin ; self . _output = ( options & & options . output ) | | process . stderr ; self . input Error = null ; self . _input . on ( 'end ' , ( ) = > { self . input Error = new EOFError ( EOF _MESSAGE ) ; } ) ; 
function find Elements ( node , name ) { return name in node & & Array . is Array ( node [ name ] ) ? node [ name ] : [ ] ; } 
async function main ( ) { 
function Travis Status Http ( endpoint , options ) { if ( endpoint & & typeof endpoint ! = = 'string ' ) { throw new Type Error ( 'endpoint must be a string ' ) ; } endpoint = endpoint & & trim Slash ( endpoint ) ; if ( options & & typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } options = Object . assign ( { gzip : true } , options ) ; options . headers = Object . assign ( { } , options . headers ) ; 
function git ( . . . args ) { return new Promise ( ( resolve , reject ) = > { const child = exec File ( 'git ' , args , ( err , stdout , stderr ) = > { if ( err ) { reject ( err ) ; } else { 
function travis Status Cmd ( args , options , callback ) { if ( ! callback & & typeof options = = = 'function ' ) { callback = options ; options = null ; } if ( ! callback ) { return new Promise ( ( resolve , reject ) = > { travis Status Cmd ( args , options , ( err , result ) = > { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; } ) ; } if ( typeof callback ! = = 'function ' ) { throw new Type Error ( 'callback must be a function ' ) ; } try { if ( args = = = undefined | | args = = = null | | args . length = = = 0 ) { 
function Slug Detection Error ( message ) { if ( ! ( this instanceof Slug Detection Error ) ) { return new Slug Detection Error ( message ) ; } Error . capture Stack Trace ( this , Slug Detection Error ) ; 
function create Scoped Css ( html , scope , filepath , css Variables ) { scope = typeof scope = = = 'string ' ? { ns : scope , vars : new Map ( ) } : scope ; const style = html . match ( style Matcher ) ; if ( ! style ) { return [ { } , scope . vars , ' ' ] ; } const cssom = css . parse ( style [ 1 ] , { source : filepath } ) ; const vars = new Map ( scope . vars . entries ( ) ) ; get Variables ( cssom ) . for Each ( ( value , key ) = > vars . set ( key , value ) ) ; if ( css Variables ) { resolve Scope Variables ( cssom , vars ) ; } const [ classes , transform Map ] = rewrite Selectors ( ` $ { decamelize ( scope . ns , ' - ' ) } ` , cssom ) ; return [ classes , vars , css . stringify ( cssom ) , transform Map ] ; } 
function create Hash ( input ) { let hash = 0 ; if ( input . length = = = 0 ) { return hash ; } for ( let i = 0 ; i < input . length ; i + + ) { const char = input . char Code At ( i ) ; hash = ( ( hash < < 5 ) - hash ) + char ; 
function combine Css ( templates , scoped Css ) { if ( ! Array . is Array ( scoped Css ) ) { scoped Css = [ scoped Css ] ; } return [ . . . Object . keys ( templates ) . map ( name = > templates [ name ] . css ) , . . . scoped Css ] . join ( ' \n ' ) . trim ( ) ; } 
function Invalid Slug Error ( message ) { if ( ! ( this instanceof Invalid Slug Error ) ) { return new Invalid Slug Error ( message ) ; } Error . capture Stack Trace ( this , Invalid Slug Error ) ; 
function check Build Commit ( build , local Commit ) { const build Commit = build . commit ; let message = ` $ { build Commit . sha } $ { local Commit . sha } ` ; if ( local Commit . name ) { message + = ` $ { local Commit . name } ` ; } 
function travis Status ( options , callback ) { if ( ! callback & & typeof options = = = 'function ' ) { callback = options ; options = null ; } if ( callback & & typeof callback ! = = 'function ' ) { throw new Type Error ( 'callback must be a function ' ) ; } let agent , git Checker , travis Checker ; try { if ( options & & typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } options = options | | { } ; if ( options . repo ) { Git Status Checker . check Slug Format ( options . repo ) ; } if ( options . store Repo ) { Git Status Checker . check Slug Format ( options . store Repo ) ; } 
function trim Slash ( string ) { if ( typeof string ! = = 'string ' ) { return string ; } if ( string . length > 0 & & string . char At ( string . length - 1 ) = = = ' / ' ) { return string . slice ( 0 , string . length - 1 ) ; } return string ; } 
function parse Options ( opts ) { return remove Empty ( { plugins : convert Fn . call ( this , opts . plugins ) , locals : convert Fn . call ( this , opts . locals ) , filename : convert Fn . call ( this , opts . filename ) , parser Options : convert Fn . call ( this , opts . parser Options ) , generator Options : convert Fn . call ( this , opts . generator Options ) , runtime : convert Fn . call ( this , opts . runtime ) , parser : convert Fn Special . call ( this , opts . parser ) , multi : convert Fn . call ( this , opts . multi ) } ) } 
function serialize Verbatim ( obj ) { let i = 0 const fns = [ ] let res = JSON . stringify ( obj , ( k , v ) = > { if ( typeof v = = = 'function ' ) { fns . push ( v . to String ( ) ) return ` $ { i + + } ` } else { return v } } ) res = res . replace ( / " _ _REPLACE ( \d { 1 } ) " / g , ( m , v ) = > { return fns [ v ] } ) return res } 
function render Pages ( filepaths , dest , { templates , vars , statics , disable Validation , css Variables , host } ) { console . log ( ` \n ` ) ; return Promise . all ( filepaths . map ( filepath = > { return sander . read File ( filepath ) . then ( content = > render Page ( content , filepath , { templates , vars , dest , css Variables } ) ) . then ( ( [ html , destination Path , css Parts ] ) = > sander . write File ( destination Path , html ) . then ( ( ) = > [ destination Path , css Parts ] ) ) . then ( ( [ destination Path , css Parts ] ) = > { console . log ( ` $ { chalk . bold . green ( figures . tick ) } $ { filepath } $ { destination Path } ` ) ; return [ destination Path , css Parts ] ; } ) ; } ) ) . then ( page Results = > disable Validation | | validate Pages ( host , dest , page Results . map ( result = > result [ 0 ] ) , statics ) . then ( ( ) = > page Results . map ( result = > result [ 1 ] ) ) ) ; } 
function Travis Status Checker ( options ) { if ( options & & typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } options = options | | { } ; const api Endpoint = options . api Endpoint & & trim Slash ( options . api Endpoint ) ; this . _travis = new Travis ( { pro : api Endpoint = = = constants . PRO _URI , version : ' 2 . 0 . 0 ' } ) ; this . _travis . agent = new Travis Status Http ( api Endpoint , options . request Opts ) ; if ( options . token ) { this . _travis . agent . set Access Token ( options . token ) ; } } 
function query With Wait ( query , value Is Pending , options ) { const max Wait Ms = options & & options . wait ? Number ( options . wait ) : 0 ; if ( Number . is Na N ( max Wait Ms ) ) { return Promise . reject ( new Type Error ( 'wait must be a number ' ) ) ; } if ( max Wait Ms < 0 ) { return Promise . reject ( new Range Error ( 'wait must be non -negative ' ) ) ; } const start Ms = Date . now ( ) ; 
function ( input ) { var result = / @charset \s + [ ' | " ] ( \w * ) [ " | ' ] ; / . exec ( input ) , charset = 'UTF - 8 ' ; if ( result & & result [ 1 ] ) { charset = result [ 1 ] ; } 
function ( text ) { text = escape ( text . to String ( ) ) . replace ( / \ + / g , " % 2B " ) ; var matches = text . match ( / ( % ( [ 0 - 9A -F ] { 2 } ) ) / gi ) ; if ( matches ) { for ( var matchid = 0 ; matchid < matches . length ; matchid + + ) { var code = matches [ matchid ] . substring ( 1 , 3 ) ; if ( parse Int ( code , 1 6 ) > = 1 2 8 ) { text = text . replace ( matches [ matchid ] , ' %u 0 0 ' + code ) ; } } } text = text . replace ( ' % 2 5 ' , ' %u 0 0 2 5 ' ) ; return text ; } 
function ( content ) { var reg = / @import \s * (url ) ? \s * [ \ ( ' " ] + ( [ ^ ' " ] + ) \ .css ( \ ? [ ^ \s ] * ) ? \s * [ ' " \ ) ] + \s * [ ^ ; ] * ; / ig ; var result = reg . exec ( content ) ; if ( result & & result [ 2 ] ) { return { match : result [ 0 ] , file Path : result [ 2 ] + ' .css ' } ; } return null ; } 
function ( content , file Path ) { 'use strict ' ; var self = this ; var reg Import = / @import \s * (url ) ? \ ( ? [ ' " ] ( [ ^ ' " % ] + ) \ .css [ ' " ] \ ) ? [ ^ ; ] * ; / ig , reg Image Or Font = / (url ) ? \ ( [ ' " ] ? ( [ ^ : \ ) ] + \ . (png |jpg |gif |jpeg |ttf |eot |woff |svg ) ) ( [ ^ \ ) ] * ) [ ' " ] ? \ ) / ig , import Result , pic And Font Result ; var import File Path = path . dirname ( path . resolve ( self . config . source Dir , file Path ) ) ; / /  import import Result = reg Import . exec ( content ) ; if ( typeof import Result ! = = 'undefined ' & & import Result & & import Result [ 2 ] ) { var import Absolute Url = path . resolve ( import File Path , import Result [ 2 ] ) ; / /  %         import             ,       / /          var regimport Replace = new Reg Exp ( import Result [ 2 ] , 'g ' ) ; content = content . replace ( regimport Replace , " % " + path . relative ( self . config . source Dir , import Absolute Url ) ) ; return self . modify Sub Imports Path ( content , file Path ) ; } / /     font    pic And Font Result = reg Image Or Font . exec ( content ) ; if ( typeof pic And Font Result ! = = 'undefined ' & & pic And Font Result & & pic And Font Result [ 2 ] & & ! / ^ \ / \ / [ ^ \ / ] + / . test ( pic And Font Result [ 2 ] ) ) { var regpic Replace = new Reg Exp ( pic And Font Result [ 2 ] , 'g ' ) ; var pic Absolute Path = path . resolve ( import File Path , pic And Font Result [ 2 ] ) ; / /  win           var is Win = ( process . platform = = = 'win 3 2 ' ) ; var _path = path . relative ( self . config . source Dir , pic Absolute Path ) ; if ( is Win ) { _path = path . relative ( self . config . source Dir , pic Absolute Path ) . split ( path . sep ) . join ( " \ / " ) ; } / /           import            content = content . replace ( regpic Replace , " : " + _path ) ; return self . modify Sub Imports Path ( content , file Path ) ; } return content ; } 
function Git Status Checker ( options ) { if ( options & & typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } options = Object . assign ( { in : process . stdin , out : process . stdout , err : process . stderr } , options ) ; if ( ! options . in | | typeof options . in . read ! = = 'function ' ) { throw new Type Error ( 'options .in must be a stream .Readable ' ) ; } if ( ! options . out | | typeof options . out . write ! = = 'function ' ) { throw new Type Error ( 'options .out must be a stream .Writable ' ) ; } if ( ! options . err | | typeof options . err . write ! = = 'function ' ) { throw new Type Error ( 'options .err must be a stream .Writable ' ) ; } this . _options = options ; this . _chalk = new Chalk ( { enabled : Boolean ( options . interactive ! = = undefined ? options . interactive : options . out . is TTY ) } ) ; } 
function git Url Path ( git Url ) { 
function ( ) { var app Env = this . app . env ; if ( process . env . DEPLOY _TARGET ) { app Env = process . env . DEPLOY _TARGET ; } var public Files = new Funnel ( this . app . trees . public ) ; this . _require Build Packages ( ) ; fs . stat ( path . join ( this . project . root , 'public ' , 'robots .txt ' ) , function ( err , stats ) { if ( stats & & stats . is File ( ) ) { console . log ( chalk . yellow ( 'There is a robots .txt in /public and ENV specific robots .txt are ignored ! ' ) ) ; } } ) ; public Files = stew . rename ( public Files , 'robots - ' + app Env + ' .txt ' , 'robots .txt ' ) ; return new Funnel ( public Files , { src Dir : ' / ' , dest Dir : ' / ' } ) ; } 
function Balance Sheet ( options ) { * # # # Balance Sheet .options * * Reference to current configuration * * / this . options = options | | { } ; * # # # Balance Sheet .init * * Configures the Balance Sheet instance * * Takes the configuration as an input parameter or * recycles the settings in `this .options ` . * * The configuration object is of the type * * var options = { * return At : 'first ' , * triggers : [ my Func , * my Func 2 * ] , * } * * @param {object } options Optional . Configuration object * * / Balance Sheet . prototype . init = function ( options ) { this . options = options | | this . options ; if ( this . options . return At = = = Balance Sheet . first | | this . options . return At = = = Balance Sheet . last ) { this . return At = this . options . return At ; } this . reset Triggers ( ) ; } ; 
function Group ( ) { this . elements = [ ] ; this . matched = [ ] ; this . left Over = [ ] ; this . pointer = 0 ; this . matches = { } ; this . matches . total = 0 ; this . matches . requested = 0 ; this . matches . done = false ; this . row Limit = 3 ; this . no Self = true ; this . pool = [ ] ; this . shuffle = true ; this . stretch = true ; } 
function Group ( options ) { this . name = null ; this . elements = [ ] ; this . pool = [ ] ; this . matched = [ ] ; this . left Over = [ ] ; this . pointer = 0 ; this . matches = { total : 0 , requested : 0 , done : false } ; this . row Limit = 1 ; this . no Self = true ; this . shuffle = true ; this . stretch = true ; 
function simulate Match ( N ) { for ( var i = 0 ; i < N ; i + + ) { var rm = new RMatcher ( ) , elements = get Elements ( ) , pools = get Pools ( ) ; 
function Socket Direct ( node , options ) { options = options | | { } ; * # # # Socket Direct .node * * Reference to the node object . * / this . node = node ; this . socket = options . socket ; this . connected = false ; } 
function my Game ( ) { this . solo _mode = false ; this . auto _wait = false ; this . auto _step = false ; this . observer = false ; this . min Players = 1 ; this . max Players = 1 0 0 0 ; } 
function Game Session ( node ) { Session Manager . call ( this ) ; this . node = node ; 
function compile Index ( ) { fs . read File ( path . join ( _ _dirname , 'templates ' , 'index .hogan ' ) , function ( err , data ) { if ( err ) throw err ; 
function sort Mentions ( mentions ) { return mentions . slice ( ) . sort ( ( a , b ) = > b . length - a . length ) ; } 
function find Emoji ( names , match ) { const compare = match . to Lower Case ( ) ; for ( let i = 0 ; i < names . length ; i + = 1 ) { const name = names [ i ] . to Lower Case ( ) ; if ( name = = = compare ) { return names [ i ] ; } } return null ; } 
function _request ( path , method , headers , body , with Credentials , callback ) { const xhr = new XMLHttp Request ( { } ) ; 
function Rpc Message ( opts ) { assert . object ( opts , 'options ' ) ; assert . bool ( opts . incoming , 'options .incoming ' ) ; assert . optional Number ( opts . type , 'options .type ' ) ; assert . optional Number ( opts . xid , 'options .xid ' ) ; stream . Transform . call ( this , opts ) ; this . type = opts . type ; this . xid = opts . xid ; this . incoming = opts . incoming ; this . _rpc _wrote _head = false ; this . _rpc _message = true ; 
function parse Auth ( xdr ) { assert . object ( xdr , 'xdr ' ) ; var msg = { } ; var type = xdr . read Int ( ) ; var len = xdr . read Int ( ) ; switch ( type ) { case 0 : 
function Portmap Get Port Call ( opts ) { Rpc Call . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 } ; this . _rpc _portmap _get _port _call = true ; 
function Rpc Client ( opts ) { assert . object ( opts , 'options ' ) ; assert . object ( opts . log , 'options .log ' ) ; assert . number ( opts . program , 'options .program ' ) ; assert . number ( opts . version , 'options .version ' ) ; assert . string ( opts . url , 'options .url ' ) ; Event Emitter . call ( this , opts ) ; var self = this ; this . conn = null ; this . log = opts . log . child ( { component : 'Rpc Client ' , serializers : require ( ' . /bunyan ' ) . serializers } ) ; this . messages = { } ; this . program = opts . program ; this . url = mod _url . parse ( opts . url ) ; this . version = opts . version ; var ID = 0 ; this . _next _xid = function ( ) { if ( + + ID = = = ( Math . pow ( 2 , 3 2 ) - 1 ) ) ID = 0 ; return ( ID ) ; } ; this . _rpc _client = true ; 
function Rpc Call ( opts ) { assert . object ( opts , 'options ' ) ; Rpc Message . call ( this , opts ) ; this . rpcvers = opts . rpcvers | | 2 ; this . prog = opts . prog ; this . vers = opts . vers ; this . proc = opts . proc ; this . auth = opts . auth | | { } ; this . verifier = opts . verifier ; this . type = 0 ; this . _buffer = null ; this . _rpc _call = true ; 
function Portmap Set Call ( opts ) { Rpc Call . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 , port : 0 } ; this . _rpc _portmap _set _call = true ; 
function Rpc Error ( cause , msg ) { var off = 0 ; if ( cause instanceof Error ) off = 1 ; var args = Array . prototype . slice . call ( arguments , off ) ; args . unshift ( { cause : off ? cause : undefined , ctor : Rpc Error } ) ; WError . apply ( this , args ) ; this . type = 1 ; 
function Portmap Client ( opts ) { assert . object ( opts , 'options ' ) ; if ( opts . log ) { var l = opts . log ; delete opts . log ; } var _opts = clone ( opts ) ; _opts . log = opts . log = l ; _opts . name = 'portmap ' ; _opts . program = 1 0 0 0 0 0 ; _opts . version = 2 ; Rpc Client . call ( this , _opts ) ; } 
function if Error ( n ) { function _if Error ( err ) { if ( err ) { err . _rpc _next = n ; throw err ; } } return ( _if Error ) ; } 
function Rpc Server ( opts ) { assert . object ( opts , 'options ' ) ; assert . object ( opts . log , 'options .log ' ) ; assert . number ( opts . program , 'options .program ' ) ; var v = opts . version ; if ( typeof ( v ) = = = 'number ' ) v = [ v ] ; assert . array Of Number ( v , 'options .version ' ) ; net . Server . call ( this , opts ) ; this . log = opts . log . child ( { component : 'Rpc Server ' } , true ) ; this . name = opts . name | | 'Rpc Server ' ; this . program = opts . program ; this . rpc _table = { } ; this . saved _handlers = [ ] ; this . version = v . slice ( ) ; this . on ( 'connection ' , on Connection . bind ( this ) ) ; } 
function Rpc Parser ( opts ) { assert . optional Object ( opts , 'options ' ) ; stream . Writable . call ( this , opts ) ; this . _buffer = null ; this . rpc _table = { } ; 
function Rpc Reply ( opts ) { Rpc Message . call ( this , opts ) ; this . _buffer = null ; this . rpc _reply _header _sent = false ; this . type = 1 ; } 
function Portmap Unset Call ( opts ) { Rpc Call . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 , port : 0 } ; this . _rpc _portmap _unset _call = true ; 
function Portmap Server ( opts ) { assert . object ( opts , 'options ' ) ; if ( opts . log ) { var l = opts . log ; delete opts . log ; } var _opts = clone ( opts ) ; _opts . log = opts . log = l ; _opts . name = 'portmap ' ; _opts . program = 1 0 0 0 0 0 ; _opts . version = 2 ; Rpc Server . call ( this , _opts ) ; } 
function XDR ( buf ) { if ( buf ) assert . ok ( Buffer . is Buffer ( buf ) , 'buffer is required ' ) ; this . xdr _buffer = buf | | null ; this . xdr _offset = 0 ; } 
function notify ( opts ) { const is Npm = require ( 'is -npm ' ) ; if ( ! process . stdout . is TTY | | is Npm ) { return ; } const boxen = require ( 'boxen ' ) ; opts = opts | | { } ; opts . defer = typeof opts . defer = = = 'boolean ' ? opts . defer : false ; opts . message = opts . message | | ' ' ; opts . boxen Opts = opts . boxen Opts | | { padding : 1 , margin : 1 , align : 'center ' , border Color : 'yellow ' , border Style : 'round ' , } ; const message = ' \n ' + boxen ( opts . message , opts . boxen Opts ) ; if ( opts . defer = = = false ) { console . error ( message ) ; } else { process . on ( 'exit ' , function ( ) { console . error ( message ) ; } ) ; process . on ( 'SIGINT ' , function ( ) { console . error ( ' \n ' + message ) ; } ) ; } } 
function ( cb ) { var templates Dir = self . data . _templates Dir ; var templates Path = path . join ( self . src , "extracted " , templates Dir ) ; fs . stat ( templates Path , function ( err , stats ) { if ( err ) { if ( err . code = = = "ENOENT " ) { return void cb ( new Error ( "Templates path ' " + templates Path + " ' directory not found " ) ) ; } return void cb ( err ) ; } if ( ! stats . is Directory ( ) ) { return void cb ( new Error ( "Templates path ' " + templates Path + " ' exists , but is not a directory " ) ) ; } cb ( null , templates Path ) ; } ) ; } 
function ( cb ) { fs . stat ( self . dest , function ( err ) { if ( err ) { 
function npm Install Package ( deps , opts , cb ) { if ( ! cb ) { cb = opts opts = { } } deps = Array . is Array ( deps ) ? deps : [ deps ] opts = opts | | opts cb = cb | | noop var args = [ ] if ( opts . save ) args . push ( ' -S ' ) if ( opts . save Dev ) args . push ( ' -D ' ) if ( opts . global ) args . push ( ' -g ' ) if ( opts . cache ) args . push ( ' - -cache -min Infinity ' ) if ( opts . silent = = = false ) { deps . for Each ( function ( dep ) { process . stdout . write ( 'pkg : ' + dep + ' \n ' ) } ) } var cli Args = [ 'npm i ' ] . concat ( args , deps ) . join ( ' ' ) exec ( cli Args , function ( err , name ) { if ( err ) return cb ( err ) cb ( ) } ) } 
function fiberize ( fn ) { return function ( done ) { var self = this ; Fiber ( function ( ) { try { if ( fn . length = = 1 ) { fn . call ( self , done ) ; } else { fn . call ( self ) ; done ( ) ; } } catch ( e ) { process . next Tick ( function ( ) { throw ( e ) ; } ) ; } } ) . run ( ) ; } ; } 
function ( regex , type , types , selector ) { var matches = selector . match ( regex ) ; if ( matches ) { for ( var i = 0 ; i < matches . length ; i + + ) { types [ type ] + + ; 
function ( selector ) { var comma Index = selector . index Of ( ' , ' ) ; if ( comma Index ! = = - 1 ) { selector = selector . substring ( 0 , comma Index ) ; } var types = { a : 0 , b : 0 , c : 0 } ; 
function ( value ) { var flag Undefined = function flag Undefined ( key , value ) { return value = = = undefined ? " / * void (undefined ) * / " : value ; } ; return JSON . stringify ( value , flag Undefined , " " ) . replace ( / " \ / \ * void \ (undefined \ ) \ * \ / " / g , "undefined " ) ; } 
function ( collection Name , index Name , columns , unique , callback ) { var options = { index Name : index Name , columns : columns , unique : unique } ; return this . _run ( 'create Index ' , collection Name , options ) . nodeify ( callback ) ; } 
function ( name , callback ) { return this . _run ( 'insert ' , this . internals . migration Table , { name : name , run _on : new Date ( ) } ) . nodeify ( callback ) ; } 
function ( name , callback ) { return this . _run ( 'insert ' , this . internals . seed Table , { name : name , run _on : new Date ( ) } ) . nodeify ( callback ) ; } 
function ( command , collection , options , callback ) { var args = this . _make Param Args ( arguments ) , sort = null , callback = args [ 2 ] ; log . sql . apply ( null , arguments ) ; if ( options & & typeof ( options ) = = = 'object ' ) { if ( options . sort ) sort = options . sort ; } if ( this . internals . dry Run ) { return Promise . resolve ( ) . nodeify ( callback ) ; } return new Promise ( function ( resolve , reject ) { var pr CB = function ( err , data ) { return ( err ? reject ( err ) : resolve ( data ) ) ; } ; 
function ( err , data ) { if ( err ) { pr CB ( err ) ; } pr CB ( null , data ) ; db . close ( ) ; } 
function parse Parameters ( options ) { var opt = { maximum Age : 0 , enable High Accuracy : true , timeout : Infinity , interval : 6 0 0 0 , fast Interval : 1 0 0 0 , priority : PRIORITY _HIGH _ACCURACY } ; if ( options ) { if ( options . maximum Age ! = = undefined & & ! is Na N ( options . maximum Age ) & & options . maximum Age > 0 ) { opt . maximum Age = options . maximum Age ; } if ( options . enable High Accuracy ! = = undefined ) { opt . enable High Accuracy = options . enable High Accuracy ; } if ( options . timeout ! = = undefined & & ! is Na N ( options . timeout ) ) { if ( options . timeout < 0 ) { opt . timeout = 0 ; } else { opt . timeout = options . timeout ; } } if ( options . interval ! = = undefined & & ! is Na N ( options . interval ) & & options . interval > 0 ) { opt . interval = options . interval ; } if ( options . fast Interval ! = = undefined & & ! is Na N ( options . fast Interval ) & & options . fast Interval > 0 ) { opt . fast Interval = options . fast Interval ; } if ( options . priority ! = = undefined & & ! is Na N ( options . priority ) & & options . priority > = PRIORITY _NO _POWER & & options . priority < = PRIORITY _HIGH _ACCURACY ) { if ( options . priority = = = PRIORITY _NO _POWER ) { opt . priority = PRIORITY _NO _POWER ; } if ( options . priority = = = PRIORITY _LOW _POWER ) { opt . priority = PRIORITY _LOW _POWER ; } if ( options . priority = = = PRIORITY _BALANCED _POWER _ACCURACY ) { opt . priority = PRIORITY _BALANCED _POWER _ACCURACY ; } if ( options . priority = = = PRIORITY _HIGH _ACCURACY ) { opt . priority = PRIORITY _HIGH _ACCURACY ; } } } return opt ; } 
function no Prop ( props , prop Name Or Function ) { if ( ! props ) { throw new Error ( 'Headful : You must pass all declared props when you use headful .props .x ( ) calls . ' ) ; } const prop Name = typeof prop Name Or Function = = = 'function ' ? prop Name Or Function . name : prop Name Or Function ; return ! props . has Own Property ( prop Name ) ; } 
function Gif Cli ( path , callback ) { var frames = [ ] ; One By One ( [ Tmp . dir , function ( next , tmp Dir ) { var str = Fs . create Read Stream ( path ) , is Finished = false , complete = [ ] , i = 0 ; str . on ( "end " , function ( ) { is Finished = true ; } ) ; str . pipe ( Gif Explode ( function ( frame ) { Tmp . file ( { postfix : " .gif " , } , function ( err , c Img ) { ( function ( i , c Img ) { if ( err ) { return next ( err ) ; } var w Str = Fs . create Write Stream ( c Img ) ; frame . pipe ( w Str ) ; complete [ i ] = false ; w Str . on ( "close " , function ( ) { 
function ( test , message , optional Params ) { return invoke ( 'CONSOLE ' , { type : 'assert ' , test : test , message : message , optional Params : optional Params | | [ ] } ) ; } 
function operation Data Base ( webview , db ) { console . log ( 'open then ' ) ; db . execute Sql ( 'SELECT 1 FROM Version LIMIT 1 ' ) . then ( function ( result ) { console . log ( 'execute Sql then ' ) ; console . log ( result ) ; function query Employees ( tx ) { console . log ( "Executing employee query " ) ; tx . execute Sql ( 'SELECT a .name , b .name as dept Name FROM Employees a , Departments b WHERE a .department = b .department _id ' ) . then ( ( [ tx , results ] ) = > { var payload = { } payload . result = [ ] payload . type = 'OPERATION _DATABASEE _DONE _QUERY _DB ' ; var len = results . rows . length ; for ( let i = 0 ; i < len ; i + + ) { let row = results . rows . item ( i ) ; payload . result . push ( row ) } webview . post Message ( JSON . stringify ( payload ) ) ; } ) . catch ( ( error ) = > { console . log ( error ) ; } ) ; } db . transaction ( query Employees ) . then ( ( ) = > { console . log ( 'query done . ' ) } ) ; } ) . catch ( function ( err ) { console . log ( 'execute Sql catch ' ) ; console . log ( err ) ; db . transaction ( function ( tx ) { tx . execute Sql ( 'DROP TABLE IF EXISTS Employees ; ' ) ; tx . execute Sql ( 'DROP TABLE IF EXISTS Offices ; ' ) ; tx . execute Sql ( 'DROP TABLE IF EXISTS Departments ; ' ) ; tx . execute Sql ( 'CREATE TABLE IF NOT EXISTS Version ( ' + 'version _id INTEGER PRIMARY KEY NOT NULL ) ; ' ) . catch ( ( error ) = > { console . log ( error ) ; } ) ; tx . execute Sql ( 'CREATE TABLE IF NOT EXISTS Departments ( ' + 'department _id INTEGER PRIMARY KEY NOT NULL , ' + 'name VARCHAR ( 3 0 ) ) ; ' ) . catch ( ( error ) = > { console . log ( error ) } ) ; tx . execute Sql ( 'CREATE TABLE IF NOT EXISTS Offices ( ' + 'office _id INTEGER PRIMARY KEY NOT NULL , ' + 'name VARCHAR ( 2 0 ) , ' + 'longtitude FLOAT , ' + 'latitude FLOAT ) ; ' ) . catch ( ( error ) = > { console . log ( error ) } ) ; tx . execute Sql ( 'CREATE TABLE IF NOT EXISTS Employees ( ' + 'employe _id INTEGER PRIMARY KEY NOT NULL , ' + 'name VARCHAR ( 5 5 ) , ' + 'office INTEGER , ' + 'department INTEGER , ' + 'FOREIGN KEY ( office ) REFERENCES Offices ( office _id ) ' + 'FOREIGN KEY ( department ) REFERENCES Departments ( department _id ) ) ; ' ) . catch ( ( error ) = > { console . log ( error ) } ) ; tx . execute Sql ( 'INSERT INTO Departments (name ) VALUES ( "Client Services " ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Departments (name ) VALUES ( "Investor Services " ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Departments (name ) VALUES ( "Shipping " ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Departments (name ) VALUES ( "Direct Sales " ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Offices (name , longtitude , latitude ) VALUES ( "Denver " , 5 9 . 8 , 3 4 . 1 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Offices (name , longtitude , latitude ) VALUES ( "Warsaw " , 1 5 . 7 , 5 4 . 1 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Offices (name , longtitude , latitude ) VALUES ( "Berlin " , 3 5 . 3 , 1 2 . 1 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Offices (name , longtitude , latitude ) VALUES ( "Paris " , 1 0 . 7 , 1 4 . 1 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Sylvester Stallone " , 2 , 4 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Elvis Presley " , 2 , 4 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Leslie Nelson " , 3 , 4 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Fidel Castro " , 3 , 3 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Bill Clinton " , 1 , 3 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Margaret Thatcher " , 1 , 3 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Donald Trump " , 1 , 3 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Dr DRE " , 2 , 2 ) ; ' ) ; tx . execute Sql ( 'INSERT INTO Employees (name , office , department ) VALUES ( "Samantha Fox " , 2 , 1 ) ; ' ) ; console . log ( "all executed SQL done " ) ; webview . post Message ( JSON . stringify ( { type : "OPERATION _DATABASEE _DONE _CREATE _TABLE _AND _INSERT _DATA " , result : 'init table done . ' } ) ) ; } ) } ) } 
function delegate ( method , _args ) { var call Position = metalogger . callposition ( ) , file , line ; if ( ! metalogger . should Log ( method , _level ) ) { return ; } var args = Array . prototype . slice . call ( _args ) ; var message = [ ] ; if ( args . length = = = 1 ) { message . push ( util . inspect ( args [ 0 ] , { show Hidden : true , depth : null } ) ) ; } if ( args . length = = = 2 ) { message . push ( args . shift ( ) ) ; message . push ( util . inspect ( args [ 0 ] , { show Hidden : true , depth : null } ) ) ; } if ( args . length > 2 ) { message . push ( args . shift ( ) ) ; message . push ( util . format . apply ( null , args ) ) ; } try { file = call Position . split ( ' : ' ) [ 0 ] . replace ( ' [ ' , ' ' ) ; line = call Position . split ( ' : ' ) [ 1 ] . replace ( ' ] ' , ' ' ) ; } catch ( e ) { 
function delegate ( method , _args ) { var call Position = metalogger . callposition ( ) , file , line ; if ( ! metalogger . should Log ( method , _level ) ) { return ; } var args = Array . prototype . slice . call ( _args ) ; var message = ' ' , inspect = null ; message = util . inspect ( args . shift ( ) , { show Hidden : true , depth : null } ) . replace ( / \n / g , ' ' ) ; inspect = args [ 0 ] ; if ( args . length > 2 ) { inspect = util . format . apply ( null , args ) ; } try { file = call Position . split ( ' : ' ) [ 0 ] . replace ( ' [ ' , ' ' ) ; line = call Position . split ( ' : ' ) [ 1 ] . replace ( ' ] ' , ' ' ) ; } catch ( e ) { 
function should Log ( testlevel , threshold Level ) { var allowed = log Level Allowed Granular ( testlevel ) ; if ( allowed ) { return true ; } return log Level Allowed ( testlevel , threshold Level ) ; } 
function log Level Allowed Granular ( testlevel ) { if ( ! _granularlevels ) { return ; } var pos = callposition Obj ( ) ; if ( pos ) { var key = 'NODE _LOGGER _LEVEL _ ' + pos . filename . replace ( / [ \ . \ / ] / gi , ' _ ' ) ; if ( key in process . env & & process . env [ key ] ) { var threshold Level = process . env [ key ] . to Lower Case ( ) ; return log Levels Obj [ testlevel ] < = log Levels Obj [ threshold Level ] ; } } } 
function ( ) { if ( attrs . type = = = 'radio ' ) { return attrs . value | | $parse ( attrs . ng Value ) ( scope ) | | true ; } var true Value = ( $parse ( attrs . ng True Value ) ( scope ) ) ; if ( angular . is Undefined ( true Value ) ) { true Value = true ; } return true Value ; } 
function ( attr Name ) { var map = { 'switch Radio Off ' : get Boolean From String Def True , 'switch Active ' : function ( value ) { return ! get Boolean From String Def True ( value ) ; } , 'switch Animate ' : get Boolean From String Def True , 'switch Label ' : function ( value ) { return value ? value : ' &nbsp ; ' ; } , 'switch Icon ' : function ( value ) { if ( value ) { return ' <span class = \ ' ' + value + ' \ ' > < /span > ' ; } } , 'switch Wrapper ' : function ( value ) { return value | | 'wrapper ' ; } , 'switch Inverse ' : get Boolean From String , 'switch Readonly ' : get Boolean From String , 'switch Change ' : get Expr From String } ; var trans Fn = map [ attr Name ] | | get Value Or Undefined ; return trans Fn ( attrs [ attr Name ] ) ; } 
function ( element , attr , model Attr ) { if ( ! is Init ) { return ; } var new Value = get Switch Attr Value ( model Attr ) ; element . bootstrap Switch ( attr , new Value ) ; } 
function ( ) { 
function ( ) { attrs . $observe ( 'switch Active ' , function ( new Value ) { var active = get Boolean From String Def True ( new Value ) ; 
function ( ) { if ( attrs . type = = = 'radio ' ) { 
function ( msg ) { if ( typeof scope . console = = = 'object ' & & scope . console ! = = null & & typeof scope . console . warn = = = 'function ' ) { warn = function ( msg ) { scope . console . warn ( msg ) ; } ; warn ( msg ) ; } } 
function ( o ) { var r , e ; if ( typeof o ! = = 'object ' | | o = = = null ) { r = default _options ; } else { r = { expires : default _options . expires , path : default _options . path , domain : default _options . domain , secure : default _options . secure } ; if ( typeof o . expires = = = 'object ' & & o . expires instanceof Date ) { r . expires = o . expires ; } else if ( typeof o . expires _at = = = 'object ' & & o . expires _at instanceof Date ) { r . expires = o . expires _at ; warn ( 'Cookie option "expires _at " has been deprecated . Rename to "expires " . Support for "expires _at " will be removed in a version to come . ' ) ; } else if ( typeof o . expires At = = = 'object ' & & o . expires At instanceof Date ) { r . expires = o . expires At ; warn ( 'Cookie option "expires At " has been deprecated . Rename to "expires " . Support for "expires At " will be removed in a version to come . ' ) ; } else if ( typeof o . hours To Live = = = 'number ' & & o . hours To Live ! = = 0 ) { e = new Date ( ) ; e . set Time ( e . get Time ( ) + ( o . hours To Live * 6 0 * 6 0 * 1 0 0 0 ) ) ; r . expires = e ; warn ( 'Cookie option "hours To Live " has been deprecated . Rename to "expires " and prodvide a Date instance (see documentation ) . Support for "hours To Live " will be removed in a version to come . ' ) ; } if ( typeof o . path = = = 'string ' & & o . path ! = = ' ' ) { r . path = o . path ; } if ( typeof o . domain = = = 'string ' & & o . domain ! = = ' ' ) { r . domain = o . domain ; } if ( o . secure = = = true ) { r . secure = o . secure ; } } return r ; } 
function ( o ) { o = resolve Options ( o ) ; return ( [ ( typeof o . expires = = = 'object ' & & o . expires instanceof Date ? ' ; expires = ' + o . expires . to GMTString ( ) : ' ' ) , ( ' ; path = ' + o . path ) , ( typeof o . domain = = = 'string ' ? ' ; domain = ' + o . domain : ' ' ) , ( o . secure = = = true ? ' ; secure ' : ' ' ) ] . join ( ' ' ) ) ; } 
function ( n ) { var r , i , c = parse Cookies ( ) ; if ( typeof n = = = 'string ' ) { r = ( c [ n ] ! = = undef ) ? c [ n ] : null ; } else if ( typeof n = = = 'object ' & & n ! = = null ) { r = { } ; for ( i in n ) { if ( Object . prototype . has Own Property . call ( n , i ) ) { if ( c [ n [ i ] ] ! = = undef ) { r [ n [ i ] ] = c [ n [ i ] ] ; } else { r [ n [ i ] ] = null ; } } } } else { r = c ; } return r ; } 
function ( p ) { var n , r = { } , c = parse Cookies ( ) ; if ( typeof p = = = 'string ' ) { p = new Reg Exp ( p ) ; } for ( n in c ) { if ( Object . prototype . has Own Property . call ( c , n ) & & n . match ( p ) ) { r [ n ] = c [ n ] ; } } return r ; } 
function ( n , v , o ) { if ( typeof o ! = = 'object ' | | o = = = null ) { o = { } ; } if ( v = = = undef | | v = = = null ) { v = ' ' ; o . expires = new Date ( ) ; o . expires . set Full Year ( 1 9 7 8 ) ; } else { v = ( v = = = true ) ? 'true ' : ( v = = = false ) ? 'false ' : ! is Na N ( v ) ? String ( v ) : v ; if ( typeof v ! = = 'string ' ) { if ( typeof JSON = = = 'object ' & & JSON ! = = null & & typeof JSON . stringify = = = 'function ' ) { v = JSON . stringify ( v ) ; } else { throw new Error ( 'cookies .set ( ) could not be serialize the value ' ) ; } } } document . cookie = n + ' = ' + encode URIComponent ( v ) + cookie Options ( o ) ; } 
function ( n , o ) { var d = { } , i ; if ( typeof o ! = = 'object ' | | o = = = null ) { o = { } ; } if ( typeof n = = = 'boolean ' & & n = = = true ) { d = this . get ( ) ; } else if ( typeof n = = = 'string ' ) { d [ n ] = true ; } for ( i in d ) { if ( Object . prototype . has Own Property . call ( d , i ) & & typeof i = = = 'string ' & & i ! = = ' ' ) { this . set ( i , null , o ) ; } } } 
function ( ) { var r = false , n = 'test _cookies _jaaulde _js ' , v = 'data ' ; this . set ( n , v ) ; if ( this . get ( n ) = = = v ) { this . del ( n ) ; r = true ; } return r ; } 
function format Message ( str ) { return String ( str ) . split ( ' \n ' ) . map ( function ( s ) { return s . magenta ; } ) . join ( ' \n ' ) ; } 
function apply Zoom ( options , chart ) { if ( angular . is Object ( options . state ) & & angular . is Object ( options . state ) & & angular . is Array ( options . state . range ) ) { chart . zoom ( options . state . range ) ; } else { chart . unzoom ( ) ; } } 
function create Zoom Range Path ( options ) { if ( ! angular . is Object ( options . state ) ) { options . state = { } ; } if ( ! angular . is Object ( options . state . range ) ) { options . state . range = [ ] ; } } 
function synchronize Zoom ( options , configuration , watcher ) { if ( angular . is Object ( options . chart ) & & angular . is Object ( options . chart . zoom ) & & options . chart . zoom . enabled = = = true ) { 
function add Selections ( chart , selections ) { service . disable Selection Listener = true ; selections . for Each ( function ( selection ) { chart . select ( [ selection . id ] , [ selection . index ] ) ; } ) ; service . disable Selection Listener = false ; } 
function remove All Selections ( chart ) { service . disable Selection Listener = true ; chart . unselect ( ) ; service . disable Selection Listener = false ; } 
function apply Selection ( options , chart ) { if ( angular . is Object ( options . state ) & & angular . is Array ( options . state . selected ) ) { 
function create Selections Path ( options ) { if ( ! angular . is Object ( options . state ) ) { options . state = { } ; } if ( ! angular . is Array ( options . state . selected ) ) { options . state . selected = [ ] ; } } 
function synchronize Selection ( options , configuration , watcher ) { if ( angular . is Object ( options . chart ) & & angular . is Object ( options . chart . data ) & & angular . is Object ( options . chart . data . selection ) & & options . chart . data . selection . enabled = = = true ) { 
function init ( scope ) { var watcher = { scope : scope , dimensions Callback : null , dimensions Type Callback : null , chart Callback : null , state Callback : null , data Callback : null , data Small Watcher : null , data Big Watcher : null , disable State Watcher : false } ; setup Dimensions Watcher ( watcher ) ; setup Dimensions Type Watcher ( watcher ) ; setup Chart Watcher ( watcher ) ; setup State Watcher ( watcher ) ; setup Watch Limit Watcher ( watcher ) ; setup Data Watcher ( watcher ) ; return watcher ; } 
function setup Dimensions Watcher ( watcher ) { watcher . scope . $watch ( function ( ) { var check = watcher . scope . options & & watcher . scope . options . dimensions ; 
function setup Data Small Watcher ( watcher ) { return watcher . scope . $watch ( 'options .data ' , function ( ) { if ( angular . is Function ( watcher . data Callback ) ) { watcher . data Callback ( ) ; } setup Data Watcher ( watcher ) ; } , true ) ; } 
function setup Data Big Watcher ( watcher ) { return watcher . scope . $watch ( function ( ) { if ( watcher . scope . options . data & & angular . is Array ( watcher . scope . options . data ) ) { return watcher . scope . options . data . length ; } else { return 0 ; } } , function ( ) { if ( angular . is Function ( watcher . data Callback ) ) { watcher . data Callback ( ) ; } setup Data Watcher ( watcher ) ; } ) ; } 
function update State ( watcher , func ) { watcher . disable State Watcher = true ; watcher . scope . $apply ( func ) ; watcher . disable State Watcher = false ; } 
function convert Data ( options , configuration ) { 
function add Identifier ( ) { $scope . data Attribute Chart ID = 'chartid ' + Math . floor ( Math . random ( ) * 1 0 0 0 0 0 0 0 0 1 ) ; angular . element ( $element ) . attr ( 'id ' , $scope . data Attribute Chart ID ) ; configuration . bindto = ' # ' + $scope . data Attribute Chart ID ; } 
function load Entity ( name , promise , options ) { if ( ! name | | typeof name ! = = 'string ' ) throw new Error ( 'Missing required entity name ' ) ; if ( ! promise | | ! promise . then ) throw new Error ( 'Missing required entity promise ' ) ; try { ! ( 0 , _validate Options . default ) ( options ) ; } catch ( error ) { throw error ; } var entity Lifecycle = new _entity Lifecycle . default ( name , options ) ; return function ( dispatch , get State ) { entity Lifecycle . set Dispatch ( dispatch ) ; entity Lifecycle . set Get State ( get State ) ; entity Lifecycle . on Load ( ) ; return new Promise ( function ( resolve , reject ) { promise . then ( function ( data ) { resolve ( entity Lifecycle . on Success ( data ) ) ; } ) . catch ( function ( error ) { reject ( entity Lifecycle . on Failure ( error ) ) ; } ) ; } ) ; } ; } 
function generate Action ( action , keys , values ) { var generated Action = Object . assign ( { } , action ) ; keys . for Each ( function ( arg , index ) { generated Action [ keys [ index ] ] = values [ index ] ; } ) ; return generated Action ; } 
function make Action Creator ( type ) { for ( var _len = arguments . length , keys = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key + + ) { keys [ _key - 1 ] = arguments [ _key ] ; } if ( ! type ) throw new Error ( 'Type cannot be null /undefined ' ) ; return function ( ) { for ( var _len 2 = arguments . length , values = new Array ( _len 2 ) , _key 2 = 0 ; _key 2 < _len 2 ; _key 2 + + ) { values [ _key 2 ] = arguments [ _key 2 ] ; } return generate Action ( { type : type } , keys , values ) ; } ; } 
function make Entity Action Creator ( type , entity ) { for ( var _len 3 = arguments . length , keys = new Array ( _len 3 > 2 ? _len 3 - 2 : 0 ) , _key 3 = 2 ; _key 3 < _len 3 ; _key 3 + + ) { keys [ _key 3 - 2 ] = arguments [ _key 3 ] ; } if ( ! type ) throw new Error ( 'Type cannot be null /undefined ' ) ; if ( ! entity ) throw new Error ( 'Entity cannot be null /undefined ' ) ; return function ( ) { for ( var _len 4 = arguments . length , values = new Array ( _len 4 ) , _key 4 = 0 ; _key 4 < _len 4 ; _key 4 + + ) { values [ _key 4 ] = arguments [ _key 4 ] ; } return generate Action ( { type : type , entity : entity } , keys , values ) ; } ; } 
function _get Random Delay Between ( min , max , round To ) { return Number ( Math . random ( ) * ( max - min ) + min ) . to Fixed ( round To ) ; } 
function _log Details ( action ) { if ( action ) { console . log ( ` $ { chalk . white . bg Red ( ' Prev State : ' ) } $ { _ _to String ( state ) } ` ) ; console . log ( ` $ { chalk . white . bg Blue ( ' Action : ' ) } $ { _ _to String ( action ) } ` ) ; } else { console . log ( ` $ { chalk . white . bg Green ( ' Next State : ' ) } $ { _ _to String ( state ) } ` ) ; console . log ( ' \n ' ) ; } } 
function jge Parse ( s , callback , context ) { if ( context & & context . new State ) { if ( ! context . keep Token ) context . token = ' ' ; context . state = context . new State ; } else { context = { } ; reset ( context ) ; } var c ; for ( var i = context . position ; i < s . length ; i + + ) { c = s . char At ( i ) ; if ( ( c . char Code At ( 0 ) < 3 2 ) & & ( context . valid Control Chars . index Of ( c ) < 0 ) ) { context . new State = context . state = s Error ; } if ( context . state ! = s Content ) { if ( context . valid Control Chars . index Of ( c ) > = 0 ) { 
function jptr ( obj , prop , new Value ) { 
function fetch From Object ( obj , prop , new Value ) { 
function ( obj , attr Prefix , standalone , indent , indent Str , fragment ) { var attribute Prefix = ( attr Prefix ? attr Prefix : ' @ ' ) ; if ( fragment ) { xml Write . start Fragment ( indent , indent Str ) ; } else { xml Write . start Document ( 'UTF - 8 ' , standalone , indent , indent Str ) ; } traverse ( obj , ' ' , attribute Prefix ) ; return xml Write . end Document ( ) ; } 
function _remove Subscribers ( a Subscribers , o Subscriber ) { let n Unsubscribed = 0 ; if ( ! is Type Of ( a Subscribers , s Not Defined ) ) { let n Index = a Subscribers . length - 1 ; for ( ; n Index > = 0 ; n Index - - ) { if ( a Subscribers [ n Index ] . subscriber = = = o Subscriber ) { n Unsubscribed + + ; a Subscribers . splice ( n Index , 1 ) ; } } } return n Unsubscribed ; } 
function _remove Subscribers Per Event ( o Events Callbacks , s Channel Id , o Subscriber ) { let n Unsubscribed = 0 ; iterate Object ( o Events Callbacks , function ( o Item , s Event ) { const a Events Parts = s Event . split ( ' : ' ) ; let s Channel = s Channel Id ; let s Event Type = s Event ; if ( a Events Parts [ 0 ] = = = 'global ' ) { s Channel = a Events Parts [ 0 ] ; s Event Type = a Events Parts [ 1 ] ; } n Unsubscribed + = _remove Subscribers ( o Channels [ s Channel ] [ s Event Type ] , o Subscriber ) ; } ) ; return n Unsubscribed ; } 
function _add Subscribers ( o Events Callbacks , s Channel Id , o Subscriber ) { iterate Object ( o Events Callbacks , function ( o Item , s Event ) { subscribe To ( s Channel Id , s Event , o Item , o Subscriber ) ; } ) ; } 
function _get Channel Events ( s Channel Id , s Event ) { if ( o Channels [ s Channel Id ] = = = und ) { o Channels [ s Channel Id ] = { } ; } if ( o Channels [ s Channel Id ] [ s Event ] = = = und ) { o Channels [ s Channel Id ] [ s Event ] = [ ] ; } return o Channels [ s Channel Id ] [ s Event ] ; } 
function subscribers By Event ( o Channel , s Event Name ) { let a Subscribers = [ ] ; if ( ! is Type Of ( o Channel , s Not Defined ) ) { iterate Object ( o Channel , function ( o Item , s Key ) { if ( s Key = = = s Event Name ) { a Subscribers = o Item ; } } ) ; } return a Subscribers ; } 
function subscribe To ( s Channel Id , s Event Type , fp Handler , o Subscriber ) { const a Channel Events = _get Channel Events ( s Channel Id , s Event Type ) ; a Channel Events . push ( { subscriber : o Subscriber , handler : fp Handler } ) ; } 
function unsubscribe From ( s Channel Id , s Event Type , o Subscriber ) { const a Channel Events = _get Channel Events ( s Channel Id , s Event Type ) ; for ( let n Event = a Channel Events . length - 1 ; n Event > = 0 ; n Event - - ) { const o Item = a Channel Events [ n Event ] ; if ( o Item . subscriber = = = o Subscriber ) { a Channel Events . splice ( n Event , 1 ) ; } } } 
function subscribe ( o Subscriber ) { const o Events Callbacks = o Subscriber . events ; if ( ! o Subscriber | | o Events Callbacks = = = und ) { return false ; } iterate Object ( o Events Callbacks , function ( o Item , s Channel Id ) { if ( o Channels [ s Channel Id ] = = = und ) { o Channels [ s Channel Id ] = { } ; } _add Subscribers ( o Item , s Channel Id , o Subscriber ) ; } ) ; return true ; } 
function unsubscribe ( o Subscriber ) { let n Unsubscribed = 0 ; const o Events Callbacks = o Subscriber . events ; if ( ! o Subscriber | | o Events Callbacks = = = und ) { return false ; } iterate Object ( o Events Callbacks , function ( o Item , s Channel Id ) { if ( o Channels [ s Channel Id ] = = = und ) { o Channels [ s Channel Id ] = { } ; } n Unsubscribed = _remove Subscribers Per Event ( o Item , s Channel Id , o Subscriber ) ; } ) ; return n Unsubscribed > 0 ; } 
function _execute Handler ( o Handler Object , o Data , s Channel Id , s Event ) { o Handler Object . handler . call ( o Handler Object . subscriber , o Data ) ; if ( get Debug ( ) ) { const Error Handler = error Handler ( ) ; Error Handler . log ( s Channel Id , s Event , o Handler Object ) ; } } 
function publish ( s Channel Id , s Event , o Data ) { const a Subscribers = copy Array ( this . subscribers ( s Channel Id , s Event ) ) ; let o Subscriber ; const n Len Subscribers = a Subscribers . length ; if ( n Len Subscribers = = = 0 ) { return false ; } o Data = preprocessors Publish Data ( o Data ) ; while ( ! ! ( o Subscriber = a Subscribers . shift ( ) ) ) { _execute Handler ( o Subscriber , o Data , s Channel Id , s Event ) ; } return true ; } 
function resolve Namespace ( s Namespace ) { var o Obj = root , a Elements = s Namespace . split ( ' . ' ) , s Element ; while ( ! ! ( s Element = a Elements . shift ( ) ) ) { o Obj = o Obj [ s Element ] ! = = und ? o Obj [ s Element ] : o Obj [ s Element ] = { } ; } return o Obj ; } 
function get Resolve DICallback ( o Mapping ) { return function ( s Dependency ) { var o Promise = get Promise ( ) ; if ( ! o Mapping . _ _map _ _ [ s Dependency ] ) { return false ; } o Promise . resolve ( o Mapping . _ _map _ _ [ s Dependency ] ) ; return o Promise ; } ; } 
function get Dependency Through All Maps ( s Dependency ) { var o Map , o Dependency , n Index Order , n Len Order , a Order Dependency = o Mapping Maps . _ _ _order _ _ _ ; create Mapping ( o Mapping Maps , ' _ _ ' , root , function ( s Dependency ) { var o Dependency , o Promise = get Promise ( ) ; o Dependency = resolve Namespace ( s Dependency ) ; o Promise . resolve ( o Dependency ) ; return o Promise ; } ) ; for ( n Index Order = 0 , n Len Order = a Order Dependency . length ; n Index Order < n Len Order ; n Index Order + + ) { o Map = o Mapping Maps [ a Order Dependency [ n Index Order ] ] ; o Dependency = o Map . _ _resolve DI _ _ ( s Dependency ) ; if ( o Dependency ) { delete o Mapping Maps [ ' _ _ ' ] ; return o Dependency ; } } delete o Mapping Maps [ ' _ _ ' ] ; return false ; } 
function get Promise Callbacks ( o Context , s Type ) { return function ( ) { var a Completed , n Len Promises , o Deferred , a Promises , n Promise , o Promise , a Results = [ ] ; o Context . b Completed = true ; o Context . s Type = s Type ; o Context . o Result = arguments ; while ( o Context . a Pending [ 0 ] ) { o Context . a Pending . shift ( ) [ s Type ] . apply ( o Context , arguments ) ; } o Deferred = o Context . o Deferred ; if ( o Deferred ) { a Completed = [ ] ; a Promises = o Deferred . a Promises ; n Len Promises = a Promises . length ; a Results = [ ] ; for ( n Promise = 0 ; n Promise < n Len Promises ; n Promise + + ) { o Promise = a Promises [ n Promise ] ; a Completed . push ( Number ( o Promise . b Completed ) ) ; a Results . push ( o Promise . o Result ) ; } if ( a Completed . join ( ' ' ) . index Of ( ' 0 ' ) = = = - 1 ) { o Deferred [ s Type ] . apply ( o Deferred , a Results ) ; } } } ; } 
function ( fp Success , fp Failure ) { var o Result = this . o Result ; if ( this . b Completed ) { if ( this . s Type = = = 'resolve ' ) { fp Success . apply ( fp Success , o Result ) ; } else { fp Failure . apply ( fp Failure , o Result ) ; } } else { this . a Pending . push ( { resolve : fp Success , reject : fp Failure } ) ; } return this ; } 
function Fake Module ( s Module Id , fp Creator ) { if ( is Type Of ( fp Creator , s Not Defined ) ) { throw new Error ( 'Something goes wrong ! ' ) ; } this . creator = fp Creator ; this . instances = { } ; this . s Module Id = s Module Id ; } 
function is Jquery Object ( o Obj ) { var is Jquery = false , $ = get Root ( ) . j Query ; if ( $ ) { is Jquery = is Instance Of ( o Obj , $ ) ; } return is Jquery ; } 
function is Event ( o Obj ) { try { return is Instance Of ( o Obj , Event ) ; } catch ( er Error ) { 
function add Properties And Methods To Module ( s Module Id , a Dependencies , fp Callback ) { var o Promise ; function success ( mapping ) { const o Modules = get Modules ( ) ; var o Module , fp Init Proxy ; o Module = o Modules [ s Module Id ] . creator . apply ( o Modules [ s Module Id ] , [ ] . slice . call ( arguments , 1 ) ) ; o Module . _ _children _ _ = [ ] ; o Module . dependencies = a Dependencies | | [ ] . slice . call ( arguments , 1 ) ; o Module . resolved Dependencies = mapping ; o Module . _ _module _id _ _ = s Module Id ; fp Init Proxy = o Module . init | | null Func ; 
function wrap Method ( o Instance , s Name , s Module Id , fp Method ) { o Instance [ s Name ] = ( function ( s Name , fp Method ) { return function ( ) { var a Args = copy Array ( arguments ) ; try { return fp Method . apply ( this , a Args ) ; } catch ( er Error ) { const Error Handler = error Handler ( ) ; Error Handler . error ( s Module Id , s Name , er Error ) ; return false ; } } ; } ( s Name , fp Method ) ) ; } 
function register ( s Module Id , a Dependencies , fp Creator ) { const o Modules = get Modules ( ) ; if ( is Function ( a Dependencies ) ) { fp Creator = a Dependencies ; a Dependencies = [ ' $ $ _bus ' , ' $ $ _module ' , ' $ $ _log ' , 'gl _Hydra ' ] ; } o Modules [ s Module Id ] = new Fake Module ( s Module Id , fp Creator ) ; o Modules [ s Module Id ] . dependencies = a Dependencies ; return o Modules [ s Module Id ] ; } 
function set Instance ( s Module Id , s Id Instance , o Instance ) { const o Modules = get Modules ( ) ; var o Module = o Modules [ s Module Id ] ; if ( ! o Module ) { fp Throw Error Module Not Registered ( s Module Id , true ) ; } o Module . instances [ s Id Instance ] = o Instance ; return o Module ; } 
function _multi Module Start ( o Instance , a Modules Ids , s Id Instance , o Data , b Single ) { var a Instances Ids , a Data , a Single , n Index , n Len Modules , s Module Id ; if ( is Array ( s Id Instance ) ) { a Instances Ids = copy Array ( s Id Instance ) ; } if ( is Array ( o Data ) ) { a Data = copy Array ( o Data ) ; } if ( is Array ( b Single ) ) { a Single = copy Array ( b Single ) ; } for ( n Index = 0 , n Len Modules = a Modules Ids . length ; n Index < n Len Modules ; n Index + + ) { s Module Id = a Modules Ids [ n Index ] ; s Id Instance = a Instances Ids & & a Instances Ids [ n Index ] | | generate Unique Key ( ) ; o Data = a Data & & a Data [ n Index ] | | o Data ; b Single = a Single & & a Single [ n Index ] | | b Single ; start Single Module ( o Instance , s Module Id , s Id Instance , o Data , b Single ) ; } } 
function before Init ( o Instance , o Data , b Single ) { iterate Object ( o Modify Init , function ( o Member ) { if ( o Member & & is Type Of ( o Member , s Function Type ) ) { o Member ( o Instance , o Data , b Single ) ; } } ) ; } 
function start Single Module ( o Wrapper , s Module Id , s Id Instance , o Data , b Single ) { const o Modules = get Modules ( ) ; var o Module ; o Module = o Modules [ s Module Id ] ; if ( ( b Single & & is Module Started ( s Module Id ) ) | | is Module Started ( s Module Id , s Id Instance ) ) { o Wrapper . stop ( s Module Id , s Id Instance ) ; } if ( ! is Type Of ( o Module , s Not Defined ) ) { create Instance ( s Module Id , undefined , function ( o Instance ) { o Module . instances [ s Id Instance ] = o Instance ; o Instance . _ _instance _id _ _ = s Id Instance ; before Init ( o Instance , o Data , b Single ) ; if ( ! is Type Of ( o Data , s Not Defined ) ) { o Instance . init ( o Data ) ; } else { o Instance . init ( ) ; } } ) ; } else { const Error Handler = error Handler ( ) ; Error Handler . error ( new Error ( ) , fp Throw Error Module Not Registered ( s Module Id ) ) ; } } 
function _single Module Start ( o Instance , s Module Id , s Id Instance , o Data , b Single ) { if ( ! is Type Of ( s Id Instance , 'string ' ) ) { b Single = o Data ; o Data = s Id Instance ; s Id Instance = generate Unique Key ( ) ; } start Single Module ( o Instance , s Module Id , s Id Instance , o Data , b Single ) ; } 
function start ( o Module Id , o Id Instance , o Data , o Single ) { var b Start Multiple Modules = is Array ( o Module Id ) ; if ( b Start Multiple Modules ) { _multi Module Start ( this , copy Array ( o Module Id ) , o Id Instance , o Data , o Single ) ; } else { _single Module Start ( this , o Module Id , o Id Instance , o Data , o Single ) ; } } 
function create Instance ( s Module Id , a Dependencies , fp Callback ) { const o Modules = get Modules ( ) ; if ( is Type Of ( o Modules [ s Module Id ] , s Not Defined ) ) { fp Throw Error Module Not Registered ( s Module Id , true ) ; } add Properties And Methods To Module ( s Module Id , a Dependencies , function ( o Instance ) { if ( ! get Debug ( ) ) { iterate Object ( o Instance , function ( o Item , s Name ) { if ( is Function ( o Item ) ) { wrap Method ( o Instance , s Name , s Module Id , o Instance [ s Name ] ) ; } } ) ; } fp Callback ( o Instance ) ; } ) ; } 
function get Callback To Set Object From Template ( o Methods Object , o Properties Object ) { return function ( o Value , s Key ) { if ( typeof o Value = = = 'function ' ) { o Methods Object [ s Key ] = get Simple Function ( o Value ) ; } else if ( is Array ( o Value ) ) { o Properties Object [ s Key ] = copy Array ( o Value ) ; } else if ( typeof o Value = = = 'object ' & & o Value ! = = null ) { o Properties Object [ s Key ] = simple Merge ( { } , o Value ) ; } else if ( is Instance Of ( o Value , Date ) ) { o Properties Object [ s Key ] = new Date ( ) ; o Properties Object [ s Key ] . set Time ( o Value . get Time ( ) ) ; } else { o Properties Object [ s Key ] = o Value ; } } ; } 
function start All ( ) { const o Modules = get Modules ( ) ; iterate Object ( o Modules , function ( _o Module , s Module Id ) { if ( ! is Type Of ( _o Module , s Not Defined ) ) { start ( s Module Id , generate Unique Key ( ) ) ; } } ) ; } 
function stop ( s Module Id , s Instance Id ) { const o Modules = get Modules ( ) ; var o Module ; o Module = o Modules [ s Module Id ] ; if ( is Type Of ( o Module , s Not Defined ) ) { return false ; } if ( ! is Type Of ( s Instance Id , s Not Defined ) ) { _single Module Stop ( o Module , s Instance Id ) ; } else { _multi Module Stop ( o Module ) ; } return true ; } 
function _multi Module Stop ( o Module ) { iterate Object ( o Module . instances , function ( o Instance ) { if ( ! is Type Of ( o Module , s Not Defined ) & & ! is Type Of ( o Instance , s Not Defined ) ) { o Instance . destroy ( ) ; } } ) ; o Module . instances = { } ; } 
function _single Module Stop ( o Module , s Instance Id ) { var o Instance = o Module . instances [ s Instance Id ] ; if ( ! is Type Of ( o Module , s Not Defined ) & & ! is Type Of ( o Instance , s Not Defined ) ) { o Instance . destroy ( ) ; delete o Module . instances [ s Instance Id ] ; } } 
function stop All ( ) { const o Modules = get Modules ( ) ; iterate Object ( o Modules , function ( _o Module , s Module Id ) { if ( ! is Type Of ( _o Module , s Not Defined ) ) { _stop One By One ( _o Module , s Module Id ) ; } } ) ; } 
function _stop One By One ( o Module , s Module Id ) { iterate Object ( o Module . instances , function ( o Item , s Instance Id ) { stop ( s Module Id , s Instance Id ) ; } ) ; } 
function remove ( s Module Id ) { const o Modules = get Modules ( ) ; var o Module = o Modules [ s Module Id ] ; if ( is Type Of ( o Module , s Not Defined ) ) { return null ; } if ( ! is Type Of ( o Module , s Not Defined ) ) { try { return Module ; } finally { _delete ( s Module Id ) ; create Mapping ( get Mapping Maps ( ) , 'hm _ ' , o Modules ) ; } } return null ; } 
function _delete ( s Module Id ) { const o Modules = get Modules ( ) ; if ( ! is Type Of ( o Modules [ s Module Id ] , s Not Defined ) ) { delete o Modules [ s Module Id ] ; return true ; } return false ; } 
function main ( ) { return _ _awaiter ( this , void 0 , void 0 , function ( ) { var output Data Size , interval , data Frame , date Format , api ; return _ _generator ( this , function ( _a ) { switch ( _a . label ) { case 0 : output Data Size = "compact " ; if ( argv . output Data Size ) { output Data Size = argv . output Data Size ; } interval = ' 6 0min ' ; if ( argv . interval ) { interval = argv . interval ; } api = new index _ 1 . Alpha Vantage API ( argv . api Key , output Data Size , argv . verbose ) ; if ( ! ( argv . type = = = 'daily ' ) ) return [ 3 , 2 ] ; return [ 4 , api . get Daily Data Frame ( argv . symbol ) ] ; case 1 : data Frame = _a . sent ( ) ; date Format = 'YYYY -MM -DD ' ; return [ 3 , 5 ] ; case 2 : if ( ! ( argv . type = = = 'intraday ' ) ) return [ 3 , 4 ] ; return [ 4 , api . get Intraday Data Frame ( argv . symbol , interval ) ] ; case 3 : data Frame = _a . sent ( ) ; date Format = "YYYY -MM -DD HH :mm :ss " ; return [ 3 , 5 ] ; case 4 : throw new Error ( "Unexpected data type : " + argv . type + " , expected it to be either 'daily ' or 'intrday ' " ) ; case 5 : if ( ! argv . verbose ) { console . log ( ' > > ' + argv . out ) ; } data Frame . transform Series ( { Timestamp : function ( t ) { return moment ( t ) . format ( date Format ) ; } , } ) . as CSV ( ) . write File Sync ( argv . out ) ; return [ 2 ] ; } } ) ; } ) ; } 
function ( name , opts ) { 
function ( val ) { 
function ( val ) { 
function ( val ) { val = this . set Value ( val ) ; if ( ( val ! = = false ) & & ( val ! = = ' ' ) ) { if ( this . has Input ( ) ) { this . input . val ( this . get Value ( ) ) ; } else { this . element . data ( 'picker Value ' , this . get Value ( ) ) ; } this . _trigger ( 'picker Set Source Value ' , { picker Value : val } ) ; } return val ; } 
function ( default Value ) { 
function ( e , p ) { if ( ! e ) return false ; var el = e . target | | e . src Element | | e | | false ; while ( el & & el ! = p ) { el = el . parent Node | | false ; } return ( el ! = = false ) ; } 
function ( el , options ) { events . Event Emitter . call ( this ) ; this . el = el ; this . options = extend ( { } , this . options ) ; this . options = extend ( this . options , options ) ; this . _init ( ) ; } 
function find Uuid Index ( array , uuid ) { for ( let i = 0 , len = array . length ; i < len ; i + + ) { if ( array [ i ] . uuid = = uuid ) { / / eslint -disable -line return i ; } } return - 1 ; } 
function create Markdown Serializer ( indent Code Blocks ) { return { serialize : ( name , suite ) = > snapshot To Markdown ( name , suite , indent Code Blocks ) , deserialize : markdown To Snapshot , } ; } 
function markdown To Snapshot ( content ) { const tree = md Parser . parse ( content ) ; const state = { name : null , suite : null , suite Stack : [ ] , current Suite : null , current Snapshot List : null , depth : 0 } ; const children = tree . children ; for ( let i = 0 ; i < children . length ; i + + ) { const c = children [ i ] ; switch ( c . type ) { case 'heading ' : if ( c . depth = = = 1 ) { enter Root Suite ( state , c ) ; } else if ( c . depth = = = 2 ) { try Exit ( state , suite Depth ( c ) ) ; enter Suite ( state , c ) ; } else if ( c . depth = = = 4 ) { enter Snapshot ( state , c ) ; } break ; case 'code ' : push Snapshot Code ( state , c ) ; break ; } } return { name : state . name , suite : state . suite } ; } 
function try Exit ( state , depth ) { while ( state . depth > = depth ) { state . suite Stack . pop ( ) ; state . current Suite = state . suite Stack [ state . suite Stack . length - 1 ] ; state . current Snapshot List = null ; state . depth - - ; } } 
function enter Root Suite ( state , node ) { const inline Code = node . children [ 0 ] ; const name = inline Code . value ; const suite = { children : { } , snapshots : { } } state . name = name ; state . suite = suite ; state . suite Stack . push ( suite ) ; state . current Suite = suite ; state . current Snapshot List = null ; state . depth = 0 ; } 
function enter Snapshot ( state , node ) { const inline Code = node . children [ 0 ] ; const name = inline Code . value ; const snapshot List = [ ] ; state . current Suite . snapshots [ name ] = snapshot List ; state . current Snapshot List = snapshot List ; } 
function push Snapshot Code ( state , node ) { state . current Snapshot List . push ( { lang : node . lang , code : normalize Newlines ( node . value ) } ) ; } 
function transform Suite ( name , suite , depth , indent Code Blocks ) { const children = suite . children ; const snapshots = suite . snapshots ; const next Depth = depth + 1 ; let result = suite Header ( name , depth ) ; let keys , i ; keys = Object . keys ( snapshots ) ; for ( i = 0 ; i < keys . length ; i + + ) { const key = keys [ i ] ; const snapshot List = snapshots [ key ] ; result + = transform Snapshot List ( key , snapshot List , next Depth , indent Code Blocks ) ; } keys = Object . keys ( children ) ; for ( i = 0 ; i < keys . length ; i + + ) { const key = keys [ i ] ; result + = transform Suite ( key , children [ key ] , next Depth , indent Code Blocks ) ; } return result ; } 
function transform Snapshot List ( name , snapshot List , depth , indent Code Blocks ) { let result = snapshot Header ( name , depth ) ; for ( let i = 0 ; i < snapshot List . length ; i + + ) { if ( i > 0 & & indent Code Blocks ) { result + = ' - - - \n \n ' ; } const snapshot = snapshot List [ i ] ; const lang = snapshot . lang ; const code = snapshot . code ; const delimiter = safe Delimiter ( code ) ; if ( indent Code Blocks ) { const lines = code . split ( ' \n ' ) ; for ( let i = 0 ; i < lines . length ; i + + ) { result + = ' ' + lines [ i ] + ' \n ' ; } } else { result + = delimiter ; if ( lang ) { result + = lang ; } result + = ' \n ' + code + ' \n ' + delimiter + ' \n ' ; } result + = ' \n ' ; } return result ; } 
function suite Header ( name , depth ) { if ( depth = = = - 1 ) { return " # " + serialize Name ( name ) + " \n \n " ; } return " # # " + indent ( depth ) + serialize Name ( name ) + " \n \n " ; } 
function safe Delimiter ( s , delimiter ) { if ( delimiter = = = undefined ) { delimiter = ' ` ` ` ' ; } while ( s . index Of ( delimiter ) ! = = - 1 ) { delimiter + = ' ` ' ; } return delimiter ; } 
function default Path Resolver ( base Path , suite Name ) { const suite Source Path = path . join ( base Path , suite Name ) ; const suite Source Dir = path . dirname ( suite Source Path ) ; const source File Name = path . basename ( suite Name ) ; return path . join ( suite Source Dir , " _ _snapshots _ _ " , source File Name + " .md " ) ; } 
function format Snapshot List ( list , limit ) { limit = ( typeof limit ! = 'undefined ' ) ? limit : - 1 ; const limited List = limit > 0 ? list . slice ( 0 , limit ) : list ; const has More = list . length > limited List . length ; const build List = ( snapshots ) = > snapshots . map ( ( s ) = > s . join ( ' > ' ) ) . join ( ' \n ' ) ; if ( has More ) { return build List ( limited List . slice ( 0 , - 1 ) ) + ` \n $ { list . length - limited List . length + 1 } ` ; } return build List ( limited List ) ; } 
function format Unused Snapshots Warning ( list , limit ) { if ( limit = = 0 ) { return ` $ { list . length } ` ; } const pruned List = format Snapshot List ( list , limit ) ; return ` $ { list . length } \n $ { pruned List } ` ; } 
function snapshot Framework ( files , config , emitter , logger Factory ) { const logger = logger Factory . create ( 'framework .snapshot ' ) ; const snapshot Config = Object . assign ( { update : false , prune : false , format : "md " , check Source File : false , path Resolver : default Path Resolver , limit Unused Snapshots In Warning : - 1 } , config . snapshot ) ; if ( typeof snapshot Config . format = = = "string " ) { switch ( snapshot Config . format ) { case "indented -md " : snapshot Serializer = create Markdown Serializer ( true ) ; break ; case "md " : default : snapshot Serializer = create Markdown Serializer ( false ) ; } } else { snapshot Serializer = snapshot Config . format ; } 
function snapshot Preprocessor ( base Path , logger Factory ) { const logger = logger Factory . create ( 'preprocessor .snapshot ' ) ; return function ( content , file , done ) { const root = snapshot Serializer . deserialize ( content ) ; done ( iife Wrapper ( 'window . _ _snapshot _ _ .add Suite ( " ' + root . name + ' " , ' + JSON . stringify ( root . suite ) + ' ) ; ' ) ) ; } ; } 
function single Line Plugin ( options = { } ) { options = Object . assign ( { } , default Options , options ) return { block Render Map : Map ( { 'unstyled ' : { element : 'div ' , } , } ) , on Change ( editor State ) { const blocks = editor State . get Current Content ( ) . get Blocks As Array ( ) * Stop new lines being inserted by always handling the return * * @param {Keyboard Event } e Synthetic keyboard event from draftjs * @return {String } Did we handle the return or not ? (pro -trip : yes , we did ) * / handle Return ( e ) { return 'handled ' } , } } 
function replace Newlines ( str ) { var replacement = arguments . length < = 1 | | arguments [ 1 ] = = = undefined ? ' ' : arguments [ 1 ] ; return str . replace ( NEWLINE _REGEX , replacement ) ; } 
function condense Blocks ( editor State , blocks , options ) { blocks = blocks | | editor State . get Current Content ( ) . get Blocks As Array ( ) ; var text = ( 0 , _immutable . List ) ( ) ; var character List = ( 0 , _immutable . List ) ( ) ; 
function character Listhas Entities ( character List ) { var has Entities = false ; character List . for Each ( function ( character Meta ) { if ( character Meta . get ( 'entity ' ) ! = = null ) { has Entities = true ; } } ) ; return has Entities ; } 
function get Closest Version ( ) { if ( ! process . versions . v 8 ) { 
function Gst Launch ( ) { const gst _launch _executable = 'gst -launch - 1 . 0 ' ; const gst _launch _versionarg = ' - -version ' ; const Spawn Sync = require ( 'child _process ' ) . spawn Sync ; const Spawn = require ( 'child _process ' ) . spawn ; const Assert = require ( 'assert ' ) ; const Path = require ( 'path ' ) ; const OS = require ( 'os ' ) ; const FS = require ( 'fs ' ) ; var get Path = function ( ) { var detected _path = undefined ; if ( OS . platform ( ) = = 'win 3 2 ' ) { * @fn get Version * @brief Returns version string of GStreamer on this machine by * invoking the gst -launch executable or 'undefined ' on failure . * / var get Version = function ( ) { var version _str = undefined ; try { var gst _launch _path = get Path ( ) ; Assert . ok ( typeof ( gst _launch _path ) , 'string ' ) ; var output = Spawn Sync ( gst _launch _path , [ gst _launch _versionarg ] , { 'timeout ' : 1 0 0 0 } ) . stdout ; if ( output & & output . to String ( ) . includes ( 'GStreamer ' ) ) { version _str = output . to String ( ) . match ( / GStreamer \s + . + / g ) [ 0 ] . replace ( / GStreamer \s + / , ' ' ) ; } } catch ( ex ) { version _str = undefined ; } return version _str ; } var is Available = function ( ) { return get Version ( ) ! = undefined ; } var spawn Pipeline = function ( pipeline ) { Assert . ok ( typeof ( pipeline ) , 'string ' ) ; Assert . ok ( is Available ( ) , "gst -launch is not available . " ) ; var gst _launch _path = get Path ( ) ; Assert . ok ( typeof ( gst _launch _path ) , 'string ' ) ; return Spawn ( gst _launch _path , pipeline . split ( ' ' ) ) ; } return { 'get Path ' : get Path , 'get Version ' : get Version , 'is Available ' : is Available , 'spawn Pipeline ' : spawn Pipeline } } 
function ( pipeline ) { Assert . ok ( typeof ( pipeline ) , 'string ' ) ; Assert . ok ( is Available ( ) , "gst -launch is not available . " ) ; var gst _launch _path = get Path ( ) ; Assert . ok ( typeof ( gst _launch _path ) , 'string ' ) ; return Spawn ( gst _launch _path , pipeline . split ( ' ' ) ) ; } 
function Gst Live Cam Server ( config ) { const Assert = require ( 'assert ' ) ; const OS = require ( 'os ' ) ; Assert . ok ( [ 'win 3 2 ' , 'linux ' , 'darwin ' ] . index Of ( OS . platform ( ) ) > - 1 , "livecam module supports Windows , Linux , and Mac OSX for broadcasting . " ) ; config = config | | { } ; Assert . ok ( typeof ( config ) , 'object ' ) ; const fake = config . fake | | false ; const width = config . width | | 8 0 0 ; const height = config . height | | 6 0 0 ; const framerate = config . framerate | | 3 0 ; const grayscale = config . grayscale | | false ; const device Index = config . device Index | | - 1 ; Assert . ok ( typeof ( fake ) , 'boolean ' ) ; Assert . ok ( typeof ( width ) , 'number ' ) ; Assert . ok ( typeof ( height ) , 'number ' ) ; Assert . ok ( typeof ( framerate ) , 'number ' ) ; Assert . ok ( typeof ( grayscale ) , 'boolean ' ) ; var gst _multipart _boundary = ' - -videoboundary ' ; var gst _video _src = ' ' ; if ( ! fake ) { if ( OS . platform ( ) = = 'win 3 2 ' ) gst _video _src = 'ksvideosrc device -index = ' + device Index + ' ! decodebin ' ; else if ( OS . platform ( ) = = 'linux ' ) gst _video _src = 'v 4l 2src ! decodebin ' ; else if ( OS . platform ( ) = = 'darwin ' ) gst _video _src = 'avfvideosrc device -index = ' + device Index ; else Assert . ok ( false , 'unsupported platform ' ) } else { gst _video _src = 'videotestsrc ' ; } if ( width > 0 | | height > 0 ) { gst _video _src + = ' ! videoscale ! video /x -raw ,width = ' + parse Int ( width ) + ' ,height = ' + parse Int ( height ) ; } if ( framerate > 0 ) { gst _video _src + = ' ! videorate ! video /x -raw ,framerate = ' + parse Int ( framerate ) + ' / 1 ' ; } if ( grayscale ) { gst _video _src + = ' ! videobalance saturation = 0 . 0 ! videoconvert ' ; } var start = function ( tcp _addr , tcp _port ) { Assert . ok ( typeof ( tcp _addr ) , 'string ' ) ; Assert . ok ( typeof ( tcp _port ) , 'number ' ) ; const cam _pipeline = gst _video _src + ' ! jpegenc ! multipartmux boundary = " ' + gst _multipart _boundary + ' " ! tcpserversink host = ' + tcp _addr + ' port = ' + tcp _port ; var gst _launch = new Gst Launch ( ) ; if ( gst _launch . is Available ( ) ) { console . log ( 'Gst Launch found : ' + gst _launch . get Path ( ) ) ; console . log ( 'GStreamer version : ' + gst _launch . get Version ( ) ) ; console . log ( 'GStreamer pipeline : ' + cam _pipeline ) ; return gst _launch . spawn Pipeline ( cam _pipeline ) ; } else { throw new Error ( 'Gst Launch not found . ' ) ; } } return { 'start ' : start } } 
function ( tcp _addr , tcp _port ) { Assert . ok ( typeof ( tcp _addr ) , 'string ' ) ; Assert . ok ( typeof ( tcp _port ) , 'number ' ) ; const cam _pipeline = gst _video _src + ' ! jpegenc ! multipartmux boundary = " ' + gst _multipart _boundary + ' " ! tcpserversink host = ' + tcp _addr + ' port = ' + tcp _port ; var gst _launch = new Gst Launch ( ) ; if ( gst _launch . is Available ( ) ) { console . log ( 'Gst Launch found : ' + gst _launch . get Path ( ) ) ; console . log ( 'GStreamer version : ' + gst _launch . get Version ( ) ) ; console . log ( 'GStreamer pipeline : ' + cam _pipeline ) ; return gst _launch . spawn Pipeline ( cam _pipeline ) ; } else { throw new Error ( 'Gst Launch not found . ' ) ; } } 
function Socket Cam Wrapper ( gst _tcp _addr , gst _tcp _port , broadcast _tcp _addr , broadcast _tcp _port ) { const Net = require ( 'net ' ) ; const Http = require ( 'http ' ) ; const Dicer = require ( 'dicer ' ) ; const Assert = require ( 'assert ' ) ; const Socket IO = require ( 'socket .io ' ) ; const gst _multipart _boundary = ' - -videoboundary ' ; var wrap = function ( gst _tcp _addr , gst _tcp _port , broadcast _tcp _addr , broadcast _tcp _port ) { Assert . ok ( typeof ( gst _tcp _addr ) , 'string ' ) ; Assert . ok ( typeof ( gst _tcp _port ) , 'number ' ) ; Assert . ok ( typeof ( broadcast _tcp _addr ) , 'string ' ) ; Assert . ok ( typeof ( broadcast _tcp _port ) , 'number ' ) ; var socket = Net . Socket ( ) ; socket . connect ( gst _tcp _port , gst _tcp _addr , function ( ) { var io = Socket IO . listen ( Http . create Server ( ) . listen ( broadcast _tcp _port , broadcast _tcp _addr ) ) ; var dicer = new Dicer ( { boundary : gst _multipart _boundary } ) ; dicer . on ( 'part ' , function ( part ) { var frame Encoded = ' ' ; part . set Encoding ( 'base 6 4 ' ) ; part . on ( 'data ' , function ( data ) { frame Encoded + = data ; } ) ; part . on ( 'end ' , function ( ) { io . sockets . emit ( 'image ' , frame Encoded ) ; } ) ; } ) ; dicer . on ( 'finish ' , function ( ) { console . log ( 'Dicer finished : ' + broadcast _tcp _addr + ' : ' + broadcast _tcp _port ) ; } ) ; socket . on ( 'close ' , function ( ) { console . log ( 'Socket closed : ' + broadcast _tcp _addr + ' : ' + broadcast _tcp _port ) ; } ) ; socket . pipe ( dicer ) ; } ) ; } return { 'wrap ' : wrap } } 
function Live Cam UI ( ) { const Http = require ( 'http ' ) ; const Assert = require ( 'assert ' ) ; const template = ( function ( ) { } ) . to String ( ) . match ( / \ / \ * \s * ( [ \s \S ] * ? ) \s * \ * \ / / m ) [ 1 ] ; var server = undefined ; var serve = function ( ui _addr , ui _port , webcam _addr , webcam _port ) { Assert . ok ( typeof ( ui _addr ) , 'object ' ) ; Assert . ok ( typeof ( ui _port ) , 'number ' ) ; Assert . ok ( typeof ( webcam _addr ) , 'object ' ) ; Assert . ok ( typeof ( webcam _port ) , 'number ' ) ; close ( ) ; server = Http . create Server ( function ( request , response ) { response . write Head ( 2 0 0 , { "Content -Type " : "text /html " } ) ; response . write ( template . replace ( ' @WEBCAM _ADDR @ ' , webcam _addr ) . replace ( ' @WEBCAM _PORT @ ' , webcam _port ) ) ; response . end ( ) ; } ) ; server . listen ( ui _port , ui _addr ) ; console . log ( 'Open http : / / ' + ui _addr + ' : ' + ui _port + ' / in your browser ! ' ) ; } var close = function ( ) { if ( server ) { server . close ( ) ; server = undefined ; } } return { 'serve ' : serve , 'close ' : close } } 
function Live Cam ( config ) { const Assert = require ( 'assert ' ) ; config = config | | { } ; Assert . ok ( typeof ( config ) , 'object ' ) ; const gst _tcp _addr = config . gst _addr | | " 1 2 7 . 0 . 0 . 1 " ; const gst _tcp _port = config . gst _port | | 1 0 0 0 0 ; const ui _addr = config . ui _addr | | " 1 2 7 . 0 . 0 . 1 " ; const ui _port = config . ui _port | | 1 1 0 0 0 ; const broadcast _addr = config . broadcast _addr | | " 1 2 7 . 0 . 0 . 1 " ; const broadcast _port = config . broadcast _port | | 1 2 0 0 0 ; const start = config . start ; const webcam = config . webcam | | { } ; if ( start ) Assert . ok ( typeof ( start ) , 'function ' ) ; if ( broadcast _port ) Assert . ok ( typeof ( broadcast _port ) , 'number ' ) ; if ( broadcast _addr ) Assert . ok ( typeof ( broadcast _addr ) , 'string ' ) ; if ( ui _port ) Assert . ok ( typeof ( ui _port ) , 'number ' ) ; if ( ui _addr ) Assert . ok ( typeof ( ui _addr ) , 'string ' ) ; if ( gst _tcp _port ) Assert . ok ( typeof ( gst _tcp _port ) , 'number ' ) ; if ( gst _tcp _addr ) Assert . ok ( typeof ( gst _tcp _addr ) , 'string ' ) ; if ( webcam ) Assert . ok ( typeof ( webcam ) , 'object ' ) ; if ( ! ( new Gst Launch ( ) ) . is Available ( ) ) { console . log ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) ; console . log ( "Unable to locate gst -launch executable . " ) ; console . log ( "Look at https : / /github .com /sepehr -laal /livecam " ) ; console . log ( "You are most likely missing the GStreamer runtime . " ) ; console . log ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) ; throw new Error ( 'Unable to broadcast . ' ) ; } console . log ( "Live Cam parameters : " , { 'broadcast _addr ' : broadcast _addr , 'broadcast _port ' : broadcast _port , 'ui _addr ' : ui _addr , 'ui _port ' : ui _port , 'gst _tcp _addr ' : gst _tcp _addr , 'gst _tcp _port ' : gst _tcp _port } ) ; var broadcast = function ( ) { var gst _cam _ui = new Live Cam UI ( ) ; var gst _cam _wrap = new Socket Cam Wrapper ( ) ; var gst _cam _server = new Gst Live Cam Server ( webcam ) ; var gst _cam _process = gst _cam _server . start ( gst _tcp _addr , gst _tcp _port ) ; gst _cam _process . stdout . on ( 'data ' , function ( data ) { console . log ( data . to String ( ) ) ; 
function hex Rgb ( hex ) { let shorthand Check = / ^ ( [a -f \d ] ) ( [a -f \d ] ) ( [a -f \d ] ) $ / i , rgb Regex = / ^ ( [a -f \d ] { 2 } ) ( [a -f \d ] { 2 } ) ( [a -f \d ] { 2 } ) $ / i , rgb ; hex = hex . replace ( shorthand Check , function ( m , r , g , b ) { return r + r + g + g + b + b ; } ) ; rgb = hex . replace ( / ^ \s + | \s + $ / g , ' ' ) . match ( rgb Regex ) ; 
function rule Handler ( decl , result ) { let input = decl . value ; 
function Segment ( config ) { this . config = config ; 
function ( ) { for ( var i = 0 ; i < this . config . methods . length ; i + + ) { var key = this . config . methods [ i ] ; 
function Segment Provider ( segment Default Config ) { this . config = angular . copy ( segment Default Config ) ; 
function es 2 0 2 0 ( filename , options ) { if ( / \ .json $ / i . test ( filename ) ) return through ( ) const bufs = [ ] const transform Stream = through ( write , end ) return transform Stream function write ( buf , enc , next ) { bufs . push ( buf ) next ( ) } function end ( ) { const src = Buffer . concat ( bufs ) . to String ( 'utf 8 ' ) try { var res = babel . transform ( src , { plugins : preset . plugins , source Maps : options . _flags . debug ? 'inline ' : false , filename : filename , compact : false } ) } catch ( err ) { this . emit ( 'error ' , err ) return } this . push ( res . code ) this . push ( null ) } } 
function bulvar ( g ) { g . each ( function ( d , i ) { var rangez = ranges . call ( this , d , i ) . slice ( ) . sort ( d 3Descending ) , markerz = markers . call ( this , d , i ) . slice ( ) . sort ( d 3Descending ) , measurez = measures . call ( this , d , i ) . slice ( ) . sort ( d 3Descending ) , g 2 = d 3Select ( this ) , extent X , extent Y ; var wrap = g 2 . select ( "g .wrap " ) ; if ( wrap . empty ( ) ) wrap = g 2 . append ( "g " ) . attr ( "class " , "wrap " ) ; if ( vertical ) { extent X = height , extent Y = width ; wrap . attr ( "transform " , "rotate ( 9 0 )translate ( 0 , " + - width + " ) " ) ; } else { extent X = width , extent Y = height ; wrap . attr ( "transform " , null ) ; } 
function generate Uuid ( target , namespace , version ) { if ( typeof target ! = = 'string ' ) { throw Type Error ( 'Value must be string ' ) ; } if ( typeof namespace = = = 'number ' ) { return generate Uuid ( target , undefined , namespace ) ; } if ( version = = null ) { return generate Uuid ( target , namespace , 5 ) ; } if ( version ! = = 3 & & version ! = = 5 ) { throw Type Error ( 'Version of UUID can be only 3 or 5 ' ) ; } 
function get Color Grad ( pct , col , max Bri ) { var no , inc , colors , percentage , rval , gval , bval , lower , upper , range , range Pct , pct Lower , pct Upper , color , pow ; no = col . length ; if ( no = = = 1 ) return col [ 0 ] ; inc = 1 / ( no - 1 ) ; colors = [ ] ; for ( var i = 0 ; i < col . length ; i + + ) { if ( typeof col [ i ] = = = 'object ' ) { percentage = col [ i ] . pct ? col [ i ] . pct : inc * i ; pow = col [ i ] . pow | | 1 ; rval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 0 , 2 ) , 1 6 ) ; gval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 2 , 4 ) , 1 6 ) ; bval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 4 , 6 ) , 1 6 ) ; } else { percentage = inc * i ; pow = 1 ; rval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 0 , 2 ) , 1 6 ) ; gval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 2 , 4 ) , 1 6 ) ; bval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 4 , 6 ) , 1 6 ) ; } colors [ i ] = { pct : percentage , pow : pow , color : { r : rval , g : gval , b : bval } } ; } if ( pct = = = 0 ) { return 'rgb ( ' + [ colors [ 0 ] . color . r , colors [ 0 ] . color . g , colors [ 0 ] . color . b ] . join ( ' , ' ) + ' ) ' ; } for ( var j = 0 ; j < colors . length ; j + + ) { if ( pct < = colors [ j ] . pct ) { var color Max = Math . max ( colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ) ; lower = colors [ j - 1 ] ; upper = colors [ j ] ; range = upper . pct - lower . pct ; range Pct = Math . pow ( ( pct - lower . pct ) / range , colors [ j ] . pow / colors [ j - 1 ] . pow ) ; pct Lower = 1 - range Pct ; pct Upper = range Pct ; color = { r : Math . floor ( lower . color . r * pct Lower + upper . color . r * pct Upper ) , g : Math . floor ( lower . color . g * pct Lower + upper . color . g * pct Upper ) , b : Math . floor ( lower . color . b * pct Lower + upper . color . b * pct Upper ) } ; if ( max Bri ) { var color Max 2 = Math . max ( color . r , color . g , color . b ) ; return 'rgb ( ' + [ Math . floor ( color . r / color Max 2 * color Max ) , Math . floor ( color . g / color Max 2 * color Max ) , Math . floor ( color . b / color Max 2 * color Max ) ] . join ( ' , ' ) + ' ) ' ; } else { return 'rgb ( ' + [ color . r , color . g , color . b ] . join ( ' , ' ) + ' ) ' ; } } } } 
function kv Lookup ( key , tablea , tableb , defval , datatype , delimiter ) { var val = defval ; var can Convert = false ; if ( ! ( key = = = null | | key = = = undefined ) ) { if ( tableb ! = = null & & tableb ! = = undefined & & typeof tableb = = = "object " & & key in tableb ) { val = tableb [ key ] ; can Convert = true ; } else if ( tablea ! = = null & & tablea ! = = undefined & & typeof tablea = = = "object " & & key in tablea ) { val = tablea [ key ] ; can Convert = true ; } else { val = defval ; } if ( can Convert = = = true ) { if ( datatype ! = = null & & datatype ! = = undefined ) { switch ( datatype ) { case 'int ' : val = parse Int ( val , 1 0 ) ; break ; case 'float ' : val = parse Float ( val ) ; break ; default : break ; } } } } return val ; } 
function get Color ( val , pct , col , no Gradient , cust Sec , full Bri ) { var no , inc , colors , percentage , rval , gval , bval , lower , upper , range , range Pct , pct Lower , pct Upper , color , pow ; var no Gradient = no Gradient | | cust Sec . length > 0 ; if ( cust Sec . length > 0 ) { for ( var i = 0 ; i < cust Sec . length ; i + + ) { if ( val > = cust Sec [ i ] . lo & & val < = cust Sec [ i ] . hi ) { return cust Sec [ i ] . color ; } } } no = col . length ; if ( no = = = 1 ) return col [ 0 ] ; inc = ( no Gradient ) ? ( 1 / no ) : ( 1 / ( no - 1 ) ) ; colors = [ ] ; for ( i = 0 ; i < col . length ; i + + ) { if ( typeof col [ i ] = = = 'object ' ) { percentage = col [ i ] . pct ? col [ i ] . pct : ( ( no Gradient ) ? ( inc * ( i + 1 ) ) : ( inc * i ) ) ; pow = col [ i ] . pow | | 1 ; rval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 0 , 2 ) , 1 6 ) ; gval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 2 , 4 ) , 1 6 ) ; bval = parse Int ( ( cut Hex ( col [ i ] . color ) ) . substring ( 4 , 6 ) , 1 6 ) ; } else { percentage = ( no Gradient ) ? ( inc * ( i + 1 ) ) : ( inc * i ) ; pow = 1 ; rval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 0 , 2 ) , 1 6 ) ; gval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 2 , 4 ) , 1 6 ) ; bval = parse Int ( ( cut Hex ( col [ i ] ) ) . substring ( 4 , 6 ) , 1 6 ) ; } colors [ i ] = { pct : percentage , pow : pow , color : { r : rval , g : gval , b : bval } } ; } if ( pct = = = 0 ) { return 'rgb ( ' + [ colors [ 0 ] . color . r , colors [ 0 ] . color . g , colors [ 0 ] . color . b ] . join ( ' , ' ) + ' ) ' ; } for ( var j = 0 ; j < colors . length ; j + + ) { if ( pct < = colors [ j ] . pct ) { var color Max = Math . max ( colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ) ; if ( no Gradient ) { return 'rgb ( ' + [ colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ] . join ( ' , ' ) + ' ) ' ; } else { lower = colors [ j - 1 ] ; upper = colors [ j ] ; range = upper . pct - lower . pct ; range Pct = Math . pow ( ( pct - lower . pct ) / range , colors [ j ] . pow / colors [ j - 1 ] . pow ) ; pct Lower = 1 - range Pct ; pct Upper = range Pct ; color = { r : Math . floor ( lower . color . r * pct Lower + upper . color . r * pct Upper ) , g : Math . floor ( lower . color . g * pct Lower + upper . color . g * pct Upper ) , b : Math . floor ( lower . color . b * pct Lower + upper . color . b * pct Upper ) } ; if ( full Bri ) { color Max 2 = Math . max ( color . r , color . g , color . b ) ; return 'rgb ( ' + [ Math . floor ( color . r / color Max 2 * color Max ) , Math . floor ( color . g / color Max 2 * color Max ) , Math . floor ( color . b / color Max 2 * color Max ) ] . join ( ' , ' ) + ' ) ' ; } else { return 'rgb ( ' + [ color . r , color . g , color . b ] . join ( ' , ' ) + ' ) ' ; } } } } } 
function set Dy ( elem , font Size , txt Ypos ) { if ( ( ! ie | | ie > 9 ) & & elem . node . first Child . attributes . dy ) { elem . node . first Child . attributes . dy . value = 0 ; } } 
function human Friendly Number ( n , d ) { var p , d 2 , i , s ; p = Math . pow ; d 2 = p ( 1 0 , d ) ; i = 7 ; while ( i ) { s = p ( 1 0 , i - - * 3 ) ; if ( s < = n ) { n = Math . round ( n * d 2 / s ) / d 2 + "KMGTPE " [ i ] ; } } return n ; } 
function format Number ( x ) { var parts = x . to String ( ) . split ( " . " ) ; parts [ 0 ] = parts [ 0 ] . replace ( / \B ( ? = ( \d { 3 } ) + ( ? ! \d ) ) / g , " , " ) ; return parts . join ( " . " ) ; } 
function fmt Short ( ms ) { if ( ms > = d $ 1 ) { return Math . round ( ms / d $ 1 ) + 'd ' } if ( ms > = h ) { return Math . round ( ms / h ) + 'h ' } if ( ms > = m ) { return Math . round ( ms / m ) + 'm ' } if ( ms > = s ) { return Math . round ( ms / s ) + 's ' } return ms + 'ms ' } 
function fmt Long ( ms ) { return plural ( ms , d $ 1 , 'day ' ) | | plural ( ms , h , 'hour ' ) | | plural ( ms , m , 'minute ' ) | | plural ( ms , s , 'second ' ) | | ms + ' ms ' } 
function debug ( namespace ) { 
function enable ( namespaces ) { exports . save ( namespaces ) ; var split = ( namespaces | | ' ' ) . split ( / [ \s , ] + / ) ; var len = split . length ; for ( var i = 0 ; i < len ; i + + ) { if ( ! split [ i ] ) continue ; 
function ( val , options ) { options = options | | { } ; if ( 'string ' = = typeof val ) return parse $ 1 ( val ) ; return options . long ? long ( val ) : short ( val ) ; } 
function parse $ 1 ( str ) { str = ' ' + str ; if ( str . length > 1 0 0 0 0 ) return ; var match = / ^ ( ( ? : \d + ) ? \ . ? \d + ) * (milliseconds ? |msecs ? |ms |seconds ? |secs ? |s |minutes ? |mins ? |m |hours ? |hrs ? |h |days ? |d |years ? |yrs ? |y ) ? $ / i . exec ( str ) ; if ( ! match ) return ; var n = parse Float ( match [ 1 ] ) ; var type = ( match [ 2 ] | | 'ms ' ) . to Lower Case ( ) ; switch ( type ) { case 'years ' : case 'year ' : case 'yrs ' : case 'yr ' : case 'y ' : return n * y $ 1 ; case 'days ' : case 'day ' : case 'd ' : return n * d $ 2 ; case 'hours ' : case 'hour ' : case 'hrs ' : case 'hr ' : case 'h ' : return n * h $ 1 ; case 'minutes ' : case 'minute ' : case 'mins ' : case 'min ' : case 'm ' : return n * m $ 1 ; case 'seconds ' : case 'second ' : case 'secs ' : case 'sec ' : case 's ' : return n * s $ 1 ; case 'milliseconds ' : case 'millisecond ' : case 'msecs ' : case 'msec ' : case 'ms ' : return n ; } } 
function short ( ms ) { if ( ms > = d $ 2 ) return Math . round ( ms / d $ 2 ) + 'd ' ; if ( ms > = h $ 1 ) return Math . round ( ms / h $ 1 ) + 'h ' ; if ( ms > = m $ 1 ) return Math . round ( ms / m $ 1 ) + 'm ' ; if ( ms > = s $ 1 ) return Math . round ( ms / s $ 1 ) + 's ' ; return ms + 'ms ' ; } 
function long ( ms ) { return plural $ 1 ( ms , d $ 2 , 'day ' ) | | plural $ 1 ( ms , h $ 1 , 'hour ' ) | | plural $ 1 ( ms , m $ 1 , 'minute ' ) | | plural $ 1 ( ms , s $ 1 , 'second ' ) | | ms + ' ms ' ; } 
function plural $ 1 ( ms , n , name ) { if ( ms < n ) return ; if ( ms < n * 1 . 5 ) return Math . floor ( ms / n ) + ' ' + name ; return Math . ceil ( ms / n ) + ' ' + name + 's ' ; } 
function is Buf $ 1 ( obj ) { return ( commonjs Global . Buffer & & commonjs Global . Buffer . is Buffer ( obj ) ) | | ( commonjs Global . Array Buffer & & obj instanceof Array Buffer ) ; } 
function encode $ 1 ( num ) { var encoded = ' ' ; do { encoded = alphabet [ num % length ] + encoded ; num = Math . floor ( num / length ) ; } while ( num > 0 ) ; return encoded ; } 
function decode $ 1 ( str ) { var decoded = 0 ; for ( i = 0 ; i < str . length ; i + + ) { decoded = decoded * length + map [ str . char At ( i ) ] ; } return decoded ; } 
function yeast $ 1 ( ) { var now = encode $ 1 ( + new Date ( ) ) ; if ( now ! = = prev ) return seed = 0 , prev = now ; return now + ' . ' + encode $ 1 ( seed + + ) ; } 
function ( val , options ) { options = options | | { } ; var type = typeof val ; if ( type = = = 'string ' & & val . length > 0 ) { return parse $ 2 ( val ) } else if ( type = = = 'number ' & & is Na N ( val ) = = = false ) { return options . long ? fmt Long $ 1 ( val ) : fmt Short $ 1 ( val ) } throw new Error ( 'val is not a non -empty string or a valid number . val = ' + JSON . stringify ( val ) ) } 
function parse $ 2 ( str ) { str = String ( str ) ; if ( str . length > 1 0 0 0 0 ) { return } var match = / ^ ( ( ? : \d + ) ? \ . ? \d + ) * (milliseconds ? |msecs ? |ms |seconds ? |secs ? |s |minutes ? |mins ? |m |hours ? |hrs ? |h |days ? |d |years ? |yrs ? |y ) ? $ / i . exec ( str ) ; if ( ! match ) { return } var n = parse Float ( match [ 1 ] ) ; var type = ( match [ 2 ] | | 'ms ' ) . to Lower Case ( ) ; switch ( type ) { case 'years ' : case 'year ' : case 'yrs ' : case 'yr ' : case 'y ' : return n * y $ 2 case 'days ' : case 'day ' : case 'd ' : return n * d $ 3 case 'hours ' : case 'hour ' : case 'hrs ' : case 'hr ' : case 'h ' : return n * h $ 2 case 'minutes ' : case 'minute ' : case 'mins ' : case 'min ' : case 'm ' : return n * m $ 2 case 'seconds ' : case 'second ' : case 'secs ' : case 'sec ' : case 's ' : return n * s $ 2 case 'milliseconds ' : case 'millisecond ' : case 'msecs ' : case 'msec ' : case 'ms ' : return n default : return undefined } } 
function fmt Short $ 1 ( ms ) { if ( ms > = d $ 3 ) { return Math . round ( ms / d $ 3 ) + 'd ' } if ( ms > = h $ 2 ) { return Math . round ( ms / h $ 2 ) + 'h ' } if ( ms > = m $ 2 ) { return Math . round ( ms / m $ 2 ) + 'm ' } if ( ms > = s $ 2 ) { return Math . round ( ms / s $ 2 ) + 's ' } return ms + 'ms ' } 
function fmt Long $ 1 ( ms ) { return plural $ 2 ( ms , d $ 3 , 'day ' ) | | plural $ 2 ( ms , h $ 2 , 'hour ' ) | | plural $ 2 ( ms , m $ 2 , 'minute ' ) | | plural $ 2 ( ms , s $ 2 , 'second ' ) | | ms + ' ms ' } 
function plural $ 2 ( ms , n , name ) { if ( ms < n ) { return } if ( ms < n * 1 . 5 ) { return Math . floor ( ms / n ) + ' ' + name } return Math . ceil ( ms / n ) + ' ' + name + 's ' } 
function Polling $ 1 ( opts ) { var force Base 6 4 = ( opts & & opts . force Base 6 4 ) ; if ( ! has XHR 2 | | force Base 6 4 ) { this . supports Binary = false ; } Transport . call ( this , opts ) ; } 
function JSONPPolling ( opts ) { Polling $ 2 . call ( this , opts ) ; this . query = this . query | | { } ; 
function onupgrade ( to ) { if ( transport $ $ 1 & & to . name ! = = transport $ $ 1 . name ) { debug $ 2 ( ' " %s " works - aborting " %s " ' , to . name , transport $ $ 1 . name ) ; freeze Transport ( ) ; } } 
function cleanup ( ) { transport $ $ 1 . remove Listener ( 'open ' , on Transport Open ) ; transport $ $ 1 . remove Listener ( 'error ' , onerror ) ; transport $ $ 1 . remove Listener ( 'close ' , on Transport Close ) ; self . remove Listener ( 'close ' , onclose ) ; self . remove Listener ( 'upgrading ' , onupgrade ) ; } 
function Backoff $ 1 ( opts ) { opts = opts | | { } ; this . ms = opts . min | | 1 0 0 ; this . max = opts . max | | 1 0 0 0 0 ; this . factor = opts . factor | | 2 ; this . jitter = opts . jitter > 0 & & opts . jitter < = 1 ? opts . jitter : 0 ; this . attempts = 0 ; } 
function ( val , options ) { options = options | | { } ; var type = typeof val ; if ( type = = = 'string ' & & val . length > 0 ) { return parse $ 3 ( val ) ; } else if ( type = = = 'number ' & & is Na N ( val ) = = = false ) { return options . long ? fmt Long $ 2 ( val ) : fmt Short $ 2 ( val ) ; } throw new Error ( 'val is not a non -empty string or a valid number . val = ' + JSON . stringify ( val ) ) ; } 
function parse $ 3 ( str ) { str = String ( str ) ; if ( str . length > 1 0 0 ) { return ; } var match = / ^ ( ( ? : \d + ) ? \ . ? \d + ) * (milliseconds ? |msecs ? |ms |seconds ? |secs ? |s |minutes ? |mins ? |m |hours ? |hrs ? |h |days ? |d |years ? |yrs ? |y ) ? $ / i . exec ( str ) ; if ( ! match ) { return ; } var n = parse Float ( match [ 1 ] ) ; var type = ( match [ 2 ] | | 'ms ' ) . to Lower Case ( ) ; switch ( type ) { case 'years ' : case 'year ' : case 'yrs ' : case 'yr ' : case 'y ' : return n * y $ 3 ; case 'days ' : case 'day ' : case 'd ' : return n * d $ 4 ; case 'hours ' : case 'hour ' : case 'hrs ' : case 'hr ' : case 'h ' : return n * h $ 3 ; case 'minutes ' : case 'minute ' : case 'mins ' : case 'min ' : case 'm ' : return n * m $ 3 ; case 'seconds ' : case 'second ' : case 'secs ' : case 'sec ' : case 's ' : return n * s $ 3 ; case 'milliseconds ' : case 'millisecond ' : case 'msecs ' : case 'msec ' : case 'ms ' : return n ; default : return undefined ; } } 
function fmt Short $ 2 ( ms ) { if ( ms > = d $ 4 ) { return Math . round ( ms / d $ 4 ) + 'd ' ; } if ( ms > = h $ 3 ) { return Math . round ( ms / h $ 3 ) + 'h ' ; } if ( ms > = m $ 3 ) { return Math . round ( ms / m $ 3 ) + 'm ' ; } if ( ms > = s $ 3 ) { return Math . round ( ms / s $ 3 ) + 's ' ; } return ms + 'ms ' ; } 
function fmt Long $ 2 ( ms ) { return plural $ 3 ( ms , d $ 4 , 'day ' ) | | plural $ 3 ( ms , h $ 3 , 'hour ' ) | | plural $ 3 ( ms , m $ 3 , 'minute ' ) | | plural $ 3 ( ms , s $ 3 , 'second ' ) | | ms + ' ms ' ; } 
function plural $ 3 ( ms , n , name ) { if ( ms < n ) { return ; } if ( ms < n * 1 . 5 ) { return Math . floor ( ms / n ) + ' ' + name ; } return Math . ceil ( ms / n ) + ' ' + name + 's ' ; } 
function extract ( str , options ) { const res = babylon . parse ( str , options ) ; return res . comments ; } 
function extend Api ( api ) { api . $on = ( event Name , callback ) = > { const wrapped Callback = ( ) = > { $timeout ( ( ) = > { callback ( api . get ( ) ) ; } ) ; } ; api . on ( event Name , wrapped Callback ) ; return ( ) = > { api . off ( event Name , wrapped Callback ) ; } ; } ; return api ; } 
function set Options Watcher ( api ) { scope . $watch ( 'options ' , ( new Options , old Options ) = > { if ( angular . equals ( new Options , old Options ) ) { return ; } options = angular . copy ( scope . options ) ; api . update Options ( options ) ; } ) ; } 
function bind Ng Model Controls ( api ) { ng Model . $render = ( ) = > { api . set ( ng Model . $model Value ) ; } ; api . on ( 'update ' , ( ) = > { const positions = api . get ( ) ; ng Model . $set View Value ( positions ) ; } ) ; } 
function initialize Ng Model ( ) { if ( ng Model = = = null ) { return $q . resolve ( null ) ; } return $q ( ( resolve ) = > { $timeout ( ( ) = > { if ( ! ( angular . is Array ( ng Model . $model Value ) | | angular . is Number ( ng Model . $model Value ) ) ) { throw new Error ( ` $ { ng Model . $model Value } ` ) ; } resolve ( ng Model . $model Value ) ; } ) ; } ) ; } 
function create Instance ( ) { const api = extend Api ( no Ui Slider . create ( html Element , options ) ) ; set Created Watcher ( api ) ; set Options Watcher ( api ) ; if ( ng Model ! = = null ) { bind Ng Model Controls ( api ) ; } } 
function postprocess ( arr ) { 
function ( w ) { let vow = / [aeiouy ] $ / ; let chars = w . split ( ' ' ) ; let before = ' ' ; let after = ' ' ; let current = ' ' ; for ( let i = 0 ; i < chars . length ; i + + ) { before = chars . slice ( 0 , i ) . join ( ' ' ) ; current = chars [ i ] ; after = chars . slice ( i + 1 , chars . length ) . join ( ' ' ) ; let candidate = before + chars [ i ] ; 
function add Api ( self , api Name , api ) { for ( var name in api ) { var fn = api [ name ] ; if ( typeof fn = = = "function " ) api [ name ] = api [ name ] . bind ( self ) ; } var tmp = null ; api . replied = new Promise ( ( resolve , reject ) = > { tmp = { resolve , reject } ; } ) ; api . replied . resolve = tmp . resolve ; api . replied . reject = tmp . reject ; self [ api Name ] = api ; } 
function get Json ( path ) { return http Get ( { hostname : t . options . remote Client Hostname , port : t . options . remote Client Port , path : path , method : 'GET ' } ) . then ( ( obj ) = > { var content Type = get Content Type ( obj . response ) ; if ( content Type ! = = "application /json " ) LOG . warn ( "Expecting JSON from " + path + " but found wrong content type : " + content Type ) ; try { return JSON . parse ( obj . data ) ; } catch ( ex ) { LOG . warn ( "Cannot parse JSON returned from " + path ) ; return null ; } } ) ; } 
function split Name ( method ) { var pos = method . index Of ( ' . ' ) ; if ( pos < 0 ) return [ null , method ] ; var domain Name = method . substring ( 0 , pos ) ; var method Name = method . substring ( pos + 1 ) ; return [ domain Name , method Name ] ; } 
function copy To Client ( req , res ) { return http Get ( { hostname : t . options . remote Client Hostname , port : t . options . remote Client Port , path : req . original Url , method : 'GET ' } ) . then ( function ( obj ) { var content Type = get Content Type ( obj . response ) ; if ( content Type ) res . set ( "Content -Type " , content Type ) ; res . send ( obj . data ) ; } ) ; } 
function promisify ( fn ) { return new Promise ( function ( resolve , reject ) { fn ( function ( err , value ) { if ( err ) reject ( err ) ; else resolve ( value ) ; } ) ; } ) ; } 
function to Fixed ( value , precision ) { var power = Math . pow ( 1 0 , precision ) ; return ( Math . round ( value * power ) / power ) . to Fixed ( precision ) ; } 
function ( code , stdout , stderr ) { 
function ( ) { 
function capture ( streams , opts , exec ) { var args = _shift ( opts , exec ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; if ( ! Array . is Array ( streams ) ) { streams = [ streams ] ; } var outputs = [ ] ; streams . for Each ( function ( stream , index ) { outputs [ index ] = ' ' ; start Capture ( stream , opts , function ( output ) { outputs [ index ] + = output ; } ) ; } ) ; exec ( ) ; streams . for Each ( stop Capture ) ; return outputs ; } 
function capture Stdio ( opts , exec ) { var streams = [ process . stdout , process . stderr ] ; var outputs = capture ( streams , opts , exec ) ; return { stdout : outputs . shift ( ) , stderr : outputs . shift ( ) } ; } 
function hook ( stream , opts , exec ) { var args = _shift ( opts , exec ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; var old _write = stream . write ; stream . write = ( function override ( stream , writer ) { return function write ( string , encoding , fd ) { exec ( string , encoding , fd ) ; if ( ! opts [ 'quiet ' ] ) { writer . apply ( stream , [ string , encoding , fd ] ) ; } } } ) ( stream , stream . write ) ; return function unhook ( ) { stream . write = old _write ; return true ; } } 
function start Capture ( stream , opts , exec ) { var unhook = hook ( stream , opts , exec ) ; var str _id = random . generate ( ) ; unhooks [ str _id ] = unhook ; stream . _id = str _id ; return true ; } 
function _wrap Intercept ( func , stream , opts , exec ) { var idex = Number ( arguments . length > 3 ) ; var args = _shift ( arguments [ idex + 1 ] , arguments [ idex + 2 ] ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; opts . quiet = true ; return idex ? func ( stream , opts , exec ) : func ( opts , exec ) ; } 
function get Nearest ( $select , value ) { var delta = { } ; $select . children ( 'option ' ) . each ( function ( i , opt ) { var opt Value = $ ( opt ) . attr ( 'value ' ) , distance ; if ( opt Value = = = ' ' ) return ; distance = Math . abs ( opt Value - value ) ; if ( typeof delta . distance = = = 'undefined ' | | distance < delta . distance ) { delta = { value : opt Value , distance : distance } ; } } ) ; return delta . value ; } 
function even Round ( x ) { 
function add Frame At ( time , value , delay , array ) { array . push ( { time : time , value : value , delay : delay } ) ; } 
function add Preservation Frame At ( time , value , delay , array ) { add Frame At ( time , value , delay , array ) ; } 
function relate Time ( time , extended Dur , resolution ) { 
function delay ( data , defined Loop ) { var pre Delay = data . sequence [ 0 ] [ defined Loop ? "begin " : "begin Static " ] ; data . sequence . for Each ( function ( value , i ) { data . sequence [ i ] . begin = value . begin - pre Delay ; } ) ; return pre Delay ; } 
function is Compatible ( instance ) { var supported = instance . $root . find ( definitions . selectors . supported ) ; var unsupported = instance . $root . find ( definitions . selectors . unsupported ) ; if ( unsupported . length ) { 
function smil 2css ( options ) { var defaults = { compress : true , force : false , target Browsers : null 
function sentiment ( options ) { return transformer function transformer ( node ) { var concatenate = concatenate Factory ( ) visit ( node , any ( options ) ) visit ( node , concatenate ) concatenate . done ( ) } } 
function concatenate Factory ( ) { var queue = [ ] concatenate . done = done return concatenate 
function one ( node ) { var children = node . children var length = children . length var polarity = 0 var index = - 1 var child var has Negation while ( + + index < length ) { child = children [ index ] if ( child . data & & child . data . polarity ) { polarity + = ( has Negation ? - 1 : 1 ) * child . data . polarity } 
function done ( ) { var length = queue . length var index = - 1 queue . reverse ( ) while ( + + index < length ) { one ( queue [ index ] ) } } 
function any ( config ) { return setter 
function patch ( node , polarity ) { var data = node . data | | { } data . polarity = polarity | | 0 data . valence = classify ( polarity ) node . data = data } 
function is Negation ( node ) { var value value = nlcst To String ( node ) . to Lower Case ( ) if ( value = = = 'not ' | | value = = = 'neither ' | | value = = = 'nor ' | | / n [ '  ]t / . t e st (v a lue ) ) { return true } return false } 
function fire ( event , target , listener ) { var returned , old Data ; if ( listener . d ! = = null ) { old Data = event . data ; event . data = listener . d ; returned = listener . h . call ( target , event , target ) ; event . data = old Data ; } else { returned = listener . h . call ( target , event , target ) ; } return returned ; } 
function handle ( listener List , root , event ) { var listener , returned , specific List , target ; if ( event [ EVENT _IGNORE ] = = = true ) { return ; } target = event . target ; if ( target . node Type = = = Node . TEXT _NODE ) { target = target . parent Node ; } specific List = listener List [ event . type ] ; 
function on ( that , listener List , root , event Type , selector , event Data , handler ) { var matcher , matcher Param ; if ( ! event Type ) { throw new Type Error ( 'Invalid event type : ' + event Type ) ; } if ( ! selector ) { throw new Type Error ( 'Invalid selector : ' + selector ) ; } 
function off ( that , listener List , root , event Type , selector , handler ) { var listener , next Listener , first Listener , specific List , single Event Type ; if ( ! event Type ) { for ( single Event Type in listener List ) { if ( listener List . has Own Property ( single Event Type ) ) { off . call ( that , that , listener List , root , single Event Type , selector , handler ) ; } } return ; } specific List = listener List [ event Type ] ; if ( ! specific List ) { return ; } 
function Delegate ( root ) { var that = this , listener List = { } ; if ( typeof root = = = 'string ' ) { root = document . query Selector ( root ) ; } if ( ! root | | ! root . add Event Listener ) { throw new Type Error ( 'Root node not specified ' ) ; } this . on = function ( ) { Array . prototype . unshift . call ( arguments , that , listener List , root ) ; on . apply ( that , arguments ) ; return this ; } ; this . off = function ( ) { Array . prototype . unshift . call ( arguments , that , listener List , root ) ; off . apply ( that , arguments ) ; return this ; } ; this . handle = function ( event ) { handle . call ( that , listener List , root , event ) ; } ; } 
function set Article ( id ) { database . get Async ( id , function ( article ) { orange . model . set ( article ) ; orange . render ( ) . setup ( ) ; } ) ; } 
function Module ( options ) { 
function fm ( options ) { var Module = fm . modules [ options . module ] ; if ( Module ) { return new Module ( options ) ; } throw new Error ( "Unable to find module ' " + options . module + " ' " ) ; } 
function Service ( oodbc , _config ) { this . instance Config = _config ; this . database Config = _config . database | | "My SQL " ; / /    this . oodbc = oodbc ; } 
function service ( oodbc , _config ) { if ( _config = = = undefined ) { throw new Type Error ( 'Expected object for argument _config ' ) } if ( ! ( this instanceof Service ) ) { return new Service ( oodbc , _config ) } throw new Type Error ( 'Expected object for argument _config ' ) ; } 
function Service ( oodbc , _database , _instance ) { / /                  MYSQL var database = _database | | "MYSQL " ; database = database . to Upper Case ( ) ; this . database = database ; var source = oodbc [ database ] ; / /        if ( source ) { / /     var dbsource = source [ _instance . to Upper Case ( ) ] ; if ( dbsource ) { / /                           this . db = dbsource ; } else { console . log ( '                  ' + _instance .to Upper Case ( ) + '      ) ; throw new Type Error ( '                  ' + _instance .to Upper Case ( ) + '      ) ; } } else { console . log ( '                  ' + this .database .to Upper Case ( ) + '     ' ) ; throw new Type Error ( '                  ' + this .database .to Upper Case ( ) + '     ' ) ; } } 
function ( instance , sql , parameters ) { return new Promise ( function ( resolve , reject ) { / /          console . time ( ' onela   SQL   ' ) ; / /console .log ( '  sql ' , sql , '   ' , parameters ) ; if ( instance ) { instance . query ( sql , parameters , function ( err , doc ) { console . time End ( ' onela   SQL   ' ) ; if ( err ) { reject ( err ) ; } else { resolve ( doc ) ; } } ) ; } else { reject ( "   instance           oodbc             onela Instance Config .json           " ) ; } } ) ; } 
function ( structure = [ ] ) { return new Promise ( ( resolve , reject ) = > { if ( Array . is Array ( structure ) = = = false ) { throw new Error ( ` ` ) } parse Structure ( structure , opts . cwd ) . then ( ( parsed Structure ) = > write Structure ( parsed Structure ) ) . then ( ( parsed Structure ) = > bin Structure ( parsed Structure , bin , opts . persistent ) ) . then ( resolve , reject ) } ) } 
function add And Where Date ( query Builder , column , from , to ) { if ( from & & to ) { query Builder . where Between ( column , [ from , to ] ) ; } else if ( from ) { query Builder . and Where ( column , ' > = ' , from ) ; } else if ( to ) { query Builder . and Where ( column , ' < = ' , to ) ; } } 
function _handle Multi Valued Parameters ( knex Builder , attr Name , parameter ) { if ( parameter instanceof Set ) { knex Builder = knex Builder . where In ( attr Name , Array . from ( parameter ) ) ; } else if ( Array . is Array ( parameter ) ) { knex Builder = knex Builder . where In ( attr Name , parameter ) ; } else { knex Builder = knex Builder . where ( attr Name , parameter ) ; } return knex Builder ; } 
function clean Db ( knex , table Names , logger , verbose Log = false ) { validate . not Nil ( table Names ) ; return table Cleaner . clean Tables ( knex , table Names , verbose Log ) . then ( ( ) = > { if ( logger ) { logger . info ( 'Tables cleaned successfully : ' , table Names . join ( ' , ' ) ) ; } } ) . catch ( err = > { if ( logger ) { logger . error ( 'Error cleaning tables ' , err ) ; } throw err ; } ) ; } 
function get Knex Instance ( config , registry = _registry , logger = console ) { validate . not Nil ( config , 'Config is null or undefined ' ) ; validate . not Nil ( config . client , 'DB client is null or undefined ' ) ; const { host , database , user } = config . connection ; const connection Timeout = config . acquire Connection Timeout ; logger . info ( ` $ { user } $ { host } $ { database } ` ) ; logger . info ( ` $ { connection Timeout } ` ) ; const knex = module . exports . _init Knex Instance ( config ) ; module . exports . register Knex Instance ( knex , registry ) ; / / unfortunately , we can 't check heartbeat here and fail -fast , as this initialization is synchronous return knex ; } 
function close All Instances ( registry = _registry ) { const promises = [ ] ; const errors = [ ] ; while ( registry . length > 0 ) { const knex = registry . pop ( ) ; const destruction Promise = knex . destroy ( ) . catch ( e = > { errors . push ( { knex , cause : e } ) ; } ) ; promises . push ( destruction Promise ) ; } return Promise . all ( promises ) . then ( ( ) = > { return errors ; } ) ; } 
function remark Custom Tags ( custom Tags ) { return ast = > visit ( ast , 'html ' , node = > { if ( node . value . starts With ( ' <x - ' ) ) { 
function remark Hljs ( { aliases } ) { return ast = > visit ( ast , 'code ' , node = > { if ( ! node . data ) { node . data = { } ; } const lang = node . lang ; const highlighted = lang ? low . highlight ( aliases [ lang ] | | lang , node . value ) . value : low . highlight Auto ( node . value ) . value ; node . data . h Children = highlighted ; node . data . h Properties = { class Name : [ 'hljs ' , lang & & ` $ { lang } ` ] , } ; } ) ; } 
function render ( processor , source ) { try { return processor . process Sync ( source ) . contents ; } catch ( exception ) { const error = ` $ { exception . message } ` ; console . error ( error ) ; return error Inline Html ( error ) . to String ( ) ; } } 
function read Template ( doc ) { return fs . read File Async ( flags . template , "utf 8 " ) . then ( template = > ( { doc , template } ) ) ; } 
function create Color Arrow ( def Element , color ) { def Element . append ( "marker " ) . attr ( "id " , "arrow - " + color ) . attr ( "view Box " , " 0 - 5 1 0 1 0 " ) . attr ( "ref X " , 8 ) . attr ( "marker Width " , 6 ) . attr ( "marker Height " , 6 ) . attr ( "fill " , color ) . attr ( "orient " , "auto " ) . append ( "path " ) . attr ( "d " , "M 0 , - 5L 1 0 , 0L 0 , 5 " ) . attr ( "class " , "arrow Head " ) ; } 
function css Values ( property , value ) { if ( typeof value = = = 'string ' ) { value = value Parser ( value ) ; } var first = value . nodes [ 0 ] ; if ( value . nodes . length = = = 1 & & ( is Keyword ( first , css Globals ) | | is Variable ( first ) ) ) { return true ; } if ( validators [ property ] ) { var result = validators [ property ] ( value ) ; if ( result . type ) { return result ; } if ( ! ! result = = = false ) { return invalid Message ( ' " ' + value + ' " is not a valid value for " ' + property + ' " . ' ) ; } return true ; } 
function value Parser Nodes Length ( length , operator = ' = = = ' ) { return t . binary Expression ( operator , value Parser ASTNodes Length , t . numeric Literal ( length ) ) ; } 
function ( data ) { data = ( data | | " " ) . to String ( ) . trim ( ) ; _ . any ( SEL _LOG _COLORS , function ( val , key ) { if ( data . index Of ( key ) > NOT _FOUND ) { data = data . split ( key ) . join ( key [ val ] ) ; return true ; } } ) ; return data ; } 
function known ( parsed ) { return parsed . every ( node = > { return node . type = = = 'keyword ' | | node . type = = = 'string ' | | node . type = = = 'group ' & & ! node . order & & ! node . min & & node . values . every ( n = > n . type = = = 'keyword ' ) | | ( node . type = = = 'data ' & & validators [ data Validator ( node . value ) ] ) ; 
function decrypt ( buf , key ) { key = ripemd 1 2 8 . ripemd 1 2 8 ( key ) ; var byte , keylen = key . length , prev = 0x 3 6 , i = 0 , len = buf . length ; for ( ; i < len ; i + + ) { byte = buf [ i ] ; byte = ( ( byte > > 4 ) | ( byte < < 4 ) ) ; 
function spreadus ( ) { var args = Array . prototype . slice . apply ( arguments ) ; args . _spreadus _ = true ; return args ; } 
function slice Then ( file , offset , len ) { var p = new Promise ( function ( _resolve ) { fs . open ( file , 'r ' , function ( err , fd ) { if ( err ) { throw err ; } var res = new Buffer ( len ) ; fs . read ( fd , res , 0 , len , offset , function ( err , bytes Read , buffer ) { if ( err ) { throw err ; } _resolve ( buffer ) ; } ) ; } ) ; } ) ; p . exec = function ( proc ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; return p . then ( function ( data ) { args . unshift ( data ) ; var ret = proc . apply ( null , args ) ; return resolve ( ret ! = = UNDEFINED & & ret . _spreadus _ ? ret : [ ret ] ) ; } ) ; } ; return p ; } 
function harvest ( outcomes ) { return Promise . settle ( outcomes ) . then ( function ( results ) { if ( results . length = = = 0 ) { return reject ( " * * NOT FOUND * * " ) ; } var solved = [ ] , failed = [ ] ; for ( var i = 0 ; i < results . length ; i + + ) { if ( results [ i ] . is Resolved ( ) ) { solved . push ( results [ i ] . value ( ) ) ; } else { failed . push ( results [ i ] . reason ( ) ) ; } } return solved . length ? solved : failed ; } ) ; } 
function create Record Block Table ( ) { var pos = 0 , 
function ( key At ) { var hi = ( arr . length > > 1 ) - 1 , lo = 0 , i = ( lo + hi ) > > 1 , val = arr [ ( i < < 1 ) + 1 ] ; if ( key At > arr [ ( hi < < 1 ) + 1 ] | | key At < 0 ) { return ; } while ( true ) { if ( hi - lo < = 1 ) { if ( i < hi ) { return { block _no : i , comp _offset : arr [ i < < = 1 ] , comp _size : arr [ i + 2 ] - arr [ i ] , decomp _offset : arr [ i + 1 ] , decomp _size : arr [ i + 3 ] - arr [ i + 1 ] } ; } else { return ; } } ( key At < val ) ? hi = i : lo = i ; i = ( lo + hi ) > > 1 ; val = arr [ ( i < < 1 ) + 1 ] ; } } 
function parse _mdict ( file , ext ) { var KEY _INDEX , * Config scanner according to dictionary attributes . * / function config ( ) { attrs . Encoding = attrs . Encoding | | 'UTF - 1 6 ' ; _search Text Len = ( attrs . Encoding = = = 'UTF - 1 6 ' ) ? function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . get Uint 1 6 ( offset + + ) ) { } ; return offset - mark ; } : function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . get Uint 8 ( offset + + ) ) { } return offset - mark - 1 ; } ; _decoder = new Text Decoder ( attrs . Encoding | | 'UTF - 1 6LE ' ) ; _bpu = ( attrs . Encoding = = = 'UTF - 1 6 ' ) ? 2 : 1 ; if ( parse Int ( attrs . Generated By Engine Version , 1 0 ) > = 2 . 0 ) { _v 2 = true ; _tail = _bpu ; * Read the first 4 bytes of mdx /mdd file to get length of header _str . * @see https : * @param input sliced file (start = 0 , length = 4 ) * @return length of header _str * / function read _file _head ( input ) { return Scanner ( input ) . read Int ( ) ; } function read _header _sect ( input , len ) { var scanner = Scanner ( input ) , header _str = scanner . read UTF 1 6 ( len ) . replace ( / \ 0 $ / , ' ' ) ; * Read keyword summary at the begining of keyword section . * @see https : * @param input sliced file , same as input passed to read _header _sect ( ) * @param offset start position of keyword section in sliced file , equals to length of header string plus checksum . \ * @return keyword _sect object * / function read _keyword _summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num _blocks : scanner . read Num ( ) , num _entries : scanner . read Num ( ) , key _index _decomp _len : _v 2 & & scanner . read Num ( ) , * Read keyword index part of keyword section . * @see https : * @see https : * @param input sliced file , remained part of keyword section after keyword summary which can also be used to read following key blocks . * @param keyword _summary * @return [keyword _summary , array of keyword index ] * / function read _keyword _index ( input , keyword _summary ) { var scanner = Scanner ( input ) . read Block ( keyword _summary . key _index _comp _len , keyword _summary . key _index _decomp _len , _decryptors [ 1 ] ) , keyword _index = Array ( keyword _summary . num _blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword _summary . num _blocks ; i + + ) { keyword _index [ i ] = { num _entries : conseq ( scanner . read Num ( ) , size = scanner . read Short ( ) ) , * Read keyword entries inside a keyword block and fill KEY _TABLE . * @param scanner scanner object to read key entries , which starts at begining of target key block * @param kdx corresponding keyword index object * NOTE : no need to read keyword block anymore , for debug only . * / function read _key _block ( scanner , kdx ) { var scanner = scanner . read Block ( kdx . comp _size , kdx . decomp _size ) ; for ( var i = 0 ; i < kdx . num _entries ; i + + ) { * Delay to scan key table , for debug onyl . * @param sliced Key Block a promise object which will resolve to an Array Buffer containing keyword blocks * sliced from mdx /mdd file . * @param num _entries number of keyword entries * @param keyword _index array of keyword index * @param delay time to delay for scanning key table * / function will Scan Key Table ( sliced Key Block , num _entries , keyword _index , delay ) { sliced Key Block . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword _index . length ; i < size ; i + + ) { * Read record summary at the begining of record section . * @see https : * @param input sliced file , start = begining of record section , length = 3 2 (max length of record summary ) * @param pos begining of record section * @returj record summary object * / function read _record _summary ( input , pos ) { var scanner = Scanner ( input ) , record _summary = { num _blocks : scanner . read Num ( ) , num _entries : scanner . read Num ( ) , index _len : scanner . read Num ( ) , blocks _len : scanner . read Num ( ) , * Read record block index part in record section , and fill RECORD _BLOCK _TABLE * @see https : * @param input sliced file , start = begining of record block index , length = record _summary .index _len * @param record _summary record summary object * / function read _record _block ( input , record _summary ) { var scanner = Scanner ( input ) , size = record _summary . num _blocks , record _index = Array ( size ) , p 0 = record _summary . block _pos , p 1 = 0 ; RECORD _BLOCK _TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i + + ) { record _index [ i ] = rdx = { comp _size : scanner . read Num ( ) , decomp _size : scanner . read Num ( ) } ; RECORD _BLOCK _TABLE . put ( p 0 , p 1 ) ; p 0 + = rdx . comp _size ; p 1 + = rdx . decomp _size ; } RECORD _BLOCK _TABLE . put ( p 0 , p 1 ) ; } function read _definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . read Block ( block . comp _size , block . decomp _size ) ; scanner . forward ( keyinfo . offset - block . decomp _offset ) ; return scanner . read Text ( ) ; } function follow Link ( definition , lookup ) { return ( definition . substring ( 0 , 8 ) ! = = ' @ @ @LINK = ' ) ? definition : lookup ( definition . substring ( 8 ) ) ; } function read _object ( input , block , keyinfo ) { if ( input . byte Length > 0 ) { var scanner = Scanner ( input ) . read Block ( block . comp _size , block . decomp _size ) ; scanner . forward ( keyinfo . offset - block . decomp _offset ) ; return scanner . read Raw ( keyinfo . size ) ; } else { throw ' * OUT OF FILE RANGE * ' + keyinfo + ' @offset = ' + block . comp _offset ; } } function find Word ( keyinfo ) { var block = RECORD _BLOCK _TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp _offset , block . comp _size ) . exec ( read _definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( follow Link ( definition , LOOKUP . mdx ) ) ; } ) ; } function find Resource ( keyinfo ) { var block = RECORD _BLOCK _TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp _offset , block . comp _size ) . exec ( read _object , block , keyinfo ) . spread ( function ( blob ) { return resolve ( blob ) ; } ) ; } * Reduce the key index array to an element which contains or is the nearest one matching a given phrase . * / function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len > > 1 ; return phrase > _adapt Key ( arr [ len - 1 ] . last _word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } } function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len > > 1 ; var key = _adapt Key ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos | | 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos | | 0 ) + ( phrase < = _adapt Key ( arr [ 0 ] ) ? 0 : 1 ) ; } } function load Keys ( kdx ) { if ( _cached _keys & & _cached _keys . pilot = = = kdx . first _word ) { return resolve ( _cached _keys . list ) ; } else { return sliced Key Block . then ( function ( input ) { var scanner = Scanner ( input ) , list = Array ( kdx . num _entries ) ; scanner . forward ( kdx . offset ) ; scanner = scanner . read Block ( kdx . comp _size , kdx . decomp _size ) ; for ( var i = 0 ; i < kdx . num _entries ; i + + ) { var offset = scanner . read Num ( ) ; list [ i ] = new Object ( scanner . read Text ( ) ) ; list [ i ] . offset = offset ; if ( i > 0 ) { list [ i - 1 ] . size = offset - list [ i - 1 ] . offset ; } } _cached _keys = { list : list , pilot : kdx . first _word } ; return list ; } ) ; } } function seek Vanguard ( phrase ) { phrase = _adapt Key ( phrase ) ; var kdx = reduce ( KEY _INDEX , phrase ) ; * Append more to word list according to a filter or expected size . * / function append More ( word , list , next Kdx , expected Size , filter , ticket ) { if ( ticket ! = = mutual _ticket ) { throw 'force terminated ' ; } if ( filter ) { if ( _trail . count < expected Size & & next Kdx & & next Kdx . first _word . substr ( 0 , word . length ) = = = word ) { return load Keys ( next Kdx ) . delay ( 3 0 ) . then ( function ( more ) { _trail . offset = 0 ; _trail . block = next Kdx . index ; Array . prototype . push . apply ( list , more . filter ( filter , _trail ) ) ; return append More ( word , list , KEY _INDEX [ next Kdx . index + 1 ] , expected Size , filter , ticket ) ; } ) ; } else { if ( list . length = = = 0 ) { _trail . exhausted = true ; } return resolve ( list ) ; } } else { var shortage = expected Size - list . length ; if ( shortage > 0 & & next Kdx ) { _trail . block = next Kdx . index ; return load Keys ( next Kdx ) . then ( function ( more ) { _trail . offset = 0 ; _trail . pos = Math . min ( shortage , more . length ) ; Array . prototype . push . apply ( list , more . slice ( 0 , shortage ) ) ; return append More ( word , list , KEY _INDEX [ next Kdx . index + 1 ] , expected Size , filter , ticket ) ; } ) ; } else { if ( _trail . pos > expected Size ) { _trail . pos = expected Size ; } list = list . slice ( 0 , expected Size ) ; _trail . count = list . length ; _trail . total + = _trail . count ; return resolve ( list ) ; } } } function follow Up ( ) { var kdx = KEY _INDEX [ _trail . block ] ; return load Keys ( kdx ) . then ( function ( list ) { return [ kdx , Math . min ( _trail . offset + _trail . pos , list . length - 1 ) , list ] ; } ) ; } function match Keys ( phrase , expected Size , follow ) { expected Size = Math . max ( expected Size | | 0 , 1 0 ) ; var str = phrase . trim ( ) . to Lower Case ( ) , m = / ( [ ^ ? * ] + ) [ ? * ] + / . exec ( str ) , word ; if ( m ) { word = m [ 1 ] ; var wildcard = new Reg Exp ( ' ^ ' + str . replace ( / ( [ \ . \ \ \ + \ [ \ ^ \ ] \ $ \ ( \ ) ] ) / g , ' \ \ $ 1 ' ) . replace ( / \ * + / g , ' . * ' ) . replace ( / \ ? / g , ' . ' ) + ' $ ' ) , tester = phrase [ phrase . length - 1 ] = = = ' ' ? function ( s ) { return wildcard . test ( s ) ; } : function ( s ) { return wildcard . test ( s ) & & ! / / . test ( s ) ; } , filter = function ( s , i ) { if ( _trail . count < expected Size & & tester ( s ) ) { _trail . count + + ; _trail . total + + ; _trail . pos = i + 1 ; return true ; } return false ; } ; } else { word = phrase . trim ( ) ; } if ( _trail & & _trail . phrase ! = = phrase ) { follow = false ; } if ( follow & & _trail & & _trail . exhausted ) { return resolve ( [ ] ) ; } var start From = follow & & _trail ? follow Up ( ) : seek Vanguard ( word ) ; return start From . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; _trail = { phrase : phrase , block : kdx . index , offset : idx , pos : list . length , count : 0 , total : follow ? _trail & & _trail . total | | 0 : 0 } ; if ( filter ) { list = list . filter ( filter , _trail ) ; } return append More ( word , list , KEY _INDEX [ kdx . index + 1 ] , expected Size , filter , + + mutual _ticket ) . then ( function ( result ) { if ( _trail . block = = = KEY _INDEX . length - 1 ) { if ( _trail . offset + _trail . pos > = KEY _INDEX [ _trail . block ] . num _entries ) { _trail . exhausted = true ; * Match the first element in list with given offset . * / function match Offset ( list , offset ) { return list . some ( function ( el ) { return el . offset = = = offset ? list = [ el ] : false ; } ) ? list : [ ] ; } * @param query * String * {phrase : . . , max : . . , follow : true } object * / mdx : function ( query ) { if ( typeof query = = = 'string ' | | query instanceof String ) { _trail = null ; var word = query . trim ( ) . to Lower Case ( ) , offset = query . offset ; return seek Vanguard ( word ) . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; if ( offset ! = = UNDEFINED ) { list = match Offset ( list , offset ) ; } else { list = list . filter ( function ( el ) { return el . to Lower Case ( ) = = = word ; } ) ; } return harvest ( list . map ( find Word ) ) ; } ) ; } else { return match Keys ( query . phrase , query . max , query . follow ) ; } } , 
function config ( ) { attrs . Encoding = attrs . Encoding | | 'UTF - 1 6 ' ; _search Text Len = ( attrs . Encoding = = = 'UTF - 1 6 ' ) ? function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . get Uint 1 6 ( offset + + ) ) { } ; return offset - mark ; } : function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . get Uint 8 ( offset + + ) ) { } return offset - mark - 1 ; } ; _decoder = new Text Decoder ( attrs . Encoding | | 'UTF - 1 6LE ' ) ; _bpu = ( attrs . Encoding = = = 'UTF - 1 6 ' ) ? 2 : 1 ; if ( parse Int ( attrs . Generated By Engine Version , 1 0 ) > = 2 . 0 ) { _v 2 = true ; _tail = _bpu ; 
function Scanner ( buf , len ) { var offset = 0 , dv = new Data View ( buf ) ; var methods = { 
function ( ) { var len = _search Text Len ( dv , offset ) ; return conseq ( _decoder . decode ( new Uint 8Array ( buf , offset , len ) ) , this . forward ( len + _bpu ) ) ; } 
function ( len ) { len * = _bpu ; var read = conseq ( _decoder . decode ( new Uint 8Array ( buf , offset , len ) ) , this . forward ( len + _tail ) ) ; return read ; } 
function ( len , expected Buf Size , decryptor ) { var comp _type = dv . get Uint 8 ( offset , false ) ; 
function ( len ) { return conseq ( new Uint 8Array ( buf , offset , len ) , this . forward ( len = = = UNDEFINED ? buf . length - offset : len ) ) ; } 
function read _header _sect ( input , len ) { var scanner = Scanner ( input ) , header _str = scanner . read UTF 1 6 ( len ) . replace ( / \ 0 $ / , ' ' ) ; 
function read _keyword _summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num _blocks : scanner . read Num ( ) , num _entries : scanner . read Num ( ) , key _index _decomp _len : _v 2 & & scanner . read Num ( ) , 
function read _keyword _index ( input , keyword _summary ) { var scanner = Scanner ( input ) . read Block ( keyword _summary . key _index _comp _len , keyword _summary . key _index _decomp _len , _decryptors [ 1 ] ) , keyword _index = Array ( keyword _summary . num _blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword _summary . num _blocks ; i + + ) { keyword _index [ i ] = { num _entries : conseq ( scanner . read Num ( ) , size = scanner . read Short ( ) ) , 
function read _key _block ( scanner , kdx ) { var scanner = scanner . read Block ( kdx . comp _size , kdx . decomp _size ) ; for ( var i = 0 ; i < kdx . num _entries ; i + + ) { 
function will Scan Key Table ( sliced Key Block , num _entries , keyword _index , delay ) { sliced Key Block . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword _index . length ; i < size ; i + + ) { 
function read _record _summary ( input , pos ) { var scanner = Scanner ( input ) , record _summary = { num _blocks : scanner . read Num ( ) , num _entries : scanner . read Num ( ) , index _len : scanner . read Num ( ) , blocks _len : scanner . read Num ( ) , 
function read _record _block ( input , record _summary ) { var scanner = Scanner ( input ) , size = record _summary . num _blocks , record _index = Array ( size ) , p 0 = record _summary . block _pos , p 1 = 0 ; RECORD _BLOCK _TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i + + ) { record _index [ i ] = rdx = { comp _size : scanner . read Num ( ) , decomp _size : scanner . read Num ( ) } ; RECORD _BLOCK _TABLE . put ( p 0 , p 1 ) ; p 0 + = rdx . comp _size ; p 1 + = rdx . decomp _size ; } RECORD _BLOCK _TABLE . put ( p 0 , p 1 ) ; } 
function read _definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . read Block ( block . comp _size , block . decomp _size ) ; scanner . forward ( keyinfo . offset - block . decomp _offset ) ; return scanner . read Text ( ) ; } 
function read _object ( input , block , keyinfo ) { if ( input . byte Length > 0 ) { var scanner = Scanner ( input ) . read Block ( block . comp _size , block . decomp _size ) ; scanner . forward ( keyinfo . offset - block . decomp _offset ) ; return scanner . read Raw ( keyinfo . size ) ; } else { throw ' * OUT OF FILE RANGE * ' + keyinfo + ' @offset = ' + block . comp _offset ; } } 
function find Word ( keyinfo ) { var block = RECORD _BLOCK _TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp _offset , block . comp _size ) . exec ( read _definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( follow Link ( definition , LOOKUP . mdx ) ) ; } ) ; } 
function find Resource ( keyinfo ) { var block = RECORD _BLOCK _TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp _offset , block . comp _size ) . exec ( read _object , block , keyinfo ) . spread ( function ( blob ) { return resolve ( blob ) ; } ) ; } 
function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len > > 1 ; return phrase > _adapt Key ( arr [ len - 1 ] . last _word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } } 
function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len > > 1 ; var key = _adapt Key ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos | | 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos | | 0 ) + ( phrase < = _adapt Key ( arr [ 0 ] ) ? 0 : 1 ) ; } } 
function load Keys ( kdx ) { if ( _cached _keys & & _cached _keys . pilot = = = kdx . first _word ) { return resolve ( _cached _keys . list ) ; } else { return sliced Key Block . then ( function ( input ) { var scanner = Scanner ( input ) , list = Array ( kdx . num _entries ) ; scanner . forward ( kdx . offset ) ; scanner = scanner . read Block ( kdx . comp _size , kdx . decomp _size ) ; for ( var i = 0 ; i < kdx . num _entries ; i + + ) { var offset = scanner . read Num ( ) ; list [ i ] = new Object ( scanner . read Text ( ) ) ; list [ i ] . offset = offset ; if ( i > 0 ) { list [ i - 1 ] . size = offset - list [ i - 1 ] . offset ; } } _cached _keys = { list : list , pilot : kdx . first _word } ; return list ; } ) ; } } 
function seek Vanguard ( phrase ) { phrase = _adapt Key ( phrase ) ; var kdx = reduce ( KEY _INDEX , phrase ) ; 
function append More ( word , list , next Kdx , expected Size , filter , ticket ) { if ( ticket ! = = mutual _ticket ) { throw 'force terminated ' ; } if ( filter ) { if ( _trail . count < expected Size & & next Kdx & & next Kdx . first _word . substr ( 0 , word . length ) = = = word ) { return load Keys ( next Kdx ) . delay ( 3 0 ) . then ( function ( more ) { _trail . offset = 0 ; _trail . block = next Kdx . index ; Array . prototype . push . apply ( list , more . filter ( filter , _trail ) ) ; return append More ( word , list , KEY _INDEX [ next Kdx . index + 1 ] , expected Size , filter , ticket ) ; } ) ; } else { if ( list . length = = = 0 ) { _trail . exhausted = true ; } return resolve ( list ) ; } } else { var shortage = expected Size - list . length ; if ( shortage > 0 & & next Kdx ) { _trail . block = next Kdx . index ; return load Keys ( next Kdx ) . then ( function ( more ) { _trail . offset = 0 ; _trail . pos = Math . min ( shortage , more . length ) ; Array . prototype . push . apply ( list , more . slice ( 0 , shortage ) ) ; return append More ( word , list , KEY _INDEX [ next Kdx . index + 1 ] , expected Size , filter , ticket ) ; } ) ; } else { if ( _trail . pos > expected Size ) { _trail . pos = expected Size ; } list = list . slice ( 0 , expected Size ) ; _trail . count = list . length ; _trail . total + = _trail . count ; return resolve ( list ) ; } } } 
function match Offset ( list , offset ) { return list . some ( function ( el ) { return el . offset = = = offset ? list = [ el ] : false ; } ) ? list : [ ] ; } 
function ( phrase ) { var word = phrase . trim ( ) . to Lower Case ( ) ; word = ' \ \ ' + word . replace ( / ( ^ [ / \ \ ] ) | ( [ / ] $ ) / , ' ' ) ; word = word . replace ( / \ / / g , ' \ \ ' ) ; return seek Vanguard ( word ) . spread ( function ( kdx , idx , list ) { return list . slice ( idx ) . filter ( function ( one ) { return one . to Lower Case ( ) = = = word ; } ) ; } ) . then ( function ( candidates ) { if ( candidates . length = = = 0 ) { throw ' *RESOURCE NOT FOUND * ' + phrase ; } else { return find Resource ( candidates [ 0 ] ) ; } } ) ; } 
function is Valid Modifier Key Combo ( modifier Keys , e ) { var modifier Key Names = [ 'alt ' , 'ctrl ' , 'meta ' , 'shift ' ] , num Mod Keys = modifier Keys . length , i , j , curr Modifier Key , is Valid = true ; 
function create Key Combo Function ( key Func , modifier Keys ) { return function ( key Code , modifier Key Names ) { var i , key Combo = ' ' ; if ( arguments . length ) { if ( typeof key Code = = = 'number ' ) { key Func ( key Code ) ; modifier Keys . length = 0 ; 
function override Key Down ( e ) { e = e | | event ; 
function override Key Press ( e ) { e = e | | event ; var key = e . key Code ; if ( tab Key Combo Pressed ( key , e ) | | untab Key Combo Pressed ( key , e ) | | ( key = = = 1 3 & & auto Indent & & ! in Whitespace ) ) { if ( e . prevent Default ) { e . prevent Default ( ) ; } else { e . return Value = false ; return false ; } } } 
function execute Extensions ( hook , args ) { var i , extensions = hooks [ hook ] | | [ ] , len = extensions . length ; for ( i = 0 ; i < len ; i + = 1 ) { extensions [ i ] . apply ( null , args ) ; } } 
function create Listeners ( handler List ) { var i , len = handler List . length , remove , add ; function loop ( func ) { for ( i = 0 ; i < len ; i + = 1 ) { func ( handler List [ i ] . type , handler List [ i ] . handler ) ; } } 
function generate Images To Preload ( total Images ) { for ( var i = 0 , images = [ ] , index ; i < total Images ; i + + ) { index = ( i < 1 0 ) ? ' 0 ' + i : i images . push ( 'https : / /github .com /rbartoli /threesixty /raw /master /example /images /sequence - ' + index + ' .png ' ) } return images } 
function ( imap Message ) { var deferred = Q . defer ( ) ; var message = new Message ( ) ; imap Message . on ( 'body ' , function ( stream , info ) { var buffer = ' ' ; stream . on ( 'data ' , function ( chunk ) { buffer + = chunk . to String ( 'utf 8 ' ) ; } ) ; stream . on ( 'end ' , function ( ) { if ( info . which = = = 'TEXT ' ) { message . body = buffer ; } else { message . headers = Imap . parse Header ( buffer ) ; } } ) ; } ) ; imap Message . on ( 'attributes ' , function ( attrs ) { message . attributes = attrs ; } ) ; imap Message . on ( 'end ' , function ( ) { deferred . resolve ( message ) ; } ) ; return deferred . promise ; } 
function GPT ( options ) { if ( ! ( this instanceof GPT ) ) { return new GPT ( options ) } options = options ! = null ? options : { } this . block Size = options . block Size | | 5 1 2 this . guid = options . guid | | GPT . GUID . ZERO this . revision = options . revision | | 0 this . header Size = options . header Size | | GPT . HEADER _SIZE this . header Checksum = 0 this . current LBA = options . current LBA | | 1 this . backup LBA = options . backup LBA | | 0 this . first LBA = options . first LBA | | 3 4 this . last LBA = options . last LBA | | 0 this . table Offset = options . table Offset | | GPT . TABLE _OFFSET this . entries = options . entries | | GPT . TABLE _ENTRIES this . entry Size = options . entry Size | | GPT . TABLE _ENTRY _SIZE this . table Checksum = 0 
function normalize String ( path , allow Above Root ) { var res = ' ' var last Segment Length = 0 var last Slash = - 1 var dots = 0 var code for ( var i = 0 ; i < = path . length ; i + = 1 ) { if ( i < path . length ) code = path . char Code At ( i ) else if ( code = = = CHAR _FORWARD _SLASH ) break else code = CHAR _FORWARD _SLASH if ( code = = = CHAR _FORWARD _SLASH ) { if ( last Slash = = = i - 1 | | dots = = = 1 ) { 
function resolve ( ) { var resolved Path = ' ' var resolved Absolute = false var cwd for ( var i = arguments . length - 1 ; i > = - 1 & & ! resolved Absolute ; i - = 1 ) { var path if ( i > = 0 ) { path = arguments [ i ] } else { if ( cwd = = = undefined ) { cwd = posix . dirname ( sketch Specifics . cwd ( ) ) } path = cwd } path = sketch Specifics . get String ( path , 'path ' ) 
function read Backup GPT ( primary GPT ) { var backup GPT = new GPT ( { block Size : primary GPT . block Size } ) var buffer = Buffer . alloc ( 3 3 * primary GPT . block Size ) var offset = ( ( primary GPT . backup LBA - 3 2 ) * block Size ) fs . read Sync ( fd , buffer , 0 , buffer . length , offset ) backup GPT . parse Backup ( buffer ) return backup GPT } 
function Partition Entry ( options ) { if ( ! ( this instanceof Partition Entry ) ) { return new Partition Entry ( options ) } options = options ! = null ? options : { } this . type = options . type | | GUID . ZERO this . guid = options . guid | | GUID . ZERO this . name = options . name | | ' ' this . first LBA = options . first LBA | | 0 this . last LBA = options . last LBA | | 0 
function stopcock ( fn , options ) { options = Object . assign ( { queue Size : Math . pow ( 2 , 3 2 ) - 1 , bucket Size : 4 0 , interval : 1 0 0 0 , limit : 2 } , options ) ; const bucket = new Token Bucket ( options ) ; const queue = [ ] ; let timer = null ; function shift ( ) { clear Timeout ( timer ) ; while ( queue . length ) { const delay = bucket . consume ( ) ; if ( delay > 0 ) { timer = set Timeout ( shift , delay ) ; break ; } const data = queue . shift ( ) ; data [ 2 ] ( fn . apply ( data [ 0 ] , data [ 1 ] ) ) ; } } function limiter ( ) { const args = arguments ; return new Promise ( ( resolve , reject ) = > { if ( queue . length = = = options . queue Size ) { return reject ( new Error ( 'Queue is full ' ) ) ; } queue . push ( [ this , args , resolve ] ) ; shift ( ) ; } ) ; } Object . define Property ( limiter , 'size ' , { get : ( ) = > queue . length } ) ; return limiter ; } 
function format Quantity ( value , encode , pad ) { if ( [ 'string ' , 'number ' , 'object ' ] . index Of ( typeof value ) = = = - 1 | | value = = = null ) { return value ; } const number Value = number To BN ( value ) ; const num Padding = number Value . lt ( ten ) & & pad = = = true & & ! number Value . is Zero ( ) ? ' 0 ' : ' ' ; if ( number To BN ( value ) . is Neg ( ) ) { throw new Error ( ` $ { number Value . to String ( 1 0 ) } ` ) ; } return encode ? ` $ { num Padding } $ { number Value . to String ( 1 6 ) } ` : number Value ; } 
function format Quantity Or Tag ( value , encode ) { var output = value ; 
function format Data ( value , byte Length ) { var output = value ; 
function format Object ( formatter , value , encode ) { var output = Object . assign ( { } , value ) ; 
function format Array ( formatter , value , encode , length Requirement ) { var output = value . slice ( ) ; 
function format ( formatter , value , encode , length Requirement ) { var output = value ; 
function format Inputs ( method , inputs ) { return format ( schema . methods [ method ] [ 0 ] , inputs , true , schema . methods [ method ] [ 2 ] ) ; } 
function ( model , schema ) { function apply ( method , schema ) { Object . define Property ( model . prototype , method , { get : function ( ) { var h = { } ; for ( var k in schema . methods [ method ] ) { h [ k ] = schema . methods [ method ] [ k ] . bind ( this ) ; } return h ; } , configurable : true , } ) ; } for ( var method in schema . methods ) { if ( typeof schema . methods [ method ] = = = 'function ' ) { model . prototype [ method ] = schema . methods [ method ] ; } else { apply ( method , schema ) ; } } } 
function ( model , schema ) { for ( var i in schema . statics ) { model [ i ] = schema . statics [ i ] ; } } 
function ( files ) { if ( ! _ . is Array ( files ) ) { throw new Error ( 'Arguments to config -helper .merge Config should be an array ' ) ; } var app Config = { } ; files . for Each ( function ( file Path ) { if ( grunt File . exists ( file Path ) ) { var file Config = grunt File . read YAML ( file Path ) ; 
function parse Binding ( node ) { consume ( ) ; 
function parse Array List ( node ) { consume ( ) ; * Use clear ( ) to allow whitespace on certain locations : * (n ,n @x ) , (n , n @x ) , ( n , n @x ) are all accepted . * (n , n @x ) is not accepted : bindings do not allow * any whitespace . * / clear ( ) ; stage 1 ( node . nodes ) ; clear ( ) ; if ( peek ( ) ! = = ' , ' ) { break ; } consume ( ) ; 
function parse Property ( node , proto ) { consume ( ) ; * Properties may have type specifiers . This is the way to go * to match nested objects . * * e .g . 'o ( .coord :o ( .x , .y ) ) ' matches objects like * ' {coord : {x : 5 , y : 7 } } ' * / if ( has Next ( ) & & peek ( ) = = = ' : ' ) { consume ( ) ; 
function parse Properties ( node ) { consume ( ) ; * Properties always have to start with ' . ' or ' : ' * o ( .x , :y ) matches an object with at least an owned property * 'x ' and a owned or inherited property 'y ' . * / if ( peek ( ) = = = ' . ' ) { parse Property ( node , false ) ; 
function parse Literal List ( AST , parse Function ) { consume ( ) ; 
function extract String Literal ( ) { var literal = [ ] , enclosing = next ( ) ; if ( ! ( enclosing = = = ' " ' | | enclosing = = = " ' " ) ) { throw "Unexpected token at index " + index + " expected 'string ' but found " + enclosing ; } while ( has Next ( ) & & peek ( ) ! = = enclosing ) { literal [ literal . length ] = next ( ) ; } consume ( ) ; 
function parse String Literal ( AST ) { if ( peek ( ) = = = ' / ' ) { new Node ( extract Regex ( ) , new Node ( 'r = ' , AST ) . nodes ) ; } else { new Node ( extract String Literal ( ) , new Node ( ' = ' , AST ) . nodes ) ; } } 
function parse Numeric Literal ( AST ) { var literal = [ ] , value ; while ( has Next ( ) & & valid Num ( peek ( ) ) ) { literal [ literal . length ] = next ( ) ; } value = parse Float ( literal . join ( ' ' ) ) ; if ( ! is Na N ( value ) & & is Finite ( value ) ) { new Node ( value , new Node ( ' = ' , AST ) . nodes ) ; } else { unexpected Token Exception ( 'numeric ' ) ; } } 
function parse Generic ( AST , type ) { var node = new Node ( next ( ) , AST ) ; 
function stage 1 ( AST ) { if ( has Next ( ) ) { switch ( peek ( ) ) { case 'a ' : parse Array ( AST ) ; break ; case 'o ' : parse Object ( AST ) ; break ; default : if ( / [ns Sbfdr _ ] / . test ( peek ( ) ) ) { parse Generic ( AST , peek ( ) ) ; } else { unexpected Token Exception ( 'one of (a ,o ,n ,s ,S ,b ,f ,d ,r , _ ) ' ) ; } } } return AST ; } 
function curry ( fun , args ) { return function ( x ) { return fun . apply ( binding Context , args . concat ( [ x ] ) ) ; } ; } 
function bind ( n , p , v ) { var m = p ( v ) ; if ( m . result ) { * When the rest of an array is matched , the binding value has to * be changed after executing bind . Thats because at bind time the * rest of the array is not known . Therefore the name of the last * binding is stored and can be retrieved in the continuing function . * / m . this _binding = n ; return m ; } 
function equals Date ( x , o ) { return { result : x . get Time ( ) = = = o . get Time ( ) , param : x } ; } 
function has Property ( m , x , o ) { return test Property ( m , x , o , o . has Own Property ( x ) ) ; } 
function has Prototype Property ( m , x , o ) { return test Property ( m , x , o , x in o ) ; } 
function or ( m , o ) { var index , result = { result : false , param : o } ; for ( index = 0 ; index < m . length ; index + + ) { if ( m [ index ] ( o ) . result ) { result . result = true ; break ; } } return result ; } 
function match Array ( m , a ) { var from = 0 , rest = false , rest Binding Result , index , matcher , item , match Result , rest Of Array = [ ] , i , result = { result : false , param : a } ; * If there are no predicates at all , this matches because it is * already ensured that argument a is an array . * / if ( m . length = = = 0 ) { result . result = true ; return result ; } for ( index = 0 ; index < a . length ; index + + ) { matcher = m [ index ] ; item = a [ index ] ; if ( ! matcher ) { return result ; } match Result = matcher ( item ) ; if ( ! match Result . result ) { return result ; } if ( match Result . rest ) { rest Binding Result = match Result ; from = index ; rest = true ; break ; } } if ( rest & & rest Binding Result . this _binding ) { for ( i = from ; i < a . length ; i + + ) { rest Of Array [ rest Of Array . length ] = a [ i ] ; } binding Context [ rest Binding Result . this _binding ] = rest Of Array ; } result . result = true ; return result ; } 
function compile Node ( ast ) { var result = [ ] , index , node , matcher ; for ( index = 0 ; index < ast . length ; index + + ) { node = ast [ index ] ; switch ( node . type ) { case 'a ' : matcher = curry ( match Array , [ compile Node ( node . nodes ) ] ) ; break ; case 'o ' : matcher = curry ( match Object , [ compile Node ( node . nodes ) ] ) ; break ; case ' . ' : matcher = curry ( has Property , [ compile Node ( node . nodes ) , node . name ] ) ; break ; case ' : ' : matcher = curry ( has Prototype Property , [ compile Node ( node . nodes ) , node . name ] ) ; break ; case ' = ' : matcher = curry ( equals , [ node . nodes [ 0 ] . type ] ) ; break ; case 'd = ' : matcher = curry ( equals Date , [ node . nodes [ 0 ] . type ] ) ; break ; case 'r = ' : matcher = curry ( matches Regex , [ node . nodes [ 0 ] . type ] ) ; break ; case ' | | ' : matcher = curry ( or , [ compile Node ( node . nodes ) ] ) ; break ; case 'n ' : matcher = curry ( match Type , [ 'number ' ] ) ; break ; case 's ' : matcher = curry ( match Type , [ 'string ' ] ) ; break ; case 'S ' : matcher = match Non Blank String ; break ; case 'b ' : matcher = curry ( match Type , [ 'boolean ' ] ) ; break ; case 'f ' : matcher = curry ( match Type , [ 'function ' ] ) ; break ; case ' _ ' : matcher = any ; break ; case ' | ' : matcher = rest ; break ; case ' ( ) ' : matcher = match Empty Array ; break ; case 'd ' : matcher = curry ( match Instance Of , [ ' [object Date ] ' ] ) ; break ; case 'r ' : matcher = curry ( match Instance Of , [ ' [object Reg Exp ] ' ] ) ; break ; default : throw "Unknown AST entity : " + node . type ; } 
function array To Object ( array ) { var obj = { } , i ; if ( array . length % 2 ! = = 0 ) { throw "Missing handler for pattern " ; } for ( i = 0 ; i < array . length ; i + = 2 ) { obj [ array [ i ] ] = array [ i + 1 ] ; } return obj ; } 
function get Name ( tag ) { return tag . name ? tag . name . value . to Lower Case ( ) : ` $ { tag . type } ` ; } 
function eat Attribute Value ( stream ) { const start = stream . pos ; if ( eat Quoted ( stream ) ) { 
function is Unquoted ( code ) { return ! is Na N ( code ) & & ! is Quote ( code ) & & ! is Space ( code ) & & ! is Terminator ( code ) ; } 
function Sentiment ( args ) { this . path = args . path | | " " ; this . language = args . language ; this . confidence = args . confidence | | null ; this . synset = args . synset ; this . synsets = { } ; this . labeler = { } ; this . negations = def ( args . negations , [ "no " , "not " , "n 't " , "never " ] ) ; this . modifiers = def ( args . modifiers , [ "RB " ] ) ; this . modifier = def ( args . modifier , function ( w ) { return _str . ends With ( w , "ly " ) ; } ) ; this . tokenizer = def ( args . tokenizer , find _tokens ) ; } 
function avg Assessment ( assessments , weighted ) { var w ; var s = 0 ; var n = 0 ; assessments . for Each ( function ( ws ) { w = weighted ( ws [ 0 ] ) ; s + = w * ws [ 1 ] ; n + = w ; } ) ; if ( n = = = 0 ) { return 0 ; } else { return s / n ; } } 
function avg ( vct ) { if ( vct . length = = = 0 ) { return 0 ; } return ( vct . reduce ( function ( a , c ) { return a + c ; } , 0 ) / vct . length ) ; } 
function set Default ( obj , key , val ) { if ( _ . is Undefined ( obj [ key ] ) ) { obj [ key ] = val ; return val ; } return obj [ key ] ; } 
function get Xml ( path , finish ) { fs . read File ( path , function ( err , data ) { if ( err ) throw err ; xml Parser . parse String ( data , function ( err , result ) { if ( err ) throw err ; finish ( result ) ; } ) ; } ) ; } 
function to Parameter ( val , key ) { var str = ' - - ' + key . replace ( / ( [A -Z ] ) / g , function ( a ) { return ' - ' + a . to Lower Case ( ) ; } ) ; return ( val = = = true ) ? [ str ] : [ str , val ] ; } 
function inject Dependencies ( func , args , callback ) { var declared Arguments = toolbox . parse Declared Arguments ( func ) ; declared Arguments = declared Arguments . replace ( / \s + / g , " " ) . split ( " , " ) ; logger . trace ( "inject Dependencies ( ) declared Arguments : " , declared Arguments , "provided args : " , args ) ; var use Callback = false ; var len = args . length > declared Arguments . length ? args . length : declared Arguments . length ; for ( var i = 0 ; i < len ; i + + ) { 
function append UISource ( client ) { angoose . get Logger ( 'angoose ' ) . debug ( "Appending angoose -ui sources " ) ; 
function error ( msg , add Hint ) { console . log ( ' \x 1b [ 3 1m ' ) ; console . log ( 'The compiler has stopped on an error ' ) console . log ( ` \x 1b $ { msg } \x 1b ` ) ; if ( add Hint ) console . log ( ` \n ` ) ; process . exit ( 1 ) ; } 
function compile ( model Name , schema , dependencies ) { logger . trace ( "Compiling schema " , model Name ) var model = function Angoose Module ( data ) { / / @todo proper clone for ( var i in data ) { this [ i ] = data [ i ] ; } } ; model . to String = function ( ) { return "PROXY : function " + model Name + " ( ) " ; } / / static methods for ( var name in schema . statics ) { model [ name ] = create Proxy ( model , name , schema . statics [ name ] , 'static ' ) ; } for ( var name in schema . methods ) { model . prototype [ name ] = create Proxy ( model , name , schema . methods [ name ] , 'instance ' ) ; } / /model .angoose $ = static Invoker ; model . dependencies $ = dependencies ; model . schema = schema ; / /model .prototype .angoose $ = instance Invoker ; / /model .prototype .classname $ = model Name ; / /model .prototype .schema $ = schema ; model . prototype . get = getter ; model . prototype . set = setter ; model . model Name = model Name ; / / this is to be compatible with backend mongoose model . name = model Name ; 
function add Props ( props , options ) { if ( ! props ) return ' # # No props ' const keys = Object . keys ( props ) . filter ( key = > filter Props ( key , props [ key ] , options ) , ) const filtered Props = keys . reduce ( ( last , key ) = > ( { . . . last , [ key ] : props [ key ] } ) , { } , ) let output = ' \n # # Props \n ' let is Flow = false const items = [ TABLE _HEADERS , . . . keys . map ( key = > { const prop = filtered Props [ key ] if ( is Flow Type ( prop ) ) is Flow = true const row = [ is Flow Type ( prop ) ? key : get Key ( key , get Type ( prop ) ) , get Type Name ( get Type ( prop ) ) , get Default Value ( prop ) , prop . required , prop . description , ] return row . map ( row Value = > { if ( typeof row Value = = = 'string ' ) { return row Value . split ( ' \n ' ) . join ( ' <br > ' ) } return row Value } ) } ) , ] output + = ` $ { table ( items ) } \n ` 
function debounce ( quiet Millis , fn , ctx ) { ctx = ctx | | undefined ; var timeout ; return function ( ) { var args = arguments ; clear Timeout ( timeout ) ; timeout = set Timeout ( function ( ) { fn . apply ( ctx , args ) ; } , quiet Millis ) ; } ; } 
function matroshka ( fn ) { var babushka = fn ; Object . keys ( process . namespaces ) . for Each ( function ( name ) { babushka = process . namespaces [ name ] . bind ( babushka ) ; } ) ; return babushka ; } 
function find Tagged ( model Class , tag ) { if ( ! model Class | | ! model Class . schema ) return [ ] ; var cols = [ ] ; Object . keys ( model Class . schema . paths ) . for Each ( function ( path ) { var data = model Class . schema . paths [ path ] ; if ( data . options . tags & & data . options . tags . index Of ( tag ) > = 0 ) cols . push ( data ) ; } ) ; return cols ; } 
function enterscope ( scope , name , arg 1 ) { angoose . logger . trace ( "Entering scope " , name , scope . $id , arg 1 ) window [ 'scope ' + scope . $id ] = scope ; } 
function post Pack ( next , invocation ) { 
function error ( msg ) { if ( exports . error ) exports . error ( msg ) ; else console . log ( 'Error : ' + msg ) ; } 
function call ( name , is Long ) { var obj = is Long ? long [ name ] : short [ name ] ; if ( ! obj ) return error ( ` $ { name } ` ) ; if ( n + obj . length > count ) return error ( ` $ { name } ` ) ; var arr = process . argv . slice ( n , n + obj . length ) ; n + = obj . length ; obj . callback ( arr ) ; } 
function extend ( target , options ) { options = options | | { } ; var parent Class = this ; logger . trace ( "Extending from " , parent Class . _angoosemeta . name , options ) ; var rv = null ; if ( typeof ( target ) = = 'function ' ) { rv = target ; mixin Instance ( parent Class , rv , options ) ; bind Mongoose Methods ( rv ) ; } else { rv = parent Class . $extend ( target ) ; } rv = mixin Static ( parent Class , rv , options ) ; if ( rv . _angoosemeta . name ) { 
function add Hook ( loc , method , func ) { var tmp = hooks [ loc ] [ method ] ; logger . debug ( "ADdding bundle hook to " , loc , method , tmp ) ; if ( ! tmp ) return false ; tmp . push ( func ) ; return true ; } 
function find Input Element ( template Element ) { return angular . element ( template Element . find ( 'input ' ) [ 0 ] | | template Element . find ( 'select ' ) [ 0 ] | | template Element . find ( 'textarea ' ) [ 0 ] ) ; } 
function get Validation Message Map ( original Element ) { 
function map Directive ( path , path Schema , model Schema , item Index ) { if ( item Index ! = = undefined ) return null ; 
function map Template ( path , path Schema , model Schema ) { if ( path Schema . options . template ) return path Schema . options . template ; if ( path Schema . options . multiline ) return "textarea " var template = 'input ' ; var opts = path Schema . options | | { } ; 
function init ( app , conf , force ) { if ( this . initialized & & ! force ) return ; 
function lookup Or Register ( name , target ) { if ( arguments . length = = 0 ) return null ; if ( arguments . length = = 1 ) return get Class ( name ) ; if ( arguments . length = = 2 ) return register Class ( name , target ) ; } 
function register Class ( name Or Opts , claz ) { var opts = typeof ( name Or Opts ) = = 'object ' ? name Or Opts : { name : name Or Opts } ; var class Name = opts . name ; if ( ! class Name ) throw "Missing module name : " + class Name if ( beans [ class Name ] ) logger . warn ( "Overriding existing bean : " , class Name ) ; if ( claz . _angoosemeta & & ( claz . _angoosemeta . base Class = = 'Service ' | | claz . _angoosemeta . base Class = = 'Model ' ) ) { 
function get Context ( ) { if ( ! domain . active | | ! domain . active . context ) { if ( this . mock Context ) return this . mock Context logger . error ( "get Context called but no active domain " , domain . active ) ; logger . error ( "Caller is " , arguments . callee & & arguments . callee . caller & & arguments . callee . caller . name , arguments . callee & & arguments . callee . caller ) ; throw "Context not available . This may happen if the code was not originated by Angoose " ; } return domain . active . context ; } 
function scan Dir ( dirname ) { if ( ! dirname | | dirname . index Of ( "node _modules " ) > = 0 ) return ; logger . debug ( "Scanning directory for modules : " , dirname ) ; if ( fs . exists Sync ( path . resolve ( dirname , 'index .js ' ) ) ) { files . push ( path . resolve ( dirname , 'index .js ' ) ) ; return ; } fs . readdir Sync ( dirname ) . for Each ( function ( file ) { var fullpath = path . resolve ( dirname , file ) ; if ( ! fs . stat Sync ( fullpath ) . is File ( ) ) scan Dir ( fullpath ) ; else if ( file . match ( / . + \ .js / g ) ! = = null ) { files . push ( fullpath ) ; } } ) ; } 
function generate Client ( ) { logger . debug ( "Generating angoose client file : " ) ; var bundle = new Bundle ( ) ; var client = { } ; bundle . generate Client ( client ) ; var filename = angoose . config ( ) [ 'client -file ' ] ; write To File ( filename , client . source ) 
function config ( path , val ) { if ( ! path ) return options ; if ( ! angoose . initialized & & typeof ( path ) = = 'string ' ) throw "Cannot call config ( " + path + " ) before angoose is intialized " ; 
function connect ( url , next ) { log ( 'connecting to %s ' , url ) ; mongo . Db . connect ( url , { db : { w : 1 } } , next ) ; } 
function start Shell ( db , program , files ) { var repl = global . repl = term ( db ) ; create Context ( db , repl , function ( ) { var code = program . eval ; if ( code ) { execute JS ( code ) ; if ( ! program . shell ) { repl . emit ( 'exit ' ) ; return ; } } if ( files . length ) { execute Files ( files ) ; print Close Msg ( ) ; } repl . prompt = prompt ; repl . display Prompt ( ) } ) ; } 
function execute Files ( files ) { var dir = process . cwd ( ) ; files . for Each ( function ( file ) { require ( dir + ' / ' + file ) ; } ) ; } 
function execute JS ( script ) { if ( ! script ) return ; try { var ret = vm . run In This Context ( script , ' [eval ] ' ) ; if ( 'undefined ' ! = typeof ret ) { console . log ( ret ) ; } } catch ( err ) { if ( ! ( err instanceof Error ) ) { err = new Error ( err ) ; } console . log ( err . stack . split ( ' \n ' ) [ 0 ] ) ; process . exit ( 1 ) ; } } 
function Error Function ( message : string ) { const Err = Error Err . call ( this , message ) if ( no Fallback ) { Error . capture Stack Trace ( this , Error Function ) } else { this . stack = ( new Error ( ) ) . stack } this . name = this . constructor . name this . message = message } 
function create Constructor ( db ) { var collections = [ ] ; function DB ( ) { this . cols ( false , noop ) ; } ; ( DB . prototype . help = function ( ) { var proto = this . constructor . prototype ; var len = 0 ; var msgs = [ ] ; Object . keys ( proto ) . for Each ( function ( method ) { if ( proto [ method ] . help ) { var msg = proto [ method ] . help ( true ) ; len = Math . max ( len , method . length ) ; msgs . push ( { method : method , text : msg } ) } } ) msgs . sort ( function ( a , b ) { return a . method > b . method ? 1 : a . method < b . method ? - 1 : 0 } ) msgs . for Each ( function ( msg ) { var space = Array ( len - msg . method . length + 1 ) . join ( ' ' ) ; log ( "db . " + msg . method + " ( ) " + space + msg . text ) ; } ) } ) . help = help ( "Logs help text for all db methods " ) ; ; ( DB . prototype . drop = function ( cb ) { var name = db . database Name ; db . drop Database ( cb | | function ( err ) { if ( err ) { return console . error ( err ) ; } db . collections ( function ( ) { log ( 'database " %s " was dropped ' , name ) ; } ) ; } ) ; } ) . help = help ( "Drops the database " ) ; wrap ( DB . prototype , 'drop ' ) ; ; ( DB . prototype . close = function ( cb ) { if ( 'function ' ! = typeof cb ) { cb = handle Error ; } db . close ( true , cb ) ; } ) . help = help ( "Closes the database connection " ) ; wrap ( DB . prototype , 'close ' ) ; ; ( DB . prototype . open = function ( cb ) { db . open ( function ( err ) { if ( err ) { return handle Error ( err , cb ) ; } if ( 'function ' = = typeof cb ) { cb ( ) ; } } ) ; } ) . help = help ( "Opens the database connection " ) wrap ( DB . prototype , 'open ' ) ; ; ( DB . prototype . use = function ( name ) { return create ( db . db ( name ) ) ; } ) . help = help ( "Changes to a different database " ) ; ( DB . prototype . col = function ( name , opts ) { if ( this [ name ] ) { return this [ name ] ; } * Creates a collection * * @param {String } name * @param {Object } [options ] * @param {Function } [cb ] * / ; ( DB . prototype . create Col = function ( name , opts , cb ) { if ( 'function ' = = typeof opts ) { cb = opts ; opts = { } ; } if ( 'string ' ! = typeof name ) { error ( new Type Error ( 'collection name must be a string ' ) ) ; return ; } if ( ! opts ) opts = { } ; * Refresh and return the list of collections on this database * * @param {Boolean } [print ] if the collection names should be printed * @param {Function } [cb ] passed any error and the result array * / ; ( DB . prototype . cols = function ( print , cb ) { var self = this ; if ( 'function ' = = typeof print ) { cb = print ; print = false ; } if ( undefined = = print ) print = true db . collection Names ( { names Only : true } , function ( err , names ) { if ( err ) { if ( cb ) return cb ( err ) ; console . error ( err . stack ) ; return ; } if ( ! Array . is Array ( names ) ) { names = [ ] ; } * Execute a command on the database * * @param {Object } cmd * @param {Object } [opts ] * @param {Function } [cb ] * / ; ( DB . prototype . run Command = function ( cmd , opts , cb ) { if ( 'function ' = = typeof opts ) { cb = opts ; opts = { } ; } if ( ! cmd ) { var err = new Error ( 'missing command ' ) ; if ( cb ) return cb ( err ) ; console . error ( err ) ; return ; } if ( ! cb ) cb = p ; if ( ! opts ) opts = { } ; var admin = ! ! opts . admin ; delete opts . admin ; var method = admin ? 'execute Db Admin Command ' : 'execute Db Command ' db [ method ] ( cmd , opts , cb ) ; } ) . help = help ( "Runs a command on the database " ) wrap ( DB . prototype , 'run Command ' ) ; ; ( DB . prototype . stats = function ( scale , cb ) { if ( 'function ' = = typeof scale ) cb = scale ; scale | = 0 ; db . stats ( function ( err , stats ) { cb ( err , stats ) ; } ) } ) . help = help ( 'Retreive database stats ' ) ; wrap ( DB . prototype , 'stats ' ) ; ; ( DB . prototype . inspect = function ( ) { return db . database Name ; } ) . help = help ( "Returns the name of the database " ) ; return DB ; } 
function wrap ( proto , name ) { var old = proto [ name ] ; proto [ name ] = function ( ) { if ( global . repl ) global . repl . buffer Start ( ) ; var args = slice ( arguments ) ; var last = args [ args . length - 1 ] ; if ( 'function ' = = typeof last ) { args [ args . length - 1 ] = function ( ) { if ( global . repl ) global . repl . buffer End ( ) if ( p ! = last ) console . log ( ) ; last . apply ( null , arguments ) if ( global . repl ) { global . repl . display Prompt ( ) ; global . repl . move Cursor To End ( ) ; } } } else { args . push ( function ( ) { if ( global . repl ) global . repl . buffer End ( ) p . apply ( null , arguments ) ; if ( global . repl ) global . repl . move Cursor To End ( ) ; } ) ; } old . apply ( this , args ) ; } if ( old . help ) { proto [ name ] . help = old . help ; } } 
function handle Error ( err , cb ) { if ( err ) { if ( cb ) { return process . next Tick ( function ( ) { cb ( err ) ; } ) ; } console . error ( err ) ; } } 
function tablature ( conf ) { const { keys = [ ] , data = [ ] , headings = { } , replacements = { } , center Values = [ ] , center Headings = [ ] , } = conf const [ i ] = data if ( ! i ) return ' ' const cv = make Binary Hash ( center Values ) const hv = make Binary Hash ( center Headings ) const k = Object . keys ( i ) . reduce ( ( acc , key ) = > { const h = headings [ key ] return { . . . acc , [ key ] : h ? h . length : key . length , 
function metric ( name , val , message ) { 
function Std Error ( message ) { if ( ! ( this instanceof Std Error ) ) { return new Std Error ( message ) ; } Error . capture Stack Trace ( this , this . constructor ) ; this . code = this . _defaults . code ; this . name = this . _defaults . name ; this . message = this . _defaults . message ; switch ( typeof ( message ) ) { case "string " : this . message = message ; break ; case "object " : ( message . code ) & & ( this . code = message . code ) ; ( message . name ) & & ( this . name = message . name ) ; ( message . message ) & & ( this . message = message . message ) ; break ; } } 
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( ! ( this instanceof child ) ) { var obj = Object . create ( child . prototype ) ; child . apply ( obj , args ) ; return obj ; } self . apply ( this , args ) ; } 
function sanatize ( str ) { return str . replace ( / \ . \w + $ / , ' ' ) 
function fix Redirect Post ( ) { 
function low Chain ( _ , array , save ) { var chain = _ . chain ( array ) ; _ . functions In ( chain ) . for Each ( function ( method ) { chain [ method ] = _ . flow ( chain [ method ] , function ( arg ) { var v = void 0 ; if ( arg ) { v = _ . is Function ( arg . value ) ? arg . value ( ) : arg ; } var s = save ( ) ; if ( s ) return s . then ( function ( ) { return Promise . resolve ( v ) ; } ) ; return v ; } ) ; } ) ; return chain ; } 
function _save ( ) { if ( db . source & & db . write & & write On Change ) { var str = JSON . stringify ( db . object ) ; if ( str ! = = db . _checksum ) { db . _checksum = str ; return db . write ( db . source , db . object ) ; } } } 
function Picklr ( start Dir , options ) { options = options | | { } ; let default Exclude Dirs Re ; if ( / ^ \ . / . test ( start Dir ) ) { default Exclude Dirs Re = / \ / \ . |node _modules / i ; } else { default Exclude Dirs Re = / ^ \ . | \ / \ . |node _modules / i ; } this . total File Count = 0 ; this . matched File Count = 0 ; this . start Dir = start Dir | | ' . ' ; this . target Text = options . target Text | | ' ' ; this . replacement Text = options . replacement Text | | ' ' ; this . action = options . action | | 'echo ' ; this . include Exts = options . include Exts | | [ ' .js ' ] ; this . exclude Dirs = options . exclude Dirs Re | | default Exclude Dirs Re ; this . logger = options . logger | | console . log ; this . picklr Actions = picklr Actions ; } 
function ( p ) { fs . readdir Sync ( p ) . for Each ( function ( file ) { const cur Path = path . join ( p , path . sep , file ) ; const stats = fs . stat Sync ( cur Path ) ; if ( this . is Directory ( stats , cur Path ) ) { this . recurse Files ( cur Path ) ; } else if ( this . is File ( stats , cur Path ) ) { this . picklr Actions [ this . action ] . call ( this , cur Path ) ; } } , this ) ; if ( p = = = this . start Dir ) { this . logger ( 'Total file count = ' + this . total File Count ) ; if ( this . action ! = = 'echo ' ) { this . logger ( 'Matched file count = ' + this . matched File Count ) ; } } } 
function ( stats , p ) { let result = stats . is File ( ) ; if ( result ) { const ext = path . extname ( p ) ; result = this . include Exts . index Of ( ext ) ! = = - 1 ; } return result ; } 
function ( stats , p ) { let result = stats . is Directory ( ) ; if ( result ) { result = ! this . exclude Dirs . test ( p ) ; } return result ; } 
function process All Files ( start Dir , options ) { const picklr = new Picklr ( start Dir , options ) ; picklr . recurse Files ( start Dir ) ; } 
function process File ( file Path , update ) { let change , found = false ; const lines = fs . read File Sync ( file Path , { encoding : 'utf 8 ' } ) . split ( ' \n ' ) ; for ( let i = 0 ; i < lines . length ; i + + ) { if ( lines [ i ] . index Of ( this . target Text ) ! = = - 1 ) { found = true ; change = lines [ i ] . replace ( this . target Text , this . replacement Text ) ; if ( update ) { lines [ i ] = change ; } else { 
function extract Encoding ( headers ) { var type = headers [ "content -type " ] ; if ( ! type ) { return "utf 8 " ; } var split = type . split ( ' = ' ) ; return split . length = = 2 ? split [ 1 ] : "utf 8 " ; } 
function substr ( string , start , length ) { if ( ! is String ( string ) ) { return string ; } return string . substr ( start , length ) ; } 
async function init HTTPServer ( { ENV = { } , HOST = ' 1 2 7 . 0 . 0 . 1 ' , PORT = 8 0 8 0 , MAX _HEADERS _COUNT = 8 0 0 , KEEP _ALIVE _TIMEOUT = ms ( ' 5m ' ) , TIMEOUT = ms ( ' 2m ' ) , MAX _CONNECTIONS , http Router , log = noop , } ) { const sockets = ENV . DESTROY _SOCKETS ? new Set ( ) : { } . undef ; const http Server = http . create Server ( http Router ) ; const listen Promise = new Promise ( resolve = > { http Server . listen ( PORT , HOST , ( ) = > { log ( 'info ' , ` $ { HOST } $ { PORT } ` ) ; resolve ( http Server ) ; } ) ; } ) ; const error Promise = new Promise ( ( resolve , reject ) = > { http Server . once ( 'error ' , reject ) ; } ) ; http Server . timeout = TIMEOUT ; http Server . keep Alive Timeout = KEEP _ALIVE _TIMEOUT ; http Server . max Headers Count = MAX _HEADERS _COUNT ; http Server . max Connections = MAX _CONNECTIONS ; if ( 'undefined ' ! = = typeof MAX _CONNECTIONS ) { http Server . max Connections = MAX _CONNECTIONS ; } if ( ENV . DESTROY _SOCKETS ) { http Server . on ( 'connection ' , socket = > { sockets . add ( socket ) ; socket . on ( 'close ' , ( ) = > { sockets . delete ( socket ) ; } ) ; } ) ; } return Promise . race ( [ listen Promise , error Promise ] ) . then ( ( ) = > ( { service : http Server , error Promise , dispose : ( ) = > new Promise ( ( resolve , reject ) = > { log ( 'debug ' , 'Closing HTTP server . ' ) ; 
function sort And Add First Element ( array , sort By , element ) { return _ ( array ) . sort By ( sort By ) . unshift ( element ) . value ( ) ; } 
function object Interface ( config ) { return function ( obj ) { var result = { } ; for ( var i = 0 ; i < config . length ; i + + ) { var OR , NEXT , REAL ; if ( ( OR = config [ i ] . split ( ' / ' ) ) & & OR [ 1 ] ) { result [ OR [ 0 ] ] = obj [ OR [ 0 ] ] | | Function ( 'return ' + OR [ 1 ] ) ( ) ; } else if ( ( NEXT = config [ i ] . split ( ' | ' ) ) & & NEXT [ 1 ] ) { result [ NEXT [ 0 ] ] = Function ( 'return ' + NEXT [ 1 ] ) . call ( obj ) ; } else if ( ( REAL = config [ i ] . split ( ' : ' ) ) & & REAL [ 1 ] ) { result [ REAL [ 0 ] ] = Function ( 'return ' + REAL [ 1 ] ) ( ) ; } else { result [ config [ i ] ] = obj [ config [ i ] ] ; } } return result ; } } 
function init HTTPTransaction ( { TIMEOUT = DEFAULT _TIMEOUT , TRANSACTIONS , log = noop , time , delay , unique Id = create Incrementor ( ) , } ) { * Create a new HTTP transaction * @param {HTTPRequest } req * A raw Node JS HTTP incoming message * @param {HTTPResponse } res * A raw Node JS HTTP response * @return {Array } * The normalized request and the HTTP * transaction created in an array . * / function http Transaction ( req , res ) { let initialization Promise ; return Promise . resolve ( ) . then ( ( ) = > { const request = { url : req . url , method : req . method . to Lower Case ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https ' : 'http ' , ip : ( req . headers [ 'x -forwarded -for ' ] | | ' ' ) . split ( ' , ' ) [ 0 ] | | req . connection . remote Address , start In Bytes : req . socket . bytes Read , start Out Bytes : req . socket . bytes Written , start Time : time ( ) , url : req . url , method : req . method , req Headers : req . headers , errored : false , } ; const delay Promise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction -id ' ] | | unique Id ( ) ; Once initiated , the transaction can be started . It basically spawns a promise that will be resolved to the actual response or rejected if the timeout is reached . * / return Promise . race ( [ initialization Promise . then ( ( ) = > build Response ( ) ) , delay Promise . then ( ( ) = > { throw new HTTPError ( 5 0 4 , 'E _TRANSACTION _TIMEOUT ' , TIMEOUT , id ) ; } ) , ] ) ; } function catch Transaction ( { id , req } , err ) { err = HTTPError . cast ( err , err . http Code | | 5 0 0 ) ; log ( 'error ' , 'An error occured ' , { guru Meditation : id , request : TRANSACTIONS [ id ] . protocol + ' : / / ' + ( req . headers . host | | 'localhost ' ) + TRANSACTIONS [ id ] . url , verb : req . method , status : err . http Code , code : err . code , stack : err . stack , details : err . params , } ) ; TRANSACTIONS [ id ] . errored = true ; throw err ; } function end Transaction ( { id , req , res , delay Promise } , response ) { return new Promise ( ( resolve , reject ) = > { res . on ( 'error ' , reject ) ; res . on ( 'finish ' , resolve ) ; res . write Head ( response . status , statuses [ response . status ] , Object . assign ( { } , response . headers , { 'Transaction -Id ' : id } ) , ) ; if ( response . body & & response . body . pipe ) { response . body . pipe ( res ) ; } else { res . end ( ) ; } } ) . catch ( err = > { TRANSACTIONS [ id ] . errored = true ; log ( 'error ' , 'An error occured ' , { guru Meditation : id , request : TRANSACTIONS [ id ] . protocol + ' : / / ' + ( req . headers . host | | 'localhost ' ) + TRANSACTIONS [ id ] . url , method : req . method , stack : err . stack | | err , } ) ; } ) . then ( ( ) = > { TRANSACTIONS [ id ] . end Time = time ( ) ; TRANSACTIONS [ id ] . end In Bytes = req . socket . bytes Read ; TRANSACTIONS [ id ] . end Out Bytes = req . socket . bytes Written ; TRANSACTIONS [ id ] . status Code = response . status ; TRANSACTIONS [ id ] . res Headers = response . headers | | { } ; log ( 'info ' , TRANSACTIONS [ id ] ) ; delete TRANSACTIONS [ id ] ; return delay . clear ( delay Promise ) ; } ) ; } } 
function http Transaction ( req , res ) { let initialization Promise ; return Promise . resolve ( ) . then ( ( ) = > { const request = { url : req . url , method : req . method . to Lower Case ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https ' : 'http ' , ip : ( req . headers [ 'x -forwarded -for ' ] | | ' ' ) . split ( ' , ' ) [ 0 ] | | req . connection . remote Address , start In Bytes : req . socket . bytes Read , start Out Bytes : req . socket . bytes Written , start Time : time ( ) , url : req . url , method : req . method , req Headers : req . headers , errored : false , } ; const delay Promise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction -id ' ] | | unique Id ( ) ; 
function date Difference ( date 1 , date 2 , difference Type ) { var diff Milliseconds = Math . abs ( date 1 - date 2 ) ; switch ( difference Type ) { case 'days ' : return dates . _get Days Diff ( diff Milliseconds ) ; case 'hours ' : return dates . _difference In Hours ( diff Milliseconds ) ; case 'minutes ' : return dates . _difference In Minutes ( diff Milliseconds ) ; case 'milliseconds ' : return diff Milliseconds ; default : return { days : dates . _get Days Diff ( diff Milliseconds ) , hours : dates . _get Hours Diff ( diff Milliseconds ) , minutes : dates . _get Minutes Diff ( diff Milliseconds ) , milliseconds : diff Milliseconds } } } 
function init Error Handler ( { ENV = { } , DEBUG _NODE _ENVS = DEFAULT _DEBUG _NODE _ENVS , STRINGIFYERS = DEFAULT _STRINGIFYERS , } ) { return Promise . resolve ( error Handler ) ; function error Handler ( transaction Id , response Spec , err ) { return Promise . resolve ( ) . then ( ( ) = > { const response = { } ; response . status = err . http Code | | 5 0 0 ; response . headers = Object . assign ( { } , err . headers | | { } , { 
function date Difference From Now ( date , difference Type ) { var now = new Date ( ) , diff Milliseconds = Math . abs ( date - now ) ; switch ( difference Type ) { case 'days ' : return dates . _get Days Diff ( diff Milliseconds ) ; case 'hours ' : return dates . _difference In Hours ( diff Milliseconds ) ; case 'minutes ' : return dates . _difference In Minutes ( diff Milliseconds ) ; case 'milliseconds ' : return diff Milliseconds ; default : return { days : dates . _get Days Diff ( diff Milliseconds ) , hours : dates . _get Hours Diff ( diff Milliseconds ) , minutes : dates . _get Minutes Diff ( diff Milliseconds ) , milliseconds : diff Milliseconds } } } 
function init HTTPRouter ( { ENV = { } , DEBUG _NODE _ENVS = DEFAULT _DEBUG _NODE _ENVS , BUFFER _LIMIT = DEFAULT _BUFFER _LIMIT , HANDLERS , API , PARSERS = DEFAULT _PARSERS , STRINGIFYERS = DEFAULT _STRINGIFYERS , DECODERS = DEFAULT _DECODERS , ENCODERS = DEFAULT _ENCODERS , QUERY _PARSER = strict Qs , log = noop , http Transaction , error Handler , } ) { const buffer Limit = bytes . parse ( BUFFER _LIMIT ) ; const ajv = new Ajv ( { verbose : ENV & & DEBUG _NODE _ENVS . includes ( ENV . NODE _ENV ) , } ) ; const consumable Charsets = Object . keys ( DECODERS ) ; const produceable Charsets = Object . keys ( ENCODERS ) ; const default Response Spec = { content Types : Object . keys ( STRINGIFYERS ) , charsets : produceable Charsets , } ; return flatten Swagger ( API ) . then ( _create Routers . bind ( null , { HANDLERS , ajv } ) ) . then ( routers = > { let handle Fatal Error ; log ( 'debug ' , 'HTTP Router initialized . ' ) ; return { service : http Router , fatal Error Promise : { promise : new Promise ( ( resolve , reject ) = > { handle Fatal Error = reject ; } ) , } , } ; function http Router ( req , res ) { let operation ; let response Spec = default Response Spec ; return http Transaction ( req , res ) . then ( ( [ request , transaction ] ) = > transaction . start ( ( ) = > Promise . resolve ( ) . then ( ( ) = > { const method = request . method ; const path = request . url . split ( SEARCH _SEPARATOR ) [ 0 ] ; const search = request . url . substr ( path . length ) ; const parts = path . split ( ' / ' ) . filter ( a = > a ) ; let [ result , path Parameters ] = routers [ method ] ? routers [ method ] . find ( parts ) : [ ] ; 
function http Router ( req , res ) { let operation ; let response Spec = default Response Spec ; return http Transaction ( req , res ) . then ( ( [ request , transaction ] ) = > transaction . start ( ( ) = > Promise . resolve ( ) . then ( ( ) = > { const method = request . method ; const path = request . url . split ( SEARCH _SEPARATOR ) [ 0 ] ; const search = request . url . substr ( path . length ) ; const parts = path . split ( ' / ' ) . filter ( a = > a ) ; let [ result , path Parameters ] = routers [ method ] ? routers [ method ] . find ( parts ) : [ ] ; 
function offset Past Auto Closed ( line , pos , options ) { 
function get Start Offset ( line , pos , prefix ) { if ( ! prefix ) { return 0 ; } const stream = new Stream Reader ( line ) ; const compiled Prefix = String ( prefix ) . split ( ' ' ) . map ( code ) ; stream . pos = pos ; let result ; while ( ! stream . sol ( ) ) { if ( consume Pair ( stream , SQUARE _BRACE _R , SQUARE _BRACE _L ) | | consume Pair ( stream , CURLY _BRACE _R , CURLY _BRACE _L ) ) { continue ; } result = stream . pos ; if ( consume Array ( stream , compiled Prefix ) ) { return result ; } stream . pos - - ; } return - 1 ; } 
function consume Pair ( stream , close , open ) { const start = stream . pos ; if ( stream . eat ( close ) ) { while ( ! stream . sol ( ) ) { if ( stream . eat ( open ) ) { return true ; } stream . pos - - ; } } stream . pos = start ; return false ; } 
function consume Array ( stream , arr ) { const start = stream . pos ; let consumed = false ; for ( let i = arr . length - 1 ; i > = 0 & & ! stream . sol ( ) ; i - - ) { if ( ! stream . eat ( arr [ i ] ) ) { break ; } consumed = i = = = 0 ; } if ( ! consumed ) { stream . pos = start ; } return consumed ; } 
function is Ident ( c ) { return c = = = COLON | | c = = = DASH | | is Alpha ( c ) | | is Number ( c ) ; } 
async function hela ( opts ) { const options = Object . assign ( { argv : { } , prefix : 'hela -config - ' , stdio : 'inherit ' } , opts ) if ( options . tasks | | ( options . presets | | options . extends ) ) { return preset Resolver ( options ) } return pretty Config ( 'hela ' , options ) . then ( ( config ) = > { if ( ! config ) { throw new Error ( 'hela : no config ' ) } return preset Resolver ( Object . assign ( { } , config , options ) ) } ) } 
function factory ( type , opts ) { return ( cmds , options ) = > { const cmd = { exec : execa . exec , shell : execa . shell } return cmd [ type ] ( cmds , Object . assign ( { } , opts , options ) ) } } 
function preset Resolver ( opts ) { const presets = arrayify ( opts . presets | | opts . extends ) if ( presets . length > 0 ) { const arg = Object . assign ( { } , opts ) const options = Object . assign ( { first : arg } , opts ) const tasks = resolve Plugins ( presets , options ) . reduce ( ( acc , preset ) = > preset Reducer ( acc , preset ) , { } ) return transform Tasks ( opts , Object . assign ( { } , tasks , opts . tasks ) ) } return transform Tasks ( opts , opts . tasks ) } 
async function run ( ) { const pkg = await read Json ( path . join ( options . cwd , 'package .json ' ) ) const tasks = await hela ( { pkg , . . . options } ) const name = options . task Name if ( Object . keys ( tasks ) . length = = = 0 ) { throw new Error ( 'hela : no tasks ' ) } const has Own = ( o , k ) = > Object . prototype . has Own Property . call ( o , k ) if ( ! has Own ( tasks , name ) ) { throw new Error ( ` $ { name } ` ) } return tasks [ name ] ( ) } 
function plugin ( options ) { if ( ! options ) throw new Error ( 'no options passed ' ) if ( ! options . src ) throw new Error ( 'required : options .src ' ) if ( ! options . dest ) throw new Error ( 'required : options .dest ' ) if ( ! options . auth ) throw new Error ( 'required : options .auth ' ) 
function _write ( file , encoding , next ) { this . workers + + vow . resolve ( file ) . then ( ( file ) = > folder . download File ( file ) ) . then ( ( file ) = > folder . front Matter ( file ) ) . then ( ( file ) = > folder . store File ( file ) ) . catch ( dbg ) . then ( ( ) = > { this . workers - - next ( ) } ) 
function _do Auth ( auth ) { if ( oauth ) return vow . resolve ( ) dbg ( 'doing o Auth 2 ' ) const google Auth = new Google Auth ( ) oauth = new google Auth . OAuth 2 ( auth . client _id , auth . client _secret , [ 'urn :ietf :wg :oauth : 2 . 0 :oob ' , 'http : / /localhost ' ] ) return vow . resolve ( ) . then ( ( ) = > { 
function _token Flow ( ) { const defer = vow . defer ( ) let prompt const auth Url = oauth . generate Auth Url ( { access _type : 'offline ' , scope : [ 'https : / /www .googleapis .com /auth /drive .readonly ' ] } ) console . log ( 'authorise metalsmith -google -drive by visiting : ' , auth Url ) prompt = readline . create Interface ( { input : process . stdin , output : process . stdout } ) prompt . question ( 'Enter the code from that page here (or "ok " to skip scrape ) : ' , ( code ) = > { prompt . close ( ) if ( code = = = 'ok ' ) return defer . reject ( 'skip ' ) oauth . get Token ( code , ( err , result ) = > { if ( err ) { dbg ( err ) defer . reject ( err ) } else { console . log ( ' - - - - - - - - - - snip - - - - - - - - - - ' ) console . log ( hjson . stringify ( { 'metalsmith -google -drive ' : { token : result } } , { separator : true , spaces : 2 , braces Same Line : true , quotes : 'all ' } ) ) console . log ( ' - - - - - - - - - - snip - - - - - - - - - - ' ) console . log ( 'this token is cached automatically , but you can store ' ) console . log ( 'it in a config file like config /local .js if you want . ' ) value Cache . store ( 'token ' , result ) defer . resolve ( result ) } } ) } ) return defer . promise ( ) } 
function on Cycle ( event ) { if ( object Pool . length = = 0 ) { throw new Error ( 'Pool ran out of objects ' ) ; } console . log ( String ( event . target ) ) ; init Pool ( ) ; } 
function modifier ( action , state ) { if ( action . type = = = 'example ' ) { return extend ( state , { example : true } ) } else if ( action . type = = = 'title ' ) { return extend ( state , { title : action . title } ) } } 
function json ( file ) { var filename = path . basename ( file . path , path . extname ( file . path ) ) + " .json " ; return optional ( path . join ( path . dirname ( file . path ) , filename ) ) | | { } ; } 
function ( ) { const self = this ; const TIME _PER _LEVEL = 1 * 1 0 0 0 ; this . level = 0 ; this . stack = [ ] ; this . fsm = new Fsm ( ) ; const open = new Fsm . State ( { fsm : self . fsm , name : 'open ' , on Entry : function ( ) { const state = this ; console . log ( 'Door opened at level ' , self . level ) ; set Timeout ( function ( ) { state . transition To ( closed ) ; } , 2 0 0 0 ) ; } , on Event : function ( event ) { if ( event . name = = = 'go To Level ' & & event . level ! = = self . level ) { self . push Level ( event . level ) ; } } } ) ; const closed = new Fsm . State ( { fsm : self . fsm , name : 'closed ' , on Entry : function ( ) { console . log ( 'Door closed ' ) ; * When the elevator 's doors are closed , * we wait for a request to move to another * level . * / on Event : function ( event ) { if ( event . name = = = 'go To Level ' ) { if ( event . level = = = self . level ) { this . transition To ( open ) ; } else { self . push Level ( event . level ) ; this . transition To ( moving ) ; } } } } ) ; / * * * The elevator is currently moving from a * level to another . * / const moving = new Fsm . State ( { fsm : self . fsm , name : 'moving ' , on Entry : function ( ) { const state = this ; const next = self . stack . shift ( ) ; console . log ( 'Moving to level ' , next ) ; set Timeout ( function ( ) { console . log ( 'Reached level ' , next ) ; self . level = next ; state . transition To ( open ) ; } , TIME _PER _LEVEL * Math . abs ( next - self . level ) ) ; } , / * * * As the elevator is currently moving and * cannot change direction nor open the * doors , we push any user request to go to * a level on the level stack . * / on Event : function ( event ) { if ( event . name = = = 'go To Level ' ) { self . push Level ( event . level ) ; } } } ) ; 
function ( event ) { if ( event . name = = = 'go To Level ' & & event . level ! = = self . level ) { self . push Level ( event . level ) ; } } 
function ( event ) { if ( event . name = = = 'go To Level ' ) { if ( event . level = = = self . level ) { this . transition To ( open ) ; } else { self . push Level ( event . level ) ; this . transition To ( moving ) ; } } } 
function decrypt CBC ( encrypted Components , key Derivation Info ) { 
function decrypt GCM ( encrypted Components , key Derivation Info ) { 
function encrypt CBC ( text , key Derivation Info , iv ) { return Promise . resolve ( ) . then ( ( ) = > { const iv Hex = iv . to String ( "hex " ) ; const encrypt Tool = crypto . create Cipheriv ( ENC _ALGORITHM _CBC , key Derivation Info . key , iv ) ; const hmac Tool = crypto . create Hmac ( HMAC _ALGORITHM , key Derivation Info . hmac ) ; const { rounds } = key Derivation Info ; 
function encrypt GCM ( text , key Derivation Info , iv ) { return Promise . resolve ( ) . then ( ( ) = > { const iv Hex = iv . to String ( "hex " ) ; const { rounds } = key Derivation Info ; const encrypt Tool = crypto . create Cipheriv ( ENC _ALGORITHM _GCM , key Derivation Info . key , iv ) ; 
function generate Salt ( length ) { if ( length < = 0 ) { return Promise . reject ( new Error ( ` $ { length } ` ) ) ; } let output = " " ; while ( output . length < length ) { output + = crypto . random Bytes ( 3 ) . to String ( "base 6 4 " ) ; if ( output . length > length ) { output = output . substr ( 0 , length ) ; } } return Promise . resolve ( output ) ; } 
function pack Encrypted Content ( encrypted Content , iv , salt , auth , rounds , method ) { return [ encrypted Content , iv , salt , auth , rounds , method ] . join ( " $ " ) ; } 
function unpack Encrypted Content ( encrypted Content ) { const [ content , iv , salt , auth , rounds Raw , method Raw ] = encrypted Content . split ( " $ " ) ; 
function derive From Password ( pbkdf 2Gen , password , salt , rounds , generate HMAC = true ) { if ( ! password ) { return Promise . reject ( new Error ( "Failed deriving key : Password must be provided " ) ) ; } if ( ! salt ) { return Promise . reject ( new Error ( "Failed deriving key : Salt must be provided " ) ) ; } if ( ! rounds | | rounds < = 0 ) { return Promise . reject ( new Error ( "Failed deriving key : Rounds must be greater than 0 " ) ) ; } const bits = generate HMAC ? ( PASSWORD _KEY _SIZE + HMAC _KEY _SIZE ) * 8 : PASSWORD _KEY _SIZE * 8 ; return pbkdf 2Gen ( password , salt , rounds , bits ) . then ( derived Key Data = > derived Key Data . to String ( "hex " ) ) . then ( function ( derived Key Hex ) { const dkh Length = derived Key Hex . length ; const key Buffer = generate HMAC ? new Buffer ( derived Key Hex . substr ( 0 , dkh Length / 2 ) , "hex " ) : new Buffer ( derived Key Hex , "hex " ) ; const output = { salt : salt , key : key Buffer , rounds : rounds } ; if ( generate HMAC ) { output . hmac = new Buffer ( derived Key Hex . substr ( dkh Length / 2 , dkh Length / 2 ) , "hex " ) ; } return output ; } ) ; } 
function pbkdf 2 ( password , salt , rounds , bits ) { return new Promise ( ( resolve , reject ) = > { derive Key ( password , salt , rounds , bits / 8 , DERIVED _KEY _ALGORITHM , ( err , key ) = > { if ( err ) { return reject ( err ) ; } return resolve ( key ) ; } ) ; } ) ; } 
function Node ( id , opts ) { var me = this this . id = id Object . define Property ( me , 'inner ' , { value : opts . inner , enumerable : false , writable : true } ) Object . define Property ( me , 'outer ' , { value : opts . outer , enumerable : false , writable : true } ) Object . define Property ( me , this . inner , { value : new Edge ( { inner : this . inner , outer : this . outer , id : id } ) , enumerable : false , writable : true } ) Object . define Property ( me , this . outer , { value : new Edge ( { inner : this . outer , outer : this . inner , id : id } ) , enumerable : false , writable : true } ) } 
function Edge ( opts ) { this . id = opts . id this . innerformat = opts . inner + ' _ %s ' this . outerformat = opts . outer + ' _ %s ' this . innerkey = format ( this . innerformat , this . id ) this . outerkey = format ( this . outerformat , this . id ) this [ opts . inner ] = function ( cb ) { this . all ( function ( error , array ) { if ( error ) return cb ( error ) if ( ! array | | ! array . length ) return cb ( null , array | | [ ] ) array = array . map ( function ( gid ) { return format ( this . innerformat , String ( gid ) ) } , this ) db . sunion ( array , cb ) } . bind ( this ) ) } this [ opts . outer ] = function ( cb ) { this . all ( function ( error , array ) { if ( error ) return cb ( error ) if ( ! array | | ! array . length ) return cb ( null , array | | [ ] ) array = array . map ( function ( gid ) { return format ( this . outerformat , gid ) } , this ) db . sunion ( array , cb ) } . bind ( this ) ) } } 
function get Dynamic Segments ( segments ) { return segments . filter ( item = > item . type = = = 1 | | ! ! item . name ) . map ( item = > item . value | | item . name ) ; } 
function create Encode Stream ( schema ) { const stream = new Binary Stream ( { readable Object Mode : false , writable Object Mode : true , transform : transform Encode , } ) ; stream [ kschema ] = schema ; return stream ; } 
function create Decode Stream ( buf Or Schema ) { let schema = null ; const is Buffer = Buffer . is Buffer ( buf Or Schema ) ; if ( ! is Buffer ) { schema = buf Or Schema ; } const stream = new Binary Stream ( { transform : transform Decode , readable Object Mode : true , writable Object Mode : false , } ) ; stream [ kschema ] = schema ; if ( is Buffer ) { stream . append ( buf Or Schema ) ; } return stream ; } 
function transform Encode ( chunk , encoding , cb ) { try { encode ( chunk , this [ kschema ] , this ) ; const buf = this . slice ( ) ; this . consume ( buf . length ) ; cb ( null , buf ) ; } catch ( error ) { cb ( error ) ; } } 
function transform Decode ( chunk , encoding , cb ) { this . append ( chunk ) ; try { while ( this . length > 0 ) { const transaction = new Transaction ( this ) ; const data = decode ( transaction , this [ kschema ] ) ; transaction . commit ( ) ; this . push ( data ) ; } cb ( ) ; } catch ( error ) { if ( error instanceof Not Enough Data Error ) { cb ( ) ; } else { cb ( error ) ; } } } 
function erdos Renyi ( Graph Class , options ) { if ( ! is Graph Constructor ( Graph Class ) ) throw new Error ( 'graphology -generators /random /erdos -renyi : invalid Graph constructor . ' ) ; var order = options . order , probability = options . probability , rng = options . rng | | Math . random ; var graph = new Graph Class ( ) ; 
function erdos Renyi Sparse ( Graph Class , options ) { if ( ! is Graph Constructor ( Graph Class ) ) throw new Error ( 'graphology -generators /random /erdos -renyi : invalid Graph constructor . ' ) ; var order = options . order , probability = options . probability , rng = options . rng | | Math . random ; var graph = new Graph Class ( ) ; 
function generate BLEPayload Parser ( profile Data ) { var output Src = " " ; log ( " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * " ) ; log ( " Generating Java Script source file for BLE Payload parser " ) ; log ( " * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * " ) ; output Src = output Src + add License Text ( ) ; output Src = output Src + " / / " + " \r \n " + " / / Payload Parser .js " + " \r \n " + " / / " + " \r \n " + " / / Autogenerated source " + " \r \n " + " / / " + " \r \n " + " / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " + " \r \n " + " / / BLE Payload parser " + " \r \n " + " / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " + " \r \n " + " \r \n " + " 'use strict ' " + " \r \n " + " var Int 6 4LE = require ( 'int 6 4 -buffer ' ) .Int 6 4LE ; " + " \r \n " + " import DLog from ' . . /common /DLog ' ; " + " \r \n " + " const dp =require ( ' . /Payload Defs ' ) ; " + " \r \n " + " \r \n " ; for ( var x = 0 ; x < profile Data . Services . length ; x + + ) { var service = profile Data . Services [ x ] ; var service Name Str = prepare Src String ( service . Name ) ; var svc Name Snake Str = prepare Src String As Snake Case ( service . Name ) ; for ( var y = 0 ; y < service . Characteristics . length ; y + + ) { var characteristic = service . Characteristics [ y ] ; var characteristic Name Str = prepare Src String ( characteristic . Name ) ; var characteristic Name Snake Str = prepare Src String As Snake Case ( characteristic . Name ) ; var chr _json _filename = "chr _ " + characteristic Name Snake Str ; output Src = output Src + " var " + chr _json _filename + " _JSON = require ( ' . . /device _services /profile /chr / " + chr _json _filename + " ' ) ; " + " \r \n " + " var " + chr _json _filename + " _uuid = " + chr _json _filename + " _JSON .Characteristic .uuid ; " + " \r \n " + " if ( " + chr _json _filename + " _JSON .Characteristic .Value ! = undefined ) { " + " \r \n " + " var " + chr _json _filename + " _format = " + chr _json _filename + " _JSON .Characteristic .Value .Field .Format ; " + " \r \n " + " } " + " \r \n " ; } } output Src = output Src + " \r \n " + " var n Payload Parser Obj Cnt = 0 ; " + " \r \n " + " var instance Payload Parser = null ; " + " \r \n " + " const BLE _CHARC _VALUE _MAX _LEN = 2 0 ; " + " \r \n " + " \r \n " + " export function get Payload Parser Instance ( ) " + " \r \n " + " { " + " \r \n " + " if (n Payload Parser Obj Cnt > 0 ) " + " \r \n " + " { " + " \r \n " + " DLog .print Debug Msg ( 'Its a singleton class , returning existing instance of Payload Parser class ' ) ; " + " \r \n " + " return instance Payload Parser ; " + " \r \n " + " } " + " \r \n " + " n Payload Parser Obj Cnt + + ; " + " \r \n " + " DLog .print Debug Msg ( 'Payload Parser Object Count is ' + n Payload Parser Obj Cnt ) ; " + " \r \n " + " instance Payload Parser = new Payload Parser ( ) ; " + " \r \n " + " return instance Payload Parser ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " class Payload Parser { " + " \r \n " + " constructor (props ) { " + " \r \n " + " } " + " \r \n " + " \r \n " + " parse (svc _class _name ,args ) " + " \r \n " + " { " + " \r \n " + " switch (args .characteristic ) " + " \r \n " + " { " + " \r \n " ; for ( var x = 0 ; x < profile Data . Services . length ; x + + ) { var service = profile Data . Services [ x ] ; var service Name Str = prepare Src String ( service . Name ) ; var svc Name Snake Str = prepare Src String As Snake Case ( service . Name ) ; for ( var y = 0 ; y < service . Characteristics . length ; y + + ) { var characteristic = service . Characteristics [ y ] ; var characteristic Name Str = prepare Src String ( characteristic . Name ) ; var characteristic Name Snake Str = prepare Src String As Snake Case ( characteristic . Name ) ; var chr _json _filename = "chr _ " + characteristic Name Snake Str ; var pkt _chr _name = "pkt _ " + characteristic Name Snake Str ; output Src = output Src + " case " + chr _json _filename + " _uuid .to Upper Case ( ) : " + " \r \n " + " DLog .print Debug (this , ' Characteristics format is = ' + " + chr _json _filename + " _format ) ; " + " \r \n " + " if ( " + chr _json _filename + " _format = = 'uint 8 ' | | " + " \r \n " + " " + chr _json _filename + " _format = = 'uint 1 6 ' | | " + " \r \n " + " " + chr _json _filename + " _format = = 'uint 3 2 ' | | " + " \r \n " + " " + chr _json _filename + " _format = = 'uint 6 4 ' ) " + " \r \n " + " { " + " \r \n " + " let " + pkt _chr _name + " = { " + " \r \n " + " " + characteristic Name Str + " : { " + " \r \n " + " 'FMT ' : ' ' , " + " \r \n " + " } " + " \r \n " + " } " + " \r \n " + " " + pkt _chr _name + " . " + characteristic Name Str + " .FMT = " + chr _json _filename + " _format ; " + " \r \n " + " return this .parse Datapayload Pkt (args .value , " + pkt _chr _name + " ) ; " + " \r \n " + " } " + " \r \n " + " else " + " \r \n " + " { " + " \r \n " + " if (dp . " + pkt _chr _name + " ! = undefined ) { " + " \r \n " + " return this .parse Datapayload Pkt (args .value ,dp . " + pkt _chr _name + " ) ; " + " \r \n " + " } " + " \r \n " + " break ; " + " \r \n " + " } " + " \r \n " ; } } output Src = output Src + " default : " + " \r \n " + " return null ; " + " \r \n " + " } " + " \r \n " + " return null ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " parse Datapayload Pkt (packet Arr , datapayload Def ) " + " \r \n " + " { " + " \r \n " + " var packet Byt Buf = this .byte Array 2DVByte Buffer (packet Arr ) ; " + " \r \n " + " if (packet Byt Buf = = = null ) " + " \r \n " + " { " + " \r \n " + " DLog .print Debug (this , 'packet Byt Buf is NUll ' ) ; " + " \r \n " + " return 'parse _error ' ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " var datapayload Struct = { } ; " + " \r \n " + " var totaldatapayload Struct Keys = Object .keys (datapayload Struct ) .length ; " + " \r \n " + " var totaldatapayload Struct Values = Object .values (datapayload Struct ) .length ; " + " \r \n " + " var total Fields = Object .keys (datapayload Def ) .length ; " + " \r \n " + " \r \n " + " DLog .print Debug (this , 'total datapayload Fields = ' + total Fields + " + " \r \n " + " ' /totaldatapayload Struct Keys = ' + totaldatapayload Struct Keys + " + " \r \n " + " ' /totaldatapayload Struct Values = ' + totaldatapayload Struct Values ) ; " + " \r \n " + " \r \n " + " for (var [key Field Name , value Field Def ] of Object .entries (datapayload Def ) ) { " + " \r \n " + " datapayload Struct [key Field Name ] = this .extract Data (packet Byt Buf , value Field Def ) ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " totaldatapayload Struct Keys = Object .keys (datapayload Struct ) .length " + " \r \n " + " totaldatapayload Struct Values = Object .values (datapayload Struct ) .length ; " + " \r \n " + " \r \n " + " DLog .print Debug (this , ' /totaldatapayload Struct Keys = ' + totaldatapayload Struct Keys + " + " \r \n " + " ' /totaldatapayload Struct Values = ' + totaldatapayload Struct Values ) ; " + " \r \n " + " DLog .print Debug (this ,datapayload Struct ) ; " + " \r \n " + " \r \n " + " return datapayload Struct ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " extract Data (payload Data Byt Buf , payload Data Field Def ) " + " \r \n " + " { " + " \r \n " + " let data Pos = payload Data Field Def .POS | | 0 ; " + " \r \n " + " let data Type = payload Data Field Def .FMT | | 'uint 8 ' ; " + " \r \n " + " let data Len In Bytes = payload Data Field Def .LEN | | 1 ; " + " \r \n " + " \r \n " + " DLog .print Debug (this , ' payload Data Field Def = ' + data Pos + ' / ' + data Type + ' / ' + data Len In Bytes ) ; " + " \r \n " + " \r \n " + " switch (data Type ) { " + " \r \n " + " case 'uint 8 ' : " + " \r \n " + " return payload Data Byt Buf .get Uint 8 (data Pos , true ) ; / / LITTLE _ENDIAN " + " \r \n " + " case 'uint 1 6 ' : " + " \r \n " + " return payload Data Byt Buf .get Uint 1 6 (data Pos , true ) ; " + " \r \n " + " case 'uint 3 2 ' : " + " \r \n " + " return payload Data Byt Buf .get Uint 3 2 (data Pos , true ) ; " + " \r \n " + " case 'uint 6 4 ' : " + " \r \n " + " return null ; " + " \r \n " + " case 'string _ascii ' : " + " \r \n " + " return this .extract String Data (payload Data Byt Buf , data Pos , data Len In Bytes ) " + " \r \n " + " default : " + " \r \n " + " return null ; " + " \r \n " + " } " + " \r \n " + " } " + " \r \n " + " \r \n " + " extract String Data (payload Data Byt Buf , keyvalue Seek Pos , keyvalue Len ) { " + " \r \n " + " var keyvalue Str = ' ' ; " + " \r \n " + " if (keyvalue Len > BLE _CHARC _VALUE _MAX _LEN ) " + " \r \n " + " { " + " \r \n " + " keyvalue Len = BLE _CHARC _VALUE _MAX _LEN ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " var keyvalue Seek Pos = 0 ; " + " \r \n " + " for (var m = 0 ;m <keyvalue Len ;m + + ) " + " \r \n " + " { " + " \r \n " + " var keyvaluebyte = payload Data Byt Buf .get Uint 8 (keyvalue Seek Pos , true ) ; " + " \r \n " + " keyvalue Str = keyvalue Str + String .from Char Code (keyvaluebyte ) ; " + " \r \n " + " DLog .print Debug (this , 'keyvalue Str = ' + keyvalue Str ) ; " + " \r \n " + " keyvalue Seek Pos + + ; " + " \r \n " + " } " + " \r \n " + " DLog .print Debug (this , 'keyvalue Str = ' + keyvalue Str ) ; " + " \r \n " + " return keyvalue Str ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " byte Array 2DVByte Buffer (byte Array ) " + " \r \n " + " { " + " \r \n " + " var byte Array Len = byte Array .length ; " + " \r \n " + " \r \n " + " if (byte Array Len < 1 ) " + " \r \n " + " { " + " \r \n " + " DLog .print Debug (this , 'packet byte arr size is zero = ' + byte Array Len ) ; " + " \r \n " + " return null ; " + " \r \n " + " } " + " \r \n " + " \r \n " + " DLog .print Debug (this , 'packet byte arr size = ' + byte Array Len ) ; " + " \r \n " + " \r \n " + " var obj Uint 8Array = new Uint 8Array (new Array Buffer (byte Array Len ) ) ; " + " \r \n " + " obj Uint 8Array .set (byte Array ) ; " + " \r \n " + " \r \n " + " var dv Byte Buf = new Data View (obj Uint 8Array .buffer ) ; " + " \r \n " + " for (var m = 0 ;m <byte Array Len ;m + + ) " + " \r \n " + " { " + " \r \n " + " DLog .print Debug (this , 'DVByte Buf = ' + dv Byte Buf .get Uint 8 (m ) ) ; " + " \r \n " + " } " + " \r \n " + " return dv Byte Buf ; " + " \r \n " + " } " + " \r \n " + " } " + " \r \n " ; File Manager . Create File ( " . \ \protocols \ \Payload Parser .js " , output Src ) ; log ( "Payload Parser .js generated sucessfully " ) ; log ( " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; } 
function validate Files ( files , state Lint ) { let ok = true for ( const file of files ) { try { ok = validate ( file , state Lint ) & & ok } catch ( err ) { console . log ( ` $ { file } \n \t $ { err . message } ` ) ok = false } } 
function validate ( file , state Lint ) { const json = read And Parse ( file ) const problems = state Lint . validate ( json ) if ( problems . length ) { console . log ( ` $ { file } ` ) problems . for Each ( p = > console . log ( ` \t $ { p } ` ) ) } return ( problems . length = = = 0 ) } 
function show If Help ( args , description ) { const name = path . basename ( args [ 1 ] ) const opts = args . slice ( 2 ) if ( ! ( opts . length = = = 1 & & [ ' - -help ' , ' -h ' , ' - ? ' ] . includes ( opts [ 0 ] ) ) ) { return false } console . log ( ` $ { name } ` ) console . log ( ' ' ) console . log ( description ) return true } 
function get Range ( ) { if ( _ _ . null Value Separator = = "bottom " ) { return [ h ( ) + 1 - _ _ . null Value Separator Padding . bottom - _ _ . null Value Separator Padding . top , 1 ] ; } else if ( _ _ . null Value Separator = = "top " ) { return [ h ( ) + 1 , 1 + _ _ . null Value Separator Padding . bottom + _ _ . null Value Separator Padding . top ] ; } return [ h ( ) + 1 , 1 ] ; } 
function single _curve ( d , ctx ) { var centroids = compute _centroids ( d ) ; var cps = compute _control _points ( centroids ) ; ctx . move To ( cps [ 0 ] . e ( 1 ) , cps [ 0 ] . e ( 2 ) ) ; for ( var i = 1 ; i < cps . length ; i + = 3 ) { if ( _ _ . show Control Points ) { for ( var j = 0 ; j < 3 ; j + + ) { ctx . fill Rect ( cps [ i + j ] . e ( 1 ) , cps [ i + j ] . e ( 2 ) , 2 , 2 ) ; } } ctx . bezier Curve To ( cps [ i ] . e ( 1 ) , cps [ i ] . e ( 2 ) , cps [ i + 1 ] . e ( 1 ) , cps [ i + 1 ] . e ( 2 ) , cps [ i + 2 ] . e ( 1 ) , cps [ i + 2 ] . e ( 2 ) ) ; } } 
function color _path ( d , ctx ) { ctx . begin Path ( ) ; if ( ( _ _ . bundle Dimension ! = = null & & _ _ . bundling Strength > 0 ) | | _ _ . smoothness > 0 ) { single _curve ( d , ctx ) ; } else { single _path ( d , ctx ) ; } ctx . stroke ( ) ; } 
function paths ( data , ctx ) { ctx . clear Rect ( - 1 , - 1 , w ( ) + 2 , h ( ) + 2 ) ; ctx . begin Path ( ) ; data . for Each ( function ( d ) { if ( ( _ _ . bundle Dimension ! = = null & & _ _ . bundling Strength > 0 ) | | _ _ . smoothness > 0 ) { single _curve ( d , ctx ) ; } else { single _path ( d , ctx ) ; } } ) ; ctx . stroke ( ) ; } 
function brush Updated ( new Selection ) { _ _ . brushed = new Selection ; events . brush . call ( pc , _ _ . brushed ) ; pc . render Brushed ( ) ; } 
function selected ( ) { var actives = d 3 . keys ( _ _ . dimensions ) . filter ( is _brushed ) , extents = actives . map ( function ( p ) { return brushes [ p ] . extent ( ) ; } ) ; 
function consecutive ( first , second ) { var length = d 3 . keys ( _ _ . dimensions ) . length ; return d 3 . keys ( _ _ . dimensions ) . some ( function ( d , i ) { return ( d = = = first ) ? i + i < length & & _ _ . dimensions [ i + 1 ] = = = second : false ; } ) ; } 
function brush For ( axis ) { var brush = d 3 . svg . multibrush ( ) ; brush . y ( _ _ . dimensions [ axis ] . yscale ) . on ( "brushstart " , function ( ) { if ( d 3 . event . source Event ! = = null ) { events . brushstart . call ( pc , _ _ . brushed ) ; d 3 . event . source Event . stop Propagation ( ) ; } } ) . on ( "brush " , function ( ) { brush Updated ( selected ( ) ) ; } ) . on ( "brushend " , function ( ) { 
function ( angle ) { var ret = angle ; if ( angle > Math . PI ) { ret = angle - 1 . 5 * Math . PI ; ret = angle - 1 . 5 * Math . PI ; } else { ret = angle - 0 . 5 * Math . PI ; ret = angle - 0 . 5 * Math . PI ; } return - ret ; } 
function ( data ) { if ( data ) rq . data ( data ) ; rq . invalidate ( ) ; _clear ( ) ; rq . render ( ) ; } 
function convert Property ( original Key , original Value , is Rtl ) { const key = get Property Doppelganger ( original Key , is Rtl ) const value = get Value Doppelganger ( key , original Value , is Rtl ) return { key , value } } 
function get Property Doppelganger ( property , is Rtl ) { const converted Property = is Rtl ? properties To Convert . rtl [ property ] : properties To Convert . ltr [ property ] return converted Property | | property } 
function get Value Doppelganger ( key , original Value , is Rtl ) { if ( is Null Or Undefined ( original Value ) ) { return original Value } const flow Direction = is Rtl ? 'rtl ' : 'ltr ' if ( is Object ( original Value ) ) { return convert ( original Value , flow Direction ) 
function analyze Original Value ( original Value ) { const is Num = is Number ( original Value ) const logicalless Value = is Num ? original Value : original Value . replace ( / ^ \s *logical \s * / i , ' ' ) const is Logical = ! is Num & & logicalless Value . length ! = = original Value . length const importantless Value = is Num ? logicalless Value : logicalless Value . replace ( / \s * !important . * ? $ / , ' ' ) const is Important = ! is Num & & importantless Value . length ! = = logicalless Value . length return { is Logical , logicalless Value , is Important , importantless Value } } 
function Dir Watcher ( input Path , persistent ) { assert . ok ( this instanceof Dir Watcher ) ; var self = this ; var abs Path = path . resolve ( input Path ) ; if ( ! fs . stat Sync ( abs Path ) . is Directory ( ) ) { throw new Error ( input Path + "is not a directory ! " ) ; } Event Emitter . call ( self ) ; self . ready = false ; self . on ( "ready " , function ( ) { self . ready = true ; } ) ; Object . define Properties ( self , { 
function ( options ) { this . body = options . body ; this . data = options . data ; this . type = options . type ; } 
function init ( app , context , swagger ) { logger . log ( 'debug ' , ' %s |adding |routes |context = %s ' + ( swagger ? " |SWAGGER " : " " ) , meta . module , context , meta ) ; if ( swagger ) { describe Models ( swagger ) ; swagger . add GET ( { 'spec ' : { "description " : "Text To Speech REST API " , "path " : context + format + ' /play / {voice } / {text } ' , "notes " : "The REST API /play / transform a text phrase into a spoken audio stream playable through an HTML 5 <audio > element . You can pre -generate the audio by calling the REST API /generate / before calling this one , to have the audio start playing as soon as you call the /play / API . " , "method " : "GET " , "summary " : "Transform a text phrase into an Audio Stream . " , "nickname " : "play " , "response Class " : "Binary Audio Stream " , "produces " : [ "audio /mp 4 " , "application /json " ] , "params " : [ swagger . params . path ( "voice " , "A 'human ' voice to use , to speak the phrase " , "string " , { "values " : voices , "value Type " : "LIST " } , "Alex " ) , swagger . params . path ( "text " , "The text phrase to be spoken . " , "string " ) ] , "error Responses " : [ fix ( swagger . errors . not Found ( 'voice ' ) ) , fix ( swagger . errors . not Found ( 'text ' ) ) , fix ( swagger . errors . invalid ( 'voice ' ) ) ] } , 'action ' : function ( req , res ) { logger . log ( 'debug ' , ' %s |say |voice = %s |text = %s ' , meta . module , req . params . voice , req . params . text , meta ) ; if ( voices . index Of ( req . params . voice ) < 0 ) { swagger . stop With Error ( res , { code : 4 0 0 , reason : 'The voice ' + req . params . voice + ' is not supported ' } ) ; return ; } tts . play ( req . param ( 'text ' , 'No text passed ' ) , req . param ( 'voice ' , voice ) , function ( err , data ) { if ( err ) { if ( ! err . code | | ! err . reason ) err = { code : 5 0 0 , reason : util . inspect ( err ) } ; swagger . stop With Error ( res , err ) ; } else { res . write Head ( 2 0 0 , { 'Content -Type ' : 'audio /mp 4 ' } ) ; res . end ( data ) ; } } ) ; } } ) . add Post ( { 'spec ' : { "description " : "Text To Speech REST API " , "path " : context + format + ' /generate ' , "notes " : "To avoid latency , when using the REST API /play / , you can pre -generate the audio on the server by calling this API . " , "method " : "POST " , "summary " : "Generate the audio on the server . " , "nickname " : "generate " , "response Class " : "Status " , "params " : [ swagger . params . body ( "params " , "The text phrase to be pre -generated on the server " , 'Text To Speech ' , ' { "voice " : "Alex " , "text " : "Hello world " , "async " : true } ' ) ] , "error Responses " : [ fix ( swagger . errors . not Found ( 'voice ' ) ) , fix ( swagger . errors . not Found ( 'text ' ) ) , fix ( swagger . errors . invalid ( 'voice ' ) ) , fix ( swagger . errors . invalid ( 'async ' ) ) ] } , 'action ' : function ( req , res ) { if ( ! req . body ) { swagger . stop With Error ( res , { code : 4 0 0 , reason : 'The BODY of the request is empty ' } ) ; return ; } logger . log ( 'debug ' , ' %s |generate |voice = %s |text = %s |async = %s ' , meta . module , req . body . voice , req . body . text , req . body . async , meta ) ; if ( voices . index Of ( req . body . voice ) < 0 ) { swagger . stop With Error ( res , { code : 4 0 0 , reason : 'The voice ' + req . params . voice + ' is not supported ' } ) ; return ; } var async ; if ( typeof req . body . async ! = 'undefined ' ) { if ( req . body . async = = = true | | req . body . async = = = 'true ' ) { async = true ; } else if ( req . body . async = = = false | | req . body . async = = = 'false ' ) { async = false ; } else { swagger . stop With Error ( res , { code : 4 0 0 , reason : 'The async must be true or false ' } ) ; return ; } } else async = false ; tts . play ( req . param ( 'text ' , 'No text passed ' ) , req . param ( 'voice ' , voice ) , function ( err ) { if ( async = = = false ) { if ( err ) { if ( ! err . code | | ! err . reason ) err = { code : 5 0 0 , reason : util . inspect ( err ) } ; swagger . stop With Error ( res , err ) ; } else { res . write Head ( 2 0 0 , { 'Content -Type ' : 'application /json ' } ) ; res . end ( ' { "result " : "OK " , "async " :false } ' ) ; } } } ) ; if ( async ) { res . write Head ( 2 0 0 , { 'Content -Type ' : 'application /json ' } ) ; res . end ( ' { "result " : "OK " , "async " :true } ' ) ; } } } ) ; } else { router . add ( app , context + ' /tts .json /play ' , 'GET ' , function ( req , res ) { tts . play ( req . param ( 'text ' , 'No text passed ' ) , req . param ( 'voice ' , voice ) , function ( err , data ) { if ( err ) { res . write Head ( 4 0 4 , { "Content -Type " : "text /html " } ) ; res . end ( ' <html > <body > <pre >Unable to generate tts <br / > \n ' + err + ' < /pre > < /body > < /html > ' ) ; } else { res . write Head ( 2 0 0 , { 'Content -Type ' : 'audio /mp 4 ' } ) ; res . end ( data ) ; } } ) ; } ) ; router . add ( app , context + ' /tts .json /generate ' , 'POST ' , function ( req , res ) { var async = req . param ( 'async ' , 'true ' ) = = = 'true ' ? true : false ; tts . play ( req . param ( 'text ' , 'No text passed ' ) , req . param ( 'voice ' , voice ) , function ( err ) { if ( async = = = false ) { if ( err ) { res . write Head ( 4 0 4 , { 'Content -Type ' : 'application /json ' } ) ; res . end ( ' { "result " : "FAILED " , "async " :false , "error " : ' + JSON . stringify ( err ) + ' } ' ) ; } else { res . write Head ( 2 0 0 , { 'Content -Type ' : 'application /json ' } ) ; res . end ( ' { "result " : "OK " , "async " :false } ' ) ; } } } ) ; if ( async ) { res . write Head ( 2 0 0 , { 'Content -Type ' : 'application /json ' } ) ; res . end ( ' { "result " : "OK " , "async " :true } ' ) ; } } ) ; } tts . init ( ) ; } 
function Read File Cache ( source Dir , charset ) { assert . ok ( this instanceof Read File Cache ) ; assert . strict Equal ( typeof source Dir , "string " ) ; this . charset = charset ; Event Emitter . call ( this ) ; Object . define Properties ( this , { source Dir : { value : source Dir } , source Cache : { value : { } } } ) ; } 
function done ( err , resource ) { total Request Elapsed + = ( ( new Date ( ) . get Time ( ) ) - started ) ; + + total Requests ; stats . avg Fetch Time = parse Int ( total Request Elapsed / total Requests ) ; if ( err | | verbose ) util . log ( 'cache |execute |done |err = ' + err + ' |result = ' + ( resource ? 'found ' : 'null ' ) ) ; if ( err ) { + + stats . failed ; } if ( ! err & & default Cache TTL ) { 
function Cache ( size , ttl ) { default Cache Size = size | | default Cache Size ; default Cache TTL = ttl | | default Cache TTL ; if ( verbose ) util . log ( 'Cache |default Cache Size = ' + default Cache Size + ' |default Cache TTL = ' + default Cache TTL ) ; if ( default Cache Size > 1 0 0 0 0 ) { util . log ( 'Cache |WARNING |Weeding out a BIG ( ' + default Cache Size + ' ) cache when it is full can degrade the NODE server performance since it is not async ' ) ; } } 
function API ( api Url , requester ) { var _this = this ; _this . api Url = api Url ; * Creates a new user account * @param user {object } the user to be created . Requires username , email , password * @param auth User {object } the user authenticating this request . Requires token or username and password * @param notify {boolean } send notification email to user * @return {Promise <object > } the newly created user * / _this . create User = function ( user , auth User , notify ) { user . send _notify = notify ; return request ( 'admin /users ' , auth User , user ) . then ( stat . check Created Response ) ; } ; _this . edit User = function ( user , auth User ) { return request ( 'admin /users / ' + user . username , auth User , user , 'PATCH ' ) . then ( stat . check Standard Response ) ; } ; _this . delete User = function ( user , auth User ) { if ( user . username = = = auth User . username ) { return Promise . reject ( 'Users cannot delete themselves ! ' ) ; } return request ( 'admin /users / ' + user . username , auth User , null , 'DELETE ' ) . then ( stat . check No Content Response ) ; } ; _this . search Users = function ( query , limit , auth User ) { limit = limit | | 1 0 ; * Retrieves a user * @param user {object } the user to retrieve . Requires username * @param auth User {object } the user to authenticate as . If null the email field in the response will be empty . Requires token or username and password * @returns {Promise <object > } the found user object * / _this . get User = function ( user , auth User ) { return request ( 'users / ' + user . username , auth User ) . then ( stat . check Standard Response ) ; } ; _this . search Repos = function ( query , uid , limit ) { uid = uid | | 0 ; limit = limit | | 1 0 ; return request ( 'repos /search ?q = ' + query + ' &uid = ' + uid + ' &limit = ' + limit ) . then ( stat . check Ok Response ) ; } ; _this . create Repo = function ( repo , user ) { return request ( 'user /repos ' , user , { name : repo . name , description : repo . description , private : repo . private } , null ) . then ( stat . check Created Response ) ; } ; _this . get Repo = function ( repo , auth User ) { return request ( 'repos / ' + repo . full _name , auth User ) . then ( stat . check Standard Response ) ; } ; _this . list Repos = function ( user ) { return request ( 'user /repos ' , user ) . then ( stat . check Standard Response ) ; } ; _this . delete Repo = function ( repo , user ) { return request ( 'repos / ' + user . username + ' / ' + repo . name , user , null , 'DELETE ' ) . then ( stat . check No Content Response ) ; } ; _this . create Token = function ( token , user ) { return request ( 'users / ' + user . username + ' /tokens ' , user , { name : token . name } ) . then ( stat . check Created Response ) ; } ; _this . list Tokens = function ( user ) { return request ( 'users / ' + user . username + ' /tokens ' , user ) . then ( stat . check Standard Response ) ; } ; _this . create Public Key = function ( key , user ) { return request ( 'user /keys ' , user , { title : key . title , key : key . key } ) . then ( stat . check Created Response ) ; } ; _this . list Public Keys = function ( user ) { return request ( 'users / ' + user . username + ' /keys ' , user ) . then ( stat . check Standard Response ) ; } ; _this . get Public Key = function ( key , user ) { return request ( 'user /keys / ' + key . id , user ) . then ( stat . check Standard Response ) ; } ; _this . delete Public Key = function ( key , user ) { return request ( 'user /keys / ' + key . id , user , null , 'DELETE ' ) . then ( stat . check No Content Response ) ; } ; return _this ; } 
function sort Reading Frames ( a , b ) { var a Sort = a . length var b Sort = b . length if ( b Sort - a Sort = = = 0 ) { var a Start Codon = a . slice ( 0 , 3 ) . to Upper Case ( ) . replace ( 'T ' , 'U ' ) var b Start Codon = b . slice ( 0 , 3 ) . to Upper Case ( ) . replace ( 'T ' , 'U ' ) if ( a Start Codon = = = 'AUG ' ) { a Sort + + } if ( b Start Codon = = = 'AUG ' ) { b Sort + + } } return b Sort - a Sort } 
function ( options ) { options = ( options | | { } ) ; this . agent = options . agent ; this . defaults = options . defaults | | { } ; this . log = options . logger | | ( new Ax ( { level : "info " } ) ) ; this . _shared Cookie Jar = new Cookie Jar ( ) ; this . log Curl = options . log Curl | | false ; } 
function ( level , message ) { var debug = ( level = = "debug " | | level = = "error " ) ; if ( ! message ) { return message . to String ( ) ; } if ( typeof ( message ) = = "object " ) { if ( message instanceof Error & & debug ) { return message . stack ; } else { return inspect ( message ) ; } } else { return message . to String ( ) ; } } 
function ( options ) { this . log = options . logger ; this . cookie Jar = options . cookie Jar ; this . encoding = options . encoding ; this . log Curl = options . log Curl ; process Options ( this , options | | { } ) ; create Request ( this ) ; } 
function ( timeout ) { var request = this , milliseconds = 0 ; ; if ( ! timeout ) return this ; if ( typeof timeout = = = "number " ) { milliseconds = timeout ; } else { milliseconds = ( timeout . milliseconds | | 0 ) + ( 1 0 0 0 * ( ( timeout . seconds | | 0 ) + ( 6 0 * ( ( timeout . minutes | | 0 ) + ( 6 0 * ( timeout . hours | | 0 ) ) ) ) ) ) ; } this . _timeout = milliseconds ; return this ; } 
function ( request , options ) { request . log . debug ( "Processing request options . . " ) ; 
function ( request ) { var timeout ; request . log . debug ( "Creating request . . " ) ; request . log . debug ( request ) ; var req Params = { host : request . host , port : request . port , method : request . method , path : request . path + ( request . query ? ' ? ' + request . query : " " ) , headers : request . get Headers ( ) , 
function ( event ) { var emitter = request . emitter ; var text Status = STATUS _CODES [ response . status ] ? STATUS _CODES [ response . status ] . to Lower Case ( ) : null ; if ( emitter . listeners ( response . status ) . length > 0 | | emitter . listeners ( text Status ) . length > 0 ) { emitter . emit ( response . status , response ) ; emitter . emit ( text Status , response ) ; } else { if ( emitter . listeners ( event ) . length > 0 ) { emitter . emit ( event , response ) ; } else if ( ! response . is Redirect ) { emitter . emit ( "response " , response ) ; 
function ( req ) { var headers = req . get Headers ( ) ; var header String = " " ; for ( var key in headers ) { header String + = ' -H " ' + key + " : " + headers [ key ] + ' " ' ; } var body String = " " if ( req . content ) { body String + = " -d ' " + req . content . body + " ' " ; } var query = req . query ? ' ? ' + req . query : " " ; console . log ( "curl " + " -X " + req . method . to Upper Case ( ) + " " + req . scheme + " : / / " + req . host + " : " + req . port + req . path + query + " " + header String + body String ) ; } 
function ( raw , request , callback ) { var response = this ; this . _raw = raw ; 
function ( object , names ) { var keys = ( names & & names . length > 0 ) ? names : Object . keys ( $H ( object ) ) ; var hash = keys . reduce ( function ( hash , key ) { hash [ key ] = get Header ( object , key ) ; return hash ; } , { } ) ; 
function ( constructor ) { constructor . prototype . get Header = function ( name ) { return get Header ( this , name ) ; } ; constructor . prototype . get Headers = function ( ) { return get Headers ( this , arguments ) ; } ; } 
function ( constructor ) { constructor . prototype . _set Header = function ( key , value ) { return set Header ( this , key , value ) ; } ; constructor . prototype . _set Headers = function ( hash ) { return set Headers ( this , hash ) ; } ; } 
function ( constructor ) { constructor . prototype . set Header = function ( key , value ) { return set Header ( this , key , value ) ; } ; constructor . prototype . set Headers = function ( hash ) { return set Headers ( this , hash ) ; } ; } 
function ( constructor ) { constructor . prototype . get Header = function ( name ) { return get Header ( this , name ) ; } ; constructor . prototype . get Headers = function ( ) { return get Headers ( this , arguments ) ; } ; constructor . prototype . set Header = function ( key , value ) { return set Header ( this , key , value ) ; } ; constructor . prototype . set Headers = function ( hash ) { return set Headers ( this , hash ) ; } ; } 
function ( encoding ) { var enc = encoding | | "utf 8 " ; var codec Options = undefined ; while ( 1 ) { if ( get Type ( enc ) = = = "String " ) enc = enc . replace ( / [ - ] / g , " " ) . to Lower Case ( ) ; var codec = iconv . encodings [ enc ] ; var type = get Type ( codec ) ; if ( type = = = "String " ) { 
function ( options ) { 
function ( options ) { var table = options . table , key , rev Chars Table = options . rev Chars Table ; if ( ! table ) { throw new Error ( "Encoding ' " + options . type + " ' has incorect 'table ' option " ) ; } if ( ! rev Chars Table ) { rev Chars Table = options . rev Chars Table = { } ; for ( key in table ) { rev Chars Table [ table [ key ] ] = parse Int ( key ) ; } } return { to Encoding : function ( str ) { str = ensure String ( str ) ; var str Len = str . length ; var buf Len = str Len ; for ( var i = 0 ; i < str Len ; i + + ) if ( str . char Code At ( i ) > > 7 ) buf Len + + ; var new Buf = new Buffer ( buf Len ) , gbkcode , unicode , default Char = rev Chars Table [ iconv . default Char Unicode . char Code At ( 0 ) ] ; for ( var i = 0 , j = 0 ; i < str Len ; i + + ) { unicode = str . char Code At ( i ) ; if ( unicode > > 7 ) { gbkcode = rev Chars Table [ unicode ] | | default Char ; new Buf [ j + + ] = gbkcode > > 8 ; 
function copy File ( opts ) { var import Str , ext ; if ( ! opts ) return console . log ( 'incomplete options ' ) ; ext = opts . ext ; if ( typeof ext = = = 'string ' ) { ext = [ ext ] ; 
function encode User Auth ( user ) { if ( ! user ) { return null ; } var token = user . token ; if ( token ) { var sha 1 = typeof token = = = 'object ' ? token . sha 1 : token ; return 'token ' + sha 1 ; } return 'Basic ' + base 6 4 . encode ( user . username + ' : ' + user . password ) } 
function add Route ( app , route , method , destination ) { if ( method = = = 'GET ' ) { app . get ( route , destination ) ; } else if ( method = = = 'POST ' ) { app . post ( route , destination ) ; } else if ( method = = = 'PUT ' ) { app . put ( route , destination ) ; } else if ( method = = = 'DELETE ' ) { app . delete ( route , destination ) ; } else { throw new Error ( meta . module + ' |add Route |EXCEPTION |unknown method : " ' + method + ' " |expecter =GET ,POST ,PUT ,DELETE ' ) ; } logger . log ( 'debug ' , ' %s |add |method = %s |route = %s ' , meta . module , method , route , meta ) ; } 
function add ( app , route , method , destination ) { var methods ; if ( typeof ( method ) = = = 'string ' ) { methods = method . split ( ' , ' ) ; } else if ( typeof ( method ) = = = 'object ' ) { 
function ( project Name ) { var self = this ; this . project Name = project Name ; this . proj Dir = ' . / ' + project Name + ' / ' ; this . packages = this . proj Dir + ' .meteor /packages ' ; this . _run Terminal Command ( 'meteor create ' + project Name , function ( ) { 
function ( command , callback ) { var exec = require ( 'child _process ' ) . exec ; exec ( command , function ( err ) { if ( err ) puts ( 'exec error : ' + err ) ; callback . call ( this ) ; } ) ; } 
function ( ) { fs . copy Sync ( this . init Source , this . proj Dir ) ; fs . remove Sync ( this . proj Dir + 'client / .gitkeep ' ) ; fs . remove Sync ( this . proj Dir + 'server / .gitkeep ' ) ; puts ( ' Created : .jshintrc ' ) ; puts ( ' Created : .jshintignore ' ) ; puts ( ' Created : makefile ' ) ; } 
function ( ) { fs . remove Sync ( this . proj Dir + this . project Name + ' .js ' ) ; fs . remove Sync ( this . proj Dir + this . project Name + ' .html ' ) ; fs . remove Sync ( this . proj Dir + this . project Name + ' .css ' ) ; puts ( ' Removed : original boilerplate ' ) ; } 
function ( package Name ) { var old Packages , new Packages ; old Packages = fs . read File Sync ( this . packages , { encoding : 'utf - 8 ' } ) ; new Packages = old Packages . replace ( package Name + ' \n ' , ' ' ) ; fs . write File Sync ( this . packages , new Packages ) ; } 
function ( proj Path ) { 
function ( res Name , action ) { var route , new Content , old File Str , new File Str , res ; res Name = res Name | | ' ' ; res = require ( ' . /parse _name ' ) ( res Name ) 
function ( res Name , opts ) { 
function ( action ) { var template Str = fs . read File Sync ( this . contr Templates + action + ' .js ' , { encoding : 'utf - 8 ' } ) ; 
function ( ) { if ( fs . exists Sync ( this . controller Path + ' _app .js ' ) ) return ; fs . copy Sync ( this . contr Templates + ' _app .js ' , this . controller Path + ' _app .js ' ) ; console . log ( ' Created : ' + this . controller Path + ' _app .js ' ) ; } 
function Vec 4 ( ) { switch ( arguments . length ) { case 1 : 
function create ( EConstructor ) { Formatted Error . display Name = EConstructor . display Name | | EConstructor . name return Formatted Error function Formatted Error ( format ) { if ( format ) { format = formatter . apply ( null , arguments ) } return new EConstructor ( format ) } } 
function Mat 4 4 ( that ) { that = that | | [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] ; if ( that instanceof Array ) { this . data = that ; } else { this . data = new Array ( 1 6 ) ; this . data [ 0 ] = that . data [ 0 ] ; this . data [ 1 ] = that . data [ 1 ] ; this . data [ 2 ] = that . data [ 2 ] ; this . data [ 3 ] = that . data [ 3 ] ; this . data [ 4 ] = that . data [ 4 ] ; this . data [ 5 ] = that . data [ 5 ] ; this . data [ 6 ] = that . data [ 6 ] ; this . data [ 7 ] = that . data [ 7 ] ; this . data [ 8 ] = that . data [ 8 ] ; this . data [ 9 ] = that . data [ 9 ] ; this . data [ 1 0 ] = that . data [ 1 0 ] ; this . data [ 1 1 ] = that . data [ 1 1 ] ; this . data [ 1 2 ] = that . data [ 1 2 ] ; this . data [ 1 3 ] = that . data [ 1 3 ] ; this . data [ 1 4 ] = that . data [ 1 4 ] ; this . data [ 1 5 ] = that . data [ 1 5 ] ; } } 
function Discovery ( options ) { var self = this ; if ( options & & ! is . obj ( options ) ) debug ( 'Dicovery constructor bad options argument : ' + inspect ( options ) ) ; 
function plugin ( options , callback ) { options = options | | { } ; return function ( style ) { if ( options . resolve Url ! = = false ) { style . define ( 'url ' , stylus . resolver ( ) ) ; } style . use ( rider ( { implicit : options . implicit } ) ) ; style . on ( 'end ' , postprocessor ( options , callback ) ) ; if ( options . husl ) { 
function Vec 2 ( ) { switch ( arguments . length ) { case 1 : 
function Quaternion ( ) { switch ( arguments . length ) { case 1 : 
function wrap ( fn ) { return wrapped function wrapped ( node , parent ) { try { fn ( node , parent ) } catch ( error ) { if ( ! error [ ID ] ) { error [ ID ] = true error . message + = ' : ` ' + view ( node ) + ' ` ' if ( parent ) { error . message + = ' in ` ' + view ( parent ) + ' ` ' } } throw error } } } 
function unist ( node ) { var type var children var value var key var index var length assert . ok ( object ( node ) , 'node should be an object ' ) type = node . type children = node . children value = node . value assert . ok ( 'type ' in node , 'node should have a type ' ) assert . strict Equal ( typeof type , 'string ' , ' `type ` should be a string ' ) assert . not Strict Equal ( type , ' ' , ' `type ` should not be empty ' ) if ( value ! = null ) { assert . strict Equal ( typeof value , 'string ' , ' `value ` should be a string ' ) } location ( node . position ) for ( key in node ) { if ( defined . index Of ( key ) = = = - 1 ) { vanilla ( key , node [ key ] ) } } if ( children ! = null ) { assert . ok ( array ( children ) , ' `children ` should be an array ' ) index = - 1 length = children . length while ( + + index < length ) { exports ( children [ index ] , node ) } } } 
function vanilla ( key , value ) { try { assert . deep Strict Equal ( value , JSON . parse ( JSON . stringify ( value ) ) ) } catch ( error ) { assert . fail ( 'non -specced property ` ' + key + ' ` should be JSON ' ) } } 
function view ( value ) { try { if ( inspect ) { return inspect ( value , { colors : false } ) } else { return JSON . stringify ( value ) } } catch ( error ) { return String ( value ) } } 
function parent ( node ) { unist ( node ) assert . strict Equal ( 'value ' in node , false , 'parent should not have `value ` ' ) assert . ok ( 'children ' in node , 'parent should have `children ` ' ) } 
function text ( node ) { unist ( node ) assert . strict Equal ( 'children ' in node , false , 'text should not have `children ` ' ) assert . ok ( 'value ' in node , 'text should have `value ` ' ) } 
function empty ( node ) { unist ( node ) assert . strict Equal ( 'value ' in node , false , 'void should not have `value ` ' ) assert . strict Equal ( 'children ' in node , false , 'void should not have `children ` ' ) } 
function location ( location ) { if ( location ! = null ) { assert . ok ( object ( location ) , ' `position ` should be an object ' ) position ( location . start , 'position .start ' ) position ( location . end , 'position .end ' ) } } 
function position ( position , name ) { if ( position ! = null ) { assert . ok ( object ( position ) , ' ` ' + name + ' ` should be an object ' ) if ( position . line ! = null ) { assert . ok ( 'line ' in position , ' ` ' + name + ' ` should have numeric `line ` ' ) assert . ok ( position . line > = 1 , ' ` ' + name + ' .line ` should be gte ` 1 ` ' ) } if ( position . column ! = null ) { assert . ok ( 'column ' in position , ' ` ' + name + ' ` should have numeric `column ` ' ) assert . ok ( position . column > = 1 , ' ` ' + name + ' .column ` should be gte ` 1 ` ' ) } } } 
function Vec 3 ( ) { switch ( arguments . length ) { case 1 : 
function Snackbar ( data , options , callback ) { if ( data ! = = " " ) { this . options = this . activate Options ( options ) ; this . data = data ; this . callback = callback ; this . start ( ) ; this . snackbar ( ) ; } else { console . warn ( "Snackbar Light : You can not create a empty snackbar please give it a string . " ) ; } } 
function ( ) { if ( ! document . get Element By Id ( "snackbar -container " ) ) { var snackbar Container = document . create Element ( "div " ) ; snackbar Container . set Attribute ( "id " , "snackbar -container " ) ; document . body . append Child ( snackbar Container ) ; } } 
function ( callback , delay ) { var remaining = delay ; this . timer = { 
function ( ) { var _ _self = this , snackbar = document . create Element ( "div " ) ; 
function ( element ) { var _ _self = this ; 
function ( new Options ) { var _ _self = this , options = new Options | | { } ; for ( var opt in this . options ) { if ( _ _self . options . has Own Property ( opt ) & & ! options . has Own Property ( opt ) ) { options [ opt ] = _ _self . options [ opt ] ; } } return options ; } 
function ( Vue ) { var _ _self = this ; Vue . prototype . $snackbar = { } ; Vue . prototype . $snackbar . create = function ( data , options , callback ) { _ _self . create ( data , options , callback ) ; } ; } 
function priv Key To WIF ( priv Key ) { var to Compressed = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; var wif = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : zconfig . mainnet . wif ; if ( to Compressed ) priv Key = priv Key + ' 0 1 ' ; return bs 5 8check . encode ( Buffer . from ( wif + priv Key , 'hex ' ) ) ; } 
function priv Key To Pub Key ( priv Key ) { var to Compressed = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : false ; var pk Buffer = Buffer . from ( priv Key , 'hex ' ) ; var public Key = secp 2 5 6k 1 . public Key Create ( pk Buffer , to Compressed ) ; return public Key . to String ( 'hex ' ) ; } 
function WIFTo Priv Key ( wif Pk ) { var og = bs 5 8check . decode ( wif Pk , 'hex ' ) . to String ( 'hex ' ) ; og = og . substr ( 2 , og . length ) ; 
function mk Multi Sig Redeem Script ( pub Keys , M , N ) { 
function multi Sig RSTo Address ( redeem Script ) { var script Hash = arguments . length > 1 & & arguments [ 1 ] ! = = undefined ? arguments [ 1 ] : zconfig . mainnet . script Hash ; 
function Transform ( that ) { that = that | | { } ; if ( that . data instanceof Array ) { 
function vue Pack ( file , encoding , callback ) { if ( ! file ) { throw new Plugin Error ( 'gulp -vue -pack ' , 'file    ' ) ; } if ( file . is Stream ( ) ) { throw new Plugin Error ( 'gulp -vue -pack ' , '    .vue   ' ) ; } if ( ! file . contents ) { 
function convert To JSContent ( script , template , style , file Name , file Path ) { if ( ! script ) { return " " ; } 
function process Javascript ( file Name , script , processed Template , style , file Path ) { script = script . replace ( VUE _COMPONENT _IMPORT _REG , function ( matched Line , variable Name , vue Path , index , contents ) { return "var " + variable Name + " = global . _ _FORGE _ES 6 _VUE _COMPONENTS _ _ [ ' " + path . resolve ( file Path , vue Path ) . replace ( / \ \ / g , " / " ) + " ' ] " ; } ) ; script = script . replace ( SCRIPT _REPLACER _REG , "var " + file Name + " = Vue .extend ( " ) ; script + = " ) ; \n " ; script + = file Name + " .options .template = " + processed Template ; 
function Triangle ( ) { switch ( arguments . length ) { case 1 : 
function mk Pubkey Hash Replay Script ( address , block Height , block Hash ) { var pub Key Hash = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : zconfig . mainnet . pub Key Hash ; 
function mk Script Hash Replay Script ( address , block Height , block Hash ) { var addr Hex = bs 5 8check . decode ( address ) . to String ( 'hex ' ) ; var sub Addr Hex = addr Hex . substring ( 4 , addr Hex . length ) ; 
function address To Script ( address , block Height , block Hash ) { 
function serialize Tx ( tx Obj ) { var serialized Tx = ' ' ; var _buf 1 6 = Buffer . alloc ( 4 ) ; 
function create Raw Tx ( history , recipients , block Height , block Hash ) { var tx Obj = { locktime : 0 , version : 1 , ins : [ ] , outs : [ ] } ; tx Obj . ins = history . map ( function ( h ) { return { output : { hash : h . txid , vout : h . vout } , script : ' ' , prev Script Pub Key : h . script Pub Key , sequence : 'ffffffff ' } ; } ) ; tx Obj . outs = recipients . map ( function ( o ) { return { script : address To Script ( o . address , block Height , block Hash ) , satoshis : o . satoshis } ; } ) ; return tx Obj ; } 
function get Script Signature ( priv Key , signing Tx , hashcode ) { 
function sign Tx ( _tx Obj , i , priv Key ) { var compress Pub Key = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : false ; var hashcode = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : zconstants . SIGHASH _ALL ; 
function multi Sign ( _tx Obj , i , priv Key , redeem Script ) { var hashcode = arguments . length > 4 & & arguments [ 4 ] ! = = undefined ? arguments [ 4 ] : zconstants . SIGHASH _ALL ; 
function apply Multi Signatures ( _tx Obj , i , signatures , redeem Script ) { 
function bash ( str , pattern , options ) { if ( typeof str ! = = 'string ' ) { throw new Type Error ( 'expected a string ' ) ; } if ( typeof pattern ! = = 'string ' ) { throw new Type Error ( 'expected a string ' ) ; } if ( is Windows ( ) ) { throw new Error ( 'bash -match does not work on windows ' ) ; } try { var opts = create Options ( pattern , options ) ; var res = spawn . sync ( get Bash Path ( ) , cmd ( str , pattern , opts ) , opts ) ; var err = to String ( res . stderr ) ; if ( err ) { return handle Error ( err , opts ) ; } return ! ! to String ( res . stdout ) ; } catch ( err ) { return handle Error ( err , opts ) ; } } 
function cmd ( str , pattern , options ) { var valid = [ 'dotglob ' , 'extglob ' , 'failglob ' , 'globstar ' , 'nocaseglob ' , 'nullglob ' ] ; var args = [ ] ; for ( var key in options ) { if ( options . has Own Property ( key ) & & valid . index Of ( key ) ! = = - 1 ) { args . push ( ' -O ' , key ) ; } } args . push ( ' -c ' , 'IFS = $ " \n " ; if [ [ " ' + str + ' " = ' + pattern + ' ] ] ; then echo true ; fi ' ) ; return args ; } 
function create Options ( pattern , options ) { if ( options & & options . normalized = = = true ) return options ; var opts = extend ( { cwd : process . cwd ( ) } , options ) ; if ( opts . nocase = = = true ) opts . nocaseglob = true ; if ( opts . nonull = = = true ) opts . nullglob = true ; if ( opts . dot = = = true ) opts . dotglob = true ; if ( ! opts . has Own Property ( 'globstar ' ) & & pattern . index Of ( ' * * ' ) ! = = - 1 ) { opts . globstar = true ; } if ( ! opts . has Own Property ( 'extglob ' ) & & is Extglob ( pattern ) ) { opts . extglob = true ; } opts . normalized = true ; return opts ; } 
function get Bash Path ( ) { if ( bash Path ) return bash Path ; if ( fs . exists Sync ( ' /usr /local /bin /bash ' ) ) { bash Path = ' /usr /local /bin /bash ' ; } else if ( fs . exists Sync ( ' /bin /bash ' ) ) { bash Path = ' /bin /bash ' ; } else { bash Path = 'bash ' ; } return bash Path ; } 
function is Between ( p , left , right ) { if ( p > = left & & p < = right ) return true ; return false ; } 
function ( reporter , definition ) { this . reporter = reporter this . definition = definition this . reporter . before Render Listeners . add ( definition . name , this , Statistics . prototype . handle Before Render ) this . reporter . after Render Listeners . add ( definition . name , this , Statistics . prototype . handle After Render ) this . _define Entities ( ) } 
function z Secret Key To Transmission Key ( a _sk ) { var sk _enc = prf . PRF _addr _sk _enc ( Buffer . from ( a _sk , 'hex ' ) ) ; 
function change Event ( event ) { var src Pattern = new Reg Exp ( ' / . * ( ? = / ' + config . source + ' ) / ' ) ; log ( 'File ' + event . path . replace ( src Pattern , ' ' ) + ' ' + event . type ) ; } 
function Memory ( options ) { options = options | | { } ; var self = this ; self . flush = options . db . _db . _memory . flush | | false ; self . flush Interval = options . db . _db . _memory . flush Interval | | 1 0 0 0 0 ; self . flush File = options . file ; self . memory Table = [ ] ; console . log ( 'Data will be handled using \ 'Memory \ ' driver ' ) ; 
function Var Stream Writer ( callback , options ) { this . last Context = ' ' ; this . callback = callback ; / / Output stream callback this . options = options ; this . imbricated Array Entries = new Array ( ) ; this . scopes = new Array ( ) ; this . contexts = new Array ( ) ; this . previous Context = ' ' ; } 
function deductcost ( ) { var cost = [ ] ; if ( ! giving . have | | giving . have . length < 1 ) return ; 
function Data Handler ( options ) { options = options | | { } ; var data Handler = options . db . _db . _driver | | 'disk ' ; switch ( data Handler ) { 
function Var Stream Reader ( scope , prop , options ) { / / Keep a ref to the root scope this . root Scope = { root : scope , prop : prop } ; / / Save the options this . options = options ; / / Store current scopes for backward references this . previous Nodes = [ ] ; / / The parse state this . state = PARSE _NEWLINE ; / / The current values this . left Value = ' ' ; this . right Value = ' ' ; this . operator = ' ' ; this . escaped = ESC _NONE ; } 
function Var Stream ( root Object , root Property , options ) { var self = this ; / / Ensure new were used if ( ! ( this instanceof Var Stream ) ) { return new Var Stream ( root Object , root Property , options ) ; } / / Ensure we had root object and property if ( ! ( root Object instanceof Object ) ) { throw new Error ( 'No root object provided . ' ) ; } if ( 'string ' ! = = typeof root Property | | oot Property = ' ) throw new Error ( 'No root property name given . ' ) ; } / / Parent constructor Duplex Stream . call ( this ) ; this . _varstream Reader = new Var Stream Reader ( root Object , root Property , options ? options & Var Stream Reader . OPTIONS : 0 ) ; this . _varstream Writer = new Var Stream Writer ( function ( str ) { self . push ( new Buffer ( str , 'utf 8 ' ) ) ; } , options ? options & Var Stream Writer . OPTIONS : 0 ) ; / / Parse input this . _write = function _write ( chunk , encoding , done ) { this . _varstream Reader . read ( chunk . to String ( encoding ! = = 'buffer ' ? encoding : 'utf 8 ' ) ) ; done ( ) ; } ; / / Output data this . _read = function _read ( ) { this . _varstream Writer . write ( root Object [ root Property ] ) ; this . push ( null ) ; } ; } 
function ( sub _node ) { if ( sub _node ) { walk ( sub _node , depth + 1 ) ; } else if ( node . pages ) { node . pages . for Each ( function ( sub _node , name ) { walk ( sub _node , depth + 1 ) ; } ) ; } } 
function find ( list , version ) { for ( let v = 0 , v Length = list . length ; v < v Length ; v + = 1 ) { const candidate = list [ v ] if ( candidate . version = = = version ) { return candidate } } throw new Error ( ` $ { version } ` ) } 
function Duplexer ( options , writable Stream , readable Stream ) { const _this = this ; 
function ( provides ) { if ( _ . is Array ( provides ) ) { this . _arguments = this . _provides = ( ! this . _provides ) ? provides : this . _provides . concat ( provides ) ; } else { this . _provides = _ . extend ( { } , this . _provides , provides ) ; this . _arguments = _ . map ( this . deps , function ( key ) { return this . _provides [ key ] ; } , this ) ; } return this ; } 
function ( context , callback ) { if ( arguments . length = = = 1 ) { callback = context ; context = this . _context ; } if ( this . is Async ) { 
function each ( arr , callback ) { var wrapper = this ; if ( this . is Async ) { return async . each ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { arr . each ( function ( item ) { wrapper . call ( item ) ; } ) ; if ( callback ) { callback ( ) ; } } } 
function map ( arr , callback ) { var wrapper = this ; if ( this . is Async ) { async . map ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { callback ( null , arr . map ( function ( item ) { return wrapper . call ( item ) ; } ) ) ; } } 
function ( selected Dates , date Str , instance ) { that . set Property ( "date Value " , selected Dates , true ) ; that . fire On Change ( { selected Dates : selected Dates , date Str : date Str , instance : instance } ) ; } 
function ( selected Dates , date Str , instance ) { this . fire On Change ( { selected Dates : selected Dates , date Str : date Str , instance : instance } ) ; } 
function XOR 1 2 8 ( x , y , z , w ) { if ( ( x & & x < 1 ) | | ( y & & y < 1 ) | | ( z & & z < 1 ) | | ( w & & w < 1 ) ) { throw new Error ( 'Invalid Seed ' ) ; } this . x = x ? x : Math . random ( ) * 4 2 9 4 9 6 7 2 9 6 ; this . y = y ? y : Math . random ( ) * 4 2 9 4 9 6 7 2 9 6 ; this . z = z ? z : Math . random ( ) * 4 2 9 4 9 6 7 2 9 6 ; this . w = w ? w : Math . random ( ) * 4 2 9 4 9 6 7 2 9 6 ; } 
function init Options ( options ) { var default Options = { root : process . cwd ( ) , port : ' 3 3 3 3 ' , style : path . resolve ( _ _dirname , ' . . /public /screen .css ' ) , dtpl : path . resolve ( _ _dirname , ' . . /public /dir _template .html ' ) , ftpl : path . resolve ( _ _dirname , ' . . /public /file _template .html ' ) , view : 'details ' , silent : false } ; return merge ( default Options , options ) ; } 
function start Server ( options ) { options = init Options ( options ) ; var app = connect ( ) , root = options . root , TEST = process . env . TEST , is Silent = options . silent | | TEST ; if ( ! is Silent ) { app . use ( log ) ; } var sm Opts = { } ; var sm Opt Map = { ftpl : 'template ' , style : 'style ' } ; Object . keys ( sm Opt Map ) . for Each ( function ( key ) { if ( options [ key ] ! = = undefined ) sm Opts [ sm Opt Map [ key ] ] = options [ key ] ; } ) ; 
function show Success Info ( options ) { 
function log ( req , res , next ) { console . log ( ' [ ' + chalk . grey ( ts ( ) ) + ' ] ' + chalk . white ( decode URI ( req . url ) ) ) ; next ( ) ; } 
function ( value To Set , type , iface , property Keys ) { type = type . to Lower Case ( ) ; property Keys . for Each ( function ( property Key ) { if ( type = = 'get ' ) value To Set [ 'Get ' + property Key ] = function ( callback ) { iface . get Property ( property Key , callback ) ; } else value To Set [ 'Set ' + property Key ] = function ( value , callback ) { iface . set Property ( property Key , value , callback ) ; } } ) ; } 
function md 5 ( data ) { var md 5sum = crypto . create Hash ( 'md 5 ' ) ; md 5sum . update ( data ) ; return md 5sum . digest ( 'hex ' ) ; } 
function init ( user _id , secret , storage ) { API _USER _ID = user _id ; API _SECRET = secret ; TOKEN _STORAGE = storage ; var hash Name = md 5 ( API _USER _ID + ' : : ' + API _SECRET ) ; if ( fs . exists Sync ( TOKEN _STORAGE + hash Name ) ) { TOKEN = fs . read File Sync ( TOKEN _STORAGE + hash Name , { encoding : 'utf 8 ' } ) ; } if ( ! TOKEN . length ) { get Token ( ) ; } } 
function send Request ( path , method , data , use Token , callback ) { var headers = { } headers [ 'Content -Type ' ] = 'application /json ' ; headers [ 'Content -Length ' ] = Buffer . byte Length ( JSON . stringify ( data ) ) ; if ( use Token & & TOKEN . length ) { headers [ 'Authorization ' ] = 'Bearer ' + TOKEN ; } if ( method = = = undefined ) { method = 'POST ' ; } if ( use Token = = = undefined ) { use Token = false ; } var options = { 
function get Token ( ) { var data = { grant _type : 'client _credentials ' , client _id : API _USER _ID , client _secret : API _SECRET } send Request ( 'oauth /access _token ' , 'POST ' , data , false , save Token ) ; function save Token ( data ) { TOKEN = data . access _token ; var hash Name = md 5 ( API _USER _ID + ' : : ' + API _SECRET ) ; fs . write File Sync ( TOKEN _STORAGE + hash Name , TOKEN ) ; } } 
function return Error ( message ) { var data = { is _error : 1 } ; if ( message ! = = undefined & & message . length ) { data [ 'message ' ] = message } return data ; } 
function create Address Book ( callback , book Name ) { if ( ( book Name = = = undefined ) | | ( ! book Name . length ) ) { return callback ( return Error ( "Empty book name " ) ) ; } var data = { book Name : book Name } ; send Request ( 'addressbooks ' , 'POST ' , data , true , callback ) ; } 
function edit Address Book ( callback , id , book Name ) { if ( ( id = = = undefined ) | | ( book Name = = = undefined ) | | ( ! book Name . length ) ) { return callback ( return Error ( "Empty book name or book id " ) ) ; } var data = { name : book Name } ; send Request ( 'addressbooks / ' + id , 'PUT ' , data , true , callback ) ; } 
function remove Address Book ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'addressbooks / ' + id , 'DELETE ' , { } , true , callback ) ; } 
function get Book Info ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'addressbooks / ' + id , 'GET ' , { } , true , callback ) ; } 
function get Emails From Book ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'addressbooks / ' + id + ' /emails ' , 'GET ' , { } , true , callback ) ; } 
function add Emails ( callback , id , emails ) { if ( ( id = = = undefined ) | | ( emails = = = undefined ) | | ( ! emails . length ) ) { return callback ( return Error ( "Empty email or book id " ) ) ; } var data = { emails : serialize ( emails ) } ; send Request ( 'addressbooks / ' + id + ' /emails ' , 'POST ' , data , true , callback ) ; } 
function get Email Info ( callback , id , email ) { if ( ( id = = = undefined ) | | ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( "Empty email or book id " ) ) ; } send Request ( 'addressbooks / ' + id + ' /emails / ' + email , 'GET ' , { } , true , callback ) ; } 
function campaign Cost ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'addressbooks / ' + id + ' /cost ' , 'GET ' , { } , true , callback ) ; } 
function list Campaigns ( callback , limit , offset ) { var data = { } if ( limit = = = undefined ) { limit = null ; } else { data [ 'limit ' ] = limit ; } if ( offset = = = undefined ) { offset = null ; } else { data [ 'offset ' ] = offset ; } send Request ( 'campaigns ' , 'GET ' , data , true , callback ) ; } 
function get Campaign Info ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'campaigns / ' + id , 'GET ' , { } , true , callback ) ; } 
function campaign Stat By Countries ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'campaigns / ' + id + ' /countries ' , 'GET ' , { } , true , callback ) ; } 
function campaign Stat By Referrals ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty book id ' ) ) ; } send Request ( 'campaigns / ' + id + ' /referrals ' , 'GET ' , { } , true , callback ) ; } 
function create Campaign ( callback , sender Name , sender Email , subject , body , book Id , name , attachments ) { if ( ( sender Name = = = undefined ) | | ( ! sender Name . length ) | | ( sender Email = = = undefined ) | | ( ! sender Email . length ) | | ( subject = = = undefined ) | | ( ! subject . length ) | | ( body = = = undefined ) | | ( ! body . length ) | | ( book Id = = = undefined ) ) { return callback ( return Error ( 'Not all data . ' ) ) ; } if ( name = = = undefined ) { name = ' ' ; } if ( attachments = = = undefined ) { attachments = ' ' ; } if ( attachments . length ) { attachments = serialize ( attachments ) ; } var data = { sender _name : sender Name , sender _email : sender Email , 
function cancel Campaign ( callback , id ) { if ( id = = = undefined ) { return callback ( return Error ( 'Empty campaign id ' ) ) ; } send Request ( 'campaigns / ' + id , 'DELETE ' , { } , true , callback ) ; } 
function add Sender ( callback , sender Name , sender Email ) { if ( ( sender Email = = = undefined ) | | ( ! sender Email . length ) | | ( sender Name = = = undefined ) | | ( ! sender Name . length ) ) { return callback ( return Error ( 'Empty sender name or email ' ) ) ; } var data = { email : sender Email , name : sender Name } send Request ( 'senders ' , 'POST ' , data , true , callback ) ; } 
function remove Sender ( callback , sender Email ) { if ( ( sender Email = = = undefined ) | | ( ! sender Email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } var data = { email : sender Email } send Request ( 'senders ' , 'DELETE ' , data , true , callback ) ; } 
function activate Sender ( callback , sender Email , code ) { if ( ( sender Email = = = undefined ) | | ( ! sender Email . length ) | | ( code = = = undefined ) | | ( ! code . length ) ) { return callback ( return Error ( 'Empty email or activation code ' ) ) ; } var data = { code : code } send Request ( 'senders / ' + sender Email + ' /code ' , 'POST ' , data , true , callback ) ; } 
function get Sender Activation Mail ( callback , sender Email ) { if ( ( sender Email = = = undefined ) | | ( ! sender Email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } send Request ( 'senders / ' + sender Email + ' /code ' , 'GET ' , { } , true , callback ) ; } 
function get Email Global Info ( callback , email ) { if ( ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } send Request ( 'emails / ' + email , 'GET ' , { } , true , callback ) ; } 
function remove Email From All Books ( callback , email ) { if ( ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } send Request ( 'emails / ' + email , 'DELETE ' , { } , true , callback ) ; } 
function email Stat By Campaigns ( callback , email ) { if ( ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } send Request ( 'emails / ' + email + ' /campaigns ' , 'GET ' , { } , true , callback ) ; } 
function add To Black List ( callback , emails , comment ) { if ( ( emails = = = undefined ) | | ( ! emails . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } if ( comment = = = undefined ) { comment = ' ' ; } var data = { emails : base 6 4 ( emails ) , comment : comment } send Request ( 'blacklist ' , 'POST ' , data , true , callback ) ; } 
function remove From Black List ( callback , emails ) { if ( ( emails = = = undefined ) | | ( ! emails . length ) ) { return callback ( return Error ( 'Empty emails ' ) ) ; } var data = { emails : base 6 4 ( emails ) , } send Request ( 'blacklist ' , 'DELETE ' , data , true , callback ) ; } 
function get Balance ( callback , currency ) { if ( currency = = = undefined ) { var url = 'balance ' ; } else { var url = 'balance / ' + currency . to Upper Case ( ) ; } send Request ( url , 'GET ' , { } , true , callback ) ; } 
function smtp List Emails ( callback , limit , offset , from Date , to Date , sender , recipient ) { if ( limit = = = undefined ) { limit = 0 ; } if ( offset = = = undefined ) { offset = 0 ; } if ( from Date = = = undefined ) { from Date = ' ' ; } if ( to Date = = = undefined ) { to Date = ' ' ; } if ( sender = = = undefined ) { sender = ' ' ; } if ( recipient = = = undefined ) { recipient = ' ' ; } var data = { limit : limit , offset : offset , from : from Date , to : to Date , sender : sender , recipient : recipient } send Request ( 'smtp /emails ' , 'GET ' , data , true , callback ) ; } 
function smtp Get Email Info By Id ( callback , id ) { if ( ( id = = = undefined ) | | ( ! id . length ) ) { return callback ( return Error ( 'Empty id ' ) ) ; } send Request ( 'smtp /emails / ' + id , 'GET ' , { } , true , callback ) ; } 
function smtp Unsubscribe Emails ( callback , emails ) { if ( emails = = = undefined ) { return callback ( return Error ( 'Empty emails ' ) ) ; } var data = { emails : serialize ( emails ) } send Request ( 'smtp /unsubscribe ' , 'POST ' , data , true , callback ) ; } 
function smtp Add Domain ( callback , email ) { if ( ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } var data = { email : email } send Request ( 'smtp /domains ' , 'POST ' , data , true , callback ) ; } 
function smtp Verify Domain ( callback , email ) { if ( ( email = = = undefined ) | | ( ! email . length ) ) { return callback ( return Error ( 'Empty email ' ) ) ; } send Request ( 'smtp /domains / ' + email , 'GET ' , { } , true , callback ) ; } 
function smtp Send Mail ( callback , email ) { if ( email = = = undefined ) { return callback ( return Error ( 'Empty email data ' ) ) ; } email [ 'html ' ] = base 6 4 ( email [ 'html ' ] ) ; var data = { email : serialize ( email ) } ; send Request ( 'smtp /emails ' , 'POST ' , data , true , callback ) ; } 
function get Opt ( res Html , output Path ) { if ( command Line . minifyall ) { console . log ( ' ' ) ; console . log ( 'minify all . Process may take a few minutes with large file . ' ) ; console . log ( ' ' ) ; minify File ( res Html , output Path ) ; } else { console . log ( ' ' ) ; console . log ( 'Output file name : ' + output Path ) ; console . log ( ' ' ) ; write File ( res Html , output Path ) ; } } 
function minify File ( res Html , output Path ) { var res Html = minify ( res Html , opt , function ( err ) { if ( err ) { console . error ( 'error will processing file . ' ) ; } } ) ; console . log ( ' ' ) ; console . log ( 'Output file name : ' + output Path ) ; console . log ( ' ' ) ; write File ( res Html , output Path ) ; } 
function write File ( res Html , output Path ) { fs . write File ( output Path , res Html , function ( err ) { if ( err ) { console . log ( ' ' ) ; console . log ( 'File error : ' + err + ' . Exit . ' ) ; } else { console . log ( ' ' ) ; console . log ( 'All done . Exit . ' . green ) ; } } ) ; } 
function ( params ) { 
function Adapter Registry Exception ( message , context ) { this . message = message ; this . name = "Adapter Registry Exception " ; this . context = context ; this . stack = ( new Error ( ) ) . stack ; } 
function Cookie ( options ) { this . options = options | | { } ; this . options . expires = typeof this . options . expires = = = 'number ' ? this . options . expires : 3 0 ; this . options . path = this . options . path ! = = undefined ? this . options . path : ' / ' ; this . options . secure = typeof this . options . secure = = = 'boolean ' ? this . options . secure : false ; } 
function set ( key , value , options ) { options = options | | this . options ; var days = parse Int ( options . expires | | - 1 ) ; if ( value ! = = undefined & & typeof value ! = = 'function ' ) { var t = new Date ( ) ; t . set Date ( ( t . get Date ( ) + days ) ) ; var res = ( document . cookie = [ this . encode ( key ) , ' = ' , this . stringify ( value ) , 
function get ( key , value ) { var i , parts , name , cookie ; var result = key ? undefined : { } ; var cookies = ( document . cookie | | ' ' ) . split ( ' ; ' ) ; for ( i = 0 ; i < cookies . length ; i + + ) { parts = cookies [ i ] . split ( ' = ' ) ; name = this . decode ( parts . shift ( ) ) ; cookie = parts . join ( ' = ' ) ; if ( key & & key = = = name ) { 
function del ( key , options ) { if ( ! options ) { options = { } ; for ( var z in this . options ) { options [ z ] = this . options [ z ] ; } } options . expires = - 1 ; this . set ( key , ' ' , options ) ; } 
function clear ( except , options ) { var keys = this . get ( ) , z ; except = except | | [ ] ; for ( z in keys ) { if ( ~ except . index Of ( z ) ) { continue ; } this . del ( z , options ) ; } } 
function curry 2 ( fn , self ) { var out = function ( ) { if ( arguments . length = = = 0 ) return out return arguments . length > 1 ? fn . apply ( self , arguments ) : bind . call ( fn , self , arguments [ 0 ] ) } out . uncurry = function uncurry ( ) { return fn } return out } 
function create Touch List ( target , list ) { if ( Array . is Array ( list ) & & list [ 0 ] & & ! Array . is Array ( list [ 0 ] ) ) { list = [ list ] ; } list = list . map ( function ( entry , index ) { var x = entry [ 0 ] ; var y = entry [ 1 ] ; var id = entry [ 2 ] | | index ; return create Touch ( x , y , target , id ) ; } ) ; return document . create Touch List . apply ( document , list ) ; } 
function init Touch Event ( touch Event , type , touches ) { var touch 1 = touches [ 0 ] ; return touch Event . init Touch Event ( 
function ( ) { if ( _ . is Object ( this . cache ) ) { return this . cache ; } if ( _ . has ( this . app . caches , this . cache ) ) { return this . app . caches [ this . cache ] ; } throw new errors . No Such Cache Error ( f ( 'You should define app .caches [ %j ] interface ' , this . cache ) ) ; } 
function create Icon Button ( viewer Elm , css , event Type ) { const button Elm = $ . create ( 'div ' , { 'class ' : css } ) $ . listen ( button Elm , { 'click ' : ( event ) = > { event . prevent Default ( ) if ( event . buttons = = = 0 ) { $ . dispatch ( viewer Elm , event Type ) } } } ) return button Elm } 
function Context ( params , logger ) { this . params = params ; this . result = new Obus ( ) ; this . errors = new Obus ( ) ; this . logger = logger ; } 
function Context Stack ( dict , tpl ) { this [ cache _stack ] = [ ] ; this . tpl = tpl ; this . push ( util . global ) ; if ( tpl . fallback ! = = U ) { this . has Fallback = true ; this . fallback = tpl . fallback ; } switch ( util . ntype ( dict ) ) { case 'object ' : this . push ( dict ) ; break ; case 'array ' : dict [ fn _var . dict ] ? dict . map ( this . push , this ) : this . push ( dict ) ; break ; default : ! util . exists ( dict ) | | this . push ( dict ) ; } } 
function aggregatet Non Empty ( res , str ) { util . empty ( str ) | | res . push ( str ) ; return res ; } 
function Track ( app , logger ) { this . id = this . _create Id ( ) ; this . logger = logger ; this . params = { } ; this . _app = app ; this . calls = { } ; this . _is Flushed = false ; } 
function clone Gallery Item ( inst , element ) { 
function Fist Error ( code , msg ) { var err = new Error ( f ( ' ( %s ) %s ' , code , msg ) ) ; err . name = this . name ; Error . capture Stack Trace ( err , this . constructor ) ; this . code = code ; this . message = err . message ; this . stack = err . stack ; } 
function Connect ( app , logger , req , res ) { this . req = req ; this . res = res ; * @public * @member Of {Connect } * @property * @type {String } * * / this . route = null ; this . matches = [ ] ; this . route Index = - 1 ; this . _url = null ; } 
function ( local File Path ) { let content Type = mime . lookup ( local File Path ) ; let stander File Path = local File Path . replace ( / \ \ / g , ' / ' ) ; fs . read File ( local File Path , function ( read File Err , file Data ) { if ( read File Err ) { throw read File Err ; } const put Config = { Bucket : bucket . Name , Body : file Data , Key : stander File Path , Content Type : content Type , Access Control Allow Origin : options . Access Control Allow Origin | | ' * ' , Cache Control : options . Cache Control | | 'no -cache ' , Expires : options . Expires | | null } ; if ( options . content Encoding ) { put Config . Content Encoding = options . content Encoding ; } oss . put Object ( put Config , function ( put Object Err ) { if ( put Object Err ) { console . error ( 'error : ' , put Object Err ) ; return put Object Err ; } console . log ( 'upload success : ' + local File Path ) ; if ( bucket Paths . index Of ( stander File Path ) = = = - 1 ) { bucket Paths . push ( stander File Path ) ; } if ( local Paths . index Of ( stander File Path ) = = = - 1 ) { local Paths . push ( stander File Path ) ; } 
function ( file Path ) { let stander Path = file Path . replace ( / \ \ / g , ' / ' ) ; oss . delete Object ( { Bucket : bucket . Name , Key : stander Path } , function ( err ) { if ( err ) { console . log ( 'error : ' , err ) ; return err ; } let bucket Index = bucket Paths . index Of ( stander Path ) ; if ( bucket Index ! = = - 1 ) { bucket Paths . splice ( bucket Index , 1 ) ; } let local Index = local Paths . index Of ( stander Path ) ; if ( local Index ! = = - 1 ) { local Paths . splice ( local Index , 1 ) ; } console . log ( 'delete success : ' + stander Path ) ; } ) ; } 
function Runtime ( unit , track , parent , args , done ) { * Runtime identity is a part of cache Key and memorization key * * @public * @member Of {Runtime } * @property * @type {String } * * / this . identity = unit . identify ( track , context ) ; this . unit = unit ; this . track = track ; this . parent = parent ; this . done = done ; this . paths Left = 0 ; this . keys = [ ] ; this . creation Date = 0 ; this . value = undefined ; this . status Bits = 0 ; this . context = context ; this . listeners = [ ] ; this . cache Key = unit . app . params . name ; } 
function setup Dispatch ( { actions : action Handlers = { } , schemas = { } , services = { } , middlewares = [ ] , ident Options = { } } ) { const get Service = setup Get Service ( schemas , services ) let dispatch = async ( action ) = > { debug ( 'Dispatch : %o ' , action ) return handle Action ( action , { schemas , services , dispatch , ident Options , get Service } , action Handlers ) } if ( middlewares . length > 0 ) { dispatch = compose ( . . . middlewares ) ( dispatch ) } return dispatch } 
function next Schedule ( schedule , allow Now = false ) { if ( schedule ) { try { const dates = later . schedule ( schedule ) . next ( 2 ) return next Date ( dates , allow Now ) } catch ( error ) { throw Type Error ( 'Invalid schedule definition ' ) } } return null } 
async function delete Fn ( action , { get Service } = { } ) { debug ( 'Action : DELETE ' ) const { type , id , service : service Id , endpoint } = action . payload const service = ( typeof get Service = = = 'function ' ) ? get Service ( type , service Id ) : null if ( ! service ) { return create Unknown Service Error ( type , service Id , 'DELETE ' ) } const data = prepare Data ( action . payload ) if ( data . length = = = 0 ) { return create Error ( ` $ { service . id } ` , 'noaction ' ) } const endpoint Debug = ( endpoint ) ? ` $ { endpoint } ` : ` $ { type } $ { id } ` debug ( 'DELETE : Delete from service \ ' %s \ ' at %s . ' , service . id , endpoint Debug ) const { response } = await service . send ( append To Action ( action , { data } ) ) return ( response . status = = = 'ok ' ) ? { status : 'ok ' } : response } 
async function request ( action , { get Service , dispatch } ) { debug ( 'Action : REQUEST ' ) const { type , service : service Id = null , endpoint } = action . payload const service = get Service ( type , service Id ) if ( ! service ) { return create Unknown Service Error ( type , service Id , 'GET ' ) } const endpoint Debug = ( endpoint ) ? ` $ { endpoint } ` : ` $ { type } ` debug ( 'REQUEST : Fetch from service %s at %s ' , service . id , endpoint Debug ) const { response } = await service . receive ( action , dispatch ) return response } 
async function get Ident ( { payload , meta } , { get Service , ident Options = { } } ) { if ( ! meta . ident ) { return create Error ( 'GET _IDENT : The request has no ident ' , 'noaction ' ) } const { type } = ident Options if ( ! type ) { return create Error ( 'GET _IDENT : Integreat is not set up with authentication ' , 'noaction ' ) } const service = get Service ( type ) if ( ! service ) { return create Unknown Service Error ( type , null , 'GET _IDENT ' ) } const prop Keys = prepare Prop Keys ( ident Options . props ) const params = prepare Params ( meta . ident , prop Keys ) if ( ! params ) { return create Error ( 'GET _IDENT : The request has no ident with id or with Token ' , 'noaction ' ) } const { response } = await service . send ( { type : 'GET ' , payload : { type , . . . params } , meta : { ident : { root : true } } } ) return prepare Response ( response , payload , prop Keys ) } 
function integreat ( { schemas : type Defs , services : service Defs , mappings = [ ] , auths : auth Defs = [ ] , ident : ident Options = { } } , { adapters = { } , authenticators = { } , filters = { } , transformers = { } , actions = { } } = { } , middlewares = [ ] ) { if ( ! service Defs | | ! type Defs ) { throw new Type Error ( 'Call integreat with at least services and schemas ' ) } * Function for dispatching actions to Integreat . Will be run through the * chain of middlewares before the relevant action handler is called . * @param {Object } action - The action to dispatch * @returns {Promise } Promise of result object * / dispatch : setup Dispatch ( { actions , services , schemas , middlewares , ident Options } ) , on ( event Name , service Id , listener ) { const service = services [ service Id ] if ( service & & service . on ) { service . on ( event Name , listener ) } } , type From Plural ( plural ) { return plural Types [ plural ] } } } 
function schedule To Action ( def ) { if ( ! def ) { return null } const id = def . id | | null const schedule = parse Schedule ( def . schedule ) const next Time = next Schedule ( schedule , true ) return { . . . def . action , meta : { id , schedule , queue : ( next Time ) ? next Time . get Time ( ) : true } } } 
function authorize Item ( item , access , { schemas , action , require Auth } ) { const { ident , status } = access if ( status = = = 'refused ' ) { return false } if ( ! item | | ( ident & & ident . root ) ) { return true } const schema = schemas [ item . type ] const scheme = get Scheme ( schema , action ) return authorize With Scheme ( item , scheme , ident , require Auth ) } 
async function get ( action , { get Service } = { } ) { const { type , service : service Id = null , only Mapped Values = false , endpoint } = action . payload const service = ( typeof get Service = = = 'function ' ) ? get Service ( type , service Id ) : null if ( ! service ) { return create Unknown Service Error ( type , service Id , 'GET ' ) } const id = get Id From Payload ( action . payload ) 
function send Request ( { adapter , service Id } ) { return async ( { request , response , connection } ) = > { if ( response ) { return response } try { response = await adapter . send ( request , connection ) return { . . . response , access : request . access } } catch ( error ) { return create Error ( ` $ { service Id } $ { error } ` ) } } } 
function schema ( { id , plural , service , attributes : attr Defs , relationships : rel Defs , access , internal = false } ) { const attributes = { . . . expand Fields ( attr Defs | | { } ) , id : { type : 'string ' } , type : { type : 'string ' } , created At : { type : 'date ' } , updated At : { type : 'date ' } } const relationships = expand Fields ( rel Defs | | { } ) const default Attrs = prepare Default Attrs ( attributes , attr Defs ) const default Rels = prepare Default Rels ( relationships , rel Defs ) const cast Fn = cast ( { id , attributes , relationships , default Attrs , default Rels } ) return { id , plural : plural | | ` $ { id } ` , service , internal , attributes , relationships , access , cast ( data , { only Mapped Values = false } = { } ) { return map Any ( ( data ) = > cast Fn ( data , { only Mapped Values } ) , data ) } , cast Query Params ( rel Id , data ) { return cast Query Params ( rel Id , data , { relationships } ) } } } 
function mapping ( { filters , transformers , schemas = { } , mappings : mappings Arr = [ ] } = { } ) { const mappings = mappings Arr . reduce ( ( mappings , def ) = > ( { . . . mappings , [ def . id ] : def } ) , { } ) const create Pipeline Fn = create Pipeline ( filters , transformers , schemas , mappings ) return ( mapping , override Type ) = > { const { id , type , schema , pipeline } = create Pipeline Fn ( mapping , override Type ) if ( ! pipeline ) { return null } const mapper = map Transform ( [ fwd ( 'data ' ) , . . . pipeline , rev ( set ( 'data ' ) ) ] ) return { id , type , schema , from Service ( data , { only Mapped Values = true } = { } ) { return data ? ensure Array ( ( only Mapped Values ) ? mapper . only Mapped Values ( data ) : mapper ( data ) ) : [ ] } , to Service ( data , target = null ) { const mapped = mapper . rev . only Mapped Values ( data ) return ( ( target ? Array . is Array ( target ) ? [ . . . target ] . concat ( mapped ) : merge Deep With ( concat Or Right , target , mapped ) : mapped ) | | null ) } } } } 
function map From Service ( ) { return ( { response , request , response Mapper , mappings } ) = > { if ( response . status ! = = 'ok ' ) { return response } const type = request . params . type | | Object . keys ( mappings ) const { only Mapped Values , unmapped = false } = request . params if ( unmapped ) { return response } const { data , status = response . status , error , paging , params } = map With Endpoint ( response Mapper , response , request . action ) if ( status ! = = 'ok ' ) { return remove Data Prop ( { . . . response , status , error } ) } const map Type = ( type ) = > ( mappings [ type ] ) ? mappings [ type ] . from Service ( { . . . request , data } , { only Mapped Values } ) : [ ] return { . . . response , status , . . . ( ( paging ) ? { paging } : { } ) , . . . ( ( params ) ? { params } : { } ) , data : ( data ) ? flatten ( map Any ( map Type , type ) ) : undefined } } } 
function ( tail Info ) { var z = this ; if ( tail Info ) { z . q . push ( tail Info ) ; } var ti ; 
function ( ) { var z = this ; var l = 0 ; Object . keys ( z . tails ) . for Each ( function ( k ) { l + = ( z . tails [ k ] . buf | | ' ' ) . length ; } ) ; return l ; } 
function prepare Pipeline ( pipeline , collection = { } ) { pipeline = [ ] . concat ( pipeline ) const replace With Function = ( key ) = > ( typeof key = = = 'string ' ) ? collection [ key ] : key const is Function Or Object = ( obj ) = > obj & & [ 'function ' , 'object ' ] . includes ( typeof obj ) return pipeline . map ( replace With Function ) . filter ( is Function Or Object ) } 
function prepare Rev Pipeline ( rev Pipeline , fwd Pipeline , collection ) { return ( rev Pipeline ) ? prepare Pipeline ( rev Pipeline , collection ) : fwd Pipeline . map ( ( fn ) = > ( fn . rev ) ? fn . rev : null ) . filter ( Boolean ) } 
function cast Query Params ( rel Id , data , { relationships } ) { const relationship = relationships [ rel Id ] if ( ! relationship . query ) { return { } } return Object . keys ( relationship . query ) . reduce ( ( params , key ) = > { const value = get Field ( data , relationship . query [ key ] ) if ( value = = = undefined ) { throw new Type Error ( 'Missing value for query param ' ) } return { . . . params , [ key ] : value } } , { } ) } 
function setup Queue ( queue ) { let dispatch = null let subscribed = false return { queue , set Dispatch ( dispatch Fn ) { dispatch = dispatch Fn if ( ! subscribed & & typeof dispatch = = = 'function ' ) { queue . subscribe ( dispatch ) subscribed = true } } , middleware ( next ) { return middleware ( next , queue ) } , async schedule ( defs ) { return schedule ( defs , queue ) } } } 
async function get Meta ( { payload , meta } , { get Service } ) { debug ( 'Action : GET _META ' ) const { service : service Id , endpoint , keys } = payload const id = ` $ { service Id } ` const service = get Service ( null , service Id ) if ( ! service ) { debug ( ` $ { service Id } ` ) return create Error ( ` $ { service Id } ` ) } const type = service . meta const meta Service = get Service ( type ) if ( ! meta Service ) { return create Error ( ` $ { service . id } $ { service . meta } ` ) } const endpoint Debug = ( endpoint ) ? ` $ { endpoint } ` : ` $ { type } $ { id } ` debug ( 'GET _META : Get meta %s for service \ ' %s \ ' on service \ ' %s \ ' at %s ' , keys , service . id , meta Service . id , endpoint Debug ) const { response } = await meta Service . send ( { type : 'GET ' , payload : { keys , type , id , endpoint } , meta : { ident : meta . ident } } ) if ( response . status = = = 'ok ' ) { const { data } = response const meta = prepare Meta ( keys , data [ 0 ] . attributes ) return { . . . response , data : { service : service Id , meta } } } else { return response } } 
async function set ( action , { get Service , schemas } ) { debug ( 'Action : SET ' ) const { service : service Id , data , endpoint , only Mapped Values = true } = action . payload const type = extract Type ( action , data ) const id = extract Id ( data ) const service = get Service ( type , service Id ) if ( ! service ) { return create Unknown Service Error ( type , service Id , 'SET ' ) } const endpoint Debug = ( endpoint ) ? ` $ { endpoint } ` : ' ' debug ( 'SET : Send to service %s %s ' , service . id , endpoint Debug ) const { response , authorized Request Data } = await service . send ( append To Action ( action , { id , type , only Mapped Values } ) ) return merge Request And Response Data ( response , authorized Request Data ) } 
function cast ( { id , attributes , relationships , default Attrs , default Rels } ) { return ( data , { only Mapped Values } ) = > { if ( ! data ) { return undefined } const attrs = cast Attributes ( data . attributes , attributes , ( only Mapped Values ) ? { } : { . . . default Attrs } ) if ( ! only Mapped Values ) { set Dates ( attrs ) } const rels = cast Relationships ( data . relationships , relationships , ( only Mapped Values ) ? { } : { . . . default Rels } ) const cast Id = data . id | | attrs . id | | uuid ( ) delete attrs . id const casted = { id : cast Id , type : id , attributes : attrs , relationships : rels } if ( data . is New ) { casted . is New = true } if ( data . is Deleted ) { casted . is Deleted = true } return casted } } 
async function set Meta ( { payload , meta } , { get Service } ) { debug ( 'Action : SET _META ' ) const { service : service Id , meta : meta Attrs , endpoint } = payload const id = ` $ { service Id } ` const service = get Service ( null , service Id ) if ( ! service ) { debug ( ` $ { service Id } ` ) return create Error ( ` $ { service Id } ` ) } const type = service . meta const meta Service = get Service ( type ) if ( ! meta Service ) { debug ( ` $ { service . id } $ { service . meta } ` ) return { status : 'noaction ' } } const endpoint Debug = ( endpoint ) ? ` $ { endpoint } ` : ` $ { type } $ { id } ` debug ( 'SET _META : Send metadata %o for service \ ' %s \ ' on service \ ' %s \ ' %s ' , meta Attrs , service . id , meta Service . id , endpoint Debug ) const data = { id , type , attributes : meta Attrs } const { response } = await meta Service . send ( { type : 'SET ' , payload : { keys : Object . keys ( meta Attrs ) , type , id , data , endpoint , only Mapped Values : true } , meta : { ident : meta . ident } } ) return response } 
function export To JSONSchema ( exp Specifications , base Schema URL , base Type URL , flat = false ) { const namespace Results = { } ; const end Of Type URL = base Type URL [ base Type URL . length - 1 ] ; if ( end Of Type URL ! = = ' # ' & & end Of Type URL ! = = ' / ' ) { base Type URL + = ' / ' ; } for ( const ns of exp Specifications . namespaces . all ) { const last Logger = logger ; logger = logger . child ( { shr Id : ns . namespace } ) ; try { logger . debug ( 'Exporting namespace . ' ) ; if ( flat ) { const { schema Id , schema } = flat Namespace To Schema ( ns , exp Specifications . data Elements , base Schema URL , base Type URL ) ; namespace Results [ schema Id ] = schema ; } else { const { schema Id , schema } = namespace To Schema ( ns , exp Specifications . data Elements , base Schema URL , base Type URL ) ; namespace Results [ schema Id ] = schema ; } logger . debug ( 'Finished exporting namespace . ' ) ; } finally { logger = last Logger ; } } return namespace Results ; } 
function namespace To Schema ( ns , data Elements Specs , base Schema URL , base Type URL ) { const data Elements = data Elements Specs . by Namespace ( ns . namespace ) ; const schema Id = ` $ { base Schema URL } $ { namespace To URLPath Segment ( ns . namespace ) } ` ; let schema = { $schema : 'http : / /json -schema .org /draft - 0 4 /schema # ' , id : schema Id , title : "TODO : Figure out what the title should be . " , definitions : { } } ; const entry Ref = make Ref ( new Identifier ( 'shr .base ' , 'Entry ' ) , ns , base Schema URL ) ; if ( ns . description ) { schema . description = ns . description ; } const non Entry Entry Type Field = { $ref : make Ref ( new Identifier ( 'shr .base ' , 'Entry Type ' ) , ns , base Schema URL ) } ; const defs = data Elements . sort ( function ( l , r ) { return l . identifier . name . locale Compare ( r . identifier . name ) ; } ) ; const entry Refs = [ ] ; for ( const def of defs ) { const last Logger = logger ; logger = logger . child ( { shr Id : def . identifier . fqn } ) ; try { logger . debug ( 'Exporting element ' ) ; let schema Def = { type : 'object ' , properties : { } } ; let whole Def = schema Def ; const tbd Parent Descriptions = [ ] ; let required Properties = [ ] ; let needs Entry Type = false ; if ( def . is Entry | | def . based On . length ) { whole Def = { all Of : [ ] } ; let has Entry Parent = false ; for ( const supertype Id of def . based On ) { if ( supertype Id instanceof TBD ) { if ( supertype Id . text ) { tbd Parent Descriptions . push ( supertype Id . text ) ; } else { tbd Parent Descriptions . push ( 'TBD ' ) ; } } else { const parent = data Elements Specs . find By Identifier ( supertype Id ) ; if ( ! parent ) { logger . error ( 'Could not find definition for %s which is a supertype of %s ' , supertype Id , def ) ; } else { has Entry Parent = has Entry Parent | | parent . is Entry ; } whole Def . all Of . push ( { $ref : make Ref ( supertype Id , ns , base Schema URL ) } ) ; } } if ( def . is Entry & & ( ! has Entry Parent ) ) { whole Def . all Of . splice ( 0 , 0 , { $ref : entry Ref } ) ; } whole Def . all Of . push ( schema Def ) ; } else { needs Entry Type = true ; } const tbd Field Descriptions = [ ] ; if ( def . value ) { if ( def . value . inheritance ! = = INHERITED ) { let { value , required , tbd } = convert Definition ( def . value , data Elements Specs , ns , base Schema URL , base Type URL ) ; if ( required ) { required Properties . push ( 'Value ' ) ; } schema Def . properties . Value = value ; if ( tbd ) { schema Def . properties . Value . description = def . value . text ? ( 'TBD : ' + def . value . text ) : tbd Value To String ( def . value ) ; } } } if ( def . fields . length ) { const field Name Map = { } ; const clashing Names = { } ; for ( const field of def . fields ) { if ( ! ( field instanceof TBD ) ) { if ( ! is Valid Field ( field ) ) { continue ; } else if ( field . inheritance = = = INHERITED ) { if ( field Name Map [ field . identifier . name ] ) { logger . error ( ` ` , field Name Map [ field . identifier . name ] . fqn , field . identifier . fqn ) ; clashing Names [ field . identifier . name ] = true ; } else { field Name Map [ field . identifier . name ] = field . identifier ; } continue ; } if ( field Name Map [ field . identifier . name ] ) { logger . error ( ` ` , field Name Map [ field . identifier . name ] . fqn , field . identifier . fqn ) ; clashing Names [ field . identifier . name ] = true ; continue ; } else { field Name Map [ field . identifier . name ] = field . identifier ; } } const card = field . effective Card ; if ( card & & card . is Zeroed Out ) { continue ; } let { value , required , tbd } = convert Definition ( field , data Elements Specs , ns , base Schema URL , base Type URL ) ; if ( tbd ) { tbd Field Descriptions . push ( tbd Value To String ( field ) ) ; continue ; } if ( field . identifier . fqn = = = 'shr .base .Entry Type ' ) { needs Entry Type = false ; } schema Def . properties [ field . identifier . name ] = value ; if ( required ) { required Properties . push ( field . identifier . name ) ; } } for ( const clashing Name in clashing Names ) { delete schema Def . properties [ clashing Name ] ; } required Properties = required Properties . filter ( prop Name = > ! ( prop Name in clashing Names ) ) ; } else if ( ! def . value ) { schema Def . type = 'object ' ; schema Def . description = 'Empty Data Element ? ' ; } let description List = [ ] ; if ( def . description ) { description List . push ( def . description ) ; } if ( def . concepts . length ) { whole Def . concepts = def . concepts . map ( ( concept ) = > make Concept Entry ( concept ) ) ; } if ( tbd Parent Descriptions . length ) { tbd Parent Descriptions [ 0 ] = 'TBD Parents : ' + tbd Parent Descriptions [ 0 ] ; description List = description List . concat ( tbd Parent Descriptions ) ; } if ( tbd Field Descriptions . length ) { tbd Field Descriptions [ 0 ] = 'TBD Fields : ' + tbd Field Descriptions [ 0 ] ; description List = description List . concat ( tbd Field Descriptions ) ; } if ( description List . length ) { whole Def . description = description List . join ( ' \n ' ) ; } if ( needs Entry Type ) { schema Def . properties [ 'Entry Type ' ] = non Entry Entry Type Field ; if ( def . identifier . fqn ! = = 'shr .base .Entry Type ' ) { required Properties . push ( 'Entry Type ' ) ; } } if ( required Properties . length ) { schema Def . required = required Properties ; } schema . definitions [ def . identifier . name ] = whole Def ; if ( def . is Entry & & ( ! def . is Abstract ) ) { entry Refs . push ( { $ref : make Ref ( def . identifier , ns , base Schema URL ) } ) ; } } finally { logger = last Logger ; } } if ( entry Refs . length ) { schema . type = 'object ' ; schema . any Of = entry Refs ; } return { schema Id , schema } ; } 
function flat Namespace To Schema ( ns , data Elements Specs , base Schema URL , base Type URL ) { const data Elements = data Elements Specs . by Namespace ( ns . namespace ) ; const schema Id = ` $ { base Schema URL } $ { namespace To URLPath Segment ( ns . namespace ) } ` ; let schema = { $schema : 'http : / /json -schema .org /draft - 0 4 /schema # ' , id : schema Id , title : "TODO : Figure out what the title should be . " , definitions : { } } ; const expanded Entry = make Expanded Entry Definitions ( ns , base Schema URL ) ; if ( ns . description ) { schema . description = ns . description ; } const defs = data Elements . sort ( function ( l , r ) { return l . identifier . name . locale Compare ( r . identifier . name ) ; } ) ; const entry Refs = [ ] ; for ( const def of defs ) { let schema Def = { type : 'object ' , properties : { } } ; let whole Def = schema Def ; const tbd Parent Descriptions = [ ] ; let required Properties = [ ] ; if ( def . is Entry ) { required Properties = expanded Entry . required . slice ( ) ; } const tbd Field Descriptions = [ ] ; if ( def . value ) { let { value , required , tbd } = convert Definition ( def . value , data Elements Specs , ns , base Schema URL , base Type URL ) ; if ( required ) { required Properties . push ( 'Value ' ) ; } schema Def . properties . Value = value ; if ( tbd ) { schema Def . properties . Value . description = def . value . text ? ( 'TBD : ' + def . value . text ) : tbd Value To String ( def . value ) ; } } if ( def . fields . length ) { for ( const field of def . fields ) { if ( ! ( field instanceof TBD ) & & ! is Valid Field ( field ) ) { continue ; } const card = field . effective Card ; if ( card & & card . is Zeroed Out ) { continue ; } let { value , required , tbd } = convert Definition ( field , data Elements Specs , ns , base Schema URL , base Type URL ) ; if ( tbd ) { tbd Field Descriptions . push ( tbd Value To String ( field ) ) ; continue ; } const field Name = field . identifier . name ; schema Def . properties [ field Name ] = value ; if ( required & & ( required Properties . index Of ( field Name ) = = = - 1 ) ) { required Properties . push ( field Name ) ; } } if ( def . is Entry ) { for ( const name in expanded Entry . properties ) { if ( ! ( name in schema Def . properties ) ) { schema Def . properties [ name ] = expanded Entry . properties [ name ] ; } } } } else if ( ! def . value ) { schema Def . type = 'object ' ; schema Def . description = 'Empty Data Element ? ' ; } let description List = [ ] ; if ( def . description ) { description List . push ( def . description ) ; } if ( def . concepts . length ) { whole Def . concepts = def . concepts . map ( ( concept ) = > make Concept Entry ( concept ) ) ; } if ( tbd Parent Descriptions . length ) { tbd Parent Descriptions [ 0 ] = 'TBD Parents : ' + tbd Parent Descriptions [ 0 ] ; description List = description List . concat ( tbd Parent Descriptions ) ; } if ( tbd Field Descriptions . length ) { tbd Field Descriptions [ 0 ] = 'TBD Fields : ' + tbd Field Descriptions [ 0 ] ; description List = description List . concat ( tbd Field Descriptions ) ; } if ( description List . length ) { whole Def . description = description List . join ( ' \n ' ) ; } if ( required Properties . length ) { schema Def . required = required Properties ; } schema . definitions [ def . identifier . name ] = whole Def ; if ( def . is Entry & & ( ! def . is Abstract ) ) { entry Refs . push ( { $ref : make Ref ( def . identifier , ns , base Schema URL ) } ) ; } } if ( entry Refs . length ) { schema . type = 'object ' ; schema . any Of = entry Refs ; } return { schema Id , schema } ; } 
function make Ref ( id , enclosing Namespace , base Schema URL ) { if ( id . namespace = = = enclosing Namespace . namespace ) { return ' # /definitions / ' + id . name ; } else { return make Shr Definition URL ( id , base Schema URL ) ; } } 
function extract Constraint Path ( constraint , value Def , data Element Specs ) { if ( constraint . on Value ) { return extract Unnormalized Constraint Path ( constraint , value Def , data Element Specs ) ; } else if ( constraint . path . length > 0 & & constraint . path [ constraint . path . length - 1 ] . is Value Key Word ) { 
function make Concept Entry ( concept ) { if ( concept instanceof TBD ) { const ret = { code : 'TBD ' , code System : 'urn :tbd ' } ; if ( concept . text ) { ret . display Text = concept . text ; } return ret ; } else { const ret = { code : concept . code , code System : concept . system } ; if ( concept . display ) { ret . display Text = concept . display ; } return ret ; } } 
function is Or Was AList ( value ) { if ( value . card . is List ) { return true ; } const card Constraints = value . constraints Filter . own . card . constraints ; return card Constraints . some ( ( one Card ) = > one Card . is List ) ; } 
function find Option In Choice ( choice , option Id , data Element Specs ) { 
function supports Code Constraint ( identifier , data Element Specs ) { if ( CODE . equals ( identifier ) | | check Has Base Type ( identifier , new Identifier ( 'shr .core ' , 'Coding ' ) , data Element Specs ) | | check Has Base Type ( identifier , new Identifier ( 'shr .core ' , 'Codeable Concept ' ) , data Element Specs ) ) { return true ; } const element = data Element Specs . find By Identifier ( identifier ) ; if ( element . value ) { if ( element . value instanceof Identifiable Value ) { return CODE . equals ( element . value . identifier ) | | check Has Base Type ( element . value . identifier , new Identifier ( 'shr .core ' , 'Coding ' ) , data Element Specs ) | | check Has Base Type ( element . value . identifier , new Identifier ( 'shr .core ' , 'Codeable Concept ' ) , data Element Specs ) ; } else if ( element . value instanceof Choice Value ) { for ( const value of element . value . aggregate Options ) { if ( value instanceof Identifiable Value ) { if ( CODE . equals ( value . identifier ) | | check Has Base Type ( value . identifier , new Identifier ( 'shr .core ' , 'Coding ' ) , data Element Specs ) | | check Has Base Type ( value . identifier , new Identifier ( 'shr .core ' , 'Codeable Concept ' ) , data Element Specs ) ) { return true ; } } } } } return false ; } 
async function expire ( { payload , meta = { } } , { dispatch } ) { const { service } = payload const { ident } = meta if ( ! service ) { return create Error ( ` ` ) } if ( ! payload . endpoint ) { return create Error ( ` $ { service } ` ) } if ( ! payload . type ) { return create Error ( ` $ { service } ` ) } const response = await get Expired ( payload , ident , dispatch ) return delete Expired ( response , service , ident , dispatch ) } 
function Set ( target , attribute , value ) { this . type = 'Set ' this . target = target this . attribute = attribute this . value = value this . has Effect = true 
function Name ( name , action , val ) { this . type = 'Name ' this . name = name this . action = action this . value = val } 
function parse Cell ( cell ) { var match = cell . match ( / ( [a -z ] + ) ( [ 0 - 9 ] + ) / i ) if ( ! match ) throw new Error ( 'invalid cell id ' + cell ) return [ column . from Str ( match [ 1 ] ) , parse Int ( match [ 2 ] ) ] } 
function transform Range ( range , ops ) { var range Comps = range . split ( ' : ' ) , new Range var start = range Comps [ 0 ] ops . for Each ( op = > start = transform Range Anchor ( start , op , true ) ) var end = range Comps [ 1 ] ops . for Each ( op = > end = transform Range Anchor ( end , op , false ) ) if ( start = = = end ) return start return start + ' : ' + end } 
function transform Range Anchor ( target , op , is Start ) { var this Cell = parse Cell ( target ) if ( op instanceof Insert Col ) { var other Cell = parse Cell ( op . new Col ) if ( other Cell [ 0 ] < = this Cell [ 0 ] ) return column . from Int ( this Cell [ 0 ] + 1 ) + this Cell [ 1 ] } else if ( op instanceof Delete Col ) { var other Cell = parse Cell ( op . col ) if ( other Cell [ 0 ] < this Cell [ 0 ] ) return column . from Int ( this Cell [ 0 ] - 1 ) + this Cell [ 1 ] if ( other Cell [ 0 ] = = = this Cell [ 0 ] ) { 
function match Endpoint ( endpoints ) { return ( { type , payload , meta } ) = > endpoints . find ( ( endpoint ) = > match Id ( endpoint , { type , payload } ) & & match Type ( endpoint , { type , payload } ) & & match Scope ( endpoint , { type , payload } ) & & match Action ( endpoint , { type , payload } ) & & match Params ( endpoint , { type , payload } ) & & match Filters ( endpoint , { type , payload , meta } ) ) } 
function create Action ( type , payload = { } , meta ) { if ( ! type ) { return null } const action = { type , payload } if ( meta ) { action . meta = meta } return action } 
function authorize Request ( { schemas } ) { return ( { request } ) = > { const { access = { } , params = { } , action } = request const { ident = null } = access if ( ident & & ident . root ) { return auth Items And Wrap ( request , { status : 'granted ' , ident , scheme : 'root ' } , schemas ) } if ( ! params . type ) { return auth Items And Wrap ( request , { status : 'granted ' , ident , scheme : null } , schemas ) } const require Auth = ! ! request . auth const schema = schemas [ params . type ] const scheme = get Scheme ( schema , action ) const status = ( do Auth ( scheme , ident , require Auth ) ) ? 'granted ' : 'refused ' return auth Items And Wrap ( request , { status , ident , scheme } , schemas ) } } 
function request From Action ( { type : action , payload , meta = { } } , { endpoint , schemas = { } } = { } ) { const { data , . . . params } = payload const { ident = null } = meta const type Plural = get Plural Type ( params . type , schemas ) return { action , params , data , endpoint : ( endpoint & & endpoint . options ) | | null , access : { ident } , meta : { type Plural } } } 
function get Service ( schemas , services ) { return ( type , service ) = > { if ( ! service & & schemas [ type ] ) { service = schemas [ type ] . service } return services [ service ] | | null } } 
async function sync ( { payload , meta = { } } , { dispatch } ) { debug ( 'Action : SYNC ' ) const from Params = await generate From Params ( payload , meta , dispatch ) const to Params = generate To Params ( payload , from Params ) const last Synced At = new Date ( ) const results = await Promise . all ( from Params . map ( get From Service ( dispatch , payload . type , meta ) ) ) if ( results . some ( ( result ) = > result . status ! = = 'ok ' ) ) { return ( results . length = = = 1 ) ? results [ 0 ] : create Error ( make Error String ( results ) ) } const data = flatten ( results . map ( ( result ) = > result . data ) ) . filter ( Boolean ) if ( data . length = = = 0 & & payload . sync No Data ! = = true ) { return create Error ( ` $ { from Params [ 0 ] . service } ` , 'noaction ' ) } return Promise . all ( [ . . . create Set Metas ( from Params , last Synced At , meta . ident , dispatch ) , dispatch ( action ( 'SET ' , { data , . . . to Params } , { . . . meta , queue : true } ) ) ] ) . then ( ( responses ) = > { return { status : 'ok ' , data : responses } } ) } 
function ( gulp , cwd , config ) { if ( util . is Null Or Undefined ( gulp ) ) { throw 'gulp must be defined ' ; } this . _config = config | | { } , this . _cwd = cwd | | _ _dirname ; this . _root = path . relative ( this . _cwd , _ _dirname ) ; this . _gulp = gulp ; } 
function ( ) { this . _colors = [ 'red ' , 'green ' , 'yellow ' , 'blue ' , 'magenta ' , 'cyan ' , 'white ' , 'black ' ] this . _colors _num = this . _colors . length this . _backgrounds = [ ] for ( var i = 0 ; i < this . _colors _num ; i + + ) { this . _backgrounds [ i ] = 'bg ' + this . _colors [ i ] . char At ( 0 ) . to Upper Case ( ) + this . _colors [ i ] . slice ( 1 ) } this . _skip = [ 'black ' , 'white ' , 'bg Black ' , 'bg White ' ] this . _skip _num = this . _skip . length - 1 this . _next = 0 this . _prev = - 1 this . options = { color _space : false , gap : 1 , space _color : null } this . wrapper = { bg : this . ponyfy ( true ) , r : this . ponyfy ( ) , add : this . addorskip ( 'add ' ) , skip : this . addorskip ( 'skip ' ) , options : ( opts ) = > { for ( let i in options ) { if ( opts [ i ] ) { this . options [ i ] = opts [ i ] continue } for ( let j in opts ) { if ( options [ i ] . alias & & ~ options [ i ] . alias . index Of ( j ) ) { this . options [ i ] = opts [ j ] break } } } return this . wrapper } , colors : ( ) = > this . colors ( ) , reset : ( ) = > { this . _skip = [ 'black ' , 'white ' , 'bg Black ' , 'bg White ' ] return this . wrapper } , _colors : this . _colors , _backgrounds : this . _backgrounds } return this . wrapper } 
function ( bg ) { bg = bg ? bg : false return ( . . . args ) = > { return this . output ( args . join ( ' ' ) , this . colors ( bg ) ) } } 
function ( browserify , name , source ) { if ( utility . is Null Or Undefined ( browserify ) ) { throw 'browserify must be defined . ' ; } if ( ! utility . is Non Empty String ( name ) ) { throw 'name must be defined . ' ; } if ( utility . is Null Or Undefined ( source ) ) { throw 'source must be defined . ' ; } this . _browserify = browserify ; this . _name = name ; this . _source = source ; this . _has Module = false ; this . _has Resolver = false ; } 
function Strategy ( options , verify ) { options = options | | { } ; if ( ! options . base URI ) { throw new Type Error ( 'Eve Seat Strategy requires a base URI option ' ) ; } 
function map To Service ( ) { return ( { request , request Mapper , mappings } ) = > { const data = map Data ( request . data , request , mappings ) return { . . . request , data : apply Endpoint Mapper ( data , request , request Mapper ) } } } 
function Router ( options ) { var self = this ; self . frontend = new Server ( { port : options . port , auth : options . auth | | options . secret , certificates : options . certificates , routing : true } ) / / connect to relay destination if ( options . client ) { self . backend = new Client ( { address : options . client . address , auth : options . client . auth | | options . client . secret | | options . auth | | options . secret , certificates : options . certificates | | options . client . certificates , / /node : options .node , designation : 'router ' , routes : self . frontend . streams } ) } else if ( options . server ) { self . backend = new Server ( { port : options . server . port , auth : options . server . auth | | options . server . secret | | options . auth | | options . secret , certificates : options . certificates | | options . server . certificates , routes : self . frontend . streams } ) } else throw new Error ( "iris -rpc : :Router ( ) requires client or server " ) self . frontend . on ( 'connect ' , function ( address , uuid , stream ) { self . backend . dispatch ( { op : 'rpc : :online ' , uuid : uuid } ) ; } ) self . frontend . on ( 'disconnect ' , function ( uuid , stream ) { self . backend . dispatch ( { op : 'rpc : :offline ' , uuid : uuid } ) ; } ) self . backend . on ( 'connect ' , function ( address , uuid , stream ) { self . frontend . dispatch ( { op : 'rpc : :online ' , uuid : uuid } ) ; } ) self . backend . on ( 'disconnect ' , function ( uuid , stream ) { self . frontend . dispatch ( { op : 'rpc : :offline ' , uuid : uuid } ) ; } ) self . frontend . digest ( function ( msg , uuid , stream ) { msg . _r = { uuid : uuid , designation : stream . designation , uuid : stream . uuid } self . backend . dispatch ( msg ) ; } ) self . backend . digest ( function ( msg , uuid ) { self . frontend . dispatch ( msg . _uuid , msg ) ; } ) } 
async function process Messenger Body ( body , context ) { const all Messages = get All Messages ( body ) if ( ! all Messages | | ! all Messages . length ) return false context = context | | { } for ( let message of all Messages ) { message = _ . clone Deep ( message ) const message Context = Object . assign ( { } , context ) try { for ( let plugin of middleware ) { await plugin ( message , message Context ) } } catch ( error ) { const log Error = ( message Context . log & & message Context . log . error instanceof Function ) ? message Context . log . error : console . error log Error ( 'Error running middleware ' , error ) } } return true } 
function create ( prop ) { if ( typeof prop ! = = 'string ' ) { throw new Error ( 'expected the first argument to be a string . ' ) ; } return function ( app ) { if ( this . is Registered ( 'base - ' + prop ) ) return ; 
function proxy ( config ) { function fn ( key , val ) { if ( typeof val = = = 'string ' ) { config . alias . apply ( config , arguments ) ; return config ; } if ( typeof key = = = 'string ' ) { config . map . apply ( config , arguments ) ; return config ; } if ( ! utils . is Object ( key ) ) { throw new Type Error ( 'expected key to be a string or object ' ) ; } for ( var prop in key ) { fn ( prop , key [ prop ] ) ; } return config ; } fn . _ _proto _ _ = config ; return fn ; } 
function ( proto , parent Proto ) { proto . _init Hooks = [ ] ; proto . _destroy Hooks = [ ] ; 
function Element Matrix ( top ) { Commanality Matrix . call ( this , top ) ; this . row ( ' ' ) ; this . collum ( ' ' ) ; this . classlist = top . root . classlist ; } 
function public S 3URI ( string ) { return encode URIComponent ( string ) . replace ( / % 2 0 / img , ' + ' ) . replace ( / % 2F / img , ' / ' ) . replace ( / \ " / img , " % 2 2 " ) . replace ( / \ # / img , " % 2 3 " ) . replace ( / \ $ / img , " % 2 4 " ) . replace ( / \ & / img , " % 2 6 " ) . replace ( / \ ' / img , " % 2 7 " ) . replace ( / \ ( / img , " % 2 8 " ) . replace ( / \ ) / img , " % 2 9 " ) . replace ( / \ , / img , " % 2C " ) . replace ( / \ : / img , " % 3A " ) . replace ( / \ ; / img , " % 3B " ) . replace ( / \ = / img , " % 3D " ) . replace ( / \ ? / img , " % 3F " ) . replace ( / \ @ / img , " % 4 0 " ) ; } 
function parse Payload ( message ) { const message Parts = message & & message . match ( / ^ ( [ ^ : ] + ) ( ? : : ( . * ) ) ? / ) if ( ! message Parts ) return { topic : undefined , data : undefined } const topic = message Parts [ 1 ] let data = message Parts [ 2 ] if ( data ) { try { data = JSON . parse ( data ) } catch ( error ) { data = undefined } } return { topic , data } } 
function ( done ) { fs . write File ( path . resolve ( _ _dirname , ' . . / . . /test /reallife /expected / ' + item . key + ' .json ' ) , JSON . stringify ( { 'title ' : item . title , 'text ' : item . text } , null , ' \t ' ) + ' \n ' , done ) ; } 
function ( done ) { fs . write File ( path . resolve ( _ _dirname , ' . . / . . /test /reallife /source / ' + item . key + ' .html ' ) , SOURCES [ item . key ] , done ) ; } 
function ( done ) { datamap [ item . index ] . labeled = true ; fs . write File ( path . resolve ( _ _dirname , ' . . / . . /test /reallife /datamap .json ' ) , JSON . stringify ( datamap , null , ' \t ' ) + ' \n ' , done ) ; } 
function attr Stringify ( attr ) { var names = Object . keys ( attr ) ; var str = ' ' ; for ( var i = 0 , l = names . length ; i < l ; i + + ) { str + = names [ i ] + ' = " ' + attr [ names [ i ] ] . slice ( 0 , 2 0 ) + ( attr [ names [ i ] ] . length > 2 0 ? ' . . . ' : ' ' ) + ' " ' ; } return str ; } 
function to NLCST ( tree , file , Parser ) { var parser var location var results var doc 
function one ( node ) { var type = node . type var tag Name = type = = = 'element ' ? node . tag Name : null var change var replacement if ( type = = = 'text ' ) { change = true replacement = parser . tokenize ( node . value ) } else if ( tag Name = = = 'wbr ' ) { change = true replacement = [ parser . tokenize White Space ( ' ' ) ] } else if ( tag Name = = = 'br ' ) { change = true replacement = [ parser . tokenize White Space ( ' \n ' ) ] } else if ( sourced ( node ) ) { change = true replacement = [ parser . tokenize Source ( text Content ( node ) ) ] } else if ( type = = = 'root ' | | ! ignored ( node ) ) { replacement = all ( node . children ) } else { return } if ( ! change ) { return replacement } return patch ( replacement , location , location . to Offset ( position . start ( node ) ) ) } 
function all ( children ) { var length = children & & children . length var index = - 1 var result = [ ] var child while ( + + index < length ) { child = one ( children [ index ] ) if ( child ) { result = result . concat ( child ) } } return result } 
function ( source , target , alias , type ) { if ( Util . isnt . Class ( source ) | | Util . isnt . Class ( target ) | | Util . isnt . String ( alias ) | | ! alias | | Association . types . index Of ( type ) = = = - 1 ) { return false ; } this . id = Util . uniq Id ( ) ; this . source = source ; this . target = target ; this . alias = Util . String . capitalize ( alias ) ; this . type = type ; return this . complete ( ) ; } 
function Node ( type , parent ) { this . type = type ; this . parent = parent ; this . root = parent ? parent . root : this ; this . identifyer = parent ? ( + + parent . root . _counter ) : 0 ; 
function Text Node ( parent , text ) { Node . call ( this , 'text ' , parent ) ; 
function Element Node ( parent , tagname , attributes ) { Node . call ( this , 'element ' , parent ) ; 
function ( ) { var r ; 
function distribute ( filename , content ) { content = content ; fs . append File ( filename , content + " \n " ) ; log ( rulecount + ' : Append to ' + filename + ' - > ' + content ) ; } 
function detect Takeout ( selectors ) { var properties = { takeout : false } ; options . takeout . for Each ( function ( takeout ) { selectors . for Each ( function ( selector ) { if ( selector . index Of ( takeout . ruleprefix ) = = = 0 ) { properties . takeout = true ; properties . filename = takeout . filename ; } } ) ; } ) ; return properties ; } 
function wordcount Score ( x ) { if ( x > 5 ) return 1 ; else return Math . min ( 1 , 2 . 2 7 * Math . sqrt ( x ) - 0 . 0 5 0 7 * Math . pow ( x , 2 ) - 2 . 8 0 8 ) ; } 
function linebreak Score ( x ) { if ( x > 5 ) return 1 ; else return Math . min ( 1 , 0 . 4 7 7 * Math . sqrt ( x ) - 0 . 0 1 0 6 * Math . pow ( x , 2 ) + 0 . 2 ) ; } 
function adjust Liklihood ( x ) { if ( x < 0 . 0 1 ) return 0 . 5 ; else if ( x > 0 . 1 ) return 1 ; else return Math . min ( 1 , - 1 3 7 1 * Math . pow ( x , 3 ) + 2 2 6 * Math . pow ( x , 2 ) - 4 . 1 1 * x + 0 . 5 2 ) ; } 
function parse Line By Line ( text ) { var lines = text . trim ( ) . split ( " \n " ) ; var bookmarks = lines . splice ( 0 , lines . length * 3 / 4 ) ; return { bookmarks : bookmarks , lines : lines } ; } 
function Commonality Interface ( Matrix Constructor , top ) { this . top = top ; this . length = null ; this . matrix = null ; this . Matrix Constructor = Matrix Constructor ; } 
function Commanality Matrix ( classlist ) { 
function array Vector ( size ) { var vec = new Array ( size ) ; for ( var i = 0 ; i < size ; i + + ) vec [ i ] = [ ] ; return vec ; } 
function build Attribute Matcher ( match ) { var keys = Object . keys ( match ) ; var jskey , i , l ; var transform = ' ' ; var bool = ' ' ; transform = 'transform = { \n ' ; for ( i = 0 , l = keys . length ; i < l ; i + + ) { jskey = JSON . stringify ( keys [ i ] ) ; transform + = ' ' + jskey + ' : attr .has Own Property ( ' + jskey + ' ) ? attr [ ' + jskey + ' ] .to Lower Case ( ) : false ' ; if ( i ! = = l - 1 ) transform + = ' , ' ; transform + = ' \n ' ; } transform + = ' } ; \n ' ; bool = 'return ! ! ( ' ; for ( i = 0 , l = keys . length ; i < l ; i + + ) { jskey = JSON . stringify ( keys [ i ] ) ; if ( i > 0 ) bool + = ' | | ' ; bool + = ' ( transform [ ' + jskey + ' ] ' ; if ( Array . is Array ( match [ keys [ i ] ] ) ) { bool + = ' & & ( ' ; for ( var j = 0 , s = match [ keys [ i ] ] . length ; j < s ; j + + ) { if ( j > 0 ) bool + = ' | | ' ; if ( typeof match [ keys [ i ] ] [ j ] = = = 'string ' ) { bool + = 'transform [ ' + jskey + ' ] = = = \ ' ' + match [ keys [ i ] ] [ j ] . to Lower Case ( ) + ' \ ' ' ; } else if ( util . is Reg Exp ( match [ keys [ i ] ] [ j ] ) ) { bool + = 'match [ ' + jskey + ' ] [ ' + j + ' ] .test (transform [ ' + jskey + ' ] ) ' ; } } bool + = ' ) ' ; } bool + = ' ) \n ' ; } bool + = ' ) ; ' ; var anonymous = new Function ( 'attr ' , 'match ' , transform + ' \n ' + bool ) ; return function ( attr ) { return anonymous ( attr , match ) ; } ; } 
function container Of ( a , b ) { while ( b = b . parent ) { if ( a = = = b ) return true ; } return false ; } 
function common Parent ( a , b ) { if ( a = = = b ) { return a ; } else if ( container Of ( a , b ) ) { return a ; } else if ( container Of ( b , a ) ) { return b ; } else { 
function style Parser ( style ) { style = style | | ' ' ; var tokens = style . trim ( ) . split ( / \s * ( ? : ; | : ) \s * / ) ; var output = { } ; for ( var i = 1 , l = tokens . length ; i < l ; i + = 2 ) { output [ tokens [ i - 1 ] ] = tokens [ i ] ; } return output ; } 
function tree Distance ( a , b ) { if ( a = = = b ) return 0 ; var parent = common Parent ( a , b ) ; var a Parent = a ; var a Count = 0 ; var b Parent = b ; var b Count = 0 ; if ( parent ! = = a ) { while ( parent ! = = a Parent . parent ) { a Count + = 1 ; a Parent = a Parent . parent ; } } else { b Count + = 1 ; } if ( parent ! = = b ) { while ( parent ! = = b Parent . parent ) { b Count + = 1 ; b Parent = b Parent . parent ; } } else { a Count + = 1 ; } var ab Count = 0 ; if ( parent ! = = a & & parent ! = = b ) { ab Count = Math . abs ( parent . children . index Of ( a Parent ) - parent . children . index Of ( b Parent ) ) ; } return a Count + b Count + ab Count ; } 
function ( casper , pos ) { this . _pos = pos | | { timestamp : Date . now ( ) , coords : { longitude : 0 , latitude : 0 , accuracy : 0 } } ; this . _casper = casper ; } 
function Lexer ( file , options ) { this . options = utils . extend ( { } , options ) ; this . file = file ; this . regex = new Regex Cache ( ) ; this . names = [ ] ; this . ast = { tags : { } , type : 'root ' , name : 'root ' , nodes : [ ] } ; this . unknown = { tags : [ ] , blocks : [ ] } ; this . known = { tags : [ 'extends ' , 'layout ' ] , blocks : [ 'block ' ] } ; this . delimiters = { variable : [ ' { { ' , ' } } ' ] , block : [ ' { % ' , ' % } ' ] , es 6 : [ ' $ { ' , ' } ' ] , } ; this . tokens = [ this . ast ] ; this . errors = [ ] ; this . stack = [ ] ; this . stash = [ ] ; this . lexers = { } ; this . fns = [ ] ; } 
function ( ) { if ( this . is Initialized ) return ; this . is Initialized = true ; var lexer = this ; this . lineno = 1 ; this . column = 1 ; this . lexed = ' ' ; this . file = utils . normalize ( this . file ) ; this . file . orig = this . file . contents ; this . input = this . file . contents . to String ( ) ; this . file . ast = this . ast ; this . file . ast . variables = { } ; this . file . ast . blocks = { } ; this . input = this . input . split ( ' { % body % } ' ) . join ( ' { % block "body " % } { % endblock % } ' ) ; if ( this . file . extends ) { this . prepend Node ( this . file , 'extends ' ) ; } this . capture Tag ( 'extends ' ) ; this . capture Tag ( 'layout ' ) ; this . capture Block ( 'block ' ) ; this . capture ( 'text ' , utils . negate Delims ( this . delimiters ) ) ; this . capture ( 'newline ' , / ^ \n + / ) ; this . capture ( 'es 6 ' , / ^ \ $ \ { ( [ ^ \ \ } ] * ( ? : \ \ . [ ^ \ \ } ] * ) * ) \ } / ) ; this . capture ( 'variable ' , / ^ \ { { 2 , } ( [ ^ \ \ } ] * ( ? : \ \ . [ ^ \ \ } ] * ) * ) \ } { 2 , } / ) ; this . capture ( 'escape ' , / ^ \ \ ( . ) / ) ; this . capture ( 'space ' , / ^ [ \t ] + / ) ; var helpers = this . options . helpers | | { } ; if ( utils . is Object ( helpers ) ) { helpers = Object . keys ( helpers ) ; } helpers . for Each ( function ( key ) { lexer . known . blocks . push ( key ) ; lexer . capture Block ( key ) ; } ) ; var matches = this . input . match ( / \ { % \s * ( [ ^ % } ] + ) / g ) ; var names = utils . get Names ( matches ) ; names . tags . for Each ( function ( key ) { if ( ! utils . is Registered ( lexer , key ) ) { lexer . unknown . tags . push ( key ) ; lexer . capture Tag ( key ) ; } } ) ; names . blocks . for Each ( function ( key ) { if ( ! utils . is Registered ( lexer , key ) ) { lexer . unknown . blocks . push ( key ) ; lexer . capture Block ( key ) ; } } ) ; } 
function ( msg ) { var message = this . file . relative + ' line : ' + this . lineno + ' column : ' + this . column + ' : ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . line = this . lineno ; err . column = this . column ; err . source = this . input ; err . path = this . file . path ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } } 
function ( ) { var start = { line : this . lineno , column : this . column } ; var self = this ; return function ( node ) { utils . define ( node , 'position ' , new Position ( start , self ) ) ; return node ; } ; } 
function ( type , regex ) { var cached = this . regex . create ( type , regex ) ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . val ) ; if ( ! m | | ! m [ 0 ] ) return ; var parent = lexer . prev ( ) ; var node = pos ( { type : type , val : m [ 0 ] } ) ; utils . define ( node , 'parent ' , parent ) ; utils . define ( node , 'raw Args ' , m [ 1 ] ) ; utils . define ( node , 'args ' , function ( ) { return utils . parse Args ( m [ 1 ] ) ; } ) ; parent . nodes . push ( node ) ; } ; this . add Lexer ( fn ) ; return this ; } 
function ( type ) { var cached = this . regex . create Variable ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var parent = this . prev ( ) ; var node = pos ( { type : type , known : utils . has ( lexer . known . tags , type ) , val : m [ 0 ] . trim ( ) } ) ; parent . known = node . known ; var nodes = parent . nodes ; Object . define Property ( file . ast . variables , type , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . define Property ( parent , 'nodes ' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; utils . define ( node , 'parent ' , parent ) ; parent . nodes . push ( node ) ; } ; this . add Lexer ( fn ) ; return this ; } 
function ( type ) { this . ast . tags [ type ] = null ; this . names . push ( type ) ; var cached = this . regex . create Tag ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . get Name ( m [ 1 ] ) ; if ( this . options . strict ) { var is Known = utils . has ( lexer . known . tags , type ) ; if ( is Known & & file . has Own Property ( type ) & & ! file . has Own Property ( 'is Parsed ' ) ) { throw new Error ( ` $ { type } ` ) ; } } file [ type ] = name ; lexer . ast . tags [ type ] = name ; lexer . create Node ( type , name , m , pos ) ; } ; this . add Lexer ( fn ) ; return this ; } 
function ( type , name , m , pos ) { var parent = this . prev ( ) ; var val = m [ 1 ] ; var tok = { type : 'args ' , val : val } ; var node = pos ( { type : type , name : name , known : utils . has ( this . known . tags , type ) , val : val . trim ( ) , nodes : [ tok ] } ) ; utils . define ( node , 'parent ' , parent ) ; utils . define ( tok , 'parent ' , node ) ; parent . nodes . push ( node ) ; } 
function ( type ) { this . names . push ( type ) ; var cached = this . regex . create Open ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . get Name ( m [ 1 ] ) ; var action = utils . get Action ( m [ 1 ] ) ; var val = m [ 0 ] ; if ( ! name & & lexer . options [ type ] & & lexer . options [ type ] . args = = = 'required ' ) { throw new Error ( ` $ { type } $ { m [ 0 ] } ` ) ; } if ( ! name ) name = 'unnamed ' ; var node = pos ( { type : ` $ { type } ` , known : utils . has ( lexer . known . blocks , type ) , name : name , val : val . trim ( ) } ) ; var parent = lexer . prev ( ) ; if ( parent & & parent . name & & parent . name ! = = 'root ' ) { name = parent . name + ' . ' + name ; } var block = { type : type , name : name , known : node . known , action : action , nodes : [ node ] } ; utils . define ( node , 'parent ' , block ) ; utils . define ( block , 'parent ' , parent ) ; block . raw Args = m [ 1 ] ; block . args = utils . parse Args ( m [ 1 ] ) ; Object . define Property ( file . ast . blocks [ type ] , name , { configurable : true , enumerable : true , set : function ( val ) { block = val ; } , get : function ( ) { return block ; } } ) ; parent . nodes . push ( block ) ; lexer . tokens . push ( block ) ; return block ; } ; } 
function ( type ) { var cached = this . regex . create Close ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var block = lexer . tokens . pop ( ) ; if ( typeof block = = = 'undefined ' | | block . type ! = = type ) { throw new Error ( ` $ { type } ` ) ; } if ( block . name = = = 'body ' ) { lexer . ast . is Layout = true ; file . ast . is Layout = true ; } var nodes = block . nodes ; Object . define Property ( file . ast . blocks , block . name , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . define Property ( block , 'nodes ' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; var tok = pos ( { known : block . known , type : ` $ { type } ` , val : m [ 0 ] . trim ( ) } ) ; utils . define ( block , 'position ' , tok . position ) ; utils . define ( tok , 'parent ' , block ) ; block . nodes . push ( tok ) ; return block ; } ; } 
function ( type ) { this . file . ast . blocks [ type ] = this . file . ast . blocks [ type ] | | { } ; this . add Lexer ( this . capture Open ( type ) ) ; this . add Lexer ( this . capture Close ( type ) ) ; return this ; } 
function ( file , prop ) { return this . create Node ( prop , file [ prop ] , ` $ { prop } $ { file [ prop ] } ` , this . position ( ) ) ; } 
function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . lineno + = lines . length ; var i = str . last Index Of ( ' \n ' ) ; this . column = ~ i ? len - i : this . column + len ; this . lexed + = str ; this . consume ( str , len ) ; } 
function ( regex ) { var m = regex . exec ( this . input ) ; if ( m ) { this . update Position ( m [ 0 ] , m [ 0 ] . length ) ; return m ; } } 
function ( ) { var len = this . fns . length ; var idx = - 1 ; while ( + + idx < len ) { this . fns [ idx ] . call ( this ) ; if ( ! this . input ) { break ; } } } 
function ( ) { while ( this . input ) { var prev = this . input ; this . advance ( ) ; if ( this . input & & prev = = = this . input ) { throw new Error ( ` $ { this . input . substr ( 0 , 1 0 ) } ` ) ; } } } 
function ( file ) { debug ( 'lexing < %s > ' , this . file . path ) ; if ( file ) this . file = file ; this . init ( ) ; while ( this . input ) this . next ( ) ; return this . ast ; } 
function notify Hook ( e ) { message _count + + ; var message ; if ( ! options . enabled ) { return ; } if ( ! e ) { return ; } if ( e & & e . length = = = 1 ) { e = e [ 0 ] ; } if ( / Task . * failed \ . / . test ( e . message ) ) { message = e . message ; } else if ( e . message & & e . stack ) { message = exception ( e ) ; } else { message = e + ' ' ; } if ( message _count > 0 & & message = = = 'Aborted due to warnings . ' ) { 
function ( ) { if ( this . _initialized & & this . _is Paused ) { return false ; } this . _is Paused = true ; raf . cancel ( this . _request ID ) ; this . _pause Time = now ( ) ; this . _on Pause ( ) ; return true ; } 
function ( ) { if ( this . _initialized & & ! this . _is Paused ) { return false ; } var pause Duration ; this . _is Paused = false ; this . _prev Time = now ( ) ; pause Duration = this . _prev Time - this . _pause Time ; this . _on Resume ( pause Duration ) ; this . _request ID = raf . request ( this . _tick ) ; return true ; } 
function create Server ( options , callback ) { if ( options & & options . cert & & options . key ) { return https . create Server ( options , callback ) ; } return http . create Server ( callback | | null ) ; } 
function create Proxy ( api , obj , methods ) { return new Proxy ( obj , { get ( target , name ) { if ( methods . includes ( name ) ) { return ( params , callback ) = > { const inject = Object . assign ( { chat _id : obj . id } , params ) ; return api . method ( name , inject , callback ) ; } ; } return target [ name ] ; } , set ( ) { return new Error ( 'Cannot change `chat ` or `user ` . ' ) ; } , } ) ; } 
function is Array Like ( value ) { return ( value ! = = void 0 & & value ! = = null & & typeof value ! = = 'function ' & & is Integer ( value . length ) & & value . length > = 0 & & value . length < = MAX ) ; } 
function render ( ) { shell . context . cache . clear ( ) ; shell . context . set Viewport ( ) ; GLOW . default Camera . update ( ) shell . context . enable Depth Test ( true ) ; if ( params . cull CW ) { shell . context . enable Culling ( true , { front Face : GL . CW , cull Face : GL . BACK } ) ; } else if ( params . cull CCW ) { shell . context . enable Culling ( true , { front Face : GL . CCW , cull Face : GL . BACK } ) ; } else { shell . context . enable Culling ( false ) ; } shell . context . clear ( ) ; shell . events . emit ( "render " ) ; utils . next Frame ( render ) ; } 
function create ( opts , cb ) { immediately add some options to the create procedure done by adding argument -o option =value the opts .options parameter is an array of objects , or a single object opts .options = { property : String , value : String } OR : opts .options = [ { property : String , value : String } , { property : String , value : String } ] * / if ( opts . options ) { if ( opts . options . length ) { 
function add ( opts , cb ) { "use strict " ; var params = [ 'add ' , ' -f ' ] ; params . push ( opts . name ) ; 
function destroy ( opts , cb ) { "use strict " ; var params = [ 'destroy ' , ' -f ' ] ; params . push ( opts . name ) ; zpool ( params , cb ) ; } 
function list ( opts , cb ) { 
function mktmpdir ( prefix Suffix , tmpdir , callback , onend ) { if ( 'function ' = = typeof prefix Suffix ) { onend = tmpdir ; callback = prefix Suffix ; tmpdir = null ; prefix Suffix = null ; } else if ( 'function ' = = typeof tmpdir ) { onend = callback ; callback = tmpdir ; tmpdir = null ; } prefix Suffix = prefix Suffix | | 'd ' ; onend = onend | | function ( ) { } ; tmpname . create ( prefix Suffix , tmpdir , function ( err , path , next ) { if ( err ) return callback ( err ) ; fs . mkdir ( path , 0 7 0 0 , next ) ; } , function ( err , path ) { if ( err ) return callback ( err ) ; callback ( null , path , function ( err ) { if ( ! path ) return onend ( err ) ; rimraf ( path , function ( _err ) { onend ( err | | _err , path ) ; } ) ; } ) ; } ) ; } 
function list ( opts , cb ) { "use strict " ; if ( typeof opts = = = 'function ' ) { cb = opts ; opts = undefined ; } var params = [ 'list ' , ' -H ' ] ; if ( opts & & opts . type ) { params . push ( ' -t ' ) ; params . push ( opts . type ) ; } if ( opts & & opts . sort ) { params . push ( ' -s ' ) ; params . push ( opts . sort ) ; } if ( opts & & opts . recursive ) { params . push ( ' -r ' ) ; } if ( opts & & opts . name ) { params . push ( opts . name ) ; } zfs ( params , function ( err , stdout ) { if ( cb & & typeof cb = = = 'function ' ) { if ( err ) { cb ( err ) ; return ; } var lines = util . compact ( stdout . split ( ' \n ' ) ) ; var list = lines . map ( function ( x ) { return new ZFS ( x ) ; } ) ; cb ( err , list ) ; } } ) ; } 
function get ( opts , cb ) { "use strict " ; var params = [ 'get ' , ' -p H ' ] ; if ( opts . source ) { params . push ( ' -s ' , opts . source ) ; } params . push ( opts . property ) ; if ( opts . name ) { params . push ( opts . name ) ; } zfs ( params , function ( err , stdout ) { if ( cb & & typeof cb = = = 'function ' ) { if ( err ) return cb ( err ) ; var lines = util . compact ( stdout . split ( ' \n ' ) ) ; var list = lines . map ( function ( x ) { return new util . Property ( x ) ; } ) ; cb ( err , list ) ; } } ) ; } 
function destroy ( opts , cb ) { "use strict " ; var params = [ 'destroy ' ] ; if ( opts . recursive ) { params . push ( ' -r ' ) ; } params . push ( opts . name ) ; zfs ( params , cb ) ; } 
function create ( opts , cb ) { "use strict " ; var params = [ 'create ' ] ; if ( opts . options ) { if ( opts . options . length ) { 
function set ( opts , cb ) { "use strict " ; var params = [ 'set ' ] ; params . push ( opts . property + " = " + opts . value ) ; params . push ( opts . name ) ; zfs ( params , cb ) ; } 
function snapshot ( opts , cb ) { "use strict " ; var params = [ 'snapshot ' ] ; if ( opts . recursive ) { params . push ( ' -r ' ) ; } params . push ( opts . dataset + ' @ ' + opts . name ) ; zfs ( params , cb ) ; } 
function clone ( opts , cb ) { "use strict " ; var params = [ 'clone ' ] ; params . push ( opts . snapshot , opts . dataset ) ; zfs ( params , cb ) ; } 
function mount ( opts , cb ) { "use strict " ; var params = [ 'mount ' ] ; if ( opts . overlay ) { params . push ( ' -O ' ) ; } if ( opts . options ) { if ( opts . options . length ) { 
function unmount ( opts , cb ) { "use strict " ; var params = [ 'unmount ' ] ; if ( opts . force ) { params . push ( ' -f ' ) ; } if ( opts . name ) { params . push ( opts . name ) ; } else { params . push ( ' -a ' ) ; } zfs ( params , cb ) ; } 
function send ( opts , cb ) { "use strict " ; var params = [ 'send ' ] ; if ( opts . replication ) { params . push ( ' -R ' ) ; } if ( opts . deduplicate ) { params . push ( ' -D ' ) ; } if ( opts . properties ) { params . push ( ' -p ' ) ; } if ( opts . noop ) { params . push ( ' -n ' ) ; } if ( opts . parsable ) { params . push ( ' -P ' ) ; } if ( opts . verbose ) { params . push ( ' -v ' ) ; } if ( opts . incremental ) { if ( opts . intermediary ) { params . push ( ' -I ' ) ; } else { params . push ( ' -i ' ) ; } params . push ( opts . incremental ) ; } params . push ( opts . snapshot ) ; spawnzfs ( params , function ( err , child ) { if ( err ) { return cb ( err ) ; } var buffer = [ ] ; var send Stream = child . stdout ; child . stderr . on ( 'data ' , function ( data ) { data = data . to String ( ) ; buffer . push ( data ) ; if ( opts . verbose ) { send Stream . emit ( 'verbose ' , data ) ; } 
function receive ( opts , cb ) { "use strict " ; var params = [ 'receive ' ] ; if ( opts . verbose ) { params . push ( ' -v ' ) ; } if ( opts . noop ) { params . push ( ' -n ' ) ; } if ( opts . force ) { params . push ( ' -F ' ) ; } if ( opts . unmounted ) { params . push ( ' -u ' ) ; } if ( opts . d ) { params . push ( ' -d ' ) ; } if ( opts . e ) { params . push ( ' -e ' ) ; } params . push ( opts . dataset ) ; spawnzfs ( params , function ( err , child ) { if ( err ) { return cb ( err ) ; } var buffer = [ ] ; var receive Stream = child . stdin ; child . stderr . on ( 'data ' , function ( data ) { data = data . to String ( ) ; buffer . push ( data ) ; if ( opts . verbose ) { receive Stream . emit ( 'verbose ' , data ) ; } 
function copy String ( buffer , length , offset Begin , offset End ) { if ( length > 2 0 4 8 ) { return buffer . to String ( 'utf - 8 ' , offset Begin , offset End ) ; } var string = ' ' ; while ( offset Begin < offset End ) { string + = String . from Char Code ( buffer [ offset Begin + + ] ) ; } return string ; } 
function parse Simple String ( parser ) { var offset = parser . offset ; var length = parser . buffer . length ; var string = ' ' ; while ( offset < length ) { var c 1 = parser . buffer [ offset + + ] ; if ( c 1 = = = 1 3 ) { var c 2 = parser . buffer [ offset + + ] ; if ( c 2 = = = 1 0 ) { parser . offset = offset ; return string ; } string + = String . from Char Code ( c 1 ) + String . from Char Code ( c 2 ) ; continue ; } string + = String . from Char Code ( c 1 ) ; } return undefined ; } 
function get Base Config ( is Prod ) { 
function get Update Info ( update ) { let is Chosen = false ; let is Edited = false ; let original = ' ' ; let name = ' ' ; if ( update . message ) { name = 'message ' ; original = 'message ' ; } else if ( update . edited _message ) { is Edited = true ; original = 'edited _message ' ; name = 'message ' ; } else if ( update . channel _post ) { original = 'channel _post ' ; name = 'post ' ; } else if ( update . edited _channel _post ) { is Edited = true ; original = 'edited _channel _post ' ; name = 'post ' ; } else if ( update . inline _query ) { original = 'inline _query ' ; name = 'inline ' ; } else if ( update . chosen _inline _result ) { is Chosen = true ; original = 'chosen _inline _result ' ; name = 'inline ' ; } else if ( update . callback _query ) { original = 'callback _query ' ; name = 'callback ' ; } return { is Chosen , is Edited , original , name } ; } 
function attach Stream To Socket ( read Stream , socket Write Stream , callback , use Pipe = false ) { if ( ! use Pipe ) { _attach Stream To Socket ( read Stream , socket Write Stream , callback ) ; } else { read Stream . pipe ( socket Write Stream , { end : false } ) ; read Stream . once ( 'end ' , ( ) = > { read Stream . unpipe ( ) ; callback ( ) ; } ) ; } } 
function post Notification ( options , cb ) { options . title = remove Color ( options . title ) ; options . message = remove Color ( options . message ) ; if ( ! options . message ) { return cb & & cb ( ! options . message & & 'Message is required ' ) ; } if ( ! notify Platform ) { notify Platform = choose Platform ( ) ; } function reset Previous Timer ( new Message ) { previous Message = new Message ; clear Timeout ( previous Message Timer ) ; previous Message Timer = set Timeout ( function ( ) { previous Message = false ; } , previous Message Timeout MS ) ; } if ( options . message = = = previous Message ) { reset Previous Timer ( options . message ) ; if ( typeof cb = = = 'function ' ) { cb ( err ) ; } return ; } reset Previous Timer ( options . message ) ; options . debug = debug ( notify Platform . name ) ; 
function Compiler ( file , options ) { this . options = options | | { } ; this . parser = new Parser ( file , options ) ; this . compilers = { } ; this . files = [ ] ; this . file = file ; this . files = [ this . file ] ; this . result = ' ' ; } 
function dry ( file , options ) { debug ( 'rendering < %s > ' , file . path ) ; var opts = utils . extend ( { } , options ) ; dry . parse ( file , opts ) ; dry . compile ( file , opts ) ; file . fn ( opts . locals ) ; return file ; } 
function generate Username ( base ) { base = base . to Lower Case ( ) ; var entries = [ ] ; var final Name ; return user DB . all Docs ( { startkey : base , endkey : base + ' \uffff ' , include _docs : false } ) . then ( function ( results ) { if ( results . rows . length = = = 0 ) { return BPromise . resolve ( base ) ; } for ( var i = 0 ; i < results . rows . length ; i + + ) { entries . push ( results . rows [ i ] . id ) ; } if ( entries . index Of ( base ) = = = - 1 ) { return BPromise . resolve ( base ) ; } var num = 0 ; while ( ! final Name ) { num + + ; if ( entries . index Of ( base + num ) = = = - 1 ) { final Name = base + num ; } } return BPromise . resolve ( final Name ) ; } ) ; } 
function init Session ( req , res , next ) { var provider = get Provider ( req . path ) ; return user . create Session ( req . user . _id , provider , req ) . then ( function ( my Session ) { return BPromise . resolve ( { error : null , session : my Session , link : null } ) ; } ) . then ( function ( results ) { var template ; if ( config . get Item ( 'test Mode .oauth Test ' ) ) { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback -test .ejs ' ) , 'utf 8 ' ) ; } else { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback .ejs ' ) , 'utf 8 ' ) ; } var html = ejs . render ( template , results ) ; res . status ( 2 0 0 ) . send ( html ) ; } , function ( err ) { return next ( err ) ; } ) ; } 
function init Token Session ( req , res , next ) { var provider = get Provider Token ( req . path ) ; return user . create Session ( req . user . _id , provider , req ) . then ( function ( my Session ) { return BPromise . resolve ( my Session ) ; } ) . then ( function ( session ) { res . status ( 2 0 0 ) . json ( session ) ; } , function ( err ) { return next ( err ) ; } ) ; } 
function link Success ( req , res , next ) { var provider = get Provider ( req . path ) ; var result = { error : null , session : null , link : provider } ; var template ; if ( config . get Item ( 'test Mode .oauth Test ' ) ) { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback -test .ejs ' ) , 'utf 8 ' ) ; } else { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback .ejs ' ) , 'utf 8 ' ) ; } var html = ejs . render ( template , result ) ; res . status ( 2 0 0 ) . send ( html ) ; } 
function link Token Success ( req , res , next ) { var provider = get Provider Token ( req . path ) ; res . status ( 2 0 0 ) . json ( { ok : true , success : util . capitalize First Letter ( provider ) + ' successfully linked ' , provider : provider } ) ; } 
function oauth Error Handler ( err , req , res , next ) { var template ; if ( config . get Item ( 'test Mode .oauth Test ' ) ) { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback -test .ejs ' ) , 'utf 8 ' ) ; } else { template = fs . read File Sync ( path . join ( _ _dirname , ' . . /templates /oauth /auth -callback .ejs ' ) , 'utf 8 ' ) ; } var html = ejs . render ( template , { error : err . message , session : null , link : null } ) ; console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; } res . status ( 4 0 0 ) . send ( html ) ; } 
function token Auth Error Handler ( err , req , res , next ) { var status ; if ( req . user & & req . user . _id ) { status = 4 0 3 ; } else { status = 4 0 1 ; } console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; delete err . stack ; } res . status ( status ) . json ( err ) ; } 
function register Provider ( provider , config Function ) { provider = provider . to Lower Case ( ) ; var config Ref = 'providers . ' + provider ; if ( config . get Item ( config Ref + ' .credentials ' ) ) { var credentials = config . get Item ( config Ref + ' .credentials ' ) ; credentials . pass Req To Callback = true ; var options = config . get Item ( config Ref + ' .options ' ) | | { } ; config Function . call ( null , credentials , passport , auth Handler ) ; router . get ( ' / ' + provider , passport Callback ( provider , options , 'login ' ) ) ; router . get ( ' / ' + provider + ' /callback ' , passport Callback ( provider , options , 'login ' ) , init Session , oauth Error Handler ) ; if ( ! config . get Item ( 'security .disable Link Accounts ' ) ) { router . get ( ' /link / ' + provider , passport . authenticate ( 'bearer ' , { session : false } ) , passport Callback ( provider , options , 'link ' ) ) ; router . get ( ' /link / ' + provider + ' /callback ' , passport . authenticate ( 'bearer ' , { session : false } ) , passport Callback ( provider , options , 'link ' ) , link Success , oauth Error Handler ) ; } console . log ( provider + ' loaded . ' ) ; } } 
function register OAuth 2 ( provider Name , Strategy ) { register Provider ( provider Name , function ( credentials , passport , auth Handler ) { passport . use ( new Strategy ( credentials , function ( req , access Token , refresh Token , profile , done ) { auth Handler ( req , provider Name , { access Token : access Token , refresh Token : refresh Token } , profile ) . as Callback ( done ) ; } ) ) ; } ) ; } 
function register Token Provider ( provider Name , Strategy ) { provider Name = provider Name . to Lower Case ( ) ; var config Ref = 'providers . ' + provider Name ; if ( config . get Item ( config Ref + ' .credentials ' ) ) { var credentials = config . get Item ( config Ref + ' .credentials ' ) ; credentials . pass Req To Callback = true ; var options = config . get Item ( config Ref + ' .options ' ) | | { } ; 
function auth Handler ( req , provider , auth , profile ) { if ( req . user & & req . user . _id & & req . user . key ) { return user . link Social ( req . user . _id , provider , auth , profile , req ) ; } else { return user . social Auth ( provider , auth , profile , req ) ; } } 
function passport Callback ( provider , options , operation ) { return function ( req , res , next ) { var the Options = extend ( { } , options ) ; if ( provider = = = 'linkedin ' ) { the Options . state = true ; } var access Token = req . query . bearer _token | | req . query . state ; if ( access Token & & ( state Required . index Of ( provider ) > - 1 | | config . get Item ( 'providers . ' + provider + ' .state Required ' ) = = = true ) ) { the Options . state = access Token ; } the Options . callback URL = get Link Callback URLs ( provider , req , operation , access Token ) ; the Options . session = false ; passport . authenticate ( provider , the Options ) ( req , res , next ) ; } ; } 
function passport Token Callback ( provider , options ) { return function ( req , res , next ) { var the Options = extend ( { } , options ) ; the Options . session = false ; passport . authenticate ( provider + ' -token ' , the Options ) ( req , res , next ) ; } ; } 
function get Provider ( pathname ) { var items = pathname . split ( ' / ' ) ; var index = items . index Of ( 'callback ' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } } 
function get Provider Token ( pathname ) { var items = pathname . split ( ' / ' ) ; var index = items . index Of ( 'token ' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } } 
function require Role ( required Role ) { return function ( req , res , next ) { if ( ! req . user ) { return next ( superlogin Error ) ; } var roles = req . user . roles ; if ( ! roles | | ! roles . length | | roles . index Of ( required Role ) = = = - 1 ) { res . status ( forbidden Error . status ) ; res . json ( forbidden Error ) ; } else { next ( ) ; } } ; } 
function get Legal DBName ( input ) { input = input . to Lower Case ( ) ; var output = encode URIComponent ( input ) ; output = output . replace ( / \ . / g , ' % 2E ' ) ; output = output . replace ( / ! / g , ' % 2 1 ' ) ; output = output . replace ( / ~ / g , ' % 7E ' ) ; output = output . replace ( / \ * / g , ' % 2A ' ) ; output = output . replace ( / ' / g , ' % 2 7 ' ) ; output = output . replace ( / \ ( / g , ' % 2 8 ' ) ; output = output . replace ( / \ ) / g , ' % 2 9 ' ) ; output = output . replace ( / \ - / g , ' % 2D ' ) ; output = output . to Lower Case ( ) ; output = output . replace ( / ( % . . ) / g , function ( esc ) { esc = esc . substr ( 1 ) ; return ' ( ' + esc + ' ) ' ; } ) ; return output ; } 
function File Adapter ( config ) { var sessions Root = config . get Item ( 'session .file .sessions Root ' ) ; this . _session Folder = path . join ( process . env . PWD , sessions Root ) ; console . log ( 'File Adapter loaded ' ) ; } 
function ( ) { var found Layer = null ; $ . each ( projected Tiles , function ( layer Name , layer ) { if ( map . has Layer ( layer ) ) { found Layer = layer ; } } ) ; return found Layer ; } 
function ( tile Layer ) { if ( this . options . changing Map ) { return false ; } 
function ( ) { for ( var i in this . _layers ) { this . remove Layer ( this . _layers [ i ] ) ; } L . Map . prototype . remove . call ( this ) ; return this ; } 
function ( crs , options ) { var resolutions = [ ] ; for ( var zoom = options . min Zoom ; zoom < = options . max Zoom ; zoom + + ) { resolutions . push ( options . max Resolution / Math . pow ( 2 , zoom ) ) ; } return new L . Proj . CRS ( crs , options . proj 4def , { origin : options . origin , resolutions : resolutions , bounds : options . projected Bounds } ) ; } 
function ( crs , options ) { switch ( crs ) { case "EPSG : 3 8 5 7 " : return L . CRS . EPSG 3 8 5 7 ; case "EPSG : 3 3 9 5 " : return L . CRS . EPSG 3 3 9 5 ; case "EPSG : 4 3 2 6 " : return L . CRS . EPSG 4 3 2 6 ; default : return this . _define Map CRS ( crs , options ) ; } } 
function ( group ) { var map = this ; if ( group . each Layer ) { group . each Layer ( function ( layer ) { map . _update All Layers ( layer ) ; } ) ; } else { if ( group . redraw ) { group . redraw ( ) ; } else if ( group . update ) { group . update ( ) ; } else { console . log ( "Don 't know how to update " , group ) ; } } } 
function ( layers Array ) { var fg = this . _feature Group , npg = this . _non Point Group , chunked = this . options . chunked Loading , chunk Interval = this . options . chunk Interval , chunk Progress = this . options . chunk Progress , new Markers , i , l , m ; if ( this . _map ) { var offset = 0 , started = ( new Date ( ) ) . get Time ( ) ; var process = L . bind ( function ( ) { var start = ( new Date ( ) ) . get Time ( ) ; for ( ; offset < layers Array . length ; offset + + ) { if ( chunked & & offset % 2 0 0 = = = 0 ) { 
function ( layers Array ) { var i , l , m , fg = this . _feature Group , npg = this . _non Point Group ; if ( ! this . _map ) { for ( i = 0 , l = layers Array . length ; i < l ; i + + ) { m = layers Array [ i ] ; this . _array Splice ( this . _needs Clustering , m ) ; npg . remove Layer ( m ) ; } return this ; } for ( i = 0 , l = layers Array . length ; i < l ; i + + ) { m = layers Array [ i ] ; if ( ! m . _ _parent ) { npg . remove Layer ( m ) ; continue ; } this . _remove Layer ( m , true , true ) ; if ( fg . has Layer ( m ) ) { fg . remove Layer ( m ) ; if ( m . set Opacity ) { m . set Opacity ( 1 ) ; } } } 
function ( ) { var bounds = new L . Lat Lng Bounds ( ) ; if ( this . _top Cluster Level ) { bounds . extend ( this . _top Cluster Level . _bounds ) ; } for ( var i = this . _needs Clustering . length - 1 ; i > = 0 ; i - - ) { bounds . extend ( this . _needs Clustering [ i ] . get Lat Lng ( ) ) ; } bounds . extend ( this . _non Point Group . get Bounds ( ) ) ; return bounds ; } 
function ( method , context ) { var markers = this . _needs Clustering . slice ( ) , i ; if ( this . _top Cluster Level ) { this . _top Cluster Level . get All Child Markers ( markers ) ; } for ( i = markers . length - 1 ; i > = 0 ; i - - ) { method . call ( context , markers [ i ] ) ; } this . _non Point Group . each Layer ( method , context ) ; } 
function ( id ) { var result = null ; this . each Layer ( function ( l ) { if ( L . stamp ( l ) = = = id ) { result = l ; } } ) ; return result ; } 
function ( layer ) { if ( ! layer ) { return false ; } var i , an Array = this . _needs Clustering ; for ( i = an Array . length - 1 ; i > = 0 ; i - - ) { if ( an Array [ i ] = = = layer ) { return true ; } } an Array = this . _needs Removing ; for ( i = an Array . length - 1 ; i > = 0 ; i - - ) { if ( an Array [ i ] = = = layer ) { return false ; } } return ! ! ( layer . _ _parent & & layer . _ _parent . _group = = = this ) | | this . _non Point Group . has Layer ( layer ) ; } 
function ( layer , callback ) { var show Marker = function ( ) { if ( ( layer . _icon | | layer . _ _parent . _icon ) & & ! this . _in Zoom Animation ) { this . _map . off ( 'moveend ' , show Marker , this ) ; this . off ( 'animationend ' , show Marker , this ) ; if ( layer . _icon ) { callback ( ) ; } else if ( layer . _ _parent . _icon ) { var after Spiderfy = function ( ) { this . off ( 'spiderfied ' , after Spiderfy , this ) ; callback ( ) ; } ; this . on ( 'spiderfied ' , after Spiderfy , this ) ; layer . _ _parent . spiderfy ( ) ; } } } ; if ( layer . _icon & & this . _map . get Bounds ( ) . contains ( layer . get Lat Lng ( ) ) ) { 
function ( map ) { this . _map = map ; var i , l , layer ; if ( ! is Finite ( this . _map . get Max Zoom ( ) ) ) { throw "Map has no max Zoom specified " ; } this . _feature Group . on Add ( map ) ; this . _non Point Group . on Add ( map ) ; if ( ! this . _grid Clusters ) { this . _generate Initial Clusters ( ) ; } for ( i = 0 , l = this . _needs Removing . length ; i < l ; i + + ) { layer = this . _needs Removing [ i ] ; this . _remove Layer ( layer , true ) ; } this . _needs Removing = [ ] ; 
function ( map ) { map . off ( 'zoomend ' , this . _zoom End , this ) ; map . off ( 'moveend ' , this . _move End , this ) ; this . _unbind Events ( ) ; 
function ( an Array , obj ) { for ( var i = an Array . length - 1 ; i > = 0 ; i - - ) { if ( an Array [ i ] = = = obj ) { an Array . splice ( i , 1 ) ; return true ; } } } 
function ( marker , remove From Distance Grid , dont Update Map ) { var grid Clusters = this . _grid Clusters , grid Unclustered = this . _grid Unclustered , fg = this . _feature Group , map = this . _map ; 
function ( cluster ) { var child Count = cluster . get Child Count ( ) ; var c = ' marker -cluster - ' ; if ( child Count < 1 0 ) { c + = 'small ' ; } else if ( child Count < 1 0 0 ) { c + = 'medium ' ; } else { c + = 'large ' ; } return new L . Div Icon ( { html : ' <div > <span > ' + child Count + ' < /span > < /div > ' , class Name : 'marker -cluster ' + c , icon Size : new L . Point ( 4 0 , 4 0 ) } ) ; } 
function ( layer , zoom ) { var grid Clusters = this . _grid Clusters , grid Unclustered = this . _grid Unclustered , marker Point , z ; if ( this . options . single Marker Mode ) { layer . options . icon = this . options . icon Create Function ( { get Child Count : function ( ) { return 1 ; } , get All Child Markers : function ( ) { return [ layer ] ; } } ) ; } 
function ( fn ) { this . _queue . push ( fn ) ; if ( ! this . _queue Timeout ) { this . _queue Timeout = set Timeout ( L . bind ( this . _process Queue , this ) , 3 0 0 ) ; } } 
function ( ) { if ( ! this . options . remove Outside Visible Bounds ) { return this . get Bounds ( ) ; } var map = this . _map , bounds = map . get Bounds ( ) , sw = bounds . _south West , ne = bounds . _north East , lat Diff = L . Browser . mobile ? 0 : Math . abs ( sw . lat - ne . lat ) , lng Diff = L . Browser . mobile ? 0 : Math . abs ( sw . lng - ne . lng ) ; return new L . Lat Lng Bounds ( new L . Lat Lng ( sw . lat - lat Diff , sw . lng - lng Diff , true ) , new L . Lat Lng ( ne . lat + lat Diff , ne . lng + lng Diff , true ) ) ; } 
function ( layer , new Cluster ) { if ( new Cluster = = = layer ) { this . _feature Group . add Layer ( layer ) ; } else if ( new Cluster . _child Count = = = 2 ) { new Cluster . _add To Map ( ) ; var markers = new Cluster . get All Child Markers ( ) ; this . _feature Group . remove Layer ( markers [ 0 ] ) ; this . _feature Group . remove Layer ( markers [ 1 ] ) ; } else { new Cluster . _update Icon ( ) ; } } 
function ( storage Array ) { storage Array = storage Array | | [ ] ; for ( var i = this . _child Clusters . length - 1 ; i > = 0 ; i - - ) { this . _child Clusters [ i ] . get All Child Markers ( storage Array ) ; } for ( var j = this . _markers . length - 1 ; j > = 0 ; j - - ) { storage Array . push ( this . _markers [ j ] ) ; } return storage Array ; } 
function ( ) { var child Clusters = this . _child Clusters . slice ( ) , map = this . _group . _map , bounds Zoom = map . get Bounds Zoom ( this . _bounds ) , zoom = this . _zoom + 1 , map Zoom = map . get Zoom ( ) , i ; 
function ( marker ) { var added Count , added Lat Lng = marker . _w Lat Lng | | marker . _latlng ; if ( marker instanceof L . Marker Cluster ) { this . _bounds . extend ( marker . _bounds ) ; added Count = marker . _child Count ; } else { this . _bounds . extend ( added Lat Lng ) ; added Count = 1 ; } if ( ! this . _c Lat Lng ) { 
function ( previous Bounds , zoom Level , except Bounds ) { var m , i ; this . _recursively ( previous Bounds , - 1 , zoom Level - 1 , function ( c ) { 
function ( bounds To Apply To , zoom Level To Start , zoom Level To Stop , run At Every Level , run At Bottom Level ) { var child Clusters = this . _child Clusters , zoom = this . _zoom , i , c ; if ( zoom Level To Start > zoom ) { 
function ( lat Lngs ) { 
function ( ) { if ( this . _group . _spiderfied = = = this | | this . _group . _in Zoom Animation ) { return ; } var child Markers = this . get All Child Markers ( ) , group = this . _group , map = group . _map , center = map . lat Lng To Layer Point ( this . _latlng ) , positions ; this . _group . _unspiderfy ( ) ; this . _group . _spiderfied = this ; 
function ( child Markers , positions ) { var group = this . _group , map = group . _map , fg = group . _feature Group , i , m , leg , new Pos ; for ( i = child Markers . length - 1 ; i > = 0 ; i - - ) { new Pos = map . layer Point To Lat Lng ( positions [ i ] ) ; m = child Markers [ i ] ; m . _pre Spiderfy Latlng = m . _latlng ; m . set Lat Lng ( new Pos ) ; if ( m . set ZIndex Offset ) { m . set ZIndex Offset ( 1 0 0 0 0 0 0 ) ; 
function ( layer ) { if ( layer . _spider Leg ) { this . _feature Group . remove Layer ( layer ) ; layer . set Opacity ( 1 ) ; 
function ( projection ) { for ( var key in projected Tiles ) { if ( projected Tiles . has Own Property ( key ) ) { if ( key . index Of ( projection ) ! = = - 1 ) { return projected Tiles [ key ] ; } } } return null ; } 
function ( projection ) { for ( var key in tiles ) { if ( tiles . has Own Property ( key ) ) { if ( key . index Of ( projection ) ! = = - 1 ) { return tiles [ key ] ; } } } return null ; } 
function add To Map ( location , map ) { var marker = L . marker ( location . coordinates ) ; marker . add To ( map ) ; } 
function ( feature Data , layer ) { var coords = feature Data . geometry . coordinates ; return bounds Limit . contains ( L . lat Lng ( [ coords [ 1 ] , coords [ 0 ] ] ) ) ; } 
function ( feature Data , layer ) { var bbox = feature Data . geometry . bbox ; var ll Bounds = L . lat Lng Bounds ( [ bbox [ 1 ] , bbox [ 0 ] ] , [ bbox [ 3 ] , bbox [ 2 ] ] ) ; return bounds Limit . contains ( ll Bounds ) ; } 
function interpolate ( path , data ) { return path . replace ( / : ( \w + ) / g , function ( match , param ) { return data [ param ] } ) } 
function create Pages Utility ( pages , index ) { return function get Pages ( number ) { var offset = Math . floor ( number / 2 ) var start , end if ( index + offset > = pages . length ) { start = Math . max ( 0 , pages . length - number ) end = pages . length } else { start = Math . max ( 0 , index - offset ) end = Math . min ( start + number , pages . length ) } return pages . slice ( start , end ) } } 
function ( ) { var templates = { data : { } } ; var string Template Source = function ( template ) { this . text = function ( value ) { if ( arguments . length = = = 0 ) { return templates [ template ] ; } templates [ template ] = value ; } ; } ; var template Engine = new ko . native Template Engine ( ) ; template Engine . make Template Source = function ( template ) { return new string Template Source ( template ) ; } ; template Engine . add Template = function ( key , value ) { templates [ key ] = value ; } ; return template Engine ; } 
function before Child ( parser State , compiler State , result , check Parent ) { var _is Dom Method = check Parent ! = = true ? is Dom Method ( compiler State ) : is Parent Dom Method ( compiler State ) ; var _num Attributes = check Parent ! = = true ? num Attributes ( parser State ) : num Parent Attributes ( parser State ) ; var _num Children = check Parent ! = = true ? num Children ( parser State ) : num Parent Children ( parser State ) ; var _is Top Level Child = check Parent ! = = true ? parser State . child Counts . length > 1 : parser State . child Counts . length > 2 ; if ( _is Top Level Child = = = true ) { if ( _num Attributes < = 0 ) { if ( _num Children < = 1 ) { if ( _is Dom Method ! = = true ) { 
function Job ( collection , data ) { this . collection = collection ; if ( data ) { 
function Worker ( queues , options ) { options | | ( options = { } ) ; this . empty = 0 ; this . queues = queues | | [ ] ; this . interval = options . interval | | 5 0 0 0 ; this . callbacks = options . callbacks | | { } ; this . strategies = options . strategies | | { } ; this . universal = options . universal | | false ; 
function Uploader ( options ) { if ( typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } this . $el = this . _get Element ( options . el ) ; this . _el Type = this . $el . tag Name . to Lower Case ( ) ; 
function handle Drag Events ( e ) { e . stop Propagation ( ) ; e . prevent Default ( ) ; return this . emit ( e . type , e ) ; } 
function format Record By Column Label ( recode ) { const recode Buffer = { } ; recode . for Each ( function ( value , index ) { recode Buffer [ new Ordinal ( index + 1 ) . to Alphabet ( ) ] = value ; } ) ; return recode Buffer ; } 
function format Record By Mapping ( recode , mapping ) { return Object . keys ( mapping ) . reduce ( ( formatted , key Name ) = > { if ( mapping [ key Name ] ! = = 0 ) { formatted [ key Name ] = recode [ new Ordinal ( mapping [ key Name ] ) . to Number ( ) - 1 ] ; } return formatted ; } , { } ) ; } 
function ( device Info ) { this . _handle = device Info . _handle ; this . address = device Info . _handle ; this . name = device Info . name ; this . service UUIDs = device Info . uuids ; this . ad Data = device Info . ad Data ; this . connected = false ; this . services = { } ; } 
function ( service Info ) { this . _handle = service Info . _handle ; this . uuid = service Info . uuid ; this . primary = service Info . primary ; this . included Services = { } ; this . characteristics = { } ; } 
function ( characteristic Info ) { this . _handle = characteristic Info . _handle ; this . uuid = characteristic Info . uuid ; this . properties = characteristic Info . properties ; this . descriptors = { } ; } 
function streamify Gulp ( plugin Stream ) { var input Stream = new Stream . Transform ( { object Mode : true } ) ; var output Stream = new Stream . Transform ( { object Mode : true } ) ; var duplex = new Duplexer ( { object Mode : true } , input Stream , output Stream ) ; 
function ( value ) { if ( value ! = value | | value = = = 0 ) { for ( var i = this . length ; i - - & & ! is ( this [ i ] , value ) ; ) { } } else { i = [ ] . index Of . call ( this , value ) ; } return i ; } 
function Tor ( child , port , dir ) { this . process = child ; this . port = port ; this . dir = dir ; } 
function get Included ( ) { var args = config . files ( ) . included | | get Default Args ( ) | | get Package Json Args ( ) | | get Bower Json Args ( ) | | [ ] ; return _expand Globs ( args ) ; } 
function get Default Args ( ) { var results = [ ] ; DEFAULT _PATHS . for Each ( function ( dir ) { if ( fs . exists Sync ( dir ) ) results . push ( dir ) ; } ) ; return results . length = = 0 ? null : results ; } 
function get Package Json Args ( ) { var results = [ ] ; var config = _load Json ( 'package .json ' ) ; if ( config . main ) results = results . concat ( get Main Field As Array ( config . main ) ) ; if ( config . files ) results = results . concat ( config . files ) ; return results . length = = 0 ? null : results . filter ( _uniqfilter ) ; } 
function get Bower Json Args ( ) { var results = [ ] ; var config = _load Json ( 'bower .json ' ) ; if ( config . main ) results = results . concat ( get Main Field As Array ( config . main ) ) ; return results . length = = 0 ? null : results . filter ( _uniqfilter ) ; } 
function get Main Field As Array ( main ) { if ( main . constructor = = = Array ) { return main ; } else { if ( fs . exists Sync ( main ) ) { return [ main ] ; } else if ( fs . exists Sync ( main + ' .js ' ) ) { return [ main + ' .js ' ] ; } else { return [ ] ; } } } 
function is Module Function 2 ( doclet ) { return doclet . longname & & doclet . longname = = = doclet . name & & doclet . longname . index Of ( 'module : ' ) = = = 0 & & doclet . kind = = = 'function ' ; } 
function get Members 2 ( data ) { var find = function ( data , spec ) { return data ( spec ) . get ( ) ; } ; var members = { classes : find ( data , { kind : 'class ' } ) , externals : find ( data , { kind : 'external ' } ) , events : find ( data , { kind : 'event ' } ) , globals : find ( data , { kind : [ 'member ' , 'function ' , 'constant ' , 'typedef ' ] , memberof : { is Undefined : true } } ) , mixins : find ( data , { kind : 'mixin ' } ) , modules : find ( data , { kind : 'module ' } ) , namespaces : find ( data , { kind : 'namespace ' } ) , typedef : find ( data , { kind : 'typedef ' , is TSEnum : { is : true } } ) , callbacks : find ( data , { kind : 'typedef ' , is TSEnum : { is Undefined : true } } ) } ; 
function ( field , reverse , primer ) { var key = function ( x ) { return primer ? primer ( x [ field ] ) : x [ field ] } ; return function ( a , b ) { var A = key ( a ) , B = key ( b ) ; return ( ( A < B ) ? - 1 : ( ( A > B ) ? 1 : 0 ) ) * [ - 1 , 1 ] [ + ! ! reverse ] ; } } 
function build Nav ( members ) { var seen = { } ; var nav = navigation Master ; if ( members . modules . length ) { members . modules . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . modules . for Each ( function ( m ) { if ( ! has Own Prop . call ( seen , m . longname ) ) { nav . module . members . push ( linkto ( m . longname , m . name ) ) ; } seen [ m . longname ] = true ; } ) ; } if ( members . externals . length ) { members . externals . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . externals . for Each ( function ( e ) { if ( ! has Own Prop . call ( seen , e . longname ) ) { nav . external . members . push ( linkto ( e . longname , e . name . replace ( / ( ^ " | " $ ) / g , ' ' ) ) ) ; } seen [ e . longname ] = true ; } ) ; } if ( members . classes . length ) { members . classes . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . classes . for Each ( function ( c ) { if ( ! has Own Prop . call ( seen , c . longname ) ) { nav . class . members . push ( { link : linkto ( c . longname , c . longname ) , namespace : c } ) ; } seen [ c . longname ] = true ; } ) ; } if ( members . typedef . length ) { members . typedef . for Each ( function ( td ) { if ( ! has Own Prop . call ( seen , td . longname ) ) { nav . typedef . members . push ( { link : linkto ( td . name , td . name ) , namespace : { longname : td . longname } } ) ; } seen [ td . longname ] = true ; } ) ; } if ( members . callbacks . length ) { members . callbacks . for Each ( function ( cb ) { if ( ! has Own Prop . call ( seen , cb . longname ) ) { nav . callbacks . members . push ( { link : linkto ( cb . longname , cb . longname . split ( ' # ' ) [ 0 ] ) , namespace : { longname : cb . longname } } ) ; } seen [ cb . longname ] = true ; } ) ; } if ( members . namespaces . length ) { members . namespaces . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . namespaces . for Each ( function ( n ) { if ( ! has Own Prop . call ( seen , n . longname ) ) { nav . namespace . members . push ( { link : linkto ( n . longname , n . longname ) , namespace : n } ) ; } seen [ n . longname ] = true ; } ) ; } if ( members . mixins . length ) { members . mixins . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . mixins . for Each ( function ( m ) { if ( ! has Own Prop . call ( seen , m . longname ) ) { nav . mixin . members . push ( linkto ( m . longname , m . longname ) ) ; } seen [ m . longname ] = true ; } ) ; } if ( members . tutorials . length ) { members . tutorials . sort ( sort _by ( 'name ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . tutorials . for Each ( function ( t ) { nav . tutorial . members . push ( tutoriallink ( t . name ) ) ; } ) ; } if ( members . globals . length ) { members . globals . sort ( sort _by ( 'longname ' , true , function ( a ) { return a . to Upper Case ( ) } ) ) ; members . globals . for Each ( function ( g ) { if ( g . kind ! = = 'typedef ' & & ! has Own Prop . call ( seen , g . longname ) ) { nav . global . members . push ( linkto ( g . longname , g . longname ) ) ; } seen [ g . longname ] = true ; } ) ; } var top Level Nav = [ ] ; _ . each ( nav , function ( entry , name ) { if ( entry . members . length > 0 & & name ! = = "index " ) { top Level Nav . push ( { title : entry . title , link : entry . link , members : entry . members } ) ; } } ) ; nav . top Level Nav = top Level Nav ; } 
function ( objects , inch _args ) { var cwd = process . cwd ( ) ; var excluded = config . files ( ) . excluded | | [ ] ; var data = { language : 'javascript ' , client _name : 'inchjs ' , args : inch _args , client _version : " " + inch _config . version , git _repo _url : get Git Repo URL ( ) } ; if ( process . env . TRAVIS ) { data [ 'travis ' ] = true ; data [ 'travis _job _id ' ] = process . env . TRAVIS _JOB _ID ; data [ 'travis _commit ' ] = process . env . TRAVIS _COMMIT ; data [ 'travis _repo _slug ' ] = process . env . TRAVIS _REPO _SLUG ; } data [ 'branch _name ' ] = get Git Branch Name ( ) ; data [ 'objects ' ] = objects . filter ( include Object Filter ) . map ( function ( item ) { return prepare Code Object ( item , cwd ) ; } ) . filter ( function ( item ) { return ! exclude Object If Match ( item , excluded ) ; } ) ; return data ; } 
function Tor Agent ( opts ) { if ( ! ( this instanceof Tor Agent ) ) { return new Tor Agent ( ) ; } http . Agent . call ( this , opts ) ; this . socks Host = opts . socks Host | | 'localhost ' ; this . socks Port = opts . socks Port | | 9 0 5 0 ; this . default Port = 8 0 ; 
function ( element , options ) { this . $element = $ ( element ) ; this . options = $ . extend ( true , { } , $ . fn . typeahead . defaults , options ) ; this . $menu = $ ( this . options . menu ) . append To ( 'body ' ) ; this . shown = false ; 
function ( ) { var that = this , query = that . $element . val ( ) ; if ( query = = = that . query ) { return that ; } 
function ( query ) { this . ajax Toggle Load Class ( true ) ; 
function ( data ) { var items ; this . ajax Toggle Load Class ( false ) ; if ( ! this . ajax . xhr ) return ; if ( this . ajax . pre Process ) { data = this . ajax . pre Process ( data ) ; } 
function ( event ) { var that = this , items ; if ( that . ajax ) { that . ajaxer ( ) ; } else { that . query = that . $element . val ( ) ; if ( ! that . query ) { return that . shown ? that . hide ( ) : that ; } items = that . grepper ( that . source ) ; if ( ! items | | ! items . length ) { return that . shown ? that . hide ( ) : that ; } return that . render ( items . slice ( 0 , that . options . items ) ) . show ( ) ; } } 
function ( data ) { var that = this , items ; if ( data & & data . length & & ! data [ 0 ] . has Own Property ( that . options . display ) ) { return null ; } items = $ . grep ( data , function ( item ) { return that . matcher ( item [ that . options . display ] , item ) ; } ) ; return this . sorter ( items ) ; } 
function ( items ) { var that = this , beginswith = [ ] , case Sensitive = [ ] , case Insensitive = [ ] , item ; while ( item = items . shift ( ) ) { if ( ! item [ that . options . display ] . to Lower Case ( ) . index Of ( this . query . to Lower Case ( ) ) ) { beginswith . push ( item ) ; } else if ( ~ item [ that . options . display ] . index Of ( this . query ) ) { case Sensitive . push ( item ) ; } else { case Insensitive . push ( item ) ; } } return beginswith . concat ( case Sensitive , case Insensitive ) ; } 
function ( item ) { var query = this . query . replace ( / [ \ - \ [ \ ] { } ( ) * + ? . , \ \ \ ^ $ | # \s ] / g , ' \ \ $ & ' ) ; return item . replace ( new Reg Exp ( ' ( ' + query + ' ) ' , 'ig ' ) , function ( $ 1 , match ) { return ' <strong > ' + match + ' < /strong > ' ; } ) ; } 
function ( items ) { var that = this ; items = $ ( items ) . map ( function ( i , item ) { i = $ ( that . options . item ) . attr ( 'data -value ' , item [ that . options . val ] ) ; i . find ( 'a ' ) . html ( that . highlighter ( item [ that . options . display ] , item ) ) ; return i [ 0 ] ; } ) ; items . first ( ) . add Class ( 'active ' ) ; this . $menu . html ( items ) ; return this ; } 
function ( event ) { var active = this . $menu . find ( ' .active ' ) . remove Class ( 'active ' ) ; var next = active . next ( ) ; if ( ! next . length ) { next = $ ( this . $menu . find ( 'li ' ) [ 0 ] ) ; } next . add Class ( 'active ' ) ; } 
function ( e ) { e . stop Propagation ( ) ; if ( ! this . shown ) { return ; } switch ( e . key Code ) { case 9 : 
function ( e ) { var that = this ; e . stop Propagation ( ) ; e . prevent Default ( ) ; set Timeout ( function ( ) { if ( ! that . $menu . is ( ' :focus ' ) ) { that . hide ( ) ; } } , 1 5 0 ) } 
function run ( inch _args , options ) { var callback = function ( filename ) { Local Inch . run ( inch _args | | [ 'suggest ' ] , filename , noop ) ; } if ( options . dry _run ) callback = noop ; retriever . run ( Path Extractor . extract Paths ( inch _args ) , callback ) ; } 
function ( options , callback ) { var data = options . data ; var target = options . target ; var features = options . features ; var feature Types = options . feature Types ; feature Types . for Each ( function ( f ) { if ( [ 'number ' , 'category ' ] . index Of ( f ) = = = - 1 ) { callback ( new Error ( 'Unrecognized feature type ' ) ) ; return ; } } ) ; var targets = unique ( data . map ( function ( d ) { return d [ d . length - 1 ] ; } ) ) ; this . features = features ; this . targets = targets ; this . target = target var classify = this . classify . bind ( this ) var model = { features : this . features , targets : this . targets , 
function shutdown ( addr , b ) { if ( addr < 0 | | addr > = max Devices ) throw 'address out of range ' ; if ( b ) spi Transfer ( addr , OP _SHUTDOWN , 0 ) ; else spi Transfer ( addr , OP _SHUTDOWN , 1 ) ; } 
function set Scan Limit ( addr , limit ) { if ( addr < 0 | | addr > = max Devices ) return ; 
function set Brightness ( addr , intensity ) { if ( addr < 0 | | addr > = max Devices ) return ; if ( typeof intensity = = 'undefined ' ) return ; intensity = constrain ( intensity , 0 , 1 5 ) ; spi Transfer ( addr , OP _INTENSITY , intensity ) ; } 
function clear Display ( addr ) { if ( addr < 0 | | addr > = max Devices ) throw 'address out of range ' ; var offset ; offset = addr * 8 ; for ( var i = 0 ; i < 8 ; i + + ) { status [ offset + i ] = 0 ; spi Transfer ( addr , i + 1 , status [ offset + i ] ) ; } } 
function set Digit ( addr , digit , value , dp ) { if ( addr < 0 | | addr > = max Devices ) throw 'address out of range ' ; if ( digit < 0 | | digit > 7 ) throw 'invalid digit number ' ; if ( value < 0 | | value > 1 5 ) throw 'number out of range ' ; var offset = addr * 8 ; var v = char Table [ value ] ; 
function show Number ( addr , num , decimalplaces , mindigits , leftjustified , pos , dontclear ) { if ( addr < 0 | | addr > = max Devices ) throw 'address out of range ' ; num = format Number ( num , decimalplaces , mindigits ) ; 
function set Char ( addr , digit , char , dp ) { if ( addr < 0 | | addr > = max Devices ) throw 'address out of range ' ; if ( digit < 0 | | digit > 7 ) throw 'invalid digit number ' ; var offset = addr * 8 ; var v = char Table [ char ] | | char Table [ char . to Lower Case ( ) ] ; 
function reduxify Service ( app , route ) { var _handle Actions ; var name = arguments . length > 2 & & arguments [ 2 ] ! = = undefined ? arguments [ 2 ] : route ; var options = arguments . length > 3 & & arguments [ 3 ] ! = = undefined ? arguments [ 3 ] : { } ; var debug = ( 0 , _debug 2 . default ) ( 'reducer : ' + name ) ; debug ( 'route ' + route ) ; var defaults = { is Error : 'is Error ' , is Loading : 'is Loading ' , is Saving : 'is Saving ' , is Finished : 'is Finished ' , data : 'data ' , query Result : 'query Result ' , store : 'store ' , PENDING : 'PENDING ' , FULFILLED : 'FULFILLED ' , REJECTED : 'REJECTED ' } ; var opts = Object . assign ( { } , defaults , options ) ; var SERVICE _NAME = 'SERVICES _ ' + name . to Upper Case ( ) + ' _ ' ; var service = app . service ( route ) ; if ( ! service ) { debug ( 'redux : Feathers service \ ' ' + route + ' does not exist . ' ) ; throw Error ( 'Feathers service \ ' ' + route + ' does not exist . ' ) ; } var reducer For Service Method = function reducer For Service Method ( action Type , if Loading , is Find ) { var _ref ; return _ref = { } , _define Property ( _ref , action Type + ' _ ' + opts . PENDING , function undefined ( state , action ) { var _extends 2 ; debug ( 'redux : ' + action Type + ' _ ' + opts . PENDING , action ) ; return _extends ( { } , state , ( _extends 2 = { } , _define Property ( _extends 2 , opts . is Error , null ) , _define Property ( _extends 2 , opts . is Loading , if Loading ) , _define Property ( _extends 2 , opts . is Saving , ! if Loading ) , _define Property ( _extends 2 , opts . is Finished , false ) , _define Property ( _extends 2 , opts . data , null ) , _define Property ( _extends 2 , opts . query Result , state [ opts . query Result ] | | null ) , _extends 2 ) ) ; } ) , _define Property ( _ref , action Type + ' _ ' + opts . FULFILLED , function undefined ( state , action ) { var _extends 3 ; debug ( 'redux : ' + action Type + ' _ ' + opts . FULFILLED , action ) ; return _extends ( { } , state , ( _extends 3 = { } , _define Property ( _extends 3 , opts . is Error , null ) , _define Property ( _extends 3 , opts . is Loading , false ) , _define Property ( _extends 3 , opts . is Saving , false ) , _define Property ( _extends 3 , opts . is Finished , true ) , _define Property ( _extends 3 , opts . data , ! is Find ? action . payload : null ) , _define Property ( _extends 3 , opts . query Result , is Find ? action . payload : state [ opts . query Result ] | | null ) , _extends 3 ) ) ; } ) , _define Property ( _ref , action Type + ' _ ' + opts . REJECTED , function undefined ( state , action ) { var _extends 4 ; debug ( 'redux : ' + action Type + ' _ ' + opts . REJECTED , action ) ; return _extends ( { } , state , ( _extends 4 = { } , _define Property ( _extends 4 , opts . is Error , action . payload ) , _define Property ( _extends 4 , opts . is Loading , false ) , _define Property ( _extends 4 , opts . is Saving , false ) , _define Property ( _extends 4 , opts . is Finished , true ) , _define Property ( _extends 4 , opts . data , null ) , _define Property ( _extends 4 , opts . query Result , is Find ? null : state [ opts . query Result ] | | null ) , _extends 4 ) ) ; } ) , _ref ; } ; 
function get Example Code ( comment ) { var expected Result = comment . expected Result ; var is Async = comment . is Async ; var test Case = comment . test Case ; if ( is Async ) { return ' \nfunction cb (err , result ) { ' + 'if (err ) return done (err ) ; ' + 'result .should .eql ( ' + expected Result + ' ) ; ' + 'done ( ) ; ' + ' } \n ' + 'var return Value = ' + test Case + ' ; ' + 'if (return Value & & return Value .then & & typeof return Value .then = = = \ 'function \ ' ) { ' + 'return Value .then (cb .bind (null , null ) , cb ) ; ' + ' } ' ; } else { return ' ( ' + test Case + ' ) .should .eql ( ' + expected Result + ' ) ; ' ; } } 
function hkdf ( ikm , length , { salt = ' ' , info = ' ' , hash = 'SHA - 2 5 6 ' } = { } ) { hash = hash . to Lower Case ( ) . replace ( ' - ' , ' ' ) ; 
function request ( method , path , body , callback ) { var stream ; 
function ( options ) { "use strict " ; if ( ( options . setter & & options . setter . index Of ( ' . ' ) > - 1 ) | | ( options . getter & & options . getter . index Of ( ' . ' ) > - 1 ) ) { throw new Error ( 'Getter ( ' + options . getter + ' ) and setter ( ' + options . setter + ' ) methods cannot be nested , so they cannot contain dot ( . ) ' ) ; } this . options = Joi . attempt ( options , options Schema ) ; this . locales = this . get Available Locales ( ) ; this . default = this . options . default | | this . locales [ 0 ] ; 
function file Exists ( path , should Be Dir ) { "use strict " ; try { var lstat = fs . lstat Sync ( path ) ; if ( should Be Dir & & lstat . is Directory ( ) ) { return true ; } if ( ! should Be Dir & & lstat . is File ( ) ) { return true ; } } catch ( err ) { return false ; } return false ; } 
async function ( server , options ) { try { var internal = new Internal ( options ) ; } catch ( err ) { throw new Boom ( err ) ; } server . expose ( 'get Locales ' , function get Locales ( ) { return internal . locales ; } ) ; server . expose ( 'get Default Locale ' , function get Default Locale ( ) { return internal . default ; } ) ; server . expose ( 'get Locale ' , function get Locale ( request ) { try { return lodash . get ( request , internal . options . getter ) ( ) ; } catch ( err ) { return null ; } } ) ; server . ext ( internal . options . on Event , internal . process Request , { bind : internal } ) ; } 
function ( curr Deps , loc ) { loc . deps = loc . deps | | [ ] ; var covered = [ ] ; 
function ( ms , cycles ) { var removed = { } ; cycles . for Each ( function ( c ) { var last = c [ c . length - 1 ] ; 
function schema ( topic ) { if ( topic = = = constants . LOBSANG _CONTENT _TOPIC ) { return wrapper . fetch ( constants . LOBSANG _CONTENT _SCHEMA _URL ) } return Promise . reject ( new Error ( 'Topic is not supported ' ) ) } 
function ( options ) { 
function when Read ( args ) { let value = get Value ( args ) if ( value & & typeof value . then = = = 'function ' ) { value . then ( ( val ) = > when Test ( args , val ) ) . catch ( ( error ) = > { console . error ( ` $ { action . display Name } ` , error ) } ) } else { when Test ( args , value ) } } 
function is Async Function ( value ) { if ( ! value ) return false ; const afc Text = value . to String ( ) . to Locale Lower Case ( ) . replace ( / \n / g , ' ' ) . replace ( / / g , ' ' ) ; return _test Constructor ( 'Async Function ' , value ) | | ( ( _test Constructor ( 'Function ' , value ) & & ( afc Text . slice ( afc Text . index Of ( ' { ' ) ) . index Of ( 'returnnewpromise (function ( $return , $error ) ' ) = = = 1 ) ) ) ; / /fast -async monkey -support } 
function is Iterable ( value ) { return ( is Object ( value ) ? ! ! Object . keys ( value ) . length : false ) | | ( is Array ( value ) ? ! ! value . length : false ) ; } 
function is JSON ( value ) { if ( ! is String ( value ) ) return false ; try { const obj = JSON . parse ( value ) ; return ! ! obj & & typeof obj = = = 'object ' ; } catch ( e ) { } return false ; } 
function array To Object ( value , to Keys ) { return ( iterate ( value , ( row , idx , iter ) = > { if ( to Keys ) { if ( is Integer ( row ) | | is String ( row ) ) iter . key ( idx + 1 ) ; return row ; } else { iter . key ( row ) ; return idx + 1 ; } } , { } ) ) ; } 
function object To Array ( value , to Keys ) { return iterate ( value , ( val , key ) = > to Keys ? key : val , [ ] ) ; } 
function set Defaults ( obj , name , value ) { if ( is Undefined ( obj [ name ] ) ) { obj [ name ] = value ; } return obj ; } 
function iterate ( value , callback , accumulate , assign ) { let break Flag = false ; function new Iteration ( index ) { let instance = { 'break ' : ( ) = > break Flag = true , acc Key Name : index , key : ( name ) = > instance . acc Key Name = name } ; return instance ; } let iterate Instance Async = async ( callback , val , index ) = > { let iteration = new Iteration ( index ) ; push Ret ( await callback ( val , index , iteration ) , iteration ) ; } ; let iterate Instance = ( callback , val , index ) = > { let iteration = new Iteration ( index ) ; push Ret ( callback ( val , index , iteration ) , iteration ) ; } ; let ret = is Object ( accumulate ) ? accumulate : is Array ( accumulate ) ? accumulate : accumulate = = = true ? false : value ; let push Ret = ( val , iteration ) = > { if ( is Undefined ( val ) ) return ; if ( is Object ( accumulate ) ) { ret [ iteration . acc Key Name ] = assign ? Object . assign ( ret [ iteration . acc Key Name ] | | { } , val ) : val ; } if ( is Array ( accumulate ) ) ret . push ( val ) ; if ( accumulate = = = true ) ret = ret | | val ; } ; return is Async Function ( callback ) ? new Promise ( async ( resolve ) = > { if ( is Array ( value ) ) { for ( let index = 0 ; index < value . length ; + + index ) { if ( break Flag ) break ; await iterate Instance Async ( callback , value [ index ] , index ) ; } resolve ( ret ) ; } if ( is Object ( value ) ) { await iterate ( Object . keys ( value ) , async ( index , _ , iteration ) = > { if ( break Flag ) iteration . break ( ) ; await iterate Instance Async ( callback , value [ index ] , index ) ; } ) ; resolve ( ret ) ; } if ( is Integer ( value ) ) { for ( let index = 0 ; index < value ; + + index ) { if ( break Flag ) break ; await iterate Instance Async ( callback , index , index ) ; } resolve ( ret ) ; } resolve ( false ) ; } ) : ( ( ) = > { if ( is Array ( value ) ) { for ( let index = 0 ; index < value . length ; + + index ) { if ( break Flag ) break ; iterate Instance ( callback , value [ index ] , index ) ; } return ret ; } if ( is Object ( value ) ) { iterate ( Object . keys ( value ) , ( index , _ , iteration ) = > { if ( break Flag ) iteration . break ( ) ; iterate Instance ( callback , value [ index ] , index ) ; } ) ; return ret ; } if ( is Integer ( value ) ) { for ( let index = 0 ; index < value ; + + index ) { if ( break Flag ) break ; iterate Instance ( callback , index , index ) ; } return ret ; } return false ; } ) ( ) ; } 
function iterate Keys ( value , callback , accumulate ) { return is Async Function ( callback ) ? ( async ( ) = > await iterate ( value , async ( row , key , iteration ) = > await callback ( key , row , iteration ) , accumulate ) ) ( ) : iterate ( value , ( row , key , iteration ) = > callback ( key , row , iteration ) , accumulate ) ; } 
async function iterate Parallel ( value , callback ) { return Promise . all ( iterate ( value , ( val , key , iter ) = > ( async ( ) = > await callback ( val , key , iter ) ) ( ) , [ ] ) ) ; } 
function find And Delete ( target , value ) { if ( ! is Iterable ( target ) ) return false ; if ( is Array ( target ) ) { for ( let i = 0 ; i < target . length ; i + + ) { if ( deep _equal _ 1 . default ( target [ i ] , value ) ) { target . splice ( i , 1 ) ; return true ; } } } else if ( is Object ( target ) ) { const keys = Object . keys ( target ) ; for ( let i = 0 ; i < keys . length ; i + + ) { if ( deep _equal _ 1 . default ( target [ keys [ i ] ] , value ) ) { delete target [ keys [ i ] ] ; return true ; } } } return false ; } 
function find And Delete All ( target , value ) { let flag = false ; while ( find And Delete ( target , value ) ) { flag = true ; } return flag ; } 
function Sign Agreement ( data ) { var d = { 'a _name ' : data . a _name , 'a _dob ' : data . a _dob } ; XForm . prototype . XExecute Post ( ' . . /agreement / _sign ' , d , function ( rslt ) { if ( ' _success ' in rslt ) { window . location . href = jsh . _BASEURL + 'agreement /welcome / ' ; } } ) ; } 
function start ( instance ) { console . log ( 'start called ! ' ) ; var chat Client = instance ( ) , 
function connect ( client ) { client . start Client ( ) return new Promise ( ( resolve , reject ) = > { client . once ( 'sync ' , ( state ) = > { if ( wrapper . is Sync State ( state ) ) { return resolve ( client ) } else { return reject ( new Error ( 'Client could not sync ' ) ) } } ) } ) } 
function lobsang Processor Hostname ( link ) { let parts try { parts = parse Url ( link ) } catch ( error ) { return Promise . reject ( error ) } if ( parts . hostname = = = ' ' ) { return Promise . reject ( new Error ( 'Not an URL ' ) ) } return Promise . resolve ( parts . hostname ) } 
function frame Of Mind ( string , options = { } ) { const { padding = 1 } = options const l = string . split ( ' \n ' ) const w = l . reduce ( ( acc , { length } ) = > length > acc ? length : acc , 0 ) const ww = w + padding * 2 const bt = ` '  ' .rep e at (ww ) }  ` const bb = ` '  ' .rep e at (ww ) }  ` const pp = ' ' . repeat ( padding ) const p = paddys ( string ) . split ( ' \n ' ) . map ( line = > ` pp } $ { li ne } $ { pp }  ` . join ( ' \n ' ) return ` $ { bt } \n $ { p } \n $ { bb } ` } 
function is Sync State ( state ) { if ( state = = = CONSTANTS . MATRIX _STATE _PREPARED ) { return true } if ( state = = = CONSTANTS . MATRIX _STATE _SYNCING ) { return true } return false } 
function lobsang Formatter Schema ( message , topic ) { if ( typeof message ! = = 'string ' ) { return Promise . reject ( new Error ( 'Message is not a string ' ) ) } return schema ( topic ) . then ( ( schema Object ) = > { const validator = validate ( schema Object ) const schema Message = format ( message ) if ( validator ( schema Message ) ) { return Promise . resolve ( schema Message ) } return Promise . reject ( validator . errors ) } ) } 
function _resolve ( path , options , mod ) { if ( path ) { var i = path . index Of ( ' : ' ) if ( i = = = - 1 ) { return resolve Module ( path , options , mod ) } else { var namespace = path . substring ( 0 , i ) var p = path . substring ( i + 1 ) if ( namespace = = = "env " ) { return resolve Env ( p , options , mod ) } else if ( namespace = = = "http " | | namespace = = = "https " ) { return resolve Http ( path , options , mod ) } else if ( namespace = = = "file " ) { return resolve File ( p , options , mod ) } else { throw new Error ( "Unable to resolve path : ' " + path + " ' . Unknown namespace : " + namespace ) } } } } 
function resolve Env ( path , options , mod ) { var result = undefined if ( path ) { result = ( process [ PRIVATE _ENV ] & & process [ PRIVATE _ENV ] [ path ] ) | | process . env [ path ] } return result } 
function resolve Module ( path , options , mod ) { 
function resolve Filename ( path , mod ) { var result = null ; if ( path ) { try { return Module . _resolve Filename ( path , mod ) 
function resolve File ( path , options , mod ) { if ( path ) { var f = Object ( ) Object . define Properties ( f , { read Stream : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . create Read Stream ( path ) } } , write Stream : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . create Write Stream ( path , { flags : "a " } ) } } , content : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . read File . sync ( path ) . to String ( ) } } } ) f . to String = function ( ) { return this . content } f . open = function ( ) { if ( ! arguments | | arguments . length < 1 ) { throw ( Error ( "flags argument is required " ) ) } var flags = arguments [ 0 ] var mode = null var cb = null if ( arguments . length > 2 ) { mode = arguments [ 1 ] cb = arguments [ 2 ] } else if ( arguments . length > 1 ) { if ( typeof arguments [ 1 ] = = = "number " ) { mode = arguments [ 1 ] } else { cb = arguments [ 1 ] } } if ( cb ) { fs . open ( path , flags , mode , cb ) } else { return fs . open Sync ( path , flags , mode ) } } return f } else { throw ( Error ( "File not found : " + path ) ) } } 
function _o ( mod ) { if ( ! ( mod instanceof Module ) ) { throw ( Error ( "Must supply a module to _o : " + mod ) ) } return function ( path , options ) { return _resolve ( path , options , mod ) } } 
function validate ( schema ) { const ajv = new Ajv ( ) try { const validator = ajv . compile ( schema ) return Promise . resolve ( validator ) } catch ( error ) { return Promise . reject ( error ) } } 
function ( options ) { assert ( options , "options are required " ) ; assert ( options . connection String , "options .connection String is missing " ) ; assert ( url . parse ( options . connection String ) . protocol = = = 'https : ' | | options . allow HTTP , "Influx DB connection String must use HTTPS ! " ) ; options = _ . defaults ( { } , options , { max Delay : 6 0 * 5 , max Pending Points : 2 5 0 } ) ; this . _options = options ; this . _pending Points = { } ; this . _nb Pending Points = 0 ; this . _flush Timeout = set Timeout ( this . flush . bind ( this , true ) , options . max Delay * 1 0 0 0 ) ; } 
function ( handler , options ) { assert ( handler instanceof Function , "A handler must be provided " ) ; assert ( options , "options required " ) ; assert ( options . drain , "options .drain is required " ) ; assert ( options . component , "options .component is required " ) ; 
function ( options ) { 
function ( options ) { options = _ . defaults ( { } , options | | { } , { tags : { } , drain : undefined } ) ; assert ( options . drain , "options .drain is required " ) ; assert ( typeof options . tags = = = 'object ' , "options .tags is required " ) ; assert ( _ . intersection ( _ . keys ( options . tags ) , series . APIClient Calls . columns ( ) ) . length = = = 0 , "Can 't used reserved tag names ! " ) ; 
function check ( message ) { if ( ! message ) { return Promise . reject ( new Error ( 'Argument must not be falsy ! ' ) ) } if ( typeof message ! = = 'string ' ) { return Promise . reject ( new Error ( 'Argument must be a string ! ' ) ) } return Promise . resolve ( message ) } 
function generate Help ( params ) { var output = ' ' ; if ( params . usage ) { var usage = result ( params , 'usage ' ) ; output + = EOL ; output + = format ( 'Usage : %s ' , usage ) ; output + = EOL ; } if ( params . desc ) { var desc = result ( params , 'desc ' ) ; output + = EOL ; output + = desc ; output + = EOL ; } if ( is . object ( params . options ) & & object Length ( params . options ) > 0 ) { var options = build Options ( params . options ) ; output + = EOL ; output + = 'Options : ' ; output + = EOL ; output + = EOL ; output + = indent ( options , ' ' , 2 ) ; output + = EOL ; } if ( is . array ( params . commands ) & & params . commands . length > 0 ) { var commands = build Commands ( params . commands ) ; output + = EOL ; output + = 'Commands : ' ; output + = EOL ; output + = EOL ; output + = indent ( commands , ' ' , 2 ) ; output + = EOL ; } output + = EOL ; return indent ( output , ' ' , 2 ) ; } 
function build Options ( options ) { var result = [ ] ; var keys = Object . keys ( options ) ; keys . for Each ( function ( key ) { var props = options [ key ] ; 
function build Commands ( commands ) { var result = [ ] ; commands . for Each ( function ( command ) { result . push ( [ command . name , command . desc | | ' ' ] ) ; } ) ; return table ( result ) ; } 
function init Growl Status ( ) { grunt . util . hooker . hook ( grunt . log , 'write ' , function ( msg ) { if ( grunt . log . uncolor ( msg ) . match ( / Waiting . . . / ) ) { flush Messages ( 'ok ' ) ; } } ) ; grunt . util . hooker . hook ( grunt . log , 'header ' , function ( msg ) { msg = grunt . log . uncolor ( msg ) ; if ( ignore Watch & & msg . match ( / "watch " task / ) ) { return ; } if ( msg . match ( / " . + : . + " / ) ) { return ; } if ( ! ignore Watch & & msg . match ( / "watch " task / ) ) { msg + = ' for ' + path . basename ( process . cwd ( ) ) ; ignore Watch = true ; } messages . push ( msg ) ; } ) ; grunt . util . hooker . hook ( grunt . log , 'ok ' , function ( msg ) { if ( typeof msg = = = 'string ' ) { messages . push ( grunt . log . uncolor ( msg ) ) ; } } ) ; grunt . util . hooker . hook ( grunt , 'warn ' , function ( error ) { var warning = [ ] ; if ( typeof error ! = = 'undefined ' ) { warning . push ( messages [ 0 ] ) ; warning . push ( messages [ messages . length - 1 ] ) ; warning . push ( String ( error . message | | error ) ) ; messages = warning ; flush Messages ( 'error ' ) ; } } ) ; grunt . util . hooker . hook ( grunt . log , 'error ' , function ( msg ) { if ( typeof msg = = = 'string ' ) { messages . push ( grunt . log . uncolor ( msg ) ) ; flush Messages ( 'error ' ) ; } } ) ; } 
function lobsang Formatter Matrix ( message ) { if ( typeof message ! = = 'string ' ) { return Promise . reject ( new Error ( 'Message is not a string ' ) ) } const formatted Message = { body : message , msgtype : CONSTANTS . MATRIX _NOTICE _TYPE } return Promise . resolve ( formatted Message ) } 
function Router ( options ) { const log Prefix = top Log Prefix + 'Router ( ) - ' ; const that = this ; let default Route Found = false ; that . options = options | | { } ; if ( ! that . options . paths ) { that . options . paths = { 'controller ' : { 'path ' : 'controllers ' , 'exts ' : 'js ' } , 'static ' : { 'path ' : 'public ' , 'exts ' : false } , 'template ' : { 'path ' : 'public /templates ' , 'exts ' : [ 'tmpl ' , 'tmp ' , 'ejs ' , 'pug ' ] } } ; } if ( ! that . options . routes ) that . options . routes = [ ] ; if ( ! that . options . base Path ) that . options . base Path = process . cwd ( ) ; if ( ! that . options . log ) { const l Utils = new LUtils ( ) ; that . options . log = new l Utils . Log ( ) ; } for ( const key of Object . keys ( that . options . paths ) ) { if ( ! Array . is Array ( that . options . paths [ key ] . exts ) & & that . options . paths [ key ] . exts ! = = false ) { that . options . paths [ key ] . exts = [ that . options . paths [ key ] . exts ] ; } } if ( ! that . options . lfs ) { that . options . lfs = new Lfs ( { 'base Path ' : that . options . base Path , 'log ' : that . options . log } ) ; } for ( let i = 0 ; that . options . routes [ i ] ! = = undefined ; i + + ) { if ( that . options . routes [ i ] . regex = = = ' ^ / $ ' ) { default Route Found = true ; break ; } } 
function copy Props ( src , target ) { const props = Object . get Own Property Names ( src ) . filter ( prop = > typeof target [ prop ] = = = 'undefined ' ) . reduce ( ( result , prop ) = > R . merge ( result , { [ prop ] : Object . get Own Property Descriptor ( src , prop ) } ) , { } ) ; Object . define Properties ( target , props ) ; } 
function lobsang Processor Port ( link ) { let parts try { parts = parse Url ( link ) } catch ( error ) { return Promise . reject ( error ) } if ( parts . port = = = ' ' ) { return get Default Port By Protocol ( parts . protocol ) } 
function get Default Port By Protocol ( raw Protocol ) { 
function clear Scripts ( node ) { var rslt = { } ; for ( var key in node ) { var val = node [ key ] ; if ( _ . is String ( val ) ) { if ( val . trim ( ) ) rslt [ key ] = " . . . " ; } else { var child Scripts = clear Scripts ( val ) ; if ( ! _ . is Empty ( child Scripts ) ) rslt [ key ] = child Scripts ; } } return rslt ; } 
function ( obj , array ) { if ( ! Array . prototype . index Of ) { for ( var i = 0 ; i < array . length ; i + + ) { if ( array [ i ] = = = obj ) { return i ; } } return - 1 ; } else { return array . index Of ( obj ) ; } } 
function format ( message , topic ) { const now = new Date ( ) const license = constants . LOBSANG _DEFAULT _LICENSE const id = 'to Be Adapted ' const issuer = 'to Be Adapted ' return { content : message , topic , license , content Type : null , created : now . to ISOString ( ) , derived From : null , id , issuer } } 
function setup Listeners ( chat , display Worker ) { chat . on ( display Worker . port . emit . bind ( display Worker . port ) ) ; display Worker . port . on ( 'login ' , function ( ) { chat . login ( ) ; } ) ; display Worker . port . on ( 'logout ' , function ( ) { chat . logout ( ) ; } ) ; display Worker . port . on ( 'send ' , function ( data ) { chat . send ( data . to , data . msg ) ; } ) ; display Worker . port . on ( 'test ' , function ( data ) { console . log ( 'Test message : ' + data ) ; } ) ; } 
function factory ( fn , options ) { var settings = options | | { } var key = settings . key var indices = settings . indices var gapless = settings . gapless if ( typeof settings = = = 'string ' ) { key = settings } if ( indices = = null ) { indices = true } return all function all ( values ) { var results = [ ] var parent = values var index = - 1 var length var result if ( key ) { if ( array ( values ) ) { parent = null } else { values = parent [ key ] } } length = values . length while ( + + index < length ) { if ( indices ) { result = fn . call ( this , values [ index ] , index , parent ) } else { result = fn . call ( this , values [ index ] , parent ) } if ( ! gapless | | result ! = null ) { results . push ( result ) } } return results } } 
function get Element Values ( node List , initial Scope ) { const value List = [ ] for ( let i = 0 ; i < node List . length ; + + i ) { const element Node = node List [ i ] if ( element Node = = null ) { value List . length = i + 1 } else if ( element Node . type = = = "Spread Element " ) { const argument = get Static Value R ( element Node . argument , initial Scope ) if ( argument = = null ) { return null } value List . push ( . . . argument . value ) } else { const element = get Static Value R ( element Node , initial Scope ) if ( element = = null ) { return null } value List . push ( element . value ) } } return value List } 
function get Static Value R ( node , initial Scope ) { if ( node ! = null & & Object . has Own Property . call ( operations , node . type ) ) { return operations [ node . type ] ( node , initial Scope ) } return null } 
function is Modified Global ( variable ) { return ( variable = = null | | variable . defs . length ! = = 0 | | variable . references . some ( r = > r . is Write ( ) ) ) } 
function config ( ext ) { return { input : "src /index .js " , output : { file : ` $ { ext } ` , format : ext = = = " .mjs " ? "es " : "cjs " , sourcemap : true , sourcemap File : ` $ { ext } ` , strict : true , banner : ` ` , } , plugins : [ sourcemaps ( ) ] , external : Object . keys ( require ( " . /package .json " ) . dependencies ) , } } 
function is Escaped ( str , index ) { let escaped = false for ( let i = index - 1 ; i > = 0 & & str . char Code At ( i ) = = = 0x 5c ; - - i ) { escaped = ! escaped } return escaped } 
function replace S ( matcher , str , replacement ) { const chunks = [ ] let index = 0 let match = null function replacer ( key ) { switch ( key ) { case " $ $ " : return " $ " case " $ & " : return match [ 0 ] case " $ ` " : return str . slice ( 0 , match . index ) case " $ ' " : return str . slice ( match . index + match [ 0 ] . length ) default : { const i = key . slice ( 1 ) if ( i in match ) { return match [ i ] } return key } } } for ( match of matcher . exec All ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( replacement . replace ( placeholder , replacer ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( " " ) } 
function replace F ( matcher , str , replace ) { const chunks = [ ] let index = 0 for ( const match of matcher . exec All ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( String ( replace ( . . . match , match . index , match . input ) ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( " " ) } 
function get Parent Syntax Paren ( node , source Code ) { const parent = node . parent switch ( parent . type ) { case "Call Expression " : case "New Expression " : if ( parent . arguments . length = = = 1 & & parent . arguments [ 0 ] = = = node ) { return source Code . get Token After ( parent . callee , is Opening Paren Token ) } return null case "Do While Statement " : if ( parent . test = = = node ) { return source Code . get Token After ( parent . body , is Opening Paren Token ) } return null case "If Statement " : case "While Statement " : if ( parent . test = = = node ) { return source Code . get First Token ( parent , 1 ) } return null case "Switch Statement " : if ( parent . discriminant = = = node ) { return source Code . get First Token ( parent , 1 ) } return null case "With Statement " : if ( parent . object = = = node ) { return source Code . get First Token ( parent , 1 ) } return null default : return null } } 
function ps Open ( ) { _event ( 'dev ' , 'pubsub - connected successfully ' ) ; let frame = { type : 'LISTEN ' , nonce : 'listen To Topics ' , data : { topics : [ 'channel -bits -events -v 1 . ' + state . channel _id , 
function send ( msg ) { switch ( ps . ready State ) { case 0 : 
function parse Message ( data ) { switch ( data . topic ) { 
function JWT ( secret , options ) { this . token = ' ' ; this . payload = { } ; this . secret = secret ; this . options = options ; this . valid = false ; this . expired = false ; this . stale = true ; } 
function ( payload ) { payload . stales = Date . now ( ) + this . options . stales ; this . payload = payload ; this . token = utils . sign ( this . payload , this . secret , this . options . sign Options ) ; this . valid = true ; this . expired = false ; this . stale = false ; return this ; } 
function ( res ) { if ( this . options . cookies ) { res . cookie ( this . options . cookie , this . token , this . options . cookie Options ) ; } return this ; } 
function ( ) { return { token : this . token , payload : this . payload , valid : this . valid , expired : this . expired , stale : this . stale } ; } 
function ( token ) { this . token = token | | ' ' ; try { this . payload = utils . verify ( this . token , this . secret , this . options . verify Options ) ; this . valid = true ; } catch ( err ) { this . payload = utils . decode ( this . token ) | | { } ; if ( err . name = = 'Token Expired Error ' ) { this . expired = true ; } } if ( this . valid & & ! this . options . verify ( this ) ) { this . valid = false ; } if ( this . payload . stales & & Date . now ( ) < = this . payload . stales ) { this . stale = false ; } return this ; } 
function ( secret , payload ) { if ( ! secret ) { throw new Reference Error ( 'secret must be defined ' ) ; } if ( typeof secret = = 'string ' ) { var _secret = secret ; secret = function ( payload ) { return _secret } ; } var jwt = new JWT ( secret ( payload ) , this . options ) ; return jwt . sign ( payload ) ; } 
function ( secret , options ) { if ( ! secret ) { throw new Reference Error ( 'secret must be defined ' ) ; } if ( typeof secret = = 'string ' ) { var _secret = secret ; secret = function ( req ) { return _secret } ; } options = options | | { } ; var defaults = { cookie : 'jwt -express ' , cookie Options : { http Only : true } , cookies : true , refresh : true , req Property : 'jwt ' , revoke : function ( jwt ) { } , sign Options : { } , stales : 9 0 0 0 0 0 , verify : function ( jwt ) { return true } , verify Options : { } } ; for ( var key in defaults ) { this . options [ key ] = options [ key ] ! = = undefined ? options [ key ] : defaults [ key ] ; } return function ( req , res , next ) { var token ; if ( this . options . cookies ) { token = req . cookies [ this . options . cookie ] ; } else if ( req . headers . authorization ) { * jwt - Creates and signs a new JWT . If cookies are in use , it stores * the JWT in the cookie as well . * @param object payload The payload of the JWT * @return JWT * / res . jwt = function ( payload ) { var jwt = new JWT ( secret ( req ) , this . options ) ; return jwt . sign ( payload ) . store ( res ) ; } . bind ( this ) ; this . clear = function ( ) { if ( this . options . cookies ) { res . clear Cookie ( this . options . cookie ) ; } } . bind ( this ) ; next ( ) ; } . bind ( this ) ; } 
function ( key , operator , value ) { if ( ! key ) { throw new Reference Error ( 'key must be defined ' ) ; } if ( operator & & [ ' = = ' , ' = = = ' , ' ! = ' , ' ! = = ' , ' < ' , ' < = ' , ' > ' , ' > = ' ] . index Of ( operator ) = = = - 1 ) { throw new JWTExpress Error ( 'Invalid operator : ' + operator ) ; } return function ( req , res , next ) { var jwt = req [ this . options . req Property ] | | { payload : { } } , data = jwt . payload [ key ] , ok ; if ( ! operator ) { ok = ! ! data ; } else if ( operator = = ' = = ' ) { ok = data = = value ; } else if ( operator = = ' = = = ' ) { ok = data = = = value ; } else if ( operator = = ' ! = ' ) { ok = data ! = value ; } else if ( operator = = ' ! = = ' ) { ok = data ! = = value ; } else if ( operator = = ' < ' ) { ok = data < value ; } else if ( operator = = ' < = ' ) { ok = data < = value ; } else if ( operator = = ' > ' ) { ok = data > value ; } else if ( operator = = ' > = ' ) { ok = data > = value ; } if ( ! ok ) { var err = new JWTExpress Error ( 'JWT is insufficient ' ) ; err . key = key ; err . data = data ; err . operator = operator ; err . value = value ; next ( err ) ; } else { next ( ) ; } } . bind ( this ) ; } 
function ( ) { return function ( req , res , next ) { var jwt = req [ this . options . req Property ] | | { } ; if ( ! jwt . valid ) { next ( new JWTExpress Error ( 'JWT is invalid ' ) ) ; } else { next ( ) ; } } . bind ( this ) ; } 
function setup Component ( fixture , options ) { 
function describe Component Factory ( component Path , spec Definitions , is Mixin ) { return function ( ) { before Each ( function ( done ) { 
function describe Module Factory ( module Path , spec Definitions ) { return function ( ) { before Each ( function ( done ) { this . module = null ; var require Callback = function ( module ) { this . module = module ; done ( ) ; } . bind ( this ) ; require ( [ module Path ] , require Callback ) ; } ) ; spec Definitions . apply ( this ) ; } ; } 
function each ( fn ) { assert . equal ( typeof fn , 'function ' ) return function ( arr ) { arr = Array . is Array ( arr ) ? arr : [ arr ] return arr . reduce ( function ( prev , curr , i ) { return prev . then ( function ( ) { return fn ( curr , i , arr . length ) } ) } , Promise . resolve ( ) ) . then ( function ( ) { return arr } ) } } 
function consul ( options , resilient ) { define Resilient Options ( params , options ) return { 
function in Handler ( err , res , next ) { if ( err ) return next ( ) 
function out Handler ( options , next ) { options . params = options . params | | { } if ( params . datacenter ) { options . params . dc = params . datacenter } if ( params . only Healthy ) { options . params . passing = true } if ( params . tag ) { options . params . tag = params . tag } next ( ) } 
function parse Price ( input ) { var str = String ( input ) var decimal Part = ' 0 0 ' var decimal Symbol = get Decimal Symbol ( str ) if ( decimal Symbol ) { decimal Part = str . split ( decimal Symbol ) [ 1 ] } var integer Part = str . split ( decimal Symbol ) [ 0 ] return Number ( filter Numbers ( integer Part ) + ' . ' + filter Numbers ( decimal Part ) ) } 
function handler ( x , y , self , items , scroller ) { var transition Pixels = 1 0 0 ; var ratio = 6 ; var header Pos = Math . max ( transition Pixels - y , 0 ) / ratio ; if ( y < 0 ) { header Pos = transition Pixels / ratio ; } switch ( self . props . name ) { case "content " : return { z Index : 3 , y : - y + items . background . rect . height , } ; case "white " : return { 
function consumption Bars ( x , y , self , items , scroller ) { 
function Pipe 2Pam ( ) { if ( ! ( this instanceof Pipe 2Pam ) ) { return new Pipe 2Pam ( ) ; } 
function cleanup Styles ( item ) { var prop ; var react Props ; if ( item . props . style ) { react Props = { } ; for ( prop in item . props . style ) { react Props [ prop ] = item . _node . style [ prop ] ; } } item . _node . remove Attribute ( 'style ' ) ; if ( react Props ) { for ( prop in react Props ) { item . _node . style [ prop ] = react Props [ prop ] ; } } if ( item . _prev Styles ) { for ( prop in item . _prev Styles ) { item . _node . style [ prop ] = item . _prev Styles [ prop ] ; } } } 
function get Image Search Results ( search Term , callback , start , num ) { start = start < 0 | | start > 9 0 | | typeof ( start ) = = = 'undefined ' ? 0 : start ; num = num < 1 | | num > 1 0 | | typeof ( num ) = = = 'undefined ' ? 1 0 : num ; if ( ! search Term ) { console . error ( 'No search term ' ) ; } var parameters = ' &q = ' + encode URIComponent ( search Term ) ; parameters + = ' &search Type =image ' ; parameters + = start ? ' &start = ' + start : ' ' ; parameters + = ' &num = ' + num ; var options = { host : 'www .googleapis .com ' , path : ' /customsearch /v 1 ?key = ' + process . env . CSE _API _KEY + ' &cx = ' + process . env . CSE _ID + parameters } ; var result = ' ' ; https . get ( options , function ( response ) { response . set Encoding ( 'utf 8 ' ) ; response . on ( 'data ' , function ( data ) { result + = data ; } ) ; response . on ( 'end ' , function ( ) { var data = JSON . parse ( result ) ; var results Array = [ ] ; 
function ( category Id , event ) { event . prevent Default ( ) ; this . refs . scroller . prepare Animation Sync ( ) ; this . set State ( { mode : 'single ' , selected : category Id , previous Scroll Position : this . refs . scroller . scroll Top , } , function ( ) { this . refs . scroller . animate And Reset Scroll ( 0 , 0 ) ; } ) ; } 
function ( event ) { event . prevent Default ( ) ; this . set State ( { mode : 'all ' , selected : null , } , function ( ) { this . refs . scroller . animate And Reset Scroll ( 0 , this . state . previous Scroll Position ) ; } ) ; } 
function handle Position When Showing All Categories ( x , y , self , items , scroller ) { var order = Data . category Ids . index Of ( self . props . category Id ) ; var multiplier = Math . max ( 1 , 1 - ( y / friction ) ) ; 
function Service ( display Name , UUID , subtype ) { if ( ! UUID ) throw new Error ( "Services must be created with a valid UUID . " ) ; this . display Name = display Name ; this . UUID = UUID ; this . subtype = subtype ; this . iid = null ; 
function Characteristic ( display Name , UUID , props ) { this . display Name = display Name ; this . UUID = UUID ; this . iid = null ; 
function Bridge ( display Name , serial Number ) { Accessory . call ( this , display Name , serial Number ) ; this . _is Bridge = true ; 
function migrate Database ( native Database , native Transaction , schema Descriptors , current Version ) { let descriptors To Process = schema Descriptors . filter ( ( descriptor ) = > { return descriptor . version > current Version } ) if ( ! descriptors To Process . length ) { return Promise Sync . resolve ( undefined ) } return migrate Database Version ( native Database , native Transaction , descriptors To Process [ 0 ] ) . then ( ( ) = > { return migrate Database ( native Database , native Transaction , descriptors To Process , descriptors To Process [ 0 ] . version ) } ) } 
function migrate Database Version ( native Database , native Transaction , descriptor ) { let fetch Promise if ( descriptor . fetch Before & & descriptor . fetch Before . length ) { let fetcher = new Record Fetcher ( ) let object Stores = normalize Fetch Before Object Stores ( descriptor . fetch Before ) fetch Promise = fetcher . fetch Records ( native Transaction , object Stores ) } else { fetch Promise = Promise Sync . resolve ( { } ) } return fetch Promise . then ( ( records Map ) = > { let version Migrator = new Database Version Migrator ( native Database , native Transaction , descriptor . object Stores ) return version Migrator . execute Migration ( descriptor . after | | ( ( ) = > { } ) , records Map ) } ) } 
function normalize Fetch Before Object Stores ( object Stores ) { return object Stores . map ( ( object Store ) = > { if ( typeof object Store = = = "string " ) { return { object Store , preprocessor : record = > record } } else if ( ! object Store . preprocessor ) { return { object Store : object Store . object Store , preprocessor : record = > record } } else { return object Store } } ) } 
function check Schema Descriptor Types ( schema Descriptors ) { let only Plain Objects = schema Descriptors . every ( ( descriptor ) = > { return descriptor . constructor = = = Object } ) if ( only Plain Objects ) { return } if ( ! ( schema Descriptors [ 0 ] instanceof Database Schema ) ) { throw new Type Error ( "The schema descriptor of the lowest described " + ` $ { schema Descriptors [ 0 ] . version } ` + "Database Schema instance , or all schema descriptors must be plain " + "objects " ) } schema Descriptors . slice ( 1 ) . for Each ( ( descriptor ) = > { if ( ! ( descriptor instanceof Upgraded Database Schema ) ) { throw new Type Error ( "The schema descriptors of the upgraded database " + "versions must be Upgraded Database Schema instances , but the " + ` $ { descriptor . version } ` + "Upgraded Database Schema instance , or all schema descriptors must " + "be plain objects " ) } } ) } 
function list ( storage , key Range , filter , direction , unique , page Size , storage Factory ) { return new Promise ( ( resolve , reject ) = > { let items = [ ] storage . create Cursor Factory ( key Range , direction ) ( ( cursor ) = > { if ( ! filter | | filter ( cursor . record , cursor . primary Key , cursor . key ) ) { if ( items . length = = = page Size ) { finalize ( true , cursor . key , cursor . primary Key ) return } else { items . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) = > finalize ( false , null , null ) ) . catch ( error = > reject ( error ) ) function finalize ( has Next Page , next Key , next Primary Key ) { resolve ( new Record List ( items , storage Factory , next Key , next Primary Key , direction , unique , filter , page Size , has Next Page ) ) } } ) } 
function normalize Compound Object Key ( key Paths , key ) { let normalized Key = [ ] key Paths . for Each ( ( key Path ) = > { let key Value = key key Path . split ( " . " ) . for Each ( ( field Name ) = > { if ( ! key Value . has Own Property ( field Name ) ) { throw new Error ( ` $ { key Path } ` + "provided compound key " ) } key Value = key Value [ field Name ] } ) normalized Key . push ( key Value ) } ) return normalized Key } 
function iterate Cursor ( request , cursor Constructor , record Callback ) { return new Promise Sync ( ( resolve , reject ) = > { let traversed Records = 0 let can Iterate = true request . onerror = ( ) = > reject ( request . error ) request . onsuccess = ( ) = > { if ( ! can Iterate ) { console . warn ( "Cursor iteration was requested asynchronously , " + "ignoring the new cursor position " ) return } if ( ! request . result ) { resolve ( traversed Records ) return } traversed Records + + let iteration Requested = handle Cursor Iteration ( request , cursor Constructor , record Callback , reject ) if ( ! iteration Requested ) { can Iterate = false resolve ( traversed Records ) } } } ) } 
function handle Cursor Iteration ( request , cursor Constructor , record Callback , reject ) { let iteration Requested = false let cursor = new cursor Constructor ( request , ( ) = > { iteration Requested = true } , ( sub Request ) = > { return Promise Sync . resolve ( sub Request ) . catch ( ( error ) = > { reject ( error ) throw error } ) } ) try { record Callback ( cursor ) } catch ( error ) { iteration Requested = false reject ( error ) } return iteration Requested } 
function fetch All Records ( transaction , object Stores ) { return Promise Sync . all ( object Stores . map ( ( descriptor ) = > { return fetch Records ( transaction . get Object Store ( descriptor . object Store ) , descriptor . preprocessor ) } ) ) . then ( ( fetched Records ) = > { let records Map = { } for ( let i = 0 ; i < object Stores . length ; i + + ) { records Map [ object Stores [ i ] . object Store ] = fetched Records [ i ] } return records Map } ) } 
function fetch Records ( object Store , preprocessor ) { return new Promise Sync ( ( resolve , reject ) = > { let records = [ ] object Store . open Cursor ( null , Cursor Direction . NEXT , ( cursor ) = > { let primary Key = cursor . primary Key if ( primary Key instanceof Object ) { Object . freeze ( primary Key ) } let preprocessed Record = preprocessor ( cursor . record , primary Key ) if ( preprocessed Record = = = Upgraded Database Schema . DELETE _RECORD ) { cursor . delete ( ) cursor . continue ( ) return } else if ( preprocessed Record ! = = Upgraded Database Schema . SKIP _RECORD ) { records . push ( { key : primary Key , record : preprocessed Record } ) } else { 
function write File P ( output Path , data , cb ) { output Path = abs ( output Path ) ; let dirname = path . dirname ( output Path ) ; mkdirp ( dirname , err = > { if ( err ) { return cb ( err ) ; } let str = data ; if ( typpy ( data , Array ) | | typpy ( data , Object ) ) { str = JSON . stringify ( data , null , 2 ) ; } fs . write File ( output Path , str , err = > cb ( err , data ) ) ; } ) ; } 
function run Transaction ( transaction , object Store Names , transaction Operations ) { let callback Arguments = object Store Names . map ( ( object Store Name ) = > { return transaction . get Object Store ( object Store Name ) } ) callback Arguments . push ( ( ) = > transaction . abort ( ) ) let result Promise = transaction Operations ( . . . callback Arguments ) return Promise . resolve ( result Promise ) . then ( ( result ) = > { return transaction . completion Promise . then ( ( ) = > result ) } ) } 
function to Native Cursor Direction ( direction , unique ) { if ( typeof direction = = = "string " ) { if ( CURSOR _DIRECTIONS . index Of ( direction . to Upper Case ( ) ) = = = - 1 ) { throw new Error ( "When using a string as cursor direction , use NEXT " + ` $ { direction } ` ) ; } } else { direction = direction . value } let cursor Direction = direction . to Lower Case ( ) . substring ( 0 , 4 ) if ( unique ) { cursor Direction + = "unique " } return cursor Direction } 
function should Delete Index ( object Store , schema , index Name ) { let schema Indexes = schema . indexes | | [ ] let new Index Names = schema Indexes . map ( index Schema = > index Schema . name ) if ( new Index Names . index Of ( index Name ) = = = - 1 ) { return true } let index = object Store . index ( index Name ) let index Key Path = index . key Path ; if ( index Key Path & & ( typeof index Key Path ! = = "string " ) ) { index Key Path = Array . from ( index Key Path ) } let serialized Index Key Path = JSON . stringify ( index Key Path ) let index Schema = schema Indexes . filter ( ( index Schema ) = > { return index Schema . name = = = index . name } ) [ 0 ] return ( index . unique ! = = index Schema . unique ) | | ( index . multi Entry ! = = index Schema . multi Entry ) | | ( serialized Index Key Path ! = = JSON . stringify ( index Schema . key Paths ) ) } 
function create Index ( object Store , index Schema ) { let index Names = Array . from ( object Store . index Names ) if ( index Names . index Of ( index Schema . name ) ! = = - 1 ) { return } object Store . create Index ( index Schema . name , index Schema . key Path , { unique : index Schema . unique , multi Entry : index Schema . multi Entry } ) } 
function fetch Next Page ( storage Factory , key Range , cursor Direction , unique , first Primary Key , filter , page Size ) { let storage = storage Factory ( ) let next Items = [ ] return new Promise ( ( resolve , reject ) = > { let idb = idb Provider ( ) let cursor Factory = storage . create Cursor Factory ( key Range , cursor Direction , unique ) cursor Factory ( ( cursor ) = > { if ( ! unique ) { let should Skip = ( ( cursor Direction = = = Cursor Direction . NEXT ) & & ( idb . cmp ( first Primary Key , cursor . primary Key ) > 0 ) ) | | ( ( cursor Direction = = = Cursor Direction . PREVIOUS ) & & ( idb . cmp ( first Primary Key , cursor . primary Key ) < 0 ) ) if ( should Skip ) { cursor . continue ( ) return } } if ( ! filter | | filter ( cursor . record , cursor . primary Key , cursor . key ) ) { if ( next Items . length = = = page Size ) { finalize ( true , cursor . key , cursor . primary Key ) return } else { next Items . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) = > finalize ( false , null , null ) ) . catch ( error = > reject ( error ) ) function finalize ( has Next Page , next Key , next Primary Key ) { resolve ( new Record List ( next Items , storage Factory , next Key , next Primary Key , cursor Direction , unique , filter , page Size , has Next Page ) ) } } ) } 
function execute Event Listeners ( listeners , . . . parameters ) { listeners . for Each ( ( listener ) = > { try { listener . apply ( null , parameters ) } catch ( error ) { console . error ( "An event listener threw an error " , error ) } } ) } 
function resolve ( instance , new State , value ) { if ( instance [ FIELDS . state ] ! = = STATE . PENDING ) { return } instance [ FIELDS . state ] = new State instance [ FIELDS . value ] = value let listeners if ( new State = = = STATE . RESOLVED ) { listeners = instance [ FIELDS . fulfill Listeners ] } else { listeners = instance [ FIELDS . error Listeners ] } for ( let listener of listeners ) { listener ( ) } } 
function run Query ( cursor Factory , filter , comparator , offset , limit , callback ) { let records = [ ] let record Index = - 1 return cursor Factory ( ( cursor ) = > { if ( ! filter & & offset & & ( ( record Index + 1 ) < offset ) ) { record Index = offset - 1 cursor . advance ( offset ) return } let primary Key = cursor . primary Key if ( filter & & ! filter ( cursor . record , primary Key ) ) { cursor . continue ( ) return } if ( comparator ) { insert Sorted ( records , cursor . record , primary Key , comparator ) if ( offset | | limit ) { if ( records . length > ( offset + limit ) ) { records . pop ( ) } } cursor . continue ( ) return } record Index + + if ( record Index < offset ) { cursor . continue ( ) return } callback ( cursor . record , primary Key ) if ( ! limit | | ( ( record Index + 1 ) < ( offset + limit ) ) ) { cursor . continue ( ) } } ) . then ( ( ) = > { if ( ! comparator ) { return } records = records . slice ( offset ) for ( let { record , primary Key } of records ) { callback ( record , primary Key ) } } ) } 
function insert Sorted ( records , record , primary Key , comparator ) { let index = find Insert Index ( records , record , comparator ) records . splice ( index , 0 , { record , primary Key } ) } 
function find Insert Index ( records , record , comparator ) { if ( ! records . length ) { return 0 } if ( records . length = = = 1 ) { let comparison = comparator ( records [ 0 ] . record , record ) return ( comparison > 0 ) ? 0 : 1 } let comparison = comparator ( records [ 0 ] . record , record ) if ( comparison > 0 ) { return 0 } let bottom = 1 let top = records . length - 1 while ( bottom < = top ) { let pivot Index = Math . floor ( ( bottom + top ) / 2 ) let comparison = comparator ( records [ pivot Index ] . record , record ) if ( comparison > 0 ) { let previous Element = records [ pivot Index - 1 ] . record if ( comparator ( previous Element , record ) < = 0 ) { return pivot Index } top = pivot Index - 1 } else { bottom = pivot Index + 1 } } return records . length } 
function prepare Query ( this Storage , filter , order ) { order = normalize Key Path ( order ) let expected Sorting Direction = order [ 0 ] . char At ( 0 ) = = = " ! " let can Sorting Be Optimized can Sorting Be Optimized = can Optimize Sorting ( expected Sorting Direction , order ) let storages = new Map ( ) storages . set ( normalize Key Path ( this Storage . key Path ) , { storage : this Storage , score : 1 
function prepare Sorting Optimization ( storages , simplified Order Field Paths ) { let idb = idb Provider ( ) for ( let [ key Path , storage And Score ] of storages ) { let key Path Slice = key Path . slice ( 0 , simplified Order Field Paths . length ) if ( idb . cmp ( key Path Slice , simplified Order Field Paths ) = = = 0 ) { storage And Score . score + = 4 
function prepare Filtering Optimization ( storages , filter ) { if ( filter instanceof Function ) { for ( let [ key Path , storage And Score ] of storages ) { storage And Score . filter = filter } return } for ( let [ key Path , storage And Score ] of storages ) { let normalized Filter = normalize Filter ( filter , key Path ) if ( normalized Filter instanceof Function ) { let is Optimizable Filter = ( filter instanceof Object ) & & ! ( filter instanceof Date ) & & ! ( filter instanceof Array ) & & ! ( filter instanceof IDBKey Range ) if ( is Optimizable Filter ) { let partial Optimization = partially Optimize Filter ( filter , key Path ) storage And Score . key Range = partial Optimization . key Range storage And Score . filter = partial Optimization . filter if ( partial Optimization . score ) { storage And Score . score + = 1 + partial Optimization . score } } else { storage And Score . filter = normalized Filter } } else { storage And Score . key Range = normalized Filter storage And Score . score + = 2 } } } 
function choose Storage For Query ( storages , order , simplified Order Field Paths , can Sorting Be Optimized , expected Sorting Direction ) { let sorted Storages = Array . from ( storages . values ( ) ) sorted Storages . sort ( ( storage 1 , storage 2 ) = > { return storage 2 . score - storage 1 . score } ) let chosen Storage Details = sorted Storages [ 0 ] let chosen Storage = chosen Storage Details . storage let chosen Storage Key Path = normalize Key Path ( chosen Storage . key Path ) let storage Key Path Slice = chosen Storage Key Path . slice ( 0 , simplified Order Field Paths . length ) let optimize Sorting = can Sorting Be Optimized & & ( idb Provider ( ) . cmp ( storage Key Path Slice , simplified Order Field Paths ) = = = 0 ) return { storage : chosen Storage , direction : optimize Sorting ? ( Cursor Direction [ expected Sorting Direction ? "PREVIOUS " : "NEXT " ] ) : Cursor Direction . NEXT , comparator : optimize Sorting ? null : compile Ordering Field Paths ( order ) , key Range : chosen Storage Details . key Range , filter : chosen Storage Details . filter } } 
function can Optimize Sorting ( expected Sorting Direction , order ) { for ( let ordering Field Path of order ) { if ( ( ordering Field Path . char At ( 0 ) = = = " ! " ) ! = = expected Sorting Direction ) { return false } } return true } 
function prepare Ordering Specification For Query ( order , key Path ) { if ( order = = = null ) { order = Cursor Direction . NEXT } let is Cursor Direction = ( ( typeof order = = = "string " ) & & ( CURSOR _DIRECTIONS . index Of ( order . to Upper Case ( ) ) > - 1 ) ) | | ( CURSOR _DIRECTIONS . index Of ( order ) > - 1 ) if ( is Cursor Direction & & ( typeof order = = = "string " ) ) { order = Cursor Direction [ order . to Upper Case ( ) ] | | Cursor Direction . PREVIOUS } if ( order instanceof Cursor Direction ) { key Path = normalize Key Path ( key Path ) if ( order = = = Cursor Direction . NEXT ) { return key Path } else { return key Path . map ( field Path = > ` $ { field Path } ` ) } } return order } 
function open Connection ( database Name , sorted Schema Descriptors ) { let version = sorted Schema Descriptors . slice ( ) . pop ( ) . version let request = Native DBAccessor . indexed DB . open ( database Name , version ) return new Promise ( ( resolve , reject ) = > { let was Blocked = false let upgrade Triggered = false let migration Promise Resolver , migration Promise Rejector let migration Promise = new Promise ( ( resolve , reject ) = > { migration Promise Resolver = resolve migration Promise Rejector = reject } ) 
function handle Connection Error ( event , error , was Blocked , upgrade Triggered , reject , migration Promise Rejector ) { if ( was Blocked | | upgrade Triggered ) { event . prevent Default ( ) return } reject ( request . error ) migration Promise Rejector ( request . error ) } 
function upgrade Database Schema ( database Name , event , migration Promise , database , transaction , sorted Schema Descriptors , migration Promise Resolver , migration Promise Rejector ) { execute Migration Listeners ( database Name , event . old Version , event . new Version , migration Promise ) let migrator = new Database Migrator ( database , transaction , sorted Schema Descriptors , event . old Version ) return Promise Sync . resolve ( ) . then ( ( ) = > { return migrator . execute Migration ( ) } ) . then ( ( ) = > { migration Promise Resolver ( ) } ) . catch ( ( error ) = > { migration Promise Rejector ( error ) throw error } ) } 
function execute Migration Listeners ( database Name , old Version , new Version , completion Promise ) { for ( let listener of migration Listeners ) { try { listener ( database Name , old Version , new Version , completion Promise ) } catch ( e ) { console . warn ( "A schema migration event listener threw an error " , e ) ; } } } 
function partially Optimize Key Path Matching Filter ( filter , key Path ) { let key Range = convert Field Map To Key Range ( filter , key Path ) if ( ! key Range ) { 
function split Filtering Object ( filter , filter Field Paths , storage Key Path ) { let fields To Optimize = { } let fields To Compile = { } filter Field Paths . for Each ( ( field Path ) = > { let value = get Field Value ( filter , field Path ) if ( storage Key Path . index Of ( field Path ) > - 1 ) { set Field Value ( fields To Optimize , field Path , value ) } else { set Field Value ( fields To Compile , field Path , value ) } } ) return { fields To Optimize , fields To Compile } } 
function compile Field Getter ( field Path ) { let fields = field Path . split ( " . " ) return ( record ) = > { let value = record for ( let field of fields ) { if ( ! ( value instanceof Object ) | | ! value . has Own Property ( field ) ) { return undefined } value = value [ field ] } return value } } 
function convert Field Map To Key Range ( filter , key Paths ) { let is Other Form Of Filter = ! ( filter instanceof Object ) | | ( filter instanceof Function ) | | ( filter instanceof Array ) | | ( filter instanceof Date ) | | ( filter instanceof IDBKey Range ) if ( is Other Form Of Filter ) { return null } if ( ! ( key Paths instanceof Array ) ) { key Paths = [ key Paths ] } let field Paths = get Field Paths ( filter ) if ( ! field Paths ) { return null } let is Key Filter = ( field Paths . length = = = key Paths . length ) & & field Paths . every ( path = > key Paths . index Of ( path ) > - 1 ) if ( ! is Key Filter ) { return null } if ( key Paths . length = = = 1 ) { return IDBKey Range . only ( get Field Value ( filter , key Paths [ 0 ] ) ) } return new IDBKey Range . only ( key Paths . map ( ( key Path ) = > { get Field Value ( filter , key Path ) } ) ) } 
function get Field Paths ( object , stop On Key Range = true ) { let field Paths = [ ] field Paths . contains Key Range = false generate Field Paths ( object , [ ] ) return field Paths function generate Field Paths ( object , parts ) { Object . keys ( object ) . some ( ( field Name ) = > { let value = object [ field Name ] if ( stop On Key Range & & ( value instanceof IDBKey Range ) ) { field Paths = null return true } let is Terminal Value = ! ( value instanceof Object ) | | ( value instanceof Date ) | | ( value instanceof Array ) | | ( value instanceof IDBKey Range ) let field Path = parts . slice ( ) field Path . push ( field Name ) if ( is Terminal Value ) { field Paths . push ( field Path . join ( " . " ) ) } else { generate Field Paths ( value , field Path ) } } ) } } 
function set Field Value ( object , field Path , value ) { let parts = field Path . split ( " . " ) let done = [ ] let current Object = object while ( parts . length ) { let field = parts . shift ( ) if ( ! parts . length ) { if ( current Object . has Own Property ( field ) ) { throw new Error ( ` $ { field Path } ` ) } current Object [ field ] = value break } if ( ! current Object . has Own Property ( field ) ) { current Object [ field ] = { } } if ( ! ( current Object [ field ] instanceof Object ) ) { throw new Error ( ` $ { field Path } ` + ` $ { done . join ( " . " ) } ` ) } current Object = current Object [ field ] done . push ( field ) } } 
function get Field Value ( object , field Path ) { if ( ! field Path ) { return object } let current Object = object field Path . split ( " . " ) . for Each ( ( field Name ) = > { if ( ! current Object . has Own Property ( field Name ) ) { throw new Error ( ` $ { field Path } ` + "provided object " ) } current Object = current Object [ field Name ] } ) return current Object } 
function upgrade Schema ( native Database , native Transaction , descriptors ) { let object Store Names = Array . from ( native Database . object Store Names ) let new Object Store Names = descriptors . map ( ( object Store ) = > { return object Store . name } ) object Store Names . for Each ( ( object Store Name ) = > { if ( new Object Store Names . index Of ( object Store Name ) = = = - 1 ) { native Database . delete Object Store ( object Store Name ) } } ) descriptors . for Each ( ( object Store Descriptor ) = > { let object Store Name = object Store Descriptor . name let native Object Store = object Store Names . index Of ( object Store Name ) > - 1 ? native Transaction . object Store ( object Store Name ) : null let object Store Migrator = new Object Store Migrator ( native Database , native Object Store , object Store Descriptor ) object Store Migrator . execute Migration ( ) } ) } 
function Mouse Position ( ) { return signal ( function ( next ) { document . add Event Listener ( "mousemove " , function ( event ) { next ( get XY ( event ) ) } ) } , new Point ( 0 , 0 ) ) } 
function rect ( width , height , pos ) { return new Shape ( [ { x : 0 - width / 2 , y : 0 - height / 2 } , { x : 0 - width / 2 , y : height / 2 } , { x : width / 2 , y : height / 2 } , { x : width / 2 , y : 0 - height / 2 } ] , pos ) } 
function container ( width , height , position , elem ) { return new Element ( new Container Element ( position , elem ) , width , height ) } 
function main Section ( state ) { var todos = state . todos var route = state . route return h ( "section .main " , { hidden : todos . length = = = 0 } , [ toggle All Pool . change ( h ( "input #toggle -all .toggle -all " , { type : "checkbox " , checked : todos . every ( function ( todo ) { return todo . completed } ) } ) ) , h ( "label " , { html For : "toggle -all " } , "Mark all as complete " ) , h ( "ul .todo -list " , todos . filter ( function ( todo ) { return route = = = "completed " & & todo . completed | | route = = = "active " & & ! todo . completed | | route = = = "all " } ) . map ( todo Item ) ) ] ) } 
function Client ( ) { Event Emitter . call ( this ) ; this . debug = true ; 
function signal ( generator , default Value ) { var value = default Value var listeners = [ ] set Timeout ( function ( ) { generator ( set ) } , 0 ) return observable function observable ( listener ) { if ( is Get ( listener ) ) { return value } else if ( is Set ( listener ) ) { throw new Error ( "read -only " ) } else { listeners . push ( listener ) } } function set ( v ) { value = v for ( var i = 0 ; i < listeners . length ; i + + ) { var listener = listeners [ i ] listener ( value ) } } } 
function get Out Dom ( hmail ) { 
function Light ( constr ) { this . client = constr . client ; this . ip Address = constr . ip Address ; this . serial Number = constr . serial Number ; this . product Id = constr . product Id ; 
function Keyboard Arrows ( ) { var valid Keys = [ 3 7 , 3 8 , 3 9 , 4 0 ] return signal ( function ( next ) { var down = { } document . add Event Listener ( "keyup " , function onup ( ev ) { if ( ev . which in KEYS ) { var key = KEYS [ ev . which ] down [ key ] = false next ( get State ( ) ) } } ) document . add Event Listener ( "keydown " , function ondown ( ev ) { if ( ev . which in KEYS ) { var key = KEYS [ ev . which ] down [ key ] = true next ( get State ( ) ) } } ) function get State ( ) { var x = 0 , y = 0 if ( down . up ) { y = 1 } else if ( down . down ) { y = - 1 } if ( down . left ) { x = - 1 } else if ( down . right ) { x = 1 } return { x : x , y : y } } } , { x : 0 , y : 0 } ) } 
function fps ( desired Fps ) { var ms Per Frame = 1 0 0 0 / desired Fps return signal ( function ( next ) { var prev = Date . now ( ) set Timeout ( tick , ms Per Frame ) function tick ( ) { var curr = Date . now ( ) var diff = curr - prev prev = curr next ( diff ) set Timeout ( tick , ms Per Frame ) } } , 0 ) } 
function Event Pool ( name ) { var storage = Transform Storage ( name ) var events = { } var _next var next Tick = function ( value , elem ) { process . next Tick ( function ( ) { _next ( value , elem ) } ) } return { signal : signal ( function ( next ) { handle Submit ( next ) handle Change ( next ) Object . keys ( events ) . for Each ( function ( event ) { handle Event ( event , next ) } ) _next = next } ) , submit : function ( elem , transform ) { return storage . set ( "submit " , elem , transform ) } , change : function ( elem , transform ) { return storage . set ( "change " , elem , transform ) } , on : function ( elem , event , transform ) { if ( ! events [ event ] ) { events [ event ] = true if ( _next ) { handle Event ( event , _next ) } } return storage . set ( event , elem , transform ) } } function handle Submit ( next ) { document . add Event Listener ( "keypress " , function ( ev ) { var target = ev . target var fn = storage . get ( "submit " , target ) var valid Event = fn & & target . type = = = "text " & & ev . key Code = = = ENTER & & ! ev . shift Key if ( ! valid Event ) { return } var item = fn ( target . value , target ) next Tick ( item ) } ) document . add Event Listener ( "click " , function ( ev ) { var target = ev . target var fn = storage . get ( "submit " , target ) if ( ! fn | | target . tag Name ! = = "BUTTON " ) { return } next Tick ( fn ( ) , target ) } ) } function handle Change ( next ) { document . add Event Listener ( "keypress " , function ( ev ) { var target = ev . target var fn = storage . get ( "change " , target ) if ( ! fn | | target . type ! = = "text " ) { return } next Tick ( fn ( target . value ) , target ) } ) document . add Event Listener ( "change " , function ( ev ) { var target = ev . target var fn = storage . get ( "change " , target ) if ( ! fn | | target . type ! = = "checkbox " ) { return } next Tick ( fn ( target . checked ) , target ) } ) } function handle Event ( event , next ) { document . add Event Listener ( event , function ( ev ) { var target = ev . target var fn = storage . get ( event , target ) if ( fn ) { next Tick ( fn ( target . value , target ) ) } } , true ) } } 
function plain Text ( content ) { var text Size = get Text Size ( content ) return new Element ( new Text Element ( "left " , content ) , text Size . width , text Size . height ) } 
function Window Dimensions ( ) { return signal ( function ( next ) { window . add Event Listener ( "resize " , function ( e ) { next ( { width : window . inner Width , height : window . inner Height } ) } ) } , { width : window . inner Width , height : window . inner Height } ) } 
function ( value ) { var value Type = typeof value ; var output = " " ; if ( value = = = null | | value = = = undefined ) { output + = this . decorate With Span ( 'null ' , 'null ' ) ; } else if ( value & & value . constructor = = = Array ) { output + = this . array To HTML ( value ) ; } else if ( value Type = = = 'object ' ) { output + = this . object To HTML ( value ) ; } else if ( value Type = = = 'number ' ) { output + = this . decorate With Span ( value , 'num ' ) ; } else if ( value Type = = = 'string ' ) { if ( / ^ (http |https ) : \ / \ / [ ^ \s ] + $ / . test ( value ) ) { output + = ' <a href = " ' + value + ' " > ' + this . html Encode ( value ) + ' < /a > ' ; } else { output + = this . decorate With Span ( ' " ' + value + ' " ' , 'string ' ) ; } } else if ( value Type = = = 'boolean ' ) { output + = this . decorate With Span ( value , 'bool ' ) ; } return output ; } 
function ( json ) { var output = ' [ <ul class = "array collapsible " > ' ; var has Contents = false ; for ( var prop in json ) { has Contents = true ; output + = ' <li > ' ; output + = this . value To HTML ( json [ prop ] ) ; output + = ' < /li > ' ; } output + = ' < /ul > ] ' ; if ( ! has Contents ) { output = " [ ] " ; } return output ; } 
function ( error , data , uri ) { 
function collapse ( evt ) { var collapser = evt . target ; var target = collapser . parent Node . get Elements By Class Name ( 'collapsible ' ) ; if ( ! target . length ) { return } target = target [ 0 ] ; if ( target . style . display = = = 'none ' ) { var ellipsis = target . parent Node . get Elements By Class Name ( 'ellipsis ' ) [ 0 ] target . parent Node . remove Child ( ellipsis ) ; target . style . display = ' ' ; collapser . inner HTML = ' - ' ; } else { target . style . display = 'none ' ; var ellipsis = document . create Element ( 'span ' ) ; ellipsis . class Name = 'ellipsis ' ; ellipsis . inner HTML = ' &hellip ; ' ; target . parent Node . insert Before ( ellipsis , target ) ; collapser . inner HTML = ' + ' ; } } 
function flow ( direction , elements ) { var widths = elements . map ( width Of ) var heights = elements . map ( height Of ) var width = direction = = = "left " ? sum ( widths ) : direction = = = "right " ? sum ( widths ) : maximum ( widths ) var height = direction = = = "down " ? sum ( heights ) : direction = = = "right " ? sum ( heights ) : maximum ( heights ) return new Element ( new Flow Element ( direction , elements ) , width , height ) } 
function collage ( width , height , forms ) { return new Element ( new Collage Element ( forms , width , height ) , width , height ) } 
function Html Element ( tag Name , special , general , children ) { this . tag Name = tag Name this . special Properties = special this . general Properties = general this . children = children this . cl = null 
function create Lexer ( g ) { function Token ( tag , text , index , sub Matches , end , pos ) { this . tag = tag ; this . text = text ; this . index = index ; this . sub Matches = sub Matches ; this . end = end ; this . pos = pos ; } Token . prototype . to String = function ( ) { return this . text ; } ; function empty Func ( ) { } function tofn ( f ) { if ( typeof f = = 'function ' ) return f ; return function ( ) { return f ; } ; } function build Scanner ( a ) { var n = 1 ; var b = [ ] ; var match Indexes = [ 1 ] ; var fa = [ ] ; for ( var i = 0 ; i < a . length ; + + i ) { match Indexes . push ( n + = Reg Exp ( ' | ' + a [ i ] [ 0 ] . source ) . exec ( ' ' ) . length ) ; fa . push ( a [ i ] [ 1 ] ? tofn ( a [ i ] [ 1 ] ) : empty Func ) ; b . push ( ' ( ' + a [ i ] [ 0 ] . source + ' ) ' ) ; } var re = Reg Exp ( b . join ( ' | ' ) + ' | ' , 'g ' ) ; return [ re , match Indexes , fa ] ; } var end Tag = g . $ | | ' $ ' ; var scanner = { } ; for ( var i in g ) { if ( i . char At ( 0 ) ! = ' $ ' ) scanner [ i ] = build Scanner ( g [ i ] ) ; } return Lexer ; function Lexer ( s ) { / / / <param name = "s " type = "String " > < /param > var Length = s . length ; var i = 0 ; var state Stack = [ ' ' ] ; var obj = { text : ' ' , index : 0 , source : s , push State : function ( s ) { state Stack . push ( s ) ; } , pop State : function ( ) { state Stack . pop ( ) ; } , retract : function ( n ) { i - = n ; } } ; var current Pos = new Position ( 1 , 1 ) ; function scan ( ) { var st = state Stack [ state Stack . length - 1 ] ; var rule = scanner [ st ] ; var re = rule [ 0 ] ; re . last Index = i ; var t = re . exec ( s ) ; if ( t [ 0 ] = = ' ' ) { if ( i < Length ) { throw Error ( 'lexer error : ' + current Pos + ' \n ' + s . slice ( i , i + 5 0 ) ) ; } return new Token ( end Tag , ' ' , i , null , i , current Pos ) ; } obj . index = i ; i = re . last Index ; var idx = rule [ 1 ] ; for ( var j = 0 ; j < idx . length ; + + j ) if ( t [ idx [ j ] ] ) { var tag = rule [ 2 ] [ j ] . apply ( obj , t . slice ( idx [ j ] , idx [ j + 1 ] ) ) ; / /if (tag = = null ) return null ; return new Token ( tag , t [ 0 ] , obj . index , t . slice ( idx [ j ] + 1 , idx [ j + 1 ] ) , i , current Pos ) ; } } var re _new Line = / \r \n ? | \n / g ; var re _last Line = / [ ^ \r \n \u 2 0 2 8 \u 2 0 2 9 ] * $ / ; return { scan : function ( ) { do { var t = scan ( ) ; var _row = current Pos . row ; var _col = current Pos . col ; var ms = t . text . match ( re _new Line ) ; var h = ms ? ms . length : 0 ; _row + = h ; if ( h = = 0 ) _col + = t . text . length ; else _col = re _last Line . exec ( t . text ) [ 0 ] . length + 1 ; current Pos = new Position ( _row , _col ) ; if ( t . tag ! = null ) { return t ; } } while ( true ) ; } , Get Current Position : function ( ) { return current Pos ; } , get Pos : function ( i ) { return get Pos ( s , i ) ; } } ; } } 
function codegen _js _tran ( prog , encode Name , default Encode , ignore Whitespace ) { / / / <param name = "prog " type = "Array " >AST < /param > / / / <param name = "encode Name " type = "String " > < /param > / / / <param name = "default Encode " type = "Boolean " > < /param > / / / <returns type = "String " / > var i _tmake = 0 ; function TMake ( ) { return ' _ ' + ( i _tmake + + ) ; } function emit ( s ) { body . push ( s ) ; } function node With Pos ( node , pos ) { node . pos = pos ; return node ; } function stmt Gen ( a ) { switch ( a [ 0 ] ) { case 'if ' : emit ( 'if ( ' ) ; emit ( expr Gen ( a [ 1 ] ) ) ; emit ( ' ) { ' ) ; stmts Gen ( a [ 2 ] ) ; emit ( ' } ' ) ; if ( a [ 3 ] ) { emit ( 'else { ' ) ; stmts Gen ( a [ 3 ] ) ; emit ( ' } ' ) ; } break ; case 'each ' : var key Name = a [ 3 ] ? encode Common Name ( a [ 3 ] ) : TMake ( ) ; var tmp Expr = expr Gen ( a [ 1 ] ) ; var tmp Str = join Code ( tmp Expr ) ; if ( / ^ \w + $ / . test ( tmp Str ) ) { var list Name = tmp Str ; } else { list Name = TMake ( ) ; emit ( 'var ' + list Name + ' = ' ) ; emit ( tmp Expr ) ; emit ( ' ; ' ) ; } if ( a [ 5 ] ) { emit ( 'for (var ' + key Name + ' = 0 ; ' + key Name + ' < ' ) ; / /list Name + ' .length ' emit ( expr Gen ( [ ' . ' , node With Pos ( [ 't ' , list Name ] , a [ 1 ] . pos ) , 'length ' ] ) ) ; emit ( ' ; ' + key Name + ' + + ) { ' ) ; } else emit ( 'for (var ' + key Name + ' in ' + list Name + ' ) { ' ) ; emit ( 'var ' + a [ 4 ] + ' = ' ) ; / /list Name + ' [ ' + key Name + ' ] ' emit ( expr Gen ( [ ' [ ] ' , node With Pos ( [ 't ' , list Name ] , a [ 1 ] . pos ) , [ 't ' , key Name ] ] ) ) ; emit ( ' ; ' ) ; stmts Gen ( a [ 2 ] ) ; emit ( ' } ' ) ; break ; case 'set ' : if ( typeof a [ 1 ] = = 'string ' ) emit ( 'var ' + encode Common Name ( a [ 1 ] ) + ' = ' ) ; else { emit ( expr Gen ( a [ 1 ] ) ) ; emit ( ' = ' ) ; } emit ( expr Gen ( a [ 2 ] ) ) ; emit ( ' ; ' ) ; break ; case 'eval ' : var tmp Expr = expr Gen ( a [ 1 ] ) ; var tmp Str = join Code ( tmp Expr ) ; if ( / ^ \w + $ / . test ( tmp Str ) ) var t Name = tmp Str ; else { t Name = ' _t ' ; emit ( ' _t = ' ) ; emit ( tmp Expr ) ; emit ( ' ; ' ) ; } emit ( 'if ( ' + t Name + ' ! =null ) _s + = ' + ( ( default Encode ? ! a [ 2 ] : a [ 2 ] ) ? encode Name + ' ( ' + t Name + ' ) ' : t Name ) + ' ; ' ) ; break ; case 'text ' : if ( ignore Whitespace ) { if ( / ^ \s + $ / . test ( a [ 1 ] ) ) break ; } emit ( ' _s + = ' + quote ( a [ 1 ] ) + ' ; ' ) ; break ; case 'inc ' : / /stmts Gen (a [ 2 ] [ 1 ] ) ; break ; case 'script ' : scripts . push ( a [ 1 ] ) ; break ; default : throw Error ( 'unknown stmt : ' + a [ 0 ] ) ; } } function stmts Gen ( a ) { for ( var i = 0 ; i < a . length ; + + i ) stmt Gen ( a [ i ] ) ; } function join Code ( a ) { if ( typeof a = = 'string ' ) return a ; if ( a instanceof Array ) { var r = [ ] ; for ( var i = 0 ; i < a . length ; + + i ) { r . push ( join Code ( a [ i ] ) ) ; } return r . join ( ' ' ) ; } throw new Error ( "unknown type " ) ; } function expr To Str ( x , check ) { var t = expr Gen ( x ) ; if ( check & & ! check ( x [ 0 ] ) ) t = [ ' ( ' , t , ' ) ' ] ; return t ; } function expr Gen ( x ) { return node With Pos ( expr Gen _original ( x ) , x . pos ) ; } function expr Gen _original ( x ) { switch ( x [ 0 ] ) { case 't ' : return x [ 1 ] ; / /         case 'id ' : return encode Common Name ( x [ 1 ] ) ; case 'lit ' : return ( typeof x [ 1 ] = = 'string ' ) ? quote ( x [ 1 ] ) : String ( x [ 1 ] ) ; case 'array ' : var tmp = [ ' [ ' ] ; for ( var i = 0 ; i < x [ 1 ] . length ; + + i ) { if ( i > 0 ) tmp . push ( " , " ) ; tmp . push ( expr Gen ( x [ 1 ] [ i ] ) ) ; } tmp . push ( ' ] ' ) ; return tmp ; case 'object ' : var tmp = [ ' { ' ] ; for ( var i = 0 ; i < x [ 1 ] . length ; + + i ) { if ( i > 0 ) tmp . push ( " , " ) ; tmp . push ( quote ( x [ 1 ] [ i ] [ 1 ] ) ) ; tmp . push ( ' : ' ) ; tmp . push ( expr Gen ( x [ 1 ] [ i ] [ 2 ] ) ) ; } tmp . push ( ' } ' ) ; return tmp ; case 'null ' : return [ 'null ' ] ; case ' . ' : return [ expr To Str ( x [ 1 ] , is Member ) , ' . ' , x [ 2 ] ] ; case ' [ ] ' : return [ expr To Str ( x [ 1 ] , is Member ) , ' [ ' , expr Gen ( x [ 2 ] ) , ' ] ' ] ; case ' ( ) ' : var a = [ expr To Str ( x [ 1 ] , is Member ) , ' ( ' ] ; if ( x [ 2 ] ) { for ( var i = 0 ; i < x [ 2 ] . length ; + + i ) { if ( i > 0 ) a . push ( ' , ' ) ; a . push ( expr Gen ( x [ 2 ] [ i ] ) ) ; } } a . push ( ' ) ' ) ; return a ; case ' ! ' : return [ ' ! ' , expr To Str ( x [ 1 ] , is Unary ) ] ; case 'u - ' : return [ ' - ' , expr To Str ( x [ 1 ] , is Unary ) ] ; case ' * ' : case ' / ' : case ' % ' : return [ expr To Str ( x [ 1 ] , is Mul ) , x [ 0 ] , expr To Str ( x [ 2 ] , is Unary ) ] ; case ' + ' : case ' - ' : return [ expr To Str ( x [ 1 ] , is Add ) , x [ 0 ] , ' ' , expr To Str ( x [ 2 ] , is Mul ) ] ; case ' < ' : case ' > ' : case ' < = ' : case ' > = ' : return [ expr To Str ( x [ 1 ] , is Rel ) , x [ 0 ] , expr To Str ( x [ 2 ] , is Add ) ] ; case ' = = ' : case ' ! = ' : case ' = = = ' : case ' ! = = ' : return [ expr To Str ( x [ 1 ] , is Equality ) , x [ 0 ] , expr To Str ( x [ 2 ] , is Rel ) ] ; case ' & & ' : return [ expr To Str ( x [ 1 ] , is Logical And ) , ' & & ' , expr To Str ( x [ 2 ] , is Equality ) ] ; case ' | | ' : return [ expr To Str ( x [ 1 ] , is Logical Or ) , ' | | ' , expr To Str ( x [ 2 ] , is Logical And ) ] ; case 'cond ' : return [ expr To Str ( x [ 1 ] , is Logical Or ) , ' ? ' , expr To Str ( x [ 2 ] , is Cond ) , ' : ' , expr To Str ( x [ 3 ] , is Cond ) ] ; default : throw Error ( "unknown expr : " + x [ 0 ] ) ; } } var body = [ ] ; var scripts = [ ] ; stmts Gen ( prog [ 1 ] ) ; var pos Log = [ ] ; var js Str = ' ' ; function join Js Str ( a ) { if ( typeof a = = 'string ' ) js Str + = a ; if ( a instanceof Array ) { if ( a . pos ) { pos Log . push ( [ js Str . length , a . pos ] ) ; } for ( var i = 0 ; i < a . length ; + + i ) { join Js Str ( a [ i ] ) ; } } } join Js Str ( body ) ; if ( scripts . length ) { js Str + = scripts . join ( ' ; ' ) ; } / /alert (pos Log .join ( ' \n ' ) ) ; var str Obj = new String ( js Str ) ; str Obj . pos Log = pos Log ; return str Obj ; } 
function codegen _php _tran ( prog , default Encode ) { / / / <param name = "prog " type = "Array " >AST < /param > / / / <param name = "default Encode " type = "Boolean " > < /param > / / / <returns type = "String " / > / /               function encode Id ( s ) { return ' $crox _ ' + encode Common Name ( s ) ; } function emit ( t ) { s + = t ; } function compile Eval ( stmt ) { var t = walk Expr ( stmt [ 1 ] ) ; emit ( 'crox _echo ( ' + t + ' , ' + ( default Encode ? ! stmt [ 2 ] : stmt [ 2 ] ) + ' ) ; ' ) ; } function compile Content ( stmt ) { var t = stmt [ 1 ] ; if ( / < \ ? ( ? :php ) ? | \ ? > / . test ( t ) ) emit ( 'echo ' + php Quote ( stmt [ 1 ] ) + ' ; ' ) ; else { emit ( ' ? > ' + t + ' < ?php ' ) ; } } function compile If ( stmt ) { emit ( 'if ( ' + walk Expr ( stmt [ 1 ] ) + ' ) { ' ) ; compile Stmts ( stmt [ 2 ] ) ; emit ( ' } ' ) ; if ( stmt [ 3 ] ) { emit ( 'else { ' ) ; compile Stmts ( stmt [ 3 ] ) ; emit ( ' } ' ) ; } } function compile Each ( stmt ) { emit ( 'foreach ( ' + walk Expr ( stmt [ 1 ] ) + ' as ' + ( stmt [ 3 ] ? encode Id ( stmt [ 3 ] ) + ' = > ' : ' ' ) + encode Id ( stmt [ 4 ] ) + ' ) ' ) ; emit ( ' { ' ) ; compile Stmts ( stmt [ 2 ] ) ; emit ( ' } ' ) ; } function compile Set ( stmt ) { emit ( encode Id ( stmt [ 1 ] ) + ' = ' + walk Expr ( stmt [ 2 ] ) + ' ; ' ) ; } function compile Stmt ( a ) { switch ( a [ 0 ] ) { case 'if ' : compile If ( a ) ; break ; case 'each ' : compile Each ( a ) ; break ; case 'set ' : compile Set ( a ) ; break ; case 'eval ' : compile Eval ( a ) ; break ; case 'text ' : compile Content ( a ) ; break ; case 'inc ' : emit ( "include ' " + change Ext ( a [ 1 ] , 'php ' ) + " ' ; " ) ; break ; default : throw Error ( 'unknown stmt : ' + a [ 0 ] ) ; } } function compile Stmts ( a ) { for ( var i = 0 ; i < a . length ; + + i ) compile Stmt ( a [ i ] ) ; } function expr To Str ( x , check ) { var t = walk Expr ( x ) ; if ( check & & ! check ( x [ 0 ] ) ) t = ' ( ' + t + ' ) ' ; return t ; } function walk Expr ( x ) { switch ( x [ 0 ] ) { case 'id ' : return encode Id ( x [ 1 ] ) ; case 'lit ' : if ( typeof x [ 1 ] = = 'string ' ) return php Quote ( x [ 1 ] ) ; return String ( x [ 1 ] ) ; case ' . ' : return expr To Str ( x [ 1 ] , is Member ) + " - > " + x [ 2 ] ; case ' [ ] ' : return expr To Str ( x [ 1 ] , is Member ) + ' [ ' + walk Expr ( x [ 2 ] ) + ' ] ' ; case ' ! ' : return ' !crox _To Boolean ( ' + expr To Str ( x [ 1 ] , is Unary ) + ' ) ' ; case 'u - ' : return ' - ' + expr To Str ( x [ 1 ] , is Unary ) ; case ' * ' : case ' / ' : case ' % ' : return expr To Str ( x [ 1 ] , is Mul ) + x [ 0 ] + expr To Str ( x [ 2 ] , is Unary ) ; case ' + ' : return 'crox _plus ( ' + expr To Str ( x [ 1 ] , null ) + ' , ' + expr To Str ( x [ 2 ] , null ) + ' ) ' ; case ' - ' : return expr To Str ( x [ 1 ] , is Add ) + ' - ' + expr To Str ( x [ 2 ] , is Mul ) ; case ' < ' : case ' > ' : case ' < = ' : case ' > = ' : return expr To Str ( x [ 1 ] , is Rel ) + x [ 0 ] + expr To Str ( x [ 2 ] , is Add ) ; case ' = = ' : case ' ! = ' : case ' = = = ' : case ' ! = = ' : return expr To Str ( x [ 1 ] , is Equality ) + x [ 0 ] + expr To Str ( x [ 2 ] , is Rel ) ; case ' & & ' : return 'crox _logical _and ( ' + expr To Str ( x [ 1 ] , null ) + ' , ' + expr To Str ( x [ 2 ] , null ) + ' ) ' ; case ' | | ' : return 'crox _logical _or ( ' + expr To Str ( x [ 1 ] , null ) + ' , ' + expr To Str ( x [ 2 ] , null ) + ' ) ' ; default : throw Error ( "unknown expr : " + x [ 0 ] ) ; } } var s = " " ; compile Stmts ( prog [ 1 ] ) ; if ( s . slice ( 0 , 2 ) = = ' ? > ' ) s = s . slice ( 2 ) ; else s = ' < ?php ' + s ; if ( s . slice ( - 6 ) = = ' < ?php ' ) s = s . slice ( 0 , - 6 ) ; else s + = ' ? > ' ; return s ; } 
function codegen _vm _tran ( prog ) { / / / <param name = "prog " type = "Array " >AST < /param > / / / <returns type = "String " / > / /                           function encode Id ( s ) { return ' $crox _ ' + encode Common Name ( s ) ; } function is Name ( s ) { return / ^ $ \w + $ / . test ( s ) ; } function emit ( s ) { body + = s ; } var i _each = 0 ; function stmt Gen ( a ) { switch ( a [ 0 ] ) { case 'if ' : emit ( ' #if ( ' + expr Gen ( a [ 1 ] ) + ' ) ' ) ; stmts Gen ( a [ 2 ] ) ; if ( a [ 3 ] ) { emit ( ' # {else } ' ) ; stmts Gen ( a [ 3 ] ) ; } emit ( ' # {end } ' ) ; break ; case 'each ' : + + i _each ; var s Expr = expr Gen ( a [ 1 ] ) ; if ( is Name ( s Expr ) ) var list Name = s Expr ; else { list Name = ' $list ' + ( i _each = = 1 ? ' ' : i _each ) ; emit ( ' #set ( ' + list Name + ' = ' + s Expr + ' ) ' ) ; } if ( a [ 5 ] ) { / /array emit ( ' #foreach ( ' + encode Id ( a [ 4 ] ) + ' in ' + list Name + ' ) ' ) ; if ( a [ 3 ] ) { emit ( ' #set ( ' + encode Id ( a [ 3 ] ) + ' = $velocity Count - 1 ) ' ) ; } } else { / /object if ( a [ 3 ] ) { emit ( ' #foreach ( ' + encode Id ( a [ 3 ] ) + ' in ' + list Name + ' .key Set ( ) ) ' ) ; emit ( ' #set ( ' + encode Id ( a [ 4 ] ) + ' = ' + list Name + ' .get ( ' + encode Id ( a [ 3 ] ) + ' ) ) ' ) ; } else { emit ( ' #foreach ( ' + encode Id ( a [ 4 ] ) + ' in ' + list Name + ' ) ' ) ; } } stmts Gen ( a [ 2 ] ) ; emit ( ' # {end } ' ) ; - - i _each ; break ; case 'set ' : emit ( ' #set ( ' + encode Id ( a [ 1 ] ) + ' = ' + expr Gen ( a [ 2 ] ) + ' ) ' ) ; break ; case 'eval ' : var s = expr Gen ( a [ 1 ] ) ; if ( is Name ( s ) ) emit ( ' $ ! { ' + s . slice ( 1 ) + ' } ' ) ; else { emit ( ' #set ( $t = ' + s + ' ) $ ! {t } ' ) ; } break ; case 'text ' : emit ( a [ 1 ] . replace ( / \ $ / g , ' $ $ {dollar } ' ) . replace ( / # / g , ' $ $ {sharp } ' ) ) ; break ; case 'inc ' : emit ( " #parse ( ' " + change Ext ( a [ 1 ] , 'vm ' ) + " ' ) " ) ; break ; default : throw Error ( 'unknown stmt : ' + a [ 0 ] ) ; } } function stmts Gen ( a ) { for ( var i = 0 ; i < a . length ; + + i ) stmt Gen ( a [ i ] ) ; } function expr To Str ( x , check ) { var t = expr Gen ( x ) ; if ( check & & ! check ( x [ 0 ] ) ) t = ' ( ' + t + ' ) ' ; return t ; } function expr Gen ( x ) { switch ( x [ 0 ] ) { case 'id ' : return encode Id ( x [ 1 ] ) ; case 'lit ' : if ( typeof x [ 1 ] = = 'string ' ) return vm Quote ( x [ 1 ] ) ; return String ( x [ 1 ] ) ; case ' . ' : return expr To Str ( x [ 1 ] , is Member ) + ' . ' + x [ 2 ] ; case ' [ ] ' : return expr To Str ( x [ 1 ] , is Member ) + ' [ ' + expr Gen ( x [ 2 ] ) + ' ] ' ; case ' ! ' : return ' ! ' + expr To Str ( x [ 1 ] , is Unary ) ; case 'u - ' : if ( x [ 1 ] [ 0 ] = = 'u - ' ) throw Error ( "         " ) ; return ' - ' + expr To Str ( x [ 1 ] , is Unary ) ; case ' * ' : case ' / ' : case ' % ' : return expr To Str ( x [ 1 ] , is Mul ) + x [ 0 ] + expr To Str ( x [ 2 ] , is Unary ) ; case ' + ' : case ' - ' : return expr To Str ( x [ 1 ] , is Add ) + x [ 0 ] + ' ' + expr To Str ( x [ 2 ] , is Mul ) ; case ' < ' : case ' > ' : case ' < = ' : case ' > = ' : return expr To Str ( x [ 1 ] , is Rel ) + x [ 0 ] + expr To Str ( x [ 2 ] , is Add ) ; case ' = = ' : case ' ! = ' : case ' = = = ' : case ' ! = = ' : return expr To Str ( x [ 1 ] , is Equality ) + x [ 0 ] . slice ( 0 , 2 ) + expr To Str ( x [ 2 ] , is Rel ) ; case ' & & ' : return expr To Str ( x [ 1 ] , is Logical And ) + ' & & ' + expr To Str ( x [ 2 ] , is Equality ) ; case ' | | ' : return expr To Str ( x [ 1 ] , is Logical Or ) + ' | | ' + expr To Str ( x [ 2 ] , is Logical And ) ; default : throw Error ( "unknown expr : " + x [ 0 ] ) ; } } function vm Quote ( s ) { / / / <param name = "s " type = "String " > < /param > if ( s . index Of ( " ' " ) = = - 1 ) return " ' " + s + " ' " ; var a = s . split ( " ' " ) ; return " ( ' " + a . join ( " ' + \ " ' \ " + ' " ) + " ' ) " ; } var body = " #set ( $dollar = ' $ ' ) #set ( $sharp = ' # ' ) " ; stmts Gen ( prog [ 1 ] ) ; return body ; } 
function write ( chunk , encoding , callback ) { if ( typeof encoding = = = 'function ' ) { callback = encoding encoding = null } if ( ended ) { throw new Error ( 'Did not expect `write ` after `end ` ' ) } chunks . push ( ( chunk | | ' ' ) . to String ( encoding | | 'utf 8 ' ) ) if ( callback ) { callback ( ) } 
function end ( ) { write . apply ( null , arguments ) ended = true processor . process ( chunks . join ( ' ' ) , done ) return true function done ( err , file ) { var messages = file ? file . messages : [ ] var length = messages . length var index = - 1 chunks = null 
function pipe ( dest , options ) { var settings = options | | { } var onend = once ( onended ) emitter . on ( 'data ' , ondata ) emitter . on ( 'error ' , onerror ) emitter . on ( 'end ' , cleanup ) emitter . on ( 'close ' , cleanup ) 
function cleanup ( ) { emitter . remove Listener ( 'data ' , ondata ) emitter . remove Listener ( 'end ' , onend ) emitter . remove Listener ( 'error ' , onerror ) emitter . remove Listener ( 'end ' , cleanup ) emitter . remove Listener ( 'close ' , cleanup ) dest . remove Listener ( 'error ' , onerror ) dest . remove Listener ( 'close ' , cleanup ) } 
function onerror ( err ) { var handlers = emitter . _events . error cleanup ( ) 
function rm ( names ) { console . log ( ) ; for ( const name of names ) { const bplate = path . join ( os . homedir ( ) , ' .snap ' , name ) ; if ( fs . path Exists Sync ( bplate ) ) { fs . remove Sync ( bplate ) ; console . log ( ` $ { chalk . green ( 'Success : ' ) } $ { chalk . red Bright ( name ) } ` ) ; } else { console . error ( ` $ { chalk . red ( 'Error : ' ) } $ { chalk . yellow ( name ) } ` ) ; } } console . log ( ) ; } 
function save ( name , src = path . resolve ( ) , options ) { 
function clean ( root , name ) { const blacklist = [ ' .git ' , 'node _modules ' ] ; for ( const item of blacklist ) { const path To Item = path . join ( root , item ) ; if ( fs . path Exists Sync ( path To Item ) ) { fs . remove Sync ( path To Item ) ; console . log ( ` $ { chalk . dim . red Bright ( item ) } $ { chalk . yellow ( name ) } ` ) ; } } } 
function ls ( ) { const vault = path . join ( os . homedir ( ) , ' .snap ' ) ; const list = shell . ls ( vault ) ; if ( ! list . length ) { console . log ( " \n It seems you don 't have anything saved . . . " ) ; console . log ( ` $ { chalk . yellow ( 'snap save ' ) } ` ) ; console . log ( ` $ { chalk . yellow ( 'snap save -h ' ) } \n ` ) ; return ; } console . log ( ' \n The following boilerplates have been saved . . . ' ) ; console . log ( ` $ { chalk . yellow ( 'snap <boilerplate -name > <project -directory > ' ) } ` ) ; for ( const bplate of list ) { console . log ( ` bp late } ` ) ; } console . log ( ) ; } 
function snap ( bplate Name , project Dir , options ) { 
function show ( name ) { const root = path . join ( os . homedir ( ) , ' .snap ' , name ) ; if ( ! fs . path Exists Sync ( root ) ) { console . log ( ` \n $ { chalk . red ( 'Error : ' ) } $ { chalk . yellow ( name ) } \n ` ) ; return ; } const tree = walk ( root , 0 ) ; console . log ( ) ; print Tree ( tree ) ; console . log ( ) ; } 
function Animation Scale In Right ( init ) { let build Style Interpolator = init ; return Object . assign ( { } , { . . . Navigator Scene Configs . Push From Right , animation Interpolators : { into : build Style Interpolator ( { . . . Center Scale Right In } ) , out : build Style Interpolator ( { . . . Center Scale Left Out } ) } } ) ; } 
function Animation Scale In Right Down ( init ) { let build Style Interpolator = init ; return Object . assign ( { } , { . . . Navigator Scene Configs . Push From Right , animation Interpolators : { into : build Style Interpolator ( { . . . Down Scale In } ) , out : build Style Interpolator ( { . . . Down Scale Out } ) } } ) ; } 
function Animation Scale In Right Up ( init ) { let build Style Interpolator = init ; return Object . assign ( { } , { . . . Navigator Scene Configs . Push From Right , animation Interpolators : { into : build Style Interpolator ( { . . . Up Scale In } ) , out : build Style Interpolator ( { . . . Up Scale Out } ) } } ) ; } 
function Animation Rotate In Left ( init ) { let build Style Interpolator = init ; return Object . assign ( { } , { . . . Navigator Scene Configs . Fade Android , animation Interpolators : { into : build Style Interpolator ( { . . . Right Rotate In Down } ) , out : build Style Interpolator ( { . . . Left Rotate Out Down } ) } } ) ; } 
function Custom Animation ( init ) { let build Style Interpolator = init ; return ( Left Right In , Up Dowm Out , Gestures , Base = { spring Friction : 2 6 , spring Tension : 2 0 0 , default Transition Velocity : 1 . 5 } ) = > { return Object . assign ( { } , Navigator Scene Configs . Fade Android , { animation Interpolators : { into : build Style Interpolator ( { . . . Check Params ( Left Right In ) } ) , out : build Style Interpolator ( { . . . Check Params ( Up Dowm Out ) } ) } , gestures : Gestures ? Gestures : { pop : { . . . Base Left To Right Gesture , direction : "left -to -right " , full Distance : Width } } , . . . Base 
function socket Connection ( socket ) { const cookies = get Cookies ( socket . handshake . headers . cookie ) ; socket . session _start = Date . now ( ) ; socket . blurred = 0 ; socket . blurring = Date . now ( ) ; socket . req _id = cookies . na _req ; socket . session _id = cookies . na _session ; 
function socket Response ( socket ) { 
function get Session ( req , res , cb ) { const now = new Date ( ) ; const cookies = get Cookies ( req . headers . cookie ) ; 
function user Session ( ) { 
function set Cookies ( req , res , session , cb ) { const now = new Date ( ) ; 
function session Data ( req , res , session , cb ) { const now = new Date ( ) ; if ( session . continued ) return cb ( null , req , res , session ) ; async . parallel Limit ( [ get Ip , get Location , get System ] , 2 , function ( err ) { cb ( err , this . req , this . res , this . session ) ; if ( opts . log _all ) log . timer ( 'session Data ' , now ) ; } . bind ( { req : req , res : res , session : session } ) ) ; 
function get Location ( cb ) { if ( ! geo _lookup ) return cb ( null ) ; const loc = geo _lookup . get ( session . ip ) ; if ( ! session . geo ) session . geo = { } ; if ( loc ) { try { if ( loc . city ) session . geo . city = loc . city . names . en ; if ( loc . subdivisions ) session . geo . state = loc . subdivisions [ 0 ] . iso _code ; if ( loc . country ) session . geo . country = loc . country . iso _code ; if ( loc . continent ) session . geo . continent = loc . continent . code ; if ( loc . location ) session . geo . time _zone = loc . location . time _zone ; } catch ( e ) { log . error ( 'geo IP error : ' , e ) ; } } cb ( null ) } 
function get System ( cb ) { var agent = useragent . parse ( req . headers [ 'user -agent ' ] ) ; var os = agent . os ; if ( ! session . system ) session . system = { } ; if ( ! session . system . browser ) session . system . browser = { } ; if ( ! session . system . os ) session . system . os = { } ; session . system . browser . name = agent . family ; session . system . browser . version = agent . major + ' . ' + agent . minor + ' . ' + agent . patch ; session . system . os . name = os . family ; session . system . os . version = os . major + ' . ' + os . minor + ' . ' + os . patch ; cb ( null ) } 
function new Request ( req , res , session , cb ) { const now = new Date ( ) ; const request = { _id : ` $ { crypto . random Bytes ( 1 6 ) . to String ( 'hex ' ) } $ { Date . now ( ) } ` , host : req . hostname , url : req . url , method : req . method , referrer : req . get ( 'Referrer ' ) | | req . get ( 'Referer ' ) } ; 
function log Request ( req , res , session , request , cb ) { const now = new Date ( ) ; if ( opts . log ) { on Headers ( res , log _start . bind ( res ) ) ; on Finished ( res , req _log . bind ( { req : request , ses : session } ) ) ; } cb ( null , session , request ) ; if ( opts . log _all ) log . timer ( 'log Request ' , now ) ; 
function nano _time ( start ) { let t = conv ( process . hrtime ( ) ) - conv ( start ) ; 
function session Save ( session , request , cb ) { const now = new Date ( ) ; if ( ! session . continued ) { session . reqs = [ request ] ; Update . session ( session , { $set : session } , ( err , session ) = > { if ( err ) return cb ( 'db session save error ' ) ; if ( opts . log _all ) log . session ( session , 'session active [ new ] ' ) ; cb ( null , session ) ; if ( opts . log _all ) log . timer ( 'session Save 1 ' , now ) ; } ) } else { 
function Identify ( name ) { Update . session ( this , { $set : { name : name } } , ( err ) = > { if ( err ) log . error ( 'session .associate : name save error ' , err ) ; } ) ; } 
function get Cookies ( src ) { let cookies = cookie . parse ( src | | ' ' ) ; for ( let k in cookies ) { if ( k . index Of ( 'na _ ' ) = = = 0 ) { try { cookies [ k ] = AES . decrypt ( cookies [ k ] ) ; } catch ( err ) { log . error ( 'get Cookies error ' , err ) ; delete cookies [ k ] ; } } } return cookies ; } 
function sessions ( options , cb ) { if ( ! cb ) { cb = options ; options = { is _bot : false } ; } var n = 3 2 ; Session . find ( options ) . sort ( { date : 'desc ' } ) . limit ( n ) . exec ( function ( err , results ) { if ( err ) log . error ( 'Sessions query error : ' , err ) ; cb ( err , results ) } ) ; } 
function ( packet ) { this . update Payload = function ( packet ) { this . p _previous = this . p ; this . p = packet . payload ; this . changed = this . p _previous ! = this . p ; this . retained = packet . retain ; this . last Change = this . current Change ; this . current Change = new Date ( ) ; } ; this . changed From To = function ( from , to ) { return this . changed & & this . p _previous = = from & & this . p = = to ; } ; this . changed To = function ( to ) { return this . changed & & this . p = = to ; } ; this . changed From = function ( from ) { return this . changed & & this . p _previous = = from ; } ; this . t = packet . topic ; this . update Payload ( packet ) ; this . current Change = new Date ( ) ; this . last Change = undefined ; 
function ( ) { this . date = new Date ( ) ; this . get Hours = function ( ) { return this . date . get Hours ( ) ; } ; this . get Minutes = function ( ) { return this . date . get Minutes ( ) ; } ; this . hours Is Between = function ( a , b ) { if ( a < = b ) return this . date . get Hours ( ) > = a & & this . date . get Hours ( ) < = b ; else return this . date . get Hours ( ) > = a | | this . date . get Hours ( ) < = b ; } ; this . step = function ( ) { this . date = new Date ( ) ; this . is Morning = this . hours Is Between ( 6 , 1 1 ) ; this . is Noon = this . hours Is Between ( 1 2 , 1 4 ) ; this . is Afternoon = this . hours Is Between ( 1 5 , 1 7 ) ; this . is Evening = this . hours Is Between ( 1 8 , 2 3 ) ; this . is Night = this . hours Is Between ( 0 , 5 ) ; return this ; } ; } 
function Nools Fire ( n ) { RED . nodes . create Node ( this , n ) ; var node = this ; node . name = n . name ; node . topic = n . topic ; node . session = RED . nodes . get Node ( n . session ) . session ; node . messages = RED . nodes . get Node ( n . session ) . messages ; RED . nodes . get Node ( n . session ) . on ( "publish " , function ( msg ) { if ( ! node . topic | | node . topic = = = msg . topic ) { node . send ( msg ) ; } } ) ; node . session . on ( "fire " , function ( name , rule ) { node . send ( [ null , { topic : node . topic , payload : name , facts : node . session . get Facts ( ) , name : name } ] ) ; } ) ; } 
function Nools Flow Node ( n ) { RED . nodes . create Node ( this , n ) ; var node = this ; 
function distance ( f 1 _  , 1 _  , f _  , f 2  ) { return 2 * asin ( sqrt ( pow ( sin ( ( f 1 _  2 _  ) / 2 , 2 + cos ( f 1 _  ) os ( f 2 _  ) * p w (s i n ( ( f 1 _  - 2  ) / 2 , 2 ) ) ) ; } 
function course ( pos 1 , pos 2 ) { var f 1 _  os 1 [ 0 ] , f 1 _  os 1 [ 1 ] , f 2 _  os 2 [ 0 ] , f 2 _  os 2 [ 1 ] ; var d = distance ( f 1 _  , 1 _  , f _  , f 2  ) , a , o u se = { ; if ( sin ( f 2 _  1 _  ) < 0 { a = acos ( ( sin ( f 2 _  ) in ( f 1 _  ) * c s (d ) ) / ( i n (d ) * c s (f 1 _  ) ) ) ; } else { a = 2 *  cos ( ( s in ( f 2 _  ) - s n (f 1 _  ) * o (d ) ) / s n (d ) * o (f 1 _  ) ) ) ; } course . d = d ; course . a = a ; return course ; } 
function midpoint ( pos 1 , pos 2 ) { var Bx = Math . cos ( pos 2 .  ) ath . c os ( p os 2 .  - p s 1 .  ) ; var By = Math . cos ( pos 2 .  ) ath . s in ( p os 2 .  - p s 1 .  ) ; return {  : tan 2 ( s in ( p os 1 .  ) + s n (p o s 2 .  ) , sqrt ( ( cos ( pos 1 .  ) x ) c os ( p os 1 .  ) + B ) + B * B ) ) ,  : os 1 .  + a an 2 (B y , c s (p o s 1 .  ) + x } ; } 
function interpolate ( f 1 _  , 1 _  , f _  , f 2  , d , u f { for ( var i = 1 ; i < d ; i + = 1 ) { let f = i / d ,  istance ( f 1 _  , f _  , f 2  , f 2 _ ) ; let A = sin ( ( 1 - f ) *  ) in (  ) , B = sin ( f *  ) in (  ) ; let x = A * cos ( f 1 _  ) os ( f 1 _  ) + B * c s (f 2 _  ) * o (f 2 _  ) , z = A * cos ( f 1 _  ) in ( f 1 _  ) + B * c s (f 2 _  ) * i (f 2 _  ) , y = A * sin ( f 1 _  ) in ( f 2 _  ) ; let  tan 2 ( y , qrt ( p ow ( x , ) ow ( z , ) ) ) ,  tan 2 ( z , ) ; buf [ 2 * ( i - 1 ) + 0 ] =  ; buf [ 2 * ( i - 1 ) + 1 ] =  ; } } 
function centroid ( buf , b , . . . p ) { var n = p . length / 2 ; var sum _x = 0 , sum _z = 0 , sum _y = 0 ; for ( let i = 0 ; i < n ; i + = 1 ) { let i _  [ 2 ] , i _  [ 2 ] ; sum _x + = cos ( i _  ) os ( i _  ) ; sum _z + = cos ( i _  ) in ( i _  ) ; sum _y + = sin ( i _  ) ; } var x = sum _x / n , z = sum _z / n , y = sum _y / n ; var r = sqrt ( x * x + z * z + y * y ) ; var  sin ( y ) ,  tan 2 ( z , ) ; buf [ b + 0 ] =  ; buf [ b + 1 ] =  ; } 
function populate ( ) { var d = this . _divisions , max _x = 2 * d - 1 , buf = new Float 6 4Array ( ( d - 1 ) * 2 ) ; this . _positions = new Float 6 4Array ( ( 5 * 2 * d * d + 2 ) * 2 ) ; 
function ( req , cb ) { req = request . normalize Request ( req ) ; var page ; try { page = this . create Page For Request ( req ) ; } catch ( err ) { if ( cb ) return cb ( err ) else throw err ; } var need Data = typeof page . fetch Data = = = 'function ' & & ! this . state . request . data ; if ( request . is Equal ( this . state . request , req ) & & ! need Data ) return ; fetch Data For Request ( this , page , req , function ( err , req ) { if ( err ) { if ( cb ) return cb ( err ) else throw err ; } this . set State ( { request : req , page : page } ) ; } . bind ( this ) ) ; } 
function create ( format , options ) { const ogr Format = ogr Formats [ format ] 
function csv Params ( cmd , options ) { cmd . push ( ' -lco ' , 'WRITE _BOM =YES ' ) const has Point Geom = options . geometry = = = 'POINT ' const fields = options . fields . join ( ' | ' ) . to Lower Case ( ) . split ( ' | ' ) const has XY = fields . index Of ( 'x ' ) > - 1 & & fields . index Of ( 'y ' ) > - 1 if ( has Point Geom & & ! has XY ) cmd = cmd . concat ( [ ' -lco ' , 'GEOMETRY =AS _XY ' ] ) return cmd } 
function shapefile Params ( cmd , options ) { 
function barycenter Vertices And Faces ( sphere , options , done ) { var n = sphere . _Fields . length , positions = new Float 3 2Array ( n * 3 ) , indices = sphere . _interfield Triangles , colors = new Float 3 2Array ( indices . length * 3 ) ; for ( let f = 0 ; f < sphere . _Fields . length ; f + = 1 ) { let field = sphere . _Fields [ f ] , f _  phere . _ positions [ 2 ] , f _  phere . _ positions [ 2 ] , color = options . color Fn . call ( field ) ; positions [ f * 3 + 0 ] = cos ( f _  ) os ( f _  ) ; / x positions [ f * 3 + 2 ] = cos ( f _  ) in ( f _  ) ; / z positions [ f * 3 + 1 ] = sin ( f _  ) ; / y colors [ f * 3 + 0 ] = color . r ; colors [ f * 3 + 1 ] = color . g ; colors [ f * 3 + 2 ] = color . b ; } 
function field Vertices And Faces ( sphere , options , done ) { 
function _field Geometry ( ) { const ifi = this . _parent . _interfield Indices , ifc = this . _parent . _interfield Centroids , i = this . _i ; var max _  I nfinity , min _  nfinity , max _  I nfinity , min _  nfinity , mid _  his . _ parent . _ positions [ 2 ] , vertices = [ ] ; for ( let v = 0 ; v < this . _adjacent Fields . length ; v + = 1 ) { let  fc [ 2 fi [ 6 ] ] ,  fc [ 2 fi [ 6 ] ] ; max _  ax ( m ax _  ,  ; min _  in ( m in _  ,  ; max _  ax ( m ax _  ,  ; min _  in ( m in _  ,  ; vertices . push ( [  , ] ) ; } if ( i = = = 0 ) { max _  / 2 } if ( i = = = 1 ) { min _  / - ; } if ( i < 2 ) { min _   ; max _  ; vertices = [ [ min _  , ax _  ] , [ max _  , ax _  ] , [ max _  , in _  ] , [ min _  , in _  ] ] ; } else if ( max _  & in _  < 0 & ( i d _  < - | id  >  ) ) { 
function _populate Selection Grid ( bmp , geo , w , h ) { var w _rect =  , h _rect =  ; var min _x = floor ( geo . min _  _rect ) , max _x = ceil ( geo . max _  _rect ) , min _y = floor ( geo . min _  _rect ) , max _y = ceil ( geo . max _  _rect ) ; for ( let x = min _x ; x < = max _x ; x + = 1 ) { for ( let y = min _y ; y < = max _y ; y + = 1 ) { bmp . write ( x % w , y , inside ( [ x * w _rect -  , _rect / 2 , geo . vertices ) ) ; } } return { min _x , max _x , min _y , max _y } ; } 
function from Raster ( data , width , height , depth , map , done ) { var sphere = this ; populate Interfield Data . call ( sphere ) ; var bmp = new Bitmap ( width , height ) ; sphere . _Fields . for Each ( function ( field ) { var geo = _field Geometry . call ( field ) , selection = _populate Selection Grid ( bmp , geo , width , height ) ; var val Sums = [ ] , weight Sum = 0 ; for ( let z = 0 ; z < depth ; z + = 1 ) { val Sums [ z ] = 0 ; } for ( let x = selection . min _x ; x < selection . max _x ; x + = 1 ) { for ( let y = selection . min _y ; y < selection . max _y ; y + = 1 ) { let w = _test Points ( bmp , x , y ) / 4 ; for ( let z = 0 ; z < depth ; z + = 1 ) { val Sums [ z ] + = data [ ( height - y - 1 ) * width * depth + ( width - x - 1 ) * depth + z ] * w ; } weight Sum + = w ; } } if ( weight Sum < = 0 ) debugger ; 
function tethys ( selector , context ) { var nodes = [ ] ; 
function ( events , fn ) { events = events . split ( / \s * \ , \s * / ) ; return this . each ( function ( el ) { fn = fn . bind ( el ) ; events . for Each ( function ( event ) { el . add Event Listener ( event , fn ) ; } ) ; } ) ; } 
function ( key , value ) { var format = function ( key ) { return key . replace ( / ( - ( [a -z ] ) ) / g , function ( s , s 1 , s 2 ) { return s 2 . to Upper Case ( ) ; } ) ; } ; return key Value . call ( this , arguments , function ( el ) { return el . style [ format ( key ) ] ; } , function ( el , key , attrs ) { el . style [ format ( key ) ] = attrs [ key ] + ' ' ; } ) ; } 
function ( key , value ) { return key Value . call ( this , arguments , function ( el ) { return el . get Attribute ( key ) ; } , function ( el , key , attrs ) { el . set Attribute ( key , attrs [ key ] + ' ' ) ; } ) ; } 
function ( cls ) { var has = false , reg = new Reg Exp ( ' \ \b ' + cls + ' \ \b ' ) ; this . each ( function ( el ) { has = has | | ! ! el . class Name . match ( reg ) ; } ) ; return has ; } 
function ( ) { return this . each ( function ( el ) { if ( el . style . display = = = 'none ' ) { el . style . display = el . get Attribute ( 'o -d ' ) | | ' ' ; } ; } ) ; } 
function ( ) { return this . each ( function ( el ) { if ( el . style . display ! = = 'none ' ) { el . set Attribute ( 'o -d ' , el . style . display ) ; el . style . display = 'none ' ; } ; } ) ; } 
function ( ) { return this . each ( function ( el ) { var e = $ ( el ) ; e . css ( "display " ) = = "none " ? e . show ( ) : e . hide ( ) ; } ) ; } 
function ( child ) { var children = tethys ( child ) ; return this . each ( function ( el ) { children . each ( function ( child , i ) { el . append Child ( child ) ; } ) ; } ) ; } 
function ( selector ) { var nodes = [ ] ; this . each ( function ( el ) { tethys ( selector , el ) . each ( function ( node ) { nodes . push ( node ) ; } ) ; } ) ; return tethys ( nodes ) ; } 
function watcher Fn ( schema Filepath , watch Interval , reinit Babel Relay Plugin , prev Mtime ) { try { let stats ; try { stats = fs . stat Sync ( schema Filepath ) ; } catch ( e ) { 
function init Babel Relay Plugin ( plugin Options , babel , ref ) { const verbose = ! ! plugin Options . verbose ; const schema Filepath = plugin Options . schema | | ' ' ; let schema ; try { schema = fs . read File Sync ( schema Filepath , 'utf 8 ' ) ; } catch ( e ) { schema = null ; log ( 'Cannot load Graph QL Schema from file \ ' ' + schema Filepath + ' \ ' : ' + e ) ; } if ( schema ) { if ( verbose ) { log ( 'Graph QL Schema loaded successfully from \ ' ' + schema Filepath + ' \ ' ' ) ; } ref . babel Relay Plugin = require ( 'babel -plugin -relay ' ) ( babel ) ; } else { 
function Tap ( el ) { this . el = typeof el = = = 'object ' ? el : document . get Element By Id ( el ) ; this . moved = false ; 
function ( ) { var doc = document . document Element ; this . el = $ ( tpl ) ; this . el . hide ( ) . css ( { width : doc . client Width + 'px ' , height : doc . client Height + 'px ' } ) ; bind Tap Event ( this . el . find ( ' .as -cover ' ) [ 0 ] , this . hide . bind ( this ) ) ; $ ( 'body ' ) . append ( this . el ) ; return this ; } 
function ( buttons ) { var button Container = this . el . find ( ' .as -buttons ' ) ; 
function Opc Parse Stream ( options ) { Writable Stream . call ( this ) ; options = options | | { } ; this . _pushback = null ; this . data Format = options . data Format | | Opc Parse Stream . Data Format . BUFFER ; this . channel = ~ ~ options . channel | | 0 ; this . system Id = ~ ~ options . system Id | | 0xffff ; } 
function Akamai Purge ( username , password , objects , options ) { var auth = { } , request Body = { } , request Options ; 
function ( ) { 
function Akamai Queue Length ( username , password ) { var request Options , auth = { } ; auth . username = username ; auth . password = password ; request Options = { uri : constants . AKAMAI _API _QUEUE , method : 'GET ' , auth : auth , json : true } ; return Akamai Request ( request Options ) ; } 
function Mock ( mount , options ) { 
function Akamai Status ( username , password , progress Uri ) { var request Options , auth = { } ; auth . username = username ; auth . password = password ; request Options = { uri : constants . AKAMAI _API _BASE + progress Uri , method : 'GET ' , auth : auth , json : true } ; return Akamai Request ( request Options ) . then ( function ( response ) { 
function Akamai Request ( request Options ) { 
function dean _add Event ( element , type , handler ) { if ( element . add Event Listener ) { element . add Event Listener ( type , handler , false ) ; } else { 
function for Each ( object , block , context ) { if ( object ) { let resolve = Object ; 
function ( target , source ) { var skeys = _ . keys ( source ) ; _ . each ( skeys , function ( skey ) { if ( ! target [ skey ] ) { target [ skey ] = source [ skey ] ; } } ) ; return target ; } 
function ( origin , target , plan , mode , out , complete Cb ) { var c ; var container ; var container Def ; out . init Progress ( plan . length , ' - - > deploying plan . . . ' ) ; var curr Progress = 0 ; var prnt ; function tick ( command , c ) { curr Progress + = 1 ; out . progress ( command + ' ' + c . id + ' ' + ( c . type | | ' ' ) ) ; } logger . info ( 'deploying plan ' ) ; async . each Series ( plan , function ( step , cb ) { c = target . topology . containers [ step . id ] | | origin . topology . containers [ step . id ] ; container = _ . clone Deep ( c ) ; prnt = target . topology . containers [ step . parent ] | | origin . topology . containers [ step . parent ] ; container Def = _ . find ( target . container Definitions , function ( cdef ) { return cdef . id = = = container . container Definition Id ; } ) ; if ( ! container Def ) { container Def = _ . find ( origin . container Definitions , function ( cdef ) { return cdef . id = = = container . container Definition Id ; } ) ; } if ( container . specific & & origin . topology . containers [ step . id ] & & origin . topology . containers [ step . id ] . specific ) { container . specific = merge ( container . specific , origin . topology . containers [ step . id ] . specific ) ; } logger . info ( 'calling : ' + step . cmd ) ; 
function create Object ( proto , args ) { var instance = Object . create ( proto ) ; if ( instance . $meta . constructors ) { instance . $meta . constructors . for Each ( function ( constructor ) { constructor . apply ( instance , args ) ; } ) ; } return instance ; } 
function merge ( destination , source ) { for ( var property in source ) { if ( source . has Own Property ( property ) ) { merge Property ( destination , source , property ) ; } } return destination ; } 
function merge Property ( destination , source , property ) { if ( source [ property ] instanceof Array ) { merge As Array ( destination , source , property ) ; } else if ( is Primitive ( source [ property ] ) | | ! is Literal ( source [ property ] ) ) { override If Not Exists ( destination , source , property ) ; } else { merge As Object ( destination , source , property ) ; } } 
function merge As Array ( destination , source , property ) { destination [ property ] = source [ property ] . concat ( destination [ property ] | | [ ] ) ; } 
function merge As Object ( destination , source , property ) { destination [ property ] = destination [ property ] | | { } ; merge ( destination [ property ] , source [ property ] ) ; } 
function mix ( destination , source ) { for ( var property in source ) { if ( property . substr ( 0 , 2 ) ! = = " _ _ " & & ! ( property in destination ) ) { destination [ property ] = source [ property ] ; } } return destination ; } 
function mixin ( instance , mixins ) { mixins . for Each ( function ( Mixin ) { mix ( instance , Mixin ) ; } ) ; return instance ; } 
function Coined ( options ) { var self = this , db Type , db Dir , db Path ; if ( ! ( this instanceof Coined ) ) { return new Coined ( options ) ; } Event Emitter . call ( this ) ; options = options | | { } ; options . db = options . db | | { } ; db Type = options . db . type | | 'tiny ' ; db Dir = db Type = = = 'level ' ? ' .coined .level ' : ' .coined ' ; db Path = db Type = = = 'level ' ? path . resolve ( process . env . HOME , db Dir ) : path . resolve ( process . env . HOME , db Dir , 'db ' ) ; options . db . type = options . db . type | | db Type ; options . db . path = options . db . path | | db Path ; if ( options . db . clear ) { cleanup ( options . db . path ) ; } if ( options . db . type = = = 'level ' ) { mkdirp ( options . db . path ) ; this . db = require ( 'levelup ' ) ( options . db . path , { db : require ( 'leveldown ' ) , value Encoding : 'json ' } ) ; } else if ( options . db . type = = = 'tiny ' ) { mkdirp ( path . resolve ( options . db . path , ' . . ' ) ) ; this . db = require ( 'tiny ' ) . json ( { file : options . db . path , save Index : false , initial Cache : false } ) ; } else { throw new Error ( 'Invalid DB type . ' ) ; } this . options = options ; this . socket Index = 0 ; this . crypto = options . crypto ; this . compressed = options . compressed ! = null ? options . compressed : true ; this . wallet Path = options . wallet Path | | options . wallet | | process . env . HOME + ' / .coined /wallet .json ' ; this . addr = null ; this . dust = 5 4 6 0 ; this . fee = 1 0 0 0 0 ; mkdirp ( path . dirname ( this . wallet Path ) ) ; this . account = null ; this . accounts = [ ] ; this . aaccounts = { } ; this . laccounts = { } ; this . recipients = { } ; if ( options . no Preload ) { this . _clear Preload ( ) ; } this . pool = options . pool | | bcoin . pool ( { size : options . size , create Connection : function ( ) { if ( self . socket Index > = seeds . length ) { self . socket Index = 0 ; } if ( seeds . length > 3 0 0 0 ) { seeds = seeds . slice ( 0 , 1 5 0 0 ) ; self . socket Index = 0 ; } var addr = seeds [ self . socket Index + + ] , parts = addr . split ( ' : ' ) , host = parts [ 0 ] , port = + parts [ 1 ] | | network . port , socket ; socket = net . connect ( port , host ) ; socket . on ( 'connect ' , function ( ) { var peers = [ ] . concat ( self . pool . peers . pending , self . pool . peers . block , self . pool . peers . load ) . filter ( Boolean ) ; for ( var i = 0 ; i < peers . length ; i + + ) { var peer = peers [ i ] ; if ( peer . socket ! = = socket ) { continue ; } if ( peer . version ) { return self . emit ( 'peer ' , peer , socket ) ; } return peer . parser . on ( 'packet ' , function callee ( payload ) { if ( payload . cmd ! = = 'version ' ) return ; peer . remove Listener ( 'packet ' , callee ) ; return set Immediate ( function ( ) { self . emit ( 'peer ' , peer , socket ) ; } ) ; } ) ; } self . _log ( 'Connected to %s : %d ' , host , port ) ; } ) ; return socket ; } , storage : this . db , start Height : options . start Height , full Node : options . full Node 
function mkdirp ( dir , made ) { var mode = 0 7 7 7 & ( ~ process . umask ( ) ) ; if ( ! made ) made = null ; dir = path . resolve ( dir ) ; try { fs . mkdir Sync ( dir , mode ) ; made = made | | dir ; } catch ( err 0 ) { switch ( err 0 . code ) { case 'ENOENT ' : made = mkdirp ( path . dirname ( dir ) , made ) ; mkdirp ( dir , made ) ; break ; default : var stat ; try { stat = fs . stat Sync ( dir ) ; } catch ( err 1 ) { throw err 0 ; } if ( ! stat . is Directory ( ) ) throw err 0 ; break ; } } return made ; } 
function ( obj ) { if ( _ . is Array ( obj ) ) { for ( var i = 0 ; i < obj . length ; i + + ) { obj [ i ] = walker ( obj [ i ] ) ; } } else if ( _ . is Plain Object ( obj ) ) { var new Obj = { } ; for ( var k in obj ) { if ( ! obj . has Own Property ( k ) ) continue ; var include = true ; if ( options . rename Fields [ k ] ) { new Obj [ options . rename Fields [ k ] ] = obj [ k ] ; include = false ; } for ( var rf in options . remove Fields ) { if ( _ . is Reg Exp ( options . remove Fields [ rf ] ) ) { if ( options . remove Fields [ rf ] . test ( k ) ) include = false ; } else { 
function fileext ( type , path ) { if ( ! path ) path = type , type = false ; var file _arr = path . match ( / ( [ ^ : \ \ / ] * ? ) ( ? : \ . ( [ ^ : \ \ / . ] * ) ) $ / ) var fileext = file _arr [ 2 ] ; var name = file _arr [ 1 ] ; var new _name = ' ' switch ( type ) { case "min " : new _name = name + ' .min . ' + fileext ; break ; case "map " : new _name = name + ' .min .map ' ; break ; case "gz " : new _name = name + ' .min .gz ' ; break ; default : new _name = file _arr [ 0 ] ; } return new _name ; } 
function format _number ( size , precision ) { var decimal , factor ; if ( precision = = null ) precision = 1 ; factor = Math . pow ( 1 0 , precision ) ; decimal = Math . round ( size * factor ) % factor ; return parse Int ( size ) + " . " + decimal ; } 
function report _size ( file ) { return echo ( "  " + c c .x t erm ( 1 6 1 ) ( f i le ) " " + ( o rmat _number (f s ize (f i le ) / 1 2 4 ) ) + " Ki B " ) ; } 
function ( identifier , target , cb ) { logger . info ( 'get head system : ' + identifier ) ; var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } _sr . get Head ( system Id , target , cb ) ; } 
function ( identifier , target , cb ) { var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } fetch Target ( system Id , target , function ( err , target ) { if ( err ) { return cb ( err ) ; } logger . info ( { system Id : system Id , target : target } , 'get deployed system ' ) ; _sr . get Deployed Revision ( system Id , target , cb ) ; } ) ; } 
function ( user , name , namespace , cwd , cb ) { logger . info ( 'create system name : ' + name + ' , namespace : ' + namespace + ' , cwd : ' + cwd ) ; _sr . create System ( user , namespace , name , cwd , cb ) ; } 
function ( user , path , cwd , cb ) { logger . info ( 'link system : ' + path + ' , ' + cwd ) ; _sr . link System ( user , path , cwd , cb ) ; } 
function ( user , identifier , cb ) { var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { return cb ( new Error ( ERR _NOSYSID ) ) ; } logger . info ( 'unlink system : ' + system Id ) ; _sr . unlink System ( user , system Id , cb ) ; } 
function ( identifier , revision Id , out , cb ) { logger . info ( 'list containers : ' + identifier ) ; var system Id = _sr . find System ( identifier ) ; var containers = { } ; if ( ! system Id ) { return cb ( new Error ( ERR _NOSYSID ) ) ; } _builder . load Targets ( system Id , revision Id , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _ . each ( targets , function ( target ) { _ . each ( target . container Definitions , function ( cdef ) { containers [ cdef . id ] = cdef ; } ) ; } ) ; cb ( null , _ . values ( containers ) ) ; } ) ; } 
function ( user , identifier , container Identifier , revision , target , out , cb ) { var container Def ; var system Id ; system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } var system Root = _sr . repo Path ( system Id ) ; out . init Progress ( 9 , ' - - > finding container ' ) ; fetch Target ( system Id , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . load Matching Targets ( system Id , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _builder . find Container ( system Id , revision , targets , container Identifier , function ( err , container Def Id , targets ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } if ( ! container Def Id ) { out . stdout ( ERR _NOCDEF ) ; logger . error ( ERR _NOCDEF ) ; return cb ( ERR _NOCDEF ) ; } async . each Series ( _ . values ( targets ) , function ( json , cb ) { var root = build Sys ( json ) ; container Def = root . container Def By Def Id ( container Def Id ) ; json . repo Path = system Root ; if ( ! container Def . specific | | ! container Def . specific . repository Url ) { return _builder . build ( user , system Id , targets , json , container Def , target , out , cb ) ; } _synchrotron . synch ( json , container Def , out , function ( err ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } _builder . build ( user , system Id , targets , json , container Def , target , out , cb ) ; } ) ; } , cb ) ; } ) ; } ) ; } ) ; } 
function ( user , system Name , revision , target , out , cb ) { var system Id = _sr . find System ( system Name ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } logger . info ( { system Id : system Id , revision : revision } , 'building all containers ' ) ; fetch Target ( system Id , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . load Matching Targets ( system Id , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } out . stdout ( ' - - > building all containers for ' + targets [ Object . keys ( targets ) [ 0 ] ] . name + ' revision ' + revision + ' target ' + target ) ; var containers = _ . chain ( targets ) . filter ( function ( value , key ) { return target = = = 'alltargets ' | | key = = = target ; } ) . map ( function ( target ) { return _ . map ( target . container Definitions , function ( cdef ) { return { id : cdef . id , target : target . topology . name , type : cdef . type } ; } ) ; } ) . flatten ( ) . reduce ( function ( acc , cont ) { var not Present = ! _ . find ( acc , function ( found ) { return found . id = = = cont . id & & found . type = = = cont . type ; } ) ; if ( not Present ) { acc . push ( cont ) ; } return acc ; } , [ ] ) . value ( ) ; async . each Series ( containers , function ( cont , next ) { build Container ( user , system Id , cont . id , revision , cont . target , out , function ( err ) { if ( err ) { out . stderr ( err ) ; } 
function ( system Id , target , revision , cb ) { if ( target = = = 'alltargets ' ) { cb ( null , target ) ; } else { _sr . get Deployed Revision Id ( system Id , target , function ( err , deployed Rev Id ) { if ( typeof revision = = = 'function ' ) { cb = revision ; if ( ! err ) { revision = deployed Rev Id ; } else { revision = 'latest ' ; } } _builder . load Targets ( system Id , revision , function ( err , targets ) { if ( err ) { return cb ( err ) ; } var candidates = Object . keys ( targets ) . filter ( function ( candidate ) { return candidate . index Of ( target ) > = 0 ; } ) ; if ( candidates . length = = = 0 | | candidates . length > 1 ) { logger . error ( ERR _NOTARGET ) ; return cb ( new Error ( ERR _NOTARGET ) ) ; } else { target = candidates [ 0 ] ; } cb ( null , target ) ; } ) ; } ) ; } } 
function ( user , identifier , revision Identifier , target , mode , out , cb ) { var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } fetch Target ( system Id , target , revision Identifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . find Revision ( system Id , revision Identifier , function ( err , revision Id ) { if ( err ) { out . stdout ( ERR _NOREV ) ; logger . error ( ERR _NOREV ) ; return cb ( ERR _NOREV ) ; } logger . info ( { system Id : system Id , revision Id : revision Id , environment : target } , 'deploy revision ' ) ; if ( ! mode ) { mode = 'live ' ; } if ( ! revision Id ) { return cb ( new Error ( 'revision Id is needed to deploy ' ) ) ; } return create Analyze And Deploy Task ( user , system Id , revision Id , target , mode , out , cb ) ; } ) ; } ) ; } 
function ( user , identifier , revision Identifier , target , out , cb ) { logger . info ( 'preview revision : ' + identifier + ' , ' + revision Identifier + ' ' + target ) ; deploy Revision ( user , identifier , revision Identifier , target , 'preview ' , out , function ( err ) { cb ( err , { plan : out . get Plan ( ) , ops : out . operations ( ) } ) ; } ) ; } 
function ( identifier , cb ) { logger . info ( 'list revisions : ' + identifier ) ; if ( ! identifier ) { return cb ( new Error ( 'no identifier ' ) ) ; } var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { return cb ( new Error ( 'system not found ' ) ) ; } _sr . list Revisions ( system Id , function ( err , revisions ) { cb ( err , _ . first ( revisions , 2 0 ) ) ; 
function ( identifier , revision Identifier , target , cb ) { logger . info ( 'get revision : ' + identifier + ' , ' + revision Identifier ) ; var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } fetch Target ( system Id , target , revision Identifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . find Revision ( system Id , revision Identifier , function ( err , revision Id ) { if ( err ) { return cb ( err ) ; } _sr . get Revision ( system Id , revision Id , target , cb ) ; } ) ; } ) ; } 
function ( identifier , cb ) { var system Id = _sr . find System ( identifier ) ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } _sr . get Timeline ( system Id , function ( err , timeline ) { cb ( err , { entries : timeline } ) ; } ) ; } 
function ( user , identifier , comment , out , cb ) { logger . info ( 'compile system : ' + identifier ) ; var system Id = _sr . find System ( identifier ) ; var system ; if ( ! system Id ) { logger . error ( ERR _NOSYSID ) ; return cb ( new Error ( ERR _NOSYSID ) ) ; } var repo Path = _sr . repo Path ( system Id ) ; _compiler . compile ( system Id , repo Path , out , function ( err , systems ) { if ( err ) { return cb ( err ) ; } async . each Series ( _ . keys ( systems ) , function ( key , next ) { system = systems [ key ] ; _sr . write File ( system . id , key + ' .json ' , JSON . stringify ( system , null , 2 ) , next ) ; } , function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function ( user , identifier , comment , out , cb ) { logger . info ( 'commit system : ' + identifier ) ; var system Id = _sr . find System ( identifier ) ; _sr . commit Revision ( user , system Id , comment , function ( err , revision Id ) { _sr . get Deployed Targets ( system Id , function ( err , targets ) { if ( targets ) { async . each Series ( targets , function ( target , next ) { if ( target . commit = = = 'edits ' ) { _sr . mark Deployed Revision ( user , system Id , revision Id , target . env , function ( ) { next ( ) ; } ) ; } else { next ( ) ; } } , function ( ) { cb ( err , revision Id ) ; } ) ; } else { cb ( err , revision Id ) ; } } ) ; } ) ; } 
function ( src , destination ) { grunt . verbose . writeln ( "Adding entries to be coffeeified /browserified : " + src ) ; var browserify Instance = browserify ( src ) ; return { dest : destination , instance : browserify Instance } ; } 
function finalize Build ( source Report ) { 
function inject Code ( ) { var fullpath = path . join ( rootpath , "app .js " ) ; var source = fs . read File Sync ( fullpath , 'utf 8 ' ) ; var test = / \ / \ /ALLOY -RESOLVER / . test ( source ) ; logger . trace ( "CODE INJECTED ALREADY : " + test ) ; if ( ! test ) { source = source . replace ( / (var \s +Alloy [ ^ ; ] + ; ) / g , " $ 1 \n / /ALLOY -RESOLVER \nvar process =require ( ' /process ' ) ; \n Alloy .resolve =new (require ( ' /resolver ' ) ) ( ) .resolve ; \n " ) ; fs . write File Sync ( fullpath , source ) ; } } 
function fix Files ( ) { logger . trace ( "inside fix Files ( ) " ) ; _ . each ( registry . files , function ( file ) { var fullpath = path . join ( rootpath , file ) ; var basepath = path . posix . dirname ( file ) ; var basefile = path . posix . resolve ( file ) ; var source = fs . read File Sync ( fullpath , 'utf 8 ' ) ; logger . trace ( "fixing file : " + fullpath ) ; var require Regex = / (require ) \s * \ ( ( ( ? : [ ^ ) ( ] + | \ ( ( ? : [ ^ ) ( ] + | \ ( [ ^ ) ( ] * \ ) ) * \ ) ) * ) \ ) / g ; var static Require Regex = / (require ) ( ? : \ ( \s * [ ' " ] ) ( [ ^ ' " ] + ) ( ? : [ ' " ] \s * \ ) ) / g ; source = source . replace ( require Regex , function ( $ 1 , $ 2 , $ 3 ) { var requested Module = $ 2 ; if ( static Require Regex . test ( $ 1 ) ) { var static Require Source = $ 1 ; static Require Source = static Require Source . replace ( static Require Regex , function ( $ 1 , $ 2 , $ 3 ) { var resolved _path = resolver . resolve ( $ 3 , basepath ) ; return 'require ( " ' + resolved _path + ' " ) ' ; } ) ; return static Require Source ; } else { return 'require (Alloy .resolve ( ' + $ 3 + ' , " ' + basepath + ' " ) ) ' ; } } ) ; fs . write File Sync ( fullpath , source , { mode : 0o 7 5 5 } ) ; } ) ; } 
function replace Back Slashes ( input ) { var is Extended Length Path = / ^ \ \ \ \ \ ? \ \ / . test ( input ) ; var has Non Ascii = / [ ^ \x 0 0 - \x 8 0 ] + / . test ( input ) ; if ( is Extended Length Path | | has Non Ascii ) { return input ; } return input . replace ( / \ \ / g , ' / ' ) ; } 
function find Files ( rootpath , patterns ) { logger . trace ( "inside find Files ( ) " ) ; var patterns = patterns | | [ ' * * ' ] ; if ( _ . is String ( patterns ) ) { patterns = [ patterns ] ; } var files = _ . map ( wrench . readdir Sync Recursive ( rootpath ) , function ( filename ) { return path . posix . sep + replace Back Slashes ( filename ) ; } ) ; var matched Files = match ( files , patterns , { nocase : true , match Base : true , dot : true , } ) ; return _ . filter ( matched Files , function ( file ) { return ! fs . stat Sync ( path . join ( rootpath , file ) ) . is Directory ( ) ; } ) | | [ ] ; } 
function match ( list , patterns , options ) { list = list | | [ ] ; patterns = patterns | | [ ] ; if ( _ . is String ( patterns ) ) { patterns = [ patterns ] ; } if ( list . length = = = 0 | | patterns . length = = = 0 ) { return [ ] ; } options = options | | { } ; return patterns . reduce ( function ( ret , pattern ) { var process = _ . union if ( pattern [ 0 ] = = = ' ! ' ) { pattern = pattern . slice ( 1 ) ; process = _ . difference ; } return process ( ret , minimatch . match ( list , pattern , options ) ) ; } , [ ] ) ; } 
function load Files ( ) { logger . trace ( "inside load Files ( ) " ) ; var allfiles = find Files ( rootpath , includes ) ; var filepaths = _ . filter ( allfiles , function ( filepath ) { return ! / . + (package \ .json ) / . test ( filepath ) ; } ) ; _ . for Each ( filepaths , function ( filepath ) { registry . files . push ( filepath ) ; } ) ; var packagepaths = _ . filter ( allfiles , function ( filepath ) { return ( / . + (package \ .json ) / . test ( filepath ) ) ; } ) ; _ . for Each ( packagepaths , function ( filepath ) { var content = fs . read File Sync ( path . posix . join ( rootpath , filepath ) , 'utf 8 ' ) ; var json = JSON . parse ( content ) ; if ( json . main ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : path . posix . resolve ( path . posix . join ( path . posix . dirname ( filepath ) , json . main ) ) } ) ; } } ) ; var indexpaths = _ . filter ( allfiles , function ( filepath ) { return ( / . + (index \ .js ) / . test ( filepath ) ) ; } ) ; _ . for Each ( indexpaths , function ( filepath ) { var existingdir = _ . find ( registry . directories , function ( dir ) { return dir . id = = = path . posix . dirname ( filepath ) ; } ) ; if ( ! existingdir ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : filepath } ) ; } } ) ; return registry ; } 
function write Registry ( ) { logger . trace ( "inside write Registry ( ) " ) ; var filepath = path . join ( rootpath , "resolver .js " ) ; var content = fs . read File Sync ( filepath , 'utf 8 ' ) ; var regex = / (var \s +registry \s + = \s + ) [ ^ ; ] * ( ; ) / g ; var modified = content . replace ( regex , " $ 1 " + JSON . stringify ( registry ) + " $ 2 " ) ; fs . write File Sync ( filepath , modified ) ; } 
function get First Letter ( text ) { var matches = text . match ( first Letter Regex ) ; if ( null = = = matches ) { return ' ' ; } 
function set Theme ( theme ) { const navigation Options = get Navigation Options ( theme ) const content Offset = theme . default Values . colors . header Opacity < 1 ? ( theme . system Values . is IOS ? theme . system Values . status Bar Height : 0 ) + theme . system Values . navigation Bar Height : 0 return { type : CONSTANTS . theme . set Theme , theme , navigation Options , 
function theme Reducer ( state = initial State , action ) { switch ( action . type ) { case CONSTANTS . theme . set Theme : return { . . . state , theme : action . theme , navigation Options : action . navigation Options , content Offset : action . content Offset , } default : return state } } 
function uri ( val ) { var parts , scheme , authority , path ; if ( ! is String ( val ) ) { return false ; } 
function build ( mode , system , cdef , out , cb ) { _containers . get Handler ( system , cdef . type , function ( err , container ) { if ( err ) { return cb ( err ) ; } if ( ! container ) { err = new Error ( 'no matching container available for type : ' + cdef . type ) ; logger . error ( err . message ) ; return cb ( err ) ; } if ( container . build ) { out . progress ( ' - - > executing container specific build for ' + cdef . id ) ; logger . info ( { container Definition : cdef . id } , 'executing container specific build ' ) ; container . build ( mode , system , cdef , out , function ( err , specific ) { if ( err ) { logger . error ( err ) ; out . stdout ( err ) ; return cb ( err ) ; } out . progress ( ' - - > ' + cdef . id + ' built ' ) ; logger . info ( { container Definition : cdef . id } , 'built ' ) ; cb ( err ) ; } ) ; } else { out . progress ( ' - - > no need to build ' + cdef . id ) ; cb ( null , { } ) ; } } ) ; } 
function find Container ( system Id , revision , targets , container Identifier , cb ) { var cdef Id ; var types = [ ] ; async . filter ( _ . keys ( targets ) , function ( key , next ) { _sr . find Container ( system Id , revision , container Identifier , key , function ( err , container Def Id , cdef ) { var def ; if ( ! err & & container Def Id ) { cdef Id = container Def Id ; def = _ . find ( targets [ key ] . container Definitions , function ( def ) { return def . id = = = cdef Id ; } ) ; if ( types . index Of ( def . type ) < 0 ) { types . push ( def . type ) ; return next ( true ) ; } } next ( false ) ; } ) ; } , function ( keys ) { var result = keys . reduce ( function ( acc , key ) { acc [ key ] = targets [ key ] ; return acc ; } , { } ) ; cb ( null , cdef Id , result ) ; } ) ; } 
function merge Emoji ( child , index , parent ) { var siblings = parent . children var value = to String ( child ) var sibling Index var node var nodes var subvalue var left var right var left Match var right Match var start var pos var end var replace var start Index var next Sibling var next Next Sibling var possible Emoji var max Sibling Index var loop Index var last Sibling var last Sibling Index if ( child . type = = = 'Word Node ' ) { if ( own . call ( unicodes , value ) ) { node = { type : EMOTICON _NODE , value : value } if ( child . position ) { node . position = child . position } siblings [ index ] = node } else { node = siblings [ index - 1 ] if ( node & & own . call ( unicodes , to String ( node ) + value ) ) { node . type = EMOTICON _NODE node . value = to String ( node ) + value if ( child . position & & node . position ) { node . position . end = child . position . end } siblings . splice ( index , 1 ) return index } } } else if ( own . call ( unicodes , value ) ) { child . type = EMOTICON _NODE start Index = index + 1 next Sibling = siblings [ start Index ] if ( ! next Sibling ) { return } if ( next Sibling . type = = = 'Word Node ' ) { if ( ! is Variance Selector ( next Sibling ) ) { return } possible Emoji = value + to String ( next Sibling ) max Sibling Index = siblings . length loop Index = start Index + 1 while ( loop Index < max Sibling Index & & loop Index - start Index < 5 & & siblings [ loop Index ] . type ! = = 'Word Node ' ) { possible Emoji + = to String ( siblings [ loop Index ] ) loop Index + + } last Sibling = siblings [ loop Index ] if ( last Sibling & & last Sibling . type = = = 'Word Node ' ) { possible Emoji + = to String ( last Sibling ) } if ( own . call ( unicodes , possible Emoji ) ) { child . value = possible Emoji if ( child . position & & last Sibling . position ) { child . position . end = last Sibling . position . end } siblings . splice ( index + 1 , loop Index - index ) return index + 1 } } else if ( next Sibling . type = = = 'Symbol Node ' ) { possible Emoji = value + to String ( next Sibling ) max Sibling Index = siblings . length loop Index = start Index + 1 while ( loop Index < max Sibling Index & & loop Index - start Index < 5 & & ( siblings [ loop Index ] . type = = = 'Symbol Node ' | | ( siblings [ loop Index ] . type = = = 'Word Node ' & & is Variance Selector ( siblings [ loop Index ] ) ) ) ) { possible Emoji + = to String ( siblings [ loop Index ] ) loop Index + + } if ( own . call ( unicodes , possible Emoji ) ) { child . value = possible Emoji last Sibling Index = loop Index - 1 last Sibling = siblings [ last Sibling Index ] if ( child . position & & last Sibling . position ) { child . position . end = last Sibling . position . end } siblings . splice ( index + 1 , last Sibling Index - index ) return index + 1 } } } else if ( child . type = = = 'Symbol Node ' ) { next Sibling = siblings [ index + 1 ] next Next Sibling = siblings [ index + 2 ] if ( ! next Sibling | | ! next Next Sibling ) { return } if ( ( next Sibling . type = = = 'Symbol Node ' | | next Sibling . type = = = 'Word Node ' ) & & next Next Sibling & & next Next Sibling . type = = = 'Symbol Node ' ) { possible Emoji = value + to String ( next Sibling ) + to String ( next Next Sibling ) if ( own . call ( unicodes , possible Emoji ) ) { child . type = EMOTICON _NODE child . value = possible Emoji if ( child . position & & next Next Sibling . position ) { child . position . end = next Next Sibling . position . end } siblings . splice ( index + 1 , 2 ) return index + 1 } } } else if ( value . char At ( 0 ) = = = ' : ' ) { nodes = [ ] sibling Index = index subvalue = value left = null right = null left Match = null right Match = null if ( subvalue . length = = = 1 ) { right Match = child } else { end = child . position & & child . position . end start = end & & child . position . start pos = end & & { line : start . line , column : start . column + 1 , offset : start . offset + 1 } right Match = { type : 'Punctuation Node ' , value : ' : ' } right = { type : 'Punctuation Node ' , value : subvalue . slice ( 1 ) } if ( end ) { right Match . position = { start : start , end : pos } right . position = { start : pos , end : end } } } while ( sibling Index - - ) { if ( index - sibling Index > MAX _GEMOJI _PART _COUNT ) { return } node = siblings [ sibling Index ] subvalue = to String ( node ) if ( subvalue . char At ( subvalue . length - 1 ) = = = ' : ' ) { left Match = node break } if ( node . children ) { nodes = nodes . concat ( node . children . concat ( ) . reverse ( ) ) } else { nodes . push ( node ) } if ( sibling Index = = = 0 ) { return } } if ( ! left Match ) { return } subvalue = to String ( left Match ) if ( subvalue . length ! = = 1 ) { end = left Match . position & & left Match . position . end start = end & & left Match . position . start pos = end & & { line : end . line , column : end . column - 1 , offset : end . offset - 1 } left = { type : 'Punctuation Node ' , value : subvalue . slice ( 0 , - 1 ) } left Match = { type : 'Punctuation Node ' , value : ' : ' } if ( end ) { left . position = { start : start , end : pos } left Match . position = { start : pos , end : end } } } nodes . push ( left Match ) nodes . reverse ( ) . push ( right Match ) value = to String ( nodes ) if ( shortcodes . index Of ( value ) = = = - 1 ) { return } replace = [ sibling Index , index - sibling Index + 1 ] if ( left ) { replace . push ( left ) } child . type = EMOTICON _NODE child . value = value if ( child . position & & left Match . position ) { child . position . start = left Match . position . start } if ( child . position & & right Match . position ) { child . position . end = right Match . position . end } replace . push ( child ) if ( right ) { replace . push ( right ) } ; [ ] . splice . apply ( siblings , replace ) return sibling Index + 3 } } 
function get Start Row ( id ) { let r ; for ( let j in Tbl Id ) { if ( Tbl Id [ j ] = = = id ) r = Start Row [ j ] ; } return r ; } 
function get Child Elms ( n ) { if ( n . node Type = = 1 ) { let enfants = n . child Nodes ; for ( let i = 0 ; i < enfants . length ; i + + ) { let child = enfants [ i ] ; if ( child . node Type = = 3 ) n . remove Child ( child ) ; } return n ; } } 
function get Filters ( id ) { Search Flt = [ ] ; let t = document . get Element By Id ( id ) ; let tr = t . get Elements By Tag Name ( "tr " ) [ 0 ] ; let inp = tr . get Elements By Tag Name ( "input " ) ; for ( let i = 0 ; i < inp . length ; i + + ) Search Flt . push ( inp [ i ] . get Attribute ( "id " ) ) ; return Search Flt ; } 
function get Cells Nb ( id , nrow ) { let t = document . get Element By Id ( id ) ; let tr ; if ( nrow = = undefined ) tr = t . get Elements By Tag Name ( "tr " ) [ 0 ] ; else tr = t . get Elements By Tag Name ( "tr " ) [ nrow ] ; let n = get Child Elms ( tr ) ; return n . child Nodes . length ; } 
function ( url , db ) { this . server = new Drowsy . Server ( url ) ; this . db = this . server . database ( db ) ; * Group model * / this . Group = this . db . Document ( 'groups ' ) . extend ( { add Group : function ( group ) { var groups = _ . clone ( this . get ( 'groups ' ) ) ; groups . push ( group ) ; this . set ( 'groups ' , _ . uniq ( group ) ) ; } } ) ; this . Groups = this . db . Collection ( 'groups ' ) . extend ( { model : this . Group } ) ; * Model for Cohorts * / this . Cohort = this . db . Document ( 'cohorts ' ) . extend ( { add Discussion : function ( discussion Id ) { var discussions = _ . clone ( this . get ( 'discussions ' ) ) ; * Model for Discussions * / this . Discussion = this . db . Document ( 'discussions ' ) . extend ( { } ) ; this . Discussions = this . db . Collection ( 'discussions ' ) . extend ( { model : this . Discussion } ) ; } 
function normalize String Posix ( path , allow Above Root ) { var res = ' ' ; var last Slash = - 1 ; var dots = 0 ; var code ; for ( var i = 0 ; i < = path . length ; + + i ) { if ( i < path . length ) code = path . char Code At ( i ) ; else if ( code = = = 4 7 ) break ; else code = 4 7 ; if ( code = = = 4 7 ) { if ( last Slash = = = i - 1 | | dots = = = 1 ) { 
function resolve ( ) { var resolved Device = ' ' ; var resolved Tail = ' ' ; var resolved Absolute = false ; for ( var i = arguments . length - 1 ; i > = - 1 ; i - - ) { var path ; if ( i > = 0 ) { path = arguments [ i ] ; } else if ( ! resolved Device ) { path = process . cwd ( ) ; } else { 
function relative ( from , to ) { assert Path ( from ) ; assert Path ( to ) ; if ( from = = = to ) return ' ' ; var from Orig = win 3 2 . resolve ( from ) ; var to Orig = win 3 2 . resolve ( to ) ; if ( from Orig = = = to Orig ) return ' ' ; from = from Orig . to Lower Case ( ) ; to = to Orig . to Lower Case ( ) ; if ( from = = = to ) return ' ' ; 
function resolve ( ) { var resolved Path = ' ' ; var resolved Absolute = false ; var cwd ; for ( var i = arguments . length - 1 ; i > = - 1 & & ! resolved Absolute ; i - - ) { var path ; if ( i > = 0 ) path = arguments [ i ] ; else { if ( cwd = = = undefined ) cwd = process . cwd ( ) ; path = cwd ; } assert Path ( path ) ; 
function ( options ) { var defaults = { 'method ' : 'get ' , 'data ' : null , 'needle Retry ' : null , 'rule ' : { 'second ' : 1 } } ; if ( ! options ) { return defaults ; } return R . merge ( defaults , options ) ; } 
function Add Row ( id , n ) { var t = document . get Element By Id ( id ) ; var fltrow = t . insert Row ( 0 ) ; var inpclass = "flt " ; for ( var i = 0 ; i < n ; i + + ) { var fltcell = fltrow . insert Cell ( i ) ; var inp = document . create Element ( "input " ) ; inp . set Attribute ( "id " , "flt " + i + " _ " + id ) ; inp . set Attribute ( "type " , "text " ) ; inp . set Attribute ( "class " , i = = n - 1 ? "flt _s " : "flt " ) ; inp . set Attribute ( 'placeholder ' , 'Filter ' ) ; inp . add Event Listener ( 'keyup ' , Filter ) ; fltcell . append Child ( inp ) ; } } 
function get Cell Text ( n ) { var s = " " ; var enfants = n . child Nodes ; for ( var i = 0 ; i < enfants . length ; i + + ) { var child = enfants [ i ] ; if ( child . node Type = = 3 ) s + = child . data ; else s + = get Cell Text ( child ) ; } return s . to Lower Case ( ) ; } 
function set Filter Grid ( id , ref _row ) { if ( typeof window = = = 'undefined ' | | typeof document = = = 'undefined ' ) return ; var tbl = document . get Element By Id ( id ) ; if ( tbl & & tbl . node Name . to Lower Case ( ) = = = "table " ) { Tbl Id . push ( id ) ; ref _row = ref _row = = = undefined ? Start Row . push ( 2 ) : Start Row . push ( ref _row + 2 ) ; 
function Filter ( e ) { if ( typeof document = = = 'undefined ' ) return ; var id = e . target . get Attribute ( "id " ) . split ( " _ " ) [ 1 ] ; var Search Flt = get Filters ( id ) ; var t = document . get Element By Id ( id ) ; var Search Args = [ ] ; var ncells = get Cells Nb ( id ) ; for ( var i in Search Flt ) { Search Args . push ( document . get Element By Id ( Search Flt [ i ] ) . value . to Lower Case ( ) ) ; } var start _row = get Start Row ( id ) ; var row = t . get Elements By Tag Name ( "tr " ) ; for ( var k = start _row ; k < row . length ; k + + ) { if ( row [ k ] . style . display = = = "none " ) row [ k ] . style . display = " " ; var cell = get Child Elms ( row [ k ] ) . child Nodes ; var nchilds = cell . length ; var is Row Valid = true ; if ( nchilds = = = ncells ) { 
function set App Consts ( ) { var merged Constants = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : ( 0 , _seamless Immutable 2 . default ) ( app Consts ) ; 
function split To ( ) { let to = arguments . length < = 0 | | arguments [ 0 ] = = = undefined ? ' ' : arguments [ 0 ] ; if ( / # / . test ( to ) ) { return to . split ( ' # ' ) ; } return [ ] ; } 
function parse Args ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } const l = args . length ; const last = args [ l - 1 ] ; let cb , opts , paths ; if ( _lodash 2 . default . is Function ( last ) ) { cb = last ; args . pop ( ) ; 
function ( cb ) { fse . read File ( systems Json Path , 'utf 8 ' , function ( err , data ) { if ( err ) { if ( err . code ! = = 'ENOENT ' ) { return cb ( err ) ; } fse . mkdirp Sync ( sys Repo Path ) ; fse . write File Sync ( systems Json Path , JSON . stringify ( blank , null , 2 ) , 'utf 8 ' ) ; return git . create Repository ( sys Repo Path , 'system ' , 'system @nfd .com ' , function ( err _ ) { _systems = blank ; cb ( err _ ) ; } ) ; } _systems = JSON . parse ( data ) ; cb ( ) ; } ) ; } 
function ( user , namespace , name , repo Name , repo Path , system Id , cb ) { if ( ! _systems [ system Id ] ) { _systems [ system Id ] = { name : name , namespace : namespace , repo Name : repo Name , repo Path : repo Path } ; fse . write File Sync ( systems Json Path , JSON . stringify ( _systems , null , 2 ) , 'utf 8 ' ) ; git . commit ( sys Repo Path , 'registered system : ' + repo Path , user . name , user . email , cb ) ; } else { cb ( null ) ; } } 
function ( user , system Id , cb ) { if ( ! _systems [ system Id ] ) { return cb ( ) ; } var new Systems = _ . clone ( _systems ) ; delete new Systems [ system Id ] ; fse . write File Sync ( systems Json Path , JSON . stringify ( new Systems , null , 2 ) , 'utf 8 ' ) ; _systems = new Systems ; git . commit ( sys Repo Path , 'unregistered system : ' + system Id , user . name , user . email , cb ) ; } 
function ( identifier ) { identifier = identifier . replace ( / [ . + ] / g , function ( match ) { return ' \ \ ' + match ; } ) ; var re = new Reg Exp ( ' ^ ' + identifier + ' . * ' , [ 'i ' ] ) ; var system Id ; system Id = _ . find ( _ . keys ( _systems ) , function ( system ) { return system = = = identifier ; } ) ; if ( ! system Id ) { system Id = _ . find ( _ . keys ( _systems ) , function ( system ) { return re . test ( system ) ; } ) ; } if ( ! system Id ) { system Id = _ . find ( _ . keys ( _systems ) , function ( system ) { return re . test ( _systems [ system ] . name ) ; } ) ; } return system Id ; } 
function ( ) { var dom Wrapper ; this . _children = [ ] ; this . _create Root Html ( ) ; dom Wrapper = utils . html . parse HTML ( this . html ) ; if ( dom Wrapper . child Nodes . length > 1 ) { throw new Error ( "Component should have only one root element " ) ; } this . root = dom Wrapper . first Child ; this . process Instance ( ) ; } 
function ( ) { var i , elements , element , value ; if ( this . _root ) { ( this . $meta . dom Processors | | [ ] ) . for Each ( function ( processor ) { elements = this . _root . query Selector All ( " [ " + processor . attribute + " ] " ) ; for ( i = 0 ; i < elements . length ; i + + ) { element = elements [ i ] ; value = element . get Attribute ( processor . attribute ) ; processor . process ( this , element , value ) ; } } , this ) ; } } 
function ( child ) { this . _validate Child ( child ) ; if ( child . parent ) { child . parent . remove ( child ) ; } child . parent = this ; this . _children . push ( child ) ; this . root . append Child ( child . root ) ; if ( this . _ _fastinject _ _ ) { this . _ _fastinject _ _ ( child ) ; } 
function ( child ) { var index = this . _children . index Of ( child ) ; if ( index ! = = - 1 ) { this . _children . splice ( index , 1 ) ; child . root . parent Node . remove Child ( child . root ) ; child . destroy ( ) ; } } 
function ( child , element , root ) { this . _children . push ( child ) ; ( root | | this . root ) . insert Before ( child . root , element ) ; ( root | | this . root ) . remove Child ( element ) ; } 
function ( repo Path , doc , done ) { generify ( path . join ( _ _dirname , 'template ' ) , repo Path , { name : doc . name , namespace : doc . namespace , id : doc . id } , done ) ; } 
function ( repo Path ) { var sys ; if ( fse . exists Sync ( path . join ( repo Path , 'system .js ' ) ) ) { 
function ( user , system Id , entry Type , details , cb ) { var file = path . join ( options . timelines Root , find System ( system Id ) ) ; if ( typeof details = = = 'function ' ) { cb = details ; details = { } ; } else if ( ! details ) { details = { } ; } var entry = { v : 0 , user : user , ts : new Date ( ) , type : entry Type , details : details } ; fs . write File ( file , JSON . stringify ( entry ) + ' \n ' , { flag : 'a ' } , function ( ) { 
function ( user , system Id , message , cb ) { logger . info ( 'committing revision : ' + system Id + ' , ' + message ) ; var repo Path = _meta . repo Path ( system Id ) ; git . commit ( repo Path , message , user . name , user . email , cb ) ; } 
function ( user , namespace , name , cwd , cb ) { var repo Name = name ; var doc = _ . extend ( { } , blank ) ; var repo Path = path . join ( cwd , repo Name ) ; doc . name = name ; doc . namespace = namespace ; doc . id = uuid . v 4 ( ) ; if ( ! fse . exists Sync ( repo Path ) ) { fse . mkdirp Sync ( repo Path ) ; init Nscale Files ( repo Path , doc , function ( ) { git . create Repository ( repo Path , user . name , user . email , function ( err ) { if ( err ) { return cb ( err ) ; } _meta . register ( user , namespace , name , repo Name , cwd + ' / ' + repo Name , doc . id , function ( err ) { write Timeline ( user , doc . id , 'create ' , 'system created ' , function ( ) { 
function ( user , path _ , cwd , cb ) { var repo Path = path . resolve ( cwd , path _ ) ; var sys ; var validation Error = validate System ( repo Path ) ; if ( validation Error ) { return cb ( validation Error ) ; } sys = require ( repo Path + ' /system .js ' ) ; delete require . cache [ repo Path + ' /system .js ' ] ; _meta . register ( user , sys . namespace , sys . name , path . basename ( repo Path ) , repo Path , sys . id , function ( err ) { write Timeline ( user , sys . id , 'link ' , 'system linked ' , function ( ) { cb ( err , { id : sys . id , err : err } ) ; } ) ; } ) ; } 
function ( user , system Id , cb ) { write Timeline ( user , system Id , 'system unlinked ' , function ( ) { 
function ( system Id , file Name , contents , cb ) { var repo Path = _meta . repo Path ( system Id ) ; fse . write File ( path . join ( repo Path , file Name ) , contents , 'utf 8 ' , cb ) ; } 
function ( system Id , target , cb ) { list Revisions ( system Id , function ( err , revs ) { if ( err ) { return cb ( err ) ; } get Revision ( system Id , revs [ 0 ] . id , target , cb ) ; } ) ; } 
function ( system Id , cb ) { list Revisions ( system Id , function ( err , revs ) { cb ( err , revs & & revs [ 0 ] & & revs [ 0 ] . id ) ; } ) ; } 
function ( system Id , cb ) { list Revisions ( system Id , function ( err , revs ) { if ( revs [ 0 ] . id = = = EDITS ) { cb ( err , revs & & revs [ 1 ] & & revs [ 1 ] . id ) ; } else { cb ( err , revs & & revs [ 0 ] & & revs [ 0 ] . id ) ; } } ) ; } 
function ( system Id , revision Id , target , cb ) { var repo Path = _meta . repo Path ( system Id ) ; git . get File Revision ( repo Path , revision Id , target + ' .json ' , function ( err , rev ) { if ( err ) { return cb ( err ) ; } var s ; try { s = JSON . parse ( rev ) ; } catch ( e ) { return cb ( new Error ( 'invalid system definition : ' + e . message ) , null ) ; } cb ( err , s ) ; } ) ; } 
function ( system Id , revision Id , target , cb ) { if ( revision Id = = = EDITS ) { _get On Disk Version ( system Id , revision Id , target , cb ) ; } else { find Revision ( system Id , revision Id , function ( err , rev ) { if ( err ) { return cb ( err ) ; } if ( rev = = = EDITS ) { _get On Disk Version ( system Id , revision Id , target , cb ) ; } else { _get Revision ( system Id , rev , target , cb ) ; } } ) ; } } 
function ( user , system Id , revision Id , env , cb ) { var repo Path = _meta . repo Path ( system Id ) ; var remove Tag ; var add Tag ; var rev Id ; get Comitted Head Revision Id ( system Id , function ( err , comitted Head Id ) { if ( revision Id = = = EDITS ) { remove Tag = base Tag + env ; add Tag = edits Tag + env ; rev Id = comitted Head Id ; } else { add Tag = base Tag + env ; remove Tag = edits Tag + env ; rev Id = revision Id ; } ngit . Repository . open ( repo Path , function ( err , repo ) { if ( err ) { return cb ( err ) ; } ngit . Reference . remove ( repo , remove Tag ) ; repo . get Commit ( rev Id , function ( err , commit ) { if ( err ) { return cb ( err ) ; } var now = Math . round ( Date . now ( ) / 1 0 0 0 ) ; var author = ngit . Signature . create ( user . name , user . email , now , 0 ) ; ngit . Reference . create ( repo , add Tag , commit , 1 , author , 'Tagged ' + add Tag ) . then ( function ( ) { write Timeline ( user , system Id , 'deployed revision ' , revision Id , function ( ) { cb ( ) ; } ) ; } ) . catch ( cb ) ; } ) ; } ) ; } ) ; } 
function ( system Id , env , cb ) { var repo Path = _meta . repo Path ( system Id ) ; var tag Name = base Tag + env ; var edits Tag Name = edits Tag + env ; ngit . Repository . open ( repo Path , function ( err , repo ) { if ( err ) { return cb ( err ) ; } ngit . Reference . name To Id ( repo , tag Name , function ( err , head ) { if ( err & & ( ! err . message | | err . message . index Of ( 'not found ' ) = = = - 1 ) ) { return cb ( err ) ; } if ( head ) { cb ( null , head . to String ( ) ) ; } else { ngit . Reference . name To Id ( repo , edits Tag Name , function ( err ) { if ( err ) { return cb ( err ) ; } cb ( null , EDITS ) ; } ) ; } } ) ; } ) ; } 
function ( system Id , cb ) { var repo Path = _meta . repo Path ( system Id ) ; get Deployed Targets ( system Id , function ( err , targets ) { if ( err ) { return cb ( err ) ; } git . list Revisions ( repo Path , function ( err , revisions ) { revisions . for Each ( function ( revision ) { var deployed To = _ . find ( targets , function ( target ) { return target . commit = = = revision . id ; } ) ; if ( deployed To ) { revision . deployed To = deployed To . env ; } } ) ; cb ( err , revisions ) ; } ) ; } ) ; } 
function ( system Id , identifier , cb ) { var re = new Reg Exp ( ' ^ ' + identifier + ' . * ' , [ 'i ' ] ) ; var revision ; if ( identifier ! = = 'head ' & & identifier ! = = 'latest ' ) { list Revisions ( system Id , function ( err , revisions ) { revision = _ . find ( revisions , function ( revision ) { return re . test ( revision . id ) ; } ) ; if ( revision ) { cb ( err , revision . id ) ; } else { cb ( new Error ( 'revision not found ' ) ) ; } } ) ; } else { get Head Revision Id ( system Id , cb ) ; } } 
function ( app , parent Addon ) { this . _super . included ( app ) ; var target = ( parent Addon | | app ) ; target . import ( target . bower Directory + ' /emojify /dist /js /emojify .js ' ) ; if ( _emoji Config . mode = = = 'sprites ' ) { var dest Sprite Dir = 'images /sprites ' ; var sprite Path = ' /emojify /dist /images /sprites / ' ; target . import ( target . bower Directory + sprite Path + 'emojify .png ' , { dest Dir : dest Sprite Dir } ) ; target . import ( target . bower Directory + sprite Path + 'emojify @ 2x .png ' , { dest Dir : dest Sprite Dir } ) ; } } 
function ( environment , base Config ) { if ( 'emoji ' in base Config ) { if ( ! base Config . emoji ) { _emoji Config = false ; } else { Object . keys ( _default Emoji Config ) . for Each ( function ( key ) { _emoji Config [ key ] = base Config . emoji . has Own Property ( key ) ? base Config . emoji [ key ] : _default Emoji Config [ key ] ; } ) ; } } else { _emoji Config = _default Emoji Config ; } if ( environment = = = 'development ' ) { return { emoji : _emoji Config , content Security Policy : { 'script -src ' : " 'self ' 'unsafe -eval ' 'unsafe -inline ' " } } ; } return { emoji : _emoji Config } ; } 
function ( ) { var emoji Data URIPath = path . join ( this . app . bower Directory , 'emojify /dist /css /data -uri /emojify .css ' ) , emoji Sprites Path = path . join ( this . app . bower Directory , 'emojify /dist /css /sprites /emojify .css ' ) ; if ( _emoji Config . mode = = = 'data -uri ' ) { this . app . import ( emoji Data URIPath ) ; } else { this . app . import ( emoji Sprites Path ) ; } } 
function ( analyzed ) { var containers = analyzed . topology . containers ; var targets = [ ] ; _ . each ( containers , function ( c ) { if ( c . container Definition Id . index Of ( ' _ _proxy ' ) = = = 0 ) { var cdef = _ . find ( analyzed . container Definitions , function ( cdef ) { return cdef . id = = = c . container Definition Id ; } ) ; targets . push ( { container Def : cdef , container : c } ) ; } } ) ; return targets ; } 
function ( cls ) { if ( this . collection ) { return this . collection ; } cls = ( cls ) ? this . superclass ( cls ) : this ; while ( cls ) { if ( cls . collection ) { this . collection = cls . collection ; return cls . collection ; } } return false ; } 
function ( model , relation , options ) { var type = ! _ . is String ( relation . type ) ? relation . type : Backbone [ relation . type ] | | this . get Object By Name ( relation . type ) ; if ( type & & type . prototype instanceof Backbone . Relation ) { new type ( model , relation , options ) ; 
function ( model Type ) { _ . find ( this . _sub Models , function ( sub Model Def ) { return _ . find ( sub Model Def . sub Models | | [ ] , function ( sub Model Type Name , type Value ) { var sub Model Type = this . get Object By Name ( sub Model Type Name ) ; if ( model Type = = = sub Model Type ) { 
function ( relation ) { var exists = _ . any ( this . _reverse Relations , function ( rel ) { return _ . all ( relation | | [ ] , function ( val , key ) { return val = = = rel [ key ] ; } ) ; } ) ; if ( ! exists & & relation . model & & relation . type ) { this . _reverse Relations . push ( relation ) ; this . _add Relation ( relation . model , relation ) ; this . retro Fit Relation ( relation ) ; } } 
function ( relation ) { var exists = _ . any ( this . _orphan Relations , function ( rel ) { return _ . all ( relation | | [ ] , function ( val , key ) { return val = = = rel [ key ] ; } ) ; } ) ; if ( ! exists & & relation . model & & relation . type ) { this . _orphan Relations . push ( relation ) ; } } 
function ( ) { 
function ( relation ) { var coll = this . get Collection ( relation . model , false ) ; coll & & coll . each ( function ( model ) { if ( ! ( model instanceof relation . model ) ) { return ; } new relation . type ( model , relation ) ; } , this ) ; } 
function ( type , create ) { if ( type instanceof Backbone . Relational Model ) { type = type . constructor ; } var root Model = type ; while ( root Model . _super Model ) { root Model = root Model . _super Model ; } var coll = _ . find ( this . _collections , function ( item ) { return item . model = = = root Model ; } ) ; if ( ! coll & & create ! = = false ) { coll = this . _create Collection ( root Model ) ; } return coll ; } 
function ( name ) { var parts = name . split ( ' . ' ) , type = null ; _ . find ( this . _model Scopes , function ( scope ) { type = _ . reduce ( parts | | [ ] , function ( memo , val ) { return memo ? memo [ val ] : undefined ; } , scope ) ; if ( type & & type ! = = scope ) { return true ; } } , this ) ; return type ; } 
function ( type , item ) { var id = _ . is String ( item ) | | _ . is Number ( item ) ? item : null ; if ( id = = = null ) { if ( item instanceof Backbone . Relational Model ) { id = item . id ; } else if ( _ . is Object ( item ) ) { id = item [ type . prototype . id Attribute ] ; } } 
function ( type , item ) { var id = this . resolve Id For Item ( type , item ) ; var coll = this . get Collection ( type ) ; 
function ( model ) { var coll = this . get Collection ( model ) ; if ( coll ) { var model Coll = model . collection ; coll . add ( model ) ; this . listen To ( model , 'destroy ' , this . unregister , this ) ; this . listen To ( model , 'relational :unregister ' , this . unregister , this ) ; model . collection = model Coll ; } } 
function ( model , id ) { var coll = this . get Collection ( model ) , duplicate = coll & & coll . get ( id ) ; if ( duplicate & & model ! = = duplicate ) { if ( Backbone . Relational . show Warnings & & typeof console ! = = 'undefined ' ) { console . warn ( 'Duplicate id ! Old Relational Model = %o , new Relational Model = %o ' , duplicate , model ) ; } throw new Error ( "Cannot instantiate more than one Backbone .Relational Model with the same id per type ! " ) ; } } 
function ( model , collection , options ) { this . stop Listening ( model ) ; var coll = this . get Collection ( model ) ; coll & & coll . remove ( model , options ) ; } 
function ( ) { var i = this . instance , k = this . key , m = this . model , rm = this . related Model , warn = Backbone . Relational . show Warnings & & typeof console ! = = 'undefined ' ; if ( ! m | | ! k | | ! rm ) { warn & & console . warn ( 'Relation = %o : missing model , key or related Model ( %o , %o , %o ) . ' , this , m , k , rm ) ; return false ; } 
function ( related ) { this . related = related ; this . instance . acquire ( ) ; this . instance . attributes [ this . key ] = related ; this . instance . release ( ) ; } 
function ( relation ) { return relation . instance instanceof this . related Model & & this . reverse Relation . key = = = relation . key & & this . key = = = relation . reverse Relation . key ; } 
function ( model ) { var reverse Relations = [ ] ; 
function ( ) { this . stop Listening ( ) ; if ( this instanceof Backbone . Has One ) { this . set Related ( null ) ; } else if ( this instanceof Backbone . Has Many ) { this . set Related ( this . _prepare Collection ( ) ) ; } _ . each ( this . get Reverse Relations ( ) , function ( relation ) { relation . remove Related ( this . instance ) ; } , this ) ; } 
function ( options ) { var related = null ; options = _ . defaults ( { parse : this . options . parse } , options ) ; if ( this . key Contents instanceof this . related Model ) { related = this . key Contents ; } else if ( this . key Contents | | this . key Contents = = = 0 ) { 
function ( key Contents ) { this . key Contents = key Contents ; this . key Id = Backbone . Relational . store . resolve Id For Item ( this . related Model , this . key Contents ) ; } 
function ( model , attr , options ) { 
function ( model , coll , options ) { if ( ( this . key Id | | this . key Id = = = 0 ) & & model . id = = = this . key Id ) { 
function ( collection ) { if ( this . related ) { this . stop Listening ( this . related ) ; } if ( ! collection | | ! ( collection instanceof Backbone . Collection ) ) { var options = _ . is Function ( this . options . collection Options ) ? this . options . collection Options ( this . instance ) : this . options . collection Options ; collection = new this . collection Type ( null , options ) ; } collection . model = this . related Model ; if ( this . options . collection Key ) { var key = this . options . collection Key = = = true ? this . options . reverse Relation . key : this . options . collection Key ; if ( collection [ key ] & & collection [ key ] ! = = this . instance ) { if ( Backbone . Relational . show Warnings & & typeof console ! = = 'undefined ' ) { console . warn ( 'Relation = %o ; collection Key = %s already exists on collection = %o ' , this , key , this . options . collection Key ) ; } } else if ( key ) { collection [ key ] = this . instance ; } } this . listen To ( collection , 'relational :add ' , this . handle Addition ) . listen To ( collection , 'relational :remove ' , this . handle Removal ) . listen To ( collection , 'relational :reset ' , this . handle Reset ) ; return collection ; } 
function ( options ) { var related = null ; options = _ . defaults ( { parse : this . options . parse } , options ) ; 
function ( key Contents ) { this . key Contents = key Contents instanceof Backbone . Collection ? key Contents : null ; this . key Ids = [ ] ; if ( ! this . key Contents & & ( key Contents | | key Contents = = = 0 ) ) { 
function ( model , attr , options ) { options = options ? _ . clone ( options ) : { } ; this . set Key Contents ( attr ) ; this . changed = false ; var related = this . find Related ( options ) ; this . set Related ( related ) ; if ( ! options . silent ) { var dit = this ; Backbone . Relational . event Queue . add ( function ( ) { 
function ( model , coll , options ) { 
function ( event Name ) { if ( event Name . length > 5 & & event Name . index Of ( 'change ' ) = = = 0 ) { var dit = this , args = arguments ; Backbone . Relational . event Queue . add ( function ( ) { if ( ! dit . _is Initialized ) { return ; } 
function ( options ) { this . acquire ( ) ; 
function ( options ) { if ( this . _is Initialized & & ! this . is Locked ( ) ) { _ . each ( this . _relations , function ( rel ) { 
function ( key , options , refresh ) { 
function ( options ) { 
function ( type , attributes ) { if ( type . _sub Models & & type . prototype . sub Model Type Attribute in attributes ) { var sub Model Type Attribute = attributes [ type . prototype . sub Model Type Attribute ] ; var sub Model Type = type . _sub Models [ sub Model Type Attribute ] ; if ( sub Model Type ) { return sub Model Type ; } else { 
function ( attributes , options ) { options | | ( options = { } ) ; var parsed Attributes = ( _ . is Object ( attributes ) & & options . parse & & this . prototype . parse ) ? this . prototype . parse ( _ . clone ( attributes ) ) : attributes ; 
function ( attributes , options ) { options | | ( options = { } ) ; options . create = false ; return this . find Or Create ( attributes , options ) ; } 
function Xtallat X ( super Class ) { return class extends super Class { constructor ( ) { super ( . . . arguments ) ; this . _ev Count = { } ; } static get observed Attributes ( ) { return [ disabled ] ; } get disabled ( ) { return this . _disabled ; } set disabled ( val ) { this . attr ( disabled , val , ' ' ) ; } attr ( name , val , true Val ) { const v = val ? 'set ' : 'remove ' ; * Turn number into string with even and odd values easy to query via css . * @param n * / to $ ( n ) { const mod = n % 2 ; return ( n - mod ) / 2 + ' - ' + mod ; } inc Attr ( name ) { const ec = this . _ev Count ; if ( name in ec ) { ec [ name ] + + ; } else { ec [ name ] = 0 ; } this . attr ( 'data - ' + name , this . to $ ( ec [ name ] ) ) ; } attribute Changed Callback ( name , old Val , new Val ) { switch ( name ) { case disabled : this . _disabled = new Val ! = = null ; break ; } } de ( name , detail , as Is = false ) { const event Name = name + ( as Is ? ' ' : ' -changed ' ) ; const new Event = new Custom Event ( event Name , { detail : detail , bubbles : true , composed : false , } ) ; this . dispatch Event ( new Event ) ; this . inc Attr ( event Name ) ; return new Event ; } _upgrade Properties ( props ) { props . for Each ( prop = > { if ( this . has Own Property ( prop ) ) { let value = this [ prop ] ; delete this [ prop ] ; this [ prop ] = value ; } } ) ; } } ; } 
function ( re ) { var arr = [ ] , tag ; for ( tag in register ) { if ( re . test ( tag ) ) arr . push ( tag ) ; } return arr ; } 
function ( Class , tag ) { tag = tag . to Lower Case ( ) ; if ( ! ( tag in register ) ) { register [ Class ] = ( register [ Class ] | | [ ] ) . concat ( tag ) ; register [ tag ] = ( register [ tag . to Upper Case ( ) ] = Class ) ; } } 
function normalize Path ( path ) { path = ' / ' + path path = resolve ( normalize ( path ) ) path = path . replace ( / ( % [a -f 0 - 9 ] { 2 } ) / g , $ 1 = > $ 1 . to Upper Case ( ) ) if ( path = = = ' ' ) path = ' / ' return path } 
function parse Args ( . . . args ) { const l = args . length const last = args [ l - 1 ] let cb , opts , paths if ( _ . is Function ( last ) ) { cb = last args . pop ( ) ; 
function sort _numeric ( a , b ) { var aa = void 0 , bb = void 0 ; aa = parse Float ( a [ 0 ] . replace ( / [ ^ 0 - 9 . - ] / g , ' ' ) ) ; if ( is Na N ( aa ) ) aa = 0 ; bb = parse Float ( b [ 0 ] . replace ( / [ ^ 0 - 9 . - ] / g , ' ' ) ) ; if ( is Na N ( bb ) ) bb = 0 ; return aa - bb ; } 
function Bitmap ( image Or Uri ) { this . Display Object _constructor ( ) ; * The source image to display . This can be a Canvas Image Source * (image , video , canvas ) , an object with a `get Image ` method that returns a Canvas Image Source , or a string URL to an image . * If the latter , a new Image instance with the URL as its src will be used . * @property image * @type Canvas Image Source | Object * * / if ( typeof image Or Uri = = "string " ) { this . image = document . create Element ( "img " ) ; this . image . src = image Or Uri ; } else { this . image = image Or Uri ; } this . source Rect = null ; * Docced in superclass . * / this . _web GLRender Style = createjs . Display Object . _Stage GL _BITMAP ; } 
function Blur Filter ( blur X , blur Y , quality ) { this . Filter _constructor ( ) ; * Horizontal blur radius in pixels * @property blur X * @default 0 * @type Number * * / this . _blur X = blur X ; this . _blur XTable = [ ] ; this . _blur Y = blur Y ; this . _blur YTable = [ ] ; this . _quality ; this . FRAG _SHADER _TEMPLATE = ( "uniform float x Weight [ { {blur X } } ] ; " + "uniform float y Weight [ { {blur Y } } ] ; " + "uniform vec 2 texture Offset ; " + "void main (void ) { " + "vec 4 color = vec 4 ( 0 . 0 ) ; " + "float x Adj = ( { {blur X } } . 0 - 1 . 0 ) / 2 . 0 ; " + "float y Adj = ( { {blur Y } } . 0 - 1 . 0 ) / 2 . 0 ; " + "vec 2 sample Offset ; " + "for (int i = 0 ; i < { {blur X } } ; i + + ) { " + "for (int j = 0 ; j < { {blur Y } } ; j + + ) { " + "sample Offset = v Render Coord + (texture Offset * vec 2 (float (i ) -x Adj , float (j ) -y Adj ) ) ; " + "color + = texture 2D (u Sampler , sample Offset ) * (x Weight [i ] * y Weight [j ] ) ; " + " } " + " } " + "gl _Frag Color = color .rgba ; " + " } " ) ; 
function convert _to _alloy _path ( resolved _path ) { var parsed _path = path . posix . parse ( resolved _path ) ; return path . posix . join ( parsed _path . dir , parsed _path . name ) ; } 
function load _as _file ( request , startpath ) { var module _path ; var resolved _path = path . posix . resolve ( startpath , request ) ; _ . includes ( registry . files , resolved _path ) & & ( module _path = resolved _path ) ; if ( module _path ) { 
function load _as _directory ( request , startpath ) { var resolved _path = path . posix . resolve ( startpath , request ) ; var module _path = _ . find ( registry . directories , function ( item ) { return item . id = = = resolved _path ; } ) ; if ( module _path ) { return module _path . path ; } } 
function load _node _modules ( request , startpath ) { var resolved _path ; var nodepaths = node _modules _paths ( startpath ) ; _ . for Each ( nodepaths , function ( nodepath ) { resolved _path = load _as _file ( request , nodepath ) ; return ! resolved _path ; } ) ; if ( resolved _path ) { return resolved _path ; } _ . for Each ( nodepaths , function ( nodepath ) { resolved _path = load _as _directory ( request , nodepath ) ; return ! resolved _path ; } ) ; return resolved _path ; } 
function canonicalize ( value , stack ) { var canonicalized Obj ; var prop ; var type = get Type ( value ) ; function with Stack ( value , fn ) { stack . push ( value ) ; fn ( ) ; stack . pop ( ) ; } stack = stack | | [ ] ; if ( stack . index Of ( value ) ! = = - 1 ) { return ' [Circular ] ' ; } switch ( type ) { case 'undefined ' : case 'buffer ' : case 'null ' : canonicalized Obj = value ; break ; case 'array ' : with Stack ( value , function ( ) { canonicalized Obj = value . map ( function ( item ) { return canonicalize ( item , stack ) ; } ) ; } ) ; break ; case 'function ' : for ( prop in value ) { canonicalized Obj = { } ; break ; } if ( ! canonicalized Obj ) { canonicalized Obj = empty Representation ( value , type ) ; break ; } case 'object ' : canonicalized Obj = canonicalized Obj | | { } ; with Stack ( value , function ( ) { Object . keys ( value ) . sort ( ) . for Each ( function ( key ) { canonicalized Obj [ key ] = canonicalize ( value [ key ] , stack ) ; } ) ; } ) ; break ; case 'date ' : case 'number ' : case 'regexp ' : case 'boolean ' : canonicalized Obj = value ; break ; default : canonicalized Obj = value . to String ( ) ; } return canonicalized Obj ; } 
function empty Representation ( value , type ) { type = type | | get Type ( value ) ; switch ( type ) { case 'function ' : return ' [Function ] ' ; case 'object ' : return ' { } ' ; case 'array ' : return ' [ ] ' ; default : return value . to String ( ) ; } } 
function create Dynode Options ( dynamo As Promised Options , key , extra Dynode Options ) { var dynode Options = _ . clone ( extra Dynode Options | | { } ) ; 
function ( doc , first , last ) { var f = doc . Word Pos [ first ] ; var l ; if ( last = = doc . Word Pos . length - 1 ) 
function parse Conditionals ( js ) { var lines = js . split ( ' \n ' ) , len = lines . length , buffer = true , browser = false , buf = [ ] , line , cond ; for ( var i = 0 ; i < len ; + + i ) { line = lines [ i ] ; if ( / ^ * \ / \ / *if * (node |browser ) / gm . exec ( line ) ) { cond = Reg Exp . $ 1 ; buffer = browser = 'browser ' = = cond ; } else if ( / ^ * \ / \ / *end / . test ( line ) ) { buffer = true ; browser = false ; } else if ( browser ) { buf . push ( line . replace ( / ^ ( * ) \ / \ / / , ' $ 1 ' ) ) ; } else if ( buffer ) { buf . push ( line ) ; } } return buf . join ( ' \n ' ) ; } 
function compile ( ) { var buf = ' ' ; buf + = ' (function ( ) { \n ' ; buf + = ' \n / / Common JS require ( ) \n \n ' ; buf + = browser . require + ' \n \n ' ; buf + = 'require .modules = { } ; \n \n ' ; buf + = 'require .resolve = ' + browser . resolve + ' ; \n \n ' ; buf + = 'require .register = ' + browser . register + ' ; \n \n ' ; buf + = 'require .relative = ' + browser . relative + ' ; \n \n ' ; args . for Each ( function ( file ) { var js = files [ file ] ; file = file . replace ( 'lib / ' , ' ' ) ; buf + = ' \nrequire .register ( " ' + file + ' " , function (module , exports , require ) { \n ' ; buf + = js ; buf + = ' \n } ) ; / / module : ' + file + ' \n ' ; } ) ; buf + = ' \nwindow .kiwi = require ( "kiwi " ) ; \n ' ; buf + = ' } ) ( ) ; \n ' ; fs . write File ( 'kiwi .js ' , buf , function ( err ) { if ( err ) throw err ; console . log ( ' \ 0 3 3 [ 9 0m create : \ 0 3 3 [ 0m \ 0 3 3 [ 3 6m %s \ 0 3 3 [ 0m ' , 'kiwi .js ' ) ; console . log ( ) ; } ) ; } 
function split Dots ( list ) { var result = [ ] ; list . for Each ( function ( x ) { if ( typeof x = = = 'string ' ) { x . split ( ' . ' ) . for Each ( function ( part ) { result . push ( part ) ; } ) ; } else { result . push ( x ) ; } } ) ; return result ; } 
function fp ( ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; if ( args . length ) { if ( ! args . every ( is String Or Function ) ) { var signature = args . map ( humanize Argument ) . join ( ' \n \t ' ) ; throw new Error ( 'Invalid arguments to functional pipeline - not a string or function \n \t ' + signature ) ; } var fns = split Dots ( args ) ; return function ( d ) { var original Object = d ; fns . for Each ( function ( fn ) { if ( typeof fn = = = 'string ' ) { if ( typeof d [ fn ] = = = 'function ' ) { d = d [ fn ] . call ( d , d ) ; } else if ( typeof d [ fn ] ! = = 'undefined ' ) { d = d [ fn ] ; } else { var signature = args . map ( humanize Argument ) . join ( ' \n \t ' ) ; throw new Error ( 'Cannot use property ' + fn + ' from object ' + JSON . stringify ( d , null , 2 ) + ' \npipeline \n \t ' + signature + ' \noriginal object \n ' + JSON . stringify ( original Object , null , 2 ) ) ; } } else if ( typeof fn = = = 'function ' ) { d = fn ( d ) ; } else { throw new Error ( 'Cannot apply ' + JSON . stringify ( fn , null , 2 ) + ' to value ' + d + ' not a property name or a function ' ) ; } } ) ; return d ; } ; } } 
function VATPeriod ( effective From , super Reduced , reduced , standard , parking ) { this . _effective From = effective From ; this . _super Reduced = super Reduced ; this . _reduced = reduced ; this . _standard = standard ; this . _parking = parking ; } 
function load Filters ( loaded Files ) { loaded Files = loaded Files | | frame . files . require Dir ( _ _dirname + ' /filters / ' ) ; for ( var file in loaded Files ) { var file Filters = loaded Files [ file ] ; for ( var filter in file Filters ) { filters [ filter ] = file Filters [ filter ] ; } } } 
function ( tick Rate ) { events . Event Emitter . call ( this ) ; 
function on Processed ( err , processed ) { if ( err ) return callback ( err ) ; _this . _tokenize ( processed , on Tokenized ) ; } 
function on Tokenized ( err , tokenized ) { if ( err ) return callback ( err ) ; tokenized . compile ( _this , on Compiled ) ; } 
function on Compiled ( err , compiled ) { if ( err ) return callback ( err ) ; var func ; try { func = new Function ( " $template " , " $tools " , " _ " , " $data " , " $helpers " , " $callback " , compiled ) ; } catch ( err ) { return callback ( err ) ; } func . $helpers = _this . helpers ; callback ( null , func ) ; } 
function Base Token ( root , parent , options ) { this . parent = parent ; this . children = [ ] ; this . tag = null ; this . tag Type = null ; this . options = options ; this . root = root ; } 
function Literal Token ( literal , root , parent , options ) { Literal Token . _superclass . call ( this , root , parent , options ) ; this . literal = literal ; } 
function Block Token ( tag , tag Type , root , parent , children , options ) { Block Token . _superclass . call ( this , root , parent , options ) ; this . tag = tag ; this . tag Type = tag Type ; if ( ! children ) children = [ ] ; this . children = children ; this . intermediate = [ ] ; } 
function Intermediate Token ( tag , tag Type , root , parent , children , options ) { Intermediate Token . _superclass . call ( this , tag , tag Type , root , parent , children , options ) ; } 
function create If Condition ( condition , strict ) { var compiled ; if ( strict ) { compiled = 'if ( ' + condition + ' ) ' ; } else { compiled = 'try { ' + ' _ _tmp = ' + condition + ' } catch ( _ _err ) { ' + 'if ( _ _err instanceof Reference Error ) { ' + ' _ _tmp = false ; ' + ' } else { ' + 'throw _ _err ; ' + ' } ' + ' } ' + 'if ( _ _tmp ) ' ; } return compiled ; } 
function VATCountry ( name , code , country Code , periods , date ) { this . _name = name ; this . _code = code ; this . _country Code = country Code ; this . _periods = periods ; this . set Date ( date ) ; } 
function compile Token Array ( tokens , compiler , callback ) { var acc = [ ] ; var index = 0 ; function compile One ( token , next ) { token . compile ( compiler , function on Compiled ( err , compiled ) { if ( err ) return next ( err ) ; acc . push ( compiled ) ; next ( null , compiled ) ; } ) ; index + + ; } function done ( err ) { if ( err ) return callback ( err ) ; callback ( null , acc ) ; } async For Each ( tokens , compile One , done ) ; } 
function Template ( str , options ) { 
function ( fn , rate ) { var allowed = true ; return function ( ) { if ( allowed ) { allowed = false ; fn . apply ( null , [ ] . slice . call ( arguments , 0 ) ) ; set Timeout ( function ( ) { allowed = true ; } , rate ) ; } } } 
function get _data ( callback ) { var data ; try { data = program . data ? JSON . parse ( program . data ) : { } ; callback ( data ) ; } catch ( err ) { fs . read File ( program . data , function ( err , str ) { str = ' ' + str ; if ( ! err ) { try { data = JSON . parse ( str ) ; callback ( data ) ; } catch ( err ) { data = eval ( str ) ; callback ( data ) ; } } } ) ; } return data ; } 
function ispunct ( ch ) { ch = ch . char Code At ( 0 ) ; return ( ch > = 0x 2 1 & & ch < = 0x 2F ) | | ( ch > = 0x 3a & & ch < = 0x 4 0 ) | | ( ch > = 0x 5B & & ch < = 0x 6 0 ) | | ( ch > = 0x 7F ) ; } 
function ( str ) { var inhash = 0 ; var charcount = 0 ; var char ; if ( str . length = = 0 ) return 1 ; 
function secure Webhook Endpoints ( ) { var authentication Middleware = require ( _ _dirname + ' /middleware /slack _authentication .js ' ) ; 
function post Form ( url , form Data , cb , multipart ) { cb = cb | | noop ; bot . logger . info ( ' * * API CALL : ' + url ) ; var params = { url : url , headers : { 'User -Agent ' : bot . user Agent ( ) , } } ; if ( multipart = = = true ) { params . form Data = form Data ; } else { params . form = form Data ; } request . post ( params , function ( error , response , body ) { bot . logger . debug ( 'Got response ' , error , body ) ; if ( error ) { return cb ( error ) ; } if ( response . status Code = = 2 0 0 ) { var json ; try { json = JSON . parse ( body ) ; } catch ( parse Error ) { return cb ( parse Error ) ; } return cb ( ( json . ok ? null : json . error ) , json ) ; } else if ( response . status Code = = 4 2 9 ) { return cb ( new Error ( 'Rate limit exceeded ' ) ) ; } else { return cb ( new Error ( 'Invalid response ' ) ) ; } } ) ; } 
function Botkit ( configuration ) { var botkit = { events : { } , * conversation will be not be ended and should be taken care by callback * / this . time Out Handler = null ; this . collect Response = function ( key , value ) { this . responses [ key ] = value ; } ; this . capture = function ( response , cb ) { var that = this ; var capture _key = this . sent [ this . sent . length - 1 ] . text ; botkit . middleware . capture . run ( that . task . bot , response , that , function ( err , bot , response , convo ) { if ( response . text ) { response . text = response . text . trim ( ) ; } else { response . text = ' ' ; } if ( that . capture _options . key ! = undefined ) { capture _key = that . capture _options . key ; } * active includes both ACTIVE and ENDING * in order to allow the timeout end scripts to play out * * / this . is Active = function ( ) { return ( this . status = = 'active ' | | this . status = = 'ending ' ) ; } ; this . deactivate = function ( ) { this . status = 'inactive ' ; } ; this . say = function ( message ) { this . add Message ( message ) ; } ; this . say First = function ( message ) { if ( typeof ( message ) = = 'string ' ) { message = { text : message , channel : this . source _message . channel , } ; } else { message . channel = this . source _message . channel ; } this . messages . unshift ( message ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for ' , event ) ; var events = event . split ( / \ , / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e + + ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res = = = false ) { return ; } } } else { } } ; * hears _regexp - default string matcher uses regular expressions * * @param {array } tests patterns to match * @param {object } message message object with various fields * @return {boolean } whether or not a pattern was matched * / botkit . hears _regexp = function ( tests , message ) { for ( var t = 0 ; t < tests . length ; t + + ) { if ( message . text ) { * change Ears - change the default matching function * * @param {function } new _test a function that accepts (tests , message ) and returns a boolean * / botkit . change Ears = function ( new _test ) { botkit . hears _test = new _test ; } ; botkit . hears = function ( keywords , events , middleware _or _cb , cb ) { * Define a default worker bot . This function should be customized outside * of Botkit and passed in as a parameter by the developer * * / botkit . worker = function ( botkit , config ) { this . botkit = botkit ; this . config = config ; this . say = function ( message , cb ) { botkit . logger . debug ( 'SAY : ' , message ) ; } ; this . reply With Question = function ( message , question , cb ) { botkit . start Conversation ( message , function ( convo ) { convo . ask ( question , cb ) ; } ) ; } ; this . reply = function ( src , resp ) { botkit . logger . debug ( 'REPLY : ' , resp ) ; } ; this . find Conversation = function ( message , cb ) { botkit . logger . debug ( 'DEFAULT FIND CONVO ' ) ; cb ( null ) ; } ; } ; botkit . user Agent = function ( ) { if ( ! botkit . my _user _agent ) { * for node 's http module . Developers can specify a hostname or IP * address to override this . * * / if ( ! botkit . config . hostname ) { botkit . config . hostname = ' 0 . 0 . 0 . 0 ' ; } if ( ! configuration . log Level ) { if ( configuration . debug ) { configuration . log Level = 'debug ' ; } else if ( configuration . log = = = false ) { configuration . log Level = 'error ' ; } else { configuration . log Level = 'info ' ; } } if ( configuration . logger ) { botkit . logger = configuration . logger ; } else { botkit . logger = logging ( 'abbott -framework :botkit :Core Bot ' ) ; } / / botkit .log = function ( ) { / / botkit .logger .info .apply (botkit .log , arguments ) ; / / } ; / / Object .keys (Log Levels ) .for Each (function (level ) { / / botkit .log [level ] = botkit .logger .log .bind (botkit .logger , level ) ; / / } ) ; / / botkit .debug = botkit .logger .debug ; / / if ( !botkit .config .disable _startup _messages ) { / / console .log ( 'Initializing Botkit v ' + botkit .version ( ) ) ; / / } if ( configuration . storage ) { if ( configuration . storage . teams & & configuration . storage . teams . get & & configuration . storage . teams . save & & configuration . storage . users & & configuration . storage . users . get & & configuration . storage . users . save & & configuration . storage . channels & & configuration . storage . channels . get & & configuration . storage . channels . save ) { botkit . logger . debug ( ' * * Using custom storage system . ' ) ; botkit . storage = configuration . storage ; } else { throw new Error ( 'Storage object does not have all required methods ! ' ) ; } / / } else if (configuration .json _file _store ) { / / botkit .logger .debug ( ' * * Using simple storage . Saving data to ' + configuration .json _file _store ) ; / / botkit .storage = simple _storage ( { / / path : configuration .json _file _store / / } ) ; } else { botkit . logger . debug ( ' * * No persistent storage method specified ! Data may be lost when process shuts down . ' ) ; } 
function Conversation ( task , message ) { this . messages = [ ] ; this . sent = [ ] ; this . transcript = [ ] ; this . context = { user : message . user , channel : message . channel , bot : task . bot , } ; this . events = { } ; this . vars = { } ; this . threads = { } ; this . thread = null ; this . status = 'new ' ; this . task = task ; this . source _message = message ; this . handler = null ; this . responses = { } ; this . capture _options = { } ; this . start Time = new Date ( ) ; this . last Active = new Date ( ) ; this . time Out Handler = null ; this . collect Response = function ( key , value ) { this . responses [ key ] = value ; } ; this . capture = function ( response , cb ) { var that = this ; var capture _key = this . sent [ this . sent . length - 1 ] . text ; botkit . middleware . capture . run ( that . task . bot , response , that , function ( err , bot , response , convo ) { if ( response . text ) { response . text = response . text . trim ( ) ; } else { response . text = ' ' ; } if ( that . capture _options . key ! = undefined ) { capture _key = that . capture _options . key ; } * active includes both ACTIVE and ENDING * in order to allow the timeout end scripts to play out * * / this . is Active = function ( ) { return ( this . status = = 'active ' | | this . status = = 'ending ' ) ; } ; this . deactivate = function ( ) { this . status = 'inactive ' ; } ; this . say = function ( message ) { this . add Message ( message ) ; } ; this . say First = function ( message ) { if ( typeof ( message ) = = 'string ' ) { message = { text : message , channel : this . source _message . channel , } ; } else { message . channel = this . source _message . channel ; } this . messages . unshift ( message ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for ' , event ) ; var events = event . split ( / \ , / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e + + ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res = = = false ) { return ; } } } else { } } ; 
function Task ( bot , message , botkit ) { this . convos = [ ] ; this . botkit = botkit ; this . bot = bot ; this . events = { } ; this . source _message = message ; this . status = 'active ' ; this . start Time = new Date ( ) ; this . is Active = function ( ) { return this . status = = 'active ' ; } ; this . create Conversation = function ( message ) { var convo = new Conversation ( this , message ) ; convo . id = botkit . convo Count + + ; this . convos . push ( convo ) ; return convo ; } ; this . start Conversation = function ( message ) { var convo = this . create Conversation ( message ) ; botkit . logger . debug ( ' > [Start ] ' , convo . id , ' Conversation with ' , message . user , 'in ' , message . channel ) ; convo . activate ( ) ; return convo ; } ; this . conversation Ended = function ( convo ) { botkit . logger . debug ( ' > [End ] ' , convo . id , ' Conversation with ' , convo . source _message . user , 'in ' , convo . source _message . channel ) ; this . trigger ( 'conversation Ended ' , [ convo ] ) ; this . botkit . trigger ( 'conversation Ended ' , [ bot , convo ] ) ; convo . trigger ( 'end ' , [ convo ] ) ; var actives = 0 ; for ( var c = 0 ; c < this . convos . length ; c + + ) { if ( this . convos [ c ] . is Active ( ) ) { actives + + ; } } if ( actives = = 0 ) { this . task Ended ( ) ; } } ; this . end Immediately = function ( reason ) { for ( var c = 0 ; c < this . convos . length ; c + + ) { if ( this . convos [ c ] . is Active ( ) ) { this . convos [ c ] . stop ( reason | | 'stopped ' ) ; } } } ; this . task Ended = function ( ) { botkit . logger . debug ( ' [End ] ' , this . id , ' Task for ' , this . source _message . user , 'in ' , this . source _message . channel ) ; this . status = 'completed ' ; this . trigger ( 'end ' , [ this ] ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for ' , event ) ; var events = event . split ( / \ , / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e + + ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res = = = false ) { return ; } } } } ; this . get Responses By User = function ( ) { var users = { } ; 
function verify Request ( req , res , buf , encoding ) { var expected = req . headers [ 'x -hub -signature ' ] ; var calculated = get Signature ( buf ) ; if ( expected ! = = calculated ) { throw new Error ( 'Invalid signature on incoming request ' ) ; } else { 
function Route ( pattern , Handler , observe , router ) { this . pattern = pattern ; this . map = parse Pattern ( pattern ) ; this . reg Exp = pattern To Reg Exp ( pattern ) ; this . strict Reg Exp = pattern To Strict Reg Exp ( pattern ) ; this . is Component = ! ! Handler . extend ; this . Handler = Handler ; this . observe = assign ( { qs : [ ] , hash : [ ] , state : [ ] } , observe ) ; this . all Observed = this . observe . qs . concat ( this . observe . hash , this . observe . state ) ; this . router = router | | { } ; this . view = null ; } 
function get Cookie ( cookies , name ) { var match = String ( cookies ) . match ( new Reg Exp ( name + ' = ( [ ^ ; ] + ) ' ) ) ; if ( match ) { return match [ 1 ] ; } return false ; } 
function append Options ( options , from Options ) { function push Option ( option Name , option Value ) { var value Defined = option Value ! = = null & & option Value ! = = undefined ; if ( option Name . length = = = 1 ) { 
function request _kissmetrics _client ( pathname , query _params , callback ) { var query _string = [ ' _k = ' , this . key , ' & ' ] . join ( ' ' ) , uri , v ; query _params [ ' _t ' ] = ( query _params [ ' _d ' ] ? query _params [ ' _t ' ] : Date . now ( ) ) ; for ( var k in query _params ) { v = query _params [ k ] ; if ( query _string ! = = ' ' ) { query _string + = ' & ' ; } query _string + = [ k , v ] . join ( ' = ' ) ; } uri = encode URI ( [ 'http ' , ' : ' , ' / / ' , this . host , ' : ' , this . port , pathname , ' ? ' , query _string ] . join ( ' ' ) ) ; 
function set _kissmetrics _client ( person , properties , callback ) { var query _params = new Object ( properties ) ; query _params [ ' _p ' ] = person ; this . request ( ' /s ' , query _params , callback ) ; } 
function alias _kissmetrics _client ( person , aliases , callback ) { var aliases = ( Array . is Array ( aliases ) ? aliases : [ aliases ] ) , that = this ; async . for Each ( aliases , function ( alias , callback ) { var query _params = { } ; query _params [ ' _p ' ] = person ; query _params [ ' _n ' ] = alias ; that . request ( ' /a ' , query _params , callback ) ; } , callback ) ; } 
function record _kissmetrics _client ( ) { var args = Array . prototype . slice . call ( arguments ) , callback = args . pop ( ) , person = args . shift ( ) , event = args . shift ( ) , properties = args . shift ( ) | | { } , query _params = new Object ( properties ) ; query _params [ ' _p ' ] = person ; query _params [ ' _n ' ] = event ; this . request ( ' /e ' , query _params , callback ) ; } 
function kissmetrics _client ( options ) { var options = options | | { } ; this . host = options . host | | DEFAULT _TRACKER _SERVER ; this . port = options . port | | DEFAULT _TRACKER _PORT ; this . key = options . key ; } 
function notify Pattern Observers ( ractive , registered Keypath , actual Keypath , is Parent Of Changed Keypath , is Top Level Call ) { var i , pattern Observer , children , child , key , child Actual Keypath , potential Wildcard Matches , cascade ; 
function get Star Map ( num ) { var ones = ' ' , max , binary , star Map , mapper , i ; if ( ! star Maps [ num ] ) { star Map = [ ] ; while ( ones . length < num ) { ones + = 1 ; } max = parse Int ( ones , 2 ) ; mapper = function ( digit ) { return digit = = = ' 1 ' ; } ; for ( i = 0 ; i < = max ; i + = 1 ) { binary = i . to String ( 2 ) ; while ( binary . length < num ) { binary = ' 0 ' + binary ; } star Map [ i ] = Array . prototype . map . call ( binary , mapper ) ; } star Maps [ num ] = star Map ; } return star Maps [ num ] ; } 
function ( keypath , root ) { var i = queue . length , animation ; while ( i - - ) { animation = queue [ i ] ; if ( animation . root = = = root & & animation . keypath = = = keypath ) { animation . stop ( ) ; } } } 
function ( ) { if ( ! this . self Updating ) { this . deferred = true ; } var i = this . refs . length ; while ( i - - ) { this . refs [ i ] . update ( ) ; } if ( this . deferred ) { this . update ( ) ; this . deferred = false ; } } 
function ( ) { var i ; if ( this . custom ) { this . custom . teardown ( ) ; } else { this . node . remove Event Listener ( this . name , generic Handler , false ) ; } i = this . proxies . length ; while ( i - - ) { this . proxies [ i ] . teardown ( ) ; } } 
function ( options ) { var easing ; this . duration = options . duration ; this . step = options . step ; this . complete = options . complete ; 
function get Refs ( token , refs ) { var i , list ; if ( token . t = = = types . REFERENCE ) { if ( refs . index Of ( token . n ) = = = - 1 ) { refs . unshift ( token . n ) ; } } list = token . o | | token . m ; if ( list ) { if ( is Object ( list ) ) { get Refs ( list , refs ) ; } else { i = list . length ; while ( i - - ) { get Refs ( list [ i ] , refs ) ; } } } if ( token . x ) { get Refs ( token . x , refs ) ; } if ( token . r ) { get Refs ( token . r , refs ) ; } if ( token . v ) { get Refs ( token . v , refs ) ; } } 
function assign ( object , source ) { for ( var i = 1 , c = arguments . length ; i < c ; i + + ) { for ( var x in arguments [ i ] ) { if ( arguments [ i ] . has Own Property ( x ) & & arguments [ i ] [ x ] ! = = undefined ) { object [ x ] = arguments [ i ] [ x ] ; } } } return object ; } 
function join Paths ( parts ) { return Array . prototype . slice . call ( arguments ) . join ( ' / ' ) . replace ( / \ / + / g , ' / ' ) ; } 
function parents ( el , name ) { while ( el & & el . node Name . to Lower Case ( ) ! = = name ) { el = el . parent Node ; } return el & & el . node Name . to Lower Case ( ) = = = name ? el : null ; } 
function parse Hash ( hash , keys ) { try { var parsed = compact ( JSON . parse ( decode URIComponent ( hash . substr ( 2 ) ) ) ) ; return keys ? pick ( parsed , keys ) : parsed ; } catch ( e ) { return { } ; } } 
function parse Uri ( uri ) { var parts = uri . match ( / ^ ( ? : ( [ \w + . - ] + ) : \ / \ / ( [ ^ / ] + ) ) ? ( [ ^ ? # ] * ) ? ( \ ? [ ^ # ] * ) ? ( # . * ) ? / ) ; return { protocol : parts [ 1 ] | | ' ' , host : parts [ 2 ] | | ' ' , path : parts [ 3 ] | | ' ' , qs : parts [ 4 ] | | ' ' , hash : parts [ 5 ] | | ' ' } ; } 
function parse QS ( qs , keys ) { var index = qs . index Of ( ' ? ' ) ; var parsed = { } ; if ( index ! = = - 1 ) { var pairs = qs . substr ( index + 1 ) . split ( ' & ' ) ; var pair = [ ] ; for ( var i = 0 , c = pairs . length ; i < c ; i + + ) { pair = pairs [ i ] . split ( ' = ' ) ; if ( ( ! is Empty ( pair [ 1 ] ) ) & & ( ! is Empty ( parse JSON ( pair [ 1 ] ) ) ) ) { parsed [ decode Form ( decode URIComponent ( pair [ 0 ] ) ) ] = parse JSON ( decode Form ( decode URIComponent ( pair [ 1 ] ) ) ) ; } } } return keys ? pick ( parsed , keys ) : parsed ; } 
function pick ( object , keys ) { var data = { } ; if ( typeof keys = = = 'function ' ) { for ( var x in object ) { if ( object . has Own Property ( x ) & & keys ( object [ x ] , x ) ) { data [ x ] = object [ x ] ; } } } else { for ( var i = 0 , c = keys . length ; i < c ; i + + ) { data [ keys [ i ] ] = object [ keys [ i ] ] ; } } return data ; } 
function scroll To ( id ) { var el = document . get Element By Id ( id ) ; if ( el ) { window . scroll By ( 0 , el . get Bounding Client Rect ( ) . top ) ; } else { window . scroll To ( 0 , 0 ) ; } } 
function stringify Hash ( data ) { data = compact ( data ) ; return ! is Empty ( data ) ? ' # ! ' + encode URIComponent ( stringify ( data ) ) : ' ' ; } 
function stringify QS ( data ) { var qs = ' ' ; for ( var x in data ) { if ( data . has Own Property ( x ) & & ! is Empty ( data [ x ] ) ) { qs + = ' & ' + encode URIComponent ( x ) + ' = ' + encode URIComponent ( stringify ( data [ x ] ) ) ; } } return qs ? ' ? ' + qs . substr ( 1 ) : ' ' ; } 
function Router ( options ) { this . globals = options . globals | | [ ] ; this . base Path = options . base Path | | ' ' ; this . el = options . el ; this . data = options . data | | function ( ) { return { } ; } ; this . history = options . history | | history ; this . strict Mode = ! ! options . strict Mode ; this . reload On Click = options . reload On Click ; this . links Watcher = null ; this . state Watcher = null ; this . route = null ; this . routes = [ ] ; this . uri = { } ; } 
function should Dispatch ( old Uri , new Uri , route ) { return old Uri . path ! = = new Uri . path | | old Uri . qs ! = = new Uri . qs | | ( decode URIComponent ( old Uri . hash ) ! = = decode URIComponent ( new Uri . hash ) & & ( ! route | | route . observe . hash . length ) ) ; } 
function Docker Cmd Manager ( dockerdesc Path ) { dockerdesc Path = dockerdesc Path | | ' . /dockerdesc .json ' ; if ( ! fs . exists Sync ( dockerdesc Path ) ) { throw new Error ( util . format ( 'The path " %s " does not exists . ' , dockerdesc Path ) ) ; } this . dockerdesc Dir = path . dirname ( dockerdesc Path ) ; var dockerdesc Path Stat = fs . stat Sync ( dockerdesc Path ) ; if ( dockerdesc Path Stat . is Directory ( ) ) { this . dockerdesc Dir = dockerdesc Path ; dockerdesc Path = path . join ( dockerdesc Path , 'dockerdesc .json ' ) ; } var dockerdesc Content = fs . read File Sync ( dockerdesc Path ) ; try { this . dockerdesc = JSON . parse ( dockerdesc Content ) ; } catch ( err ) { throw new Error ( 'Problem in the dockerdesc .json file format . \n ' + err . stack ) ; } } 
function dd ( object , _context , _key , _root , _root Path ) { _root = _root | | object ; _root Path = _root Path | | [ ] ; var drill = function ( key ) { var next Object = ( object & & object . has Own Property ( key ) & & object [ key ] | | undefined ) ; return dd ( next Object , object , key , _root , _root Path . concat ( key ) ) ; } ; drill . val = object ; drill . exists = object ! = = undefined ; drill . set = function ( value ) { if ( _root Path . length = = = 0 ) { return ; } var context Iterator = _root ; for ( var depth = 0 ; depth < _root Path . length ; depth + + ) { var key = _root Path [ depth ] ; var is Final Depth = ( depth = = = _root Path . length - 1 ) ; if ( ! is Final Depth ) { context Iterator [ key ] = ( context Iterator . has Own Property ( key ) & & typeof context Iterator [ key ] = = = 'object ' ? context Iterator [ key ] : { } ) ; context Iterator = context Iterator [ key ] ; } else { _context = context Iterator ; _key = key ; } } _context [ _key ] = value ; drill . val = value ; drill . exists = value ! = = undefined ; return value ; } ; drill . update = function ( value ) { if ( drill . exists ) { _context [ _key ] = value ; drill . val = value ; return value ; } } ; drill . invoke = is Function ( object ) ? Function . prototype . bind . call ( object , _context ) : function ( ) { } ; return drill ; } 
function ( option , req , res ) { this . params = { 'req ' : req , 'res ' : res } ; this . option = option ; this . features = { } ; 
function print Tasks ( tasks , verbose ) { tasks = tasks . filter Hidden ( verbose ) . sort ( ) ; var results = [ 'Usage : gulp [task ] [task 2 ] . . . ' , ' ' , 'Tasks : ' ] ; var field Task Len = tasks . get Longest Name Length ( ) ; tasks . for Each ( function ( task ) { var comment = task . comment | | { } ; var lines = comment . lines | | [ ] ; results . push ( format Column ( task . name , field Task Len ) + ( lines [ 0 ] | | ' ' ) ) ; for ( var i = 1 ; i < lines . length ; i + + ) { results . push ( format Column ( ' ' , field Task Len ) + ' ' + lines [ i ] ) ; } } ) ; return results . join ( ' \n ' ) ; } 
function format Column ( text , width , offset Left , offset Right ) { offset Left = undefined ! = = offset Left ? offset Left : 3 ; offset Right = undefined ! = = offset Right ? offset Right : 3 ; return new Array ( offset Left + 1 ) . join ( ' ' ) + text + new Array ( Math . max ( width - text . length , 0 ) + 1 ) . join ( ' ' ) + new Array ( offset Right + 1 ) . join ( ' ' ) ; } 
function inherit Gulp ( ) { function Task Doc ( ) { this . task List = new Task List ( ) ; gulp . Gulp . call ( this ) ; } Task Doc . prototype = gulp ; return new Task Doc ( ) ; } 
function where ( fn ) { if ( typeof fn ! = 'function ' ) { throw new Error ( 'where (param ) expected param should be a function ' ) ; } var fn Body = fn . to String ( ) . replace ( / \s *function [ ^ \ ( ] * [ \ ( ] [ ^ \ ) ] * [ \ ) ] [ ^ \ { ] * { / , ' ' ) . replace ( / [ \ } ] $ / , ' ' ) ; var values = parse Fn Body ( fn Body ) ; var labels = values [ 0 ] ; var fn Test = new Function ( labels . to String ( ) , fn Body ) ; var failed Count = 0 ; var trace = ' \n [ ' + labels . join ( PAD ) + ' ] : ' ; var current Spec = jasmine . get Env ( ) . current Spec | | { result : { } } ; var result = current Spec . result | | current Spec . results _ ; var item , message ; for ( var i = 1 ; i < values . length ; + + i ) { message = MESSAGE ; fn Test . apply ( current Spec , values [ i ] ) ; * jasmine 2 .x .x . * / if ( failed Count < result . failed Expectations . length ) { failed Count + = 1 ; item = result . failed Expectations [ failed Count - 1 ] ; message = item . message ; item . message = trace + ' \n [ ' + values [ i ] . join ( PAD ) + ' ] ( ' + message + ' ) ' ; } } else if ( result . items _ ) { item = result . items _ [ result . items _ . length - 1 ] ; if ( item & & ! item . passed _ ) { failed Count + = 1 ; message = item . message ; item . message = trace + ' \n [ ' + values [ i ] . join ( PAD ) + ' ] ( ' + message + ' ) ' ; } } } 
function parse Fn Body ( fn Body ) { var fs = fn Body . to String ( ) ; var table = fs . match ( / \ / ( \ * ) { 3 , 3 } [ ^ \ * ] + ( \ * ) { 3 , 3 } \ / / ) ; var data = table [ 0 ] . replace ( / [ \ / \ * ] * [ \r ] * [ \ * \ / ] * / g , ' ' ) . split ( ' \n ' ) ; var rows = [ ] ; var row , size ; for ( var i = 0 ; i < data . length ; i + + ) { row = data [ i ] . replace ( / \b [ \s * ] / , ' ' ) . replace ( / ( \s ) * \b / , ' ' ) ; if ( row . match ( / \S + / ) ) { row = row . replace ( / \s + / g , ' ' ) ; 
function should Not Have Duplicate Labels ( row ) { for ( var label , visited = { } , j = 0 ; j < row . length ; j + = 1 ) { label = row [ j ] ; if ( visited [ label ] ) { throw new Error ( 'where -data table contains duplicate label \ ' ' + label + ' \ ' in [ ' + row . join ( ' , ' ) + ' ] ' ) ; } visited [ label ] = 1 ; } } 
function convert Numerics ( row ) { for ( var t , i = 0 ; i < row . length ; i + = 1 ) { t = parse Float ( row [ i ] . replace ( / \ ' | \ " | \ , / g , ' ' ) ) ; is Na N ( t ) | | ( row [ i ] = t ) ; } } 
function _log ( level ) { return function ( ) { var meta = null ; var args = arguments ; if ( arguments . length = = = 0 ) { 
function get Path ( obj , path , default Value ) { var pointer = obj ; path . split ( ' . ' ) . every ( function ( slice ) { if ( pointer [ slice ] ) { pointer = pointer [ slice ] ; return true ; } else { pointer = default Value ; return false ; } } ) ; return pointer ; } 
function is Promise ( item ) { if ( ! item ) return false ; return ( ( util . types & & util . types . is Promise & & util . types . is Promise ( item ) ) | | ( item . constructor & & item . constructor . name = = 'Promise ' ) | | ( ! item instanceof object Instance & & item . then & & typeof item . then = = 'function ' ) ) ; } 
function has Callback ( fn ) { var fn String = fn . to String ( ) ; 
function parallel ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'function ' , function ( callback ) { self . _struct . push ( { type : 'parallel Array ' , payload : [ callback ] } ) ; } ) . if Form ( 'string function ' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'parallel Array ' , payload : payload } ) ; } ) . if Form ( 'array ' , function ( tasks ) { self . _struct . push ( { type : 'parallel Array ' , payload : tasks } ) ; } ) . if Form ( 'object ' , function ( tasks ) { self . _struct . push ( { type : 'parallel Object ' , payload : tasks } ) ; } ) 
function race ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'array ' , function ( tasks ) { self . _struct . push ( { type : 'race ' , payload : tasks } ) ; } ) . if Form ( 'string array ' , function ( id , tasks ) { self . _struct . push ( { type : 'race ' , id : arguments [ 0 ] , payload : arguments [ 1 ] } ) ; } ) . if Form Else ( function ( form ) { throw new Error ( 'Unknown call style for .parallel ( ) : ' + form ) ; } ) return self ; } 
function for Each ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'array function ' , function ( tasks , callback ) { self . _struct . push ( { type : 'for Each Array ' , payload : tasks , callback : callback } ) ; } ) . if Form ( 'object function ' , function ( tasks , callback ) { self . _struct . push ( { type : 'for Each Object ' , payload : tasks , callback : callback } ) ; } ) . if Form ( 'string function ' , function ( tasks , callback ) { self . _struct . push ( { type : 'for Each Late Bound ' , payload : tasks , callback : callback } ) ; } ) . if Form ( 'number function ' , function ( max , callback ) { self . _struct . push ( { type : 'for Each Range ' , min : 1 , max : max , callback : callback } ) ; } ) . if Form ( 'number number function ' , function ( min , max , callback ) { self . _struct . push ( { type : 'for Each Range ' , min : min , max : max , callback : callback } ) ; } ) . if Form ( 'string array function ' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'map Array ' , output : output , payload : tasks , callback : callback } ) ; } ) . if Form ( 'string object function ' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'map Object ' , output : output , payload : tasks , callback : callback } ) ; } ) . if Form ( 'string string function ' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'map Late Bound ' , output : output , payload : tasks , callback : callback } ) ; } ) . if Form Else ( function ( form ) { throw new Error ( 'Unknown call style for .for Each ( ) : ' + form ) ; } ) ; return self ; } 
function defer Add ( id , task , parent Chain ) { var self = this ; parent Chain . waiting On = ( parent Chain . waiting On | | 0 ) + 1 ; if ( ! parent Chain . waiting On Ids ) parent Chain . waiting On Ids = [ ] ; parent Chain . waiting On Ids . push ( id ) ; self . _deferred . push ( { id : id | | null , prereq : parent Chain . prereq | | [ ] , payload : function ( next ) { self . _context . _id = id ; run ( self . _options . context , task , function ( err , value ) { 
function defer ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'function ' , function ( callback ) { self . _struct . push ( { type : 'defer Array ' , payload : [ callback ] } ) ; } ) . if Form ( 'string function ' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'defer Object ' , payload : payload } ) ; } ) . if Form ( 'array ' , function ( tasks ) { self . _struct . push ( { type : 'defer Array ' , payload : tasks } ) ; } ) . if Form ( 'object ' , function ( tasks ) { self . _struct . push ( { type : 'defer Object ' , payload : tasks } ) ; } ) . if Form ( 'array function ' , function ( pre Reqs , callback ) { self . _struct . push ( { type : 'defer Array ' , prereq : pre Reqs , payload : [ callback ] } ) ; } ) . if Form ( 'string string function ' , function ( pre Req , id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'defer Object ' , prereq : [ pre Req ] , payload : payload } ) ; } ) . if Form ( 'array string function ' , function ( pre Reqs , id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'defer Object ' , prereq : pre Reqs , payload : payload } ) ; } ) . if Form ( 'string array function ' , function ( id , pre Reqs , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'defer Object ' , prereq : pre Reqs , payload : payload } ) ; } ) . if Form Else ( function ( form ) { throw new Error ( 'Unknown call style for .defer ( ) : ' + form ) ; } ) ; return self ; } 
function await ( ) { var payload = [ ] ; 
function timeout ( new Timeout ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { self . _struct . push ( { type : 'timeout ' , delay : false } ) ; } ) . if Form ( 'boolean ' , function ( set Timeout ) { if ( set Timeout ) throw new Error ( 'When calling .timeout (Boolean ) only False is accepted to disable the timeout ' ) ; self . _struct . push ( { type : 'timeout ' , delay : false } ) ; } ) . if Form ( 'number ' , function ( delay ) { self . _struct . push ( { type : 'timeout ' , delay : delay } ) ; } ) . if Form ( 'function ' , function ( callback ) { self . _struct . push ( { type : 'timeout ' , callback : callback } ) ; } ) . if Form ( 'number function ' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout ' , delay : delay , callback : callback } ) ; } ) . if Form ( 'function number ' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout ' , delay : delay , callback : callback } ) ; } ) . if Form Else ( function ( form ) { throw new Error ( 'Unknown call style for .timeout ( ) : ' + form ) ; } ) ; return self ; } 
function _timeout Handler ( ) { var current Task Index = this . _struct . find Index ( function ( task ) { return ! task . completed } ) ; if ( ! current Task Index < 0 ) { console . log ( 'Async -Chainable timeout on unknown task ' ) ; console . log ( 'Full structure : ' , this . _struct ) ; } else { console . log ( 'Async -Chainable timeout : Task # ' , current Task Index + 1 , ' ( ' + this . _struct [ current Task Index ] . type + ' ) ' , 'elapsed timeout of ' , this . _options . timeout + 'ms ' ) ; } this . fire ( 'timeout ' ) ; } 
function set ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'string scalar |array |object |date |regexp |null ' , function ( id , value ) { var payload = { } ; payload [ id ] = value ; self . _struct . push ( { type : 'set ' , payload : payload } ) ; } ) . if Form ( 'object ' , function ( obj ) { self . _struct . push ( { type : 'set ' , payload : obj } ) ; } ) . if Form ( 'function ' , function ( callback ) { self . _struct . push ( { type : 'series Array ' , payload : [ callback ] } ) ; } ) . if Form ( 'string function ' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'series Object ' , payload : payload } ) ; } ) . if Form ( [ 'string ' , 'string undefined ' ] , function ( id ) { var payload = { } ; payload [ id ] = undefined ; self . _struct . push ( { type : 'set ' , payload : payload } ) ; } ) . if Form Else ( function ( form ) { throw new Error ( 'Unknown call style for .set ( ) : ' + form ) ; } ) ; return self ; } 
function _set ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'string scalar |array |object |date |regexp |null ' , function ( id , value ) { self . _set Raw ( id , value ) ; } ) . if Form ( 'object ' , function ( obj ) { for ( var key in obj ) self . _set Raw ( key , obj [ key ] ) ; } ) . if Form ( 'string function ' , function ( id , callback ) { self . _set Raw ( id , callback . call ( this ) ) ; } ) . if Form ( 'function ' , function ( callback ) { 
function _finalize ( err ) { 
function _execute ( err ) { var self = this ; if ( err ) return this . _finalize ( err ) ; 
function run Array ( tasks , limit , callback ) { var self = this ; var next Task Offset = 0 ; var running = 0 ; var err ; 
function ( task Err , task Result ) { if ( task Err ) err = task Err ; - - running ; if ( err & & ! running ) { reset Timeout ( false ) ; callback ( err ) ; } else if ( err ) { 
function run ( context , fn , finish , args ) { 
function run While ( iter , limit , callback ) { var index = 0 ; var has Exited = false ; var err ; var running = 0 ; if ( ! Number . is Finite ( limit ) ) limit = 1 0 ; var invoke = function ( ) { iter . call ( this . _context , function ( task Err , task Result ) { if ( task Err ) err = task Err ; if ( task Err | | ! task Result ) has Exited = true ; - - running ; if ( err & & ! running ) { callback ( err , res ) ; } else if ( running < = 0 & & has Exited ) { callback ( err ) ; } else if ( ! has Exited ) { set Timeout ( invoke ) ; } } , index + + ) ; } ; for ( var i = 0 ; i < limit ; i + + ) { running + + ; set Timeout ( invoke ) ; } return this ; } 
function reset ( ) { this . _struct = [ ] ; this . _struct Pointer = 0 ; var re Attach Context = ( this . _options . context = = this . _context ) ; 
function hook ( ) { var self = this ; argy ( arguments ) . if Form ( ' ' , function ( ) { } ) . if Form ( 'string function ' , function ( hook , callback ) { 
function hybrid ( fn , cb ) { if ( typeof cb = = = 'function ' ) { 
function tag ( name ) { if ( ! this . comment | | ! this . comment . tags ) { return null ; } for ( var i = 0 ; i < this . comment . tags . length ; i + + ) { var tag Obj = this . comment . tags [ i ] ; if ( tag Obj . name = = = name ) { return tag Obj . value ; } } return null ; } 
function Fixed Value History ( max Length , initial ) { if ( ! ( this instanceof Fixed Value History ) ) return new Fixed Value History ( max Length , initial ) if ( ! is Number ( max Length ) | | max Length = = 0 ) { throw new Error ( "max Length must be a positive number . " ) } this . max Length = Math . floor ( + max Length ) if ( initial ! = null ) { this . push ( initial ) } } 
function ( path , max Age , cron Time , options ) { this . job = null ; this . path = path ; this . max Age = max Age ; this . cron Time = cron Time ; this . options = util . _extend ( { } , default Options ) ; if ( typeof options = = = 'object ' & & options ! = = null ) { this . options = util . _extend ( this . options , options ) ; } if ( this . options . start = = = true ) { this . start ( ) ; } } 
function check Pattern ( file , black List , white List ) { if ( util . is Reg Exp ( black List ) & & black List . test ( file ) ) { return false ; } if ( util . is Reg Exp ( white List ) ) { if ( white List . test ( file ) ) { return true ; } return false ; } return true ; } 
function create Getter Setter ( prop Name ) { function gs ( element , value ) { 
function Seven ( _a ) { var _b = _a = = = void 0 ? { } : _a , height = _b . height , width = _b . width , _c = _b . angle , angle = _c = = = void 0 ? 1 0 : _c , _d = _b . ratio Lto W , ratio Lto W = _d = = = void 0 ? 4 : _d , _e = _b . ratio Lto S , ratio Lto S = _e = = = void 0 ? 3 2 : _e , _f = _b . digit , digit = _f = = = void 0 ? Digit . BLANK : _f ; this . _horizontal Segment Geometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _vertical Segment Geometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _translations = [ { x : 0 , y : 0 , a : this . _horizontal Segment Geometry } , { x : 0 , y : 0 , a : this . _vertical Segment Geometry } , { x : 0 , y : 0 , a : this . _vertical Segment Geometry } , { x : 0 , y : 0 , a : this . _horizontal Segment Geometry } , { x : 0 , y : 0 , a : this . _vertical Segment Geometry } , { x : 0 , y : 0 , a : this . _vertical Segment Geometry } , { x : 0 , y : 0 , a : this . _horizontal Segment Geometry } ] ; this . segments = [ new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) ] ; this . _angle Degree = angle ; this . digit = digit ; this . _ratio Lto W = ratio Lto W ; this . _ratio Lto S = ratio Lto S ; this . _height = this . _width = 1 0 0 ; 
function Friends Of Friends ( mongoose , options ) { debug ( 'mongoose ' , mongoose ) ; debug ( 'options ' , options ) ; if ( ! ( this instanceof Friends Of Friends ) ) { return new Friends Of Friends ( mongoose , options ) ; } var friendship = require ( ' . /friendship ' ) , plugin = require ( ' . /plugin ' ) ; var defaults = { person Model Name : 'Person ' , friendship Model Name : 'Friendship ' , friendship Collection Name : undefined , } ; this . options = utils . extend ( defaults , options ) ; this . Friendship = friendship ( mongoose , this . options ) ; this . plugin = plugin ( mongoose ) ; } 
function total Rx ( opts ) { if ( opts ) { opts . iface = opts . iface | | 'lo ' ; opts . units = opts . units | | 'bytes ' ; } else { opts = { iface : 'lo ' , units : 'bytes ' , } ; } var total = parse Int ( _parse Proc Net Dev ( ) [ opts . iface ] . bytes . receive ) ; var converted = _bytes To ( total , opts . units ) ; return converted ; } 
function _parse Proc Net Dev ( ) { var buf = fs . read File Sync ( ' /proc /net /dev ' ) ; var lines = buf . to String ( ) . trim ( ) . split ( ' \n ' ) ; var sections = lines . shift ( ) . split ( ' | ' ) ; var columns = lines . shift ( ) . trim ( ) . split ( ' | ' ) ; var s ; var l ; var c ; var p = 0 ; var map = { } ; var keys = [ ] ; for ( var i = 0 ; i < sections . length ; + + i ) { s = sections [ i ] . trim ( ) ; l = sections [ i ] . length ; c = columns [ i ] . trim ( ) . split ( / \s + / g ) ; while ( c . length ) { map [ keys . length ] = s ; keys . push ( c . shift ( ) ) ; } p + = s . length + 1 ; } var ret Obj = { } ; lines . for Each ( function ( l ) { l = l . trim ( ) . split ( / \s + / g ) ; var o = { } ; var iface ; for ( var i = 0 ; i < l . length ; + + i ) { var s = map [ i ] ; 
function on Change ( event ) { try { if ( remove ( ) ) { return ; } resolve ( Array . from ( input . files ) ) ; 
function Remove Observer _init ( ref , node ) { let self = Self . get ( node ) ; if ( ! self ) { self = new Remove Observer Private ( node ) ; Self . set ( node , self ) ; } Self . set ( ref , self ) ; } 
function ( done ) { async . series ( [ function ( next ) { var child = child _process . exec ( 'jsdoc -c jsdoc .conf .json lib / ' ) ; child . stdout . on ( 'data ' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data ' , function ( data ) { console . log ( 'stderr : ' + data ) ; var err = new Error ( 'error spawning : ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close ' , function ( code ) { if ( code = = = 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning : ' , cmd ) ) ; } } ) ; } , function ( next ) { var cmd = util . format ( 'cp -r doc / %s / %s / * doc / ' , package . name , package . version ) ; var child = child _process . exec ( cmd ) ; child . stdout . on ( 'data ' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data ' , function ( data ) { console . log ( 'stderr : ' + data ) ; var err = new Error ( 'error spawning : ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close ' , function ( code ) { if ( code = = = 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning jsdoc ' ) ) ; } } ) ; } , function ( next ) { var cmd = 'rm -rf doc / ' + package . name + ' / ' ; var child = child _process . exec ( cmd ) ; child . stdout . on ( 'data ' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data ' , function ( data ) { console . log ( 'stderr : ' + data ) ; var err = new Error ( 'error spawning : ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close ' , function ( code ) { console . log ( 'child process exited with code ' + code ) ; if ( code = = = 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning jsdoc ' ) ) ; } } ) ; } ] , function ( err , results ) { if ( err ) done ( err ) ; else done ( ) ; } ) ; } 
function ( done ) { console . log ( 'generating markdown docs . . . ' ) ; var tasks = { } , task Names = [ 'index ' , 'friendship ' , 'plugin ' , 'relationships ' ] ; 
function parse Property Chains ( expr ) { var parsed Expr = ' ' , chain ; 
function parse Function ( link , index , expr ) { var call = get Function Call ( expr ) ; 
function parse Brackets ( link , index , expr ) { var call = get Function Call ( expr ) ; var inside Brackets = call . slice ( 1 , - 1 ) ; var evaled Link = parse Part ( link , index ) ; index + = 1 ; link = ' [ ~ ~inside Brackets ~ ~ ] ' ; if ( expr . char At ( property Regex . last Index ) = = = ' . ' ) { link = parse Part ( link , index ) ; } else { link = ' _ref ' + current Reference + link ; } link = evaled Link + link ; var ref = current Reference ; link = link . replace ( ' ~ ~inside Brackets ~ ~ ' , parse Property Chains ( inside Brackets ) ) ; current Reference = ref ; return link ; } 
function get Function Call ( expr ) { var start Index = property Regex . last Index ; var open = expr . char At ( start Index - 1 ) ; var close = parens [ open ] ; var end Index = start Index - 1 ; var paren Count = 1 ; while ( end Index + + < expr . length ) { var ch = expr . char At ( end Index ) ; if ( ch = = = open ) paren Count + + ; else if ( ch = = = close ) paren Count - - ; if ( paren Count = = = 0 ) break ; } current Index = property Regex . last Index = end Index + 1 ; return open + expr . slice ( start Index , end Index ) + close ; } 
function add References ( expr ) { if ( reference Count ) { var refs = [ ] ; for ( var i = 1 ; i < = reference Count ; i + + ) { refs . push ( ' _ref ' + i ) ; } expr = 'var ' + refs . join ( ' , ' ) + ' ; \n ' + expr ; } return expr ; } 
function ( fn ) { var pending var has Next function next ( ) { set Timeout ( function ( ) { if ( pending = = = false ) return pending = false if ( has Next ) { has Next = false fn ( next ) } } , 5 0 ) 
function assert ( t , m ) { if ( ! t ) { var err = new Assertion Error ( m ) if ( Error . capture Stack Trace ) Error . capture Stack Trace ( err , assert ) throw err } } 
function bind Arguments ( func ) { function binder ( ) { return func . apply ( this , args . concat ( slice . call ( arguments ) ) ) ; } var args = slice . call ( arguments , 1 ) ; return binder ; } 
function get Route Index From Pattern Id ( pattern : string | number ) : number { const pat = transitive Network . patterns . find ( p = > p . pattern _id = = = String ( pattern ) ) if ( ! pat ) return - 1 return transitive Network . routes . find Index ( r = > r . route _id = = = pat . route _id ) } 
function get Common Paths ( { get Route Index From Pattern Id , log , origin , paths } : { get Route Index From Pattern Id : ( string | number ) = > number , log : Function , origin : Origin , paths : Array < Path Descriptor > } ) : Array < Stop Pattern Stops > { paths . sort ( by Stop Id And Path Index ) const path Counts = paths . reduce ( count Common Paths , [ ] ) path Counts . sort ( by Count ) log ( ` $ { path Counts . length } ` ) if ( path Counts . length > MAX _TRANSITIVE _PATHS ) { log ( ` $ { path Counts . length - MAX _TRANSITIVE _PATHS } $ { path Counts [ MAX _TRANSITIVE _PATHS ] . count } $ { paths . length } ` ) } let all Stop Pattern Stop Sets = path Counts . slice ( 0 , MAX _TRANSITIVE _PATHS ) . map ( ( p ) = > p . path ) . filter ( unique Path Ids ) 
function cluster Journeys ( { journeys , log , patterns , stops } : { journeys : Array < Journey > , log : Function , patterns : Array < Pattern > , stops : Array < Stop > } ) { 
function get Cluster Dissimilarity ( c 1 : Array < Journey > , c 2 : Array < Journey > , { patterns , stops } : { patterns : Array < Pattern > , stops : Array < Stop > } ) : number { let dissimilarity = 0 for ( const j 1 of c 1 ) { for ( const j 2 of c 2 ) { 
function segment Dissimilarity ( s 1 : Segment , s 2 : Segment , { patterns , stops } : { patterns : Array < Pattern > , stops : Array < Stop > } ) : number { const pat 1 = patterns . find ( ( p ) = > p . pattern _id = = = s 1 . pattern _id ) const pat 2 = patterns . find ( ( p ) = > p . pattern _id = = = s 2 . pattern _id ) if ( ! pat 1 | | ! pat 2 ) return Infinity const s 1f = s 1 . from _stop _index const s 1t = s 1 . to _stop _index const s 2f = s 2 . from _stop _index const s 2t = s 2 . to _stop _index if ( s 1f = = null | | s 1t = = null | | s 2f = = null | | s 2t = = null ) return Infinity function find Stop ( id : string ) : ? Stop { return stops . find ( ( stop ) = > stop . stop _id = = = id ) } const from 1 = find Stop ( pat 1 . stops [ s 1f ] . stop _id ) const to 1 = find Stop ( pat 1 . stops [ s 1t ] . stop _id ) const from 2 = find Stop ( pat 2 . stops [ s 2f ] . stop _id ) const to 2 = find Stop ( pat 2 . stops [ s 2t ] . stop _id ) if ( ! from 1 | | ! from 2 | | ! to 1 | | ! to 2 ) return Infinity const d 1 = stop Distance ( from 1 , from 2 ) const d 2 = stop Distance ( to 1 , to 2 ) return Math . max ( d 1 , d 2 ) } 
function stop Distance ( s 1 : Stop , s 2 : Stop ) : number { const cos Lat = Math . cos ( s 1 . stop _lat * Math . PI / 1 8 0 ) return Math . pow ( s 1 . stop _lat - s 2 . stop _lat , 2 ) + Math . pow ( s 1 . stop _lon * cos Lat - s 2 . stop _lon * cos Lat , 2 ) } 
function get Exceptions ( ) { const openers = [ ] ; const closers = [ ] ; if ( options . brace Exception ) { openers . push ( ' { ' ) ; closers . push ( ' } ' ) ; } if ( options . bracket Exception ) { openers . push ( ' [ ' ) ; closers . push ( ' ] ' ) ; } if ( options . paren Exception ) { openers . push ( ' ( ' ) ; closers . push ( ' ) ' ) ; } if ( options . empty ) { openers . push ( ' ) ' ) ; closers . push ( ' ( ' ) ; } return { openers , closers } ; } 
function should Opener Have Space ( left , right ) { if ( source Code . is Space Between Tokens ( left , right ) ) { return false ; } if ( ALWAYS ) { if ( ast Utils . is Closing Paren Token ( right ) ) { return false ; } return ! is Opener Exception ( right ) ; } return is Opener Exception ( right ) ; } 
function should Closer Have Space ( left , right ) { if ( ast Utils . is Opening Paren Token ( left ) ) { return false ; } if ( source Code . is Space Between Tokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return ! is Closer Exception ( left ) ; } return is Closer Exception ( left ) ; } 
function should Opener Reject Space ( left , right ) { if ( right . type = = = 'Line ' ) { return false ; } if ( ! ast Utils . is Token On Same Line ( left , right ) ) { return false ; } if ( ! source Code . is Space Between Tokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return is Opener Exception ( right ) ; } return ! is Opener Exception ( right ) ; } 
function should Closer Reject Space ( left , right ) { if ( ast Utils . is Opening Paren Token ( left ) ) { return false ; } if ( ! ast Utils . is Token On Same Line ( left , right ) ) { return false ; } if ( ! source Code . is Space Between Tokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return is Closer Exception ( left ) ; } return ! is Closer Exception ( left ) ; } 
function define Configurable ( obj , key , val ) { Object . define Property ( obj , key , { configurable : true , enumerable : false , writable : true , value : val } ) ; } 
function To Integer ( argument ) { var number = + argument ; if ( number ! = = number ) { return 0 ; } if ( number = = = 0 | | number = = = Infinity | | number = = = - Infinity ) { return number ; } return ( number > = 0 ? 1 : - 1 ) * Math . floor ( Math . abs ( number ) ) ; } 
function To Length ( argument ) { var len = To Integer ( argument ) ; return len < = 0 ? 0 : Math . min ( len , Math . pow ( 2 , 5 3 ) - 1 ) ; } 
function Same Value ( x , y ) { if ( typeof x ! = = typeof y ) { return false ; } if ( Type ( x ) = = = 'undefined ' ) { return true ; } if ( Type ( x ) = = = 'number ' ) { if ( x ! = = x & & y ! = = y ) { return true ; } if ( x = = = 0 ) { return 1 / x = = = 1 / y ; } } return x = = = y ; } 
function Iterator Next ( iterator , value ) { var result = iterator . next ( value ) ; if ( Type ( result ) ! = = 'object ' ) { throw Type Error ( ) ; } return result ; } 
function Iterator Step ( iterator ) { var result = Iterator Next ( iterator ) ; return Iterator Complete ( result ) = = = true ? false : result ; } 
function Create Iter Result Object ( value , done ) { if ( Type ( done ) ! = = 'boolean ' ) { throw Type Error ( ) ; } return { value : value , done : done } ; } 
function Enqueue Task ( task , args ) { if ( typeof set Immediate = = = 'function ' ) { set Immediate ( function ( ) { task . apply ( null , args ) ; } ) ; } else { set Timeout ( function ( ) { task . apply ( null , args ) ; } , 0 ) ; } } 
function Create Array Iterator ( array , kind ) { var O = To Object ( array ) , iterator = Object . create ( Array Iterator Prototype ) ; define Internal ( iterator , ' [ [Iterated Object ] ] ' , O ) ; define Internal ( iterator , ' [ [Array Iterator Next Index ] ] ' , 0 ) ; define Internal ( iterator , ' [ [Array Iterator Kind ] ] ' , kind ) ; return iterator ; } 
function If Abrupt Reject Promise ( value , capability ) { try { capability [ ' [ [Reject ] ] ' ] . call ( undefined , [ value ] ) ; } catch ( e ) { return e ; } return capability ; } 
function Promise Resolve ( ) { return function F ( resolution ) { var promise = F [ ' [ [Promise ] ] ' ] , reactions ; if ( Type ( promise ) ! = = 'object ' ) { throw Type Error ( ) ; } if ( promise [ ' [ [Promise Status ] ] ' ] ! = = 'unresolved ' ) { return undefined ; } reactions = promise [ ' [ [Promise Resolve Reactions ] ] ' ] ; define Internal ( promise , ' [ [Promise Result ] ] ' , resolution ) ; define Internal ( promise , ' [ [Promise Resolve Reactions ] ] ' , undefined ) ; define Internal ( promise , ' [ [Promise Reject Reactions ] ] ' , undefined ) ; define Internal ( promise , ' [ [Promise Status ] ] ' , 'has -resolution ' ) ; return Trigger Promise Reactions ( reactions , resolution ) ; } ; } 
function New Promise Capability ( C ) { var promise ; if ( ! Is Constructor ( C ) ) { throw Type Error ( ) ; } try { promise = Object . create ( C . prototype ) ; } catch ( e ) { return e ; } return Create Promise Capability Record ( promise , C ) ; } 
function Create Promise Capability Record ( promise , constructor ) { var promise Capability = { } , executor , constructor Result ; define Internal ( promise Capability , ' [ [Promise ] ] ' , promise ) ; define Internal ( promise Capability , ' [ [Resolve ] ] ' , undefined ) ; define Internal ( promise Capability , ' [ [Reject ] ] ' , undefined ) ; executor = new Get Capabilities Executor ( ) ; define Internal ( executor , ' [ [Capability ] ] ' , promise Capability ) ; try { constructor Result = constructor . call ( promise , executor ) ; } catch ( e ) { return e ; } if ( ! Is Callable ( promise Capability [ ' [ [Resolve ] ] ' ] ) ) { throw Type Error ( ) ; } if ( ! Is Callable ( promise Capability [ ' [ [Reject ] ] ' ] ) ) { throw Type Error ( ) ; } if ( typeof constructor Result = = = 'object ' & & ! Same Value ( promise , constructor Result ) ) { throw Type Error ( ) ; } return promise Capability ; } 
function Get Capabilities Executor ( ) { return function F ( resolve , reject ) { var promise Capability = F [ ' [ [Capability ] ] ' ] ; if ( Type ( promise Capability [ ' [ [Resolve ] ] ' ] ) ! = = 'undefined ' ) { throw Type Error ( ) ; } if ( Type ( promise Capability [ ' [ [Reject ] ] ' ] ) ! = = 'undefined ' ) { throw Type Error ( ) ; } define Internal ( promise Capability , ' [ [Resolve ] ] ' , resolve ) ; define Internal ( promise Capability , ' [ [Reject ] ] ' , reject ) ; } ; } 
function Trigger Promise Reactions ( reactions , argument ) { reactions . for Each ( function ( reaction ) { Enqueue Task ( Promise Reaction Task , [ reaction , argument ] ) ; } ) ; } 
function Update Promise From Potential Thenable ( x , promise Capability ) { var then , reject Result , then Call Result ; if ( Type ( x ) ! = = 'object ' ) { return 'not a thenable ' ; } try { then = x . then ; } catch ( e ) { reject Result = promise Capability [ ' [ [Reject ] ] ' ] . call ( undefined , e ) ; return null ; } if ( ! Is Callable ( then ) ) { return 'not a thenable ' ; } try { then Call Result = then . call ( x , promise Capability [ ' [ [Resolve ] ] ' ] , promise Capability [ ' [ [Reject ] ] ' ] ) ; } catch ( e ) { reject Result = promise Capability [ ' [ [Reject ] ] ' ] . call ( undefined , e ) ; return null ; } return null ; } 
function Promise Reaction Task ( reaction , argument ) { var promise Capability = reaction [ ' [ [Capabilities ] ] ' ] , handler = reaction [ ' [ [Handler ] ] ' ] , handler Result , self Resolution Error , update Result ; try { handler Result = handler . call ( undefined , argument ) ; } catch ( e ) { return promise Capability [ ' [ [Reject ] ] ' ] . call ( undefined , e ) ; } if ( Same Value ( handler Result , promise Capability [ ' [ [Promise ] ] ' ] ) ) { self Resolution Error = Type Error ( ) ; return promise Capability [ ' [ [Reject ] ] ' ] . call ( undefined , self Resolution Error ) ; } update Result = Update Promise From Potential Thenable ( handler Result , promise Capability ) ; if ( update Result = = = 'not a thenable ' ) { return promise Capability [ ' [ [Resolve ] ] ' ] . call ( undefined , handler Result ) ; } return undefined ; } 
function Promise ( executor ) { var promise = this ; if ( ! Is Callable ( executor ) ) { throw Type Error ( 'Invalid executor ' ) ; } if ( Type ( promise ) ! = = 'object ' ) { throw Type Error ( 'Invalid promise ' ) ; } if ( Type ( promise [ ' [ [Promise Status ] ] ' ] ) ! = = 'undefined ' ) { throw Type Error ( ) ; } define Internal ( this , ' [ [Promise Constructor ] ] ' , Promise ) ; return Initialize Promise ( promise , executor ) ; } 
function Initialize Promise ( promise , executor ) { var resolve , reject , completion , status ; if ( Type ( promise [ ' [ [Promise Status ] ] ' ] ) ! = = 'undefined ' ) { throw Type Error ( ) ; } if ( ! Is Callable ( executor ) ) { throw Type Error ( ) ; } define Internal ( promise , ' [ [Promise Status ] ] ' , 'unresolved ' ) ; define Internal ( promise , ' [ [Promise Resolve Reactions ] ] ' , [ ] ) ; define Internal ( promise , ' [ [Promise Reject Reactions ] ] ' , [ ] ) ; resolve = Create Resolve Function ( promise ) ; reject = Create Reject Function ( promise ) ; try { completion = executor . call ( undefined , resolve , reject ) ; } catch ( e ) { try { status = reject . call ( undefined , e ) ; } catch ( e ) { return e ; } } return promise ; } 
function Promise Resolution Handler Function ( ) { return function F ( x ) { var promise = F [ ' [ [Promise ] ] ' ] , fulfillment Handler = F [ ' [ [Fulfillment Handler ] ] ' ] , rejection Handler = F [ ' [ [Rejection Handler ] ] ' ] , self Resolution Error , C , promise Capability , update Result ; if ( Same Value ( x , promise ) ) { self Resolution Error = Type Error ( ) ; return rejection Handler . call ( undefined , self Resolution Error ) ; } C = promise [ ' [ [Promise Constructor ] ] ' ] ; try { promise Capability = New Promise Capability ( C ) ; } catch ( e ) { return e ; } try { update Result = Update Promise From Potential Thenable ( x , promise Capability ) ; } catch ( e ) { return e ; } if ( update Result ! = = 'not a thenable ' ) { return promise Capability [ ' [ [Promise ] ] ' ] . then ( fulfillment Handler , rejection Handler ) ; } return fulfillment Handler . call ( undefined , x ) ; } ; } 
function ( target , sequence , t ) { 
function ( e ) { var el = e . target , attr , type = e . type , key = type . index Of ( 'key ' ) = = = 0 ? e . which | | e . key Code | | ' ' : ' ' , special = _ . special [ type + key ] ; if ( el & & special ) { type = special ( e , el , el . node Name . to Lower Case ( ) ) ; if ( ! type ) { return ; } 
function ( el , sequence ) { if ( typeof el = = = "string " ) { sequence = el ; el = document ; } return _ . all ( el , sequence | | _ . attr ( el , 'click ' ) ) ; } 
function report No Beginning Space ( node , token , token After ) { context . report ( { node : node , loc : token . loc . start , message : 'There should be no space after \ ' ' + token . value + ' \ ' ' , fix : function ( fixer ) { return fixer . remove Range ( [ token . range [ 1 ] , token After . range [ 0 ] ] ) ; } } ) ; } 
function report No Ending Space ( node , token , token Before ) { context . report ( { node : node , loc : token . loc . start , message : 'There should be no space before \ ' ' + token . value + ' \ ' ' , fix : function ( fixer ) { return fixer . remove Range ( [ token Before . range [ 1 ] , token . range [ 0 ] ] ) ; } } ) ; } 
function report Required Beginning Space ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required after \ ' ' + token . value + ' \ ' ' , fix : function ( fixer ) { return fixer . insert Text After ( token , ' ' ) ; } } ) ; } 
function report Required Ending Space ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required before \ ' ' + token . value + ' \ ' ' , fix : function ( fixer ) { return fixer . insert Text Before ( token , ' ' ) ; } } ) ; } 
function generate Destination Lon Lat ( { lat , lon } ) { const lat Offset = ( get Distance ( ) / LAT _DEGREE ) * get Sign ( ) const lon Offset = ( get Distance ( ) / ( LAT _DEGREE * Math . cos ( lat ) ) ) * get Sign ( ) return { lat : lat + lat Offset , lon : lon + lon Offset } } 
function ( key Parts , hash ) { for ( var i = 0 ; i < key Parts . length - 1 ; + + i ) { hash = get Value ( key Parts [ i ] , hash ) ; if ( typeof ( hash ) = = = 'undefined ' ) { return undefined ; } } var last Key Part Index = key Parts . length - 1 ; return get Value ( key Parts [ last Key Part Index ] , hash ) } 
function git Authors ( cb ) { return exec ( 'git log - -pretty = " %an < %ae > " ' , function ( er , stdout , stderr ) { if ( er | | stderr ) throw new Error ( er | | stderr ) return cb ( null , stdout . split ( ' \n ' ) . reverse ( ) ) } ) } 
function lookup Github Login ( p , print , callback ) { var api URI = 'https : / /api .github .com /search /users ?q = ' var options = { json : true , headers : { 'user -agent ' : pkg . name + ' / ' + pkg . version } } if ( process . env . OAUTH _TOKEN ) { options . headers [ 'Authorization ' ] = 'token ' + process . env . OAUTH _TOKEN . trim ( ) } function cb ( err , p ) { callback ( err , p ) } if ( print ) process . stdout . write ( ' . ' ) request ( api URI + encode URIComponent ( p . email + ' in :email type :user ' ) , options , on Email ) function on Email ( err , data ) { rate Limit Exceeded = rate Limit Exceeded | | data . body . message if ( ! err & & data . body . items & & data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } request ( api URI + encode URIComponent ( p . name + ' in :fullname type :user ' ) , options , on Name ) } function on Name ( err , data ) { rate Limit Exceeded = rate Limit Exceeded | | data . body . message if ( ! err & & data . body . items & & data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } cb ( err , p ) } } 
function _unpack Output ( message ) { if ( message . char At ( 0 ) ! = keyczar _util . VERSION _BYTE ) { throw new Error ( 'Unsupported version byte : ' + message . char Code At ( 0 ) ) ; } var keyhash = message . substr ( 1 , keyczar _util . KEYHASH _LENGTH ) ; message = message . substr ( 1 + keyczar _util . KEYHASH _LENGTH ) ; return { keyhash : keyhash , message : message } ; } 
function _rsa Hash ( public Key ) { var md = forge . md . sha 1 . create ( ) ; 
function _make Rsa Key ( rsa Key ) { var key = { keyhash : _rsa Hash ( rsa Key ) , size : rsa Key . n . bit Length ( ) } ; key . encrypt = function ( plaintext ) { 
function ( ) { if ( ! result ) { var exec = grunt . config . get ( 'exec ' ) ; for ( var key in exec ) { exec [ key ] . cmd = nvm Use + ' & & ' + exec [ key ] . cmd ; } grunt . config . set ( 'exec ' , exec ) ; } } 
function ( callback ) { var command = ' . ' + nvm Path ; child Process . exec ( command , cmd Opts , function ( err , stdout , stderr ) { if ( stderr . index Of ( 'No such file or directory ' ) ! = = - 1 ) { if ( nvm Path = = = home + ' / .nvm /nvm .sh ' ) { nvm Path = home + ' /nvm /nvm .sh ' ; nvm Init = ' . ' + nvm Path + ' & & ' ; check NVM ( callback ) ; } else { grunt [ options . error Level ] ( 'Expected node ' + expected + ' , but found v ' + actual + ' \n NVM does not appear to be installed . \n Please install (https : / /github .com /creationix /nvm #installation ) , or update the NVM path . ' ) ; } } else { callback ( ) ; } } ) ; } 
function ( packages ) { var this Package ; if ( packages . length ) { this Package = packages . pop ( ) ; var command = nvm Use + ' & & npm ls -g ' + this Package ; child Process . exec ( command , cmd Opts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } if ( stdout . index Of ( '    (empty ) ' ) ! = = 1 ) npm Install ( this Package , function ( ) { check Packages ( packages ) ; } ) ; } else { check Packages ( packages ) ; } } ) ; } else { done ( ) ; } } 
function ( this Package , callback ) { var command = nvm Use + ' & & npm install -g ' + this Package ; child Process . exec ( command , cmd Opts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } grunt . verbose . writeln ( stdout ) ; grunt . log . oklns ( 'Installed ' + this Package ) ; callback ( ) ; } ) ; } 
function ( ) { prompt . start ( ) ; var prop = { name : 'yesno ' , message : 'You do not have any node versions installed that satisfy this project \ 's requirements ( ' . white + expected . yellow + ' ) . Would you like to install the latest compatible version ? (y /n ) ' . white , validator : / y [es ] * |n [o ] ? / , required : true , warning : 'Must respond yes or no ' } ; prompt . get ( prop , function ( err , result ) { result = result . yesno . to Lower Case ( ) ; if ( result = = = 'yes ' | | result = = = 'y ' ) { nvm Install ( ) ; } else { grunt [ options . error Level ] ( 'Expected node v ' + expected + ' , but found ' + actual ) ; } } ) ; } 
function ( ) { nvm Ls ( 'remote ' , function ( ) { best Match = semver . max Satisfying ( remotes , expected ) ; nvm Use = nvm Init + 'nvm use ' + best Match ; var command = nvm Init + 'nvm install ' + best Match ; child Process . exec ( command , cmd Opts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } var node Version = stdout . split ( ' ' ) [ 3 ] ; grunt . log . ok ( 'Installed node v ' + best Match ) ; print Version ( node Version ) ; extend Exec ( ) ; check Packages ( options . globals ) ; } ) ; } ) ; } 
function ( loc , callback ) { var command = nvm Init + 'nvm ls ' ; if ( loc = = = 'remote ' ) { command + = ' -remote ' ; } child Process . exec ( command , cmd Opts , function ( err , stdout , stderr ) { var data = strip Color Codes ( stdout . to String ( ) ) . replace ( / \s + / g , ' | ' ) , available = data . split ( ' | ' ) ; for ( var i = 0 ; i < available . length ; i + + ) { 
function ( ) { 
function Each Subject ( subject , elements , element Name , opt _no Index ) { Proxy Base . call ( this ) ; this . element Subjects = [ ] ; for ( var i = 0 ; i < elements . length ; + + i ) { var es = subject Factory . new Subject ( subject . failure Strategy , elements [ i ] ) ; es . named ( element Name + ( opt _no Index ? ' ' : ( ' ' + i ) ) + ' of ' + subject . describe ( ) ) ; es . failure Message = subject . failure Message ; this . element Subjects . push ( es ) ; } } 
function Eventual Subject ( subject , promise ) { Deferred Subject . call ( this ) ; this . subject = subject ; var self = this ; this . promise = promise . then ( function ( value ) { 
function Promise Subject ( failure Strategy , value ) { Subject . call ( this , failure Strategy , value ) ; 
function first Diff ( exp , act ) { var i ; for ( i = 0 ; i < exp . length & & i < act . length ; + + i ) { if ( exp [ i ] ! = act [ i ] ) { break ; } } return i ; } 
function compare ( exp , act , opt _path , opt _deep , opt _results ) { var path = opt _path | | ' ' ; var i , j , str Exp , str Act ; if ( same Value ( exp , act ) ) { return true ; } var et = type ( exp ) ; var at = type ( act ) ; if ( et ! = = at | | et = = = 'number ' | | at = = = 'boolean ' | | et = = = 'undefined ' | | exp = = = null | | act = = = null ) { if ( opt _results ) { opt _results . push ( inequality ( exp , act , path ) ) ; } return false ; } else if ( et = = = 'object ' ) { 
function default Dest Rewriter ( path Obj : Object , inner Path : string , options : Object ) { let file Name = path Obj . base ; if ( options . file Suffix ) { file Name . replace ( options . file Suffix , ' .svg ' ) ; } else { file Name = file Name . replace ( ' .svg ' , ' .js ' ) ; } file Name = file Name . replace ( / ( ^ . ) | ( _ ) ( . ) / g , ( match , p 1 , p 2 , p 3 ) = > ( p 1 | | p 3 ) . to Upper Case ( ) ) ; return path . join ( inner Path , file Name ) ; } 
function get ( store , key , options ) { if ( key = = = ' ' | | key = = null ) { return store . _data ; } return do Get ( store , key , options ) ; } 
function do Get ( store , key , options = { } ) { 
function resolve References ( store , value , depth ) { if ( - - depth < 0 ) { return value ; } if ( Array . is Array ( value ) ) { const n = value . length ; const v = new Array ( n ) ; let item ; for ( let i = n - 1 ; i > = 0 ; i - - ) { item = value [ i ] ; v [ i ] = resolve References ( store , store . _is Ref Value ( item ) ? property . get ( store . _data , store . _parse Ref Key ( item ) ) : item , depth ) ; } value = v ; } else if ( is Plain Object ( value ) ) { const v = { } ; let item ; for ( const prop in value ) { item = value [ prop ] ; v [ prop ] = resolve References ( store , store . _is Ref Value ( item ) ? property . get ( store . _data , store . _parse Ref Key ( item ) ) : item , depth ) ; } value = v ; } return value ; } 
function format String ( value , options ) { var opts = options | | { } ; var result = value . replace ( / [ \ 0 - \ 3 7 ] / g , function ( ch ) { switch ( ch ) { case ' \n ' : return ' \ \n ' ; case ' \r ' : return ' \ \r ' ; case ' \t ' : return ' \ \t ' ; case ' \b ' : return ' \ \b ' ; case ' \v ' : return ' \ \v ' ; case ' \f ' : return ' \ \f ' ; default : return ' \ \ ' + ch . char Code At ( 0 ) . to String ( 8 ) ; } } ) ; if ( opts . clip & & result . length > opts . clip ) { result = result . slice ( 0 , Math . max ( 0 , opts . clip - 3 ) ) + ' . . . ' ; } return ' " ' + result + ' " ' ; } 
function base ( ) { const args = [ config . path _base ] . concat ( [ ] . slice . call ( arguments ) ) ; return path . resolve . apply ( path , args ) ; } 
function Key Value ( subject , key ) { this . subject = subject ; this . key = key ; this . format = subject . format ; this . value = subject . value . get ( key ) ; } 
function format Object ( value , options ) { if ( value = = = undefined ) { return 'undefined ' ; } if ( value = = = null ) { return 'null ' ; } if ( typeof ( value ) = = 'object ' ) { if ( value instanceof Reg Exp | | value instanceof Date ) { return value + ' ' ; } var opts = options | | { } ; var inner Opts = Object . assign ( { } , opts , { clip : false } ) ; 
function _export Public Key ( key ) { var t = key . metadata . type ; var p = key . metadata . purpose ; if ( ! ( t = = keyczar . TYPE _RSA _PRIVATE & & ( p = = keyczar . PURPOSE _DECRYPT _ENCRYPT | | p = = keyczar . PURPOSE _SIGN _VERIFY ) ) ) { throw new Error ( 'Unsupported key type /purpose : ' + t + ' / ' + p ) ; } var public Purpose = keyczar . PURPOSE _ENCRYPT ; if ( p = = keyczar . PURPOSE _SIGN _VERIFY ) { public Purpose = keyczar . PURPOSE _VERIFY ; } var metadata = { name : key . metadata . name , purpose : public Purpose , type : keyczar . TYPE _RSA _PUBLIC , encrypted : false , 
function _get Primary Version ( metadata ) { var primary Version = null ; for ( var i = 0 ; i < metadata . versions . length ; i + + ) { if ( metadata . versions [ i ] . status = = STATUS _PRIMARY ) { if ( primary Version ! = = null ) { throw new Error ( 'Invalid key : multiple primary keys ' ) ; } primary Version = metadata . versions [ i ] . version Number ; } } if ( primary Version = = = null ) { throw new Error ( 'No primary key ' ) ; } return primary Version ; } 
function _make Keyczar ( data , password ) { var instance = { } ; instance . metadata = JSON . parse ( data . meta ) ; if ( instance . metadata . encrypted ! = = false ) { if ( ! password ) { throw new Error ( 'Key is encrypted ; you must provide the password ' ) ; } if ( password . length = = = 0 ) { throw new Error ( 'Must supply a password length > 0 ' ) ; } } else if ( password ) { throw new Error ( 'Key is not encrypted but password provided ' ) ; } var primary Version = _get Primary Version ( instance . metadata ) ; var primary Key String = data [ String ( primary Version ) ] ; if ( instance . metadata . encrypted ) { primary Key String = _decrypt Key ( primary Key String , password ) ; } var t = instance . metadata . type ; var p = instance . metadata . purpose ; if ( t = = keyczar . TYPE _RSA _PRIVATE ) { instance . primary = keyczar _util . private Key From Keyczar ( primary Key String ) ; instance . export Public Key = function ( ) { return _export Public Key ( instance ) ; } ; } else if ( t = = keyczar . TYPE _RSA _PUBLIC ) { instance . primary = keyczar _util . public Key From Keyczar ( primary Key String ) ; } else if ( t = = keyczar . TYPE _AES & & p = = keyczar . PURPOSE _DECRYPT _ENCRYPT ) { instance . primary = keyczar _util . aes From Keyczar ( primary Key String ) ; } else { throw new Error ( 'Unsupported key type : ' + t ) ; } if ( p = = keyczar . PURPOSE _ENCRYPT | | p = = keyczar . PURPOSE _DECRYPT _ENCRYPT ) { 
function kebab Dest Rewriter ( path Obj : Object , inner Path : string , options : Object ) { let file Name = path Obj . base ; if ( options . file Suffix ) { file Name . replace ( options . file Suffix , ' .svg ' ) ; } else { file Name = file Name . replace ( ' .svg ' , ' .js ' ) ; } file Name = file Name . replace ( / _ / g , ' - ' ) ; return path . join ( inner Path , file Name ) ; } 
function set ( store , key , value , options ) { return do Set ( store , key , value , Object . assign ( { } , DEFAULT _OPTIONS , options ) ) ; } 
function do Set ( store , key , value , options ) { if ( ! key | | typeof key ! = = 'string ' ) { return false ; } 
function format Map ( value , options ) { return 'Map ( ' + registry . format ( Array . from ( value . entries ( ) ) , options ) + ' ) ' ; } 
function fetch ( store , key , url , options ) { options = Object . assign ( { } , DEFAULT _LOAD _OPTIONS , options ) ; options . cache Control = parse Cache Control ( options . cache Control ) ; if ( ! key ) { return Promise . resolve ( { body : undefined , duration : 0 , headers : { } , key , status : 4 0 0 } ) ; } return do Fetch ( store , key , url , options ) ; } 
function do Fetch ( store , key , url , options ) { const { cache Control , reject On Error } = options ; const value = get ( store , key ) ; const is Missing = ! value ; let is Expired = has Expired ( value & & value [ store . EXPIRY _KEY ] , false ) ; store . debug ( 'fetch %s from %s ' , key , url ) ; 
function load ( store , key , url , options ) { const { cache Control , reject On Error , retry , timeout } = options ; options . id = key ; store . debug ( 'load %s from %s ' , key , url ) ; return agent . get ( url , options ) . timeout ( timeout ) . retry ( retry ) . then ( res = > { 
function parse Cache Control ( cache Control String ) { let max Age = 0 ; let stale If Error = 0 ; if ( cache Control String & & typeof cache Control String = = = 'string ' ) { let match ; while ( ( match = RE _CACHE _CONTROL . exec ( cache Control String ) ) ) { if ( match [ 1 ] ) { max Age = parse Int ( match [ 1 ] , 1 0 ) * 1 0 0 0 ; } else if ( match [ 2 ] ) { stale If Error = parse Int ( match [ 2 ] , 1 0 ) * 1 0 0 0 ; } } } return { max Age , stale If Error } ; } 
function merge Cache Control ( cache Control , default Cache Control ) { if ( cache Control = = null ) { return Object . assign ( { } , default Cache Control ) ; } return { max Age : 'max Age ' in cache Control ? cache Control . max Age : default Cache Control . max Age , stale If Error : 'stale If Error ' in cache Control ? cache Control . stale If Error : default Cache Control . stale If Error } ; } 
function generate Expiry ( headers = { } , default Cache Control ) { const cache Control = merge Cache Control ( parse Cache Control ( headers [ 'cache -control ' ] ) , default Cache Control ) ; const now = Date . now ( ) ; let expires = now ; if ( headers . expires ) { expires = typeof headers . expires = = = 'string ' ? Number ( new Date ( headers . expires ) ) : headers . expires ; } if ( now > = expires ) { expires = now + cache Control . max Age ; } return { expires , expires If Error : expires + cache Control . stale If Error } ; } 
function generate Response Headers ( expiry = { } , default Cache Control , is Error ) { const now = Date . now ( ) ; let max Age ; if ( is Error ) { max Age = expiry & & expiry . expires If Error > now & & expiry . expires If Error - now < default Cache Control . max Age ? Math . ceil ( ( expiry . expires If Error - now ) / 1 0 0 0 ) : default Cache Control . max Age / 1 0 0 0 ; } else { 
function has Expired ( expiry , is Error ) { if ( ! expiry ) { return true ; } 
function format Set ( value , options ) { return 'Set ( ' + registry . format ( Array . from ( value . values ( ) ) , options ) + ' ) ' ; } 
function format Array ( value , options ) { var opts = options | | { } ; var inner Opts = Object . assign ( { } , opts , { clip : false } ) ; var parts = [ ' [ ' ] ; var length = 2 ; 
function _init ( client , uri , options ) { Promise . init . call ( this ) this . client = client this . uri = uri this . options = options return this } 
function _timeout ( delay ) { this . clear Timer ( ) this . timer = set Timeout ( function ( ) { this . flush ( 'timeouted ' , 'failed ' ) . fail ( 'timeouted ' ) this . forget ( ) } . bind ( this ) , delay * 1 0 0 0 ) return this } 
function request ( uri , options ) { var client , promise , method , serialise _body _p , mime options = options | | { } options . headers = options . headers | | { } method = ( options . method | | 'GET ' ) . to Upper Case ( ) uri = build _uri ( uri , options . query , options . body ) options . headers [ 'X -Requested -With ' ] = 'XMLHttp Request ' serialise _body _p = object _p ( options . body ) if ( serialise _body _p ) { mime = options . headers [ 'Content -Type ' ] | | 'application /x -www -form -urlencoded ' options . body = serialise _for _type ( mime , options . body ) options . headers [ 'Content -Type ' ] = mime } client = make _xhr ( ) promise = Promise P . make ( client , uri , options ) setup _listeners ( ) set Timeout ( function ( ) { client . open ( method , uri , true , options . username , options . password ) setup _headers ( options . headers | | { } ) client . send ( options . body ) } ) active . push ( promise ) return promise 
function build _uri ( uri , query , body ) { uri = build _query _string ( uri , query ) return method = = 'GET ' ? build _query _string ( uri , body ) : uri } 
function setup _headers ( headers ) { keys ( headers ) . for Each ( function ( key ) { client . set Request Header ( key , headers [ key ] ) } ) } 
function setup _listeners ( ) { client . onerror = make _error _handler ( 'errored ' ) client . onabort = make _error _handler ( 'forgotten ' ) client . ontimeout = make _error _handler ( 'timeouted ' ) client . onloadstart = function ( ev ) { promise . fire ( 'load :start ' , ev ) } client . onprogress = function ( ev ) { promise . fire ( 'load :progress ' , ev ) } client . onloadend = function ( ev ) { promise . fire ( 'load :end ' , ev ) } client . onload = function ( ev ) { promise . fire ( 'load :success ' , ev ) } client . onreadystatechange = function ( ) { var response , status , state state = client . ready State promise . fire ( 'state : ' + state _map [ state ] ) if ( state = = 4 ) { var binding _state = success . test ( status ) ? 'ok ' : error . test ( status ) ? 'failed ' : 'any ' response = client . response Text status = normalise _status ( client . status ) active . splice ( active . index Of ( promise ) , 1 ) promise . flush ( 'status : ' + status ) . flush ( 'status : ' + status _type ( status ) ) status = = 0 ? raise ( 'errored ' ) : success . test ( status ) ? promise . bind ( response , status ) : error . test ( status ) ? promise . fail ( response , status ) : promise . done ( [ response , status ] ) } } } 
function request _with _method ( method ) { return function ( uri , options ) { options = options | | { } options . method = method . to Upper Case ( ) return request ( uri , options ) } } 
function is Link Working ( link , options ) { options = Object . assign ( { check Connectivity : false , follow Redirect : true , timeout : 1 5 0 0 0 , retries : 3 , agent : null , } , options ) ; const got Options = { timeout : options . timeout , follow Redirect : options . follow Redirect , retries : options . retries , agent : options . agent , headers : { 'user -agent ' : ` $ { pkg . version } ` , } , } ; return try Head ( link , got Options ) . catch ( ( ) = > try Get ( link , options , got Options ) ) ; } 
function Field Value ( subject , name , value ) { this . subject = subject ; this . name = name ; this . value = subject . value [ name ] ; this . format = subject . format ; } 
function Sapi ( key , opts ) { opts = opts | | { } ; function _auth Require ( result , cb ) { 
function Leak Error ( opts , src , file ) { Error . call ( this ) ; this . message = 'global leak detected : ' + opts . variable ; this . line = opts . line - 1 ; this . column = opts . column ; this . annotated = ' \n ' + ( file | | ' (anonymous file ) ' ) + ' : ' + this . line + ' \n ' + src . split ( ' \n ' ) [ this . line ] + ' \n ' + Array ( this . column + 1 ) . join ( ' ' ) + ' ^ ' + ' \n ' + 'Leak Error : ' + this . message ; } 
function Strategy ( options , verify ) { options = options | | { } ; this . server URL = options . server URL | | 'https : / /account .lab .fiware .org ' ; this . is Legacy = options . is Legacy = = = true ? options . is Legacy : false ; if ( this . server URL . ends With ( ' / ' ) ) { this . server URL = this . server URL . slice ( 0 , - 1 ) ; } options . authorization URL = this . server URL + ' /oauth 2 /authorize ' ; options . token URL = this . server URL + ' /oauth 2 /token ' ; 
function reset ( store , data ) { store . debug ( 'reset ' ) ; store . _data = data ; store . changed = true ; } 
function serialise ( key , data , config ) { if ( is Plain Object ( data ) ) { const obj = { } ; for ( const prop in data ) { const key Chain = key ? ` $ { key } $ { prop } ` : prop ; const value = data [ prop ] ; if ( config [ key Chain ] ! = = false ) { if ( is Plain Object ( value ) ) { obj [ prop ] = serialise ( key Chain , value , config ) ; } else if ( value ! = null & & typeof value = = = 'object ' & & 'to JSON ' in value ) { obj [ prop ] = value . to JSON ( ) ; } else { obj [ prop ] = value ; } } } return obj ; } return config [ key ] ! = = false ? data : null ; } 
function explode ( store , data ) { if ( is Plain Object ( data ) ) { const obj = { } ; for ( const prop in data ) { obj [ prop ] = explode ( store , data [ prop ] ) ; } return obj ; } else if ( Array . is Array ( data ) ) { return data . map ( value = > explode ( store , value ) ) ; } else if ( store . _is Ref Value ( data ) ) { return explode ( store , store . get ( store . _parse Ref Key ( data ) ) ) ; } return data ; } 
function serialise ( data ) { return keys ( data | | { } ) . map ( encode _pair ) . filter ( Boolean ) . join ( ' & ' ) function encode _pair ( key ) { return data [ key ] ! = null ? encode ( key ) + ' = ' + encode ( data [ key ] ) : null } } 
function Subject ( failure Strategy , value ) { this . failure Strategy = failure Strategy ; this . value = value ; this . name = null ; this . format = format ; this . failure Message = null ; } 
function ( json ) { 
function fs Generator ( configs ) { var deferred = Q . defer ( ) ; var dir Name = " " ; var dest Dir = " " ; var tmp Dir = " " ; var ref Src Dir = " " ; var dest Folder Dir = " " ; var dir Type = " " ; var temp Folder Name = " " ; var content Replace Regx = new Reg Exp ( " " , 'g ' ) ; var replace Content Length = 0 ; var ignore Extentions = [ ] ; var ignore Folders = [ ] ; var init = function ( ) { for ( var fls in configs ) { dir Name = utils . folder Name ( configs [ fls ] [ 'input ' ] , configs [ fls ] [ 'folder Name ' ] ) ; dir Type = configs [ fls ] [ 'type ' ] ; dest Folder Dir = path . join ( configs [ fls ] [ 'destination Source Path ' ] , dir Name ) ; dest Dir = configs [ fls ] [ 'destination Source Path ' ] ; tmp Dir = configs [ fls ] [ 'temp Folder Path ' ] ; temp Folder Name = utils . get Base Folder Name ( tmp Dir ) ; ref Src Dir = configs [ fls ] [ 'refrence Source Path ' ] ; ignore Extentions = configs [ fls ] [ 'ignore Exts ' ] | | [ ] ; ignore Folders = configs [ fls ] [ 'ignore Folders ' ] | | [ ] ; content Replace Regx = new Reg Exp ( utils . regx Content ( configs [ fls ] [ 'replace Content ' ] ) , 'g ' ) ; if ( configs [ fls ] [ 'replace Content ' ] ) { replace Content Length = Object . keys ( configs [ fls ] [ 'replace Content ' ] ) . length ; } console . log ( ' : : : ~ ~ ' + fls + ' : : : ~ ~ ' ) ; folder Sync ( configs [ fls ] ) ; } } ; var folder Sync = function ( fls ) { if ( fs . exists Sync ( dest Folder Dir ) ) { console . log ( ' : : : ~ ~ ' + dir Name + ' exists , please pick another name or delete previous to create new ~ ~ : : : ' ) deferred . reject ( fls . type + ' exists , please pick another name . ' ) ; } else { console . log ( ' : : : ~ ~ ' + dir Name + ' does not exists , creating new ~ ~ : : : ' ) ; if ( ! fs . exists Sync ( dest Folder Dir ) ) { fse . ensure Dir Sync ( dest Folder Dir ) ; console . log ( ' : : : ~ ~Created new directory : ' + fls . type + " / " + dir Name + ' ~ ~ : : : ' ) ; } * Copy refrence directory in temporary directory * / var copy Ref To Temp = function ( ) { fse . empty Dir Sync ( tmp Dir ) ; fse . copy Sync ( ref Src Dir , tmp Dir , { overwrite : true } , err = > { if ( err ) { console . log ( ' : : : ~ ~error in copying to temp directory : ' + err + ' ~ ~ : : : ' ) ; fse . remove Sync ( dest Folder Dir ) ; fse . empty Dir Sync ( tmp Dir ) ; deferred . reject ( 'Error in copying to temp directory ' ) ; } console . log ( ' : : : ~ ~ temp directory created ~ ~ : : : ' ) ; } ) ; } ; var update Temp Sub Dir Names = function ( fls ) { fs . readdir Sync ( tmp Dir ) . map ( function ( dir ) { var temp Folder Path = path . join ( tmp Dir , dir ) ; if ( fs . stat Sync ( temp Folder Path ) . is Directory ( ) ) { * Process nested folders in temp directory recently copied * @param { * } temp Folder Path * / var nested Directory = function ( temp Folder Path , fls ) { fs . readdir Sync ( temp Folder Path ) . map ( function ( dir ) { var new Temp Folder Path = path . join ( temp Folder Path , dir ) ; if ( fs . stat Sync ( new Temp Folder Path ) . is Directory ( ) ) { nested Directory ( new Temp Folder Path , fls ) ; } else { process Temp Folder ( new Temp Folder Path , fls ) ; } } ) ; } var process Temp Folder = function ( old Path , fls ) { console . log ( " : : : ~ ~processing your temp folder and file ~ ~ : : : " + old Path ) ; var parsed Path = update File Name Path ( path . parse ( old Path ) , fls ) ; var new Path = path . format ( parsed Path ) ; var first Folder Name = utils . get First Folder Name ( old Path , temp Folder Name ) ; fs . rename Sync ( old Path , new Path ) ; if ( replace Content Length > 0 & & ignore Extentions . index Of ( parsed Path . ext ) < 0 & & ignore Folders . index Of ( first Folder Name ) < 0 ) { console . log ( " : : : ~ ~writing your temp file ~ ~ : : : " + new Path ) ; var old Content = fs . read File Sync ( new Path , 'utf 8 ' ) ; var new Content = update File Content ( old Content , fls . replace Content , fls ) ; fs . write File Sync ( new Path , new Content ) ; } else { console . log ( " : : : ~ ~skipping writing of your temp file ~ ~ : : : " + new Path ) ; } } var update File Name Path = function ( parsed Path , fls ) { * get array of folders from base temp path * @param { * } parsed Path * / var get Nested Folder Name = function ( parsed Path ) { var temp Path Array = tmp Dir . split ( " \ \ " ) ; var parsed Path Array = parsed Path . dir . split ( " \ \ " ) ; if ( parse Int ( temp Path Array . length ) = = = parse Int ( parsed Path Array . length ) ) { return "base " ; } else if ( parse Int ( temp Path Array . length ) < parse Int ( parsed Path Array . length ) ) { var folder Name Array = [ ] ; for ( var i in parsed Path Array ) { if ( i > parse Int ( temp Path Array . length ) - 1 ) { folder Name Array . push ( parsed Path Array [ i ] ) ; } } return folder Name Array ; } } var update File Content = function ( old Content , replace Config , fls ) { var new Content = old Content . replace ( content Replace Regx , function ( e ) { for ( var cont in replace Config ) { var cont Regex = new Reg Exp ( cont , 'g ' ) ; if ( e . match ( cont Regex ) ) { var replace Value = utils . get Replacable Content ( fls . input , replace Config [ cont ] ) ; return replace Value ; } } } ) ; return new Content ; } ; var copy Temp To Dest = function ( ) { fse . empty Dir Sync ( dest Folder Dir ) ; fse . copy Sync ( tmp Dir , dest Folder Dir , { overwrite : true } , err = > { if ( err ) { console . log ( ' : : : ~ ~error in copying to destination directory : ' + err + ' ~ ~ : : : ' ) ; fse . remove Sync ( dest Folder Dir ) ; fse . empty Dir Sync ( tmp Dir ) ; deferred . reject ( 'Error in copying to destination directory ' ) ; } console . log ( ' : : : ~ ~ destination directory created : ' + dir Name + ' ~ ~ : : : ' ) ; } ) ; fse . empty Dir Sync ( tmp Dir ) ; console . log ( ' : : : ~ ~Created new ' + dir Type + " / " + dir Name + ' : : : ~ ~ ' ) ; } ; init ( configs ) ; } 
function ( ) { for ( var fls in configs ) { dir Name = utils . folder Name ( configs [ fls ] [ 'input ' ] , configs [ fls ] [ 'folder Name ' ] ) ; dir Type = configs [ fls ] [ 'type ' ] ; dest Folder Dir = path . join ( configs [ fls ] [ 'destination Source Path ' ] , dir Name ) ; dest Dir = configs [ fls ] [ 'destination Source Path ' ] ; tmp Dir = configs [ fls ] [ 'temp Folder Path ' ] ; temp Folder Name = utils . get Base Folder Name ( tmp Dir ) ; ref Src Dir = configs [ fls ] [ 'refrence Source Path ' ] ; ignore Extentions = configs [ fls ] [ 'ignore Exts ' ] | | [ ] ; ignore Folders = configs [ fls ] [ 'ignore Folders ' ] | | [ ] ; content Replace Regx = new Reg Exp ( utils . regx Content ( configs [ fls ] [ 'replace Content ' ] ) , 'g ' ) ; if ( configs [ fls ] [ 'replace Content ' ] ) { replace Content Length = Object . keys ( configs [ fls ] [ 'replace Content ' ] ) . length ; } console . log ( ' : : : ~ ~ ' + fls + ' : : : ~ ~ ' ) ; folder Sync ( configs [ fls ] ) ; } } 
function ( fls ) { if ( fs . exists Sync ( dest Folder Dir ) ) { console . log ( ' : : : ~ ~ ' + dir Name + ' exists , please pick another name or delete previous to create new ~ ~ : : : ' ) deferred . reject ( fls . type + ' exists , please pick another name . ' ) ; } else { console . log ( ' : : : ~ ~ ' + dir Name + ' does not exists , creating new ~ ~ : : : ' ) ; if ( ! fs . exists Sync ( dest Folder Dir ) ) { fse . ensure Dir Sync ( dest Folder Dir ) ; console . log ( ' : : : ~ ~Created new directory : ' + fls . type + " / " + dir Name + ' ~ ~ : : : ' ) ; } 
function ( ) { fse . empty Dir Sync ( tmp Dir ) ; fse . copy Sync ( ref Src Dir , tmp Dir , { overwrite : true } , err = > { if ( err ) { console . log ( ' : : : ~ ~error in copying to temp directory : ' + err + ' ~ ~ : : : ' ) ; fse . remove Sync ( dest Folder Dir ) ; fse . empty Dir Sync ( tmp Dir ) ; deferred . reject ( 'Error in copying to temp directory ' ) ; } console . log ( ' : : : ~ ~ temp directory created ~ ~ : : : ' ) ; } ) ; } 
function ( old Path , fls ) { console . log ( " : : : ~ ~processing your temp folder and file ~ ~ : : : " + old Path ) ; var parsed Path = update File Name Path ( path . parse ( old Path ) , fls ) ; var new Path = path . format ( parsed Path ) ; var first Folder Name = utils . get First Folder Name ( old Path , temp Folder Name ) ; fs . rename Sync ( old Path , new Path ) ; if ( replace Content Length > 0 & & ignore Extentions . index Of ( parsed Path . ext ) < 0 & & ignore Folders . index Of ( first Folder Name ) < 0 ) { console . log ( " : : : ~ ~writing your temp file ~ ~ : : : " + new Path ) ; var old Content = fs . read File Sync ( new Path , 'utf 8 ' ) ; var new Content = update File Content ( old Content , fls . replace Content , fls ) ; fs . write File Sync ( new Path , new Content ) ; } else { console . log ( " : : : ~ ~skipping writing of your temp file ~ ~ : : : " + new Path ) ; } } 
function ( parsed Path , fls ) { 
function ( parsed Path ) { var temp Path Array = tmp Dir . split ( " \ \ " ) ; var parsed Path Array = parsed Path . dir . split ( " \ \ " ) ; if ( parse Int ( temp Path Array . length ) = = = parse Int ( parsed Path Array . length ) ) { return "base " ; } else if ( parse Int ( temp Path Array . length ) < parse Int ( parsed Path Array . length ) ) { var folder Name Array = [ ] ; for ( var i in parsed Path Array ) { if ( i > parse Int ( temp Path Array . length ) - 1 ) { folder Name Array . push ( parsed Path Array [ i ] ) ; } } return folder Name Array ; } } 
function ( old Content , replace Config , fls ) { var new Content = old Content . replace ( content Replace Regx , function ( e ) { for ( var cont in replace Config ) { var cont Regex = new Reg Exp ( cont , 'g ' ) ; if ( e . match ( cont Regex ) ) { var replace Value = utils . get Replacable Content ( fls . input , replace Config [ cont ] ) ; return replace Value ; } } } ) ; return new Content ; } 
function ( ) { fse . empty Dir Sync ( dest Folder Dir ) ; fse . copy Sync ( tmp Dir , dest Folder Dir , { overwrite : true } , err = > { if ( err ) { console . log ( ' : : : ~ ~error in copying to destination directory : ' + err + ' ~ ~ : : : ' ) ; fse . remove Sync ( dest Folder Dir ) ; fse . empty Dir Sync ( tmp Dir ) ; deferred . reject ( 'Error in copying to destination directory ' ) ; } console . log ( ' : : : ~ ~ destination directory created : ' + dir Name + ' ~ ~ : : : ' ) ; } ) ; fse . empty Dir Sync ( tmp Dir ) ; console . log ( ' : : : ~ ~Created new ' + dir Type + " / " + dir Name + ' : : : ~ ~ ' ) ; } 
function scan ( text ) { let sr = SReader . create ( text ) ; let tokens = [ ] ; while ( ! sr . is Done ( ) ) { tokens . push ( read Next ( sr ) ) ; } return tokens ; } 
function read Next ( sr ) { if ( sr . accept ( " < ! " ) ) { return read Comment ( sr ) ; } if ( sr . accept ( " < " ) ) { return read Tag ( sr ) ; } return read Text ( sr ) ; } 
function read Text ( sr ) { let start = sr . get Pos ( ) ; let value = sr . expect RE ( RE _TEXT ) ; return { type : "text " , start , value } ; } 
function read Comment ( sr ) { let start = sr . get Pos ( ) - 2 ; sr . expect ( " - - " ) ; if ( ! sr . goto ( " - - > " ) ) { throw Tools . syntax Error ( "Unterminated comment " , start ) ; } sr . expect ( " - - > " ) ; return { type : "comment " , start } ; } 
function read Tag ( sr ) { let start = sr . get Pos ( ) - 1 ; let name ; if ( sr . accept ( " / " ) ) { name = sr . expect RE ( RE _TAG _NAME ) ; sr . expect ( " > " ) ; return { type : "tag _ 2 " , start , name } ; } name = sr . expect RE ( RE _TAG _NAME ) ; let props = { } ; while ( true ) { sr . accept RE ( RE _WS ) ; if ( sr . accept ( " > " ) ) { return { type : "tag _ 1 " , start , name , props } ; } if ( sr . accept ( " / " ) ) { sr . expect ( " > " ) ; return { type : "tag _ 0 " , start , name , props } ; } let p Name = sr . expect RE ( RE _PROP _NAME ) ; sr . accept RE ( RE _WS ) ; sr . expect ( " = " ) ; sr . accept RE ( RE _WS ) ; sr . expect ( ' " ' ) ; let p Value = sr . expect RE ( RE _PROP _VALUE ) ; sr . expect ( ' " ' ) ; props [ p Name ] = p Value ; } } 
function Keystone Client ( url , options ) { options = options | | { } ; if ( options . username ) { if ( ! options . password & & ! options . api Key ) { throw new Error ( 'If username is provided you also need to provide password or api Key ' ) ; } } this . _url = url ; this . _username = options . username ; this . _api Key = options . api Key ; this . _password = options . password ; this . _extra Args = options . extra Args | | { } ; this . _cache Token For = options . cache Token For | | DEFAULT _CACHE _TOKEN _FOR ; this . _token = null ; this . _token Expires = null ; this . _refresh Token Completions = [ ] ; this . _token Updated = 0 ; this . _tenant Id = null ; this . _service Catalog = [ ] ; } 
function pack Node ( node ) { if ( node . type = = = " # " ) { return node . text ; } let item = [ node . type ] ; let has Props = ( Object . keys ( node . props ) . length ! = = 0 ) ; if ( has Props ) { item . push ( node . props ) ; } if ( node . children . length = = = 0 ) { return item ; } if ( ! has Props ) { item . push ( 0 ) ; } node . children . for Each ( child = > item . push ( pack Node ( child ) ) ) ; return item ; } 
function unpack Node ( item ) { if ( ! Array . is Array ( item ) ) { return { type : " # " , text : item } ; } let node = { type : item [ 0 ] , props : item [ 1 ] | | { } , children : [ ] } ; for ( let i = 2 ; i < item . length ; i + + ) { node . children . push ( unpack Node ( item [ i ] ) ) ; } return node ; } 
function find All Parents ( p ) { var last Parent = p [ 0 ] ; var last Parents Parent = parents [ last Parent ] ; if ( last Parents Parent = = = undefined ) { return p ; } else { p . unshift ( last Parents Parent ) ; return find All Parents ( p ) ; } } 
function find Direct Children ( class Name ) { var children = [ ] ; for ( var longname in parents ) { if ( parents [ longname ] = = = class Name ) { children . push ( longname ) ; } } return children ; } 
function make Hierarchy List ( classes ) { if ( classes . length = = = 0 ) { return ' ' ; } else { var class Name = classes . shift ( ) ; return ' <ul > <li > ' + link To ( class Name ) + ' ' + make Hierarchy List ( classes ) + ' < /li > < /ul > ' } } 
function make Children List ( classes ) { var list = ' <ul > ' ; classes . for Each ( function ( class Name ) { list + = ' <li > ' + link To ( class Name ) + ' < /li > ' ; } ) list + = ' < /ul > ' ; return list ; } 
function ( e ) { var doclet = e . doclet ; if ( doclet . kind = = = 'class ' & & doclet . augments ! = = undefined & & doclet . augments . length > 0 ) { parents [ doclet . longname ] = doclet . augments [ 0 ] ; } } 
function transform ( opts ) { var contents = opts . contents ; var index = opts . index ; var $ = cheerio . load ( contents ) ; $ ( 'link [href ] ' ) . each ( function ( ) { var el $ = $ ( this ) ; var href = el $ . attr ( 'href ' ) ; var new Href = index . resolve Local Url ( href ) ; if ( href & & href ! = = new Href ) { el $ . attr ( { 'data -appcache -href ' : href , href : new Href } ) ; } } ) ; return $ . html ( ) ; } 
function ( json ) { 
function got Option ( option ) { if ( map [ option ] ) { option = map [ option ] var name = option [ 0 ] 
function ( json ) { 
function Writer ( options ) { this . options = _ . defaults ( options | | { } , { template : ' ' , data : _ . identity } ) ; Writable . call ( this , { object Mode : true } ) ; this . _commits = [ ] ; } 
function ( json ) { 
function parse _issues ( body ) { var issues = null ; var content = body . match ( / \s + ( ? :issues |closes ) ( ? : , ? \s # ( [ ^ , \n ] + ) ) + / i ) ; if ( content ) { issues = content [ 0 ] . match ( / # ( [ ^ , \n \s ] + ) / g ) . map ( function ( issue ) { return issue . slice ( 1 ) ; } ) ; } return issues ; } 
function ( json ) { 
function get All Paths And Optionally Slice ( paths , state , slice = Immutable . List ( ) ) { let got Paths = Immutable . List ( ) ; got Paths = got Paths . with Mutations ( ( mutable ) = > { paths . for Each ( ( gen ) = > { if ( state . has In ( gen ) ) { let got = state . get In ( gen ) ; if ( Immutable . List . is List ( got ) ) { if ( slice . size > 0 ) { mutable . push ( . . . got . slice ( . . . slice ) ) } else { mutable . push ( . . . got ) } } else { mutable . push ( got ) ; } } } ) } ) ; return got Paths ; } 
function ( json ) { 
function ( json ) { 
function execute ( template , data ) { let result = [ ] ; template . for Each ( node = > execute Node ( node , data , result ) ) ; return result ; } 
function execute Node ( node , data , result ) { if ( node . type = = = " # " ) { execute Text ( node , data , result ) ; return ; } if ( node . props . each ) { execute Each ( node , data , result ) ; return ; } if ( node . props . if ) { execute If ( node , data , result ) ; return ; } if ( node . props . fi ) { execute Fi ( node , data , result ) ; return ; } let props = { } ; Object . keys ( node . props ) . for Each ( key = > { if ( key ! = = "each " & & key ! = = "if " & & key ! = = "fi " ) { props [ key ] = Extender . process Prop ( node . props [ key ] , data ) ; } } ) ; let children = [ ] ; node . children . for Each ( child = > execute Node ( child , data , children ) ) ; result . push ( { type : node . type , props , children } ) ; } 
function execute Text ( node , data , result ) { result . push ( { type : " # " , text : Extender . process Text ( node . text , data ) } ) ; } 
function execute Each ( node , data , result ) { let each = Extender . process Each ( node . props . each , data ) ; if ( ! each ) { return ; } let next Node = { type : node . type , props : Object . assign ( { } , node . props ) , children : node . children } ; next Node . props . each = null ; let next Data = Object . assign ( { } , data ) ; each . items . for Each ( item = > { next Data [ each . item ] = item ; execute Node ( next Node , next Data , result ) ; } ) ; } 
function execute Fi ( node , data , result ) { if ( Extender . process Expr ( node . props . fi , data ) ) { return ; } let next Node = { type : node . type , props : Object . assign ( { } , node . props ) , children : node . children } ; next Node . props . fi = null ; execute Node ( next Node , data , result ) ; } 
function Graceful Express ( options ) { options = options | | { } ; this . server = null ; this . graceful = null ; var start File = process . main Module . filename ; this . _set Option ( 'in Process Test ' , options , / mocha $ / . test ( start File ) ) ; this . reaper Poll Interval = options . reaper Poll Interval | | 5 0 0 ; util . verify Type ( 'number ' , this , 'reaper Poll Interval ' ) ; this . shutting Down = false ; this . _server Closed = false ; this . _responses = [ ] ; this . _sockets = [ ] ; this . _active Sockets = [ ] ; 
function ( json ) { 
function invoke Callback ( cb , invoke Method , value Or Reason , promise , type ) { var cb Value , cb Error , error Thrown ; try { cb Value = cb [ invoke Method ] ( null , value Or Reason ) ; } catch ( err ) { error Thrown = true , cb Error = err ; } 
function ( key ) { var tmp = window . document . cookie . match ( ( new Reg Exp ( key + ' = [ ^ ; ] + ( $ | ; ) ' , 'gi ' ) ) ) ; if ( ! tmp | | ! tmp [ 0 ] ) { return null ; } else { return window . unescape ( tmp [ 0 ] . substring ( key . length + 1 , tmp [ 0 ] . length ) . replace ( ' ; ' , ' ' ) ) | | null ; } } 
function ( key , value , options ) { var cookie = [ key + ' = ' + window . escape ( value ) ] , seconds , minutes , days , months , years , expiry Date , add Days ; 
function ( name , info ) { if ( trigger Plugin Errors ) { 
function ( core Args ) { var obj = { } , i ; 
function ( name , func , plugin Name ) { if ( plugin Name ! = = undefined ) { current Plugin Name = plugin Name ; } var event Current Plugin Name = current Plugin Name , 
function ( eve ) { cap Eve = eve . type . substring ( 0 , 1 ) . to Upper Case ( ) + eve . type . substring ( 1 ) ; core Obj [ 'on ' + cap Eve ] = make Event ( eve . type ) ; pubsub . add Event Type ( eve ) ; } 
function ( name ) { var i ; for ( i = 0 ; i < plugins . length ; i + = 1 ) { if ( plugins [ i ] . name = = = name ) { return plugins [ i ] ; } } return false ; } 
function ( name , plugin Obj ) { var has Plugin = ! ! ( get Plugin ( name ) ) , i , j ; current Plugin Name = name ; if ( ! has Plugin ) { plugins . push ( { name : name , obj : plugin Obj } ) ; setup Plugin ( plugins [ plugins . length - 1 ] ) ; } else { if ( plugin Override ) { for ( i = 0 ; i < plugins . length ; i + = 1 ) { if ( plugins [ i ] . name = = = name ) { 
function ( plugin , config ) { var i , pc = plugin Config [ " * " ] ; config = ( config ! = = undefined ) ? config : plugin Config [ plugin . name ] ; 
function ( json ) { 
function ( repo ) { return p . spawn ( 'git ' , [ 'remote ' , 'show ' , program . remote ] , CHILD _IGNORE ) . then ( function ( ) { } , function ( e ) { return p . spawn ( 'git ' , [ 'remote ' , 'add ' , program . remote , 'git @github .com : ' + repo ] ) ; } ) ; } 
function ( repo , branchname ) { return ensure Remote ( repo ) . then ( function ( ) { return p . spawn ( 'git ' , [ 'push ' , program . remote , 'HEAD :refs /heads / ' + branchname ] , CHILD _IGNORE ) ; } ) ; } 
function transform ( opts ) { var contents = opts . contents ; var file Path = opts . file Path ; var last Script $ ; var $ = cheerio . load ( contents ) ; if ( path . basename ( file Path ) = = = 'index .html ' ) { last Script $ = find Last Script ( $ ) ; if ( last Script $ ) { last Script $ . after ( ' <script src = "require .load .js " > < /script > ' ) ; } else { $ ( 'body ' ) . append ( ' <script src = "require .load .js " > < /script > ' ) ; } } return $ . html ( ) ; } 
function transform ( opts ) { var contents = opts . contents ; var file Path = opts . file Path ; var index = opts . index ; 
function _filter To Shape ( mutable , obj , shape , path = [ ] , full Obj = null ) { if ( full Obj = = = null ) { full Obj = obj ; } 
function record Speed ( child , speed ) { child . run Count + = sample Size if ( pass Count > 1 ) { var square = Math . pow ( speed - child . speed , 2 ) child . variance + = ( square - child . variance ) / ( pass Count - 1 ) } child . speed + = ( speed - child . speed ) / pass Count } 
function next Child ( ) { child = children [ child Index + + ] if ( child ) { fn = child . fn run Index = 0 var run Fn = / ^function . * ? \ ( [ ^ \s \ ) ] / . test ( fn . to String ( ) ) ? run Async : run Sync start = process . hrtime ( ) run Fn ( ) } else { calculate Stats ( ) } } 
function run Sync ( ) { for ( run Index = 0 ; run Index < sample Size ; run Index + + ) { fn . call ( child ) } set Timeout ( finish Child , 0 ) } 
function run Async ( ) { if ( run Index + + < sample Size ) { fn . call ( child , function ( ) { set Timeout ( run Async , 0 ) } ) } else { set Timeout ( finish Child , 0 ) } } 
function file To Readable ( file ) { class VFile Readable extends stream . Readable { _read ( ) { this . push ( file ) ; this . push ( null ) ; } } return new VFile Readable ( { object Mode : true } ) ; } 
function transform DOMText ( opts ) { return new Promise ( ( resolve , reject ) = > { var file = new VFile ( { path : opts . file Path , contents : new Buffer ( opts . get Text ( opts . el $ ) , 'utf 8 ' ) 
function transform ( opts ) { var contents = opts . contents ; var $ = cheerio . load ( contents ) ; var css Transforms = opts . fetcher . transforms . css . map ( ( tf ) = > tf ( { fetcher : opts . fetcher , index : opts . index } ) ) ; 
function ( json ) { 
function instance ( state , methods ) { let api = { } ; Object . keys ( methods ) . for Each ( key = > { api [ key ] = methods [ key ] . bind ( null , state ) ; } ) ; return api ; } 
function syntax Error ( message , pos ) { let err = Error ( message ) ; err . name = "Syntax Error " ; err . pos = pos ; return err ; } 
function watch ( dir ) { if ( ! ignore Dir . test ( dir ) & & ! map [ dir ] ) { fs . lstat ( dir , function ( e , stat ) { if ( ! e ) { if ( stat . is Symbolic Link ( ) ) { var source = dir fs . readlink ( source , function ( e , link ) { if ( ! e ) { var dest = link if ( dest [ 0 ] ! = = ' / ' ) { while ( dest . substr ( 0 , 3 ) = = = ' . . / ' ) { dest = dest . substr ( 3 ) source = source . replace ( / \ / [ ^ \ / ] + $ / , ' ' ) } if ( dest . substr ( 0 , 2 ) = = = ' . / ' ) { dest = dest . substr ( 2 ) } dest = source + ' / ' + dest } watch ( dest ) } } ) } else if ( stat . is Directory ( ) ) { add Dir ( dir , stat ) } else { dir = dirname ( dir ) map [ dir ] = Math . max ( map [ dir ] , stat . mtime . get Time ( ) ) } } } ) } } 
function add Dir ( dir , stat ) { var mtime = stat . mtime . get Time ( ) if ( ! map [ dir ] & & list . length < = max List Size ) { map [ dir ] = mtime list . push ( dir ) clear Timeout ( sort List . timer ) sort List . timer = set Timeout ( sort List , check Interval ) fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . for Each ( function ( file ) { watch ( dir + ' / ' + file ) } ) } } ) } } 
function start Watches ( ) { list . for Each ( function ( dir , i ) { if ( i < max Fs Watches ) { try { fs . watch ( dir , function ( op , file ) { notify ( dir + ' / ' + file ) } ) } catch ( e ) { 
function check Dir ( ) { var n = indexes [ i ] if ( i > 4 4 ) { indexes [ i ] = ( indexes [ i ] + 5 ) % list . length } i = ( i + 1 ) % indexes . length var dir = list [ n ] if ( dir ) { fs . stat ( dir , function ( e , stat ) { if ( ! e & & ( stat . mtime > ok To Notify After ) ) { fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . for Each ( function ( file ) { var path = dir + ' / ' + file fs . stat ( path , function ( e , stat ) { if ( ! e & & ( stat . mtime > ok To Notify After ) ) { notify ( path ) } } ) } ) } } ) } } ) } } 
function notify ( path ) { var now = Date . now ( ) if ( ( now > ok To Notify After ) & & ! ignore File . test ( path ) ) { process . send ( path ) ok To Notify After = now + notify Interval sort List ( ) } } 
function Graceful ( options ) { options = options | | { } ; this . shutting Down = false ; this . _checks = [ ] ; this . _sending = false ; this . poll Interval = options . poll Interval | | 2 5 0 ; local Util . verify Type ( 'number ' , this , 'poll Interval ' ) ; this . timeout = options . timeout | | 5 * 1 0 0 0 ; local Util . verify Type ( 'number ' , this , 'timeout ' ) ; this . messenger = options . messenger | | require ( 'thehelp -last -ditch ' ) ; local Util . verify Type ( 'function ' , this , 'messenger ' ) ; this . log = options . log | | log Shim ( 'thehelp -cluster :graceful ' ) ; local Util . verify Log ( this . log ) ; var _this = this ; this . add Check ( function are We Sending ( ) { return _this . _sending = = = false ; } ) ; this . _process = options . _process | | process ; this . _cluster = options . _cluster | | cluster ; this . _log Prefix = local Util . get Log Prefix ( ) ; this . _setup Listeners ( ) ; if ( Graceful . instance ) { this . log . warn ( 'More than one Graceful instance created in this process . ' + 'There are now duplicate process -level wireups ! ' ) ; } Graceful . instance = this ; } 
function decorate Fn ( fn ) { fn . returns = function ( value ) { fn . _returns = value return fn } return fn } 
function Mock Date ( value ) { 
function move Time ( ) { if ( mock . time . _SPEED ) { 
function get Scheduler ( is Interval ) { return function ( fn , time ) { schedules . push ( { id : + + schedules . id , fn : fn , time : Date . now ( ) + time , interval : is Interval ? time : false } ) } } 
function get Unscheduler ( ) { 
function run Schedules ( ) { 
function Startup ( options ) { options = options | | { } ; this . _log Prefix = util . get Log Prefix ( ) ; this . worker = options . worker ; if ( ! this . worker ) { throw new Error ( 'Need to provide a worker callback ! ' ) ; } util . verify Type ( 'function ' , this , 'worker ' ) ; this . _stats = options . stats | | new Stats D ( { prefix : process . env . THEHELP _APP _NAME + ' . ' } ) ; this . log = options . log | | log Shim ( 'thehelp -cluster :startup ' ) ; util . verify Log ( this . log ) ; this . master Options = options . master Options ; this . master = options . master | | this . _default Master Start . bind ( this ) ; util . verify Type ( 'function ' , this , 'master ' ) ; this . graceful = options . graceful | | Graceful . instance ; 
function start Gc ( db , options ) { this . options = options | | { } var freq Ms = options . gc Freq Ms | | 6 0 0 0 0 var max Versions = options . gc Max Versions var max Age = options . gc Max Age var backup = options . gc Backup var callback = options . gc Callback if ( max Age | | max Versions ) { max Age = max Age | | Math . pow ( 2 , 5 3 ) max Version = max Versions | | Math . pow ( 2 , 5 3 ) function filter ( record ) { if ( record . version ! = null ) { if ( Date . now ( ) - record . version > max Age ) return true } if ( record . key ! = this . current Key ) { this . current Key = record . key this . current Count = 0 } return this . current Count + + > = max Versions } this . scanner = gc ( db , filter , backup ) return loose Interval ( scanner . run . bind ( scanner ) , freq Ms , callback ) } } 
function pipe Transforms ( stream , transforms ) { var head , rest ; if ( ! Array . is Array ( transforms ) | | ! transforms . length ) { return stream ; } head = transforms [ 0 ] ; rest = transforms . slice ( 1 ) ; 
function streamify ( opts , transform ) { return through 2 . obj ( 
function ( entry ) { var parsed = url . parse ( entry , true , true ) ; return ! parsed . protocol | | values . FETCH _PROTOCOLS . index Of ( parsed . protocol ) ! = = - 1 ; } 
function ( json ) { 
function ( json ) { 
function ( json ) { 
function force In Range ( value , min , max ) { if ( value > max ) { return max ; } else if ( value < min ) { return min ; } else { return value ; } } 
function insert Into List ( item , position , list ) { var before = list . slice ( 0 , position ) ; var after = list . slice ( position ) ; return before . push ( item ) . concat ( after ) } 
function parse ( tokens ) { let tr = TReader . create ( prepare Tokens ( tokens ) ) ; let nodes = [ ] ; while ( true ) { if ( tr . accept ( " $ " ) ) { return nodes ; } if ( tr . accept ( "text " ) ) { nodes . push ( parse Text ( tr ) ) ; } else if ( tr . accept ( "tag _ 0 " ) ) { nodes . push ( parse Tag 0 ( tr ) ) ; } else { tr . expect ( "tag _ 1 " ) ; nodes . push ( parse Tag 1 ( tr ) ) ; } } } 
function prepare Tokens ( tokens ) { let result = [ ] ; let last Token = null ; tokens . for Each ( token = > { let new Token = null ; if ( token . type = = = "text " ) { let value = token . value . replace ( GRE _WS , " " ) . trim ( ) ; if ( value ! = = " " ) { if ( last Token & & last Token . type = = = "text " ) { last Token . value + = value ; } else { new Token = { type : "text " , start : token . start , value } ; } } } else if ( token . type ! = = "comment " ) { new Token = token ; } if ( new Token ) { result . push ( new Token ) ; last Token = new Token ; } } ) ; result . push ( { type : " $ " } ) ; return result ; } 
function parse Tag 1 ( tr ) { let start Token = tr . get Token ( ) ; let node = init Tag Node ( start Token ) ; while ( true ) { if ( tr . accept ( "text " ) ) { node . children . push ( parse Text ( tr ) ) ; } else if ( tr . accept ( "tag _ 0 " ) ) { node . children . push ( parse Tag 0 ( tr ) ) ; } else if ( tr . accept ( "tag _ 1 " ) ) { node . children . push ( parse Tag 1 ( tr ) ) ; } else if ( tr . accept ( "tag _ 2 " ) ) { let token = tr . get Token ( ) ; if ( token . name ! = = start Token . name ) { let msg = ` $ { token . name } ` ; throw Tools . syntax Error ( msg , token . start ) ; } return node ; } else { let msg = ` $ { start Token . name } ` ; throw Tools . syntax Error ( msg , start Token . start ) ; } } } 
function init Tag Node ( token ) { validate Props ( token ) ; return { type : token . name , props : token . props , children : [ ] } ; } 
function validate Props ( token ) { Object . keys ( token . props ) . for Each ( key = > { if ( ! validate Prop ( key , token . props [ key ] ) ) { throw Tools . syntax Error ( ` $ { key } ` , token ) ; } } ) ; } 
function validate Prop ( key , value ) { switch ( key ) { case "each " : return Extender . validate Each ( value ) ; case "if " : case "fi " : return Extender . validate Expr ( value ) ; default : return true ; } } 
function process Prop ( value , data ) { return RE _EXPR . test ( value ) ? process Expr ( value , data ) : process Text ( value , data ) ; } 
function process Text ( value , data ) { return value . replace ( GRE _EXPR , m = > { let res = process Expr ( m , data ) ; return Tools . is Void ( res ) ? " " : res + " " ; } ) . replace ( GRE _WS , " " ) . trim ( ) ; } 
function process Expr ( value , data ) { if ( value = = = "true " ) { return true ; } if ( value = = = "false " ) { return false ; } let m = value . match ( RE _EXPR ) ; if ( ! m ) { return null ; } return m [ 1 ] ? process Path ( m [ 1 ] , data ) : parse Float ( m [ 2 ] ) ; } 
function process Each ( value , data ) { let m = value . match ( RE _EACH ) ; if ( ! m ) { return null ; } let items = process Path ( m [ 2 ] , data ) ; if ( ! Array . is Array ( items ) ) { items = [ ] ; } return { item : m [ 1 ] , items } ; } 
function process Path Array ( path , data ) { if ( ! data ) { return null ; } let value = data [ path [ 0 ] ] ; return path . length > 1 ? process Path Array ( path . slice ( 1 ) , value ) : value ; } 
function Event ( name , attributes ) { this . _name = name ; this . _stopped = false ; this . _attrs = { } ; if ( attributes ) { this . set Attributes ( attributes ) ; } } 
function read UInt 6 4BE ( buf , offset ) { if ( offset ) { buf = buf . slice ( offset , offset + 8 ) ; } 
function create ( text ) { return Tools . instance ( { text , pos : 0 } , { is Done , get Pos , expect , accept , expect RE , accept RE , goto } ) ; } 
function expect RE ( $ , regexp ) { let str = accept RE ( $ , regexp ) ; if ( str = = = null ) { throw Tools . syntax Error ( "Unexpected character " , $ . pos ) ; } return str ; } 
function accept ( $ , str ) { if ( ! $ . text . starts With ( str , $ . pos ) ) { return false ; } $ . pos + = str . length ; return true ; } 
function accept RE ( $ , regexp ) { let m = $ . text . substr ( $ . pos ) . match ( regexp ) ; if ( ! m ) { return null ; } let str = m [ 0 ] ; $ . pos + = str . length ; return str ; } 
function goto ( $ , str ) { let index = $ . text . index Of ( " - - > " , $ . pos ) ; if ( index = = = - 1 ) { return false ; } $ . pos = index ; return true ; } 
function transform ( opts ) { var contents = opts . contents ; var $ = cheerio . load ( contents ) ; $ ( 'html ' ) . remove Attr ( 'manifest ' ) ; 
function ( json ) { 
function ( json ) { 
function expect ( $ , type ) { if ( ! accept ( $ , type ) ) { let token = $ . tokens [ $ . pos ] ; throw Tools . syntax Error ( "Unexpected token " , token . start ) ; } } 
function accept ( $ , type ) { let token = $ . tokens [ $ . pos ] ; if ( token . type ! = = type ) { return false ; } $ . pos + + ; return true ; } 
function Master ( options ) { options = options | | { } ; this . _workers = { } ; this . shutting Down = false ; this . spin Timeout = options . spin Timeout | | 1 0 * 1 0 0 0 ; util . verify Type ( 'number ' , this , 'spin Timeout ' ) ; this . delay Start = options . delay Start | | 6 0 * 1 0 0 0 ; util . verify Type ( 'number ' , this , 'delay Start ' ) ; this . poll Interval = options . poll Interval | | 5 0 0 ; util . verify Type ( 'number ' , this , 'poll Interval ' ) ; this . kill Timeout = options . kill Timeout | | 7 0 0 0 ; util . verify Type ( 'number ' , this , 'kill Timeout ' ) ; this . number Workers = options . number Workers | | parse Int ( process . env . THEHELP _NUMBER _WORKERS , 1 0 ) | | 1 ; util . verify Type ( 'number ' , this , 'number Workers ' ) ; this . set Graceful ( options . graceful | | Graceful . instance ) ; this . log = options . log | | log Shim ( 'thehelp -cluster :master ' ) ; util . verify Log ( options . log ) ; this . _cluster = options . _cluster | | cluster ; this . _cluster . on ( 'disconnect ' , this . _restart Worker . bind ( this ) ) ; if ( Master . instance ) { this . log . warn ( 'More than one Master instance created in this process . ' + 'You \ 'll have more worker processes than you signed up for ! ' ) ; } Master . instance = this ; } 
function ( json ) { 
function Topic ( name , options , emitter ) { this . name = name ; this . subscribers = [ ] ; this . queue = [ ] ; this . published Events = { } ; this . options = options | | { } ; this . emitter = emitter ; } 
function Pub Sub ( name , options ) { Event Emitter . call ( this ) ; this . name = name ; this . topics = { } ; this . options = options | | { strict : true } ; } 
function async For Each ( array , iterator , done ) { if ( array . length = = = 0 ) { 
function readdir Async ( dir , options , callback , internal Options ) { if ( typeof options = = = 'function ' ) { callback = options ; options = undefined ; } return maybe ( callback , new Promise ( ( ( resolve , reject ) = > { let results = [ ] ; internal Options . facade = async Facade ; let reader = new Directory Reader ( dir , options , internal Options ) ; let stream = reader . stream ; stream . on ( 'error ' , err = > { reject ( err ) ; stream . pause ( ) ; } ) ; stream . on ( 'data ' , result = > { results . push ( result ) ; } ) ; stream . on ( 'end ' , ( ) = > { resolve ( results ) ; } ) ; } ) ) ) ; } 
function safe Call ( fn , args ) { 
function call Once ( fn ) { let fulfilled = false ; return function once Wrapper ( err ) { if ( ! fulfilled ) { fulfilled = true ; return fn . apply ( this , arguments ) ; } else if ( err ) { 
function readdir Async Stat ( dir , options , callback ) { return readdir Async ( dir , options , callback , { stats : true } ) ; } 
function normalize Options ( options , internal Options ) { if ( options = = = null | | options = = = undefined ) { options = { } ; } else if ( typeof options ! = = 'object ' ) { throw new Type Error ( 'options must be an object ' ) ; } let recurse Depth , recurse Fn , recurse Reg Exp , recurse Glob , deep = options . deep ; if ( deep = = = null | | deep = = = undefined ) { recurse Depth = 0 ; } else if ( typeof deep = = = 'boolean ' ) { recurse Depth = deep ? Infinity : 0 ; } else if ( typeof deep = = = 'number ' ) { if ( deep < 0 | | is Na N ( deep ) ) { throw new Error ( 'options .deep must be a positive number ' ) ; } else if ( Math . floor ( deep ) ! = = deep ) { throw new Error ( 'options .deep must be an integer ' ) ; } else { recurse Depth = deep ; } } else if ( typeof deep = = = 'function ' ) { recurse Depth = Infinity ; recurse Fn = deep ; } else if ( deep instanceof Reg Exp ) { recurse Depth = Infinity ; recurse Reg Exp = deep ; } else if ( typeof deep = = = 'string ' & & deep . length > 0 ) { recurse Depth = Infinity ; recurse Glob = glob To Reg Exp ( deep , { extended : true , globstar : true } ) ; } else { throw new Type Error ( 'options .deep must be a boolean , number , function , regular expression , or glob pattern ' ) ; } let filter Fn , filter Reg Exp , filter Glob , filter = options . filter ; if ( filter ! = = null & & filter ! = = undefined ) { if ( typeof filter = = = 'function ' ) { filter Fn = filter ; } else if ( filter instanceof Reg Exp ) { filter Reg Exp = filter ; } else if ( typeof filter = = = 'string ' & & filter . length > 0 ) { filter Glob = glob To Reg Exp ( filter , { extended : true , globstar : true } ) ; } else { throw new Type Error ( 'options .filter must be a function , regular expression , or glob pattern ' ) ; } } let sep = options . sep ; if ( sep = = = null | | sep = = = undefined ) { sep = path . sep ; } else if ( typeof sep ! = = 'string ' ) { throw new Type Error ( 'options .sep must be a string ' ) ; } let base Path = options . base Path ; if ( base Path = = = null | | base Path = = = undefined ) { base Path = ' ' ; } else if ( typeof base Path = = = 'string ' ) { 
function stat ( fs , path , callback ) { let is Sym Link = false ; call . safe ( fs . lstat , path , ( err , lstats ) = > { if ( err ) { 
function symlink Stat ( fs , path , lstats , callback ) { call . safe ( fs . stat , path , ( err , stats ) = > { if ( err ) { 
function readdir Stream ( dir , options , internal Options ) { internal Options . facade = stream Facade ; let reader = new Directory Reader ( dir , options , internal Options ) ; return reader . stream ; } 
function sync For Each ( array , iterator , done ) { array . for Each ( item = > { iterator ( item , ( ) = > { 
function readdir Sync ( dir , options , internal Options ) { internal Options . facade = sync Facade ; let reader = new Directory Reader ( dir , options , internal Options ) ; let stream = reader . stream ; let results = [ ] ; let data = stream . read ( ) ; while ( data ! = = null ) { results . push ( data ) ; data = stream . read ( ) ; } return results ; } 
function stat ( path , opts ) { return new Promise ( ( resolve , reject ) = > { stat Provider . async ( path , options Manager . prepare ( opts ) , ( err , stats ) = > err ? reject ( err ) : resolve ( stats ) ) ; } ) ; } 
function uniq No Set ( arr ) { var ret = [ ] ; for ( var i = 0 ; i < arr . length ; i + + ) { if ( ret . index Of ( arr [ i ] ) = = = - 1 ) { ret . push ( arr [ i ] ) ; } } return ret ; } 
function uniq Set With For Each ( arr ) { var ret = [ ] ; ( new Set ( arr ) ) . for Each ( function ( el ) { ret . push ( el ) ; } ) ; return ret ; } 
function does For Each Actually Work ( ) { var ret = false ; ( new Set ( [ true ] ) ) . for Each ( function ( el ) { ret = el ; } ) ; return ret = = = true ; } 
function Base ( config , options ) { if ( ! ( this instanceof Base ) ) { return new Base ( config , options ) ; } Cache . call ( this , config ) ; this . is ( 'base ' ) ; this . init Base ( config , options ) ; } 
function braces ( pattern , options ) { var key = utils . create Key ( String ( pattern ) , options ) ; var arr = [ ] ; var disabled = options & & options . cache = = = false ; if ( ! disabled & & cache . has Own Property ( key ) ) { return cache [ key ] ; } if ( Array . is Array ( pattern ) ) { for ( var i = 0 ; i < pattern . length ; i + + ) { arr . push . apply ( arr , braces . create ( pattern [ i ] , options ) ) ; } } else { arr = braces . create ( pattern , options ) ; } if ( options & & options . nodupes = = = true ) { arr = unique ( arr ) ; } if ( ! disabled ) { cache [ key ] = arr ; } return arr ; } 
function memoize ( type , pattern , options , fn ) { var key = utils . create Key ( type + ' : ' + pattern , options ) ; var disabled = options & & options . cache = = = false ; if ( disabled ) { braces . clear Cache ( ) ; return fn ( pattern , options ) ; } if ( cache . has Own Property ( key ) ) { return cache [ key ] ; } var res = fn ( pattern , options ) ; cache [ key ] = res ; return res ; } 
function multiply ( queue , n , options ) { return utils . flatten ( utils . repeat ( utils . arrayify ( queue ) , n ) ) ; } 
function is Optimized ( node , options ) { if ( node . parent . is Optimized ) return true ; return is Type ( node . parent , 'brace ' ) & & ! is Escaped ( node . parent ) & & options . expand ! = = true ; } 
function no Inner ( node , type ) { if ( node . parent . queue . length = = = 1 ) { return true ; } var nodes = node . parent . nodes ; return nodes . length = = = 3 & & is Type ( nodes [ 0 ] , 'brace .open ' ) & & ! is Type ( nodes [ 1 ] , 'text ' ) & & is Type ( nodes [ 2 ] , 'brace .close ' ) ; } 
function concat Nodes ( pos , node , parent , options ) { node . orig = node . val ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; var is Escaped = false ; if ( node . val . length > 1 ) { var a = node . val . char At ( 0 ) ; var b = node . val . slice ( - 1 ) ; is Escaped = ( a = = = ' " ' & & b = = = ' " ' ) | | ( a = = = " ' " & & b = = = " ' " ) | | ( a = = = ' ` ' & & b = = = ' ` ' ) ; } if ( is Escaped & & options . unescape ! = = false ) { node . val = node . val . slice ( 1 , node . val . length - 1 ) ; node . escaped = true ; } if ( node . match ) { var match = node . match [ 1 ] ; if ( ! match | | match . index Of ( ' } ' ) = = = - 1 ) { match = node . match [ 0 ] ; } 
function enable ( namespaces ) { exports . save ( namespaces ) ; exports . names = [ ] ; exports . skips = [ ] ; var i ; var split = ( typeof namespaces = = = 'string ' ? namespaces : ' ' ) . split ( / [ \s , ] + / ) ; var len = split . length ; for ( i = 0 ; i < len ; i + + ) { if ( ! split [ i ] ) continue ; 
function brackets ( pattern , options ) { debug ( 'initializing from < %s > ' , _ _filename ) ; var res = brackets . create ( pattern , options ) ; return res . output ; } 
function parsers ( brackets ) { brackets . state = brackets . state | | { } ; brackets . parser . sets . bracket = brackets . parser . sets . bracket | | [ ] ; brackets . parser . capture ( 'escape ' , function ( ) { if ( this . is Inside ( 'bracket ' ) ) return ; var pos = this . position ( ) ; var m = this . match ( / ^ \ \ ( . ) / ) ; if ( ! m ) return ; return pos ( { type : 'escape ' , val : m [ 0 ] } ) ; } ) . capture ( 'text ' , function ( ) { if ( this . is Inside ( 'bracket ' ) ) return ; var pos = this . position ( ) ; var m = this . match ( not ) ; if ( ! m | | ! m [ 0 ] ) return ; return pos ( { type : 'text ' , val : m [ 0 ] } ) ; } ) . capture ( 'posix ' , function ( ) { var pos = this . position ( ) ; var m = this . match ( / ^ \ [ : ( . * ? ) : \ ] ( ? = . * \ ] ) / ) ; if ( ! m ) return ; var inside = this . is Inside ( 'bracket ' ) ; if ( inside ) { brackets . posix + + ; } return pos ( { type : 'posix ' , inside Bracket : inside , inner : m [ 1 ] , val : m [ 0 ] } ) ; } ) . capture ( 'bracket ' , function ( ) { } ) . capture ( 'bracket .open ' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( / ^ \ [ ( ? = . * \ ] ) / ) ; if ( ! m ) return ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; if ( parsed . slice ( - 1 ) = = = ' \ \ ' & & ! this . is Inside ( 'bracket ' ) ) { last . val = last . val . slice ( 0 , last . val . length - 1 ) ; return pos ( { type : 'escape ' , val : m [ 0 ] } ) ; } var open = pos ( { type : 'bracket .open ' , val : m [ 0 ] } ) ; if ( last . type = = = 'bracket .open ' | | this . is Inside ( 'bracket ' ) ) { open . val = ' \ \ ' + open . val ; open . type = 'bracket .inner ' ; open . escaped = true ; return open ; } var node = pos ( { type : 'bracket ' , nodes : [ open ] } ) ; define ( node , 'parent ' , prev ) ; define ( open , 'parent ' , node ) ; this . push ( 'bracket ' , node ) ; prev . nodes . push ( node ) ; } ) . capture ( 'bracket .inner ' , function ( ) { if ( ! this . is Inside ( 'bracket ' ) ) return ; var pos = this . position ( ) ; var m = this . match ( not ) ; if ( ! m | | ! m [ 0 ] ) return ; var next = this . input . char At ( 0 ) ; var val = m [ 0 ] ; var node = pos ( { type : 'bracket .inner ' , val : val } ) ; if ( val = = = ' \ \ \ \ ' ) { return node ; } var first = val . char At ( 0 ) ; var last = val . slice ( - 1 ) ; if ( first = = = ' ! ' ) { val = ' ^ ' + val . slice ( 1 ) ; } if ( last = = = ' \ \ ' | | ( val = = = ' ^ ' & & next = = = ' ] ' ) ) { val + = this . input [ 0 ] ; this . consume ( 1 ) ; } node . val = val ; return node ; } ) . capture ( 'bracket .close ' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( / ^ \ ] / ) ; if ( ! m ) return ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; if ( parsed . slice ( - 1 ) = = = ' \ \ ' & & ! this . is Inside ( 'bracket ' ) ) { last . val = last . val . slice ( 0 , last . val . length - 1 ) ; return pos ( { type : 'escape ' , val : m [ 0 ] } ) ; } var node = pos ( { type : 'bracket .close ' , rest : this . input , val : m [ 0 ] } ) ; if ( last . type = = = 'bracket .open ' ) { node . type = 'bracket .inner ' ; node . escaped = true ; return node ; } var bracket = this . pop ( 'bracket ' ) ; if ( ! this . is Type ( bracket , 'bracket ' ) ) { if ( this . options . strict ) { throw new Error ( 'missing opening " [ " ' ) ; } node . type = 'bracket .inner ' ; node . escaped = true ; return node ; } bracket . nodes . push ( node ) ; define ( node , 'parent ' , bracket ) ; } ) ; } 
function fill Range ( a , b , step , options , fn ) { if ( a = = null | | b = = null ) { throw new Error ( 'fill -range expects the first and second args to be strings . ' ) ; } if ( typeof step = = = 'function ' ) { fn = step ; options = { } ; step = null ; } if ( typeof options = = = 'function ' ) { fn = options ; options = { } ; } if ( is Object ( step ) ) { options = step ; step = ' ' ; } var expand , regex = false , sep = ' ' ; var opts = options | | { } ; if ( typeof opts . silent = = = 'undefined ' ) { opts . silent = true ; } step = step | | opts . step ; 
function wrap ( arr , sep , opts ) { if ( sep = = = ' ~ ' ) { sep = ' - ' ; } var str = arr . join ( sep ) ; var pre = opts & & opts . regex Prefix ; 
function is Char Class ( a , b , step , is Num , is Descending ) { if ( is Descending ) { return false ; } if ( is Num ) { return a < = 9 & & b < = 9 ; } if ( a < b ) { return step = = = 1 ; } return false ; } 
function should Expand ( a , b , num , is Num , padding , opts ) { if ( is Num & & ( a > 9 | | b > 9 ) ) { return false ; } return ! padding & & num = = = 1 & & a < b ; } 
function detect Separator ( a , b , step , is Num , is Descending ) { var is Char = is Char Class ( a , b , step , is Num , is Descending ) ; if ( ! is Char ) { return ' | ' ; } return ' ~ ' ; } 
function format Padding ( ch , pad ) { var res = pad ? pad + ch : ch ; if ( pad & & ch . to String ( ) . char At ( 0 ) = = = ' - ' ) { res = ' - ' + pad + ch . to String ( ) . substr ( 1 ) ; } return res . to String ( ) ; } 
function is Invalid Char ( str ) { var ch = to Str ( str ) ; return ch = = = ' \ \ ' | | ch = = = ' [ ' | | ch = = = ' ] ' | | ch = = = ' ^ ' | | ch = = = ' ( ' | | ch = = = ' ) ' | | ch = = = ' ` ' ; } 
function is Padded ( orig A , orig B ) { if ( has Zeros ( orig A ) | | has Zeros ( orig B ) ) { var alen = length ( orig A ) ; var blen = length ( orig B ) ; var len = alen > = blen ? alen : blen ; return function ( a ) { return repeat Str ( ' 0 ' , len - length ( a ) ) ; } ; } return false ; } 
function Extglob ( options ) { this . options = extend ( { source : 'extglob ' } , options ) ; this . snapdragon = this . options . snapdragon | | new Snapdragon ( this . options ) ; this . snapdragon . patterns = this . snapdragon . patterns | | { } ; this . compiler = this . snapdragon . compiler ; this . parser = this . snapdragon . parser ; compilers ( this . snapdragon ) ; parsers ( this . snapdragon ) ; define ( this . snapdragon , 'parse ' , function ( str , options ) { var parsed = Snapdragon . prototype . parse . apply ( this , arguments ) ; parsed . input = str ; * Decorate ` .parse ` method * / define ( this , 'parse ' , function ( ast , options ) { return this . snapdragon . parse . apply ( this . snapdragon , arguments ) ; } ) ; define ( this , 'compile ' , function ( ast , options ) { return this . snapdragon . compile . apply ( this . snapdragon , arguments ) ; } ) ; } 
function micromatch ( list , patterns , options ) { patterns = utils . arrayify ( patterns ) ; list = utils . arrayify ( list ) ; var len = patterns . length ; if ( list . length = = = 0 | | len = = = 0 ) { return [ ] ; } if ( len = = = 1 ) { return micromatch . match ( list , patterns [ 0 ] , options ) ; } var omit = [ ] ; var keep = [ ] ; var idx = - 1 ; while ( + + idx < len ) { var pattern = patterns [ idx ] ; if ( typeof pattern = = = 'string ' & & pattern . char Code At ( 0 ) = = = 3 3 ) { omit . push . apply ( omit , micromatch . match ( list , pattern . slice ( 1 ) , options ) ) ; } else { keep . push . apply ( keep , micromatch . match ( list , pattern , options ) ) ; } } var matches = utils . diff ( keep , omit ) ; if ( ! options | | options . nodupes ! = = false ) { return utils . unique ( matches ) ; } return matches ; } 
function memoize ( type , pattern , options , fn ) { var key = utils . create Key ( type + ' = ' + pattern , options ) ; if ( options & & options . cache = = = false ) { return fn ( pattern , options ) ; } if ( cache . has ( type , key ) ) { return cache . get ( type , key ) ; } var val = fn ( pattern , options ) ; cache . set ( type , key , val ) ; return val ; } 
function visit ( node , fn ) { return node . nodes ? map Visit ( node . nodes , fn ) : fn ( node ) ; } 
function map Visit ( nodes , fn ) { var len = nodes . length ; var idx = - 1 ; while ( + + idx < len ) { visit ( nodes [ idx ] , fn ) ; } } 
function text Regex ( pattern ) { var not Str = regex Not . create ( pattern , { contains : true , strict Close : false } ) ; var prefix = ' ( ? : [ \ \ ^ ] | \ \ \ \ | ' ; return to Regex ( prefix + not Str + ' ) ' , { strict Close : false } ) ; } 
function sync ( source , opts ) { var works = get Works ( source , reader _sync _ 1 . default , opts ) ; return array Utils . flatten ( works ) ; } 
function async ( source , opts ) { var works = get Works ( source , reader _async _ 1 . default , opts ) ; return Promise . all ( works ) . then ( array Utils . flatten ) ; } 
function stream ( source , opts ) { var works = get Works ( source , reader _stream _ 1 . default , opts ) ; return merge 2 ( works ) ; } 
function generate Tasks ( source , opts ) { var patterns = [ ] . concat ( source ) ; var options = options Manager . prepare ( opts ) ; return task Manager . generate ( patterns , options ) ; } 
function get Works ( source , _Reader , opts ) { var patterns = [ ] . concat ( source ) ; var options = options Manager . prepare ( opts ) ; var tasks = task Manager . generate ( patterns , options ) ; var reader = new _Reader ( options ) ; return tasks . map ( reader . read , reader ) ; } 
function generate ( patterns , options ) { var unix Patterns = patterns . map ( pattern Utils . unixify Pattern ) ; var unix Ignore = options . ignore . map ( pattern Utils . unixify Pattern ) ; var positive Patterns = get Positive Patterns ( unix Patterns ) ; var negative Patterns = get Negative Patterns As Positive ( unix Patterns , unix Ignore ) ; var static Patterns = positive Patterns . filter ( pattern Utils . is Static Pattern ) ; var dynamic Patterns = positive Patterns . filter ( pattern Utils . is Dynamic Pattern ) ; var static Tasks = convert Patterns To Tasks ( static Patterns , negative Patterns , false ) ; var dynamic Tasks = convert Patterns To Tasks ( dynamic Patterns , negative Patterns , true ) ; return static Tasks . concat ( dynamic Tasks ) ; } 
function convert Patterns To Tasks ( positive , negative , dynamic ) { var positive Patterns Group = group Patterns By Base Directory ( positive ) ; var negative Patterns Group = group Patterns By Base Directory ( negative ) ; 
function get Negative Patterns As Positive ( patterns , ignore ) { var negative = pattern Utils . get Negative Patterns ( patterns ) . concat ( ignore ) ; var positive = negative . map ( pattern Utils . convert To Positive Pattern ) ; return positive ; } 
function group Patterns By Base Directory ( patterns ) { return patterns . reduce ( function ( collection , pattern ) { var base = pattern Utils . get Base Directory ( pattern ) ; if ( base in collection ) { collection [ base ] . push ( pattern ) ; } else { collection [ base ] = [ pattern ] ; } return collection ; } , { } ) ; } 
function convert Pattern Groups To Tasks ( positive , negative , dynamic ) { var global Negative = ' . ' in negative ? negative [ ' . ' ] : [ ] ; return Object . keys ( positive ) . map ( function ( base ) { var local Negative = find Local Negative Patterns ( base , negative ) ; var full Negative = local Negative . concat ( global Negative ) ; return convert Pattern Group To Task ( base , positive [ base ] , full Negative , dynamic ) ; } ) ; } 
function find Local Negative Patterns ( positive Base , negative ) { return Object . keys ( negative ) . reduce ( function ( collection , base ) { if ( base . starts With ( positive Base ) ) { collection . push . apply ( collection , _ _spread ( negative [ base ] ) ) ; } return collection ; } , [ ] ) ; } 
function convert Pattern Group To Task ( base , positive , negative , dynamic ) { return { base : base , dynamic : dynamic , patterns : [ ] . concat ( positive , negative . map ( pattern Utils . convert To Negative Pattern ) ) , positive : positive , negative : negative } ; } 
function is Affect Depth Of Reading Pattern ( pattern ) { var basename = path . basename ( pattern ) ; return ends With Slash Glob Star ( pattern ) | | is Static Pattern ( basename ) ; } 
function match Any ( entry , patterns Re ) { try { for ( var patterns Re _ 1 = _ _values ( patterns Re ) , patterns Re _ 1 _ 1 = patterns Re _ 1 . next ( ) ; ! patterns Re _ 1 _ 1 . done ; patterns Re _ 1 _ 1 = patterns Re _ 1 . next ( ) ) { var regexp = patterns Re _ 1 _ 1 . value ; if ( regexp . test ( entry ) ) { return true ; } } } catch ( e _ 1 _ 1 ) { e _ 1 = { error : e _ 1 _ 1 } ; } finally { try { if ( patterns Re _ 1 _ 1 & & ! patterns Re _ 1 _ 1 . done & & ( _a = patterns Re _ 1 . return ) ) _a . call ( patterns Re _ 1 ) ; } finally { if ( e _ 1 ) throw e _ 1 . error ; } } return false ; var e _ 1 , _a ; } 
function ( ) { remove Not Found Files ( ) ; var entries = normalized Entries ; var keys = Object . keys ( entries ) ; if ( keys . length = = = 0 ) { return ; } keys . for Each ( function ( entry Name ) { var cache Entry = entries [ entry Name ] ; try { var stat = fs . stat Sync ( cache Entry . key ) ; var meta = assign ( cache Entry . meta , { size : stat . size , mtime : stat . mtime . get Time ( ) } ) ; cache . set Key ( entry Name , meta ) ; } catch ( err ) { 
function fill Range ( start , stop , step , options ) { if ( typeof start = = = 'undefined ' ) { return [ ] ; } if ( typeof stop = = = 'undefined ' | | start = = = stop ) { 
function ( doc Id , cache Dir ) { var me = this ; me . _visited = { } ; me . _persisted = { } ; me . _path To File = cache Dir ? path . resolve ( cache Dir , doc Id ) : path . resolve ( _ _dirname , ' . / .cache / ' , doc Id ) ; if ( fs . exists Sync ( me . _path To File ) ) { me . _persisted = utils . try Parse ( me . _path To File , { } ) ; } } 
function ( path To File ) { var me = this ; var dir = path . dirname ( path To File ) ; var f Name = path . basename ( path To File ) ; me . load ( f Name , dir ) ; } 
function ( ) { var me = this ; var obj = { } ; var keys = Object . keys ( me . _visited ) ; 
function ( no Prune ) { var me = this ; ( ! no Prune ) & & me . _prune ( ) ; write JSON ( me . _path To File , me . _persisted ) ; } 
function ( doc Id , cache Dir ) { var obj = Object . create ( cache ) ; obj . load ( doc Id , cache Dir ) ; return obj ; } 
function ( doc Id , cache Dir ) { var file Path = cache Dir ? path . resolve ( cache Dir , doc Id ) : path . resolve ( _ _dirname , ' . / .cache / ' , doc Id ) ; return del ( file Path , { force : true } ) . length > 0 ; } 
function ( cache Name , key , val ) { var cache = this . cache ( cache Name ) ; cache . set ( key , val ) ; return cache ; } 
function ( name , key ) { var cache = this . cache ( name ) ; if ( typeof key = = = 'string ' ) { return cache . get ( key ) ; } return cache ; } 
function LOOP ( ) { 
function ignore Map ( pattern ) { var gmatcher = null if ( pattern . slice ( - 3 ) = = = ' / * * ' ) { var gpattern = pattern . replace ( / ( \ / \ * \ * ) + $ / , ' ' ) gmatcher = new Minimatch ( gpattern , { dot : true } ) } return { matcher : new Minimatch ( pattern , { dot : true } ) , gmatcher : gmatcher } } 
function make Abs ( self , f ) { var abs = f if ( f . char At ( 0 ) = = = ' / ' ) { abs = path . join ( self . root , f ) } else if ( is Absolute ( f ) | | f = = = ' ' ) { abs = f } else if ( self . changed Cwd ) { abs = path . resolve ( self . cwd , f ) } else { abs = path . resolve ( f ) } if ( process . platform = = = 'win 3 2 ' ) abs = abs . replace ( / \ \ / g , ' / ' ) return abs } 
function is Ignored ( self , path ) { if ( ! self . ignore . length ) return false return self . ignore . some ( function ( item ) { return item . matcher . match ( path ) | | ! ! ( item . gmatcher & & item . gmatcher . match ( path ) ) } ) } 
function is Buffer ( val ) { return val . constructor & & typeof val . constructor . is Buffer = = = 'function ' & & val . constructor . is Buffer ( val ) ; } 
function micromatch ( files , patterns , opts ) { if ( ! files | | ! patterns ) return [ ] ; opts = opts | | { } ; if ( typeof opts . cache = = = 'undefined ' ) { opts . cache = true ; } if ( ! Array . is Array ( patterns ) ) { return match ( files , patterns , opts ) ; } var len = patterns . length , i = 0 ; var omit = [ ] , keep = [ ] ; while ( len - - ) { var glob = patterns [ i + + ] ; if ( typeof glob = = = 'string ' & & glob . char Code At ( 0 ) = = = 3 3 ) { omit . push . apply ( omit , match ( files , glob . slice ( 1 ) , opts ) ) ; } else { keep . push . apply ( keep , match ( files , glob , opts ) ) ; } } return utils . diff ( keep , omit ) ; } 
function match ( files , pattern , opts ) { if ( utils . type Of ( files ) ! = = 'string ' & & ! Array . is Array ( files ) ) { throw new Error ( msg ( 'match ' , 'files ' , 'a string or array ' ) ) ; } files = utils . arrayify ( files ) ; opts = opts | | { } ; var negate = opts . negate | | false ; var orig = pattern ; if ( typeof pattern = = = 'string ' ) { negate = pattern . char At ( 0 ) = = = ' ! ' ; if ( negate ) { pattern = pattern . slice ( 1 ) ; } 
function filter ( patterns , opts ) { if ( ! Array . is Array ( patterns ) & & typeof patterns ! = = 'string ' ) { throw new Type Error ( msg ( 'filter ' , 'patterns ' , 'a string or array ' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length , i = 0 ; var pattern Matchers = Array ( len ) ; while ( i < len ) { pattern Matchers [ i ] = matcher ( patterns [ i + + ] , opts ) ; } return function ( fp ) { if ( fp = = null ) return [ ] ; var len = pattern Matchers . length , i = 0 ; var res = true ; fp = utils . unixify ( fp , opts ) ; while ( i < len ) { var fn = pattern Matchers [ i + + ] ; if ( ! fn ( fp ) ) { res = false ; break ; } } return res ; } ; } 
function is Match ( fp , pattern , opts ) { if ( typeof fp ! = = 'string ' ) { throw new Type Error ( msg ( 'is Match ' , 'filepath ' , 'a string ' ) ) ; } fp = utils . unixify ( fp , opts ) ; if ( utils . type Of ( pattern ) = = = 'object ' ) { return matcher ( fp , pattern ) ; } return matcher ( pattern , opts ) ( fp ) ; } 
function contains ( fp , pattern , opts ) { if ( typeof fp ! = = 'string ' ) { throw new Type Error ( msg ( 'contains ' , 'pattern ' , 'a string ' ) ) ; } opts = opts | | { } ; opts . contains = ( pattern ! = = ' ' ) ; fp = utils . unixify ( fp , opts ) ; if ( opts . contains & & ! utils . is Glob ( pattern ) ) { return fp . index Of ( pattern ) ! = = - 1 ; } return matcher ( pattern , opts ) ( fp ) ; } 
function any ( fp , patterns , opts ) { if ( ! Array . is Array ( patterns ) & & typeof patterns ! = = 'string ' ) { throw new Type Error ( msg ( 'any ' , 'patterns ' , 'a string or array ' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length ; fp = utils . unixify ( fp , opts ) ; while ( len - - ) { var is Match = matcher ( patterns [ len ] , opts ) ; if ( is Match ( fp ) ) { return true ; } } return false ; } 
function match Keys ( obj , glob , options ) { if ( utils . type Of ( obj ) ! = = 'object ' ) { throw new Type Error ( msg ( 'match Keys ' , 'first argument ' , 'an object ' ) ) ; } var fn = matcher ( glob , options ) ; var res = { } ; for ( var key in obj ) { if ( obj . has Own Property ( key ) & & fn ( key ) ) { res [ key ] = obj [ key ] ; } } return res ; } 
function matcher ( pattern , opts ) { 
function to Regex ( glob , options ) { 
function wrap Glob ( glob , opts ) { var prefix = ( opts & & ! opts . contains ) ? ' ^ ' : ' ' ; var after = ( opts & & ! opts . contains ) ? ' $ ' : ' ' ; glob = ( ' ( ? : ' + glob + ' ) ' + after ) ; if ( opts & & opts . negate ) { return prefix + ( ' ( ? ! ^ ' + glob + ' ) . * $ ' ) ; } return prefix + glob ; } 
function make Re ( glob , opts ) { if ( utils . type Of ( glob ) ! = = 'string ' ) { throw new Error ( msg ( 'make Re ' , 'glob ' , 'a string ' ) ) ; } return utils . cache ( to Regex , glob , opts ) ; } 
function expand ( pattern , options ) { if ( typeof pattern ! = = 'string ' ) { throw new Type Error ( 'micromatch .expand ( ) : argument should be a string . ' ) ; } var glob = new Glob ( pattern , options | | { } ) ; var opts = glob . options ; if ( ! utils . is Glob ( pattern ) ) { glob . pattern = glob . pattern . replace ( / ( [ \ / . ] ) / g , ' \ \ $ 1 ' ) ; return glob ; } glob . pattern = glob . pattern . replace ( / ( \ + ) ( ? ! \ ( ) / g , ' \ \ $ 1 ' ) ; glob . pattern = glob . pattern . split ( ' $ ' ) . join ( ' \ \ $ ' ) ; if ( typeof opts . braces ! = = 'boolean ' & & typeof opts . nobraces ! = = 'boolean ' ) { opts . braces = true ; } if ( glob . pattern = = = ' . * ' ) { return { pattern : ' \ \ . ' + star , tokens : tok , options : opts } ; } if ( glob . pattern = = = ' * ' ) { return { pattern : one Star ( opts . dot ) , tokens : tok , options : opts } ; } * Extended globs * / 
function collapse ( str , ch ) { var res = str . split ( ch ) ; var is First = res [ 0 ] = = = ' ' ; var is Last = res [ res . length - 1 ] = = = ' ' ; res = res . filter ( Boolean ) ; if ( is First ) res . unshift ( ' ' ) ; if ( is Last ) res . push ( ' ' ) ; return res . join ( ch ) ; } 
function negate Slash ( str ) { return str . replace ( / \ [ \ ^ ( [ ^ \ ] ] * ? ) \ ] / g , function ( match , inner ) { if ( inner . index Of ( ' / ' ) = = = - 1 ) { inner = ' \ \ / ' + inner ; } return ' [ ^ ' + inner + ' ] ' ; } ) ; } 
function balance ( str , a , b ) { var aarr = str . split ( a ) ; var alen = aarr . join ( ' ' ) . length ; var blen = str . split ( b ) . join ( ' ' ) . length ; if ( alen ! = = blen ) { str = aarr . join ( ' \ \ ' + a ) ; return str . split ( b ) . join ( ' \ \ ' + b ) ; } return str ; } 
function braces ( str , arr , options ) { if ( str = = = ' ' ) { return [ ] ; } if ( ! Array . is Array ( arr ) ) { options = arr ; arr = [ ] ; } var opts = options | | { } ; arr = arr | | [ ] ; if ( typeof opts . nodupes = = = 'undefined ' ) { opts . nodupes = true ; } var fn = opts . fn ; var es 6 ; if ( typeof opts = = = 'function ' ) { fn = opts ; opts = { } ; } if ( ! ( pattern Re instanceof Reg Exp ) ) { pattern Re = pattern Regex ( ) ; } var matches = str . match ( pattern Re ) | | [ ] ; var m = matches [ 0 ] ; switch ( m ) { case ' \ \ , ' : return escape Commas ( str , arr , opts ) ; case ' \ \ . ' : return escape Dots ( str , arr , opts ) ; case ' \ / . ' : return escape Paths ( str , arr , opts ) ; case ' ' : return split Whitespace ( str ) ; case ' { , } ' : return exponential ( str , opts , braces ) ; case ' { } ' : return empty Braces ( str , arr , opts ) ; case ' \ \ { ' : case ' \ \ } ' : return escape Braces ( str , arr , opts ) ; case ' $ { ' : if ( ! / \ { [ ^ { ] + \ { / . test ( str ) ) { return arr . concat ( str ) ; } else { es 6 = true ; str = tokens . before ( str , es 6Regex ( ) ) ; } } if ( ! ( brace Re instanceof Reg Exp ) ) { brace Re = brace Regex ( ) ; } var match = brace Re . exec ( str ) ; if ( match = = null ) { return [ str ] ; } var outter = match [ 1 ] ; var inner = match [ 2 ] ; if ( inner = = = ' ' ) { return [ str ] ; } var segs , segs Length ; if ( inner . index Of ( ' . . ' ) ! = = - 1 ) { segs = expand ( inner , opts , fn ) | | inner . split ( ' , ' ) ; segs Length = segs . length ; } else if ( inner [ 0 ] = = = ' " ' | | inner [ 0 ] = = = ' \ ' ' ) { return arr . concat ( str . split ( / [ ' " ] / ) . join ( ' ' ) ) ; } else { segs = inner . split ( ' , ' ) ; if ( opts . make Re ) { return braces ( str . replace ( outter , wrap ( segs , ' | ' ) ) , opts ) ; } segs Length = segs . length ; if ( segs Length = = = 1 & & opts . bash ) { segs [ 0 ] = wrap ( segs [ 0 ] , ' \ \ ' ) ; } } var len = segs . length ; var i = 0 , val ; while ( len - - ) { var path = segs [ i + + ] ; if ( / ( \ . [ ^ . \ / ] ) / . test ( path ) ) { if ( segs Length > 1 ) { return segs ; } else { return [ str ] ; } } val = splice ( str , outter , path ) ; if ( / \ { [ ^ { } ] + ? \ } / . test ( val ) ) { arr = braces ( val , arr , opts ) ; } else if ( val ! = = ' ' ) { if ( opts . nodupes & & arr . index Of ( val ) ! = = - 1 ) { continue ; } arr . push ( es 6 ? tokens . after ( val ) : val ) ; } } if ( opts . strict ) { return filter ( arr , filter Empty ) ; } return arr ; } 
function exponential ( str , options , fn ) { if ( typeof options = = = 'function ' ) { fn = options ; options = null ; } var opts = options | | { } ; var esc = ' _ _ESC _EXP _ _ ' ; var exp = 0 ; var res ; var parts = str . split ( ' { , } ' ) ; if ( opts . nodupes ) { return fn ( parts . join ( ' ' ) , opts ) ; } exp = parts . length - 1 ; res = fn ( parts . join ( esc ) , opts ) ; var len = res . length ; var arr = [ ] ; var i = 0 ; while ( len - - ) { var ele = res [ i + + ] ; var idx = ele . index Of ( esc ) ; if ( idx = = = - 1 ) { arr . push ( ele ) ; } else { ele = ele . split ( ' _ _ESC _EXP _ _ ' ) . join ( ' ' ) ; if ( ! ! ele & & opts . nodupes ! = = false ) { arr . push ( ele ) ; } else { var num = Math . pow ( 2 , exp ) ; arr . push . apply ( arr , repeat ( ele , num ) ) ; } } } return arr ; } 
function wrap ( val , ch ) { if ( ch = = = ' | ' ) { return ' ( ' + val . join ( ch ) + ' ) ' ; } if ( ch = = = ' , ' ) { return ' { ' + val . join ( ch ) + ' } ' ; } if ( ch = = = ' - ' ) { return ' [ ' + val . join ( ch ) + ' ] ' ; } if ( ch = = = ' \ \ ' ) { return ' \ \ { ' + val + ' \ \ } ' ; } } 
function empty Braces ( str , arr , opts ) { return braces ( str . split ( ' { } ' ) . join ( ' \ \ { \ \ } ' ) , arr , opts ) ; } 
function split Whitespace ( str ) { var segs = str . split ( ' ' ) ; var len = segs . length ; var res = [ ] ; var i = 0 ; while ( len - - ) { res . push . apply ( res , braces ( segs [ i + + ] ) ) ; } return res ; } 
function escape Braces ( str , arr , opts ) { if ( ! / \ { [ ^ { ] + \ { / . test ( str ) ) { return arr . concat ( str . split ( ' \ \ ' ) . join ( ' ' ) ) ; } else { str = str . split ( ' \ \ { ' ) . join ( ' _ _LT _BRACE _ _ ' ) ; str = str . split ( ' \ \ } ' ) . join ( ' _ _RT _BRACE _ _ ' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { ele = ele . split ( ' _ _LT _BRACE _ _ ' ) . join ( ' { ' ) ; return ele . split ( ' _ _RT _BRACE _ _ ' ) . join ( ' } ' ) ; } ) ; } } 
function escape Paths ( str , arr , opts ) { str = str . split ( ' \ / . ' ) . join ( ' _ _ESC _PATH _ _ ' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { return ele . split ( ' _ _ESC _PATH _ _ ' ) . join ( ' \ / . ' ) ; } ) ; } 
function escape Commas ( str , arr , opts ) { if ( ! / \w , / . test ( str ) ) { return arr . concat ( str . split ( ' \ \ ' ) . join ( ' ' ) ) ; } else { str = str . split ( ' \ \ , ' ) . join ( ' _ _ESC _COMMA _ _ ' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { return ele . split ( ' _ _ESC _COMMA _ _ ' ) . join ( ' , ' ) ; } ) ; } } 
function splice ( str , token , replacement ) { var i = str . index Of ( token ) ; return str . substr ( 0 , i ) + replacement + str . substr ( i + token . length ) ; } 
function filter ( arr , cb ) { if ( arr = = null ) return [ ] ; if ( typeof cb ! = = 'function ' ) { throw new Type Error ( 'braces : filter expects a callback function . ' ) ; } var len = arr . length ; var res = arr . slice ( ) ; var i = 0 ; while ( len - - ) { if ( ! cb ( arr [ len ] , i + + ) ) { res . splice ( len , 1 ) ; } } return res ; } 
function extglob ( str , opts ) { opts = opts | | { } ; var o = { } , i = 0 ; 
function wrap ( inner , prefix , esc ) { if ( esc ) inner = escape ( inner ) ; switch ( prefix ) { case ' ! ' : return ' ( ? ! ' + inner + ' ) [ ^ / ] ' + ( esc ? ' % % % ~ ' : ' * ? ' ) ; case ' @ ' : return ' ( ? : ' + inner + ' ) ' ; case ' + ' : return ' ( ? : ' + inner + ' ) + ' ; case ' * ' : return ' ( ? : ' + inner + ' ) ' + ( esc ? ' % % ' : ' * ' ) case ' ? ' : return ' ( ? : ' + inner + ' | ) ' ; default : return inner ; } } 
function to Regex ( pattern , contains , is Negated ) { var prefix = contains ? ' ^ ' : ' ' ; var after = contains ? ' $ ' : ' ' ; pattern = ( ' ( ? : ' + pattern + ' ) ' + after ) ; if ( is Negated ) { pattern = prefix + negate ( pattern ) ; } return new Reg Exp ( prefix + pattern ) ; } 
function copy ( val , key ) { if ( key = = = ' _ _proto _ _ ' ) { return ; } var obj = this [ key ] ; if ( is Object ( val ) & & is Object ( obj ) ) { mixin Deep ( obj , val ) ; } else { this [ key ] = val ; } } 
function advance To ( input , end Char ) { var ch = input . char At ( 0 ) ; var tok = { len : 1 , val : ' ' , esc : ' ' } ; var idx = 0 ; function advance ( ) { if ( ch ! = = ' \ \ ' ) { tok . esc + = ' \ \ ' + ch ; tok . val + = ch ; } ch = input . char At ( + + idx ) ; tok . len + + ; if ( ch = = = ' \ \ ' ) { advance ( ) ; advance ( ) ; } } while ( ch & & ch ! = = end Char ) { advance ( ) ; } return tok ; } 
function create Text Regex ( pattern ) { if ( cached ) return cached ; var opts = { contains : true , strict Close : false } ; var not = regex Not . create ( pattern , opts ) ; var re = to Regex ( ' ^ ( ? : [ * ] \ \ ( ( ? = . ) | ' + not + ' ) ' , opts ) ; return ( cached = re ) ; } 
function postcss ( ) { for ( var _len = arguments . length , plugins = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { plugins [ _key ] = arguments [ _key ] ; } if ( plugins . length = = = 1 & & Array . is Array ( plugins [ 0 ] ) ) { plugins = plugins [ 0 ] ; } return new _processor 2 . default ( plugins ) ; } 
function Basic Source Map Consumer ( a Source Map , a Source Map URL ) { var source Map = a Source Map ; if ( typeof a Source Map = = = 'string ' ) { source Map = util . parse Source Map Input ( a Source Map ) ; } var version = util . get Arg ( source Map , 'version ' ) ; var sources = util . get Arg ( source Map , 'sources ' ) ; 
function compare By Original Positions ( mapping A , mapping B , only Compare Original ) { var cmp = strcmp ( mapping A . source , mapping B . source ) ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . original Line - mapping B . original Line ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . original Column - mapping B . original Column ; if ( cmp ! = = 0 | | only Compare Original ) { return cmp ; } cmp = mapping A . generated Column - mapping B . generated Column ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . generated Line - mapping B . generated Line ; if ( cmp ! = = 0 ) { return cmp ; } return strcmp ( mapping A . name , mapping B . name ) ; } 
function compare By Generated Positions Deflated ( mapping A , mapping B , only Compare Generated ) { var cmp = mapping A . generated Line - mapping B . generated Line ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . generated Column - mapping B . generated Column ; if ( cmp ! = = 0 | | only Compare Generated ) { return cmp ; } cmp = strcmp ( mapping A . source , mapping B . source ) ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . original Line - mapping B . original Line ; if ( cmp ! = = 0 ) { return cmp ; } cmp = mapping A . original Column - mapping B . original Column ; if ( cmp ! = = 0 ) { return cmp ; } return strcmp ( mapping A . name , mapping B . name ) ; } 
function compute Source URL ( source Root , source URL , source Map URL ) { source URL = source URL | | ' ' ; if ( source Root ) { 
function Corked Request ( state ) { var _this = this ; this . next = null ; this . entry = null ; this . finish = function ( ) { on Corked Finish ( _this , state ) ; } ; } 
function clear Buffer ( stream , state ) { state . buffer Processing = true ; var entry = state . buffered Request ; if ( stream . _writev & & entry & & entry . next ) { 
function destroy ( err , cb ) { var _this = this ; var readable Destroyed = this . _readable State & & this . _readable State . destroyed ; var writable Destroyed = this . _writable State & & this . _writable State . destroyed ; if ( readable Destroyed | | writable Destroyed ) { if ( cb ) { cb ( err ) ; } else if ( err & & ( ! this . _writable State | | ! this . _writable State . error Emitted ) ) { pna . next Tick ( emit Error NT , this , err ) ; } return this ; } 
function Node ( val , type , parent ) { if ( typeof type ! = = 'string ' ) { parent = type ; type = null ; } define ( this , 'parent ' , parent ) ; define ( this , 'is Node ' , true ) ; define ( this , 'expect ' , null ) ; if ( typeof type ! = = 'string ' & & is Object ( val ) ) { lazy Keys ( ) ; var keys = Object . keys ( val ) ; for ( var i = 0 ; i < keys . length ; i + + ) { var key = keys [ i ] ; if ( own Names . index Of ( key ) = = = - 1 ) { this [ key ] = val [ key ] ; } } } else { this . type = type ; this . val = val ; } } 
function append ( compiler , val , node ) { if ( typeof compiler . append ! = = 'function ' ) { return compiler . emit ( val , node ) ; } return compiler . append ( val , node ) ; } 
function Snapdragon ( options ) { Base . call ( this , null , options ) ; this . options = utils . extend ( { source : 'string ' } , this . options ) ; this . compiler = new Compiler ( this . options ) ; this . parser = new Parser ( this . options ) ; Object . define Property ( this , 'compilers ' , { get : function ( ) { return this . compiler . compilers ; } } ) ; Object . define Property ( this , 'parsers ' , { get : function ( ) { return this . parser . parsers ; } } ) ; Object . define Property ( this , 'regex ' , { get : function ( ) { return this . parser . regex ; } } ) ; } 
function Compiler ( options , state ) { debug ( 'initializing ' , _ _filename ) ; this . options = utils . extend ( { source : 'string ' } , options ) ; this . state = state | | { } ; this . compilers = { } ; this . output = ' ' ; this . set ( 'eos ' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; this . set ( 'noop ' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; this . set ( 'bos ' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; use ( this ) ; } 
function ( msg , node ) { var pos = node . position | | { start : { column : 0 } } ; var message = this . options . source + ' column : ' + pos . start . column + ' : ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . column = pos . start . column ; err . source = this . pattern ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } } 
function ( node , nodes , i ) { var fn = this . compilers [ node . type ] ; this . idx = i ; if ( typeof fn ! = = 'function ' ) { throw this . error ( 'compiler " ' + node . type + ' " is not registered ' , node ) ; } return fn . call ( this , node , nodes , i ) ; } 
function ( nodes ) { if ( ! Array . is Array ( nodes ) ) { throw new Type Error ( 'expected an array ' ) ; } var len = nodes . length ; var idx = - 1 ; while ( + + idx < len ) { this . visit ( nodes [ idx ] , nodes , idx ) ; } return this ; } 
function ( ast , options ) { var opts = utils . extend ( { } , this . options , options ) ; this . ast = ast ; this . parsing Errors = this . ast . errors ; this . output = ' ' ; 
function Parser ( options ) { debug ( 'initializing ' , _ _filename ) ; this . options = utils . extend ( { source : 'string ' } , options ) ; this . init ( this . options ) ; use ( this ) ; } 
function ( ) { var start = { line : this . line , column : this . column } ; var self = this ; return function ( node ) { define ( node , 'position ' , new Position ( start , self ) ) ; return node ; } ; } 
function ( type , fn ) { if ( this . types . index Of ( type ) = = = - 1 ) { this . types . push ( type ) ; } this . parsers [ type ] = fn . bind ( this ) ; return this ; } 
function ( type , token ) { this . sets [ type ] = this . sets [ type ] | | [ ] ; this . count + + ; this . stack . push ( token ) ; return this . sets [ type ] . push ( token ) ; } 
function ( type ) { this . sets [ type ] = this . sets [ type ] | | [ ] ; this . count - - ; this . stack . pop ( ) ; return this . sets [ type ] . pop ( ) ; } 
function ( n ) { return this . stack . length > 0 ? utils . last ( this . stack , n ) : utils . last ( this . nodes , n ) ; } 
function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . line + = lines . length ; var i = str . last Index Of ( ' \n ' ) ; this . column = ~ i ? len - i : this . column + len ; this . parsed + = str ; this . consume ( len ) ; } 
function ( type , regex ) { if ( typeof regex = = = 'function ' ) { return this . set . apply ( this , arguments ) ; } this . regex . set ( type , regex ) ; this . set ( type , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( regex ) ; if ( ! m | | ! m [ 0 ] ) return ; var prev = this . prev ( ) ; var node = pos ( { type : type , val : m [ 0 ] , parsed : parsed , rest : this . input } ) ; if ( m [ 1 ] ) { node . inner = m [ 1 ] ; } define ( node , 'inside ' , this . stack . length > 0 ) ; define ( node , 'parent ' , prev ) ; prev . nodes . push ( node ) ; } . bind ( this ) ) ; return this ; } 
function ( type , open Regex , close Regex , fn ) { this . sets [ type ] = this . sets [ type ] | | [ ] ; this . set ( type + ' .open ' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( open Regex ) ; if ( ! m | | ! m [ 0 ] ) return ; var val = m [ 0 ] ; this . set Count + + ; this . special Chars = true ; var open = pos ( { type : type + ' .open ' , val : val , rest : this . input } ) ; if ( typeof m [ 1 ] ! = = 'undefined ' ) { open . inner = m [ 1 ] ; } var prev = this . prev ( ) ; var node = pos ( { type : type , nodes : [ open ] } ) ; define ( node , 'rest ' , this . input ) ; define ( node , 'parsed ' , parsed ) ; define ( node , 'prefix ' , m [ 1 ] ) ; define ( node , 'parent ' , prev ) ; define ( open , 'parent ' , node ) ; if ( typeof fn = = = 'function ' ) { fn . call ( this , open , node ) ; } this . push ( type , node ) ; prev . nodes . push ( node ) ; } ) ; this . set ( type + ' .close ' , function ( ) { var pos = this . position ( ) ; var m = this . match ( close Regex ) ; if ( ! m | | ! m [ 0 ] ) return ; var parent = this . pop ( type ) ; var node = pos ( { type : type + ' .close ' , rest : this . input , suffix : m [ 1 ] , val : m [ 0 ] } ) ; if ( ! this . is Type ( parent , type ) ) { if ( this . options . strict ) { throw new Error ( 'missing opening " ' + type + ' " ' ) ; } this . set Count - - ; node . escaped = true ; return node ; } if ( node . suffix = = = ' \ \ ' ) { parent . escaped = true ; node . escaped = true ; } parent . nodes . push ( node ) ; define ( node , 'parent ' , parent ) ; } ) ; return this ; } 
function ( ) { var pos = this . position ( ) ; if ( this . input ) return ; var prev = this . prev ( ) ; while ( prev . type ! = = 'root ' & & ! prev . visited ) { if ( this . options . strict = = = true ) { throw new Syntax Error ( 'invalid syntax : ' + util . inspect ( prev , null , 2 ) ) ; } if ( ! has Delims ( prev ) ) { prev . parent . escaped = true ; prev . escaped = true ; } visit ( prev , function ( node ) { if ( ! has Delims ( node . parent ) ) { node . parent . escaped = true ; node . escaped = true ; } } ) ; prev = prev . parent ; } var tok = pos ( { type : 'eos ' , val : this . append | | ' ' } ) ; define ( tok , 'parent ' , this . ast ) ; return tok ; } 
function ( ) { var parsed = this . parsed ; var len = this . types . length ; var idx = - 1 ; var tok ; while ( + + idx < len ) { if ( ( tok = this . parsers [ this . types [ idx ] ] . call ( this ) ) ) { define ( tok , 'rest ' , this . input ) ; define ( tok , 'parsed ' , parsed ) ; this . last = tok ; return tok ; } } } 
function ( input ) { if ( typeof input ! = = 'string ' ) { throw new Type Error ( 'expected a string ' ) ; } this . init ( this . options ) ; this . orig = input ; this . input = input ; var self = this ; function parse ( ) { 
function visit ( node , fn ) { if ( ! node . visited ) { define ( node , 'visited ' , true ) ; return node . nodes ? map Visit ( node . nodes , fn ) : fn ( node ) ; } return node ; } 
function mixin ( compiler ) { define ( compiler , ' _comment ' , compiler . comment ) ; compiler . map = new utils . Source Map . Source Map Generator ( ) ; compiler . position = { line : 1 , column : 1 } ; compiler . content = { } ; compiler . files = { } ; for ( var key in exports ) { define ( compiler , key , exports [ key ] ) ; } } 
function utf 8End ( buf ) { var r = buf & & buf . length ? this . write ( buf ) : ' ' ; if ( this . last Need ) return r + ' \ufffd ' ; return r ; } 
function range To Pattern ( start , stop , options ) { if ( start = = = stop ) { return { pattern : String ( start ) , digits : [ ] } ; } var zipped = zip ( String ( start ) , String ( stop ) ) ; var len = zipped . length , i = - 1 ; var pattern = ' ' ; var digits = 0 ; while ( + + i < len ) { var numbers = zipped [ i ] ; var start Digit = numbers [ 0 ] ; var stop Digit = numbers [ 1 ] ; if ( start Digit = = = stop Digit ) { pattern + = start Digit ; } else if ( start Digit ! = = ' 0 ' | | stop Digit ! = = ' 9 ' ) { pattern + = to Character Class ( start Digit , stop Digit ) ; } else { digits + = 1 ; } } if ( digits ) { pattern + = options . shorthand ? ' \ \d ' : ' [ 0 - 9 ] ' ; } return { pattern : pattern , digits : [ digits ] } ; } 
function zip ( a , b ) { var arr = [ ] ; for ( var ch in a ) arr . push ( [ a [ ch ] , b [ ch ] ] ) ; return arr ; } 
function use ( type , fn , options ) { var offset = 1 ; if ( typeof type = = = 'string ' | | Array . is Array ( type ) ) { fn = wrap ( type , fn ) ; offset + + ; } else { options = fn ; fn = type ; } if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'expected a function ' ) ; } var self = this | | app ; var fns = self [ prop ] ; var args = [ ] . slice . call ( arguments , offset ) ; args . unshift ( self ) ; if ( typeof opts . hook = = = 'function ' ) { opts . hook . apply ( self , args ) ; } var val = fn . apply ( self , args ) ; if ( typeof val = = = 'function ' & & fns . index Of ( val ) = = = - 1 ) { fns . push ( val ) ; } return self ; } 
function wrap ( type , fn ) { return function plugin ( ) { return this . type = = = type ? fn . apply ( this , arguments ) : plugin ; } ; } 
function process Arguments ( ) { var arg ; for ( var i = 2 ; i < process . argv . length ; + + i ) { arg = process . argv [ i ] ; if ( arg = = = " -l " | | arg = = = " -log " ) enable Log = true ; else if ( arg = = = " -m " | | arg = = = " - -minify " ) enable Minify = true ; else if ( arg = = = " -f " | | arg = = = " - -folder " ) input Is Folder = true ; else if ( arg = = = " -s " | | arg = = = " - -silent " ) enable Silent = true ; else if ( arg = = = " -i " | | arg = = = " - -input " ) input = process . argv [ + + i ] ; else if ( arg = = = " -o " | | arg = = = " - -output " ) output = process . argv [ + + i ] ; else if ( arg = = = " -e " | | arg = = = " - -ensure " ) include Inq = true ; else if ( arg = = = " -d " | | arg = = = " - -define " ) definitions = process . argv [ + + i ] . split ( ' ' ) ; else console . error ( " [WARNING ] Unknown compiler flag : " + arg ) ; } if ( ! output ) output = input + ( input Is Folder ? " " : " .js " ) ; return ! ! input ; } 
function try Init ( ) { var temp , i , files ; if ( ! processors . length ) { var processors Path = path . resolve ( _ _dirname , "processor " ) ; files = fs . readdir Sync ( processors Path ) ; for ( i = 0 ; i < files . length ; + + i ) { temp = require ( path . resolve ( processors Path , files [ i ] ) ) ; processors . push ( temp ) ; processors Named [ temp . name ] = temp ; } } if ( ! complex Expressions . length ) { var expressions Path = path . resolve ( _ _dirname , "combination " ) ; files = fs . readdir Sync ( expressions Path ) ; for ( i = 0 ; i < files . length ; + + i ) { temp = require ( path . resolve ( expressions Path , files [ i ] ) ) ; complex Expressions [ temp . name ] = temp . value ; } } } 
function Cal Event ( name , start Date , end Date , description , location , uid ) { if ( start Date instanceof Date ) { this . start Date = start Date ; } else { return null ; } if ( end Date instanceof Date ) { this . end Date = end Date ; } else { return null ; } this . uid = uid = = null ? ( util . guid ( ) + ' @node -cal -event .js ' ) : uid ; this . summary = name ; this . location = location ; this . description = description ; } 
function ask ( questions ) { "use strict " ; let answers = { } ; let i = 0 ; return new Promise ( function ( resolve , reject ) { function ask Question ( item ) { let key = item . key ; let msg = item . msg ; let fn = fn List [ item . fn ] ; if ( ! key ) { throw new Error ( 'A value for `key ` must be defined for question ' + i ) ; } if ( ! msg ) { throw new Error ( 'A value for `msg ` must be defined for question ' + i ) ; } if ( ! fn ) { throw new Error ( 'A value for `fn ` must be "prompt " , "confirm " , or "multiline " for question ' + i ) ; } if ( fn ) { fn ( msg , key , answers ) . then ( function ( ) { next ( ) ; } ) ; } } function next ( ) { if ( i < questions . length ) { var question = questions [ i ] ; i + + ; ask Question ( question ) ; } else { resolve ( answers ) ; } } next ( ) ; } ) ; } 
function promise Fn ( msg , key , answers , fn ) { "use strict " ; answers = answers | | { } ; return fn ( msg ) . then ( function ( resp ) { answers [ key ] = resp ; return answers ; } ) ; } 
function http Middleware ( req , res , arr , done ) { done = done | | noop assert . ok ( is Req ( req ) , 'is incoming message ' ) assert . ok ( is Res ( res ) , 'is server response ' ) assert . ok ( Array . is Array ( arr ) , 'is array ' ) assert . equal ( typeof done , 'function ' , 'is function ' ) map Limit ( arr , 1 , iterator , done ) function iterator ( fn , next ) { next = dezalgo ( next ) if ( fn . length = = = 3 ) return fn ( req , res , next ) fn ( req , res ) next ( ) } } 
function memoize ( fun ) { 
function generate Detach Tasks ( planner , origin , opts ) { _ . for In ( origin . topology . containers , function ( container ) { var stop Sub Task = { cmd : 'stop ' , id : container . id , parent : container . contained By } ; var remove Sub Task = { cmd : 'remove ' , id : container . id , parent : container . contained By } ; var unlink Sub Task = { cmd : 'unlink ' , id : container . id , parent : container . contained By } ; var detach Op = { preconditions : container Status ( container , 'running ' ) , sub Tasks : [ unlink Sub Task , stop Sub Task , remove Sub Task ] } ; var unlink Preconditions = container Status ( container , 'running ' ) ; var stop Precondition = container Status ( container , 'started ' ) ; var remove Precondition = container Status ( container , 'added ' ) ; container . contains . for Each ( function ( contained ) { var status = container Status ( { id : contained } , 'started ' ) ; stop Precondition = _ . merge ( stop Precondition , status ) ; detach Op . sub Tasks . splice ( 1 , 0 , { cmd : 'detach ' , id : contained } ) ; } ) ; if ( opts . mode = = = 'safe ' ) { all Parents Ids ( origin , container ) . for Each ( function ( id ) { detach Op . sub Tasks . unshift ( { cmd : 'unlink ' , id : id , parent : origin . topology . containers [ id ] . contained By } ) ; detach Op . sub Tasks . push ( { cmd : 'link ' , id : id , parent : origin . topology . containers [ id ] . contained By } ) ; } ) ; } planner . add Task ( { cmd : 'detach ' , id : container . id } , { preconditions : container Status ( container , 'detached ' ) , sub Tasks : [ { cmd : 'nop ' } ] } ) ; planner . add Task ( { cmd : 'detach ' , id : container . id } , detach Op ) ; planner . add Task ( unlink Sub Task , { preconditions : unlink Preconditions , effects : container Status ( container , { running : false } ) } ) ; planner . add Task ( unlink Sub Task , { preconditions : container Status ( container , { running : false } ) , sub Tasks : [ { cmd : 'nop ' } ] } ) ; planner . add Task ( stop Sub Task , { preconditions : container Status ( container , 'started ' ) , effects : container Status ( container , 'added ' ) } ) ; planner . add Task ( stop Sub Task , { preconditions : container Status ( container , { running : false , started : false } ) , sub Tasks : [ { cmd : 'nop ' } ] } ) ; planner . add Task ( remove Sub Task , { preconditions : remove Precondition , effects : container Status ( container , 'detached ' ) } ) ; planner . add Task ( remove Sub Task , { preconditions : container Status ( container , 'detached ' ) , sub Tasks : [ { cmd : 'nop ' } ] } ) ; } ) ; } 
function keyblade ( obj , opts ) { opts = Object . assign ( { message : _default Message , log Before Throw : true , ignore : [ ] } , opts ) opts . ignore = ( opts . ignore & & Array . is Array ( opts . ignore ) ) ? opts . ignore : [ ] return new Proxy ( obj , { get ( target , prop Key , receiver ) { const use Getter = Reflect . has ( target , prop Key , receiver ) | | _is Reserved ( prop Key , opts . ignore ) if ( use Getter ) { return Reflect . get ( target , prop Key , receiver ) } 
function pcorr ( ) { var args , n Args , len , deltas , delta , means , stdevs , C , cov , corr , arr , N , r , A , B , sum , val , sigma , i , j , n ; args = Array . prototype . slice . call ( arguments ) ; n Args = args . length ; if ( ! n Args ) { throw new Error ( 'pcorr ( ) : :insufficient input arguments . Must provide array arguments . ' ) ; } for ( i = 0 ; i < n Args ; i + + ) { if ( ! Array . is Array ( args [ i ] ) ) { throw new Type Error ( 'pcorr ( ) : :invalid input argument . Must provide array arguments . ' ) ; } } if ( Array . is Array ( args [ 0 ] [ 0 ] ) ) { 
function sub Register ( obj , name ) { var res ; res = is Primitive ( obj [ name ] ) ? { } : obj [ name ] ; return obj [ name ] = mixable ( res ) . mixin ( proto , 'register ' , 'extend ' ) ; } 
function register Mod ( leaf , dir , name ) { var mod Path ; try { mod Path = require . resolve ( dir ) ; } catch ( _error ) { } if ( mod Path = = null ) { return false ; } 
function register Dir ( leaf , dir , name ) { var files ; try { files = fs . readdir Sync ( dir ) ; } catch ( _error ) { } if ( files = = null ) { return false ; } if ( name ! = null ) { leaf = sub Register ( leaf , name ) ; } for ( var i = 0 , len = files . length ; i < len ; i + + ) { name = files [ i ] ; leaf . register ( dir , name ) ; } return true ; } 
function register ( root ) { var leaf = this ; 
function apply Middleware ( socket , req , done ) { 
function generate Configure Tasks ( planner , origin , dest , opts ) { _ . for In ( dest . topology . containers , function ( container ) { var add Sub Task = { cmd : 'add ' , id : container . id , parent : container . contained By } ; var start Sub Task = { cmd : 'start ' , id : container . id , parent : container . contained By } ; var link Sub Task = { cmd : 'link ' , id : container . id , parent : container . contained By } ; var configure Op = { preconditions : container Status ( container , 'detached ' ) , sub Tasks : [ add Sub Task , start Sub Task , link Sub Task ] } ; var configure Nop = { preconditions : container Status ( container , 'started ' ) , sub Tasks : [ { cmd : 'nop ' } ] } ; var add Preconditions = container Status ( container , 'detached ' ) ; var link Preconditions = container Status ( container , { started : true , running : false } ) ; var old Container = origin . topology . containers [ container . id ] ; if ( old Container ) { 
function all Parents Ids ( context , container , parents ) { var is Leaf = parents = = = undefined ; parents = parents | | [ ] ; 
function container Status ( original , status , parent ) { var state = { topology : { containers : { } } } ; var container = { id : original . id } ; if ( parent = = = null ) { 
function ( opt ) { Event Emitter . call ( this ) ; opt = opt | | { } ; 
async function lstat Files ( dir Path , dir Content ) { const read Files = dir Content . map ( async ( relative Path ) = > { const path = join ( dir Path , relative Path ) const ls = await make Promise ( lstat , path ) return { lstat : ls , path , relative Path , } } ) const res = await Promise . all ( read Files ) return res } 
async function read Dir Structure ( dir Path ) { if ( ! dir Path ) { throw new Error ( 'Please specify a path to the directory ' ) } const ls = await make Promise ( lstat , dir Path ) if ( ! ls . is Directory ( ) ) { const err = new Error ( 'Path is not a directory ' ) err . code = 'ENOTDIR ' throw err } const dir = ( await make Promise ( readdir , dir Path ) ) const lsr = await lstat Files ( dir Path , dir ) const directories = lsr . filter ( is Directory ) 
function parse Policies ( input ) { var type = typeof input ; if ( type = = = 'object ' ) { for ( var i in input ) { input [ i ] = this . parse Policies ( input [ i ] ) ; } return input ; } if ( type = = = 'string ' ) { var parsed String = esprima . parse ( input ) . body [ 0 ] . expression ; return this . parse Esprima ( parsed String ) ; } return input ; } 
function parse Esprima ( input , from Factory ) { var type = input . type ; if ( type = = = esprima Type . value ) { return input . value ; } if ( type = = = esprima Type . policy ) { var policy Name = input . name ; if ( from Factory ) { return require ( sails . config . paths . policies + ' / ' + policy Name ) ; } return policy Name ; } if ( type = = = esprima Type . factory ) { var factory Name = input . callee . name ; try { var factory = require ( sails . config . paths . policy Factories + ' / ' + factory Name ) ; } catch ( e ) { return require ( sails . config . paths . policies + ' / ' + factory Name ) ; } var args = input . arguments . map ( function ( arg ) { return this . parse Esprima ( arg , true ) ; } , this ) ; return factory . apply ( this , args ) ; } throw new Error ( 'esprima type unhandled : ' + type ) ; } 
function property Name To Attribute ( name ) { var result = name . replace ( / ( [A -Z ] ) / g , function ( match , letter ) { return ' - ' + letter . to Lower Case ( ) ; } ) ; return 'data - ' + result ; } 
function generate Commands ( origin , dest ) { var dest Cmds = _ . chain ( dest . topology . containers ) . values ( ) . filter ( function ( container ) { return container . contained By = = = container . id | | ! container . contained By ; } ) . map ( function ( container ) { return { cmd : 'configure ' , id : container . id } ; } ) . value ( ) ; var origin Cmds = _ . chain ( origin . topology . containers ) . values ( ) . map ( function ( container ) { if ( ! dest . topology . containers [ container . id ] ) { return { cmd : 'detach ' , id : container . id } ; } return null ; } ) . filter ( function ( container ) { return container ! = = null ; } ) . value ( ) ; return dest Cmds . concat ( origin Cmds ) ; } 
function class _ 1 ( ) { var args = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i + + ) { args [ _i ] = arguments [ _i ] ; } var _this = _super . apply ( this , args [ 0 ] . injector . args ( Class ) ) | | this ; var params = args [ 0 ] ; _this . _injector = params . injector ; _this . _store = params . store ; _this . _aggregates = params . aggregates ; _this . _view Handlers = params . view Handlers ; _this . _logger = _this . _injector . get ( Logger ) ; return _this ; } 
function _param ( req , key , _default ) { var src = req . params [ key ] ; if ( src = = = undefined ) { src = req . body [ key ] ; } if ( src = = = undefined ) { src = req . query [ key ] ; } if ( src = = = undefined ) { src = _default ; } return src ; } 
function Limon ( input , options ) { if ( ! ( this instanceof Limon ) ) { return new Limon ( input , options ) } lazy . use ( this , { fn : function ( app , opts ) { app . options = lazy . utils . extend ( app . options , opts ) } } ) this . defaults ( input , options ) this . use ( lazy . plugin . prev Next ( ) ) } 
function col Letter To Number ( letters ) { var number = 0 , i = 0 ; for ( i = 0 ; i < letters . length ; i + = 1 ) { 
function planner ( origin , dest , opts ) { var tasks = new Task Planner ( ) ; var cmds = generate Commands ( origin , dest ) ; var state = _ . clone Deep ( origin ) ; var result ; opts = xtend ( defaults , opts ) ; assert ( opts . mode = = = 'quick ' | | opts . mode = = = 'safe ' , 'unknown mode ' ) ; tasks . add Task ( { cmd : 'nop ' } , { } ) ; generate Detach Tasks ( tasks , origin , opts ) ; generate Detach Tasks ( tasks , dest , opts ) ; 
function replace Blocks ( file , blocks ) { blocks . for Each ( block = > { const index = file . search ( block [ 0 ] ) ; if ( index > - 1 ) { 
function link Unlink Filter ( list ) { var skip Next ; var needs Filtering = true ; function do Filter ( cmd , i , cmds ) { if ( skip Next ) { skip Next = false ; return false ; } if ( ! cmds [ i + 1 ] ) { return true ; } if ( cmds [ i + 1 ] . id ! = = cmd . id ) { return true ; } var unlink Link = ( cmd . cmd = = = 'unlink ' & & cmds [ i + 1 ] . cmd = = = 'link ' ) ; var link Unlink = ( cmd . cmd = = = 'link ' & & cmds [ i + 1 ] . cmd = = = 'unlink ' ) ; if ( link Unlink | | unlink Link ) { needs Filtering = true ; skip Next = true ; return false ; } return true ; } while ( needs Filtering ) { needs Filtering = false ; skip Next = false ; list = list . filter ( do Filter ) ; } return list ; } 
function ( branch Name ) { var story Id = extract Story Id ( branch Name ) , command String ; argv . message = ' " ' + get Human Readable Story Id ( story Id ) + ' - ' + argv . message + ' " ' ; command String = compile Command String ( 'git ' ) ; return execute Command ( command String ) . fail ( function ( failure ) { if ( ! sjl . empty ( failure ) ) { log ( failure ) ; } } ) ; } 
function ( ) { return new Promise ( function ( resolve , reject ) { board . on ( 'ready ' , function ( ) { var strip = new pixel . Strip ( { data : 6 , length : 1 2 , board : this , controller : "FIRMATA " } ) ; strip . on ( 'ready ' , function ( ) { resolve ( strip ) ; } ) ; } ) ; } ) ; } 
function ( strip ) { if ( ! strip ) { console . log ( messaging Texts . no Strip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messaging Texts . wrong Strip ) ; } pattern . reset ( strip , interval ) ; interval = pattern . domino ( strip , 'white ' ) ; } 
function ( strip ) { if ( ! strip ) { console . log ( messaging Texts . no Strip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messaging Texts . wrong Strip ) ; } pattern . reset ( strip , interval ) ; set Timeout ( function ( ) { pattern . flash ( strip , 'green ' , 2 ) ; } , 1 0 ) ; } 
function clone Any Node ( element , deep ) { switch ( element . node Type ) { case _Node 2 [ 'default ' ] . DOCUMENT _FRAGMENT _NODE : return clone Document Fragment ( element , deep ) ; case _Node 2 [ 'default ' ] . ELEMENT _NODE : return clone Element Node ( element , deep ) ; case _Node 2 [ 'default ' ] . TEXT _NODE : return clone Text Node ( element ) ; default : throw new _DOMException 2 [ 'default ' ] ( _DOMException 2 [ 'default ' ] . DATA _CLONE _ERR ) ; } } 
function try Init ( ) { if ( ! processors . length ) { var processors Path = path . resolve ( _ _dirname , "processor " ) ; var files = fs . readdir Sync ( processors Path ) ; for ( var i = 0 ; i < files . length ; + + i ) { var processor = require ( path . resolve ( processors Path , files [ i ] ) ) ; 
function clone Any Node ( element , deep ) { switch ( element . node Type ) { case Node . DOCUMENT _FRAGMENT _NODE : return clone Document Fragment ( element , deep ) ; case Node . ELEMENT _NODE : return clone Element Node ( element , deep ) ; case Node . TEXT _NODE : return clone Text Node ( element ) ; default : throw new DOMException ( DOMException . DATA _CLONE _ERR ) ; } } 
function class _ 1 ( ) { var args = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i + + ) { args [ _i ] = arguments [ _i ] ; } var _this = _super . apply ( this , args [ 0 ] . injector . args ( Class ) ) | | this ; var params = args [ 0 ] ; _this . _injector = params . injector ; _this . _store = params . store ; _this . _transports = params . transports ; _this . _aggregate = params . aggregate ; _this . _logger = _this . _injector . get ( Logger ) ; return _this ; } 
function process Rules ( element , rules ) { if ( rules . type = = = 'selectors ' ) { return process Selectors ( element , rules . selectors ) ; } else if ( rules . type = = = 'rule Set ' ) { return process Rule ( element , rules . rule ) ; } } 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) if ( ! options . venue _id ) throw new Error ( 'venue _id required to make subvenue api calls ' ) return ngin . Venue . url Root ( ) + ' / ' + options . venue _id + ' /subvenues ' } 
function fetch Config ( filename ) { var data ; filename = path . resolve ( filename ) ; try { data = fs . read File Sync ( filename , 'utf - 8 ' ) ; } catch ( e ) { console . error ( 'Config read error : ' + e ) ; process . exit ( 2 ) ; } try { data = JSON . parse ( data ) ; } catch ( e ) { console . error ( 'Config parse error : ' + e ) ; process . exit ( 2 ) ; } return { filename : filename , path : path . dirname ( filename ) , data : data } ; } 
function Router ( routes ) { this . _routes = [ ] ; this . _not _found = null ; this . _not _found _path = ' / 4 0 4 ' ; if ( arguments . length = = = 1 ) { this . add Routes ( routes ) ; } } 
function Hmif ( config , status , log ) { if ( ! ( this instanceof Hmif ) ) return new Hmif ( config , status , log ) ; if ( ! log ) { log = { } ; log . debug = log . info = log . warn = log . error = log . set Level = function ( ) { } ; } var that = this ; this . status = status ; this . status . homematic = { interfaces : { } } ; if ( ! config ) return ; this . config = config ; log . info ( pkg . name + ' ' + pkg . version + ' starting ' ) ; this . _iface = { } ; this . _values = { } ; this . _paramset Descriptions = pjson . load ( 'paramset Descriptions .json ' ) | | { } ; this . _names = { } ; var xmlrpc Server ; var binrpc Server ; function meta ( params ) { var iface = params [ 0 ] ; var address = params [ 1 ] ; var datapoint = params [ 2 ] ; var value = params [ 3 ] ; var dev = that . _iface [ iface ] . devices [ address ] ; var ident = paramset Ident ( dev , 'VALUES ' ) ; var desc = that . _paramset Descriptions [ ident ] [ datapoint ] ; var meta = { } ; if ( address . index Of ( ' : ' ) ! = = - 1 ) { meta . channel Name = that . _names [ address ] ; meta . device Name = that . _names [ address . replace ( / : [ 0 - 9 ] + $ / , ' ' ) ] ; } else { meta . device Name = that . _names [ address . replace ( / : [ 0 - 9 ] + $ / , ' ' ) ] ; } if ( desc . TYPE = = = 'ENUM ' ) meta . enum Value = desc . VALUE _LIST [ value ] ; return meta ; } function paramset Ident ( dev , paramset ) { var ident = ' ' ; if ( dev . PARENT _TYPE ) ident = ident + dev . PARENT _TYPE + ' / ' ; ident = ident + dev . TYPE ; if ( dev . SUBTYPE ) ident = ident + ' / ' + dev . SUBTYPE ; ident = ident + ' / ' + dev . VERSION + ' / ' + paramset ; return ident ; } function get Paramset Descriptions ( iface ) { var calls = [ ] ; var requests = [ ] ; Object . keys ( that . _iface [ iface ] . devices ) . for Each ( function ( address ) { var dev = that . _iface [ iface ] . devices [ address ] ; dev . PARAMSETS . for Each ( function ( paramset ) { var ident = paramset Ident ( dev , paramset ) ; if ( ( ! that . _paramset Descriptions [ ident ] ) & & ( requests . index Of ( ident ) = = = - 1 ) ) { requests . push ( ident ) ; calls . push ( function ( cb ) { log . debug ( 'get Paramset Description ' , ident ) ; that . _iface [ iface ] . rpc . method Call ( 'get Paramset Description ' , [ dev . ADDRESS , paramset ] , function ( err , res ) { if ( ! err ) { that . _paramset Descriptions [ ident ] = res ; } else { log . error ( err ) ; } cb ( ) ; } ) ; } ) ; } } ) } ) ; async . series ( calls , function ( ) { log . debug ( 'get Paramset Descriptions ' , iface , 'done ' ) ; pjson . save ( 'paramset Descriptions .json ' , that . _paramset Descriptions ) ; } ) ; } this . methods = { 'system .multicall ' : function multicall ( err , params , callback ) { log . debug ( 'rpc < system .multicall ' , err , ' ( ' + params [ 0 ] . length + ' ) ' ) ; var res = [ ] ; params [ 0 ] . for Each ( function ( c ) { that . methods . event ( null , c . params ) ; res . push ( ' ' ) ; } ) ; log . debug ( 're > ' , null , res ) ; callback ( null , res ) ; } , 'system .list Methods ' : function list Methods ( err , params , callback ) { log . debug ( 'rpc < system .list Methods ' , err , params ) ; log . debug ( 're > ' , null , JSON . stringify ( Object . keys ( that . methods ) ) ) ; callback ( null , Object . keys ( that . methods ) ) ; } , 'event ' : function event ( err , params , callback ) { log . debug ( 'rpc < event ' , err , params ) ; that . _iface [ params [ 0 ] ] . last Event = ( new Date ( ) ) . get Time ( ) ; if ( params [ 1 ] = = = 'CENTRAL ' & & params [ 2 ] = = = 'PONG ' ) return ; if ( ! that . _values [ params [ 0 ] ] [ params [ 1 ] ] ) { that . _values [ params [ 0 ] ] [ params [ 1 ] ] = { } ; } if ( params [ 3 ] ! = = that . _values [ params [ 0 ] ] [ params [ 1 ] ] [ params [ 2 ] ] ) { log . debug ( 'rpc < change ' , err , params , that . _names [ params [ 1 ] ] ) ; 
function create ( parent , base Url , params , callback ) { parent . get Client ( ) . post ( base Url , params , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( null , new this ( parent , definition ) ) ; } . bind ( this ) ) ; } 
function register ( type , lang , handler ) { if ( Array . is Array ( lang ) ) { lang . for Each ( ( v ) = > store [ type ] . langs [ v ] = handler ) ; return ; } store [ type ] . langs [ lang ] = handler ; } 
function loader ( module , file Path ) { let content = fs . read File Sync ( file Path , 'utf 8 ' ) ; let module Id = ` $ { hash ( file Path ) } ` ; let vue Template = ' ' ; let vue Component = compiler . parse Component ( strip Bom ( content ) ) ; let script = vue Component . script ; let styles = vue Component . styles ; let template = vue Component . template ; let scoped = styles . some ( ( { attrs } ) = > attrs . scoped ) ; [ ] . concat ( script , template , styles ) . for Each ( ( tag , index ) = > { if ( tag ) { let type = tag . type ; let content = tag . content ; let lang = tag . attrs . lang | | store [ type ] . defaults ; let handler = store [ type ] . langs [ lang ] ; if ( handler ) { content = handler ( content , file Path , index , module ) ; } switch ( type ) { case 'style ' : if ( browser Env ) { if ( tag . attrs . scoped ) { let ast = css . parse ( content ) ; ast . stylesheet . rules . for Each ( ( rule ) = > { rule . selectors = rule . selectors . map ( ( selector ) = > { let [ patterns ] = css What ( selector ) ; let index = patterns . length - 1 ; for ( ; index > = 0 ; index - - ) { let { type } = patterns [ index ] ; if ( type ! = = 'pseudo ' & & type ! = = 'pseudo -element ' ) { break ; } } patterns . splice ( index + 1 , 0 , { value : ' ' , name : module Id , action : 'exists ' , type : 'attribute ' , ignore Case : false , } ) ; return css What . stringify ( [ patterns ] ) ; } ) ; } ) ; content = css . stringify ( ast ) ; } let style = document . create Element ( 'style ' ) ; style . inner HTML = content ; store . style . exports . call ( module . exports , style , { index , styles , file Path , } ) ; } break ; case 'script ' : module . _compile ( content , file Path ) ; break ; case 'template ' : if ( browser Env ) { if ( scoped ) { let div = document . create Element ( 'div ' ) ; div . inner HTML = content ; let root = div . first Element Child ; let walk = function walk ( element , handler ) { handler ( element ) ; let children = element . children | | [ ] ; [ ] . for Each . call ( children , ( child ) = > { walk ( child , handler ) ; } ) ; } ; walk ( root , ( element ) = > { element . set Attribute ( module Id , ' ' ) ; } ) ; content = div . inner HTML ; } } vue Template = content ; break ; } } } ) ; module . exports . vue Component = vue Component ; module . exports . template = vue Template ; } 
function WMURL _is Valid ( url , 
function _parse Query ( _ , key , value ) { var encoded Key = global [ "encode URIComponent " ] ( key ) , encoded Value = global [ "encode URIComponent " ] ( value ) ; if ( rv [ encoded Key ] ) { if ( Array . is Array ( rv [ encoded Key ] ) ) { rv [ encoded Key ] . push ( encoded Value ) ; } else { rv [ encoded Key ] = [ rv [ encoded Key ] , encoded Value ] ; } } else { rv [ encoded Key ] = encoded Value ; } return " " ; } 
function ( kind , promises Dfd ) { return function ( ) { 
function ( set , args ) { 
function ( kind , args ) { var bucket = this [ kind + 's ' ] ; for ( var i = 0 ; i < bucket . length ; i + + ) { call Set . call ( this , bucket [ i ] , args ) ; } } 
function ( ) { var dfd = this ; 
function ( kind ) { return function ( ) { if ( this . state = = = 'pending ' ) { if ( kind ! = = 'progress ' ) { this [ kind + 'Args ' ] = arguments ; this . state = this . promise . state = kind ; } call Sets . call ( this , kind , arguments ) ; } return this ; } ; } 
function ( ) { this . dones = [ ] ; this . done Args = [ ] ; this . fails = [ ] ; this . fail Args = [ ] ; this . pendings = [ ] ; this . pending Args = [ ] ; this . state = 'pending ' ; 
function ( performer ) { 
function toposort ( dependencies ) { var sorted = [ ] , visited = { } ; function visit ( key ) { if ( ! visited [ key ] ) { visited [ key ] = true ; if ( ! dependencies [ key ] ) { throw new Error ( 'A dependency is given which is not defined ' + key ) ; } dependencies [ key ] . dependencies . for Each ( visit ) ; sorted . push ( key ) ; } } for ( var key in dependencies ) { visit ( key ) ; } return sorted ; } 
function ( schema ) { this . _decoders = decoders ; this . _encoders = encoders ; this . _schemas = { } ; 
function ( selector , properties , value ) { let rule = postcss . rule ( { selector : selector } ) let decls = _ . map ( properties , function ( property ) { return postcss . decl ( { prop : property , value : value } ) } ) rule . append ( decls ) return rule } 
function ( breakpoints , spacing Scale ) { return _ . map ( breakpoints , function ( breakpoint Value , breakpoint Key ) { let media Query = postcss . at Rule ( { name : 'media ' , params : breakpoint Value , } ) let rules = _ . flat Map ( spacing Scale , function ( scale Value , scale Key ) { return _ . map ( helpers , function ( helper Values , helper Key ) { return make Functional Rule ( ` $ { breakpoint Key } $ { helper Key } $ { scale Key } ` , helper Values , scale Value ) } ) } ) return media Query . append ( rules ) } ) } 
function _assert Data Type ( type , val ) { var data Type ; if ( val = = = UNDEFINED ) { data Type = OBJECT _UNDEFINED ; } else if ( val = = = NULL ) { data Type = OBJECT _NULL ; } else { data Type = _to String . call ( val ) ; } var lower Case Type = data Type . replace ( DATA _TYPE _REPLACE _REX , ' ' ) . to Lower Case ( ) ; return lower Case Type = = = type ; } 
function branch Matching ( value , branches ) { var i = branches . length while ( i - - ) if ( equal ( value , branches [ i ] . condition ) ) return branches [ i ] return { condition : null , code : null } } 
function method ( dispatch ) { var branches = [ ] var baseline = function ( a ) { throw no Branch For ( a ) } var dispatch Table = new Dispatch Table ( ) dispatch = dispatch | | identity return make Method ( function ( ) { var value = dispatch . apply ( null , arguments ) var branch = dispatch Table . get Branch ( value ) . code | | branch Matching ( value , branches ) . code | | baseline return branch . apply ( null , arguments ) } ) 
function make Method ( f ) { f . when = when f . fallback = fallback f . remove = remove f . clone = clone return f } 
function when ( condition , f ) { if ( branch Matching ( condition , branches ) . code ) throw ambiguous Branch ( condition ) branches . push ( { condition : condition , code : f } ) dispatch Table . add ( condition , f ) return this } 
function remove ( condition ) { branches = branches . filter ( function ( a ) { return ! equal ( condition , a . condition ) } ) return this } 
function destroy ( callback ) { this . get Client ( ) . destroy ( this . definition . _links . self . href , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( ) ; } . bind ( this ) ) ; } 
function load _config ( ) { let config = { } ; if ( fs . exists Sync ( pgrunner _config _file ) ) { config = JSON . parse ( fs . read File Sync ( pgrunner _config _file , { 'encoding ' : 'utf 8 ' } ) ) ; if ( argv . v ) { debug . log ( 'Loaded from ' , pgrunner _config _file ) ; } } if ( ! is . array ( config . servers ) ) { config . servers = [ ] ; } return config ; } 
function save _config ( config ) { fs . write File Sync ( pgrunner _config _file , JSON . stringify ( config , null , 2 ) , { 'encoding ' : 'utf 8 ' } ) ; if ( argv . v ) { debug . log ( 'Saved to ' , pgrunner _config _file ) ; } } 
function strip _argv ( a ) { let o = { } ; return Object . keys ( a ) . filter ( k = > k ! = = ' _ ' ) . map ( k = > { o [ k ] = a [ k ] ; } ) ; } 
function strip _server _opts ( old _opts ) { debug . assert ( old _opts ) . is ( 'object ' ) ; let opts = { } ; [ 'pgconfig ' , 'host ' , 'port ' , 'user ' , 'database ' ] . for Each ( key = > { if ( old _opts [ key ] ! = = undefined ) { opts [ key ] = old _opts [ key ] ; } } ) ; return opts ; } 
function get _server _opts ( opts ) { debug . assert ( opts ) . is ( 'object ' ) ; debug . assert ( opts . settings ) . is ( 'object ' ) ; return { 'dbconfig ' : opts . dbconfig , 'host ' : opts . settings . host , 'port ' : opts . settings . port , 'user ' : opts . settings . user , 'database ' : opts . settings . database } ; } 
function _is JSON ( val ) { if ( ! _is String ( val ) ) { return false ; } try { 
function custom ( fn ) { return function ( req , res , next ) { fn ( req , function ( result ) { if ( result = = = true ) { return next ( ) ; } next ( new Error Unauthorized ( 'Authentication Failed ' ) ) ; } ) ; } ; } 
function http _basic ( username , password ) { return function ( req , res , next ) { var credentials = basic _auth ( req ) ; if ( credentials ! = = undefined ) { if ( credentials . name & & credentials . name = = = username ) { if ( credentials . pass & & credentials . pass = = = password ) { return next ( ) ; } } } res . set ( 'WWW -Authenticate ' , 'Basic ' ) ; next ( new Error Unauthorized ( 'Authentication Failed ' ) ) ; } ; } 
function get Resources ( domains ) { return store . get Resources ( ) . then ( rsrcs = > { return rsrcs . filter ( e = > domains . includes ( e . domain ) ) ; } ) ; } 
function Base Controller ( context ) { Object . define Properties ( this , { body : { enumerable : true , get ( ) { return context . body ; } , set ( val ) { context . body = val ; } , } , context : { enumerable : true , get ( ) { return context ; } , } , response : { enumerable : true , get ( ) { return context . response ; } , } , request : { enumerable : true , get ( ) { return context . request ; } , } , query : { enumerable : true , get ( ) { return context . query ; } , } , } ) ; } 
function pack Ranges ( from Index , to Index , bucket Threshold , sparse Iteration Threshold , get Own Property Names Threshold ) { var own Property Names = null ; var consecutive Range = ( to Index - from Index > = sparse Iteration Threshold ) & & Array Buffer . is View ( this ) ; var skip Get Own Property Names = consecutive Range & & ( to Index - from Index > = get Own Property Names Threshold ) ; function * array Indexes ( object ) { if ( to Index - from Index < sparse Iteration Threshold ) { for ( var i = from Index ; i < = to Index ; + + i ) { if ( i in object ) yield i ; } } else { own Property Names = own Property Names | | Object . get Own Property Names ( object ) ; for ( var i = 0 ; i < own Property Names . length ; + + i ) { var name = own Property Names [ i ] ; var index = name > > > 0 ; if ( ( " " + index ) = = = name & & from Index < = index & & index < = to Index ) yield index ; } } } var count = 0 ; if ( consecutive Range ) { count = to Index - from Index + 1 ; } else { for ( var i of array Indexes ( this ) ) + + count ; } var bucket Size = count ; if ( count < = bucket Threshold ) bucket Size = count ; else bucket Size = Math . pow ( bucket Threshold , Math . ceil ( Math . log ( count ) / Math . log ( bucket Threshold ) ) - 1 ) ; var ranges = [ ] ; if ( consecutive Range ) { for ( var i = from Index ; i < = to Index ; i + = bucket Size ) { var group Start = i ; var group End = group Start + bucket Size - 1 ; if ( group End > to Index ) group End = to Index ; ranges . push ( [ group Start , group End , group End - group Start + 1 ] ) ; } } else { count = 0 ; var group Start = - 1 ; var group End = 0 ; for ( var i of array Indexes ( this ) ) { if ( group Start = = = - 1 ) group Start = i ; group End = i ; if ( + + count = = = bucket Size ) { ranges . push ( [ group Start , group End , count ] ) ; count = 0 ; group Start = - 1 ; } } if ( count > 0 ) ranges . push ( [ group Start , group End , count ] ) ; } return { ranges : ranges , skip Get Own Property Names : skip Get Own Property Names } ; } 
function url Format ( obj ) { 
function writeln Color ( ) { for ( var i = 0 ; i < arguments . length ; i = i + 2 ) grunt . log . write ( arguments [ i ] [ arguments [ i + 1 ] ] ) ; grunt . log . writeln ( ' ' ) ; } 
function ray Vs Circle ( ray , circle ) { var ray Start = new Vec 2 ( ray . start ) ; if ( circle Contains Point ( circle . position , circle . radius , ray . start ) ) { return ray Start ; } var intersections = ray Line Vs Circle ( ray , circle ) ; if ( intersections . length ) { return ray Start . nearest ( intersections . filter ( within ( ray ) ) ) ; } else { return null ; } } 
function ray Line Vs Circle ( ray , circle ) { var ray Line = new Line 2 ( ray . start . x , ray . start . y , ray . end . x , ray . end . y ) ; return ray Line . intersect Circle ( circle . position , circle . radius ) ; } 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) if ( typeof options ! = = 'object ' & & ( ! options . tournament _id | | ! options . flight _id ) ) throw new Error ( 'tournament _id or flight _id required to make tibreak preference api calls ' ) var url = ' ' if ( options . tournament _id ) { url + = ngin . Tournament . url Root ( ) + ' / ' + options . tournament _id } else if ( options . flight _id ) { url + = ngin . Flight . url Root ( ) + ' / ' + options . flight _id } return url + Tiebreak Preference . url Root ( ) } 
function ( options , callback ) { var url = scope Url ( options , this ) return Super . fetch . call ( this , url , options , callback ) } 
function ( module , debug ) { this . debug = debug | | false ; this . jsonrpc = " 2 . 0 " ; 
function _get Param Names ( func ) { var fun Str = func . to String ( ) ; return fun Str . slice ( fun Str . index Of ( ' ( ' ) + 1 , fun Str . index Of ( ' ) ' ) ) . match ( / ( [ ^ \s , ] + ) / g ) ; } 
function _get Changed Properties ( ) { var ret Val = { } , key ; for ( key in this . _changed ) { ret Val [ key ] = this . _changed [ key ] ; } return ret Val ; } 
function update ( properties , callback ) { if ( typeof properties = = 'function ' ) { callback = properties ; properties = { } ; } var key , changed ; var exceptions = [ 'addresses _update _action ' , 'emails _update _action ' , 'phone _numbers _update _action ' ] ; for ( key in properties ) { if ( 'set ' + inflection . camelize ( key ) in this ) { this [ 'set ' + inflection . camelize ( key ) ] ( properties [ key ] ) ; } else if ( exceptions . index Of ( key ) ! = - 1 ) { this . _changed [ key ] = properties [ key ] ; } } changed = this . _get Changed Properties ( ) ; this . get Client ( ) . patch ( this . definition . _links . self . href , changed , function ( err , definition , response ) { if ( err ) return callback ( err ) ; this . definition = definition ; this . _setup ( ) ; callback ( null , this ) ; } . bind ( this ) ) ; } 
function Data Type _Uint 8Array _clone ( source , 
function by Class ( c ) { c = classnames ( c ) if ( / ^ \ . / . test ( c ) ) { throw new Error ( 'No need to " . " on start ' ) } return by Selector ( ` $ { c } ` ) } 
function publish ( symbol Set ) { publish . conf = { 
function subtemplate ( template , data ) { try { return new JSDOC . Js Plate ( publish . conf . templates Dir + template ) . process ( data ) ; } catch ( e ) { print ( e . message ) ; quit ( ) ; } } 
function make Signature ( params ) { if ( ! params ) return " ( ) " ; var signature = " ( " + params . filter ( function ( $ ) { return ! / \w + \ . \w + / . test ( $ . name ) ; } ) . map ( function ( $ ) { var name = $ . is Optional ? ' [ ' + $ . name + ' ] ' : $ . name ; return name ; } ) . join ( " , " ) + " ) " ; return signature ; } 
function resolve Links ( str , from ) { str = str . replace ( / \ { @link ( [ ^ } ] + ) \ } / gi , function ( match , symbol Name ) { symbol Name = symbol Name . trim ( ) ; var index = symbol Name . index Of ( ' ' ) ; if ( index > 0 ) { var label = symbol Name . substring ( index + 1 ) ; symbol Name = symbol Name . substring ( 0 , index ) ; return new Link ( ) . to Symbol ( symbol Name ) . with Text ( label ) ; } else { return new Link ( ) . to Symbol ( symbol Name ) ; } } ) ; return str ; } 
function format Query ( options ) { var required Params if ( options & & typeof options ! = = 'function ' ) { options . query = required Params = _ . pick ( _ . extend ( { } , options , options . query ) , 'tournament _id ' , 'league _id ' , 'flight _id ' , 'division _id ' ) } if ( _ . is Empty ( required Params ) ) throw new Error ( 'tournament _id , league _id , flight _id or division _id are required . ' ) } 
function approach ( index , x , on Axis ) { while ( 0 < = x & & x < = 1 ) { candidate HSVA [ index ] = x ; Web Inspector . Color . hsva 2rgba ( candidate HSVA , candidate RGBA ) ; Web Inspector . Color . blend Colors ( candidate RGBA , bg RGBA , blended RGBA ) ; var fg Luminance = Web Inspector . Color . luminance ( blended RGBA ) ; var d Luminance = fg Luminance - desired Luminance ; if ( Math . abs ( d Luminance ) < ( on Axis ? epsilon / 1 0 : epsilon ) ) return x ; else x + = ( index = = = V ? - d Luminance : d Luminance ) ; } return null ; } 
function color Control Input ( id ) { const data = { id : id , column : d 3form . option Data ( ` $ { id } ` ) } ; const preset = d 3form . option Data ( ` $ { id } ` ) ; if ( preset . scale . scale = = = 'ordinal ' ) { data . scale = preset . scale ; return data ; } data . scale = { scale : d 3form . value ( ` $ { id } ` ) , domain : [ d 3form . value ( ` $ { id } ` ) , d 3form . value ( ` $ { id } ` ) ] , unknown : ' # 6 9 6 9 6 9 ' } ; const range = [ d 3form . value ( ` $ { id } ` ) ] ; if ( d 3form . checked ( ` $ { id } ` ) ) { range . push ( d 3form . value ( ` $ { id } ` ) ) ; } range . push ( d 3form . value ( ` $ { id } ` ) ) ; data . scale . range = range ; return data ; } 
function update Node Color ( data ) { d 3 . select All ( ' .node ' ) . select ( ' .node -symbol ' ) . style ( 'fill ' , d = > d 3scale . scale Function ( data . scale ) ( d [ data . column . key ] ) ) ; } 
function main Control Box ( ) { d 3 . select ( ' #show -struct ' ) . on ( 'change ' , function ( ) { const data = node Content Input ( ) ; d 3 . select ( ' #main -control ' ) . datum ( data ) ; update Node Structure ( data ) ; } ) . dispatch ( 'change ' ) ; } 
function bootstrap ( ) { 
function center Graph ( new Scale , duration , delay ) { if ( typeof delay = = = 'function ' ) { delay = delay . call ( this ) ; } delay = typeof delay = = = 'number ' ? delay : 0 ; set Timeout ( function ( ) { if ( typeof new Scale = = = 'function ' ) { new Scale = new Scale . call ( this ) ; } if ( typeof duration = = = 'function ' ) { duration = duration . call ( this ) ; } new Scale = typeof new Scale = = = 'number ' ? new Scale : zoom . scale ( ) ; duration = typeof duration = = = 'number ' ? duration : 2 0 0 ; if ( typeof new Scale ! = = 'number ' ) { throw new Type Error ( "center Graph error : 'new Scale ' is not a 'number ' . " ) ; } if ( typeof duration ! = = 'number ' ) { throw new Type Error ( "center Graph error : 'duration ' is not a 'number ' . " ) ; } var bounds = graph . node ( ) . get BBox ( ) ; var center SVGX = ( graph Width * new Scale / 2 ) ; var center SVGY = ( graph Height * new Scale / 2 ) ; var center Graph X = ( bounds . x * new Scale ) + ( bounds . width * new Scale / 2 ) ; var center Graph Y = ( bounds . y * new Scale ) + ( bounds . height * new Scale / 2 ) ; 
function detect All Nodes Fixed ( ) { if ( data ) { var current Nodes Fixed = data . all Nodes Fixed ; var all Nodes Fixed = true ; data . nodes . for Each ( function ( node ) { if ( ! node . fixed ) { all Nodes Fixed = false ; } } ) ; data . all Nodes Fixed = all Nodes Fixed ; if ( current Nodes Fixed ! = = all Nodes Fixed ) { update Menu UI ( ) ; } 
function fade Related Nodes ( target Node , selected , nodes , links ) { var opacity = selected ? 0 . 1 : 1 ; var elm = find Element By Node ( 'circle ' , target Node ) ; 
function find Element By Node ( prefix , node ) { var selector = ' . ' + format Class Name ( prefix , node ) ; return graph . select ( selector ) ; } 
function get Element Coords ( element ) { var ctm = element . get CTM ( ) ; return { x : ctm . e + element . get Attribute ( 'cx ' ) * ctm . a , y : ctm . f + element . get Attribute ( 'cy ' ) * ctm . d } ; } 
function get SVG ( element Type ) { var return Val ; var svg Element ; var cached ; switch ( element Type ) { case 'circle ' : case 'g ' : case 'path ' : case 'text ' : return Val = function ( data ) { svg Element = svg Element Map [ element Type ] . pop ( ) ; cached = svg Element ! = null ; svg Element = svg Element ! = null ? svg Element : document . create Element NS ( 'http : / /www .w 3 .org / 2 0 0 0 /svg ' , element Type ) ; 
function hide Node Context Menu ( event ) { 
function is Connected ( target Node , other Node ) { return target Node . index = = = other Node . index | | linked By Index [ target Node . index + ' , ' + other Node . index ] ; } 
function on Control Deps Clicked ( ) { 
function on Control Level Changed ( ) { app Options . current Level = parse Int ( this . value ) ; $ ( ' .control -level input ' ) . val ( app Options . current Level ) ; $ ( ' .control -level label ' ) . html ( app Options . current Level ) ; 
function on Control Menu Clicked ( ) { switch ( $ ( this ) . data ( 'action ' ) ) { case 'toggle Freeze All Nodes ' : set Nodes Fixed ( ! data . all Nodes Fixed ) ; break ; case 'show Full Names ' : app Options . show Full Names = ! app Options . show Full Names ; update All ( { redraw Only : true } ) ; break ; case 'show Table View ' : app Options . show Table View = ! app Options . show Table View ; $ ( ' .control -table ' ) . toggle Class ( 'hidden ' , ! app Options . show Table View ) ; update Table UIExtent ( ) ; break ; case 'max Depth Sticky ' : app Options . max Depth Sticky = ! app Options . max Depth Sticky ; break ; } 
function on Control Table Row Context Click ( node , event ) { event . prevent Default ( ) ; 
function on Control Table Row Mouse Over ( nodes , links , node , enter ) { 
function on Control Zoom Clicked ( ) { var new Scale = 1 ; var scale Percentile = 0 . 2 0 ; 
function on Node Context Menu Click ( ) { 
function on Node Context Click ( target Node , coords ) { 
function on Node Mouse Down ( nodes , links , target Node ) { hide Node Context Menu ( ) ; 
function on Node Mouse Over Out ( nodes , links , enter , target Node ) { 
function on Resize ( ) { 
function on Tick ( ) { nodes . attr ( 'cx ' , function ( node ) { return node . x ; } ) . attr ( 'cy ' , function ( node ) { return node . y ; } ) . attr ( 'transform ' , function ( node ) { return 'translate ( ' + node . x + ' , ' + node . y + ' ) ' ; } ) ; 
function on Zoom Changed ( ) { var new Scale = Math . max ( d 3 . event . scale , min Scale Extent ) ; zoom . scale ( new Scale ) ; graph . attr ( 'transform ' , 'translate ( ' + d 3 . event . translate + ' ) ' + ' scale ( ' + new Scale + ' ) ' ) ; } 
function recycle Graph ( ) { var child Nodes = graph . select All ( 'g > * ' ) . remove ( ) ; if ( ! Array . is Array ( child Nodes ) & & ! Array . is Array ( child Nodes [ ' 0 ' ] ) ) { return ; } 
function render Graph ( options ) { options = typeof options = = = 'object ' ? options : { } ; options . redraw Only = typeof options . redraw Only = = = 'boolean ' ? options . redraw Only : false ; 
function reverse Graph Links ( ) { for ( var key in data Package Map ) { var graph Data = data Package Map [ key ] ; graph Data . links . for Each ( function ( link ) { var link Source = link . source ; link . source = link . target ; link . target = link Source ; } ) ; } } 
function set Nodes Fixed ( fixed ) { 
function update Graph Data ( ) { 
function update Menu UI ( ) { if ( data ) { $ ( ' .control -menu li [data -action =toggle Freeze All Nodes ] ' ) . html ( data . all Nodes Fixed ? 'Unfreeze nodes ' : 'Freeze nodes ' ) ; } app Menu Toggle Options . for Each ( function ( key ) { var icon = app Options [ key ] ? 'check _box ' : 'check _box _outline _blank ' ; $ ( ' .control -menu li [data -action = ' + key + ' ] i ' ) . html ( icon ) ; } ) ; } 
function update Table UI ( ) { var table = $ ( ' .control -table tbody ' ) ; table . off ( 'mouseenter ' , 'tr ' , on Control Table Row Mouse Over ) ; table . off ( 'mouseleave ' , 'tr ' , on Control Table Row Mouse Over ) ; table . off ( 'contextmenu ' , 'tr ' , on Control Table Row Context Click ) ; table . empty ( ) ; if ( data ) { data . nodes . for Each ( function ( node ) { var nd = node . package Data ; var name = app Options . show Full Names ? nd . actual Package Name : nd . package Name ; var is Aliased = nd . is Alias ? ' is Aliased ' : ' ' ; var tr = $ ( ' <tr > ' + ' <td class = "mdl -data -table _ _cell - -non -numeric ' + is Aliased + ' " > ' + name + ' < /td > ' + ' <td class = "mdl -data -table _ _cell - -non -numeric " > ' + nd . jspm Type + ' < /td > ' + ' <td class = "mdl -data -table _ _cell - -non -numeric " > ' + nd . version + ' < /td > ' + ' <td class = "mdl -data -table _ _cell - -non -numeric " > ' + node . min Level + ' < /td > ' + ' < /tr > ' ) ; table . append ( tr ) ; tr . on ( 'mouseenter ' , on Control Table Row Mouse Over . bind ( this , nodes , links , node , true ) ) ; tr . on ( 'mouseleave ' , on Control Table Row Mouse Over . bind ( this , nodes , links , node , false ) ) ; tr . on ( 'contextmenu ' , on Control Table Row Context Click . bind ( this , node ) ) ; } ) ; 
function update Table UIExtent ( ) { var table Div = $ ( ' .control -table -inner ' ) ; var node Table = $ ( ' #node Table ' ) ; var table Height = node Table . height ( ) ; var offset = table Div . offset ( ) ; var max Table Height = window . inner Height - offset . top - 2 0 ; table Div . css ( 'max -height ' , max Table Height ) ; node Table . css ( 'margin -right ' , table Height > max Table Height ? ' 1 0px ' : ' 0px ' ) ; } 
function zoom Fit ( ) { var bounds = graph . node ( ) . get BBox ( ) ; var parent = graph . node ( ) . parent Element ; var full Width = parent . client Width , full Height = parent . client Height ; var width = bounds . width , height = bounds . height ; if ( width = = = 0 | | height = = = 0 ) { return 1 ; } 
function get Window Width ( ) { if ( window . inner Width ) { return window . inner Width ; } else if ( document . document Element . client Width ) { return document . document Element . client Width ; } else if ( document . body . client Width ) { return document . body . client Width ; } else { return 0 ; } } 
function ( css Screen , css Handheld , mobile Max Width ) { / / Set config values if ( typeof ( css Screen ) ! = "undefined " ) { config . css Screen = css Screen ; } if ( typeof ( css Handheld ) ! = "undefined " ) { config . css Handheld = css Handheld ; } if ( typeof ( mobile Max Width ) ! = "undefined " ) { config . mobile Max Width = mobile Max Width ; } / / Check if CSS is loaded var cssload Check Node = document . create Element ( 'div ' ) ; cssload Check Node . class Name = config . test Div Class ; document . get Elements By Tag Name ( "body " ) [ 0 ] . append Child ( cssload Check Node ) ; if ( cssload Check Node . offset Width ! = 1 0 0 & & no Media Query = = false ) { no Media Query = true ; } cssload Check Node . parent Node . remove Child ( cssload Check Node ) if ( no Media Query = = true ) { / / Browser does not support Media Queries , so Java Script will supply a fallback var css Href = " " ; / / Determines what CSS file to load if ( get Window Width ( ) < = config . mobile Max Width ) { css Href = config . css Handheld ; new Css Media Type = "handheld " ; } else { css Href = config . css Screen ; new Css Media Type = "screen " ; } / / Add CSS link to <head > of page if ( css Href ! = " " & & current Css Media Type ! = new Css Media Type ) { var current Css Links = document . style Sheets for ( var i = 0 ; i < current Css Links . length ; i + + ) { for ( var ii = 0 ; ii < current Css Links [ i ] . media . length ; ii + + ) { if ( typeof ( current Css Links [ i ] . media ) = = "object " ) { if ( current Css Links [ i ] . media . item ( ii ) = = "fallback " ) { current Css Links [ i ] . owner Node . parent Node . remove Child ( current Css Links [ i ] . owner Node ) i - - break ; } } else { if ( current Css Links [ i ] . media . index Of ( "fallback " ) > = 0 ) { current Css Links [ i ] . owning Element . parent Node . remove Child ( current Css Links [ i ] . owning Element ) i - - break ; } } } } if ( typeof ( css Href ) = = "object " ) { for ( var i = 0 ; i < css Href . length ; i + + ) { add Css Link ( css Href [ i ] ) } } else { add Css Link ( css Href ) } current Css Media Type = new Css Media Type ; } / / Check screen size again if user resizes window add Event ( window , wbos . Css Tools . Media Query Fall Back . Load Css Delayed , 'onresize ' ) } } 
function gulp Rebound ( options ) { options | | ( options = { } ) ; 
function clear File ( obj ) { if ( Utils . tools . is Array ( obj ) ) obj . for Each ( _clear File ) ; else _clear File ( obj ) ; return Utils ; } 
function Item ( source , file ) { this . source = source ; this . file = file ; this . dirname = path . dirname ( this . file ) ; this . basename = path . basename ( this . file , ' .yml ' ) ; this . rel Path = path . relative ( this . source , this . dirname ) ; this . yaml = yaml . load ( fs . read File Sync ( this . file , 'utf 8 ' ) ) ; this [ "package " ] = path . dirname ( this . rel Path ) ; this . module = path . basename ( this . rel Path ) ; } 
function do _success ( req , res , msg ) { res . write Head ( 2 0 0 , { 'Content -Type ' : ( ( typeof msg = = = 'string ' ) ? 'text /plain ' : 'application /json ' ) } ) ; msg = ( typeof msg = = = 'string ' ) ? msg : helpers . stringify ( msg ) ; res . end ( msg ) ; } 
function do _failure ( req , res , opts ) { opts = opts | | { } ; var obj = { 'type ' : opts . type | | 'error ' , 'code ' : opts . code | | 5 0 1 , 'desc ' : opts . desc | | ( ' ' + opts ) } ; res . write Head ( obj . code , { 'Content -Type ' : 'application /json ' } ) ; res . end ( helpers . stringify ( obj ) + ' \n ' ) ; } 
function do _create _req ( config , routes ) { routes = routes | | { } ; var version = routes . version | | { } ; if ( version & & ( typeof version = = = 'object ' ) ) { } else { version = { 'self ' : routes . version | | config . pkg . version } ; } if ( ! version . api ) { version . api = api _config . pkg . version ; } routes . version = version ; var router = new Request Router ( routes ) ; var req _counter = 0 ; function do _req ( req , res ) { req _counter + = 1 ; return router . resolve ( req , res ) ; } 
function do _create _server ( config , do _req ) { var http = require ( 'http ' ) ; if ( config . host ) { http . create Server ( do _req ) . listen ( config . port , config . host ) ; 
function setup _server ( config , opts ) { config . _def ( 'port ' , 3 0 0 0 ) ; var req _handler = do _create _req ( config , opts ) ; var server = do _create _server ( config , function ( req , res ) { req _handler ( req , res ) . then ( function ( obj ) { if ( obj = = = api . reply Sent ) { 
function ( element , ev , fn ) { if ( element . add Event Listener ) element . add Event Listener ( ev , fn , false ) ; else element . attach Event ( "on " + ev , fn ) ; } 
function ( ) { if ( this . visible ( ) ) return ; this . _body Element = document . body ; this . _body Element . add Event Listener ( "mousedown " , this . _maybe Hide Bound , true ) ; this . _overlay = new Web Inspector . Suggest Box . Overlay ( ) ; this . _overlay . set Content Element ( this . _container ) ; } 
function Reply ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Reply . super _ . apply ( this , arguments ) ; } 
function WMURL _decode ( source ) { 
function serve Git File ( repo , tree , parts , res , next ) { 
function build And Start ( ) { if ( / ^https ? : \ / \ / / . test ( Program . file ) ) { var url = Program . file . replace ( / ^ (https ? : \ / \ / ) ( [ ^ / : ] + ) ( ? = : \d + | \ / ) / , function ( m , a , b ) { if ( ! / \d + \ . \d + \ . \d + \ . \d + / . test ( a ) ) { return a + Hosts . find Real Host ( b ) ; } else { return m ; } } ) ; Config . entry Bundle Url = url ; start Server And Launch Devtool ( ) ; } else { var file Path = Path . resolve ( Program . file ) ; var ext = Path . extname ( file Path ) ; if ( ! Fs . exists Sync ( file Path ) ) { console . error ( file Path + ' : No such file or directory ' ) ; return Exit ( 0 ) ; } if ( ext = = ' .ju ' | | ext = = ' .vue ' ) { console . log ( 'building . . . ' ) ; console . time ( 'Build completed ! ' ) ; build File And Watch It ( Program . mode , file Path ) . then ( function ( ) { console . time End ( 'Build completed ! ' ) ; start Server And Launch Devtool ( Program . file ) ; } , function ( err ) { if ( err ) { console . log ( err , err . stack ) ; } Exit ( 0 ) ; } ) } else if ( ext = = ' .js ' ) { build File And Watch It ( 'copy ' , file Path ) . then ( function ( ) { start Server And Launch Devtool ( Program . file ) ; } ) } else if ( ! ext ) { 
function random Unique Id ( ) { 
function move To Next Callback ( already New , value Changed , section ) { if ( ! move Direction ) return ; 
function process File List ( files , base , settings , state ) { for ( var i = 0 ; i < files . length ; i + + ) { var module Path = path . join ( base , files [ i ] ) ; var stats = fs . stat Sync ( module Path ) ; if ( stats . is File ( ) ) { 
function package Module ( global , name , api ) { if ( global . define & & global . define . amd ) { define ( [ ] , api ) ; } else if ( typeof exports ! = = "undefined " ) { module . exports = api ; } else { global [ name ] = api ; } } 
function framework Event Listeners ( ) { var error Lines = [ ] ; var event Listeners = [ ] ; var internal Handlers = [ ] ; var fetchers = [ j Query Fetcher ] ; try { if ( self . devtools Framework Event Listeners & & is Array Like ( self . devtools Framework Event Listeners ) ) fetchers = fetchers . concat ( self . devtools Framework Event Listeners ) ; } catch ( e ) { error Lines . push ( "devtools Framework Event Listeners call produced error : " + to String ( e ) ) ; } for ( var i = 0 ; i < fetchers . length ; + + i ) { try { var fetcher Result = fetchers [ i ] ( this ) ; if ( fetcher Result . event Listeners & & is Array Like ( fetcher Result . event Listeners ) ) { event Listeners = event Listeners . concat ( fetcher Result . event Listeners . map ( check Event Listener ) . filter ( non Empty Object ) ) ; } if ( fetcher Result . internal Handlers & & is Array Like ( fetcher Result . internal Handlers ) ) internal Handlers = internal Handlers . concat ( fetcher Result . internal Handlers . map ( check Internal Handler ) . filter ( non Empty Object ) ) ; } catch ( e ) { error Lines . push ( "fetcher call produced error : " + to String ( e ) ) ; } } var result = { event Listeners : event Listeners } ; if ( internal Handlers . length ) result . internal Handlers = internal Handlers ; if ( error Lines . length ) { var error String = "Framework Event Listeners API Errors : \n \t " + error Lines . join ( " \n \t " ) ; error String = error String . substr ( 0 , error String . length - 1 ) ; result . error String = error String ; } return result ; function is Array Like ( obj ) { if ( ! obj | | typeof obj ! = = "object " ) return false ; try { if ( typeof obj . splice = = = "function " ) { var len = obj . length ; return typeof len = = = "number " & & ( len > > > 0 = = = len & & ( len > 0 | | 1 / len > 0 ) ) ; } } catch ( e ) { } return false ; } function check Event Listener ( event Listener ) { try { var error String = " " ; if ( ! event Listener ) error String + = "empty event listener , " ; var type = event Listener . type ; if ( ! type | | ( typeof type ! = = "string " ) ) error String + = "event listener 's type isn 't string or empty , " ; var use Capture = event Listener . use Capture ; if ( typeof use Capture ! = = "boolean " ) error String + = "event listener 's use Capture isn 't boolean or undefined , " ; var passive = event Listener . passive ; if ( typeof passive ! = = "boolean " ) error String + = "event listener 's passive isn 't boolean or undefined , " ; var handler = event Listener . handler ; if ( ! handler | | ( typeof handler ! = = "function " ) ) error String + = "event listener 's handler isn 't a function or empty , " ; var remove = event Listener . remove ; if ( remove & & ( typeof remove ! = = "function " ) ) error String + = "event listener 's remove isn 't a function , " ; if ( ! error String ) { return { type : type , use Capture : use Capture , passive : passive , handler : handler , remove : remove } ; } else { error Lines . push ( error String . substr ( 0 , error String . length - 2 ) ) ; return null ; } } catch ( e ) { error Lines . push ( to String ( e ) ) ; return null ; } } function check Internal Handler ( handler ) { if ( handler & & ( typeof handler = = = "function " ) ) return handler ; error Lines . push ( "internal handler isn 't a function or empty " ) ; return null ; } function to String ( obj ) { try { return " " + obj ; } catch ( e ) { return " <error > " ; } } function non Empty Object ( obj ) { return ! ! obj ; } function j Query Fetcher ( node ) { if ( ! node | | ! ( node instanceof Node ) ) return { event Listeners : [ ] } ; var j Query = ( window [ "j Query " ] ) ; if ( ! j Query | | ! j Query . fn ) return { event Listeners : [ ] } ; var j Query Function = ( j Query ) ; var data = j Query . _data | | j Query . data ; var event Listeners = [ ] ; var internal Handlers = [ ] ; if ( typeof data = = = "function " ) { var events = data ( node , "events " ) ; for ( var type in events ) { for ( var key in events [ type ] ) { var framework Listener = events [ type ] [ key ] ; if ( typeof framework Listener = = = "object " | | typeof framework Listener = = = "function " ) { var listener = { handler : framework Listener . handler | | framework Listener , use Capture : true , passive : false , type : type } ; listener . remove = j Query Remove . bind ( node , framework Listener . selector ) ; event Listeners . push ( listener ) ; } } } var node Data = data ( node ) ; if ( node Data & & typeof node Data . handle = = = "function " ) internal Handlers . push ( node Data . handle ) ; } var entry = j Query Function ( node ) [ 0 ] ; if ( entry ) { var entry Events = entry [ " $events " ] ; for ( var type in entry Events ) { var events = entry Events [ type ] ; for ( var key in events ) { if ( typeof events [ key ] = = = "function " ) { var listener = { handler : events [ key ] , use Capture : true , passive : false , type : type } ; * @param {string } selector * @param {string } type * @param {function ( ) } handler * @this { ?Object } * / function j Query Remove ( selector , type , handler ) { if ( ! this | | ! ( this instanceof Node ) ) return ; var node = ( this ) ; var j Query = ( window [ "j Query " ] ) ; if ( ! j Query | | ! j Query . fn ) return ; var j Query Function = ( j Query ) ; j Query Function ( node ) . off ( type , selector , handler ) ; } } 
function proxify ( api ) { if ( ! api | | typeof api ! = = "object " ) throw new Type Error ( "Only objects can be proxified . " ) ; if ( typeof api . route ! = = "function " | | typeof api . close ! = = "function " ) throw new Type Error ( "Only objects that offer an owe Api interface can be proxified . " ) ; const passthrough Set = api [ passthrough ] ; const proxy = new Proxy ( target , { get ( target , property ) { if ( typeof property = = = "symbol " | | passthrough Set & & passthrough Set . has ( property ) & & property in api ) return typeof api [ property ] = = = "function " ? api [ property ] . bind ( api ) : api [ property ] ; return proxify ( api . route ( property ) ) ; } , apply ( target , context , args ) { return api . close ( args [ 0 ] ) ; } , delete Property ( ) { return false ; } } ) ; proxy Map . set ( proxy , api ) ; return proxy ; } 
function Ebus ( p ) { "use strict " ; this . debug = false ; this . yields = false ; this . handlers = { } ; if ( p ) { this . priorities = p ; } else { this . priorities = { } ; } } 
function Api Client ( config ) { var self = this this . config = _ . extend ( { } , config , { client : this } ) config . headers = _ . extend ( { } , config . headers , { Accept : 'application /json ' } ) this . auth = config . auth models . sync = require ( ' . /sync ' ) models . Model = require ( ' . /modelbase ' ) models . Ngin Model = require ( ' . /ngin Model ' ) 
function get First Index Of ( value , array ) { error _if _not _primitive _or _array _ 1 . error If Not Primitive Or Array ( value ) ; if ( is Array _not Array _ 1 . is Array ( value ) ) { return get First Index Of Array _ 1 . get First Index Of Array ( value , array ) ; } else { 
function ( type , obj ) { return obj ! = = null & & obj ! = = undefined & & obj . constructor . prototype = = = type . prototype ; } 
function break Role List ( matcher , list ) { const pieces = [ ] const role Breaker = XReg Exp ( ` \ \ $ { matcher . role Matcher } \ \ ` ) for ( let m = list . match ( role Breaker ) ; m ! = = null ; m = list . match ( role Breaker ) ) { const [ consumed , matched ] = m pieces . push ( matched ) list = list . substring ( consumed . length ) } const alt Finder = XReg Exp ( ` \ \ \ \ \ \ $ { matcher . role Matcher } ` ) const alt Match = list . match ( alt Finder ) if ( alt Match ) { pieces . push ( alt Match [ 2 ] ) } 
function scope Url ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season _id ) throw new Error ( 'season _id required to make division instance api calls ' ) return ngin . Season . url Root ( ) + ' / ' + options . season _id + Division . url Root ( ) } 
function process ( ast , scope ) { ast . scope = scope ; ast . names = [ ] ; ast . scopes = [ ] ; var var Walker = function ( token , scope ) { scope . declarations . push ( { type : 'var ' , name : token . id . name , parent : this . top ( 1 ) , loc : token . loc . start } ) ; scope . put ( token . id . name , { type : 'var ' , token : token . init , loc : token . loc . start } ) ; } ; return walker . walk ( ast , { Variable Declarator : var Walker , Function Declaration : fn Walker , Function Expression : fn Walker , Arrow Function Expression : fn Walker , Expression Statement : function ( token ) { if ( token . directive & & token . directive . to Lower Case ( ) = = = 'use strict ' ) scope . strict = true ; } , Catch Clause : function ( token , scope ) { var new Scope = new Scope ( 'catch ' , scope ) ; scope . put ( token . param . name , { type : 'catch ' , token : null } ) ; token . body . scope = new Scope ; this . scopes . push ( scope ) ; } , Identifier : function ( token , scope ) { var parent = this . top ( 1 ) ; 
function Scope ( type , parent Scope , this Object ) { this . type = type | | 'unknown ' ; this . this Object = this Object | | utils . create Identifier ( 'undefined ' ) ; this . subscopes = [ ] ; this . names = { } ; this . declarations = [ ] ; if ( parent Scope ) { this . parent = parent Scope ; this . root = parent Scope . root ; this . strict = parent Scope . strict ; parent Scope . subscopes . push ( this ) ; } else { this . root = this ; } this . put ( 'this ' , { type : 'readonly ' , token : this . this Object } ) ; } 
function Customer ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Customer . super _ . apply ( this , arguments ) ; } 
function copy ( obj ) { return Object . get Own Property Names ( obj | | { } ) . reduce ( ( a , c ) = > { a [ c ] = obj [ c ] ; return a ; } , { } ) ; } 
function format With ( options ) { options = Object . assign ( { } , DEFAULTS , options ) ; return ( message , . . . args ) = > { return _formatter ( options , message , . . . args ) ; } ; } 
function ( obj ) { var that = { } ; that . obj = obj ; var method ; var con ; if ( typeof window ! = = 'undefined ' ) { window . console = window . console | | { } ; con = window . console ; } else { con = console | | { } ; } if ( ! con [ 'debug ' ] ) { con . debug = con . log ; } 
function ( source Dir , dest File , opts ) { opts = opts | | { archive _path : ' / ' } ; return new Promise ( function ( resolve , reject ) { try { var archive = archiver . create ( 'zip ' , { zlib : { level : 9 } } ) ; var output = fs . create Write Stream ( dest File ) ; output . on ( 'finish ' , function ( ) { resolve ( dest File ) ; } ) ; archive . pipe ( output ) ; archive . directory ( source Dir , opts . archive _path ) ; archive . finalize ( ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function ( source File , dest Dir ) { return new Promise ( function ( resolve , reject ) { var zip = new Adm Zip ( source File ) ; try { zip . extract All To ( dest Dir ) ; resolve ( dest Dir ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function ( source Dir , dest File , opts ) { opts = opts | | { archive _path : ' / ' } ; return new Promise ( function ( resolve , reject ) { 
function ( source File , dest Dir ) { return new Promise ( function ( resolve , reject ) { 
function _is Negative Number ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . NEGATIVE _NUMBER _REX . test ( val ) ; } return REGEX _ENUM . NEGATIVE _NUMBER _REX . test ( val ) ; } 
async function make ( dir ) { try { await make Promise ( mkdir , dir ) } catch ( err ) { if ( err . code = = 'ENOENT ' ) { const parent Dir = dirname ( dir ) await make ( parent Dir ) await make ( dir ) } else if ( err . code ! = 'EEXIST ' ) { 
function fabricator ( stack , options ) { options = options | | { } ; 
function read ( filepath , options ) { if ( 'string ' ! = = is ( filepath ) ) return fabricator ( filepath , options ) ; if ( options . source ) filepath = path . resolve ( options . source , filepath ) ; 
function iterator ( traverse , obj , options ) { return function reduce ( stack , entity ) { var base = obj ? obj [ entity ] : entity , name = options . name | | entity ; 
function js ( file ) { var type = is ( file ) ; return 'function ' = = = type | | 'string ' = = = type & & path . extname ( file ) = = = ' .js ' ; } 
function empty ( value ) { if ( ! value ) return true ; switch ( is ( value ) ) { case "object " : return ! Object . keys ( value ) . length ; case "array " : return ! value . length ; default : return ! value ; } } 
function init ( constructor , name , options ) { constructor = ( 'string ' = = = is ( constructor ) ) ? require ( constructor ) : constructor ; 
function click ( e ) { var op = 'remove ' ; if ( this . class Name = = = 'menu Link ' ) { op = document . body . class List . contains ( 'menu -open ' ) ? 'remove ' : 'add ' ; e . prevent Default ( ) ; } document . body . class List [ op ] ( 'menu -open ' ) ; } 
function Shell Stream ( args ) { if ( this instanceof Shell Stream = = = false ) { return new Shell Stream ( args ) ; } this . _command = args ; this . _events = [ ] ; var self = this ; 
function read ( path , options , callback ) { var str = read Cache [ path ] ; var cached = options . cache & & str & & ( 'string ' = = = typeof str ) ; 
function ( name , specs ) { this . name = name ; this . id = 0 ; this . properties = specs . properties | | [ ] ; this . extends = specs . extends | | null ; this . depends = specs . depends | | null ; this . factory = specs . factory | | "new " ; this . init = specs . init | | "default " ; this . frequent = false ; this . keep Used Properties = false ; this . init Properties = true ; this . init Constructor Args = [ ] ; this . prop Custom Assign = { } ; this . prop Assign = " " ; this . prop Custom Get = { } ; this . prop Get = " " ; this . post Init = specs . post Init | | " " ; this . embed = specs . embed | | [ ] ; if ( this . post Init ) this . post Init + = " \n " ; 
function ( o ) { 
function ( inst Var , prefix ) { var code = " [ " , get Code = " " , prop = " " , default Get = " $inst . $prop " ; if ( this . default Get ) default Get = default Get ; for ( var i = 0 , l = this . properties . length ; i < l ; + + i ) { prop = this . properties [ i ] ; if ( i > 0 ) code + = " , " ; if ( this . prop Custom Get [ prop ] ) { get Code = this . prop Custom Get [ prop ] . replace ( / \ $inst / g , inst Var ) . replace ( / \ $prop / g , prop ) ; } else { get Code = default Get . replace ( / \ $inst / g , inst Var ) . replace ( / \ $prop / g , prop ) ; } 
function ( ) { var props = this . properties . slice ( ) . sort ( ) ; return 'init ' + crypto . create Hash ( 'md 5 ' ) . update ( props . join ( " , " ) ) . digest ( "hex " ) ; } 
function ( inst Var , val Var , pagesz Var , offset Var , prefix , indent ) { var code = " " , used Props = { } , default Assign = " $inst . $prop = $value " , replace Variable Macro = ( function ( s , v ) { var i = this . properties . index Of ( v ) ; if ( i > = 0 ) { used Props [ v ] = true ; } else { throw "Macro " + s + " refers to a property not part of property table ! " ; } } ) . bind ( this ) ; 
function buffer Mode ( contents , options , callback ) { Profile Compiler ( contents . to String ( 'utf - 8 ' ) , options , function ( err , enc Buf , dec Buf ) { if ( err ) { callback ( err ) ; return ; } 
function stream Mode ( contents , options , callback ) { to Array ( contents , function ( err , chunks ) { if ( err ) { callback ( err ) ; return ; } buffer Mode ( Buffer . concat ( chunks ) , options , function ( err , enc Buf , dec Buf ) { if ( err ) { callback ( err ) ; return ; } var enc Stream = new Readable ( ) ; enc Stream . push ( enc Buf ) ; enc Stream . push ( null ) ; var dec Stream = new Readable ( ) ; dec Stream . push ( dec Buf ) ; dec Stream . push ( null ) ; 
function ( err , enc Contents , dec Contents ) { 
function journal ( ) { 'use strict ' ; var fs = require ( 'fs ' ) ; 
function log Creation Event ( id , type , message , time ) { if ( log Mode = = = 'l ' ) { if ( ! event List . creation Events [ id ] ) { event List . creation Events [ id ] = [ ] ; } event List . creation Events [ id ] . push ( { 'type ' : type , 'event ' : message , "timestamp " : time } ) ; } else if ( log Mode = = = 'v ' ) { console . log ( type + ' : Agent ' + id + ' ' + message + ' on ' + time ) ; } } 
function log Execution Event ( id , type , message , time ) { if ( log Mode = = = 'l ' ) { if ( ! event List . execution Events [ id ] ) { event List . execution Events [ id ] = [ ] ; } event List . execution Events [ id ] . push ( { 'type ' : type , 'event ' : message , "timestamp " : time } ) ; } else if ( log Mode = = = 'v ' ) { console . log ( type + ' : Agent ' + id + ' ' + message + ' on ' + time ) ; } } 
function report ( log File ) { var default Log File = ( new Date ( ) ) . to JSON ( ) + ' .log ' ; var data = JSON . stringify ( event List , null , 3 ) ; if ( log File ) { fs . write File ( log File , data , function ( err ) { if ( err ) { console . log ( ' \n Could not write log to file " ' + log File + ' " \n ' + err ) ; fs . write File ( default Log File , data , function ( err ) { if ( err ) { console . log ( 'Could not write log file : ' + err ) ; } else { console . log ( 'Log was written on default file " ' + default Log File + ' " ' ) ; } } ) ; } } ) ; } else { fs . write File ( default Log File , data , function ( err ) { if ( err ) { console . log ( 'Could not write log file : ' + err ) ; } } ) ; } } 
function scope Url ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . teamcenter _team _id ) throw new Error ( 'teamcenter _team _id required to make Team Center Contact instance api calls ' ) if ( ! options . teamcenter _member _id ) throw new Error ( 'teamcenter _member _id require to make Team Center Contact instance api calls ' ) return ngin . Team Center Team . url Root ( ) + ' / ' + options . teamcenter _team _id + ngin . Team Center Member . url Root ( ) + ' / ' + options . teamcenter _member _id + Team Center Contact . url Root ( ) } 
function install Object Observe ( ) { var properties = [ "advanced Search Config " , "audits Panel Split View State " , "audits Sidebar Width " , "blocked URLs " , "breakpoints " , "cache Disabled " , "color Format " , "console History " , "console Timestamps Enabled " , "cpu Profiler View " , "css Source Maps Enabled " , "current Dock State " , "custom Color Palette " , "custom Device Presets " , "custom Emulated Device List " , "custom Formatters " , "custom User Agent " , "database Table View Visible Columns " , "data Grid -cookies Table " , "data Grid -DOMStorage Items View " , "debugger Sidebar Hidden " , "disable Data Saver Infobar " , "disable Paused State Overlay " , "dom Breakpoints " , "dom Word Wrap " , "elements Panel Split View State " , "elements Sidebar Width " , "emulation .device Height " , "emulation .device Mode Value " , "emulation .device Orientation Override " , "emulation .device Scale " , "emulation .device Scale Factor " , "emulation .device UA " , "emulation .device Width " , "emulation .geolocation Override " , "emulation .show Device Mode " , "emulation .show Rulers " , "enable Async Stack Traces " , "event Listener Breakpoints " , "file Mapping Entries " , "file System Mapping " , "File System View Sidebar Width " , "file System View Split View State " , "filter Bar -console View " , "filter Bar -network Panel " , "filter Bar -promise Pane " , "filter Bar -timeline Panel " , "frame Viewer Hide Chrome Window " , "heap Snapshot Retainers View Size " , "heap Snapshot Split View State " , "hide Collected Promises " , "hide Network Messages " , "highlight Node On Hover In Overlay " , "high Resolution Cpu Profiling " , "inline Variable Values " , "Inspector .drawer Split View " , "Inspector .drawer Split View State " , "Inspector View .panel Order " , "Inspector View .screencast Split View " , "Inspector View .screencast Split View State " , "Inspector View .split View " , "Inspector View .split View State " , "java Script Disabled " , "js Source Maps Enabled " , "last Active Panel " , "last Dock State " , "last Selected Sources Sidebar Pane Tab " , "last Snippet Evaluation Index " , "layer Details Split View " , "layer Details Split View State " , "layers Panel Split View State " , "layers Show Internal Layers " , "layers Sidebar Width " , "message Level Filters " , "message URLFilters " , "monitoring XHREnabled " , "navigator Group By Folder " , "navigator Hidden " , "network Color Code Resource Types " , "network Conditions " , "network Conditions Custom Profiles " , "network Hide Data URL " , "network Log Columns Visibility " , "network Log Large Rows " , "network Log Show Overview " , "network Panel Split View State " , "network Record Film Strip Setting " , "network Resource Type Filters " , "network Show Primary Load Waterfall " , "network Sidebar Width " , "open Link Handler " , "pause On Caught Exception " , "pause On Exception Enabled " , "preserve Console Log " , "pretty Print Infobar Disabled " , "previously Viewed Files " , "profiles Panel Split View State " , "profiles Sidebar Width " , "promise Status Filters " , "record Allocation Stacks " , "request Header Filter Setting " , "request -info -form Data -category -expanded " , "request -info -general -category -expanded " , "request -info -query String -category -expanded " , "request -info -request Headers -category -expanded " , "request -info -request Payload -category -expanded " , "request -info -response Headers -category -expanded " , "resources " , "resources Last Selected Item " , "resources Panel Split View State " , "resources Sidebar Width " , "resource View Tab " , "saved URLs " , "screencast Enabled " , "scripts Panel Navigator Sidebar Width " , "search In Content Scripts " , "selected Audit Categories " , "selected Color Palette " , "selected Profile Type " , "shortcut Panel Switch " , "show Advanced Heap Snapshot Properties " , "show Event Listeners For Ancestors " , "show Frameowkr Listeners " , "show Hea Snapshot Objects Hidden Properties " , "show Inherited Computed Style Properties " , "show Media Query Inspector " , "show Native Functions In JSProfile " , "show UAShadow DOM " , "show Whitespaces In Editor " , "sidebar Position " , "skip Content Scripts " , "skip Stack Frames Pattern " , "source Map Infobar Disabled " , "sources Panel Debugger Sidebar Split View State " , "sources Panel Navigator Split View State " , "sources Panel Split Sidebar Ratio " , "sources Panel Split View State " , "sources Sidebar Width " , "standard Emulated Device List " , "Styles Pane Split Ratio " , "styles Pane Split View State " , "text Editor Autocompletion " , "text Editor Auto Detect Indent " , "text Editor Bracket Matching " , "text Editor Indent " , "timeline Capture Film Strip " , "timeline Capture Layers And Pictures " , "timeline Capture Memory " , "timeline Capture Network " , "timeline -details " , "timeline Enable JSSampling " , "timeline Overview Mode " , "timeline Panel Details Split View State " , "timeline Panel Recors Split View State " , "timeline Panel Timeline Stack Split View State " , "timeline Perspective " , "timeline -split " , "timeline Tree Group By " , "timeline -view " , "timeline View Mode " , "ui Theme " , "watch Expressions " , "Web Inspector .Drawer .last Selected View " , "Web Inspector .Drawer .show On Load " , "workspace Excluded Folders " , "workspace Folder Exclude Pattern " , "workspace Infobar Disabled " , "workspace Mapping Infobar Disabled " , "xhr Breakpoints " ] ; function setting Remove ( ) { this . _storage [ this . _name ] = undefined ; } function object Observe ( object , observer ) { if ( window [ "Web Inspector " ] ) { var setting Prototype = window [ "Web Inspector " ] [ "Setting " ] [ "prototype " ] ; if ( typeof setting Prototype [ "remove " ] = = = "function " ) setting Prototype [ "remove " ] = setting Remove ; } var changed Properties = new Set ( ) ; var scheduled = false ; function schedule Observer ( ) { if ( ! scheduled ) { scheduled = true ; set Immediate ( call Observer ) ; } } function call Observer ( ) { scheduled = false ; var changes = [ ] ; changed Properties . for Each ( function ( name ) { changes . push ( { name : name } ) ; } ) ; changed Properties . clear ( ) ; observer . call ( null , changes ) ; } var storage = new Map ( ) ; function define Property ( property ) { if ( property in object ) { storage . set ( property , object [ property ] ) ; delete object [ property ] ; } Object . define Property ( object , property , { get : function ( ) { return storage . get ( property ) ; } , set : function ( value ) { storage . set ( property , value ) ; changed Properties . add ( property ) ; schedule Observer ( ) ; } } ) ; } for ( var i = 0 ; i < properties . length ; + + i ) define Property ( properties [ i ] ) ; } window . Object . observe = object Observe ; } 
function Article Translation ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Article Translation . super _ . apply ( this , arguments ) ; } 
function ( list , options ) { 
function require ( p , root ) { 
function Macro Action ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Macro Action . super _ . apply ( this , arguments ) ; } 
function map ( obj , source , target , is Recursive = true ) { 
function ( visit , on Fail , opts ) { var fail = on Fail ? on Fail : utils . ret ( false ) , config = opts | | { compact : true } ; return function ( list ) { var p = Promise . resolve ( false ) , results = [ ] ; list . for Each ( function ( l , i ) { p = p . then ( visit . bind ( null , l ) ) . catch ( function ( err ) { return fail ( err , l ) ; } ) . then ( function ( result ) { results . push ( result ) ; if ( config . on Progress ) config . on Progress ( list . length , i + 1 , l ) ; } ) ; } ) ; return p . then ( function ( ) { return config . compact ? results . filter ( Boolean ) : results ; } ) ; } ; } 
function ( module , fn ) { var has Module = typeof module ! = = 'function ' , f = has Module ? module [ fn ] : module , mod = has Module ? module : null ; return function ( ) { var args = [ ] , i = arguments . length - 1 ; while ( i > = 0 & & typeof arguments [ i ] = = = 'undefined ' ) { - - i ; } while ( i > = 0 ) { args . unshift ( arguments [ i ] ) ; - - i ; } return new Promise ( function ( resolve , reject ) { try { resolve ( f . apply ( mod , args ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } ; } 
function ( module , opts ) { var config = opts | | { } , is Valid = config . is Valid | | function ( f , fn , mod ) { return typeof f = = = 'function ' & & fn [ 0 ] ! = = ' _ ' & & fn [ 0 ] . to Upper Case ( ) ! = = fn [ 0 ] & & ! fn . ends With ( 'Sync ' ) ; } ; return utils . map Object ( module , function ( f , fn , mod ) { return utils . promisify ( mod , fn ) ; } , is Valid ) ; } 
function resource ( object , data ) { if ( data = = = undefined ) return resource Map . get ( object ) | | { } ; if ( ! object | | typeof object ! = = "object " & & typeof object ! = = "function " | | resource Map . has ( object ) ) throw new Type Error ( "Could not transform given object into a resource . " ) ; if ( ! data | | typeof data ! = = "object " ) throw new Type Error ( "Resource data has to be an object . " ) ; resource Map . set ( object , data ) ; return object ; } 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) if ( typeof options ! = = 'object ' & & ! options . flight _id ) throw new Error ( 'flight _id required to make flight defaults api calls ' ) return ngin . Flight . url Root ( ) + ' / ' + options . flight _id + Flight Stage . url Root ( ) } 
function ( ) { console . warn ( 'Code is using deprecated teams _advancing , switch to teams Advancing ' ) var where = ( new Error ( ) . stack | | ' ' ) . split ( ' \n ' , 3 ) [ 2 ] if ( where ) console . warn ( where ) this . teams Advancing . apply ( this , arguments ) } 
function get Index Of Primitive ( primitive , array , starting Position ) { if ( starting Position = = = void 0 ) { starting Position = 0 ; } error If Not Primitive _ 1 . error If Not Primitive ( primitive ) ; error _if _not _populated _array _ 1 . error If Not Populated Array ( array ) ; error If Not Integer _ 1 . error If Not Integer ( starting Position ) ; return array . index Of ( primitive , starting Position ) ; } 
function loads ( xhr , ee ) { var onreadystatechange , onprogress , ontimeout , onabort , onerror , onload , timer ; onerror = xhr . onerror = one ( function onerror ( evt ) { var status = statuscode ( xhr ) , err = fail ( new Error ( 'Network request failed ' ) , status ) ; ee . emit ( 'error ' , err ) ; ee . emit ( 'end ' , err , status ) ; } ) ; onabort = xhr . onabort = function onabort ( evt ) { onerror ( evt ) ; } ; onreadystatechange = xhr . onreadystatechange = function change ( evt ) { var target = evt . target ; if ( 4 = = = target . ready State ) return onload ( evt ) ; } ; ontimeout = xhr . ontimeout = one ( function timeout ( evt ) { ee . emit ( 'timeout ' , evt ) ; * IE needs have it 's `onprogress ` function assigned to a unique function . So , * no touchy touchy here ! * * @param {Event } evt Triggered progress event . * @api private * / onprogress = xhr . onprogress = function progress ( evt ) { var status = statuscode ( xhr ) , data ; ee . emit ( 'progress ' , evt , status ) ; if ( xhr . ready State > = 3 & & status . code = = = 2 0 0 & & ( data = response ( xhr ) ) ) { ee . emit ( 'stream ' , data , status ) ; } } ; / * * * Handle load events an potential data events for when there was no streaming * data . * * @param {Event } evt Triggered load event . * @api private * / onload = xhr . onload = one ( function load ( evt ) { var status = statuscode ( xhr ) , data = response ( xhr ) ; if ( status . code < 1 0 0 | | status . code > 5 9 9 ) return onerror ( evt ) ; / / / / There is a bug in Fire Fox 's XHR 2 implementation where status code 2 0 4 
function sheetify Nest ( filename , source , opts , done ) { var processor = postcss ( [ nest ( opts ) ] ) processor . process ( source ) . then ( function ( res ) { done ( null , res . css ) } ) . catch ( done ) } 
function Cache ( key , opt ) { if ( ! ( this instanceof Cache ) ) return new Cache ( key , opt ) ; if ( key ) this . set Token ( key ) ; this . config = _ . defaults ( opt | | { } , { protocol : 'https ' , fragment : ' _escaped _fragment _ ' , service : 'service .cache .watch ' , path : ' / ' , sender : { method : 'get ' , headers : { 'User -Agent ' : 'Cache Watch Client ' } , } , auth : 'x -cache -watch ' , lengths : 1 5 0 , useragent : pack . config . useragent , url : pack . config . extencion } ) ; var that = this ; that . watch = function Cache Watch ( req , res , next ) { var query = querystring . parse ( url . parse ( req . url ) . query ) ; if ( that . is Not ( req , query ) | | ! that . key ) return next ( ) ; that . get ( that . create Url ( req , query ) , function ( err , resp , body ) { if ( err | | that . res ( resp ) ) return next ( ) ; res . set Header ( 'Cache Watch ' , Cache . version ) ; res . set Header ( 'last -modified ' , resp . headers [ 'last -modified ' ] ) ; res . set Header ( 'content -type ' , resp . headers [ 'content -type ' ] ) ; res . send ( body ) ; } ) ; } ; } 
function add With Dependencies ( all Files , new File , dependencies , current Files , cycle Check ) { if ( cycle Check . index Of ( new File ) > = 0 ) { throw new Error ( 'Dependency cycle found ' + JSON . stringify ( cycle Check ) ) } cycle Check . push ( new File ) try { 
function order Files ( all Files , dependencies ) { var result = [ ] all Files . for Each ( function ( new File ) { add With Dependencies ( all Files , new File , dependencies , result , [ ] ) } ) return result } 
function batch Forms ( batch , form , merkle ) { 
function parse JSON ( input , callback ) { var error var result try { result = JSON . parse ( input ) } catch ( e ) { error = e } callback ( error , result ) } 
function create File ( file Path , file Content ) { var folder Path = file Path . split ( ' / ' ) ; folder Path . pop ( ) ; folder Path = folder Path . join ( ' / ' ) ; if ( ! Utils . exist ( folder Path ) ) create Folder ( folder Path ) ; fs . write File Sync ( file Path , file Content ) ; Utils . log ( 'Created file : ' + file Path ) ; return Utils ; } 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) var route = [ ] if ( options . season _id ) route . push ( 'seasons ' , options . season _id ) if ( options . flight _stage _id ) route . push ( 'flight _stages ' , options . flight _stage _id ) else if ( options . division _id ) route . push ( 'divisions ' , options . division _id ) else if ( options . pool _id ) route . push ( 'pools ' , options . pool _id ) route . push ( 'standings ' ) var base = config . urls & & config . urls . sports | | config . url return Url . resolve ( base , route . join ( ' / ' ) ) } 
function format Num ( value , type ) { const conv = { scientific : " . 3e " , si : " . 3s " , rounded : " . 3r " } ; if ( type = = = 'raw ' ) return value ; if ( value = = = undefined | | value = = = null | | Number . is Na N ( value ) ) return ' ' ; return value = = parse Float ( value ) ? d 3 . format ( conv [ type ] ) ( value ) : value ; } 
function Reconnecting Web Socket ( url , opts ) { if ( ! ( this instanceof Reconnecting Web Socket ) ) { throw new Type Error ( 'Cannot call a constructor as a function ' ) ; } opts = opts | | { } ; var self = this ; function get Opt ( name , def ) { return opts . has Own Property ( name ) ? opts [ name ] : def ; } var timeout = get Opt ( 'timeout ' , 1 0 0 ) ; var max Retries = get Opt ( 'max Retries ' , 5 ) ; var cur Retries = 0 ; 
function get First Index Of Array ( array To Search For , array To Search Inside ) { error If Not Array _ 1 . error If Not Array ( array To Search For ) ; error _if _not _populated _array _ 1 . error If Not Populated Array ( array To Search Inside ) ; return array To Search Inside . find Index ( function ( value ) { return ( is Array _not Array _ 1 . is Array ( value ) & & arrays _match _ 1 . arrays Match ( value , array To Search For ) ) ; } ) ; } 
function _is Positive Integer ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . POSITIVE _INTEGER _REX . test ( val ) ; } return REGEX _ENUM . POSITIVE _INTEGER _REX . test ( val ) ; } 
function client ( protocol ) { if ( ! protocol | | typeof protocol ! = = "object " ) throw new Type Error ( "owe Client Api protocols have to be objects . " ) ; if ( typeof protocol . closer ! = = "function " ) throw new Type Error ( "owe Client Api proctols have to offer a closer function . " ) ; if ( protocol . init & & typeof protocol . init ! = = "function " ) throw new Type Error ( "owe Client Api protocols have to offer an init function . " ) ; let connected = false ; const observers = new Set ( ) ; protocol = Object . assign ( { get connected ( ) { return connected ; } , set connected ( value ) { if ( typeof value ! = = "boolean " ) throw new Type Error ( "Protocol connection state has to be boolean . " ) ; if ( value = = = connected ) return ; connected = value ; for ( const observer of observers ) observer ( connected ) ; } , observe ( observer ) { if ( typeof observer ! = = "function " ) throw new Type Error ( "Protocol connection state observers have to be functions . " ) ; observers . add ( observer ) ; } , unobserve ( observer ) { observers . delete ( observer ) ; } } , protocol ) ; if ( protocol . init ) protocol . init ( ) ; return new Client Api ( protocol ) ; } 
function write Path ( parent Dir , path , data ) { let files = path . split ( ' / ' ) ; let file = files . shift ( ) ; 
function ( main Files ) { for ( var i = 0 ; i < main Files . length ; i + + ) { 
function descendant Roles ( roles , field Name , all Descendants ) { return roles . map ( role = > all Descendants . get ( role ) ) . filter ( descendants = > ! ! descendants ) . map ( descendants = > descendants . get ( field Name ) ) . filter ( field Roles = > ! ! field Roles ) } 
function map Of Maps ( ) { const m = new Map ( ) m . get Or Create = function ( key ) { if ( ! this . has ( key ) ) this . set ( key , map Of Maps ( ) ) return this . get ( key ) } return m } 
function map Of Arrays ( ) { const m = new Map ( ) m . get Or Create = function ( key ) { if ( ! this . has ( key ) ) this . set ( key , [ ] ) return this . get ( key ) } return m } 
function ( ) { this . objects = { } ; this . index = [ ] ; this . _obj Tree = [ ] ; this . _obj List = [ ] ; this . _properties = { } ; this . _prop ID = 0 ; this . _decode Index = [ ] ; this . _obj Freq = [ ] ; this . _obj Infeq = [ ] ; this . short Names = true ; this . indent = " \t " ; this . has Embed = false ; } 
function ( po ) { this . objects [ po . name ] = po ; if ( po . extends ) { this . _obj Tree . push ( [ po . extends , po . name ] ) ; } else if ( po . depends ) { this . _obj Tree . push ( [ po . depends , po . name ] ) ; } else { this . _obj List . push ( po . name ) ; } } 
function ( index _offset , size , depth , prefix , test Var , callback ) { if ( size = = 0 ) return prefix + this . indent + " / * No items * / \n " ; var code = " " ; gen Chunk = ( function ( s , e , d , pf ) { if ( d = = = 0 ) { code + = pf + "switch ( " + test Var + " ) { \n " ; for ( var i = s ; i < e ; + + i ) { code + = pf + this . indent + "case " + ( index _offset + i ) + " : return " + callback ( i ) ; } code + = pf + " } \n " ; } else { 
function ( name ) { var id = this . _properties [ name ] ; if ( id = = = undefined ) { if ( this . short Names ) { id = this . _properties [ name ] = 'p ' + ( this . _prop ID + + ) . to String ( ) } else { id = this . _properties [ name ] = 'p ' + name [ 0 ] . to Upper Case ( ) + name . substr ( 1 ) . to Lower Case ( ) . replace ( / [ , \ . \ - \ _ ] / g , ' _ ' ) } } } 
function ( ) { 
function ( ) { var pn = Object . keys ( this . _properties ) ; var code = "var " ; for ( var i = 0 , l = pn . length ; i < l ; + + i ) { if ( i ! = = 0 ) code + = " , \n " ; code + = this . indent + this . _properties [ pn [ i ] ] + " = ' " + pn [ i ] + " ' " ; } code + = " ; \n " ; return code ; } 
function ( ) { var code = " " ; 
function ( prefix ) { var code = "function ( id ) { \n " ; code + = prefix + this . indent + "if (id < " + MAX _FREQ _ITEMS + " ) { \n " ; code + = this . generate Dn Cif ( 0 , this . _obj Freq . length , 3 , prefix + this . indent , 'id ' , ( function ( i ) { return "factory _ " + this . _obj Freq [ i ] . safe Name + " ; \n " } ) . bind ( this ) ) ; code + = prefix + this . indent + " } else { \n " ; code + = this . generate Dn Cif ( MAX _FREQ _ITEMS , this . _obj Infeq . length , 3 , prefix + this . indent , 'id ' , ( function ( i ) { return "factory _ " + this . _obj Infeq [ i ] . safe Name + " ; \n " } ) . bind ( this ) ) ; code + = prefix + this . indent + " } \n " ; code + = prefix + " } \n " ; return code ; } 
function ( prefix ) { var code = "function ( inst ) { \n " ; for ( var i = 0 , l = this . index . length ; i < l ; + + i ) { var o = this . index [ i ] ; if ( i = = = 0 ) code + = prefix + this . indent + "if " ; else code + = prefix + this . indent + " } else if " ; code + = " (inst instanceof " + o . name + " ) { \n " ; code + = prefix + this . indent + this . indent + "return [ " + o . id + " , getter _ " + o . safe Name + " ] ; \n " ; } code + = prefix + this . indent + " } \n " ; code + = prefix + " } \n " return code ; } 
function ( ) { var code = " " ; 
function Client ( options ) { options = options | | { } ; this . is Client = true ; this . subdomain = options . subdomain ; this . endpoint = options . endpoint ; if ( ! this . subdomain & & ! this . endpoint ) throw new Error ( 'No subdomain was specified . ' ) ; 
function _is Positive Number ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . POSITIVE _NUMBER _REX . test ( val ) ; } return REGEX _ENUM . POSITIVE _NUMBER _REX . test ( val ) ; } 
function scope Url ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season _id & & ! options . team _id & & ! ( options . flight _stage _id & & options . flight _id ) ) throw new Error ( 'flight _stage _id +flight _id , season _id and /or team _id required to make team instance api calls ' ) if ( options . flight _stage _id & & options . flight _id ) { var url = ngin . Flight . url Root ( ) + ' / ' + options . flight _id + ' /flight _stages / ' + options . flight _stage _id + ' /teams ' return options . team _id ? url + ' / ' + options . team _id : url } else if ( options . season _id ) { var url = ngin . Season . url Root ( ) + ' / ' + options . season _id + ' /teams ' return options . team _id ? url + ' / ' + options . team _id : url } else { return ngin . Team . url Root ( ) + ' / ' + options . team _id + ngin . Team Instance . url Root ( ) } } 
function Imagesloader ( opts ) { var self = { } ; var opts = opts | | { } ; var imageloader = Imageloader ( ) ; var imgs = [ ] ; var srcs = [ ] ; var def ; function load ( images ) { def = Deferred ( ) ; srcs = convert Images To Src ( images ) ; for ( var i = 0 ; i < srcs . length ; i + + ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { image Loaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn \ 't be loaded ' ) ; } ) ; } ; return def . promise ; } / * * * Image loaded checker * @param {img } img The loaded image * / function image Loaded ( img ) { / * * Notify the promise * / def . notify ( "notify " ) ; / * * Add the image to the imgs array * / imgs . push ( img ) ; / * * If the imgs array size is the same as the src 's * / if ( imgs . length = = srcs . length ) { sort Images ( ) ; def . resolve ( imgs ) ; } } function convert Images To Src ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i + + ) { if ( typeof imgs [ i ] = = 'object ' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; } function sort Images ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i + + ) { for ( var j = 0 ; j < imgs . length ; j + + ) { var str = imgs [ j ] . src . to String ( ) ; var reg = new Reg Exp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; } self . load = load ; return self ; } 
function load ( images ) { def = Deferred ( ) ; srcs = convert Images To Src ( images ) ; for ( var i = 0 ; i < srcs . length ; i + + ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { image Loaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn \ 't be loaded ' ) ; } ) ; } ; return def . promise ; } 
function image Loaded ( img ) { def . notify ( "notify " ) ; imgs . push ( img ) ; if ( imgs . length = = srcs . length ) { sort Images ( ) ; def . resolve ( imgs ) ; } } 
function convert Images To Src ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i + + ) { if ( typeof imgs [ i ] = = 'object ' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; } 
function sort Images ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i + + ) { for ( var j = 0 ; j < imgs . length ; j + + ) { var str = imgs [ j ] . src . to String ( ) ; var reg = new Reg Exp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; } 
function builder ( env List , env Name ) { if ( env List = = null ) { env List = DEFAULT _ENV _LIST ; } if ( env Name = = null ) { env Name = DEFAULT _ENV _NAME ; } if ( ! Array . is Array ( env List ) ) { throw new Error ( 'env List must be an array ' ) ; } if ( typeof env Name ! = = 'string ' ) { throw new Error ( 'env Name must be a string ' ) ; } * . * / 
function Data Type _Array _to String ( source ) { 
function agent ( agency , jn ) { 'use strict ' ; 
function validate Id ( id ) { if ( id & & id . trim ( ) & & / ^ [a -z A -Z 0 - 9 _ ] + $ / . test ( id ) ) { if ( agency . is Id In Use ( id ) ) { err . name = 'Duplicate Id Error ' ; err . message = 'duplication (use a different id ) ' ; return err ; } else { return id ; } } else { err . name = 'Validate Id Error ' ; err . message = 'failed id validation (please use alphanumeric characters and underscore ) ' ; return err ; } } 
function array Get Uniques ( arr ) { var a = [ ] ; for ( var i = 0 , l = arr . length ; i < l ; i + + ) { if ( a . index Of ( arr [ i ] ) = = = - 1 & & arr [ i ] ! = = ' ' ) a . push ( arr [ i ] ) ; } return a ; } 
function parse Expression ( expr ) { var parent List = [ ] ; var parsed Tokenized Expression = [ ] ; var parsed Expression = ' ' ; var test Invalid Char ; if ( expr & & expr . trim ( ) ) { parsed Expression = expr . replace ( / \ 0 4 0 / g , ' ' ) ; test Invalid Char = / [ ^a -z A -Z 0 - 9 _ & | ! ( ) _ ] / . test ( parsed Expression ) ; 
function set Function ( f ) { if ( can Execute ) { if ( Object . get Prototype Of ( f ) = = = Function . prototype ) { func = f ; jn . log Creation Event ( id , 'INFO ' , 'function definition completed ' , ( new Date ( ) ) . to JSON ( ) ) ; } else { set Can Execute ( false ) ; jn . log Creation Event ( id , 'ERROR ' , 'function definition failed ' , ( new Date ( ) ) . to JSON ( ) ) ; } } } 
function set Callback ( cb ) { if ( can Execute ) { if ( Object . get Prototype Of ( cb ) = = = Function . prototype ) { callback = cb ; jn . log Creation Event ( id , 'INFO ' , 'callback definition completed ' , ( new Date ( ) ) . to JSON ( ) ) ; } else { set Can Execute ( false ) ; jn . log Creation Event ( id , 'ERROR ' , 'callback definition failed ' , ( new Date ( ) ) . to JSON ( ) ) ; } } } 
function get Value Of Agent ( dep ) { var len = dependencies . length ; for ( var i = 0 ; i < len ; i + + ) { if ( dep = = = dependencies [ i ] ) { return agency . get Agent Value ( dep ) ; } } jn . log Execution Event ( id , 'INFO ' , 'could not get value of agent ' + dep + ' (not a dependency ) ' , ( new Date ( ) ) . to JSON ( ) ) ; return null ; } 
function execute ( ) { var res ; var function Interface = { get Value Of Agent : get Value Of Agent } ; if ( func ) { set Waiting Exec ( true ) ; set Timeout ( function ( ) { var error On Execution = false ; jn . log Execution Event ( id , 'INFO ' , 'began function execution ' , ( new Date ( ) ) . to JSON ( ) ) ; try { res = func ( function Interface ) ; set Result ( res ) ; if ( callback ) { callback ( null , res ) ; } jn . log Execution Event ( id , 'INFO ' , 'function executed whitout errors ' , ( new Date ( ) ) . to JSON ( ) ) ; } catch ( err ) { error On Execution = true ; set Result ( err ) ; jn . log Execution Event ( id , 'ERROR ' , 'failed to execute function : ' + err . message , ( new Date ( ) ) . to JSON ( ) ) ; if ( callback ) { callback ( err ) ; } } set Executed ( true ) ; set Waiting Exec ( false ) ; if ( halts Execution & & error On Execution ) { jn . log Execution Event ( id , 'ERROR ' , 'error on execution halted agency execution ' , ( new Date ( ) ) . to JSON ( ) ) ; agency . report ( ) ; } else { agency . run Agents ( ) ; } } , 0 ) ; } else { jn . log Execution Event ( id , 'INFO ' , 'does not have a defined function ' , ( new Date ( ) ) . to JSON ( ) ) ; } } 
function Case ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Case . super _ . apply ( this , arguments ) ; } 
function ( panel Name ) { if ( this . _current Panel Locked ) { if ( this . _current Panel ! = = this . _panels [ panel Name ] ) return Promise . reject ( new Error ( "Current panel locked " ) ) ; return Promise . resolve ( this . _current Panel ) ; } this . _panel For Show Promise = this . panel ( panel Name ) ; return this . _panel For Show Promise . then ( set Current Panel If Necessary . bind ( this , this . _panel For Show Promise ) ) ; function set Current Panel If Necessary ( panel Promise , panel ) { if ( this . _panel For Show Promise ! = = panel Promise ) return null ; this . set Current Panel ( panel ) ; return panel ; } } 
function Resource ( parent , definition ) { this . parent = parent ; this . definition = definition ; 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) var url = config . urls & & config . urls . sports | | config . url url = ngin . Season . url Root ( ) + ' / ' + options . season _id + ' /teams / ' + options . team _id + ' /rosters ' if ( options . id ) url + = ' / ' + options . id return url } 
function ( ctx ) { var DMYRegex = / ^ ( [ 0 - 9 ] { 1 , 2 } ) [ \ . \ - \ / ] ( [ 0 - 9 ] { 1 , 2 } ) [ \ . \ - \ / ] ( [ 0 - 9 ] { 4 , 4 } ) \s ( [ 0 - 9 ] { 1 , 2 } ) : ( [ 0 - 9 ] { 1 , 2 } ) : ( [ 0 - 9 ] { 1 , 2 } ) / gi ; var regexmatch = DMYRegex . exec ( ctx . value ) ; if ( ! regexmatch | | regexmatch . length ! = = 7 ) { return console . log ( 'valdiation error - - not DMY ' , ctx ) ; } var datetime = [ [ regexmatch [ 3 ] , regexmatch [ 2 ] , regexmatch [ 1 ] ] . join ( ' - ' ) , [ regexmatch [ 4 ] , regexmatch [ 5 ] , regexmatch [ 6 ] ] . join ( ' : ' ) ] . join ( ' ' ) ; var date = new Date ( datetime ) ; ctx . value = date . get Time ( ) ; return ctx ; } 
function ( result ) { var body = JSON . parse ( result . body ) ; 
function get Indexes Of Array ( array To Search For , array To Search Inside ) { error If Not Array _ 1 . error If Not Array ( array To Search For ) ; error _if _not _populated _array _ 1 . error If Not Populated Array ( array To Search Inside ) ; var indexes = [ ] ; array To Search Inside . filter ( function ( value , index ) { if ( is Array _not Array _ 1 . is Array ( value ) & & arrays _match _ 1 . arrays Match ( value , array To Search For ) ) { indexes . push ( index ) ; return true ; } else return false ; } ) ; return indexes ; } 
function _is Zero ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( _is Number ( val ) ) { return val - 0 = = = 0 ; } if ( opts . is Strict ! = = true ) { return _is Real Number ( val ) & & val - 0 = = = 0 ; } return false ; } 
function container Slug ( language _slug , project _slug , resource _slug ) { if ( ! language _slug | | ! project _slug | | ! resource _slug ) throw new Error ( 'Invalid resource container slug parameters ' ) ; return language _slug + ' _ ' + project _slug + ' _ ' + resource _slug ; } 
function Container ( container _directory , package _json ) { let config _yaml = { } ; let toc _yaml = { } ; assert ( container _directory , 'resource -container : missing container _directory ' ) ; assert . equal ( typeof container _directory , 'string ' , 'resource -container : container _directory should be a string ' ) ; try { let config File = path . join ( container _directory , content _dir , 'config .yml ' ) ; if ( file Utils . file Exists ( config File ) ) config _yaml = YAML . parse ( fs . read File Sync ( config File , { encoding : 'utf 8 ' } ) ) ; } catch ( err ) { console . warn ( err ) ; } try { let toc File = path . join ( container _directory , content _dir , 'toc .yml ' ) ; if ( file Utils . file Exists ( toc File ) ) toc _yaml = YAML . parse ( fs . read File Sync ( toc File , { encoding : 'utf 8 ' } ) ) ; } catch ( err ) { console . warn ( err ) ; } assert ( package _json , 'resource -container : missing package json ' ) ; assert ( package _json . language , 'resource -container : missing language ' ) ; assert ( package _json . project , 'resource -container : missing project ' ) ; assert ( package _json . resource , 'resource -container : missing resource ' ) ; assert ( package _json . resource . type , 'resource -container : missing resource type ' ) ; return { get language ( ) { return package _json . language ; } , get project ( ) { return package _json . project ; } , get resource ( ) { return package _json . resource ; } , chapters : function ( ) { let dir = path . join ( container _directory , content _dir ) ; return fs . readdir Sync ( dir ) . filter ( function ( file ) { try { return fs . stat Sync ( file ) . is Directory ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } , chunks : function ( chapter Slug ) { let dir = path . join ( container _directory , content _dir , chapter Slug ) ; return fs . readdir Sync ( dir ) . filter ( function ( file ) { try { return fs . stat Sync ( file ) . is File ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } , read Chunk : function ( chapter Slug , chunk Slug ) { let file = path . join ( container _directory , content _dir , chapter Slug , chunk Slug + ' . ' + this . chunk Ext ) ; return fs . read File Sync ( file , { encoding : 'utf 8 ' } ) ; } , get chunk Ext ( ) { switch ( package _json [ 'content _mime _type ' ] ) { case 'text /usx ' : return 'usx ' ; case 'text /usfm ' : return 'usfm ' ; case 'text /markdown ' : return 'md ' ; default : return 'txt ' ; } } , get path ( ) { return container _directory ; } , get slug ( ) { return container Slug ( package _json . language . slug , package _json . project . slug , package _json . resource . slug ) ; } , get type ( ) { return package _json . resource . type ; } , get info ( ) { return package _json ; } , get config ( ) { return config _yaml ; } , get toc ( ) { return toc _yaml ; } } ; } 
function ( ) { let dir = path . join ( container _directory , content _dir ) ; return fs . readdir Sync ( dir ) . filter ( function ( file ) { try { return fs . stat Sync ( file ) . is Directory ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } 
function ( chapter Slug , chunk Slug ) { let file = path . join ( container _directory , content _dir , chapter Slug , chunk Slug + ' . ' + this . chunk Ext ) ; return fs . read File Sync ( file , { encoding : 'utf 8 ' } ) ; } 
function make Container ( container _directory , opts ) { return new Promise ( function ( resolve , reject ) { if ( file Utils . file Exists ( container _directory ) ) { reject ( new Error ( 'Container already exists ' ) ) ; return ; } let package _json = { } ; 
function open Container ( container _archive , container _directory , opts ) { opts = opts | | { compression _method : 'tar ' } ; if ( file Utils . file Exists ( container _directory ) ) { return load Container ( container _directory ) ; } if ( ! file Utils . file Exists ( container _archive ) ) return Promise . reject ( new Error ( 'Missing resource container ' ) ) ; if ( opts . compression _method = = = 'zip ' ) { return compression Utils . unzip ( container _archive , container _directory ) . then ( function ( dir ) { return load Container ( dir ) ; } ) ; } else { return compression Utils . untar ( container _archive , container _directory ) . then ( function ( dir ) { return load Container ( dir ) ; } ) ; } } 
function close Container ( container _directory , opts ) { opts = opts | | { compression _method : 'tar ' , clean : true } ; if ( ! file Utils . file Exists ( container _directory ) ) return Promise . reject ( new Error ( 'Missing resource container ' ) ) ; var container _archive = container _directory + ' . ' + spec . file _ext ; var compress Promise = Promise . resolve ( container _archive ) ; 
function localize Chapter Title ( language _slug , chapter _number ) { var translations = { 'ar ' : '      % ' , 'en ' : 'Chapter % ' , 'ru ' : '      % ' , 'hu ' : ' % . fejezet ' , 'sr -Latin ' : '         % ' , 'default ' : 'Chapter % ' } ; var title = translations [ language _slug ] ; if ( ! title ) title = translations [ 'default ' ] ; var num = parse Int ( chapter _number ) ; if ( is Na N ( num ) ) num = chapter _number ; return title . replace ( ' % ' , num ) ; } 
function normalize Slug ( slug ) { if ( typeof slug ! = = 'string ' ) throw new Error ( 'slug must be a string ' ) ; if ( slug = = = ' ' ) throw new Error ( 'slug cannot be an empty string ' ) ; if ( is Na N ( Number ( slug ) ) ) return slug ; slug = slug . replace ( / ^ ( 0 + ) / , ' ' ) . trim ( ) ; while ( slug . length < 2 ) { slug = ' 0 ' + slug ; } return slug ; } 
function inspect Container ( container _path , opts ) { return new Promise ( function ( resolve , reject ) { if ( path . extname ( container _path ) ! = = ' . ' + spec . file _ext ) { reject ( new Error ( 'Invalid resource container file extension ' ) ) ; return ; } try { resolve ( fs . stat Sync ( container _path ) . is File ( ) ) ; } catch ( err ) { reject ( new Error ( 'The resource container does not exist at ' , container _path ) ) ; } } ) . then ( function ( is File ) { if ( is File ) { 
function scope Url ( options , inst , action ) { var opts = _ . extend ( { } , inst , options ) if ( ! opts . id & & ! opts . tournament _id & & ! opts . league _id & & ! opts . season _id ) throw new Error ( 'id , season _id , tournament _id or league _id required to make survey api calls ' ) return Survey . url Root ( ) + ' / ' + action + ( opts . id ? ' / ' + opts . id : ' ' ) + ' .json ' } 
function ( ) { var header Table Columns = this . _header Table Column Group . children ; 
function User Preference ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } User Preference . super _ . apply ( this , arguments ) ; } 
function ( room , sockets ) { 
function ( Crafty , socket ) { 
function ( Crafty , socket ) { 
function Server ( sockets ) { return { create Instance : function ( room ) { return create Instance ( room , sockets ) ; } , add Client : add Client , remove Client : remove Client } ; } 
function ( immediate FN , connect FN , disconnect FN , port ) { var app = require ( 'express ' ) ( ) , server = require ( 'http ' ) . create Server ( app ) , io = require ( 'socket .io ' ) . listen ( server ) , path = require ( 'path ' ) , browserify = require ( 'browserify -middleware ' ) ; io . set ( 'log level ' , 2 ) ; server . listen ( port | | process . env . PORT | | 8 0 ) ; var browserify Options = { } ; browserify Options [ path . join ( _ _dirname + ' /npm _crafty .client .js ' ) ] = { expose : 'npm _crafty ' } ; app . get ( ' /npm _crafty .js ' , browserify ( [ browserify Options ] ) ) ; app . get ( ' /crafty _client .js ' , function ( req , res ) { res . sendfile ( path . join ( _ _dirname + ' /crafty _client .js ' ) ) ; } ) ; io . sockets . on ( 'connection ' , function ( socket ) { console . log ( "Connected " , socket . id ) ; connect FN ( socket ) ; socket . on ( 'disconnect ' , function ( arg ) { console . log ( "Disconnected " , socket . id ) ; disconnect FN ( socket ) ; } ) ; } ) ; process . next Tick ( immediate FN ) ; var _server = new Server ( io . sockets ) ; _server . app = app ; _server . server = server ; _server . io = io ; return _server ; } 
function _create ( crud , schema , data ) { if ( data . _id ) delete data . _id ; 
function replace ( format , data ) { return format . replace ( / { ( \w + ) } / g , ( m , name ) = > ( data [ name ] ? data [ name ] : ' ' ) ) ; } 
function highlight ( code , lang ) { const g = Prism . languages [ lang ] ; if ( g ) { return Prism . highlight ( code , g , lang ) ; } return code ; } 
function get Updater ( error Fn ) { error Fn = error Fn | | new Function ( ) ; return updater ; function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( test Doc Tag ) . map ( get Annotated Node ) . concat ( infer Angular ( ast ) ) * Get the node that is annotated by the comment or throw if not present . * @throws {Error } Where comment does not annotate a node * @param {object } comment The comment node * / function get Annotated Node ( comment ) { 
function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( test Doc Tag ) . map ( get Annotated Node ) . concat ( infer Angular ( ast ) ) 
function get Annotated Node ( comment ) { 
function location Str ( runtime , line ) { var loc ; loc = 'line : ' + ( line ! = = undefined ? line : runtime . line Number ) ; if ( runtime . file ) { loc + = ' - - file : ' + runtime . file ; } return loc ; } 
function _is Telephone ( val , locale ) { var key = _is String ( locale ) ? locale : LOCALE _ENUM . ZHCN ; var rex = REGEX _ENUM . TELEPHONE _REX [ key ] ; if ( ! rex ) { return false ; } if ( ! _is String ( val ) ) { return false ; } return rex . test ( val ) ; } 
function Macro ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } this . destroy = destroy Mixin ; Macro . super _ . apply ( this , arguments ) ; } 
function quick Sort ( a , l , h , k , c ) { const s = [ ] ; let t = 0 ; s [ t + + ] = l ; s [ t + + ] = h ; while ( t > 0 ) { h = s [ - - t ] ; l = s [ - - t ] ; if ( h - l > k ) { const p = partition ( a , l , h , c ) ; if ( p > l ) { s [ t + + ] = l ; s [ t + + ] = p ; } if ( p + 1 < h ) { s [ t + + ] = p + 1 ; s [ t + + ] = h ; } } } } 
function pivot ( a , l , h , c ) { const p = ( l + ( ( h - l ) / 2 ) ) | 0 ; if ( c ( a [ h ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ h ] ] = [ a [ h ] , a [ l ] ] ; } if ( c ( a [ p ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ p ] ] = [ a [ p ] , a [ l ] ] ; } if ( c ( a [ h ] , a [ p ] ) < 0 ) { [ a [ h ] , a [ p ] ] = [ a [ p ] , a [ h ] ] ; } return p ; } 
function partition ( a , l , h , c ) { const p = a [ pivot ( a , l , h , c ) ] ; let i = l - 1 ; let j = h + 1 ; for ( ; ; ) { do { i + + ; } while ( c ( a [ i ] , p ) < 0 ) ; do { j - - ; } while ( c ( a [ j ] , p ) > 0 ) ; if ( i < j ) { [ a [ i ] , a [ j ] ] = [ a [ j ] , a [ i ] ] ; } else { return j ; } } } 
function insertion Sort ( a , l , h , c ) { for ( let i = l + 1 ; i < = h ; i + + ) { const x = a [ i ] ; let j = i - 1 ; while ( j > = 0 & & c ( a [ j ] , x ) > 0 ) { a [ j + 1 ] = a [ j ] ; j - - ; } a [ j + 1 ] = x ; } } 
function search ( parent , base Url , callback ) { var resource = new ( get Resource ( 'page ' ) ) ( parent , { _links : { self : { href : base Url , 'class ' : 'page ' } } } ) ; if ( typeof callback = = 'function ' ) return resource . exec ( callback ) ; return resource ; } 
function create Pipe Stream ( cmd ) { var proc ; var command ; if ( Array . is Array ( cmd ) ) { 
function Pipe Stream ( self ) { 
function wrap Methods ( self ) { var methods = [ 'on ' ] ; var child Objects = [ 'stdin ' , 'stdout ' , 'stderr ' ] ; 
function add Functions ( self ) { 
function connect Events ( self ) { if ( self . stdout ) { self . stdout . on ( 'data ' , function ( d ) { self . emit ( 'data ' , d ) ; } ) ; self . stderr . on ( 'data ' , function ( d ) { self . emit ( 'error ' , d ) ; } ) ; } } 
function add Event Handlers ( self ) { self . on ( 'error ' , function ( d ) { var fn = self . _error ; self . _clean Up ( ) ; if ( fn ) { fn ( 'pipeline [ ' + self . _nr + ' ] : " ' + self . _command + ' " failed with : ' + d . to String ( ) ) ; } } ) ; } 
function _resolve ( routes , path , req , res ) { return Q . fcall ( function ( ) { path = path | | [ ] ; var obj = routes ; 
function do _parse _url ( url ) { var s = require ( 'url ' ) . parse ( url ) . pathname . replace ( / [ ^a -z A -Z 0 - 9 _ \ - \ + \ . ] + / g , " / " ) . replace ( / ^ \ / + / , " " ) ; if ( s . length = = = 0 ) { return [ ] ; } return s . split ( " / " ) ; } 
function link ( definition ) { var key , link , new Resource , Resource ; if ( ' _links ' in definition ) { for ( key in definition . _links ) { if ( key = = = 'self ' ) continue ; link = definition . _links [ key ] ; key = key . char At ( 0 ) + inflection . camelize ( key ) . slice ( 1 ) ; 
function _build Function ( resource ) { return function ( callback ) { if ( typeof callback = = 'function ' ) { if ( resource ! = = null ) return resource . exec . call ( resource , callback ) ; else return callback ( null , null ) ; } return resource ; } } 
function _is Negative Integer ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . NEGATIVE _INTEGER _REX . test ( val ) ; } return REGEX _ENUM . NEGATIVE _INTEGER _REX . test ( val ) ; } 
function generate Signature ( secret Key , method , content Md 5 , content Type , date , canonicalized Headers , canonicalized Resource ) { var hmac = _crypto 2 . default . create Hmac ( SHA 2 5 6 , secret Key ) ; var headers = canonicalized Headers . map ( function ( header ) { return header . to Lower Case ( ) ; } ) . sort ( ) . join ( ' \n ' ) ; var data = method + ' \n ' + content Md 5 + ' \n ' + content Type + ' \n ' + date + ' \n ' ; if ( headers & & headers . length ) { data + = headers + ' \n ' ; } data + = canonicalized Resource ; hmac . update ( data ) ; return hmac . digest ( ENCODING ) ; } 
function get Object ( host , access Key , secret Key , bucket , object Key ) { var expires = arguments . length < = 5 | | arguments [ 5 ] = = = undefined ? 0 : arguments [ 5 ] ; var opts = arguments . length < = 6 | | arguments [ 6 ] = = = undefined ? { } : arguments [ 6 ] ; var date = utc Date ( ) ; if ( opts . version Id ) url + = ' ?version Id = ' + opts . version Id ; var resource = gen Resource ( bucket , object Key , ( 0 , _lodash . pick ) ( opts , [ 'version Id ' ] ) ) ; var signature = encode URIComponent ( generate Signature ( secret Key , 'GET ' , ' ' , ' ' , expires , [ ] , resource ) ) ; var url = pub ? 'http : / / ' + bucket + ' . ' + host + ' / ' + object Key : 'http : / / ' + host + ' / ' + bucket + ' / ' + object Key + ' ?NOSAccess Key Id = ' + access Key + ' &Expires = ' + expires + ' &Signature = ' + signature ; var headers = { Date : date } ; if ( opts . range ) headers . Range = opts . range ; if ( opts . modified Since ) headers [ 'If -Modified -Since ' ] = opts . modified Since ; headers [ 'url ' ] = url ; return nos Request ( { method : 'get ' , headers : headers , uri : url } ) ; } 
function get Meta ( host , access Key , secret Key , bucket , object Key ) { var expires = arguments . length < = 5 | | arguments [ 5 ] = = = undefined ? 0 : arguments [ 5 ] ; var opts = arguments . length < = 6 | | arguments [ 6 ] = = = undefined ? { } : arguments [ 6 ] ; var date = utc Date ( ) ; if ( opts . version Id ) url + = ' ?version Id = ' + opts . version Id ; var resource = gen Resource ( bucket , object Key , ( 0 , _lodash . pick ) ( opts , [ 'version Id ' ] ) ) ; var authorization = authorize ( access Key , secret Key , 'HEAD ' , ' ' , ' ' , date , [ ] , resource ) ; var signature = ( 0 , _urlencode 2 . default ) ( generate Signature ( secret Key , 'HEAD ' , ' ' , ' ' , date , [ ] , resource ) ) ; var url = pub ? 'http : / / ' + bucket + ' . ' + host + ' / ' + object Key : 'http : / / ' + host + ' / ' + bucket + ' / ' + object Key + ' ?NOSAccess Key Id = ' + access Key + ' &Expires = ' + expires + ' &Signature = ' + signature ; var headers = { Date : date } ; if ( opts . modified Since ) headers [ 'If -Modified -Since ' ] = opts . modified Since ; headers [ 'url ' ] = url ; return nos Request ( { method : 'head ' , uri : url , headers : headers } ) . then ( function ( res ) { var content Type = res [ 'content -type ' ] ; var last Modified = res [ 'last -modified ' ] ; var etag = res [ 'etag ' ] ; var request Id = res [ 'x -nos -request -id ' ] ; return { content Type : content Type , last Modified : last Modified , etag : etag , request Id : request Id } ; } ) ; } 
function upload ( host , access Key , secret Key , bucket , object Key , file ) { var nos Header = arguments . length < = 6 | | arguments [ 6 ] = = = undefined ? { } : arguments [ 6 ] ; nos Header [ 'x -nos -storage -class ' ] = nos Header [ 'x -nos -storage -class ' ] | | 'standard ' ; var date = utc Date ( ) ; var content = _fs 2 . default . read File Sync ( file ) ; var content Length = content . length ; var content Md 5 = ( 0 , _md 2 . default ) ( content ) ; var resource = gen Resource ( bucket , object Key ) ; var canonicalized Headers = Object . keys ( nos Header ) . map ( function ( key ) { return key + ' : ' + nos Header [ key ] ; } ) ; var authorization = authorize ( access Key , secret Key , 'PUT ' , content Md 5 , ' ' , date , canonicalized Headers , resource ) ; var url = 'http : / / ' + bucket + ' . ' + host + ' / ' + object Key ; var headers = ( 0 , _lodash . assign ) ( { Date : date , 'Content -Length ' : content Length , 'Content -MD 5 ' : content Md 5 , Authorization : authorization , 'url ' : url } , nos Header ) ; return nos Request ( { method : 'put ' , uri : url , body : content , headers : headers } ) ; } 
function _is Un Negative Integer ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . UN _NEGATIVE _INTEGER _REX . test ( val ) ; } return REGEX _ENUM . UN _NEGATIVE _INTEGER _REX . test ( val ) ; } 
function get File List ( ) { var result = [ ] , file Name List = [ 'da .md ' , 'en .md ' ] , cwd , file Name ; for ( var i = 0 ; i < dir List . length ; i + + ) { cwd = paths . temp _dist + dir List [ i ] ; for ( var f in file Name List ) { file Name = file Name List [ f ] ; if ( grunt . file . is File ( cwd + ' / ' + file Name ) ) result . push ( { cwd : cwd , src : file Name } ) ; } } return result ; } 
function ( mixins , options ) { 
function ( base , wrapped ) { return function ( ) { var args = [ ] . slice . call ( arguments , 0 ) ; return wrapped . apply ( this , [ _ . bind ( base , this ) ] . concat ( args ) ) ; } ; } 
function ( base , before ) { return Advice . around ( base , function ( ) { var args = [ ] . slice . call ( arguments , 0 ) , orig = args . shift ( ) , before Fn ; before Fn = ( typeof before = = 'function ' ) ? before : before . obj [ before . fn Name ] ; before Fn . apply ( this , args ) ; return ( orig ) . apply ( this , args ) ; } ) ; } 
function ( base , after ) { return Advice . around ( base , function ( ) { var args = [ ] . slice . call ( arguments , 0 ) , orig = args . shift ( ) , after Fn ; 
function ( base , key , value ) { var ext Base = base ; if ( typeof ext Base = = 'function ' ) ext Base = base . prototype ; if ( _ . is String ( key ) ) { var temp = key ; key = { } ; key [ temp ] = value ; } _ . extend ( ext Base , key ) ; return base ; } 
function ( base , obj ) { var ext Base = base ; if ( typeof ext Base = = 'function ' ) ext Base = base . prototype ; _ . each ( obj , function ( val , key ) { ext Base [ key ] = _ . extend ( _ . clone ( Advice . find Val ( ext Base , key ) ) | | { } , val ) ; } ) ; return base ; } 
function ( obj , name ) { while ( ! obj [ name ] & & obj . prototype ) obj = obj . prototype ; return obj [ name ] ; } 
function ( obj ) { var add Api = function ( ) { 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) if ( options & & options . flight _id ) { var route = ngin . Flight . url Root ( ) + ' / ' + options . flight _id + Standings Preference . url Root ( ) } else if ( options & & ( options . division _id & & options . game _type ) ) { var route = ngin . Division . url Root ( ) + ' / ' + options . division _id + Standings Preference . url Root ( ) + ' / ' + options . game _type } else { throw new Error ( 'flight _id or division _id and game _type required to make standings preference api calls ' ) } var base = config . urls & & config . urls . sports | | config . url return Url . resolve ( base , route ) } 
function expose ( obj , val ) { if ( arguments . length = = = 1 ) { if ( obj instanceof Error ) Object . define Property ( obj , "message " , { enumerable : true , value : obj . message } ) ; val = obj ; } return resource ( obj , { expose : val } ) ; } 
function get Api Key ( ) { if ( is Local ( ) & & pkg . api Key ) { log . trace ( 'using api Key in fhconfig ' ) ; return pkg . api Key ; } else { log . trace ( 'using api key in FH _APP _API _KEY env var ' ) ; return env ( 'FH _APP _API _KEY ' ) . as String ( ) ; } } 
function str Map To Obj ( str Map ) { const obj = { } for ( const [ k , v ] of str Map ) { 
function get Resource ( name ) { if ( name in resources ) return resources [ name ] ; try { return resources [ name ] = require ( ' . . /resource / ' + name ) ; } catch ( err ) { return resources [ name ] = require ( ' . . /resource ' ) ; } } 
function _is Plain Object ( val ) { if ( ! _is Object ( val ) ) { return false ; } var proto = Object . get Prototype Of ( val ) ; if ( proto = = = null ) { return true ; } var ctor = proto . constructor ; return _is Function ( ctor ) ; } 
function stringify ( obj , replacer , space ) { if ( typeof replacer = = = 'string ' | | typeof replacer = = = 'number ' ) { 
function build Nav ( members , opts ) { var nav = ' ' , seen = { } , list = { Modules : 'modules ' , Externals : 'externals ' , Classes : 'classes ' , Events : 'events ' , Namespaces : 'namespaces ' , Mixins : 'mixins ' } , has Class List = false , class Nav = ' ' , global Nav = ' ' ; nav + = ' <h 2 > <a href = "index .html " > ' + ( opts . index Name | | 'Index ' ) + ' < /a > < /h 2 > ' ; for ( var name in list ) { if ( members [ list [ name ] ] . length ) { nav + = ' <div class = "nav - ' + list [ name ] + ' " > ' ; nav + = ' <h 3 > ' + name + ' < /h 3 > <ul > ' ; members [ list [ name ] ] . for Each ( function ( m ) { if ( ! has Own Prop . call ( seen , m . longname ) ) { nav + = ' <li title = " ' + m . longname + ' " > ' + linkto ( m . longname , m . name ) + ' < /li > ' ; } seen [ m . longname ] = true ; var funcs = find ( { kind : 'function ' , memberof : m . longname = = = 'Global ' ? { is Undefined : true } : m . longname } ) ; if ( funcs . length ) { nav + = ' <div class = "navinner nav -methods " > <h 4 >Methods < /h 4 > <ul > ' ; funcs . for Each ( function ( f ) { if ( ! has Own Prop . call ( seen , f . longname ) ) { nav + = ' <li title = " ' + f . longname + ' " > ' + linkto ( f . longname , f . name ) + ' < /li > ' ; } seen [ m . longname ] = true ; } ) ; nav + = ' < /ul > < /div > ' ; } } ) ; nav + = ' < /ul > ' ; } } if ( members . tutorials . length ) { nav + = ' <h 3 >Tutorials < /h 3 > <ul > ' ; members . tutorials . for Each ( function ( t ) { nav + = ' <li > ' + tutoriallink ( t . name ) + ' < /li > ' ; } ) ; nav + = ' < /ul > ' ; } if ( members . globals . length ) { members . globals . for Each ( function ( g ) { if ( g . kind ! = = 'typedef ' & & ! has Own Prop . call ( seen , g . longname ) ) { global Nav + = ' <li title = " ' + g . longname + ' " > ' + linkto ( g . longname , g . name ) + ' < /li > ' ; } seen [ g . longname ] = true ; } ) ; if ( ! global Nav ) { 
function WMURL _encode ( source ) { 
function update Subscribers ( ) { last Update = Date . now ( ) ; update Requested = false ; var access Map = new immutable . Map ( ) ; for ( var path of dirty State ) { access Map = set In ( access Map , path , true ) ; } dirty State . clear ( ) ; for ( var subscriber of subscribers . values ( ) ) { var needs Update = false ; for ( path of subscriber . accessed ) { if ( access Map . get In ( path ) ) { needs Update = true ; break ; } } if ( needs Update ) { update Subscriber ( subscriber ) ; } } } 
function update Subscriber ( subscriber ) { state Accessed . clear ( ) ; subscriber . fn ( ) ; subscriber . accessed = Array . from ( state Accessed ) ; } 
function set In ( o , path , value ) { if ( path . length ) { var key = path [ 0 ] ; var rest = path . slice ( 1 ) ; if ( typeof key = = = 'number ' & & ! ( o instanceof immutable . List ) ) { o = new immutable . List ( ) ; } else if ( ! ( o instanceof immutable . Map ) ) { o = new immutable . Map ( ) ; } return o . set ( key , set In ( o . get ( path [ 0 ] ) , path . slice ( 1 ) , value ) ) ; } else { return immutable . from JS ( value ) ; } } 
function to JS ( o ) { if ( typeof o = = = 'object ' & & o ! = = null & & typeof o . to JS = = = 'function ' ) { o = o . to JS ( ) ; } return o ; } 
function to Path ( arr ) { if ( typeof arr = = = 'string ' ) { arr = arr . split ( ' . ' ) ; } else if ( ! Array . is Array ( arr ) ) { arr = [ arr ] ; } return arr ; } 
function sign Msg ( msg , key , alg ) { var signer = crypto . create Sign ( alg ) ; signer . update ( msg ) ; return signer . sign ( key ) ; } 
function hash Msg ( msg , alg ) { var hash = crypto . create Hash ( alg ) ; hash . update ( msg ) ; return hash . digest ( ) ; } 
function decrypt APIMResponse ( body , private _key ) { if ( ! body . key | | ! body . cipher ) { throw new Error ( 'bad handshake response from APIm ' ) ; } var key = crypto . private Decrypt ( { key : private _key , padding : constants . RSA _PKCS 1 _PADDING } , new Buffer ( body . key , 'base 6 4 ' ) ) ; var iv = new Buffer ( 1 6 ) ; iv . fill ( 0 ) ; var decipher = crypto . create Decipheriv ( 'aes - 2 5 6 -cbc ' , key , iv ) ; var plain Text = decipher . update ( body . cipher , 'base 6 4 ' , 'utf 8 ' ) ; plain Text + = decipher . final ( 'utf 8 ' ) ; log . debug ( 'handshake response payload : ' , plain Text ) ; return JSON . parse ( plain Text ) ; } 
function add Signature Headers ( body , headers , key Id , key ) { if ( ! headers ) { headers = { } ; } if ( ! headers . date ) { headers . date = ( new Date ( ) ) . to UTCString ( ) ; } if ( ! headers . digest ) { headers . digest = 'SHA 2 5 6 = ' + hash Msg ( JSON . stringify ( body ) , 'sha 2 5 6 ' ) . to String ( 'base 6 4 ' ) ; } var combine = function ( names , headers ) { var parts = [ ] ; names . for Each ( function ( e ) { parts . push ( e + ' : ' + headers [ e ] ) ; } ) ; return parts . join ( ' \n ' ) ; } ; headers . authorization = 'Signature ' + 'key Id = " ' + key Id + ' " , ' + 'headers = "date digest " , ' + 'algorithm = "rsa -sha 2 5 6 " , ' + 'signature = " ' + sign Msg ( combine ( [ 'date ' , 'digest ' ] , headers ) , key , 'RSA -SHA 2 5 6 ' ) . to String ( 'base 6 4 ' ) + ' " ' ; return headers ; } 
function OZWManager ( ) { this . ozw = new OZW ( { Logging : true , 
function copy ORIGINALTo Bower Json ( ) { if ( grunt . file . exists ( ORIGINALFile Name ) ) { grunt . file . copy ( ORIGINALFile Name , 'bower .json ' ) ; grunt . file . delete ( ORIGINALFile Name ) ; } } 
function each Dependencies ( package Func , options ) { var bwr = common . read JSONFile ( 'bower .json ' ) ; _each Dependencies ( bwr . name , bwr , package Func , options , [ ] , true , common . read JSONFile ( ' .bower .json ' ) ) ; } 
function _each Dependencies ( package Name , bower Json , package Func , options , package List , first Level , dot Bower Json ) { bower Json = bower Json | | { } ; dot Bower Json = dot Bower Json | | { } ; var dependencies Package Name , dependencies = bower Json . dependencies | | dot Bower Json . dependencies | | { } ; package Func ( package Name , bower Json , options , first Level , dot Bower Json ) ; 
async function wait Variable To Be ( variable Expression , value , timeout ) { return await this . wait Until ( async ( ) = > { const result = await this . execute ( ` $ { variable Expression } $ { JSON . stringify ( value ) } ` ) return result . value } , timeout , ` \ ` $ { variable Expression } \ ` \ ` $ { JSON . stringify ( value ) } \ ` ` ) } 
async function wait Attribute To Be ( selector , key , value , timeout ) { return await this . wait Until ( async ( ) = > { const got = await this . element ( selector ) . get Attribute ( key ) return [ ] . concat ( value ) . some ( ( value ) = > got = = = value | | String ( got ) = = = String ( value ) ) } , timeout , ` $ { key } \ ` $ { selector } \ ` \ ` $ { JSON . stringify ( value ) } \ ` ` ) } 
function ( view ) { this . unmount ( ) ; this . current View = view ; var render Returns View = this . current View . render ( ) ; if ( render Returns View ) { $ ( Special K . main Container ) . empty ( ) . append ( render Returns View . el ) . fade In ( 'slow ' ) ; } } 
function ( ) { if ( ! this . current View ) return false ; $ ( Special K . container ) . hide ( ) ; this . current View . unbind ( ) ; this . current View . remove ( ) ; this . current View = null ; return true ; } 
function check Value ( val , expected Type , name ) { if ( typeof val ! = = expected Type ) { throw new Error ( name + ' must return ' + expected Type ) ; } return Utils ; } 
function merge All ( safe , obj ) { let args = to Array ( arguments ) . slice ( 2 ) ; for ( let i = 0 ; i < args . length ; i + + ) { obj = merge ( obj , args [ i ] , safe ) ; } return obj ; } 
function call If ( condition , func ) { return ( condition ? func . apply ( undefined , Array . prototype . slice . call ( arguments , 2 ) ) : undefined ) ; } 
function ( reserved _spaces , object _type ) { v . required ( reserved _spaces , "reserved _spaces " ) ; v . required ( object _type , "object _type " ) ; return { from Byte Buffer ( b ) { return b . read Varint 3 2 ( ) ; } , append Byte Buffer ( b , object ) { v . required ( object ) ; if ( object . resolve ! = = undefined ) { object = object . resolve ; } 
function quality ( str ) { var parts = str . split ( / * ; * / ) , val = parts [ 0 ] ; var q = parts [ 1 ] ? parse Float ( parts [ 1 ] . split ( / * = * / ) [ 1 ] ) : 1 ; return { value : val , quality : q } ; } 
function cast ( x , type ) { var ctor , len , d , i ; if ( ! array Like ( x ) ) { throw new Type Error ( 'invalid input argument . First argument must be an array -like object . Value : ` ' + x + ' ` . ' ) ; } if ( typeof type = = = 'string ' ) { ctor = get Ctor ( type ) ; } else { ctor = get Ctor ( dtype ( type Name ( type ) ) ) ; } if ( ctor = = = null ) { throw new Error ( 'invalid input argument . Unrecognized /unsupported type to which to cast . Value : ` ' + type + ' ` . ' ) ; } len = x . length ; 
function parse _by _content _type ( type , body ) { if ( type = = = 'application /json ' ) { return JSON . parse ( body ) ; } if ( type = = = 'text /plain ' ) { return ' ' + body ; } throw new Error ( "Unknown Content -Type " + type + " - - don 't know how to parse ! " ) ; } 
function _resolve Filter ( req ) { function _ _is Req Object ( req ) { return ! ! req . url ; } function _ _has Query String ( req ) { return _ _is Req Object ( req ) & & ( Object . keys ( req . query | | { } ) . length > 0 ) ; } function _ _has Route Params ( req ) { return _ _is Req Object ( req ) & & ( Object . keys ( req . params | | { } ) . length > 0 ) ; } function _ _has ODATA ( req ) { return _ _is Req Object ( req ) & & ( Object . keys ( req . odata | | { } ) . length > 0 ) ; } if ( ! req ) { return { type : "none " , filter : null } ; } else if ( _ _has ODATA ( req ) ) { return { type : "odata " , filter : req . odata } ; } else if ( _ _has Query String ( req ) ) { return { type : "query String " , filter : req . query } ; } else if ( _ _has Route Params ( req ) ) { return { type : "route Params " , filter : req . params } ; } else { if ( _ _is Req Object ( req ) ) { return req ; } else { if ( typeof ( req ) = = = "object " ) { return { type : "plain Object " , filter : req } ; } else { return { type : "route Params " , filter : { "id " : req } } ; } } } } 
function get Brightness ( hex ) { var r = parse Int ( hex . substr ( 2 + 0 * 2 , 2 ) , 1 6 ) , g = parse Int ( hex . substr ( 2 + 1 * 2 , 2 ) , 1 6 ) , b = parse Int ( hex . substr ( 2 + 2 * 2 , 2 ) , 1 6 ) ; function lin 2log ( n ) { return n < = 0 . 0 0 3 1 3 0 8 ? n * 1 2 . 9 2 : 1 . 0 5 5 * Math . pow ( n , 1 / 2 . 4 ) - 0 . 0 5 5 ; } function log 2lin ( n ) { return n < = 0 . 0 4 0 4 5 ? n / 1 2 . 9 2 : Math . pow ( ( ( n + 0 . 0 5 5 ) / 1 . 0 5 5 ) , 2 . 4 ) ; } r = log 2lin ( r / 2 5 5 ) ; g = log 2lin ( g / 2 5 5 ) ; b = log 2lin ( b / 2 5 5 ) ; return lin 2log ( 0 . 2 1 2 6 * r + 0 . 7 1 5 2 * g + 0 . 0 7 2 2 * b ) * 1 0 0 ; } 
function Route ( args ) { this . name = args . name ; this . method = args . method ; var pattern = args . pattern ; this . pattern = Route Pattern . from String ( pattern ) ; } 
function Telepathy ( options ) { 'use strict ' ; options = options | | { } ; if ( typeof options = = 'string ' ) options = { secret : options } ; var _secret = options . secret | | ' ' ; delete options . secret ; this . user = options . user | | ' ' ; this . alphabet = options . alphabet | | Telepathy . alphabet . base 6 2 ; this . length = options . length | | 1 0 ; this . domain = options . domain | | ' ' ; this . algorithm = options . algorithm | | 'SHA 2 5 6 ' ; this . set Secret = function ( secret ) { _secret = secret | | ' ' ; } ; this . password = function ( options ) { return this . _password ( _secret , options ) ; } ; } 
function read File ( filename , is JSON , strip Comments , default Contents ) { if ( grunt . file . exists ( filename ) ) { var contents = grunt . file . read ( filename ) ; if ( is JSON | | strip Comments ) contents = strip Json Comments ( contents ) ; return is JSON ? JSON . parse ( contents ) : contents ; } else return default Contents ; } 
function read JSONFile ( filename , default Contents ) { return read File ( filename , true , true , default Contents = = = null ? { } : default Contents ) ; } 
function write JSONFile ( file Name , contents ) { var obj = JSON . parse ( JSON . stringify ( contents ) ) ; grunt . file . write ( file Name , JSON . stringify ( obj , null , 4 ) ) ; } 
function write File ( file Name , is JSON , contents ) { if ( is JSON ) contents = JSON . stringify ( contents ) ; grunt . file . write ( file Name , contents ) ; } 
function update Options ( options , default Options ) { for ( var id in default Options ) if ( default Options . has Own Property ( id ) & & ( ! options . has Own Property ( id ) ) | | ( options [ id ] = = = ' ' ) | | ( options [ id ] = = = null ) ) options [ id ] = default Options [ id ] ; } 
function merge ( ) { var result = { } ; for ( var i = 0 ; i < arguments . length ; i + + ) for ( var key in arguments [ i ] ) if ( arguments [ i ] . has Own Property ( key ) ) result [ key ] = arguments [ i ] [ key ] ; return result ; } 
function run Cmd ( cmd , use Cmd Output ) { if ( ! use Cmd Output ) grunt . log . writeln ( cmd [ 'grey ' ] ) ; var shell = require ( 'shelljs ' ) , result = shell . exec ( cmd , { silent : ! use Cmd Output } ) ; if ( result . code = = = 0 ) { if ( ! use Cmd Output ) grunt . log . writeln ( result . stdout [ 'white ' ] ) ; } else { if ( ! use Cmd Output ) { grunt . log . writeln ( ) ; grunt . log . writeln ( result . stderr [ 'yellow ' ] ) ; } grunt . fail . warn ( ' " ' + cmd + ' " failed . ' ) ; } return result ; } 
function create Transition ( glsl ) { 
function command _exists ( paths , name ) { if ( is . string ( paths ) ) { paths = paths . split ( ' : ' ) ; } debug . assert ( paths ) . is ( 'array ' ) ; return paths . some ( dir = > fs . exists Sync ( PATH . join ( dir , name ) ) ) ; } 
function spawn Process ( command , args , { env = { } } = { } ) { return Async . Promise ( ( resolve , reject ) = > { 
function ( ) { if ( this . _uncommitted Is Top ) this . _data . pop ( ) ; 
function complete Assign ( target ) { for ( var index = 1 ; index < arguments . length ; index + + ) { var source = arguments [ index ] ; 
function _is Integer ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . INTEGER _REX . test ( val ) ; } return REGEX _ENUM . INTEGER _REX . test ( val ) ; } 
function ( Template ) { return [ Template . language . tag ( 'set ' ) , Template . language . tag ( 'setalist ' ) , Template . language . tag ( 'setahash ' ) , Template . language . tag ( 'addtolist ' ) , Template . language . tag ( 'setaregex ' ) ] ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'set ' ) : return new Set ( Template , expression ) ; case Template . language . tag ( 'setalist ' ) : return new Set List ( Template , expression ) ; case Template . language . tag ( 'setahash ' ) : return new Set Hash ( Template , expression ) ; case Template . language . tag ( 'addtolist ' ) : return new Add To List ( Template , expression ) ; case Template . language . tag ( 'setaregex ' ) : return new Set AReg Ex ( Template , expression ) ; default : return { skip : true } ; } } 
function ( Template , expression ) { this . needs = { } ; expression = expression . split ( ' ' ) ; if ( expression . length < 4 ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Set tag has bad syntax ' ) ; return ; } var temp = Noodles . Utilities . parse Type ( Template , expression [ 1 ] ) ; if ( temp . type ! = = "object " ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Set tag has bad syntax , the variable must be an identifier or object ' ) ; return ; } this . key = temp ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . merge Object With ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; this . value = Noodles . Utilities . parse Type ( Template , expression [ 3 ] ) ; this . needs = Noodles . Utilities . merge Object With ( this . needs , this . value . needs ) ; } 
function ( Template , expression ) { this . needs = { } ; var re List Split = new Reg Exp ( ' ^ ' + Template . language . tag ( 'setalist ' ) + ' \ \s + ( [ ^ = ] + ) \ \s * = \ \s * ( . + ) ' ) , obj , list , item ; if ( ! re List Split . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setalist tag has bad syntax ' ) ; return ; } expression = re List Split . exec ( expression ) obj = Noodles . Utilities . parse Type ( Template , expression [ 1 ] ) ; if ( obj . type ! = = "object " ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setalist tag has bad syntax , the variable must be an identifier or object ' ) ; return ; } this . key = obj ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . merge Object With ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; list = expression [ 2 ] . split ( ' , ' ) ; for ( var i = 0 , l = list . length ; i < l ; i + + ) { list [ i ] = Noodles . Utilities . parse Type ( Template , list [ i ] . trim ( ) ) ; this . needs = Noodles . Utilities . merge Object With ( this . needs , list [ i ] . needs ) ; } this . value = list ; } 
function ( Template , expression ) { this . needs = { } ; var re Hash Split = new Reg Exp ( ' ^ ' + Template . language . tag ( 'setahash ' ) + ' \ \s + ( [ ^ = ] + ) \ \s * = \ \s * ( . + ) ' ) , hash Object = { } , obj , hash , value ; if ( ! re Hash Split . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setahash tag has bad syntax ' ) ; return ; } expression = re Hash Split . exec ( expression ) obj = Noodles . Utilities . parse Type ( Template , expression [ 1 ] ) ; if ( obj . type ! = = "object " ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setahash tag has bad syntax , the variable must be an identifier or object ' ) ; return ; } this . key = obj ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . merge Object With ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; hash = expression [ 2 ] . split ( ' , ' ) ; for ( var i = 0 , l = hash . length ; i < l ; i + + ) { hash [ i ] = hash [ i ] . split ( ' : ' ) ; value = hash [ i ] [ 0 ] . trim ( ) . to Lower Case ( ) ; hash Object [ value ] = Noodles . Utilities . parse Type ( Template , hash [ i ] [ 1 ] . trim ( ) ) this . needs = Noodles . Utilities . merge Object With ( this . needs , hash Object [ value ] . needs ) ; } this . value = hash Object ; } 
function ( Template , expression ) { this . needs = { } ; var re Add To List = new Reg Exp ( ' ^ ' + Template . language . tag ( 'addtolist ' ) + ' \ \s + ( [ ^ = ] + ) \ \s +to \ \s + ( . + ) ' ) ; if ( ! re Add To List . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Addtolist tag has bad syntax ' ) ; return ; } expression = re Add To List . exec ( expression ) this . value = Noodles . Utilities . parse Type ( Template , expression [ 1 ] ) ; this . list = Noodles . Utilities . parse Type ( Template , expression [ 2 ] ) ; if ( this . list . type ! = = "object " ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Addtolist tag has bad syntax , the list must be an identifier or object ' ) ; return ; } this . needs = Noodles . Utilities . merge Object With ( this . needs , this . value . needs ) ; this . needs = Noodles . Utilities . merge Object With ( this . needs , this . list . needs ) ; this . modifies = { } ; this . modifies [ this . list . order [ 0 ] ] = true ; } 
function ( Template , expression ) { this . needs = { } ; expression = expression . split ( / \s + / ) ; this . name = Noodles . Utilities . parse Type ( Template , expression [ 0 ] ) ; if ( this . name . type ! = = "object " ) { Noodles . Utilities . warning ( Template , 'Set AReg Ex tag has bad syntax , the name must be an identifier ' ) ; this . skip = true ; return ; } this . value = Noodles . Utilities . parse Type ( Template , expression [ 2 ] ) ; this . options = typeof expression [ 3 ] = = = "string " & & expression [ 3 ] . length > 0 ? expression [ 3 ] . to Lower Case ( ) : false ; if ( this . value . type = = = "string " ) { this . regex = this . options ? new Reg Exp ( this . value . execute ( ) , this . options ) : new Reg Exp ( this . value . execute ( ) ) ; } else if ( this . value . type = = = "object " ) { this . regex = false ; this . needs = Noodles . Utilities . merge Object With ( this . needs , this . value . needs ) ; this . modifies = { } ; this . modifies [ this . value . order [ 0 ] ] = true ; } else { this . skip = true ; Noodles . Utilities . warning ( Template , 'Set AReg Ex tag has bad syntax , the value must receive a string or object ' ) ; return ; } } 
function ( obj , keys , key , Template , Context , desc ) { var name = key = = = Template . language . other ( 'name ' ) , value = key = = = null | | key = = = Template . language . other ( 'value ' ) ; keys = keys . sort ( function ( a , b ) { if ( value ) { a = obj [ a ] ; b = obj [ b ] ; if ( typeof a = = = "object " & & typeof a . execute ! = = "undefined " ) a = a . execute ( Template , Context ) ; if ( typeof b = = = "object " & & typeof b . execute ! = = "undefined " ) b = b . execute ( Template , Context ) ; } else if ( ! name ) { a = obj [ a ] ; b = obj [ b ] ; if ( typeof a = = = "object " & & typeof a . execute ! = = "undefined " ) a = a . execute ( Template , Context ) ; if ( typeof b = = = "object " & & typeof b . execute ! = = "undefined " ) b = b . execute ( Template , Context ) ; a = a [ key ] ; b = b [ key ] ; if ( typeof a = = = "object " & & typeof a . execute ! = = "undefined " ) a = a . execute ( Template , Context ) ; if ( typeof b = = = "object " & & typeof b . execute ! = = "undefined " ) b = b . execute ( Template , Context ) ; } if ( desc ) { return b - a ; } else { return a - b ; } } ) ; return keys ; } 
function ( Template ) { Template . end Tags = Template . end Tags | | { } ; Template . end Tags [ Template . language . tag ( 'loop ' ) ] = true ; Template . end Tags [ Template . language . tag ( 'sortloop ' ) ] = true ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'loop ' ) : return new Loop ( Template , expression ) ; case Template . language . tag ( 'sortloop ' ) : return new Loop ( Template , expression , true ) ; default : return { skip : true } ; } } 
function ( Template , expression , sort ) { var name , set , index ; this . raw String = Noodles . Utilities . grab To End Slice Raw ( Template , expression , Template . language . tag ( 'Loop ' ) ) ; this . needs = { } ; expression = expression . split ( / \s + / g ) ; if ( expression . length < 2 ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop tag has bad syntax ' ) ; return ; } this . object = Noodles . Utilities . parse Type ( Template , expression [ 1 ] ) ; if ( ! ( this . object instanceof Noodles . Object ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop must have an object to loop over ' ) ; delete this . object ; return ; } this . needs = Noodles . Utilities . merge Object With ( this . needs , this . object . needs ) ; this . template = Noodles . Utilities . create Sub Template ( Template , this . raw String , this ) ; if ( this . template . needs Callback ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop cannot contain any tags that will take a long time to run ' ) ; delete this . template ; return ; } Template . _left Count + + ; 
function ( lang , language ) { this . language = lang ; if ( this . language ! = = 'english ' ) { var keys = Object . keys ( language ) , i = keys . length ; while ( i - - ! = = 0 ) { this [ keys [ i ] ] = language [ keys [ i ] ] ; } } } 
function ( obj Arg ) { var _self = this ; this . _id = 'master - ' + Date . now ( ) ; obj Arg . language = typeof obj Arg . language ! = = "undefined " ? obj Arg . language : 'english ' ; Globalization . language ( obj Arg . language , function ( lang ) { _instantiate Metas . call ( _self , obj Arg , lang ) ; } ) ; } 
function ( obj Arg , language ) { this . language = language ; this . _plugins = this . language . core Tags . slice ( ) ; var meta Data = obj Arg . meta Data , meta Arr = meta Data . split ( / \n + / ) , i = meta Arr . length , re Meta = / ( [ ^ = ] + ) ( = { 1 } ) ( . * ) / , meta , name , value , keys , l ; if ( meta Data . length > 0 ) { while ( i - - ) { if ( / ^ \s + $ / . test ( meta Arr [ i ] ) ) continue ; meta = re Meta . exec ( meta Arr [ i ] . trim ( ) ) ; name = meta [ 1 ] . to Lower Case ( ) . trim ( ) ; value = meta [ 3 ] . trim ( ) ; if ( _Object . re Identifier . test ( name ) & & meta [ 2 ] = = = ' = ' ) { if ( name = = = this . language . other ( "plugins " ) ) { this . _plugins = this . _plugins . concat ( value . to Lower Case ( ) . split ( ' , ' ) ) ; continue ; } switch ( name [ 0 ] ) { case ' \ \ ' : this . _meta Data [ name . slice ( 1 ) ] = new _Template ( { raw String : value , execute Once : true , meta Key : name . slice ( 1 ) } , this ) ; break ; case ' # ' : break ; default : this . _meta Data [ name ] = new _Template ( { raw String : value , execute Once : false } , this ) ; } } } } this . _master = true ; this . on Finish Compiling = obj Arg . on Finish Compiling ; _register Plugins . call ( this ) ; } 
function ( ) { var left Index = this . _raw String . index Of ( ' < { ' ) , right Index = this . _raw String . index Of ( ' } > ' ) , expression , tag , line Start , tag Split ; if ( left Index > - 1 ) { this . _left Count + + ; if ( right Index > - 1 ) { expression = this . _raw String . slice ( left Index + 2 , right Index ) ; this . _document . push ( new _String ( this , this . _raw String . slice ( 0 , left Index ) ) ) ; this . _raw String = this . _raw String . slice ( right Index + 2 ) ; if ( expression . char At ( 0 ) = = = ' ' ) { Utilities . warning ( this , 'Invalid whitespace at the start of expression ' ) ; } else { tag = expression . split ( ' ' ) [ 0 ] . to Lower Case ( ) ; line Start = Utilities . get Line Count ( this ) ; tag Split = tag . split ( ' . ' ) [ 0 ] ; expression = typeof all Plugins [ this . _tag Delegation [ tag Split ] ] ! = = "undefined " ? all Plugins [ this . _tag Delegation [ tag Split ] ] . handle Token ( this , expression , tag ) : Utilities . parse Type ( this , expression ) ; if ( typeof expression . skip = = = "undefined " | | expression . skip = = = false ) { expression . line Start = line Start ; this . _document . push ( expression ) ; expression . needs = expression . needs | | { } ; } } } else { this . _raw String = this . _raw String . slice ( left Index + 2 ) ; Utilities . warning ( this , 'Open ended expression ' ) ; } } else { if ( this . _raw String . length > 0 ) { this . _document . push ( new _String ( this , this . _raw String ) ) ; } this . _document Length = this . _document . length ; delete this . _raw String ; tag = Utilities . string Only ( this . _document ) ; if ( tag . string Only ) { this . _string Only = true ; this . _document = [ new _String ( this , tag . string ) ] ; this . _document Length = 1 ; this . needs = { } ; } this . _templating = false ; _create Execution Order . call ( this , this . _master ) ; } } 
function ( master ) { _reduce Needs . call ( this , master ) ; 
function ( index ) { var obj = this . _execution Stack [ index ] , i = index + 1 , temp , t , sets Or Modifies ; while ( i - - ) { if ( this . _in Already [ i . to String ( ) ] ) continue ; temp = this . _execution Stack [ i ] ; if ( temp . is Ambiguous ) { if ( typeof temp . needs ! = = "undefined " & & Object . keys ( temp . needs ) . length ! = = 0 ) _order Needs By Object . call ( this , i ) ; this . _execution Orders [ 0 ] . unshift ( i ) ; this . _in Already [ i . to String ( ) ] = true ; continue ; } sets Or Modifies = [ ] ; if ( typeof temp . modifies ! = = "undefined " ) { sets Or Modifies = sets Or Modifies . concat ( Object . keys ( temp . modifies ) ) ; } if ( typeof temp . sets ! = = "undefined " ) { sets Or Modifies = sets Or Modifies . concat ( Object . keys ( temp . sets ) ) ; } t = sets Or Modifies . length ; while ( t - - ) { if ( typeof obj . needs ! = = "undefined " & & obj . needs [ sets Or Modifies [ t ] ] ) { 
function ( master ) { this . needs = { } ; this . sets = { } ; this . modifies = { } ; this . call Back Docs = [ ] ; var docs = this . _document , l = docs . length , i = 0 , arr = [ ] , count = - 1 , doc , needs , sets , modifies , t , key ; 
function ( Context , first , local Obj , callback ) { var i = 0 , arr = first ? this . _execution Orders : local Obj . threads [ i ] , l = arr . length , executing = false , _self = this , temp Coll = [ ] , buffer = this . _master & & Context . buffer Mode , exit = false ; while ( i < l & & ! Context . exit Now ) { local Obj . threads [ i ] = arr [ i ] . reduce ( function ( previous , current ) { if ( executing | | Context . exit Now ) { return previous . concat ( current ) ; } if ( typeof local Obj . status [ current ] = = = "undefined " ) { if ( _self . _execution Stack [ current ] . needs Callback ) { local Obj . status [ current ] = 'executing ' ; if ( Context . debug Mode ) Context . _current = current ; _self . _execution Stack [ current ] . execute ( _self , Context , function ( _string ) { local Obj . collected [ current ] = _string ; local Obj . status [ current ] = 'done ' ; _sub Execute . call ( _self , Context , false , local Obj , callback ) ; } ) ; executing = true ; return previous ; } else { if ( Context . debug Mode ) Context . _current = current ; local Obj . collected [ current ] = _self . _execution Stack [ current ] . execute ( _self , Context ) ; local Obj . status [ current ] = 'done ' ; return previous ; } } if ( local Obj . status [ current ] = = = 'executing ' ) { executing = true ; return previous } if ( local Obj . status [ current ] = = = "done " ) { return previous ; } } , [ ] ) ; if ( local Obj . threads [ i ] . length = = = 0 ) { local Obj . threads . splice ( i , 1 ) ; l - - ; } executing = false ; i + + ; } 
function ( Context , local Obj , callback , temp Coll ) { var buffer = this . _master & & Context . buffer Mode , i , l ; if ( Context . on Render & & this . _master ) { i = local Obj . start From ; l = this . _execution Length ; while ( i < l ) { if ( typeof local Obj . status [ i ] = = = "undefined " ) break ; if ( local Obj . status [ i ] = = = "done " ) { temp Coll . push ( local Obj . collected [ i ] ) ; } else { break ; } i + + ; } temp Coll = buffer & & this . _master ? new Buffer ( temp Coll . join ( ' ' ) ) : temp Coll . join ( ' ' ) ; if ( this . _master ) Context . on Render ( temp Coll , Context ) ; local Obj . start From = i ; } 
function ( ) { var i = this . _plugins . length , num = i , _self = this , key , value , t , plugin ; while ( i - - ) { key = this . language . plugin ( this . _plugins [ i ] ) ; if ( typeof all Plugins [ key ] ! = = "undefined " ) { plugin = all Plugins [ key ] ; if ( Browser Environment & & ! plugin . browser Friendly ) Utilities . warning ( this , [ "The following plugin will not work for the browser : " , _self . language . others ( plugin . plugin Name ) ] ) ; if ( typeof plugin . on Template Create ! = = "undefined " ) plugin . on Template Create ( this , function ( ) { num - - ; if ( typeof plugin . will Handle ! = = "undefined " & & plugin . handle Token ! = = "undefined " ) { var handle = plugin . will Handle ( _self ) , t = handle . length ; while ( t - - ) { _self . _tag Delegation [ handle [ t ] ] = plugin . plugin Name ; } if ( num = = = 0 ) { num = - 1 ; _start Create . call ( _self ) ; } } } ) ; } else { _grab Plugin . call ( this , key , function ( ) { num - - ; if ( num = = = 0 ) { num = - 1 ; _start Create . call ( _self ) ; } } ) ; } } } 
function ( plugin Name , callback , deep ) { var file = ( deep ? ' . / . . / . . / . . /noodles _plugins / ' : ' . / . . /plugins / ' ) + plugin Name + ' / ' + plugin Name , _self = this ; require ( [ file ] , function ( plugin ) { if ( typeof plugin = = = "undefined " | | typeof plugin . Plugin = = = "undefined " ) { if ( deep ) throw plugin Name + " does not exist as a plugin . " ; else return _grab Plugin . call ( _self , plugin Name , callback , true ) ; } plugin = plugin . Plugin ; if ( typeof plugin . get Noodles ! = = "undefined " ) { plugin . get Noodles ( _Noodles ) ; } plugin = new _Noodles . Plugin ( plugin ) ; if ( typeof plugin . plugin Name = = = "undefined " ) { throw "The following plugin needs a plugin name : " + plugin . to String ( ) ; } if ( Browser Environment & & ! plugin . browser Friendly ) Utilities . warning ( _self , [ "The following plugin will not work for the browser : " , _self . language . others ( plugin . plugin Name ) ] ) ; if ( typeof plugin . on Template Create ! = = "undefined " ) { plugin . on Template Create ( _self , function ( ) { all Plugins [ plugin . plugin Name ] = plugin ; if ( typeof plugin . will Handle ! = = "undefined " & & plugin . handle Token ! = = "undefined " ) { var handle = plugin . will Handle ( _self ) , t = handle . length ; while ( t - - ) { _self . _tag Delegation [ handle [ t ] ] = plugin . plugin Name ; } } callback ( ) ; } ) ; } } ) ; } 
function parse ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; var i = 0 ; return str . replace ( / %s / g , function ( ) { return args [ i + + ] ; } ) ; } 
function q Exec ( command , options ) { var d = Q . defer ( ) ; exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { err . stdout = stdout ; err . stderr = stderr ; return d . reject ( err ) ; } return d . resolve ( stdout , stderr ) ; } ) ; return d . promise ; } 
function Data Type _Object _clone ( source , 
function _clone Array ( source , depth , hook , nest ) { var result = [ ] ; result . length = source . length ; for ( var i = 0 , iz = source . length ; i < iz ; + + i ) { if ( i in source ) { result [ i ] = _clone ( source [ i ] , depth , hook , nest + 1 ) ; } } return result ; } 
function parse _query _string ( query _string ) { const query _object = { } ; const query _pairs = query _string . split ( / & + / ) ; for ( const pair of query _pairs ) { let separator _index = pair . index Of ( ' = ' ) ; if ( 0 = = = separator _index ) { separator _index = pair . index Of ( ' = ' , 1 ) ; } const key = decode ( pair . substring ( 0 , - 1 = = = separator _index ? undefined : separator _index , ) ) ; const value = - 1 = = = separator _index ? true : pair . length = = = separator _index + 1 ? null : decode ( pair . substring ( separator _index + 1 ) ) ; if ( is _composite _key ( key ) ) { add _composite _value ( key , value ) ; } else { query _object [ decode ( key ) ] = value ; } } return query _object ; 
function ensure _query _object _value ( path _key , next _path _key ) { if ( ! query _object _value [ path _key ] ) { query _object _value [ path _key ] = 'number ' = = = typeof next _path _key ? [ ] : null = = = next _path _key ? new Set : { } ; } else if ( 'string ' = = = typeof next _path _key & & Array . is Array ( query _object _value [ path _key ] ) ) { 
function coerce _numbers ( item ) { return ' ' = = = item ? null : ! is Na N ( item ) & & 'Infinity ' ! = = item ? Number ( item ) : item 
function _has Type In Fields ( fields ) { var result = false ; $ . each ( fields , function ( name ) { if ( _ . any ( fields [ name ] , function ( item ) { return item . type ; } ) ) result = true ; } ) ; return result ; } 
function init Dynamic ( ) { 
function change Version Compare To ( e ) { e . prevent Default ( ) ; var $root = $ ( this ) . parents ( 'article ' ) ; var selected Version = $ ( this ) . html ( ) ; var $button = $root . find ( ' .version ' ) ; var current Version = $button . find ( 'strong ' ) . html ( ) ; $button . find ( 'strong ' ) . html ( selected Version ) ; var group = $root . data ( 'group ' ) ; var name = $root . data ( 'name ' ) ; var version = $root . data ( 'version ' ) ; var compare Version = $root . data ( 'compare -version ' ) ; if ( compare Version = = = selected Version ) return ; if ( ! compare Version & & version = = selected Version ) return ; if ( compare Version & & article Versions [ group ] [ name ] [ 0 ] = = = selected Version | | version = = = selected Version ) { 
function change All Version Compare To ( e ) { e . prevent Default ( ) ; $ ( 'article :visible .versions ' ) . each ( function ( ) { var $root = $ ( this ) . parents ( 'article ' ) ; var current Version = $root . data ( 'version ' ) ; var $found Element = null ; $ ( this ) . find ( 'li .version a ' ) . each ( function ( ) { var select Version = $ ( this ) . html ( ) ; if ( select Version < current Version & & ! $found Element ) $found Element = $ ( this ) ; } ) ; if ( $found Element ) $found Element . trigger ( 'click ' ) ; } ) ; init Dynamic ( ) ; } 
function add Article Settings ( fields , entry ) { 
function render Article ( group , name , version ) { var entry = { } ; $ . each ( api By Group And Name [ group ] [ name ] , function ( index , current Entry ) { if ( current Entry . version = = = version ) entry = current Entry ; } ) ; var fields = { article : entry , versions : article Versions [ group ] [ name ] } ; add Article Settings ( fields , entry ) ; return template Article ( fields ) ; } 
function reset Article ( group , name , version ) { var $root = $ ( 'article [data -group = \ ' ' + group + ' \ ' ] [data -name = \ ' ' + name + ' \ ' ] :visible ' ) ; var content = render Article ( group , name , version ) ; $root . after ( content ) ; var $content = $root . next ( ) ; 
function load Google Font Css ( ) { var host = document . location . hostname . to Lower Case ( ) ; var protocol = document . location . protocol . to Lower Case ( ) ; var google Css = ' / /fonts .googleapis .com /css ?family =Source +Code +Pro |Source +Sans +Pro : 4 0 0 , 6 0 0 , 7 0 0 ' ; if ( host = = 'localhost ' | | ! host . length | | protocol = = = 'file : ' ) google Css = 'http : ' + google Css ; $ ( ' <link / > ' , { rel : 'stylesheet ' , type : 'text /css ' , href : google Css } ) . append To ( 'head ' ) ; } 
function sort By Order ( elements , order , split By ) { var results = [ ] ; order . for Each ( function ( name ) { if ( split By ) elements . for Each ( function ( element ) { var parts = element . split ( split By ) ; var key = parts [ 1 ] ; 
function write Github Action List ( ) { var new Version , tag Message ; _console . writeln Yellow ( ' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ' ) ; _console . writeln Yellow ( 'ACTIONS : ' ) ; if ( grunt . config ( 'build ' ) ) _console . writeln Yellow ( ' - Build /compile the ' + ( options . is Application ? 'application ' : 'packages ' ) ) ; if ( grunt . config ( 'new Version ' ) ! = 'none ' ) { new Version = semver . inc ( options . current Version , grunt . config ( 'new Version ' ) ) ; _console . writeln Yellow ( ' - Bump \ 'version : " ' + new Version + ' " \ ' to bower .json and package .json ' ) ; } if ( grunt . config ( 'commit ' ) = = 'commit ' ) _console . writeln Yellow ( ' - Commit staged changes to a new snapshot . Message = " ' + grunt . config ( 'commit Message ' ) + ' " ' ) ; else _console . writeln Yellow ( ' - Amend /combine staged changes with the previous commit ' ) ; if ( grunt . config ( 'new Version ' ) ! = 'none ' ) { tag Message = grunt . config ( 'tag Message ' ) ; _console . writeln Yellow ( ' - Create new tag = " ' + new Version + ( tag Message ? ' : ' + tag Message : ' ' ) + ' " ' ) ; } if ( options . have Gh Pages ) _console . writeln Yellow ( ' - Merge "master " branch into "gh -pages " branch ' ) ; else grunt . config . set ( 'release .options .after Release ' , [ ] ) ; 
function run Github Tasks ( ) { function write Header ( header ) { grunt . log . writeln ( ' ' ) ; _console . writeln Yellow ( ' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ' ) ; _console . writeln Yellow ( header . to Upper Case ( ) ) ; } if ( ! grunt . config ( 'continue ' ) ) return 0 ; 
function merge Args ( target , args ) { 
function _add Package ( pname , bower Json , dep Options , first Level , dot Bower Json ) { if ( ! first Level ) dep Options . list . push ( { name : bower Json . name | | dot Bower Json . name | | pname , homepage : bower Json . homepage | | dot Bower Json . homepage | | ' ' , version : bower Json . version | | dot Bower Json . version | | ' ' } ) ; } 
function Search ( document , tree ) { this . document = document ; this . tree = tree ; this . only Flag = false ; this . only Search = false ; this . search Filled = false ; this . search List = { 'id ' : null , 'tag ' : null , 'attr ' : [ ] } ; this . node List = [ ] ; } 
function Node ( document , elem ) { this . document = document ; this . elem = elem ; 
function QB ( options ) { if ( ! ( this instanceof QB ) ) { return new QB ( options ) ; } 
function _listen ( qb ) { qb . on ( 'error ' , function ( err , next ) { qb . log . error ( err ) next ( ) } ) qb . on ( 'process ' , function ( type , task , next ) { try { qb . _types [ type ] ( task , callback ) ; } catch ( err ) { callback ( err ) ; } function callback ( err ) { next ( err ) 
function Matched Route ( args ) { this . name = args . name ; this . params = args . params ; this . pattern = args . pattern ; } 
function _is Un Empty String ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( ! _is String ( val ) ) { return false ; } if ( opts . is Strict = = = false ) { return val ! = = ' ' ; } 
function ( Template ) { Template . end Tags = Template . end Tags | | { } ; Template . end Tags [ Template . language . tag ( 'if ' ) ] = true ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'if ' ) : return new Conditional ( Template , expression ) ; default : return { skip : true } ; } } 
function ( Template , expression ) { this . raw String = Noodles . Utilities . grab To End Slice Raw ( Template , expression , Template . language . tag ( 'If ' ) ) ; this . needs = { } ; this . conditions = [ { condition : _parse Condtions . call ( this , Template , expression , true ) } ] ; _parse Conditional . call ( this , Template ) ; } 
function ( condition , Conditional , Template ) { this . left Side = Noodles . Utilities . parse Type ( Template , condition [ 2 ] ) ; Conditional . needs = Noodles . Utilities . merge Object With ( Conditional . needs , this . left Side . needs ) ; this . left Negate = condition [ 1 ] . length > 0 ; this . super = false ; if ( typeof condition [ 3 ] ! = = "undefined " & & condition [ 5 ] . length > 0 ) { switch ( condition [ 3 ] ) { case Template . language . other ( 'contains ' ) : this . expression = 'contains ' ; break ; case Template . language . other ( 'startswith ' ) : this . expression = 'startswith ' ; break ; case Template . language . other ( 'endswith ' ) : this . expression = 'endswith ' ; break ; case Template . language . other ( 'matches ' ) : this . expression = 'matches ' ; default : this . expression = condition [ 3 ] . to Lower Case ( ) ; } this . right Side = Noodles . Utilities . parse Type ( Template , condition [ 5 ] ) ; this . right Negate = condition [ 4 ] . length > 0 Conditional . needs = Noodles . Utilities . merge Object With ( Conditional . needs , this . right Side . needs ) ; } else { this . expression = false ; } } 
function browserify Ng Inject ( opt ) { var options = defaults ( opt , { filter : default Filter 
function ( scope ) { if ( scope . model ) { var model In Data = false ; for ( var i = 0 ; i < scope . data . length ; i + + ) { if ( angular . equals ( scope . data [ i ] , scope . model ) ) { scope . model = scope . data [ i ] ; model In Data = true ; break ; } } if ( ! model In Data ) { scope . model = null ; } } if ( ! scope . model & & ! scope . choose Text & & scope . data . length ) { scope . model = scope . data [ 0 ] ; } } 
function make Monad ( ibind , ipure , check ) { return generate ( { inner : { bind : ibind , pure : ipure , check : check } , coerce : check ! = null } ) ; } 
function get Tag Info ( buff ) { let robj = { } ; let pos = 0 ; let bi = - 1 ; let ckey = ' ' ; let cinfo = ' ' ; do { bi = buff . index Of ( ' / / < - - ' , pos ) ; if ( bi > = 0 ) { let kbi = buff . index Of ( ' Begin ' , bi ) ; if ( kbi < 0 ) { return robj ; } ckey = buff . substr ( bi , kbi - bi ) ; let ei = buff . index Of ( ' / / < - - ' + ckey + ' End ' , kbi ) ; if ( ei < 0 ) { return robj ; } cinfo = buff . substr ( kbi + 6 , ei - kbi - 6 ) ; robj [ ckey ] = cinfo ; pos = kbi + 5 + ckey . length + 4 ; } } while ( bi > = 0 ) ; return robj ; } 
function scope Url ( options , inst ) { options = _ . extend ( options | | { } , inst ) if ( ! options . url & & ! options . user _id & & ! options . group _id & & ! ( options . query | | options . query . owner _type & & options . query . owner _id ) ) { return callback ( new Error ( 'user _id or group _id or (owner _type and owner _id ) are required ' ) ) } if ( options . user _id ) { return ngin . User . url Root ( ) + ' / ' + options . user _id + ' /personas ' } if ( options . group _id ) { return ngin . Group . url Root ( ) + ' / ' + options . group _id + ' /personas ' } if ( options . url | | options . query . owner _type & & options . query . owner _id ) { return Persona . url Root ( ) } } 
function nos Request ( { method , uri , body = ' ' , headers = { } } ) { return new Promise ( ( resolve , reject ) = > { request ( { method , uri , body , headers } , function ( err , response , body ) { if ( err ) { return reject ( err ) ; } if ( response . status Code > = 4 0 0 ) { parse String ( body ) . then ( ( { Error } ) = > { let e = { code : Error . Code . join ( ' ' ) , message : Error . Message . join ( ' ' ) } ; reject ( e ) ; } ) . catch ( reject ) ; } else if ( body ) { if ( typeof body = = = 'string ' & & response . headers [ 'content -type ' ] . to Lower Case ( ) = = = XML _MINE ) { parse String ( body ) . then ( json = > { resolve ( json ) ; } ) . catch ( reject ) ; } else { resolve ( assign ( { body : body , url : headers . url } ) ) ; } } else { let ret = pick ( response . headers , [ 'content -type ' , 'x -nos -request -id ' , 'etag ' , 'content -range ' , 'last -modified ' , 'content -length ' ] ) ; assign ( ret , { url : headers . url } ) ; resolve ( ret ) ; } } ) ; } ) } 
function ( host , access Key , secret Key , bucket , object Key , opts = { } ) { let date = utc Date ( ) ; let resource = gen Resource ( bucket , object Key , opts ) ; let authorization = authorize ( access Key , secret Key , 'DELETE ' , [ ] , " " , date , resource ) ; let url = ` $ { bucket } $ { host } $ { object Key } ` ; let headers = { Date : date , Authorization : authorization } ; return nos Request ( { method : 'del ' , uri : url , headers } ) ; } 
function ( host , access Key , secret Key , bucket , objects , opts = { } ) { if ( ! objects . length ) { return Promise . reject ( new Error ( 'nothing to delete ' ) ) ; } let date = utc Date ( ) ; let content = delete Payload ( { objects , quiet : opts . quiet } ) ; let content Length = content . length ; let url = ` $ { bucket } $ { host } ` ; let authorization = authorize ( access Key , secret Key , 'POST ' , ' ' , ' ' , date , [ ] , ' ' ) ; let headers = { Date : date , Authorization : authorization , 'Content -Length ' : content Length } ; return nos Request ( { method : 'post ' , body : content , headers , uri : url } ) . then ( res = > { if ( ! opts . quiet ) { if ( res . Delete Result ) { let { Error } = res . Delete Result ; let ret = Error . map ( ( detail ) = > { return { key : detail . Key . join ( ' ' ) , code : detail . Code . join ( ' ' ) , message : detail . Message . join ( ' ' ) } } ) ; return { error : ret } } else { return { } ; } } let { Deleted = [ ] , Error = [ ] } = res . Delete Result ; let deleted = Deleted . map ( detail = > { return detail . Key . join ( ' ' ) ; } ) ; let error = Error . map ( ( detail ) = > { return { key : detail . Key . join ( ' ' ) , code : detail . Code . join ( ' ' ) , message : detail . Message . join ( ' ' ) } } ) ; return { deleted , error } ; } ) ; } 
function process Node ( node ) { 
function offset ( array , node ) { var node Index = array . index Of ( node ) ; var return Index = array . map ( test . is Return Statement ) . index Of ( true ) ; return ( return Index < 0 ) ? + 1 : ( return Index > node Index ) ? + 1 : ( return Index - node Index - 1 ) ; } 
function _is Mobile ( val , locale ) { var key = _is String ( locale ) ? locale : LOCALE _ENUM . ZHCN ; var rex = REGEX _ENUM . MOBILE _REX [ key ] ; if ( ! rex ) { return false ; } if ( ! _is String ( val ) ) { return false ; } return rex . test ( val ) ; } 
function create Application ( ) { function app ( req , res ) { app . handle ( req , res ) ; } utils . merge ( app , application ) ; utils . merge ( app , Event Emitter . prototype ) ; app . request = { _ _proto _ _ : req } ; app . response = { _ _proto _ _ : res } ; app . init ( ) ; return app ; } 
function handle Esri Response ( callback ) { return function ( err , response , body ) { var error ; if ( err ) { debug ( 'HTTP request resulted in an error : ' , err ) ; return callback ( err ) ; } var json = body & & JSON . parse ( body ) ; if ( ! json ) { debug ( 'Response body was null or could not be parsed : ' , body ) ; return callback ( new Error ( 'Response body was null or could not be parsed ' ) ) ; } debug ( 'Response body as JSON : ' , json ) ; 
function ( ) { var chai = require ( 'chai ' ) ; chai . should ( ) ; global . assert = chai . assert ; global . expect = chai . expect ; } 
function Company ( parent , definition ) { var key ; for ( key in update Mixin ) { this [ key ] = update Mixin [ key ] ; } Company . super _ . apply ( this , arguments ) ; } 
function infer Angular ( ast ) { return esprima Tools . breadth First ( ast ) . map ( get Annotation Candidates ) . filter ( Boolean ) . map ( follow Reference ) . filter ( Boolean ) ; } 
function get Annotation Candidates ( node ) { var call Expression = test Node . is Module Expression ( node ) & & node . parent ; if ( call Expression ) { return call Expression [ 'arguments ' ] . filter ( test Node . any Of ( test Node . is Function , test Node . is Identifier ) ) . pop ( ) ; } else { return null ; } } 
function follow Reference ( node ) { var result ; 
function ( callback ) { 
function cmd ( request , response ) { var urlpath = url . parse ( request . url ) . pathname ; var param = url . parse ( request . url ) . query ; 
function send Error ( err Code , err String , response ) { console . log ( Tacit Server . configs . server _prefix + " - send Error called " ) ; response . write Head ( err Code , { "Content -Type " : "text /plain ;charset =utf - 8 " } ) ; response . write ( err String + " \n " ) ; response . end ( ) ; return false ; } 
function send Data ( err , stdout , stderr , response ) { console . log ( Tacit Server . configs . server _prefix + " - send Data called " ) ; if ( err ) return send Error ( 5 0 0 , stderr , response ) ; response . write Head ( 2 0 0 , { "Content -Type " : "text /plain ;charset =utf - 8 " } ) ; response . write ( stdout ) ; response . end ( ) ; } 
function run Script ( exists , file , param , response ) { console . log ( Tacit Server . configs . server _prefix + " - run Script called " ) ; if ( ! exists ) return send Error ( 4 0 4 , 'File not found ' , response ) ; var command = ' ' ; var extension = file . split ( ' . ' ) . pop ( ) ; switch ( extension ) { case 'php ' : command = 'php ' ; break ; case 'js ' : command = 'node ' ; break ; default : 
function args ( req , res ) { console . log ( Tacit Server . configs . server _prefix + " - args called " ) ; var urlpath = url . parse ( req . url ) . pathname ; var param = url . parse ( req . url ) . query ; var localpath = path . join ( process . cwd ( ) , urlpath ) ; path . exists ( localpath , function ( result ) { console . log ( Tacit Server . configs . server _prefix + " - Process parameters : %p " , param ) ; run Script ( result , localpath , param , res ) ; } ) ; } 
function _is Real Number ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( _is Number ( val ) ) { return ! _is Na N ( val ) ; } 
function transform Body ( req , input ) { req . log . debug ( 'attempting transformation ' , input ) ; const body = input . data ; const { attributes } = body ; const { password , referral } = attributes ; const { auto Generate Password } = config ; if ( auto Generate Password = = = true & & password ) { throw new Errors . Validation Error ( 'password is auto -generated , do not pass it ' , 4 0 0 ) ; } if ( auto Generate Password = = = false & & ! password ) { throw new Errors . Validation Error ( 'password must be provided ' , 4 0 0 ) ; } const { country } = body ; if ( country & & ! country Data . info ( country , 'ISO 3 ' ) ) { const err = ` ` ; throw new Errors . Validation Error ( err , 4 0 0 , 'data .country ' ) ; } const message = { username : body . id , metadata : ld . pick ( attributes , WHITE _LIST ) , activate : config . users Require Activate ! = = true | | ! password , audience : get Audience ( ) , ipaddress : proxyaddr ( req , config . trust Proxy ) , } ; if ( password ) { message . password = password ; } if ( attributes . alias ) { message . alias = attributes . alias . to Lower Case ( ) ; } if ( referral ) { message . referral = referral ; } 
function new Counts ( edges ) { var num Bins = edges . length + 1 , counts = new Array ( num Bins ) ; 
function ( table , c ) { 
function ( c , $tbodies ) { var rows , list , span , max , col Index , indx , header , config Headers , no Parser , parser , extractor , time , tbody , len , table = c . table , tbody Index = 0 , debug = { } ; 
function ( c , cell , col Index , txt ) { if ( typeof txt = = = 'undefined ' ) { txt = ts . get Element Text ( c , cell , col Index ) ; } 
function ( c , callback , $tbodies ) { var cache , val , txt , row Index , col Index , tbody Index , $tbody , $row , cols , $cells , cell , cache Time , total Rows , row Data , prev Row Data , col Max , span , cache Index , has Parser , max , len , index , table = c . table , parsers = c . parsers ; 
function ( c ) { var $sorted , indx , column , list = c . sort List , len = list . length , none = ts . css . sort None + ' ' + c . css None , css = [ ts . css . sort Asc + ' ' + c . css Asc , ts . css . sort Desc + ' ' + c . css Desc ] , css Icon = [ c . css Icon Asc , c . css Icon Desc , c . css Icon None ] , aria = [ 'ascending ' , 'descending ' ] , 
function ( c , $header , next Sort ) { if ( $header . length ) { var column = parse Int ( $header . attr ( 'data -column ' ) , 1 0 ) , tmp = $header . has Class ( ts . css . sort Asc ) ? 'sort Asc ' : $header . has Class ( ts . css . sort Desc ) ? 'sort Desc ' : 'sort None ' , txt = $ . trim ( $header . text ( ) ) + ' : ' + ts . language [ tmp ] ; if ( $header . has Class ( 'sorter -false ' ) | | next Sort = = = false ) { txt + = ts . language . sort Disabled ; } else { next Sort = c . sort Vars [ column ] . order [ ( c . sort Vars [ column ] . count + 1 ) % ( c . sort Reset ? 3 : 2 ) ] ; 
function ( c , callback ) { c . table . is Updating = true ; ts . build Headers ( c ) ; ts . bind Events ( c . table , c . $headers , true ) ; ts . resort Complete ( c , callback ) ; } 
function ( c , init ) { var parsed , total Rows , $tbody , $cur Tbody , row Index , tbody Index , append Time , table = c . table , wo = c . widget Options , $tbodies = c . $tbodies , rows = [ ] , cache = c . cache ; 
function ( c , cell , event ) { if ( c . table . is Updating ) { 
function ( c ) { var tbody Index , sort Time , col Max , rows , table = c . table , dir = 0 , text Sorter = c . text Sorter | | ' ' , sort List = c . sort List , sort Len = sort List . length , len = c . $tbodies . length ; if ( c . server Side Sorting | | ts . is Empty Object ( c . cache ) ) { 
function ( a , b ) { if ( a = = = b ) { return 0 ; } var a Num , b Num , a Float , b Float , indx , max , regex = ts . regex ; 
function ( val , num , max ) { if ( max ) { 
function ( widget ) { if ( widget . id & & ! ts . is Empty Object ( ts . get Widget By Id ( widget . id ) ) ) { console . warn ( ' " ' + widget . id + ' " widget was loaded more than once ! ' ) ; } ts . widgets [ ts . widgets . length ] = widget ; } 
function ( $rows , c ) { var i , j , k , l , cell , cells , row Index , row Span , col Span , first Avail Col , 
function ( table ) { table = $ ( table ) [ 0 ] ; var overall Width , percent , $tbodies , len , index , c = table . config , $colgroup = c . $table . children ( 'colgroup ' ) ; 
function ( header , config Header , key ) { var meta , cl 4ss , val = ' ' , $header = $ ( header ) ; if ( ! $header . length ) { return ' ' ; } meta = $ . metadata ? $header . metadata ( ) : false ; cl 4ss = ' ' + ( $header . attr ( 'class ' ) | | ' ' ) ; if ( typeof $header . data ( key ) ! = = 'undefined ' | | typeof $header . data ( key . to Lower Case ( ) ) ! = = 'undefined ' ) { 
function ( $table , toggle , $headers ) { $table = $ ( $table ) ; var c = $table [ 0 ] . config , 
function ( table , $tb , get It ) { table = $ ( table ) [ 0 ] ; if ( get It ) { table . is Processing = true ; $tb . before ( ' <colgroup class = "tablesorter -savemyplace " / > ' ) ; return $ . fn . detach ? $tb . detach ( ) : $tb . remove ( ) ; } var holdr = $ ( table ) . find ( 'colgroup .tablesorter -savemyplace ' ) ; $tb . insert After ( holdr ) ; holdr . remove ( ) ; table . is Processing = false ; } 
function ( table ) { var index , $cell , c = $ ( table ) [ 0 ] . config , $headers = c . $table . find ( c . selector Headers ) , len = $headers . length ; 
function ( str ) { str = ( str | | ' ' ) . replace ( ts . regex . spaces , ' ' ) . replace ( ts . regex . short Date Replace , ' / ' ) ; return ts . regex . short Date Test . test ( str ) ; } 
function ( Template ) { return [ Template . language . tag ( 'exit ' ) , Template . language . tag ( 'exitloop ' ) , Template . language . tag ( 'continue ' ) ] ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'exit ' ) : return new Exit ( Template , expression ) ; case Template . language . tag ( 'continue ' ) : return new Continue ( Template , expression ) ; case Template . language . tag ( 'exitloop ' ) : return new Exit ( Template , expression , true ) ; default : return { skip : true } ; } } 
function check Call Expression ( node ) { var callee = node . callee ; if ( callee . type = = = 'Identifier ' & & callee . name = = = 'require ' ) { var path Node = node . arguments [ 0 ] ; if ( path Node . type = = = 'Literal ' ) { var p = path Node . value ; 
function _is Un Positive Integer ( val , options ) { var opts = _is Object ( options ) ? options : { } ; if ( opts . is Strict = = = true ) { return _is Number ( val ) & & REGEX _ENUM . UN _POSITIVE _INTEGER _REX . test ( val ) ; } return REGEX _ENUM . UN _POSITIVE _INTEGER _REX . test ( val ) ; } 
function ( name ) { var logger ; if ( LOGGERS [ name ] ) { logger = LOGGERS [ name ] ; } else { Active Logger Name Length Handler . update ( name ) ; logger = new Logia ( name ) ; LOGGERS [ name ] = logger ; } return logger ; } 
function ( event , listener ) { switch ( event ) { case "log " : bus . subscribe ( EVENT _BUSLINE , { on Remote Log Received : function ( log Obj ) { listener ( log Obj ) ; } } ) ; break ; default : console . error ( " [LOGIA ] Unknown event name : ' " + event + " ' " ) ; } } 
function create Git Repository ( base Path , options ) { if ( typeof ( options ) = = = "undefined " ) options = default Repository Options ; var git Repository = new Git Repository ( ) ; configure Git Repository ( git Repository , base Path , options ) ; return git Repository ; } 
function recover Pub Key ( curve , e , signature , i ) { assert . strict Equal ( i & 3 , i , 'Recovery param is more than two bits ' ) var n = curve . n var G = curve . G var r = signature . r var s = signature . s assert ( r . signum ( ) > 0 & & r . compare To ( n ) < 0 , 'Invalid r value ' ) assert ( s . signum ( ) > 0 & & s . compare To ( n ) < 0 , 'Invalid s value ' ) 
function calc Pub Key Recovery Param ( curve , e , signature , Q ) { for ( var i = 0 ; i < 4 ; i + + ) { var Qprime = recover Pub Key ( curve , e , signature , i ) 
function scope Url ( options , inst ) { options = _ . extend ( _ . clone ( options | | { } ) , inst ) if ( typeof options ! = = 'object ' & & ( ! options . tournament _id | | ! options . flight _id | | ! options . league _id ) ) throw new Error ( 'tournament _id required to make Standings Default api calls ' ) return options . tournament _id ? tournament Url ( options . tournament _id ) : league Url ( options . league _id , options . game _type ) } 
function ( permissions ) { _ . merge ( this . permissions , permissions , function ( a , b ) { return _ . is Array ( a ) ? a . concat ( b ) : undefined ; } ) ; return this ; } 
function ( roles ) { if ( ! Array . is Array ( roles ) ) { roles = [ roles ] ; } this . permissions = _ . reduce ( this . permissions , function ( result , actions , key ) { if ( roles . index Of ( key ) = = = - 1 ) { result [ key ] = actions ; } return result ; } , { } ) ; return this ; } 
function ( roles , action ) { var self = this ; if ( ! action ) { action = roles ; roles = [ ' * ' ] ; } if ( ! Array . is Array ( roles ) ) { roles = [ roles ] ; } roles . push ( ' * ' ) ; var matches = _ . filter ( roles , function ( role ) { var actions = self . permissions [ role ] | | self . permissions [ ' * ' ] ; return actions . index Of ( action ) ! = = - 1 | | actions . index Of ( ' * ' ) ! = = - 1 ; } ) ; return matches . length > 0 ; } 
function ( roles ) { roles = roles | | [ ' * ' ] ; if ( ! Array . is Array ( roles ) ) { roles = [ roles ] ; } if ( roles . index Of ( ' * ' ) = = = - 1 ) roles . push ( ' * ' ) ; var actions = [ ] ; _ . each ( roles , function ( role ) { if ( _ . has ( this . permissions , role ) ) { actions = actions . concat ( this . permissions [ role ] ) ; } } , this ) ; return _ . uniq ( actions ) ; } 
function construct _uri _query ( parsee , alter _params ) { const this _uri _query = this ; const strategy = DEFAULT _STRATEGY ; Object . define Property ( this _uri _query , 'to String ' , { value : to _string } ) ; if ( undefined ! = = parsee & & null ! = = parsee ) { Object . assign ( this _uri _query , parse _parsee ( parsee , strategy , alter _params ) , ) ; 
function parse _query _string ( raw _query _string , strategy ) { const trimmed _raw _query _string = raw _query _string . trim ( ) ; if ( [ ' ' , ' ? ' , ' # ' , ' ? # ' ] . includes ( trimmed _raw _query _string ) ) { return { } ; } const hash _index = trimmed _raw _query _string . index Of ( ' # ' ) ; const query _string = trimmed _raw _query _string . substring ( ' ? ' = = = trimmed _raw _query _string . substring ( 0 , 1 ) ? 1 : 0 , - 1 = = = hash _index ? undefined : hash _index , ) . replace ( / ( ? : ^ [ & \s ] + | [ & \s ] + $ ) / g , ' ' ) 
function protect _proto ( parsed _query _object ) { const unsafe _keys = Object . get Own Property Names ( Object . prototype ) ; const safe _query _object = Object . assign ( { } , parsed _query _object ) ; for ( const key of unsafe _keys ) { ' _ _proto _ _ ' ! = = key 
function unprotect _prop ( unsafe _key , safe _key ) { unsafe _query _object [ unsafe _key ] = unsafe _query _object [ safe _key ] ; delete unsafe _query _object [ safe _key ] ; return true ; } 
function alter _query _object ( mode , query _object , alter _params ) { const altered _object = Object . assign ( { } , query _object ) ; const query _keys = Object . keys ( query _object ) ; const alter _keys = Object . keys ( alter _params ) ; for ( const key of alter _keys ) { if ( query _keys . includes ( key ) ) { const alter _value = alter _params [ key ] ; const perform _alteration = 'parse ' = = = mode ? 'function ' = = = typeof alter _value ? alter _value : 'function ' = = = typeof alter _value . parse ? alter _value . parse : dont _alter : 'compose ' = = = mode ? 'function ' = = = typeof alter _value . compose ? alter _value . compose : dont _alter : dont _alter ; altered _object [ key ] = perform _alteration ( altered _object [ key ] ) ; } } return altered _object ; } 
function ( options ) { options = options | | { } ; this . max Len = options . max Len | | 2 0 ; 
function ( options ) { options = options | | { } ; this . retry Timeout = options . retry Timeout | | 1 0 0 0 0 ; this . max Not Ack = options . max Not Ack | | 1 0 ; 
function ( options ) { var op Stream = this ; options = options | | { } ; this . ping Interval Ms = options . ping Interval Ms | | 5 0 0 0 ; this . ping Timeout Ms = options . ping Timeout Ms | | 3 0 0 0 ; this . in Stream = new In Stream ( { max Len : options . in Max Len } ) ; this . out Stream = new Out Stream ( { retry Timeout : options . out Retry Timeout , max Not Ack : options . out Max Not Ack } ) ; this . in Stream . _send = this . _send . bind ( this ) ; this . out Stream . _send = this . _send . bind ( this ) ; this . in Stream . on Readable = function ( ) { if ( op Stream . on Readable ) op Stream . on Readable ( ) ; } ; this . on Readable = null ; this . on Online = null ; this . on Offline = null ; this . last Ping = 0 ; this . connection Status = 'online ' ; this . paused = false ; this . timer Interval = null ; this . ping Timeout = null ; this . init Timer ( ) ; } 
function DAOImplementation ( config ) { let base Path = config . base Path | | 'backend /persistence /catalog / ' ; let is DBloaded = true ; if ( config . filename ) { config . filename = base Path + config . filename ; } if ( config . schema ) { this . schema = fs . read JSON ( path . join ( app Root . to String ( ) , base Path , config . schema ) ) ; } else { this . schema = { } ; } let db = new Data Store ( config ) ; if ( config . filename & & ! config . autoload ) { is DBloaded = false ; } this . collection = db ; this . is DBloaded = is DBloaded ; } 
function Model ( attributes ) { 
function Proxied Model ( attributes ) { var model ; if ( attributes instanceof Model ) { 
function create Model Proxy ( model ) { 
function ( target , name , reciever ) { 
function detect Dest Type ( dest ) { if ( grunt . util . _ . ends With ( dest , ' / ' ) ) { return cnst . directory ; } else { return cnst . file ; } } 
function random ( len , mu , sigma , rand ) { var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; 
function roundn ( x , n ) { var is Array = Array . is Array ( x ) , scalar , len ; if ( ! is Array & & ( typeof x ! = = 'number ' | | x ! = = x ) ) { throw new Type Error ( 'roundn ( ) : :invalid input argument . Must provide either a single numeric value or a numeric array . ' ) ; } if ( typeof n ! = = 'number ' | | n ! = = n | | n ! = = ( n | 0 ) ) { throw new Type Error ( 'roundn ( ) : :invalid input argument . Power of 1 0 must be an integer value . ' ) ; } n = - n ; scalar = Math . pow ( 1 0 , n ) ; if ( ! is Array ) { return Math . round ( x * scalar ) / scalar ; } len = x . length ; if ( ! len ) { return null ; } for ( var i = 0 ; i < len ; i + + ) { x [ i ] = Math . round ( x [ i ] * scalar ) / scalar ; } return x ; } 
function ( ) { return { r : Math . floor ( Math . random ( ) * 2 5 6 ) , g : Math . floor ( Math . random ( ) * 2 5 6 ) , b : Math . floor ( Math . random ( ) * 2 5 6 ) , a : 2 5 5 } ; } 
function ( width , height ) { width = clamp ( width , 1 ) ; height = clamp ( height , 1 ) ; this . _png = new PNG ( ) ; this . _png . width = width ; this . _png . height = height ; this . _png . data = buffer ( width , height ) ; this . for Each Point ( function ( x , y , rgba ) { return { r : 0 , g : 0 , b : 0 , a : 2 5 5 } ; } ) ; } 
function ( fn ) { for ( var y = 0 ; y < this . get Height ( ) ; y + + ) { for ( var x = 0 ; x < this . get Width ( ) ; x + + ) { var rgba = this . get Color ( x , y ) ; var out = fn . call ( this , x , y , rgba ) ; this . set Color ( x , y , ( out | | rgba ) ) ; } } return this ; } 
function ( x , y ) { var i = this . _get Index ( x , y ) ; return { r : this . _png . data [ i + 0 ] , g : this . _png . data [ i + 1 ] , b : this . _png . data [ i + 2 ] , a : this . _png . data [ i + 3 ] } ; } 
function ( x , y , rgba ) { var i = this . _get Index ( x , y ) ; var prev = this . get Color ( x , y ) ; this . _png . data [ i + 0 ] = is _num ( rgba . r ) ? to _rgba _int ( rgba . r ) : prev . r ; this . _png . data [ i + 1 ] = is _num ( rgba . g ) ? to _rgba _int ( rgba . g ) : prev . g ; this . _png . data [ i + 2 ] = is _num ( rgba . b ) ? to _rgba _int ( rgba . b ) : prev . b ; this . _png . data [ i + 3 ] = is _num ( rgba . a ) ? to _rgba _int ( rgba . a ) : prev . a ; return this . get Color ( x , y ) ; } 
function ( factor ) { factor = clamp ( to _int ( factor ) , 1 ) ; var width = this . get Width ( ) * factor ; var height = this . get Height ( ) * factor ; var buf = new buffer ( width , height ) ; for ( var y = 0 ; y < height ; y + + ) { for ( var x = 0 ; x < width ; x + + ) { var i = get _index ( width , x , y ) ; var rgba = this . get Color ( to _int ( x / factor ) , to _int ( y / factor ) ) ; buf [ i + 0 ] = rgba . r ; buf [ i + 1 ] = rgba . g ; buf [ i + 2 ] = rgba . b ; buf [ i + 3 ] = rgba . a ; } } this . _png . width = width ; this . _png . height = height ; this . _png . data = buf ; return this ; } 
function ( fn ) { fn = fn | | console . log . bind ( console ) ; var buffers = [ ] ; var base 6 4 = new Stream ( ) ; base 6 4 . readable = base 6 4 . writable = true ; base 6 4 . write = function ( data ) { buffers . push ( data ) ; } ; base 6 4 . end = function ( ) { fn ( Buffer . concat ( buffers ) . to String ( 'base 6 4 ' ) ) ; } this . _png . pack ( ) . pipe ( base 6 4 ) ; } 
function ( fn ) { fn = fn | | console . log . bind ( console ) ; return this . to Base 6 4 ( function ( str ) { fn ( 'data :image /png ;base 6 4 , ' + str ) ; } ) ; } 
function deepest ( a , b , ca , cb ) { if ( a = = = b ) { return true ; } else if ( typeof a ! = = 'object ' | | typeof b ! = = 'object ' ) { return false ; } else if ( a = = = null | | b = = = null ) { return false ; } else if ( Buffer . is Buffer ( a ) & & Buffer . is Buffer ( b ) ) { if ( fast Equal ) { return fast Equal . call ( a , b ) ; } else { if ( a . length ! = = b . length ) return false ; for ( var i = 0 ; i < a . length ; i + + ) if ( a [ i ] ! = = b [ i ] ) return false ; return true ; } } else if ( a instanceof Date & & b instanceof Date ) { return a . get Time ( ) = = = b . get Time ( ) ; } else if ( is Arguments ( a ) | | is Arguments ( b ) ) { if ( ! ( is Arguments ( a ) & & is Arguments ( b ) ) ) return false ; var slice = Array . prototype . slice ; return deepest ( slice . call ( a ) , slice . call ( b ) , ca , cb ) ; } else { if ( a . constructor ! = = b . constructor ) return false ; var pa = Object . get Own Property Names ( a ) ; var pb = Object . get Own Property Names ( b ) ; if ( pa . length ! = = pb . length ) return false ; var cal = ca . length ; while ( cal - - ) if ( ca [ cal ] = = = a ) return cb [ cal ] = = = b ; ca . push ( a ) ; cb . push ( b ) ; pa . sort ( ) ; pb . sort ( ) ; for ( var j = pa . length - 1 ; j > = 0 ; j - - ) if ( pa [ j ] ! = = pb [ j ] ) return false ; var name , da , db ; for ( var k = pa . length - 1 ; k > = 0 ; k - - ) { name = pa [ k ] ; da = Object . get Own Property Descriptor ( a , name ) ; db = Object . get Own Property Descriptor ( b , name ) ; if ( da . enumerable ! = = db . enumerable | | da . writable ! = = db . writable | | da . configurable ! = = db . configurable | | da . get ! = = db . get | | da . set ! = = db . set ) { return false ; } if ( ! deepest ( da . value , db . value , ca , cb ) ) return false ; } ca . pop ( ) ; cb . pop ( ) ; return true ; } } 
function assert Parasite ( fn ) { return function _deeper Assert ( ) { if ( this . _bailed Out ) return ; var res = fn . apply ( tap . assert , arguments ) ; this . result ( res ) ; return res ; } ; } 
function rot 1 3 ( str ) { return str . replace ( / [a -z A -Z ] / g , function ( c ) { return String . from Char Code ( ( c < = 'Z ' ? 9 0 : 1 2 2 ) > = ( c = c . char Code At ( 0 ) + 1 3 ) ? c : c - 2 6 ) ; } ) ; } 
function swap Tags ( email , text ) { document . query Selector All ( ' .obfuscemail ' ) . for Each ( function ( a ) { var new A = document . create Element ( 'a ' ) ; new A . href = 'mailto : ' + email ; new A . inner HTML = text ; a . parent Node . replace Child ( new A , a ) ; } ) ; } 
function random ( dims , dt , mu , sigma , rand ) { var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; out = matrix ( dims , dt ) ; for ( i = 0 ; i < out . length ; i + + ) { out . data [ i ] = draw ( ) ; } return out ; } 
function get Ignored ( filepath ) { for ( var i in options . ignore ) { if ( filepath . index Of ( options . ignore [ i ] ) ! = = - 1 ) { return options . ignore [ i ] ; } } return null ; } 
function is Valid Dir ( filepath ) { if ( grunt . file . is Dir ( filepath ) ) { return grunt . file . exists ( path . resolve ( filepath , 'package .json ' ) ) ; } return false ; } 
function bindify ( fn , this Arg , args ) { return fn . bind . apply ( fn , [ this Arg ] . concat ( args ) ) } 
function define Get Stage Value ( parts ) { let body ; switch ( parts . length ) { case 0 : body = "return this .state ; " ; break ; default : const last Index = parts . length - 1 ; body = "var tmp 0 = this .state ; " ; for ( let i = 0 ; i < last Index ; + + i ) { body + = ` $ { i } $ { i + 1 } $ { i } $ { parts [ i ] } ` ; } body + = ` $ { last Index } $ { last Index } $ { parts [ last Index ] } ` ; break ; } return Function ( body ) ; } 
function define Set Stage Value ( parts ) { let body = ` ` ; switch ( parts . length ) { case 0 : body + = " \nthis .set State (value , cb 2 ) ; " ; break ; case 1 : body + = ` \n $ { parts [ 0 ] } ` ; break ; default : const last Index = parts . length - 1 ; body + = ` \n ` ; for ( let i = 0 ; i < last Index ; + + i ) { body + = ` $ { i + 1 } $ { i } $ { parts [ i ] } $ { i + 1 } $ { i + 1 } $ { i } $ { parts [ i ] } ` ; } body + = ` $ { last Index } $ { parts [ last Index ] } ` ; break ; } return Function ( "value " , "cb " , body ) ; } 
function handle Send Action ( event ) { if ( event . default Prevented ) { return ; } if ( typeof this . filter Action = = = "function " & & ! this . filter Action ( event ) ) { return ; } event . stop Propagation ( ) ; event . apply To ( this ) ; } 
function Mongootils ( ) { if ( arguments [ 0 ] & & arguments [ 0 ] . constructor & & arguments [ 0 ] . constructor . name = = = 'Native Connection ' ) { this . connection = arguments [ 0 ] ; this . uri = this . get Connection URI ( ) ; this . options = this . connection . options ; } else { this . uri = arguments [ 0 ] ; this . options = arguments [ 1 ] ; } } 
function partial ( mu , sigma , rand ) { var random ; var s _ad Zig X = new Array ( ZIGNOR _C + 1 ) ; var s _ad Zig R = new Array ( ZIGNOR _C ) ; var i ; var f ; if ( rand ) { random = rand ; } else { random = Math . random ; } f = exp ( - 0 . 5 * ZIGNOR _R * ZIGNOR _R ) ; s _ad Zig X [ 0 ] = ZIGNOR _V / f ; s _ad Zig X [ 1 ] = ZIGNOR _R ; s _ad Zig X [ ZIGNOR _C ] = 0 ; for ( i = 2 ; i < ZIGNOR _C ; i + + ) { s _ad Zig X [ i ] = sqrt ( - 2 * log ( ZIGNOR _V / s _ad Zig X [ i - 1 ] + f ) ) ; f = exp ( - 0 . 5 * s _ad Zig X [ i ] * s _ad Zig X [ i ] ) ; } for ( i = 0 ; i < ZIGNOR _C ; i + + ) { s _ad Zig R [ i ] = s _ad Zig X [ i + 1 ] / s _ad Zig X [ i ] ; } return function draw ( ) { var x , u , f 0 , f 1 ; for ( ; ; ) { u = 2 * random ( ) - 1 ; i = TWO _P _ 3 2 * random ( ) & 0x 7F ; if ( abs ( u ) < s _ad Zig R [ i ] ) { return mu + sigma * u * s _ad Zig X [ i ] ; } if ( i = = = 0 ) { return mu + sigma * d Ran Normal Tail ( ZIGNOR _R , u < 0 , rand ) ; } x = u * s _ad Zig X [ i ] ; f 0 = exp ( - 0 . 5 * ( s _ad Zig X [ i ] * s _ad Zig X [ i ] - x * x ) ) ; f 1 = exp ( - 0 . 5 * ( s _ad Zig X [ i + 1 ] * s _ad Zig X [ i + 1 ] - x * x ) ) ; if ( f 1 + random ( ) * ( f 0 - f 1 ) < 1 . 0 ) { return mu + sigma * x ; } } } ; 
function render Input Prompt ( ) { process . stdout . write ( prefix ) ; process . stdout . write ( text To Render . join ( ' ' ) ) ; } 
function calculate Field Color ( selected Color , non Selected Color , focused Color , index , out ) { if ( selected . index Of ( index ) ! = = - 1 & & focused = = index ) return chalk . bold . rgb ( selected Color . r , selected Color . g , selected Color . b ) ( out ) ; if ( selected . index Of ( index ) ! = = - 1 ) 
function randn ( length ) { var urand , vrand , vec = [ ] , num Values = length | | 1 ; for ( var i = 0 ; i < num Values ; i + + ) { urand = Math . random ( ) ; vrand = Math . random ( ) ; vec . push ( Math . sqrt ( - 2 * Math . log ( urand ) ) * Math . cos ( 2 * Math . PI * vrand ) ) ; } if ( num Values = = = 1 ) { return vec [ 0 ] ; } return vec ; } 
function render ( errors ) { if ( ! errors ) { return ' ' ; } ; return errors . map ( function ( error ) { return error . line + ' : ' + error . column + ' ' + ' - ' + error . message + ' ( ' + error . rule Id + ' ) ' ; } ) . join ( ' \n ' ) ; } 
function ( url ) { let request = parse Request ( url ) ; let resource = get Requested Resource ( request ) ; return resource . get ( request ) . then ( return Get Response ) ; function return Get Response ( result ) { 
function ( url , data ) { let request = parse Request ( url , data ) ; let resource = get Requested Resource ( request ) ; return resource . put ( request ) . then ( return Response ) ; function return Response ( result ) { 
function recurse ( dims , d , draw ) { var out = [ ] ; var len ; var i ; len = dims [ d ] ; d + = 1 ; if ( d < dims . length ) { for ( i = 0 ; i < len ; i + + ) { out . push ( recurse ( dims , d , draw ) ) ; } } else { for ( i = 0 ; i < len ; i + + ) { out . push ( draw ( ) ) ; } } return out ; } 
function map Prune ( input , schema ) { var result = { } ; _ . for Own ( schema , function ( value , key ) { if ( _ . is Plain Object ( value ) ) { 
function map Run ( input , schema , discrepencies ) { var result = { } ; _ . for Own ( schema , function ( value , key ) { if ( _ . is Plain Object ( value ) ) { 
function transform Value ( prop Spec , input Val , fallback Value ) { var value = input Val ; if ( typeof prop Spec . coerce = = = 'function ' ) value = prop Spec . coerce ( value ) ; 
function ( type Coerce ) { return function ( spec Obj ) { spec Obj = spec Obj | | { } ; var inner Coerce = spec Obj . coerce ; if ( typeof inner Coerce = = = 'function ' ) { spec Obj . coerce = function ( x ) { return inner Coerce ( type Coerce ( x ) ) ; } ; } else { spec Obj . coerce = type Coerce ; } return new Prop Placeholder ( spec Obj ) ; } ; } 
function ( values , yaml Loader ) { var palettes = lui Theme ( 'core .references .palettes ' ) , palette = values . split ( ' | ' ) [ 0 ] , palette Name = palette . split ( ' . ' ) [ 0 ] , palette Prop = ( palette . split ( ' . ' ) [ 1 ] ) ? palette . split ( ' . ' ) [ 1 ] : null , manipulation = ( values . split ( ' | ' ) [ 1 ] ) ? values . split ( ' | ' ) [ 1 ] : null , result = palettes . colors [ palette Name ] ; if ( palette Prop & & result [ palette Prop ] ) result = result [ palette Prop ] ; if ( manipulation ) { result = palettes . manipulations [ manipulation ] [ 0 ] + ' ( ' + result + ' , ' + palettes . manipulations [ manipulation ] [ 1 ] + ' ) ' ; } return result ; } 
function create Yaml Schema ( custom Types ) { var yaml Types = [ ] ; _ . each ( custom Types , function ( resolver , tag And Kind String ) { var tag And Kind = tag And Kind String . split ( / \s + / ) , yaml Type = new yaml . Type ( tag And Kind [ 0 ] , { kind : tag And Kind [ 1 ] , construct : function ( data ) { var result = resolver . call ( this , data , load Yaml File ) ; if ( _ . is Undefined ( result ) | | _ . is Function ( result ) ) { return null ; } else { return result ; } } } ) ; yaml Types . push ( yaml Type ) ; } ) ; return yaml . Schema . create ( yaml Types ) ; } 
function load Yaml File ( filepath ) { try { return yaml . safe Load ( fs . read File Sync ( filepath ) , { schema : yaml Schema , filename : filepath } ) ; } catch ( err ) { return null ; } } 
function load Theme ( props ) { var rel Path = ' / ' + props . join ( ' / ' ) + ' .yml ' , defaults Path = path . resolve ( base + ' /scss /themes /default ' + rel Path ) , custom Path = ( custom ) ? custom + rel Path : null , default Vars = { } , custom Vars = null , result = { } ; 
function lui Theme ( props ) { var props S = ( _ . is Array ( props ) ) ? props . join ( ' . ' ) : props , props A = ( _ . is String ( props ) ) ? props . split ( ' . ' ) : props , object Vars , object Path = [ ] ; object Vars = _ . result ( theme , props S ) ; 
function write ( destination , data , callback ) { 
function init ( _options ) { 
function redact ( _options , callback ) { var imports = [ ] , 
function ( _options , callback ) { var options = init ( _options ) ; return write ( options . dest , redact ( options ) , callback ) ; } 
function ( map ) { return ' ( ' + Object . keys ( map ) . map ( function ( key ) { return key + ' : ' + parse Value ( map [ key ] ) ; } ) . join ( ' , ' ) + ' ) ' ; } 
function object To Sass ( object ) { return Object . keys ( object ) . map ( function ( key ) { return ' $ ' + key + ' : ' + parse Value ( object [ key ] ) + ' ; ' ; } ) . join ( ' \n ' ) ; } 
function parse Value ( value ) { if ( _ . is Array ( value ) ) return converters . list ( value ) ; else if ( _ . is Plain Object ( value ) ) return converters . map ( value ) ; else return value ; } 
function format Data ( data ) { var result = ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + ' / / = = = = = = = = = = = = = = = CORE = = = = = = = = = = = = = = \n ' + ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + ' @import "core /core " ; \n \n ' + ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + ' / / = = = = = = = = = THEME VARIABLES = = = = = = = = = \n ' + ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + object To Sass ( { theme : data . theme } ) + ' \n \n ' + ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + ' / / = = = = = = = = = = = = = OBJECTS = = = = = = = = = = = = = \n ' + ' / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n ' + ' @import " ' + data . imports . join ( ' " , \n " ' ) + ' " ; ' ; return result ; } 
function random ( dims , options ) { var opts = { } ; var is Array ; var ndims ; var err ; var len ; var mu ; var sigma ; var rand ; var dt ; if ( arguments . length > 0 ) { is Array = is Positive Integer Array ( dims ) ; if ( ! is Array & & ! is Positive Integer ( dims ) ) { throw new Type Error ( 'invalid input argument . Dimensions argument must be either a positive integer or a positive integer array . Value : ` ' + dims + ' ` . ' ) ; } } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( opts . seed ) { rand = lcg ( opts . seed ) ; } else { rand = RAND ; } dt = opts . dtype | | 'generic ' ; mu = typeof opts . mu ! = = 'undefined ' ? opts . mu : 0 ; sigma = typeof opts . sigma ! = = 'undefined ' ? opts . sigma : 1 ; if ( arguments . length = = = 0 ) { return number ( mu , sigma , rand ) ; } if ( is Array ) { ndims = dims . length ; if ( ndims < 2 ) { len = dims [ 0 ] ; } } else { ndims = 1 ; len = dims ; } 
function dom Safe Random Guid ( ) { var _arguments = arguments ; var _again = true ; _function : while ( _again ) { number Of Blocks = output = num = undefined ; var s 4 = function s 4 ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 6 5 5 3 6 ) . to String ( 1 6 ) . substring ( 1 ) ; } ; _again = false ; var number Of Blocks = _arguments [ 0 ] = = = undefined ? 4 : _arguments [ 0 ] ; var output = ' ' ; var num = number Of Blocks ; while ( num > 0 ) { output + = s 4 ( ) ; if ( num > 1 ) output + = ' - ' ; num - - ; } if ( null = = = document . get Element By Id ( output ) ) { return output ; } else { _arguments = [ number Of Blocks ] ; _again = true ; continue _function ; } } } 
function ( options ) { options = Safe . object ( options ) ; this . name = Safe . string ( options . name , " ? " ) ; this . fn = Safe . function ( options . fn , function ( ) { } ) ; this . args = Safe . array ( options . args ) ; } 
function I ( obj ) { function is Object ( v ) { return { } . to String . call ( v ) = = = ' [object Object ] ' ; } function is Array ( v ) { return { } . to String . call ( v ) = = = ' [object Array ] ' ; } function is Func ( v ) { return { } . to String . call ( v ) = = = ' [object Function ] ' ; } function assert A ( v , msg ) { if ( ! is Array ( v ) ) throw new Error ( msg ) ; } function assert AO ( v , msg ) { if ( ! is Array ( v ) & & ! is Object ( v ) ) throw new Error ( msg ) ; } function _get ( o , p ) { var key = is Func ( p [ 0 ] ) ? o . find Index ( p [ 0 ] ) : p [ 0 ] ; return p . length ? _get ( o [ key ] , p . slice ( 1 ) ) : o ; } function _set ( o , p , v ) { var key = is Func ( p [ 0 ] ) ? o . find Index ( p [ 0 ] ) : p [ 0 ] ; 
function validate ( opts , options ) { if ( ! is Object ( options ) ) { return new Type Error ( 'invalid input argument . Options argument must be an object . Value : ` ' + options + ' ` . ' ) ; } if ( options . has Own Property ( 'mu ' ) ) { opts . mu = options . mu ; if ( ! is Number ( opts . mu ) ) { return new Type Error ( 'invalid option . `mu ` parameter must be a number primitive . Option : ` ' + opts . mu + ' ` . ' ) ; } } if ( options . has Own Property ( 'sigma ' ) ) { opts . sigma = options . sigma ; if ( ! is Non Negative ( opts . sigma ) ) { return new Type Error ( 'invalid option . `sigma ` parameter must be a non -negative number . Option : ` ' + opts . sigma + ' ` . ' ) ; } } if ( options . has Own Property ( 'dtype ' ) ) { opts . dtype = options . dtype ; if ( ! is String ( opts . dtype ) ) { return new Type Error ( 'invalid option . Data type option must be a string primitive . Option : ` ' + opts . dtype + ' ` . ' ) ; } } if ( options . has Own Property ( 'seed ' ) ) { opts . seed = options . seed ; if ( ! is Positive Integer ( opts . seed ) ) { return new Type Error ( 'invalid option . Seed option must be a positive integer . Option : ` ' + opts . seed + ' ` . ' ) ; } } return null ; } 
function object Property ( obj , indent Length = 1 , in Array = 0 ) { if ( Object . keys ( obj ) . length = = = 0 ) { return ' { } ' ; } let str = ' \n ' ; const object Prefix = get Prefix ( indent Length , indent Chars ) ; Object . keys ( obj ) . for Each ( ( name ) = > { const value = obj [ name ] ; const type = type Of ( value ) ; const in Array Prefix = get Prefix ( in Array , ' ' ) ; const after Props Indent = NO _INDENT _TYPES . includes ( type ) ? ' ' : ' ' ; const value String = check Circular ( value ) ? ' [Circular ] ' : typified String ( type , value , indent Length + 1 , in Array ) ; str + = ` $ { in Array Prefix } $ { object Prefix } $ { name } $ { after Props Indent } $ { value String } \n ` ; } ) ; return str . substring ( 0 , str . length - 1 ) ; } 
function array Property ( values , indent Length = 1 , in Array = 0 ) { if ( values . length = = = 0 ) { return ' [ ] ' ; } let str = ' \n ' ; const array Prefix = get Prefix ( indent Length , indent Chars ) ; values . for Each ( ( value ) = > { const type = type Of ( value ) ; const in Array Prefix = get Prefix ( in Array , ' ' ) ; const value String = check Circular ( value ) ? ' [Circular ] ' : typified String ( type , value , indent Length , in Array + 1 ) . to String ( ) . trim Left ( ) ; str + = ` $ { in Array Prefix } $ { array Prefix } $ { value String } \n ` ; } ) ; return str . substring ( 0 , str . length - 1 ) ; } 
function in Command ( cmd ) { let npm _config _argv , V ; try { npm _config _argv = JSON . parse ( process . env [ 'npm _config _argv ' ] ) ; } catch ( e ) { return false ; } if ( typeof npm _config _argv ! = = 'object ' ) { process . exit ( 1 ) ; } if ( ! npm _config _argv . cooked ) { process . exit ( 1 ) ; } if ( ! npm _config _argv . cooked instanceof Array ) { process . exit ( 1 ) ; } while ( ( V = npm _config _argv . cooked . shift ( ) ) ! = = undefined ) { if ( cmd . test ( V ) ) { return true ; } } return false ; } 
function mocha Task ( reporter ) { return function ( ) { return gulp . src ( paths . test ) . pipe ( $ . mocha ( { reporter : reporter | | "spec " } ) ) ; } ; } 
function random ( dims , mu , sigma , rand ) { var draw = partial ( mu , sigma , rand ) ; return recurse ( dims , 0 , draw ) ; } 
function random ( len , dt , mu , sigma , rand ) { var ctor ; var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; ctor = ctors ( dt ) ; if ( ctor = = = null ) { throw new Error ( 'invalid value . Data type does not have a corresponding array constructor . Value : ` ' + dt + ' ` . ' ) ; } out = new ctor ( len ) ; for ( i = 0 ; i < len ; i + + ) { out [ i ] = draw ( ) ; } return out ; } 
function parse Json ( input Text ) { 
function get Range Data ( quantifier ) { let range Type = date Range . DAY ; let start Range = 'day ' ; if ( / seconds ? / i . test ( quantifier ) ) { range Type = date Range . SEC ; start Range = 'second ' ; } else if ( / minutes ? / i . test ( quantifier ) ) { range Type = date Range . MIN ; start Range = 'minute ' ; } else if ( / hours ? / i . test ( quantifier ) ) { range Type = date Range . HOUR ; start Range = 'hour ' ; } else if ( new Reg Exp ( ` $ { days . join ( 's ? | ' ) } ` , 'i ' ) . test ( quantifier ) ) { range Type = date Range . DAY * 7 ; start Range = quantifier ; } return { range Type : range Type , start Range : start Range } ; } 
function Resource Client ( opts ) { opts = opts | | { } this . name = opts . name this . token = opts . token this . base Url = opts . base Url } 
function RESTResponse ( url , method , body ) { this . request = { url : url , method : method } ; this . body = body | | " " ; this . status = " 2 0 0 " ; } 
function ( map , receive ) { var entries = map Entries . call ( map ) ; var next ; do { next = entries . next ( ) ; } while ( ! next . done & & receive ( next . value ) ) ; } 
function d Ran Normal Tail ( d Min , i Negative , rand ) { var x , y ; do { x = ln ( rand ( ) ) / d Min ; y = ln ( rand ( ) ) ; } while ( - 2 * y < x * x ) ; return i Negative ? x - d Min : d Min - x ; } 
function reqo ( func , required Keys , options Index = 0 , context = undefined ) { return function ( . . . args ) { const options = args [ options Index ] ; if ( ! is Plain Object ( options ) ) { throw new Type Error ( 'options must be a plain object literal ' ) ; } 
function ( component ) { var id = component . get Id ( ) ; 
function ( component , default Type ) { if ( component . is Component ) { return component ; } else if ( Ext . is String ( component ) ) { return Ext . create By Alias ( 'widget . ' + component ) ; } else { var type = component . xtype | | default Type ; return Ext . create By Alias ( 'widget . ' + type , component ) ; } } 
function rns ( ) { let jargv = _ . $ ( 'env .jargv ' ) let key = _ . get ( jargv , ' _ [ 0 ] ' ) let prop = key ? _ . get ( snapptop , key ) : null if ( ! _ . is Function ( prop ) ) return _ . log ( ` \n $ { key | | 'NO KEY ' } \n ` ) _ . log ( ` \n $ { key } \n ` ) _ . log ( jargv ) _ . log ( ) jargv = _ . omit ( jargv , [ ' _ ' ] ) var ret = _ . attempt ( prop , jargv , ( err , result ) = > { if ( err ) return _ . log ( err ) _ . log ( result ) } ) if ( _ . is Error ( ret ) ) _ . log ( ret ) return ret } 
function ( element ) { var cache = this . cache , instance , dom , id ; if ( ! element ) { return null ; } 
function ( node ) { var result = ' ' , i , n , attr , child ; if ( node . node Type = = = document . TEXT _NODE ) { return node . node Value ; } result + = ' < ' + node . node Name ; if ( node . attributes . length ) { for ( i = 0 , n = node . attributes . length ; i < n ; i + + ) { attr = node . attributes [ i ] ; result + = ' ' + attr . name + ' = " ' + attr . value + ' " ' ; } } result + = ' > ' ; if ( node . child Nodes & & node . child Nodes . length ) { for ( i = 0 , n = node . child Nodes . length ; i < n ; i + + ) { child = node . child Nodes [ i ] ; result + = this . serialize Node ( child ) ; } } result + = ' < / ' + node . node Name + ' > ' ; return result ; } 
function ( dom ) { if ( typeof dom = = 'string ' ) { dom = document . get Element By Id ( dom ) ; } if ( ! dom ) { throw new Error ( "Invalid dom Node reference or an id of an existing dom Node : " + dom ) ; } this . dom = dom ; this . get Unique Id ( ) ; } 
function ( attributes , use Set ) { var dom = this . dom , attribute , value ; for ( attribute in attributes ) { if ( attributes . has Own Property ( attribute ) ) { value = attributes [ attribute ] ; if ( attribute = = 'style ' ) { this . apply Styles ( value ) ; } else if ( attribute = = 'cls ' ) { dom . class Name = value ; } else if ( use Set ! = = false ) { if ( value = = = undefined ) { dom . remove Attribute ( attribute ) ; } else { dom . set Attribute ( attribute , value ) ; } } else { dom [ attribute ] = value ; } } } return this ; } 
function ( name , namespace ) { var dom = this . dom ; return dom . get Attribute NS ( namespace , name ) | | dom . get Attribute ( namespace + " : " + name ) | | dom . get Attribute ( name ) | | dom [ name ] ; } 
function ( ) { this . is Destroyed = true ; var cache = Ext . Element . cache , dom = this . dom ; if ( dom & & dom . parent Node & & dom . tag Name ! = 'BODY ' ) { dom . parent Node . remove Child ( dom ) ; } delete cache [ this . id ] ; delete this . dom ; } 
function ( element , named ) { var fly = null , flyweights = Element . _flyweights , cached Element ; named = named | | ' _global ' ; element = Ext . get Dom ( element ) ; if ( element ) { fly = flyweights [ named ] | | ( flyweights [ named ] = new Element . Fly ( ) ) ; fly . dom = element ; fly . is Synchronized = false ; cached Element = Ext . cache [ element . id ] ; if ( cached Element & & cached Element . is Element ) { cached Element . is Synchronized = false ; } } return fly ; } 
function Router ( window , url State Map , front Controller ) { Event Emitter . call ( this ) ; this . window = window ; this . url State Map = url State Map ; this . front Controller = front Controller ; this . current State List = null ; this . _pending Transition Promise = null ; this . _pending Replace = null ; this . _initial History State = null ; this . _queue = { has Entry : false , state List : null , from History : false , upgrade : false , push : false , promise : null , resolve : null , reject : null } ; if ( ! window | | ! url State Map | | ! front Controller ) { throw Error ( 'Missing argument ' ) ; } if ( typeof this . url State Map . to URL ! = = 'function ' | | typeof this . url State Map . from URL ! = = 'function ' ) { throw Error ( 'Argument `url State Map ` must implement to URL (states ) and from URL (url ) ' ) ; } if ( ! Router . is Supported ( this . window ) ) { throw Error ( 'Argument `window ` does not support the history API ' ) ; } if ( this . front Controller . is Stateful Controller 1 ! = = true ) { throw Error ( 'Argument `front Controller ` is not a stateful -controller ' ) ; } this . _onpopstate = this . _onpopstate . bind ( this ) ; } 
function ( sorters , direction , where , do Sort ) { var me = this , sorter , sorter Fn , new Sorters ; if ( Ext . is Array ( sorters ) ) { do Sort = where ; where = direction ; new Sorters = sorters ; } else if ( Ext . is Object ( sorters ) ) { do Sort = where ; where = direction ; new Sorters = [ sorters ] ; } else if ( Ext . is String ( sorters ) ) { sorter = me . sorters . get ( sorters ) ; if ( ! sorter ) { sorter = { property : sorters , direction : direction } ; new Sorters = [ sorter ] ; } else if ( direction = = = undefined ) { sorter . toggle ( ) ; } else { sorter . set Direction ( direction ) ; } } if ( new Sorters & & new Sorters . length ) { new Sorters = me . decode Sorters ( new Sorters ) ; if ( Ext . is String ( where ) ) { if ( where = = = 'prepend ' ) { sorters = me . sorters . clone ( ) . items ; me . sorters . clear ( ) ; me . sorters . add All ( new Sorters ) ; me . sorters . add All ( sorters ) ; } else { me . sorters . add All ( new Sorters ) ; } } else { me . sorters . clear ( ) ; me . sorters . add All ( new Sorters ) ; } if ( do Sort ! = = false ) { me . on Before Sort ( new Sorters ) ; } } if ( do Sort ! = = false ) { sorters = me . sorters . items ; if ( sorters . length ) { 
function export Code ( projname , root , plugins , objname , callback , option ) { if ( option = = undefined ) { option = { isclient : false , mainobj : objname , projname : projname } ; } else { if ( ! option . has Own Property ( 'isclient ' ) ) { option . isclient = false ; } option . mainobj = objname ; option . projname = projname ; } var lstexport = [ ] ; var obj = base . get Global Obj ( objname , root ) ; if ( obj ! = undefined ) { lstexport = add Export Obj ( obj , root , lstexport , option ) ; } proc Static Table ( objname , root , option ) ; if ( plugins ! = undefined ) { if ( ! fs . exists Sync ( projname ) ) { fs . mkdir Sync ( projname ) ; } var curparams = { projname _up : projname . to Upper Case ( ) , projname : projname } ; 
function ( rules ) { this . _instantiated Date = new Date ( ) ; this . _instance Count = 0 ; this . _property Count = 0 ; this . _collated Instances = null ; this . _rules = ( rules & & this . _check Rules ( rules ) ) | | [ ] ; this . init Eventual Schema ( ) ; } 
function ( record , reader , association Data ) { var inverse = this . get Inverse Association ( ) , new Record = reader . read ( [ association Data ] ) . get Records ( ) [ 0 ] ; record [ this . get Setter Name ( ) ] . call ( record , new Record ) ; 
function ( sorters , default Direction ) { var current Sorters = this . get Sorters ( ) ; return this . insert Sorters ( current Sorters ? current Sorters . length : 0 , sorters , default Direction ) ; } 
function ( index , sorters , default Direction ) { 
function ( sorters ) { 
function ( ) { var sorters = this . get Sorters ( ) . items ; this . sort Fn = function ( r 1 , r 2 ) { var ln = sorters . length , result , i ; 
function ( items , item , sort Fn , contains Item ) { var start = 0 , end = items . length - 1 , sorter Fn = sort Fn | | this . get Sort Fn ( ) , middle , comparison ; while ( start < end | | start = = = end & & ! contains Item ) { middle = ( start + end ) > > 1 ; var middle Item = items [ middle ] ; if ( middle Item = = = item ) { start = middle ; break ; } comparison = sorter Fn ( item , middle Item ) ; if ( comparison > 0 | | ( ! contains Item & & comparison = = = 0 ) ) { start = middle + 1 ; } else if ( comparison < 0 ) { end = middle - 1 ; } else if ( contains Item & & ( start ! = = end ) ) { start = middle + 1 ; } } return start ; } 
function Reliability Metric ( ) { if ( ! ( this instanceof Reliability Metric ) ) { return new Reliability Metric ( ) } Metric . call ( this ) this . key = 'reliability ' this . default = [ 0 , 0 ] 
function cmin ( arr ) { if ( ! Array . is Array ( arr ) ) { throw new Type Error ( 'cmin ( ) : :invalid input argument . Must provide an array . ' ) ; } var len = arr . length , v = new Array ( len ) , min ; min = arr [ 0 ] ; v [ 0 ] = min ; for ( var i = 1 ; i < len ; i + + ) { if ( arr [ i ] < min ) { min = arr [ i ] ; } v [ i ] = min ; } return v ; } 
function export Table ( obj , callback , root ) { if ( obj . type = = 'struct ' ) { var isautoinc = false ; var autoincval = 1 ; var str = " - - " + obj . comment + ' \r \n ' ; str + = "CREATE TABLE IF NOT EXISTS ` " + get Table Name ( obj . name ) + " ` ( " + ' \r \n ' ; var lastcomment = ' ' ; var lstmember = [ ] ; base . for Each Struct ( obj . name , obj , root , function ( structname , memberobj , root ) { lstmember . push ( memberobj ) ; } ) ; var validindex = [ ] ; for ( var i = 0 ; i < lstmember . length ; + + i ) { var membername = lstmember [ i ] . name . name ; 
function export Sql ( obj , callback ) { var str = ' ' ; if ( Array . is Array ( obj ) ) { for ( var i = 0 ; i < obj . length ; + + i ) { if ( obj [ i ] . type = = 'struct ' & & base . is Export Type String ( obj [ i ] . name ) ) { var cs = export Table ( obj [ i ] , callback , obj ) ; if ( cs = = undefined ) { return ; } str + = cs + ' \r \n ' ; } } return str ; } return ; } 
function ( attribute , new Value ) { var input = this . input ; if ( ! Ext . is Empty ( new Value , true ) ) { input . dom . set Attribute ( attribute , new Value ) ; } else { input . dom . remove Attribute ( attribute ) ; } } 
function ( new Cls , old Cls ) { this . input . add Cls ( Ext . base CSSPrefix + 'input -el ' ) ; this . input . replace Cls ( old Cls , new Cls ) ; } 
function ( new Type , old Type ) { var prefix = Ext . base CSSPrefix + 'input - ' ; this . input . replace Cls ( prefix + old Type , prefix + new Type ) ; this . update Field Attribute ( 'type ' , new Type ) ; } 
function ( ) { var el = this . input , checked ; if ( el ) { checked = el . dom . checked ; this . _checked = checked ; } return checked ; } 
function ( ) { var me = this , el = me . input ; if ( el & & el . dom . focus ) { el . dom . focus ( ) ; } return me ; } 
function ( ) { var me = this , el = this . input ; if ( el & & el . dom . blur ) { el . dom . blur ( ) ; } return me ; } 
function ( ) { var me = this , el = me . input ; if ( el & & el . dom . set Selection Range ) { el . dom . set Selection Range ( 0 , 9 9 9 9 ) ; } return me ; } 
function xf ( format ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; return format . replace ( / \ { ( \d + ) \ } / g , function ( m , i ) { return args [ i ] ; } ) ; } 
function ( date , format ) { if ( util Date . format Functions [ format ] = = null ) { util Date . create Format ( format ) ; } var result = util Date . format Functions [ format ] . call ( date ) ; return result + ' ' ; } 
function ( date , interval , value ) { var d = Ext . Date . clone ( date ) ; if ( ! interval | | value = = = 0 ) return d ; switch ( interval . to Lower Case ( ) ) { case Ext . Date . MILLI : d = new Date ( d . value Of ( ) + value ) ; break ; case Ext . Date . SECOND : d = new Date ( d . value Of ( ) + value * 1 0 0 0 ) ; break ; case Ext . Date . MINUTE : d = new Date ( d . value Of ( ) + value * 6 0 0 0 0 ) ; break ; case Ext . Date . HOUR : d = new Date ( d . value Of ( ) + value * 3 6 0 0 0 0 0 ) ; break ; case Ext . Date . DAY : d = new Date ( d . value Of ( ) + value * 8 6 4 0 0 0 0 0 ) ; break ; case Ext . Date . MONTH : var day = date . get Date ( ) ; if ( day > 2 8 ) { day = Math . min ( day , Ext . Date . get Last Date Of Month ( Ext . Date . add ( Ext . Date . get First Date Of Month ( date ) , 'mo ' , value ) ) . get Date ( ) ) ; } d . set Date ( day ) ; d . set Month ( date . get Month ( ) + value ) ; break ; case Ext . Date . YEAR : d . set Full Year ( date . get Full Year ( ) + value ) ; break ; } return d ; } 
function ( min , max , unit ) { var Ext Date = Ext . Date , est , diff = + max - min ; switch ( unit ) { case Ext Date . MILLI : return diff ; case Ext Date . SECOND : return Math . floor ( diff / 1 0 0 0 ) ; case Ext Date . MINUTE : return Math . floor ( diff / 6 0 0 0 0 ) ; case Ext Date . HOUR : return Math . floor ( diff / 3 6 0 0 0 0 0 ) ; case Ext Date . DAY : return Math . floor ( diff / 8 6 4 0 0 0 0 0 ) ; case 'w ' : return Math . floor ( diff / 6 0 4 8 0 0 0 0 0 ) ; case Ext Date . MONTH : est = ( max . get Full Year ( ) * 1 2 + max . get Month ( ) ) - ( min . get Full Year ( ) * 1 2 + min . get Month ( ) ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } case Ext Date . YEAR : est = max . get Full Year ( ) - min . get Full Year ( ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } } } 
function ( date , unit , step ) { var num = new Date ( + date ) ; switch ( unit . to Lower Case ( ) ) { case Ext . Date . MILLI : return num ; break ; case Ext . Date . SECOND : num . set UTCSeconds ( num . get UTCSeconds ( ) - num . get UTCSeconds ( ) % step ) ; num . set UTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MINUTE : num . set UTCMinutes ( num . get UTCMinutes ( ) - num . get UTCMinutes ( ) % step ) ; num . set UTCSeconds ( 0 ) ; num . set UTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . HOUR : num . set UTCHours ( num . get UTCHours ( ) - num . get UTCHours ( ) % step ) ; num . set UTCMinutes ( 0 ) ; num . set UTCSeconds ( 0 ) ; num . set UTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . DAY : if ( step = = 7 | | step = = 1 4 ) { num . set UTCDate ( num . get UTCDate ( ) - num . get UTCDay ( ) + 1 ) ; } num . set UTCHours ( 0 ) ; num . set UTCMinutes ( 0 ) ; num . set UTCSeconds ( 0 ) ; num . set UTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MONTH : num . set UTCMonth ( num . get UTCMonth ( ) - ( num . get UTCMonth ( ) - 1 ) % step , 1 ) ; num . set UTCHours ( 0 ) ; num . set UTCMinutes ( 0 ) ; num . set UTCSeconds ( 0 ) ; num . set UTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . YEAR : num . set UTCFull Year ( num . get UTCFull Year ( ) - num . get UTCFull Year ( ) % step , 1 , 1 ) ; num . set UTCHours ( 0 ) ; num . set UTCMinutes ( 0 ) ; num . set UTCSeconds ( 0 ) ; num . set UTCMilliseconds ( 0 ) ; return date ; break ; } } 
function ( callback ) { var filter Function = function ( doc , req ) { if ( doc . user Id = = = req . query . key ) { return true ; } else { return false ; } } ; db . add Filter ( 'profile _by _user Id ' , filter Function , function ( err ) { if ( err ) { return callback ( err ) ; } return callback ( ) ; } ) ; } 
function Contact ( options ) { if ( ! ( this instanceof Contact ) ) { return new Contact ( options ) } assert ( options instanceof Object , 'Invalid options were supplied ' ) Object . define Property ( this , 'node ID ' , { value : options . node ID | | this . _create Node ID ( ) , configurable : false , enumerable : true } ) assert ( utils . is Valid Key ( this . node ID ) , 'Invalid node ID was supplied ' ) this . seen ( ) } 
function ( new Value , old Value ) { var thumbs = this . get Thumbs ( ) , ln = new Value . length , min Value = this . get Min Value ( ) , offset = this . offset Value Ratio , i ; this . set Thumbs Count ( ln ) ; for ( i = 0 ; i < ln ; i + + ) { thumbs [ i ] . get Draggable ( ) . set Extra Constraint ( null ) . set Offset ( ( new Value [ i ] - min Value ) * offset ) ; } for ( i = 0 ; i < ln ; i + + ) { this . refresh Thumb Constraints ( thumbs [ i ] ) ; } } 
function get Options ( message Type ) { const options = Object . assign ( { } , _defaults ) ; if ( message Type in _options ) { Object . assign ( options , _options [ message Type ] ) ; } return options ; } 
function parse ( message Type , args ) { const options = get Options ( message Type ) ; if ( typeof options . interpreter = = = "function " ) { for ( const index in args ) { if ( typeof args [ index ] = = = "string " ) { continue ; } args [ index ] = options . interpreter ( args [ index ] ) ; } } if ( options . labels ) { args . unshift ( ` $ { message Type . to Upper Case ( ) } ` ) ; } if ( options . timestamp ) { switch ( typeof options . timestamp ) { case "boolean " : args . unshift ( ` $ { new Date ( ) . to Locale String ( ) } ` ) ; break ; case "string " : args . unshift ( ` $ { moment ( ) . format ( options . timestamp ) } ` ) ; break ; default : throw new Error ( ` $ { typeof options . timestamp } ` ) ; } } return args . join ( " " ) ; } 
function stdout ( message Type ) { return ( . . . args ) = > { const options = get Options ( message Type ) ; let message = parse ( message Type , args ) ; if ( message Type = = = "trace " ) { message + = ` \n $ { get Trace ( ) } ` ; } if ( ! options . file Only ) { _console . log ( message ) ; } if ( typeof options . file Path = = = "string " & & options . file Path . length > 0 ) { fs . append File Sync ( options . file Path , ` $ { message } \n ` ) ; } } ; } 
function assign Options ( defaults , user Defined ) { for ( const option Key in user Defined ) { if ( defaults . has Own Property ( option Key ) ) { defaults [ option Key ] = user Defined [ option Key ] ; } else { throw new Error ( ` $ { option Key } ` ) ; } } return defaults ; } 
function G ( cmd , coords ) { var parts = [ 'G ' + cmd , ] ; for ( var coord in coords ) { if ( coords . has Own Property ( coord ) ) { var lcoord = coord . to Lower Case ( ) ; if ( lcoord = = = 'x ' ) { coords [ coord ] + = offset X ; } else if ( lcoord = = 'y ' ) { coords [ coord ] + = offset Y ; } parts . push ( coord . to Upper Case ( ) + ( ( negate ) ? - coords [ coord ] : coords [ coord ] ) ) ; } } if ( ! coords . f & & ! coords . F ) { parts . push ( 'F ' + feed Rate ) ; } gcode . push ( parts . join ( ' ' ) ) ; } 
function exponent ( x ) { 
function ( ) { 
function ( ) { 
function repeat Zero ( qty ) { var result = " " ; 
function pad Zero ( str , len , is Right ) { if ( str = = null ) { str = " " ; } str = " " + str ; return ( is Right ? str : " " ) + repeat Zero ( len - str . length ) + ( is Right ? " " : str ) ; } 
function find ( array , callback ) { var index = 0 , max = array . length , match ; if ( typeof callback ! = = "function " ) { match = callback ; callback = function ( item ) { return item = = = match ; } ; } while ( index < max ) { if ( callback ( array [ index ] ) ) { return array [ index ] ; } index + = 1 ; } } 
function each ( array , callback ) { var index = 0 , max = array . length ; if ( ! array | | ! max ) { return ; } while ( index < max ) { if ( callback ( array [ index ] , index ) = = = false ) { return ; } index + = 1 ; } } 
function map ( array , callback ) { var index = 0 , max = array . length , ret = [ ] ; if ( ! array | | ! max ) { return ret ; } while ( index < max ) { ret [ index ] = callback ( array [ index ] , index ) ; index + = 1 ; } return ret ; } 
function compact ( array ) { var ret = [ ] ; each ( array , function ( item ) { if ( item ) { ret . push ( item ) ; } } ) ; return ret ; } 
function unique ( array ) { var ret = [ ] ; each ( array , function ( _a ) { if ( ! find ( ret , _a ) ) { ret . push ( _a ) ; } } ) ; return ret ; } 
function intersection ( a , b ) { var ret = [ ] ; each ( a , function ( _a ) { each ( b , function ( _b ) { if ( _a = = = _b ) { ret . push ( _a ) ; } } ) ; } ) ; return unique ( ret ) ; } 
function rest ( array , callback ) { var ret = [ ] ; each ( array , function ( item , index ) { if ( ! callback ( item ) ) { ret = array . slice ( index ) ; return false ; } } ) ; return ret ; } 
function initial ( array , callback ) { var reversed = array . slice ( ) . reverse ( ) ; return rest ( reversed , callback ) . reverse ( ) ; } 
function ( ) { var types = this . types , dur = this . duration , last Type = find Last ( types , function ( type ) { return dur . _data [ type ] ; } ) ; 
function ( partial Path ) { if ( options . verbose ) { grunt . log . writeln ( ' - using partial path : %s ' , partial Path ) ; } var all Partials = { } ; 
function ( pages Path , all Partials ) { if ( options . verbose ) { grunt . log . writeln ( ' - using pages path : %s ' , pages Path ) ; } var all Pages = { } ; 
function dd Reporter ( runner ) { Base . call ( this , runner ) ; var self = this , stats = this . stats , indents = 0 , n = 0 ; function indent ( ) { return Array ( indents ) . join ( ' ' ) } runner . on ( 'start ' , function ( ) { console . log ( ) ; } ) ; runner . on ( 'suite ' , function ( suite ) { + + indents ; console . log ( color ( 'suite ' , ' %s %s ' ) , indent ( ) , suite . title ) ; } ) ; runner . on ( 'suite end ' , function ( suite ) { - - indents ; if ( 1 = = indents ) console . log ( ) ; } ) ; runner . on ( 'pending ' , function ( test ) { var fmt = indent ( ) + color ( 'pending ' , ' - %s ' ) ; console . log ( fmt , test . title ) ; } ) ; runner . on ( 'pass ' , function ( test ) { if ( test . is Action ) { var fmt = indent ( ) + color ( 'pending ' , '  %s ' ) ; cursor . CR ( ) ; self . stats . passes - - ; console . log ( fmt , test . title ) ; } else if ( 'fast ' = = test . speed ) { var fmt = indent ( ) + color ( 'checkmark ' , ' ' + Base . symbols . ok ) + color ( 'pass ' , ' %s ' ) ; cursor . CR ( ) ; console . log ( fmt , test . title ) ; } else { var fmt = indent ( ) + color ( 'checkmark ' , ' ' + Base . symbols . ok ) + color ( 'pass ' , ' %s ' ) + color ( test . speed , ' ( %dms ) ' ) ; cursor . CR ( ) ; console . log ( fmt , test . title , test . duration ) ; } } ) ; runner . on ( 'fail ' , function ( test , err ) { cursor . CR ( ) ; console . log ( indent ( ) + color ( 'fail ' , ' %d ) %s ' ) , + + n , test . title ) ; } ) ; runner . on ( 'end ' , self . epilogue . bind ( self ) ) ; } 
function ( result ) { 
function ( cb , param ) { return function ( ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; if ( typeof param ! = = 'undefined ' ) { args . unshift ( param ) ; } else if ( arguments . length = = = 1 ) { args . unshift ( arguments [ 0 ] ) ; } args . unshift ( null ) ; cb . apply ( null , args ) ; } ; } 
function ( callback ) { if ( tunnel ) { return callback ( null ) ; } grunt . log . debug ( 'checking if selenium is running ' ) ; var options = { host : capabilities . host | | 'localhost ' , port : capabilities . port | | 4 4 4 4 , path : ' /wd /hub /status ' } ; http . get ( options , function ( ) { grunt . log . debug ( 'selenium is running ' ) ; is Selenium Server Running = true ; callback ( null ) ; } ) . on ( 'error ' , function ( ) { grunt . log . debug ( 'selenium is not running ' ) ; callback ( null ) ; } ) ; } 
function ( callback ) { if ( tunnel | | is Selenium Server Running ) { return callback ( null ) ; } grunt . log . debug ( 'installing driver if needed ' ) ; selenium . install ( options . selenium Install Options , function ( err ) { if ( err ) { return callback ( err ) ; } grunt . log . debug ( 'driver installed ' ) ; callback ( null ) ; } ) ; } 
function ( callback ) { if ( tunnel ) { if ( is Sauce Tunnel Running ) { return callback ( null , true ) ; } grunt . log . debug ( 'start sauce tunnel ' ) ; tunnel . start ( function ( has Tunnel Started ) { * starts selenium standalone server if its not running * / server = selenium . start ( options . selenium Options , function ( err , child ) { if ( err ) { return callback ( err ) ; } grunt . log . debug ( 'selenium successfully started ' ) ; selenium Server = child ; is Selenium Server Running = true ; callback ( null , true ) ; } ) ; } else { grunt . log . debug ( 'standalone server or sauce tunnel is running ' ) ; callback ( null , true ) ; } } 
function ( ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'init Webdriver IO instance ' ) ; GLOBAL . browser . init ( function ( err ) { callback ( err ) ; } ) ; } 
function ( callback ) { grunt . log . debug ( 'run mocha tests ' ) ; session ID = GLOBAL . browser . request Handler . session ID ; mocha . run ( next ( callback ) ) ; } 
function ( result , callback ) { grunt . log . debug ( 'end selenium session ' ) ; 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; if ( is Last Task & & is Sauce Tunnel Running ) { grunt . log . debug ( 'destroy sauce tunnel if connected (once all tasks were executed ) ' ) ; return tunnel . stop ( next ( callback , result ) ) ; } else if ( is Last Task & & selenium Server ) { grunt . log . debug ( 'kill selenium server ' ) ; selenium Server . kill ( ) ; } callback ( null , result ) ; } 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; if ( ! options . user & & ! options . key & & ! options . update Sauce Job ) { return callback ( null , result ) ; } grunt . log . debug ( 'update job on Sauce Labs ' ) ; var sauce Account = new Sauce Labs ( { username : options . user , password : options . key } ) ; sauce Account . update Job ( session ID , { passed : result , public : true } , next ( callback , result ) ) ; } 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'finish grunt task ' ) ; if ( is Last Task ) { 
function send ( ghosttrain , verb , url , params , callback ) { var req , res ; verb = verb . to Lower Case ( ) ; 
function render ( req , res , body ) { var response = { } ; var parsed URL = parse URL ( req . url ) ; 
function factory ( options , clbk ) { var opts ; var err ; opts = copy ( defaults ) ; err = validate ( opts , options ) ; if ( err ) { throw err ; } if ( opts . port = = = null ) { if ( opts . protocol = = = 'https ' ) { opts . port = DEFAULT _HTTPS _PORT ; } else { opts . port = DEFAULT _HTTP _PORT ; } } if ( ! is Function ( clbk ) ) { throw new Type Error ( 'invalid input argument . Callback argument must be a function . Value : ` ' + clbk + ' ` . ' ) ; } return function post ( data ) { var d ; if ( arguments . length & & ! is String ( data ) & & ! is Object ( data ) ) { throw new Type Error ( 'invalid input argument . Request data must be either a string or an object . Value : ` ' + data + ' ` . ' ) ; } d = data | | ' ' ; query ( d , opts , done ) ; } ; * FUNCTION : done ( error , results ) * Callback invoked after completing query . * * @private * @param {Error |Null } error - error object * @param {Object [ ] } results - query results * @returns {Void } * / function done ( error , results ) { if ( error ) { return clbk ( error ) ; } clbk ( null , results ) ; } 
function ( val , key ) { const opt Val = _M . _option . get In ( key ) ; 
function ( option Obj ) { 
function ( _data , _target , type = 'style ' ) { const self = this ; * The plan for this fn is to cycle through the various * components , and then merge and res of said comps * / const compose Data = function ( data Map , target ) { If gate for the real fun ; * / if ( object Args . size ) { * So the gist of this funk is its a wrapper funk for the passed in args . * I would take a look at whats happening below in the loop to get a better * idea of whats going on but we are just passing the key Args into this funk * @param {str } key - > Key from the object Args * @param {str } key List - > the regex ref in the _H .util * @param {str } plural - > The plural name which will then cycle through * the cylce Call Fn * @param {fn } funk - > The funk which we will invoke if it passes the * if gate * @param {bln } pass Key - > If we need to pass the key to the funk * @return { - - - } - > A whole shit load could happen but nothing * is returned directly * / const key Check = function ( key , key Type , funk , pass Key = true ) { * Deflate and tmpl features before moving onto the next cycle * / if ( _M . _queue . deflate Queue . size ) { _M . _queue . deflate Next ( ) ; } return { object Args , target } ; } ; * Processes , formats , and renders our CSS styles in the stack * / if ( target . get ( 'stack ' ) . size = = = 1 ) { let queue Done = false ; 
function ( data , target ) { 
function ( data Map , target ) { 
function ( data Map , target ) { If gate for the real fun ; * / if ( object Args . size ) { * So the gist of this funk is its a wrapper funk for the passed in args . * I would take a look at whats happening below in the loop to get a better * idea of whats going on but we are just passing the key Args into this funk * @param {str } key - > Key from the object Args * @param {str } key List - > the regex ref in the _H .util * @param {str } plural - > The plural name which will then cycle through * the cylce Call Fn * @param {fn } funk - > The funk which we will invoke if it passes the * if gate * @param {bln } pass Key - > If we need to pass the key to the funk * @return { - - - } - > A whole shit load could happen but nothing * is returned directly * / const key Check = function ( key , key Type , funk , pass Key = true ) { * Deflate and tmpl features before moving onto the next cycle * / if ( _M . _queue . deflate Queue . size ) { _M . _queue . deflate Next ( ) ; } return { object Args , target } ; } 
function ( key , key Type , funk , pass Key = true ) { 
function ( object Args , target ) { * Processes , formats , and renders our CSS styles in the stack * / if ( target . get ( 'stack ' ) . size = = = 1 ) { let queue Done = false ; 
function ( data , key = false ) { const use Is False = function ( obj ) { return _ . includes ( [ false , 'false ' ] , obj ) ; } ; const use Is True = function ( obj ) { return _ . includes ( [ true , 'true ' ] , obj ) ; } ; 
function ( source Obj ) { 
function add ( reducers , scope , default State ) { if ( scope = = = undefined ) scope = "general " ; 
function remove ( scope , type ) { if ( scope = = = undefined ) scope = "general " ; if ( type = = = undefined ) { delete _combines [ scope ] ; delete _reducers [ scope ] ; } else { delete _reducers [ scope ] [ type ] ; } } 
function replace ( reducers , scope , default State ) { remove ( scope ) ; add ( reducers , scope , default State ) ; } 
function create Goal ( type , goal Name , params , opts ) { opts = opts | | { } opts . type = type var new Goal Instance = new Goal ( goal Name , params , opts ) m . log ( 'Starting ' + goal Name , { params : params } , { custom : { goal Id : new Goal Instance . goal Id } } ) var new Goal = m . context ( { goal Instance : new Goal Instance , name : goal Name } ) return new Goal } 
function to Integer ( value ) { if ( ! value ) { return value = = = 0 ? value : 0 ; } value = to Number ( value ) ; if ( value = = = INFINITY | | value = = = - INFINITY ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX _INTEGER ; } var remainder = value % 1 ; return value = = = value ? ( remainder ? value - remainder : value ) : 0 ; } 
function on Response ( error , results ) { if ( error ) { throw new Error ( error . message ) ; } console . log ( results ) ; } 
function before ( fn , callback ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } if ( callback . apply ( this , [ fn . bind ( this ) ] . concat ( args ) ) ! = = false ) { return fn . apply ( this , args ) ; } } ; } 
function write Error ( type , file , line , message ) { if ( ! messages [ type ] ) { messages [ type ] = [ ] ; } messages [ type ] . push ( { type : type , file : file , line : line , message : message } ) ; } 
function flush Messages ( ) { Object . keys ( messages ) . for Each ( function ( type ) { messages [ type ] . for Each ( function ( msg ) { write Line ( msg . type + " error : [ " + msg . file + " : " + msg . line + " ] " + msg . message ) ; } ) ; } ) ; } 
function get Config ( file ) { var config = { } , sub Config ; try { config = JSON . parse ( fs . read File Sync ( file , "utf 8 " ) ) ; if ( config . extends ) { sub Config = JSON . parse ( fs . read File Sync ( config . extends , "utf 8 " ) ) ; util . _extend ( sub Config , config ) ; delete sub Config . extends ; config = sub Config ; } } catch ( e ) { 
function is Ignored ( file ) { return ignore Patterns . some ( function ( pattern ) { return minimatch ( file , pattern , { nocase : true , match Base : true } ) ; } ) ; } 
function extract Styles ( src ) { var is In Block = false , lines = [ ] ; src . replace ( / \r / g , " " ) . split ( " \n " ) . for Each ( function ( l ) { 
function read ( ) { var filename = process . argv [ 2 ] , src = fs . read File Sync ( process . argv [ 3 ] , "utf 8 " ) ; 
function load File Checker Plugins ( ) { var checkers = { } ; try { fs . readdir Sync ( path . join ( process . cwd ( ) , " .git -hooks /pre -commit -plugins /plugins " ) ) . for Each ( function ( file ) { var check = file . replace ( / \ .js $ / , " " ) ; if ( ! ( / \ .js $ / ) . test ( file ) ) { return ; } checkers [ check ] = require ( path . join ( process . cwd ( ) , " .git -hooks /pre -commit -plugins /plugins " , file ) ) ; } ) ; } catch ( e ) { 
function ( ) { var to = this . get To ( ) , from = this . get From ( ) , before = this . get Before ( ) , after = this . get After ( ) , out = this . get Out ( ) , direction = this . get Direction ( ) , el = this . get Element ( ) , el W = el . get Width ( ) , el H = el . get Height ( ) , origin = out ? ' 1 0 0 % 1 0 0 % ' : ' 0 % 0 % ' , from Opacity = 1 , to Opacity = 1 , transform From = { rotate Y : 0 , translate Z : 0 } , transform To = { rotate Y : 0 , translate Z : 0 } ; if ( direction = = "left " | | direction = = "right " ) { if ( out ) { to Opacity = 0 . 5 ; transform To . translate Z = el W ; transform To . rotate Y = - 9 0 ; } else { from Opacity = 0 . 5 ; transform From . translate Z = el W ; transform From . rotate Y = 9 0 ; } } before [ 'transform -origin ' ] = origin ; after [ 'transform -origin ' ] = null ; to . set ( 'transform ' , transform To ) ; from . set ( 'transform ' , transform From ) ; from . set ( 'opacity ' , from Opacity ) ; to . set ( 'opacity ' , to Opacity ) ; return this . call Parent ( arguments ) ; } 
function ( store Config ) { var me = this , associated Model = me . get Associated Model ( ) , store Name = me . get Store Name ( ) , foreign Key = me . get Foreign Key ( ) , primary Key = me . get Primary Key ( ) , filter Property = me . get Filter Property ( ) , auto Load = me . get Auto Load ( ) , auto Sync = me . get Auto Sync ( ) ; return function ( ) { var record = this , config , filter , store , model Defaults = { } , listeners = { addrecords : me . on Add Records , removerecords : me . on Remove Records , scope : me } ; if ( record [ store Name ] = = = undefined ) { if ( filter Property ) { filter = { property : filter Property , value : record . get ( filter Property ) , exact Match : true } ; } else { filter = { property : foreign Key , value : record . get ( primary Key ) , exact Match : true } ; } model Defaults [ foreign Key ] = record . get ( primary Key ) ; config = Ext . apply ( { } , store Config , { model : associated Model , filters : [ filter ] , remote Filter : true , auto Sync : auto Sync , model Defaults : model Defaults } ) ; store = record [ store Name ] = Ext . create ( 'Ext .data .Store ' , config ) ; store . bound To = record ; store . on After ( listeners ) ; if ( auto Load ) { record [ store Name ] . load ( ) ; } } return record [ store Name ] ; } ; } 
function ( record , reader , association Data ) { var store = record [ this . get Name ( ) ] ( ) , records = reader . read ( association Data ) . get Records ( ) ; store . add ( records ) ; } 
function ( names , prefix , suffix ) { if ( ! names ) { return this ; } if ( ! this . is Synchronized ) { this . synchronize ( ) ; } var dom = this . dom , map = this . has Class Map , class List = this . class List , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : ' ' ; suffix = suffix ? SEPARATOR + suffix : ' ' ; if ( typeof names = = 'string ' ) { names = names . split ( this . spaces Re ) ; } for ( i = 0 , ln = names . length ; i < ln ; i + + ) { name = prefix + names [ i ] + suffix ; if ( ! map [ name ] ) { map [ name ] = true ; class List . push ( name ) ; } } dom . class Name = class List . join ( ' ' ) ; return this ; } 
function ( names , prefix , suffix ) { if ( ! names ) { return this ; } if ( ! this . is Synchronized ) { this . synchronize ( ) ; } if ( ! suffix ) { suffix = ' ' ; } var dom = this . dom , map = this . has Class Map , class List = this . class List , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : ' ' ; suffix = suffix ? SEPARATOR + suffix : ' ' ; if ( typeof names = = 'string ' ) { names = names . split ( this . spaces Re ) ; } for ( i = 0 , ln = names . length ; i < ln ; i + + ) { name = prefix + names [ i ] + suffix ; if ( map [ name ] ) { delete map [ name ] ; Ext . Array . remove ( class List , name ) ; } } dom . class Name = class List . join ( ' ' ) ; return this ; } 
function ( old Name , new Name , prefix , suffix ) { if ( ! old Name & & ! new Name ) { return this ; } old Name = old Name | | [ ] ; new Name = new Name | | [ ] ; if ( ! this . is Synchronized ) { this . synchronize ( ) ; } if ( ! suffix ) { suffix = ' ' ; } var dom = this . dom , map = this . has Class Map , class List = this . class List , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : ' ' ; suffix = suffix ? SEPARATOR + suffix : ' ' ; if ( typeof old Name = = 'string ' ) { old Name = old Name . split ( this . spaces Re ) ; } if ( typeof new Name = = 'string ' ) { new Name = new Name . split ( this . spaces Re ) ; } for ( i = 0 , ln = old Name . length ; i < ln ; i + + ) { name = prefix + old Name [ i ] + suffix ; if ( map [ name ] ) { delete map [ name ] ; Ext . Array . remove ( class List , name ) ; } } for ( i = 0 , ln = new Name . length ; i < ln ; i + + ) { name = prefix + new Name [ i ] + suffix ; if ( ! map [ name ] ) { map [ name ] = true ; class List . push ( name ) ; } } dom . class Name = class List . join ( ' ' ) ; return this ; } 
function ( class Name ) { var map = this . has Class Map , i , ln , name ; if ( typeof class Name = = 'string ' ) { class Name = class Name . split ( this . spaces Re ) ; } for ( i = 0 , ln = class Name . length ; i < ln ; i + + ) { name = class Name [ i ] ; if ( ! map [ name ] ) { map [ name ] = true ; } } this . class List = class Name . slice ( ) ; this . dom . class Name = class Name . join ( ' ' ) ; } 
function ( class Name , force ) { if ( typeof force ! = = 'boolean ' ) { force = ! this . has Cls ( class Name ) ; } return ( force ) ? this . add Cls ( class Name ) : this . remove Cls ( class Name ) ; } 
function ( width , height ) { if ( Ext . is Object ( width ) ) { 
function ( visible ) { var mode = this . get Visibility Mode ( ) , method = visible ? 'remove Cls ' : 'add Cls ' ; switch ( mode ) { case this . VISIBILITY : this . remove Cls ( [ 'x -hidden -display ' , 'x -hidden -offsets ' ] ) ; this [ method ] ( 'x -hidden -visibility ' ) ; break ; case this . DISPLAY : this . remove Cls ( [ 'x -hidden -visibility ' , 'x -hidden -offsets ' ] ) ; this [ method ] ( 'x -hidden -display ' ) ; break ; case this . OFFSETS : this . remove Cls ( [ 'x -hidden -visibility ' , 'x -hidden -display ' ] ) ; this [ method ] ( 'x -hidden -offsets ' ) ; break ; } return this ; } 
function ( prop ) { var me = this , dom = me . dom , hook = me . style Hooks [ prop ] , cs , result ; if ( dom = = document ) { return null ; } if ( ! hook ) { me . style Hooks [ prop ] = hook = { name : Ext . dom . Element . normalize ( prop ) } ; } if ( hook . get ) { return hook . get ( dom , me ) ; } cs = window . get Computed Style ( dom , ' ' ) ; 
function ( prop , value ) { var me = this , dom = me . dom , hooks = me . style Hooks , style = dom . style , value From = Ext . value From , name , hook ; 
function ( side ) { var me = this , hash = { t : "top " , l : "left " , r : "right " , b : "bottom " } , o = { } , key ; if ( ! side ) { for ( key in me . margins ) { o [ hash [ key ] ] = parse Float ( me . get Style ( me . margins [ key ] ) ) | | 0 ; } return o ; } else { return me . add Styles . call ( me , side , me . margins ) ; } } 
function ( ) { 
function ( prop ) { 
function ( class Name ) { 
function get All Keys ( for Value , in Object ) { var keys = [ ] for ( let key of Object . keys ( in Object ) ) { if ( in Object [ key ] = = = for Value ) { keys . push ( key ) } } return keys } 
function print Counter ( indicator ) { counter + + ; process . stdout . write ( indicator ) ; if ( counter = = = files Length | | counter % line Length = = = 0 ) { process . stdout . write ( line Spacing . slice ( - 1 * ( ( line Length - counter ) % line Length ) ) + " " ) ; process . stdout . write ( String ( " " + counter ) . slice ( - 3 ) + " / " + String ( " " + files Length ) . slice ( - 3 ) ) ; process . stdout . write ( " \n " ) ; } } 
function ( config ) { var default Class = Ext . fx . animation . Abstract , type ; if ( typeof config = = 'string ' ) { type = config ; config = { } ; } else if ( config & & config . type ) { type = config . type ; } if ( type ) { if ( Ext . browser . is . Android Stock 2 ) { if ( type = = 'pop ' ) { type = 'fade ' ; } if ( type = = 'pop In ' ) { type = 'fade In ' ; } if ( type = = 'pop Out ' ) { type = 'fade Out ' ; } } default Class = Ext . Class Manager . get By Alias ( 'animation . ' + type ) ; 
function encode ( string ) { function hex ( code ) { var hex _code = code . to String ( 1 6 ) . to Upper Case ( ) ; if ( hex _code . length < 2 ) { hex _code = 0 + hex _code ; } return ' % ' + hex _code ; } string = string + ' ' ; var reserved _chars = / [ : \ / ? # \ [ \ ] @ ! $ & ' ( ) * + , ; = < > " { } | \ \ ` \ ^ % \r \n \u 0 0 8 0 - \uffff ] / ; var str _len = string . length ; var i ; var string _arr = string . split ( ' ' ) ; var c ; for ( i = 0 ; i < str _len ; i + = 1 ) { if ( c = string _arr [ i ] . match ( reserved _chars ) ) { c = c [ 0 ] . char Code At ( 0 ) ; if ( c < 1 2 8 ) { string _arr [ i ] = hex ( c ) ; } else if ( c < 2 0 4 8 ) { string _arr [ i ] = hex ( 1 9 2 + ( c > > 6 ) ) + hex ( 1 2 8 + ( c & 6 3 ) ) ; } else if ( c < 6 5 5 3 6 ) { string _arr [ i ] = hex ( 2 2 4 + ( c > > 1 2 ) ) + hex ( 1 2 8 + ( ( c > > 6 ) & 6 3 ) ) + hex ( 1 2 8 + ( c & 6 3 ) ) ; } else if ( c < 2 0 9 7 1 5 2 ) { string _arr [ i ] = hex ( 2 4 0 + ( c > > 1 8 ) ) + hex ( 1 2 8 + ( ( c > > 1 2 ) & 6 3 ) ) + hex ( 1 2 8 + ( ( c > > 6 ) & 6 3 ) ) + hex ( 1 2 8 + ( c & 6 3 ) ) ; } } } return string _arr . join ( ' ' ) ; } 
function decode ( string ) { return string . replace ( / % [a -f A -F 0 - 9 ] { 2 } / ig , function ( match ) { return String . from Char Code ( parse Int ( match . replace ( ' % ' , ' ' ) , 1 6 ) ) ; } ) ; } 
function get Nonce ( key _length ) { function rand ( ) { return Math . floor ( Math . random ( ) * chars . length ) ; } key _length = key _length | | 6 4 ; var key _bytes = key _length / 8 ; var value = ' ' ; var key _iter = key _bytes / 4 ; var key _remainder = key _bytes % 4 ; var i ; var chars = [ ' 2 0 ' , ' 2 1 ' , ' 2 2 ' , ' 2 3 ' , ' 2 4 ' , ' 2 5 ' , ' 2 6 ' , ' 2 7 ' , ' 2 8 ' , ' 2 9 ' , ' 2A ' , ' 2B ' , ' 2C ' , ' 2D ' , ' 2E ' , ' 2F ' , ' 3 0 ' , ' 3 1 ' , ' 3 2 ' , ' 3 3 ' , ' 3 4 ' , ' 3 5 ' , ' 3 6 ' , ' 3 7 ' , ' 3 8 ' , ' 3 9 ' , ' 3A ' , ' 3B ' , ' 3C ' , ' 3D ' , ' 3E ' , ' 3F ' , ' 4 0 ' , ' 4 1 ' , ' 4 2 ' , ' 4 3 ' , ' 4 4 ' , ' 4 5 ' , ' 4 6 ' , ' 4 7 ' , ' 4 8 ' , ' 4 9 ' , ' 4A ' , ' 4B ' , ' 4C ' , ' 4D ' , ' 4E ' , ' 4F ' , ' 5 0 ' , ' 5 1 ' , ' 5 2 ' , ' 5 3 ' , ' 5 4 ' , ' 5 5 ' , ' 5 6 ' , ' 5 7 ' , ' 5 8 ' , ' 5 9 ' , ' 5A ' , ' 5B ' , ' 5C ' , ' 5D ' , ' 5E ' , ' 5F ' , ' 6 0 ' , ' 6 1 ' , ' 6 2 ' , ' 6 3 ' , ' 6 4 ' , ' 6 5 ' , ' 6 6 ' , ' 6 7 ' , ' 6 8 ' , ' 6 9 ' , ' 6A ' , ' 6B ' , ' 6C ' , ' 6D ' , ' 6E ' , ' 6F ' , ' 7 0 ' , ' 7 1 ' , ' 7 2 ' , ' 7 3 ' , ' 7 4 ' , ' 7 5 ' , ' 7 6 ' , ' 7 7 ' , ' 7 8 ' , ' 7 9 ' , ' 7A ' , ' 7B ' , ' 7C ' , ' 7D ' , ' 7E ' ] ; for ( i = 0 ; i < key _iter ; i + = 1 ) { value + = chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] ; } 
function to Header String ( params , realm ) { var arr = [ ] ; var i ; for ( i in params ) { if ( typeof params [ i ] ! = = 'object ' & & params [ i ] ! = = ' ' & & params [ i ] ! = = undefined ) { arr . push ( encode ( i ) + ' = " ' + encode ( params [ i ] ) + ' " ' ) ; } } arr . sort ( ) ; if ( realm ) { arr . unshift ( 'realm = " ' + encode ( realm ) + ' " ' ) ; } return arr . join ( ' , ' ) ; } 
function to Signature Base String ( method , url , header _params , query _params ) { var arr = [ ] ; var i ; for ( i in header _params ) { if ( header _params [ i ] ! = = undefined & & header _params [ i ] ! = = ' ' ) { arr . push ( [ encode ( i ) , encode ( header _params [ i ] + ' ' ) ] ) ; } } for ( i in query _params ) { if ( query _params [ i ] ! = = undefined & & query _params [ i ] ! = = ' ' ) { arr . push ( [ encode ( i ) , encode ( query _params [ i ] + ' ' ) ] ) ; } } arr = arr . sort ( function lexical Sort ( a , b ) { if ( a [ 0 ] < b [ 0 ] ) { return - 1 ; } else if ( a [ 0 ] > b [ 0 ] ) { return 1 ; } else { if ( a [ 1 ] < b [ 1 ] ) { return - 1 ; } else if ( a [ 1 ] > b [ 1 ] ) { return 1 ; } else { return 0 ; } } } ) . map ( function ( el ) { return el . join ( " = " ) ; } ) ; return [ method , encode ( url ) , encode ( arr . join ( ' & ' ) ) ] . join ( ' & ' ) ; } 
function ( method , url , async , user , password ) { var xhr = this . request ; xhr . method = method . to Upper Case ( ) ; xhr . url = Url . parse ( url , true ) ; xhr . async = async ; xhr . user = password ; xhr . open ( xhr . method , xhr . url , xhr . async , xhr . user , xhr . password ) ; } 
function ( application _secret , token _secret , signature _base ) { var passphrase ; var signature ; application _secret = encode ( application _secret ) ; token _secret = encode ( token _secret | | ' ' ) ; passphrase = application _secret + ' & ' + token _secret ; signature = Cryptography . hmac ( Cryptography . SHA 1 , passphrase , signature _base ) ; return btoa ( signature ) ; } 
function ( file Name , tmp L , idx , index Column ) { var self = this ; var f Name List = tmp L . splice ( 0 , 1 ) [ 0 ] ; var f Type List = tmp L . splice ( 0 , 1 ) [ 0 ] ; if ( index Column ! = undefined ) { idx = f Name List [ index Column ] ; } var fields Name = { } ; f Name List . for Each ( function ( value , index ) { fields Name [ value ] = index ; } ) ; self . data = { } ; tmp L . for Each ( function ( item ) { var obj = { } ; for ( var k in fields Name ) { 
function ( config ) { if ( typeof config = = "string " ) { config = { title : config } ; } var min Height = ' 1 . 3em ' ; if ( Ext . theme . is . Cupertino ) { min Height = ' 1 . 5em ' } else if ( Ext . filter Platform ( 'blackberry ' ) | | Ext . filter Platform ( 'ie 1 0 ' ) ) { min Height = ' 2 . 6em ' ; } Ext . apply If ( config , { docked : 'top ' , min Height : min Height , ui : Ext . filter Platform ( 'blackberry ' ) ? 'light ' : 'dark ' , cls : this . get Base Cls ( ) + ' -title ' } ) ; if ( Ext . theme . is . Tizen ) { Ext . apply If ( config , { centered : false } ) ; } return Ext . factory ( config , Ext . Toolbar , this . get Title ( ) ) ; } 
function ( new Buttons ) { var me = this ; 
function ( initial Config ) { Ext . util . Input Blocker . block Inputs ( ) ; 
function ( title , message , fn , scope ) { return this . show ( { title : title | | null , message : message | | null , buttons : Ext . Message Box . YESNO , prompt Config : false , scope : scope , fn : function ( ) { if ( fn ) { fn . apply ( scope , arguments ) ; } } } ) ; } 
function ( title , message , fn , scope , multi Line , value , prompt ) { return this . show ( { title : title | | null , message : message | | null , buttons : Ext . Message Box . OKCANCEL , scope : scope , prompt : prompt | | true , multi Line : multi Line , value : value , fn : function ( ) { if ( fn ) { fn . apply ( scope , arguments ) ; } } } ) ; } 
function ( new Component ) { this . call Parent ( arguments ) ; var cls = this . get Cls ( ) ; if ( new Component ) { this . spin Down Button = Ext . Element . create ( { cls : cls + ' -button ' + cls + ' -button -down ' , html : ' - ' } ) ; this . spin Up Button = Ext . Element . create ( { cls : cls + ' -button ' + cls + ' -button -up ' , html : ' + ' } ) ; this . down Repeater = this . create Repeater ( this . spin Down Button , this . on Spin Down ) ; this . up Repeater = this . create Repeater ( this . spin Up Button , this . on Spin Up ) ; } } 
function ( val , type ) { var ret ; 
function ( config ) { if ( config ) { if ( Ext . is Boolean ( config ) ) { config = { } ; } if ( typeof config = = "string " ) { config = { text : config } ; } Ext . apply If ( config , { ui : 'action ' , align : 'right ' , text : 'Done ' } ) ; } return Ext . factory ( config , 'Ext .Button ' , this . get Done Button ( ) ) ; } 
function ( config ) { if ( config ) { if ( Ext . is Boolean ( config ) ) { config = { } ; } if ( typeof config = = "string " ) { config = { text : config } ; } Ext . apply If ( config , { align : 'left ' , text : 'Cancel ' } ) ; } return Ext . factory ( config , 'Ext .Button ' , this . get Cancel Button ( ) ) ; } 
function ( new Slots ) { var bcss = Ext . base CSSPrefix , inner Items ; this . remove All ( ) ; if ( new Slots ) { this . add ( new Slots ) ; } inner Items = this . get Inner Items ( ) ; if ( inner Items . length > 0 ) { inner Items [ 0 ] . add Cls ( bcss + 'first ' ) ; inner Items [ inner Items . length - 1 ] . add Cls ( bcss + 'last ' ) ; } this . update Use Titles ( this . get Use Titles ( ) ) ; } 
function ( values , animated ) { var me = this , slots = me . get Inner Items ( ) , ln = slots . length , key , slot , loop Slot , i , value ; if ( ! values ) { values = { } ; for ( i = 0 ; i < ln ; i + + ) { 
function ( use Dom ) { var values = { } , items = this . get Items ( ) . items , ln = items . length , item , i ; if ( use Dom ) { for ( i = 0 ; i < ln ; i + + ) { item = items [ i ] ; if ( item & & item . is Slot ) { values [ item . get Name ( ) ] = item . get Value ( use Dom ) ; } } this . _values = values ; } return this . _values ; } 
function behat Runner ( data , callback ) { var spawn = require ( 'child _process ' ) . spawn , behat = spawn ( data . cmd , data . args ) , stderr = ' ' , stdout = ' ' , options = data . options | | { } ; if ( typeof options . fail On Undefined = = = 'undefined ' ) { options . fail On Undefined = false ; } if ( typeof options . fail On Failed = = = 'undefined ' ) { options . fail On Failed = true ; } behat . stdout . on ( 'data ' , function ( data ) { stdout + = data ; } ) ; behat . stderr . on ( 'data ' , function ( data ) { stderr + = data ; } ) ; behat . on ( 'exit ' , function ( code ) { if ( code = = = 1 2 7 ) { grunt . log . errorlns ( 'In order for this task to work properly , Behat must be ' + 'installed and in the system PATH (if you can run "behat " at ' + ' the command line , this task should work ) . Unfortunately , ' + 'Behat cannot be installed automatically via npm or grunt . ' + 'See the Behat installation instructions : ' + 'http : / /docs .behat .org /quick _intro .html #installation ' ) ; grunt . warn ( 'Behat not found . ' , code ) ; } else { if ( options . fail On Undefined & & has Undefined Steps ( stdout ) ) { grunt . verbose . writeln ( stdout ) ; stderr = 'Undefined Steps ' ; if ( options . output ) { stderr = stdout ; } } if ( options . fail On Failed & & has Failed Steps ( stdout ) ) { grunt . verbose . writeln ( stdout ) ; stderr = 'Failed Steps ' ; if ( options . output ) { stderr = stdout ; } } if ( stderr = = = ' ' & & options . output ) { grunt . log . write ( stdout ) ; } } callback ( stderr , stdout ) ; } ) ; } 
function add Translation ( translations , locale ) { if ( typeof translations ! = = 'object ' ) { return ; } 
function ( ) { var me = this , pressed Buttons = [ ] , ln , i , item , items ; 
function ( button ) { if ( ! this . get Allow Toggle ( ) ) { return ; } var me = this , pressed Buttons = me . get Pressed Buttons ( ) | | [ ] , buttons = [ ] , already Pressed ; if ( ! me . get Disabled ( ) & & ! button . get Disabled ( ) ) { 
function ( new Buttons , old Buttons ) { var me = this , items = me . get Items ( ) , pressed Cls = me . get Pressed Cls ( ) , events = [ ] , item , button , ln , i , e ; 
function ( ) { var me = this , store = me . get Store ( ) , value = me . get Value ( ) ; 
function ( new Options ) { var store = this . get Store ( ) ; if ( ! store ) { this . set Store ( true ) ; store = this . _store ; } if ( ! new Options ) { store . clear Data ( ) ; } else { store . set Data ( new Options ) ; this . on Store Data Changed ( store ) ; } return this ; } 
function ( store ) { var initial Config = this . get Initial Config ( ) , value = this . get Value ( ) ; if ( value | | value = = 0 ) { this . update Value ( this . apply Value ( value ) ) ; } if ( this . get Value ( ) = = = null ) { if ( initial Config . has Own Property ( 'value ' ) ) { this . set Value ( initial Config . value ) ; } if ( this . get Value ( ) = = = null & & this . get Auto Select ( ) ) { if ( store . get Count ( ) > 0 ) { this . set Value ( store . get At ( 0 ) ) ; } } } } 
function ( ) { var me = this , record ; if ( me . get Auto Select ( ) ) { var store = me . get Store ( ) ; record = ( me . original Value ) ? me . original Value : store . get At ( 0 ) ; } else { var use Picker = me . get Use Picker ( ) , picker = use Picker ? me . picker : me . list Panel ; if ( picker ) { picker = picker . child ( use Picker ? 'pickerslot ' : 'dataview ' ) ; picker . deselect All ( ) ; } record = null ; } me . set Value ( record ) ; return me ; } 
function generate Sql Schema ( db Dialect , metadata , prefix = undefined ) { check . assert . non Empty String ( db Dialect ) check . assert . object ( metadata ) check . assert . maybe . string ( prefix ) if ( ! Dialects . is Supported ( db Dialect ) ) { throw new Error ( ` $ { db Dialect } ` ) } prefix = prefix | | ' ' const sql Serializer = new Sql Serializer ( db Dialect ) const ordered Entities = get Entities Ordered By Relations ( metadata ) let queries = [ ] _ . for Each ( ordered Entities , ( entity Name ) = > { const entity = metadata [ entity Name ] const table Name = pg Escape . ident ( ` $ { prefix } $ { entity Name } ` ) let create Queries = [ ] _ . for Own ( entity . fields , ( field , field Name ) = > { const column Name = pg Escape . ident ( field Name ) let column Query = ' ' column Query + = column Name let column Constraints = [ ] const column Type = Sql Serializer . resolve Type ( field . type ) column Query + = ` $ { column Type } ` if ( field . enum ) { const enum Values = field . enum . map ( ( value ) = > sql Serializer . serialize Value ( field . type , value ) ) . join ( ' , ' ) const expression = column Type . match ( / ( \ [ \d * \ ] ) + / g ) ? ` $ { enum Values } ` : ` $ { enum Values } ` column Constraints . push ( ` $ { column Name } $ { expression } ` ) } 
function get Global Obj ( str , root ) { for ( var i = 0 ; i < root . length ; + + i ) { if ( root [ i ] . name = = str ) { return root [ i ] ; } } return undefined ; } 
function for Each Struct ( structname , obj , root , callback , noexline ) { if ( noexline = = undefined ) { noexline = false ; } for ( var i = 0 ; i < obj . val . length ; + + i ) { if ( noexline & & obj . val [ i ] . name . name . index Of ( ' _ ' ) = = 0 ) { continue ; } if ( obj . val [ i ] . has Own Property ( 'type 2 ' ) & & obj . val [ i ] . type 2 = = 'expand ' ) { if ( ! obj . val [ i ] . has Own Property ( 'expand ' ) ) { for Each Struct ( structname , get Global Obj ( obj . val [ i ] . type , root ) , root , callback ) ; } else { var expandobj = get Global Obj ( obj . val [ i ] . expand , root ) ; for ( var eoi = 0 ; eoi < expandobj . val . length ; + + eoi ) { callback ( structname , { name : { name : get Enum Member Real Name ( expandobj . val [ eoi ] . name , expandobj . name ) } , type : obj . val [ i ] . type , comment : expandobj . val [ eoi ] . comment } , root ) ; } } } else { if ( obj . name ! = structname & & obj . val [ i ] . has Own Property ( 'type 2 ' ) & & obj . val [ i ] . type 2 = = 'primary ' ) { callback ( structname , { name : obj . val [ i ] . name , val : obj . val [ i ] . val , type : obj . val [ i ] . type , type 2 : 'unique ' } , root ) ; } else { callback ( structname , obj . val [ i ] , root ) ; } } } } 
function get Struct Member Type ( membername , structname , root ) { var obj = get Global Obj ( structname , root ) ; if ( obj ! = undefined ) { if ( obj . type = = 'message ' | | obj . type = = 'struct ' | | obj . type = = 'static ' ) { for ( var i = 0 ; i < obj . val . length ; + + i ) { if ( obj . val [ i ] . name . name = = membername ) { return obj . val [ i ] . type ; } } } } return undefined ; } 
function get Member ( obj , name , root ) { var ii = str . index Of ( ' . ' ) ; if ( ii < 0 ) { var curobj = undefined ; for Each Struct ( obj . name , obj , root , function ( structname , cobj , root ) { if ( name = = cobj . name . name ) { curobj = cobj ; } } ) ; return curobj ; } if ( ii = = 0 ) { return ; } var curtype = undefined ; var cur = str . slice ( 0 , ii ) ; for Each Struct ( obj . name , obj , root , function ( structname , cobj , root ) { if ( cur = = cobj . name . name ) { curtype = cobj . type ; } } ) ; if ( curtype ! = undefined ) { return get Member ( get Global Obj ( curtype , root ) , str . slice ( ii + 1 ) , root ) ; } return ; } 
function set In Message ( obj , root ) { obj . inmessage = true ; if ( obj . type = = 'static ' | | obj . type = = 'struct ' | | obj . type = = 'message ' ) { for ( var i = 0 ; i < obj . val . length ; + + i ) { var cval = obj . val [ i ] ; if ( cval . has Own Property ( 'type 2 ' ) & & 'expand ' = = cval . type 2 ) { continue ; } var mytype = get Real Type ( cval . type , root ) ; if ( is Base Type ( mytype ) ) { continue ; } set In Message ( get Global Obj ( mytype , root ) , root ) ; } } } 
function proc In Message ( root ) { for ( var i = 0 ; i < root . length ; + + i ) { if ( 'message ' = = root [ i ] . type ) { set In Message ( root [ i ] , root ) ; } } return root ; } 
function get Ver ( root ) { let cur = get Global Obj ( 'VER ' , root ) ; if ( cur = = undefined ) { return ' ' ; } return cur . val . val ; } 
function RPC ( contact , options ) { assert ( this instanceof RPC , 'Invalid instance supplied ' ) assert ( contact instanceof Contact , 'Invalid contact was supplied ' ) events . Event Emitter . call ( this ) options = options | | { } if ( options . replyto ) { assert ( options . replyto instanceof Contact , 'Invalid contact was supplied ' ) } this . _hooks = { before : { } , after : { } } this . _pending Calls = { } this . _contact = options . replyto | | contact this . _log = options & & options . logger this . ready State = 0 this . open ( ) } 
function ( el , q ) { var root , is , i , ln ; if ( typeof el = = "string " ) { el = document . get Element By Id ( el ) ; } if ( Ext . is Array ( el ) ) { is = true ; ln = el . length ; for ( i = 0 ; i < ln ; i + + ) { if ( ! this . is ( el [ i ] , q ) ) { is = false ; break ; } } } else { root = el . parent Node ; if ( ! root ) { root = document . create Document Fragment ( ) ; root . append Child ( el ) ; is = this . select ( q , root ) . index Of ( el ) ! = = - 1 ; root . remove Child ( el ) ; root = null ; } else { is = this . select ( q , root ) . index Of ( el ) ! = = - 1 ; } } return is ; } 
function Channel ( id , exchange ) { var self = this ; events . Event Emitter . call ( this ) ; this . id = id ; this . exchange = exchange ; this . exchange . on ( this . id , function ( message ) { self . emit ( 'message ' , message ) ; } ) ; this . set Max Listeners ( 0 ) ; } 
function Availability Metric ( ) { if ( ! ( this instanceof Availability Metric ) ) { return new Availability Metric ( ) } Metric . call ( this ) this . key = 'availability ' this . default = [ 0 , 0 ] 
function include Helpers ( func ) { 
function jam ( func , context ) { ensure Func ( func , 'function ' ) ; var steps = [ ] ; 
function continuable ( func , context ) { ensure Func ( func , 'function ' ) ; if ( context ) { 
function extract Description ( d ) { if ( ! d ) return ; if ( d = = = "ERROR : No README data found ! " ) return ; 
function add Comment ( type , value , start , end , loc ) { var comment ; assert ( typeof start = = = 'number ' , 'Comment must have valid position ' ) ; 
function scan Punctuator ( ) { var start = index , code = source . char Code At ( index ) , code 2 , ch 1 = source [ index ] , ch 2 , ch 3 , ch 4 ; if ( state . in JSXTag | | state . in JSXChild ) { 
function expect Keyword ( keyword , contextual ) { var token = lex ( ) ; if ( token . type ! = = ( contextual ? Token . Identifier : Token . Keyword ) | | token . value ! = = keyword ) { throw Unexpected ( token ) ; } } 
function parse Array Initialiser ( ) { var elements = [ ] , blocks = [ ] , filter = null , tmp , possiblecomprehension = true , marker = marker Create ( ) ; expect ( ' [ ' ) ; while ( ! match ( ' ] ' ) ) { if ( lookahead . value = = = 'for ' & & lookahead . type = = = Token . Keyword ) { if ( ! possiblecomprehension ) { throw Error ( { } , Messages . Comprehension Error ) ; } match Keyword ( 'for ' ) ; tmp = parse For Statement ( { ignore Body : true } ) ; tmp . of = tmp . type = = = Syntax . For Of Statement ; tmp . type = Syntax . Comprehension Block ; if ( tmp . left . kind ) { 
function parse Property Function ( options ) { var previous Strict , previous Yield Allowed , previous Await Allowed , params , defaults , body , marker = marker Create ( ) ; previous Strict = strict ; previous Yield Allowed = state . yield Allowed ; state . yield Allowed = options . generator ; previous Await Allowed = state . await Allowed ; state . await Allowed = options . async ; params = options . params | | [ ] ; defaults = options . defaults | | [ ] ; body = parse Concise Body ( ) ; if ( options . name & & strict & & is Restricted Word ( params [ 0 ] . name ) ) { throw Error Tolerant ( options . name , Messages . Strict Param Name ) ; } strict = previous Strict ; state . yield Allowed = previous Yield Allowed ; state . await Allowed = previous Await Allowed ; return marker Apply ( marker , delegate . create Function Expression ( null , params , defaults , body , options . rest | | null , options . generator , body . type ! = = Syntax . Block Statement , options . async , options . return Type , options . type Parameters ) ) ; } 
function parse Postfix Expression ( ) { var marker = marker Create ( ) , expr = parse Left Hand Side Expression Allow Call ( ) , token ; if ( lookahead . type ! = = Token . Punctuator ) { return expr ; } if ( ( match ( ' + + ' ) | | match ( ' - - ' ) ) & & ! peek Line Terminator ( ) ) { 
function parse Unary Expression ( ) { var marker , token , expr ; if ( lookahead . type ! = = Token . Punctuator & & lookahead . type ! = = Token . Keyword ) { return parse Postfix Expression ( ) ; } if ( match ( ' + + ' ) | | match ( ' - - ' ) ) { marker = marker Create ( ) ; token = lex ( ) ; expr = parse Unary Expression ( ) ; 
function reinterpret As Assignment Binding Pattern ( expr ) { var i , len , property , element ; if ( expr . type = = = Syntax . Object Expression ) { expr . type = Syntax . Object Pattern ; for ( i = 0 , len = expr . properties . length ; i < len ; i + = 1 ) { property = expr . properties [ i ] ; if ( property . type = = = Syntax . Spread Property ) { if ( i < len - 1 ) { throw Error ( { } , Messages . Property After Spread Property ) ; } reinterpret As Assignment Binding Pattern ( property . argument ) ; } else { if ( property . kind ! = = 'init ' ) { throw Error ( { } , Messages . Invalid LHSIn Assignment ) ; } reinterpret As Assignment Binding Pattern ( property . value ) ; } } } else if ( expr . type = = = Syntax . Array Expression ) { expr . type = Syntax . Array Pattern ; for ( i = 0 , len = expr . elements . length ; i < len ; i + = 1 ) { element = expr . elements [ i ] ; if ( element ) { reinterpret As Assignment Binding Pattern ( element ) ; } } } else if ( expr . type = = = Syntax . Identifier ) { if ( is Restricted Word ( expr . name ) ) { throw Error ( { } , Messages . Invalid LHSIn Assignment ) ; } } else if ( expr . type = = = Syntax . Spread Element ) { reinterpret As Assignment Binding Pattern ( expr . argument ) ; if ( expr . argument . type = = = Syntax . Object Pattern ) { throw Error ( { } , Messages . Object Pattern As Spread ) ; } } else { if ( expr . type ! = = Syntax . Member Expression & & expr . type ! = = Syntax . Call Expression & & expr . type ! = = Syntax . New Expression ) { throw Error ( { } , Messages . Invalid LHSIn Assignment ) ; } } } 
function parse Expression Statement ( ) { var marker = marker Create ( ) , expr = parse Expression ( ) ; consume Semicolon ( ) ; return marker Apply ( marker , delegate . create Expression Statement ( expr ) ) ; } 
function parse Return Statement ( ) { var argument = null , marker = marker Create ( ) ; expect Keyword ( 'return ' ) ; if ( ! state . in Function Body ) { throw Error Tolerant ( { } , Messages . Illegal Return ) ; } 
function parse Statement ( ) { var type = lookahead . type , marker , expr , labeled Body ; if ( type = = = Token . EOF ) { throw Unexpected ( lookahead ) ; } if ( type = = = Token . Punctuator ) { switch ( lookahead . value ) { case ' ; ' : return parse Empty Statement ( ) ; case ' { ' : return parse Block ( ) ; case ' ( ' : return parse Expression Statement ( ) ; default : break ; } } if ( type = = = Token . Keyword ) { switch ( lookahead . value ) { case 'break ' : return parse Break Statement ( ) ; case 'continue ' : return parse Continue Statement ( ) ; case 'debugger ' : return parse Debugger Statement ( ) ; case 'do ' : return parse Do While Statement ( ) ; case 'for ' : return parse For Statement ( ) ; case 'function ' : return parse Function Declaration ( ) ; case 'class ' : return parse Class Declaration ( ) ; case 'if ' : return parse If Statement ( ) ; case 'return ' : return parse Return Statement ( ) ; case 'switch ' : return parse Switch Statement ( ) ; case 'throw ' : return parse Throw Statement ( ) ; case 'try ' : return parse Try Statement ( ) ; case 'var ' : return parse Variable Statement ( ) ; case 'while ' : return parse While Statement ( ) ; case 'with ' : return parse With Statement ( ) ; default : break ; } } if ( match Async Func Expr Or Decl ( ) ) { return parse Function Declaration ( ) ; } marker = marker Create ( ) ; expr = parse Expression ( ) ; 
function parse Source Element ( ) { var token ; if ( lookahead . type = = = Token . Keyword ) { switch ( lookahead . value ) { case 'const ' : case 'let ' : return parse Const Let Declaration ( lookahead . value ) ; case 'function ' : return parse Function Declaration ( ) ; case 'export ' : throw Error Tolerant ( { } , Messages . Illegal Export Declaration ) ; return parse Export Declaration ( ) ; case 'import ' : throw Error Tolerant ( { } , Messages . Illegal Import Declaration ) ; return parse Import Declaration ( ) ; case 'interface ' : if ( lookahead 2 ( ) . type = = = Token . Identifier ) { return parse Interface ( ) ; } return parse Statement ( ) ; default : return parse Statement ( ) ; } } if ( match Contextual Keyword ( 'type ' ) & & lookahead 2 ( ) . type = = = Token . Identifier ) { return parse Type Alias ( ) ; } if ( match Contextual Keyword ( 'interface ' ) & & lookahead 2 ( ) . type = = = Token . Identifier ) { return parse Interface ( ) ; } if ( match Contextual Keyword ( 'declare ' ) ) { token = lookahead 2 ( ) ; if ( token . type = = = Token . Keyword ) { switch ( token . value ) { case 'class ' : return parse Declare Class ( ) ; case 'function ' : return parse Declare Function ( ) ; case 'var ' : return parse Declare Variable ( ) ; } } else if ( token . type = = = Token . Identifier & & token . value = = = 'module ' ) { return parse Declare Module ( ) ; } } if ( lookahead . type ! = = Token . EOF ) { return parse Statement ( ) ; } } 
function advance JSXChild ( ) { var ch = source . char Code At ( index ) ; 
function extend ( object , properties ) { var entry , result = { } ; for ( entry in object ) { if ( object . has Own Property ( entry ) ) { result [ entry ] = object [ entry ] ; } } for ( entry in properties ) { if ( properties . has Own Property ( entry ) ) { result [ entry ] = properties [ entry ] ; } } return result ; } 
function resolve ( value , key ) { 
function clone ( parent , circular , depth , prototype ) { var filter ; if ( typeof circular = = = 'object ' ) { depth = circular . depth ; prototype = circular . prototype ; filter = circular . filter ; circular = circular . circular } 
function make Abs ( self , f ) { var abs = f if ( f . char At ( 0 ) = = = ' / ' ) { abs = path . join ( self . root , f ) } else if ( is Absolute ( f ) | | f = = = ' ' ) { abs = f } else if ( self . changed Cwd ) { abs = path . resolve ( self . cwd , f ) } else { abs = path . resolve ( f ) } return abs } 
function is Plain Object ( value ) { var Ctor ; 
function reflow Text ( text , width , gfm ) { 
function is Absolute ( fp ) { if ( typeof fp ! = = 'string ' ) { throw new Type Error ( 'is Absolute expects a string . ' ) ; } if ( ! is Windows ( ) & & is Absolute . posix ( fp ) ) { return true ; } return is Absolute . win 3 2 ( fp ) ; } 
function repeat ( str , num ) { if ( typeof str ! = = 'string ' ) { throw new Type Error ( 'repeat -string expects a string . ' ) ; } if ( num = = = 1 ) return str ; if ( num = = = 2 ) return str + str ; var max = str . length * num ; if ( cache ! = = str | | typeof cache = = = 'undefined ' ) { cache = str ; res = ' ' ; } while ( max > res . length & & num > 0 ) { if ( num & 1 ) { res + = str ; } num > > = 1 ; if ( ! num ) break ; str + = str ; } return res . substr ( 0 , max ) ; } 
function uniq Set ( arr ) { var seen = new Set ( ) ; return arr . filter ( function ( el ) { if ( ! seen . has ( el ) ) { seen . add ( el ) ; return true ; } } ) ; } 
function ( data , options ) { var handler = new Dom Handler ( options ) ; new Parser ( handler , options ) . end ( data ) ; return handler . dom ; } 
function error ( msg , _continue ) { if ( state . error = = = null ) state . error = ' ' ; state . error + = state . current Cmd + ' : ' + msg + ' \n ' ; if ( msg . length > 0 ) log ( state . error ) ; if ( config . fatal ) process . exit ( 1 ) ; if ( ! _continue ) throw ' ' ; } 
function parse Options ( str , map ) { if ( ! map ) error ( 'parse Options ( ) internal error : no map given ' ) ; 
function expand ( list ) { var expanded = [ ] ; list . for Each ( function ( list El ) { 
function unlink Sync ( file ) { try { fs . unlink Sync ( file ) ; } catch ( e ) { 
function random File Name ( ) { function random Hash ( count ) { if ( count = = = 1 ) return parse Int ( 1 6 * Math . random ( ) , 1 0 ) . to String ( 1 6 ) ; else { var hash = ' ' ; for ( var i = 0 ; i < count ; i + + ) hash + = random Hash ( 1 ) ; return hash ; } } return 'shelljs _ ' + random Hash ( 2 0 ) ; } 
function extend ( target ) { var sources = [ ] . slice . call ( arguments , 1 ) ; sources . for Each ( function ( source ) { for ( var key in source ) target [ key ] = source [ key ] ; } ) ; return target ; } 
function wrap ( cmd , fn , options ) { return function ( ) { var ret Value = null ; state . current Cmd = cmd ; state . error = null ; try { var args = [ ] . slice . call ( arguments , 0 ) ; if ( options & & options . not Unix ) { ret Value = fn . apply ( this , args ) ; } else { if ( args . length = = = 0 | | typeof args [ 0 ] ! = = 'string ' | | args [ 0 ] [ 0 ] ! = = ' - ' ) args . unshift ( ' ' ) ; 
function push File ( file , query ) { 
function writeable Dir ( dir ) { if ( ! dir | | ! fs . exists Sync ( dir ) ) return false ; if ( ! fs . stat Sync ( dir ) . is Directory ( ) ) return false ; var test File = dir + ' / ' + common . random File Name ( ) ; try { fs . write File Sync ( test File , ' ' ) ; common . unlink Sync ( test File ) ; return dir ; } catch ( e ) { return false ; } } 
function copy File Sync ( src File , dest File ) { if ( ! fs . exists Sync ( src File ) ) common . error ( 'copy File Sync : no such file or directory : ' + src File ) ; var BUF _LENGTH = 6 4 * 1 0 2 4 , buf = new Buffer ( BUF _LENGTH ) , bytes Read = BUF _LENGTH , pos = 0 , fdr = null , fdw = null ; try { fdr = fs . open Sync ( src File , 'r ' ) ; } catch ( e ) { common . error ( 'copy File Sync : could not read src file ( ' + src File + ' ) ' ) ; } try { fdw = fs . open Sync ( dest File , 'w ' ) ; } catch ( e ) { common . error ( 'copy File Sync : could not write to dest file (code = ' + e . code + ' ) : ' + dest File ) ; } while ( bytes Read = = = BUF _LENGTH ) { bytes Read = fs . read Sync ( fdr , buf , 0 , BUF _LENGTH , pos ) ; fs . write Sync ( fdw , buf , 0 , bytes Read ) ; pos + = bytes Read ; } fs . close Sync ( fdr ) ; fs . close Sync ( fdw ) ; fs . chmod Sync ( dest File , fs . stat Sync ( src File ) . mode ) ; } 
function cpdir Sync Recursive ( source Dir , dest Dir , opts ) { if ( ! opts ) opts = { } ; var check Dir = fs . stat Sync ( source Dir ) ; try { fs . mkdir Sync ( dest Dir , check Dir . mode ) ; } catch ( e ) { 
function mkdir Sync Recursive ( dir ) { var base Dir = path . dirname ( dir ) ; 
function split Path ( p ) { for ( i = 1 ; i < 2 ; i + + ) { } if ( ! p ) return [ ] ; if ( common . platform = = = 'win ' ) return p . split ( ' ; ' ) ; else return p . split ( ' : ' ) ; } 
function exec Sync ( cmd , opts ) { var temp Dir = _temp Dir ( ) ; var stdout File = path . resolve ( temp Dir + ' / ' + common . random File Name ( ) ) , code File = path . resolve ( temp Dir + ' / ' + common . random File Name ( ) ) , script File = path . resolve ( temp Dir + ' / ' + common . random File Name ( ) ) , sleep File = path . resolve ( temp Dir + ' / ' + common . random File Name ( ) ) ; var options = common . extend ( { silent : common . config . silent } , opts ) ; var previous Stdout Content = ' ' ; 
function update Stdout ( ) { if ( options . silent | | ! fs . exists Sync ( stdout File ) ) return ; var stdout Content = fs . read File Sync ( stdout File , 'utf 8 ' ) ; 
function exec Async ( cmd , opts , callback ) { var output = ' ' ; var options = common . extend ( { silent : common . config . silent } , opts ) ; var c = child . exec ( cmd , { env : process . env , max Buffer : 2 0 * 1 0 2 4 * 1 0 2 4 } , function ( err ) { if ( callback ) callback ( err ? err . code : 0 , output ) ; } ) ; c . stdout . on ( 'data ' , function ( data ) { output + = data ; if ( ! options . silent ) process . stdout . write ( data ) ; } ) ; c . stderr . on ( 'data ' , function ( data ) { output + = data ; if ( ! options . silent ) process . stdout . write ( data ) ; } ) ; return c ; } 
function format Args ( ) { var args = arguments ; var use Colors = this . use Colors ; var name = this . namespace ; if ( use Colors ) { var c = this . color ; args [ 0 ] = ' \u 0 0 1b [ 3 ' + c + ' ; 1m ' + name + ' ' + ' \u 0 0 1b [ 0m ' + args [ 0 ] + ' \u 0 0 1b [ 3 ' + c + 'm ' + ' + ' + exports . humanize ( this . diff ) + ' \u 0 0 1b [ 0m ' ; } else { args [ 0 ] = new Date ( ) . to UTCString ( ) + ' ' + name + ' ' + args [ 0 ] ; } return args ; } 
function GNTP ( type , opts ) { opts = opts | | { } ; this . type = type ; this . host = opts . host | | 'localhost ' ; this . port = opts . port | | 2 3 0 5 3 ; this . request = 'GNTP / 1 . 0 ' + type + ' NONE ' + nl ; this . resources = [ ] ; this . attempts = 0 ; this . max Attempts = 5 ; } 
function Growly ( ) { this . appname = 'Growly ' ; this . notifications = undefined ; this . labels = undefined ; this . count = 0 ; this . registered = false ; this . host = undefined ; this . port = undefined ; } 
function Command ( name ) { this . commands = [ ] ; this . options = [ ] ; this . _execs = [ ] ; this . _allow Unknown Option = false ; this . _args = [ ] ; this . _name = name ; } 
function uniq ( array , is Sorted , iteratee , this Arg ) { var length = array ? array . length : 0 ; if ( ! length ) { return [ ] ; } if ( is Sorted ! = null & & typeof is Sorted ! = 'boolean ' ) { this Arg = iteratee ; iteratee = is Iteratee Call ( array , is Sorted , this Arg ) ? undefined : is Sorted ; is Sorted = false ; } iteratee = iteratee = = null ? iteratee : base Callback ( iteratee , this Arg , 3 ) ; return ( is Sorted ) ? sorted Uniq ( array , iteratee ) : base Uniq ( array , iteratee ) ; } 
function base Difference ( array , values ) { var length = array ? array . length : 0 , result = [ ] ; if ( ! length ) { return result ; } var index = - 1 , index Of = base Index Of , is Common = true , cache = ( is Common & & values . length > = LARGE _ARRAY _SIZE ) ? create Cache ( values ) : null , values Length = values . length ; if ( cache ) { index Of = cache Index Of ; is Common = false ; values = cache ; } outer : while ( + + index < length ) { var value = array [ index ] ; if ( is Common & & value = = = value ) { var values Index = values Length ; while ( values Index - - ) { if ( values [ values Index ] = = = value ) { continue outer ; } } result . push ( value ) ; } else if ( index Of ( values , value , 0 ) < 0 ) { result . push ( value ) ; } } return result ; } 
function Assertion Error ( message , _props , ssf ) { var extend = exclude ( 'name ' , 'message ' , 'stack ' , 'constructor ' , 'to JSON ' ) , props = extend ( _props | | { } ) ; 
function ( ) { var ch 1 = this . peek ( ) ; var ch 2 , ch 3 , ch 4 ; switch ( ch 1 ) { 
function ( ) { var index = 0 ; var value = " " ; var length = this . input . length ; var char = this . peek ( index ) ; var bad ; var is Allowed Digit = is Decimal Digit ; var base = 1 0 ; var is Legacy = false ; function is Decimal Digit ( str ) { return ( / ^ [ 0 - 9 ] $ / ) . test ( str ) ; } function is Octal Digit ( str ) { return ( / ^ [ 0 - 7 ] $ / ) . test ( str ) ; } function is Binary Digit ( str ) { return ( / ^ [ 0 1 ] $ / ) . test ( str ) ; } function is Hex Digit ( str ) { return ( / ^ [ 0 - 9a -f A -F ] $ / ) . test ( str ) ; } function is Identifier Start ( ch ) { return ( ch = = = " $ " ) | | ( ch = = = " _ " ) | | ( ch = = = " \ \ " ) | | ( ch > = "a " & & ch < = "z " ) | | ( ch > = "A " & & ch < = "Z " ) ; } 
function ( checks ) { var allow New Line = false ; var jump = 1 ; this . skip ( ) ; var char = this . peek ( ) ; switch ( char ) { case " ' " : this . trigger Async ( "warning " , { code : "W 1 1 4 " , line : this . line , character : this . char , data : [ " \ \ ' " ] } , checks , function ( ) { return state . json Mode ; } ) ; break ; case "b " : char = " \ \b " ; break ; case "f " : char = " \ \f " ; break ; case "n " : char = " \ \n " ; break ; case "r " : char = " \ \r " ; break ; case "t " : char = " \ \t " ; break ; case " 0 " : char = " \ \ 0 " ; 
function ( checks ) { var token Type ; var value = " " ; var ch ; var start Line = this . line ; var start Char = this . char ; var depth = this . template Starts . length ; if ( ! state . option . esnext ) { 
function ( checks ) { var quote = this . peek ( ) ; 
function addlabel ( name , opts ) { var type = opts . type ; var token = opts . token ; var isblockscoped = opts . isblockscoped ; 
function peek ( p ) { var i = p | | 0 , j = 0 , t ; while ( j < = i ) { t = lookahead [ j ] ; if ( ! t ) { t = lookahead [ j ] = lex . token ( ) ; } j + = 1 ; } 
function is Typo Typeof ( left , right , state ) { var values ; if ( state . option . notypeof ) return false ; if ( ! left | | ! right ) return false ; values = state . in ESNext ( ) ? typeof Values . es 6 : typeof Values . es 3 ; if ( right . type = = = " (identifier ) " & & right . value = = = "typeof " & & left . type = = = " (string ) " ) return ! _ . contains ( values , left . value ) ; return false ; } 
function identifier ( fnparam , prop ) { var i = optionalidentifier ( fnparam , prop , false ) ; if ( i ) { return i ; } 
function destructuring Assign Or Json Value ( ) { 
function ( ) { var Comp Array = function ( ) { this . mode = "use " ; this . variables = [ ] ; } ; var _carrays = [ ] ; var _current ; function declare ( v ) { var l = _current . variables . filter ( function ( elt ) { 
function ( s , o , g ) { var i , k , x , re Ignore Str , re Ignore ; var option Keys ; var new Option Obj = { } ; var new Ignored Obj = { } ; o = _ . clone ( o ) ; state . reset ( ) ; if ( o & & o . scope ) { JSHINT . scope = o . scope ; } else { JSHINT . errors = [ ] ; JSHINT . undefs = [ ] ; JSHINT . internals = [ ] ; JSHINT . blacklist = { } ; JSHINT . scope = " (main ) " ; } predefined = Object . create ( null ) ; combine ( predefined , vars . ecma Identifiers [ 3 ] ) ; combine ( predefined , vars . reserved Vars ) ; combine ( predefined , g | | { } ) ; declared = Object . create ( null ) ; exported = Object . create ( null ) ; function each ( obj , cb ) { if ( ! obj ) return ; if ( ! Array . is Array ( obj ) & & typeof obj = = = "object " ) obj = Object . keys ( obj ) ; obj . for Each ( cb ) ; } if ( o ) { each ( o . predef | | null , function ( item ) { var slice , prop ; if ( item [ 0 ] = = = " - " ) { slice = item . slice ( 1 ) ; JSHINT . blacklist [ slice ] = slice ; 
function rename ( filepath , transformer ) { var result ; var file Obj = parse ( filepath ) ; if ( ! transformer ) { result = stringify ( file Obj ) ; debug ( 'transform to %s with no transformer ' , result ) ; return result ; } var transformed = util . is Function ( transformer ) ? transformer ( file Obj ) : transformer ; 
function parse Legacy ( ext , content , file Name , custom Tags , with Inline Files ) { return parse ( { ext : ext , content : content , file Name : file Name , custom Tags : custom Tags , with Inline Files : with Inline Files } ) ; } 
function parse Path ( path ) { var str = path . replace ( / ( [ ^ \ \ ] ) \ [ / g , ' $ 1 . [ ' ) , parts = str . match ( / ( \ \ \ . | [ ^ . ] + ? ) + / g ) ; return parts . map ( function ( value ) { var re = / ^ \ [ ( \d + ) \ ] $ / , m Arr = re . exec ( value ) ; if ( m Arr ) return { i : parse Float ( m Arr [ 1 ] ) } ; else return { p : value . replace ( / \ \ ( [ . \ [ \ ] ] ) / g , ' $ 1 ' ) } ; } ) ; } 
function assert Keys ( keys ) { var obj = flag ( this , 'object ' ) , str , ok = true , mixed Args Msg = 'keys must be given single argument of Array |Object |String , or multiple String arguments ' ; switch ( _ . type ( keys ) ) { case "array " : if ( arguments . length > 1 ) throw ( new Error ( mixed Args Msg ) ) ; break ; case "object " : if ( arguments . length > 1 ) throw ( new Error ( mixed Args Msg ) ) ; keys = Object . keys ( keys ) ; break ; default : keys = Array . prototype . slice . call ( arguments ) ; } if ( ! keys . length ) throw new Error ( 'keys required ' ) ; var actual = Object . keys ( obj ) , expected = keys , len = keys . length , any = flag ( this , 'any ' ) , all = flag ( this , 'all ' ) ; if ( ! any & & ! all ) { all = true ; } 
function assert Throws ( constructor , err Msg , msg ) { if ( msg ) flag ( this , 'message ' , msg ) ; var obj = flag ( this , 'object ' ) ; new Assertion ( obj , msg ) . is . a ( 'function ' ) ; var thrown = false , desired Error = null , name = null , thrown Error = null ; if ( arguments . length = = = 0 ) { err Msg = null ; constructor = null ; } else if ( constructor & & ( constructor instanceof Reg Exp | | 'string ' = = = typeof constructor ) ) { err Msg = constructor ; constructor = null ; } else if ( constructor & & constructor instanceof Error ) { desired Error = constructor ; constructor = null ; err Msg = null ; } else if ( typeof constructor = = = 'function ' ) { name = constructor . prototype . name | | constructor . name ; if ( name = = = 'Error ' & & constructor ! = = Error ) { name = ( new constructor ( ) ) . name ; } } else { constructor = null ; } try { obj ( ) ; } catch ( err ) { 
function respond To ( method , msg ) { if ( msg ) flag ( this , 'message ' , msg ) ; var obj = flag ( this , 'object ' ) , itself = flag ( this , 'itself ' ) , context = ( 'function ' = = = _ . type ( obj ) & & ! itself ) ? obj . prototype [ method ] : obj [ method ] ; this . assert ( 'function ' = = = typeof context , 'expected # {this } to respond to ' + _ . inspect ( method ) , 'expected # {this } to not respond to ' + _ . inspect ( method ) ) ; } 
function assert Changes ( object , prop , msg ) { if ( msg ) flag ( this , 'message ' , msg ) ; var fn = flag ( this , 'object ' ) ; new Assertion ( object , msg ) . to . have . property ( prop ) ; new Assertion ( fn ) . is . a ( 'function ' ) ; var initial = object [ prop ] ; fn ( ) ; this . assert ( initial ! = = object [ prop ] , 'expected . ' + prop + ' to change ' , 'expected . ' + prop + ' to not change ' ) ; } 
function should Getter ( ) { if ( this instanceof String | | this instanceof Number | | this instanceof Boolean ) { return new Assertion ( this . value Of ( ) , null , should Getter ) ; } return new Assertion ( this , null , should Getter ) ; } 
function function Throws ( fn , context , args , value ) { try { fn . apply ( context , args ) ; } catch ( error ) { if ( value = = null ) return true ; if ( _is Function 2 [ 'default ' ] ( value ) & & error instanceof value ) return true ; var message = error . message | | error ; if ( typeof message = = = 'string ' ) { if ( _is Regexp 2 [ 'default ' ] ( value ) & & value . test ( error . message ) ) return true ; if ( typeof value = = = 'string ' & & message . index Of ( value ) ! = = - 1 ) return true ; } } return false ; } 
function is A ( object , value ) { if ( _is Function 2 [ 'default ' ] ( value ) ) return object instanceof value ; if ( value = = = 'array ' ) return Array . is Array ( object ) ; return typeof object = = = value ; } 
function ( bin , opt ) { cmd = bin ; if ( opt . testing ! = = 'undefined ' ) { opt . dry Run = opt . testing ; } if ( typeof opt . test Suite = = = 'undefined ' ) { opt . test Suite = ' ' ; } if ( typeof opt . verbose = = = 'undefined ' ) { opt . verbose = ' ' ; } if ( typeof opt . dry Run = = = 'undefined ' ) { opt . dry Run = false ; } if ( typeof opt . silent = = = 'undefined ' ) { opt . silent = false ; } if ( typeof opt . testing = = = 'undefined ' ) { opt . testing = false ; } if ( typeof opt . debug = = = 'undefined ' ) { opt . debug = false ; } if ( typeof opt . test Class = = = 'undefined ' ) { opt . test Class = ' ' ; } if ( typeof opt . clear = = = 'undefined ' ) { opt . clear = false ; } if ( typeof opt . flags = = = 'undefined ' ) { opt . flags = ' ' ; } if ( typeof opt . notify = = = 'undefined ' ) { opt . notify = false ; } if ( typeof opt . no Interaction = = = 'undefined ' ) { opt . no Interaction = true ; } if ( typeof opt . no Ansi = = = 'undefined ' ) { opt . no Ansi = false ; } if ( typeof opt . quiet = = = 'undefined ' ) { opt . quiet = false ; } if ( typeof opt . formatter = = = 'undefined ' ) { opt . formatter = ' ' ; } cmd = opt . clear ? 'clear & & ' + cmd : cmd ; 
function eat Nargs ( i , key , args ) { var to Eat = check All Aliases ( key , opts . narg ) if ( args . length - ( i + 1 ) < to Eat ) error = Error ( _ _ ( 'Not enough arguments following : %s ' , key ) ) for ( var ii = i + 1 ; ii < ( to Eat + i + 1 ) ; ii + + ) { set Arg ( key , args [ ii ] ) } return ( i + to Eat ) } 
function eat Array ( i , key , args ) { for ( var ii = i + 1 ; ii < args . length ; ii + + ) { if ( / ^ - / . test ( args [ ii ] ) ) break i = ii set Arg ( key , args [ ii ] ) } return i } 
function set Config ( argv ) { var config Lookup = { } 
function extend Aliases ( obj ) { Object . keys ( obj | | { } ) . for Each ( function ( key ) { aliases [ key ] = [ ] . concat ( opts . alias [ key ] | | [ ] ) 
function check All Aliases ( key , flag ) { var is Set = false var to Check = [ ] . concat ( aliases [ key ] | | [ ] , key ) to Check . for Each ( function ( key ) { if ( flag [ key ] ) is Set = flag [ key ] } ) return is Set } 
function guess Type ( key , flags ) { var type = 'boolean ' if ( flags . strings & & flags . strings [ key ] ) type = 'string ' else if ( flags . arrays & & flags . arrays [ key ] ) type = 'array ' return type } 
function max Width ( table ) { var width = 0 
function normalize Aliases ( ) { var demanded = yargs . get Demanded ( ) var options = yargs . get Options ( ) ; ( Object . keys ( options . alias ) | | [ ] ) . for Each ( function ( key ) { options . alias [ key ] . for Each ( function ( alias ) { 
function default String ( value , default Description ) { var string = ' [ ' + _ _ ( 'default : ' ) + ' ' if ( value = = = undefined & & ! default Description ) return null if ( default Description ) { string + = default Description } else { switch ( typeof value ) { case 'string ' : string + = JSON . stringify ( value ) break case 'object ' : string + = JSON . stringify ( value ) break default : string + = value } } return string + ' ] ' } 
function sigletonify ( inst ) { Object . keys ( inst ) . for Each ( function ( key ) { if ( key = = = 'argv ' ) { Argv . _ _define Getter _ _ ( key , inst . _ _lookup Getter _ _ ( key ) ) } else { Argv [ key ] = typeof inst [ key ] = = = 'function ' ? inst [ key ] . bind ( inst ) : inst [ key ] } } ) } 
function find _attr _value ( attr Forms , attr Name ) { var attr Val ; var attr Pos = - 1 ; if ( attr Forms & & Array . is Array ( attr Forms ) ) { attr Key = attr Forms . find ( function ( form , i ) { attr Pos = i ; return ( i % 2 = = = 1 ) & & form . value = = = attr Name ; } ) if ( attr Key & & attr Pos + 1 < attr Forms . length ) { attr Val = attr Forms [ attr Pos + 1 ] ; } } return attr Val ; } 
function ( options ) { options = options | | { } if ( this . passports & & this . passports . every ( t = > t instanceof app . orm [ 'Passport ' ] ) & & options . reload ! = = true ) { return Promise . resolve ( this ) } else { return this . get Passports ( { transaction : options . transaction | | null } ) . then ( passports = > { passports = passports | | [ ] this . passports = passports this . set Data Value ( 'passports ' , passports ) this . set ( 'passports ' , passports ) return this } ) } } 
function ( cls , overrides ) { if ( cls . $is Class ) { return cls . override ( overrides ) ; } else { Ext . apply ( cls . prototype , overrides ) ; } } 
function ( value ) { if ( value = = = null ) { return 'null ' ; } var type = typeof value ; if ( type = = = 'undefined ' | | type = = = 'string ' | | type = = = 'number ' | | type = = = 'boolean ' ) { return type ; } var type To String = to String . call ( value ) ; switch ( type To String ) { case ' [object Array ] ' : return 'array ' ; case ' [object Date ] ' : return 'date ' ; case ' [object Boolean ] ' : return 'boolean ' ; case ' [object Number ] ' : return 'number ' ; case ' [object Reg Exp ] ' : return 'regexp ' ; } if ( type = = = 'function ' ) { return 'function ' ; } if ( type = = = 'object ' ) { if ( value . node Type ! = = undefined ) { if ( value . node Type = = = 3 ) { return ( / \S / ) . test ( value . node Value ) ? 'textnode ' : 'whitespace ' ; } else { return 'element ' ; } } return 'object ' ; } 
function write ( path , str ) { fs . write File Sync ( path , str ) ; console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; } 
function mkdir ( path , silent ) { if ( ! exists ( path ) ) { fs . mkdir Sync ( path , 0 7 5 5 ) ; if ( ! silent ) console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; } } 
function is Empty Directory ( path ) { var files ; try { files = fs . readdir Sync ( path ) ; if ( files . length > 0 ) { return false ; } } catch ( err ) { if ( err . code ) { terminal . abort ( 'Error : ' , err ) ; } else { throw e ; } } return true ; } 
function ( config , callback , scope ) { 
function ( selector , max Depth , return El ) { if ( arguments . length = = = 0 ) { return this . delegated Target ; } return selector ? Ext . fly ( this . target ) . find Parent ( selector , max Depth , return El ) : ( return El ? Ext . get ( this . target ) : this . target ) ; } 
function ( action , silent ) { action = Ext . factory ( action , Ext . app . Action ) ; this . get Actions ( ) . push ( action ) ; var url = action . get Url ( ) ; if ( this . get Update Url ( ) ) { 
function ( ) { var actions = this . get Actions ( ) , previous Action = actions [ actions . length - 2 ] ; if ( previous Action ) { actions . pop ( ) ; previous Action . get Controller ( ) . get Application ( ) . redirect To ( previous Action . get Url ( ) ) ; } else { actions [ actions . length - 1 ] . get Controller ( ) . get Application ( ) . redirect To ( ' ' ) ; } } 
function strformat ( string , dict ) { var formatted = string ; for ( var prop in dict ) { var regexp = new Reg Exp ( ' \ \ { ' + prop + ' \ \ } ' , 'gi ' ) ; formatted = formatted . replace ( regexp , dict [ prop ] ) ; } return formatted ; } 
function Grel Request ( grel ) { var auth String ; if ( grel . token ) { auth String = grel . token + ' : ' ; } else { auth String = grel . user + ' : ' + grel . password ; } this . headers = { 'Authorization ' : 'Basic ' + new Buffer ( auth String ) . to String ( 'base 6 4 ' ) , 'Accept ' : 'application /vnd .github .manifold -preview ' , 'User -Agent ' : 'Grel ' } ; this . grel = grel ; this . content = null ; } 
function handle Response ( res , data , callback ) { 
function split Header ( content ) { 
function ( x , y , animation ) { if ( this . is Destroyed ) { return this ; } 
function ( animation ) { var size = this . get Size ( ) , cnt Size = this . get Container Size ( ) ; return this . scroll To ( size . x - cnt Size . x , size . y - cnt Size . y , animation ) ; } 
function ( x , y , animation ) { var position = this . position ; x = ( typeof x = = 'number ' ) ? x + position . x : null ; y = ( typeof y = = 'number ' ) ? y + position . y : null ; return this . scroll To ( x , y , animation ) ; } 
function ( config ) { var element ; this . extra Constraint = { } ; this . initial Config = config ; this . offset = { x : 0 , y : 0 } ; this . listeners = { dragstart : 'on Drag Start ' , drag : 'on Drag ' , dragend : 'on Drag End ' , resize : 'on Element Resize ' , touchstart : 'on Press ' , touchend : 'on Release ' , scope : this } ; if ( config & & config . element ) { element = config . element ; delete config . element ; this . set Element ( element ) ; } return this ; } 
function add Actions ( actions ) { if ( typeof actions = = = 'string ' ) { add ( actions ) ; } else if ( Array . is Array ( actions ) ) { actions . for Each ( add Actions ) ; } else if ( typeof actions = = = 'object ' ) { for ( var type in actions ) { add ( type , actions [ type ] ) ; } } } 
function indexspace ( str , len ) { var x 1 , x 2 , tmp , inc , arr ; if ( ! is String ( str ) | | ! re . test ( str ) ) { throw new Error ( 'indexspace ( ) : :invalid input argument . Invalid subsequence syntax . Please consult documentation . Value : ` ' + str + ' ` . ' ) ; } if ( ! is Non Negative Integer ( len ) ) { throw new Type Error ( 'indexspace ( ) : :invalid input argument . Reference array length must be a nonnegative integer . Value : ` ' + len + ' ` . ' ) ; } if ( ! len ) { return [ ] ; } str = str . split ( ' : ' ) ; x 1 = str [ 0 ] ; x 2 = str [ 1 ] ; if ( str . length = = = 2 ) { inc = 1 ; } else { inc = parse Int ( str [ 2 ] , 1 0 ) ; } 
function ( element , event Name , fn , scope , options ) { 
function ( element , event Name , fn , scope ) { 
function ( fn , scope , options ) { 
function ( pattern , count , sep ) { for ( var buf = [ ] , i = count ; i - - ; ) { buf . push ( pattern ) ; } return buf . join ( sep | | ' ' ) ; } 
function ( config ) { var options = new File Upload Options ( ) ; options . file Key = config . file Key | | "file " ; options . file Name = this . path . substr ( this . path . last Index Of ( ' / ' ) + 1 ) ; options . mime Type = config . mime Type | | "image /jpeg " ; options . params = config . params | | { } ; options . headers = config . headers | | { } ; options . chunk Mode = config . chunk Mode | | true ; var file Transfer = new File Transfer ( ) ; file Transfer . upload ( this . path , encode URI ( config . url ) , config . success , config . failure , options , config . trust All Hosts | | false ) ; return file Transfer ; } 
function ( config ) { var file Transfer = new File Transfer ( ) ; file Transfer . download ( encode URI ( config . source ) , this . path , config . success , config . failure , config . trust All Hosts | | false , config . options | | { } ) ; return file Transfer ; } 
function ( property , value , any Match , case Sensitive ) { 
function ( key , item ) { var me = this , filtered = this . filtered , sorted = this . sorted , all = this . all , items = this . items , keys = this . keys , indices = this . indices , filterable = this . mixins . filterable , current Length = items . length , index = current Length ; if ( arguments . length = = 1 ) { item = key ; key = me . get Key ( item ) ; } if ( typeof key ! = 'undefined ' & & key ! = = null ) { if ( typeof me . map [ key ] ! = 'undefined ' ) { return me . replace ( key , item ) ; } me . map [ key ] = item ; } all . push ( item ) ; if ( filtered & & this . get Auto Filter ( ) & & filterable . is Filtered . call ( me , item ) ) { return null ; } me . length + + ; if ( sorted & & this . get Auto Sort ( ) ) { index = this . find Insertion Index ( items , item ) ; } if ( index ! = = current Length ) { this . dirty Indices = true ; Ext . Array . splice ( keys , index , 0 , key ) ; Ext . Array . splice ( items , index , 0 , item ) ; } else { indices [ key ] = current Length ; keys . push ( key ) ; items . push ( item ) ; } return item ; } 
function ( old Key , item ) { var me = this , sorted = me . sorted , presorted = me . presorted , filtered = me . filtered , filterable = me . mixins . filterable , items = me . items , keys = me . keys , all = me . all , map = me . map , return Item = null , old Items Ln = items . length , subject To Optimize = false , old Item , index , new Key ; if ( arguments . length = = 1 ) { item = old Key ; old Key = new Key = me . get Key ( item ) ; subject To Optimize = true ; } else { new Key = me . get Key ( item ) ; } old Item = map [ old Key ] ; if ( typeof old Key = = 'undefined ' | | old Key = = = null | | typeof old Item = = 'undefined ' ) { return me . add ( new Key , item ) ; } me . map [ new Key ] = item ; if ( new Key ! = = old Key ) { delete me . map [ old Key ] ; } if ( sorted & & me . get Auto Sort ( ) ) { if ( ! subject To Optimize ) { Ext . Array . remove ( items , old Item ) ; Ext . Array . remove ( keys , old Key ) ; } else { var items From = items . index Of ( old Item ) ; } if ( ! presorted ) { Ext . Array . remove ( all , old Item ) ; all . push ( item ) ; me . dirty Indices = true ; } else { var all To = this . find Insertion Index ( all , item , undefined , true ) , all From = all . index Of ( item ) ; if ( all To ! = = all From ) { move ( all , all From , all To ) ; me . dirty Indices = true ; } } if ( filtered & & me . get Auto Filter ( ) ) { 
function ( add Items ) { var me = this , filtered = me . filtered , sorted = me . sorted , all = me . all , items = me . items , keys = me . keys , map = me . map , auto Filter = me . get Auto Filter ( ) , auto Sort = me . get Auto Sort ( ) , new Keys = [ ] , new Items = [ ] , filterable = me . mixins . filterable , added Items = [ ] , ln , key , i , item ; if ( Ext . is Object ( add Items ) ) { for ( key in add Items ) { if ( add Items . has Own Property ( key ) ) { new Items . push ( items [ key ] ) ; new Keys . push ( key ) ; } } } else { new Items = add Items ; ln = add Items . length ; for ( i = 0 ; i < ln ; i + + ) { new Keys . push ( me . get Key ( add Items [ i ] ) ) ; } } for ( i = 0 ; i < ln ; i + + ) { key = new Keys [ i ] ; item = new Items [ i ] ; if ( typeof key ! = 'undefined ' & & key ! = = null ) { if ( typeof map [ key ] ! = 'undefined ' ) { me . replace ( key , item ) ; continue ; } map [ key ] = item ; } all . push ( item ) ; if ( filtered & & auto Filter & & filterable . is Filtered . call ( me , item ) ) { continue ; } me . length + + ; keys . push ( key ) ; items . push ( item ) ; added Items . push ( item ) ; } if ( added Items . length ) { me . dirty Indices = true ; if ( sorted & & auto Sort ) { me . sort ( ) ; } return added Items ; } return null ; } 
function ( fn , scope ) { var keys = this . keys , items = this . items , ln = keys . length , i ; for ( i = 0 ; i < ln ; i + + ) { fn . call ( scope | | window , keys [ i ] , items [ i ] , i , ln ) ; } } 
function ( fn , scope ) { var me = this , new Collection = new this . self ( ) , keys = me . keys , items = me . all , length = items . length , i ; new Collection . get Key = me . get Key ; for ( i = 0 ; i < length ; i + + ) { if ( fn . call ( scope | | me , items [ i ] , me . get Key ( items [ i ] ) ) ) { new Collection . add ( keys [ i ] , items [ i ] ) ; } } return new Collection ; } 
function ( index , key , item ) { var me = this , sorted = this . sorted , map = this . map , filtered = this . filtered ; if ( arguments . length = = 2 ) { item = key ; key = me . get Key ( item ) ; } if ( index > = me . length | | ( sorted & & me . get Auto Sort ( ) ) ) { return me . add ( key , item ) ; } if ( typeof key ! = 'undefined ' & & key ! = = null ) { if ( typeof map [ key ] ! = 'undefined ' ) { me . replace ( key , item ) ; return false ; } map [ key ] = item ; } this . all . push ( item ) ; if ( filtered & & this . get Auto Filter ( ) & & this . mixins . filterable . is Filtered . call ( me , item ) ) { return null ; } me . length + + ; Ext . Array . splice ( me . items , index , 0 , item ) ; Ext . Array . splice ( me . keys , index , 0 , key ) ; me . dirty Indices = true ; return item ; } 
function ( item ) { var index = this . items . index Of ( item ) ; if ( index = = = - 1 ) { Ext . Array . remove ( this . all , item ) ; if ( typeof this . get Key = = 'function ' ) { var key = this . get Key ( item ) ; if ( key ! = = undefined ) { delete this . map [ key ] ; } } return item ; } return this . remove At ( this . items . index Of ( item ) ) ; } 
function ( items ) { if ( items ) { var ln = items . length , i ; for ( i = 0 ; i < ln ; i + + ) { this . remove ( items [ i ] ) ; } } return this ; } 
function ( index ) { var me = this , items = me . items , keys = me . keys , all = me . all , item , key ; if ( index < me . length & & index > = 0 ) { item = items [ index ] ; key = keys [ index ] ; if ( typeof key ! = 'undefined ' ) { delete me . map [ key ] ; } Ext . Array . erase ( items , index , 1 ) ; Ext . Array . erase ( keys , index , 1 ) ; Ext . Array . remove ( all , item ) ; delete me . indices [ key ] ; me . length - - ; this . dirty Indices = true ; return item ; } return false ; } 
function ( item ) { if ( this . dirty Indices ) { this . update Indices ( ) ; } var index = item ? this . indices [ this . get Key ( item ) ] : - 1 ; return ( index = = = undefined ) ? - 1 : index ; } 
function ( key ) { var me = this , from Map = me . map [ key ] , item ; if ( from Map ! = = undefined ) { item = from Map ; } else if ( typeof key = = 'number ' ) { item = me . items [ key ] ; } return typeof item ! = 'function ' | | me . get Allow Functions ( ) ? item : null ; 
function ( item ) { var key = this . get Key ( item ) ; if ( key ) { return this . contains Key ( key ) ; } else { return Ext . Array . contains ( this . items , item ) ; } } 
function ( ) { var me = this ; me . length = 0 ; me . items . length = 0 ; me . keys . length = 0 ; me . all . length = 0 ; me . dirty Indices = true ; me . indices = { } ; me . map = { } ; } 
function ( start , end ) { var me = this , items = me . items , range = [ ] , i ; if ( items . length < 1 ) { return range ; } start = start | | 0 ; end = Math . min ( typeof end = = 'undefined ' ? me . length - 1 : end , me . length - 1 ) ; if ( start < = end ) { for ( i = start ; i < = end ; i + + ) { range [ range . length ] = items [ i ] ; } } else { for ( i = start ; i > = end ; i - - ) { range [ range . length ] = items [ i ] ; } } return range ; } 
function ( fn , scope , start ) { var me = this , keys = me . keys , items = me . items , i = start | | 0 , ln = items . length ; for ( ; i < ln ; i + + ) { if ( fn . call ( scope | | me , items [ i ] , keys [ i ] ) ) { return i ; } } return - 1 ; } 
function ( ) { var me = this , copy = new this . self ( ) , keys = me . keys , items = me . items , i = 0 , ln = items . length ; for ( ; i < ln ; i + + ) { copy . add ( keys [ i ] , items [ i ] ) ; } copy . get Key = me . get Key ; return copy ; } 
function ( new Month Text , old Month Text ) { var inner Items = this . get Inner Items , ln = inner Items . length , item , i ; 
function ( new Day Text , old Day Text ) { var inner Items = this . get Inner Items , ln = inner Items . length , item , i ; 
function ( year Text ) { var inner Items = this . get Inner Items , ln = inner Items . length , item , i ; 
function ( ) { var me = this , slot Order = me . get Slot Order ( ) , years From = me . get Year From ( ) , years To = me . get Year To ( ) , years = [ ] , days = [ ] , months = [ ] , reverse = years From > years To , ln , i , days In Month ; while ( years From ) { years . push ( { text : years From , value : years From } ) ; if ( years From = = = years To ) { break ; } if ( reverse ) { years From - - ; } else { years From + + ; } } days In Month = me . get Days In Month ( 1 , new Date ( ) . get Full Year ( ) ) ; for ( i = 0 ; i < days In Month ; i + + ) { days . push ( { text : i + 1 , value : i + 1 } ) ; } for ( i = 0 , ln = Ext . Date . month Names . length ; i < ln ; i + + ) { months . push ( { text : Ext . Date . month Names [ i ] , value : i + 1 } ) ; } var slots = [ ] ; slot Order . for Each ( function ( item ) { slots . push ( me . create Slot ( item , days , months , years ) ) ; } ) ; me . set Slots ( slots ) ; } 
function ( name , days , months , years ) { switch ( name ) { case 'year ' : return { name : 'year ' , align : 'center ' , data : years , title : this . get Year Text ( ) , flex : 3 } ; case 'month ' : return { name : name , align : 'right ' , data : months , title : this . get Month Text ( ) , flex : 4 } ; case 'day ' : return { name : 'day ' , align : 'center ' , data : days , title : this . get Day Text ( ) , flex : 2 } ; } } 
function ( contact , options ) { this . messaging = options . messaging kademlia . RPC . call ( this , contact , options ) } 
function ( user ) { if ( user ) { if ( ! ! ~ this . roles . index Of ( ' * ' ) ) { return true ; } else { for ( var user Role Index in user . roles ) { for ( var role Index in this . roles ) { if ( this . roles [ role Index ] = = = user . roles [ user Role Index ] ) { return true ; } } } } } else { return this . is Public ; } return false ; } 
function ( old Left , old Title , reverse ) { var me = this , bar Element = me . element , new Left Element = me . left Box . element , title Element = me . title Component . element , min Offset = Math . min ( bar Element . get Width ( ) / 3 , 2 0 0 ) , new Left Width = new Left Element . get Width ( ) , bar X = bar Element . get X ( ) , bar Width = bar Element . get Width ( ) , title X = title Element . get X ( ) , title Left = title Element . get Left ( ) , title Width = title Element . get Width ( ) , old Left X = old Left . x , old Left Width = old Left . width , old Left Left = old Left . left , use Left = Ext . browser . is . Android Stock 2 & & ! this . get Android 2Transforms ( ) , new Offset , old Offset , left Anims , title Anims , omega , theta ; theta = bar X - old Left X - old Left Width ; if ( reverse ) { new Offset = theta ; old Offset = Math . min ( title X - old Left Width , min Offset ) ; } else { old Offset = theta ; new Offset = Math . min ( title X - bar X , min Offset ) ; } if ( use Left ) { left Anims = { element : { from : { left : new Offset , opacity : 1 } , to : { left : 0 , opacity : 1 } } } ; } else { left Anims = { element : { from : { transform : { translate X : new Offset } , opacity : 0 } , to : { transform : { translate X : 0 } , opacity : 1 } } , ghost : { to : { transform : { translate X : old Offset } , opacity : 0 } } } ; } theta = bar X - title X + new Left Width ; if ( ( old Left Left + title Width ) > title X ) { omega = bar X - title X - title Width ; } if ( reverse ) { title Element . set Left ( 0 ) ; old Offset = bar X + bar Width - title X - title Width ; if ( omega ! = = undefined ) { new Offset = omega ; } else { new Offset = theta ; } } else { new Offset = bar X + bar Width - title X - title Width ; if ( omega ! = = undefined ) { old Offset = omega ; } else { old Offset = theta ; } new Offset = Math . max ( title Left , new Offset ) ; } if ( use Left ) { title Anims = { element : { from : { left : new Offset , opacity : 1 } , to : { left : title Left , opacity : 1 } } } ; } else { title Anims = { element : { from : { transform : { translate X : new Offset } , opacity : 0 } , to : { transform : { translate X : title Left } , opacity : 1 } } , ghost : { to : { transform : { translate X : old Offset } , opacity : 0 } } } ; } return { left : left Anims , title : title Anims , title Left : title Left } ; } 
function ( element , config , callback ) { var me = this , animation ; 
function ( ) { var text = this . back Button Stack [ this . back Button Stack . length - 2 ] , use Title For Back Button Text = this . get Use Title For Back Button Text ( ) ; if ( ! use Title For Back Button Text ) { if ( text ) { text = this . get Default Back Button Text ( ) ; } } return text ; } 
function ( hidden ) { if ( ! hidden ) { this . element . set Style ( { position : 'relative ' , top : 'auto ' , left : 'auto ' , width : 'auto ' } ) ; } else { this . element . set Style ( { position : 'absolute ' , top : ' - 1 0 0 0px ' , left : ' - 1 0 0 0px ' , width : this . element . get Width ( ) + 'px ' } ) ; } } 
function ( element ) { var ghost , x , y , left , width ; ghost = element . dom . clone Node ( true ) ; ghost . id = element . id + ' -proxy ' ; 
function plugin ( options ) { options = options | | { } ; options . key = options . key | | 'untemplatized ' ; return function ( files , metalsmith , done ) { set Immediate ( done ) ; Object . keys ( files ) . for Each ( function ( file ) { debug ( 'checking file : %s ' , file ) ; var data = files [ file ] ; var contents = data . contents . to String ( ) . replace ( / ^ \n + / g , ' ' ) ; debug ( 'storing untemplatized content : %s ' , file ) ; data [ options . key ] = new Buffer ( contents ) ; } ) ; } ; } 
function Latency Metric ( ) { if ( ! ( this instanceof Latency Metric ) ) { return new Latency Metric ( ) } Metric . call ( this ) this . key = 'latency ' this . default = [ 0 ] this . hooks = [ { trigger : 'before ' , event : 'send ' , handler : this . _start } , { trigger : 'before ' , event : 'receive ' , handler : this . _stop } ] this . _tests = { } set Interval ( this . _expire Timeouts . bind ( this ) , Latency Metric . TEST _TIMEOUT ) } 
function decode Result ( content Type , data Type , result ) { if ( data Type = = 'json ' ) { try { result = JSON . parse ( result ) ; return result ; } catch ( e ) { } } if ( content Type & & content Type . index Of ( 'application /json ' ) = = 0 ) { try { result = JSON . parse ( result ) ; } catch ( e ) { } } 
function default Map Fn ( data ) { return Object . keys ( data ) . slice ( 0 , this . headers . length ) . map ( function ( key ) { return data [ key ] } ) } 
function schedule Job ( trigger , job Func , job Data ) { const job = Job . create Job ( trigger , job Func , job Data ) ; const excute Time = job . excute Time ( ) ; const id = job . id ; map [ id ] = job ; const element = { id : id , time : excute Time } ; const cur Job = queue . peek ( ) ; if ( ! cur Job | | excute Time < cur Job . time ) { queue . offer ( element ) ; set Timer ( job ) ; return job . id ; } queue . offer ( element ) ; return job . id ; } 
function ( members ) { var member , name ; 
function ( members ) { var prototype = this . prototype , names = [ ] , name , member ; 
function ( members ) { var me = this , enumerables = Ext . enumerables , target = me . prototype , clone Function = Ext . Function . clone , current Config = target . config , name , index , member , statics , names , previous , new Config , prop ; if ( arguments . length = = = 2 ) { name = members ; members = { } ; members [ name ] = arguments [ 1 ] ; enumerables = null ; } do { names = [ ] ; 
function ( name , mixin Class ) { var mixin = mixin Class . prototype , prototype = this . prototype , key ; if ( typeof mixin . on Class Mixed In ! = 'undefined ' ) { mixin . on Class Mixed In . call ( mixin Class , this ) ; } if ( ! prototype . has Own Property ( 'mixins ' ) ) { if ( 'mixins ' in prototype ) { prototype . mixins = Ext . Object . chain ( prototype . mixins ) ; } else { prototype . mixins = { } ; } } for ( key in mixin ) { if ( key = = = 'mixins ' ) { Ext . merge ( prototype . mixins , mixin [ key ] ) ; } else if ( typeof prototype [ key ] = = 'undefined ' & & key ! = 'mixin Id ' & & key ! = 'config ' ) { prototype [ key ] = mixin [ key ] ; } } 
function ( args ) { var call Overridden Fn = this . call Overridden | | this . prototype . call Overridden , method = call Overridden Fn . caller , previous Method = method & & method . $previous ; if ( ! previous Method ) { return method . $return ; } return previous Method . apply ( this , args | | no Args ) ; } 
function ( instance Config ) { 
function define Type ( type , validator ) { var type Def ; var reg Key ; if ( type instanceof Function ) { validator = _custom Validator ( type ) ; type = type . name ; 
function undefine Type ( type ) { var validator ; var type Def = parse Type Def ( type ) ; var reg Key = type Def . name . to Locale Lower Case ( ) ; if ( primitives [ reg Key ] ) { throw Type Exception ( 'Cannot undefine primitive type ` { {type } } ` ' , null , null , { type : type Def . name } ) ; } validator = registry [ reg Key ] & & registry [ reg Key ] . validator ; delete registry [ reg Key ] ; return validator | | false ; } 
function check Type ( type , value , previous , attribute Name ) { var type Def = parse Type Def ( type ) ; var reg Key = type Def . name . to Locale Lower Case ( ) ; validator = primitives [ reg Key ] | | ( registry [ reg Key ] & & registry [ reg Key ] . validator ) ; if ( ! validator ) { throw Type Exception ( 'Unknown type ` { {type } } ` ' , null , [ attribute Name ] , { type : type Def . name } ) ; } else if ( type Def . indexes ) { return array Validation ( type Def , 0 , value , previous , attribute Name , validator ) ; } return validator ( value , previous , attribute Name ) ; } 
function get Defined Names ( ) { return Object . keys ( primitives ) . concat ( Object . keys ( registry ) . map ( function ( type ) { return registry [ type ] . type ; } ) ) ; } 
function array Validation ( type Def , index , value , previous , attribute Name , validator ) { var index Inc ; var i ; var ilen ; if ( value = = = null | | value = = = undefined | | type Def . indexes . length < = index ) { 
function ( comment ) { const is License = comment . to Lower Case ( ) . includes ( "license " ) | | comment . to Lower Case ( ) . includes ( "copyright " ) ; if ( is License = = = false ) { return false ; } if ( last License ! = = comment ) { last License = comment ; return true ; } else { return false ; } } 
function ctor ( k , v ) { if ( k & & _ . is String ( k ) & & k . index Of ( 'paths . ' ) = = = 0 ) return get . apply ( null , _ . to Array ( arguments ) ) return v ? set ( k , v ) : get ( k ) } 
function get ( k ) { if ( ! k ) return _SETTINGS let v = _ . get ( _SETTINGS , k ) if ( ! v ) return if ( _ . is String ( k ) & & k . index Of ( 'paths . ' ) ! = = 0 ) return v let args = _ . drop ( _ . to Array ( arguments ) ) let args Length = args . unshift ( v ) return path . join . apply ( path , args ) } 
function set ( k , v ) { let curr = get ( k ) if ( curr & & _ . is Plain Object ( curr ) & & _ . is Plain Object ( v ) ) v = _ . mcopy ( curr , v ) if ( k ) _ . set ( _SETTINGS , k , v ) if ( ! k ) _SETTINGS = v return get ( k ) } 
function load ( src ) { if ( ! src | | ! _ . is String ( src ) ) return let file = _ . attempt ( require , src ) if ( ! file | | _ . is Error ( file ) | | ! _ . is Plain Object ( file ) ) return return _ . merge ( _SETTINGS , file ) } 
function Sip Fake Stack ( config ) { if ( ! config . server ) { throw ' (Sip Fake Stack ) You need at least to specify a valid IPv 4 / 6 target ' ; } this . server = config . server | | null ; this . port = config . port | | 5 0 6 0 ; this . transport = config . transport | | 'UDP ' ; 
function ( size , units ) { 
function ( box ) { if ( typeof box ! = 'string ' ) { box = box . to String ( ) ; } var parts = box . split ( ' ' ) , ln = parts . length ; if ( ln = = 1 ) { parts [ 1 ] = parts [ 2 ] = parts [ 3 ] = parts [ 0 ] ; } else if ( ln = = 2 ) { parts [ 2 ] = parts [ 0 ] ; parts [ 3 ] = parts [ 1 ] ; } else if ( ln = = 3 ) { parts [ 3 ] = parts [ 1 ] ; } return { top : parts [ 0 ] | | 0 , right : parts [ 1 ] | | 0 , bottom : parts [ 2 ] | | 0 , left : parts [ 3 ] | | 0 } ; } 
function ( box , units ) { var me = this ; box = me . parse Box ( box ) ; return me . add Units ( box . top , units ) + ' ' + me . add Units ( box . right , units ) + ' ' + me . add Units ( box . bottom , units ) + ' ' + me . add Units ( box . left , units ) ; } 
function ( form ) { var f Elements = form . elements | | ( document . forms [ form ] | | Ext . get Dom ( form ) ) . elements , has Submit = false , encoder = encode URIComponent , name , data = ' ' , type , has Value ; Ext . each ( f Elements , function ( element ) { name = element . name ; type = element . type ; if ( ! element . disabled & & name ) { if ( / select - (one |multiple ) / i . test ( type ) ) { Ext . each ( element . options , function ( opt ) { if ( opt . selected ) { has Value = opt . has Attribute ? opt . has Attribute ( 'value ' ) : opt . get Attribute Node ( 'value ' ) . specified ; data + = Ext . String . format ( " { 0 } = { 1 } & " , encoder ( name ) , encoder ( has Value ? opt . value : opt . text ) ) ; } } ) ; } else if ( ! ( / file |undefined |reset |button / i . test ( type ) ) ) { if ( ! ( / radio |checkbox / i . test ( type ) & & ! element . checked ) & & ! ( type = = 'submit ' & & has Submit ) ) { data + = encoder ( name ) + ' = ' + encoder ( element . value ) + ' & ' ; has Submit = / submit / i . test ( type ) ; } } } } ) ; return data . substr ( 0 , data . length - 1 ) ; } 
function ( ) { 
function ( ) { 
function ( el , config ) { config = config | | { } ; Ext . apply ( this , config ) ; this . add Events ( 'sortstart ' , 'sortend ' , 'sortchange ' 
function ( ) { this . el . on ( this . start Event Name , this . on Start , this , { delegate : this . item Selector , hold Threshold : this . get Delay ( ) } ) ; this . disabled = false ; } 
function msum ( arr , W , options ) { var copy = true , clbk , len , sum , drop Val , out , i ; if ( ! is Array ( arr ) ) { throw new Type Error ( 'msum ( ) : :invalid input argument . Must provide an array . Value : ` ' + arr + ' ` . ' ) ; } if ( ! is Positive Integer ( W ) ) { throw new Type Error ( 'msum ( ) : :invalid input argument . Window must be a positive integer . Value : ` ' + W + ' ` . ' ) ; } if ( arguments . length > 2 ) { if ( ! is Object ( options ) ) { throw new Type Error ( 'msum ( ) : :invalid input argument . Options must be an object . Value : ` ' + options + ' ` . ' ) ; } if ( options . has Own Property ( 'accessor ' ) ) { clbk = options . accessor ; if ( ! is Function ( clbk ) ) { throw new Type Error ( 'msum ( ) : :invalid option . Accessor option must be a function . Value : ` ' + clbk + ' ` . ' ) ; } } if ( options . has Own Property ( 'copy ' ) ) { copy = options . copy ; if ( ! is Boolean ( copy ) ) { throw new Type Error ( 'msum ( ) : :invalid option . Copy option must be a boolean primitive . Value : ` ' + copy + ' ` . ' ) ; } } } if ( W > arr . length ) { throw new Error ( 'msum ( ) : :invalid input argument . Window cannot exceed the array length . ' ) ; } len = arr . length ; sum = 0 ; if ( copy & & ! clbk ) { 
function Request ( ghosttrain , route , url , options ) { 
function _compare Maps ( a , b , options ) { debug ( a , b ) ; let alength = a . size = = = undefined ? a . length : a . size ; let blength = b . size = = = undefined ? b . length : b . size ; if ( alength = = = 0 & & blength = = = 0 ) return ops . NOP ; 
function compare ( a , b , options ) { debug ( 'compare %j , %j options : %j ' , a , b , options ) ; options = Options . add Defaults ( options ) ; debug ( 'compare - options %j ' , options ) ; if ( a = = = b ) return ops . NOP ; if ( b = = = undefined ) return ops . DEL ; if ( a = = = undefined ) return new ops . Rpl ( b ) ; if ( typeof a = = = 'object ' & & typeof b = = = 'object ' ) { if ( utils . is Array Like ( a ) & & utils . is Array Like ( b ) ) { if ( options . map ) { return _compare Maps ( a , b , options ) ; } else { return _compare Arrays ( a , b , options ) ; } } else if ( a instanceof Map & & b instanceof Map ) { return _compare Maps ( a , b , options ) ; } else if ( a . constructor = = = b . constructor ) { 
function from JSON ( object ) { if ( object instanceof ops . Op ) return object ; 
function ( sorter Fn ) { var me = this , items = me . items , keys = me . keys , length = items . length , temp = [ ] , i ; 
function ( mapping ) { var me = this , items = me . items , index = 0 , length = items . length , order = [ ] , remaining = [ ] , old Index ; me . suspend Events ( ) ; 
function transpose ( mat , options ) { var strides , shape , opts , ctor , err , tmp , d ; if ( ! is Matrix Like ( mat ) ) { throw new Type Error ( 'transpose ( ) : :invalid input argument . First argument must be a matrix . Value : ` ' + mat + ' ` . ' ) ; } opts = { } ; if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } else { opts . copy = true ; } if ( opts . copy ) { 
function Queue ( q ) { events . Event Emitter . call ( this ) ; var self = this ; this . q = q & & q . process ? q : kue . create Queue ( ) ; this . q . process ( 'message ' , function ( message , done ) { self . emit ( 'message ' , message ) ; done ( ) ; } ) ; } 
function apply ( func , args , self ) { return ( typeof func = = = 'function ' ) ? func . apply ( self , array ( args ) ) : func } 
function detect Device Class ( ) { var body = document . body ; if ( is Mobile . any ( ) ) { body . class List . add ( 'mobile ' ) ; } if ( is Mobile . Android ( ) ) { body . class List . add ( 'android ' ) ; } if ( is Tablet . any ( ) ) { body . class List . add ( 'tablet ' ) ; } } 
function detect Window Width ( ) { var mobile Width = arguments . length > 0 & & arguments [ 0 ] ! = = undefined ? arguments [ 0 ] : 7 3 0 ; var is Mobile Width = window . inner Width < mobile Width ; var body = document . body ; if ( is Mobile Width ) { body . class List . add ( 'is -mobile -width ' ) ; } else { body . class List . remove ( 'is -mobile -width ' ) ; } } 
function ( config , callback , scope ) { var changed = false ; if ( config ) { config . config _id = 'csv ' ; Ext . data . CSV . superclass . constructor . call ( this , config ) ; if ( config . v ) { this . v = [ ] ; this . do _add ( config . v ) ; } } if ( this . v = = = undefined ) { this . v = [ ] ; changed = true ; } this . write And Callback ( changed , callback , scope ) ; } 
function add Virtual Ref ( schema , node , path ) { if ( _ . is Array ( node ) & & is Ref ( _ . first ( node ) ) ) { schema . virtual ( path + 'P ' ) . get ( function ( ) { if ( ! this [ path ] | | ! this [ path ] . length ) return Promise . resolve ( [ ] ) ; var model = this . constructor . db . model ( _ . first ( node ) . ref ) ; return find Async . call ( model , { $or : _ . map ( this [ path ] , function ( id ) { return { _id : id } ; } ) } ) ; } ) ; } else if ( is Ref ( node ) ) { schema . virtual ( path + 'P ' ) . get ( function ( ) { var model = this . constructor . db . model ( node . ref ) ; return find By Id Async . call ( model , this [ path ] ) ; } ) ; } } 
function create Topic ( options ) { var max = Number . MAX _VALUE , duplicates = false ; if ( ! options . has Own Property ( 'max ' ) ) { options . max = max ; } else { max = options . max ; } if ( ! options . has Own Property ( 'duplicates ' ) ) { options . duplicates = duplicates ; } else { duplicates = options . duplicates ; } if ( ! is Integer ( max ) | | max < 0 ) { throw new Type Error ( 'create Topic ( ) : :invalid option . Max subscribers must be an integer greater than or equal to 0 . ' ) ; } if ( typeof duplicates ! = = 'boolean ' ) { throw new Type Error ( 'create Topic ( ) : :invalid option . Duplicates flag must be a boolean . ' ) ; } return { 'subscribers ' : [ ] , 'options ' : options } ; } 
function load Module ( data , name ) { if ( typeof data ! = = 'object ' ) { return ; } 
function ( data ) { if ( data & & j Query . trim ( data ) ) { 
function ( elems , fn , key , value , chainable , empty Get , raw ) { var i = 0 , length = elems . length , bulk = key = = null ; 
function ( iteratee , events , name , callback , opts ) { var i = 0 , names ; if ( name & & typeof name = = = 'object ' ) { 
function ( array , insert , at ) { at = Math . min ( Math . max ( at , 0 ) , array . length ) ; var tail = Array ( array . length - at ) ; var length = insert . length ; for ( var i = 0 ; i < tail . length ; i + + ) tail [ i ] = array [ i + at ] ; for ( i = 0 ; i < length ; i + + ) array [ i + at ] = insert [ i ] ; for ( i = 0 ; i < tail . length ; i + + ) array [ i + length + at ] = tail [ i ] ; } 
function ( models , options ) { options = _ . extend ( { } , options ) ; var singular = ! _ . is Array ( models ) ; models = singular ? [ models ] : _ . clone ( models ) ; var removed = this . _remove Models ( models , options ) ; if ( ! options . silent & & removed ) this . trigger ( 'update ' , this , options ) ; return singular ? removed [ 0 ] : removed ; } 
function ( models , options ) { var removed = [ ] ; for ( var i = 0 ; i < models . length ; i + + ) { var model = this . get ( models [ i ] ) ; if ( ! model ) continue ; var index = this . index Of ( model ) ; this . models . splice ( index , 1 ) ; this . length - - ; if ( ! options . silent ) { options . index = index ; model . trigger ( 'remove ' , model , this , options ) ; } removed . push ( model ) ; this . _remove Reference ( model , options ) ; } return removed . length ? removed : false ; } 
function ( ) { var path = this . decode Fragment ( this . location . pathname ) ; var root = path . slice ( 0 , this . root . length - 1 ) + ' / ' ; return root = = = this . root ; } 
function ( ) { if ( ! performance Timeline Requires Sort ) { return ; } 
function get Template Data ( template Prop , view , view Options ) { var data ; if ( template Prop & & _ . is String ( template Prop ) ) { data = template Cache [ template Prop ] ; if ( ! data ) data = _create Template Cache ( template Prop , view , view Options ) ; if ( data . invalid ) data = undefined ; if ( data ) data = _copy Cache Entry ( data ) ; } return data ; } 
function get View Template Data ( view , view Options ) { var data , meta = view . declarative Views . meta ; if ( ! meta . processed ) { if ( view . template & & _ . is String ( view . template ) ) { meta . original Template Prop = view . template ; data = get Template Data ( view . template , view , view Options ) ; meta . processed = true ; meta . in Global Cache = true ; if ( data ) events . trigger ( "cache Entry :view :process " , _copy Cache Entry ( data ) , meta . original Template Prop , view , view Options ) ; } else { data = undefined ; meta . processed = true ; meta . in Global Cache = false ; } } else { data = meta . in Global Cache ? get Template Data ( meta . original Template Prop , view , view Options ) : undefined ; } if ( data ) events . trigger ( "cache Entry :view :fetch " , data , meta . original Template Prop , view , view Options ) ; return data ; } 
function clear Cache ( from Marionette ) { template Cache = { } ; if ( ! from Marionette & & Backbone . Marionette & & Backbone . Marionette . Template Cache ) Backbone . Marionette . Template Cache . clear ( ) ; } 
function clear Cached Template ( template Prop ) { var from Marionette = false , args = _ . to Array ( arguments ) , last Arg = _ . last ( args ) ; 
function clear View Template Cache ( view ) { var meta = view . declarative Views . meta ; if ( meta . processed ) { if ( meta . in Global Cache ) _clear Cached Template ( meta . original Template Prop ) ; } else if ( view . template & & _ . is String ( view . template ) ) { _clear Cached Template ( view . template ) ; } } 
function load Template ( template Property ) { var $template ; try { $template = $ ( template Property ) ; 
function _wrap Raw Template ( template String ) { var $wrapper = $ ( " <script / > " ) . attr ( "type " , "text /x -template " ) . text ( template String ) , el Data Attributes = _get Embedded El Attributes ( template String ) ; if ( el Data Attributes ) $wrapper . attr ( el Data Attributes ) ; return $wrapper ; } 
function _get Embedded El Attributes ( template String ) { var el Data Attributes = { } , el Definition Match = rx El Definition Comment . exec ( template String ) , el Definition Comment = el Definition Match & & el Definition Match [ 0 ] ; if ( el Definition Comment ) { _ . each ( rx Registered Data Attributes , function ( rx Attribute Matcher , attribute Name ) { var match = rx Attribute Matcher . exec ( el Definition Comment ) , attribute Value = match & & match [ 2 ] ; if ( attribute Value ) el Data Attributes [ attribute Name ] = attribute Value ; } ) ; } return _ . size ( el Data Attributes ) ? el Data Attributes : undefined ; } 
function _copy Cache Entry ( cache Entry ) { var copy = _ . clone ( cache Entry ) ; if ( _ . is Object ( copy . attributes ) ) copy . attributes = _ . clone ( copy . attributes ) ; return copy ; } 
function _create Template Cache ( template Prop , view , view Options ) { var $template , data , html , custom Loader = Backbone . Declarative Views . custom . load Template , default Loader = Backbone . Declarative Views . defaults . load Template , modified Default Loader = default Loader ! = = load Template , cache Id = template Prop ; 
function _try Compile Template ( html , $template ) { var compiled , custom Compiler = Backbone . Declarative Views . custom . compiler ; if ( custom Compiler ) { if ( custom Compiler & & ! _ . is Function ( custom Compiler ) ) throw new Customization Error ( "Invalid custom template compiler set in Backbone .Declarative Views .custom .compiler : compiler is not a function " ) ; try { compiled = custom Compiler ( html , $template ) ; } catch ( err ) { throw new Compiler Error ( 'An error occurred while compiling the template . The compiler had been passed the HTML string " ' + html + ( $template ? ' " as the first argument , and the corresponding template node , wrapped in a j Query object , as the second argument . ' : ' " as the only argument . ' ) + " \n Original error thrown by the compiler : \n " + err . message ) ; } } return compiled ; } 
function _register Data Attribute ( name , options ) { var existing Names = _get Registered Data Attribute Names ( ) , full Name = "data - " + name , type = options & & options . is JSON ? "json " : "primitives " , names = registered Data Attributes [ type ] ; if ( name . index Of ( "data - " ) = = = 0 ) throw new Customization Error ( 'register Data Attribute ( ) : Illegal attribute name " ' + name + ' " , must be registered without "data - " prefix ' ) ; if ( name = = = "html " | | name = = = "compiled " ) throw new Customization Error ( 'register Data Attribute ( ) : Cannot register attribute name " ' + name + ' " because it is reserved ' ) ; if ( _ . contains ( existing Names , name ) ) throw new Customization Error ( 'register Data Attribute ( ) : Cannot register attribute name " ' + name + ' " because it has already been registered ' ) ; 
function _update JQuery Data Cache ( $elem ) { var add = { } , remove = [ ] ; if ( $ . has Data ( $elem [ 0 ] ) ) { 
function _register Cache Alias ( namespace Object , instance Cache Property Name ) { namespace Object . get Cached Template = Backbone . Declarative Views . get Cached Template ; namespace Object . clear Cached Template = Backbone . Declarative Views . clear Cached Template ; namespace Object . clear Cache = Backbone . Declarative Views . clear Cache ; namespace Object . custom = Backbone . Declarative Views . custom ; if ( instance Cache Property Name ) { instance Cache Aliases . push ( instance Cache Property Name ) ; instance Cache Aliases = _ . unique ( instance Cache Aliases ) ; } } 
function _is Declarative Views Error Type ( error ) { return error instanceof Generic Error | | error instanceof Template Error | | error instanceof Compiler Error | | error instanceof Customization Error | | error instanceof Configuration Error ; } 
function join Marionette ( ) { if ( Backbone . Marionette & & Backbone . Marionette . Template Cache & & ! is Marionette Initialized ) { original Clear Cache = Backbone . Marionette . Template Cache . clear ; 
function create Custom Error Type ( name ) { function Custom Error ( message ) { this . message = message ; if ( Error . capture Stack Trace ) { Error . capture Stack Trace ( this , this . constructor ) ; } else { this . stack = ( new Error ( ) ) . stack ; } } Custom Error . prototype = new Error ( ) ; Custom Error . prototype . name = name ; Custom Error . prototype . constructor = Custom Error ; return Custom Error ; } 
function ( name ) { var config = this . _wreqr Handlers [ name ] ; if ( ! config ) { return ; } return function ( ) { return config . callback . apply ( config . context , arguments ) ; } ; } 
function ( name ) { name = arguments [ 0 ] ; var args = _ . rest ( arguments ) ; if ( this . has Handler ( name ) ) { this . get Handler ( name ) . apply ( this , args ) ; } else { this . storage . add Command ( name , args ) ; } } 
function ( type , hash , context ) { if ( ! hash ) { return ; } context = context | | this ; var method = type = = = "vent " ? "on " : "set Handler " ; _ . each ( hash , function ( fn , event Name ) { this [ type ] [ method ] ( event Name , _ . bind ( fn , context ) ) ; } , this ) ; } 
function trigger DOMRefresh ( ) { if ( view . _is Shown & & view . _is Rendered & & Marionette . is Node Attached ( view . el ) ) { Marionette . trigger Method On ( view , 'dom :refresh ' , view ) ; } } 
function iterate Events ( target , entity , bindings , function Callback , string Callback ) { if ( ! entity | | ! bindings ) { return ; } 
function ( callback , context Override ) { var promise = _ . result ( this . _deferred , 'promise ' ) ; this . _callbacks . push ( { cb : callback , ctx : context Override } ) ; promise . then ( function ( args ) { if ( context Override ) { args . context = context Override ; } callback . call ( args . context , args . options ) ; } ) ; } 
function ( view , options ) { if ( ! this . _ensure Element ( ) ) { return ; } this . _ensure View Is Intact ( view ) ; Marionette . Monitor DOMRefresh ( view ) ; var show Options = options | | { } ; var is Different View = view ! = = this . current View ; var prevent Destroy = ! ! show Options . prevent Destroy ; var force Show = ! ! show Options . force Show ; 
function ( options ) { var view = this . current View ; var empty Options = options | | { } ; var prevent Destroy = ! ! empty Options . prevent Destroy ; 
function ( ) { var view = this . current View ; if ( view . is Destroyed ) { return ; } if ( ! view . supports Destroy Lifecycle ) { Marionette . trigger Method On ( view , 'before :destroy ' , view ) ; } if ( view . destroy ) { view . destroy ( ) ; } else { view . remove ( ) ; 
function ( region Config , Default Region Class ) { if ( _ . is String ( region Config ) ) { return this . _build Region From Selector ( region Config , Default Region Class ) ; } if ( region Config . selector | | region Config . el | | region Config . region Class ) { return this . _build Region From Object ( region Config , Default Region Class ) ; } if ( _ . is Function ( region Config ) ) { return this . _build Region From Region Class ( region Config ) ; } throw new Marionette . Error ( { message : 'Improper region configuration type . ' , url : 'marionette .region .html #region -configuration -types ' } ) ; } 
function ( region Config , Default Region Class ) { var Region Class = region Config . region Class | | Default Region Class ; var options = _ . omit ( region Config , 'selector ' , 'region Class ' ) ; if ( region Config . selector & & ! options . el ) { options . el = region Config . selector ; } return new Region Class ( options ) ; } 
function ( region Definitions , defaults ) { region Definitions = Marionette . _get Value ( region Definitions , this , arguments ) ; return _ . reduce ( region Definitions , function ( regions , definition , name ) { if ( _ . is String ( definition ) ) { definition = { selector : definition } ; } if ( definition . selector ) { definition = _ . defaults ( { } , definition , defaults ) ; } regions [ name ] = this . add Region ( name , definition ) ; return regions ; } , { } , this ) ; } 
function ( name , definition ) { var region ; if ( definition instanceof Marionette . Region ) { region = definition ; } else { region = Marionette . Region . build Region ( definition , Marionette . Region ) ; } this . trigger Method ( 'before :add :region ' , name , region ) ; region . _parent = this ; this . _store ( name , region ) ; this . trigger Method ( 'add :region ' , name , region ) ; return region ; } 
function ( ) { var regions = this . get Regions ( ) ; _ . each ( this . _regions , function ( region , name ) { this . _remove ( name , region ) ; } , this ) ; return regions ; } 
function ( name , region ) { this . trigger Method ( 'before :remove :region ' , name , region ) ; region . empty ( ) ; region . stop Listening ( ) ; delete region . _parent ; delete this . _regions [ name ] ; this . length - - ; this . trigger Method ( 'remove :region ' , name , region ) ; } 
function ( template Id , options ) { var cached Template = this . template Caches [ template Id ] ; if ( ! cached Template ) { cached Template = new Marionette . Template Cache ( template Id ) ; this . template Caches [ template Id ] = cached Template ; } return cached Template . load ( options ) ; } 
function ( ) { var i ; var args = _ . to Array ( arguments ) ; var length = args . length ; if ( length > 0 ) { for ( i = 0 ; i < length ; i + + ) { delete this . template Caches [ args [ i ] ] ; } } else { this . template Caches = { } ; } } 
function ( options ) { 
function ( template Id , options ) { var $template = Backbone . $ ( template Id ) ; if ( ! $template . length ) { throw new Marionette . Error ( { name : 'No Template Error ' , message : 'Could not find template : " ' + template Id + ' " ' } ) ; } return $template . html ( ) ; } 
function ( template , data ) { if ( ! template ) { throw new Marionette . Error ( { name : 'Template Not Found Error ' , message : 'Cannot render the template since its false , null or undefined . ' } ) ; } var template Func = _ . is Function ( template ) ? template : Marionette . Template Cache . get ( template ) ; return template Func ( data ) ; } 
function ( target ) { target = target | | { } ; var template Helpers = this . get Option ( 'template Helpers ' ) ; template Helpers = Marionette . _get Value ( template Helpers , this ) ; return _ . extend ( target , template Helpers ) ; } 
function ( hash ) { var ui Bindings = _ . result ( this , ' _ui Bindings ' ) ; return Marionette . normalize UIKeys ( hash , ui Bindings | | _ . result ( this , 'ui ' ) ) ; } 
function ( hash , properties ) { var ui = _ . result ( this , 'ui ' ) ; var ui Bindings = _ . result ( this , ' _ui Bindings ' ) ; return Marionette . normalize UIValues ( hash , ui Bindings | | ui , properties ) ; } 
function ( ) { if ( ! this . triggers ) { return ; } 
function ( events ) { this . _delegate DOMEvents ( events ) ; this . bind Entity Events ( this . model , this . get Option ( 'model Events ' ) ) ; this . bind Entity Events ( this . collection , this . get Option ( 'collection Events ' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . bind Entity Events ( this . model , behavior . get Option ( 'model Events ' ) ) ; behavior . bind Entity Events ( this . collection , behavior . get Option ( 'collection Events ' ) ) ; } , this ) ; return this ; } 
function ( events Arg ) { var events = Marionette . _get Value ( events Arg | | this . events , this ) ; 
function ( ) { Backbone . View . prototype . undelegate Events . apply ( this , arguments ) ; this . unbind Entity Events ( this . model , this . get Option ( 'model Events ' ) ) ; this . unbind Entity Events ( this . collection , this . get Option ( 'collection Events ' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . unbind Entity Events ( this . model , behavior . get Option ( 'model Events ' ) ) ; behavior . unbind Entity Events ( this . collection , behavior . get Option ( 'collection Events ' ) ) ; } , this ) ; return this ; } 
function ( ) { if ( this . is Destroyed ) { return this ; } var args = _ . to Array ( arguments ) ; this . trigger Method . apply ( this , [ 'before :destroy ' ] . concat ( args ) ) ; 
function ( ) { if ( ! this . ui ) { return ; } 
function ( trigger Def ) { var options = _ . defaults ( { } , trigger Def , { prevent Default : true , stop Propagation : true } ) ; var event Name = _ . is Object ( trigger Def ) ? options . event : trigger Def ; return function ( e ) { if ( e ) { if ( e . prevent Default & & options . prevent Default ) { e . prevent Default ( ) ; } if ( e . stop Propagation & & options . stop Propagation ) { e . stop Propagation ( ) ; } } var args = { view : this , model : this . model , collection : this . collection } ; this . trigger Method ( event Name , args ) ; } ; } 
function ( ) { var ret = Marionette . _trigger Method ( this , arguments ) ; this . _trigger Event On Behaviors ( arguments ) ; this . _trigger Event On Parent Layout ( arguments [ 0 ] , _ . rest ( arguments ) ) ; return ret ; } 
function ( ) { var children = this . _get Immediate Children ( ) ; if ( ! children . length ) { return children ; } return _ . reduce ( children , function ( memo , view ) { if ( ! view . _get Nested Views ) { return memo ; } return memo . concat ( view . _get Nested Views ( ) ) ; } , children ) ; } 
function ( ) { var parent = this . _parent ; while ( parent ) { if ( parent instanceof Marionette . Layout View ) { return parent ; } parent = parent . _parent ; } } 
function ( ) { if ( ! this . model & & ! this . collection ) { return { } ; } var args = [ this . model | | this . collection ] ; if ( arguments . length ) { args . push . apply ( args , arguments ) ; } if ( this . model ) { return this . serialize Model . apply ( this , args ) ; } else { return { items : this . serialize Collection . apply ( this , args ) } ; } } 
function ( ) { var template = this . get Template ( ) ; 
function ( options ) { this . once ( 'render ' , this . _initial Events ) ; this . _init Child View Storage ( ) ; Marionette . View . apply ( this , arguments ) ; this . on ( { 'before :show ' : this . _on Before Show Called , 'show ' : this . _on Show Called , 'before :attach ' : this . _on Before Attach Called , 'attach ' : this . _on Attach Called } ) ; this . init Render Buffer ( ) ; } 
function ( ) { if ( this . collection ) { this . listen To ( this . collection , 'add ' , this . _on Collection Add ) ; this . listen To ( this . collection , 'remove ' , this . _on Collection Remove ) ; this . listen To ( this . collection , 'reset ' , this . render ) ; if ( this . get Option ( 'sort ' ) ) { this . listen To ( this . collection , 'sort ' , this . _sort Views ) ; } } } 
function ( child , collection , opts ) { 
function ( ) { var children = this . children ; var models = this . _filtered Sorted Models ( ) ; if ( ! models . length & & this . _showing Empty View ) { return this ; } var any Models Added = _ . some ( models , function ( model ) { return ! children . find By Model ( model ) ; } ) ; 
function ( ) { var models = this . _filtered Sorted Models ( ) ; 
function ( ) { this . destroy Empty View ( ) ; this . destroy Children ( { check Empty : false } ) ; if ( this . is Empty ( this . collection ) ) { this . show Empty View ( ) ; } else { this . trigger Method ( 'before :render :collection ' , this ) ; this . start Buffering ( ) ; this . show Collection ( ) ; this . end Buffering ( ) ; this . trigger Method ( 'render :collection ' , this ) ; 
function ( ) { var Child View ; var models = this . _filtered Sorted Models ( ) ; _ . each ( models , function ( child , index ) { Child View = this . get Child View ( child ) ; this . add Child ( child , Child View , index ) ; } , this ) ; } 
function ( added At ) { var view Comparator = this . get View Comparator ( ) ; var models = this . collection . models ; added At = Math . min ( Math . max ( added At , 0 ) , models . length - 1 ) ; if ( view Comparator ) { var added Model ; 
function ( ) { var Empty View = this . get Empty View ( ) ; if ( Empty View & & ! this . _showing Empty View ) { this . trigger Method ( 'before :render :empty ' ) ; this . _showing Empty View = true ; var model = new Backbone . Model ( ) ; this . add Empty View ( model , Empty View ) ; this . trigger Method ( 'render :empty ' ) ; } } 
function ( child , Empty View ) { 
function ( child , Child View , index ) { var child View Options = this . get Option ( 'child View Options ' ) ; child View Options = Marionette . _get Value ( child View Options , this , [ child , index ] ) ; var view = this . build Child View ( child , Child View , child View Options ) ; 
function ( view , increment , index ) { if ( ! this . get Option ( 'sort ' ) ) { return ; } if ( increment ) { 
function ( view , index ) { 
function ( view , index ) { if ( ! view . supports Render Lifecycle ) { Marionette . trigger Method On ( view , 'before :render ' , view ) ; } view . render ( ) ; if ( ! view . supports Render Lifecycle ) { Marionette . trigger Method On ( view , 'render ' , view ) ; } this . attach Html ( this , view , index ) ; return view ; } 
function ( child , Child View Class , child View Options ) { var options = _ . extend ( { model : child } , child View Options ) ; var child View = new Child View Class ( options ) ; Marionette . Monitor DOMRefresh ( child View ) ; return child View ; } 
function ( view ) { if ( ! view ) { return view ; } this . trigger Method ( 'before :remove :child ' , view ) ; if ( ! view . supports Destroy Lifecycle ) { Marionette . trigger Method On ( view , 'before :destroy ' , view ) ; } 
function ( ) { var el Buffer = document . create Document Fragment ( ) ; _ . each ( this . _buffered Children , function ( b ) { el Buffer . append Child ( b . el ) ; } ) ; return el Buffer ; } 
function ( collection View , child View , index ) { if ( collection View . is Buffering ) { 
function ( child View , index ) { var current View ; var find Position = this . get Option ( 'sort ' ) & & ( index < this . children . length - 1 ) ; if ( find Position ) { 
function ( ) { if ( this . is Destroyed ) { return this ; } this . trigger Method ( 'before :destroy :collection ' ) ; this . destroy Children ( { check Empty : false } ) ; this . trigger Method ( 'destroy :collection ' ) ; return Marionette . View . prototype . destroy . apply ( this , arguments ) ; } 
function ( options ) { var destroy Options = options | | { } ; var should Check Empty = true ; var child Views = this . children . map ( _ . identity ) ; if ( ! _ . is Undefined ( destroy Options . check Empty ) ) { should Check Empty = destroy Options . check Empty ; } this . children . each ( this . remove Child View , this ) ; if ( should Check Empty ) { this . check Empty ( ) ; } return child Views ; } 
function ( child , index ) { var filter = this . get Option ( 'filter ' ) ; return ! _ . is Function ( filter ) | | filter . call ( this , child , index , this . collection ) ; } 
function ( view ) { var prefix = this . get Option ( 'child View Event Prefix ' ) ; 
function ( ) { 
function ( ) { var data = { } ; if ( this . model ) { data = _ . partial ( this . serialize Model , this . model ) . apply ( this , arguments ) ; } return data ; } 
function ( ) { this . _ensure View Is Intact ( ) ; this . _is Rendering = true ; this . reset Child View Container ( ) ; this . trigger Method ( 'before :render ' , this ) ; this . _render Template ( ) ; this . _render Children ( ) ; this . _is Rendering = false ; this . is Rendered = true ; this . trigger Method ( 'render ' , this ) ; return this ; } 
function ( ) { var data = { } ; data = this . serialize Data ( ) ; data = this . mixin Template Helpers ( data ) ; this . trigger Method ( 'before :render :template ' ) ; var template = this . get Template ( ) ; var html = Marionette . Renderer . render ( template , data , this ) ; this . attach El Content ( html ) ; 
function ( container View , child View ) { if ( ! ! container View . $child View Container ) { return container View . $child View Container ; } var container ; var child View Container = Marionette . get Option ( container View , 'child View Container ' ) ; if ( child View Container ) { var selector = Marionette . _get Value ( child View Container , container View ) ; if ( selector . char At ( 0 ) = = = ' @ ' & & container View . ui ) { container = container View . ui [ selector . substr ( 4 ) ] ; } else { container = container View . $ ( selector ) ; } if ( container . length < = 0 ) { throw new Marionette . Error ( { name : 'Child View Container Missing Error ' , message : 'The specified "child View Container " was not found : ' + container View . child View Container } ) ; } } else { container = container View . $el ; } container View . $child View Container = container ; return container ; } 
function ( options ) { options = options | | { } ; this . _first Render = true ; this . _initialize Regions ( options ) ; Marionette . Item View . call ( this , options ) ; } 
function ( ) { this . _ensure View Is Intact ( ) ; if ( this . _first Render ) { 
function ( ) { if ( this . is Destroyed ) { return this ; } 
function ( regions ) { var defaults = { region Class : this . get Option ( 'region Class ' ) , parent El : _ . partial ( _ . result , this , 'el ' ) } ; return this . region Manager . add Regions ( regions , defaults ) ; } 
function ( options ) { var regions ; this . _init Region Manager ( ) ; regions = Marionette . _get Value ( this . regions , this , [ options ] ) | | { } ; 
function ( ) { this . region Manager = this . get Region Manager ( ) ; this . region Manager . _parent = this ; this . listen To ( this . region Manager , 'before :add :region ' , function ( name ) { this . trigger Method ( 'before :add :region ' , name ) ; } ) ; this . listen To ( this . region Manager , 'add :region ' , function ( name , region ) { this [ name ] = region ; this . trigger Method ( 'add :region ' , name , region ) ; } ) ; this . listen To ( this . region Manager , 'before :remove :region ' , function ( name ) { this . trigger Method ( 'before :remove :region ' , name ) ; } ) ; this . listen To ( this . region Manager , 'remove :region ' , function ( name , region ) { delete this [ name ] ; this . trigger Method ( 'remove :region ' , name , region ) ; } ) ; } 
function ( options , key ) { if ( options . behavior Class ) { return options . behavior Class ; } 
function ( view , behaviors ) { return _ . chain ( behaviors ) . map ( function ( options , key ) { var Behavior Class = Behaviors . get Behavior Class ( options , key ) ; var behavior = new Behavior Class ( options , view ) ; var nested Behaviors = Behaviors . parse Behaviors ( view , _ . result ( behavior , 'behaviors ' ) ) ; return [ behavior ] . concat ( nested Behaviors ) ; } ) . flatten ( ) . value ( ) ; } 
function ( view , behaviors , method Names ) { _ . each ( method Names , function ( method Name ) { view [ method Name ] = _ . partial ( methods [ method Name ] , view [ method Name ] , behaviors ) ; } ) ; } 
function ( behavior , i ) { var triggers Hash = _ . clone ( _ . result ( behavior , 'triggers ' ) ) | | { } ; triggers Hash = Marionette . normalize UIKeys ( triggers Hash , get Behaviors UI ( behavior ) ) ; _ . each ( triggers Hash , _ . bind ( this . _set Handler For Behavior , this , behavior , i ) ) ; } 
function ( behavior , i , event Name , trigger ) { 
function ( route Name , route Args ) { 
function ( module Names , module Definition ) { 
function ( options ) { var regions = _ . is Function ( this . regions ) ? this . regions ( options ) : this . regions | | { } ; this . _init Region Manager ( ) ; 
function ( ) { this . _region Manager = this . get Region Manager ( ) ; this . _region Manager . _parent = this ; this . listen To ( this . _region Manager , 'before :add :region ' , function ( ) { Marionette . _trigger Method ( this , 'before :add :region ' , arguments ) ; } ) ; this . listen To ( this . _region Manager , 'add :region ' , function ( name , region ) { this [ name ] = region ; Marionette . _trigger Method ( this , 'add :region ' , arguments ) ; } ) ; this . listen To ( this . _region Manager , 'before :remove :region ' , function ( ) { Marionette . _trigger Method ( this , 'before :remove :region ' , arguments ) ; } ) ; this . listen To ( this . _region Manager , 'remove :region ' , function ( name ) { delete this [ name ] ; Marionette . _trigger Method ( this , 'remove :region ' , arguments ) ; } ) ; } 
function ( ) { this . channel Name = _ . result ( this , 'channel Name ' ) | | 'global ' ; this . channel = _ . result ( this , 'channel ' ) | | Backbone . Wreqr . radio . channel ( this . channel Name ) ; this . vent = _ . result ( this , 'vent ' ) | | this . channel . vent ; this . commands = _ . result ( this , 'commands ' ) | | this . channel . commands ; this . reqres = _ . result ( this , 'reqres ' ) | | this . channel . reqres ; } 
function ( ) { 
function ( definition , custom Args ) { 
function ( app , module Names , module Definition ) { var module = app ; 
function ( module Definition ) { var Module Class = Marionette . Module ; if ( ! module Definition ) { return Module Class ; } 
function ( parent Module , module , def , args ) { var fn = this . _get Define ( def ) ; var start With Parent = this . _get Start With Parent ( def , module ) ; if ( fn ) { module . add Definition ( fn , args ) ; } this . _add Start With Parent ( parent Module , module , start With Parent ) ; } 
function _sig Name ( src ) { if ( ! _ . is Function ( src ) ) return ' ' let ret = _ . trim ( _ . replace ( src . to String ( ) , 'function ' , ' ' ) ) ret = ret . substr ( 0 , ret . index Of ( ' ( ' ) ) return ret | | ' ' } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext .device .filesystem #request File System : You must specify a `success ` callback . ' ) ; return null ; } var me = this ; var success Callback = function ( fs ) { var file System = Ext . create ( 'Ext .device .filesystem .File System ' , fs ) ; config . success . call ( config . scope | | me , file System ) ; } ; window . request File System ( config . type , config . size , success Callback , config . failure | | Ext . empty Fn ) ; } 
function ( ) { var components = this . path . split ( ' / ' ) ; for ( var i = components . length - 1 ; i > = 0 ; - - i ) { if ( components [ i ] . length > 0 ) { return components [ i ] ; } } return ' / ' ; } 
function ( config ) { if ( config . parent = = null ) { Ext . Logger . error ( 'Ext .device .filesystem .Entry #move To : You must specify a new `parent ` of the entry . ' ) ; return null ; } var me = this ; this . get Entry ( { options : config . options | | { } , success : function ( source Entry ) { config . parent . get Entry ( { options : config . options | | { } , success : function ( destination Entry ) { if ( config . copy ) { source Entry . copy To ( destination Entry , config . new Name , function ( entry ) { config . success . call ( config . scope | | me , entry . is Directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , entry . full Path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , entry . full Path , me . file System ) ) ; } , config . failure ) ; } else { source Entry . move To ( destination Entry , config . new Name , function ( entry ) { config . success . call ( config . scope | | me , entry . is Directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , entry . full Path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , entry . full Path , me . file System ) ) ; } , config . failure ) ; } } , failure : config . failure } ) ; } , failure : config . failure } ) ; } 
function ( config ) { this . get Entry ( { success : function ( entry ) { if ( config . recursively & & this . directory ) { entry . remove Recursively ( config . success , config . failure ) } else { entry . remove ( config . success , config . failure ) } } , failure : config . failure } ) } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext .device .filesystem .Entry #get Parent : You must specify a `success ` callback . ' ) ; return null ; } var me = this ; this . get Entry ( { options : config . options | | { } , success : function ( entry ) { entry . get Parent ( function ( parent Entry ) { config . success . call ( config . scope | | me , parent Entry . is Directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , parent Entry . full Path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , parent Entry . full Path , me . file System ) ) } , config . failure ) } , failure : config . failure } ) } 
function ( config ) { var me = this ; var callback = config . success ; if ( ( config . options & & config . options . create ) & & this . path ) { var folders = this . path . split ( " / " ) ; if ( folders [ 0 ] = = ' . ' | | folders [ 0 ] = = ' ' ) { folders = folders . slice ( 1 ) ; } var recursive Creation = function ( dir Entry ) { if ( folders . length ) { dir Entry . get Directory ( folders . shift ( ) , config . options , recursive Creation , config . failure ) ; } else { callback ( dir Entry ) ; } } ; recursive Creation ( this . file System . fs . root ) ; } else { this . file System . fs . root . get Directory ( this . path , config . options , function ( directory ) { config . success . call ( config . scope | | me , directory ) ; } , config . failure ) ; } } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext .device .filesystem .Directory Entry #read Entries : You must specify a `success ` callback . ' ) ; return null ; } var me = this ; this . get Entry ( { success : function ( dir Entry ) { var directory Reader = dir Entry . create Reader ( ) ; directory Reader . read Entries ( function ( entry Infos ) { var entries = [ ] , i = 0 , len = entry Infos . length ; for ( ; i < len ; i + + ) { entry Info = entry Infos [ i ] ; entries [ i ] = entry Info . is Directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , entry Info . full Path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , entry Info . full Path , me . file System ) ; } config . success . call ( config . scope | | this , entries ) ; } , function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } ) ; } , failure : config . failure } ) ; } 
function ( config ) { if ( config . path = = null ) { Ext . Logger . error ( 'Ext .device .filesystem .Directory Entry #get File : You must specify a `path ` of the file . ' ) ; return null ; } var me = this ; var full Path = this . path + config . path ; var directory Entry = Ext . create ( 'Ext .device .filesystem .Directory Entry ' , full Path , this . file System ) ; directory Entry . get Entry ( { success : function ( ) { config . success . call ( config . scope | | me , directory Entry ) ; } , options : config . options | | { } , failure : config . failure } ) } 
function ( config ) { var me = this ; var original Config = Ext . apply If ( { } , config ) ; if ( this . file System ) { var failure = function ( evt ) { if ( ( config . options & & config . options . create ) & & Ext . is String ( this . path ) ) { var folders = this . path . split ( " / " ) ; if ( folders [ 0 ] = = ' . ' | | folders [ 0 ] = = ' ' ) { folders = folders . slice ( 1 ) ; } if ( folders . length > 1 & & ! config . recursive = = = true ) { folders . pop ( ) ; var dir Entry = Ext . create ( 'Ext .device .filesystem .Directory Entry ' , folders . join ( " / " ) , me . file System ) ; dir Entry . get Entry ( { options : config . options , success : function ( ) { original Config . recursive = true ; me . get Entry ( original Config ) ; } , failure : config . failure } ) ; } else { if ( config . failure ) { config . failure . call ( config . scope | | me , evt ) ; } } } else { if ( config . failure ) { config . failure . call ( config . scope | | me , evt ) ; } } } ; this . file System . fs . root . get File ( this . path , config . options | | null , function ( file Entry ) { file Entry . file ( function ( file ) { me . length = file . size ; original Config . success . call ( config . scope | | me , file Entry ) ; } , function ( error ) { failure . call ( config . scope | | me , error ) ; } ) ; } , function ( error ) { failure . call ( config . scope | | me , error ) ; } ) ; } else { config . failure ( { code : - 1 , message : "File System not Initialized " } ) ; } } 
function ( config ) { if ( config . offset = = null ) { Ext . Logger . error ( 'Ext .device .filesystem .File Entry #seek : You must specify an `offset ` in the file . ' ) ; return null ; } this . offset = config . offset | | 0 ; if ( config . success ) { config . success . call ( config . scope | | this ) ; } } 
function ( config ) { var me = this ; this . get Entry ( { success : function ( file Entry ) { file Entry . file ( function ( file ) { if ( Ext . is Number ( config . length ) ) { if ( Ext . is Function ( file . slice ) ) { file = file . slice ( me . offset , config . length ) ; } else { if ( config . failure ) { config . failure . call ( config . scope | | me , { code : - 2 , message : "File missing slice functionality " } ) ; } return ; } } var reader = new File Reader ( ) ; reader . onloadend = function ( evt ) { config . success . call ( config . scope | | me , evt . target . result ) ; } ; reader . onerror = function ( error ) { config . failure . call ( config . scope | | me , error ) ; } ; if ( config . reader ) { reader = Ext . apply If ( reader , config . reader ) ; } config . encoding = config . encoding | | "UTF 8 " ; switch ( config . type ) { default : case "text " : reader . read As Text ( file , config . encoding ) ; break ; case "data URL " : reader . read As Data URL ( file ) ; break ; case "binary String " : reader . read As Binary String ( file ) ; break ; case "array Buffer " : reader . read As Array Buffer ( file ) ; break ; } } , function ( error ) { config . failure . call ( config . scope | | me , error ) } ) ; } , failure : function ( error ) { config . failure . call ( config . scope | | me , error ) } } ) } 
function ( config ) { if ( config . size = = null ) { Ext . Logger . error ( 'Ext .device .filesystem .File Entry #write : You must specify a `size ` of the file . ' ) ; return null ; } var me = this ; 
function ( obj ) { const keys = _ . sort By ( _ . keys ( obj ) , function ( key ) { return key ; } ) ; return _ . zip Object ( keys , _ . map ( keys , function ( key ) { return obj [ key ] ; } ) ) ; } 
function ( err ) { if ( err ) return done ( err ) ; var ret ; if ( typeof leave = = 'function ' ) { try { ret = leave . call ( this , child , parent ) ; } catch ( err ) { return done ( err ) ; } } done ( null , ret ) ; } 
function Multi Key Cache ( options ) { options = options | | { } ; var self = this ; var dispose = options . dispose ; options . dispose = function ( key , value ) { self . _dispose ( key ) ; if ( dispose ) { dispose ( key , value ) ; } } ; this . cache = new LRU ( options ) ; this . _key Map = { } ; } 
function curry ( len , f ) { for ( var _len = arguments . length , init Args = Array ( _len > 2 ? _len - 2 : 0 ) , _key = 2 ; _key < _len ; _key + + ) { init Args [ _key - 2 ] = arguments [ _key ] ; } var _ref = function ( ) { switch ( true ) { case _extract Hidden Class ( len ) = = = 'Function ' : var args = f = = null ? [ ] : [ f ] . concat ( init Args ) ; return [ len , len . length , args ] ; case _extract Hidden Class ( len ) = = = 'Number ' : return [ f , len , init Args ] ; default : throw new Type Error ( 'Unrecognized arguments ' + len + ' and ' + f + ' to function curry . ' ) ; } } ( ) , _ref 2 = _sliced To Array ( _ref , 3 ) , fn = _ref 2 [ 0 ] , arity = _ref 2 [ 1 ] , fn Args = _ref 2 [ 2 ] ; if ( ! fn ) { return function ( fn ) { for ( var _len 2 = arguments . length , args = Array ( _len 2 > 1 ? _len 2 - 1 : 0 ) , _key 2 = 1 ; _key 2 < _len 2 ; _key 2 + + ) { args [ _key 2 - 1 ] = arguments [ _key 2 ] ; } return curry . apply ( this , [ arity , fn ] . concat ( args ) ) ; } ; } var helper = function helper ( args ) { return function ( ) { for ( var _len 3 = arguments . length , rest = Array ( _len 3 ) , _key 3 = 0 ; _key 3 < _len 3 ; _key 3 + + ) { rest [ _key 3 ] = arguments [ _key 3 ] ; } return currier . call ( this , arity , fn , [ ] . concat ( _to Consumable Array ( args ) , rest ) ) ; } ; } ; var currier = function currier ( length , f , args ) { if ( args . length > = length ) { 
function debounce ( n , immed , f ) { var _ref 3 = function ( ) { switch ( _extract Hidden Class ( immed ) ) { case 'Boolean ' : return [ f , immed ] ; case 'Function ' : return [ immed , false ] ; default : throw new Type Error ( 'Unrecognized arguments ' + immed + ' and ' + f + ' to function debounce . ' ) ; } } ( ) , _ref 4 = _sliced To Array ( _ref 3 , 2 ) , fn = _ref 4 [ 0 ] , now = _ref 4 [ 1 ] ; var timer = null ; return function ( ) { var _this = this ; for ( var _len 4 = arguments . length , args = Array ( _len 4 ) , _key 4 = 0 ; _key 4 < _len 4 ; _key 4 + + ) { args [ _key 4 ] = arguments [ _key 4 ] ; } if ( timer = = = null & & now ) { fn . apply ( this , args ) ; } clear Timeout ( timer ) ; timer = set Timeout ( function ( ) { return fn . apply ( _this , args ) ; } , n ) ; return timer ; } ; } 
function pipe ( ) { for ( var _len 6 = arguments . length , fs = Array ( _len 6 ) , _key 6 = 0 ; _key 6 < _len 6 ; _key 6 + + ) { fs [ _key 6 ] = arguments [ _key 6 ] ; } return function ( ) { var _this 3 = this ; var first = fs . shift ( ) ; for ( var _len 7 = arguments . length , args = Array ( _len 7 ) , _key 7 = 0 ; _key 7 < _len 7 ; _key 7 + + ) { args [ _key 7 ] = arguments [ _key 7 ] ; } return fs . reduce ( function ( acc , f ) { return f . call ( _this 3 , acc ) ; } , first . apply ( this , args ) ) ; } ; } 
function denodeify ( fn ) { var length = fn . length > 0 ? fn . length - 1 : 0 ; var f = function f ( ) { var _this 4 = this ; for ( var _len 8 = arguments . length , args = Array ( _len 8 ) , _key 8 = 0 ; _key 8 < _len 8 ; _key 8 + + ) { args [ _key 8 ] = arguments [ _key 8 ] ; } return new Promise ( function ( resolve , reject ) { fn . apply ( _this 4 , [ ] . concat ( args , [ function ( err ) { for ( var _len 9 = arguments . length , rest = Array ( _len 9 > 1 ? _len 9 - 1 : 0 ) , _key 9 = 1 ; _key 9 < _len 9 ; _key 9 + + ) { rest [ _key 9 - 1 ] = arguments [ _key 9 ] ; } if ( err ) { reject ( err ) ; } var result = void 0 ; switch ( rest . length ) { case 0 : result = true ; break ; case 1 : result = rest [ 0 ] ; break ; default : result = rest ; break ; } resolve ( result ) ; } ] ) ) ; } ) ; } ; return length ? curry ( length , f ) : f ; } 
function trampoline ( fn ) { return curry ( fn . length , function ( ) { for ( var _len 1 0 = arguments . length , args = Array ( _len 1 0 ) , _key 1 0 = 0 ; _key 1 0 < _len 1 0 ; _key 1 0 + + ) { args [ _key 1 0 ] = arguments [ _key 1 0 ] ; } var result = fn . apply ( this , args ) ; while ( _extract Hidden Class ( result ) = = = 'Function ' ) { result = result ( ) ; } return result ; } ) ; } 
function ( options , listeners ) { var me = this , params = options . params , use Batch = me . get Batch Actions ( ) , model = me . get Model ( ) , batch , records ; if ( options . operations = = = undefined ) { 
function create Raw Html ( create Template Fn , template Language , el Comment Config , data Attributes ) { 
function create Complex Template ( template Language , options ) { var t = get Template Language Constructs ( template Language ) , indent = options & & options . indentation | | " " , insert = options & & options . insertion | | " " , lines = [ ' < ! - - top -level comment (single line ) - - > ' , ' < ! - - ' , ' top -level ' , ' comment ' , ' (multi -line ) ' , ' - - > ' , t . if , ' <p >This is a % %paragraph ' , 'Some random % %text & & with different line breaks . <br > <br / > <br / > ' , t . else , ' <h 1 class = "header " >This is a % %header & & < /h 1 > ' , t . end If , t . if , ' < /p > ' , t . end If , insert , 'Some top -level % %text & & , not wrapped in a tag . <br > <br / > <br / > ' , ' < ! - - comment containing a <div > tag - - > ' , " < " + "script >alert ( 'foo ' ) ; < / " + "script > " , ' <p class = "significant Whitespace Expected " > ' , ' some text < /p > ' , ' < % %tag Name & & % %attrs & & >lorem ipsum < / % %tag Name & & > ' , ' <p > <h 1 >Invalid nesting < /h 1 > < /p > ' , t . partial , ' <dl class = " % %dl _class & & " > ' , ' ' + t . loop , ' <dt class = "dtclass " > % %dd _name & & < /dt > ' , ' <dd class = "ddclass " > % %dd _content & & < /dd > ' , ' ' + t . end Loop , ' < /dl > ' ] , inner Content = _ . map ( lines , function ( line ) { return indent + line ; } ) . join ( " \n " ) ; return inner Content . replace ( / % % / g , t . start Delimiter ) . replace ( / & & / g , t . end Delimiter ) ; } 
function get Template Language Constructs ( template Language ) { var constructs ; switch ( template Language . to Lower Case ( ) ) { case "handlebars " : constructs = { start Delimiter : " { { " , end Delimiter : " } } " , if : " { { #if is Active } } " , else : " { {else } } " , end If : " { { /if } } " , loop : " { { #each looped as |value index | } } " , end Loop : " { { /each } } " , partial : ' { { > user Message tag Name = "h 2 " } } ' } ; break ; case "ejs " : constructs = { start Delimiter : " < % = " , end Delimiter : " % > " , if : " < % if (is Active ) { % > " , else : " < % } else { % > " , end If : " < % } % > " , loop : " < % looped .for Each (function (item ) { % > " , end Loop : " < % } ) ; % > " , partial : " < % - include ( 'user /show ' , {user : user } ) ; % > " } ; break ; case "es 6 " : constructs = { start Delimiter : " $ { " , end Delimiter : " } " , if : " " , else : " " , end If : " " , loop : " " , end Loop : " " , partial : " " } ; break ; default : throw new Error ( 'Unsupported template language " ' + template Language + ' " ' ) ; } return constructs ; } 
function define Model ( model Type , options ) { var primary Attributes ; var attributes ; var prototype ; var static Proto ; var Model Constructor ; var type Name ; var namespace ; if ( types . is Valid Type ( model Type ) . indexes ) { throw Model Exception ( 'Model type cannot be an array ` { {type } } ` ' , null , null , { type : String ( model Type ) } ) ; } else if ( models [ model Type ] ) { throw Model Exception ( 'Model already defined ` { {type } } ` ' , null , null , { type : String ( model Type ) } ) ; } options = options | | { } ; primary Attributes = [ ] ; namespace = _get Namespace ( model Type ) ; type Name = _get Type Name ( model Type ) ; attributes = _prepare Attributes ( options . attributes | | { } , primary Attributes ) ; prototype = _prepare Prototype ( options . methods | | { } , primary Attributes , model Type , namespace , type Name ) ; static Proto = _prepare Static Proto ( options . static Methods | | { } , primary Attributes , options . attributes , prototype . _type ) ; Model Constructor = Function ( 'Model , events , attributes ' , 'return function ' + type Name + 'Model (data ) { ' + 'if ( ! (this instanceof ' + type Name + 'Model ) ) { ' + 'return new ' + type Name + 'Model (data ) ; ' + ' } ' + ( attributes ? 'Object .define Properties (this , attributes ) ; ' : ' ' ) + 'events .emit ( "create " , data ) ; ' + 'Model .call (this , data ) ; ' + ' } ' ) ( Model , events , attributes ) ; util . inherits ( Model Constructor , Model ) ; Object . define Properties ( Model Constructor . prototype , prototype ) ; Object . define Properties ( Model Constructor , static Proto ) ; if ( ! types . is Defined ( model Type ) ) { types . define ( model Type , options . type Validator | | _model Type Validator ( Model Constructor ) ) ; } 
function Model ( data ) { var attributes = this . _ _proto _ _ . constructor . attributes ; var i , ilen ; var dirty = false ; Object . define Properties ( this , { _id : { configurable : false , enumerable : true , writable : false , value : + + unique Id } , _is Dirty : { configurable : false , enumerable : true , get : function is Dirty ( ) { return dirty ; } , set : function is Dirty ( d ) { dirty = d ; if ( ! d & & this . _previous Data ) { this . _previous Data = undefined ; } } } , _is New : { configurable : false , enumerable : true , get : function is New Model ( ) { var new Model = false ; var attr Value ; if ( this . _primary Attributes ) { for ( i = 0 , ilen = this . _primary Attributes . length ; i < ilen & & ! new Model ; + + i ) { attr Value = this [ this . _primary Attributes [ i ] ] ; if ( ( attr Value = = = undefined ) | | ( attr Value = = = null ) ) { new Model = true ; } } } return new Model ; } } } ) ; if ( attributes ) { Object . define Properties ( this , attributes ) ; Object . define Property ( this , ' _data ' , { configurable : false , enumerable : false , writable : false , value : _default Data ( attributes ) } ) ; } if ( Array . is Array ( data ) ) { for ( i = 0 , ilen = data . length ; i < ilen ; + + i ) { if ( this . _primary Attributes [ i ] ) { this [ this . _primary Attributes [ i ] ] = data [ i ] ; } } } else if ( data ) { this . from JSON ( data ) ; } this . _is Dirty = false ; 
function Point ( master Apikey , feed ID , stream ID ) { this . master Api Key = master Apikey ; this . feed ID = feed ID . to String ( ) ; this . stream ID = stream ID . to String ( ) ; } 
function ( value , len , word ) { if ( value & & value . length > len ) { if ( word ) { var vs = value . substr ( 0 , len - 2 ) , index = Math . max ( vs . last Index Of ( ' ' ) , vs . last Index Of ( ' . ' ) , vs . last Index Of ( ' ! ' ) , vs . last Index Of ( ' ? ' ) ) ; if ( index ! = - 1 & & index > = ( len - 1 5 ) ) { return vs . substr ( 0 , index ) + " . . . " ; } } return value . substr ( 0 , len - 3 ) + " . . . " ; } return value ; } 
function ( val , size , ch ) { var result = String ( val ) ; ch = ch | | " " ; while ( result . length < size ) { result = ch + result ; } return result ; } 
function ( format ) { var args = Ext . to Array ( arguments , 1 ) ; return format . replace ( Ext . util . Format . format Re , function ( m , i ) { return args [ i ] ; } ) ; } 
function ( value ) { return ! value ? value : String ( value ) . replace ( / & / g , " &amp ; " ) . replace ( / > / g , " &gt ; " ) . replace ( / < / g , " &lt ; " ) . replace ( / " / g , " &quot ; " ) ; } 
function ( value , format ) { var date = value ; if ( ! value ) { return " " ; } if ( ! Ext . is Date ( value ) ) { date = new Date ( Date . parse ( value ) ) ; if ( is Na N ( date ) ) { * This code is modified from the following source : <https : *  2 0 1 1 Colin Snover <http : * Released under MIT license . * / var potential Undefined Keys = [ 1 , 4 , 5 , 6 , 7 , 1 0 , 1 1 ] ; var date Parsed , minutes Offset = 0 ; 
function ( tab Bar , new Tab ) { var old Active Item = this . get Active Item ( ) , new Active Item ; this . set Active Item ( tab Bar . index Of ( new Tab ) ) ; new Active Item = this . get Active Item ( ) ; return this . forced Change | | old Active Item ! = = new Active Item ; } 
function ( config ) { if ( config = = = true ) { config = { } ; } if ( config ) { Ext . apply If ( config , { ui : this . get Ui ( ) , docked : this . get Tab Bar Position ( ) } ) ; } return Ext . factory ( config , Ext . tab . Bar , this . get Tab Bar ( ) ) ; } 
function ( point 1 , point 2 ) { var Point = Ext . util . Point ; this . point 1 = Point . from ( point 1 ) ; this . point 2 = Point . from ( point 2 ) ; } 
function ( line Segment ) { var point 1 = this . point 1 , point 2 = this . point 2 , point 3 = line Segment . point 1 , point 4 = line Segment . point 2 , x 1 = point 1 . x , x 2 = point 2 . x , x 3 = point 3 . x , x 4 = point 4 . x , y 1 = point 1 . y , y 2 = point 2 . y , y 3 = point 3 . y , y 4 = point 4 . y , d = ( x 1 - x 2 ) * ( y 3 - y 4 ) - ( y 1 - y 2 ) * ( x 3 - x 4 ) , xi , yi ; if ( d = = 0 ) { return null ; } xi = ( ( x 3 - x 4 ) * ( x 1 * y 2 - y 1 * x 2 ) - ( x 1 - x 2 ) * ( x 3 * y 4 - y 3 * x 4 ) ) / d ; yi = ( ( y 3 - y 4 ) * ( x 1 * y 2 - y 1 * x 2 ) - ( y 1 - y 2 ) * ( x 3 * y 4 - y 3 * x 4 ) ) / d ; if ( xi < Math . min ( x 1 , x 2 ) | | xi > Math . max ( x 1 , x 2 ) | | xi < Math . min ( x 3 , x 4 ) | | xi > Math . max ( x 3 , x 4 ) | | yi < Math . min ( y 1 , y 2 ) | | yi > Math . max ( y 1 , y 2 ) | | yi < Math . min ( y 3 , y 4 ) | | yi > Math . max ( y 3 , y 4 ) ) { return null ; } return new Ext . util . Point ( xi , yi ) ; } 
function function Name ( fcn ) { var name ; if ( ! is Function ( fcn ) ) { throw new Type Error ( 'invalid input argument . Must provide a function . Value : ` ' + fcn + ' ` . ' ) ; } if ( is String ( fcn . name ) ) { name = fcn . name ; } else { name = RE . exec ( fcn . to String ( ) ) [ 1 ] ; } return ( name = = = ' ' ) ? 'anonymous ' : name ; } 
function ( ) { 
function Steroids Socket ( options ) { var final Target ; if ( options . target & & net . is IPv 6 ( options . target ) ) { final Target = normalize 6 ( options . target ) ; } else { final Target = options . target ; } this . target = final Target ; this . port = options . port | | 8 0 ; this . transport = options . transport | | 'TCP ' ; this . lport = options . lport | | null ; this . timeout = options . timeout | | 8 0 0 0 ; this . allow Half Open = options . allow Half Open | | null ; this . ws Proto = options . ws Proto | | 'sip ' ; this . ws Path = options . ws Path | | null ; 
function timeout Cb ( ) { if ( ! received ) { self . emit ( 'error ' , { type : 'socket : timeout ' , data : 'Connection problem : No response ' } ) ; } 
function real Width ( str ) { if ( str = = null ) return 0 ; str = strip ANSI ( str ) ; return str . length + ( strip Emoji ( str ) . match ( / [ ^ \x 0 0 - \xff ] / g ) | | [ ] ) . length ; } 
function PC ( source , config ) { if ( source = = null ) return ; this . config = { prefix : ' ' , suffix : ' ' , placeholder : ' ' , column Separation : ' ' , row Separation : " \n " , row Split Symbol : " \n " , column Split Symbol : " \t " } ; this . _STATS = { original Source : source , source : null , formatted : null , rows : 0 , columns : 0 , max Width : [ ] , width : [ ] , align : [ ] } ; this . params ( config ) ; this . parse Source ( ) ; this . Analytic Alignment ( ) ; this . format ( ) ; } 
function ( source , destination ) { gulp . src ( source ) . pipe ( conflict ( destination ) ) . pipe ( gulp . dest ( destination ) ) ; } 
function ( source , destination , context , opts ) { if ( ! opts ) opts = { force : true } ; this . mkdir P ( destination ) ; var files = fs . readdir Sync ( source ) ; for ( var i = 0 ; i < files . length ; i + + ) { var source File = path . join ( source , files [ i ] ) ; var destination File = path . join ( destination , files [ i ] ) ; if ( this . is Directory ( source File ) ) { this . template Dir Sync ( source File , destination File , context , opts ) ; } else { if ( fs . exists Sync ( destination File ) & & ! opts . force ) { console . log ( 'skipping existing file : ' + files [ i ] ) ; } else { this . template File Sync ( source File , destination File , context ) ; } } } } 
function ( source , destination , context ) { 
function ( source , destination ) { if ( ! fs . exists Sync ( destination ) ) mkdir ( ' -p ' , destination ) ; cp ( ' -R ' , source , destination ) ; } 
function ( tracker , prop List ) { var tracking Data = tracker [ tracking Key Name ] ; prop List . for Each ( function ( name ) { Object . define Property ( tracker , name , { enumerable : true , configurable : true , get : function ( ) { return tracking Data . object [ name ] ; } , set : function ( x ) { tracking Data . actions . push ( { key : name , set : x , } ) ; tracking Data . object [ name ] = x ; } , } ) ; } ) ; } 
function ( tracker , method List ) { var tracking Data = tracker [ tracking Key Name ] ; method List . for Each ( function ( name ) { tracker [ name ] = function ( ) { var context = this ; var args Array = Array . prototype . slice . call ( arguments ) ; 
function ( object ) { var prop List = [ ] ; var method List = [ ] ; for ( var k in object ) { if ( typeof object [ k ] = = = "function " ) { method List . push ( k ) ; } else { prop List . push ( k ) ; } } return { prop List : prop List , method List : method List , } ; } 
function ( config , callback , scope ) { 
function ( content ) { content = trim ( content ) ; if ( this . mounted ) { invoke ( this , [ Constants . BLOCK , 'set Mounted Content ' ] , content ) ; } else { dom . content Node ( this ) . inner HTML = content ; this . upgrade ( ) ; } } 
function ( ) { const props = dom . attrs . to Object ( this ) ; const xprops = this . xprops ; const eprops = get ( xtag , [ 'tags ' , this [ Constants . TAGNAME ] , 'accessors ' ] , { } ) ; for ( let prop in eprops ) { if ( xprops . has Own Property ( prop ) & & eprops . has Own Property ( prop ) & & ! BLOCK _COMMON _ACCESSORS . has Own Property ( prop ) ) { props [ prop ] = this [ prop ] ; } } dom . attrs . type Conversion ( props , xprops ) ; return props ; } 
function ( deep ) { 
function block Init ( node ) { if ( ! node [ Constants . TAGNAME ] ) { node [ Constants . INSERTED ] = false ; node [ Constants . TAGNAME ] = node . tag Name . to Lower Case ( ) ; node [ Constants . TMPL ] = { } ; node [ Constants . UID ] = unique Id ( ) ; return true ; } return false ; } 
function block Create ( node ) { if ( node . has Child Nodes ( ) ) { Array . prototype . for Each . call ( node . query Selector All ( 'script [type = "text /x -template " ] [ref ] ,template [ref ] ' ) , tmpl Compile Iterator , node ) ; } node [ Constants . BLOCK ] = new XBElement ( node ) ; } 
function merge Customizer ( obj Value , src Value , key ) { if ( is Array ( obj Value ) ) { return obj Value . concat ( src Value ) ; } if ( key = = = 'lifecycle ' ) { return merge With ( obj Value , src Value , lifecycle Customizer ) ; } if ( key = = = 'events ' ) { return merge With ( obj Value , src Value , events Customizer ) ; } if ( key = = = 'accessors ' ) { return merge With ( obj Value , src Value , accessors Customizer ) ; } if ( key = = = 'methods ' ) { check Overridden Methods ( obj Value , src Value ) ; } } 
function accessors Customizer ( obj Value , src Value ) { const obj Setter = get ( obj Value , 'set ' ) ; const src Setter = get ( src Value , 'set ' ) ; return merge ( { } , obj Value , src Value , { set : wrap ( obj Setter , wrap ( src Setter , wrapper Function ) ) } ) ; } 
function wrapper Events ( src Func , obj Func , . . . args ) { const event = ( args [ 0 ] instanceof Event ) & & args [ 0 ] ; const is Stopped = event ? ( ) = > event . immediate Propagation Stopped : stub False ; if ( ! is Stopped ( ) & & is Function ( obj Func ) ) { obj Func . apply ( this , args ) ; } if ( ! is Stopped ( ) & & is Function ( src Func ) ) { src Func . apply ( this , args ) ; } } 
function accessors Iterator ( options , name , accessors ) { const options Setter = get ( options , 'set ' ) ; const update Setter = wrap ( name , wrapper Accessors Set Update ) ; accessors [ name ] = merge ( { } , options , { set : wrap ( options Setter , wrap ( update Setter , wrapper Function ) ) } ) ; } 
function wrapper Accessors Set Update ( accessor Name , next Value , prev Value ) { if ( next Value ! = = prev Value & & this . xprops . has Own Property ( accessor Name ) & & this . mounted ) { this [ Constants . BLOCK ] . update ( ) ; } } 
function lifecycle Removed ( ) { this [ Constants . INSERTED ] = false ; const block = this [ Constants . BLOCK ] ; if ( block ) { block . destroy ( ) ; this [ Constants . BLOCK ] = undefined ; } } 
function lifecycle Inserted ( ) { if ( this [ Constants . INSERTED ] ) { return ; } block Init ( this ) ; this [ Constants . INSERTED ] = true ; const is Script Content = Boolean ( this . query Selector ( 'script ' ) ) ; 
function ( obj , remove Prop ) { var new Obj = { } ; for ( var prop in obj ) { if ( ! obj . has Own Property ( prop ) | | prop = = = remove Prop ) { continue ; } new Obj [ prop ] = obj [ prop ] ; } return new Obj ; } 
function read File Content ( conn , filepath ) { var validate Input Arg = function ( ) { if ( filepath = = = null | | filepath . length = = = 0 ) { throw { "success " : false , "value " : null , "error " : new Error ( "a filepath value is required " ) } ; } else { return true ; } } ; var read Remote File Content = function ( ) { 
function Client ( options ) { var self = this ; options = options | | { } ; this . mid = 0 ; this . callbacks = { } ; this . socket = new net . Socket ( options ) ; replier . _migrate _events ( [ 'connect ' , 'error ' , 'end ' , 'timeout ' , 'close ' , 'drain ' ] , this . socket , this ) ; this . socket . on ( 'data ' , function ( data ) { deal Stream ( data , function ( msg ) { self . emit ( 'data ' , msg ) ; self . _deal Server Data ( msg ) ; } ) ; } ) ; } 
function data Attributes To Properties ( data Attributes Hash ) { var transformed = { } ; $ . each ( data Attributes Hash , function ( key , value ) { 
function properties To Data Attributes ( attributes Hash ) { var transformed = { } ; $ . each ( attributes Hash , function ( key , value ) { 
function attributes Hash To String ( attributes Hash , options ) { var reduce = options & & options . reverse ? _ . reduce Right : _ . reduce , separator = options & & options . multiline ? " \n " : " " , spacing = options & & options . extr Space | | " " , default Quote = options & & options . prefer Single Quotes ? " ' " : ' " ' ; return reduce ( attributes Hash , function ( attr String , value , key ) { var quote = value . index Of ( ' " ' ) ! = = - 1 ? " ' " : value . index Of ( " ' " ) ! = = - 1 ? ' " ' : default Quote ; return attr String + key + spacing + " = " + spacing + quote + value + quote + separator ; } , " " ) ; } 
function to Dashed Properties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ to Dashed ( key ) ] = value ; } ) ; return transformed ; } 
function to Camel Cased Properties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ to Camel Case ( key ) ] = value ; } ) ; return transformed ; } 
function dashed Key Alternatives ( hash ) { var keys = _ . keys ( to Dashed Properties ( hash ) ) ; return _ . filter ( keys , function ( key ) { return key . search ( / [ ^ - ] - [a -z ] / ) ! = = - 1 ; } ) ; } 
function combine ( hash A , hash B , hash N ) { var hashes = _ . to Array ( arguments ) ; return _ . extend . apply ( undefined , [ { } ] . concat ( hashes ) ) ; } 
function ( selector , root ) { var selectors = selector . split ( ' , ' ) , length = selectors . length , i = 0 , results = [ ] , no Dup Results = [ ] , dup Matcher = { } , query , results Ln , cmp ; for ( ; i < length ; i + + ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . parse ( selector ) ; 
function ( component , selector ) { if ( ! selector ) { return true ; } var query = this . cache [ selector ] ; if ( ! query ) { this . cache [ selector ] = query = this . parse ( selector ) ; } return query . is ( component ) ; } 
function md 5 ( buffer ) { var hash = crypto . create Hash ( 'md 5 ' ) ; return hash . update ( buffer ) . digest ( 'hex ' ) . slice ( 0 , 1 0 ) ; } 
function clean Query ( url ) { var query = path . extname ( url ) . split ( ' ? ' ) [ 1 ] ; if ( query & & query . length > 0 ) { return url . substr ( 0 , url . length - ( query . length + 1 ) ) ; } return url ; } 
function create Pattern ( pattern , flags ) { pattern = pattern . replace ( / [ \ - \ [ \ ] \ / \ { \ } \ ( \ ) \ * \ + \ ? \ . \ \ \ ^ \ $ \ | ] / g , " \ \ $ & " ) ; return flags ? new Reg Exp ( pattern , flags ) : new Reg Exp ( pattern ) ; } 
function walk Dependencies ( file , rules ) { var directory = path . dirname ( file . path ) ; var content = file . contents . to String ( ) ; var list = [ ] ; 
function unique Dependencies ( dependencies ) { var result = [ ] ; var map = { } ; dependencies . for Each ( function ( dependency ) { if ( ! map [ dependency . absolute ] ) { result . push ( dependency ) ; map [ dependency . absolute ] = 1 ; } } ) ; return result ; } 
function correct Dependencies ( file , dependencies , correct ) { if ( ! correct ) { return ; } for ( var i = dependencies . length - 1 ; i > = 0 ; i - - ) { correct ( file , dependencies [ i ] ) ; } } 
function filter Dependencies ( file , dependencies , filter ) { for ( var i = dependencies . length - 1 ; i > = 0 ; i - - ) { var dependency = dependencies [ i ] ; 
function rename Dependencies ( file , dependencies , rename ) { var src Content = file . contents . to String ( ) ; var dest Content = src Content ; 
function get Recursive Hash ( dependency , hash Map , dependency Map ) { 
function html Dependencies ( file , instance , options ) { var dependencies = walk Dependencies ( file , instance . html Rules ) ; correct Dependencies ( file , dependencies , instance . correct Dependency ) ; filter Dependencies ( file , dependencies , instance . filter Dependency ) ; if ( options . process ) { options . process ( file , dependencies ) ; } if ( options . rename ) { rename Dependencies ( file , dependencies , function ( dependency ) { return options . rename ( file , dependency , instance . hash Map , instance . dependency Map ) ; } ) ; } } 
function css Dependencies ( file , instance , options ) { var dependencies = walk Dependencies ( file , instance . css Rules ) ; correct Dependencies ( file , dependencies , instance . correct Dependency ) ; filter Dependencies ( file , dependencies , instance . filter Dependency ) ; if ( options . process ) { options . process ( file , dependencies ) ; } if ( options . rename ) { rename Dependencies ( file , dependencies , function ( dependency ) { return options . rename ( file , dependency , instance . hash Map , instance . dependency Map ) ; } ) ; } } 
function amd Dependencies ( file , instance , options ) { var dependencies = [ ] ; var config = instance . get Amd Config ( file ) ; var file Info = parse File ( file . path , file . contents . to String ( ) , config ) ; file Info . modules . for Each ( function ( module ) { var resources = parse Factory Resources ( module . factory ) ; [ 
function get Iterator ( file ) { var iterator ; switch ( path . extname ( file . path ) . to Lower Case ( ) ) { 
function ( handler ) { var me = this ; return es . map ( function ( file , callback ) { var done = function ( ) { callback ( null , file ) ; } ; if ( file . contents ) { handler ( file , done ) ; } else { done ( ) ; } } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { html Dependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { css Dependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { amd Dependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var filter = options & & options . filter ; return me . custom ( function ( file , callback ) { if ( ! filter | | ! filter ( file ) ) { var file Path = file . path ; var hash = me . hash Map [ file Path ] ; hash = md 5 ( file . contents ) ; me . hash Map [ file Path ] = hash ; } callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var filter = options & & options . filter ; return me . custom ( function ( file , callback ) { if ( ! filter | | ! filter ( file ) ) { var iterator = get Iterator ( file ) ; if ( iterator ) { iterator ( file , me , { process : function ( file , dependencies ) { if ( dependencies . length > 0 ) { me . dependency Map [ file . path ] = unique Dependencies ( dependencies ) . map ( function ( dependency ) { return dependency . absolute ; } ) ; } } } ) ; } } callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var hash Map = me . hash Map ; var dependency Map = me . dependency Map ; var filter ; var replace ; if ( options ) { filter = options . filter ; replace = options . replace ; } return me . custom ( function ( file , callback ) { if ( ! filter | | ! filter ( file ) ) { var iterator = get Iterator ( file ) ; if ( iterator ) { iterator ( file , me , { process : function ( file , dependencies ) { if ( replace ) { var src Content = file . contents . to String ( ) ; var dest Content = replace ( file , src Content ) ; if ( dest Content & & dest Content ! = = src Content ) { file . contents = new Buffer ( dest Content ) ; } } } , rename : function ( file , dependency ) { var prefix = ' . / ' ; 
function ( options ) { var me = this ; var filter = options & & options . filter ; var hash Map = me . hash Map ; var dependency Map = me . dependency Map ; return me . custom ( function ( file , callback ) { if ( ! filter | | ! filter ( file ) ) { var hash = me . get File Hash ( file . path , hash Map , dependency Map , true ) ; var file Path = me . rename File ( file , hash ) ; if ( file Path ) { file . path = file Path ; } } callback ( ) ; } ) ; } 
function ( file Path , hash Map , dependency Map , cache ) { var me = this ; var recursive Hash Map = me . recursive Hash Map ; var hash = recursive Hash Map [ file Path ] ; if ( ! cache | | ! hash ) { hash = get Recursive Hash ( file Path , hash Map , dependency Map ) ; } if ( cache ) { recursive Hash Map [ file Path ] = hash ; } return hash ; } 
function ( ) { var me = this ; return me . custom ( function ( file , callback ) { amd Deploy ( { file : file . path , content : file . contents . to String ( ) , config : me . get Amd Config ( file ) , callback : function ( code ) { file . contents = new Buffer ( code ) ; callback ( ) ; } } ) ; } ) ; } 
function ( file , match , literal ) { 
function plugin ( suite ) { 
function post ( data , opts , clbk ) { if ( arguments . length = = = 2 ) { 
function Router Decorator ( Router ) { function Telemetry Router ( options ) { if ( ! ( this instanceof Telemetry Router ) ) { return new Telemetry Router ( options ) } Router . call ( this , options ) } inherits ( Telemetry Router , Router ) Telemetry Router . prototype . get Nearest Contacts = function ( key , limit , id , cb ) { var self = this var callback = function ( err , shortlist ) { if ( ! err ) { self . _log . debug ( 'sorting shortlist based on telemetry score ' ) var profiles = { } each ( shortlist , function ( contact , iterator Callback ) { var profile Callback = function ( err , profile ) { profiles [ contact . node ID ] = profile iterator Callback ( err ) } self . _rpc . telemetry . get Profile ( contact , profile Callback ) } , function ( err ) { if ( err ) { cb ( null , shortlist ) } else { shortlist . sort ( self . _compare . bind ( self , profiles ) ) cb ( null , shortlist ) } } ) } else { cb ( err , null ) } } Router . prototype . get Nearest Contacts . call ( this , key , limit , id , callback ) } Telemetry Router . prototype . _compare = function ( profiles , c A , c B ) { var profile A = profiles [ c A . node ID ] var profile B = profiles [ c B . node ID ] var scores A = { } var scores B = { } this . _rpc . _telopts . metrics . for Each ( function ( Metric ) { var m = new Metric ( ) scores A [ m . key ] = Metric . score ( m . get Metric ( profile A ) ) scores B [ m . key ] = Metric . score ( m . get Metric ( profile B ) ) } ) var result A = Telemetry Router . get Success Probability ( scores A ) var result B = Telemetry Router . get Success Probability ( scores B ) this . _log . debug ( 'success probability is %d % vs %d % ' , ( result A * 1 0 0 ) . to Fixed ( 3 ) , ( result B * 1 0 0 ) . to Fixed ( 3 ) ) * Uses a profile scorecard to calculate the probability of success * #get Success Probability * @param {Object } score * @returns {Number } * / Telemetry Router . get Success Probability = function ( score ) { return ( score . reliability + score . availability + score . latency ) / 3 } return Telemetry Router } 
function partial ( a , b , c ) { var p Inflection = ( c - a ) / ( b - a ) , fact 1 = ( b - a ) * ( c - a ) , fact 2 = ( b - a ) * ( b - c ) ; return function quantile ( p ) { if ( p ! = = p | | p < 0 | | p > 1 ) { return Na N ; } if ( p < p Inflection ) { return a + sqrt ( fact 1 * p ) ; } if ( p > p Inflection ) { return b - sqrt ( fact 2 * ( 1 - p ) ) ; } 
function ( config ) { if ( config . name = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #open Database : You must specify a `name ` of the database . ' ) ; return null ; } if ( config . version = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #open Database : You must specify a `version ` of the database . ' ) ; return null ; } if ( config . display Name = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #open Database : You must specify a `display Name ` of the database . ' ) ; return null ; } if ( config . estimated Size = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #open Database : You must specify a `estimated Size ` of the database . ' ) ; return null ; } var database = null ; var result = Ext . device . Communicator . send ( { command : 'SQLite #open Database ' , sync : true , name : config . name , version : config . version , display Name : config . display Name , estimated Size : config . estimated Size , callbacks : { 
function ( config ) { if ( config . old Version = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #change Version : You must specify an `old Version ` of the database . ' ) ; return null ; } if ( config . new Version = = null ) { Ext . Logger . error ( 'Ext .device .SQLite #change Version : You must specify a `new Version ` of the database . ' ) ; return null ; } this . transaction ( Ext . apply ( config , { preflight : function ( ) { return config . old Version = = this . get Version ( ) ? null : 'Unable to change version : version mismatch ' ; } , postflight : function ( ) { var result = Ext . device . Communicator . send ( { command : 'SQLite #set Version ' , sync : true , database Id : this . id , version : config . new Version } ) ; if ( result ) { this . version = config . new Version ; } } } ) ) ; } 
function ( config ) { if ( ! this . active ) { Ext . Logger . error ( 'Ext .device .sqlite .SQLTransaction #execute Sql : An attempt was made to use a SQLTransaction that is no longer usable . ' ) ; return null ; } if ( config . sql Statement = = null ) { Ext . Logger . error ( 'Ext .device .sqlite .SQLTransaction #execute Sql : You must specify a `sql Statement ` for the transaction . ' ) ; return null ; } this . statements . push ( { sql Statement : config . sql Statement , arguments : config . arguments , callback : config . callback , failure : config . failure , scope : config . scope } ) ; } 
function ( index ) { if ( index < this . get Length ( ) ) { var item = { } ; var row = this . rows [ index ] ; this . names . for Each ( function ( name , index ) { item [ name ] = row [ index ] ; } ) ; return item ; } return null ; } 
function Logger ( name , options ) { this . name = name ; this . _enabled = _defaults ( options , 'enabled ' ) ; this . _stream = _defaults ( options , 'stream ' ) ; this . _level = _defaults ( options , 'level ' ) ; var logger = this ; _loggers [ name ] = this ; Object . keys ( levels ) . for Each ( function ( level ) { logger [ level ] = function ( ) { return logger . write ( levels [ level ] , arguments ) ; } ; } ) ; } 
function create Payload ( name , level , data ) { return { date : get Date ( ) , level : level , name : name , data : data } ; } 
function Message ( spec ) { if ( ! ( this instanceof Message ) ) { return new Message ( spec ) } this . jsonrpc = ' 2 . 0 ' if ( Message . is Request ( spec ) ) { this . id = spec . id | | Message . create ID ( ) this . method = spec . method this . params = spec . params } else if ( Message . is Response ( spec ) ) { this . id = spec . id this . result = merge ( { } , spec . result ) if ( spec . error ) { this . error = { code : - 3 2 6 0 3 , message : spec . error . message } } } else { throw new Error ( 'Invalid message specification ' ) } } 
function _ _ENFORCETYPE ( a , . . . types ) { if ( env . application _env ! = = "development " ) return ; let has Error = false ; let expecting ; let got ; let i = 0 ; types . map ( ( t , index ) = > { if ( a [ index ] = = = null ) { has Error = true ; expecting = t ; got = "null " ; i = index ; return ; } switch ( t ) { case "mixed " : break ; case "jsx " : if ( ! React . is Valid Element ( a [ index ] ) ) { has Error = true ; expecting = "jsx " ; got = typeof a [ index ] ; i = index ; } case "array " : if ( ! Array . is Array ( a [ index ] ) ) { has Error = true ; expecting = "array " ; got = typeof a [ index ] ; i = index ; } break ; case "object " : if ( typeof a [ index ] ! = = 'object ' | | Array . is Array ( a [ index ] ) | | a [ index ] = = = null ) { has Error = true ; expecting = "object " ; i = index ; if ( a [ index ] = = = null ) { got = 'null ' ; } else { got = Array . is Array ( a [ index ] ) ? "array " : typeof a [ index ] ; } } default : if ( typeof a [ index ] ! = = t ) { has Error = true ; { expecting = t ; got = typeof a [ index ] ; } i = index ; } } } ) ; if ( has Error ) { let err = new Error ( ) ; console . error ( ` $ { i + 1 } $ { expecting } $ { got } ` , err . stack ) ; } } 
function parse XMP ( data ) { return new Promise ( function ( resolve , reject ) { var parserstrict = true ; var parser = sax . parser ( parserstrict ) ; var nodepath = [ ] ; var currentnode = null ; var outdata = { } ; parser . onerror = function ( err ) { reject ( { error : Media Ext . ERROR . PARSEXML , internalerror : err } ) } ; parser . onopentag = function ( node ) { nodepath . push ( node . name ) ; if ( node . attributes ) { for ( var att in node . attributes ) { if ( ! node . attributes . has Own Property ( att ) ) continue ; var value = node . attributes [ att ] ; nodepath . push ( att ) ; set Outdata ( nodepath , value , outdata ) ; nodepath . pop ( ) ; } } currentnode = node ; } parser . onclosetag = function ( node ) { nodepath . pop ( ) ; currentnode = null ; } parser . ontext = function ( value ) { set Outdata ( nodepath , value , outdata ) ; } parser . onend = function ( data ) { resolve ( outdata ) } ; parser . write ( data ) . close ( ) ; } ) ; } 
function assign ( parent , val , key Opts ) { var target = parent , key Parts = key Opts . val . to String ( ) . split ( ' . ' ) ; key Parts . for Each ( function ( key Part , idx ) { if ( key Parts . length = = = idx + 1 ) { if ( val ! = = undefined ) { if ( Array . is Array ( val ) & & Array . is Array ( target [ key Part ] ) ) { val = target [ key Part ] . concat ( val ) ; } if ( ! ( ( Array . is Array ( val ) & & ! val . length ) | | ( typeof val = = = 'object ' & & ! Object . keys ( val | | { } ) . length ) ) ) { target [ key Part ] = val ; } } } else if ( ! ( key Part in target ) ) { target [ key Part ] = { } ; } } ) ; } 
function ( token ) { var filter = { val : ' ' , opts : [ ] , type : 'filter ' } token . filters . push ( filter ) ; return filter ; } 
function ( node 1 , node 2 ) { 
function ( root ) { var node = this . get Node ( ) , recursive = this . get Recursive ( ) , added = [ ] , child = root ; if ( ! root . child Nodes . length | | ( ! recursive & & root ! = = node ) ) { return added ; } if ( ! recursive ) { return root . child Nodes ; } while ( child ) { if ( child . _added ) { delete child . _added ; if ( child = = = root ) { break ; } else { child = child . next Sibling | | child . parent Node ; } } else { if ( child ! = = root ) { added . push ( child ) ; } if ( child . first Child ) { child . _added = true ; child = child . first Child ; } else { child = child . next Sibling | | child . parent Node ; } } } return added ; } 
function ( config ) { var me = this ; config = Ext . device . filesystem . Abstract . prototype . request File System ( config ) ; var success Callback = function ( fs ) { var file System = Ext . create ( 'Ext .device .filesystem .File System ' , fs ) ; config . success . call ( config . scope | | me , file System ) ; } ; if ( config . type = = window . PERSISTENT ) { if ( navigator . webkit Persistent Storage ) { navigator . webkit Persistent Storage . request Quota ( config . size , function ( granted Bytes ) { window . webkit Request File System ( config . type , granted Bytes , success Callback , config . failure ) ; } ) } else { window . webkit Storage Info . request Quota ( window . PERSISTENT , config . size , function ( granted Bytes ) { window . webkit Request File System ( config . type , granted Bytes , success Callback , config . failure ) ; } ) } } else { window . webkit Request File System ( config . type , config . size , success Callback , config . failure ) ; } } 
function Pub Sub ( pub , sub ) { events . Event Emitter . call ( this ) ; var self = this ; 
function ( operation , callback , scope ) { var me = this , writer = me . get Writer ( ) , request = me . build Request ( operation ) ; request . set Config ( { headers : me . get Headers ( ) , timeout : me . get Timeout ( ) , method : me . get Method ( request ) , callback : me . create Request Callback ( request , operation , callback , scope ) , scope : me , proxy : me , use Default Xhr Header : me . get Use Default Xhr Header ( ) } ) ; if ( operation . get With Credentials ( ) | | me . get With Credentials ( ) ) { request . set With Credentials ( true ) ; request . set Username ( me . get Username ( ) ) ; request . set Password ( me . get Password ( ) ) ; } 
function ( err ) { var output ; try { var field Name = err . err . substring ( err . err . last Index Of ( ' . $ ' ) + 2 , err . err . last Index Of ( ' _ 1 ' ) ) ; output = field Name . char At ( 0 ) . to Upper Case ( ) + field Name . slice ( 1 ) + ' already exists ' ; } catch ( ex ) { output = 'Unique field already exists ' ; } return output ; } 
function ( new Message ) { var cls = Ext . base CSSPrefix + 'has -message ' ; if ( new Message ) { this . add Cls ( cls ) ; } else { this . remove Cls ( cls ) ; } this . message Element . set Html ( new Message ) ; } 
function is Promise ( val , Promize ) { return val instanceof Promize | | ( val ! = = null & & typeof val = = = 'object ' & & typeof val . then = = = 'function ' & & typeof val . catch = = = 'function ' ) } 
function acquire ( src , err ) { let mod = _ . attempt ( require , src ) return mod ? _ . is Error ( mod ) ? _ . is Boolean ( err ) & & err ? mod : null : null : mod } 
function acopy ( ) { let zargs = _ . to Array ( arguments ) zargs . unshift ( { } ) return _ . assign . apply ( _ , zargs ) } 
function mcopy ( ) { let zargs = _ . to Array ( arguments ) zargs . unshift ( { } ) return _ . merge . apply ( _ , zargs ) } 
function ( project ) { var current = process . cwd ( ) ; console . log ( ' \n Creating folder " ' + project + ' " . . . ' ) ; 
function browserify Task ( ) { 
function prewatch ( the Options ) { if ( config . watch ) { return _ . defaults ( the Options , watchify . args ) ; } return the Options ; } 
function ( index , filters ) { 
function ( filters ) { 
function ( ) { var filters = this . get Filters ( ) . items ; this . filter Fn = function ( item ) { var is Match = true , length = filters . length , i ; for ( i = 0 ; i < length ; i + + ) { var filter = filters [ i ] , fn = filter . get Filter Fn ( ) , scope = filter . get Scope ( ) | | this ; is Match = is Match & & fn . call ( scope , item ) ; } return is Match ; } ; this . dirty Filter Fn = false ; return this . filter Fn ; } 
function merge Customizer ( obj Value , src Value , key ) { if ( is Array ( obj Value ) ) { return obj Value . concat ( src Value ) ; } if ( METHODS _INHERITANCE . index Of ( key ) ! = = - 1 ) { return wrap ( obj Value , wrap ( src Value , wrapper Function ) ) ; } if ( METHODS _MERGE _RESULT . index Of ( key ) ! = = - 1 ) { return wrap ( obj Value , wrap ( src Value , wrapper Merge Result ) ) ; } if ( key = = = 'should Component Update ' ) { return wrap ( obj Value , wrap ( src Value , wrapper Or Result ) ) ; } if ( key = = = 'statics ' ) { check Overridden Methods ( obj Value , src Value ) ; } if ( key = = = 'render ' & & obj Value & & src Value ) { throw new Error ( 'The "render " method you can override ' ) ; } if ( key = = = 'display Name ' & & obj Value & & src Value ) { throw new Error ( 'The "display Name " property can not be redefined ' ) ; } if ( is Function ( obj Value ) & & is Function ( src Value ) ) { throw new Error ( ` $ { key } ` ) ; } } 
function wrapper Merge Result ( src Func , obj Func , . . . args ) { let result Obj Function = { } ; let result Src Function = { } ; if ( is Function ( obj Func ) ) { result Obj Function = obj Func . apply ( this , args ) ; } if ( is Function ( src Func ) ) { result Src Function = src Func . apply ( this , args ) ; } return merge ( { } , result Obj Function , result Src Function ) ; } 
function wrapper Or Result ( src Func , obj Func , . . . args ) { let result Obj Function = false ; let result Src Function = false ; if ( is Function ( obj Func ) ) { result Obj Function = obj Func . apply ( this , args ) ; } if ( is Function ( src Func ) ) { result Src Function = src Func . apply ( this , args ) ; } return result Obj Function | | result Src Function ; } 
function ( instance ) { this . _model = instance . _model ; this . _instance = instance ; this . id = instance . id ; this . each Attribute = function ( cb ) { return this . _model . each Attribute ( cb ) ; } ; this . each Relationship = function ( cb ) { return this . _model . each Relationship ( cb ) ; } this . attr = function ( name ) { return this . _instance [ name ] ; } ; this . belongs To = function ( name , opts ) { return ( opts . id ? this . _instance [ name ] . id : new Snapshot ( this . _instance [ name ] ) ) ; } ; } 
function ( val ) { var trimmed = val . trim ( ) ; if ( trimmed . index Of ( " ' " ) = = = 0 & & trimmed . last Index Of ( " ' " ) = = = ( trimmed . length - 1 ) ) return ' " ' + trimmed . substring ( 1 , trimmed . length - 1 ) + ' " ' ; return val ; } 
function ( type Name , obj ) { this . type = type Name ; if ( typeof obj ! = = 'undefined ' ) for ( var key in obj ) this [ key ] = obj [ key ] ; } 
function ( ) { var id Str = ' ' + sforce . db . id + + ; return sforce . db . _id Template . substring ( 0 , 1 8 - id Str . length ) + id Str ; } 
function ( select ) { var chars = new antlr 4 . Input Stream ( input ) ; var lexer = new Select Lexer ( chars ) ; var tokens = new antlr 4 . Common Token Stream ( lexer ) ; var parser = new Select Parser ( tokens ) ; parser . build Parse Trees = true ; return parser . select ( ) ; } 
function ( obj ) { var schema = sforce . db . schema ; var obj Desc = schema [ obj . type ] ; if ( typeof obj Desc = = = 'undefined ' ) throw 'No type exists by the name : ' + obj . type ; for ( var key in obj ) { if ( { Id : false , type : true } [ key ] ) continue ; var field Desc = null ; for ( var i = 0 ; i < obj Desc . fields . length ; i + + ) { var fd = obj Desc . fields [ i ] ; if ( fd . name = = = key ) { field Desc = fd ; break ; } } if ( field Desc = = null ) throw 'No field exists by the name : ' + key + 'in the type : ' + obj . type ; } } 
function ( type , fields ) { for ( var i = 0 ; i < fields . length ; i + + ) sforce . db . validate Field ( type , fields [ i ] ) ; } 
function ( type , field ) { var obj Desc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < obj Desc . fields . length ; i + + ) if ( obj Desc . fields [ i ] . name = = = field ) return ; throw 'No field exists by the name : ' + field + 'in the type : ' + type ; } 
function ( type , rel ) { var obj Desc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < obj Desc . child Relationships . length ; i + + ) if ( obj Desc . child Relationships [ i ] . relationship Name = = = rel ) return ; throw 'No child relationship exists by the name : ' + rel + 'in the type : ' + type ; } 
function ( type ) { var sos = sforce . db . sobjects ; if ( typeof sos [ type ] ! = = 'object ' ) sos [ type ] = { } ; return sos [ type ] ; } 
function ( obj Ary , success , err ) { var result = [ ] ; for ( var i = 0 ; i < obj Ary . length ; i + + ) { var obj = obj Ary [ i ] ; try { sforce . db . validate Sobject ( obj ) ; obj = _extend ( { } , obj ) ; var objs = sforce . db . get Sobjects ( obj . type ) ; obj . Id = ( ( ! sforce . db . use Given Ids | | typeof obj . Id = = = 'undefined ' ) ? sforce . db . new Id ( ) : obj . Id ) ; objs [ obj . Id ] = obj ; result . push ( { success : 'true ' , id : obj . Id } ) ; } catch ( e ) { result . push ( { success : 'false ' , id : obj . Id } ) ; } } if ( success ) success ( result ) ; return result ; } 
function ( id Ary , success , err ) { var result = [ ] ; for ( var i = 0 ; i < id Ary . length ; i + + ) { var found = false ; var Id = id Ary [ i ] ; for ( var type in this . schema ) { var all Of Type = sforce . db . get Sobjects ( type ) ; if ( Id in all Of Type ) { delete all Of Type [ Id ] ; found = true ; result . push ( { success : 'true ' , id : Id } ) ; break ; } } if ( ! found ) result . push ( { success : 'false ' , id : Id } ) ; } if ( success ) success ( result ) ; return result ; } 
function ( select , success , err ) { try { var chars = new antlr 4 . Input Stream ( select ) ; var lexer = new Select Lexer ( chars ) ; var tokens = new antlr 4 . Common Token Stream ( lexer ) ; var parser = new Select Parser ( tokens ) ; parser . build Parse Trees = true ; var tree = parser . select ( ) ; console . log ( tree . to String Tree ( ) ) ; var listener = new Query Builder Listener ( sforce . db ) ; antlr 4 . tree . Parse Tree Walker . DEFAULT . walk ( listener , tree ) ; var result = listener . query . get Result ( ) ; if ( success ) success ( result ) ; return result ; } catch ( e ) { if ( err ) err ( e ) ; return e ; } } 
function ( result Ary , is Root ) { if ( result Ary . length = = 0 ) { if ( is Root ) return { done : 'true ' , query Locator : null , size : 0 , } ; return null ; } var records = null ; if ( result Ary . length = = 1 ) records = result Ary [ 0 ] ; else records = result Ary ; return { done : 'true ' , query Locator : null , records : records , size : result Ary . length , } ; } 
function ( obj ) { var result = { type : this . type } ; this . db . validate Fields ( this . type , this . fields ) ; for ( var i = 0 ; i < this . fields . length ; i + + ) { var f Name = this . fields [ i ] ; result [ f Name ] = obj [ f Name ] ; } for ( var i = 0 ; i < this . subqueries . length ; i + + ) { var sq = this . subqueries [ i ] ; result [ sq . relationship ] = sq . get Result ( obj ) ; } return result } 
function ( ) { var all = this . db . get Sobjects ( this . type ) ; var result = [ ] ; for ( var Id in all ) { var obj = all [ Id ] ; if ( ! this . condition | | this . condition . matches ( obj ) ) result . push ( this . _create Result Obj ( obj ) ) ; } return this . db . wrap Result ( result , true ) ; } 
function ( obj ) { var result = { type : obj . type } ; this . get Db ( ) . validate Fields ( obj . type , this . fields ) ; for ( var i = 0 ; i < this . fields . length ; i + + ) { var f Name = this . fields [ i ] ; result [ f Name ] = obj [ f Name ] ; } return result } 
function ( parent Obj ) { this . get Db ( ) . validate Relationship ( this . get Type ( ) , this . relationship ) var obj Desc = this . get Db ( ) . schema [ this . get Type ( ) ] ; var rel Desc = null ; for ( var i = 0 ; i < obj Desc . child Relationships . length ; i + + ) if ( this . relationship = = = obj Desc . child Relationships [ i ] . relationship Name ) rel Desc = obj Desc . child Relationships [ i ] ; if ( rel Desc = = null ) throw 'No child relationship by the name : ' + this . relationship + ' exists in the type : ' + this . get Type ( ) ; var rel Obj Desc = this . get Db ( ) . schema [ rel Desc . child SObject ] ; var all = this . get Db ( ) . get Sobjects ( rel Desc . child SObject ) ; var result = [ ] ; for ( var key in all ) { var obj = all [ key ] ; if ( obj [ rel Desc . field ] = = = parent Obj . Id & & ( ! this . condition | | this . condition . matches ( obj ) ) ) result . push ( this . _create Result Obj ( obj ) ) ; } return this . get Db ( ) . wrap Result ( result ) ; } 
function ( obj ) { var matches = this . sequence [ 0 ] . matches ( obj ) ; for ( var i = 1 ; i < this . sequence . length ; i + = 2 ) { if ( this . sequence [ i ] = = = ' & ' ) matches = matches & & this . sequence [ i + 1 ] . matches ( obj ) ; else matches = matches | | this . sequence [ i + 1 ] . matches ( obj ) ; } return matches ; } 
function add Contents ( $ , contents ) { console . log ( 'add Contents ' , contents ) ; var body = document . get Elements By Tag Name ( 'BODY ' ) ; if ( ! body ) return ; var $body = $ ( body [ 0 ] ) , contents Style = [ 'position :fixed ;right : 1em ;top : 1em ; ' , 'padding : 0 . 5em ;min -width : 1 2 0px ; ' , 'font -size : 9 0 % ;line -height : 1 8px ; ' , 'border : 1px solid #aaa ;background : #F 9F 9F 9 ; ' ] . join ( ' ' ) , html = [ ] , order = [ ] , hash = [ ] ; for ( var i = 0 ; i < contents . length ; + + i ) { order [ i ] = 0 ; hash [ i ] = ' ' ; } function index Of ( tag ) { for ( var i = 0 ; i < contents . length & & contents [ i ] . to Lower Case ( ) ! = = tag ; + + i ) ; return i ; } $ ( contents . join ( ' , ' ) ) . each ( function ( i , obj ) { var index = index Of ( obj . tag Name . to Lower Case ( ) ) ; order [ index ] + + ; hash [ index ] = $ ( obj ) . text ( ) ; for ( var j = index + 1 ; j < contents . length ; + + j ) { 
function add Top ( $ , top ) { console . log ( 'add Top ' , top ) ; $ ( top . join ( ' , ' ) ) . each ( function ( i , obj ) { 
function ( ) { var actions = this . get Actions ( ) , namespace = this . get Namespace ( ) , action , cls , methods , i , ln , method ; for ( action in actions ) { if ( actions . has Own Property ( action ) ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } methods = actions [ action ] ; for ( i = 0 , ln = methods . length ; i < ln ; + + i ) { method = Ext . create ( 'Ext .direct .Remoting Method ' , methods [ i ] ) ; cls [ method . get Name ( ) ] = this . create Handler ( action , method ) ; } } } } 
function ( transaction , event ) { var success = ! ! event . get Status ( ) , function Name = success ? 'success ' : 'failure ' , callback = transaction & & transaction . get Callback ( ) , result ; if ( callback ) { 
function ( options , success , response ) { var me = this , i = 0 , ln , events , event , transaction , transactions ; if ( success ) { events = me . create Events ( response ) ; for ( ln = events . length ; i < ln ; + + i ) { event = events [ i ] ; transaction = me . get Transaction ( event ) ; me . fire Event ( 'data ' , me , event ) ; if ( transaction ) { me . run Callback ( transaction , event , true ) ; Ext . direct . Manager . remove Transaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( ln = transactions . length ; i < ln ; + + i ) { transaction = me . get Transaction ( transactions [ i ] ) ; if ( transaction & & transaction . get Retry Count ( ) < me . get Max Retries ( ) ) { transaction . retry ( ) ; } else { event = Ext . create ( 'Ext .direct .Exception Event ' , { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server . ' , xhr : response } ) ; me . fire Event ( 'data ' , me , event ) ; if ( transaction ) { me . run Callback ( transaction , event , false ) ; Ext . direct . Manager . remove Transaction ( transaction ) ; } } } } } 
function ( options ) { return options & & options . get Tid ? Ext . direct . Manager . get Transaction ( options . get Tid ( ) ) : null ; } 
function ( action , method , args ) { var me = this , call Data = method . get Call Data ( args ) , data = call Data . data , callback = call Data . callback , scope = call Data . scope , transaction ; transaction = Ext . create ( 'Ext .direct .Transaction ' , { provider : me , args : args , action : action , method : method . get Name ( ) , data : data , callback : scope & & Ext . is Function ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( me . fire Event ( 'beforecall ' , me , transaction , method ) ! = = false ) { Ext . direct . Manager . add Transaction ( transaction ) ; me . queue Transaction ( transaction ) ; me . fire Event ( 'call ' , me , transaction , method ) ; } } 
function ( transaction ) { return { action : transaction . get Action ( ) , method : transaction . get Method ( ) , data : transaction . get Data ( ) , type : 'rpc ' , tid : transaction . get Id ( ) } ; } 
function ( transaction ) { var me = this , enable Buffer = me . get Enable Buffer ( ) ; if ( transaction . get Form ( ) ) { me . send Form Request ( transaction ) ; return ; } me . call Buffer . push ( transaction ) ; if ( enable Buffer ) { if ( ! me . call Task ) { me . call Task = Ext . create ( 'Ext .util .Delayed Task ' , me . combine And Send , me ) ; } me . call Task . delay ( Ext . is Number ( enable Buffer ) ? enable Buffer : 1 0 ) ; } else { me . combine And Send ( ) ; } } 
function ( ) { var buffer = this . call Buffer , ln = buffer . length ; if ( ln > 0 ) { this . send Request ( ln = = 1 ? buffer [ 0 ] : buffer ) ; this . call Buffer = [ ] ; } } 
function ( action , method , form , callback , scope ) { var me = this , transaction , is Upload , params ; transaction = new Ext . direct . Transaction ( { provider : me , action : action , method : method . get Name ( ) , args : [ form , callback , scope ] , callback : scope & & Ext . is Function ( callback ) ? Ext . Function . bind ( callback , scope ) : callback , is Form : true } ) ; if ( me . fire Event ( 'beforecall ' , me , transaction , method ) ! = = false ) { Ext . direct . Manager . add Transaction ( transaction ) ; is Upload = String ( form . get Attribute ( 'enctype ' ) ) . to Lower Case ( ) = = 'multipart /form -data ' ; params = { ext TID : transaction . id , ext Action : action , ext Method : method . get Name ( ) , ext Type : 'rpc ' , ext Upload : String ( is Upload ) } ; 
function ( transaction ) { var me = this ; Ext . Ajax . request ( { url : me . get Url ( ) , params : transaction . params , callback : me . on Data , scope : me , form : transaction . form , is Upload : transaction . is Upload , transaction : transaction } ) ; } 
function inline Block Fix ( decl ) { var orig Rule = decl . parent ; orig Rule . append ( { prop : ' *display ' , value : 'inline ' } , { prop : ' *zoom ' , value : ' 1 ' } ) ; } 
function ( target , event Name ) { if ( ! this . handles ( event Name ) ) { return false ; } var match = target . match ( this . id Or Class Selector Regex ) , subscribers = this . get Subscribers ( event Name ) , type , value ; if ( match ! = = null ) { type = match [ 1 ] ; value = match [ 2 ] ; if ( type = = = ' # ' ) { return subscribers . id . has Own Property ( value ) ; } else { return subscribers . class Name . has Own Property ( value ) ; } } else { return ( subscribers . selector . has Own Property ( target ) & & Ext . Array . index Of ( subscribers . selector , target ) ! = = - 1 ) ; } return false ; } 
function stub Plain Text Files ( resource Roots , destination ) { _ . for Each ( resource Roots , function ( resource ) { 
function user Preferences Directory ( config Directory ) { var home = platform . user Home Directory ( ) ; var web Storm Preferences = io . maximise Path ( home , / ^ \ .Web Storm \s * [ . \d ] + $ / , 'config ' ) | | 
function write Project View Template ( root Path ) { var context = { root Path : root Path } ; var template Source = path . join ( String ( _ _dirname ) , 'template ' , 'project View .xml ' ) ; var tool Template = fs . read File Sync ( template Source ) ; return io . template Sync ( tool Template , context ) ; } 
function resolve Jetbrains Exe ( jetbrains Directory ) { var exists = false ; var webstorm Install Paths = io . resolve Dir Matches ( jetbrains Directory , / ^Web Storm \s * [ . \d ] + $ / ) ; 
function ( key , data ) { if ( data . n & & data . e ) { if ( data . d & & data . p & & data . q & & data . dmp 1 & & data . dmq 1 & & data . coeff ) { module . exports . private Import ( key , data ) ; return true ; } else { module . exports . public Import ( key , data ) ; return true ; } } return false ; } 
function Route ( method , path , callback , options ) { this . path = path ; this . method = method ; this . callback = callback ; this . regexp = utils . path Regexp ( path , this . keys = [ ] , options . sensitive , options . strict ) ; } 
function tree 2archy ( node ) { var dependencies = mout . object . values ( node . dependencies ) ; var version = ! node . missing ? node . pkg Meta . _release | | node . pkg Meta . version : null ; var label = node . endpoint . name + ( version ? ' # ' + version : ' ' ) ; var update ; if ( node . root ) { label + = ' ' + node . canonical Dir ; } 
function Transport Decorator ( Transport ) { function Telemetry Transport ( contact , options ) { if ( ! ( this instanceof Telemetry Transport ) ) { return new Telemetry Transport ( contact , options ) } assert . ok ( options , 'Missing required options parameter ' ) this . _telopts = options . telemetry this . telemetry = new Persistence ( this . _telopts . storage ) Transport . call ( this , contact , options ) } inherits ( Telemetry Transport , Transport ) Telemetry Transport . DEFAULT _METRICS = [ metrics . Latency , metrics . Availability , metrics . Reliability , metrics . Throughput ] Telemetry Transport . prototype . _open = function ( callback ) { var self = this var metrics = this . _telopts . metrics if ( ! metrics | | metrics . length = = = 0 ) { this . _telopts . metrics = Telemetry Transport . DEFAULT _METRICS } this . _telopts . metrics . for Each ( function ( Metric ) { var metric = new Metric ( ) metric . hooks . for Each ( function ( hook ) { self [ hook . trigger ] ( hook . event , hook . handler ( metric , self . telemetry ) ) } ) } ) return Transport . prototype . _open . call ( this , callback ) } return Telemetry Transport } 
function Router ( options ) { if ( ! ( this instanceof Router ) ) { return new Router ( options ) } this . _log = options . logger this . _rpc = options . transport this . _self = this . _rpc . _contact this . _validator = options . validator this . _routing Table = new Routing Table ( options . storage , this . _rpc ) } 
function get Random Arr Value ( arr , min = 0 , max = arr . length - 1 ) { return arr [ get Random Int ( min , max ) ] ; } 
function random ( number = 1 ) { if ( 1 > number ) { throw Error ( ` $ { number } ` ) ; } if ( number = = = 1 ) { return get Random Arr Value ( dinosaurs ) ; } else { const l = dinosaurs . length - 1 ; return new Array ( number ) . fill ( ) . map ( ( ) = > get Random Arr Value ( dinosaurs , 0 , l ) ) ; } } 
function ( config ) { var me = this ; if ( ! config . received ) { Ext . Logger . error ( 'Failed to pass a received callback . This is required . ' ) ; } if ( config . type = = null ) { Ext . Logger . error ( 'Failed to pass a type . This is required . ' ) ; } return { success : function ( token ) { me . on Success ( token , config . success , config . scope | | me ) ; } , failure : function ( error ) { me . on Failure ( error , config . failure , config . scope | | me ) ; } , received : function ( notifications ) { me . on Received ( notifications , config . received , config . scope | | me ) ; } , type : config . type } ; } 
function ( request ) { var me = this , operation = request . get Operation ( ) , records = operation . get Records ( ) | | [ ] , record = records [ 0 ] , model = me . get Model ( ) , id Property = model . get Id Property ( ) , format = me . get Format ( ) , url = me . get Url ( request ) , params = request . get Params ( ) | | { } , id = ( record & & ! record . phantom ) ? record . get Id ( ) : params [ id Property ] ; if ( me . get Append Id ( ) & & id ) { if ( ! url . match ( / \ / $ / ) ) { url + = ' / ' ; } url + = id ; delete params [ id Property ] ; } if ( format ) { if ( ! url . match ( / \ . $ / ) ) { url + = ' . ' ; } url + = format ; } request . set Url ( url ) ; return me . call Parent ( [ request ] ) ; } 
function Response ( ghosttrain , callback ) { this . charset = ' ' ; this . headers = { } ; this . status Code = 2 0 0 ; this . app = ghosttrain ; this . _callback = callback ; } 
function ( ) { var body ; var app = this . app ; 
function ( ) { var data ; if ( arguments . length = = = 2 ) { this . status ( arguments [ 0 ] ) ; data = arguments [ 1 ] ; } else { data = arguments [ 0 ] ; } if ( ! this . get ( 'Content -Type ' ) ) this . content Type ( 'application /json ' ) ; return this . send ( data ) ; } 
function ( field , value ) { if ( arguments . length = = = 2 ) this . headers [ field ] = value ; else { for ( var prop in field ) this . headers [ prop ] = field [ prop ] ; } return this ; } 
function ( body ) { var type = this . get ( 'Content -Type ' ) ; if ( type = = = 'application /json ' ) this . _callback ( JSON . parse ( body | | ' { } ' ) ) ; else this . _callback ( body ) ; } 
function ( args ) { 
function ( expected , args , minimum ) { var shifted Args = [ ] ; var cur Arg = args . length - 1 ; var remaining Optional Args = expected . length - minimum ; var optional Indice Segments = [ ] ; var optional Indice Segment = [ ] ; var available Args Segments = [ ] ; var available Args Segment = [ ] ; 
function ( ) { available Args Segment . unshift ( cur Arg ) ; cur Arg - - ; remaining Optional Args - - ; if ( cur Arg < 0 | | remaining Optional Args < 0 ) { throw Error ( get Expected Vs Recieved _ ( expected , args ) ) ; } } 
function ( expected , expected Index , actual , actual Index ) { 
function ( expected , expected Index , value ) { var i = expected Index + 1 ; var matching Optionals = 0 ; var in Between Optionals = 0 ; var tmp In Between = 0 ; while ( i < expected . length & & is Optional Type ( expected [ i ] ) ) { if ( is Of Type ( value , expected [ i ] ) ) { matching Optionals + + ; in Between Optionals + = tmp In Between ; tmp In Between = 0 ; } else { tmp In Between + + ; } i + + ; } return matching Optionals + in Between Optionals ; } 
function ( expected , expected Index , value ) { var i = expected Index - 1 ; var matching Requires = 0 while ( i > = 0 ) { if ( ! is Optional Type ( expected [ i ] ) & & is Of Type ( value , expected [ i ] ) ) { matching Requires + + ; } i - - ; } return matching Requires ; } 
function ( expected , actual ) { var arg Names = [ ] ; var expected Names = [ ] ; for ( var i = 0 ; i < actual . length ; i + + ) { arg Names . push ( get Name For Value ( actual [ i ] ) ) ; } ; for ( var i = 0 ; i < expected . length ; i + + ) { expected Names . push ( get Name For Type ( expected [ i ] ) ) ; } ; return 'Expected arguments to be ( ' + expected Names . join ( ' , ' ) + ' ) but received ( ' + arg Names . join ( ' , ' ) + ' ) instead . ' ; } 
function ( value , type ) { if ( ! is Valid Type ( type ) ) { throw Error ( 'Invalid type supplied . ' ) ; } if ( ! is Of Type ( value , type ) ) { arg Name = get Name For Value ( value ) ; type Name = get Name For Type ( type ) ; throw Error ( 'Expected ' + arg Name + ' to be an instance of ' + type Name + ' . ' ) ; } } 
function ( type ) { if ( type = = = null ) return true ; if ( type = = = undefined ) return true ; if ( type instanceof Any Type ) return true ; if ( type instanceof Array ) { 
function ( value ) { if ( value = = = undefined ) return 'undefined ' ; if ( value = = = null ) return 'null ' ; 
function ( type ) { if ( type = = = undefined ) return 'undefined ' ; if ( type = = = null ) return 'null ' ; 
function ( operation , callback , scope ) { 
function ( request ) { var me = this , url = me . call Parent ( arguments ) , params = Ext . apply ( { } , request . get Params ( ) ) , filters = params . filters , filter , i , value ; delete params . filters ; if ( me . get Auto Append Params ( ) ) { url = Ext . url Append ( url , Ext . Object . to Query String ( params ) ) ; } if ( filters & & filters . length ) { for ( i = 0 ; i < filters . length ; i + + ) { filter = filters [ i ] ; value = filter . get Value ( ) ; if ( value ) { url = Ext . url Append ( url , filter . get Property ( ) + " = " + value ) ; } } } return url ; } 
function get State From Options ( options , property Name ) { property Name = property Name | | 'state ' ; const state Name = options [ property Name ] | | options . resource . default State ; let state Obj = options . resource . states [ state Name ] | | { validate : false } ; state Obj . name = state Name ; return state Obj ; } 
function validate ( resource , doc , do Validate ) { return new Promise ( ( resolve , reject ) = > { if ( do Validate ! = = true ) { return resolve ( ) ; } if ( resource . validate ( doc ) ) { return resolve ( ) ; } else { debug ( 'model have %d error (s ) ' , resource . validate . errors . length ) ; return reject ( resource . validate . errors ) ; } } ) ; } 
function prune ( str , max , nice , suf ) { max = max | | 1 4 0 nice = _ . is Boolean ( nice ) ? nice : false if ( ! str | | max < = 0 | | str . length < = max ) return str suf = suf | | " . . . " str = str . substr ( 0 , max ) return nice ? str . substr ( 0 , Math . min ( str . length , str . last Index Of ( " " ) ) ) + suf : str } 
function attempt Render ( reporter , filename , src , resolve , reject , globals ) { globals = globals | | { } ; less . render ( src , { 
function validate Array ( indexes ) { var valid = false ; if ( typeof indexes = = = 'string ' ) { if ( indexes . match ( TYPE _ARRAY _REGEX ) ) { valid = true ; } } return valid ; } 
function add Routes ( pies , pie , routes , app ) { 
function load Route ( app , method , route , pie Path , fn , middleware ) { var middlewares = [ ] ; 
function generate UUID ( ) { let dat = new Date ( ) . get Time ( ) ; return 'xxxxxxxx -xxxx - 4xxx -yxxx -xxxxxxxxxxxx ' . replace ( / [xy ] / g , ( cha ) = > { const ran = ( dat + ( Math . random ( ) * 1 6 ) ) % 1 6 | 0 ; dat = Math . floor ( dat / 1 6 ) ; return ( cha = = = 'x ' ? ran : ran & 0x 3 | 0x 8 ) . to String ( 1 6 ) ; } ) ; } 
function random String ( length , char Set = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 0 1 2 3 4 5 6 7 8 9 ' ) { let str = ' ' , is All Numeric = false , is Negative = false , use Char Set = char Set ; if ( + length ) { if ( ! is String ( char Set ) ) { if ( is Number ( char Set ) ) { if ( + char Set ) { is All Numeric = true ; is Negative = + char Set < 0 ; use Char Set = ` $ { Math . abs ( + char Set ) } ` ; } else { use Char Set = ALPHANUMERIC _CHARS ; } } else { use Char Set = ALPHANUMERIC _CHARS ; } } const generate Char = function gc ( len ) { return Math . round ( Math . random ( ) * ( len - 1 ) ) ; } . bind ( null , use Char Set . length ) ; str = Array ( + length ) . fill ( ) . map ( ( v , index ) = > { const new Char = generate Char ( ) ; if ( ! index & & is All Numeric & & ! new Char ) { return use Char Set . char At ( new Char + 1 ) ; } return use Char Set . char At ( new Char ) ; } ) . join ( ' ' ) ; } if ( is All Numeric ) { return is Negative ? - + str : + str ; } return str ; } 
function to Uint ( str ) { const string = window . btoa ( unescape ( encode URIComponent ( str ) ) ) , chars = string . split ( ' ' ) , len = chars . length , uint Array = [ ] ; Array ( len ) . fill ( ) . for Each ( ( val , i ) = > uint Array . push ( chars [ i ] . char Code At ( 0 ) ) ) ; return new Uint 8Array ( uint Array ) ; } 
function to Array Buffer ( str ) { const len = is String ( str ) ? str . length : 0 , buf = new Array Buffer ( len ) , view = new Uint 8Array ( buf ) ; Array ( len ) . fill ( ) . for Each ( ( val , i ) = > ( view [ i ] = str . char Code At ( i ) & 0x FF ) ) ; return view ; } 
function ( key , data ) { 
function ( toolbar , item ) { item . on ( { scope : this , show : this . refresh Back Button Container , hide : this . refresh Back Button Container } ) ; this . refresh Back Button Container ( ) ; } 
function ( toolbar , item ) { item . un ( { scope : this , show : this . refresh Back Button Container , hide : this . refresh Back Button Container } ) ; this . refresh Back Button Container ( ) ; } 
function ( ) { if ( ! this . $back Button Container ) { return ; } var i = 0 , back Button Container = this . $back Button Container , items = back Button Container . items , item ; for ( ; i < items . length ; i + + ) { item = items . get ( i ) ; if ( ! item . is Hidden ( ) ) { this . $back Button Container . show ( ) ; return ; } } this . $back Button Container . hide ( ) ; } 
function ( message , priority , caller Id ) { if ( ! this . get Enabled ( ) ) { return this ; } var statics = Logger , priorities = statics . priorities , priority Value = priorities [ priority ] , caller = this . log . caller , caller Display Name = ' ' , writers = this . get Writers ( ) , event , i , original Caller ; if ( ! priority ) { priority = 'info ' ; } if ( priorities [ this . get Min Priority ( ) ] > priority Value ) { return this ; } if ( ! caller Id ) { caller Id = 1 ; } if ( Ext . is Array ( message ) ) { message = message . join ( " " ) ; } else { message = String ( message ) ; } if ( typeof caller Id = = 'number ' ) { i = caller Id ; do { i - - ; caller = caller . caller ; if ( ! caller ) { break ; } if ( ! original Caller ) { original Caller = caller . caller ; } if ( i < = 0 & & caller . display Name ) { break ; } } while ( caller ! = = original Caller ) ; caller Display Name = Ext . get Display Name ( caller ) ; } else { caller = caller . caller ; caller Display Name = Ext . get Display Name ( caller Id ) + ' # ' + caller . $name ; } event = { time : Ext . Date . now ( ) , priority : priority Value , priority Name : priority , message : message , caller : caller , caller Display Name : caller Display Name } ; for ( i in writers ) { if ( writers . has Own Property ( i ) ) { writers [ i ] . write ( Ext . merge ( { } , event ) ) ; } } return this ; } 
function write Template File Sync ( source , context , destination ) { var template Content = fs . read File Sync ( source , 'utf 8 ' ) ; var template Result ; try { template Result = _ . template ( template Content , context ) ; } catch ( error ) { console . error ( 'template File Sync ( ) error with source ' , source , ' and ' , destination ) ; console . error ( error ) ; } fs . write File Sync ( destination , template Result ) ; } 
function template Sync ( content , context ) { var template Result ; try { template Result = _ . template ( content , context ) ; } catch ( error ) { console . error ( 'template Sync ( ) error with source ' , content , 'or content ' , context ) ; console . error ( error ) ; } return template Result ; } 
function copy File Sync ( source , destination ) { if ( validate File Sync ( source ) ) { fs . write File Sync ( destination , fs . read File Sync ( source ) ) ; } } 
function copy Files Match Sync ( match , source , destination ) { fs . readdir Sync ( source ) . for Each ( function each Template ( filename ) { var source File = path . join ( source , filename ) ; var destination File = path . join ( destination , filename ) ; if ( match . test ( path . basename ( filename ) ) ) { fs . write File Sync ( destination File , fs . read File Sync ( source File ) ) ; } } ) ; } 
function replace Match Files Sync ( match , source , destination ) { unlink Files Match Sync ( match , destination ) ; copy Files Match Sync ( match , source , destination ) ; } 
function unlink Files Match Sync ( match , location ) { fs . readdir Sync ( location ) . for Each ( function each Template ( filename ) { if ( match . test ( path . basename ( filename ) ) ) { var file Path = path . join ( location , filename ) ; if ( validate File Sync ( file Path ) ) { fs . unlink Sync ( file Path ) ; } } } ) ; } 
function validate Directory Sync ( path , error Message ) { error Message = error Message | | 'Error validate Directory Sync ( ) the directory path is not valid ' + path ; var is Valid = exists Directory Sync ( path ) ; if ( ! is Valid ) { console . error ( error Message ) ; } return is Valid ; } 
function validate File Sync ( path , error Message ) { error Message = error Message | | 'Error validate File Sync ( ) the file path is not valid ' + path ; var is Valid = exists File Sync ( path ) ; if ( ! is Valid ) { console . error ( error Message ) ; } return is Valid ; } 
function sub Directories With File ( base , filename ) { var result = [ ] ; if ( fs . exists Sync ( base ) & & fs . stat Sync ( base ) . is Directory ( ) ) { if ( fs . exists Sync ( path . join ( base , filename ) ) ) { result . push ( base ) ; } fs . readdir Sync ( base ) . for Each ( function ( subdir ) { result . push . apply ( result , sub Directories With File ( path . join ( base , subdir ) , filename ) ) ; } ) ; } return result ; } 
function maximise Path ( ) { 
function resolve Dir Matches ( directory , match ) { if ( validate Directory Sync ( directory ) ) { return fs . readdir Sync ( directory ) . filter ( function each Directory Item ( item ) { var resolved = path . resolve ( path . join ( directory , item ) ) ; return match . test ( item ) & & fs . stat Sync ( resolved ) . is Directory ( ) ; } ) . sort ( compare Higher ) ; } else { return [ ] ; } } 
function compare Higher ( a , b ) { var num A = parse Float ( / [ \d \ . ] + $ / . exec ( a ) [ 0 ] ) ; var num B = parse Float ( / [ \d \ . ] + $ / . exec ( b ) [ 0 ] ) ; if ( is Na N ( num A ) | | ( num B > num A ) ) { return + 1 ; } else if ( is Na N ( num B ) | | ( num A > num B ) ) { return - 1 ; } else { return 0 ; } } 
function reduce Directories ( ) { return Array . prototype . slice . call ( arguments ) . map ( function ( candidate ) { return path . normalize ( candidate ) ; } ) . filter ( function ( candidate ) { return fs . exists Sync ( candidate ) & & fs . stat Sync ( candidate ) . is Directory ( ) ; } ) . shift ( ) ; } 
function ( menu , config ) { var me = this ; config = config | | { } ; 
function ( side ) { var menus = this . get Menus ( ) | | { } , menu = menus [ side ] ; if ( menu ) this . hide Menu ( side ) ; delete menus [ side ] ; this . set Menus ( menus ) ; } 
function ( side ) { var menus = this . get Menus ( ) , menu = menus [ side ] , before , after , viewport Before , viewport After ; if ( ! menu | | menu . is Animating ) { return ; } this . hide Other Menus ( side ) ; before = { translate X : 0 , translate Y : 0 } ; after = { translate X : 0 , translate Y : 0 } ; viewport Before = { translate X : 0 , translate Y : 0 } ; viewport After = { translate X : 0 , translate Y : 0 } ; if ( menu . $reveal ) { Ext . get Body ( ) . insert First ( menu . element ) ; } else { Ext . Viewport . add ( menu ) ; } menu . show ( ) ; menu . add Cls ( 'x - ' + side ) ; var size = ( side = = 'left ' | | side = = 'right ' ) ? menu . element . get Width ( ) : menu . element . get Height ( ) ; if ( side = = 'left ' ) { before . translate X = - size ; viewport After . translate X = size ; } else if ( side = = 'right ' ) { before . translate X = size ; viewport After . translate X = - size ; } else if ( side = = 'top ' ) { before . translate Y = - size ; viewport After . translate Y = size ; } else if ( side = = 'bottom ' ) { before . translate Y = size ; viewport After . translate Y = - size ; } if ( menu . $reveal ) { if ( Ext . browser . get Preferred Translation Method ( ) ! = 'scrollposition ' ) { menu . translate ( 0 , 0 ) ; } } else { menu . translate ( before . translate X , before . translate Y ) ; } if ( menu . $cover ) { menu . get Translatable ( ) . on ( 'animationend ' , function ( ) { menu . is Animating = false ; } , this , { single : true } ) ; menu . translate ( after . translate X , after . translate Y , { preserve End State : true , duration : 2 0 0 } ) ; } else { this . translate ( viewport Before . translate X , viewport Before . translate Y ) ; this . get Translatable ( ) . on ( 'animationend ' , function ( ) { menu . is Animating = false ; } , this , { single : true } ) ; this . translate ( viewport After . translate X , viewport After . translate Y , { preserve End State : true , duration : 2 0 0 } ) ; } 
function ( side , animate ) { var menus = this . get Menus ( ) , menu = menus [ side ] , after , viewport After , size ; animate = ( animate = = = false ) ? false : true ; if ( ! menu | | ( menu . is Hidden ( ) | | menu . is Animating ) ) { return ; } after = { translate X : 0 , translate Y : 0 } ; viewport After = { translate X : 0 , translate Y : 0 } ; size = ( side = = 'left ' | | side = = 'right ' ) ? menu . element . get Width ( ) : menu . element . get Height ( ) ; if ( side = = 'left ' ) { after . translate X = - size ; } else if ( side = = 'right ' ) { after . translate X = size ; } else if ( side = = 'top ' ) { after . translate Y = - size ; } else if ( side = = 'bottom ' ) { after . translate Y = size ; } if ( menu . $cover ) { if ( animate ) { menu . get Translatable ( ) . on ( 'animationend ' , function ( ) { menu . is Animating = false ; menu . hide ( ) ; } , this , { single : true } ) ; menu . translate ( after . translate X , after . translate Y , { preserve End State : true , duration : 2 0 0 } ) ; } else { menu . translate ( after . translate X , after . translate Y ) ; menu . hide ( ) } } else { if ( animate ) { this . get Translatable ( ) . on ( 'animationend ' , function ( ) { menu . is Animating = false ; menu . hide ( ) ; } , this , { single : true } ) ; this . translate ( viewport After . translate X , viewport After . translate Y , { preserve End State : true , duration : 2 0 0 } ) ; } else { this . translate ( viewport After . translate X , viewport After . translate Y ) ; menu . hide ( ) ; } } } 
function ( side , animation ) { var menus = this . get Menus ( ) ; for ( var menu in menus ) { if ( side ! = menu ) { this . hide Menu ( menu , animation ) ; } } } 
function ( side ) { var menus = this . get Menus ( ) , menu ; if ( menus [ side ] ) { menu = menus [ side ] ; if ( menu . is Hidden ( ) ) { this . show Menu ( side ) ; } else { this . hide Menu ( side ) ; } } } 
function timer ( options ) { if ( _ . is Function ( options ) ) { options = { out : options } ; } options = options | | { } ; this . _out = options . out | | _ . stderr ; this . _times = { } ; } 
function init ( adapter , config ) { if ( ! fs ) { var Adapter = require ( ' . /adapters / ' + adapter ) ; fs = new Adapter ( config ) ; } } 
function get Hierarchy ( cb ) { get Config ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ' :hierarchy ' ] ) ; } ) ; } 
function get Backends ( cb ) { get Config ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ' :backends ' ] ) ; } ) ; } 
function get Backend Config ( backend , cb ) { get Config ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ' : ' + backend ] ) ; } ) ; } 
function get File ( backend , file , cb ) { get Backend Config ( backend , function ( err , config ) { file = [ config [ ' :datadir ' ] , ' / ' , file ] . join ( ' ' ) ; fs . read File ( file , cb ) ; } ) ; } 
function save File ( backend , file , data , cb ) { cb = typeof ( cb ) = = = 'function ' ? cb : function ( ) { } ; get Backend Config ( backend , function ( err , config ) { var datadir = config [ ' :datadir ' ] ; file = path . join ( datadir , file ) ; fs . write File ( file , data , cb ) ; } ) ; } 
function get Overrides ( backend , file , cb ) { async . parallel ( [ function hierarchy ( cb ) { get Hierarchy ( cb ) ; } , function backend Config ( cb ) { get Backend Config ( backend , cb ) ; } ] , function ( err , results ) { var hierarchy , datadir , filename , tasks , pos , search Hierarchy , tasks ; hierarchy = results [ 0 ] ; datadir = results [ 1 ] [ ' :datadir ' ] ; filename = file . remove ( ' . ' + backend ) ; tasks = [ ] ; 
function ( me , e ) { 
function parse ( session , file ) { if ( ! this . match ( file ) ) { return ; } var fn = util . require ( file ) ; fn ( session . suite , session ) ; } 
function pdf ( x , options ) { var opts = { } , ctor , err , out , dt , d ; if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } opts . mu = typeof opts . mu ! = = 'undefined ' ? opts . mu : 0 ; opts . sigma = typeof opts . sigma ! = = 'undefined ' ? opts . sigma : 1 ; if ( is Number ( x ) ) { return pdf 1 ( x , opts . mu , opts . sigma ) ; } if ( is Matrix Like ( x ) ) { if ( opts . copy ! = = false ) { dt = opts . dtype | | 'float 6 4 ' ; ctor = ctors ( dt ) ; if ( ctor = = = null ) { throw new Error ( 'pdf ( ) : :invalid option . Data type option does not have a corresponding array constructor . Option : ` ' + dt + ' ` . ' ) ; } 
function done ( result , callback ) { if ( ! _ . is Function ( callback ) ) return process . next Tick ( function ( ) { callback ( null , result ) } ) } 
function fail ( err , callback ) { if ( ! _ . is Function ( callback ) ) return let u Error = new Error ( 'Unknown Error ' ) err = err ? _ . is Error ( err ) ? err : _ . is String ( err ) ? new Error ( err ) : u Error : u Error process . next Tick ( function ( ) { callback ( err ) } ) } 
function cb ( callback ) { callback = _ . is Arguments ( callback ) ? acb ( callback ) : callback return function ( err , result ) { if ( err ) return fail ( err , callback ) done ( result , callback ) } } 
function acb ( args ) { args = _ . to Array ( args ) return _ . find ( _ . reverse ( args ) , function ( arg ) { return _ . is Function ( arg ) } ) | | function ( ) { } } 
function ( data ) { var fields Collection = this . get Model ( ) . get Fields ( ) ; if ( fields Collection . is Dirty ) { this . build Extractors ( true ) ; delete fields Collection . is Dirty ; } if ( this . root Accessor ) { return this . root Accessor . call ( this , data ) ; } else { return data ; } } 
function arr Includes ( arr , values ) { if ( ! Array . is Array ( values ) ) { return in Array ( arr , values ) } var len = values . length ; var i = - 1 ; while ( i + + < len ) { var j = in Array ( arr , values [ i ] ) ; if ( j ) { return j } } return false } 
function function Arguments ( fn ) { if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'function -arguments expect a function ' ) } if ( fn . length = = = 0 ) { return [ ] } 
function is Async Function ( fn , names , strict ) { if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'is -async -function expect a function ' ) } strict = typeof names = = = 'boolean ' ? names : strict ; strict = typeof strict = = = 'boolean ' ? strict : true ; names = typeof names = = = 'boolean ' ? null : names ; names = Array . is Array ( names ) ? names : index ( names ) ; names = names . length ? names : index $ 8 ; var idx = index $ 6 ( names , index $ 1 0 ( fn ) ) ; return strict ? Boolean ( idx ) : idx } 
function redolent ( fn , opts ) { if ( typeof fn ! = = 'function ' ) { throw new Type Error ( 'redolent : expect `fn ` to be a function ' ) } opts = index $ 2 ( { context : this , Promise : Promize } , opts ) ; opts . Promise = register ( opts ) ; 
function is Promise ( val , Promize $ $ 1 ) { return val instanceof Promize $ $ 1 | | ( val ! = = null & & typeof val = = = 'object ' & & typeof val . then = = = 'function ' & & typeof val . catch = = = 'function ' ) } 
function all ( src ) { let ret = { } _ . for In ( exports , ( v , k ) = > { if ( ! _ . is Function ( v ) | | _ . includes ( ALL _EXCLUDE _KEYS , k ) ) return ret [ k ] = _ . attempt ( v , src ) } ) return ret } 
function clean ( src ) { let pidx = src . index Of ( 'http ' ) if ( pidx > 0 ) src = src . substr ( pidx ) return src ? pidx > = 0 | | src . index Of ( ' / / ' ) > = 0 ? src : ' / ' + src : ' ' } 
function jquery ( src ) { src = clean ( src ) ; let params = { } let match = null if ( ! url | | ! _ . is String ( src ) ) return params while ( match = REGX _QUERY _OBJECT . exec ( src ) ) { params [ match [ 1 ] ] = match [ 2 ] } return params } 
function validate ( opts , options ) { if ( ! is Object ( options ) ) { return new Type Error ( 'transpose ( ) : :invalid input argument . Options argument must be an object . Value : ` ' + options + ' ` . ' ) ; } if ( options . has Own Property ( 'copy ' ) ) { opts . copy = options . copy ; if ( ! is Boolean ( opts . copy ) ) { return new Type Error ( 'transpose ( ) : :invalid option . Copy option must be a boolean primitive . Option : ` ' + opts . copy + ' ` . ' ) ; } } return null ; } 
function ( el , options ) { events . Event Emitter . call ( this ) ; this . el = el ; this . options = extend ( { } , this . options ) ; extend ( this . options , options ) ; this . show Tab = this . _show ; this . _init ( ) ; } 
function to URI ( obj , dont Encode ) { const arr = [ ] ; let param Val ; if ( is Object ( obj ) & & ! is Array ( obj ) ) { Object . keys ( obj ) . for Each ( ( val ) = > { if ( is Array ( obj [ val ] ) ) { param Val = ` $ { obj [ val ] . join ( ' , ' ) } ` ; } else { param Val = obj [ val ] ; } if ( dont Encode ) { arr . push ( ` $ { val } $ { param Val } ` ) ; } else { arr . push ( ` $ { encode URIComponent ( val ) } $ { encode URIComponent ( param Val ) } ` ) ; } } ) ; } return arr . join ( ' & ' ) ; } 
function to Param ( obj , dont Encode ) { const arr = [ ] ; let vals ; if ( is Object ( obj ) & & ! is Array ( obj ) ) { Object . keys ( obj ) . for Each ( ( val ) = > { if ( is Array ( obj [ val ] ) ) { vals = ` $ { obj [ val ] . map ( v = > ( is Na N ( v ) ? ` $ { v } ` : v ) ) . join ( ' , ' ) } ` ; } else { vals = is Na N ( obj [ val ] ) ? ` $ { obj [ val ] } ` : obj [ val ] ; } arr . push ( ` $ { val } $ { vals } ` ) ; } ) ; if ( dont Encode ) { return ` $ { arr . join ( ' , ' ) } ` ; } return encode URIComponent ( ` $ { arr . join ( ' , ' ) } ` ) ; } return ' ' ; } 
function ( config ) { var default Config = Ext . device . geolocation . Abstract . prototype . config ; config = Ext . apply If ( config , { maximum Age : default Config . maximum Age , frequency : default Config . frequency , allow High Accuracy : default Config . allow High Accuracy , timeout : default Config . timeout } ) ; 
function ( anchor , local , size ) { 
function ( el , position , offsets , local ) { 
function ( key , obj ) { var me = this , my Obj = obj , my Key = key , old ; if ( arguments . length = = 1 ) { my Obj = my Key ; my Key = me . get Key ( my Obj ) ; } if ( typeof my Key ! = 'undefined ' & & my Key ! = = null ) { old = me . map [ my Key ] ; if ( typeof old ! = 'undefined ' ) { return me . replace ( my Key , my Obj ) ; } me . map [ my Key ] = my Obj ; } me . length + + ; me . items . push ( my Obj ) ; me . keys . push ( my Key ) ; me . fire Event ( 'add ' , me . length - 1 , my Obj , my Key ) ; return my Obj ; } 
function ( key , o ) { var me = this , old , index ; if ( arguments . length = = 1 ) { o = arguments [ 0 ] ; key = me . get Key ( o ) ; } old = me . map [ key ] ; if ( typeof key = = 'undefined ' | | key = = = null | | typeof old = = 'undefined ' ) { return me . add ( key , o ) ; } index = me . index Of Key ( key ) ; me . items [ index ] = o ; me . map [ key ] = o ; me . fire Event ( 'replace ' , key , old , o ) ; return o ; } 
function ( objs ) { var me = this , i = 0 , args , len , key ; if ( arguments . length > 1 | | Ext . is Array ( objs ) ) { args = arguments . length > 1 ? arguments : objs ; for ( len = args . length ; i < len ; i + + ) { me . add ( args [ i ] ) ; } } else { for ( key in objs ) { if ( objs . has Own Property ( key ) ) { if ( me . allow Functions | | typeof objs [ key ] ! = 'function ' ) { me . add ( key , objs [ key ] ) ; } } } } } 
function ( fn , scope ) { var items = [ ] . concat ( this . items ) , 
function ( index , key , obj ) { var me = this , my Key = key , my Obj = obj ; if ( arguments . length = = 2 ) { my Obj = my Key ; my Key = me . get Key ( my Obj ) ; } if ( me . contains Key ( my Key ) ) { me . suspend Events ( ) ; me . remove At Key ( my Key ) ; me . resume Events ( ) ; } if ( index > = me . length ) { return me . add ( my Key , my Obj ) ; } me . length + + ; Ext . Array . splice ( me . items , index , 0 , my Obj ) ; if ( typeof my Key ! = 'undefined ' & & my Key ! = = null ) { me . map [ my Key ] = my Obj ; } Ext . Array . splice ( me . keys , index , 0 , my Key ) ; me . fire Event ( 'add ' , index , my Obj , my Key ) ; return my Obj ; } 
function ( ) { var me = this ; me . length = 0 ; me . items = [ ] ; me . keys = [ ] ; me . map = { } ; me . fire Event ( 'clear ' ) ; } 
function ( property , value , any Match , case Sensitive ) { var filters = [ ] , filter Fn ; 
function create _user ( options ) { options = options | | { } ; var success = options . success | | function ( ) { terminal . exit ( ' \n User created ! \n \n ' ) ; } , error = options . error | | function ( err ) { terminal . abort ( 'Failed to created user ' , err ) ; } ; program . prompt ( 'username : ' , function ( username ) { program . password ( 'password : ' , ' * ' , function ( password ) { program . password ( 'confirm password : ' , ' * ' , function ( password 2 ) { if ( password ! = password 2 ) { terminal . abort ( 'Password do not match , bailing out . ' ) ; } program . prompt ( 'email : ' , function ( email ) { var body = { username : username , password : password , email : email } , db = require ( 'captain -core /lib /db ' ) ; db . users . create ( body , function ( err ) { if ( err ) { error ( err ) ; } else { success ( ) ; } } ) ; } ) ; } ) ; } ) ; } ) ; } 
function syncdb ( ) { function _syncdb ( drop ) { var db = require ( 'captain -core /lib /db ' ) ; db . sync DB ( { complete : function ( err ) { if ( err ) { terminal . abort ( 'Failed syncing ' , err ) ; } else { terminal . exit ( ' \n All done \n \n ' ) ; } } , progress : function ( script , file ) { console . log ( 'Executing : ' , file ) ; if ( program . verbose ) { console . log ( ' = = = = = = = = \n %s \n ' , script ) ; } } , drop : drop } ) ; } if ( program . drop ) { if ( ! program . force ) { program . prompt ( 'This will drop all databases , are you sure you want to proceed ? (y /N ) : ' , function ( answer ) { if ( ! ! answer . match ( / y |yes |arrr / i ) ) { fn ( true ) ; } else { terminal . exit ( 'Exiting . ' ) ; } } ) ; } else { _syncdb ( true ) ; } } else { _syncdb ( false ) ; } } 
function load _data ( filename ) { var files = [ ] , db = require ( 'captain -core /lib /db ' ) ; if ( filename = = = true ) { program . help ( ) ; } if ( helpers . is Directory ( filename ) ) { fs . readdir Sync ( filename ) . for Each ( function ( file ) { files . push ( join ( filename , file ) ) ; } ) ; } else { files . push ( filename ) ; } async . series ( files . map ( db . load ) , function ( err ) { if ( err ) { terminal . abort ( 'Failed loading data ' , err ) ; } else { terminal . exit ( ' \n All done . \n \n ' ) ; } } ) ; } 
function init ( target ) { function create _project ( name , uri ) { console . log ( ) ; console . log ( terminal . cyan ( 'Creating project : ' ) + name ) ; console . log ( ) ; 
function themes ( ) { var themes = fs . readdir Sync ( join ( PROJECT _ROOT , 'themes ' ) ) ; console . log ( terminal . cyan ( 'Available themes : ' ) ) ; console . log ( themes . map ( helpers . pad ) . join ( helpers . EOL ) ) ; } 
function theme ( target ) { if ( target = = = true ) { program . help ( ) ; } if ( helpers . is Captain Project ( ) ) { helpers . copy R ( [ join ( 'themes ' , target ) ] , ' . ' ) ; } else { terminal . abort ( 'Not a Captain project ' ) ; } } 
function run ( ) { process . env [ 'NODE _PATH ' ] = resolve ( PROJECT _ROOT , ' . . ' ) ; helpers . count Users ( function ( err , count ) { if ( err ) { throw err ; } if ( count > 0 ) { _run ( ) ; } else { terminal . abort ( 'You need to create at least one user with `captain create _user ` ' ) ; } } ) ; function _run ( ) { 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext .device .filesystem #request File System : You must specify a `success ` callback . ' ) ; return null ; } Ext . device . Communicator . send ( { command : 'File System #request File System ' , callbacks : { success : function ( id ) { var file System = Ext . create ( 'Ext .device .filesystem .File System ' , id ) ; config . success . call ( config . scope | | this , file System ) ; } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } } , scope : config . scope | | this } ) ; } 
function ( config ) { Ext . device . Communicator . send ( { command : 'File System #remove ' , path : this . path , file System Id : this . file System . id , recursively : config . recursively , callbacks : { success : function ( ) { if ( config . success ) { config . success . call ( config . scope | | this ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } } , scope : config . scope | | this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext .device .filesystem .Directory Entry #read Entries : You must specify a `success ` callback . ' ) ; return null ; } var me = this ; Ext . device . Communicator . send ( { command : 'File System #read Entries ' , path : this . path , file System Id : this . file System . id , callbacks : { success : function ( entry Infos ) { var entries = entry Infos . map ( function ( entry Info ) { return entry Info . directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , entry Info . path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , entry Info . path , me . file System ) ; } ) ; config . success . call ( config . scope | | this , entries ) ; } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } } , scope : config . scope | | this } ) ; } 
function ( config ) { if ( config . path = = null ) { Ext . Logger . error ( 'Ext .device .filesystem .Directory Entry #get File : You must specify a `path ` of the file . ' ) ; return null ; } if ( config . options = = null ) { config . options = { } ; } var me = this ; Ext . device . Communicator . send ( { command : 'File System #get Entry ' , path : this . path , file System Id : this . file System . id , new Path : config . path , directory : config . directory , create : config . options . create , exclusive : config . options . exclusive , callbacks : { success : function ( path ) { if ( config . success ) { var entry = config . directory ? Ext . create ( 'Ext .device .filesystem .Directory Entry ' , path , me . file System ) : Ext . create ( 'Ext .device .filesystem .File Entry ' , path , me . file System ) ; config . success . call ( config . scope | | this , entry ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } } , scope : config . scope | | this } ) ; } 
function ( config ) { var me = this ; Ext . device . Communicator . send ( { command : 'File System #read ' , path : this . path , file System Id : this . file System . id , offset : this . offset , length : config . length , callbacks : { success : function ( result ) { me . offset = result . offset ; if ( config . success ) { config . success . call ( config . scope | | this , result . data ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope | | this , error ) ; } } } , scope : config . scope | | this } ) ; } 
function to Have Text ( ) { return { compare : function compare ( element , text ) { var regexp = text instanceof Reg Exp ? text : new Reg Exp ( text , 'ig ' ) ; var pass = element . get DOMNode ( ) . text Content . match ( regexp ) ; var message = pass ? 'Text " ' + text + ' " is found within an element ' : 'Text " ' + text + ' " is not found within an element ' ; return { pass : pass , message : message } ; } } ; } 
function ( ) { var me = this , container = me . container , base Cls = me . get Base Cls ( ) , scrollable , scroll View Element , pinned Header ; Ext . apply ( me , { list Items : [ ] , header Items : [ ] , updated Items : [ ] , header Map : [ ] , scroll Dock Items : { top : [ ] , bottom : [ ] } } ) ; 
function ( ) { var me = this , container = me . container , scroll View Element = me . scroll View Element , index Bar = me . get Index Bar ( ) , trigger Event = me . get Trigger Event ( ) , trigger Ct Event = me . get Trigger Ct Event ( ) ; if ( index Bar ) { scroll View Element . append Child ( index Bar . render Element ) ; } if ( trigger Event ) { me . on ( trigger Event , me . on Item Trigger , me ) ; } if ( trigger Ct Event ) { me . on ( trigger Ct Event , me . on Container Trigger , me ) ; } container . element . on ( { delegate : ' . ' + me . get Base Cls ( ) + ' -disclosure ' , tap : 'handle Item Disclosure ' , scope : me } ) ; container . element . on ( { resize : 'on Container Resize ' , scope : me } ) ; 
function ( index ) { var list Items = this . list Items , ln = list Items . length , i , list Item ; for ( i = 0 ; i < ln ; i + + ) { list Item = list Items [ i ] ; if ( list Item . $data Index = = index ) { return list Item ; } } } 
function ( me , index , target , record , e ) { if ( ! ( this . get Prevent Selection On Disclose ( ) & & Ext . fly ( e . target ) . has Cls ( this . get Base Cls ( ) + ' -disclosure ' ) ) ) { this . call Parent ( arguments ) ; } } 
function notify ( arg 1 , arg 2 , arg 3 ) { var args Length = arguments . length ; return new P ( function ( resolve , reject ) { var files Csv = null ; var request Url = null ; var host = null ; var port = null ; var files = null ; if ( args Length = = = 3 ) { host = arg 1 ; port = arg 2 ; files = arg 3 ; } else if ( args Length = = = 2 ) { host = DEFAULT _HOST ; port = arg 1 ; files = arg 2 ; } else if ( args Length = = = 1 ) { host = DEFAULT _HOST ; port = DEFAULT _PORT ; files = arg 1 ; } request Url = 'http : / / ' + host + ' : ' + port + ' /changed ?files = ' ; if ( host = = null | | port = = null | | files = = null ) { return reject ( new Error ( 'host , port and files are all required fields ! ' ) ) ; } 
function ( name , value ) { if ( Ext . is Object ( name ) & & arguments . length = = = 1 ) { Ext . merge ( this . config , name ) ; } else { this . config [ name ] = ( Ext . is Object ( value ) ) ? Ext . merge ( this . config [ name ] , value ) : value ; } set Path Count + = 1 ; return this ; } 
function ( class Name ) { var path = ' ' , paths = this . config . paths , prefix = this . get Prefix ( class Name ) ; if ( prefix . length > 0 ) { if ( prefix = = = class Name ) { return paths [ prefix ] ; } path = paths [ prefix ] ; class Name = class Name . substring ( prefix . length + 1 ) ; } if ( path . length > 0 ) { path + = ' / ' ; } return path . replace ( / \ / \ . \ / / g , ' / ' ) + class Name . replace ( / \ . / g , " / " ) + ' .js ' ; } 
function ( excludes ) { var me = this ; return { require : function ( expressions , fn , scope ) { return me . require ( expressions , fn , scope , excludes ) ; } , sync Require : function ( expressions , fn , scope ) { return me . sync Require ( expressions , fn , scope , excludes ) ; } } ; } 
function ( url , on Load , on Error , scope , charset ) { var script = document . create Element ( 'script ' ) , me = this , on Load Fn = function ( ) { me . cleanup Script Element ( script ) ; on Load . call ( scope ) ; } , on Error Fn = function ( ) { me . cleanup Script Element ( script ) ; on Error . call ( scope ) ; } ; script . type = 'text /javascript ' ; script . src = url ; script . onload = on Load Fn ; script . onerror = on Error Fn ; script . onreadystatechange = function ( ) { if ( this . ready State = = = 'loaded ' | | this . ready State = = = 'complete ' ) { on Load Fn ( ) ; } } ; if ( charset ) { script . charset = charset ; } this . document Head . append Child ( script ) ; return script ; } 
function ( url , on Load , on Error , scope , synchronous ) { var me = this , is File Loaded = this . is File Loaded , script Elements = this . script Elements , no Cache Url = url + ( this . get Config ( 'disable Caching ' ) ? ( ' ? ' + this . get Config ( 'disable Caching Param ' ) + ' = ' + Ext . Date . now ( ) ) : ' ' ) , xhr , status , content , on Script Error ; if ( is File Loaded [ url ] ) { return this ; } scope = scope | | this ; this . is Loading = true ; if ( ! synchronous ) { on Script Error = function ( ) { 
function ( ) { var sync Mode Enabled = this . sync Mode Enabled ; if ( ! sync Mode Enabled ) { this . sync Mode Enabled = true ; } this . require . apply ( this , arguments ) ; if ( ! sync Mode Enabled ) { this . sync Mode Enabled = false ; } this . refresh Queue ( ) ; } 
function ( expressions , fn , scope , excludes ) { var excluded = { } , included = { } , queue = this . queue , class Name To File Path Map = this . class Name To File Path Map , is Class File Loaded = this . is Class File Loaded , excluded Class Names = [ ] , possible Class Names = [ ] , class Names = [ ] , references = [ ] , callback , sync Mode Enabled , file Path , expression , exclude , class Name , possible Class Name , i , j , ln , sub Ln ; if ( excludes ) { excludes = array From ( excludes ) ; for ( i = 0 , ln = excludes . length ; i < ln ; i + + ) { exclude = excludes [ i ] ; if ( typeof exclude = = 'string ' & & exclude . length > 0 ) { excluded Class Names = Manager . get Names By Expression ( exclude ) ; for ( j = 0 , sub Ln = excluded Class Names . length ; j < sub Ln ; j + + ) { excluded [ excluded Class Names [ j ] ] = true ; } } } } expressions = array From ( expressions ) ; if ( fn ) { if ( fn . length > 0 ) { callback = function ( ) { var classes = [ ] , i , ln , name ; for ( i = 0 , ln = references . length ; i < ln ; i + + ) { name = references [ i ] ; classes . push ( Manager . get ( name ) ) ; } return fn . apply ( this , classes ) ; } ; } else { callback = fn ; } } else { callback = Ext . empty Fn ; } scope = scope | | Ext . global ; for ( i = 0 , ln = expressions . length ; i < ln ; i + + ) { expression = expressions [ i ] ; if ( typeof expression = = 'string ' & & expression . length > 0 ) { possible Class Names = Manager . get Names By Expression ( expression ) ; sub Ln = possible Class Names . length ; for ( j = 0 ; j < sub Ln ; j + + ) { possible Class Name = possible Class Names [ j ] ; if ( excluded [ possible Class Name ] ! = = true ) { references . push ( possible Class Name ) ; if ( ! Manager . is Created ( possible Class Name ) & & ! included [ possible Class Name ] ) { included [ possible Class Name ] = true ; class Names . push ( possible Class Name ) ; } } } } } 
async function ( fname , attrs ) { let partial Dirs ; if ( typeof module . exports . configuration . partial Dirs = = = 'undefined ' | | ! module . exports . configuration . partial Dirs | | module . exports . configuration . partial Dirs . length < = 0 ) { partial Dirs = [ _ _dirname ] ; } else { partial Dirs = module . exports . configuration . partial Dirs ; } var partial Found = await globfs . find Async ( partial Dirs , fname ) ; if ( ! partial Found ) throw new Error ( ` $ { fname } $ { util . inspect ( partial Dirs ) } ` ) ; try { const t = literal (partial Text ) ; return t (attrs ) ; } catch (e ) { throw new Error ( `Literal rendering of $ {fname } failed because of $ {e } ` ) ; } } * / else if ( / \ .html $ / i . test ( partial Fname ) ) { 
function ( record ) { var me = this , fields = record . get Fields ( ) , id Property = record . get Id Property ( ) , unique Id Strategy = me . get Unique Id Strategy ( ) , data = { } , name , value ; fields . each ( function ( field ) { if ( field . get Persist ( ) ) { name = field . get Name ( ) ; if ( name = = = id Property & & ! unique Id Strategy ) { return ; } value = record . get ( name ) ; if ( field . get Type ( ) . type = = 'date ' ) { value = me . write Date ( field , value ) ; } data [ name ] = value ; } } , me ) ; return data ; } 
function ( provider ) { var me = this , args = Ext . to Array ( arguments ) , i = 0 , ln ; if ( args . length > 1 ) { for ( ln = args . length ; i < ln ; + + i ) { me . add Provider ( args [ i ] ) ; } return ; } 
function ( provider ) { var me = this , providers = me . providers ; provider = provider . is Provider ? provider : providers . get ( provider ) ; if ( provider ) { provider . un ( 'data ' , me . on Provider Data , me ) ; providers . remove ( provider ) ; return provider ; } return null ; } 
function ( fn ) { if ( Ext . is String ( fn ) ) { var parts = fn . split ( ' . ' ) , i = 0 , ln = parts . length , current = window ; while ( current & & i < ln ) { current = current [ parts [ i ] ] ; + + i ; } fn = Ext . is Function ( current ) ? current : null ; } return fn | | null ; } 
function ( config ) { config = config | | { } ; Ext . apply If ( config , { application : this } ) ; this . init Config ( config ) ; 
function ( action , add To History ) { action = action | | { } ; Ext . apply If ( action , { application : this } ) ; action = Ext . factory ( action , Ext . app . Action ) ; if ( action ) { var profile = this . get Current Profile ( ) , profile NS = profile ? profile . get Namespace ( ) : undefined , controller = this . get Controller ( action . get Controller ( ) , profile NS ) ; if ( controller ) { if ( add To History ! = = false ) { this . get History ( ) . add ( action , true ) ; } controller . execute ( action ) ; } } } 
function ( url ) { if ( Ext . data & & Ext . data . Model & & url instanceof Ext . data . Model ) { var record = url ; url = record . to Url ( ) ; } var decoded = this . get Router ( ) . recognize ( url ) ; if ( decoded ) { decoded . url = url ; if ( record ) { decoded . data = { } ; decoded . data . record = record ; } return this . dispatch ( decoded ) ; } } 
function ( name , profile Name ) { var instances = this . get Controller Instances ( ) , app Name = this . get Name ( ) , format = Ext . String . format , top Level Name ; if ( name instanceof Ext . app . Controller ) { return name ; } if ( instances [ name ] ) { return instances [ name ] ; } else { top Level Name = format ( " { 0 } .controller . { 1 } " , app Name , name ) ; profile Name = format ( " { 0 } .controller . { 1 } . { 2 } " , app Name , profile Name , name ) ; return instances [ profile Name ] | | instances [ top Level Name ] ; } } 
function ( masked ) { var is Visible = true , current Mask ; if ( masked = = = false ) { masked = true ; is Visible = false ; } current Mask = Ext . factory ( masked , Ext . Mask , this . get Masked ( ) ) ; if ( current Mask ) { this . add ( current Mask ) ; current Mask . set Hidden ( ! is Visible ) ; } return current Mask ; } 
function ( ) { delete this . on Item Add ; if ( this . inner Html Element & & ! this . get Html ( ) ) { this . inner Html Element . destroy ( ) ; delete this . inner Html Element ; } this . on ( 'innerstatechange ' , 'on Item Inner State Change ' , this , { delegate : ' > component ' } ) ; return this . on Item Add . apply ( this , arguments ) ; } 
function ( ) { var layout = this . layout ; if ( ! layout ) { layout = this . link ( ' _layout ' , this . link ( 'layout ' , Ext . factory ( this . _layout | | 'default ' , Ext . layout . Default , null , 'layout ' ) ) ) ; layout . set Container ( this ) ; } return layout ; } 
function ( new Items ) { var me = this , i , ln , item , new Active Item ; if ( Ext . is Array ( new Items ) ) { for ( i = 0 , ln = new Items . length ; i < ln ; i + + ) { item = me . factory Item ( new Items [ i ] ) ; this . do Add ( item ) ; if ( ! new Active Item & & ! this . get Active Item ( ) & & this . inner Items . length > 0 & & item . is Inner Item ( ) ) { new Active Item = item ; } } } else { item = me . factory Item ( new Items ) ; this . do Add ( item ) ; if ( ! new Active Item & & ! this . get Active Item ( ) & & this . inner Items . length > 0 & & item . is Inner Item ( ) ) { new Active Item = item ; } } if ( new Active Item ) { this . set Active Item ( new Active Item ) ; } return item ; } 
function ( item , destroy ) { var me = this , index = me . index Of ( item ) , inner Items = me . get Inner Items ( ) ; if ( destroy = = = undefined ) { destroy = me . get Auto Destroy ( ) ; } if ( index ! = = - 1 ) { if ( ! me . removing All & & inner Items . length > 1 & & item = = = me . get Active Item ( ) ) { me . on ( { activeitemchange : 'do Remove ' , scope : me , single : true , order : 'after ' , args : [ item , index , destroy ] } ) ; me . do Reset Active Item ( inner Items . index Of ( item ) ) ; } else { me . do Remove ( item , index , destroy ) ; if ( inner Items . length = = = 0 ) { me . set Active Item ( null ) ; } } } return me ; } 
function ( destroy , everything ) { var items = this . items , ln = items . length , i = 0 , item ; if ( typeof destroy ! = 'boolean ' ) { destroy = this . get Auto Destroy ( ) ; } everything = Boolean ( everything ) ; 
function ( index , item ) { var me = this , i ; 
function ( ) { var items = this . get Items ( ) . items , docked Items = [ ] , ln = items . length , item , i ; for ( i = 0 ; i < ln ; i + + ) { item = items [ i ] ; if ( item . is Docked ( ) ) { docked Items . push ( item ) ; } } return docked Items ; } 
function ( active Item , animation ) { var layout = this . get Layout ( ) , default Animation ; if ( this . active Item Animation ) { this . active Item Animation . destroy ( ) ; } this . active Item Animation = animation = new Ext . fx . layout . Card ( animation ) ; if ( animation & & layout . is Card ) { animation . set Layout ( layout ) ; default Animation = layout . get Animation ( ) ; if ( default Animation ) { default Animation . disable ( ) ; } animation . on ( 'animationend ' , function ( ) { if ( default Animation ) { default Animation . enable ( ) ; } animation . destroy ( ) ; } , this ) ; } return this . set Active Item ( active Item ) ; } 
function ( deep ) { var items = this . get Items ( ) . items . slice ( ) , ln = items . length , i , item ; if ( deep ) { for ( i = 0 ; i < ln ; i + + ) { item = items [ i ] ; if ( item . get Ref Items ) { items = items . concat ( item . get Ref Items ( true ) ) ; } } } return items ; } 
function ( component ) { if ( Ext . is Object ( component ) ) { component = component . get Item Id ( ) ; } return this . get Items ( ) . get ( component ) ; } 
function ( component ) { if ( Ext . is Object ( component ) ) { component = component . get Item Id ( ) ; } var docked Items = this . get Docked Items ( ) , ln = docked Items . length , item , i ; if ( Ext . is Number ( component ) ) { return docked Items [ component ] ; } for ( i = 0 ; i < ln ; i + + ) { item = docked Items [ i ] ; if ( item . id = = component ) { return item ; } } return false ; } 
function ( ) { var me = this , modal = me . get Modal ( ) ; if ( modal ) { modal . destroy ( ) ; } me . remove All ( true , true ) ; me . unlink ( ' _scrollable ' ) ; Ext . destroy ( me . items ) ; me . call Super ( ) ; } 
function export Protobuf ( pkgname , obj , callback ) { var lstexport = [ ] ; var lstreq = [ ] ; var lstres = [ ] ; if ( Array . is Array ( obj ) ) { var str = 'package ' + pkgname + ' ; \r \n \r \n ' ; for ( var i = 0 ; i < obj . length ; + + i ) { if ( obj [ i ] . type = = 'message ' ) { if ( base . is Res Msg ( obj [ i ] . name ) ) { lstres . push ( { name : obj [ i ] . name , comment : obj [ i ] . comment } ) ; } else if ( base . is Req Msg ( obj [ i ] . name ) ) { lstreq . push ( { name : obj [ i ] . name , comment : obj [ i ] . comment } ) ; } } } str + = export Enum Msg ID ( lstreq , base . get Global Obj ( 'REQ _MSGID _BEGIN ' , obj ) . val . val , lstres , base . get Global Obj ( 'RES _MSGID _BEGIN ' , obj ) . val . val ) ; for ( var i = 0 ; i < obj . length ; + + i ) { if ( obj [ i ] . type = = 'message ' ) { lstexport = export Member ( obj [ i ] , lstexport , obj ) ; } } for ( var i = 0 ; i < lstexport . length ; + + i ) { var co = base . get Global Obj ( lstexport [ i ] , obj ) ; if ( co . type = = 'enum ' ) { var cs = export Enum ( co , callback , obj ) ; if ( cs = = undefined ) { return ; } str + = cs + ' \r \n ' ; } else { var cs = export Msg ( co , callback , obj ) ; if ( cs = = undefined ) { return ; } str + = cs + ' \r \n ' ; } } for ( var i = 0 ; i < obj . length ; + + i ) { if ( obj [ i ] . type = = 'message ' ) { var cs = export Msg ( obj [ i ] , callback , obj ) ; if ( cs = = undefined ) { return ; } str + = cs + ' \r \n ' ; } } return str ; } return undefined ; } 
function ( e ) { var src Element = e . src Element . node Name . to Upper Case ( ) , selectable Elements = [ 'INPUT ' , 'TEXTAREA ' ] ; if ( selectable Elements . index Of ( src Element ) = = - 1 ) { return false ; } } 
function ( number , min , max ) { number = parse Float ( number ) ; if ( ! is Na N ( min ) ) { number = Math . max ( number , min ) ; } if ( ! is Na N ( max ) ) { number = Math . min ( number , max ) ; } return number ; } 
function ( value , increment , min Value , max Value ) { var new Value = value , m ; if ( ! ( increment & & value ) ) { return value ; } m = value % increment ; if ( m ! = = 0 ) { new Value - = m ; if ( m * 2 > = increment ) { new Value + = increment ; } else if ( m * 2 < - increment ) { new Value - = increment ; } } return Ext . Number . constrain ( new Value , min Value , max Value ) ; } 
function ( value , precision ) { if ( is To Fixed Broken ) { precision = precision | | 0 ; var pow = Math . pow ( 1 0 , precision ) ; return ( Math . round ( value * pow ) / pow ) . to Fixed ( precision ) ; } return value . to Fixed ( precision ) ; } 
function _extend ( target , source ) { var keys = Object . keys ( source ) ; for ( var i = 0 ; i < keys . length ; i + + ) { target [ keys [ i ] ] = source [ keys [ i ] ] ; } return target ; } 
function logger ( req , res , next ) { if ( req . url . substr ( 0 , 2 ) = = = " /r " ) { console . log ( req . method , decode URIComponent ( req . url ) , req . body ? JSON . stringify ( req . body ) : " " ) ; } next ( ) ; } 
function type Convert ( obj , only Date ) { var i , res ; if ( typeof obj = = = "object " ) { for ( i in obj ) { if ( obj . has Own Property ( i ) ) { obj [ i ] = type Convert ( obj [ i ] , only Date ) ; } } } else if ( typeof obj = = = "string " ) { if ( ! only Date & & obj . match ( / ^ ( [ 0 - 9 . ] + |true |false |undefined |null ) $ / ) ) { obj = eval ( obj ) ; } else { res = obj . match ( / ^ " ? ( \d { 4 } - \d { 2 } - \d { 2 }T \d { 2 } : \d { 2 } : \d { 2 } \ . \d { 3 }Z ) " ? $ / ) ; if ( res ) { obj = new Date ( res [ 1 ] ) ; } } } return obj ; } 
function type Convert Middleware ( req , res , next ) { type Convert ( req . params ) ; type Convert ( req . body , true ) ; next ( ) ; } 
function Store Manager ( options ) { var stores = { } ; this . get = function ( name ) { if ( ! stores [ name ] ) { stores [ name ] = options . store ( name ) ; } return stores [ name ] ; } ; } 
function create Server ( options ) { var server , stores ; 
function define Route ( method , route , handler ) { server [ method ] ( route , function ( req , res ) { var store = stores . get ( req . params . resource ) ; delete req . params . resource ; handler ( req , store , function ( error , docs ) { if ( error ) { res . status ( 5 0 0 ) ; res . end ( error ) ; } else if ( ! docs ) { res . status ( 4 0 4 ) ; res . end ( "Not found " ) ; } else { res . json ( docs ) ; } } ) ; } ) ; } 
function route URL ( ) { var prefix = options . prefix | | " " , args = [ " / " + prefix , " :resource " ] . concat ( Array . prototype . slice . call ( arguments ) ) ; return path . join . apply ( path , args ) ; } 
function create Password Hash ( object ) { if ( ! object ) return object ; var password = object . password ; if ( password ) { delete object . password ; object . password Salt = sha 1 ( Math . random ( ) . to String ( ) ) ; object . password Hash = sha 1 ( "restify -magic " + object . password Salt + password ) ; } return object ; } 
function ( json , type Specification , array ) { var keys , current = json , nested = [ ] , nested Keys = [ ] , levels = [ ] , query = 'COLUMN _CREATE ( ' , root = true , cur Nest = ' ' , cur Item , item = 0 , level = 0 ; while ( current ) { keys = Object . keys ( current ) ; var len = keys . length ; var _l ; var deepest Level = 1 ; for ( var i = 0 ; i < len ; + + i ) { if ( ( _l = current [ keys [ i ] ] ) = = = null | | _l = = = undefined ) { continue ; } if ( typeof ( _l ) = = = 'object ' ) { 
function ( record ) { if ( ! record . is Node ) { * @event append * Fires when a new child node is appended . * @param {Ext .data .Node Interface } this This node . * @param {Ext .data .Node Interface } node The newly appended node . * @param {Number } index The index of the newly appended node . * / "append " , "remove " , "move " , "insert " , "beforeappend " , "beforeremove " , "beforemove " , "beforeinsert " , "expand " , "collapse " , "beforeexpand " , "beforecollapse " , "sort " , 'load ' ] ) ; } return record ; } 
function ( node ) { if ( Ext . is Object ( node ) & & ! node . is Model ) { node = Ext . data . Model Manager . create ( node , this . model Name ) ; } 
function ( silent ) { var me = this , parent Node = me . parent Node , is First = ( ! parent Node ? true : parent Node . first Child = = me ) , is Last = ( ! parent Node ? true : parent Node . last Child = = me ) , depth = 0 , parent = me , children = me . child Nodes , ln = children . length , i ; while ( parent . parent Node ) { + + depth ; parent = parent . parent Node ; } me . begin Edit ( ) ; me . set ( { is First : is First , is Last : is Last , depth : depth , index : parent Node ? parent Node . index Of ( me ) : 0 , parent Id : parent Node ? parent Node . get Id ( ) : null } ) ; me . end Edit ( silent ) ; if ( silent ) { me . commit ( silent ) ; } for ( i = 0 ; i < ln ; i + + ) { children [ i ] . update Info ( silent ) ; } } 
function ( node , suppress Events , suppress Node Update ) { var me = this , i , ln , index , old Parent , ps ; 
function ( node , destroy , suppress Events , suppress Node Update ) { var me = this , index = me . index Of ( node ) ; if ( index = = - 1 | | ( suppress Events ! = = true & & me . fire Event ( "beforeremove " , me , node ) = = = false ) ) { return false ; } 
function ( new Id , deep ) { var me = this , result = me . call Overridden ( arguments ) , len = me . child Nodes ? me . child Nodes . length : 0 , i ; 
function ( destroy ) { var me = this ; 
function ( silent ) { var me = this , options = me . destroy Options ; if ( silent = = = true ) { me . clear ( true ) ; Ext . each ( me . child Nodes , function ( n ) { n . destroy ( true ) ; } ) ; me . child Nodes = null ; delete me . destroy Options ; me . call Overridden ( [ options ] ) ; } else { me . destroy Options = silent ; 
function ( node , ref Node , suppress Events ) { var me = this , index = me . index Of ( ref Node ) , old Parent = node . parent Node , ref Index = index , ps ; if ( ! ref Node ) { 
function ( destroy , suppress Events ) { var parent Node = this . parent Node ; if ( parent Node ) { parent Node . remove Child ( this , destroy , suppress Events , true ) ; } return this ; } 
function ( destroy , suppress Events ) { var cn = this . child Nodes , n ; while ( ( n = cn [ 0 ] ) ) { this . remove Child ( n , destroy , suppress Events ) ; } return this ; } 
function ( sort Fn , recursive , suppress Event ) { var cs = this . child Nodes , ln = cs . length , i , n ; if ( ln > 0 ) { Ext . Array . sort ( cs , sort Fn ) ; for ( i = 0 ; i < ln ; i + + ) { n = cs [ i ] ; n . previous Sibling = cs [ i - 1 ] ; n . next Sibling = cs [ i + 1 ] ; if ( i = = = 0 ) { this . set First Child ( n ) ; } if ( i = = ln - 1 ) { this . set Last Child ( n ) ; } n . update Info ( suppress Event ) ; if ( recursive & & ! n . is Leaf ( ) ) { n . sort ( sort Fn , true , true ) ; } } this . notify Stores ( 'after Edit ' , [ 'sorted ' ] , { sorted : 'sorted ' } ) ; if ( suppress Event ! = = true ) { this . fire Event ( 'sort ' , this , cs ) ; } } } 
function ( recursive , callback , scope ) { var me = this ; if ( ! me . is Leaf ( ) ) { if ( me . is Loading ( ) ) { me . on ( 'expand ' , function ( ) { me . expand ( recursive , callback , scope ) ; } , me , { single : true } ) ; } else { if ( ! me . is Expanded ( ) ) { 
function ( recursive , callback , scope ) { var me = this ; 
function ( ) { if ( head . open = = = 0 & & head . next ) { 
function ( next Target Fn , fn Opt ) { tail . next = { fns : [ next Target Fn ] , opts : [ fn Opt ] } ; tail = tail . next ; dispatch ( ) ; return controller ; } 
function Deployor ( options ) { this . options = _assign ( { } , Deployor . defaults , options ) 
function ( ) { var mask = Ext . get Body ( ) . create Child ( { cls : Ext . base CSSPrefix + 'mask ' + Ext . base CSSPrefix + 'mask -transparent ' } ) ; set Timeout ( function ( ) { mask . destroy ( ) ; } , 0 ) ; } 
function ( el , prefix ) { if ( el & & el . id ) { return el . id ; } el = Ext . get Dom ( el ) | | { } ; if ( el = = = document | | el = = = document . document Element ) { el . id = 'ext -app ' ; } else if ( el = = = document . body ) { el . id = 'ext -body ' ; } else if ( el = = = window ) { el . id = 'ext -window ' ; } el . id = el . id | | ( ( prefix | | 'ext - ' ) + ( + + Ext . id Seed ) ) ; return el . id ; } 
function ( ) { if ( ! Ext . document Body Element ) { if ( ! document . body ) { throw new Error ( " [Ext .get Body ] document .body does not exist at this point " ) ; } Ext . document Body Element = Ext . get ( document . body ) ; } return Ext . document Body Element ; } 
function ( ) { if ( ! Ext . document Head Element ) { Ext . document Head Element = Ext . get ( document . head | | document . get Elements By Tag Name ( 'head ' ) [ 0 ] ) ; } return Ext . document Head Element ; } 
function ( dest , source , names , use Prototype Keys ) { if ( typeof names = = 'string ' ) { names = names . split ( / [ , ; \s ] / ) ; } Ext . each ( names , function ( name ) { if ( use Prototype Keys | | source . has Own Property ( name ) ) { dest [ name ] = source [ name ] ; } } , this ) ; return dest ; } 
function ( ) { var args = arguments , ln = args . length , i , item ; for ( i = 0 ; i < ln ; i + + ) { item = args [ i ] ; if ( item ) { if ( Ext . is Array ( item ) ) { this . destroy . apply ( this , item ) ; } else if ( Ext . is Function ( item . destroy ) ) { item . destroy ( ) ; } } } } 
function ( el ) { if ( ! el | | ! document ) { return null ; } return el . dom ? el . dom : ( typeof el = = 'string ' ? document . get Element By Id ( el ) : el ) ; } 
function ( node ) { if ( node & & node . parent Node & & node . tag Name ! = 'BODY ' ) { Ext . get ( node ) . clear Listeners ( ) ; node . parent Node . remove Child ( node ) ; delete Ext . cache [ node . id ] ; } } 
function ( config ) { var default Setup Config = Ext . default Setup Config , empty Fn = Ext . empty Fn , on Ready = config . on Ready | | empty Fn , on Updated = config . on Updated | | empty Fn , scope = config . scope , requires = Ext . Array . from ( config . requires ) , ext On Ready = Ext . on Ready , head = Ext . get Head ( ) , callback , viewport , precomposed ; Ext . setup = function ( ) { throw new Error ( "Ext .setup has already been called before " ) ; } ; delete config . requires ; delete config . on Ready ; delete config . on Updated ; delete config . scope ; Ext . require ( [ 'Ext .event .Dispatcher ' ] ) ; callback = function ( ) { var listeners = Ext . setup Listeners , ln = listeners . length , i , listener ; delete Ext . setup Listeners ; Ext . is Setup = true ; for ( i = 0 ; i < ln ; i + + ) { listener = listeners [ i ] ; listener . fn . call ( listener . scope ) ; } Ext . on Ready = ext On Ready ; Ext . on Ready ( on Ready , scope ) ; } ; Ext . on Updated = on Updated ; Ext . on Ready = function ( fn , scope ) { var origin = on Ready ; on Ready = function ( ) { origin ( ) ; Ext . on Ready ( fn , scope ) ; } ; } ; config = Ext . merge ( { } , default Setup Config , config ) ; Ext . on Document Ready ( function ( ) { Ext . factory Config ( config , function ( data ) { Ext . event . Dispatcher . get Instance ( ) . set Publishers ( data . event Publishers ) ; if ( data . logger ) { Ext . Logger = data . logger ; } if ( data . animator ) { Ext . Animator = data . animator ; } if ( data . viewport ) { Ext . Viewport = viewport = data . viewport ; if ( ! scope ) { scope = viewport ; } Ext . require ( requires , function ( ) { Ext . Viewport . on ( 'ready ' , callback , null , { single : true } ) ; } ) ; } else { Ext . require ( requires , callback ) ; } } ) ; if ( ! Ext . microloaded & & navigator . user Agent . match ( / IEMobile \ / 1 0 \ . 0 / ) ) { var ms Viewport Style = document . create Element ( "style " ) ; ms Viewport Style . append Child ( document . create Text Node ( " @media screen and (orientation : portrait ) { " + " @ -ms -viewport {width : 3 2 0px !important ; } " + " } " + " @media screen and (orientation : landscape ) { " + " @ -ms -viewport {width : 5 6 0px !important ; } " + " } " ) ) ; head . append Child ( ms Viewport Style ) ; } } ) ; function add Meta ( name , content ) { var meta = document . create Element ( 'meta ' ) ; meta . set Attribute ( 'name ' , name ) ; meta . set Attribute ( 'content ' , content ) ; head . append ( meta ) ; } function add Icon ( href , sizes , precomposed ) { var link = document . create Element ( 'link ' ) ; link . set Attribute ( 'rel ' , 'apple -touch -icon ' + ( precomposed ? ' -precomposed ' : ' ' ) ) ; link . set Attribute ( 'href ' , href ) ; if ( sizes ) { link . set Attribute ( 'sizes ' , sizes ) ; } head . append ( link ) ; } function add Startup Image ( href , media ) { var link = document . create Element ( 'link ' ) ; link . set Attribute ( 'rel ' , 'apple -touch -startup -image ' ) ; link . set Attribute ( 'href ' , href ) ; if ( media ) { link . set Attribute ( 'media ' , media ) ; } head . append ( link ) ; } var icon = config . icon , is Icon Precomposed = Boolean ( config . is Icon Precomposed ) , startup Image = config . startup Image | | { } , status Bar Style = config . status Bar Style | | 'black ' , device Pixel Ratio = window . device Pixel Ratio | | 1 ; if ( navigator . standalone ) { add Meta ( 'viewport ' , 'width =device -width , initial -scale = 1 . 0 , maximum -scale = 1 . 0 , minimum -scale = 1 . 0 ' ) ; } else { add Meta ( 'viewport ' , 'initial -scale = 1 . 0 , maximum -scale = 1 . 0 , minimum -scale = 1 . 0 , minimum -ui ' ) ; } add Meta ( 'apple -mobile -web -app -capable ' , 'yes ' ) ; add Meta ( 'apple -touch -fullscreen ' , 'yes ' ) ; if ( Ext . browser . is . ie ) { add Meta ( 'msapplication -tap -highlight ' , 'no ' ) ; } 
function ( config ) { var app Name = config . name , on Ready , scope , requires ; if ( ! config ) { config = { } ; } if ( ! Ext . Loader . config . paths [ app Name ] ) { Ext . Loader . set Path ( app Name , config . app Folder | | 'app ' ) ; } requires = Ext . Array . from ( config . requires ) ; config . requires = [ 'Ext .app .Application ' ] ; on Ready = config . on Ready ; scope = config . scope ; config . on Ready = function ( ) { config . requires = requires ; new Ext . app . Application ( config ) ; if ( on Ready ) { on Ready . call ( scope ) ; } } ; Ext . setup ( config ) ; } 
function ( config , class Reference , instance , alias Namespace ) { var manager = Ext . Class Manager , new Instance ; 
function ( ) { var map = Ext . Component Manager . all . map , leaks = [ ] , parent ; Ext . Object . each ( map , function ( id , component ) { while ( ( parent = component . get Parent ( ) ) & & map . has Own Property ( parent . get Id ( ) ) ) { component = parent ; } if ( leaks . index Of ( component ) = = = - 1 ) { leaks . push ( component ) ; } } ) ; console . log ( leaks ) ; } 
function add Action ( name , fn ) { if ( typeof name = = = "object " & & fn = = null ) { _ . each ( name , function ( fn , n ) { this . add Action ( n , fn ) ; } , this ) ; return this ; } if ( typeof name ! = = "string " | | name = = = " " ) throw new Error ( "Expecting non -empty string for action name . " ) ; if ( typeof fn ! = = "function " ) throw new Error ( "Expecting function for action . " ) ; if ( this . _actions = = null ) this . _actions = { } ; if ( this . _actions [ name ] = = null ) this . _actions [ name ] = [ ] ; if ( ! ~ this . _actions [ name ] . index Of ( fn ) ) this . _actions [ name ] . push ( fn ) ; return this ; } 
function ( options ) { this . options = options ; this . headers = { 'User -Agent ' : 'request /grunt -github -release -asset ' } ; var auth Str ; if ( options . credentials ) { if ( options . credentials . token ) { auth Str = options . credentials . token + ' : ' + ' ' ; } else if ( options . credentials . username & & options . credentials . password ) { auth Str = options . credentials . username + ' : ' + options . credentials . password ; } } if ( ! auth Str ) { throw new Error ( 'Please supply a token or username & password to authorize yourself . ' ) ; } this . headers [ 'Authorization ' ] = 'Basic ' + ( new Buffer ( auth Str ) . to String ( 'base 6 4 ' ) ) try { this . repo Path = options . repo . split ( ' : ' ) [ 1 ] . split ( ' . ' ) . slice ( 0 , - 1 ) . join ( ' . ' ) . to Lower Case ( ) ; } catch ( err ) { throw new Error ( 'Repository url isn \ 't provided or isn \ 't valid . ' ) ; } } 
function map ( fn , list ) { var end = list . length var idx = - 1 var out = [ ] while ( + + idx < end ) { out . push ( ( typeof fn = = = 'string ' ) ? selectn ( fn , list [ idx ] ) : fn ( list [ idx ] ) ) } return out } 
function isfinite ( arr ) { if ( ! Array . is Array ( arr ) ) { throw new Type Error ( 'isfinite ( ) : :invalid input argument . Must provide an array . ' ) ; } var len = arr . length , out = new Array ( len ) , val ; for ( var i = 0 ; i < len ; i + + ) { out [ i ] = 0 ; val = arr [ i ] ; if ( typeof val = = = 'number ' & & val = = = val & & val < pinf & & val > ninf ) { out [ i ] = 1 ; } } return out ; } 
function exec ( options , callback ) { return cmd ( _ . assign ( options , { type : 'exec ' } ) , _ . cb ( callback ) ) } 
function exec File ( options , callback ) { return cmd ( _ . assign ( options , { type : 'exec File ' } ) , _ . cb ( callback ) ) } 
function cmd ( options , callback ) { let opts = _ . merge ( { } , DEFAULTS , options ) let { cmd = ' ' , type = ' ' , args = [ ] , switches = { } } = opts type = type & & _ . is String ( type ) & & _ . includes ( [ 'exec ' , 'exec File ' ] , type ) ? type : 'exec ' args = args & & _ . is Array ( args ) ? args : [ ] switches = switches & & _ . is Plain Object ( switches ) ? _ . merge ( switches , _ . omit ( JARGV | | { } , [ ' _ ' ] ) ) | | { } : { } let method = _ . get ( cproc , type ) if ( ! cmd | | ! _ . is String ( cmd ) ) return _ . fail ( 'Invalid cmd ' , callback ) if ( ! _ . is Function ( method ) ) return _ . fail ( 'Invalid type ' , callback ) _ . for In ( switches , ( v , k ) = > { if ( ! v & & ! k ) return let arg = v & & k ? ` $ { k } $ { v } ` : ` $ { k | | v } ` if ( arg ) args . push ( arg ) } ) args = _ . compact ( args ) let is Exec = type = = = 'exec ' _ . assign ( opts , { args : args } ) opts = _ . omit ( opts , [ 'type ' , 'switches ' ] ) 
function _handle Child ( child , callback ) { if ( ! child ) return _ . fail ( 'Invalid child process ' , callback ) if ( _ . is Error ( child ) ) return _ . fail ( child , callback ) let stdout = ' ' let stderr = ' ' child . stdout . on ( 'data ' , function ( data ) { stdout + = data } ) child . stderr . on ( 'data ' , function ( data ) { stderr + = data } ) child . on ( 'close ' , function ( code ) { return _ . done ( stdout | | stderr , callback ) } ) child . on ( 'disconnect ' , function ( err ) { } ) child . on ( 'error ' , function ( err ) { } ) child . on ( 'exit ' , function ( code , signal ) { } ) child . on ( 'message ' , function ( message , send Handle ) { } ) return child } 
function query ( data , options , clbk ) { var opts ; * FUNCTION : done ( error , response , data ) * Callback invoked after completing request . * * @private * @param {Error |Null } error - error object * @param {Object } response - HTTP response object * @param {Object } data - response data * @returns {Void } * / function done ( error , response , data ) { if ( error ) { return clbk ( error ) ; } debug ( 'Request successfully completed . ' ) ; clbk ( null , data ) ; } 
function done ( error , response , data ) { if ( error ) { return clbk ( error ) ; } debug ( 'Request successfully completed . ' ) ; clbk ( null , data ) ; } 
function get Digest ( cfg ) { var ha 1 , ha 2 , response ; ha 1 = crypto . create Hash ( 'md 5 ' ) . update ( cfg . from Ext + ' : ' + cfg . realm + ' : ' + cfg . pass ) . digest ( 'hex ' ) ; ha 2 = crypto . create Hash ( 'md 5 ' ) . update ( cfg . meth + ' : ' + cfg . auth Uri ) . digest ( 'hex ' ) ; 
function ( property , obj , new Property ) { if ( config . has Own Property ( property ) ) { if ( obj ) { config [ obj ] = config [ obj ] | | { } ; config [ obj ] [ ( new Property ) ? new Property : property ] = config [ obj ] [ ( new Property ) ? new Property : property ] | | config [ property ] ; } else { config [ new Property ] = config [ property ] ; } delete config [ property ] ; 
function Store ( name , items ) { if ( ! name ) { throw new Error ( 'Please give the store a name ! ' ) ; } this . name = name ; this . items = items | | { } ; this . type = 'object ' ; this . set Type ( ) ; return this ; } 
function node ( content , type , name , indent ) { this . type = type ; if ( name ) this . name = name ; this . content = content ; if ( indent ) { this . indent = indent ; 
function f ( arr ) { if ( arr ) { var merged = [ ] ; return merged . concat . apply ( merged , arr ) . join ( " " ) } } 
function configure Store ( on Complete ) { 
function ( el , config ) { var me = this ; config = config | | { } ; Ext . apply ( me , config ) ; me . el = Ext . get ( el ) ; me . call Parent ( ) ; me . mixins . observable . constructor . call ( me ) ; if ( ! me . disabled ) { me . enable ( ) ; } me . el . add Cls ( me . base Cls ) ; } 
function ( ) { if ( ! this . mgr ) { this . mgr = Ext . util . Observable . observe ( Ext . util . Draggable ) ; } this . mgr . on ( { dragstart : this . on Drag Start , scope : this } ) ; this . disabled = false ; } 
function ns ( rootpath , src ) { return _ . compact ( src . replace ( rootpath , ' ' ) . split ( path . sep ) ) . join ( ' . ' ) } 
function nspath ( ) { let src = _ . join ( _ . filter ( _ . to Array ( arguments ) , function ( arg ) { return arg & & _ . is String ( arg ) } ) , ' . ' ) if ( ! src ) return ' ' return _ . replace ( src , REGX _DOTS , ' / ' ) } 
function diff ( rootpath , src ) { return _ . is String ( rootpath ) & & _ . is String ( src ) ? src . replace ( rootpath , ' ' ) . split ( path . sep ) . join ( ' / ' ) : ' ' } 
function rel ( root , src , sep ) { if ( ! root | | ! _ . is String ( root ) | | ! src | | ! _ . is String ( src ) ) return let root _split = root . split ( path . sep ) , src _split = src . split ( path . sep ) return _ . join ( _ . difference ( src _split , root _split ) , sep | | ' / ' ) } 
function rebase ( root , src , dest ) { let relp = rel ( root , src ) return relp ? path . join ( dest , relp ) : ' ' } 
function ( parent , name , type ) { if ( Java Script Compiler . RESERVED _WORDS [ name ] | | name . index Of ( ' - ' ) ! = = - 1 | | ! is Na N ( name ) ) { return parent + " [ ' " + name + " ' ] " ; } else if ( / ^ [ 0 - 9 ] + $ / . test ( name ) ) { return parent + " [ " + name + " ] " ; } else { return parent + " . " + name ; } } 
function ( environment , options ) { this . environment = environment ; this . options = options | | { } ; this . preamble ( ) ; this . stack Slot = 0 ; this . stack Vars = [ ] ; this . registers = { list : [ ] } ; this . compile Children ( environment , options ) ; Handlebars . log ( Handlebars . logger . DEBUG , environment . disassemble ( ) + " \n \n " ) ; var opcodes = environment . opcodes , opcode , name , declare Name , declare Val ; this . i = 0 ; for ( l = opcodes . length ; this . i < l ; this . i + + ) { opcode = this . next Opcode ( 0 ) ; if ( opcode [ 0 ] = = = 'DECLARE ' ) { this . i = this . i + 2 ; this [ opcode [ 1 ] ] = opcode [ 2 ] ; } else { this . i = this . i + opcode [ 1 ] . length ; this [ opcode [ 0 ] ] . apply ( this , opcode [ 1 ] ) ; } } return this . create Function ( ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _handlebars Runtime = _ _webpack _require _ _ ( 2 ) ; var _handlebars Runtime 2 = _interop Require Default ( _handlebars Runtime ) ; 
function ( module , exports ) { "use strict " ; exports [ "default " ] = function ( obj ) { return obj & & obj . _ _es Module ? obj : { "default " : obj } ; } ; exports . _ _es Module = true ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Wildcard = _ _webpack _require _ _ ( 3 ) [ 'default ' ] ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _handlebars Base = _ _webpack _require _ _ ( 4 ) ; var base = _interop Require Wildcard ( _handlebars Base ) ; 
function ( module , exports ) { "use strict " ; exports [ "default " ] = function ( obj ) { if ( obj & & obj . _ _es Module ) { return obj ; } else { var new Obj = { } ; if ( obj ! = null ) { for ( var key in obj ) { if ( Object . prototype . has Own Property . call ( obj , key ) ) new Obj [ key ] = obj [ key ] ; } } new Obj [ "default " ] = obj ; return new Obj ; } } ; exports . _ _es Module = true ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . Handlebars Environment = Handlebars Environment ; var _utils = _ _webpack _require _ _ ( 5 ) ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; var _helpers = _ _webpack _require _ _ ( 7 ) ; var _decorators = _ _webpack _require _ _ ( 1 5 ) ; var _logger = _ _webpack _require _ _ ( 1 7 ) ; var _logger 2 = _interop Require Default ( _logger ) ; var VERSION = ' 4 . 0 . 5 ' ; exports . VERSION = VERSION ; var COMPILER _REVISION = 7 ; exports . COMPILER _REVISION = COMPILER _REVISION ; var REVISION _CHANGES = { 1 : ' < = 1 . 0 .rc . 2 ' , 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . register Default Helpers = register Default Helpers ; var _helpers Block Helper Missing = _ _webpack _require _ _ ( 8 ) ; var _helpers Block Helper Missing 2 = _interop Require Default ( _helpers Block Helper Missing ) ; var _helpers Each = _ _webpack _require _ _ ( 9 ) ; var _helpers Each 2 = _interop Require Default ( _helpers Each ) ; var _helpers Helper Missing = _ _webpack _require _ _ ( 1 0 ) ; var _helpers Helper Missing 2 = _interop Require Default ( _helpers Helper Missing ) ; var _helpers If = _ _webpack _require _ _ ( 1 1 ) ; var _helpers If 2 = _interop Require Default ( _helpers If ) ; var _helpers Log = _ _webpack _require _ _ ( 1 2 ) ; var _helpers Log 2 = _interop Require Default ( _helpers Log ) ; var _helpers Lookup = _ _webpack _require _ _ ( 1 3 ) ; var _helpers Lookup 2 = _interop Require Default ( _helpers Lookup ) ; var _helpers With = _ _webpack _require _ _ ( 1 4 ) ; var _helpers With 2 = _interop Require Default ( _helpers With ) ; function register Default Helpers ( instance ) { _helpers Block Helper Missing 2 [ 'default ' ] ( instance ) ; _helpers Each 2 [ 'default ' ] ( instance ) ; _helpers Helper Missing 2 [ 'default ' ] ( instance ) ; _helpers If 2 [ 'default ' ] ( instance ) ; _helpers Log 2 [ 'default ' ] ( instance ) ; _helpers Lookup 2 [ 'default ' ] ( instance ) ; _helpers With 2 [ 'default ' ] ( instance ) ; } } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'block Helper Missing ' , function ( context , options ) { var inverse = options . inverse , fn = options . fn ; if ( context = = = true ) { return fn ( this ) ; } else if ( context = = = false | | context = = null ) { return inverse ( this ) ; } else if ( _utils . is Array ( context ) ) { if ( context . length > 0 ) { if ( options . ids ) { options . ids = [ options . name ] ; } return instance . helpers . each ( context , options ) ; } else { return inverse ( this ) ; } } else { if ( options . data & & options . ids ) { var data = _utils . create Frame ( options . data ) ; data . context Path = _utils . append Context Path ( options . data . context Path , options . name ) ; options = { data : data } ; } return fn ( context , options ) ; } } ) ; } ; module . exports = exports [ 'default ' ] ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'each ' , function ( context , options ) { if ( ! options ) { throw new _exception 2 [ 'default ' ] ( 'Must pass iterator to #each ' ) ; } var fn = options . fn , inverse = options . inverse , i = 0 , ret = ' ' , data = undefined , context Path = undefined ; if ( options . data & & options . ids ) { context Path = _utils . append Context Path ( options . data . context Path , options . ids [ 0 ] ) + ' . ' ; } if ( _utils . is Function ( context ) ) { context = context . call ( this ) ; } if ( options . data ) { data = _utils . create Frame ( options . data ) ; } function exec Iteration ( field , index , last ) { if ( data ) { data . key = field ; data . index = index ; data . first = index = = = 0 ; data . last = ! ! last ; if ( context Path ) { data . context Path = context Path + field ; } } ret = ret + fn ( context [ field ] , { data : data , block Params : _utils . block Params ( [ context [ field ] , field ] , [ context Path + field , null ] ) } ) ; } if ( context & & typeof context = = = 'object ' ) { if ( _utils . is Array ( context ) ) { for ( var j = context . length ; i < j ; i + + ) { if ( i in context ) { exec Iteration ( i , i , i = = = context . length - 1 ) ; } } } else { var prior Key = undefined ; for ( var key in context ) { if ( context . has Own Property ( key ) ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'helper Missing ' , function ( ) { if ( arguments . length = = = 1 ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'if ' , function ( conditional , options ) { if ( _utils . is Function ( conditional ) ) { conditional = conditional . call ( this ) ; } 
function ( module , exports ) { 'use strict ' ; exports . _ _es Module = true ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'log ' , function ( ) { var args = [ undefined ] , options = arguments [ arguments . length - 1 ] ; for ( var i = 0 ; i < arguments . length - 1 ; i + + ) { args . push ( arguments [ i ] ) ; } var level = 1 ; if ( options . hash . level ! = null ) { level = options . hash . level ; } else if ( options . data & & options . data . level ! = null ) { level = options . data . level ; } args [ 0 ] = level ; instance . log . apply ( instance , args ) ; } ) ; } ; module . exports = exports [ 'default ' ] ; } 
function ( module , exports ) { 'use strict ' ; exports . _ _es Module = true ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'lookup ' , function ( obj , field ) { return obj & & obj [ field ] ; } ) ; } ; module . exports = exports [ 'default ' ] ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; exports [ 'default ' ] = function ( instance ) { instance . register Helper ( 'with ' , function ( context , options ) { if ( _utils . is Function ( context ) ) { context = context . call ( this ) ; } var fn = options . fn ; if ( ! _utils . is Empty ( context ) ) { var data = options . data ; if ( options . data & & options . ids ) { data = _utils . create Frame ( options . data ) ; data . context Path = _utils . append Context Path ( options . data . context Path , options . ids [ 0 ] ) ; } return fn ( context , { data : data , block Params : _utils . block Params ( [ context ] , [ data & & data . context Path ] ) } ) ; } else { return options . inverse ( this ) ; } } ) ; } ; module . exports = exports [ 'default ' ] ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . register Default Decorators = register Default Decorators ; var _decorators Inline = _ _webpack _require _ _ ( 1 6 ) ; var _decorators Inline 2 = _interop Require Default ( _decorators Inline ) ; function register Default Decorators ( instance ) { _decorators Inline 2 [ 'default ' ] ( instance ) ; } } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; exports [ 'default ' ] = function ( instance ) { instance . register Decorator ( 'inline ' , function ( fn , props , container , options ) { var ret = fn ; if ( ! props . partials ) { props . partials = { } ; ret = function ( context , options ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; var logger = { method Map : [ 'debug ' , 'info ' , 'warn ' , 'error ' ] , level : 'info ' , 
function lookup Level ( level ) { if ( typeof level = = = 'string ' ) { var level Map = _utils . index Of ( logger . method Map , level . to Lower Case ( ) ) ; if ( level Map > = 0 ) { level = level Map ; } else { level = parse Int ( level , 1 0 ) ; } } return level ; } 
function log ( level ) { level = logger . lookup Level ( level ) ; if ( typeof console ! = = 'undefined ' & & logger . lookup Level ( logger . level ) < = level ) { var method = logger . method Map [ level ] ; if ( ! console [ method ] ) { 
function ( module , exports ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Wildcard = _ _webpack _require _ _ ( 3 ) [ 'default ' ] ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . check Revision = check Revision ; exports . template = template ; exports . wrap Program = wrap Program ; exports . resolve Partial = resolve Partial ; exports . invoke Partial = invoke Partial ; exports . noop = noop ; var _utils = _ _webpack _require _ _ ( 5 ) ; var Utils = _interop Require Wildcard ( _utils ) ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; var _base = _ _webpack _require _ _ ( 4 ) ; function check Revision ( compiler Info ) { var compiler Revision = compiler Info & & compiler Info [ 0 ] | | 1 , current Revision = _base . COMPILER _REVISION ; if ( compiler Revision ! = = current Revision ) { if ( compiler Revision < current Revision ) { var runtime Versions = _base . REVISION _CHANGES [ current Revision ] , compiler Versions = _base . REVISION _CHANGES [ compiler Revision ] ; throw new _exception 2 [ 'default ' ] ( 'Template was precompiled with an older version of Handlebars than the current runtime . ' + 'Please update your precompiler to a newer version ( ' + runtime Versions + ' ) or downgrade your runtime to an older version ( ' + compiler Versions + ' ) . ' ) ; } else { 
function ( module , exports ) { ( function ( global ) { 'use strict ' ; exports . _ _es Module = true ; exports [ 'default ' ] = function ( Handlebars ) { var root = typeof global ! = = 'undefined ' ? global : window , $Handlebars = root . Handlebars ; Handlebars . no Conflict = function ( ) { if ( root . Handlebars = = = Handlebars ) { root . Handlebars = $Handlebars ; } return Handlebars ; } ; } ; module . exports = exports [ 'default ' ] ; } . call ( exports , ( function ( ) { return this ; } ( ) ) ) ) } 
function ( module , exports ) { 'use strict ' ; exports . _ _es Module = true ; var AST = { 
function helper Expression ( node ) { return node . type = = = 'Sub Expression ' | | ( node . type = = = 'Mustache Statement ' | | node . type = = = 'Block Statement ' ) & & ! ! ( node . params & & node . params . length | | node . hash ) ; } 
function simple Id ( path ) { return path . parts . length = = = 1 & & ! AST . helpers . scoped Id ( path ) & & ! path . depth ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; var _interop Require Wildcard = _ _webpack _require _ _ ( 3 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . parse = parse ; var _parser = _ _webpack _require _ _ ( 2 3 ) ; var _parser 2 = _interop Require Default ( _parser ) ; var _whitespace Control = _ _webpack _require _ _ ( 2 4 ) ; var _whitespace Control 2 = _interop Require Default ( _whitespace Control ) ; var _helpers = _ _webpack _require _ _ ( 2 6 ) ; var Helpers = _interop Require Wildcard ( _helpers ) ; var _utils = _ _webpack _require _ _ ( 5 ) ; exports . parser = _parser 2 [ 'default ' ] ; var yy = { } ; _utils . extend ( yy , Helpers ) ; function parse ( input , options ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _visitor = _ _webpack _require _ _ ( 2 5 ) ; var _visitor 2 = _interop Require Default ( _visitor ) ; function Whitespace Control ( ) { var options = arguments . length < = 0 | | arguments [ 0 ] = = = undefined ? { } : arguments [ 0 ] ; this . options = options ; } Whitespace Control . prototype = new _visitor 2 [ 'default ' ] ( ) ; Whitespace Control . prototype . Program = function ( program ) { var do Standalone = ! this . options . ignore Standalone ; var is Root = ! this . is Root Seen ; this . is Root Seen = true ; var body = program . body ; for ( var i = 0 , l = body . length ; i < l ; i + + ) { var current = body [ i ] , strip = this . accept ( current ) ; if ( ! strip ) { continue ; } var _is Prev Whitespace = is Prev Whitespace ( body , i , is Root ) , _is Next Whitespace = is Next Whitespace ( body , i , is Root ) , open Standalone = strip . open Standalone & & _is Prev Whitespace , close Standalone = strip . close Standalone & & _is Next Whitespace , inline Standalone = strip . inline Standalone & & _is Prev Whitespace & & _is Next Whitespace ; if ( strip . close ) { omit Right ( body , i , true ) ; } if ( strip . open ) { omit Left ( body , i , true ) ; } if ( do Standalone & & inline Standalone ) { omit Right ( body , i ) ; if ( omit Left ( body , i ) ) { 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; function Visitor ( ) { this . parents = [ ] ; } Visitor . prototype = { constructor : Visitor , mutating : false , 
function accept Key ( node , name ) { var value = this . accept ( node [ name ] ) ; if ( this . mutating ) { 
function accept Required ( node , name ) { this . accept Key ( node , name ) ; if ( ! node [ name ] ) { throw new _exception 2 [ 'default ' ] ( node . type + ' requires ' + name ) ; } } 
function accept Array ( array ) { for ( var i = 0 , l = array . length ; i < l ; i + + ) { this . accept Key ( array , i ) ; if ( ! array [ i ] ) { array . splice ( i , 1 ) ; i - - ; l - - ; } } } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . Source Location = Source Location ; exports . id = id ; exports . strip Flags = strip Flags ; exports . strip Comment = strip Comment ; exports . prepare Path = prepare Path ; exports . prepare Mustache = prepare Mustache ; exports . prepare Raw Block = prepare Raw Block ; exports . prepare Block = prepare Block ; exports . prepare Program = prepare Program ; exports . prepare Partial Block = prepare Partial Block ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; function validate Close ( open , close ) { close = close . path ? close . path . original : close ; if ( open . path . original ! = = close ) { var error Node = { loc : open . path . loc } ; throw new _exception 2 [ 'default ' ] ( open . path . original + " doesn 't match " + close , error Node ) ; } } function Source Location ( source , loc Info ) { this . source = source ; this . start = { line : loc Info . first _line , column : loc Info . first _column } ; this . end = { line : loc Info . last _line , column : loc Info . last _column } ; } function id ( token ) { if ( / ^ \ [ . * \ ] $ / . test ( token ) ) { return token . substr ( 1 , token . length - 2 ) ; } else { return token ; } } function strip Flags ( open , close ) { return { open : open . char At ( 2 ) = = = ' ~ ' , close : close . char At ( close . length - 3 ) = = = ' ~ ' } ; } function strip Comment ( comment ) { return comment . replace ( / ^ \ { \ { ~ ? \ ! - ? - ? / , ' ' ) . replace ( / - ? - ? ~ ? \ } \ } $ / , ' ' ) ; } function prepare Path ( data , parts , loc ) { loc = this . loc Info ( loc ) ; var original = data ? ' @ ' : ' ' , dig = [ ] , depth = 0 , depth String = ' ' ; for ( var i = 0 , l = parts . length ; i < l ; i + + ) { var part = parts [ i ] . part , 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; exports . Compiler = Compiler ; exports . precompile = precompile ; exports . compile = compile ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; var _utils = _ _webpack _require _ _ ( 5 ) ; var _ast = _ _webpack _require _ _ ( 2 1 ) ; var _ast 2 = _interop Require Default ( _ast ) ; var slice = [ ] . slice ; function Compiler ( ) { } 
function opcode ( name ) { this . opcodes . push ( { opcode : name , args : slice . call ( arguments , 1 ) , loc : this . source Node [ 0 ] . loc } ) ; } 
function ret ( context , exec Options ) { if ( ! compiled ) { compiled = compile Input ( ) ; } return compiled . call ( this , context , exec Options ) ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; var _interop Require Default = _ _webpack _require _ _ ( 1 ) [ 'default ' ] ; exports . _ _es Module = true ; var _base = _ _webpack _require _ _ ( 4 ) ; var _exception = _ _webpack _require _ _ ( 6 ) ; var _exception 2 = _interop Require Default ( _exception ) ; var _utils = _ _webpack _require _ _ ( 5 ) ; var _code Gen = _ _webpack _require _ _ ( 2 9 ) ; var _code Gen 2 = _interop Require Default ( _code Gen ) ; function Literal ( value ) { this . value = value ; } function Java Script Compiler ( ) { } Java Script Compiler . prototype = { 
function name Lookup ( parent , name ) { if ( Java Script Compiler . is Valid Java Script Variable Name ( name ) ) { return [ parent , ' . ' , name ] ; } else { return [ parent , ' [ ' , JSON . stringify ( name ) , ' ] ' ] ; } } 
function block Value ( name ) { var block Helper Missing = this . aliasable ( 'helpers .block Helper Missing ' ) , params = [ this . context Name ( 0 ) ] ; this . setup Helper Args ( name , 0 , params ) ; var block Name = this . pop Stack ( ) ; params . splice ( 1 , 0 , block Name ) ; this . push ( this . source . function Call ( block Helper Missing , 'call ' , params ) ) ; } 
function ambiguous Block Value ( ) { 
function append Content ( content ) { if ( this . pending Content ) { content = this . pending Content + content ; } else { this . pending Location = this . source . current Location ; } this . pending Content = content ; } 
function append ( ) { if ( this . is Inline ( ) ) { this . replace Stack ( function ( current ) { return [ ' ! = null ? ' , current , ' : " " ' ] ; } ) ; this . push Source ( this . append To Buffer ( this . pop Stack ( ) ) ) ; } else { var local = this . pop Stack ( ) ; this . push Source ( [ 'if ( ' , local , ' ! = null ) { ' , this . append To Buffer ( local , undefined , true ) , ' } ' ] ) ; if ( this . environment . is Simple ) { this . push Source ( [ 'else { ' , this . append To Buffer ( " ' ' " , undefined , true ) , ' } ' ] ) ; } } } 
function lookup On Context ( parts , falsy , strict , scoped ) { var i = 0 ; if ( ! scoped & & this . options . compat & & ! this . last Context ) { 
function lookup Block Param ( block Param Id , parts ) { this . use Block Params = true ; this . push ( [ 'block Params [ ' , block Param Id [ 0 ] , ' ] [ ' , block Param Id [ 1 ] , ' ] ' ] ) ; this . resolve Path ( 'context ' , parts , 1 ) ; } 
function push String Param ( string , type ) { this . push Context ( ) ; this . push String ( type ) ; 
function register Decorator ( param Size , name ) { var found Decorator = this . name Lookup ( 'decorators ' , name , 'decorator ' ) , options = this . setup Helper Args ( name , param Size ) ; this . decorators . push ( [ 'fn = ' , this . decorators . function Call ( found Decorator , ' ' , [ 'fn ' , 'props ' , 'container ' , options ] ) , ' | | fn ; ' ] ) ; } 
function invoke Helper ( param Size , name , is Simple ) { var non Helper = this . pop Stack ( ) , helper = this . setup Helper ( param Size , name ) , simple = is Simple ? [ helper . name , ' | | ' ] : ' ' ; var lookup = [ ' ( ' ] . concat ( simple , non Helper ) ; if ( ! this . options . strict ) { lookup . push ( ' | | ' , this . aliasable ( 'helpers .helper Missing ' ) ) ; } lookup . push ( ' ) ' ) ; this . push ( this . source . function Call ( lookup , 'call ' , helper . call Params ) ) ; } 
function invoke Known Helper ( param Size , name ) { var helper = this . setup Helper ( param Size , name ) ; this . push ( this . source . function Call ( helper . name , 'call ' , helper . call Params ) ) ; } 
function assign To Hash ( key ) { var value = this . pop Stack ( ) , context = undefined , type = undefined , id = undefined ; if ( this . track Ids ) { id = this . pop Stack ( ) ; } if ( this . string Params ) { type = this . pop Stack ( ) ; context = this . pop Stack ( ) ; } var hash = this . hash ; if ( context ) { hash . contexts [ key ] = context ; } if ( type ) { hash . types [ key ] = type ; } if ( id ) { hash . ids [ key ] = id ; } hash . values [ key ] = value ; } 
function ( module , exports , _ _webpack _require _ _ ) { 'use strict ' ; exports . _ _es Module = true ; var _utils = _ _webpack _require _ _ ( 5 ) ; var Source Node = undefined ; try { if ( false ) { 
function reduce Child List Mutation ( mutation Content , record ) { const is Added = Boolean ( record . added Nodes . length ) ; const is Next = Boolean ( record . next Sibling ) ; const is Prev = Boolean ( record . previous Sibling ) ; const is Removed = Boolean ( record . removed Nodes . length ) ; 
function Node ( options ) { if ( ! ( this instanceof Node ) ) { return new Node ( options ) } events . Event Emitter . call ( this ) this . _set Storage Adapter ( options . storage ) this . _log = options . logger this . _rpc = options . transport this . _self = this . _rpc . _contact this . _validator = options . validator this . _router = options . router | | new Router ( { logger : this . _log , transport : this . _rpc , validator : this . _validate Key Value Pair . bind ( this ) } ) this . _bind Router Event Handlers ( ) this . _bind RPCMessage Handlers ( ) this . _start Replication Interval ( ) this . _start Expiration Interval ( ) this . _log . info ( 'node created ' , { node ID : this . _self . node ID } ) } 
function ( ) { var deferred ; deferred = Q . defer ( ) ; if ( running . length < limit ) { running . push ( deferred ) ; deferred . resolve ( ) ; } else { queue . push ( deferred ) ; } return deferred . promise ; } 
function ( ) { var next ; running . pop ( ) ; if ( queue . length > 0 & & running . length < limit ) { switch ( type ) { case "lifo " : next = queue . pop ( ) ; break ; default : next = queue . shift ( ) ; } running . push ( next ) ; return next . resolve ( ) ; } } 
function ( ) { var promise ; while ( promise = queue . pop ( ) ) { promise . reject ( "flush " ) ; } while ( promise = running . pop ( ) ) { promise . reject ( "flush " ) ; } } 
function ( record ) { var me = this ; me . _record = record ; if ( record & & record . data ) { me . set Values ( record . data ) ; } return this ; } 
function ( options , e ) { options = options | | { } ; var me = this , form Values = me . get Values ( me . get Standard Submit ( ) | | ! options . submit Disabled ) , form = me . element . dom | | { } ; if ( this . get Enable Submission Form ( ) ) { form = this . create Submission Form ( form , form Values ) ; } options = Ext . apply ( { url : me . get Url ( ) | | form . action , submit : false , form : form , method : me . get Method ( ) | | form . method | | 'post ' , auto Abort : false , params : null , wait Msg : null , headers : null , success : null , failure : null } , options | | { } ) ; return me . fire Action ( 'beforesubmit ' , [ me , form Values , options , e ] , 'do Before Submit ' , null , null , 'after ' ) ; } 
function ( options ) { options = options | | { } ; var me = this , api = me . get Api ( ) , url = me . get Url ( ) | | options . url , wait Msg = options . wait Msg , success Fn = function ( response , data ) { me . set Values ( data . data ) ; if ( Ext . is Function ( options . success ) ) { options . success . call ( options . scope | | me , me , response , data ) ; } me . fire Event ( 'load ' , me , response ) ; } , failure Fn = function ( response , data ) { if ( Ext . is Function ( options . failure ) ) { options . failure . call ( scope , me , response , data ) ; } me . fire Event ( 'exception ' , me , response ) ; } , load , method , args ; if ( options . wait Msg ) { if ( typeof wait Msg = = = 'string ' ) { wait Msg = { xtype : 'loadmask ' , message : wait Msg } ; } me . set Masked ( wait Msg ) ; } if ( api ) { load = api . load ; if ( typeof load = = = 'string ' ) { load = Ext . direct . Manager . parse Method ( load ) ; if ( load ) { api . load = load ; } } if ( load ) { method = load . direct Cfg . method ; args = method . get Args ( me . get Params ( options . params ) , me . get Param Order ( ) , me . get Params As Hash ( ) ) ; args . push ( function ( data , response , success ) { me . set Masked ( false ) ; if ( success ) { success Fn ( response , data ) ; } else { failure Fn ( response , data ) ; } } , me ) ; return load . apply ( window , args ) ; } } else if ( url ) { return Ext . Ajax . request ( { url : url , timeout : ( options . timeout | | this . get Timeout ( ) ) * 1 0 0 0 , method : options . method | | 'GET ' , auto Abort : options . auto Abort , headers : Ext . apply ( { 'Content -Type ' : 'application /x -www -form -urlencoded ; charset =UTF - 8 ' } , options . headers | | { } ) , callback : function ( callback Options , success , response ) { var response Text = response . response Text , status Result = Ext . Ajax . parse Status ( response . status , response ) ; me . set Masked ( false ) ; if ( success ) { if ( status Result & & response Text . length = = 0 ) { success = true ; } else { response = Ext . decode ( response Text ) ; success = ! ! response . success ; } if ( success ) { success Fn ( response , response Text ) ; } else { failure Fn ( response , response Text ) ; } } else { failure Fn ( response , response Text ) ; } } } ) ; } } 
function ( values ) { var fields = this . get Fields ( ) , me = this , name , field , value , ln , i , f ; values = values | | { } ; for ( name in values ) { if ( values . has Own Property ( name ) ) { field = fields [ name ] ; value = values [ name ] ; if ( field ) { 
function ( enabled , all ) { var fields = this . get Fields ( ) , values = { } , is Array = Ext . is Array , field , value , add Value , bucket , name , ln , i ; 
function ( by Name ) { var fields = { } , item Name ; var get Fields From = function ( item ) { if ( item . is Field ) { item Name = item . get Name ( ) ; if ( ( by Name & & item Name = = by Name ) | | typeof by Name = = 'undefined ' ) { if ( fields . has Own Property ( item Name ) ) { if ( ! Ext . is Array ( fields [ item Name ] ) ) { fields [ item Name ] = [ fields [ item Name ] ] ; } fields [ item Name ] . push ( item ) ; } else { fields [ item Name ] = item ; } } } if ( item . is Container ) { item . items . each ( get Fields From ) ; } } ; this . get Items ( ) . each ( get Fields From ) ; return ( by Name ) ? ( fields [ by Name ] | | [ ] ) : fields ; } 
function ( ) { var fields = [ ] ; var get Fields From = function ( item ) { if ( item . is Field ) { fields . push ( item ) ; } if ( item . is Container ) { item . items . each ( get Fields From ) ; } } ; this . items . each ( get Fields From ) ; return fields ; } 
function ( cfg , target ) { 
function ( ) { var fields = this . get Fields Array ( ) , ln = fields . length , field , i ; for ( i = 0 ; i < ln ; i + + ) { field = fields [ i ] ; if ( field . is Focused ) { return field ; } } return null ; } 
function Bucket ( index , routing Table ) { if ( ! ( this instanceof Bucket ) ) { return new Bucket ( ) } assert ( _ . is Number ( index ) & & index > = 0 & & index < = constants . B ) this . index = index this . contacts = [ ] this . _cache = { } this . _routing Table = routing Table } 
function static Move ( source : string , dest : string , assets : Array < string > ) : Promise { assets . for Each ( folder = > { fs . copy ( path . join ( source , folder ) , path . join ( dest , folder ) ) ; } ) ; return Promise . resolve ( ) ; } 
function scss ( source : string , dest : string ) : Promise { return new Promise ( ( resolve , reject ) = > { sass . render ( { file : source , out File : dest , output Style : 'compressed ' , } , ( err , result ) = > { if ( err ) reject ( err ) ; fs . ensure File ( dest ) . then ( fs . write File ( dest , result . css ) ) . then ( resolve ) . catch ( reject ) ; } , ) ; } ) ; } 
function ( axis , scroller Position ) { if ( ! this . is Axis Enabled ( axis ) ) { return this ; } var scroller = this . get Scroller ( ) , scroller Max Position = scroller . get Max Position ( ) [ axis ] , scroller Container Size = scroller . get Container Size ( ) [ axis ] , value ; if ( scroller Max Position = = = 0 ) { value = scroller Position / scroller Container Size ; if ( scroller Position > = 0 ) { value + = 1 ; } } else { if ( scroller Position > scroller Max Position ) { value = 1 + ( ( scroller Position - scroller Max Position ) / scroller Container Size ) ; } else if ( scroller Position < 0 ) { value = scroller Position / scroller Container Size ; } else { value = scroller Position / scroller Max Position ; } } this . get Indicators ( ) [ axis ] . set Value ( value ) ; } 
function ( e ) { var changed Touches = e . changed Touches , touch = ( changed Touches & & changed Touches . length > 0 ) ? changed Touches [ 0 ] : e ; return this . from Touch ( touch ) ; } 
function ( point , threshold ) { if ( typeof threshold = = 'number ' ) { threshold = { x : threshold } ; threshold . y = threshold . x ; } var x = point . x , y = point . y , threshold X = threshold . x , threshold Y = threshold . y ; return ( this . x < = x + threshold X & & this . x > = x - threshold X & & this . y < = y + threshold Y & & this . y > = y - threshold Y ) ; } 
function ( point ) { if ( typeof point ! = 'object ' ) { point = { x : 0 , y : 0 } ; } return ( Math . round ( this . x ) = = = Math . round ( point . x ) & & Math . round ( this . y ) = = = Math . round ( point . y ) ) ; } 
function ssh Exec Single Command ( cnx Params , cmd , fn Output ) { var result = { "command " : cmd , "success " : true , "error " : null , "value " : null } ; return Q . promise ( function ( resolve , reject ) { var ssh Client = new SSHClient ( ) ; ssh Client . on ( 'ready ' , function ( ) { 
function ssh Command Parallel ( connection , commands , fn Output ) { var command List = commands . map ( function ( command ) { return ssh Exec Single Command ( connection , command , fn Output ) ; } ) ; return Q . all Settled ( command List ) . then ( function ( results ) { return results . map ( function ( result ) { if ( result . state = = = "rejected " ) { return result . reason ; } else { return result . value ; } } ) ; } ) ; } 
function ssh Command Sequence ( connection , commands , fn Output ) { var all Results = [ ] ; var success Handler = function ( next Promise ) { return function ( result ) { if ( result ! = = true ) { 
function replace Refs ( parsed , options ) { var top Level = top Level Decls And Refs ( parsed ) , refs To Replace = top Level . refs . filter ( ref = > should Ref Be Captured ( ref , top Level , options ) ) , locally Ignored = [ ] ; const replaced = Replace Visitor . run ( parsed , ( node , path ) = > { 
function generate Unique Name ( declared Names , hint ) { var unique = hint , n = 1 ; while ( declared Names . index Of ( unique ) > - 1 ) { if ( n > 1 0 0 0 ) throw new Error ( "Endless loop searching for unique variable " + unique ) ; unique = unique . replace ( / _ [ 0 - 9 ] + $ | $ / , " _ " + ( + + n ) ) ; } return unique ; } 
function additional Ignored Decls ( parsed , options ) { var top Level = top Level Decls And Refs ( parsed ) , ignore Decls = [ ] ; for ( var i = 0 ; i < top Level . scope . var Decls . length ; i + + ) { var decl = top Level . scope . var Decls [ i ] , path = Path ( top Level . scope . var Decl Paths [ i ] ) , parent = path . slice ( 0 , - 1 ) . get ( parsed ) ; if ( parent . type = = = "For Statement " | | parent . type = = = "For In Statement " | | parent . type = = = "For Of Statement " | | parent . type = = = "Export Named Declaration " ) ignore Decls . push ( . . . decl . declarations ) } return top Level . scope . catches . map ( ea = > ea . name ) . concat ( ignore Decls . map ( ea = > ea . id . name ) ) ; } 
function replace Class Decls ( parsed , options ) { if ( options . class To Function ) return class To Function Transform ( parsed , options . class To Function ) ; var top Level = top Level Decls And Refs ( parsed ) ; if ( ! top Level . class Decls . length ) return parsed ; for ( var i = parsed . body . length - 1 ; i > = 0 ; i - - ) { var stmt = parsed . body [ i ] ; if ( stmt . id & & top Level . class Decls . includes ( stmt ) ) parsed . body . splice ( i + 1 , 0 , assign Expr ( options . capture Obj , stmt . id , stmt . id , false ) ) ; } return parsed ; } 
function var Decl Or Assignment ( parsed , declarator , kind ) { var top Level = top Level Decls And Refs ( parsed ) , name = declarator . id . name return top Level . declared Names . index Of ( name ) > - 1 ? 
function Item ( key , value , publisher , timestamp ) { if ( ! ( this instanceof Item ) ) { return new Item ( key , value , publisher , timestamp ) } assert ( typeof key = = = 'string ' , 'Invalid key supplied ' ) assert ( utils . is Valid Key ( publisher ) , 'Invalid publisher node ID supplied ' ) if ( timestamp ) { assert ( typeof timestamp = = = 'number ' , 'Invalid timestamp supplied ' ) assert ( Date . now ( ) > = timestamp , 'Timestamp cannot be in the future ' ) } this . key = key this . value = value this . publisher = publisher this . timestamp = timestamp | | Date . now ( ) } 
function ( ) { function on Login Response ( res ) { if ( res . status Code = = = 3 0 2 & & res . headers [ 'location ' ] . index Of ( 'login .do ' ) = = = - 1 ) { console . log ( 'login success ' ) ; } else { throw new Error ( 'Login error ' ) ; } } request . post ( process . env . ONEAPM _LOGIN _URL ) . form ( { encode : true , username : process . env . ONEAPM _USERNAME , strong : true , password : base 6 4 ( process . env . ONEAPM _PASSWORD ) , } ) . on ( 'response ' , on Login Response ) ; } 
function on ( top ) { top = typeof top = = = 'string ' ? document . query Selector ( top ) : top ; var h = handle . bind ( this , top ) ; h . once = once . bind ( this , top ) ; return h ; } 
function handle ( top , element , type , fn , capture ) { if ( ! element | | ! ( typeof element = = = 'string ' | | typeof element . length = = = 'number ' | | typeof element . add Event Listener = = = 'function ' ) ) { throw new Type Error ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( element ) ) ; } if ( typeof type ! = = 'string ' ) throw new Type Error ( 'Event type must be a string , e .g . "click " , not ' + inspect ( type ) ) ; if ( typeof fn ! = = 'function ' ) throw new Type Error ( ' `fn ` (the function to call when the event is triggered ) must be a function , not ' + inspect ( fn ) ) ; if ( capture ! = = undefined & & capture ! = = false & & capture ! = = true ) { throw new Type Error ( ' `capture ` must be `undefined ` (defaults to `false ` ) , `false ` or `true ` , not ' + inspect ( capture ) ) ; } if ( typeof element = = = 'string ' ) { return handle Element ( top , type , function ( body , e ) { var target = find Match ( body , e . target , element ) ; e . delegate Target = target ; if ( target ) fn ( target , e ) ; } , capture ) ; } else if ( typeof element . add Event Listener ! = = 'function ' & & typeof element . length = = = 'number ' ) { return handle Elements ( element , type , fn , capture ) ; } else { return handle Element ( element , type , fn , capture ) ; } } 
function handle Elements ( elements , type , fn , capture ) { if ( ! elements | | typeof elements . length ! = = 'number ' ) throw new Type Error ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( elements ) ) ; if ( typeof type ! = = 'string ' ) throw new Type Error ( 'Event type must be a string , e .g . "click " , not ' + inspect ( type ) ) ; if ( typeof fn ! = = 'function ' ) throw new Type Error ( ' `fn ` (the function to call when the event is triggered ) must be a function , not ' + inspect ( fn ) ) ; if ( capture ! = = undefined & & capture ! = = false & & capture ! = = true ) { throw new Type Error ( ' `capture ` must be `undefined ` (defaults to `false ` ) , `false ` or `true ` , not ' + inspect ( capture ) ) ; } var handles = [ ] ; for ( var i = 0 ; i < elements . length ; i + + ) { handles . push ( handle Element ( elements [ i ] , type , fn , capture ) ) ; } return function dispose ( ) { for ( var i = 0 ; i < handles . length ; i + + ) { handles [ i ] ( ) ; } } ; } 
function handle Element ( element , type , fn , capture ) { if ( ! element | | typeof element . add Event Listener ! = = 'function ' ) throw new Type Error ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( element ) ) ; if ( typeof type ! = = 'string ' ) throw new Type Error ( 'Event type must be a string , e .g . "click " , not ' + inspect ( type ) ) ; if ( typeof fn ! = = 'function ' ) throw new Type Error ( ' `fn ` (the function to call when the event is triggered ) must be a function , not ' + inspect ( fn ) ) ; if ( capture ! = = undefined & & capture ! = = false & & capture ! = = true ) { throw new Type Error ( ' `capture ` must be `undefined ` (defaults to `false ` ) , `false ` or `true ` , not ' + inspect ( capture ) ) ; } function on Event ( e ) { e . delegate Target = element ; return fn ( element , e ) ; } element . add Event Listener ( type , on Event , capture | | false ) ; return element . remove Event Listener . bind ( element , type , on Event , capture | | false ) ; } 
function find Match ( top , bottom , selector ) { while ( bottom ! = top & & bottom ) { if ( matches ( bottom , selector ) ) return bottom ; bottom = bottom . parent Element ; } if ( bottom & & matches ( bottom , selector ) ) return bottom ; return null ; } 
function Crop And Resize ( arg , opt ) { this . box Init = new Box ( ) ; this . editor = new Editor ( arg ) ; this . mask = new JSYG ( ' <rect > ' ) [ 0 ] ; this . selection = new JSYG ( ' <rect > ' ) [ 0 ] ; this . pattern = new JSYG ( ' <pattern > ' ) [ 0 ] ; if ( arg ) this . set Node ( arg ) ; if ( opt ) this . enable ( opt ) ; } 
function ( width , height ) { var box = this . selection . get BBox ( ) ; return JSYG ( this . node ) . to Canvas ( ) . then ( function ( canvas ) { var max Width = canvas . get Attribute ( "width " ) , max Height = canvas . get Attribute ( "height " ) , x = Math . max ( 0 , box . x ) , y = Math . max ( 0 , box . y ) , box Width = Math . min ( max Width , box . width ) , box Height = Math . min ( max Height , box . height ) ; canvas = new Canvas ( canvas ) ; canvas = canvas . crop ( x , y , box Width , box Height ) ; if ( width ! = null | | height ! = null ) canvas = canvas . resize ( width , height ) ; return canvas [ 0 ] ; } ) ; } 
function ( opt ) { this . disable ( ) ; if ( opt ) this . set ( opt ) ; var j Node = new JSYG ( this . node ) , dim = j Node . get Dim ( ) , color = j Node . fill ( ) , svg = j Node . offset Parent ( ) , id = 'idpattern ' + JSYG . rand ( 0 , 5 0 0 0 ) , g , rect , selection ; if ( ! color | | color = = 'transparent ' | | color = = 'none ' ) color = 'white ' ; if ( dim . width < this . box Init . width ) this . box Init . width = dim . width ; if ( dim . height < this . box Init . height ) this . box Init . height = dim . height ; rect = new JSYG ( ' <rect > ' ) . fill ( color ) ; g = new JSYG ( ' <g > ' ) . append ( rect ) ; new JSYG ( this . pattern ) . attr ( { id : id , pattern Units : 'user Space On Use ' } ) . append ( g ) . append To ( svg ) ; new JSYG ( this . mask ) . css ( 'fill -opacity ' , 0 . 5 ) . append To ( svg ) ; if ( this . keep Ratio ) this . box Init . height = dim . height * this . box Init . width / dim . width ; selection = new JSYG ( this . selection ) . attr ( this . box Init ) . attr ( 'fill ' , "url ( # " + id + " ) " ) . append To ( svg ) ; this . editor . target ( selection ) ; this . editor . display Shadow = false ; new JSYG ( this . editor . path Box ) . css ( 'fill -opacity ' , 0 ) ; this . editor . ctrls Drag . enable ( { bounds : 0 } ) ; this . editor . ctrls Resize . enable ( { keep Ratio : this . keep Ratio , bounds : 0 } ) ; this . editor . show ( ) ; this . enabled = true ; this . update ( ) ; return this ; } 
function ( ) { this . editor . hide ( ) ; new JSYG ( this . pattern ) . remove ( ) ; new JSYG ( this . mask ) . remove ( ) ; new JSYG ( this . selection ) . remove ( ) ; this . enabled = false ; return this ; } 
function postinstall ( ) { var json = Readers . get Bower JSON ( ) ; if ( ! json . scripts | | ! json . scripts . postinstall ) return ; 
function ( pie ) { var current = process . cwd ( ) ; 
function reqo ( func , required Keys ) { var options Index = arguments [ 2 ] = = = undefined ? 0 : arguments [ 2 ] ; var context = arguments [ 3 ] = = = undefined ? undefined : arguments [ 3 ] ; return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key + + ) { args [ _key ] = arguments [ _key ] ; } var options = args [ options Index ] ; if ( ! ( 0 , _lodash . is Plain Object ) ( options ) ) { throw new Type Error ( 'options must be a plain object literal ' ) ; } 
function Strategy ( options , verify ) { options = options | | { } ; if ( options . statusnet = = = undefined ) { throw new Error ( "A Status Net instance is required (e .g . identi .ca ) " ) ; } this . prefix = "https : / / " + options . statusnet + " /api " ; options . request Token URL = options . request Token URL | | this . prefix + ' /oauth /request _token ' ; options . access Token URL = options . access Token URL | | this . prefix + ' /oauth /access _token ' ; options . user Authorization URL = options . user Authorization URL | | this . prefix + ' /oauth /authorize ' ; options . session Key = options . session Key | | 'oauth : ' + options . statusnet ; OAuth Strategy . call ( this , options , verify ) ; this . name = options . statusnet ; } 
function without ( to Remove ) { return function ( prev , curr ) { if ( ! Array . is Array ( prev ) ) { prev = ! test Value ( prev , to Remove ) ? [ prev ] : [ ] } if ( ! test Value ( curr , to Remove ) ) prev . push ( curr ) return prev } } 
function init Dhtmlx Toolbar ( container ) { var impl = null ; if ( Util . is Node ( container ) ) { impl = new dhtml XToolbar Object ( container , SKIN ) ; } else if ( container . type = = = OBJECT _TYPE . LAYOUT _CELL | | container . type = = = OBJECT _TYPE . ACCORDION _CELL | | container . type = = = OBJECT _TYPE . LAYOUT | | container . type = = = OBJECT _TYPE . WINDOW | | container . type = = = OBJECT _TYPE . TAB ) { impl = container . impl . attach Toolbar ( ) ; impl . set Skin ( SKIN ) ; } else { throw new Error ( 'init Dhtmlx Toolbar : container is not valid . ' ) ; } return impl ; } 
function ( data , track ) { if ( track ! = = false ) data = $track ( data , track ) ; this . data = data ; this . _dep . changed ( ) ; return this ; } 
function ( ) { var models = [ this ] , model = this ; while ( model . parent ) { models . unshift ( model = model . parent ) ; } return models } 
function ( index ) { if ( ! _ . is Number ( index ) | | is Na N ( index ) ) index = 0 ; if ( index < 0 ) return this . get All Models ( ) [ ~ index ] ; var model = this ; while ( index & & model ) { model = model . parent ; index - - ; } return model ; } 
function ( fn ) { var index = 0 , model = this ; while ( model ! = null ) { if ( fn . call ( this , model , index + + ) ) return model ; model = model . parent ; } } 
function ( path ) { if ( typeof path = = = "string " ) path = parse ( path , { start Rule : "path " } ) ; if ( ! _ . is Object ( path ) ) throw new Error ( "Expecting string or object for path . " ) ; var self = this ; this . _dep . depend ( ) ; return _ . reduce ( path . parts , function ( target , part ) { target = self . _get ( target , part . key ) ; _ . each ( part . children , function ( k ) { if ( _ . is Object ( k ) ) k = self . get ( k ) ; target = self . _get ( target , k ) ; } ) ; return target ; } , this . data ) ; } 
function ( paths ) { var self = this ; if ( typeof paths = = = "string " ) paths = parse ( paths , { start Rule : "path Query " } ) ; if ( ! _ . is Array ( paths ) ) paths = paths ! = null ? [ paths ] : [ ] ; if ( ! paths . length ) { var model = this . find Model ( function ( m ) { return ! _ . is Undefined ( m . data ) ; } ) ; if ( model = = null ) return ; var val = model . data ; if ( _ . is Function ( val ) ) val = val . call ( this , null ) ; return val ; } return _ . reduce ( paths , function ( result , path , index ) { var model = self , scope = true , val ; if ( path . type = = = "root " ) { model = self . get Root Model ( ) ; } else if ( path . type = = = "parent " ) { model = self . get Model At Offset ( path . distance ) ; scope = false ; } else if ( path . type = = = "all " ) { scope = false ; } if ( model = = null ) return ; while ( _ . is Undefined ( val ) & & model ! = null ) { val = model . get Local ( path ) ; model = model . parent ; if ( scope ) break ; } if ( _ . is Function ( val ) ) { val = val . call ( self , index = = = 0 ? null : result ) ; } return val ; } , void 0 ) ; } 
function deep Query ( root , current Dir , last Key , cb ) { if ( ! last Key ) { 
function ( done ) { crypto . random Bytes ( 2 0 , function ( err , buffer ) { var token = buffer . to String ( 'hex ' ) ; done ( err , token ) ; } ) ; } 
function ( token , done ) { if ( req . body . username ) { User . find One ( { username : req . body . username } , ' -salt -password ' , function ( err , user ) { if ( ! user ) { return res . status ( 4 0 0 ) . send ( { message : 'No account with that username has been found ' } ) ; } else if ( user . provider ! = = 'local ' ) { return res . status ( 4 0 0 ) . send ( { message : 'It seems like you signed up using your ' + user . provider + ' account ' } ) ; } else { user . reset Password Token = token ; user . reset Password Expires = Date . now ( ) + 3 6 0 0 0 0 0 ; 
function ( email HTML , user , done ) { var smtp Transport = nodemailer . create Transport ( config . mailer . options ) ; var mail Options = { to : user . email , from : config . mailer . from , subject : 'Your password has been changed ' , html : email HTML } ; smtp Transport . send Mail ( mail Options , function ( err ) { done ( err , 'done ' ) ; } ) ; } 
function sort Issues ( issues ) { var sorted ; 
function deduplicate Collaborators ( collaborators ) { var found Logins = [ ] ; return _ . filter ( collaborators , function ( collaborator ) { var duplicate = false , login = collaborator . login ; if ( found Logins . index Of ( login ) > - 1 ) { duplicate = true ; } else { found Logins . push ( login ) ; } return ! duplicate ; } ) ; } 
function extract Super Issue Sub Task Numbers ( super Issue ) { var matches = super Issue . body . match ( markdown Tasks Regex ) , sub Task Ids = [ ] ; _ . each ( matches , function ( line ) { var match = line . match ( subtask Regex ) ; if ( match ) { sub Task Ids . push ( parse Int ( match [ 3 ] ) ) ; } } ) ; return sub Task Ids ; } 
function format Issues ( format , issues ) { var formatted Issues , partition , super Issues , singleton Issues , removed Subtasks = [ ] ; if ( format = = 'network ' ) { formatted Issues = { supers : [ ] , singletons : [ ] , all : issues } ; partition = _ . partition ( issues , function ( issue ) { return _ . find ( issue . labels , function ( label ) { return label . name = = 'super ' ; } ) ; } ) ; super Issues = partition . shift ( ) ; singleton Issues = partition . shift ( ) ; _ . each ( super Issues , function ( super Issue ) { var sub Task Numbers = extract Super Issue Sub Task Numbers ( super Issue ) ; super Issue . subtasks = _ . filter ( singleton Issues , function ( issue ) { var is Subtask = _ . contains ( sub Task Numbers , issue . number ) ; if ( is Subtask ) { removed Subtasks . push ( issue . number ) ; } return is Subtask ; } ) ; } ) ; formatted Issues . supers = super Issues ; _ . each ( singleton Issues , function ( issue ) { if ( ! _ . contains ( removed Subtasks , issue . number ) ) { formatted Issues . singletons . push ( issue ) ; } } ) ; } else { formatted Issues = issues ; } return formatted Issues ; } 
function merge Issues And Prs ( issues , prs ) { _ . each ( issues , function ( issue ) { var target Pr , target Pr Index = _ . find Index ( prs , function ( pr ) { return pr & & pr . number = = issue . number ; } ) ; if ( target Pr Index > - 1 ) { target Pr = prs [ target Pr Index ] ; prs [ target Pr Index ] = _ . merge ( target Pr , issue ) ; } } ) ; return prs ; } 
function Sprinter ( username , password , repo Slugs , cache ) { if ( ! username ) { throw new Error ( 'Missing username . ' ) ; } if ( ! password ) { throw new Error ( 'Missing password . ' ) ; } if ( ! repo Slugs ) { throw new Error ( 'Missing repositories . ' ) ; } this . username = username ; this . password = password ; 
function get Fetch By State Callback ( callback ) { return function ( err , data ) { if ( err ) { async Errors . push ( err ) ; } callback ( null , data ) ; } ; } 
function list Availables ( force Refresh ) { force Refresh & & ( adapters Cache = [ ] ) ; if ( adapters Cache . length ) { return adapters Cache ; } adapters Cache = fs . readdir Sync ( _ _dirname ) . filter ( function ( file Or Dir Name ) { return is Dir ( _ _dirname + ' / ' + file Or Dir Name ) ; } ) ; return adapters Cache ; } 
function read Config ( adapter Name , path ) { var adapter = get Adapter Instance ( adapter Name ) ; return adapter . config Loader ( normalize Adapter Config Path ( adapter , path ) ) ; } 
function write Config ( adapter Name , path , config ) { var adapter = get Adapter Instance ( adapter Name ) ; return adapter . config Writer ( normalize Adapter Config Path ( adapter , path ) , config ) ; } 
function handle Files ( files ) { files . for Each ( function ( f ) { f . src . filter ( src Exists ) . map ( function ( filepath ) { var path Info = get Path Info ( filepath , f . dest ) , context = get Context ( f . context , path Info ) ; render File ( path Info . outfile , filepath , context ) ; } ) ; } ) ; } 
function handle I 1 8n Files ( files ) { options . locales . for Each ( function ( locale ) { grunt . register Task ( 'swigtemplates Subtask - ' + locale , function ( ) { var done = this . async ( ) ; var translator Factory = options . translate Function ( locale ) ; Q . when ( translator Factory , function ( translator ) { do Translations ( files , locale , translator ) } ) . done ( done ) ; } ) ; grunt . task . run ( 'swigtemplates Subtask - ' + locale ) ; } ) ; } 
function do Translations ( files , locale , translator ) { files . for Each ( function ( f ) { f . src . filter ( src Exists ) . map ( function ( filepath ) { var path Info = get Path Info ( filepath , f . dest ) , context = get Context ( f . context , path Info ) ; if ( locale ! = = options . default Locale ) { path Info . outfile = path . join ( f . dest , locale , path Info . outfile Path , path Info . outfile Name ) ; } context . locale = locale ; options . locals [ options . translate Function Name ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) ; return translator ( args ) ; } ; swig . set Defaults ( { locals : options . locals } ) ; render File ( path Info . outfile , filepath , context ) ; } ) ; } ) ; } 
function render File ( outfile , filepath , context ) { grunt . file . write ( outfile , swig . render File ( filepath , context ) ) ; grunt . log . ok ( 'File " ' + outfile + ' " created . ' ) ; } 
function get Path Info ( filepath , dest ) { var outfile Name = path . basename ( filepath , ' .swig ' ) , dir Name = path . dirname ( filepath ) , outfile Path = path . normalize ( path . relative ( options . templates Dir , dir Name ) ) , outfile = path . join ( dest , outfile Path , outfile Name ) ; return { outfile Name : outfile Name , dir Name : dir Name , outfile Path : outfile Path , outfile : outfile } ; } 
function get Context ( context , path Info ) { var global Context , template Context ; try { global Context = grunt . file . read JSON ( path . join ( options . templates Dir , "global .json " ) ) ; } catch ( err ) { global Context = { } ; } try { template Context = grunt . file . read JSON ( path . join ( path Info . dir Name , path Info . outfile Name ) + " .json " ) ; } catch ( err ) { template Context = { } ; } return _ . extend ( { } , global Context , template Context , options . default Context , context ) ; } 
function Lru ( options ) { if ( options = = = undefined ) { options = { } } this . size = 0 ; this . max Size = options . max Size ; this . del Callback = options . del Callback ; this . hash Enabled = options . hash Enabled = = = undefined ? true : options . hash Enabled ; 
function render ( url ) { return async page = > { try { const template = ` $ { page . template | | 'schedule ' } ` ; 
async function generate Menu ( ) { try { const files = await fs . readdir ( source ) ; const filter = files . filter ( file = > file . substring ( 0 , file . last Index Of ( ' . ' ) ) ! = = 'index ' ) ; const menu = filter . map ( file = > ( { title : file . substring ( 0 , file . last Index Of ( ' . ' ) ) , url : file . substring ( 0 , file . last Index Of ( ' . ' ) ) , } ) ) ; menu . unshift ( { title : 'Home ' , url : ' ' } ) ; return menu ; } catch ( err ) { throw err ; } } 
function is Named Function ( node ) { if ( node . id ) return true ; const { parent } = node ; const { type } = parent ; const named Function = type = = = 'Method Definition ' | | type = = = 'Property ' & & ( parent . kind = = = 'get ' | | parent . kind = = = 'set ' | | parent . method ) ; return named Function ; } 
function get Config For Function ( node ) { if ( is Named Function ( node ) ) return 'never ' ; if ( node . type = = = 'Arrow Function Expression ' ) { 
function check Function ( node ) { const function Config = get Config For Function ( node ) ; if ( function Config = = = 'ignore ' ) return ; const right Token = source Code . get First Token ( node , ast Utils . is Opening Paren Token ) ; const left Token = source Code . get Token Before ( right Token ) ; const text = source Code . text . slice ( left Token . range [ 1 ] , right Token . range [ 0 ] ) . replace ( / \ / \ * [ ^ ] * ? \ * \ / / g , ' ' ) ; if ( ast Utils . LINEBREAK _MATCHER . test ( text ) ) return ; const has Spacing = / \s / . test ( text ) ; if ( has Spacing & & function Config = = = 'never ' ) { const report = { node , loc : left Token . loc . end , message : 'Unexpected space before function parentheses . ' , fix : fixer = > fixer . remove Range ( [ left Token . range [ 1 ] , right Token . range [ 0 ] ] ) , } ; context . report ( report ) ; } else if ( ! has Spacing & & function Config = = = 'always ' ) { const report = { node , loc : left Token . loc . end , message : 'Missing space before function parentheses . ' , fix : fixer = > fixer . insert Text After ( left Token , ' ' ) , } ; context . report ( report ) ; } } 
function ( config ) { var me = this ; 
function check Struct Member ( structname , obj , callback , root ) { var membername = obj . name . name ; if ( ! is Var String ( membername ) ) { callback ( false , structname + ' . ' + membername + ' : The first letter should be lowercase . ' ) ; return false ; } if ( ! base . is Type ( obj . type , root ) ) { callback ( false , structname + ' . ' + membername + ' : ' + obj . type + ' not defined . ' ) ; return false ; } if ( obj . type = = 'time ' ) { if ( obj . has Own Property ( 'val ' ) ) { if ( typeof ( obj . val ) = = 'object ' ) { if ( obj . val . type = = 'NULL ' ) { return true ; } else if ( obj . val . type = = 'time ' & & obj . val . val = = 'NOW ' ) { return true ; } } callback ( false , structname + ' . ' + membername + ' : default is not NULL or NOW . ' ) ; return false ; } } else if ( obj . type = = 'int ' ) { if ( obj . has Own Property ( 'val ' ) ) { if ( typeof ( obj . val ) = = 'object ' ) { if ( obj . val . type = = 'int ' & & obj . val . val = = 'AUTOINC ' ) { if ( obj . type 2 ! = 'primary ' ) { callback ( false , structname + ' . ' + membername + ' : AUTOINC is primary . ' ) ; return false ; } } } } } if ( obj . type 2 = = 'expand ' ) { if ( obj . has Own Property ( 'expand ' ) ) { if ( ! base . is Enum ( obj . expand , root ) ) { callback ( false , structname + ' . ' + membername + ' : expand need enum ! . ' ) ; return false ; } } else { var cobj = base . get Global Obj ( obj . type , root ) ; if ( cobj = = undefined ) { callback ( false , structname + ' . ' + membername + ' : expand fail ! . ' ) ; return false ; } var structobj = base . get Global Obj ( structname , root ) ; for ( var i = 0 ; i < cobj . val . length ; + + i ) { if ( base . has Member Ex ( cobj . val [ i ] . name . name , obj . type , structobj , root ) ) { callback ( false , structname + ' . ' + membername + ' . ' + cobj . val [ i ] . name . name + ' : expand err (duplication of name ) . ' ) ; return false ; } } } } if ( obj . type 2 = = 'repeated ' ) { if ( obj . has Own Property ( 'memberkey ' ) ) { if ( ! ( base . is Struct ( obj . type , root ) | | base . is Static ( obj . type , root ) ) ) { callback ( false , structname + ' . ' + membername + ' : repeated object must be struct . ' ) ; return false ; } if ( ! base . has Member 2 ( obj . memberkey , base . get Global Obj ( obj . type , root ) , root ) ) { callback ( false , structname + ' . ' + membername + ' : repeated key ( ' + obj . memberkey + ' ) not defined in ' + obj . type + ' . ' ) ; return false ; } } } return true ; } 
function check Struct ( obj , callback , root ) { if ( obj . type = = 'struct ' | | obj . type = = 'static ' | | obj . type = = 'message ' ) { if ( ! is Type String ( obj . name ) ) { callback ( false , 'struct ' + obj . name + ' : The first letter should be capitalized . ' ) ; return false ; } for ( var i = 0 ; i < obj . val . length ; + + i ) { if ( base . count Member ( obj . val [ i ] . name . name , obj , root ) > 1 ) { callback ( false , 'struct ' + obj . name + ' . ' + obj . val [ i ] . name . name + ' : duplication of name . ' ) ; return false ; } if ( ! check Struct Member ( obj . name , obj . val [ i ] , callback , root ) ) { return false ; } if ( obj . type = = 'message ' ) { if ( obj . val [ i ] . name . name . index Of ( ' _ ' ) = = 0 ) { callback ( false , 'message ' + obj . name + ' . ' + obj . val [ i ] . name . name + " : can 't begin with an underscore ( _ ) . " ) ; return false ; } } } } return true ; } 
function check Enum Member ( enumname , enumarr , obj , callback ) { if ( ! is Enum String ( obj . name ) ) { callback ( false , enumname + ' . ' + obj . name + ' : All letters should be capitalized . ' ) ; return false ; } if ( obj . type ! = 'int ' ) { callback ( false , enumname + ' . ' + obj . name + ' : This member is not int . ' ) ; return false ; } if ( obj . name . index Of ( enumname + ' _ ' ) ! = 0 ) { callback ( false , enumname + ' . ' + obj . name + ' : This member is begin ' + enumname + ' _ . ' ) ; return false ; } if ( enumarr . index Of ( obj . val ) > = 0 ) { callback ( false , enumname + ' . ' + obj . name + ' : This member \ 's val is used . ' ) ; return false ; } return true ; } 
function check Enum ( obj , callback ) { if ( obj . type = = 'enum ' ) { if ( ! is Enum String ( obj . name ) ) { callback ( false , 'enum ' + obj . name + ' : All letters should be capitalized . ' ) ; return false ; } var enumarr = [ ] ; for ( var i = 0 ; i < obj . val . length ; + + i ) { if ( ! check Enum Member ( obj . name , enumarr , obj . val [ i ] , callback ) ) { return false ; } enumarr . push ( obj . val [ i ] . val ) ; } } return true ; } 
function check Type ( obj , callback , root ) { if ( obj . type = = 'type ' ) { if ( ! is Type String ( obj . name ) ) { callback ( false , 'global type ' + obj . name + ' : The first letter should be capitalized . ' ) ; return false ; } if ( ! base . is Type ( obj . name , root ) ) { callback ( false , 'global type ' + obj . name + ' : ' + obj . name + ' not defined . ' ) ; return false ; } } return true ; } 
function check Grammar ( obj , callback ) { let hasver = false ; if ( Array . is Array ( obj ) ) { for ( var i = 0 ; i < obj . length ; + + i ) { var nums = base . count Global Obj ( obj [ i ] . name , obj ) ; if ( nums > 1 ) { callback ( false , obj [ i ] . name + ' : duplication of name ' ) ; return false ; } if ( obj [ i ] . name = = 'VER ' ) { hasver = true ; } if ( obj [ i ] . type = = 'struct ' | | obj [ i ] . type = = 'static ' | | obj [ i ] . type = = 'message ' ) { check Struct ( obj [ i ] , callback , obj ) ; } else if ( obj [ i ] . type = = 'enum ' ) { check Enum ( obj [ i ] , callback ) ; } else if ( obj [ i ] . type = = 'type ' ) { check Type ( obj [ i ] , callback , obj ) ; } } if ( ! hasver ) { callback ( false , 'no VER ! ' ) ; return false ; } return true ; } callback ( false , 'empty file ! ' ) ; return false ; } 
function bind Event Map ( event Map , event Emitter ) { var event Names = Object . keys ( event Map ) ; event Names . map ( function ( event Name ) { event Emitter . on ( event Name , event Map [ event Name ] ) ; } ) ; } 
function ( delay , new Fn , new Scope , new Args ) { var me = this ; 
function ( operation ) { var me = this , params = Ext . apply If ( operation . get Params ( ) | | { } , me . get Extra Params ( ) | | { } ) , request ; 
function ( success , operation , request , response , callback , scope ) { var me = this , action = operation . get Action ( ) , reader , result Set ; if ( success = = = true ) { reader = me . get Reader ( ) ; try { result Set = reader . process ( me . get Response Result ( response ) ) ; } catch ( e ) { operation . set Exception ( e . message ) ; me . fire Event ( 'exception ' , me , response , operation ) ; return ; } * @event exception * Fires when the server returns an exception * @param {Ext .data .proxy .Proxy } this * @param {Object } response The response from the AJAX request * @param {Ext .data .Operation } operation The operation that triggered request * / me . fire Event ( 'exception ' , this , response , operation ) ; } 
function ( operation , response ) { if ( Ext . is Object ( response ) ) { operation . set Exception ( { status : response . status , status Text : response . status Text } ) ; } } 
function ( sorters ) { var min = [ ] , length = sorters . length , i = 0 ; for ( ; i < length ; i + + ) { min [ i ] = { property : sorters [ i ] . get Property ( ) , direction : sorters [ i ] . get Direction ( ) } ; } return this . apply Encoding ( min ) ; } 
function ( filters ) { var min = [ ] , length = filters . length , i = 0 ; for ( ; i < length ; i + + ) { min [ i ] = { property : filters [ i ] . get Property ( ) , value : filters [ i ] . get Value ( ) } ; } return this . apply Encoding ( min ) ; } 
function ( request ) { var me = this , url = me . get Url ( request ) ; 
function has TAB ( excelobj , tabname ) { for ( let ii = 0 ; ii < excelobj . length ; + + ii ) { if ( excelobj [ ii ] . name = = tabname ) { return true ; } } return false ; } 
function merge Excel ( src 1 , src 2 ) { if ( src 1 = = undefined ) { return src 2 ; } if ( src 1 [ 0 ] . name ! = src 2 [ 0 ] . name ) { return src 2 ; } if ( src 1 [ 0 ] . data . length < = 2 ) { return src 2 ; } let dest = [ ] ; dest . push ( { name : src 2 [ 0 ] . name , data : [ ] } ) ; for ( let ii = 0 ; ii < src 1 [ 0 ] . data . length ; + + ii ) { dest [ 0 ] . data . push ( [ ] ) ; } for ( let ii = 0 ; ii < src 2 [ 0 ] . data [ 1 ] . length ; + + ii ) { let sf = find Field ( src 1 [ 0 ] . data , src 2 [ 0 ] . data [ 1 ] [ ii ] ) ; if ( sf ! = - 1 ) { let cn = src 1 [ 0 ] . data . length - 2 ; dest [ 0 ] . data [ 0 ] . push ( src 2 [ 0 ] . data [ 0 ] [ ii ] ) ; dest [ 0 ] . data [ 1 ] . push ( src 2 [ 0 ] . data [ 1 ] [ ii ] ) ; for ( let jj = 0 ; jj < cn ; + + jj ) { dest [ 0 ] . data [ jj + 2 ] . push ( src 1 [ 0 ] . data [ jj + 2 ] [ sf ] ) ; } } else { let cn = src 1 [ 0 ] . data . length - 2 ; dest [ 0 ] . data [ 0 ] . push ( src 2 [ 0 ] . data [ 0 ] [ ii ] ) ; dest [ 0 ] . data [ 1 ] . push ( src 2 [ 0 ] . data [ 1 ] [ ii ] ) ; for ( let jj = 0 ; jj < cn ; + + jj ) { dest [ 0 ] . data [ jj + 2 ] . push ( ' ' ) ; } } } for ( let ii = 1 ; ii < src 2 . length ; + + ii ) { dest . push ( src 2 [ ii ] ) ; } return dest ; } 
function ( new Date Format , old Date Format ) { var value = this . get Value ( ) ; if ( new Date Format ! = old Date Format & & Ext . is Date ( value ) ) { this . get Component ( ) . set Value ( Ext . Date . format ( value , new Date Format | | Ext . util . Format . default Date Format ) ) ; } } 
function ( format ) { var value = this . get Value ( ) ; return ( Ext . is Date ( value ) ) ? Ext . Date . format ( value , format | | this . get Date Format ( ) | | Ext . util . Format . default Date Format ) : value ; } 
function ( picker , value ) { var me = this , old Value = me . get Value ( ) ; me . set Value ( value ) ; me . fire Event ( 'select ' , me , value ) ; me . on Change ( me , value , old Value ) ; } 
function ( ) { var me = this , picker = me . get Picker ( ) ; if ( me . get Destroy Picker On Hide ( ) & & picker ) { picker . destroy ( ) ; me . _picker = me . get Initial Config ( ) . picker | | true ; } } 
function debug ( gt ) { var args = arrayify ( arguments ) ; args . splice ( 0 , 1 ) ; 
function find Route ( ghosttrain , verb , url ) { 
function clone ( obj ) { var new Obj = { } ; 
function request URL ( url ) { var parsed URL = url . pathname ? url : parse URL ( url , true ) ; return parsed URL . pathname + ( parsed URL . search | | ' ' ) ; } 
function add Route ( verb ) { return function ( path , fn ) { 
function path Regexp ( path , keys , sensitive , strict ) { if ( Object . prototype . to String . call ( path ) = = ' [object Reg Exp ] ' ) return path ; if ( Array . is Array ( path ) ) path = ' ( ' + path . join ( ' | ' ) + ' ) ' ; path = path . concat ( strict ? ' ' : ' / ? ' ) . replace ( / \ / \ ( / g , ' ( ? : / ' ) . replace ( / ( \ / ) ? ( \ . ) ? : ( \w + ) ( ? : ( \ ( . * ? \ ) ) ) ? ( \ ? ) ? ( \ * ) ? / g , function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash | | ' ' ; return ' ' + ( optional ? ' ' : slash ) + ' ( ? : ' + ( optional ? slash : ' ' ) + ( format | | ' ' ) + ( capture | | ( format & & ' ( [ ^ / . ] + ? ) ' | | ' ( [ ^ / ] + ? ) ' ) ) + ' ) ' + ( optional | | ' ' ) + ( star ? ' ( / * ) ? ' : ' ' ) ; } ) . replace ( / ( [ \ / . ] ) / g , ' \ \ $ 1 ' ) . replace ( / \ * / g , ' ( . * ) ' ) ; return new Reg Exp ( ' ^ ' + path + ' $ ' , sensitive ? ' ' : 'i ' ) ; } 
function Impulse Bin ( ) { this . settings = { adapter : 'commander ' , quiet Option : 'quiet ' , required Option Tmpl : ' - - %s is required ' , verbose Option : 'verbose ' , verbose Log Name : ' [verbose ] ' , stdout Log Name : ' [stdout ] ' , stderr Log Name : ' [stderr ] ' } ; this . console = require ( 'long -con ' ) . create ( ) ; 
function ( config ) { var me = this , current Config = me . config , id ; me . on Initialized Listeners = [ ] ; me . initial Config = config ; if ( config ! = = undefined & & 'id ' in config ) { id = config . id ; } else if ( 'id ' in current Config ) { id = current Config . id ; } else { id = me . get Id ( ) ; } me . id = id ; me . set Id ( id ) ; Ext . Component Manager . register ( me ) ; me . init Element ( ) ; me . init Config ( me . initial Config ) ; me . refresh Size State = me . do Refresh Size State ; me . refresh Floating = me . do Refresh Floating ; if ( me . refresh Size State On Initialized ) { me . refresh Size State ( ) ; } if ( me . refresh Floating On Initialized ) { me . refresh Floating ( ) ; } me . initialize ( ) ; me . trigger Initialized ( ) ; if ( me . config . fullscreen ) { me . fire Event ( 'fullscreen ' , me ) ; } me . fire Event ( 'initialize ' , me ) ; } 
function ( cls , prefix , suffix ) { var old Cls = this . get Cls ( ) , new Cls = ( old Cls ) ? old Cls . slice ( ) : [ ] , ln , i , cached Cls ; prefix = prefix | | ' ' ; suffix = suffix | | ' ' ; if ( typeof cls = = "string " ) { cls = [ cls ] ; } ln = cls . length ; 
function ( cls , prefix , suffix ) { var old Cls = this . get Cls ( ) , new Cls = ( old Cls ) ? old Cls . slice ( ) : [ ] , ln , i ; prefix = prefix | | ' ' ; suffix = suffix | | ' ' ; if ( typeof cls = = "string " ) { new Cls = Ext . Array . remove ( new Cls , prefix + cls + suffix ) ; } else { ln = cls . length ; for ( i = 0 ; i < ln ; i + + ) { new Cls = Ext . Array . remove ( new Cls , prefix + cls [ i ] + suffix ) ; } } this . set Cls ( new Cls ) ; } 
function ( old Cls , new Cls , prefix , suffix ) { 
function ( class Name , force ) { var old Cls = this . get Cls ( ) , new Cls = ( old Cls ) ? old Cls . slice ( ) : [ ] ; if ( force | | new Cls . index Of ( class Name ) = = - 1 ) { new Cls . push ( class Name ) ; } else { Ext . Array . remove ( new Cls , class Name ) ; } this . set Cls ( new Cls ) ; return this ; } 
function ( new Html Cls , old Html Cls ) { var inner Html Element = this . inner Html Element , inner Element = this . inner Element ; if ( this . get Style Html Content ( ) & & old Html Cls ) { if ( inner Html Element ) { inner Html Element . replace Cls ( old Html Cls , new Html Cls ) ; } else { inner Element . replace Cls ( old Html Cls , new Html Cls ) ; } } } 
function ( animation ) { this . set Current Alignment Info ( null ) ; if ( ! this . get Hidden ( ) ) { if ( animation = = = undefined | | ( animation & & animation . is Component ) ) { animation = this . get Hide Animation ( ) ; } if ( animation ) { if ( animation = = = true ) { animation = 'fade Out ' ; } this . on Before ( { hiddenchange : 'animate Fn ' , scope : this , single : true , args : [ animation ] } ) ; } this . set Hidden ( true ) ; } return this ; } 
function ( animation ) { if ( this . active Animation ) { this . active Animation . on ( { animationend : function ( ) { this . show ( animation ) ; } , scope : this , single : true } ) ; return this ; } var hidden = this . get Hidden ( ) ; if ( hidden | | hidden = = = null ) { if ( animation = = = true ) { animation = 'fade In ' ; } else if ( animation = = = undefined | | ( animation & & animation . is Component ) ) { animation = this . get Show Animation ( ) ; } if ( animation ) { this . before Show Animation ( ) ; this . on Before ( { hiddenchange : 'animate Fn ' , scope : this , single : true , args : [ animation ] } ) ; } this . set Hidden ( false ) ; } return this ; } 
function ( width , height ) { if ( width ! = undefined ) { this . set Width ( width ) ; } if ( height ! = undefined ) { this . set Height ( height ) ; } } 
function ( component , alignment ) { var me = this , viewport = Ext . Viewport , parent = me . get Parent ( ) ; me . set Visibility ( false ) ; if ( parent ! = = viewport ) { viewport . add ( me ) ; } me . show ( ) ; me . on ( { hide : 'on Show By Erased ' , destroy : 'on Show By Erased ' , single : true , scope : me } ) ; viewport . on ( 'resize ' , 'align To ' , me , { args : [ component , alignment ] } ) ; me . align To ( component , alignment ) ; me . set Visibility ( true ) ; } 
function ( component , alignment ) { var align To Element = component . is Component ? component . render Element : component , align To Box = align To Element . get Page Box ( ) , element = this . render Element , box = element . get Page Box ( ) , stats = { align To Box : align To Box , alignment : alignment , top : align To Box . top , left : align To Box . left , align To Width : align To Box . width , align To Height : align To Box . height , width : box . width , height : box . height } , current Alignment Info = this . get Current Alignment Info ( ) , is Aligned = true ; if ( ! Ext . is Empty ( current Alignment Info ) ) { Ext . Object . each ( stats , function ( key , value ) { if ( ! Ext . is Object ( value ) & & current Alignment Info [ key ] ! = value ) { is Aligned = false ; return false ; } return true ; } ) ; } else { is Aligned = false ; } return { is Aligned : is Aligned , stats : stats } ; } 
function ( alignment Info ) { this . $current Alignment Info = Ext . is Empty ( alignment Info ) ? null : Ext . merge ( { } , alignment Info . stats ? alignment Info . stats : alignment Info ) ; } 
function ( selector ) { var result = this . parent ; if ( selector ) { for ( ; result ; result = result . parent ) { if ( Ext . Component Query . is ( result , selector ) ) { return result ; } } } return result ; } 
function ( ) { this . destroy = Ext . empty Fn ; var parent = this . get Parent ( ) , reference List = this . reference List , i , ln , reference ; this . is Destroying = true ; Ext . destroy ( this . get Translatable ( ) , this . get Plugins ( ) ) ; 
function ( from , to ) { var me = this , items = me . get View Items ( ) , i = to - from , item ; for ( ; i > = 0 ; i - - ) { item = items [ from + i ] ; Ext . get ( item ) . destroy ( ) ; } if ( me . get View Items ( ) . length = = 0 ) { this . dataview . show Empty Text ( ) ; } } 
function ( records ) { var me = this , dataview = me . dataview , store = dataview . get Store ( ) , ln = records . length , i , record ; if ( ln ) { dataview . hide Empty Text ( ) ; } for ( i = 0 ; i < ln ; i + + ) { records [ i ] . _tmp Index = store . index Of ( records [ i ] ) ; } Ext . Array . sort ( records , function ( record 1 , record 2 ) { return record 1 . _tmp Index > record 2 . _tmp Index ? 1 : - 1 ; } ) ; for ( i = 0 ; i < ln ; i + + ) { record = records [ i ] ; me . add List Item ( record . _tmp Index , record ) ; delete record . _tmp Index ; } } 
function ( list , index , target , record , e ) { var me = this , store = list . get Store ( ) , node = store . get At ( index ) ; me . fire Event ( 'itemtap ' , this , list , index , target , record , e ) ; if ( node . is Leaf ( ) ) { me . fire Event ( 'leafitemtap ' , this , list , index , target , record , e ) ; me . go To Leaf ( node ) ; } else { this . go To Node ( node ) ; } } 
function ( ) { var me = this , node = me . get Last Node ( ) , detail Card = me . get Detail Card ( ) , detail Card Active = detail Card & & me . get Active Item ( ) = = detail Card , last Active List = me . get Last Active List ( ) ; this . fire Action ( 'back ' , [ this , node , last Active List , detail Card Active ] , 'do Back ' ) ; } 
function ( node ) { if ( ! node ) { return ; } var me = this , active Item = me . get Active Item ( ) , detail Card = me . get Detail Card ( ) , detail Card Active = detail Card & & me . get Active Item ( ) = = detail Card , reverse = me . go To Node Reverse Animation ( node ) , first List = me . first List , second List = me . second List , layout = me . get Layout ( ) , animation = ( layout ) ? layout . get Animation ( ) : null , list ; 
function ( node ) { if ( ! node . is Leaf ( ) ) { throw new Error ( 'go To Leaf : passed a node which is not a leaf . ' ) ; } var me = this , card = me . get Detail Card ( node ) , container = me . get Detail Container ( ) , shared Container = container = = this , layout = me . get Layout ( ) , animation = ( layout ) ? layout . get Animation ( ) : false ; if ( card ) { if ( container . get Items ( ) . index Of ( card ) = = = - 1 ) { container . add ( card ) ; } if ( shared Container ) { if ( me . get Active Item ( ) instanceof Ext . dataview . List ) { me . set Last Active List ( me . get Active Item ( ) ) ; } me . set Last Node ( node ) ; } if ( animation ) { animation . set Reverse ( false ) ; } container . set Active Item ( card ) ; me . sync Toolbar ( ) ; } } 
function hoist Functions ( program ) { var functions = [ ] ; var body = [ ] ; for ( let line of program . body ) { if ( line . type = = = 'Export Default Declaration ' ) { if ( line . declaration . type = = = 'Function Declaration ' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type = = = 'Export Named Declaration ' ) { if ( ! ! line . declaration & & line . declaration . type = = = 'Function Declaration ' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type = = = 'Function Declaration ' ) { functions . push ( line ) ; } else { body . push ( line ) ; } } return make Program ( [ . . . functions , . . . body ] ) ; } 
function get AST ( load ) { if ( load . ast ) { return load . ast ; } else { if ( load . source ) { const opts = Object . assign ( { source File : load . source File } , parse Opts ) ; return acorn . parse ( load . source , opts ) ; } else { throw new Error ( 'Cannot get AST ! ' ) ; } } } 
function ( date ) { return date . replace ( 'ledna ' , ' 1 . ' ) . replace ( ' nora ' , 2 . ' ) . replace ( 'b ezna ' , 3 . ' ) . replace ( 'dubna ' , ' 4 . ' ) . replace ( 'kv tna ' , 5 . ' ) . replace ( ' ervna ' , 6 . ' ) . replace ( ' ervence ' , 7 . ' ) . replace ( 'srpna ' , ' 8 . ' ) . replace ( 'z    ' , ' 9 ' ) . replace ( '  jna ' , ' 0 . ' ) . replace ( 'listopadu ' , ' 1 1 . ' ) . replace ( 'prosince ' , ' 1 2 . ' ) . replace ( / \s / g , ' ' ) ; } 
function parse Vehicle ID ( $ , item ) { let fields = $ ( item ) . find ( 'td ' ) ; let id = $ ( fields [ 1 ] ) . find ( 'a ' ) . attr ( 'href ' ) . replace ( 'Detail .aspx ?id = ' , ' ' ) ; return id ; } 
function format Details ( details ) { let result = { results : details , count : details . length , time : new Date ( ) . to ISOString ( ) } ; return result ; } 
function get By ID ( id ) { var url = ` $ { APP _BASE _URL } $ { id } ` ; return request ( url ) . then ( function ( body ) { let $ = cheerio . load ( body ) ; let info = { url : url , id : id } ; $ ( 'table #search Table Results tr ' ) . each ( ( i , item ) = > { let span = $ ( item ) . find ( 'span ' ) ; let key = $ ( span ) . attr ( 'id ' ) . replace ( 'ctl 0 0 _Application _lbl ' , ' ' ) . to Lower Case ( ) ; let value = $ ( span ) . text ( ) . trim ( ) ; info [ translations [ key ] | | key ] = value ; } ) ; info . stolendate = get Standardized Date Str ( info . stolendate ) ; return info ; } ) ; } 
function ( search Query ) { return request ( construct Search Url ( search Query ) ) . then ( function ( body ) { let $ = cheerio . load ( body ) ; let rows = $ ( 'table #celacr tr ' ) ; let promises = rows . filter ( idx = > idx > = 1 ) 
function ( config ) { if ( ! config . callback ) { Ext . Logger . error ( 'You must specify a `callback ` for ` #can Make Payments ` to work . ' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase #can Make Payments ' , callbacks : { callback : function ( flag ) { config . callback . call ( config . scope | | this , flag ) ; } } , scope : config . scope | | this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success ` callback for ` #get Products ` to work . ' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure ` callback for ` #get Products ` to work . ' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase #get Products ' , product Infos : JSON . stringify ( config . product Infos ) , callbacks : { success : function ( products ) { var store = Ext . create ( 'Ext .data .Store ' , { model : 'Ext .device .Purchases .Product ' , data : products } ) ; config . success . call ( config . scope | | this , store ) ; } , failure : config . failure } , scope : config . scope | | this } ) ; } 
function ( config ) { if ( ! config . callback ) { Ext . Logger . error ( 'You must specify a `callback ` for ` #get Purchases ` to work . ' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase #get Purchases ' , callbacks : { callback : function ( purchases ) { var ln = purchases . length , i ; for ( i = 0 ; i < ln ; i + + ) { purchases [ i ] . state = 'charged ' ; } var store = Ext . create ( 'Ext .data .Store ' , { model : 'Ext .device .purchases .Purchase ' , data : purchases } ) ; config . callback . call ( config . scope | | this , store ) ; } } , scope : config . scope | | this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success ` callback for ` #purchase ` to work . ' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure ` callback for ` #purchase ` to work . ' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase #purchase ' , identifier : this . get ( 'product Identifier ' ) , callbacks : { success : config . success , failure : config . failure } , scope : config . scope | | this } ) ; } 
function ( config ) { var me = this ; if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success ` callback for ` #complete ` to work . ' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure ` callback for ` #complete ` to work . ' ) ; return false ; } if ( this . get ( 'state ' ) ! = 'charged ' ) { config . failure . call ( config . scope | | this , 'purchase is not charged ' ) ; } Ext . device . Communicator . send ( { command : 'Purchase #complete ' , identifier : me . get ( 'transaction Identifier ' ) , callbacks : { success : function ( ) { me . set ( 'state ' , 'completed ' ) ; config . success . call ( config . scope | | this ) ; } , failure : function ( ) { me . set ( 'state ' , 'charged ' ) ; config . failure . call ( config . scope | | this ) ; } } , scope : config . scope | | this } ) ; } 
function ( operation , callback , scope ) { var me = this , reader = me . get Reader ( ) ; if ( operation . process ( 'read ' , reader . process ( me . get Data ( ) ) ) = = = false ) { this . fire Event ( 'exception ' , this , null , operation ) ; } Ext . callback ( callback , scope | | me , [ operation ] ) ; } 
function pdf ( x , mu , sigma ) { if ( sigma = = = 0 ) { return x = = = mu ? Number . POSITIVE _INFINITY : 0 ; } var s 2 = pow ( sigma , 2 ) , A = 1 / ( sqrt ( 2 * s 2 * PI ) ) , B = - 1 / ( 2 * s 2 ) ; return A * exp ( B * pow ( x - mu , 2 ) ) ; } 
function require All Enum ( dir ) { if ( ! fs . exists Sync ( dir ) ) { return ; } log . verbose ( ` ` ) ; var files = fs . readdir Sync ( dir ) . filter ( ( file ) = > ( ( file . starts With ( "E " ) & & file . ends With ( " .js " ) ) ) ) ; for ( var file of files ) { var file Name = file . substring ( 0 , file . last Index Of ( " .js " ) ) ; global [ file Name ] = require ( path . resolve ( dir , file ) ) ; log . verbose ( ` $ { file } ` ) ; } } 
function require All Interceptor ( dir ) { if ( ! fs . exists Sync ( dir ) ) { return ; } log . verbose ( ` ` ) ; global [ 'Base Interceptor Handler ' ] = require ( path . resolve ( dir , 'Base Interceptor Handler ' ) ) ; log . verbose ( ` ` ) ; } 
function ( key ) { this . key = key ; this . key Type = key . split ( " " ) [ 0 ] ; this . rawkey = key . split ( " " ) [ 1 ] ; try { this . key Comment = key . split ( " " ) [ 2 ] ; } catch ( err ) { this . key Comment = null ; } this . byte Array = this . _string To Bytes ( atob ( this . rawkey ) ) ; this . sliced Array = [ ] ; this . word Length = 4 ; this . _load ( ) ; } 
function ( source Func , bound Func , context , calling Context , args ) { if ( ! ( calling Context instanceof bound Func ) ) return source Func . apply ( context , args ) ; Ctor . prototype = source Func . prototype ; var self = new Ctor ; Ctor . prototype = null ; var result = source Func . apply ( self , args ) ; if ( _ . is Object ( result ) ) return result ; return self ; } 
function ( e ) { var me = this , old Checked = me . _checked , new Checked = me . get Checked ( ) ; 
function ( ) { var values = [ ] ; this . get Same Group Fields ( ) . for Each ( function ( field ) { if ( field . get Checked ( ) ) { values . push ( field . get Value ( ) ) ; } } ) ; return values ; } 
function ( values ) { this . get Same Group Fields ( ) . for Each ( function ( field ) { field . set Checked ( ( values . index Of ( field . get Value ( ) ) ! = = - 1 ) ) ; } ) ; return this ; } 
function ( e ) { var me = this ; if ( e . target ! = me . element . dom ) { return ; } if ( me . get Deselect On Container Click ( ) & & me . get Store ( ) ) { me . deselect All ( ) ; } } 
function ( record , suppress Event ) { var me = this ; if ( suppress Event ) { me . do Item Select ( me , record ) ; } else { me . fire Action ( 'select ' , [ me , record ] , 'do Item Select ' ) ; } } 
function ( record , suppress Event ) { var me = this ; if ( me . container & & ! me . is Destroyed ) { if ( suppress Event ) { me . do Item Deselect ( me , record ) ; } else { me . fire Action ( 'deselect ' , [ me , record , suppress Event ] , 'do Item Deselect ' ) ; } } } 
function ( ) { var me = this , container = me . container ; if ( ! me . get Store ( ) ) { if ( ! me . has Loaded Store & & ! me . get Defer Empty Text ( ) ) { me . show Empty Text ( ) ; } return ; } if ( container ) { me . fire Action ( 'refresh ' , [ me ] , 'do Refresh ' ) ; } } 
function Strategy ( options , verify ) { options = options | | { } ; options . client ID = options . client ID | | { } ; options . client Secret = options . client Secret | | { } ; options . grant _type = "password " ; options . skip User Profile = true ; options . authorization URL = options . authorization URL | | 'https : / /winkapi .quirky .com /oauth 2 /token ' ; options . token URL = options . token URL | | 'https : / /winkapi .quirky .com /oauth 2 /token ' ; OAuth 2Strategy . call ( this , options , verify ) ; this . name = 'wink ' ; } 
function process Params ( params String ) { var individual Params = params String . split ( " & " ) , result Object = { } ; individual Params . for Each ( function ( item ) { var item Parts = item . split ( " = " ) , param Name = item Parts [ 0 ] , param Value = decode URIComponent ( item Parts [ 1 ] | | " " ) ; var param Object = { } ; param Object [ param Name ] = param Value ; $ . extend ( result Object , param Object ) ; } ) ; return result Object ; } 
function ( config ) { if ( ! this . _store ) { this . _store = [ { first : 'Robert ' , last : 'Dougan ' , emails : { work : 'rob @sencha .com ' } } , { first : 'Jamie ' , last : 'Avins ' , emails : { work : 'jamie @sencha .com ' } } ] ; } config . success . call ( config . scope | | this , this . _store ) ; } 
function ( config ) { config . callback . call ( config . scope | | this , config . label . to Upper Case ( ) , config . label ) ; } 
function Collection ( options ) { if ( ! ( this instanceof Collection ) ) { return new Collection ( options ) ; } options = options | | { } ; if ( options instanceof Array ) { this . model Type = undefined ; this . items = options ; } else { this . model Type = options . model Type ; this . items = options . items | | [ ] ; if ( ! ( this . items instanceof Array ) ) { throw new Collection Exception ( 'Items must be an array ' ) ; } } } 
function find ( filter ) { var item ; var i ; var ilen ; var keys ; var key ; var k ; var klen ; var found ; if ( filter instanceof Function ) { for ( i = 0 , ilen = this . items . length ; i < ilen ; + + i ) { item = this . items [ i ] ; if ( filter ( item , i ) ) { return item ; } } } else if ( filter ! = = null & & filter ! = = undefined ) { if ( typeof filter = = = 'object ' ) { keys = Object . keys ( filter ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; + + i ) { item = this . items [ i ] ; found = true ; for ( k = 0 ; k < klen & & found ; + + k ) { key = keys [ k ] ; if ( filter [ key ] ! = = item [ key ] ) { found = false ; } } if ( found ) { return item ; } } } else if ( this . model Type ) { keys = Object . keys ( this . model Type . attributes ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; + + i ) { item = this . items [ i ] ; found = false ; for ( k = 0 ; k < klen & & ! found ; + + k ) { key = keys [ k ] ; if ( filter = = = item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } else { for ( i = 0 , ilen = this . items . length ; i < ilen ; + + i ) { item = this . items [ i ] ; found = false ; keys = Object . keys ( item ) ; for ( k = 0 , klen = keys . length ; k < klen & & ! found ; + + k ) { key = keys [ k ] ; if ( filter = = = item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } } return undefined ; } 
function ( context , grunt ) { this . context = context ; this . grunt = grunt ; 

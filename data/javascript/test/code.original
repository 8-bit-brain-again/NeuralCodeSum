function createInstance ( defaultConfig ) { var context = new Axios ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; 
function CancelToken ( executor ) { if ( typeof executor !== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ; } var resolvePromise ; this . promise = new Promise ( function promiseExecutor ( resolve ) { resolvePromise = resolve ; } ) ; var token = this ; executor ( function cancel ( message ) { if ( token . reason ) { 
function isArrayBufferView ( val ) { var result ; if ( ( typeof ArrayBuffer !== 'undefined' ) && ( ArrayBuffer . isView ) ) { result = ArrayBuffer . isView ( val ) ; } else { result = ( val ) && ( val . buffer ) && ( val . buffer instanceof ArrayBuffer ) ; } return result ; } 
function isStandardBrowserEnv ( ) { if ( typeof navigator !== 'undefined' && ( navigator . product === 'ReactNative' || navigator . product === 'NativeScript' || navigator . product === 'NS' ) ) { return false ; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ) ; } 
function forEach ( obj , fn ) { 
function extend ( a , b , thisArg ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; } 
function fetchQuery ( operation , variables , cacheConfig , uploadables ) { 
function retryStrategy ( times ) { if ( times === 1 ) { const error = 'Unable to connect to Redis - please check your Redis config!' if ( process . env . NODE_ENV === 'test' ) { console . error ( error ) } else { api . log ( error , 'error' ) } return 5000 } return Math . min ( times * 50 , maxBackoff ) } 
function writePackageManifest ( packageName ) { const packagePath = require . resolve ( packageName + '/package.json' ) let { name , main , author , license , types , typings } = require ( packagePath ) if ( ! main ) { main = 'index.js' } let typesFile = types || typings if ( typesFile ) { typesFile = require . resolve ( join ( packageName , typesFile ) ) } const compiledPackagePath = join ( __dirname , ` ${ packageName } ` ) const potentialLicensePath = join ( dirname ( packagePath ) , './LICENSE' ) if ( existsSync ( potentialLicensePath ) ) { this . _ . files . push ( { dir : compiledPackagePath , base : 'LICENSE' , data : readFileSync ( potentialLicensePath , 'utf8' ) } ) } this . _ . files . push ( { dir : compiledPackagePath , base : 'package.json' , data : JSON . stringify ( Object . assign ( { } , { name , main : ` ${ basename ( main , '.' + extname ( main ) ) } ` } , author ? { author } : undefined , license ? { license } : undefined , typesFile ? { types : relative ( compiledPackagePath , typesFile ) } : undefined ) ) + '\n' } ) } 
function supportsPreload ( list ) { if ( ! list || ! list . supports ) { return false } try { return list . supports ( 'preload' ) } catch ( e ) { return false } } 
function addEntry ( compilation , context , name , entry ) { return new Promise ( ( resolve , reject ) => { const dep = DynamicEntryPlugin . createDependency ( entry , name ) compilation . addEntry ( context , dep , name , ( err ) => { if ( err ) return reject ( err ) resolve ( ) } ) } ) } 
function handleWarnings ( warnings ) { clearOutdatedErrors ( ) 
function handleErrors ( errors ) { clearOutdatedErrors ( ) isFirstCompilation = false hasCompileErrors = true 
function processMessage ( e ) { const obj = JSON . parse ( e . data ) switch ( obj . action ) { case 'building' : { console . log ( '[HMR] bundle ' + ( obj . name ? "'" + obj . name + "' " : '' ) + 'rebuilding' ) break } case 'built' : case 'sync' : { clearOutdatedErrors ( ) if ( obj . hash ) { handleAvailableHash ( obj . hash ) } if ( obj . warnings . length > 0 ) { handleWarnings ( obj . warnings ) } if ( obj . errors . length > 0 ) { 
async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { 
async function tryApplyUpdates ( ) { if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } try { const res = await fetch ( ` ${ hotUpdatePath } ${ curHash } ` ) const data = await res . json ( ) const curPage = page === '/' ? 'index' : page const pageUpdated = Object . keys ( data . c ) . some ( mod => { return ( mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` ) !== - 1 || mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` . replace ( / \/ / g , '\\' ) ) !== - 1 ) } ) if ( pageUpdated ) { document . location . reload ( true ) } else { curHash = mostRecentHash } } catch ( err ) { console . error ( 'Error occurred checking for update' , err ) document . location . reload ( true ) } } 
function formatMessage ( message , isError ) { let lines = message . split ( '\n' ) 
function slideNext ( speed = this . params . speed , runCallbacks = true , internal ) { const swiper = this ; const { params , animating } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loopFix ( ) ; 
function slidePrev ( speed = this . params . speed , runCallbacks = true , internal ) { const swiper = this ; const { params , animating , snapGrid , slidesGrid , rtlTranslate , } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loopFix ( ) ; 
function encodeName ( name ) { var littleEndian = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( typeof name !== "string" ) throw new TypeError ( "name parameter is a required string" ) ; if ( name . length > 13 ) throw new TypeError ( "A name can be up to 13 characters long" ) ; var bitstr = "" ; for ( var i = 0 ; i <= 12 ; i ++ ) { 
function UDecimalString ( value ) { assert ( value != null , "value is required" ) ; value = value === "object" && value . toString ? value . toString ( ) : String ( value ) ; if ( value [ 0 ] === "." ) { value = '0' + value ; } var part = value . split ( "." ) ; assert ( part . length <= 2 , 'invalid decimal ' + value ) ; assert ( / ^\d+(,?\d)*\d*$ / . test ( part [ 0 ] ) , 'invalid decimal ' + value ) ; if ( part . length === 2 ) { assert ( / ^\d*$ / . test ( part [ 1 ] ) , 'invalid decimal ' + value ) ; part [ 1 ] = part [ 1 ] . replace ( / 0+$ / , "" ) ; 
function UDecimalPad ( num , precision ) { var value = UDecimalString ( num ) ; assert . equal ( "number" , typeof precision === 'undefined' ? 'undefined' : ( 0 , _typeof3 . default ) ( precision ) , "precision" ) ; var part = value . split ( "." ) ; if ( precision === 0 && part . length === 1 ) { return part [ 0 ] ; } if ( part . length === 1 ) { return part [ 0 ] + '.' + "0" . repeat ( precision ) ; } else { var pad = precision - part [ 1 ] . length ; assert ( pad >= 0 , 'decimal \'' + value + '\' exceeds precision ' + precision ) ; return part [ 0 ] + '.' + part [ 1 ] + "0" . repeat ( pad ) ; } } 
function UDecimalUnimply ( value , precision ) { assert ( value != null , "value is required" ) ; value = value === "object" && value . toString ? value . toString ( ) : String ( value ) ; assert ( / ^\d+$ / . test ( value ) , 'invalid whole number ' + value ) ; 
function parseAssetSymbol ( assetSymbol ) { var precision = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : null ; assert . equal ( typeof assetSymbol === 'undefined' ? 'undefined' : ( 0 , _typeof3 . default ) ( assetSymbol ) , "string" , "Asset symbol should be string" ) ; if ( assetSymbol . indexOf ( "," ) === - 1 ) { assetSymbol = ',' + assetSymbol ; 
function encodeAddress ( str ) { if ( typeof str !== "string" || str . length !== 53 || ! str . startsWith ( "EVT" ) ) throw new Error ( "EVTAddress should be a string with length 53 starts with EVT." ) ; str = str . substr ( 3 ) ; if ( str === "0" . repeat ( 50 ) ) return Buffer . from ( [ 0 , 0 ] ) ; 
function decodeAddress ( bytes ) { if ( bytes . length === 2 && bytes . equals ( Buffer . from ( [ 0 , 0 ] ) ) ) return "EVT" + "0" . repeat ( 50 ) ; 
function createSegment ( typeKey , value ) { 
function parseSegment ( buffer , offset ) { let typeKey = buffer [ offset ] ; if ( typeKey <= 20 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: No value for uint8" ) ; return { typeKey : typeKey , value : buffer [ offset + 1 ] , bufferLength : 2 } ; } if ( typeKey <= 40 ) { if ( buffer [ offset + 2 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uint16" ) ; return { typeKey : typeKey , value : buffer . readUInt16BE ( offset + 1 ) , bufferLength : 3 } ; } else if ( typeKey <= 90 ) { if ( buffer [ offset + 4 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uint32" ) ; return { typeKey : typeKey , value : buffer . readUInt32BE ( offset + 1 ) , bufferLength : 5 } ; } else if ( typeKey <= 155 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete length value for string" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + 1 + len ] == undefined ) throw new Error ( "ParseError: Incomplete value for string" ) ; let value = buffer . toString ( "utf8" , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else if ( typeKey <= 165 ) { if ( buffer [ offset + 16 ] == undefined ) throw new Error ( "ParseError: Incomplete value for uuid" ) ; let len = 16 ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 1 , offset + 1 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 1 + len } ; } else if ( typeKey <= 180 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete length value for byte string" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + len + 1 ] == undefined ) throw new Error ( "ParseError: Incomplete value for byte string" ) ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else { throw new Error ( "typeKey not supported" ) ; } } 
function parseSegments ( buffer ) { if ( buffer . length == 0 ) throw new Error ( "bad segments stream" ) ; let pointer = 0 ; let segments = [ ] ; while ( pointer < buffer . length ) { let seg = parseSegment ( buffer , pointer ) ; segments . push ( seg ) ; pointer += seg . bufferLength ; delete seg . bufferLength ; } if ( pointer != buffer . length ) { throw new Error ( "Bad / incomplete segments" ) ; } return segments ; } 
function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( "Invalid length of EvtLink" ) ; let textSplited = text . split ( "_" ) ; if ( textSplited . length > 2 ) return null ; let rawText ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } 
async function __calcKeyProvider ( keyProvider ) { if ( ! keyProvider ) { return [ ] ; } 
function random32ByteBuffer ( { cpuEntropyBits = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , "number" , "cpuEntropyBits" ) ; assert . equal ( typeof safe , "boolean" , "boolean" ) ; if ( safe ) { assert ( entropyCount >= 128 , "Call initialize() to add entropy (current: " + entropyCount + ")" ) ; } 
function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , "externalEntropyArray" ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 > 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } } 
function cpuEntropy ( cpuEntropyBits = 128 ) { let collected = [ ] ; let lastCount = null ; let lowEntropySamples = 0 ; while ( collected . length < cpuEntropyBits ) { const count = floatingPointCount ( ) ; if ( lastCount != null ) { const delta = count - lastCount ; if ( Math . abs ( delta ) < 1 ) { lowEntropySamples ++ ; continue ; } 
function browserEntropy ( ) { let entropyStr = Array ( randomBytes ( 101 ) ) . join ( ) ; try { entropyStr += ( new Date ( ) ) . toString ( ) + " " + window . screen . height + " " + window . screen . width + " " + window . screen . colorDepth + " " + " " + window . screen . availHeight + " " + window . screen . availWidth + " " + window . screen . pixelDepth + navigator . language + " " + window . location + " " + window . history . length ; for ( let i = 0 , mimeType ; i < navigator . mimeTypes . length ; i ++ ) { mimeType = navigator . mimeTypes [ i ] ; entropyStr += mimeType . description + " " + mimeType . type + " " + mimeType . suffixes + " " ; } } catch ( error ) { 
function encrypt ( private_key , public_key , message , nonce = uniqueNonce ( ) ) { return crypt ( private_key , public_key , nonce , message ) ; } 
function decrypt ( private_key , public_key , nonce , message , checksum ) { return crypt ( private_key , public_key , nonce , message , checksum ) . message ; } 
function cryptoJsDecrypt ( message , key , iv ) { assert ( message , "Missing cipher text" ) ; message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( "aes-256-cbc" , key , iv ) ; 
function cryptoJsEncrypt ( message , key , iv ) { assert ( message , "Missing plain text" ) ; message = toBinaryBuffer ( message ) ; const cipher = crypto . createCipheriv ( "aes-256-cbc" , key , iv ) ; 
function getSharedSecret ( public_key ) { public_key = PublicKey ( public_key ) ; let KB = public_key . toUncompressed ( ) . toBuffer ( ) ; let KBP = Point . fromAffine ( secp256k1 , BigInteger . fromBuffer ( KB . slice ( 1 , 33 ) ) , 
function getChildKey ( name ) { 
function initialize ( ) { if ( initialized ) { return ; } unitTest ( ) ; keyUtils . addEntropy ( ... keyUtils . cpuEntropy ( ) ) ; assert ( keyUtils . entropyCount ( ) >= 128 , "insufficient entropy" ) ; initialized = true ; } 
function am1 ( i , x , w , j , c , n ) { while ( -- n >= 0 ) { var v = x * this [ i ++ ] + w [ j ] + c c = Math . floor ( v / 0x4000000 ) w [ j ++ ] = v & 0x3ffffff } return c } 
function am2 ( i , x , w , j , c , n ) { var xl = x & 0x7fff , xh = x >> 15 while ( -- n >= 0 ) { var l = this [ i ] & 0x7fff var h = this [ i ++ ] >> 15 var m = xh * l + h * xl l = xl * l + ( ( m & 0x7fff ) << 15 ) + w [ j ] + ( c & 0x3fffffff ) c = ( l >>> 30 ) + ( m >>> 15 ) + xh * h + ( c >>> 30 ) w [ j ++ ] = l & 0x3fffffff } return c } 
function bnpCopyTo ( r ) { for ( var i = this . t - 1 ; i >= 0 ; -- i ) r [ i ] = this [ i ] r . t = this . t r . s = this . s } 
function bnpInvDigit ( ) { if ( this . t < 1 ) return 0 var x = this [ 0 ] if ( ( x & 1 ) == 0 ) return 0 var y = x & 3 ; 
function Montgomery ( m ) { this . m = m this . mp = m . invDigit ( ) this . mpl = this . mp & 0x7fff this . mph = this . mp >> 15 this . um = ( 1 << ( m . DB - 15 ) ) - 1 this . mt2 = 2 * m . t } 
function montConvert ( x ) { var r = new BigInteger ( ) x . abs ( ) . dlShiftTo ( this . m . t , r ) r . divRemTo ( this . m , null , r ) if ( x . s < 0 && r . compareTo ( BigInteger . ZERO ) > 0 ) this . m . subTo ( r , r ) return r } 
function montRevert ( x ) { var r = new BigInteger ( ) x . copyTo ( r ) this . reduce ( r ) return r } 
function bnNot ( ) { var r = new BigInteger ( ) for ( var i = 0 ; i < this . t ; ++ i ) r [ i ] = this . DM & ~ this [ i ] r . t = this . t r . s = ~ this . s return r } 
function bnShiftLeft ( n ) { var r = new BigInteger ( ) if ( n < 0 ) this . rShiftTo ( - n , r ) else this . lShiftTo ( n , r ) return r } 
function bnShiftRight ( n ) { var r = new BigInteger ( ) if ( n < 0 ) this . lShiftTo ( - n , r ) else this . rShiftTo ( n , r ) return r } 
function bnpChangeBit ( n , op ) { var r = BigInteger . ONE . shiftLeft ( n ) this . bitwiseTo ( r , op , r ) return r } 
function bnDivideAndRemainder ( a ) { var q = new BigInteger ( ) , r = new BigInteger ( ) this . divRemTo ( a , q , r ) return new Array ( q , r ) } 
function barrettReduce ( x ) { var self = this x . drShiftTo ( self . m . t - 1 , self . r2 ) if ( x . t > self . m . t + 1 ) { x . t = self . m . t + 1 x . clamp ( ) } self . mu . multiplyUpperTo ( self . r2 , self . m . t + 1 , self . q3 ) self . m . multiplyLowerTo ( self . q3 , self . m . t + 1 , self . r2 ) while ( x . compareTo ( self . r2 ) < 0 ) x . dAddOffset ( 1 , self . m . t + 1 ) x . subTo ( self . r2 , x ) while ( x . compareTo ( self . m ) >= 0 ) x . subTo ( self . m , x ) } 
function bnModPow ( e , m ) { var i = e . bitLength ( ) , k , r = nbv ( 1 ) , z if ( i <= 0 ) return r else if ( i < 18 ) k = 1 else if ( i < 48 ) k = 3 else if ( i < 144 ) k = 4 else if ( i < 768 ) k = 5 else k = 6 if ( i < 8 ) z = new Classic ( m ) else if ( m . isEven ( ) ) z = new Barrett ( m ) else z = new Montgomery ( m ) 
function bnGCD ( a ) { var x = ( this . s < 0 ) ? this . negate ( ) : this . clone ( ) var y = ( a . s < 0 ) ? a . negate ( ) : a . clone ( ) if ( x . compareTo ( y ) < 0 ) { var t = x x = y y = t } var i = x . getLowestSetBit ( ) , g = y . getLowestSetBit ( ) if ( g < 0 ) return x if ( i < g ) g = i if ( g > 0 ) { x . rShiftTo ( g , x ) y . rShiftTo ( g , y ) } while ( x . signum ( ) > 0 ) { if ( ( i = x . getLowestSetBit ( ) ) > 0 ) x . rShiftTo ( i , x ) if ( ( i = y . getLowestSetBit ( ) ) > 0 ) y . rShiftTo ( i , y ) if ( x . compareTo ( y ) >= 0 ) { x . subTo ( y , x ) x . rShiftTo ( 1 , x ) } else { y . subTo ( x , y ) y . rShiftTo ( 1 , y ) } } if ( g > 0 ) y . lShiftTo ( g , y ) return y } 
function bnpModInt ( n ) { if ( n <= 0 ) return 0 var d = this . DV % n , r = ( this . s < 0 ) ? n - 1 : 0 if ( this . t > 0 ) if ( d == 0 ) r = this [ 0 ] % n else for ( var i = this . t - 1 ; i >= 0 ; -- i ) r = ( d * r + this [ i ] ) % n return r } 
function bnIsProbablePrime ( t ) { var i , x = this . abs ( ) if ( x . t == 1 && x [ 0 ] <= lowprimes [ lowprimes . length - 1 ] ) { for ( i = 0 ; i < lowprimes . length ; ++ i ) if ( x [ 0 ] == lowprimes [ i ] ) return true return false } if ( x . isEven ( ) ) return false i = 1 while ( i < lowprimes . length ) { var m = lowprimes [ i ] , j = i + 1 while ( j < lowprimes . length && m < lplim ) m *= lowprimes [ j ++ ] m = x . modInt ( m ) while ( i < j ) if ( m % lowprimes [ i ++ ] == 0 ) return false } return x . millerRabin ( t ) } 
function verify ( data , pubkey , encoding = "utf8" ) { if ( typeof data === "string" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , "data is a required String or Buffer" ) ; data = hash . sha256 ( data ) ; return verifyHash ( data , pubkey ) ; } 
function verifyHash ( dataSha256 , pubkey , encoding = "hex" ) { if ( typeof dataSha256 === "string" ) { dataSha256 = Buffer . from ( dataSha256 , encoding ) ; } if ( dataSha256 . length !== 32 || ! Buffer . isBuffer ( dataSha256 ) ) throw new Error ( "dataSha256: 32 bytes required" ) ; const publicKey = PublicKey ( pubkey ) ; assert ( publicKey , "pubkey required" ) ; return ecdsa . verify ( curve , dataSha256 , { r : r , s : s } , publicKey . Q ) ; } 
function recover ( data , encoding = "utf8" ) { if ( typeof data === "string" ) { data = Buffer . from ( data , encoding ) ; } assert ( Buffer . isBuffer ( data ) , "data is a required String or Buffer" ) ; data = hash . sha256 ( data ) ; return recoverHash ( data ) ; } 
function recoverHash ( dataSha256 , encoding = "hex" ) { 
function encodeName ( name , littleEndian = true ) { if ( typeof name !== "string" ) throw new TypeError ( "name parameter is a required string" ) ; if ( name . length > 13 ) throw new TypeError ( "A name can be up to 13 characters long" ) ; let bitstr = "" ; for ( let i = 0 ; i <= 12 ; i ++ ) { 
function encodeName128 ( name ) { if ( typeof name !== 'string' ) throw new TypeError ( 'name parameter is a required string' ) ; if ( name . length > 21 ) throw new TypeError ( 'A name can be up to 21 characters long' ) ; let bitstr = '' ; for ( let i = 0 ; i < 21 ; i ++ ) { 
function authenticate ( helper , paramsValues , credentials ) { print ( "Authenticating via JavaScript script..." ) ; var msg = helper . prepareMessage ( ) ; 
function authenticate ( helper , paramsValues , credentials ) { print ( "Authenticating via JavaScript script..." ) ; 
function invokeWith ( msg ) { 
function scan ( ps , msg , src ) { 
function authenticate ( helper , paramsValues , credentials ) { print ( "Wordpress Authenticating via JavaScript script..." ) ; 
function FormGroup ( props ) { const { children , className , grouped , inline , unstackable , widths } = props const classes = cx ( useKeyOnly ( grouped , 'grouped' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( unstackable , 'unstackable' ) , useWidthProp ( widths , null , true ) , 'fields' , className , ) const rest = getUnhandledProps ( FormGroup , props ) const ElementType = getElementType ( FormGroup , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } 
function Loader ( props ) { const { active , children , className , content , disabled , indeterminate , inline , inverted , size , } = props const classes = cx ( 'ui' , size , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( indeterminate , 'indeterminate' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( children || content , 'text' ) , useKeyOrValueAndKey ( inline , 'inline' ) , 'loader' , className , ) const rest = getUnhandledProps ( Loader , props ) const ElementType = getElementType ( Loader , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function FormTextArea ( props ) { const { control } = props const rest = getUnhandledProps ( FormTextArea , props ) const ElementType = getElementType ( FormTextArea , props ) return < ElementType { ... rest } control = { control } / > } 
function FormSelect ( props ) { const { control , options } = props const rest = getUnhandledProps ( FormSelect , props ) const ElementType = getElementType ( FormSelect , props ) return < ElementType { ... rest } control = { control } options = { options } / > } 
function ItemContent ( props ) { const { children , className , content , description , extra , header , meta , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , 'content' , className ) const rest = getUnhandledProps ( ItemContent , props ) const ElementType = getElementType ( ItemContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemHeader . create ( header , { autoGenerateKey : false } ) } { ItemMeta . create ( meta , { autoGenerateKey : false } ) } { ItemDescription . create ( description , { autoGenerateKey : false } ) } { ItemExtra . create ( extra , { autoGenerateKey : false } ) } { content } < / ElementType > ) } 
function Table ( props ) { const { attached , basic , celled , children , className , collapsing , color , columns , compact , definition , fixed , footerRow , headerRow , headerRows , inverted , padded , renderBodyRow , selectable , singleLine , size , sortable , stackable , striped , structured , tableData , textAlign , unstackable , verticalAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( celled , 'celled' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( definition , 'definition' ) , useKeyOnly ( fixed , 'fixed' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( sortable , 'sortable' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( striped , 'striped' ) , useKeyOnly ( structured , 'structured' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( basic , 'basic' ) , useKeyOrValueAndKey ( compact , 'compact' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' ) , 'table' , className , ) const rest = getUnhandledProps ( Table , props ) const ElementType = getElementType ( Table , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const hasHeaderRows = headerRow || headerRows const headerShorthandOptions = { defaultProps : { cellAs : 'th' } } const headerElement = hasHeaderRows && ( < TableHeader > { TableRow . create ( headerRow , headerShorthandOptions ) } { _ . map ( headerRows , ( data ) => TableRow . create ( data , headerShorthandOptions ) ) } < / TableHeader > ) return ( < ElementType { ... rest } className = { classes } > { headerElement } < TableBody > { renderBodyRow && _ . map ( tableData , ( data , index ) => TableRow . create ( renderBodyRow ( data , index ) ) ) } < / TableBody > { footerRow && < TableFooter > { TableRow . create ( footerRow ) } < / TableFooter > } < / ElementType > ) } 
function Rail ( props ) { const { attached , children , className , close , content , dividing , internal , position , size , } = props const classes = cx ( 'ui' , position , size , useKeyOnly ( attached , 'attached' ) , useKeyOnly ( dividing , 'dividing' ) , useKeyOnly ( internal , 'internal' ) , useKeyOrValueAndKey ( close , 'close' ) , 'rail' , className , ) const rest = getUnhandledProps ( Rail , props ) const ElementType = getElementType ( Rail , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function ButtonGroup ( props ) { const { attached , basic , buttons , children , className , color , compact , content , floated , fluid , icon , inverted , labeled , negative , positive , primary , secondary , size , toggle , vertical , widths , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( icon , 'icon' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( labeled , 'labeled' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( primary , 'primary' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( toggle , 'toggle' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( floated , 'floated' ) , useWidthProp ( widths ) , 'buttons' , className , ) const rest = getUnhandledProps ( ButtonGroup , props ) const ElementType = getElementType ( ButtonGroup , props ) if ( _ . isNil ( buttons ) ) { return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( buttons , button => Button . create ( button ) ) } < / ElementType > ) } 
function GridRow ( props ) { const { centered , children , className , color , columns , divided , only , reversed , stretched , textAlign , verticalAlign , } = props const classes = cx ( color , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'row' , className , ) const rest = getUnhandledProps ( GridRow , props ) const ElementType = getElementType ( GridRow , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } 
function FormField ( props ) { const { children , className , content , control , disabled , error , inline , label , required , type , width , } = props const classes = cx ( useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( required , 'required' ) , useWidthProp ( width , 'wide' ) , 'field' , className , ) const rest = getUnhandledProps ( FormField , props ) const ElementType = getElementType ( FormField , props ) { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createHTMLLabel ( label , { autoGenerateKey : false } ) } < / ElementType > ) } < label > { createElement ( control , controlProps ) } { label } < / label > < / ElementType > ) } { createElement ( control , { ... controlProps , label } ) } < / ElementType > ) } { createHTMLLabel ( label , { defaultProps : { htmlFor : _ . get ( controlProps , 'id' ) } , autoGenerateKey : false , } ) } { createElement ( control , controlProps ) } < / ElementType > ) } 
function CardContent ( props ) { const { children , className , content , description , extra , header , meta , textAlign } = props const classes = cx ( useKeyOnly ( extra , 'extra' ) , useTextAlignProp ( textAlign ) , 'content' , className ) const rest = getUnhandledProps ( CardContent , props ) const ElementType = getElementType ( CardContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( CardHeader , val => ( { content : val } ) , header , { autoGenerateKey : false } ) } { createShorthand ( CardMeta , val => ( { content : val } ) , meta , { autoGenerateKey : false } ) } { createShorthand ( CardDescription , val => ( { content : val } ) , description , { autoGenerateKey : false , } ) } < / ElementType > ) } 
function Item ( props ) { const { children , className , content , description , extra , header , image , meta } = props const classes = cx ( 'item' , className ) const rest = getUnhandledProps ( Item , props ) const ElementType = getElementType ( Item , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ItemImage . create ( image , { autoGenerateKey : false } ) } < ItemContent content = { content } description = { description } extra = { extra } header = { header } meta = { meta } / > < / ElementType > ) } 
function CommentAvatar ( props ) { const { className , src } = props const classes = cx ( 'avatar' , className ) const rest = getUnhandledProps ( CommentAvatar , props ) const [ imageProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( CommentAvatar , props ) return ( < ElementType { ... rootProps } className = { classes } > { createHTMLImage ( src , { autoGenerateKey : false , defaultProps : imageProps } ) } < / ElementType > ) } 
function StatisticLabel ( props ) { const { children , className , content } = props const classes = cx ( 'label' , className ) const rest = getUnhandledProps ( StatisticLabel , props ) const ElementType = getElementType ( StatisticLabel , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function Radio ( props ) { const { slider , toggle , type } = props const rest = getUnhandledProps ( Radio , props ) 
function FormCheckbox ( props ) { const { control } = props const rest = getUnhandledProps ( FormCheckbox , props ) const ElementType = getElementType ( FormCheckbox , props ) return < ElementType { ... rest } control = { control } / > } 
function FeedMeta ( props ) { const { children , className , content , like } = props const classes = cx ( 'meta' , className ) const rest = getUnhandledProps ( FeedMeta , props ) const ElementType = getElementType ( FeedMeta , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLike , val => ( { content : val } ) , like , { autoGenerateKey : false } ) } { content } < / ElementType > ) } 
function Container ( props ) { const { children , className , content , fluid , text , textAlign } = props const classes = cx ( 'ui' , useKeyOnly ( text , 'text' ) , useKeyOnly ( fluid , 'fluid' ) , useTextAlignProp ( textAlign ) , 'container' , className , ) const rest = getUnhandledProps ( Container , props ) const ElementType = getElementType ( Container , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function StepGroup ( props ) { const { attached , children , className , content , fluid , items , ordered , size , stackable , unstackable , vertical , widths , } = props const classes = cx ( 'ui' , size , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( ordered , 'ordered' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useValueAndKey ( stackable , 'stackable' ) , useWidthProp ( widths ) , 'steps' , className , ) const rest = getUnhandledProps ( StepGroup , props ) const ElementType = getElementType ( StepGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Step . create ( item ) ) } < / ElementType > ) } 
function Divider ( props ) { const { children , className , clearing , content , fitted , hidden , horizontal , inverted , section , vertical , } = props const classes = cx ( 'ui' , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( fitted , 'fitted' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( section , 'section' ) , useKeyOnly ( vertical , 'vertical' ) , 'divider' , className , ) const rest = getUnhandledProps ( Divider , props ) const ElementType = getElementType ( Divider , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function Header ( props ) { const { attached , block , children , className , color , content , disabled , dividing , floated , icon , image , inverted , size , sub , subheader , textAlign , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( block , 'block' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( dividing , 'dividing' ) , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( icon === true , 'icon' ) , useKeyOnly ( image === true , 'image' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( sub , 'sub' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useTextAlignProp ( textAlign ) , 'header' , className , ) const rest = getUnhandledProps ( Header , props ) const ElementType = getElementType ( Header , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const iconElement = Icon . create ( icon , { autoGenerateKey : false } ) const imageElement = Image . create ( image , { autoGenerateKey : false } ) const subheaderElement = HeaderSubheader . create ( subheader , { autoGenerateKey : false } ) if ( iconElement || imageElement ) { return ( < ElementType { ... rest } className = { classes } > { iconElement || imageElement } { ( content || subheaderElement ) && ( < HeaderContent > { content } { subheaderElement } < / HeaderContent > ) } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { content } { subheaderElement } < / ElementType > ) } 
function Grid ( props ) { const { celled , centered , children , className , columns , container , divided , doubling , inverted , padded , relaxed , reversed , stackable , stretched , textAlign , verticalAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( container , 'container' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( stackable , 'stackable' ) , useKeyOnly ( stretched , 'stretched' ) , useKeyOrValueAndKey ( celled , 'celled' ) , useKeyOrValueAndKey ( divided , 'divided' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , useMultipleProp ( reversed , 'reversed' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( columns , 'column' , true ) , 'grid' , className , ) const rest = getUnhandledProps ( Grid , props ) const ElementType = getElementType ( Grid , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } 
function Breadcrumb ( props ) { const { children , className , divider , icon , sections , size } = props const classes = cx ( 'ui' , size , 'breadcrumb' , className ) const rest = getUnhandledProps ( Breadcrumb , props ) const ElementType = getElementType ( Breadcrumb , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const childElements = [ ] _ . each ( sections , ( section , index ) => { { childElements } < / ElementType > ) } 
function FormDropdown ( props ) { const { control } = props const rest = getUnhandledProps ( FormDropdown , props ) const ElementType = getElementType ( FormDropdown , props ) return < ElementType { ... rest } control = { control } / > } 
function CardDescription ( props ) { const { children , className , content , textAlign } = props const classes = cx ( useTextAlignProp ( textAlign ) , 'description' , className ) const rest = getUnhandledProps ( CardDescription , props ) const ElementType = getElementType ( CardDescription , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function ItemGroup ( props ) { const { children , className , content , divided , items , link , relaxed , unstackable } = props const classes = cx ( 'ui' , useKeyOnly ( divided , 'divided' ) , useKeyOnly ( link , 'link' ) , useKeyOnly ( unstackable , 'unstackable' ) , useKeyOrValueAndKey ( relaxed , 'relaxed' ) , 'items' , className , ) const rest = getUnhandledProps ( ItemGroup , props ) const ElementType = getElementType ( ItemGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const { childKey , ... itemProps } = item const finalKey = childKey || [ itemProps . content , itemProps . description , itemProps . header , itemProps . meta ] . join ( '-' ) return < Item { ... itemProps } key = { finalKey } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) } 
function GridColumn ( props ) { const { children , className , computer , color , floated , largeScreen , mobile , only , stretched , tablet , textAlign , verticalAlign , widescreen , width , } = props const classes = cx ( color , useKeyOnly ( stretched , 'stretched' ) , useMultipleProp ( only , 'only' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( computer , 'wide computer' ) , useWidthProp ( largeScreen , 'wide large screen' ) , useWidthProp ( mobile , 'wide mobile' ) , useWidthProp ( tablet , 'wide tablet' ) , useWidthProp ( widescreen , 'wide widescreen' ) , useWidthProp ( width , 'wide' ) , 'column' , className , ) const rest = getUnhandledProps ( GridColumn , props ) const ElementType = getElementType ( GridColumn , props ) return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } 
function ItemImage ( props ) { const { size } = props const rest = getUnhandledProps ( ItemImage , props ) return < Image { ... rest } size = { size } ui = { ! ! size } wrapped / > } 
function CardGroup ( props ) { const { centered , children , className , content , doubling , items , itemsPerRow , stackable , textAlign , } = props const classes = cx ( 'ui' , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( doubling , 'doubling' ) , useKeyOnly ( stackable , 'stackable' ) , useTextAlignProp ( textAlign ) , useWidthProp ( itemsPerRow ) , 'cards' , className , ) const rest = getUnhandledProps ( CardGroup , props ) const ElementType = getElementType ( CardGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } const itemsJSX = _ . map ( items , ( item ) => { const key = item . key || [ item . header , item . description ] . join ( '-' ) return < Card key = { key } { ... item } / > } ) return ( < ElementType { ... rest } className = { classes } > { itemsJSX } < / ElementType > ) } 
function TableRow ( props ) { const { active , cellAs , cells , children , className , disabled , error , negative , positive , textAlign , verticalAlign , warning , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , className , ) const rest = getUnhandledProps ( TableRow , props ) const ElementType = getElementType ( TableRow , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( cells , cell => TableCell . create ( cell , { defaultProps : { as : cellAs } } ) ) } < / ElementType > ) } 
function FormButton ( props ) { const { control } = props const rest = getUnhandledProps ( FormButton , props ) const ElementType = getElementType ( FormButton , props ) return < ElementType { ... rest } control = { control } / > } 
function Ref ( props ) { const { children , innerRef } = props const child = React . Children . only ( children ) const ElementType = isForwardRef ( child ) ? RefForward : RefFindNode return < ElementType innerRef = { innerRef } > { child } < / ElementType > } 
function FeedEvent ( props ) { const { content , children , className , date , extraImages , extraText , image , icon , meta , summary , } = props const classes = cx ( 'event' , className ) const rest = getUnhandledProps ( FeedEvent , props ) const ElementType = getElementType ( FeedEvent , props ) const hasContentProp = content || date || extraImages || extraText || meta || summary const contentProps = { content , date , extraImages , extraText , meta , summary } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedLabel , val => ( { icon : val } ) , icon , { autoGenerateKey : false } ) } { createShorthand ( FeedLabel , val => ( { image : val } ) , image , { autoGenerateKey : false } ) } { hasContentProp && < FeedContent { ... contentProps } / > } { children } < / ElementType > ) } 
function TabPane ( props ) { const { active , children , className , content , loading } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( loading , 'loading' ) , 'tab' , className ) const rest = getUnhandledProps ( TabPane , props ) const ElementType = getElementType ( TabPane , props ) const calculatedDefaultProps = { } if ( ElementType === Segment ) { calculatedDefaultProps . attached = 'bottom' } return ( < ElementType { ... calculatedDefaultProps } { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function ListContent ( props ) { const { children , className , content , description , floated , header , verticalAlign } = props const classes = cx ( useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign ) , 'content' , className , ) const rest = getUnhandledProps ( ListContent , props ) const ElementType = getElementType ( ListContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { ListHeader . create ( header ) } { ListDescription . create ( description ) } { content } < / ElementType > ) } 
function ButtonOr ( props ) { const { className , text } = props const classes = cx ( 'or' , className ) const rest = getUnhandledProps ( ButtonOr , props ) const ElementType = getElementType ( ButtonOr , props ) return < ElementType { ... rest } className = { classes } data-text = { text } / > } 
function TableCell ( props ) { const { active , children , className , collapsing , content , disabled , error , icon , negative , positive , selectable , singleLine , textAlign , verticalAlign , warning , width , } = props const classes = cx ( useKeyOnly ( active , 'active' ) , useKeyOnly ( collapsing , 'collapsing' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( error , 'error' ) , useKeyOnly ( negative , 'negative' ) , useKeyOnly ( positive , 'positive' ) , useKeyOnly ( selectable , 'selectable' ) , useKeyOnly ( singleLine , 'single line' ) , useKeyOnly ( warning , 'warning' ) , useTextAlignProp ( textAlign ) , useVerticalAlignProp ( verticalAlign ) , useWidthProp ( width , 'wide' ) , className , ) const rest = getUnhandledProps ( TableCell , props ) const ElementType = getElementType ( TableCell , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon ) } { content } < / ElementType > ) } 
function BreadcrumbDivider ( props ) { const { children , className , content , icon } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( BreadcrumbDivider , props ) const ElementType = getElementType ( BreadcrumbDivider , props ) if ( ! _ . isNil ( icon ) ) { return Icon . create ( icon , { defaultProps : { ... rest , className : classes } , autoGenerateKey : false , } ) } if ( ! _ . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? '/' : children } < / ElementType > ) } 
function MessageList ( props ) { const { children , className , items } = props const classes = cx ( 'list' , className ) const rest = getUnhandledProps ( MessageList , props ) const ElementType = getElementType ( MessageList , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? _ . map ( items , MessageItem . create ) : children } < / ElementType > ) } 
function TableFooter ( props ) { const { as } = props const rest = getUnhandledProps ( TableFooter , props ) return < TableHeader { ... rest } as = { as } / > } 
function CommentGroup ( props ) { const { className , children , collapsed , content , minimal , size , threaded } = props const classes = cx ( 'ui' , size , useKeyOnly ( collapsed , 'collapsed' ) , useKeyOnly ( minimal , 'minimal' ) , useKeyOnly ( threaded , 'threaded' ) , 'comments' , className , ) const rest = getUnhandledProps ( CommentGroup , props ) const ElementType = getElementType ( CommentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function Reveal ( props ) { const { active , animated , children , className , content , disabled , instant } = props const classes = cx ( 'ui' , animated , useKeyOnly ( active , 'active' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( instant , 'instant' ) , 'reveal' , className , ) const rest = getUnhandledProps ( Reveal , props ) const ElementType = getElementType ( Reveal , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function Segment ( props ) { const { attached , basic , children , circular , className , clearing , color , compact , content , disabled , floated , inverted , loading , placeholder , padded , piled , raised , secondary , size , stacked , tertiary , textAlign , vertical , } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( basic , 'basic' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( clearing , 'clearing' ) , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( loading , 'loading' ) , useKeyOnly ( placeholder , 'placeholder' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( secondary , 'secondary' ) , useKeyOnly ( stacked , 'stacked' ) , useKeyOnly ( tertiary , 'tertiary' ) , useKeyOnly ( vertical , 'vertical' ) , useKeyOrValueAndKey ( attached , 'attached' ) , useKeyOrValueAndKey ( padded , 'padded' ) , useTextAlignProp ( textAlign ) , useValueAndKey ( floated , 'floated' ) , 'segment' , className , ) const rest = getUnhandledProps ( Segment , props ) const ElementType = getElementType ( Segment , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function FormInput ( props ) { const { control } = props const rest = getUnhandledProps ( FormInput , props ) const ElementType = getElementType ( FormInput , props ) return < ElementType { ... rest } control = { control } / > } 
function PlaceholderLine ( props ) { const { className , length } = props const classes = cx ( 'line' , length , className ) const rest = getUnhandledProps ( PlaceholderLine , props ) const ElementType = getElementType ( PlaceholderLine , props ) return < ElementType { ... rest } className = { classes } / > } 
function RevealContent ( props ) { const { children , className , content , hidden , visible } = props const classes = cx ( 'ui' , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( visible , 'visible' ) , 'content' , className , ) const rest = getUnhandledProps ( RevealContent , props ) const ElementType = getElementType ( RevealContent , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function FeedLike ( props ) { const { children , className , content , icon } = props const classes = cx ( 'like' , className ) const rest = getUnhandledProps ( FeedLike , props ) const ElementType = getElementType ( FeedLike , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { Icon . create ( icon , { autoGenerateKey : false } ) } { content } < / ElementType > ) } 
function Placeholder ( props ) { const { children , className , content , fluid , inverted } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , 'placeholder' , className , ) const rest = getUnhandledProps ( Placeholder , props ) const ElementType = getElementType ( Placeholder , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function Accordion ( props ) { const { className , fluid , inverted , styled } = props const classes = cx ( 'ui' , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( inverted , 'inverted' ) , useKeyOnly ( styled , 'styled' ) , className , ) const rest = getUnhandledProps ( Accordion , props ) return < AccordionAccordion { ... rest } className = { classes } / > } 
function PlaceholderImage ( props ) { const { className , square , rectangular } = props const classes = cx ( useKeyOnly ( square , 'square' ) , useKeyOnly ( rectangular , 'rectangular' ) , 'image' , className , ) const rest = getUnhandledProps ( PlaceholderImage , props ) const ElementType = getElementType ( PlaceholderImage , props ) return < ElementType { ... rest } className = { classes } / > } 
function DropdownMenu ( props ) { const { children , className , content , direction , open , scrolling } = props const classes = cx ( direction , useKeyOnly ( open , 'visible' ) , useKeyOnly ( scrolling , 'scrolling' ) , 'menu transition' , className , ) const rest = getUnhandledProps ( DropdownMenu , props ) const ElementType = getElementType ( DropdownMenu , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function ListIcon ( props ) { const { className , verticalAlign } = props const classes = cx ( useVerticalAlignProp ( verticalAlign ) , className ) const rest = getUnhandledProps ( ListIcon , props ) return < Icon { ... rest } className = { classes } / > } 
function Advertisement ( props ) { const { centered , children , className , content , test , unit } = props const classes = cx ( 'ui' , unit , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( test , 'test' ) , 'ad' , className , ) const rest = getUnhandledProps ( Advertisement , props ) const ElementType = getElementType ( Advertisement , props ) return ( < ElementType { ... rest } className = { classes } data-text = { test } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function StatisticGroup ( props ) { const { children , className , color , content , horizontal , inverted , items , size , widths } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , useWidthProp ( widths ) , 'statistics' , className , ) const rest = getUnhandledProps ( StatisticGroup , props ) const ElementType = getElementType ( StatisticGroup , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { _ . map ( items , item => Statistic . create ( item ) ) } < / ElementType > ) } 
function Statistic ( props ) { const { children , className , color , content , floated , horizontal , inverted , label , size , text , value , } = props const classes = cx ( 'ui' , color , size , useValueAndKey ( floated , 'floated' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( inverted , 'inverted' ) , 'statistic' , className , ) const rest = getUnhandledProps ( Statistic , props ) const ElementType = getElementType ( Statistic , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StatisticValue . create ( value , { defaultProps : { text } , autoGenerateKey : false , } ) } { StatisticLabel . create ( label , { autoGenerateKey : false } ) } < / ElementType > ) } 
function getElementType ( Component , props , getDefault ) { const { defaultProps = { } } = Component 
function SegmentGroup ( props ) { const { children , className , compact , content , horizontal , piled , raised , size , stacked } = props const classes = cx ( 'ui' , size , useKeyOnly ( compact , 'compact' ) , useKeyOnly ( horizontal , 'horizontal' ) , useKeyOnly ( piled , 'piled' ) , useKeyOnly ( raised , 'raised' ) , useKeyOnly ( stacked , 'stacked' ) , 'segments' , className , ) const rest = getUnhandledProps ( SegmentGroup , props ) const ElementType = getElementType ( SegmentGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function TableHeaderCell ( props ) { const { as , className , sorted } = props const classes = cx ( useValueAndKey ( sorted , 'sorted' ) , className ) const rest = getUnhandledProps ( TableHeaderCell , props ) return < TableCell { ... rest } as = { as } className = { classes } / > } 
function Feed ( props ) { const { children , className , events , size } = props const classes = cx ( 'ui' , size , 'feed' , className ) const rest = getUnhandledProps ( Feed , props ) const ElementType = getElementType ( Feed , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } const eventElements = _ . map ( events , ( eventProps ) => { const { childKey , date , meta , summary , ... eventData } = eventProps const finalKey = childKey || [ date , meta , summary ] . join ( '-' ) return < FeedEvent date = { date } key = { finalKey } meta = { meta } summary = { summary } { ... eventData } / > } ) return ( < ElementType { ... rest } className = { classes } > { eventElements } < / ElementType > ) } 
function LabelGroup ( props ) { const { children , circular , className , color , content , size , tag } = props const classes = cx ( 'ui' , color , size , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( tag , 'tag' ) , 'labels' , className , ) const rest = getUnhandledProps ( LabelGroup , props ) const ElementType = getElementType ( LabelGroup , props ) return ( < ElementType { ... rest } className = { classes } > { childrenUtils . isNil ( children ) ? content : children } < / ElementType > ) } 
function FeedExtra ( props ) { const { children , className , content , images , text } = props const classes = cx ( useKeyOnly ( images , 'images' ) , useKeyOnly ( content || text , 'text' ) , 'extra' , className , ) const rest = getUnhandledProps ( FeedExtra , props ) const ElementType = getElementType ( FeedExtra , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } { content } { imageElements } < / ElementType > ) } 
function DropdownDivider ( props ) { const { className } = props const classes = cx ( 'divider' , className ) const rest = getUnhandledProps ( DropdownDivider , props ) const ElementType = getElementType ( DropdownDivider , props ) return < ElementType { ... rest } className = { classes } / > } 
function FeedSummary ( props ) { const { children , className , content , date , user } = props const classes = cx ( 'summary' , className ) const rest = getUnhandledProps ( FeedSummary , props ) const ElementType = getElementType ( FeedSummary , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { createShorthand ( FeedUser , val => ( { content : val } ) , user , { autoGenerateKey : false } ) } { content } { createShorthand ( FeedDate , val => ( { content : val } ) , date , { autoGenerateKey : false } ) } < / ElementType > ) } 
function StepContent ( props ) { const { children , className , content , description , title } = props const classes = cx ( 'content' , className ) const rest = getUnhandledProps ( StepContent , props ) const ElementType = getElementType ( StepContent , props ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } return ( < ElementType { ... rest } className = { classes } > { StepTitle . create ( title , { autoGenerateKey : false } ) } { StepDescription . create ( description , { autoGenerateKey : false } ) } < / ElementType > ) } 
function FormRadio ( props ) { const { control } = props const rest = getUnhandledProps ( FormRadio , props ) const ElementType = getElementType ( FormRadio , props ) return < ElementType { ... rest } control = { control } / > } 
function Image ( props ) { const { avatar , bordered , centered , children , circular , className , content , dimmer , disabled , floated , fluid , hidden , href , inline , label , rounded , size , spaced , verticalAlign , wrapped , ui , } = props const classes = cx ( useKeyOnly ( ui , 'ui' ) , size , useKeyOnly ( avatar , 'avatar' ) , useKeyOnly ( bordered , 'bordered' ) , useKeyOnly ( circular , 'circular' ) , useKeyOnly ( centered , 'centered' ) , useKeyOnly ( disabled , 'disabled' ) , useKeyOnly ( fluid , 'fluid' ) , useKeyOnly ( hidden , 'hidden' ) , useKeyOnly ( inline , 'inline' ) , useKeyOnly ( rounded , 'rounded' ) , useKeyOrValueAndKey ( spaced , 'spaced' ) , useValueAndKey ( floated , 'floated' ) , useVerticalAlignProp ( verticalAlign , 'aligned' ) , 'image' , className , ) const rest = getUnhandledProps ( Image , props ) const [ imgTagProps , rootProps ] = partitionHTMLProps ( rest , { htmlProps : htmlImageProps } ) const ElementType = getElementType ( Image , props , ( ) => { if ( ! _ . isNil ( dimmer ) || ! _ . isNil ( label ) || ! _ . isNil ( wrapped ) || ! childrenUtils . isNil ( children ) ) { return 'div' } } ) if ( ! childrenUtils . isNil ( children ) ) { return ( < ElementType { ... rest } className = { classes } > { children } < / ElementType > ) } if ( ! childrenUtils . isNil ( content ) ) { return ( < ElementType { ... rest } className = { classes } > { content } < / ElementType > ) } if ( ElementType === 'img' ) { return < ElementType { ... rootProps } { ... imgTagProps } className = { classes } / > } return ( < ElementType { ... rootProps } className = { classes } href = { href } > { Dimmer . create ( dimmer , { autoGenerateKey : false } ) } { Label . create ( label , { autoGenerateKey : false } ) } < img { ... imgTagProps } / > < / ElementType > ) } 
function ( width , height ) { var canvas = document . createElement ( 'canvas' ) ; canvas . width = width ; canvas . height = height ; canvas . oncontextmenu = function ( ) { return false ; } ; canvas . onselectstart = function ( ) { return false ; } ; return canvas ; } 
function ( canvas ) { var context = canvas . getContext ( '2d' ) , devicePixelRatio = window . devicePixelRatio || 1 , backingStorePixelRatio = context . webkitBackingStorePixelRatio || context . mozBackingStorePixelRatio || context . msBackingStorePixelRatio || context . oBackingStorePixelRatio || context . backingStorePixelRatio || 1 ; return devicePixelRatio / backingStorePixelRatio ; } 
function ( render , imagePath ) { var image = render . textures [ imagePath ] ; if ( image ) return image ; image = render . textures [ imagePath ] = new Image ( ) ; image . src = imagePath ; return image ; } 
function ( render , background ) { var cssBackground = background ; if ( / (jpg|gif|png)$ / . test ( background ) ) cssBackground = 'url(' + background + ')' ; render . canvas . style . background = cssBackground ; render . canvas . style . backgroundSize = "contain" ; render . currentBackground = background ; } 
function ( render , body ) { var bodyRender = body . render , texturePath = bodyRender . sprite . texture , texture = _getTexture ( render , texturePath ) , sprite = new PIXI . Sprite ( texture ) ; sprite . anchor . x = body . render . sprite . xOffset ; sprite . anchor . y = body . render . sprite . yOffset ; return sprite ; } 
function ( render , body ) { var bodyRender = body . render , options = render . options , primitive = new PIXI . Graphics ( ) , fillStyle = Common . colorToNumber ( bodyRender . fillStyle ) , strokeStyle = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleIndicator = Common . colorToNumber ( bodyRender . strokeStyle ) , strokeStyleWireframe = Common . colorToNumber ( '#bbb' ) , strokeStyleWireframeIndicator = Common . colorToNumber ( '#CD5C5C' ) , part ; primitive . clear ( ) ; 
function ( render , imagePath ) { var texture = render . textures [ imagePath ] ; if ( ! texture ) texture = render . textures [ imagePath ] = PIXI . Texture . fromImage ( imagePath ) ; return texture ; } 
function ( body , options ) { options = options || { } ; 
async function createPages ( { actions , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , 
function parseMonthString ( str ) { const matches = monthRe . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year <= 0 ) { return null ; } const month = Number ( matches [ 2 ] ) ; if ( month < 1 || month > 12 ) { return null ; } return { year , month } ; } 
function parseDateString ( str ) { const matches = dateRe . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year <= 0 ) { return null ; } const month = Number ( matches [ 2 ] ) ; if ( month < 1 || month > 12 ) { return null ; } const day = Number ( matches [ 3 ] ) ; if ( day < 1 || day > numberOfDaysInMonthOfYear ( month , year ) ) { return null ; } return { year , month , day } ; } 
function parseYearlessDateString ( str ) { const matches = yearlessDateRe . exec ( str ) ; if ( ! matches ) { return null ; } const month = Number ( matches [ 1 ] ) ; if ( month < 1 || month > 12 ) { return null ; } const day = Number ( matches [ 2 ] ) ; if ( day < 1 || day > numberOfDaysInMonthOfYear ( month , 4 ) ) { return null ; } return { month , day } ; } 
function parseTimeString ( str ) { const matches = timeRe . exec ( str ) ; if ( ! matches ) { return null ; } const hour = Number ( matches [ 1 ] ) ; if ( hour < 0 || hour > 23 ) { return null ; } const minute = Number ( matches [ 2 ] ) ; if ( minute < 0 || minute > 59 ) { return null ; } const second = matches [ 3 ] !== undefined ? Math . trunc ( Number ( matches [ 3 ] ) ) : 0 ; if ( second < 0 || second >= 60 ) { return null ; } const millisecond = matches [ 4 ] !== undefined ? Number ( matches [ 4 ] ) : 0 ; return { hour , minute , second , millisecond } ; } 
function parseLocalDateAndTimeString ( str , normalized = false ) { let separatorIdx = str . indexOf ( "T" ) ; if ( separatorIdx < 0 && ! normalized ) { separatorIdx = str . indexOf ( " " ) ; } if ( separatorIdx < 0 ) { return null ; } const date = parseDateString ( str . slice ( 0 , separatorIdx ) ) ; if ( date === null ) { return null ; } const time = parseTimeString ( str . slice ( separatorIdx + 1 ) ) ; if ( time === null ) { return null ; } return { date , time } ; } 
function weekNumberOfLastDay ( year ) { const jan1 = new Date ( year , 0 ) ; return jan1 . getDay ( ) === 4 || ( isLeapYear ( year ) && jan1 . getDay ( ) === 3 ) ? 53 : 52 ; } 
function parseWeekString ( str ) { const matches = weekRe . exec ( str ) ; if ( ! matches ) { return null ; } const year = Number ( matches [ 1 ] ) ; if ( year <= 0 ) { return null ; } const week = Number ( matches [ 2 ] ) ; if ( week < 1 || week > weekNumberOfLastDay ( year ) ) { return null ; } return { year , week } ; } 
function wrapNodeCanvasMethod ( ctx , name ) { const prev = ctx [ name ] ; ctx [ name ] = function ( image ) { const impl = idlUtils . implForWrapper ( image ) ; if ( impl ) { arguments [ 0 ] = impl . _image || impl . _canvas ; } return prev . apply ( ctx , arguments ) ; } ; } 
function Window ( options ) { EventTarget . setup ( this ) ; const rawPerformance = new RawPerformance ( ) ; const windowInitialized = rawPerformance . now ( ) ; const window = this ; mixin ( window , WindowEventHandlersImpl . prototype ) ; mixin ( window , GlobalEventHandlersImpl . prototype ) ; this . _initGlobalEvents ( ) ; 
function isHostInclusiveAncestor ( nodeImplA , nodeImplB ) { for ( const ancestor of domSymbolTree . ancestorsIterator ( nodeImplB ) ) { if ( ancestor === nodeImplA ) { return true ; } } const rootImplB = getRoot ( nodeImplB ) ; if ( rootImplB . _host ) { return isHostInclusiveAncestor ( nodeImplA , rootImplB . _host ) ; } return false ; } 
function isWindow ( val ) { if ( typeof val !== "object" ) { return false ; } const wrapper = idlUtils . wrapperForImpl ( val ) ; if ( typeof wrapper === "object" ) { return wrapper === wrapper . _globalProxy ; } 
function createClient ( xhr ) { const flag = xhr [ xhrSymbols . flag ] ; const properties = xhr [ xhrSymbols . properties ] ; const urlObj = new URL ( flag . uri ) ; const uri = urlObj . href ; const ucMethod = flag . method . toUpperCase ( ) ; const { requestManager } = flag ; if ( urlObj . protocol === "file:" ) { const response = new EventEmitter ( ) ; response . statusCode = 200 ; response . rawHeaders = [ ] ; response . headers = { } ; response . request = { uri : urlObj } ; const filePath = urlObj . pathname . replace ( / ^file:\/\/ / , "" ) . replace ( / ^\/([a-z]):\/ / i , "$1:/" ) . replace ( / %20 / g , " " ) ; const client = new EventEmitter ( ) ; const readableStream = fs . createReadStream ( filePath , { encoding : null } ) ; readableStream . on ( "data" , chunk => { response . emit ( "data" , chunk ) ; client . emit ( "data" , chunk ) ; } ) ; readableStream . on ( "end" , ( ) => { response . emit ( "end" ) ; client . emit ( "end" ) ; } ) ; readableStream . on ( "error" , err => { client . emit ( "error" , err ) ; } ) ; client . abort = function ( ) { readableStream . destroy ( ) ; client . emit ( "abort" ) ; } ; if ( requestManager ) { const req = { abort ( ) { properties . abortError = true ; xhr . abort ( ) ; } } ; requestManager . add ( req ) ; const rmReq = requestManager . remove . bind ( requestManager , req ) ; client . on ( "abort" , rmReq ) ; client . on ( "error" , rmReq ) ; client . on ( "end" , rmReq ) ; } process . nextTick ( ( ) => client . emit ( "response" , response ) ) ; return client ; } if ( urlObj . protocol === "data:" ) { const response = new EventEmitter ( ) ; response . request = { uri : urlObj } ; const client = new EventEmitter ( ) ; let buffer ; try { const parsed = parseDataURL ( uri ) ; const contentType = parsed . mimeType . toString ( ) ; buffer = parsed . body ; response . statusCode = 200 ; response . rawHeaders = [ "Content-Type" , contentType ] ; response . headers = { "content-type" : contentType } ; } catch ( err ) { process . nextTick ( ( ) => client . emit ( "error" , err ) ) ; return client ; } client . abort = ( ) => { 
function parseFragment ( markup , contextElement ) { const { _parsingMode } = contextElement . _ownerDocument ; let parseAlgorithm ; if ( _parsingMode === "html" ) { parseAlgorithm = htmlParser . parseFragment ; } else if ( _parsingMode === "xml" ) { parseAlgorithm = xmlParser . parseFragment ; } 
function onError ( event ) { const bench = event . target ; console . error ( "Error in benchmark" , bench . name , ":" , bench . error ) ; } 
function reportAnError ( line , col , target , errorObject , message , location ) { if ( target [ errorReportingMode ] ) { return false ; } target [ errorReportingMode ] = true ; const event = createAnEvent ( "error" , ErrorEvent , { cancelable : true , message , filename : location , lineno : line , colno : col , error : errorObject } ) ; try { target . _dispatch ( event ) ; } finally { target [ errorReportingMode ] = false ; return event . defaultPrevented ; } } 
function maybeFetchAndProcess ( el ) { if ( ! isExternalResourceLink ( el ) ) { return ; } 
function fetchAndProcess ( el ) { const href = el . getAttributeNS ( null , "href" ) ; if ( href === null || href === "" ) { return ; } const url = parseURLToResultingURLRecord ( href , el . _ownerDocument ) ; if ( url === null ) { return ; } 
function isSlotable ( nodeImpl ) { return nodeImpl && ( nodeImpl . nodeType === NODE_TYPE . ELEMENT_NODE || nodeImpl . nodeType === NODE_TYPE . TEXT_NODE ) ; } 
function isShadowInclusiveAncestor ( ancestor , node ) { while ( isNode ( node ) ) { if ( node === ancestor ) { return true ; } if ( isShadowRoot ( node ) ) { node = node . host ; } else { node = domSymbolTree . parent ( node ) ; } } return false ; } 
function retarget ( a , b ) { while ( true ) { if ( ! isNode ( a ) ) { return a ; } const aRoot = getRoot ( a ) ; if ( ! isShadowRoot ( aRoot ) || ( isNode ( b ) && isShadowInclusiveAncestor ( aRoot , b ) ) ) { return a ; } a = getRoot ( a ) . host ; } } 
function shadowIncludingRoot ( node ) { const root = getRoot ( node ) ; return isShadowRoot ( root ) ? shadowIncludingRoot ( root . host ) : root ; } 
function assignSlotable ( slot ) { const slotables = findSlotable ( slot ) ; let shouldFireSlotChange = false ; if ( slotables . length !== slot . _assignedNodes . length ) { shouldFireSlotChange = true ; } else { for ( let i = 0 ; i < slotables . length ; i ++ ) { if ( slotables [ i ] !== slot . _assignedNodes [ i ] ) { shouldFireSlotChange = true ; break ; } } } if ( shouldFireSlotChange ) { signalSlotChange ( slot ) ; } slot . _assignedNodes = slotables ; for ( const slotable of slotables ) { slotable . _assignedSlot = slot ; } } 
function assignSlotableForTree ( root ) { for ( const slot of domSymbolTree . treeIterator ( root ) ) { if ( isSlot ( slot ) ) { assignSlotable ( slot ) ; } } } 
function findSlotable ( slot ) { const result = [ ] ; const root = getRoot ( slot ) ; if ( ! isShadowRoot ( root ) ) { return result ; } for ( const slotable of domSymbolTree . treeIterator ( root . host ) ) { const foundSlot = findSlot ( slotable ) ; if ( foundSlot === slot ) { result . push ( slotable ) ; } } return result ; } 
function findFlattenedSlotables ( slot ) { const result = [ ] ; const root = getRoot ( slot ) ; if ( ! isShadowRoot ( root ) ) { return result ; } const slotables = findSlotable ( slot ) ; if ( slotables . length === 0 ) { for ( const child of domSymbolTree . childrenIterator ( slot ) ) { if ( isSlotable ( child ) ) { slotables . push ( child ) ; } } } for ( const node of slotables ) { if ( isSlot ( node ) && isShadowRoot ( getRoot ( node ) ) ) { const temporaryResult = findFlattenedSlotables ( node ) ; result . push ( ... temporaryResult ) ; } else { result . push ( node ) ; } } return result ; } 
function findSlot ( slotable , openFlag ) { const { parentNode : parent } = slotable ; if ( ! parent ) { return null ; } const shadow = parent . _shadowRoot ; if ( ! shadow || ( openFlag && shadow . mode !== "open" ) ) { return null ; } for ( const child of domSymbolTree . treeIterator ( shadow ) ) { if ( isSlot ( child ) && child . name === slotable . _slotableName ) { return child ; } } return null ; } 
function signalSlotChange ( slot ) { if ( ! signalSlotList . some ( entry => entry === slot ) ) { signalSlotList . push ( slot ) ; } queueMutationObserverMicrotask ( ) ; } 
function navigateToFragment ( window , newURL , flags ) { const document = idlUtils . implForWrapper ( window . _document ) ; window . _sessionHistory . clearHistoryTraversalTasks ( ) ; if ( ! flags . replacement ) { 
function invokeEventListeners ( tuple , eventImpl ) { const tupleIndex = eventImpl . _path . indexOf ( tuple ) ; for ( let i = tupleIndex ; i >= 0 ; i -- ) { const t = eventImpl . _path [ i ] ; if ( t . target ) { eventImpl . target = t . target ; break ; } } eventImpl . relatedTarget = idlUtils . wrapperForImpl ( tuple . relatedTarget ) ; if ( eventImpl . _stopPropagationFlag ) { return ; } eventImpl . currentTarget = idlUtils . wrapperForImpl ( tuple . item ) ; const listeners = tuple . item . _eventListeners ; innerInvokeEventListeners ( eventImpl , listeners ) ; } 
function innerInvokeEventListeners ( eventImpl , listeners ) { let found = false ; const { type , target } = eventImpl ; const wrapper = idlUtils . wrapperForImpl ( target ) ; if ( ! listeners || ! listeners [ type ] ) { return found ; } 
function normalizeEventHandlerOptions ( options , defaultBoolKeys ) { const returnValue = { } ; 
function appendToEventPath ( eventImpl , target , targetOverride , relatedTarget , touchTargets , slotInClosedTree ) { const itemInShadowTree = isNode ( target ) && isShadowRoot ( getRoot ( target ) ) ; const rootOfClosedTree = isShadowRoot ( target ) && target . mode === "closed" ; eventImpl . _path . push ( { item : target , itemInShadowTree , target : targetOverride , relatedTarget , touchTargets , rootOfClosedTree , slotInClosedTree } ) ; } 
function queueMutationRecord ( type , target , name , namespace , oldValue , addedNodes , removedNodes , previousSibling , nextSibling ) { const interestedObservers = new Map ( ) ; const nodes = domSymbolTree . ancestorsToArray ( target ) ; for ( const node of nodes ) { for ( const registered of node . _registeredObserverList ) { const { options , observer : mo } = registered ; if ( ! ( node !== target && options . subtree === false ) && ! ( type === MUTATION_TYPE . ATTRIBUTES && options . attributes !== true ) && ! ( type === MUTATION_TYPE . ATTRIBUTES && options . attributeFilter && ! options . attributeFilter . some ( value => value === name || value === namespace ) ) && ! ( type === MUTATION_TYPE . CHARACTER_DATA && options . characterData !== true ) && ! ( type === MUTATION_TYPE . CHILD_LIST && options . childList === false ) ) { if ( ! interestedObservers . has ( mo ) ) { interestedObservers . set ( mo , null ) ; } if ( ( type === MUTATION_TYPE . ATTRIBUTES && options . attributeOldValue === true ) || ( type === MUTATION_TYPE . CHARACTER_DATA && options . characterDataOldValue === true ) ) { interestedObservers . set ( mo , oldValue ) ; } } } } for ( const [ observer , mappedOldValue ] of interestedObservers . entries ( ) ) { const record = MutationRecord . createImpl ( [ ] , { type , target , attributeName : name , attributeNamespace : namespace , oldValue : mappedOldValue , addedNodes , removedNodes , previousSibling , nextSibling } ) ; observer . _recordQueue . push ( record ) ; activeMutationObservers . add ( observer ) ; } queueMutationObserverMicrotask ( ) ; } 
function queueTreeMutationRecord ( target , addedNodes , removedNodes , previousSibling , nextSibling ) { queueMutationRecord ( MUTATION_TYPE . CHILD_LIST , target , null , null , null , addedNodes , removedNodes , previousSibling , nextSibling ) ; } 
function queueAttributeMutationRecord ( target , name , namespace , oldValue ) { queueMutationRecord ( MUTATION_TYPE . ATTRIBUTES , target , name , namespace , oldValue , [ ] , [ ] , null , null ) ; } 
function notifyMutationObservers ( ) { mutationObserverMicrotaskQueueFlag = false ; const notifyList = [ ... activeMutationObservers ] . sort ( ( a , b ) => a . _id - b . _id ) ; activeMutationObservers . clear ( ) ; const signalList = [ ... signalSlotList ] ; signalSlotList . splice ( 0 , signalSlotList . length ) ; for ( const mo of notifyList ) { const records = [ ... mo . _recordQueue ] ; mo . _recordQueue = [ ] ; for ( const node of mo . _nodeList ) { node . _registeredObserverList = node . _registeredObserverList . filter ( registeredObserver => { return registeredObserver . source !== mo ; } ) ; if ( records . length ) { try { mo . _callback ( records . map ( idlUtils . wrapperForImpl ) , idlUtils . wrapperForImpl ( mo ) ) ; } catch ( e ) { const { target } = records [ 0 ] ; const window = target . _ownerDocument . _defaultView ; reportException ( window , e ) ; } } } } for ( const slot of signalList ) { const slotChangeEvent = Event . createImpl ( [ "slotchange" , { bubbles : true } ] , { isTrusted : true } ) ; slot . _dispatch ( slotChangeEvent ) ; } } 
function addStylesheet ( sheet , elementImpl ) { elementImpl . _ownerDocument . styleSheets . push ( sheet ) ; 
function scanForImportRules ( elementImpl , cssRules , baseURL ) { if ( ! cssRules ) { return ; } for ( let i = 0 ; i < cssRules . length ; ++ i ) { if ( cssRules [ i ] . cssRules ) { 
function getUTCMs ( year , month = 1 , day = 1 , hour = 0 , minute = 0 , second = 0 , millisecond = 0 ) { if ( year > 99 || year < 0 ) { return Date . UTC ( year , month - 1 , day , hour , minute , second , millisecond ) ; } const d = new Date ( 0 ) ; d . setUTCFullYear ( year ) ; d . setUTCMonth ( month - 1 ) ; d . setUTCDate ( day ) ; d . setUTCHours ( hour ) ; d . setUTCMinutes ( minute ) ; d . setUTCSeconds ( second , millisecond ) ; return d . valueOf ( ) ; } 
function sammary ( ) { const nodeFn = function ( { parentPaths , lang , item , isDir , result } ) { const navTitle = generateNavTitle ( { parentPaths , item , sign : isDir ? '-' : '*' , lang } ) ; result . push ( navTitle ) ; } ; langs . forEach ( dir => { const SUMMARY = 'SUMMARY.md' ; const targetFile = path . join ( docsDir , ` ${ dir } ${ SUMMARY } ` ) ; const result = walk ( { catalog : docConfig . catalog , lang : dir , result : [ ] , parentPaths : [ ] , fn : nodeFn } ) ; if ( result && result . length ) { result . unshift ( '# whistle\n' ) ; fs . writeFileSync ( targetFile , result . join ( '\n' ) ) ; } } ) ; } 
function clearCache ( ) { var overflow = frames . length - MAX_FRAMES_LENGTH ; overflow > 0 && frames . splice ( 0 , overflow + 60 ) ; var len = ids . length ; if ( len <= MAX_LENGTH ) { return ; } var now = Date . now ( ) ; var _ids = [ ] ; var preserveLen = len ; overflow = - 1 ; if ( len >= OVERFLOW_LENGTH ) { overflow = len - MAX_CACHE_SIZE ; preserveLen = len - PRESERVE_LEN ; } for ( var i = 0 ; i < len ; i ++ ) { var id = ids [ i ] ; var curData = reqData [ id ] ; if ( i > overflow && ( i >= preserveLen || ( curData . endTime ? now - curData . endTime < CACHE_TIME : now - curData . startTime < CACHE_TIMEOUT ) ) ) { if ( curData . endTime && curData . abort ) { delete curData . abort ; } _ids . push ( id ) ; } else { delete reqData [ id ] ; } } ids = _ids ; } 
function formatFilter ( filter , clientIp ) { if ( ! filter . url && ! filter . name && ! filter . value && ! filter . ip ) { return ; } var url = util . trimStr ( filter . url ) . toLowerCase ( ) ; var name = util . trimStr ( filter . name ) . toLowerCase ( ) ; var value = util . trimStr ( filter . value ) . toLowerCase ( ) ; var ip = util . trimStr ( filter . ip ) ; var list = [ ] ; if ( ip === 'self' ) { ip = clientIp ; } else if ( ip && ! net . isIP ( ip ) ) { ip . split ( ',' ) . forEach ( function ( item ) { item = item . trim ( ) ; if ( item === 'self' ) { item = clientIp ; } if ( net . isIP ( item ) && list . indexOf ( item ) === - 1 ) { list . push ( item ) ; } } ) ; ip = null ; } var result ; if ( url ) { result = { } ; result . url = url ; } if ( name && value ) { result = result || { } ; result . name = name ; result . value = value ; } if ( ip ) { result = result || { } ; result . ip = ip ; } if ( list . length ) { result = result || { } ; result . ipList = list . slice ( 0 , 16 ) ; } return result ; } 
function resolveInlineValues ( str ) { str = str && str . replace ( CONTROL_RE , '' ) . trim ( ) ; if ( ! str || str . indexOf ( '```' ) === - 1 ) { return str ; } return str . replace ( MULTI_LINE_VALUE_RE , function ( _ , __ , key , value ) { inlineValues = inlineValues || { } ; if ( ! inlineValues [ key ] ) { inlineValues [ key ] = value ; } return '' ; } ) ; } 
function ( message , filename , lineno , colno , error ) { if ( error ) { wConsole . error ( getErrorStack ( error , message ) ) ; } else { wConsole . error ( 'Error: ' + message + '(' + filename + ':' + lineno + ':' + ( colno || 0 ) + ')' + getPageInfo ( ) ) ; } } 
function renderChildNodes ( props , from , to ) { var nodeType = props . nodeType , data = props . data , collectionLimit = props . collectionLimit , circularCache = props . circularCache , keyPath = props . keyPath , postprocessValue = props . postprocessValue , sortObjectKeys = props . sortObjectKeys ; var childNodes = [ ] ; ( 0 , _getCollectionEntries2 [ 'default' ] ) ( nodeType , data , sortObjectKeys , collectionLimit , from , to ) . forEach ( function ( entry ) { if ( entry . to ) { childNodes . push ( _react2 [ 'default' ] . createElement ( _ItemRange2 [ 'default' ] , ( 0 , _extends3 [ 'default' ] ) ( { } , props , { key : 'ItemRange--' + entry . from + '-' + entry . to , from : entry . from , to : entry . to , renderChildNodes : renderChildNodes } ) ) ) ; } else { var key = entry . key , value = entry . value ; var isCircular = circularCache . indexOf ( value ) !== - 1 ; var node = _react2 [ 'default' ] . createElement ( _JSONNode2 [ 'default' ] , ( 0 , _extends3 [ 'default' ] ) ( { } , props , { postprocessValue : postprocessValue , collectionLimit : collectionLimit } , { key : 'Node--' + key , keyPath : [ key ] . concat ( keyPath ) , value : postprocessValue ( value ) , circularCache : [ ] . concat ( circularCache , [ value ] ) , isCircular : isCircular , hideRoot : false } ) ) ; if ( node !== false ) { childNodes . push ( node ) ; } } } ) ; return childNodes ; } 
function createItemString ( data , limit ) { var count = 0 ; var hasMore = false ; if ( ( 0 , _isSafeInteger2 [ 'default' ] ) ( data . size ) ) { count = data . size ; } else { for ( var _iterator = data , _isArray = Array . isArray ( _iterator ) , _i = 0 , _iterator = _isArray ? _iterator : ( 0 , _getIterator3 [ 'default' ] ) ( _iterator ) ; ; ) { var _ref ; if ( _isArray ) { if ( _i >= _iterator . length ) break ; _ref = _iterator [ _i ++ ] ; } else { _i = _iterator . next ( ) ; if ( _i . done ) break ; _ref = _i . value ; } var entry = _ref ; 
function JSONIterableNode ( _ref2 ) { var props = ( 0 , _objectWithoutProperties3 [ 'default' ] ) ( _ref2 , [ ] ) ; return _react2 [ 'default' ] . createElement ( _JSONNestedNode2 [ 'default' ] , ( 0 , _extends3 [ 'default' ] ) ( { } , props , { nodeType : 'Iterable' , nodeTypeIndicator : '()' , createItemString : createItemString } ) ) ; } 
function join ( first , second ) { if ( ! first || ! second ) { return first + second ; } var firstIndex = first . indexOf ( '?' ) ; var secondIndex = second . indexOf ( '?' ) ; var firstQuery = '' ; var secondQuery = '' ; if ( firstIndex != - 1 ) { firstQuery = first . substring ( firstIndex ) ; first = first . substring ( 0 , firstIndex ) ; } if ( secondIndex != - 1 ) { secondQuery = second . substring ( secondIndex ) ; second = second . substring ( 0 , secondIndex ) ; } var query = firstQuery && secondQuery ? firstQuery + secondQuery . substring ( 1 ) : ( firstQuery || secondQuery ) ; if ( second ) { var lastIndex = first . length - 1 ; var startWithSep = isPathSeparator ( second [ 0 ] ) ; if ( isPathSeparator ( first [ lastIndex ] ) ) { first = startWithSep ? first . substring ( 0 , lastIndex ) + second : first + second ; } else { first = first + ( startWithSep ? '' : '/' ) + second ; } } return WEB_PROTOCOL_RE . test ( first ) ? formatUrl ( first + query ) : first + query ; } 
function handleReq ( req , data ) { var method = util . getMethod ( data . method || req . method ) ; req . method = method ; req . timeout = parseInt ( data . timeout , 10 ) ; extend ( req . headers , data . headers ) ; if ( typeof data . charset == 'string' ) { var type = req . headers [ 'content-type' ] ; var charset = '; charset=' + data . charset ; if ( typeof type == 'string' ) { req . headers [ 'content-type' ] = type . split ( ';' ) [ 0 ] + charset ; } else { req . headers [ 'content-type' ] = charset ; } } else { delete data . charset ; } if ( ! util . hasRequestBody ( method ) ) { delete data . top ; delete data . bottom ; delete data . body ; delete req . headers [ 'content-length' ] ; } else if ( data . top || data . bottom || data . body ) { delete req . headers [ 'content-length' ] ; } util . isWhistleTransformData ( data ) && req . addZipTransform ( new WhistleTransform ( data ) ) ; } 
function ( id , options ) { options = options || { } ; if ( typeof id === "object" ) { options = id ; } var _this = this ; var classPrefix = this . classPrefix = editormd . classPrefix ; var settings = this . settings = $ . extend ( true , editormd . defaults , options ) ; id = ( typeof id === "object" ) ? settings . id : id ; var editor = this . editor = $ ( "#" + id ) ; this . id = id ; this . lang = settings . lang ; var classNames = this . classNames = { textarea : { html : classPrefix + "html-textarea" , markdown : classPrefix + "markdown-textarea" } } ; settings . pluginPath = ( settings . pluginPath === "" ) ? settings . path + "../plugins/" : settings . pluginPath ; this . state . watching = ( settings . watch ) ? true : false ; if ( ! editor . hasClass ( "editormd" ) ) { editor . addClass ( "editormd" ) ; } editor . css ( { width : ( typeof settings . width === "number" ) ? settings . width + "px" : settings . width , height : ( typeof settings . height === "number" ) ? settings . height + "px" : settings . height } ) ; if ( settings . autoHeight ) { editor . css ( "height" , "auto" ) ; } var markdownTextarea = this . markdownTextarea = editor . children ( "textarea" ) ; if ( markdownTextarea . length < 1 ) { editor . append ( "<textarea></textarea>" ) ; markdownTextarea = this . markdownTextarea = editor . children ( "textarea" ) ; } markdownTextarea . addClass ( classNames . textarea . markdown ) . attr ( "placeholder" , settings . placeholder ) ; if ( typeof markdownTextarea . attr ( "name" ) === "undefined" || markdownTextarea . attr ( "name" ) === "" ) { markdownTextarea . attr ( "name" , ( settings . name !== "" ) ? settings . name : id + "-markdown-doc" ) ; } var appendElements = [ ( ! settings . readOnly ) ? "<a href=\"javascript:;\" class=\"fa fa-close " + classPrefix + "preview-close-btn\"></a>" : "" , ( ( settings . saveHTMLToTextarea ) ? "<textarea class=\"" + classNames . textarea . html + "\" name=\"" + id + "-html-code\"></textarea>" : "" ) , "<div class=\"" + classPrefix + "preview\"><div class=\"markdown-body " + classPrefix + "preview-container\"></div></div>" , "<div class=\"" + classPrefix + "container-mask\" style=\"display:block;\"></div>" , "<div class=\"" + classPrefix + "mask\"></div>" ] . join ( "\n" ) ; editor . append ( appendElements ) . addClass ( classPrefix + "vertical" ) ; if ( settings . theme !== "" ) { editor . addClass ( classPrefix + "theme-" + settings . theme ) ; } this . mask = editor . children ( "." + classPrefix + "mask" ) ; this . containerMask = editor . children ( "." + classPrefix + "container-mask" ) ; if ( settings . markdown !== "" ) { markdownTextarea . val ( settings . markdown ) ; } if ( settings . appendMarkdown !== "" ) { markdownTextarea . val ( markdownTextarea . val ( ) + settings . appendMarkdown ) ; } this . htmlTextarea = editor . children ( "." + classNames . textarea . html ) ; this . preview = editor . children ( "." + classPrefix + "preview" ) ; this . previewContainer = this . preview . children ( "." + classPrefix + "preview-container" ) ; if ( settings . previewTheme !== "" ) { this . preview . addClass ( classPrefix + "preview-theme-" + settings . previewTheme ) ; } if ( typeof define === "function" && define . amd ) { if ( typeof katex !== "undefined" ) { editormd . $katex = katex ; } if ( settings . searchReplace && ! settings . readOnly ) { editormd . loadCSS ( settings . path + "codemirror/addon/dialog/dialog" ) ; editormd . loadCSS ( settings . path + "codemirror/addon/search/matchesonscrollbar" ) ; } } if ( ( typeof define === "function" && define . amd ) || ! settings . autoLoadModules ) { if ( typeof CodeMirror !== "undefined" ) { editormd . $CodeMirror = CodeMirror ; } if ( typeof marked !== "undefined" ) { editormd . $marked = marked ; } this . setCodeMirror ( ) . setToolbar ( ) . loadedDisplay ( ) ; } else { this . loadQueues ( ) ; } return this ; } 
function ( ) { var _this = this ; var settings = this . settings ; var loadPath = settings . path ; var loadFlowChartOrSequenceDiagram = function ( ) { if ( editormd . isIE8 ) { _this . loadedDisplay ( ) ; return ; } if ( settings . flowChart || settings . sequenceDiagram ) { editormd . loadScript ( loadPath + "raphael.min" , function ( ) { editormd . loadScript ( loadPath + "underscore.min" , function ( ) { if ( ! settings . flowChart && settings . sequenceDiagram ) { editormd . loadScript ( loadPath + "sequence-diagram.min" , function ( ) { _this . loadedDisplay ( ) ; } ) ; } else if ( settings . flowChart && ! settings . sequenceDiagram ) { editormd . loadScript ( loadPath + "flowchart.min" , function ( ) { editormd . loadScript ( loadPath + "jquery.flowchart.min" , function ( ) { _this . loadedDisplay ( ) ; } ) ; } ) ; } else if ( settings . flowChart && settings . sequenceDiagram ) { editormd . loadScript ( loadPath + "flowchart.min" , function ( ) { editormd . loadScript ( loadPath + "jquery.flowchart.min" , function ( ) { editormd . loadScript ( loadPath + "sequence-diagram.min" , function ( ) { _this . loadedDisplay ( ) ; } ) ; } ) ; } ) ; } } ) ; } ) ; } else { _this . loadedDisplay ( ) ; } } ; editormd . loadCSS ( loadPath + "codemirror/codemirror.min" ) ; if ( settings . searchReplace && ! settings . readOnly ) { editormd . loadCSS ( loadPath + "codemirror/addon/dialog/dialog" ) ; editormd . loadCSS ( loadPath + "codemirror/addon/search/matchesonscrollbar" ) ; } if ( settings . codeFold ) { editormd . loadCSS ( loadPath + "codemirror/addon/fold/foldgutter" ) ; } editormd . loadScript ( loadPath + "codemirror/codemirror.min" , function ( ) { editormd . $CodeMirror = CodeMirror ; editormd . loadScript ( loadPath + "codemirror/modes.min" , function ( ) { editormd . loadScript ( loadPath + "codemirror/addons.min" , function ( ) { _this . setCodeMirror ( ) ; if ( settings . mode !== "gfm" && settings . mode !== "markdown" ) { _this . loadedDisplay ( ) ; return false ; } _this . setToolbar ( ) ; editormd . loadScript ( loadPath + "marked.min" , function ( ) { editormd . $marked = marked ; if ( settings . previewCodeHighlight ) { editormd . loadScript ( loadPath + "prettify.min" , function ( ) { loadFlowChartOrSequenceDiagram ( ) ; } ) ; } else { loadFlowChartOrSequenceDiagram ( ) ; } } ) ; } ) ; } ) ; } ) ; return this ; } 
function ( theme ) { var editor = this . editor ; var oldTheme = this . settings . theme ; var themePrefix = this . classPrefix + "theme-" ; editor . removeClass ( themePrefix + oldTheme ) . addClass ( themePrefix + theme ) ; this . settings . theme = theme ; return this ; } 
function ( theme ) { var settings = this . settings ; settings . editorTheme = theme ; if ( theme !== "default" ) { editormd . loadCSS ( settings . path + "codemirror/theme/" + settings . editorTheme ) ; } this . cm . setOption ( "theme" , theme ) ; return this ; } 
function ( theme ) { var preview = this . preview ; var oldTheme = this . settings . previewTheme ; var themePrefix = this . classPrefix + "preview-theme-" ; preview . removeClass ( themePrefix + oldTheme ) . addClass ( themePrefix + theme ) ; this . settings . previewTheme = theme ; return this ; } 
function ( ) { var settings = this . settings ; var editor = this . editor ; if ( settings . editorTheme !== "default" ) { editormd . loadCSS ( settings . path + "codemirror/theme/" + settings . editorTheme ) ; } var codeMirrorConfig = { mode : settings . mode , theme : settings . editorTheme , tabSize : settings . tabSize , dragDrop : false , autofocus : settings . autoFocus , autoCloseTags : settings . autoCloseTags , readOnly : ( settings . readOnly ) ? "nocursor" : false , indentUnit : settings . indentUnit , lineNumbers : settings . lineNumbers , lineWrapping : settings . lineWrapping , extraKeys : { "Ctrl-Q" : function ( cm ) { cm . foldCode ( cm . getCursor ( ) ) ; } } , foldGutter : settings . codeFold , gutters : [ "CodeMirror-linenumbers" , "CodeMirror-foldgutter" ] , matchBrackets : settings . matchBrackets , indentWithTabs : settings . indentWithTabs , styleActiveLine : settings . styleActiveLine , styleSelectedText : settings . styleSelectedText , autoCloseBrackets : settings . autoCloseBrackets , showTrailingSpace : settings . showTrailingSpace , highlightSelectionMatches : ( ( ! settings . matchWordHighlight ) ? false : { showToken : ( settings . matchWordHighlight === "onselected" ) ? false : / \w / } ) } ; this . codeEditor = this . cm = editormd . $CodeMirror . fromTextArea ( this . markdownTextarea [ 0 ] , codeMirrorConfig ) ; this . codeMirror = this . cmElement = editor . children ( ".CodeMirror" ) ; if ( settings . value !== "" ) { this . cm . setValue ( settings . value ) ; } this . codeMirror . css ( { fontSize : settings . fontSize , width : ( ! settings . watch ) ? "100%" : "50%" } ) ; if ( settings . autoHeight ) { this . codeMirror . css ( "height" , "auto" ) ; this . cm . setOption ( "viewportMargin" , Infinity ) ; } if ( ! settings . lineNumbers ) { this . codeMirror . find ( ".CodeMirror-gutters" ) . css ( "border-right" , "none" ) ; } return this ; } 
function ( line ) { var settings = this . settings ; if ( ! settings . gotoLine ) { return this ; } var cm = this . cm ; var editor = this . editor ; var count = cm . lineCount ( ) ; var preview = this . preview ; if ( typeof line === "string" ) { if ( line === "last" ) { line = count ; } if ( line === "first" ) { line = 1 ; } } if ( typeof line !== "number" ) { alert ( "Error: The line number must be an integer." ) ; return this ; } line = parseInt ( line ) - 1 ; if ( line > count ) { alert ( "Error: The line number range 1-" + count ) ; return this ; } cm . setCursor ( { line : line , ch : 0 } ) ; var scrollInfo = cm . getScrollInfo ( ) ; var clientHeight = scrollInfo . clientHeight ; var coords = cm . charCoords ( { line : line , ch : 0 } , "local" ) ; cm . scrollTo ( null , ( coords . top + coords . bottom - clientHeight ) / 2 ) ; if ( settings . watch ) { var cmScroll = this . codeMirror . find ( ".CodeMirror-scroll" ) [ 0 ] ; var height = $ ( cmScroll ) . height ( ) ; var scrollTop = cmScroll . scrollTop ; var percent = ( scrollTop / cmScroll . scrollHeight ) ; if ( scrollTop === 0 ) { preview . scrollTop ( 0 ) ; } else if ( scrollTop + height >= cmScroll . scrollHeight - 16 ) { preview . scrollTop ( preview [ 0 ] . scrollHeight ) ; } else { preview . scrollTop ( preview [ 0 ] . scrollHeight * percent ) ; } } cm . focus ( ) ; return this ; } 
function ( ) { if ( typeof arguments [ 1 ] !== "undefined" ) { if ( typeof arguments [ 1 ] === "function" ) { arguments [ 1 ] = $ . proxy ( arguments [ 1 ] , this ) ; } this [ arguments [ 0 ] ] = arguments [ 1 ] ; } if ( typeof arguments [ 0 ] === "object" && typeof arguments [ 0 ] . length === "undefined" ) { $ . extend ( true , this , arguments [ 0 ] ) ; } return this ; } 
function ( key , value ) { var settings = this . settings ; if ( typeof key === "object" ) { settings = $ . extend ( true , settings , key ) ; } if ( typeof key === "string" ) { settings [ key ] = value ; } this . settings = settings ; this . recreate ( ) ; return this ; } 
function ( eventType , callback ) { var settings = this . settings ; if ( typeof settings [ "on" + eventType ] !== "undefined" ) { settings [ "on" + eventType ] = $ . proxy ( callback , this ) ; } return this ; } 
function ( callback ) { var settings = this . settings ; if ( settings . readOnly ) { return this ; } if ( settings . toolbar && ( this . toolbar . length < 1 || this . toolbar . find ( "." + this . classPrefix + "menu" ) . html ( ) === "" ) ) { this . setToolbar ( ) ; } settings . toolbar = true ; this . toolbar . show ( ) ; this . resize ( ) ; $ . proxy ( callback || function ( ) { } , this ) ( ) ; return this ; } 
function ( callback ) { var settings = this . settings ; settings . toolbar = false ; this . toolbar . hide ( ) ; this . resize ( ) ; $ . proxy ( callback || function ( ) { } , this ) ( ) ; return this ; } 
function ( fixed ) { var state = this . state ; var editor = this . editor ; var toolbar = this . toolbar ; var settings = this . settings ; if ( typeof fixed !== "undefined" ) { settings . toolbarAutoFixed = fixed ; } var autoFixedHandle = function ( ) { var $window = $ ( window ) ; var top = $window . scrollTop ( ) ; if ( ! settings . toolbarAutoFixed ) { return false ; } if ( top - editor . offset ( ) . top > 10 && top < editor . height ( ) ) { toolbar . css ( { position : "fixed" , width : editor . width ( ) + "px" , left : ( $window . width ( ) - editor . width ( ) ) / 2 + "px" } ) ; } else { toolbar . css ( { position : "absolute" , width : "100%" , left : 0 } ) ; } } ; if ( ! state . fullscreen && ! state . preview && settings . toolbar && settings . toolbarAutoFixed ) { $ ( window ) . bind ( "scroll" , autoFixedHandle ) ; } return this ; } 
function ( ) { var settings = this . settings ; if ( settings . readOnly ) { return this ; } var editor = this . editor ; var preview = this . preview ; var classPrefix = this . classPrefix ; var toolbar = this . toolbar = editor . children ( "." + classPrefix + "toolbar" ) ; if ( settings . toolbar && toolbar . length < 1 ) { var toolbarHTML = "<div class=\"" + classPrefix + "toolbar\"><div class=\"" + classPrefix + "toolbar-container\"><ul class=\"" + classPrefix + "menu\"></ul></div></div>" ; editor . append ( toolbarHTML ) ; toolbar = this . toolbar = editor . children ( "." + classPrefix + "toolbar" ) ; } if ( ! settings . toolbar ) { toolbar . hide ( ) ; return this ; } toolbar . show ( ) ; var icons = ( typeof settings . toolbarIcons === "function" ) ? settings . toolbarIcons ( ) : ( ( typeof settings . toolbarIcons === "string" ) ? editormd . toolbarModes [ settings . toolbarIcons ] : settings . toolbarIcons ) ; var toolbarMenu = toolbar . find ( "." + this . classPrefix + "menu" ) , menu = "" ; var pullRight = false ; for ( var i = 0 , len = icons . length ; i < len ; i ++ ) { var name = icons [ i ] ; if ( name === "||" ) { pullRight = true ; } else if ( name === "|" ) { menu += "<li class=\"divider\" unselectable=\"on\">|</li>" ; } else { var isHeader = ( / h(\d) / . test ( name ) ) ; var index = name ; if ( name === "watch" && ! settings . watch ) { index = "unwatch" ; } var title = settings . lang . toolbar [ index ] ; var iconTexts = settings . toolbarIconTexts [ index ] ; var iconClass = settings . toolbarIconsClass [ index ] ; title = ( typeof title === "undefined" ) ? "" : title ; iconTexts = ( typeof iconTexts === "undefined" ) ? "" : iconTexts ; iconClass = ( typeof iconClass === "undefined" ) ? "" : iconClass ; var menuItem = pullRight ? "<li class=\"pull-right\">" : "<li>" ; if ( typeof settings . toolbarCustomIcons [ name ] !== "undefined" && typeof settings . toolbarCustomIcons [ name ] !== "function" ) { menuItem += settings . toolbarCustomIcons [ name ] ; } else { menuItem += "<a href=\"javascript:;\" title=\"" + title + "\" unselectable=\"on\">" ; menuItem += "<i class=\"fa " + iconClass + "\" name=\"" + name + "\" unselectable=\"on\">" + ( ( isHeader ) ? name . toUpperCase ( ) : ( ( iconClass === "" ) ? iconTexts : "" ) ) + "</i>" ; menuItem += "</a>" ; } menuItem += "</li>" ; menu = pullRight ? menuItem + menu : menu + menuItem ; } } toolbarMenu . html ( menu ) ; toolbarMenu . find ( "[title=\"Lowercase\"]" ) . attr ( "title" , settings . lang . toolbar . lowercase ) ; toolbarMenu . find ( "[title=\"ucwords\"]" ) . attr ( "title" , settings . lang . toolbar . ucwords ) ; this . setToolbarHandler ( ) ; this . setToolbarAutoFixed ( ) ; return this ; } 
function ( ) { var _this = this ; var settings = this . settings ; if ( ! settings . toolbar || settings . readOnly ) { return this ; } var toolbar = this . toolbar ; var cm = this . cm ; var classPrefix = this . classPrefix ; var toolbarIcons = this . toolbarIcons = toolbar . find ( "." + classPrefix + "menu > li > a" ) ; var toolbarIconHandlers = this . getToolbarHandles ( ) ; toolbarIcons . bind ( editormd . mouseOrTouch ( "click" , "touchend" ) , function ( event ) { var icon = $ ( this ) . children ( ".fa" ) ; var name = icon . attr ( "name" ) ; var cursor = cm . getCursor ( ) ; var selection = cm . getSelection ( ) ; if ( name === "" ) { return ; } _this . activeIcon = icon ; if ( typeof toolbarIconHandlers [ name ] !== "undefined" ) { $ . proxy ( toolbarIconHandlers [ name ] , _this ) ( cm ) ; } else { if ( typeof settings . toolbarHandlers [ name ] !== "undefined" ) { $ . proxy ( settings . toolbarHandlers [ name ] , _this ) ( cm , icon , cursor , selection ) ; } } if ( name !== "link" && name !== "reference-link" && name !== "image" && name !== "code-block" && name !== "preformatted-text" && name !== "watch" && name !== "preview" && name !== "search" && name !== "fullscreen" && name !== "info" ) { cm . focus ( ) ; } return false ; } ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var classPrefix = this . classPrefix ; var infoDialogHTML = [ "<div class=\"" + classPrefix + "dialog " + classPrefix + "dialog-info\" style=\"\">" , "<div class=\"" + classPrefix + "dialog-container\">" , "<h1><i class=\"editormd-logo editormd-logo-lg editormd-logo-color\"></i> " + editormd . title + "<small>v" + editormd . version + "</small></h1>" , "<p>" + this . lang . description + "</p>" , "<p style=\"margin: 10px 0 20px 0;\"><a href=\"" + editormd . homePage + "\" target=\"_blank\">" + editormd . homePage + " <i class=\"fa fa-external-link\"></i></a></p>" , "<p style=\"font-size: 0.85em;\">Copyright &copy; 2015 <a href=\"https: 
function ( ) { var infoDialog = this . infoDialog ; var _infoDialogPosition = function ( ) { infoDialog . css ( { top : ( $ ( window ) . height ( ) - infoDialog . height ( ) ) / 2 + "px" , left : ( $ ( window ) . width ( ) - infoDialog . width ( ) ) / 2 + "px" } ) ; } ; _infoDialogPosition ( ) ; $ ( window ) . resize ( _infoDialogPosition ) ; return this ; } 
function ( ) { $ ( "html,body" ) . css ( "overflow-x" , "hidden" ) ; var _this = this ; var editor = this . editor ; var settings = this . settings ; var infoDialog = this . infoDialog = editor . children ( "." + this . classPrefix + "dialog-info" ) ; if ( infoDialog . length < 1 ) { this . createInfoDialog ( ) ; } this . lockScreen ( true ) ; this . mask . css ( { opacity : settings . dialogMaskOpacity , backgroundColor : settings . dialogMaskBgColor } ) . show ( ) ; infoDialog . css ( "z-index" , editormd . dialogZindex ) . show ( ) ; this . infoDialogPosition ( ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var settings = this . settings ; this . codeMirror . remove ( ) ; this . setCodeMirror ( ) ; if ( ! settings . readOnly ) { if ( editor . find ( ".editormd-dialog" ) . length > 0 ) { editor . find ( ".editormd-dialog" ) . remove ( ) ; } if ( settings . toolbar ) { this . getToolbarHandles ( ) ; this . setToolbar ( ) ; } } this . loadedDisplay ( true ) ; return this ; } 
function ( ) { var settings = this . settings ; var previewContainer = this . previewContainer ; if ( settings . previewCodeHighlight ) { previewContainer . find ( "pre" ) . addClass ( "prettyprint linenums" ) ; if ( typeof prettyPrint !== "undefined" ) { prettyPrint ( ) ; } } return this ; } 
function ( ) { if ( timer === null ) { return this ; } this . previewContainer . find ( "." + editormd . classNames . tex ) . each ( function ( ) { var tex = $ ( this ) ; editormd . $katex . render ( tex . text ( ) , tex [ 0 ] ) ; tex . find ( ".katex" ) . css ( "font-size" , "1.6em" ) ; } ) ; return this ; } 
function ( ) { var $this = this ; var settings = this . settings ; var previewContainer = this . previewContainer ; if ( editormd . isIE8 ) { return this ; } if ( settings . flowChart ) { if ( flowchartTimer === null ) { return this ; } previewContainer . find ( ".flowchart" ) . flowChart ( ) ; } if ( settings . sequenceDiagram ) { previewContainer . find ( ".sequence-diagram" ) . sequenceDiagram ( { theme : "simple" } ) ; } var preview = $this . preview ; var codeMirror = $this . codeMirror ; var codeView = codeMirror . find ( ".CodeMirror-scroll" ) ; var height = codeView . height ( ) ; var scrollTop = codeView . scrollTop ( ) ; var percent = ( scrollTop / codeView [ 0 ] . scrollHeight ) ; var tocHeight = 0 ; preview . find ( ".markdown-toc-list" ) . each ( function ( ) { tocHeight += $ ( this ) . height ( ) ; } ) ; var tocMenuHeight = preview . find ( ".editormd-toc-menu" ) . height ( ) ; tocMenuHeight = ( ! tocMenuHeight ) ? 0 : tocMenuHeight ; if ( scrollTop === 0 ) { preview . scrollTop ( 0 ) ; } else if ( scrollTop + height >= codeView [ 0 ] . scrollHeight - 16 ) { preview . scrollTop ( preview [ 0 ] . scrollHeight ) ; } else { preview . scrollTop ( ( preview [ 0 ] . scrollHeight + tocHeight + tocMenuHeight ) * percent ) ; } return this ; } 
function ( keyMap ) { var _this = this ; var cm = this . cm ; var settings = this . settings ; var toolbarHandlers = editormd . toolbarHandlers ; var disabledKeyMaps = settings . disabledKeyMaps ; keyMap = keyMap || null ; if ( keyMap ) { for ( var i in keyMap ) { if ( $ . inArray ( i , disabledKeyMaps ) < 0 ) { var map = { } ; map [ i ] = keyMap [ i ] ; cm . addKeyMap ( keyMap ) ; } } } else { for ( var k in editormd . keyMaps ) { var _keyMap = editormd . keyMaps [ k ] ; var handle = ( typeof _keyMap === "string" ) ? $ . proxy ( toolbarHandlers [ _keyMap ] , _this ) : $ . proxy ( _keyMap , _this ) ; if ( $ . inArray ( k , [ "F9" , "F10" , "F11" ] ) < 0 && $ . inArray ( k , disabledKeyMaps ) < 0 ) { var _map = { } ; _map [ k ] = handle ; cm . addKeyMap ( _map ) ; } } $ ( window ) . keydown ( function ( event ) { var keymaps = { "120" : "F9" , "121" : "F10" , "122" : "F11" } ; if ( $ . inArray ( keymaps [ event . keyCode ] , disabledKeyMaps ) < 0 ) { switch ( event . keyCode ) { case 120 : $ . proxy ( toolbarHandlers [ "watch" ] , _this ) ( ) ; return false ; break ; case 121 : $ . proxy ( toolbarHandlers [ "preview" ] , _this ) ( ) ; return false ; break ; case 122 : $ . proxy ( toolbarHandlers [ "fullscreen" ] , _this ) ( ) ; return false ; break ; default : break ; } } } ) ; } return this ; } 
function ( ) { var _this = this ; var preview = this . preview ; var settings = this . settings ; var codeMirror = this . codeMirror ; var mouseOrTouch = editormd . mouseOrTouch ; if ( ! settings . syncScrolling ) { return this ; } var cmBindScroll = function ( ) { codeMirror . find ( ".CodeMirror-scroll" ) . bind ( mouseOrTouch ( "scroll" , "touchmove" ) , function ( event ) { var height = $ ( this ) . height ( ) ; var scrollTop = $ ( this ) . scrollTop ( ) ; var percent = ( scrollTop / $ ( this ) [ 0 ] . scrollHeight ) ; var tocHeight = 0 ; preview . find ( ".markdown-toc-list" ) . each ( function ( ) { tocHeight += $ ( this ) . height ( ) ; } ) ; var tocMenuHeight = preview . find ( ".editormd-toc-menu" ) . height ( ) ; tocMenuHeight = ( ! tocMenuHeight ) ? 0 : tocMenuHeight ; if ( scrollTop === 0 ) { preview . scrollTop ( 0 ) ; } else if ( scrollTop + height >= $ ( this ) [ 0 ] . scrollHeight - 16 ) { preview . scrollTop ( preview [ 0 ] . scrollHeight ) ; } else { preview . scrollTop ( ( preview [ 0 ] . scrollHeight + tocHeight + tocMenuHeight ) * percent ) ; } $ . proxy ( settings . onscroll , _this ) ( event ) ; } ) ; } ; var cmUnbindScroll = function ( ) { codeMirror . find ( ".CodeMirror-scroll" ) . unbind ( mouseOrTouch ( "scroll" , "touchmove" ) ) ; } ; var previewBindScroll = function ( ) { preview . bind ( mouseOrTouch ( "scroll" , "touchmove" ) , function ( event ) { var height = $ ( this ) . height ( ) ; var scrollTop = $ ( this ) . scrollTop ( ) ; var percent = ( scrollTop / $ ( this ) [ 0 ] . scrollHeight ) ; var codeView = codeMirror . find ( ".CodeMirror-scroll" ) ; if ( scrollTop === 0 ) { codeView . scrollTop ( 0 ) ; } else if ( scrollTop + height >= $ ( this ) [ 0 ] . scrollHeight ) { codeView . scrollTop ( codeView [ 0 ] . scrollHeight ) ; } else { codeView . scrollTop ( codeView [ 0 ] . scrollHeight * percent ) ; } $ . proxy ( settings . onpreviewscroll , _this ) ( event ) ; } ) ; } ; var previewUnbindScroll = function ( ) { preview . unbind ( mouseOrTouch ( "scroll" , "touchmove" ) ) ; } ; codeMirror . bind ( { mouseover : cmBindScroll , mouseout : cmUnbindScroll , touchstart : cmBindScroll , touchend : cmUnbindScroll } ) ; if ( settings . syncScrolling === "single" ) { return this ; } preview . bind ( { mouseover : previewBindScroll , mouseout : previewUnbindScroll , touchstart : previewBindScroll , touchend : previewUnbindScroll } ) ; return this ; } 
function ( recreate ) { recreate = recreate || false ; var _this = this ; var editor = this . editor ; var preview = this . preview ; var settings = this . settings ; this . containerMask . hide ( ) ; this . save ( ) ; if ( settings . watch ) { preview . show ( ) ; } editor . data ( "oldWidth" , editor . width ( ) ) . data ( "oldHeight" , editor . height ( ) ) ; // Zepto this . resize ( ) ; this . registerKeyMaps ( ) ; $ ( window ) . resize ( function ( ) { _this . resize ( ) ; } ) ; this . bindScrollEvent ( ) . bindChangeEvent ( ) ; if ( ! recreate ) { $ . proxy ( settings . onload , this ) ( ) ; } this . state . loaded = true ; return this ; } 
function ( width , height ) { width = width || null ; height = height || null ; var state = this . state ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var codeMirror = this . codeMirror ; if ( width ) { editor . css ( "width" , ( typeof width === "number" ) ? width + "px" : width ) ; } if ( settings . autoHeight && ! state . fullscreen && ! state . preview ) { editor . css ( "height" , "auto" ) ; codeMirror . css ( "height" , "auto" ) ; } else { if ( height ) { editor . css ( "height" , ( typeof height === "number" ) ? height + "px" : height ) ; } if ( state . fullscreen ) { editor . height ( $ ( window ) . height ( ) ) ; } if ( settings . toolbar && ! settings . readOnly ) { codeMirror . css ( "margin-top" , toolbar . height ( ) + 1 ) . height ( editor . height ( ) - toolbar . height ( ) ) ; } else { codeMirror . css ( "margin-top" , 0 ) . height ( editor . height ( ) ) ; } } if ( settings . watch ) { codeMirror . width ( editor . width ( ) / 2 ) ; preview . width ( ( ! state . preview ) ? editor . width ( ) / 2 : editor . width ( ) ) ; this . previewContainer . css ( "padding" , settings . autoHeight ? "20px 20px 50px 40px" : "20px" ) ; if ( settings . toolbar && ! settings . readOnly ) { preview . css ( "top" , toolbar . height ( ) + 1 ) ; } else { preview . css ( "top" , 0 ) ; } if ( settings . autoHeight && ! state . fullscreen && ! state . preview ) { preview . height ( "" ) ; } else { var previewHeight = ( settings . toolbar && ! settings . readOnly ) ? editor . height ( ) - toolbar . height ( ) : editor . height ( ) ; preview . height ( previewHeight ) ; } } else { codeMirror . width ( editor . width ( ) ) ; preview . hide ( ) ; } if ( state . loaded ) { $ . proxy ( settings . onresize , this ) ( ) ; } return this ; } 
function ( ) { if ( timer === null ) { return this ; } var _this = this ; var state = this . state ; var settings = this . settings ; var cm = this . cm ; var cmValue = cm . getValue ( ) ; var previewContainer = this . previewContainer ; if ( settings . mode !== "gfm" && settings . mode !== "markdown" ) { this . markdownTextarea . val ( cmValue ) ; return this ; } var marked = editormd . $marked ; var markdownToC = this . markdownToC = [ ] ; var rendererOptions = this . markedRendererOptions = { toc : settings . toc , tocm : settings . tocm , tocStartLevel : settings . tocStartLevel , pageBreak : settings . pageBreak , taskList : settings . taskList , emoji : settings . emoji , tex : settings . tex , atLink : settings . atLink , // for @link emailLink : settings . emailLink , // for mail address auto link flowChart : settings . flowChart , sequenceDiagram : settings . sequenceDiagram , previewCodeHighlight : settings . previewCodeHighlight , } ; var markedOptions = this . markedOptions = { renderer : editormd . markedRenderer ( markdownToC , rendererOptions ) , gfm : true , tables : true , breaks : true , pedantic : false , sanitize : ( settings . htmlDecode ) ? false : true , // HTMLHTMLfalse smartLists : true , smartypants : true } ; marked . setOptions ( markedOptions ) ; var newMarkdownDoc = editormd . $marked ( cmValue , markedOptions ) ; //console.info("cmValue", cmValue, newMarkdownDoc); newMarkdownDoc = editormd . filterHTMLTags ( newMarkdownDoc , settings . htmlDecode ) ; //console.error("cmValue", cmValue, newMarkdownDoc); this . markdownTextarea . text ( cmValue ) ; cm . save ( ) ; if ( settings . saveHTMLToTextarea ) { this . htmlTextarea . text ( newMarkdownDoc ) ; } if ( settings . watch || ( ! settings . watch && state . preview ) ) { previewContainer . html ( newMarkdownDoc ) ; this . previewCodeHighlight ( ) ; if ( settings . toc ) { var tocContainer = ( settings . tocContainer === "" ) ? previewContainer : $ ( settings . tocContainer ) ; var tocMenu = tocContainer . find ( "." + this . classPrefix + "toc-menu" ) ; tocContainer . attr ( "previewContainer" , ( settings . tocContainer === "" ) ? "true" : "false" ) ; if ( settings . tocContainer !== "" && tocMenu . length > 0 ) { tocMenu . remove ( ) ; } editormd . markdownToCRenderer ( markdownToC , tocContainer , settings . tocDropdown , settings . tocStartLevel ) ; if ( settings . tocDropdown || tocContainer . find ( "." + this . classPrefix + "toc-menu" ) . length > 0 ) { editormd . tocDropdownMenu ( tocContainer , ( settings . tocTitle !== "" ) ? settings . tocTitle : this . lang . tocTitle ) ; } if ( settings . tocContainer !== "" ) { previewContainer . find ( ".markdown-toc" ) . css ( "border" , "none" ) ; } } if ( settings . tex ) { if ( ! editormd . kaTeXLoaded && settings . autoLoadModules ) { editormd . loadKaTeX ( function ( ) { editormd . $katex = katex ; editormd . kaTeXLoaded = true ; _this . katexRender ( ) ; } ) ; } else { editormd . $katex = katex ; this . katexRender ( ) ; } } if ( settings . flowChart || settings . sequenceDiagram ) { flowchartTimer = setTimeout ( function ( ) { clearTimeout ( flowchartTimer ) ; _this . flowChartAndSequenceDiagramRender ( ) ; flowchartTimer = null ; } , 10 ) ; } if ( state . loaded ) { $ . proxy ( settings . onchange , this ) ( ) ; } } return this ; } 
function ( md ) { var settings = this . settings ; var cm = this . cm ; cm . setValue ( cm . getValue ( ) + md ) ; return this ; } 
function ( callback ) { var settings = this . settings ; if ( $ . inArray ( settings . mode , [ "gfm" , "markdown" ] ) < 0 ) { return this ; } this . state . watching = settings . watch = true ; this . preview . show ( ) ; if ( this . toolbar ) { var watchIcon = settings . toolbarIconsClass . watch ; var unWatchIcon = settings . toolbarIconsClass . unwatch ; var icon = this . toolbar . find ( ".fa[name=watch]" ) ; icon . parent ( ) . attr ( "title" , settings . lang . toolbar . watch ) ; icon . removeClass ( unWatchIcon ) . addClass ( watchIcon ) ; } this . codeMirror . css ( "border-right" , "1px solid #ddd" ) . width ( this . editor . width ( ) / 2 ) ; timer = 0 ; this . save ( ) . resize ( ) ; if ( ! settings . onwatch ) { settings . onwatch = callback || function ( ) { } ; } $ . proxy ( settings . onwatch , this ) ( ) ; return this ; } 
function ( callback ) { var settings = this . settings ; this . state . watching = settings . watch = false ; this . preview . hide ( ) ; if ( this . toolbar ) { var watchIcon = settings . toolbarIconsClass . watch ; var unWatchIcon = settings . toolbarIconsClass . unwatch ; var icon = this . toolbar . find ( ".fa[name=watch]" ) ; icon . parent ( ) . attr ( "title" , settings . lang . toolbar . unwatch ) ; icon . removeClass ( watchIcon ) . addClass ( unWatchIcon ) ; } this . codeMirror . css ( "border-right" , "none" ) . width ( this . editor . width ( ) ) ; this . resize ( ) ; if ( ! settings . onunwatch ) { settings . onunwatch = callback || function ( ) { } ; } $ . proxy ( settings . onunwatch , this ) ( ) ; return this ; } 
function ( ) { var _this = this ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var codeMirror = this . codeMirror ; var previewContainer = this . previewContainer ; if ( $ . inArray ( settings . mode , [ "gfm" , "markdown" ] ) < 0 ) { return this ; } if ( settings . toolbar && toolbar ) { toolbar . toggle ( ) ; toolbar . find ( ".fa[name=preview]" ) . toggleClass ( "active" ) ; } codeMirror . toggle ( ) ; var escHandle = function ( event ) { if ( event . shiftKey && event . keyCode === 27 ) { _this . previewed ( ) ; } } ; if ( codeMirror . css ( "display" ) === "none" ) // ZeptocodeMirror.is(":hidden") { this . state . preview = true ; if ( this . state . fullscreen ) { preview . css ( "background" , "#fff" ) ; } editor . find ( "." + this . classPrefix + "preview-close-btn" ) . show ( ) . bind ( editormd . mouseOrTouch ( "click" , "touchend" ) , function ( ) { _this . previewed ( ) ; } ) ; if ( ! settings . watch ) { this . save ( ) ; } else { previewContainer . css ( "padding" , "" ) ; } previewContainer . addClass ( this . classPrefix + "preview-active" ) ; preview . show ( ) . css ( { position : "" , top : 0 , width : editor . width ( ) , height : ( settings . autoHeight && ! this . state . fullscreen ) ? "auto" : editor . height ( ) } ) ; if ( this . state . loaded ) { $ . proxy ( settings . onpreviewing , this ) ( ) ; } $ ( window ) . bind ( "keyup" , escHandle ) ; } else { $ ( window ) . unbind ( "keyup" , escHandle ) ; this . previewed ( ) ; } } 
function ( ) { var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var previewContainer = this . previewContainer ; var previewCloseBtn = editor . find ( "." + this . classPrefix + "preview-close-btn" ) ; this . state . preview = false ; this . codeMirror . show ( ) ; if ( settings . toolbar ) { toolbar . show ( ) ; } preview [ ( settings . watch ) ? "show" : "hide" ] ( ) ; previewCloseBtn . hide ( ) . unbind ( editormd . mouseOrTouch ( "click" , "touchend" ) ) ; previewContainer . removeClass ( this . classPrefix + "preview-active" ) ; if ( settings . watch ) { previewContainer . css ( "padding" , "20px" ) ; } preview . css ( { background : null , position : "absolute" , width : editor . width ( ) / 2 , height : ( settings . autoHeight && ! this . state . fullscreen ) ? "auto" : editor . height ( ) - toolbar . height ( ) , top : ( settings . toolbar ) ? toolbar . height ( ) : 0 } ) ; if ( this . state . loaded ) { $ . proxy ( settings . onpreviewed , this ) ( ) ; } return this ; } 
function ( ) { var _this = this ; var state = this . state ; var editor = this . editor ; var preview = this . preview ; var toolbar = this . toolbar ; var settings = this . settings ; var fullscreenClass = this . classPrefix + "fullscreen" ; if ( toolbar ) { toolbar . find ( ".fa[name=fullscreen]" ) . parent ( ) . toggleClass ( "active" ) ; } var escHandle = function ( event ) { if ( ! event . shiftKey && event . keyCode === 27 ) { if ( state . fullscreen ) { _this . fullscreenExit ( ) ; } } } ; if ( ! editor . hasClass ( fullscreenClass ) ) { state . fullscreen = true ; $ ( "html,body" ) . css ( "overflow" , "hidden" ) ; editor . css ( { width : $ ( window ) . width ( ) , height : $ ( window ) . height ( ) } ) . addClass ( fullscreenClass ) ; this . resize ( ) ; $ . proxy ( settings . onfullscreen , this ) ( ) ; $ ( window ) . bind ( "keyup" , escHandle ) ; } else { $ ( window ) . unbind ( "keyup" , escHandle ) ; this . fullscreenExit ( ) ; } return this ; } 
function ( ) { var editor = this . editor ; var settings = this . settings ; var toolbar = this . toolbar ; var fullscreenClass = this . classPrefix + "fullscreen" ; this . state . fullscreen = false ; if ( toolbar ) { toolbar . find ( ".fa[name=fullscreen]" ) . parent ( ) . removeClass ( "active" ) ; } $ ( "html,body" ) . css ( "overflow" , "" ) ; editor . css ( { width : editor . data ( "oldWidth" ) , height : editor . data ( "oldHeight" ) } ) . removeClass ( fullscreenClass ) ; this . resize ( ) ; $ . proxy ( settings . onfullscreenExit , this ) ( ) ; return this ; } 
function ( name , path ) { var _this = this ; var cm = this . cm ; var settings = this . settings ; path = settings . pluginPath + path ; if ( typeof define === "function" ) { if ( typeof this [ name ] === "undefined" ) { alert ( "Error: " + name + " plugin is not found, you are not load this plugin." ) ; return this ; } this [ name ] ( cm ) ; return this ; } if ( $ . inArray ( path , editormd . loadFiles . plugin ) < 0 ) { editormd . loadPlugin ( path , function ( ) { editormd . loadPlugins [ name ] = _this [ name ] ; _this [ name ] ( cm ) ; } ) ; } else { $ . proxy ( editormd . loadPlugins [ name ] , this ) ( cm ) ; } return this ; } 
function ( command ) { var settings = this . settings ; if ( ! settings . searchReplace ) { alert ( "Error: settings.searchReplace == false" ) ; return this ; } if ( ! settings . readOnly ) { this . cm . execCommand ( command || "find" ) ; } return this ; } 
function kw ( name , options = { } ) { options . keyword = name return keywords [ name ] = new TokenType ( name , options ) } 
function isInAstralSet ( code , set ) { let pos = 0x10000 for ( let i = 0 ; i < set . length ; i += 2 ) { pos += set [ i ] if ( pos > code ) return false pos += set [ i + 1 ] if ( pos >= code ) return true } } 
function transformMetadata ( metadata ) { const namesRegEx = new RegExp ( metadata . tokens . map ( token => token . name ) . join ( '|' ) , 'g' ) ; const replaceMap = { } ; metadata . tokens . map ( token => { replaceMap [ token . name ] = formatTokenName ( token . name ) ; } ) ; metadata . tokens . forEach ( ( token , i ) => { 
async function findPackageFor ( filepath ) { let directory = filepath ; while ( directory !== '/' ) { const directoryToSearch = path . dirname ( directory ) ; const files = await fs . readdir ( directoryToSearch ) ; if ( files . indexOf ( 'package.json' ) !== - 1 ) { const packageJson = await fs . readJson ( path . join ( directoryToSearch , 'package.json' ) ) ; return packageJson . name ; } directory = path . resolve ( directory , '..' ) ; } throw new Error ( ` ${ filepath } ` ) ; } 
function svgToggleClass ( svg , name , forceAdd ) { const list = svg . getAttribute ( 'class' ) . trim ( ) . split ( / \s+ / ) ; const uniqueList = Object . keys ( list . reduce ( ( o , item ) => Object . assign ( o , { [ item ] : 1 } ) , { } ) ) ; const index = uniqueList . indexOf ( name ) ; const found = index >= 0 ; const add = forceAdd === undefined ? ! found : forceAdd ; if ( found === ! add ) { if ( add ) { uniqueList . push ( name ) ; } else { uniqueList . splice ( index , 1 ) ; } svg . setAttribute ( 'class' , uniqueList . join ( ' ' ) ) ; } } 
function cleanArgs ( command ) { return command . options . reduce ( ( acc , option ) => { 
async function flatMapAsync ( source , mapFn ) { const results = await Promise . all ( source . map ( mapFn ) ) ; return results . reduce ( ( acc , result ) => acc . concat ( result ) , [ ] ) ; } 
async function createJson ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { return data ; } , err => { console . error ( err ) ; } ) ; } 
function dedupeArray ( arr ) { return arr . reduce ( ( p , item ) => { const type = item . type || item . context . type ; const name = item . name || item . context . name ; const id = [ type , name ] . join ( '|' ) ; if ( p . temp . indexOf ( id ) === - 1 ) { p . out . push ( item ) ; p . temp . push ( id ) ; } return p ; } , { temp : [ ] , out : [ ] } ) . out ; } 
function createAnchorLink ( name , heading ) { const anchorLink = heading . toLowerCase ( ) . replace ( / / g , '-' ) . replace ( / [`~!@#$%^&*()+=<>?,./:;"'|{}\[\]\\]/g, ' ' ) . replace ( / [ ]/g, '' ) ; return ` ${ name } ${ anchorLink } ` ; } 
function createMarkdownItem ( item ) { let str = '' ; if ( ! item . context ) return '' ; let status = item . access === 'public' ? '' : ' '; if ( item . deprecated || item . deprecated === '' ) { status += ''; } 
async function createMarkdown ( sourceDir , config ) { config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { let markdownFile = '' ; const documentedItems = data . filter ( ( item , index ) => item . access === 'public' || item . access === 'private' ) ; markdownFile += ` ` ; let currentGroup = '' ; documentedItems . forEach ( item => { const itemGroup = createGroupName ( item . group ) ; if ( itemGroup !== currentGroup ) { markdownFile += ` \n \n ${ itemGroup } ` ; currentGroup = itemGroup ; } markdownFile += createMarkdownItem ( item ) ; } ) ; return prettier . format ( toc . insert ( markdownFile , { slugify } ) , prettierOptions ) ; } , err => { console . error ( err ) ; } ) ; } 
async function main ( ) { reporter . info ( 'Building examples...' ) ; await fs . remove ( BUILD_DIR ) ; await fs . ensureDir ( BUILD_DIR ) ; const packageNames = await fs . readdir ( PACKAGES_DIR ) ; const packages = await Promise . all ( packageNames . map ( async name => { 
function flattenOptions ( options ) { const o = { } ; 
function append ( str , prefix = '' ) { const item = document . createElement ( 'li' ) ; item . textContent = prefix + str ; list . appendChild ( item ) ; } 
function multiresNodeSort ( a , b ) { 
function multiresNodeRenderSort ( a , b ) { 
function multiresDraw ( ) { if ( ! program . drawInProgress ) { program . drawInProgress = true ; gl . clear ( gl . COLOR_BUFFER_BIT ) ; for ( var i = 0 ; i < program . currentNodes . length ; i ++ ) { if ( program . currentNodes [ i ] . textureLoaded > 1 ) { 
function MultiresNode ( vertices , side , level , x , y , path ) { this . vertices = vertices ; this . side = side ; this . level = level ; this . x = x ; this . y = y ; this . path = path . replace ( '%s' , side ) . replace ( '%l' , level ) . replace ( '%x' , x ) . replace ( '%y' , y ) ; } 
function rotateMatrix ( m , angle , axis ) { var s = Math . sin ( angle ) ; var c = Math . cos ( angle ) ; if ( axis == 'x' ) { return [ m [ 0 ] , c * m [ 1 ] + s * m [ 2 ] , c * m [ 2 ] - s * m [ 1 ] , m [ 3 ] , c * m [ 4 ] + s * m [ 5 ] , c * m [ 5 ] - s * m [ 4 ] , m [ 6 ] , c * m [ 7 ] + s * m [ 8 ] , c * m [ 8 ] - s * m [ 7 ] ] ; } if ( axis == 'y' ) { return [ c * m [ 0 ] - s * m [ 2 ] , m [ 1 ] , c * m [ 2 ] + s * m [ 0 ] , c * m [ 3 ] - s * m [ 5 ] , m [ 4 ] , c * m [ 5 ] + s * m [ 3 ] , c * m [ 6 ] - s * m [ 8 ] , m [ 7 ] , c * m [ 8 ] + s * m [ 6 ] ] ; } if ( axis == 'z' ) { return [ c * m [ 0 ] + s * m [ 1 ] , c * m [ 1 ] - s * m [ 0 ] , m [ 2 ] , c * m [ 3 ] + s * m [ 4 ] , c * m [ 4 ] - s * m [ 3 ] , m [ 5 ] , c * m [ 6 ] + s * m [ 7 ] , c * m [ 7 ] - s * m [ 6 ] , m [ 8 ] ] ; } } 
function makeMatrix4 ( m ) { return [ m [ 0 ] , m [ 1 ] , m [ 2 ] , 0 , m [ 3 ] , m [ 4 ] , m [ 5 ] , 0 , m [ 6 ] , m [ 7 ] , m [ 8 ] , 0 , 0 , 0 , 0 , 1 ] ; } 
function makePersp ( hfov , aspect , znear , zfar ) { var fovy = 2 * Math . atan ( Math . tan ( hfov / 2 ) * gl . drawingBufferHeight / gl . drawingBufferWidth ) ; var f = 1 / Math . tan ( fovy / 2 ) ; return [ f / aspect , 0 , 0 , 0 , 0 , f , 0 , 0 , 0 , 0 , ( zfar + znear ) / ( znear - zfar ) , ( 2 * zfar * znear ) / ( znear - zfar ) , 0 , 0 , - 1 , 0 ] ; } 
function processLoadedTexture ( img , tex ) { gl . bindTexture ( gl . TEXTURE_2D , tex ) ; gl . texImage2D ( gl . TEXTURE_2D , 0 , gl . RGB , gl . RGB , gl . UNSIGNED_BYTE , img ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MAG_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_MIN_FILTER , gl . LINEAR ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_S , gl . CLAMP_TO_EDGE ) ; gl . texParameteri ( gl . TEXTURE_2D , gl . TEXTURE_WRAP_T , gl . CLAMP_TO_EDGE ) ; gl . bindTexture ( gl . TEXTURE_2D , null ) ; } 
function processNextTile ( node ) { loadTexture ( node , encodeURI ( node . path + '.' + image . extension ) , function ( texture , loaded ) { node . texture = texture ; node . textureLoaded = loaded ? 2 : 1 ; } , globalParams . crossOrigin ) ; } 
function checkZoom ( hfov ) { 
function rotatePersp ( p , r ) { return [ p [ 0 ] * r [ 0 ] , p [ 0 ] * r [ 1 ] , p [ 0 ] * r [ 2 ] , 0 , p [ 5 ] * r [ 4 ] , p [ 5 ] * r [ 5 ] , p [ 5 ] * r [ 6 ] , 0 , p [ 10 ] * r [ 8 ] , p [ 10 ] * r [ 9 ] , p [ 10 ] * r [ 10 ] , p [ 11 ] , - r [ 8 ] , - r [ 9 ] , - r [ 10 ] , 0 ] ; } 
function applyRotPerspToVec ( m , v ) { return [ m [ 0 ] * v [ 0 ] + m [ 1 ] * v [ 1 ] + m [ 2 ] * v [ 2 ] , m [ 4 ] * v [ 0 ] + m [ 5 ] * v [ 1 ] + m [ 6 ] * v [ 2 ] , m [ 11 ] + m [ 8 ] * v [ 0 ] + m [ 9 ] * v [ 1 ] + m [ 10 ] * v [ 2 ] , 1 / ( m [ 12 ] * v [ 0 ] + m [ 13 ] * v [ 1 ] + m [ 14 ] * v [ 2 ] ) ] ; } 
function checkInView ( m , v ) { var vpp = applyRotPerspToVec ( m , v ) ; var winX = vpp [ 0 ] * vpp [ 3 ] ; var winY = vpp [ 1 ] * vpp [ 3 ] ; var winZ = vpp [ 2 ] * vpp [ 3 ] ; var ret = [ 0 , 0 , 0 ] ; if ( winX < - 1 ) ret [ 0 ] = - 1 ; if ( winX > 1 ) ret [ 0 ] = 1 ; if ( winY < - 1 ) ret [ 1 ] = - 1 ; if ( winY > 1 ) ret [ 1 ] = 1 ; if ( winZ < - 1 || winZ > 1 ) ret [ 2 ] = 1 ; return ret ; } 
function checkSquareInView ( m , v ) { var check1 = checkInView ( m , v . slice ( 0 , 3 ) ) ; var check2 = checkInView ( m , v . slice ( 3 , 6 ) ) ; var check3 = checkInView ( m , v . slice ( 6 , 9 ) ) ; var check4 = checkInView ( m , v . slice ( 9 , 12 ) ) ; var testX = check1 [ 0 ] + check2 [ 0 ] + check3 [ 0 ] + check4 [ 0 ] ; if ( testX == - 4 || testX == 4 ) return false ; var testY = check1 [ 1 ] + check2 [ 1 ] + check3 [ 1 ] + check4 [ 1 ] ; if ( testY == - 4 || testY == 4 ) return false ; var testZ = check1 [ 2 ] + check2 [ 2 ] + check3 [ 2 ] + check4 [ 2 ] ; return testZ != 4 ; } 
function handleWebGLError1286 ( ) { console . log ( 'Reducing canvas size due to error 1286!' ) ; canvas . width = Math . round ( canvas . width / 2 ) ; canvas . height = Math . round ( canvas . height / 2 ) ; } 
function init ( ) { 
function onImageLoad ( ) { if ( ! renderer ) renderer = new libpannellum . renderer ( renderContainer ) ; 
function ( tag ) { var result ; if ( xmpData . indexOf ( tag + '="' ) >= 0 ) { result = xmpData . substring ( xmpData . indexOf ( tag + '="' ) + tag . length + 2 ) ; result = result . substring ( 0 , result . indexOf ( '"' ) ) ; } else if ( xmpData . indexOf ( tag + '>' ) >= 0 ) { result = xmpData . substring ( xmpData . indexOf ( tag + '>' ) + tag . length + 1 ) ; result = result . substring ( 0 , result . indexOf ( '<' ) ) ; } if ( result !== undefined ) { return Number ( result ) ; } return null ; } 
function anError ( errorMsg ) { if ( errorMsg === undefined ) errorMsg = config . strings . genericWebGLError ; infoDisplay . errorMsg . innerHTML = '<p>' + errorMsg + '</p>' ; controls . load . style . display = 'none' ; infoDisplay . load . box . style . display = 'none' ; infoDisplay . errorMsg . style . display = 'table' ; error = true ; renderContainer . style . display = 'none' ; fireEvent ( 'error' , errorMsg ) ; } 
function clearError ( ) { if ( error ) { infoDisplay . load . box . style . display = 'none' ; infoDisplay . errorMsg . style . display = 'none' ; error = false ; fireEvent ( 'errorcleared' ) ; } } 
function aboutMessage ( event ) { var pos = mousePosition ( event ) ; aboutMsg . style . left = pos . x + 'px' ; aboutMsg . style . top = pos . y + 'px' ; clearTimeout ( aboutMessage . t1 ) ; clearTimeout ( aboutMessage . t2 ) ; aboutMsg . style . display = 'block' ; aboutMsg . style . opacity = 1 ; aboutMessage . t1 = setTimeout ( function ( ) { aboutMsg . style . opacity = 0 ; } , 2000 ) ; aboutMessage . t2 = setTimeout ( function ( ) { aboutMsg . style . display = 'none' ; } , 2500 ) ; event . preventDefault ( ) ; } 
function mousePosition ( event ) { var bounds = container . getBoundingClientRect ( ) ; var pos = { } ; 
function onDocumentMouseDown ( event ) { 
function onDocumentDoubleClick ( event ) { if ( config . minHfov === config . hfov ) { _this . setHfov ( origHfov , 1000 ) ; } else { var coords = mouseEventToCoords ( event ) ; _this . lookAt ( coords [ 0 ] , coords [ 1 ] , config . minHfov , 1000 ) ; } } 
function mouseEventToCoords ( event ) { var pos = mousePosition ( event ) ; var canvas = renderer . getCanvas ( ) ; var canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var x = pos . x / canvasWidth * 2 - 1 ; var y = ( 1 - pos . y / canvasHeight * 2 ) * canvasHeight / canvasWidth ; var focal = 1 / Math . tan ( config . hfov * Math . PI / 360 ) ; var s = Math . sin ( config . pitch * Math . PI / 180 ) ; var c = Math . cos ( config . pitch * Math . PI / 180 ) ; var a = focal * c - y * s ; var root = Math . sqrt ( x * x + a * a ) ; var pitch = Math . atan ( ( y * c + focal * s ) / root ) * 180 / Math . PI ; var yaw = Math . atan2 ( x / root , a / root ) * 180 / Math . PI + config . yaw ; if ( yaw < - 180 ) yaw += 360 ; if ( yaw > 180 ) yaw -= 360 ; return [ pitch , yaw ] ; } 
function onDocumentMouseMove ( event ) { if ( isUserInteracting && loaded ) { latestInteraction = Date . now ( ) ; var canvas = renderer . getCanvas ( ) ; var canvasWidth = canvas . clientWidth , canvasHeight = canvas . clientHeight ; var pos = mousePosition ( event ) ; 
function onDocumentMouseUp ( event ) { if ( ! isUserInteracting ) { return ; } isUserInteracting = false ; if ( Date . now ( ) - latestInteraction > 15 ) { 
function onDocumentTouchStart ( event ) { 
function onDocumentTouchMove ( event ) { if ( ! config . draggable ) { return ; } 
function onDocumentTouchEnd ( ) { isUserInteracting = false ; if ( Date . now ( ) - latestInteraction > 150 ) { speed . pitch = speed . yaw = 0 ; } onPointerDownPointerDist = - 1 ; latestInteraction = Date . now ( ) ; fireEvent ( 'touchend' , event ) ; } 
function onDocumentPointerDown ( event ) { if ( event . pointerType == 'touch' ) { pointerIDs . push ( event . pointerId ) ; pointerCoordinates . push ( { clientX : event . clientX , clientY : event . clientY } ) ; event . targetTouches = pointerCoordinates ; onDocumentTouchStart ( event ) ; event . preventDefault ( ) ; } } 
function onDocumentPointerMove ( event ) { if ( event . pointerType == 'touch' ) { for ( var i = 0 ; i < pointerIDs . length ; i ++ ) { if ( event . pointerId == pointerIDs [ i ] ) { pointerCoordinates [ i ] . clientX = event . clientX ; pointerCoordinates [ i ] . clientY = event . clientY ; event . targetTouches = pointerCoordinates ; onDocumentTouchMove ( event ) ; event . preventDefault ( ) ; return ; } } } } 
function onDocumentPointerUp ( event ) { if ( event . pointerType == 'touch' ) { var defined = false ; for ( var i = 0 ; i < pointerIDs . length ; i ++ ) { if ( event . pointerId == pointerIDs [ i ] ) pointerIDs [ i ] = undefined ; if ( pointerIDs [ i ] ) defined = true ; } if ( ! defined ) { pointerIDs = [ ] ; pointerCoordinates = [ ] ; onDocumentTouchEnd ( ) ; } event . preventDefault ( ) ; } } 
function onDocumentMouseWheel ( event ) { 
function onDocumentKeyPress ( event ) { 
function onDocumentKeyUp ( event ) { 
function changeKey ( keynumber , value ) { var keyChanged = false ; switch ( keynumber ) { 
function keyRepeat ( ) { 
function animateMove ( axis ) { var t = animatedMove [ axis ] ; var normTime = Math . min ( 1 , Math . max ( ( Date . now ( ) - t . startTime ) / 1000 / ( t . duration / 1000 ) , 0 ) ) ; var result = t . startPosition + config . animationTimingFunction ( normTime ) * ( t . endPosition - t . startPosition ) ; if ( ( t . endPosition > t . startPosition && result >= t . endPosition ) || ( t . endPosition < t . startPosition && result <= t . endPosition ) || t . endPosition === t . startPosition ) { result = t . endPosition ; speed [ axis ] = 0 ; delete animatedMove [ axis ] ; } config [ axis ] = result ; } 
function animate ( ) { render ( ) ; if ( autoRotateStart ) clearTimeout ( autoRotateStart ) ; if ( isUserInteracting || orientation === true ) { requestAnimationFrame ( animate ) ; } else if ( keysDown [ 0 ] || keysDown [ 1 ] || keysDown [ 2 ] || keysDown [ 3 ] || keysDown [ 4 ] || keysDown [ 5 ] || keysDown [ 6 ] || keysDown [ 7 ] || keysDown [ 8 ] || keysDown [ 9 ] || config . autoRotate || animatedMove . pitch || animatedMove . yaw || animatedMove . hfov || Math . abs ( speed . yaw ) > 0.01 || Math . abs ( speed . pitch ) > 0.01 || Math . abs ( speed . hfov ) > 0.01 ) { keyRepeat ( ) ; if ( config . autoRotateInactivityDelay >= 0 && autoRotateSpeed && Date . now ( ) - latestInteraction > config . autoRotateInactivityDelay && ! config . autoRotate ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; } requestAnimationFrame ( animate ) ; } else if ( renderer && ( renderer . isLoading ( ) || ( config . dynamic === true && update ) ) ) { requestAnimationFrame ( animate ) ; } else { fireEvent ( 'animatefinished' , { pitch : _this . getPitch ( ) , yaw : _this . getYaw ( ) , hfov : _this . getHfov ( ) } ) ; animating = false ; prevTime = undefined ; var autoRotateStartTime = config . autoRotateInactivityDelay - ( Date . now ( ) - latestInteraction ) ; if ( autoRotateStartTime > 0 ) { autoRotateStart = setTimeout ( function ( ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; animateInit ( ) ; } , autoRotateStartTime ) ; } else if ( config . autoRotateInactivityDelay >= 0 && autoRotateSpeed ) { config . autoRotate = autoRotateSpeed ; _this . lookAt ( origPitch , undefined , origHfov , 3000 ) ; animateInit ( ) ; } } } 
function render ( ) { var tmpyaw ; if ( loaded ) { 
function taitBryanToQuaternion ( alpha , beta , gamma ) { var r = [ beta ? beta * Math . PI / 180 / 2 : 0 , gamma ? gamma * Math . PI / 180 / 2 : 0 , alpha ? alpha * Math . PI / 180 / 2 : 0 ] ; var c = [ Math . cos ( r [ 0 ] ) , Math . cos ( r [ 1 ] ) , Math . cos ( r [ 2 ] ) ] , s = [ Math . sin ( r [ 0 ] ) , Math . sin ( r [ 1 ] ) , Math . sin ( r [ 2 ] ) ] ; return new Quaternion ( c [ 0 ] * c [ 1 ] * c [ 2 ] - s [ 0 ] * s [ 1 ] * s [ 2 ] , s [ 0 ] * c [ 1 ] * c [ 2 ] - c [ 0 ] * s [ 1 ] * s [ 2 ] , c [ 0 ] * s [ 1 ] * c [ 2 ] + s [ 0 ] * c [ 1 ] * s [ 2 ] , c [ 0 ] * c [ 1 ] * s [ 2 ] + s [ 0 ] * s [ 1 ] * c [ 2 ] ) ; } 
function computeQuaternion ( alpha , beta , gamma ) { 
function orientationListener ( e ) { var q = computeQuaternion ( e . alpha , e . beta , e . gamma ) . toEulerAngles ( ) ; if ( typeof ( orientation ) == 'number' && orientation < 10 ) { 
function renderInit ( ) { try { var params = { } ; if ( config . horizonPitch !== undefined ) params . horizonPitch = config . horizonPitch * Math . PI / 180 ; if ( config . horizonRoll !== undefined ) params . horizonRoll = config . horizonRoll * Math . PI / 180 ; if ( config . backgroundColor !== undefined ) params . backgroundColor = config . backgroundColor ; renderer . init ( panoImage , config . type , config . dynamic , config . haov * Math . PI / 180 , config . vaov * Math . PI / 180 , config . vOffset * Math . PI / 180 , renderInitCallback , params ) ; if ( config . dynamic !== true ) { 
function renderInitCallback ( ) { 
function createHotSpot ( hs ) { 
function createHotSpots ( ) { if ( hotspotsCreated ) return ; if ( ! config . hotSpots ) { config . hotSpots = [ ] ; } else { 
function destroyHotSpots ( ) { var hs = config . hotSpots ; hotspotsCreated = false ; delete config . hotSpots ; if ( hs ) { for ( var i = 0 ; i < hs . length ; i ++ ) { var current = hs [ i ] . div ; if ( current ) { while ( current . parentNode && current . parentNode != renderContainer ) { current = current . parentNode ; } renderContainer . removeChild ( current ) ; } delete hs [ i ] . div ; } } } 
function renderHotSpot ( hs ) { var hsPitchSin = Math . sin ( hs . pitch * Math . PI / 180 ) , hsPitchCos = Math . cos ( hs . pitch * Math . PI / 180 ) , configPitchSin = Math . sin ( config . pitch * Math . PI / 180 ) , configPitchCos = Math . cos ( config . pitch * Math . PI / 180 ) , yawCos = Math . cos ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) ; var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos ; if ( ( hs . yaw <= 90 && hs . yaw > - 90 && z <= 0 ) || ( ( hs . yaw > 90 || hs . yaw <= - 90 ) && z <= 0 ) ) { hs . div . style . visibility = 'hidden' ; } else { var yawSin = Math . sin ( ( - hs . yaw + config . yaw ) * Math . PI / 180 ) , hfovTan = Math . tan ( config . hfov * Math . PI / 360 ) ; hs . div . style . visibility = 'visible' ; 
function mergeConfig ( sceneId ) { config = { } ; var k , s ; var photoSphereExcludes = [ 'haov' , 'vaov' , 'vOffset' , 'northOffset' , 'horizonPitch' , 'horizonRoll' ] ; specifiedPhotoSphereExcludes = [ ] ; 
function processOptions ( isPreview ) { isPreview = isPreview ? isPreview : false ; 
function toggleFullscreen ( ) { if ( loaded && ! error ) { if ( ! fullscreenActive ) { try { if ( container . requestFullscreen ) { container . requestFullscreen ( ) ; } else if ( container . mozRequestFullScreen ) { container . mozRequestFullScreen ( ) ; } else if ( container . msRequestFullscreen ) { container . msRequestFullscreen ( ) ; } else { container . webkitRequestFullScreen ( ) ; } } catch ( event ) { 
function onFullScreenChange ( resize ) { if ( document . fullscreenElement || document . fullscreen || document . mozFullScreen || document . webkitIsFullScreen || document . msFullscreenElement ) { controls . fullscreen . classList . add ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = true ; } else { controls . fullscreen . classList . remove ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = false ; } if ( resize !== 'resize' ) fireEvent ( 'fullscreenchange' , fullscreenActive ) ; 
function constrainHfov ( hfov ) { 
function stopAnimation ( ) { animatedMove = { } ; autoRotateSpeed = config . autoRotate ? config . autoRotate : autoRotateSpeed ; config . autoRotate = false ; } 
function load ( ) { 
function loadScene ( sceneId , targetPitch , targetYaw , targetHfov , fadeDone ) { loaded = false ; animatedMove = { } ; 
function stopOrientation ( ) { window . removeEventListener ( 'deviceorientation' , orientationListener ) ; controls . orientation . classList . remove ( 'pnlm-orientation-button-active' ) ; orientation = false ; } 
function escapeHTML ( s ) { if ( ! initialConfig . escapeHTML ) return String ( s ) . split ( '\n' ) . join ( '<br>' ) ; return String ( s ) . split ( / & / g ) . join ( '&amp;' ) . split ( '"' ) . join ( '&quot;' ) . split ( "'" ) . join ( '&#39;' ) . split ( '<' ) . join ( '&lt;' ) . split ( '>' ) . join ( '&gt;' ) . split ( '/' ) . join ( '&#x2f;' ) . split ( '\n' ) . join ( '<br>' ) ; 
function fireEvent ( type ) { if ( type in externalEventListeners ) { 
function ( latchFunction , optional_timeoutMessage , optional_timeout ) { jasmine . getEnv ( ) . currentSpec . waitsFor . apply ( jasmine . getEnv ( ) . currentSpec , arguments ) ; } 
function OAuthError ( messageOrError , properties ) { var message = messageOrError instanceof Error ? messageOrError . message : messageOrError ; var error = messageOrError instanceof Error ? messageOrError : null ; if ( _ . isEmpty ( properties ) ) { properties = { } ; } _ . defaults ( properties , { code : 500 } ) ; if ( error ) { properties . inner = error ; } if ( _ . isEmpty ( message ) ) { message = statuses [ properties . code ] ; } this . code = this . status = this . statusCode = properties . code ; this . message = message ; for ( var key in properties ) { if ( key !== 'code' ) { this [ key ] = properties [ key ] ; } } Error . captureStackTrace ( this , OAuthError ) ; } 
function AuthorizationCodeGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getAuthorizationCode ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getAuthorizationCode()`' ) ; } if ( ! options . model . revokeAuthorizationCode ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `revokeAuthorizationCode()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; } 
function PasswordGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getUser ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getUser()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; } 
function TokenHandler ( options ) { options = options || { } ; if ( ! options . accessTokenLifetime ) { throw new InvalidArgumentError ( 'Missing parameter: `accessTokenLifetime`' ) ; } if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . refreshTokenLifetime ) { throw new InvalidArgumentError ( 'Missing parameter: `refreshTokenLifetime`' ) ; } if ( ! options . model . getClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getClient()`' ) ; } this . accessTokenLifetime = options . accessTokenLifetime ; this . grantTypes = _ . assign ( { } , grantTypes , options . extendedGrantTypes ) ; this . model = options . model ; this . refreshTokenLifetime = options . refreshTokenLifetime ; this . allowExtendedTokenAttributes = options . allowExtendedTokenAttributes ; this . requireClientAuthentication = options . requireClientAuthentication || { } ; this . alwaysIssueNewRefreshToken = options . alwaysIssueNewRefreshToken !== false ; } 
function AbstractGrantType ( options ) { options = options || { } ; if ( ! options . accessTokenLifetime ) { throw new InvalidArgumentError ( 'Missing parameter: `accessTokenLifetime`' ) ; } if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } this . accessTokenLifetime = options . accessTokenLifetime ; this . model = options . model ; this . refreshTokenLifetime = options . refreshTokenLifetime ; this . alwaysIssueNewRefreshToken = options . alwaysIssueNewRefreshToken ; } 
function AuthenticateHandler ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getAccessToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getAccessToken()`' ) ; } if ( options . scope && undefined === options . addAcceptedScopesHeader ) { throw new InvalidArgumentError ( 'Missing parameter: `addAcceptedScopesHeader`' ) ; } if ( options . scope && undefined === options . addAuthorizedScopesHeader ) { throw new InvalidArgumentError ( 'Missing parameter: `addAuthorizedScopesHeader`' ) ; } if ( options . scope && ! options . model . verifyScope ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `verifyScope()`' ) ; } this . addAcceptedScopesHeader = options . addAcceptedScopesHeader ; this . addAuthorizedScopesHeader = options . addAuthorizedScopesHeader ; this . allowBearerTokensInQueryString = options . allowBearerTokensInQueryString ; this . model = options . model ; this . scope = options . scope ; } 
function InvalidArgumentError ( message , properties ) { properties = _ . assign ( { code : 500 , name : 'invalid_argument' } , properties ) ; OAuthError . call ( this , message , properties ) ; } 
function RefreshTokenGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getRefreshToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getRefreshToken()`' ) ; } if ( ! options . model . revokeToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `revokeToken()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; } 
function Request ( options ) { options = options || { } ; if ( ! options . headers ) { throw new InvalidArgumentError ( 'Missing parameter: `headers`' ) ; } if ( ! options . method ) { throw new InvalidArgumentError ( 'Missing parameter: `method`' ) ; } if ( ! options . query ) { throw new InvalidArgumentError ( 'Missing parameter: `query`' ) ; } this . body = options . body || { } ; this . headers = { } ; this . method = options . method ; this . query = options . query ; 
function AuthorizeHandler ( options ) { options = options || { } ; if ( options . authenticateHandler && ! options . authenticateHandler . handle ) { throw new InvalidArgumentError ( 'Invalid argument: authenticateHandler does not implement `handle()`' ) ; } if ( ! options . authorizationCodeLifetime ) { throw new InvalidArgumentError ( 'Missing parameter: `authorizationCodeLifetime`' ) ; } if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getClient()`' ) ; } if ( ! options . model . saveAuthorizationCode ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveAuthorizationCode()`' ) ; } this . allowEmptyState = options . allowEmptyState ; this . authenticateHandler = options . authenticateHandler || new AuthenticateHandler ( options ) ; this . authorizationCodeLifetime = options . authorizationCodeLifetime ; this . model = options . model ; } 
function ClientCredentialsGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getUserFromClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getUserFromClient()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; } 
function BearerTokenType ( accessToken , accessTokenLifetime , refreshToken , scope , customAttributes ) { if ( ! accessToken ) { throw new InvalidArgumentError ( 'Missing parameter: `accessToken`' ) ; } this . accessToken = accessToken ; this . accessTokenLifetime = accessTokenLifetime ; this . refreshToken = refreshToken ; this . scope = scope ; if ( customAttributes ) { this . customAttributes = customAttributes ; } } 
function Response ( options ) { options = options || { } ; this . body = options . body || { } ; this . headers = { } ; this . status = 200 ; 
function import_hooks ( mod_name , _path , from_stdlib ) { var _meta_path = $B . meta_path . slice ( ) , _sys_modules = $B . imported , _loader , spec if ( from_stdlib == "static" ) { 
function $getMouseOffset ( target , ev ) { ev = ev || _window . event ; var docPos = $getPosition ( target ) ; var mousePos = $mouseCoords ( ev ) ; return { x : mousePos . x - docPos . x , y : mousePos . y - docPos . y } ; } 
function jscode_namespace ( iter_name , action , parent_id ) { var _clean = '' ; if ( action === 'store' ) { _clean = ' = {}' } var res = 'for(var attr in this.blocks){' + 'eval("var " + attr + " = this.blocks[attr]")' + '};' + 'var $locals_' + iter_name + ' = this.env' + _clean + ', ' + '$local_name = "' + iter_name + '", ' + '$locals = $locals_' + iter_name + ';' if ( parent_id ) { res += '$locals.$parent = $locals_' + parent_id . replace ( / \. / g , "_" ) + ';' } return res } 
function ( val , flags ) { number_check ( val ) if ( ! flags . precision ) { if ( ! flags . decimal_point ) { flags . precision = 6 } else { flags . precision = 0 } } else { flags . precision = parseInt ( flags . precision , 10 ) validate_precision ( flags . precision ) } return parseFloat ( val ) } 
function ( val , upper , flags ) { val = _float_helper ( val , flags ) , v = val . toString ( ) , v_len = v . length , dot_idx = v . indexOf ( '.' ) if ( dot_idx < 0 ) { dot_idx = v_len } if ( val < 1 && val > - 1 ) { var zeros = leading_zeros . exec ( v ) , numzeros if ( zeros ) { numzeros = zeros [ 1 ] . length } else { numzeros = 0 } if ( numzeros >= 4 ) { val = format_sign ( val , flags ) + format_float_precision ( val , upper , flags , _floating_g_exp_helper ) if ( ! flags . alternate ) { var trl = trailing_zeros . exec ( val ) if ( trl ) { val = trl [ 1 ] . replace ( trailing_dot , "" ) + trl [ 3 ] 
function ( val , upper , flags ) { val = _float_helper ( val , flags ) return format_padding ( format_sign ( val , flags ) + format_float_precision ( val , upper , flags , function ( val , precision , flags ) { val = val . toFixed ( precision ) if ( precision === 0 && flags . alternate ) { val += '.' } return val } ) , flags ) } 
function ( val , upper , flags ) { val = _float_helper ( val , flags ) return format_padding ( format_sign ( val , flags ) + format_float_precision ( val , upper , flags , _floating_exp_helper ) , flags ) } 
function replace_nested ( name , key ) { if ( / \d+ / . exec ( key ) ) { 
function ( self , other ) { if ( _b_ . isinstance ( other , int ) ) { if ( other . __class__ === $B . long_int ) { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } other = int_value ( other ) if ( self > $B . max_int32 || self < $B . min_int32 || other > $B . max_int32 || other < $B . min_int32 ) { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } return self - other } if ( _b_ . isinstance ( other , _b_ . bool ) ) { return self - other } var rsub = $B . $getattr ( other , "__rsub__" , _b_ . None ) if ( rsub !== _b_ . None ) { return rsub ( self ) } $err ( "-" , other ) } 
function ( self , other ) { if ( _b_ . isinstance ( other , int ) ) { other = int_value ( other ) if ( typeof other == "number" ) { var res = self . valueOf ( ) - other . valueOf ( ) if ( res > $B . min_int && res < $B . max_int ) { return res } else { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } } else if ( typeof other == "boolean" ) { return other ? self - 1 : self } else { return $B . long_int . __sub__ ( $B . long_int . $factory ( self ) , $B . long_int . $factory ( other ) ) } } if ( _b_ . isinstance ( other , _b_ . float ) ) { return new Number ( self - other ) } if ( _b_ . isinstance ( other , _b_ . complex ) ) { return $B . make_complex ( self - other . $real , - other . $imag ) } if ( _b_ . isinstance ( other , _b_ . bool ) ) { var bool_value = 0 ; if ( other . valueOf ( ) ) { bool_value = 1 } return self - bool_value } if ( _b_ . isinstance ( other , _b_ . complex ) ) { return $B . make_complex ( self . valueOf ( ) - other . $real , other . $imag ) } var rsub = $B . $getattr ( other , "__rsub__" , _b_ . None ) if ( rsub !== _b_ . None ) { return rsub ( self ) } throw $err ( "-" , other ) } 
function ( self , other ) { if ( other . __class__ === $B . long_int ) { return $B . long_int . __lt__ ( other , $B . long_int . $factory ( self ) ) } if ( _b_ . isinstance ( other , int ) ) { other = int_value ( other ) return self . valueOf ( ) > other . valueOf ( ) } else if ( _b_ . isinstance ( other , _b_ . float ) ) { return self . valueOf ( ) > other . valueOf ( ) } else if ( _b_ . isinstance ( other , _b_ . bool ) ) { return self . valueOf ( ) > _b_ . bool . __hash__ ( other ) } if ( _b_ . hasattr ( other , "__int__" ) || _b_ . hasattr ( other , "__index__" ) ) { return int . __gt__ ( self , $B . $GetInt ( other ) ) } return _b_ . NotImplemented } 
function loop ( ) { if ( tasks . length == 0 ) { 
function ( self , other ) { if ( isinstance ( other , _b_ . int ) ) { if ( typeof other == "boolean" ) { return other ? self - 1 : self } else if ( other . __class__ === $B . long_int ) { return float . $factory ( self - parseInt ( other . value ) ) } else { return float . $factory ( self - other ) } } if ( isinstance ( other , float ) ) { return float . $factory ( self - other ) } if ( isinstance ( other , _b_ . bool ) ) { var bool_value = 0 if ( other . valueOf ( ) ) { bool_value = 1 } return float . $factory ( self - bool_value ) } if ( isinstance ( other , _b_ . complex ) ) { return $B . make_complex ( self - other . $real , - other . $imag ) } if ( hasattr ( other , "__rsub__" ) ) { return getattr ( other , "__rsub__" ) ( self ) } $err ( "-" , other ) } 
function ( self , other ) { if ( isinstance ( other , _b_ . int ) ) { if ( other . __class__ === $B . long_int ) { return self > parseInt ( other . value ) } return self > other . valueOf ( ) } if ( isinstance ( other , float ) ) { return self > other } if ( isinstance ( other , _b_ . bool ) ) { return self . valueOf ( ) > _b_ . bool . __hash__ ( other ) } if ( hasattr ( other , "__int__" ) || hasattr ( other , "__index__" ) ) { return _b_ . int . __gt__ ( self , $B . $GetInt ( other ) ) } 
function $$eval ( src , _globals , _locals ) { if ( _globals === undefined ) { _globals = _b_ . None } if ( _locals === undefined ) { _locals = _b_ . None } var current_frame = $B . frames_stack [ $B . frames_stack . length - 1 ] if ( current_frame !== undefined ) { var current_locals_id = current_frame [ 0 ] . replace ( / \. / , '_' ) , current_globals_id = current_frame [ 2 ] . replace ( / \. / , '_' ) } var stack_len = $B . frames_stack . length var is_exec = arguments [ 3 ] == 'exec' if ( src . __class__ === code ) { is_exec = src . mode == "exec" src = src . source } else if ( typeof src !== 'string' ) { throw _b_ . TypeError . $factory ( "eval() arg 1 must be a string, bytes " + "or code object" ) } 
function input ( msg ) { var stdin = ( $B . imported . sys && $B . imported . sys . stdin || $B . stdin ) ; if ( stdin . __original__ ) { return prompt ( msg || '' ) || '' } msg = msg || "" if ( msg ) { $B . stdout . write ( msg ) } stdin . msg = msg var val = $B . $getattr ( stdin , 'readline' ) ( ) val = val . split ( '\n' ) [ 0 ] if ( stdin . len === stdin . pos ) { $B . $getattr ( stdin , 'close' ) ( ) } 
function RGBColor ( m ) { this . ok = ! 1 ; m . charAt ( 0 ) == "#" && ( m = m . substr ( 1 , 6 ) ) ; var m = m . replace ( / / g , "" ) , m = m . toLowerCase ( ) , a = { aliceblue : "f0f8ff" , antiquewhite : "faebd7" , aqua : "00ffff" , aquamarine : "7fffd4" , azure : "f0ffff" , beige : "f5f5dc" , bisque : "ffe4c4" , black : "000000" , blanchedalmond : "ffebcd" , blue : "0000ff" , blueviolet : "8a2be2" , brown : "a52a2a" , burlywood : "deb887" , cadetblue : "5f9ea0" , chartreuse : "7fff00" , chocolate : "d2691e" , coral : "ff7f50" , cornflowerblue : "6495ed" , cornsilk : "fff8dc" , crimson : "dc143c" , cyan : "00ffff" , darkblue : "00008b" , darkcyan : "008b8b" , darkgoldenrod : "b8860b" , darkgray : "a9a9a9" , darkgreen : "006400" , darkkhaki : "bdb76b" , darkmagenta : "8b008b" , darkolivegreen : "556b2f" , darkorange : "ff8c00" , darkorchid : "9932cc" , darkred : "8b0000" , darksalmon : "e9967a" , darkseagreen : "8fbc8f" , darkslateblue : "483d8b" , darkslategray : "2f4f4f" , darkturquoise : "00ced1" , darkviolet : "9400d3" , deeppink : "ff1493" , deepskyblue : "00bfff" , dimgray : "696969" , dodgerblue : "1e90ff" , feldspar : "d19275" , firebrick : "b22222" , floralwhite : "fffaf0" , forestgreen : "228b22" , fuchsia : "ff00ff" , gainsboro : "dcdcdc" , ghostwhite : "f8f8ff" , gold : "ffd700" , goldenrod : "daa520" , gray : "808080" , green : "008000" , greenyellow : "adff2f" , honeydew : "f0fff0" , hotpink : "ff69b4" , indianred : "cd5c5c" , indigo : "4b0082" , ivory : "fffff0" , khaki : "f0e68c" , lavender : "e6e6fa" , lavenderblush : "fff0f5" , lawngreen : "7cfc00" , lemonchiffon : "fffacd" , lightblue : "add8e6" , lightcoral : "f08080" , lightcyan : "e0ffff" , lightgoldenrodyellow : "fafad2" , lightgrey : "d3d3d3" , lightgreen : "90ee90" , lightpink : "ffb6c1" , lightsalmon : "ffa07a" , lightseagreen : "20b2aa" , lightskyblue : "87cefa" , lightslateblue : "8470ff" , lightslategray : "778899" , lightsteelblue : "b0c4de" , lightyellow : "ffffe0" , lime : "00ff00" , limegreen : "32cd32" , linen : "faf0e6" , magenta : "ff00ff" , maroon : "800000" , mediumaquamarine : "66cdaa" , mediumblue : "0000cd" , mediumorchid : "ba55d3" , mediumpurple : "9370d8" , mediumseagreen : "3cb371" , mediumslateblue : "7b68ee" , mediumspringgreen : "00fa9a" , mediumturquoise : "48d1cc" , mediumvioletred : "c71585" , midnightblue : "191970" , mintcream : "f5fffa" , mistyrose : "ffe4e1" , moccasin : "ffe4b5" , navajowhite : "ffdead" , navy : "000080" , oldlace : "fdf5e6" , olive : "808000" , olivedrab : "6b8e23" , orange : "ffa500" , orangered : "ff4500" , orchid : "da70d6" , palegoldenrod : "eee8aa" , palegreen : "98fb98" , paleturquoise : "afeeee" , palevioletred : "d87093" , papayawhip : "ffefd5" , peachpuff : "ffdab9" , peru : "cd853f" , pink : "ffc0cb" , plum : "dda0dd" , powderblue : "b0e0e6" , purple : "800080" , red : "ff0000" , rosybrown : "bc8f8f" , royalblue : "4169e1" , saddlebrown : "8b4513" , salmon : "fa8072" , sandybrown : "f4a460" , seagreen : "2e8b57" , seashell : "fff5ee" , sienna : "a0522d" , silver : "c0c0c0" , skyblue : "87ceeb" , slateblue : "6a5acd" , slategray : "708090" , snow : "fffafa" , springgreen : "00ff7f" , steelblue : "4682b4" , tan : "d2b48c" , teal : "008080" , thistle : "d8bfd8" , tomato : "ff6347" , turquoise : "40e0d0" , violet : "ee82ee" , violetred : "d02090" , wheat : "f5deb3" , white : "ffffff" , whitesmoke : "f5f5f5" , yellow : "ffff00" , yellowgreen : "9acd32" } , c ; for ( c in a ) m == c && ( m = a [ c ] ) ; var d = [ { re : / ^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$ / , example : [ "rgb(123, 234, 45)" , "rgb(255,234,245)" ] , process : function ( b ) { return [ parseInt ( b [ 1 ] ) , parseInt ( b [ 2 ] ) , parseInt ( b [ 3 ] ) ] } } , { re : / ^(\w{2})(\w{2})(\w{2})$ / , example : [ "#00ff00" , "336699" ] , process : function ( b ) { return [ parseInt ( b [ 1 ] , 16 ) , parseInt ( b [ 2 ] , 16 ) , parseInt ( b [ 3 ] , 16 ) ] } } , { re : / ^(\w{1})(\w{1})(\w{1})$ / , example : [ "#fb0" , "f0f" ] , process : function ( b ) { return [ parseInt ( b [ 1 ] + b [ 1 ] , 16 ) , parseInt ( b [ 2 ] + b [ 2 ] , 16 ) , parseInt ( b [ 3 ] + b [ 3 ] , 16 ) ] } } ] ; for ( c = 0 ; c < d . length ; c ++ ) { var b = d [ c ] . process , k = d [ c ] . re . exec ( m ) ; if ( k ) channels = b ( k ) , this . r = channels [ 0 ] , this . g = channels [ 1 ] , this . b = channels [ 2 ] , this . ok = ! 0 } this . r = this . r < 0 || isNaN ( this . r ) ? 0 : this . r > 255 ? 255 : this . r ; this . g = this . g < 0 || isNaN ( this . g ) ? 0 : this . g > 255 ? 255 : this . g ; this . b = this . b < 0 || isNaN ( this . b ) ? 0 : this . b > 255 ? 255 : this . b ; this . toRGB = function ( ) { return "rgb(" + this . r + ", " + this . g + ", " + this . b + ")" } ; this . toHex = function ( ) { var b = this . r . toString ( 16 ) , a = this . g . toString ( 16 ) , d = this . b . toString ( 16 ) ; b . length == 1 && ( b = "0" + b ) ; a . length == 1 && ( a = "0" + a ) ; d . length == 1 && ( d = "0" + d ) ; return "#" + b + a + d } ; this . getHelpXML = function ( ) { for ( var b = [ ] , k = 0 ; k < d . length ; k ++ ) for ( var c = d [ k ] . example , j = 0 ; j < c . length ; j ++ ) b [ b . length ] = c [ j ] ; for ( var h in a ) b [ b . length ] = h ; c = document . createElement ( "ul" ) ; c . setAttribute ( "id" , "rgbcolor-examples" ) ; for ( k = 0 ; k < b . length ; k ++ ) try { var l = document . createElement ( "li" ) , o = new RGBColor ( b [ k ] ) , n = document . createElement ( "div" ) ; n . style . cssText = "margin: 3px; border: 1px solid black; background:" + o . toHex ( ) + "; color:" + o . toHex ( ) ; n . appendChild ( document . createTextNode ( "test" ) ) ; var q = document . createTextNode ( " " + b [ k ] + " -> " + o . toRGB ( ) + " -> " + o . toHex ( ) ) ; l . appendChild ( n ) ; l . appendChild ( q ) ; c . appendChild ( l ) } catch ( p ) { } return c } } 
function ( name , path ) { path = path || '' ; return gulp . src ( ` ${ buildFolder } ${ path } ` ) 
function promiseify ( fn ) { return function ( ) { const args = [ ] . slice . call ( arguments , 0 ) ; return new Promise ( ( resolve , reject ) => { fn . apply ( this , args . concat ( [ function ( err , value ) { if ( err ) { reject ( err ) ; } else { resolve ( value ) ; } } ] ) ) ; } ) ; } ; } 
function inlineResourcesFromString ( content , urlResolver ) { 
function inlineStyle ( content , urlResolver ) { return content . replace ( / styleUrls\s*:\s*(\[[\s\S]*?\]) / gm , function ( m , styleUrls ) { const urls = eval ( styleUrls ) ; return 'styles: [' + urls . map ( styleUrl => { const styleFile = urlResolver ( styleUrl ) ; const originContent = fs . readFileSync ( styleFile , 'utf-8' ) ; const styleContent = styleFile . endsWith ( '.scss' ) ? buildSass ( originContent , styleFile ) : originContent ; const shortenedStyle = styleContent . replace ( / ([\n\r]\s*)+ / gm , ' ' ) . replace ( / " / g , '\\"' ) ; return ` ${ shortenedStyle } ` ; } ) . join ( ',\n' ) + ']' ; } ) ; } 
function buildSass ( content , sourceFile ) { try { const result = sass . renderSync ( { data : content , file : sourceFile , importer : tildeImporter } ) ; return result . css . toString ( ) } catch ( e ) { console . error ( '\x1b[41m' ) ; console . error ( 'at ' + sourceFile + ':' + e . line + ":" + e . column ) ; console . error ( e . formatted ) ; console . error ( '\x1b[0m' ) ; return "" ; } } 
function FormioResourceRoutes ( config ) { config = config || { } ; return [ { path : '' , component : config . index || index_component_1 . FormioResourceIndexComponent } , { path : 'new' , component : config . create || create_component_1 . FormioResourceCreateComponent } , { path : ':id' , component : config . resource || resource_component_1 . FormioResourceComponent , children : [ { path : '' , redirectTo : 'view' , pathMatch : 'full' } , { path : 'view' , component : config . view || view_component_1 . FormioResourceViewComponent } , { path : 'edit' , component : config . edit || edit_component_1 . FormioResourceEditComponent } , { path : 'delete' , component : config . delete || delete_component_1 . FormioResourceDeleteComponent } ] } ] ; } 
function groupPartitionsByTopic ( topicPartitions ) { assert ( Array . isArray ( topicPartitions ) ) ; return topicPartitions . reduce ( function ( result , tp ) { if ( ! ( tp . topic in result ) ) { result [ tp . topic ] = [ tp . partition ] ; } else { result [ tp . topic ] . push ( tp . partition ) ; } return result ; } , { } ) ; } 
function createTopicPartitionList ( topicPartitions ) { var tpList = [ ] ; for ( var topic in topicPartitions ) { if ( ! topicPartitions . hasOwnProperty ( topic ) ) { continue ; } topicPartitions [ topic ] . forEach ( function ( partition ) { tpList . push ( { topic : topic , partition : partition } ) ; } ) ; } return tpList ; } 
function decodeSnappy ( buffer , cb ) { if ( isChunked ( buffer ) ) { var pos = 16 ; var max = buffer . length ; var encoded = [ ] ; var size ; while ( pos < max ) { size = buffer . readUInt32BE ( pos ) ; pos += 4 ; encoded . push ( buffer . slice ( pos , pos + size ) ) ; pos += size ; } return async . mapSeries ( encoded , snappy . uncompress , function ( err , decodedChunks ) { if ( err ) return cb ( err ) ; return cb ( null , Buffer . concat ( decodedChunks ) ) ; } ) ; } return snappy . uncompress ( buffer , cb ) ; } 
function parseHost ( hostString ) { const ip = hostString . substring ( 0 , hostString . lastIndexOf ( ':' ) ) ; const port = + hostString . substring ( hostString . lastIndexOf ( ':' ) + 1 ) ; const isIpv6 = ip . match ( / \[(.*)\] / ) ; const host = isIpv6 ? isIpv6 [ 1 ] : ip ; return { host , port } ; } 
function BaseProducer ( client , options , defaultPartitionerType , customPartitioner ) { EventEmitter . call ( this ) ; options = options || { } ; this . ready = false ; this . client = client ; this . requireAcks = options . requireAcks === undefined ? DEFAULTS . requireAcks : options . requireAcks ; this . ackTimeoutMs = options . ackTimeoutMs === undefined ? DEFAULTS . ackTimeoutMs : options . ackTimeoutMs ; if ( customPartitioner !== undefined && options . partitionerType !== PARTITIONER_TYPES . custom ) { throw new Error ( 'Partitioner Type must be custom if providing a customPartitioner.' ) ; } else if ( customPartitioner === undefined && options . partitionerType === PARTITIONER_TYPES . custom ) { throw new Error ( 'No customer partitioner defined' ) ; } var partitionerType = PARTITIONER_MAP [ options . partitionerType ] || PARTITIONER_MAP [ defaultPartitionerType ] ; 
function encodeGroupProtocol ( protocol ) { this . Int16BE ( protocol . name . length ) . string ( protocol . name ) . string ( _encodeProtocolData ( protocol ) ) ; } 
function decodeMemberAssignment ( assignmentBytes ) { var assignment = { partitions : { } } ; Binary . parse ( assignmentBytes ) . word16bs ( 'version' ) . tap ( function ( vars ) { assignment . version = vars . version ; } ) . word32bs ( 'partitionAssignment' ) . loop ( function ( end , vars ) { if ( vars . partitionAssignment -- === 0 ) return end ( ) ; var topic ; var partitions = [ ] ; this . word16bs ( 'topic' ) . tap ( function ( vars ) { this . buffer ( 'topic' , vars . topic ) ; topic = vars . topic . toString ( ) ; } ) . word32bs ( 'partitionsNum' ) . loop ( function ( end , vars ) { if ( vars . partitionsNum -- === 0 ) return end ( ) ; this . word32bs ( 'partition' ) . tap ( function ( vars ) { partitions . push ( vars . partition ) ; } ) ; } ) ; assignment . partitions [ topic ] = partitions ; } ) . word32bs ( 'userData' ) . tap ( function ( vars ) { if ( vars . userData == null || vars . userData === - 1 ) { return ; } this . buffer ( 'userData' , vars . userData ) ; try { assignment . userData = JSON . parse ( vars . userData . toString ( ) ) ; } catch ( e ) { assignment . userData = 'JSON Parse error' ; } } ) ; return assignment ; } 
function encodeJoinGroupRequest ( clientId , correlationId , groupId , memberId , sessionTimeout , groupProtocols ) { var request = encodeRequestHeader ( clientId , correlationId , REQUEST_TYPE . joinGroup ) ; request . Int16BE ( groupId . length ) . string ( groupId ) . Int32BE ( sessionTimeout ) . Int16BE ( memberId . length ) . string ( memberId ) . Int16BE ( GROUPS_PROTOCOL_TYPE . length ) . string ( GROUPS_PROTOCOL_TYPE ) . Int32BE ( groupProtocols . length ) ; groupProtocols . forEach ( encodeGroupProtocol . bind ( request ) ) ; return encodeRequestWithLength ( request . make ( ) ) ; } 
function decodeJoinGroupResponse ( resp ) { var result = { members : [ ] } ; var error ; Binary . parse ( resp ) . word32bs ( 'size' ) . word32bs ( 'correlationId' ) . word16bs ( 'errorCode' ) . tap ( function ( vars ) { error = createGroupError ( vars . errorCode ) ; } ) . word32bs ( 'generationId' ) . tap ( function ( vars ) { result . generationId = vars . generationId ; } ) . word16bs ( 'groupProtocol' ) . tap ( function ( vars ) { this . buffer ( 'groupProtocol' , vars . groupProtocol ) ; result . groupProtocol = vars . groupProtocol = vars . groupProtocol . toString ( ) ; } ) . word16bs ( 'leaderId' ) . tap ( function ( vars ) { this . buffer ( 'leaderId' , vars . leaderId ) ; result . leaderId = vars . leaderId = vars . leaderId . toString ( ) ; } ) . word16bs ( 'memberId' ) . tap ( function ( vars ) { this . buffer ( 'memberId' , vars . memberId ) ; result . memberId = vars . memberId = vars . memberId . toString ( ) ; } ) . word32bs ( 'memberNum' ) . loop ( function ( end , vars ) { if ( error ) { return end ( ) ; } if ( vars . memberNum -- === 0 ) return end ( ) ; var memberMetadata ; this . word16bs ( 'groupMemberId' ) . tap ( function ( vars ) { this . buffer ( 'groupMemberId' , vars . groupMemberId ) ; vars . memberId = vars . groupMemberId . toString ( ) ; } ) . word32bs ( 'memberMetadata' ) . tap ( function ( vars ) { if ( vars . memberMetadata > - 1 ) { this . buffer ( 'memberMetadata' , vars . memberMetadata ) ; memberMetadata = decodeGroupData ( this . vars . memberMetadata ) ; memberMetadata . id = vars . memberId ; result . members . push ( memberMetadata ) ; } } ) ; } ) ; return error || result ; } 
function fetchOffsets ( offset , topics , cb , when ) { if ( ! offset . ready ) { if ( when === - 1 ) { offset . once ( 'ready' , ( ) => offset . fetchLatestOffsets ( topics , cb ) ) ; } else if ( when === - 2 ) { offset . once ( 'ready' , ( ) => offset . fetchEarliestOffsets ( topics , cb ) ) ; } return ; } async . waterfall ( [ callback => { offset . client . loadMetadataForTopics ( topics , callback ) ; } , ( topicsMetaData , callback ) => { var payloads = [ ] ; var metaDatas = topicsMetaData [ 1 ] . metadata ; Object . keys ( metaDatas ) . forEach ( function ( topicName ) { var topic = metaDatas [ topicName ] ; Object . keys ( topic ) . forEach ( function ( partition ) { payloads . push ( { topic : topicName , partition : partition , time : when } ) ; } ) ; } ) ; if ( payloads . length === 0 ) { return callback ( new Error ( 'Topic(s) does not exist' ) ) ; } offset . fetch ( payloads , callback ) ; } , function ( results , callback ) { Object . keys ( results ) . forEach ( function ( topicName ) { var topic = results [ topicName ] ; Object . keys ( topic ) . forEach ( function ( partitionName ) { topic [ partitionName ] = topic [ partitionName ] [ 0 ] ; } ) ; } ) ; callback ( null , results ) ; } ] , cb ) ; } 
function wrap ( payloads , cb ) { var out = { } ; var count = Object . keys ( payloads ) . length ; return function ( err , data ) { 
function Context ( options ) { if ( ! options ) options = { body : '' , hostname : '' } ; const body = options . body ; const href = 'http://' + options . hostname + '/' ; const cache = Object . create ( null ) ; const keys = [ ] ; this . atob = function ( str ) { return Buffer . from ( str , 'base64' ) . toString ( 'binary' ) ; } ; 
function handler ( options , { captcha } ) { return new Promise ( ( resolve , reject ) => { 
function alternative ( options , { captcha : { url , siteKey } } ) { 
function performRequest ( options , isFirstRequest ) { 
function onRequestResponse ( options , error , response , body ) { const callback = options . callback ; 
function onCaptcha ( options , response , body ) { const callback = options . callback ; 
function ( error ) { if ( error ) { 
function insertTs ( name ) { const tsIndexPath = path . resolve ( __dirname , '../src/index.ts' ) ; const tsIndexFile = fs . readFileSync ( tsIndexPath , { encoding : 'utf-8' } ) ; const moduleExports = tsIndexFile . trim ( ) . split ( '\n' ) ; moduleExports . push ( ` ${ name } ` ) ; sortByModulePath ( moduleExports ) ; fs . writeFileSync ( tsIndexPath , ` ${ moduleExports . join ( '\n' ) } \n ` ) ; } 
function insertCss ( name ) { const cssIndexPath = path . resolve ( __dirname , '../assets/index.scss' ) ; const cssIndexFile = fs . readFileSync ( cssIndexPath , { encoding : 'utf-8' } ) ; const cssImportStr = ` ${ name } ` ; const cssIndexFileArr = cssIndexFile . trim ( ) . split ( '\n' ) ; cssIndexFileArr . push ( cssImportStr ) ; 
function addFiles ( name ) { const packagesDir = path . resolve ( __dirname , '../src' ) ; const assetsDir = path . resolve ( __dirname , '../assets' ) ; const componentDir = ` ${ packagesDir } ${ name } ` ; const upperComponentName = getComponentName ( name ) ; console . log ( ` up perComponentName}` ) ; if ( ! fs . existsSync ( componentDir ) ) { fs . mkdirSync ( componentDir ) ; } else { console . log ( ` ${ upperComponentName } ` ) ; process . exit ( 2 ) ; } fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ upperComponentName } \n \n ${ upperComponentName } \n ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } ${ upperComponentName } ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } om ponentName}  ` ) ; fs . writeFileSync ( ` ${ componentDir } ${ upperComponentName } ` , '' ) ; fs . writeFileSync ( ` ${ assetsDir } ${ name } ` , '' ) ; addFilesToIndex ( name ) ; } 
function createMapper ( ) { var packagesDir = path . resolve ( __dirname , '../src' ) ; var packages = fs . readdirSync ( packagesDir ) ; return packages . filter ( p => fs . statSync ( path . join ( packagesDir , p ) ) . isDirectory ( ) ) . reduce ( ( alias , p ) => { alias [ ` ${ p } ` ] = ` ${ p } ` ; alias [ ` ${ p } ` ] = ` ${ p } ` ; return alias ; } , { } ) ; } 
function ( event ) { var that = $ ( this ) ; that . on ( 'click' , onMapClickHandler ) ; that . off ( 'mouseleave' , onMapMouseleaveHandler ) ; that . find ( 'iframe' ) . css ( "pointer-events" , "none" ) ; } 
function toggleDocumentationSidebar ( ) { const sidebarNav = document . querySelector ( 'nav.sidebar' ) ; const trigger = document . querySelector ( '.sidebar-opener' ) ; function init ( ) { const bodySize = document . body . clientWidth ; if ( bodySize <= 960 && sidebarNav ) { trigger . addEventListener ( 'click' , ( ) => { sidebarNav . classList . toggle ( 'Showed' ) ; trigger . classList . toggle ( 'Showed' ) ; } ) ; } } init ( ) ; } 
function assets ( userOptions = { } ) { const options = { ... defaults , ... userOptions , } ; return ( files , metalsmith , cb ) => { const src = metalsmith . path ( options . source ) ; const dest = options . destination ; 
function getStartStopBoundaries ( parent , sidebar , topOffset ) { const bbox = parent . getBoundingClientRect ( ) ; const sidebarBbox = sidebar . getBoundingClientRect ( ) ; const bodyBbox = document . body . getBoundingClientRect ( ) ; const containerAbsoluteTop = bbox . top - bodyBbox . top ; const sidebarAbsoluteTop = sidebarBbox . top - bodyBbox . top ; const marginTop = sidebarAbsoluteTop - containerAbsoluteTop ; const start = containerAbsoluteTop - topOffset ; const stop = bbox . height + containerAbsoluteTop - sidebarBbox . height - marginTop - topOffset ; return { start , stop , } ; } 
function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i ++ ) args [ i ] = arguments [ i ] return fn . call ( this , old , args ) } } 
function before ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { fn . call ( this ) old . apply ( this , arguments ) } } 
function confirm ( msg , callback ) { var rl = readline . createInterface ( { input : process . stdin , output : process . stdout } ) rl . question ( msg , function ( input ) { rl . close ( ) callback ( / ^y|yes|ok|true$ / i . test ( input ) ) } ) } 
function copyTemplate ( from , to ) { write ( to , fs . readFileSync ( path . join ( TEMPLATE_DIR , from ) , 'utf-8' ) ) } 
function copyTemplateMulti ( fromDir , toDir , nameGlob ) { fs . readdirSync ( path . join ( TEMPLATE_DIR , fromDir ) ) . filter ( minimatch . filter ( nameGlob , { matchBase : true } ) ) . forEach ( function ( name ) { copyTemplate ( path . join ( fromDir , name ) , path . join ( toDir , name ) ) } ) } 
function createApplication ( name , dir ) { console . log ( ) 
function createAppName ( pathName ) { return path . basename ( pathName ) . replace ( / [^A-Za-z0-9.-]+ / g , '-' ) . replace ( / ^[-_.]+|-+$ / g , '' ) . toLowerCase ( ) } 
function emptyDirectory ( dir , fn ) { fs . readdir ( dir , function ( err , files ) { if ( err && err . code !== 'ENOENT' ) throw err fn ( ! files || ! files . length ) } ) } 
function exit ( code ) { 
function loadTemplate ( name ) { var contents = fs . readFileSync ( path . join ( __dirname , '..' , 'templates' , ( name + '.ejs' ) ) , 'utf-8' ) var locals = Object . create ( null ) function render ( ) { return ejs . render ( contents , locals , { escape : util . inspect } ) } return { locals : locals , render : render } } 
function main ( ) { 
function mkdir ( base , dir ) { var loc = path . join ( base , dir ) console . log ( ' \x1b[36mcreate\x1b[0m : ' + loc + path . sep ) mkdirp . sync ( loc , MODE_0755 ) } 
function renamedOption ( originalName , newName ) { return function ( val ) { warning ( util . format ( "option `%s' has been renamed to `%s'" , originalName , newName ) ) return val } } 
function warning ( message ) { console . error ( ) message . split ( '\n' ) . forEach ( function ( line ) { console . error ( ' warning: %s' , line ) } ) console . error ( ) } 
function write ( file , str , mode ) { fs . writeFileSync ( file , str , { mode : mode || MODE_0666 } ) console . log ( ' \x1b[36mcreate\x1b[0m : ' + file ) } 
function getCoordinatesForPosition ( triggerBounding , ContentBounding , position , arrow , _ref ) { var offsetX = _ref . offsetX , offsetY = _ref . offsetY ; var margin = arrow ? 8 : 0 ; var args = position . split ( " " ) ; 
function string_array_to_rgb ( string_array ) { var rgbs = new Float32Array ( string_array . length * 3 ) ; for ( var i = 0 ; i < string_array . length ; i ++ ) { var color = new THREE . Color ( string_array [ i ] ) ; rgbs [ i * 3 + 0 ] = color . r ; rgbs [ i * 3 + 1 ] = color . g ; rgbs [ i * 3 + 2 ] = color . b ; } return rgbs ; } 
function bind_d3 ( f , context ) { return function ( ) { var args = [ this ] . concat ( [ ] . slice . call ( arguments ) ) 
function renderToString ( vnode , context , opts , inner , isSvgMode , selectValue ) { if ( vnode == null || typeof vnode === 'boolean' ) { return '' ; } let nodeName = vnode . type , props = vnode . props , isComponent = false ; context = context || { } ; opts = opts || { } ; let pretty = ENABLE_PRETTY && opts . pretty , indentChar = pretty && typeof pretty === 'string' ? pretty : '\t' ; 
async function start ( opts : * ) { const isTaken = await isPortTaken ( opts . port ) ; if ( isTaken ) { if ( ! opts . no_interactive ) { const { userChoice } = await inquirer . prompt ( { type : 'list' , name : 'userChoice' , message : ` ${ opts . port } ` , choices : [ ` ${ opts . port } ` , 'Quit' , ] , } ) ; if ( userChoice === 'Quit' ) { process . exit ( ) ; } try { await killProcess ( opts . port ) ; } catch ( e ) { logger . error ( ` \n ${ e . message } ` ) ; process . exit ( 1 ) ; } logger . info ( ` ` ) ; } else { logger . error ( ` ${ opts . port } ` ) ; process . exit ( 1 ) ; } } const directory = process . cwd ( ) ; const configPath = getWebpackConfigPath ( directory , opts . config ) ; let assetsDest ; if ( opts . assetsDest ) { assetsDest = path . isAbsolute ( opts . assetsDest ) ? opts . assetsDest : path . join ( directory , opts . assetsDest ) ; } else { assetsDest = fs . mkdtempSync ( path . join ( os . tmpdir ( ) , 'haul-start-' ) ) ; } const configOptions = { root : directory , assetsDest , dev : opts . dev , minify : opts . minify , port : opts . port , eager : opts . eager , disableHotReloading : ! opts . hotReloading , } ; createServer ( { configPath , configOptions , } ) . listen ( opts . port ) ; } 
function isPortTaken ( port : number ) : Promise < boolean > { return new Promise ( resolve => { const portTester = net . createServer ( ) . once ( 'error' , ( ) => { return resolve ( true ) ; } ) . once ( 'listening' , ( ) => { portTester . close ( ) ; resolve ( false ) ; } ) . listen ( port ) ; } ) ; } 
async function bundle ( opts : * ) { const directory = process . cwd ( ) ; const configPath = getWebpackConfigPath ( directory , opts . config ) ; const config = getConfig ( configPath , { root : directory , dev : opts . dev , minify : opts . minify , bundle : true , } , opts . platform , logger ) ; if ( opts . assetsDest ) { config . output . path = path . isAbsolute ( opts . assetsDest ) ? opts . assetsDest : path . join ( directory , opts . assetsDest ) ; } if ( opts . bundleOutput ) { config . output . filename = path . isAbsolute ( opts . bundleOutput ) ? path . relative ( config . output . path , opts . bundleOutput ) : path . relative ( config . output . path , path . join ( directory , opts . bundleOutput ) ) ; } logger . info ( ` ${ config . output . path } ` ) ; logger . info ( ` ${ config . output . filename } ` ) ; logger . info ( ` ${ path . resolve ( config . output . filename ) } ` ) ; 
function adjustOptions ( options ) { const directory = process . cwd ( ) ; const configPath = getWebpackConfigPath ( directory , options . config ) ; const haulOptions = getHaulConfig ( configPath , logger ) ; if ( haulOptions . platforms ) { const platformOption = command . options && command . options . find ( _ => _ . name === 'platform' ) ; if ( platformOption ) { platformOption . choices = [ ] ; for ( const platformName in haulOptions . platforms ) { if ( Object . prototype . hasOwnProperty . call ( haulOptions . platforms , platformName ) ) { if ( platformOption . choices ) { platformOption . choices . push ( { value : platformName , description : ` ${ haulOptions . platforms [ platformName ] } ` , } ) ; } } } } } } 
function exec ( args : string ) : Promise < void > { return new Promise ( ( resolve , reject ) => { child_process . exec ( args , ( err , stdout , stderr ) => { if ( err ) { reject ( new Error ( stderr ) ) ; } else { resolve ( ) ; } } ) ; } ) ; } 
function createLabel ( platform : string ) { if ( labelOptions [ platform ] ) { const { color , label } = labelOptions [ platform ] ; return ` ${ chalk . bold [ color ] ( label ) } ` . padEnd ( 30 ) ; } return ` ${ chalk . bold . magenta ( platform ) } ` . padEnd ( 30 ) ; } 
function createBarFormat ( platform : string ) { const label = createLabel ( platform ) ; const leftBar = chalk . bold ( '[' ) ; const rightBar = chalk . bold ( ']' ) ; const percent = chalk . bold . blue ( ':percent' ) ; return ` ${ label } ${ leftBar } ${ rightBar } ${ percent } ` ; } 
function cleanPathMiddleware ( req , res , next ) { req . cleanPath = req . path . replace ( / \/$ / , '' ) ; next ( ) ; } 
function createServer ( config : { configPath : ? string , configOptions : Object } ) { const appHandler = express ( ) ; appHandler . disable ( 'etag' ) ; const { configPath , configOptions } = config ; const compiler = new Compiler ( { configPath , configOptions , } ) ; const loggerMiddleware = initUI ( compiler , configOptions ) ; process . on ( 'uncaughtException' , err => { compiler . terminate ( ) ; throw err ; } ) ; process . on ( 'SIGINT' , ( ) => { compiler . terminate ( ) ; process . exit ( 0 ) ; } ) ; process . on ( 'SIGTERM' , ( ) => { compiler . terminate ( ) ; process . exit ( 2 ) ; } ) ; const compilerMiddleware = createCompilerMiddleware ( compiler , { configPath , configOptions , } ) ; const httpServer = http . createServer ( appHandler ) ; const webSocketServer = new WebSocketServer ( { server : httpServer } ) ; const debuggerProxy = new WebSocketDebuggerProxy ( webSocketProxy ( webSocketServer , '/debugger-proxy' ) ) ; if ( ! configOptions . disableHotReloading ) { hotMiddleware ( compiler , { nativeProxy : webSocketProxy ( webSocketServer , '/hot' ) , haulProxy : webSocketProxy ( webSocketServer , '/haul-hmr' ) , } ) ; } 
function devToolsMiddleware ( debuggerProxy ) { return ( req , res , next ) => { switch ( req . cleanPath ) { case '/debugger-ui/' : case '/debugger-ui' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debugger.html' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; readStream . pipe ( res ) ; break ; } case '/debugger-ui/debuggerWorker.js' : case '/debuggerWorker.js' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debuggerWorker.js' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'application/javascript' } ) ; readStream . pipe ( res ) ; break ; } case '/launch-js-devtools' : { if ( ! debuggerProxy . isDebuggerConnected ( ) ) { launchBrowser ( ` ${ req . socket . localPort } ` ) ; } res . end ( 'OK' ) ; break ; } default : next ( ) ; } } ; } 
function normalizeOptions ( { path , quiet , overlay , reload , name } ) { const shouldLog = ! quiet ; const options = { path , overlay : true , reload : false , name : '' , logger : { shouldLog , log ( ... args ) { if ( shouldLog ) { console . log ( ... args ) ; } } , warn ( ... args ) { if ( shouldLog ) { console . warn ( ... args ) ; } } , error ( ... args ) { if ( shouldLog ) { console . error ( ... args ) ; } } , } , } ; if ( overlay ) { options . overlay = overlay !== 'false' ; } if ( reload ) { options . reload = reload !== 'false' ; } if ( name ) { options . name = name ; } return options ; } 
async function createSourceMapConsumer ( compiler : Compiler , url : string ) { const response = await fetch ( url ) ; const sourceMap = await response . text ( ) ; 
function fixRequireIssue ( ) { return { visitor : { AssignmentExpression ( path ) { if ( path . node . operator === '=' ) { const { left } = path . node ; if ( left . type !== 'MemberExpression' ) { return ; } const { object } = left ; if ( 
function findIndex ( predicate , context ) { if ( this == null ) { throw new TypeError ( 'Array.prototype.findIndex called on null or undefined' ) ; } if ( typeof predicate !== 'function' ) { throw new TypeError ( 'predicate must be a function' ) ; } const list = Object ( this ) ; const length = list . length >>> 0 ; for ( let i = 0 ; i < length ; i ++ ) { if ( predicate . call ( context , list [ i ] , i , list ) ) { return i ; } } return - 1 ; } 
function onLoad ( event ) { 
function prefixSubstrings ( prefix , substrings , strings ) { let prefixed , regExp ; for ( const substring of substrings ) { prefixed = "$1" + prefix + substring . charAt ( 0 ) . toUpperCase ( ) + substring . slice ( 1 ) ; regExp = new RegExp ( "([^\\.])(\\b" + substring + "\\b)" , "g" ) ; for ( const entry of strings . entries ( ) ) { if ( entry [ 1 ] !== null ) { strings . set ( entry [ 0 ] , entry [ 1 ] . replace ( regExp , prefixed ) ) ; } } } } 
function integrateEffect ( prefix , effect , shaderParts , blendModes , defines , uniforms , attributes ) { const functionRegExp = / (?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+}) / g ; const varyingRegExp = / (?:varying\s+\w+\s+(\w*)) / g ; const blendMode = effect . blendMode ; const shaders = new Map ( [ [ "fragment" , effect . fragmentShader ] , [ "vertex" , effect . vertexShader ] ] ) ; const mainImageExists = ( shaders . get ( "fragment" ) !== undefined && shaders . get ( "fragment" ) . indexOf ( "mainImage" ) >= 0 ) ; const mainUvExists = ( shaders . get ( "fragment" ) !== undefined && shaders . get ( "fragment" ) . indexOf ( "mainUv" ) >= 0 ) ; let varyings = [ ] , names = [ ] ; let transformedUv = false ; let readDepth = false ; if ( shaders . get ( "fragment" ) === undefined ) { console . error ( "Missing fragment shader" , effect ) ; } else if ( mainUvExists && ( attributes & EffectAttribute . CONVOLUTION ) !== 0 ) { console . error ( "Effects that transform UV coordinates are incompatible with convolution effects" , effect ) ; } else if ( ! mainImageExists && ! mainUvExists ) { console . error ( "The fragment shader contains neither a mainImage nor a mainUv function" , effect ) ; } else { if ( mainUvExists ) { shaderParts . set ( Section . FRAGMENT_MAIN_UV , shaderParts . get ( Section . FRAGMENT_MAIN_UV ) + "\t" + prefix + "MainUv(UV);\n" ) ; transformedUv = true ; } if ( shaders . get ( "vertex" ) !== null && shaders . get ( "vertex" ) . indexOf ( "mainSupport" ) >= 0 ) { shaderParts . set ( Section . VERTEX_MAIN_SUPPORT , shaderParts . get ( Section . VERTEX_MAIN_SUPPORT ) + "\t" + prefix + "MainSupport();\n" ) ; varyings = varyings . concat ( findSubstrings ( varyingRegExp , shaders . get ( "vertex" ) ) ) ; names = names . concat ( varyings ) . concat ( findSubstrings ( functionRegExp , shaders . get ( "vertex" ) ) ) ; } names = names . concat ( findSubstrings ( functionRegExp , shaders . get ( "fragment" ) ) ) . concat ( Array . from ( effect . uniforms . keys ( ) ) ) . concat ( Array . from ( effect . defines . keys ( ) ) ) ; 
function createCanvas ( width , height , data , channels ) { const canvas = document . createElementNS ( "http://www.w3.org/1999/xhtml" , "canvas" ) ; const context = canvas . getContext ( "2d" ) ; const imageData = context . createImageData ( width , height ) ; const target = imageData . data ; let x , y ; let i , j ; for ( y = 0 ; y < height ; ++ y ) { for ( x = 0 ; x < width ; ++ x ) { i = ( y * width + x ) * 4 ; j = ( y * width + x ) * channels ; target [ i ] = ( channels > 0 ) ? data [ j ] : 0 ; target [ i + 1 ] = ( channels > 1 ) ? data [ j + 1 ] : 0 ; target [ i + 2 ] = ( channels > 2 ) ? data [ j + 2 ] : 0 ; target [ i + 3 ] = ( channels > 3 ) ? data [ j + 3 ] : 255 ; } } canvas . width = width ; canvas . height = height ; context . putImageData ( imageData , 0 , 0 ) ; return canvas ; } 
function smoothArea ( d , b ) { const a1 = b . min ; const a2 = b . max ; const b1X = Math . sqrt ( a1 . x * 2.0 ) * 0.5 ; const b1Y = Math . sqrt ( a1 . y * 2.0 ) * 0.5 ; const b2X = Math . sqrt ( a2 . x * 2.0 ) * 0.5 ; const b2Y = Math . sqrt ( a2 . y * 2.0 ) * 0.5 ; const p = saturate ( d / SMOOTH_MAX_DISTANCE ) ; a1 . set ( lerp ( b1X , a1 . x , p ) , lerp ( b1Y , a1 . y , p ) ) ; a2 . set ( lerp ( b2X , a2 . x , p ) , lerp ( b2Y , a2 . y , p ) ) ; return b ; } 
function calculateDiagonalAreaForPixel ( p1 , p2 , pX , pY ) { let a ; let x , y ; let offsetX , offsetY ; for ( a = 0 , y = 0 ; y < DIAGONAL_SAMPLES ; ++ y ) { for ( x = 0 ; x < DIAGONAL_SAMPLES ; ++ x ) { offsetX = x / ( DIAGONAL_SAMPLES - 1.0 ) ; offsetY = y / ( DIAGONAL_SAMPLES - 1.0 ) ; if ( isInsideArea ( p1 , p2 , pX + offsetX , pY + offsetY ) ) { ++ a ; } } } return a / ( DIAGONAL_SAMPLES * DIAGONAL_SAMPLES ) ; } 
function calculateDiagonalArea ( pattern , p1 , p2 , left , offset , result ) { const e = diagonalEdges [ pattern ] ; const e1 = e [ 0 ] ; const e2 = e [ 1 ] ; if ( e1 > 0 ) { p1 . x += offset [ 0 ] ; p1 . y += offset [ 1 ] ; } if ( e2 > 0 ) { p2 . x += offset [ 0 ] ; p2 . y += offset [ 1 ] ; } return result . set ( 1.0 - calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 0.0 + left ) , calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 1.0 + left ) ) ; } 
function calculateDiagonalAreaForPattern ( pattern , left , right , offset , result ) { const p1 = b0 . min ; const p2 = b0 . max ; const a1 = b1 . min ; const a2 = b1 . max ; const d = left + right + 1 ; switch ( pattern ) { case 0 : { * .- * .- * .- * | * | */ calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 0.0 + d , 0.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 2 : { calculateDiagonalArea ( pattern , p1 . set ( 0.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 3 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , result ) ; break ; } case 4 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 0.0 + d , 0.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 5 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 0.0 + d , 0.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 6 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , result ) ; break ; } case 7 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 8 : { calculateDiagonalArea ( pattern , p1 . set ( 0.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 9 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , result ) ; break ; } case 10 : { calculateDiagonalArea ( pattern , p1 . set ( 0.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 11 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 12 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , result ) ; break ; } case 13 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 14 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } case 15 : { calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 1.0 ) , p2 . set ( 1.0 + d , 1.0 + d ) , left , offset , a1 ) ; calculateDiagonalArea ( pattern , p1 . set ( 1.0 , 0.0 ) , p2 . set ( 1.0 + d , 0.0 + d ) , left , offset , a2 ) ; result . addVectors ( a1 , a2 ) . divideScalar ( 2.0 ) ; break ; } } return result ; } 
function generatePatterns ( patterns , offset , orthogonal ) { const result = new Vector2 ( ) ; let i , l ; let x , y ; let c ; let pattern ; let data , size ; for ( i = 0 , l = patterns . length ; i < l ; ++ i ) { pattern = patterns [ i ] ; data = pattern . data ; size = pattern . width ; for ( y = 0 ; y < size ; ++ y ) { for ( x = 0 ; x < size ; ++ x ) { if ( orthogonal ) { calculateOrthogonalAreaForPattern ( i , x , y , offset , result ) ; } else { calculateDiagonalAreaForPattern ( i , x , y , offset , result ) ; } c = ( y * size + x ) * 2 ; data [ c ] = result . x * 255 ; data [ c + 1 ] = result . y * 255 ; } } } } 
function assemble ( base , patterns , edges , size , orthogonal , target ) { const p = new Vector2 ( ) ; const dstData = target . data ; const dstWidth = target . width ; let i , l ; let x , y ; let c , d ; let edge ; let pattern ; let srcData , srcWidth ; for ( i = 0 , l = patterns . length ; i < l ; ++ i ) { edge = edges [ i ] ; pattern = patterns [ i ] ; srcData = pattern . data ; srcWidth = pattern . width ; for ( y = 0 ; y < size ; ++ y ) { for ( x = 0 ; x < size ; ++ x ) { p . fromArray ( edge ) . multiplyScalar ( size ) ; p . add ( base ) ; p . x += x ; p . y += y ; c = ( p . y * dstWidth + p . x ) * 2 ; d = orthogonal ? ( ( y * y * srcWidth + x * x ) * 2 ) : ( ( y * srcWidth + x ) * 2 ) ; dstData [ c ] = srcData [ d ] ; dstData [ c + 1 ] = srcData [ d + 1 ] ; } } } } 
function deltaRight ( left , top ) { let d = 0 ; crossing edges, continue. */ if ( d === 1 && top [ 2 ] === 1 && left [ 0 ] !== 1 && left [ 2 ] !== 1 ) { d += 1 ; } return d ; } 
function bilinear ( e ) { const a = lerp ( e [ 0 ] , e [ 1 ] , 1.0 - 0.25 ) ; const b = lerp ( e [ 2 ] , e [ 3 ] , 1.0 - 0.25 ) ; return lerp ( a , b , 1.0 - 0.125 ) ; } 
function getKeys ( ) { keys = { pageup : 33 , pagedown : 34 , end : 35 , home : 36 , left : 37 , up : 38 , right : 39 , down : 40 , } return keys } 
function checkForm ( that ) { var newValue = $ ( that ) . val ( ) var matches = newValue != '' ? newValue . match ( timeRegEx ) : '' var error = $ ( that ) . closest ( '.time-spinner' ) . find ( '.error_container' ) var $closerTimeSpinner = $ ( that ) . closest ( '.time-spinner' ) . find ( '.spinner-control' ) if ( matches ) { $ ( error ) . html ( '' ) 
function mc_symbol_clone ( ) { var clone = this . _cloneProps ( new this . constructor ( this . mode , this . startPosition , this . loop ) ) ; clone . gotoAndStop ( this . currentFrame ) ; clone . paused = this . paused ; clone . framerate = this . framerate ; return clone ; } 
function resetToMove ( contextControl ) { var left = contextControl . find ( '.source .transfer-group' ) var right = contextControl . find ( '.target .transfer-group' ) var textLeft = contextControl . find ( '.source .transfer-header span.num' ) var textRight = contextControl . find ( '.target .transfer-header span.num' ) var header = contextControl . find ( '.transfer-header input' ) $ ( left ) . html ( elemLeft ) $ ( right ) . html ( elemRight ) $ ( textLeft ) . text ( elemLeftNum ) $ ( textRight ) . text ( elemRightNum ) $ ( header ) . prop ( 'disabled' , false ) } 
function checkIfActive ( targetControl , targetHeaderControl , containerTypeControl , addButtonControl ) { $ ( targetControl ) . each ( function ( el ) { if ( $ ( this ) . prop ( 'checked' ) ) { if ( ! $ ( targetHeaderControl ) . hasClass ( 'semi-checked' ) ) { $ ( targetHeaderControl ) . addClass ( 'semi-checked' ) $ ( targetHeaderControl ) . prop ( 'checked' , false ) if ( containerTypeControl . hasClass ( 'source' ) ) { $ ( addButtonControl ) . addClass ( 'active' ) } if ( containerTypeControl . hasClass ( 'target' ) ) { $ ( inverseButton ) . addClass ( 'active' ) } } return false } else { $ ( targetHeaderControl ) . removeClass ( 'semi-checked' ) if ( containerTypeControl . hasClass ( 'source' ) ) { $ ( addButtonControl ) . removeClass ( 'active' ) } if ( containerTypeControl . hasClass ( 'target' ) ) { $ ( inverseButton ) . removeClass ( 'active' ) } } } ) } 
function sourceControl ( contextControl ) { var tocheck = contextControl . find ( '.transfer-scroll' ) . find ( 'input' ) var checknum = tocheck . length var targetText = contextControl . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = contextControl . find ( '.transfer-header input' ) $ ( header ) . prop ( 'checked' , false ) . removeClass ( 'semi-checked' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) } 
function targetControl ( targetControl ) { var tocheck = targetControl . find ( 'input' ) var checknum = tocheck . length var targetText = tocheck . closest ( '.it-transfer-wrapper' ) . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = $ ( targetControl ) . find ( '.transfer-header input' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) } 
function checkToMove ( contextControl , targetControl ) { var elements = contextControl . find ( '.transfer-group' ) . find ( 'input:checked' ) var sourceTag = $ ( elements ) . closest ( '.form-check' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked' , false ) $ ( sourceTag ) . detach ( ) . appendTo ( targetControl ) . addClass ( 'added' ) } ) } 
function inputNumberResize ( $target ) { var $inputNumber = $target . closest ( '.input-number' ) if ( $inputNumber . hasClass ( 'input-number-adaptive' ) ) { 
function updateScrollPos ( ) { if ( ! stickies . length ) { return } lastKnownScrollTop = document . documentElement . scrollTop || document . body . scrollTop 
function scoreText ( score ) { if ( score === - 1 ) { return options . shortPass } score = score < 0 ? 0 : score if ( score < 26 ) { return options . shortPass } if ( score < 51 ) { return options . badPass } if ( score < 76 ) { return options . goodPass } return options . strongPass } 
function calculateScore ( password ) { var score = 0 
function checkRepetition ( rLen , str ) { var res = '' , repeated = false for ( var i = 0 ; i < str . length ; i ++ ) { repeated = true for ( var j = 0 ; j < rLen && j + i + rLen < str . length ; j ++ ) { repeated = repeated && str . charAt ( j + i ) === str . charAt ( j + i + rLen ) } if ( j < rLen ) { repeated = false } if ( repeated ) { i += rLen - 1 repeated = false } else { res += str . charAt ( i ) } } return res } 
function init ( ) { var shown = true var $text = options . showText var $graybar = $ ( '<div>' ) . addClass ( 'password-meter progress rounded-0 position-absolute' ) $graybar . append ( ` ` ) var $colorbar = $ ( '<div>' ) . attr ( { class : 'progress-bar' , role : 'progressbar' , 'aria-valuenow' : '0' , 'aria-valuemin' : '0' , 'aria-valuemax' : '100' , } ) var $insert = $ ( '<div>' ) . append ( $graybar . append ( $colorbar ) ) if ( options . showText ) { $text = $ ( '<small>' ) . addClass ( 'form-text text-muted' ) . html ( options . enterPass ) $insert . prepend ( $text ) } $object . after ( $insert ) $object . keyup ( function ( ) { var score = calculateScore ( $object . val ( ) ) $object . trigger ( 'password.score' , [ score ] ) var perc = score < 0 ? 0 : score $colorbar . removeClass ( function ( index , className ) { return ( className . match ( / (^|\s)bg-\S+ / g ) || [ ] ) . join ( ' ' ) } ) $colorbar . addClass ( 'bg-' + scoreColor ( score ) ) $colorbar . css ( { width : perc + '%' , } ) $colorbar . attr ( 'aria-valuenow' , perc ) if ( options . showText ) { var text = scoreText ( score ) if ( ! $object . val ( ) . length && score <= 0 ) { text = options . enterPass } if ( $text . html ( ) !== $ ( '<div>' ) . html ( text ) . html ( ) ) { $text . html ( text ) $text . removeClass ( function ( index , className ) { return ( className . match ( / (^|\s)text-\S+ / g ) || [ ] ) . join ( ' ' ) } ) $text . addClass ( 'text-' + scoreColor ( score ) ) $object . trigger ( 'password.text' , [ text , score ] ) } } } ) return this } 
function Log ( data ) { var self = this ; Object . keys ( data ) . forEach ( function ( key ) { self [ key ] = data [ key ] ; } ) ; } 
function ( length , rng ) { var buf = [ ] ; for ( var i = 0 ; i < length ; i ++ ) { buf . push ( rng ( ) * 255 ) ; } return Buffer . from ( buf ) ; } 
function LevelUpArrayAdapter ( name , db , serializer ) { this . db = Sublevel ( db ) ; this . db = this . db . sublevel ( name ) ; this . name = name ; this . serializer = serializer || { encode : function ( val , callback ) { callback ( null , val ) ; } , decode : function ( val , callback ) { callback ( null , val ) ; } } ; } 
function fixProps ( tx , data ) { * @prop {Buffer} from (read/write) Set from address to bypass transaction * signing on fake transactions. */ Object . defineProperty ( tx , "from" , { enumerable : true , configurable : true , get : tx . getSenderAddress . bind ( tx ) , set : ( val ) => { if ( val ) { tx . _from = ethUtil . toBuffer ( val ) ; } else { tx . _from = null ; } } } ) ; if ( data && data . from ) { tx . from = data . from ; } tx . hash = fakeHash ; } } 
function initData ( tx , data ) { if ( data ) { if ( typeof data === "string" ) { data = to . buffer ( data ) ; } if ( Buffer . isBuffer ( data ) ) { data = rlp . decode ( data ) ; } const self = tx ; if ( Array . isArray ( data ) ) { if ( data . length > tx . _fields . length ) { throw new Error ( "wrong number of fields in data" ) ; } 
function TXRejectedError ( message ) { 
function RuntimeError ( transactions , vmOutput ) { 
function ( val ) { if ( typeof val === "string" ) { if ( val . indexOf ( "0x" ) === 0 ) { return val . trim ( ) ; } else { val = new utils . BN ( val ) ; } } if ( typeof val === "boolean" ) { val = val ? 1 : 0 ; } if ( typeof val === "number" ) { val = utils . intToHex ( val ) ; } else if ( val == null ) { return "0x" ; } else if ( typeof val === "object" ) { 
function ( number , done ) { try { number = to . number ( number ) ; } catch ( e ) { 
function RequestFunnel ( ) { 
function compileSass ( _path , ext , data , callback ) { const compiledCss = sass . renderSync ( { data : data , outputStyle : 'expanded' , importer : function ( url , prev , done ) { if ( url . startsWith ( '~' ) ) { const newUrl = path . join ( __dirname , 'node_modules' , url . substr ( 1 ) ) ; return { file : newUrl } ; } else { return { file : url } ; } } } ) ; callback ( null , compiledCss . css ) ; } 
function requireBrocfile ( brocfilePath ) { let brocfile ; if ( brocfilePath . match ( / \.ts$ / ) ) { try { require . resolve ( 'ts-node' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } try { require . resolve ( 'typescript' ) ; } catch ( e ) { throw new Error ( ` ` ) ; } 
function State ( rule , dot , reference , wantedBy ) { this . rule = rule ; this . dot = dot ; this . reference = reference ; this . data = [ ] ; this . wantedBy = wantedBy ; this . isComplete = this . dot === rule . symbols . length ; } 
function runmath ( s ) { var ans ; try { 
function ( readField , result , end ) { end = end || this . length ; while ( this . pos < end ) { var val = this . readVarint ( ) , tag = val >> 3 , startPos = this . pos ; this . type = val & 0x7 ; readField ( tag , result , this ) ; if ( this . pos === startPos ) this . skip ( val ) ; } return result ; } 
function ( ) { var val = readUInt32 ( this . buf , this . pos ) + readUInt32 ( this . buf , this . pos + 4 ) * SHIFT_LEFT_32 ; this . pos += 8 ; return val ; } 
function ( arr , isSigned ) { if ( this . type !== Pbf . Bytes ) return arr . push ( this . readVarint ( isSigned ) ) ; var end = readPackedEnd ( this ) ; arr = arr || [ ] ; while ( this . pos < end ) arr . push ( this . readVarint ( isSigned ) ) ; return arr ; } 
function readUInt32 ( buf , pos ) { return ( ( buf [ pos ] ) | ( buf [ pos + 1 ] << 8 ) | ( buf [ pos + 2 ] << 16 ) ) + ( buf [ pos + 3 ] * 0x1000000 ) ; } 
function stringifyOuterOrder ( orders , q ) { const conditions = [ ] for ( let condition of orders ) { for ( let column in condition . columns ) { const direction = condition . columns [ column ] conditions . push ( ` ${ q ( condition . table ) } ${ q ( column ) } ${ direction } ` ) } } return conditions . join ( ', ' ) } 
function handleUnionSelections ( sqlASTNode , children , selections , gqlType , namespace , depth , options , context , internalOptions = { } ) { for ( let selection of selections ) { 
function handleSelections ( sqlASTNode , children , selections , gqlType , namespace , depth , options , context , internalOptions = { } , ) { for ( let selection of selections ) { 
function columnToASTChild ( columnName , namespace ) { return { type : 'column' , name : columnName , fieldName : columnName , as : namespace . generate ( 'column' , columnName ) } } 
function keyToASTChild ( key , namespace ) { if ( typeof key === 'string' ) { return columnToASTChild ( key , namespace ) } if ( Array . isArray ( key ) ) { const clumsyName = toClumsyName ( key ) return { type : 'composite' , name : key , fieldName : clumsyName , as : namespace . generate ( 'column' , clumsyName ) } } } 
function stripRelayConnection ( gqlType , queryASTNode , fragments ) { 
function spreadFragments ( selections , fragments , typeName ) { return flatMap ( selections , selection => { switch ( selection . kind ) { case 'FragmentSpread' : const fragmentName = selection . name . value const fragment = fragments [ fragmentName ] return spreadFragments ( fragment . selectionSet . selections , fragments , typeName ) case 'InlineFragment' : if ( selection . typeCondition . name . value === typeName ) { return spreadFragments ( selection . selectionSet . selections , fragments , typeName ) } return [ ] default : return selection } } ) } 
async function joinMonster ( resolveInfo , context , dbCall , options = { } ) { 
async function getNode ( typeName , resolveInfo , context , condition , dbCall , options = { } ) { 
async function nextBatchChild ( childAST , data , dbCall , context , options ) { if ( childAST . type !== 'table' && childAST . type !== 'union' ) return const fieldName = childAST . fieldName 
function arrToConnection ( data , sqlAST ) { 
function validate ( rows ) { 
function sortKeyToWhereCondition ( keyObj , descending , sortTable , dialect ) { const { name , quote : q } = dialect const sortColumns = [ ] const sortValues = [ ] for ( let key in keyObj ) { sortColumns . push ( ` ${ q ( sortTable ) } ${ q ( key ) } ` ) sortValues . push ( maybeQuote ( keyObj [ key ] , name ) ) } const operator = descending ? '<' : '>' return name === 'oracle' ? recursiveWhereJoin ( sortColumns , sortValues , operator ) : ` ${ sortColumns . join ( ', ' ) } ${ operator } ${ sortValues . join ( ', ' ) } ` } 
function ( ) { 
function filterByStoreKeys ( storeKeys , obj ) { 
function clone ( frm , to ) { if ( frm === null || typeof frm !== "object" ) { return frm ; } if ( frm . constructor !== Object && frm . constructor !== Array ) { return frm ; } if ( frm . constructor === Date || frm . constructor === RegExp || frm . constructor === Function || frm . constructor === String || frm . constructor === Number || frm . constructor === Boolean ) { return new frm . constructor ( frm ) ; } to = to || new frm . constructor ( ) ; for ( var name in frm ) { to [ name ] = typeof to [ name ] === "undefined" ? clone ( frm [ name ] , null ) : to [ name ] ; } return to ; } 
function ( ) { for ( var m in ListenerMethods ) { if ( this [ m ] !== ListenerMethods [ m ] ) { if ( this [ m ] ) { throw "Can't have other property '" + m + "' when using Reflux.listenTo!" ; } this [ m ] = ListenerMethods [ m ] ; } } this . listenTo ( listenable , callback , initial ) ; } 
function ( ) { for ( var m in ListenerMethods ) { if ( this [ m ] !== ListenerMethods [ m ] ) { if ( this [ m ] ) { throw "Can't have other property '" + m + "' when using Reflux.listenToMany!" ; } this [ m ] = ListenerMethods [ m ] ; } } this . listenToMany ( listenables ) ; } 
function ( data ) { var entries var self = this var input = Object . assign ( { } , data ) 
function ( value ) { var safe = / ^[a-z0-9-_/.@%^=:]+$ / i 
function buildString ( length , str ) { return Array . apply ( null , new Array ( length ) ) . map ( String . prototype . valueOf , str ) . join ( '' ) } 
function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? ',\n' + currentIndent : ', ' if ( pretty ) { return '[\n' + currentIndent + arr . join ( join ) + '\n' + closingBraceIndent + ']' } else { return '[' + arr . join ( join ) + ']' } } 
function ( value , opts , indentLevel ) { indentLevel = indentLevel === undefined ? 1 : indentLevel + 1 switch ( Object . prototype . toString . call ( value ) ) { case '[object Number]' : return value case '[object Array]' : 
function multipart ( handler , done , opts ) { if ( typeof handler !== 'function' ) { throw new Error ( 'handler must be a function' ) } if ( typeof done !== 'function' ) { throw new Error ( 'the callback must be a function' ) } if ( ! this . isMultipart ( ) ) { done ( new Error ( 'the request is not multipart' ) ) return } const log = this . log log . debug ( 'starting multipart parsing' ) const req = this . req const busboyOptions = deepmerge . all ( [ { headers : req . headers } , options || { } , opts || { } ] ) const stream = new Busboy ( busboyOptions ) var completed = false var files = 0 var count = 0 var callDoneOnNextEos = false req . on ( 'error' , function ( err ) { stream . destroy ( ) if ( ! completed ) { completed = true done ( err ) } } ) stream . on ( 'finish' , function ( ) { log . debug ( 'finished multipart parsing' ) if ( ! completed && count === files ) { completed = true setImmediate ( done ) } else { callDoneOnNextEos = true } } ) stream . on ( 'file' , wrap ) req . pipe ( stream ) function wrap ( field , file , filename , encoding , mimetype ) { log . debug ( { field , filename , encoding , mimetype } , 'parsing part' ) files ++ eos ( file , waitForFiles ) handler ( field , file , filename , encoding , mimetype ) } function waitForFiles ( err ) { if ( err ) { completed = true done ( err ) return } if ( completed ) { return } ++ count if ( callDoneOnNextEos && count === files ) { completed = true done ( ) } } return stream } 
function ( text , placeholders ) { if ( text [ text . length - 1 ] == "]" && text . lastIndexOf ( " [" ) != - 1 ) { 
function ( src , successCallback , errorCallback , statusCallback ) { argscheck . checkArgs ( 'SFFF' , 'Media' , arguments ) ; this . id = utils . createUUID ( ) ; mediaObjects [ this . id ] = this ; this . src = src ; this . successCallback = successCallback ; this . errorCallback = errorCallback ; this . statusCallback = statusCallback ; this . _duration = - 1 ; this . _position = - 1 ; try { this . node = createNode ( this ) ; } catch ( err ) { Media . onStatus ( this . id , Media . MEDIA_ERROR , { code : MediaError . MEDIA_ERR_ABORTED } ) ; } } 
function createNode ( media ) { var node = new Audio ( ) ; node . onplay = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_STARTING ) ; } ; node . onplaying = function ( ) { Media . onStatus ( media . id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; node . ondurationchange = function ( e ) { Media . onStatus ( media . id , Media . MEDIA_DURATION , e . target . duration || - 1 ) ; } ; node . onerror = function ( e ) { 
function ( win , lose , args ) { var id = args [ 0 ] ; var srcUri = processUri ( args [ 1 ] ) ; var createAudioNode = ! ! args [ 2 ] ; var thisM = Media . get ( id ) ; Media . prototype . node = null ; var prefix = args [ 1 ] . split ( ':' ) . shift ( ) ; var extension = srcUri . extension ; if ( thisM . node === null ) { if ( SUPPORTED_EXTENSIONS . indexOf ( extension ) === - 1 && SUPPORTED_PREFIXES . indexOf ( prefix ) === - 1 ) { if ( lose ) { lose ( { code : MediaError . MEDIA_ERR_ABORTED } ) ; } return false ; 
function ( win , lose , args ) { var id = args [ 0 ] ; 
function ( win , lose , args ) { var id = args [ 0 ] ; var milliseconds = args [ 1 ] ; var thisM = Media . get ( id ) ; try { thisM . node . currentTime = milliseconds / 1000 ; win ( thisM . node . currentTime ) ; } catch ( err ) { lose ( "Failed to seek: " + err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; try { thisM . node . pause ( ) ; Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_PAUSED ) ; } catch ( err ) { lose ( "Failed to pause: " + err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; try { var p = ( Media . get ( id ) ) . node . currentTime ; win ( p ) ; } catch ( err ) { lose ( err ) ; } } 
function ( win , lose , args ) { var id = args [ 0 ] ; var srcUri = processUri ( args [ 1 ] ) ; var dest = parseUriToPathAndFilename ( srcUri ) ; var destFileName = dest . fileName ; var success = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_RUNNING ) ; } ; var error = function ( reason ) { Media . onStatus ( id , Media . MEDIA_ERROR , reason ) ; } ; 
function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; var srcUri = processUri ( thisM . src ) ; var dest = parseUriToPathAndFilename ( srcUri ) ; var destPath = dest . path ; var destFileName = dest . fileName ; var fsType = dest . fsType ; var success = function ( ) { Media . onStatus ( id , Media . MEDIA_STATE , Media . MEDIA_STOPPED ) ; } ; var error = function ( reason ) { Media . onStatus ( id , Media . MEDIA_ERROR , reason ) ; } ; thisM . mediaCaptureMgr . stopRecordAsync ( ) . done ( function ( ) { if ( fsType === fsTypes . TEMPORARY ) { if ( ! destPath ) { 
function ( win , lose , args ) { var id = args [ 0 ] ; var thisM = Media . get ( id ) ; try { if ( thisM . node ) { thisM . node . onloadedmetadata = null ; 
function setTemporaryFsByDefault ( src ) { var uri ; try { uri = new Windows . Foundation . Uri ( src ) ; } catch ( e ) { if ( e . number === PARAMETER_IS_INCORRECT ) { 
function fullPathToAppData ( uri ) { if ( uri . schemeName === 'file' ) { if ( uri . rawUri . indexOf ( Windows . Storage . ApplicationData . current . localFolder . path ) !== - 1 ) { 
function cdvfileToAppData ( uri ) { var cdvFsRoot ; if ( uri . schemeName === 'cdvfile' ) { cdvFsRoot = uri . path . split ( '/' ) [ 1 ] ; if ( cdvFsRoot === 'temporary' ) { return new Windows . Foundation . Uri ( tempFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else if ( cdvFsRoot === 'persistent' ) { return new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else { throw new Error ( cdvFsRoot + ' cdvfile root is not supported on Windows' ) ; } } return uri ; } 
function processUri ( src ) { 
function parseUriToPathAndFilename ( uri ) { 
function ( src , successCallback , errorCallback , statusCallback ) { argscheck . checkArgs ( 'sFFF' , 'Media' , arguments ) ; this . id = utils . createUUID ( ) ; mediaObjects [ this . id ] = this ; this . src = src ; this . successCallback = successCallback ; this . errorCallback = errorCallback ; this . statusCallback = statusCallback ; this . _duration = - 1 ; this . _position = - 1 ; exec ( null , this . errorCallback , "Media" , "create" , [ this . id , this . src ] ) ; } 
function proj ( location ) { 
function Context ( hook , opts ) { this . hook = hook ; 
function getUniqueCapabilities ( capabilities ) { return capabilities . reduce ( function ( uniqueCaps , currCap ) { var isRepeated = uniqueCaps . some ( function ( cap ) { return getCapabilityName ( cap ) === getCapabilityName ( currCap ) ; } ) ; return isRepeated ? uniqueCaps : uniqueCaps . concat ( [ currCap ] ) ; } , [ ] ) ; } 
function compareCapabilities ( firstCap , secondCap ) { var firstCapName = getCapabilityName ( firstCap ) ; var secondCapName = getCapabilityName ( secondCap ) ; if ( firstCapName < secondCapName ) { return - 1 ; } if ( firstCapName > secondCapName ) { return 1 ; } return 0 ; } 
function generateUapCapabilities ( capabilities ) { function hasCapabilityChange ( change ) { return / ^\s*<(\w+:)?(Device)?Capability\s / . test ( change . xml ) ; } function createPrefixedCapabilityChange ( change ) { if ( CapsNeedUapPrefix . indexOf ( getCapabilityName ( change ) ) < 0 ) { return change ; } 
function removePlatformPluginsJson ( projectRoot , target ) { var plugins_json = path . join ( projectRoot , 'plugins' , target + '.json' ) ; fs . removeSync ( plugins_json ) ; } 
function isCordova ( dir ) { if ( ! dir ) { 
function cdProjectRoot ( ) { const projectRoot = this . getProjectRoot ( ) ; if ( ! origCwd ) { origCwd = process . env . PWD || process . cwd ( ) ; } process . env . PWD = projectRoot ; process . chdir ( projectRoot ) ; return projectRoot ; } 
function fixRelativePath ( value , cwd ) { 
function convertToRealPathSafe ( path ) { if ( path && fs . existsSync ( path ) ) { return fs . realpathSync ( path ) ; } return path ; } 
function deleteSvnFolders ( dir ) { var contents = fs . readdirSync ( dir ) ; contents . forEach ( function ( entry ) { var fullpath = path . join ( dir , entry ) ; if ( isDirectory ( fullpath ) ) { if ( entry === '.svn' ) { fs . removeSync ( fullpath ) ; } else module . exports . deleteSvnFolders ( fullpath ) ; } } ) ; } 
function findPlugins ( pluginDir ) { var plugins = [ ] ; if ( fs . existsSync ( pluginDir ) ) { plugins = fs . readdirSync ( pluginDir ) . filter ( function ( fileName ) { var pluginPath = path . join ( pluginDir , fileName ) ; var isPlugin = isDirectory ( pluginPath ) || isSymbolicLink ( pluginPath ) ; return fileName !== '.svn' && fileName !== 'CVS' && isPlugin ; } ) ; } return plugins ; } 
function getPlatformApiFunction ( dir ) { let PlatformApi ; try { PlatformApi = exports . requireNoCache ( dir ) ; } catch ( err ) { 
function downloadPlatform ( projectRoot , platform , version , opts ) { var target = version ? ( platform + '@' + version ) : platform ; return Promise . resolve ( ) . then ( function ( ) { 
function HooksRunner ( projectRoot ) { var root = cordovaUtil . isCordova ( projectRoot ) ; if ( ! root ) throw new CordovaError ( 'Not a Cordova project ("' + projectRoot + '"), can\'t use hooks.' ) ; else this . projectRoot = root ; } 
function executeEventHandlersSerially ( hook , opts ) { var handlers = events . listeners ( hook ) ; if ( handlers . length ) { 
function runScriptsSerially ( scripts , context ) { if ( scripts . length === 0 ) { events . emit ( 'verbose' , 'No scripts found for hook "' + context . hook + '".' ) ; } return scripts . reduce ( function ( prevScriptPromise , nextScript ) { return prevScriptPromise . then ( function ( ) { return runScript ( nextScript , context ) ; } ) ; } , Promise . resolve ( ) ) ; } 
function extractSheBangInterpreter ( fullpath ) { 
function isHookDisabled ( opts , hook ) { if ( opts === undefined || opts . nohooks === undefined ) { return false ; } var disabledHooks = opts . nohooks ; var length = disabledHooks . length ; for ( var i = 0 ; i < length ; i ++ ) { if ( hook . match ( disabledHooks [ i ] ) !== null ) { return true ; } } return false ; } 
function installPlatformsFromConfigXML ( platforms , opts ) { events . emit ( 'verbose' , 'Checking config.xml and package.json for saved platforms that haven\'t been added to the project' ) ; var projectHome = cordova_util . cdProjectRoot ( ) ; var configPath = cordova_util . projectConfig ( projectHome ) ; var cfg = new ConfigParser ( configPath ) ; var engines = cfg . getEngines ( ) ; var pkgJsonPath = path . join ( projectHome , 'package.json' ) ; var pkgJson ; var pkgJsonPlatforms ; var comboArray = [ ] ; var configPlatforms = [ ] ; var modifiedPkgJson = false ; var mergedPlatformSpecs = { } ; var key ; var installAllPlatforms = ! platforms || platforms . length === 0 ; var file ; var indent ; // Check if path exists and require pkgJsonPath. if ( fs . existsSync ( pkgJsonPath ) ) { pkgJson = require ( pkgJsonPath ) ; file = fs . readFileSync ( pkgJsonPath , 'utf8' ) ; indent = detectIndent ( file ) . indent || ' ' ; } if ( pkgJson !== undefined && pkgJson . cordova !== undefined && pkgJson . cordova . platforms !== undefined ) { pkgJsonPlatforms = pkgJson . cordova . platforms ; } if ( cfg !== undefined ) { if ( pkgJsonPlatforms !== undefined ) { // Combining arrays and checking duplicates. comboArray = pkgJsonPlatforms . slice ( ) ; } engines = cfg . getEngines ( projectHome ) ; // TODO: CB-12592: Eventually refactor out to pacakge manager module. // If package.json doesn't exist, auto-create one. if ( engines . length > 0 && pkgJson === undefined ) { pkgJson = { } ; if ( cfg . packageName ( ) ) { pkgJson . name = cfg . packageName ( ) . toLowerCase ( ) ; } if ( cfg . version ( ) ) { pkgJson . version = cfg . version ( ) ; } if ( cfg . name ( ) ) { pkgJson . displayName = cfg . name ( ) ; } fs . writeFileSync ( pkgJsonPath , JSON . stringify ( pkgJson , null , indent ) , 'utf8' ) ; } configPlatforms = engines . map ( function ( Engine ) { var configPlatName = Engine . name ; 
function installPluginsFromConfigXML ( args ) { events . emit ( 'verbose' , 'Checking for saved plugins that haven\'t been added to the project' ) ; const projectRoot = cordova_util . getProjectRoot ( ) ; const pluginsRoot = path . join ( projectRoot , 'plugins' ) ; const pkgJsonPath = path . join ( projectRoot , 'package.json' ) ; const confXmlPath = cordova_util . projectConfig ( projectRoot ) ; let pkgJson = { } ; let indent = ' ' ; if ( fs . existsSync ( pkgJsonPath ) ) { const fileData = fs . readFileSync ( pkgJsonPath , 'utf8' ) ; indent = detectIndent ( fileData ) . indent ; pkgJson = JSON . parse ( fileData ) ; } pkgJson . devDependencies = pkgJson . devDependencies || { } ; pkgJson . cordova = pkgJson . cordova || { } ; pkgJson . cordova . plugins = pkgJson . cordova . plugins || { } ; const pkgPluginIDs = Object . keys ( pkgJson . cordova . plugins ) ; const pkgSpecs = Object . assign ( { } , pkgJson . dependencies , pkgJson . devDependencies ) ; // Check for plugins listed in config.xml const cfg = new ConfigParser ( confXmlPath ) ; const cfgPluginIDs = cfg . getPluginIdList ( ) ; cfgPluginIDs . forEach ( plID => { // If package.json includes the plugin, we use that config // Otherwise, we need to add the plugin to package.json if ( ! pkgPluginIDs . includes ( plID ) ) { events . emit ( 'info' , ` ${ plID } ` ) ; const cfgPlugin = cfg . getPlugin ( plID ) ; // If config.xml has a spec for the plugin and package.json has not, // add the spec to devDependencies of package.json if ( cfgPlugin . spec && ! ( plID in pkgSpecs ) ) { pkgJson . devDependencies [ plID ] = cfgPlugin . spec ; } pkgJson . cordova . plugins [ plID ] = Object . assign ( { } , cfgPlugin . variables ) ; } } ) ; // Now that plugins have been updated, re-fetch them from package.json const pluginIDs = Object . keys ( pkgJson . cordova . plugins ) ; if ( pluginIDs . length !== pkgPluginIDs . length ) { // We've modified package.json and need to save it fs . outputJsonSync ( pkgJsonPath , pkgJson , { indent : indent , encoding : 'utf8' } ) ; } const specs = Object . assign ( { } , pkgJson . dependencies , pkgJson . devDependencies ) ; const plugins = pluginIDs . map ( plID => ( { name : plID , spec : specs [ plID ] , variables : pkgJson . cordova . plugins [ plID ] || { } } ) ) ; let pluginName = '' ; 
function ( ) { var modulemapper = require ( 'cordova/modulemapper' ) ; var channel = require ( 'cordova/channel' ) ; modulemapper . clobbers ( 'cordova/exec/proxy' , 'cordova.commandProxy' ) ; channel . onNativeReady . fire ( ) ; document . addEventListener ( "visibilitychange" , function ( ) { if ( document . hidden ) { channel . onPause . fire ( ) ; } else { channel . onResume . fire ( ) ; } } ) ; 
function absolutePathHandler ( request , response , next ) { if ( ! request . headers . referer ) return next ( ) ; 
function ( hook , opts ) { 
function getApplicationHookScripts ( hook , opts ) { 
function getPluginsHookScripts ( hook , opts ) { 
function getApplicationHookScriptsFromDir ( dir ) { if ( ! ( fs . existsSync ( dir ) ) ) { return [ ] ; } var compareNumbers = function ( a , b ) { 
function getScriptsFromConfigXml ( hook , opts ) { var configPath = cordovaUtil . projectConfig ( opts . projectRoot ) ; var configXml = new ConfigParser ( configPath ) ; return configXml . getHookScripts ( hook , opts . cordova . platforms ) . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( opts . projectRoot , scriptElement . attrib . src ) } ; } ) ; } 
function getPluginScriptFiles ( plugin , hook , platforms ) { var scriptElements = plugin . pluginInfo . getHookScripts ( hook , platforms ) ; return scriptElements . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( plugin . dir , scriptElement . attrib . src ) , plugin : plugin } ; } ) ; } 
function getAllPluginsHookScriptFiles ( hook , opts ) { var scripts = [ ] ; var currentPluginOptions ; var plugins = ( new PluginInfoProvider ( ) ) . getAllWithinSearchPath ( path . join ( opts . projectRoot , 'plugins' ) ) ; plugins . forEach ( function ( pluginInfo ) { currentPluginOptions = { id : pluginInfo . id , pluginInfo : pluginInfo , dir : pluginInfo . dir } ; scripts = scripts . concat ( getPluginScriptFiles ( currentPluginOptions , hook , opts . cordova . platforms ) ) ; } ) ; return scripts ; } 
function AppxManifest ( path , prefix ) { this . path = path ; 
function ensureUapPrefixedCapabilities ( capabilities ) { capabilities . getchildren ( ) . forEach ( function ( el ) { if ( CAPS_NEEDING_UAPNS . indexOf ( el . attrib . Name ) > - 1 && el . tag . indexOf ( 'uap:' ) !== 0 ) { el . tag = 'uap:' + el . tag ; } } ) ; } 
function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . remove ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; } 
function mergeVariables ( pluginInfo , cfg , opts ) { 
function copyNewFile ( plugin_dir , src , project_dir , dest , link ) { var target_path = path . resolve ( project_dir , dest ) ; if ( fs . existsSync ( target_path ) ) throw new CordovaError ( '"' + target_path + '" already exists!' ) ; copyFile ( plugin_dir , src , project_dir , dest , ! ! link ) ; } 
function PluginSpec ( raw , scope , id , version ) { this . scope = scope || null ; this . id = id || raw ; this . version = version || null ; this . package = ( scope ? scope + id : id ) || null ; } 
function parse ( raw ) { var split = NPM_SPEC_REGEX . exec ( raw ) ; if ( split ) { return new PluginSpec ( raw , split [ 1 ] , split [ 2 ] , split [ 3 ] ) ; } return new PluginSpec ( raw ) ; } 
function getPluginFilePath ( plugin , pluginFile , targetDir ) { var src = path . resolve ( plugin . dir , pluginFile ) ; return '$(ProjectDir)' + path . relative ( targetDir , src ) ; } 
function Q_chainmap ( args , func ) { return Promise . resolve ( ) . then ( function ( inValue ) { return args . reduce ( function ( soFar , arg ) { return soFar . then ( function ( val ) { return func ( arg , val ) ; } ) ; } , Promise . resolve ( inValue ) ) ; } ) ; } 
function platform ( command , targets , opts ) { 
function ( result , callbackOptions ) { callbackOptions = callbackOptions || { } ; var callbackStatus ; 
function getPlatforms ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; 
function getPlugins ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; 
function getPlatformApi ( platform , platformRootDir ) { 
function ( plugin_id , plugins_dir , platformJson , pluginInfoProvider ) { var depsInfo ; if ( typeof plugins_dir === 'object' ) { depsInfo = plugins_dir ; } else { depsInfo = pkg . generateDependencyInfo ( platformJson , plugins_dir , pluginInfoProvider ) ; } var graph = depsInfo . graph ; var tlps = depsInfo . top_level_plugins ; var dependents = tlps . filter ( function ( tlp ) { return tlp !== plugin_id && graph . getChain ( tlp ) . indexOf ( plugin_id ) >= 0 ; } ) ; return dependents ; } 
function ( plugin_id , plugins_dir , platformJson , pluginInfoProvider ) { var depsInfo ; if ( typeof plugins_dir === 'object' ) { depsInfo = plugins_dir ; } else { depsInfo = pkg . generateDependencyInfo ( platformJson , plugins_dir , pluginInfoProvider ) ; } var graph = depsInfo . graph ; var dependencies = graph . getChain ( plugin_id ) ; var tlps = depsInfo . top_level_plugins ; var diff_arr = [ ] ; tlps . forEach ( function ( tlp ) { if ( tlp !== plugin_id ) { diff_arr . push ( graph . getChain ( tlp ) ) ; } } ) ; 
function createReplacement ( manifestFile , originalChange ) { var replacement = { target : manifestFile , parent : originalChange . parent , after : originalChange . after , xmls : originalChange . xmls , versions : originalChange . versions , deviceTarget : originalChange . deviceTarget } ; return replacement ; } 
function PluginInfo ( dirname ) { 
function checkID ( expectedIdAndVersion , pinfo ) { if ( ! expectedIdAndVersion ) return ; var parsedSpec = pluginSpec . parse ( expectedIdAndVersion ) ; if ( parsedSpec . id !== pinfo . id ) { throw new Error ( 'Expected plugin to have ID "' + parsedSpec . id + '" but got "' + pinfo . id + '".' ) ; } if ( parsedSpec . version && ! semver . satisfies ( pinfo . version , parsedSpec . version ) ) { throw new Error ( 'Expected plugin ' + pinfo . id + ' to satisfy version "' + parsedSpec . version + '" but got "' + pinfo . version + '".' ) ; } } 
function findLocalPlugin ( plugin_src , searchpath , pluginInfoProvider ) { loadLocalPlugins ( searchpath , pluginInfoProvider ) ; var parsedSpec = pluginSpec . parse ( plugin_src ) ; var versionspec = parsedSpec . version || '*' ; var latest = null ; var versions = localPlugins . plugins [ parsedSpec . id ] ; if ( ! versions ) return null ; versions . forEach ( function ( pinfo ) { 
function copyPlugin ( pinfo , plugins_dir , link ) { var plugin_dir = pinfo . dir ; var dest = path . join ( plugins_dir , pinfo . id ) ; fs . removeSync ( dest ) ; if ( ! link && dest . indexOf ( path . resolve ( plugin_dir ) + path . sep ) === 0 ) { events . emit ( 'verbose' , 'Copy plugin destination is child of src. Forcing --link mode.' ) ; link = true ; } if ( link ) { var isRelativePath = plugin_dir . charAt ( 1 ) !== ':' && plugin_dir . charAt ( 0 ) !== path . sep ; var fixedPath = isRelativePath ? path . join ( path . relative ( plugins_dir , process . env . PWD || process . cwd ( ) ) , plugin_dir ) : plugin_dir ; events . emit ( 'verbose' , 'Linking "' + dest + '" => "' + fixedPath + '"' ) ; fs . symlinkSync ( fixedPath , dest , 'junction' ) ; } else { events . emit ( 'verbose' , 'Copying plugin "' + plugin_dir + '" => "' + dest + '"' ) ; fs . copySync ( plugin_dir , dest , { dereference : true } ) ; } return dest ; } 
function ( id ) { var plugin_dir = path . join ( plugins_dir , id ) ; if ( ! fs . existsSync ( plugin_dir ) ) { events . emit ( 'verbose' , 'Plugin "' + id + '" already removed (' + plugin_dir + ')' ) ; return Promise . resolve ( ) ; } fs . removeSync ( plugin_dir ) ; events . emit ( 'verbose' , 'Deleted plugin "' + id + '"' ) ; 
function runUninstallPlatform ( actions , platform , project_dir , plugin_dir , plugins_dir , options ) { var pluginInfoProvider = options . pluginInfoProvider ; 
function handleUninstall ( actions , platform , pluginInfo , project_dir , www_dir , plugins_dir , is_top_level , options ) { events . emit ( 'log' , 'Uninstalling ' + pluginInfo . id + ' from ' + platform ) ; 
function getPlatformDetailsFromDir ( dir , platformIfKnown ) { var libDir = path . resolve ( dir ) ; var platform ; var version ; 
function platformFromName ( name ) { var platName = name ; var platMatch = / ^cordova-([a-z0-9-]+)$ / . exec ( name ) ; if ( platMatch && ( platMatch [ 1 ] in platforms ) ) { platName = platMatch [ 1 ] ; events . emit ( 'verbose' , 'Removing "cordova-" prefix from ' + name ) ; } return platName ; } 
function processMessage ( message ) { var firstChar = message . charAt ( 0 ) ; if ( firstChar == 'J' ) { 
function possiblyFetch ( id , plugins_dir , options ) { var parsedSpec = pluginSpec . parse ( id ) ; 
function callEngineScripts ( engines , project_dir ) { return Promise . all ( engines . map ( function ( engine ) { 
function copyPlugin ( plugin_src_dir , plugins_dir , link , pluginInfoProvider ) { var pluginInfo = new PluginInfo ( plugin_src_dir ) ; var dest = path . join ( plugins_dir , pluginInfo . id ) ; if ( link ) { events . emit ( 'verbose' , 'Symlinking from location "' + plugin_src_dir + '" to location "' + dest + '"' ) ; fs . removeSync ( dest ) ; fs . ensureSymlinkSync ( plugin_src_dir , dest , 'junction' ) ; } else { events . emit ( 'verbose' , 'Copying from location "' + plugin_src_dir + '" to location "' + dest + '"' ) ; fs . copySync ( plugin_src_dir , dest ) ; } pluginInfo . dir = dest ; pluginInfoProvider . put ( pluginInfo ) ; return dest ; } 
function Api ( platform , platformRootDir , events ) { this . platform = PLATFORM ; this . root = path . resolve ( __dirname , '..' ) ; setupEvents ( events ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'assets/www' ) , res : path . join ( self . root , 'res' ) , platformWww : path . join ( self . root , 'platform_www' ) , configXml : path . join ( self . root , 'res/xml/config.xml' ) , defaultConfigXml : path . join ( self . root , 'cordova/defaults.xml' ) , strings : path . join ( self . root , 'res/values/strings.xml' ) , manifest : path . join ( self . root , 'AndroidManifest.xml' ) , build : path . join ( self . root , 'build' ) , 
function createPackageJson ( plugin_path ) { var pluginInfo = new PluginInfo ( plugin_path ) ; var defaults = { id : pluginInfo . id , version : pluginInfo . version , description : pluginInfo . description , license : pluginInfo . license , keywords : pluginInfo . getKeywordsAndPlatforms ( ) , repository : pluginInfo . repo , engines : pluginInfo . getEngines ( ) , platforms : pluginInfo . getPlatformsArray ( ) } ; var initFile = require . resolve ( './init-defaults' ) ; return initPkgJson ( plugin_path , initFile , defaults ) . then ( _ => { events . emit ( 'verbose' , 'Package.json successfully created' ) ; } ) ; } 
function preparePlatforms ( platformList , projectRoot , options ) { return Promise . all ( platformList . map ( function ( platform ) { 
function Api ( platform , platformRootDir , eventEmitter ) { this . platform = PLATFORM ; this . root = path . resolve ( __dirname , '..' ) ; setupEvents ( eventEmitter ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'www' ) , platformWww : path . join ( self . root , 'platform_www' ) , configXml : path . join ( self . root , 'config.xml' ) , defaultConfigXml : path . join ( self . root , 'cordova/defaults.xml' ) , 
function mergeVariables ( plugin_dir , platform , options ) { options . pluginInfoProvider = options . pluginInfoProvider || new PluginInfoProvider ( ) ; var pluginInfoProvider = options . pluginInfoProvider ; var pluginInfo = pluginInfoProvider . get ( plugin_dir ) ; var filtered_variables = { } ; var prefs = pluginInfo . getPreferences ( platform ) ; var keys = underscore . keys ( prefs ) ; options . cli_variables = options . cli_variables || { } ; var missing_vars = underscore . difference ( keys , Object . keys ( options . cli_variables ) ) ; underscore . each ( missing_vars , function ( _key ) { var def = prefs [ _key ] ; if ( def ) { options . cli_variables [ _key ] = def ; } } ) ; 
function default_versionCode ( version ) { var nums = version . split ( '-' ) [ 0 ] . split ( '.' ) ; var versionCode = 0 ; if ( + nums [ 0 ] ) { versionCode += + nums [ 0 ] * 10000 ; } if ( + nums [ 1 ] ) { versionCode += + nums [ 1 ] * 100 ; } if ( + nums [ 2 ] ) { versionCode += + nums [ 2 ] ; } events . emit ( 'verbose' , 'android-versionCode not found in config.xml. Generating a code based on version in config.xml (' + version + '): ' + versionCode ) ; return versionCode ; } 
function ( icon , icon_size ) { 
function mapImageResources ( rootDir , subDir , type , resourceName ) { var pathMap = { } ; shell . ls ( path . join ( rootDir , subDir , type + '-*' ) ) . forEach ( function ( drawableFolder ) { var imagePath = path . join ( subDir , path . basename ( drawableFolder ) , resourceName ) ; pathMap [ imagePath ] = null ; } ) ; return pathMap ; } 
function findAndroidLaunchModePreference ( platformConfig ) { var launchMode = platformConfig . getPreference ( 'AndroidLaunchMode' ) ; if ( ! launchMode ) { 
function AndroidManifest ( path ) { this . path = path ; this . doc = xml . parseElementtreeSync ( path ) ; if ( this . doc . getroot ( ) . tag !== 'manifest' ) { throw new Error ( 'AndroidManifest at ' + path + ' has incorrect root node name (expected "manifest")' ) ; } } 
function expectUnmetRequirements ( expected ) { const actual = unmetRequirementsCollector . store ; expect ( actual ) . toEqual ( jasmine . arrayWithExactContents ( expected ) ) ; } 
function getFetchVersion ( projectRoot , pluginInfo , cordovaVersion ) { 
function determinePluginVersionToFetch ( pluginInfo , pluginMap , platformMap , cordovaVersion ) { var allVersions = pluginInfo . versions ; var engine = pluginInfo . engines . cordovaDependencies ; var name = pluginInfo . name ; 
function getFailedRequirements ( reqs , pluginMap , platformMap , cordovaVersion ) { var failed = [ ] ; var version = cordovaVersion ; if ( semver . prerelease ( version ) ) { 
function findVersion ( versions , version ) { var cleanedVersion = semver . clean ( version ) ; for ( var i = 0 ; i < versions . length ; i ++ ) { if ( semver . clean ( versions [ i ] ) === cleanedVersion ) { return versions [ i ] ; } } return null ; } 
function listUnmetRequirements ( name , failedRequirements ) { events . emit ( 'warn' , 'Unmet project requirements for latest version of ' + name + ':' ) ; failedRequirements . forEach ( function ( req ) { events . emit ( 'warn' , ' ' + req . dependency + ' (' + req . installed + ' in project, ' + req . required + ' required)' ) ; } ) ; } 
function utilExec ( cmdLine ) { var defer = Q . defer ( ) ; shell . exec ( cmdLine , function ( code , output ) { defer . resolve ( { code : code , output : output } ) ; } ) ; return defer . promise ; } 
function ( folderName , task ) { var defer = Q . defer ( ) ; var vn = ( task . name || folderName ) ; if ( ! task . id || ! check . isUUID ( task . id ) ) { defer . reject ( createError ( vn + ': id is a required guid' ) ) ; } ; if ( ! task . name || ! check . isAlphanumeric ( task . name ) ) { defer . reject ( createError ( vn + ': name is a required alphanumeric string' ) ) ; } if ( ! task . friendlyName || ! check . isLength ( task . friendlyName , 1 , 40 ) ) { defer . reject ( createError ( vn + ': friendlyName is a required string <= 40 chars' ) ) ; } if ( ! task . instanceNameFormat ) { defer . reject ( createError ( vn + ': instanceNameFormat is required' ) ) ; } // resolve if not already rejected defer . resolve ( ) ; return defer . promise ; } 
function setResult ( result , message ) { debug ( 'task result: ' + TaskResult [ result ] ) ; command ( 'task.complete' , { 'result' : TaskResult [ result ] } , message ) ; if ( result == TaskResult . Failed ) { _writeError ( message ) ; } if ( result == TaskResult . Failed ) { process . exit ( 0 ) ; } } 
function getVariable ( name ) { var varval = process . env [ name . replace ( / \. / g , '_' ) . toUpperCase ( ) ] ; debug ( name + '=' + varval ) ; var mocked = mock . getResponse ( 'getVariable' , name ) ; return mocked || varval ; } 
function getDelimitedInput ( name , delim , required ) { var inval = getInput ( name , required ) ; if ( ! inval ) { return [ ] ; } return inval . split ( delim ) ; } 
function getEndpointUrl ( id , optional ) { var urlval = getVariable ( 'ENDPOINT_URL_' + id ) ; debug ( id + '=' + urlval ) ; if ( ! optional && ! urlval ) { _writeError ( 'Endpoint not present: ' + id ) ; exit ( 1 ) ; } return urlval ; } 
function command ( command , properties , message ) { var taskCmd = new tcm . TaskCommand ( command , properties , message ) ; _writeLine ( taskCmd . toString ( ) ) ; } 
function checkPath ( p , name ) { debug ( 'check path : ' + p ) ; if ( ! p || ! mock . getResponse ( 'checkPath' , p ) ) { setResult ( TaskResult . Failed , 'not found ' + name + ': ' + p ) ; 
function exec ( tool , args , options ) { var toolPath = which ( tool , true ) ; var tr = createToolRunner ( toolPath ) ; if ( args ) { tr . arg ( args ) ; } return tr . exec ( options ) ; } 
function matchesRange ( cardNumber , min , max ) { var maxLengthToCheck = String ( min ) . length ; var substr = cardNumber . substr ( 0 , maxLengthToCheck ) ; var integerRepresentationOfCardNumber = parseInt ( substr , 10 ) ; min = parseInt ( String ( min ) . substr ( 0 , substr . length ) , 10 ) ; max = parseInt ( String ( max ) . substr ( 0 , substr . length ) , 10 ) ; return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max ; } 
function ( files , packageFilename ) { const convertedFiles = _ . flatten ( Object . keys ( files ) . map ( key => { if ( files [ key ] === true ) return key else return files [ key ] } ) ) const hasPackageLock = _ . includes ( convertedFiles , packageFilename . replace ( 'package.json' , 'package-lock.json' ) ) if ( hasPackageLock ) return packageFilename . replace ( 'package.json' , 'package-lock.json' ) const hasYarnLock = _ . includes ( convertedFiles , packageFilename . replace ( 'package.json' , 'yarn.lock' ) ) if ( hasYarnLock ) return packageFilename . replace ( 'package.json' , 'yarn.lock' ) return null } 
function ( version , newVersion , newCodeName , versionOnly = false ) { let matches = [ ` ${ newCodeName } ` , newCodeName , newVersion ] 
function ( existingVersionStrings , newVersion , newCodeName , versionOnly = false ) { if ( ! existingVersionStrings || existingVersionStrings . length === 0 ) return - 1 return existingVersionStrings . findIndex ( ( version ) => { return hasNodeVersion ( version , newVersion , newCodeName , versionOnly ) } ) } 
function ( travisYML , newVersion , newCodeName , existingVersions ) { 
function ( travisYML , newVersion , newCodeName , existingVersions ) { 
function hasVersionComment ( issue , version ) { if ( ! issue . version && ! issue . comments ) { log . error ( 'no version information on issue document' , { issue } ) return false } return issue . version === version || ( issue . comments && issue . comments . includes ( version ) ) } 
async function updateRepoDoc ( { installationId , doc , filePaths , log } ) { const fullName = doc . fullName const oldGreenkeeperConfig = doc . greenkeeper 
async function discoverPackageFiles ( { installationId , fullName , defaultBranch , log } ) { const ghqueue = githubQueue ( installationId ) const relevantPackageFilePaths = await discoverPackageFilePaths ( { installationId , fullName , defaultBranch , log } ) const [ owner , repo ] = fullName . split ( '/' ) 
async function discoverPackageFilePaths ( { installationId , fullName , defaultBranch , log } ) { 
function hasLockFileText ( files ) { if ( ! files ) return const lockFiles = [ 'package-lock.json' , 'npm-shrinkwrap.json' , 'yarn.lock' ] . filter ( ( key ) => { if ( _ . isArray ( files [ key ] ) && files [ key ] . length ) { return true } if ( files [ key ] === true ) { return true } return false } ) if ( lockFiles . length === 0 ) return if ( lockFiles . includes ( 'npm-shrinkwrap.json' ) ) { return md ` .c od e ('np m -shrinkwrap.json')} f i l } const lockFile = lockFiles [ 0 ] return md ` d. co d e(lo c kFile)} f i } 
function travisTransform ( travisYML ) { try { var travisJSON = yaml . safeLoad ( travisYML , { schema : yaml . FAILSAFE_SCHEMA } ) } catch ( e ) { 
function getGroupForPackageFile ( groups , packageFilePath ) { return Object . keys ( groups ) . find ( ( group ) => { return groups [ group ] . packages && groups [ group ] . packages . includes ( packageFilePath ) } ) } 
function isDependencyIgnoredInGroups ( groups , packageFilePath , dependencyName ) { const groupName = getGroupForPackageFile ( groups , packageFilePath ) return groupName && _ . includes ( groups [ groupName ] . ignore , dependencyName ) } 
function getDependencyURL ( { repositoryURL , dependency } ) { 
function getDependenciesFromPackageFiles ( packagePaths , packageJsonContents ) { return _ . compact ( _ . uniqWith ( _ . flatten ( packagePaths . map ( path => { return _ . flatten ( [ 'dependencies' , 'devDependencies' , 'optionalDependencies' ] . map ( type => { if ( packageJsonContents [ path ] ) { return _ . map ( packageJsonContents [ path ] [ type ] , ( version , name ) => ( { name , version , type } ) ) } } ) ) } ) ) , _ . isEqual ) ) } 
async function addNPMPackageData ( dependencyInfo , registryGet , log ) { return Promise . mapSeries ( dependencyInfo , async dep => { try { dep . data = await registryGet ( registryUrl + dep . name . replace ( '/' , '%2F' ) , { } ) return dep } catch ( err ) { log . error ( 'npm: Could not get package data' , { dependency : dep , error : err } ) } } ) } 
async function getUpdatedDependenciesForFiles ( { packagePaths , packageJsonContents , registryGet , ignore , log } ) { const dependencyInfo = module . exports . getDependenciesFromPackageFiles ( packagePaths , packageJsonContents , log ) 
function checkForData ( ) { ph . windowProperty ( "DATA" ) . then ( function ( data ) { if ( data !== undefined ) { writeToFile ( data ) ; ph . exit ( ) ; } else { setTimeout ( checkForData , 100 ) ; } } ) ; } 
function extractApis ( services ) { var filterTypes = arguments . length <= 1 || arguments [ 1 ] === undefined ? [ ] : arguments [ 1 ] ; services = Array . isArray ( services ) ? services : [ services ] ; var apis = services . reduce ( function ( total , service ) { var obj = service . constructor === Object ? service : Object . getPrototypeOf ( service ) ; var keys = aggregateApisByType ( obj , total , filterTypes ) ; total . push . apply ( total , keys ) ; return total ; } , [ ] ) ; return apis ; } 
function SearchResults ( state , results ) { var mainSubResponse = results [ 0 ] ; this . _rawResults = results ; this . query = mainSubResponse . query ; this . parsedQuery = mainSubResponse . parsedQuery ; this . hits = mainSubResponse . hits ; this . index = mainSubResponse . index ; this . hitsPerPage = mainSubResponse . hitsPerPage ; this . nbHits = mainSubResponse . nbHits ; this . nbPages = mainSubResponse . nbPages ; this . page = mainSubResponse . page ; this . processingTimeMS = sumBy ( results , 'processingTimeMS' ) ; this . aroundLatLng = mainSubResponse . aroundLatLng ; this . automaticRadius = mainSubResponse . automaticRadius ; this . serverUsed = mainSubResponse . serverUsed ; this . timeoutCounts = mainSubResponse . timeoutCounts ; this . timeoutHits = mainSubResponse . timeoutHits ; this . exhaustiveFacetsCount = mainSubResponse . exhaustiveFacetsCount ; this . exhaustiveNbHits = mainSubResponse . exhaustiveNbHits ; this . userData = mainSubResponse . userData ; this . queryID = mainSubResponse . queryID ; this . disjunctiveFacets = [ ] ; this . hierarchicalFacets = map ( state . hierarchicalFacets , function initFutureTree ( ) { return [ ] ; } ) ; this . facets = [ ] ; var disjunctiveFacets = state . getRefinedDisjunctiveFacets ( ) ; var facetsIndices = getIndices ( state . facets ) ; var disjunctiveFacetsIndices = getIndices ( state . disjunctiveFacets ) ; var nextDisjunctiveResult = 1 ; var self = this ; 
function extractNormalizedFacetValues ( results , attribute ) { var predicate = { name : attribute } ; if ( results . _state . isConjunctiveFacet ( attribute ) ) { var facet = find ( results . facets , predicate ) ; if ( ! facet ) return [ ] ; return map ( facet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isFacetRefined ( attribute , k ) , isExcluded : results . _state . isExcludeRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isDisjunctiveFacet ( attribute ) ) { var disjunctiveFacet = find ( results . disjunctiveFacets , predicate ) ; if ( ! disjunctiveFacet ) return [ ] ; return map ( disjunctiveFacet . data , function ( v , k ) { return { name : k , count : v , isRefined : results . _state . isDisjunctiveFacetRefined ( attribute , k ) } ; } ) ; } else if ( results . _state . isHierarchicalFacet ( attribute ) ) { return find ( results . hierarchicalFacets , predicate ) ; } } 
function recSort ( sortFn , node ) { if ( ! node . data || node . data . length === 0 ) { return node ; } var children = map ( node . data , partial ( recSort , sortFn ) ) ; var sortedChildren = sortFn ( children ) ; var newNode = merge ( { } , node , { data : sortedChildren } ) ; return newNode ; } 
function SearchParameters ( newParameters ) { var params = newParameters ? SearchParameters . _parseNumbers ( newParameters ) : { } ; this . index = params . index || '' ; * Query string of the instant search. The empty string is a valid query. * @member {string} * @see https: */ this . query = params . query || '' ; * This attribute contains the list of all the conjunctive facets * used. This list will be added to requested facets in the * [facets attribute](https: * @member {string[]} */ this . facets = params . facets || [ ] ; this . disjunctiveFacets = params . disjunctiveFacets || [ ] ; this . hierarchicalFacets = params . hierarchicalFacets || [ ] ; * This attribute contains all the filters that need to be * applied on the conjunctive facets. Each facet must be properly * defined in the `facets` attribute. * * The key is the name of the facet, and the `FacetList` contains all * filters selected for the associated facet name. * * When querying algolia, the values stored in this attribute will * be translated into the `facetFilters` attribute. * @member {Object.<string, SearchParameters.FacetList>} */ this . facetsRefinements = params . facetsRefinements || { } ; this . facetsExcludes = params . facetsExcludes || { } ; this . disjunctiveFacetsRefinements = params . disjunctiveFacetsRefinements || { } ; this . numericRefinements = params . numericRefinements || { } ; this . tagRefinements = params . tagRefinements || [ ] ; this . hierarchicalFacetsRefinements = params . hierarchicalFacetsRefinements || { } ; this . numericFilters = params . numericFilters ; this . tagFilters = params . tagFilters ; this . optionalTagFilters = params . optionalTagFilters ; this . optionalFacetFilters = params . optionalFacetFilters ; * Number of hits to be returned by the search API * @member {number} * @see https: */ this . hitsPerPage = params . hitsPerPage ; this . maxValuesPerFacet = params . maxValuesPerFacet ; this . page = params . page || 0 ; this . queryType = params . queryType ; this . typoTolerance = params . typoTolerance ; this . minWordSizefor1Typo = params . minWordSizefor1Typo ; this . minWordSizefor2Typos = params . minWordSizefor2Typos ; this . minProximity = params . minProximity ; this . allowTyposOnNumericTokens = params . allowTyposOnNumericTokens ; this . ignorePlurals = params . ignorePlurals ; this . restrictSearchableAttributes = params . restrictSearchableAttributes ; this . advancedSyntax = params . advancedSyntax ; this . analytics = params . analytics ; this . analyticsTags = params . analyticsTags ; this . synonyms = params . synonyms ; this . replaceSynonymsInHighlight = params . replaceSynonymsInHighlight ; this . optionalWords = params . optionalWords ; this . removeWordsIfNoResults = params . removeWordsIfNoResults ; this . attributesToRetrieve = params . attributesToRetrieve ; this . attributesToHighlight = params . attributesToHighlight ; this . highlightPreTag = params . highlightPreTag ; this . highlightPostTag = params . highlightPostTag ; this . attributesToSnippet = params . attributesToSnippet ; this . getRankingInfo = params . getRankingInfo ; this . distinct = params . distinct ; this . aroundLatLng = params . aroundLatLng ; this . aroundLatLngViaIP = params . aroundLatLngViaIP ; this . aroundRadius = params . aroundRadius ; this . minimumAroundRadius = params . minimumAroundRadius ; this . aroundPrecision = params . aroundPrecision ; this . insideBoundingBox = params . insideBoundingBox ; this . insidePolygon = params . insidePolygon ; this . snippetEllipsisText = params . snippetEllipsisText ; this . disableExactOnAttributes = params . disableExactOnAttributes ; this . enableExactOnSingleWordQuery = params . enableExactOnSingleWordQuery ; 
function clearRefinements ( attribute ) { var clear = RefinementList . clearRefinement ; var patch = { numericRefinements : this . _clearNumericRefinements ( attribute ) , facetsRefinements : clear ( this . facetsRefinements , attribute , 'conjunctiveFacet' ) , facetsExcludes : clear ( this . facetsExcludes , attribute , 'exclude' ) , disjunctiveFacetsRefinements : clear ( this . disjunctiveFacetsRefinements , attribute , 'disjunctiveFacet' ) , hierarchicalFacetsRefinements : clear ( this . hierarchicalFacetsRefinements , attribute , 'hierarchicalFacet' ) } ; if ( patch . numericRefinements === this . numericRefinements && patch . facetsRefinements === this . facetsRefinements && patch . facetsExcludes === this . facetsExcludes && patch . disjunctiveFacetsRefinements === this . disjunctiveFacetsRefinements && patch . hierarchicalFacetsRefinements === this . hierarchicalFacetsRefinements ) { return this ; } return this . setQueryParameters ( patch ) ; } 
function ( attribute , operator , v ) { var value = valToNumber ( v ) ; if ( this . isNumericRefined ( attribute , operator , value ) ) return this ; var mod = merge ( { } , this . numericRefinements ) ; mod [ attribute ] = merge ( { } , mod [ attribute ] ) ; if ( mod [ attribute ] [ operator ] ) { 
function ( attribute , operator , paramValue ) { if ( paramValue !== undefined ) { var paramValueAsNumber = valToNumber ( paramValue ) ; if ( ! this . isNumericRefined ( attribute , operator , paramValueAsNumber ) ) return this ; return this . setQueryParameters ( { numericRefinements : this . _clearNumericRefinements ( function ( value , key ) { return key === attribute && value . op === operator && isEqual ( value . val , paramValueAsNumber ) ; } ) } ) ; } else if ( operator !== undefined ) { if ( ! this . isNumericRefined ( attribute , operator ) ) return this ; return this . setQueryParameters ( { numericRefinements : this . _clearNumericRefinements ( function ( value , key ) { return key === attribute && value . op === operator ; } ) } ) ; } if ( ! this . isNumericRefined ( attribute ) ) return this ; return this . setQueryParameters ( { numericRefinements : this . _clearNumericRefinements ( function ( value , key ) { return key === attribute ; } ) } ) ; } 
function _clearNumericRefinements ( attribute ) { if ( isUndefined ( attribute ) ) { if ( isEmpty ( this . numericRefinements ) ) return this . numericRefinements ; return { } ; } else if ( isString ( attribute ) ) { if ( isEmpty ( this . numericRefinements [ attribute ] ) ) return this . numericRefinements ; return omit ( this . numericRefinements , attribute ) ; } else if ( isFunction ( attribute ) ) { var hasChanged = false ; var newNumericRefinements = reduce ( this . numericRefinements , function ( memo , operators , key ) { var operatorList = { } ; forEach ( operators , function ( values , operator ) { var outValues = [ ] ; forEach ( values , function ( value ) { var predicateResult = attribute ( { val : value , op : operator } , key , 'numeric' ) ; if ( ! predicateResult ) outValues . push ( value ) ; } ) ; if ( ! isEmpty ( outValues ) ) { if ( outValues . length !== values . length ) hasChanged = true ; operatorList [ operator ] = outValues ; } else hasChanged = true ; } ) ; if ( ! isEmpty ( operatorList ) ) memo [ key ] = operatorList ; return memo ; } , { } ) ; if ( hasChanged ) return newNumericRefinements ; return this . numericRefinements ; } } 
function addHierarchicalFacet ( hierarchicalFacet ) { if ( this . isHierarchicalFacet ( hierarchicalFacet . name ) ) { throw new Error ( 'Cannot declare two hierarchical facets with the same name: `' + hierarchicalFacet . name + '`' ) ; } return this . setQueryParameters ( { hierarchicalFacets : this . hierarchicalFacets . concat ( [ hierarchicalFacet ] ) } ) ; } 
function addFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . facetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { facetsRefinements : RefinementList . addRefinement ( this . facetsRefinements , facet , value ) } ) ; } 
function addExcludeRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . facetsExcludes , facet , value ) ) return this ; return this . setQueryParameters ( { facetsExcludes : RefinementList . addRefinement ( this . facetsExcludes , facet , value ) } ) ; } 
function addDisjunctiveFacetRefinement ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } if ( RefinementList . isRefined ( this . disjunctiveFacetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { disjunctiveFacetsRefinements : RefinementList . addRefinement ( this . disjunctiveFacetsRefinements , facet , value ) } ) ; } 
function addTagRefinement ( tag ) { if ( this . isTagRefined ( tag ) ) return this ; var modification = { tagRefinements : this . tagRefinements . concat ( tag ) } ; return this . setQueryParameters ( modification ) ; } 
function removeFacet ( facet ) { if ( ! this . isConjunctiveFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { facets : filter ( this . facets , function ( f ) { return f !== facet ; } ) } ) ; } 
function removeDisjunctiveFacet ( facet ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { disjunctiveFacets : filter ( this . disjunctiveFacets , function ( f ) { return f !== facet ; } ) } ) ; } 
function removeHierarchicalFacet ( facet ) { if ( ! this . isHierarchicalFacet ( facet ) ) { return this ; } return this . clearRefinements ( facet ) . setQueryParameters ( { hierarchicalFacets : filter ( this . hierarchicalFacets , function ( f ) { return f . name !== facet ; } ) } ) ; } 
function removeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . facetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { facetsRefinements : RefinementList . removeRefinement ( this . facetsRefinements , facet , value ) } ) ; } 
function removeExcludeRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . facetsExcludes , facet , value ) ) return this ; return this . setQueryParameters ( { facetsExcludes : RefinementList . removeRefinement ( this . facetsExcludes , facet , value ) } ) ; } 
function removeDisjunctiveFacetRefinement ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } if ( ! RefinementList . isRefined ( this . disjunctiveFacetsRefinements , facet , value ) ) return this ; return this . setQueryParameters ( { disjunctiveFacetsRefinements : RefinementList . removeRefinement ( this . disjunctiveFacetsRefinements , facet , value ) } ) ; } 
function removeTagRefinement ( tag ) { if ( ! this . isTagRefined ( tag ) ) return this ; var modification = { tagRefinements : filter ( this . tagRefinements , function ( t ) { return t !== tag ; } ) } ; return this . setQueryParameters ( modification ) ; } 
function toggleFacetRefinement ( facet , value ) { if ( this . isHierarchicalFacet ( facet ) ) { return this . toggleHierarchicalFacetRefinement ( facet , value ) ; } else if ( this . isConjunctiveFacet ( facet ) ) { return this . toggleConjunctiveFacetRefinement ( facet , value ) ; } else if ( this . isDisjunctiveFacet ( facet ) ) { return this . toggleDisjunctiveFacetRefinement ( facet , value ) ; } throw new Error ( 'Cannot refine the undeclared facet ' + facet + '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets' ) ; } 
function toggleConjunctiveFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { facetsRefinements : RefinementList . toggleRefinement ( this . facetsRefinements , facet , value ) } ) ; } 
function toggleExcludeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { facetsExcludes : RefinementList . toggleRefinement ( this . facetsExcludes , facet , value ) } ) ; } 
function toggleDisjunctiveFacetRefinement ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { disjunctiveFacetsRefinements : RefinementList . toggleRefinement ( this . disjunctiveFacetsRefinements , facet , value ) } ) ; } 
function toggleHierarchicalFacetRefinement ( facet , value ) { if ( ! this . isHierarchicalFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration' ) ; } var separator = this . _getHierarchicalFacetSeparator ( this . getHierarchicalFacetByName ( facet ) ) ; var mod = { } ; var upOneOrMultipleLevel = this . hierarchicalFacetsRefinements [ facet ] !== undefined && this . hierarchicalFacetsRefinements [ facet ] . length > 0 && ( 
function ( facet , path ) { if ( this . isHierarchicalFacetRefined ( facet ) ) { throw new Error ( facet + ' is already refined.' ) ; } var mod = { } ; mod [ facet ] = [ path ] ; return this . setQueryParameters ( { hierarchicalFacetsRefinements : defaults ( { } , mod , this . hierarchicalFacetsRefinements ) } ) ; } 
function isFacetRefined ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return RefinementList . isRefined ( this . facetsRefinements , facet , value ) ; } 
function isExcludeRefined ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return RefinementList . isRefined ( this . facetsExcludes , facet , value ) ; } 
function isDisjunctiveFacetRefined ( facet , value ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the disjunctiveFacets attribute of the helper configuration' ) ; } return RefinementList . isRefined ( this . disjunctiveFacetsRefinements , facet , value ) ; } 
function isHierarchicalFacetRefined ( facet , value ) { if ( ! this . isHierarchicalFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the hierarchicalFacets attribute of the helper configuration' ) ; } var refinements = this . getHierarchicalRefinement ( facet ) ; if ( ! value ) { return refinements . length > 0 ; } return indexOf ( refinements , value ) !== - 1 ; } 
function isNumericRefined ( attribute , operator , value ) { if ( isUndefined ( value ) && isUndefined ( operator ) ) { return ! ! this . numericRefinements [ attribute ] ; } var isOperatorDefined = this . numericRefinements [ attribute ] && ! isUndefined ( this . numericRefinements [ attribute ] [ operator ] ) ; if ( isUndefined ( value ) || ! isOperatorDefined ) { return isOperatorDefined ; } var parsedValue = valToNumber ( value ) ; var isAttributeValueDefined = ! isUndefined ( findArray ( this . numericRefinements [ attribute ] [ operator ] , parsedValue ) ) ; return isOperatorDefined && isAttributeValueDefined ; } 
function getRefinedDisjunctiveFacets ( ) { 
function setParameter ( parameter , value ) { if ( this [ parameter ] === value ) return this ; var modification = { } ; modification [ parameter ] = value ; return this . setQueryParameters ( modification ) ; } 
function setQueryParameters ( params ) { if ( ! params ) return this ; var error = SearchParameters . validate ( this , params ) ; if ( error ) { throw error ; } var parsedParams = SearchParameters . _parseNumbers ( params ) ; return this . mutateMe ( function mergeWith ( newInstance ) { var ks = keys ( params ) ; forEach ( ks , function ( k ) { newInstance [ k ] = parsedParams [ k ] ; } ) ; return newInstance ; } ) ; } 
function ( facetName ) { if ( ! this . isHierarchicalFacet ( facetName ) ) { throw new Error ( 'Cannot get the breadcrumb of an unknown hierarchical facet: `' + facetName + '`' ) ; } var refinement = this . getHierarchicalRefinement ( facetName ) [ 0 ] ; if ( ! refinement ) return [ ] ; var separator = this . _getHierarchicalFacetSeparator ( this . getHierarchicalFacetByName ( facetName ) ) ; var path = refinement . split ( separator ) ; return map ( path , trim ) ; } 
function AlgoliaSearchHelper ( client , index , options ) { if ( client . addAlgoliaAgent && ! doesClientAgentContainsHelper ( client ) ) { client . addAlgoliaAgent ( 'JS Helper (' + version + ')' ) ; } this . setClient ( client ) ; var opts = options || { } ; opts . index = index ; this . state = SearchParameters . make ( opts ) ; this . lastResults = null ; this . _queryId = 0 ; this . _lastQueryIdReceived = - 1 ; this . derivedHelpers = [ ] ; this . _currentNbQueries = 0 ; } 
function runCommand ( cmd , args ) { var prev = null ; console . log ( chalk . cyanBright ( cmd ) + " " + args . map ( arg => { if ( arg . startsWith ( "-" ) ) return chalk . gray ( "\\" ) + "\n " + chalk . bold ( arg ) ; return arg ; } ) . join ( " " ) + "\n" ) ; var proc = child_process . spawnSync ( cmd , args , { stdio : "inherit" } ) ; if ( proc . error ) throw proc . error ; if ( proc . status !== 0 ) throw Error ( "exited with " + proc . status ) ; return proc ; } 
function compileIntrinsics ( ) { var target = path . join ( sourceDirectory , "passes" , "WasmIntrinsics.cpp" ) ; runCommand ( "python" , [ path . join ( binaryenDirectory , "scripts" , "embedwast.py" ) , path . join ( sourceDirectory , "passes" , "wasm-intrinsics.wast" ) , target ] ) ; sourceFiles . push ( target ) ; } 
function compileShared ( ) { runCommand ( "python" , [ path . join ( emscriptenDirectory , "em++" ) ] . concat ( sourceFiles ) . concat ( commonOptions ) . concat ( [ "-o" , "shared.bc" ] ) ) ; } 
function compileJs ( options ) { runCommand ( "python" , [ path . join ( emscriptenDirectory , "em++" ) , "shared.bc" ] . concat ( commonOptions ) . concat ( [ "--post-js" , options . post , "--closure" , "1" , "-s" , "WASM=0" , "-s" , "EXPORTED_FUNCTIONS=[" + exportedFunctionsArg + "]" , "-s" , "ALLOW_MEMORY_GROWTH=1" , "-s" , "ELIMINATE_DUPLICATE_FUNCTIONS=1" , "-s" , "MODULARIZE_INSTANCE=1" , "-s" , "EXPORT_NAME=\"Binaryen\"" , "-o" , options . out , "-Oz" ] ) ) ; } 
function compileWasm ( options ) { run ( "python" , [ path . join ( emscriptenDirectory , "em++" ) , "shared.bc" ] . concat ( commonOptions ) . concat ( [ "--post-js" , options . post , "--closure" , "1" , "-s" , "EXPORTED_FUNCTIONS=[" + exportedFunctionsArg + "]" , "-s" , "ALLOW_MEMORY_GROWTH=1" , "-s" , "BINARYEN=1" , "-s" , "BINARYEN_METHOD=\"native-wasm\"" , "-s" , "MODULARIZE_INSTANCE=1" , "-s" , "EXPORT_NAME=\"Binaryen\"" , "-o" , options . out , "-Oz" ] ) ) ; } 
function pluginState ( ) { return { _sync : { signedIn : false , userId : null , unsubscribe : { } , pathVariables : { } , patching : false , syncStack : { inserts : [ ] , updates : { } , propDeletions : { } , deletions : [ ] , debounceTimer : null , } , fetched : { } , stopPatchingTimeout : null } } ; } 
function helpers ( originVal , newVal ) { if ( isArray ( originVal ) && isArrayHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } if ( isNumber ( originVal ) && isIncrementHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } return newVal ; 
function startDebounce ( ms ) { var startTime = Date . now ( ) ; var done = new Promise ( function ( resolve , reject ) { var interval = setInterval ( function ( _ ) { var now = Date . now ( ) ; var deltaT = now - startTime ; if ( deltaT >= ms ) { clearInterval ( interval ) ; resolve ( true ) ; } } , 10 ) ; } ) ; var refresh = function ( ) { return ( startTime = Date . now ( ) ) ; } ; return { done : done , refresh : refresh } ; } 
function grabUntilApiLimit ( syncStackProp , count , maxCount , state ) { var targets = state . _sync . syncStack [ syncStackProp ] ; 
function makeBatchFromSyncstack ( state , getters , Firebase , batchMaxCount ) { if ( batchMaxCount === void 0 ) { batchMaxCount = 500 ; } 
function getPathVarMatches ( pathPiece ) { var matches = pathPiece . match ( / \{([a-z]+)\} / gi ) ; if ( ! matches ) return [ ] ; return matches . map ( function ( key ) { return trimAccolades ( key ) ; } ) ; } 
function createFetchIdentifier ( whereOrderBy ) { if ( whereOrderBy === void 0 ) { whereOrderBy = { } ; } var identifier = '' ; if ( 'where' in whereOrderBy ) { identifier += '[where]' + whereOrderBy . where . map ( function ( where ) { return stringifyParams ( where ) ; } ) . join ( ) ; } if ( 'orderBy' in whereOrderBy ) { identifier += '[orderBy]' + stringifyParams ( whereOrderBy . orderBy ) ; } if ( 'pathVariables' in whereOrderBy ) { delete whereOrderBy . pathVariables . where ; delete whereOrderBy . pathVariables . orderBy ; identifier += '[pathVariables]' + JSON . stringify ( whereOrderBy . pathVariables ) ; } return identifier ; } 
function getValueFromPayloadPiece ( payloadPiece ) { if ( isPlainObject ( payloadPiece ) && ! payloadPiece . id && Object . keys ( payloadPiece ) . length === 1 && isPlainObject ( payloadPiece [ Object . keys ( payloadPiece ) [ 0 ] ] ) ) { return Object . values ( payloadPiece ) [ 0 ] ; } return payloadPiece ; } 
function storeUpdateFn ( _doc ) { switch ( change ) { case 'added' : commit ( 'INSERT_DOC' , _doc ) ; break ; case 'removed' : commit ( 'DELETE_DOC' , id ) ; break ; default : dispatch ( 'deleteMissingProps' , _doc ) ; commit ( 'PATCH_DOC' , _doc ) ; break ; } } 
function storeUpdateFn ( _val ) { commit ( 'PATCH_DOC' , _val ) ; return dispatch ( 'patchDoc' , { id : id , doc : copy ( _val ) } ) ; } 
function storeUpdateFn ( _doc , _ids ) { _ids . forEach ( function ( _id ) { commit ( 'PATCH_DOC' , __assign ( { id : _id } , _doc ) ) ; } ) ; return dispatch ( 'patchDoc' , { ids : _ids , doc : _doc } ) ; } 
function storeUpdateFn ( _ids ) { _ids . forEach ( function ( _id ) { 
function errorCheck ( config ) { var errors = [ ] ; var reqProps = [ 'firestorePath' , 'moduleName' ] ; reqProps . forEach ( function ( prop ) { if ( ! config [ prop ] ) { errors . push ( "Missing `" + prop + "` in your module!" ) ; } } ) ; if ( / (\.|\/) / . test ( config . statePropName ) ) { errors . push ( "statePropName must only include letters from [a-z]" ) ; } if ( / \. / . test ( config . moduleName ) ) { errors . push ( "moduleName must only include letters from [a-z] and forward slashes '/'" ) ; } var syncProps = [ 'where' , 'orderBy' , 'fillables' , 'guard' , 'defaultValues' , 'insertHook' , 'patchHook' , 'deleteHook' , 'insertBatchHook' , 'patchBatchHook' , 'deleteBatchHook' ] ; syncProps . forEach ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found `" + prop + "` on your module, are you sure this shouldn't be inside a prop called `sync`?" ) ; } } ) ; var serverChangeProps = [ 'modifiedHook' , 'defaultValues' , 'addedHook' , 'removedHook' ] ; serverChangeProps . forEach ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found `" + prop + "` on your module, are you sure this shouldn't be inside a prop called `serverChange`?" ) ; } } ) ; var fetchProps = [ 'docLimit' ] ; fetchProps . forEach ( function ( prop ) { if ( config [ prop ] ) { errors . push ( "We found `" + prop + "` on your module, are you sure this shouldn't be inside a prop called `fetch`?" ) ; } } ) ; var numberProps = [ 'docLimit' ] ; numberProps . forEach ( function ( prop ) { var _prop = config . fetch [ prop ] ; if ( ! isNumber ( _prop ) ) errors . push ( "`" + prop + "` should be a Number, but is not." ) ; } ) ; var functionProps = [ 'insertHook' , 'patchHook' , 'deleteHook' , 'insertBatchHook' , 'patchBatchHook' , 'deleteBatchHook' , 'addedHook' , 'modifiedHook' , 'removedHook' ] ; functionProps . forEach ( function ( prop ) { var _prop = ( syncProps . includes ( prop ) ) ? config . sync [ prop ] : config . serverChange [ prop ] ; if ( ! isFunction ( _prop ) ) errors . push ( "`" + prop + "` should be a Function, but is not." ) ; } ) ; var objectProps = [ 'sync' , 'serverChange' , 'defaultValues' , 'fetch' ] ; objectProps . forEach ( function ( prop ) { var _prop = ( prop === 'defaultValues' ) ? config . sync [ prop ] : config [ prop ] ; if ( ! isPlainObject ( _prop ) ) errors . push ( "`" + prop + "` should be an Object, but is not." ) ; } ) ; var stringProps = [ 'firestorePath' , 'firestoreRefType' , 'moduleName' , 'statePropName' ] ; stringProps . forEach ( function ( prop ) { var _prop = config [ prop ] ; if ( ! isString ( _prop ) ) errors . push ( "`" + prop + "` should be a String, but is not." ) ; } ) ; var arrayProps = [ 'where' , 'orderBy' , 'fillables' , 'guard' ] ; arrayProps . forEach ( function ( prop ) { var _prop = config . sync [ prop ] ; if ( ! isArray ( _prop ) ) errors . push ( "`" + prop + "` should be an Array, but is not." ) ; } ) ; if ( errors . length ) { console . group ( '[vuex-easy-firestore] ERRORS:' ) ; console . error ( "Module: " + config . moduleName ) ; errors . forEach ( function ( e ) { return console . error ( ' - ' , e ) ; } ) ; console . groupEnd ( ) ; return false ; } return true ; } 
function iniModule ( userConfig , FirebaseDependency ) { 
function defaults ( config ) { 
function pluginMutations ( userState ) { return { SET_PATHVARS : function ( state , pathVars ) { var self = this ; Object . keys ( pathVars ) . forEach ( function ( key ) { var pathPiece = pathVars [ key ] ; self . _vm . $set ( state . _sync . pathVariables , key , pathPiece ) ; } ) ; } , SET_SYNCFILTERS : function ( state , _a ) { var where = _a . where , orderBy = _a . orderBy ; if ( where && isWhat . isArray ( where ) ) state . _conf . sync . where = where ; if ( orderBy && isWhat . isArray ( orderBy ) ) state . _conf . sync . orderBy = orderBy ; } , SET_USER_ID : function ( state , userId ) { if ( ! userId ) { state . _sync . signedIn = false ; state . _sync . userId = null ; } else { state . _sync . signedIn = true ; state . _sync . userId = userId ; } } , CLEAR_USER : function ( state ) { state . _sync . signedIn = false ; state . _sync . userId = null ; } , RESET_VUEX_EASY_FIRESTORE_STATE : function ( state ) { 
function convertTimestamps ( originVal , targetVal ) { if ( originVal === '%convertTimestamp%' ) { 
function setDefaultValues ( obj , defaultValues ) { if ( ! isWhat . isPlainObject ( defaultValues ) ) console . error ( '[vuex-easy-firestore] Trying to merge target:' , obj , 'onto a non-object (defaultValues):' , defaultValues ) ; if ( ! isWhat . isPlainObject ( obj ) ) console . error ( '[vuex-easy-firestore] Trying to merge a non-object:' , obj , 'onto the defaultValues:' , defaultValues ) ; var result = merge ( { extensions : [ convertTimestamps ] } , defaultValues , obj ) ; return findAndReplaceAnything . findAndReplace ( result , '%convertTimestamp%' , null , { onlyPlainObjects : true } ) ; } 
function getId ( payloadPiece , conf , path , fullPayload ) { if ( isWhat . isString ( payloadPiece ) ) return payloadPiece ; if ( isWhat . isPlainObject ( payloadPiece ) ) { if ( 'id' in payloadPiece ) return payloadPiece . id ; var keys = Object . keys ( payloadPiece ) ; if ( keys . length === 1 ) return keys [ 0 ] ; } return '' ; } 
function pluginActions ( Firebase ) { var _this = this ; return { setUserId : function ( _a , userId ) { var commit = _a . commit , getters = _a . getters ; if ( userId === undefined ) userId = null ; 
function pluginGetters ( Firebase ) { return { firestorePathComplete : function ( state , getters ) { var path = state . _conf . firestorePath ; Object . keys ( state . _sync . pathVariables ) . forEach ( function ( key ) { var pathPiece = state . _sync . pathVariables [ key ] ; path = path . replace ( "{" + key + "}" , "" + pathPiece ) ; } ) ; var requireUser = path . includes ( '{userId}' ) ; if ( requireUser ) { var userId = state . _sync . userId ; if ( getters . signedIn && isWhat . isString ( userId ) && userId !== '' && userId !== '{userId}' ) { path = path . replace ( '{userId}' , userId ) ; } } return path ; } , signedIn : function ( state , getters , rootState , rootGetters ) { var requireUser = state . _conf . firestorePath . includes ( '{userId}' ) ; if ( ! requireUser ) return true ; return state . _sync . signedIn ; } , dbRef : function ( state , getters , rootState , rootGetters ) { var path = getters . firestorePathComplete ; return ( getters . collectionMode ) ? Firebase . firestore ( ) . collection ( path ) : Firebase . firestore ( ) . doc ( path ) ; } , storeRef : function ( state , getters , rootState ) { var path = ( state . _conf . statePropName ) ? state . _conf . moduleName + "/" + state . _conf . statePropName : state . _conf . moduleName ; return vuexEasyAccess . getDeepRef ( rootState , path ) ; } , collectionMode : function ( state , getters , rootState ) { return ( state . _conf . firestoreRefType . toLowerCase ( ) === 'collection' ) ; } , docModeId : function ( state , getters ) { return getters . firestorePathComplete . split ( '/' ) . pop ( ) ; } , fillables : function ( state ) { var fillables = state . _conf . sync . fillables ; if ( ! fillables . length ) return fillables ; return fillables . concat ( [ 'updated_at' , 'updated_by' , 'id' , 'created_at' , 'created_by' ] ) ; } , guard : function ( state ) { return state . _conf . sync . guard . concat ( [ '_conf' , '_sync' ] ) ; } , defaultValues : function ( state , getters ) { return merge ( state . _conf . sync . defaultValues , state . _conf . serverChange . defaultValues 
function vuexEasyFirestore ( easyFirestoreModule , _a ) { var _b = _a === void 0 ? { logging : false , preventInitialDocInsertion : false , FirebaseDependency : Firebase$2 } : _a , _c = _b . logging , logging = _c === void 0 ? false : _c , _d = _b . preventInitialDocInsertion , preventInitialDocInsertion = _d === void 0 ? false : _d , _e = _b . FirebaseDependency , FirebaseDependency = _e === void 0 ? Firebase$2 : _e ; if ( FirebaseDependency ) { setFirebaseDependency ( FirebaseDependency ) ; setFirebaseDependency$1 ( FirebaseDependency ) ; } return function ( store ) { 
function addAttrs ( element , attrs ) { Object . keys ( attrs ) . forEach ( function ( key ) { element . setAttribute ( key , attrs [ key ] ) ; } ) ; } 
function _transformToHierarchy ( links , attributeFields ) { const nodesByName = { } ; const assignNode = name => { if ( ! nodesByName [ name ] ) { nodesByName [ name ] = { name } ; } return nodesByName [ name ] ; } ; const assignNodeWithAttributes = ( name , attributes ) => { if ( ! nodesByName [ name ] ) { nodesByName [ name ] = { name , attributes , } ; } return nodesByName [ name ] ; } ; 
function parseCSV ( csvFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) => { try { csv ( csvFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; 
function parseJSON ( jsonFilePath ) { return new Promise ( ( resolve , reject ) => { try { json ( jsonFilePath , data => resolve ( [ data ] ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function parseFlatJSON ( jsonFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) => { try { json ( jsonFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function checkPropTypes ( typeSpecs , values , location , componentName , getStack ) { if ( true ) { for ( var typeSpecName in typeSpecs ) { if ( typeSpecs . hasOwnProperty ( typeSpecName ) ) { var error ; 
function invokeGuardedCallback ( name , func , context , a , b , c , d , e , f ) { hasError = false ; caughtError = null ; invokeGuardedCallbackImpl$1 . apply ( reporter , arguments ) ; } 
function invokeGuardedCallbackAndCatchFirstError ( name , func , context , a , b , c , d , e , f ) { invokeGuardedCallback . apply ( this , arguments ) ; if ( hasError ) { var error = clearCaughtError ( ) ; if ( ! hasRethrowError ) { hasRethrowError = true ; rethrowError = error ; } } } 
function getClosestInstanceFromNode ( node ) { if ( node [ internalInstanceKey ] ) { return node [ internalInstanceKey ] ; } while ( ! node [ internalInstanceKey ] ) { if ( node . parentNode ) { node = node . parentNode ; } else { 
function getInstanceFromNode$1 ( node ) { var inst = node [ internalInstanceKey ] ; if ( inst ) { if ( inst . tag === HostComponent || inst . tag === HostText ) { return inst ; } else { return null ; } } return null ; } 
function getNodeFromInstance$1 ( inst ) { if ( inst . tag === HostComponent || inst . tag === HostText ) { 
function traverseEnterLeave ( from , to , fn , argFrom , argTo ) { var common = from && to ? getLowestCommonAncestor ( from , to ) : null ; var pathFrom = [ ] ; while ( true ) { if ( ! from ) { break ; } if ( from === common ) { break ; } var alternate = from . alternate ; if ( alternate !== null && alternate === common ) { break ; } pathFrom . push ( from ) ; from = getParent ( from ) ; } var pathTo = [ ] ; while ( true ) { if ( ! to ) { break ; } if ( to === common ) { break ; } var _alternate = to . alternate ; if ( _alternate !== null && _alternate === common ) { break ; } pathTo . push ( to ) ; to = getParent ( to ) ; } for ( var i = 0 ; i < pathFrom . length ; i ++ ) { fn ( pathFrom [ i ] , 'bubbled' , argFrom ) ; } for ( var _i = pathTo . length ; _i -- > 0 ; ) { fn ( pathTo [ _i ] , 'captured' , argTo ) ; } } 
function accumulateDirectionalDispatches ( inst , phase , event ) { { ! inst ? warningWithoutStack$1 ( false , 'Dispatching inst must not be null' ) : void 0 ; } var listener = listenerAtPhase ( inst , event , phase ) ; if ( listener ) { event . _dispatchListeners = accumulateInto ( event . _dispatchListeners , listener ) ; event . _dispatchInstances = accumulateInto ( event . _dispatchInstances , inst ) ; } } 
function makePrefixMap ( styleProp , eventName ) { var prefixes = { } ; prefixes [ styleProp . toLowerCase ( ) ] = eventName . toLowerCase ( ) ; prefixes [ 'Webkit' + styleProp ] = 'webkit' + eventName ; prefixes [ 'Moz' + styleProp ] = 'moz' + eventName ; return prefixes ; } 
function ( ) { var Interface = this . constructor . Interface ; for ( var propName in Interface ) { { Object . defineProperty ( this , propName , getPooledWarningPropertyDefinition ( propName , Interface [ propName ] ) ) ; } } this . dispatchConfig = null ; this . _targetInst = null ; this . nativeEvent = null ; this . isDefaultPrevented = functionThatReturnsFalse ; this . isPropagationStopped = functionThatReturnsFalse ; this . _dispatchListeners = null ; this . _dispatchInstances = null ; { Object . defineProperty ( this , 'nativeEvent' , getPooledWarningPropertyDefinition ( 'nativeEvent' , null ) ) ; Object . defineProperty ( this , 'isDefaultPrevented' , getPooledWarningPropertyDefinition ( 'isDefaultPrevented' , functionThatReturnsFalse ) ) ; Object . defineProperty ( this , 'isPropagationStopped' , getPooledWarningPropertyDefinition ( 'isPropagationStopped' , functionThatReturnsFalse ) ) ; Object . defineProperty ( this , 'preventDefault' , getPooledWarningPropertyDefinition ( 'preventDefault' , function ( ) { } ) ) ; Object . defineProperty ( this , 'stopPropagation' , getPooledWarningPropertyDefinition ( 'stopPropagation' , function ( ) { } ) ) ; } } 
function getCompositionEventType ( topLevelType ) { switch ( topLevelType ) { case TOP_COMPOSITION_START : return eventTypes . compositionStart ; case TOP_COMPOSITION_END : return eventTypes . compositionEnd ; case TOP_COMPOSITION_UPDATE : return eventTypes . compositionUpdate ; } } 
function isFallbackCompositionEnd ( topLevelType , nativeEvent ) { switch ( topLevelType ) { case TOP_KEY_UP : 
function getValueForProperty ( node , name , expected , propertyInfo ) { { if ( propertyInfo . mustUseProperty ) { var propertyName = propertyInfo . propertyName ; return node [ propertyName ] ; } else { var attributeName = propertyInfo . attributeName ; var stringValue = null ; if ( propertyInfo . type === OVERLOADED_BOOLEAN ) { if ( node . hasAttribute ( attributeName ) ) { var value = node . getAttribute ( attributeName ) ; if ( value === '' ) { return true ; } if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return value ; } if ( value === '' + expected ) { return expected ; } return value ; } } else if ( node . hasAttribute ( attributeName ) ) { if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { 
function setValueForProperty ( node , name , value , isCustomComponentTag ) { var propertyInfo = getPropertyInfo ( name ) ; if ( shouldIgnoreAttribute ( name , propertyInfo , isCustomComponentTag ) ) { return ; } if ( shouldRemoveAttribute ( name , value , propertyInfo , isCustomComponentTag ) ) { value = null ; } 
function getHostProps ( element , props ) { var node = element ; var checked = props . checked ; var hostProps = _assign ( { } , props , { defaultChecked : undefined , defaultValue : undefined , value : undefined , checked : checked != null ? checked : node . _wrapperState . initialChecked } ) ; return hostProps ; } 
function getTargetInstForInputEventPolyfill ( topLevelType , targetInst ) { if ( topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN ) { 
function ( topLevelType , targetInst , nativeEvent , nativeEventTarget ) { var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER ; var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT ; if ( isOverEvent && ( nativeEvent . relatedTarget || nativeEvent . fromElement ) ) { return null ; } if ( ! isOutEvent && ! isOverEvent ) { 
function findRootContainerNode ( inst ) { 
function listenTo ( registrationName , mountAt ) { var isListening = getListeningForDocument ( mountAt ) ; var dependencies = registrationNameDependencies [ registrationName ] ; for ( var i = 0 ; i < dependencies . length ; i ++ ) { var dependency = dependencies [ i ] ; if ( ! ( isListening . hasOwnProperty ( dependency ) && isListening [ dependency ] ) ) { switch ( dependency ) { case TOP_SCROLL : trapCapturedEvent ( TOP_SCROLL , mountAt ) ; break ; case TOP_FOCUS : case TOP_BLUR : trapCapturedEvent ( TOP_FOCUS , mountAt ) ; trapCapturedEvent ( TOP_BLUR , mountAt ) ; 
function getEventTargetDocument ( eventTarget ) { return eventTarget . window === eventTarget ? eventTarget . document : eventTarget . nodeType === DOCUMENT_NODE ? eventTarget : eventTarget . ownerDocument ; } 
function constructSelectEvent ( nativeEvent , nativeEventTarget ) { 
function validateProps ( element , props ) { { 
function ( node , text ) { if ( text ) { var firstChild = node . firstChild ; if ( firstChild && firstChild === node . lastChild && firstChild . nodeType === TEXT_NODE ) { firstChild . nodeValue = text ; return ; } } node . textContent = text ; } 
function dangerousStyleValue ( name , value , isCustomProperty ) { 
function createDangerousStringForStyles ( styles ) { { var serialized = '' ; var delimiter = '' ; for ( var styleName in styles ) { if ( ! styles . hasOwnProperty ( styleName ) ) { continue ; } var styleValue = styles [ styleName ] ; if ( styleValue != null ) { var isCustomProperty = styleName . indexOf ( '--' ) === 0 ; serialized += delimiter + hyphenateStyleName ( styleName ) + ':' ; serialized += dangerousStyleValue ( styleName , styleValue , isCustomProperty ) ; delimiter = ';' ; } } return serialized || null ; } } 
function setValueForStyles ( node , styles ) { var style = node . style ; for ( var styleName in styles ) { if ( ! styles . hasOwnProperty ( styleName ) ) { continue ; } var isCustomProperty = styleName . indexOf ( '--' ) === 0 ; { if ( ! isCustomProperty ) { warnValidStyle$1 ( styleName , styles [ styleName ] ) ; } } var styleValue = dangerousStyleValue ( styleName , styles [ styleName ] , isCustomProperty ) ; if ( styleName === 'float' ) { styleName = 'cssFloat' ; } if ( isCustomProperty ) { style . setProperty ( styleName , styleValue ) ; } else { style [ styleName ] = styleValue ; } } } 
function createFiberRoot ( containerInfo , isAsync , hydrate ) { 
function markPendingPriorityLevel ( root , expirationTime ) { 
function warnOnInvalidKey ( child , knownKeys ) { { if ( typeof child !== 'object' || child === null ) { return knownKeys ; } switch ( child . $$typeof ) { case REACT_ELEMENT_TYPE : case REACT_PORTAL_TYPE : warnForMissingKey ( child ) ; var key = child . key ; if ( typeof key !== 'string' ) { break ; } if ( knownKeys === null ) { knownKeys = new Set ( ) ; knownKeys . add ( key ) ; break ; } if ( ! knownKeys . has ( key ) ) { knownKeys . add ( key ) ; break ; } warning$1 ( false , 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + ' ould change in a future version.', k y); break ; default : break ; } } return knownKeys ; } 
function bailoutOnAlreadyFinishedWork ( current$$1 , workInProgress , renderExpirationTime ) { cancelWorkTimer ( workInProgress ) ; if ( current$$1 !== null ) { 
function ( containerChildSet , workInProgress ) { 
function safelyCallComponentWillUnmount ( current$$1 , instance ) { { invokeGuardedCallback ( null , callComponentWillUnmountWithTimer , null , current$$1 , instance ) ; if ( hasCaughtError ( ) ) { var unmountError = clearCaughtError ( ) ; captureCommitPhaseError ( current$$1 , unmountError ) ; } } } 
function commitUnmount ( current$$1 ) { onCommitUnmount ( current$$1 ) ; switch ( current$$1 . tag ) { case ClassComponent : case ClassComponentLazy : { safelyDetachRef ( current$$1 ) ; var instance = current$$1 . stateNode ; if ( typeof instance . componentWillUnmount === 'function' ) { safelyCallComponentWillUnmount ( current$$1 , instance ) ; } return ; } case HostComponent : { safelyDetachRef ( current$$1 ) ; return ; } case HostPortal : { 
function computeUniqueAsyncExpiration ( ) { var currentTime = requestCurrentTime ( ) ; var result = computeAsyncExpiration ( currentTime ) ; if ( result <= lastUniqueAsyncExpiration ) { 
function batchedUpdates$1 ( fn , a ) { var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return fn ( a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; if ( ! isBatchingUpdates && ! isRendering ) { performSyncWork ( ) ; } } } 
function flushSync ( fn , a ) { ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return syncUpdates ( fn , a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; performSyncWork ( ) ; } } 
function createPortal$1 ( children , containerInfo , 
function ReactBatch ( root ) { var expirationTime = computeUniqueAsyncExpiration ( ) ; this . _expirationTime = expirationTime ; this . _root = root ; this . _next = null ; this . _callbacks = null ; this . _didComplete = false ; this . _hasChildren = false ; this . _children = null ; this . _defer = true ; } 
function Component ( props , context , updater ) { this . props = props ; this . context = context ; 
function toArray ( children ) { var result = [ ] ; mapIntoWithKeyPrefixInternal ( children , result , null , function ( child ) { return child ; } ) ; return result ; } 
function validatePropTypes ( element ) { var type = element . type ; var name = void 0 , propTypes = void 0 ; if ( typeof type === 'function' ) { 
function validateFragmentProps ( fragment ) { setCurrentlyValidatingElement ( fragment ) ; var keys = Object . keys ( fragment . props ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { var key = keys [ i ] ; if ( key !== 'children' && key !== 'key' ) { warning$1 ( false , 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.' , key ) ; break ; } } if ( fragment . ref !== null ) { warning$1 ( false , 'Invalid attribute `ref` supplied to `React.Fragment`.' ) ; } setCurrentlyValidatingElement ( null ) ; } 
function headBucket ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:HeadBucket' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , method : 'HEAD' , } , function ( err , data ) { callback ( err , data ) ; } ) ; } 
function getBucket ( params , callback ) { var reqParams = { } ; reqParams [ 'prefix' ] = params [ 'Prefix' ] || '' ; reqParams [ 'delimiter' ] = params [ 'Delimiter' ] ; reqParams [ 'marker' ] = params [ 'Marker' ] ; reqParams [ 'max-keys' ] = params [ 'MaxKeys' ] ; reqParams [ 'encoding-type' ] = params [ 'EncodingType' ] ; submitRequest . call ( this , { Action : 'name/cos:GetBucket' , ResourceKey : reqParams [ 'prefix' ] , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , qs : reqParams , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var ListBucketResult = data . ListBucketResult || { } ; var Contents = ListBucketResult . Contents || [ ] ; var CommonPrefixes = ListBucketResult . CommonPrefixes || [ ] ; Contents = util . isArray ( Contents ) ? Contents : [ Contents ] ; CommonPrefixes = util . isArray ( CommonPrefixes ) ? CommonPrefixes : [ CommonPrefixes ] ; var result = util . clone ( ListBucketResult ) ; util . extend ( result , { Contents : Contents , CommonPrefixes : CommonPrefixes , statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function getBucketAcl ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketACL' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'acl' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var AccessControlPolicy = data . AccessControlPolicy || { } ; var Owner = AccessControlPolicy . Owner || { } ; var Grant = AccessControlPolicy . AccessControlList . Grant || [ ] ; Grant = util . isArray ( Grant ) ? Grant : [ Grant ] ; var result = decodeAcl ( AccessControlPolicy ) ; if ( data . headers && data . headers [ 'x-cos-acl' ] ) { result . ACL = data . headers [ 'x-cos-acl' ] ; } result = util . extend ( result , { Owner : Owner , Grants : Grant , statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function getBucketCors ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketCORS' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors' , } , function ( err , data ) { if ( err ) { if ( err . statusCode === 404 && err . error && err . error . Code === 'NoSuchCORSConfiguration' ) { var result = { CORSRules : [ ] , statusCode : err . statusCode , } ; err . headers && ( result . headers = err . headers ) ; callback ( null , result ) ; } else { callback ( err ) ; } return ; } var CORSConfiguration = data . CORSConfiguration || { } ; var CORSRules = CORSConfiguration . CORSRules || CORSConfiguration . CORSRule || [ ] ; CORSRules = util . clone ( util . isArray ( CORSRules ) ? CORSRules : [ CORSRules ] ) ; util . each ( CORSRules , function ( rule ) { util . each ( [ 'AllowedOrigin' , 'AllowedHeader' , 'AllowedMethod' , 'ExposeHeader' ] , function ( key , j ) { var sKey = key + 's' ; var val = rule [ sKey ] || rule [ key ] || [ ] ; delete rule [ key ] ; rule [ sKey ] = util . isArray ( val ) ? val : [ val ] ; } ) ; } ) ; callback ( null , { CORSRules : CORSRules , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function putBucketCors ( params , callback ) { var CORSConfiguration = params [ 'CORSConfiguration' ] || { } ; var CORSRules = CORSConfiguration [ 'CORSRules' ] || params [ 'CORSRules' ] || [ ] ; CORSRules = util . clone ( util . isArray ( CORSRules ) ? CORSRules : [ CORSRules ] ) ; util . each ( CORSRules , function ( rule ) { util . each ( [ 'AllowedOrigin' , 'AllowedHeader' , 'AllowedMethod' , 'ExposeHeader' ] , function ( key , k ) { var sKey = key + 's' ; var val = rule [ sKey ] || rule [ key ] || [ ] ; delete rule [ sKey ] ; rule [ key ] = util . isArray ( val ) ? val : [ val ] ; } ) ; } ) ; var xml = util . json2xml ( { CORSConfiguration : { CORSRule : CORSRules } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:PutBucketCORS' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'cors' , headers : headers , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function deleteBucketCors ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteBucketCORS' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors' , } , function ( err , data ) { if ( err && err . statusCode === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode || err . statusCode , headers : data . headers , } ) ; } ) ; } 
function getBucketLocation ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketLocation' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'location' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , data ) ; } ) ; } 
function getBucketPolicy ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketPolicy' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'policy' , rawBody : true , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( { ErrorStatus : 'Access Denied' } ) ; } if ( err . statusCode && err . statusCode === 405 ) { return callback ( { ErrorStatus : 'Method Not Allowed' } ) ; } if ( err . statusCode && err . statusCode === 404 ) { return callback ( { ErrorStatus : 'Policy Not Found' } ) ; } return callback ( err ) ; } var Policy = { } ; try { Policy = JSON . parse ( data . body ) ; } catch ( e ) { } callback ( null , { Policy : Policy , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function getBucketTagging ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketTagging' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'tagging' , } , function ( err , data ) { if ( err ) { if ( err . statusCode === 404 && err . error && ( err . error === "Not Found" || err . error . Code === 'NoSuchTagSet' ) ) { var result = { Tags : [ ] , statusCode : err . statusCode , } ; err . headers && ( result . headers = err . headers ) ; callback ( null , result ) ; } else { callback ( err ) ; } return ; } var Tags = [ ] ; try { Tags = data . Tagging . TagSet . Tag || [ ] ; } catch ( e ) { } Tags = util . clone ( util . isArray ( Tags ) ? Tags : [ Tags ] ) ; callback ( null , { Tags : Tags , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function putBucketTagging ( params , callback ) { var Tagging = params [ 'Tagging' ] || { } ; var Tags = Tagging . TagSet || Tagging . Tags || params [ 'Tags' ] || [ ] ; Tags = util . clone ( util . isArray ( Tags ) ? Tags : [ Tags ] ) ; var xml = util . json2xml ( { Tagging : { TagSet : { Tag : Tags } } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:PutBucketTagging' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'tagging' , headers : headers , } , function ( err , data ) { if ( err && err . statusCode === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function headObject ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:HeadObject' , method : 'HEAD' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , VersionId : params . VersionId , headers : params . Headers , } , function ( err , data ) { if ( err ) { var statusCode = err . statusCode ; if ( params . Headers [ 'If-Modified-Since' ] && statusCode && statusCode === 304 ) { return callback ( null , { NotModified : true , statusCode : statusCode , } ) ; } return callback ( err ) ; } if ( data . headers && data . headers . etag ) { data . ETag = data . headers && data . headers . etag ; } callback ( null , data ) ; } ) ; } 
function getObject ( params , callback ) { var reqParams = { } ; reqParams [ 'response-content-type' ] = params [ 'ResponseContentType' ] ; reqParams [ 'response-content-language' ] = params [ 'ResponseContentLanguage' ] ; reqParams [ 'response-expires' ] = params [ 'ResponseExpires' ] ; reqParams [ 'response-cache-control' ] = params [ 'ResponseCacheControl' ] ; reqParams [ 'response-content-disposition' ] = params [ 'ResponseContentDisposition' ] ; reqParams [ 'response-content-encoding' ] = params [ 'ResponseContentEncoding' ] ; 
function putObject ( params , callback ) { var self = this ; var FileSize = params . ContentLength ; var onProgress = util . throttleOnProgress . call ( self , FileSize , params . onProgress ) ; 
function deleteObject ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteObject' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , VersionId : params . VersionId , } , function ( err , data ) { if ( err ) { var statusCode = err . statusCode ; if ( statusCode && statusCode === 204 ) { return callback ( null , { statusCode : statusCode } ) ; } else if ( statusCode && statusCode === 404 ) { return callback ( null , { BucketNotFound : true , statusCode : statusCode , } ) ; } else { return callback ( err ) ; } } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function putObjectAcl ( params , callback ) { var headers = params . Headers ; var xml = '' ; if ( params [ 'AccessControlPolicy' ] ) { var AccessControlPolicy = util . clone ( params [ 'AccessControlPolicy' ] || { } ) ; var Grants = AccessControlPolicy . Grants || AccessControlPolicy . Grant ; Grants = util . isArray ( Grants ) ? Grants : [ Grants ] ; delete AccessControlPolicy . Grant ; delete AccessControlPolicy . Grants ; AccessControlPolicy . AccessControlList = { Grant : Grants } ; xml = util . json2xml ( { AccessControlPolicy : AccessControlPolicy } ) ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; } 
function optionsObject ( params , callback ) { var headers = params . Headers ; headers [ 'Origin' ] = params [ 'Origin' ] ; headers [ 'Access-Control-Request-Method' ] = params [ 'AccessControlRequestMethod' ] ; headers [ 'Access-Control-Request-Headers' ] = params [ 'AccessControlRequestHeaders' ] ; submitRequest . call ( this , { Action : 'name/cos:OptionsObject' , method : 'OPTIONS' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : headers , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( null , { OptionsForbidden : true , statusCode : err . statusCode } ) ; } return callback ( err ) ; } var headers = data . headers || { } ; callback ( null , { AccessControlAllowOrigin : headers [ 'access-control-allow-origin' ] , AccessControlAllowMethods : headers [ 'access-control-allow-methods' ] , AccessControlAllowHeaders : headers [ 'access-control-allow-headers' ] , AccessControlExposeHeaders : headers [ 'access-control-expose-headers' ] , AccessControlMaxAge : headers [ 'access-control-max-age' ] , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function multipartInit ( params , callback ) { var xml ; var headers = params . Headers ; var userAgent = navigator && navigator . userAgent || '' ; var m = userAgent . match ( / TBS\/(\d{6}) / ) ; if ( location . protocol === 'http:' && m && m [ 1 ] . length <= 6 && m [ 1 ] < '044429' ) { xml = util . json2xml ( { } ) ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; 
function multipartComplete ( params , callback ) { var self = this ; var UploadId = params . UploadId ; var Parts = params [ 'Parts' ] ; for ( var i = 0 , len = Parts . length ; i < len ; i ++ ) { if ( Parts [ i ] [ 'ETag' ] . indexOf ( '"' ) === 0 ) { continue ; } Parts [ i ] [ 'ETag' ] = '"' + Parts [ i ] [ 'ETag' ] + '"' ; } var xml = util . json2xml ( { CompleteMultipartUpload : { Part : Parts } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:CompleteMultipartUpload' , method : 'POST' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , qs : { uploadId : UploadId } , body : xml , headers : headers , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var url = getUrl ( { ForcePathStyle : self . options . ForcePathStyle , protocol : self . options . Protocol , domain : self . options . Domain , bucket : params . Bucket , region : params . Region , object : params . Key , isLocation : true , } ) ; var CompleteMultipartUploadResult = data . CompleteMultipartUploadResult || { } ; var result = util . extend ( CompleteMultipartUploadResult , { Location : url , statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipartList ( params , callback ) { var reqParams = { } ; reqParams [ 'delimiter' ] = params [ 'Delimiter' ] ; reqParams [ 'encoding-type' ] = params [ 'EncodingType' ] ; reqParams [ 'prefix' ] = params [ 'Prefix' ] || '' ; reqParams [ 'max-uploads' ] = params [ 'MaxUploads' ] ; reqParams [ 'key-marker' ] = params [ 'KeyMarker' ] ; reqParams [ 'upload-id-marker' ] = params [ 'UploadIdMarker' ] ; reqParams = util . clearKey ( reqParams ) ; submitRequest . call ( this , { Action : 'name/cos:ListMultipartUploads' , ResourceKey : reqParams [ 'prefix' ] , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , qs : reqParams , action : 'uploads' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } if ( data && data . ListMultipartUploadsResult ) { var Upload = data . ListMultipartUploadsResult . Upload || [ ] ; var CommonPrefixes = data . ListMultipartUploadsResult . CommonPrefixes || [ ] ; CommonPrefixes = util . isArray ( CommonPrefixes ) ? CommonPrefixes : [ CommonPrefixes ] ; Upload = util . isArray ( Upload ) ? Upload : [ Upload ] ; data . ListMultipartUploadsResult . Upload = Upload ; data . ListMultipartUploadsResult . CommonPrefixes = CommonPrefixes ; } var result = util . clone ( data . ListMultipartUploadsResult || { } ) ; util . extend ( result , { statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipartListPart ( params , callback ) { var reqParams = { } ; reqParams [ 'uploadId' ] = params [ 'UploadId' ] ; reqParams [ 'encoding-type' ] = params [ 'EncodingType' ] ; reqParams [ 'max-parts' ] = params [ 'MaxParts' ] ; reqParams [ 'part-number-marker' ] = params [ 'PartNumberMarker' ] ; submitRequest . call ( this , { Action : 'name/cos:ListParts' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , qs : reqParams , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } var ListPartsResult = data . ListPartsResult || { } ; var Part = ListPartsResult . Part || [ ] ; Part = util . isArray ( Part ) ? Part : [ Part ] ; ListPartsResult . Part = Part ; var result = util . clone ( ListPartsResult ) ; util . extend ( result , { statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; } 
function multipartAbort ( params , callback ) { var reqParams = { } ; reqParams [ 'uploadId' ] = params [ 'UploadId' ] ; submitRequest . call ( this , { Action : 'name/cos:AbortMultipartUpload' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , qs : reqParams , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; } 
function getAuth ( params ) { var self = this ; return util . getAuth ( { SecretId : params . SecretId || this . options . SecretId || '' , SecretKey : params . SecretKey || this . options . SecretKey || '' , Method : params . Method , Key : params . Key , Query : params . Query , Headers : params . Headers , Expires : params . Expires , UseRawKey : self . options . UseRawKey , SystemClockOffset : self . options . SystemClockOffset , } ) ; } 
function getObjectUrl ( params , callback ) { var self = this ; var url = getUrl ( { ForcePathStyle : self . options . ForcePathStyle , protocol : params . Protocol || self . options . Protocol , domain : self . options . Domain , bucket : params . Bucket , region : params . Region , object : params . Key , } ) ; if ( params . Sign !== undefined && ! params . Sign ) { callback ( null , { Url : url } ) ; return url ; } var AuthData = getAuthorizationAsync . call ( this , { Action : ( ( params . Method || '' ) . toUpperCase ( ) === 'PUT' ? 'name/cos:PutObject' : 'name/cos:GetObject' ) , Bucket : params . Bucket || '' , Region : params . Region || '' , Method : params . Method || 'get' , Key : params . Key , Expires : params . Expires , } , function ( err , AuthData ) { if ( ! callback ) return ; if ( err ) { callback ( err ) ; return ; } var signUrl = url ; signUrl += '?' + ( AuthData . Authorization . indexOf ( 'q-signature' ) > - 1 ? AuthData . Authorization : 'sign=' + encodeURIComponent ( AuthData . Authorization ) ) ; AuthData . XCosSecurityToken && ( signUrl += '&x-cos-security-token=' + AuthData . XCosSecurityToken ) ; AuthData . ClientIP && ( signUrl += '&clientIP=' + AuthData . ClientIP ) ; AuthData . ClientUA && ( signUrl += '&clientUA=' + AuthData . ClientUA ) ; AuthData . Token && ( signUrl += '&token=' + AuthData . Token ) ; setTimeout ( function ( ) { callback ( null , { Url : signUrl } ) ; } ) ; } ) ; if ( AuthData ) { return url + '?' + AuthData . Authorization + ( AuthData . XCosSecurityToken ? '&x-cos-security-token=' + AuthData . XCosSecurityToken : '' ) ; } else { return url ; } } 
function decodeAcl ( AccessControlPolicy ) { var result = { GrantFullControl : [ ] , GrantWrite : [ ] , GrantRead : [ ] , GrantReadAcp : [ ] , GrantWriteAcp : [ ] , ACL : '' , } ; var GrantMap = { 'FULL_CONTROL' : 'GrantFullControl' , 'WRITE' : 'GrantWrite' , 'READ' : 'GrantRead' , 'READ_ACP' : 'GrantReadAcp' , 'WRITE_ACP' : 'GrantWriteAcp' , } ; var Grant = AccessControlPolicy . AccessControlList . Grant ; if ( Grant ) { Grant = util . isArray ( Grant ) ? Grant : [ Grant ] ; } var PublicAcl = { READ : 0 , WRITE : 0 , FULL_CONTROL : 0 } ; Grant . length && util . each ( Grant , function ( item ) { if ( item . Grantee . ID === 'qcs::cam::anyone:anyone' || item . Grantee . URI === 'http://cam.qcloud.com/groups/global/AllUsers' ) { PublicAcl [ item . Permission ] = 1 ; } else if ( item . Grantee . ID !== AccessControlPolicy . Owner . ID ) { result [ GrantMap [ item . Permission ] ] . push ( 'id="' + item . Grantee . ID + '"' ) ; } } ) ; if ( PublicAcl . FULL_CONTROL || ( PublicAcl . WRITE && PublicAcl . READ ) ) { result . ACL = 'public-read-write' ; } else if ( PublicAcl . READ ) { result . ACL = 'public-read' ; } else { result . ACL = 'private' ; } util . each ( GrantMap , function ( item ) { result [ item ] = uniqGrant ( result [ item ] . join ( ',' ) ) ; } ) ; return result ; } 
function uniqGrant ( str ) { var arr = str . split ( ',' ) ; var exist = { } ; var i , item ; for ( i = 0 ; i < arr . length ; ) { item = arr [ i ] . trim ( ) ; if ( exist [ item ] ) { arr . splice ( i , 1 ) ; } else { exist [ item ] = true ; arr [ i ] = item ; i ++ ; } } return arr . join ( ',' ) ; } 
function getUrl ( params ) { var longBucket = params . bucket ; var shortBucket = longBucket . substr ( 0 , longBucket . lastIndexOf ( '-' ) ) ; var appId = longBucket . substr ( longBucket . lastIndexOf ( '-' ) + 1 ) ; var domain = params . domain ; var region = params . region ; var object = params . object ; var protocol = params . protocol || ( util . isBrowser && location . protocol === 'http:' ? 'http:' : 'https:' ) ; if ( ! domain ) { if ( [ 'cn-south' , 'cn-south-2' , 'cn-north' , 'cn-east' , 'cn-southwest' , 'sg' ] . indexOf ( region ) > - 1 ) { domain = '{Region}.myqcloud.com' ; } else { domain = 'cos.{Region}.myqcloud.com' ; } if ( ! params . ForcePathStyle ) { domain = '{Bucket}.' + domain ; } } domain = domain . replace ( / \{\{AppId\}\} / ig , appId ) . replace ( / \{\{Bucket\}\} / ig , shortBucket ) . replace ( / \{\{Region\}\} / ig , region ) . replace ( / \{\{.*?\}\} / ig , '' ) ; domain = domain . replace ( / \{AppId\} / ig , appId ) . replace ( / \{BucketName\} / ig , shortBucket ) . replace ( / \{Bucket\} / ig , longBucket ) . replace ( / \{Region\} / ig , region ) . replace ( / \{.*?\} / ig , '' ) ; if ( ! / ^[a-zA-Z]+:\/\/ / . test ( domain ) ) { domain = protocol + '//' + domain ; } 
function submitRequest ( params , callback ) { var self = this ; 
function _submitRequest ( params , callback ) { var self = this ; var TaskId = params . TaskId ; if ( TaskId && ! self . _isRunningTask ( TaskId ) ) return ; var bucket = params . Bucket ; var region = params . Region ; var object = params . Key ; var method = params . method || 'GET' ; var url = params . url ; var body = params . body ; var json = params . json ; var rawBody = params . rawBody ; 
function ( data ) { if ( data . TaskId === TaskId ) { sender && sender . abort && sender . abort ( ) ; self . off ( 'inner-kill-task' , killTask ) ; } } 
function ( opt ) { var pathname = opt . Pathname || '/' ; var expires = opt . Expires ; var ShortBucketName = '' ; var AppId = '' ; var match = opt . Bucket . match ( / ^(.+)-(\d+)$ / ) ; if ( match ) { ShortBucketName = match [ 1 ] ; AppId = match [ 2 ] ; } var random = parseInt ( Math . random ( ) * Math . pow ( 2 , 32 ) ) ; var now = parseInt ( Date . now ( ) / 1000 ) ; var e = now + ( expires === undefined ? 900 : ( expires * 1 || 0 ) ) ; 
function ( opt ) { if ( ! opt . SecretId ) return console . error ( 'missing param SecretId' ) ; if ( ! opt . SecretKey ) return console . error ( 'missing param SecretKey' ) ; if ( opt . Version === '4.0' ) { return CosAuthV4 ( opt ) ; } opt = opt || { } ; var SecretId = opt . SecretId ; var SecretKey = opt . SecretKey ; var method = ( opt . Method || 'get' ) . toLowerCase ( ) ; var query = opt . Query || { } ; var headers = opt . Headers || { } ; var pathname = opt . Pathname || '/' ; var expires = opt . Expires ; var getObjectKeys = function ( obj ) { var list = [ ] ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) { list . push ( key ) ; } } return list . sort ( function ( a , b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; return a === b ? 0 : ( a > b ? 1 : - 1 ) ; } ) ; } ; var obj2str = function ( obj ) { var i , key , val ; var list = [ ] ; var keyList = getObjectKeys ( obj ) ; for ( i = 0 ; i < keyList . length ; i ++ ) { key = keyList [ i ] ; val = ( obj [ key ] === undefined || obj [ key ] === null ) ? '' : ( '' + obj [ key ] ) ; key = key . toLowerCase ( ) ; key = camSafeUrlEncode ( key ) ; val = camSafeUrlEncode ( val ) || '' ; list . push ( key + '=' + val ) } return list . join ( '&' ) ; } ; 
function ( opt ) { opt = opt || { } ; var SecretId = opt . SecretId ; var SecretKey = opt . SecretKey ; var method = ( opt . method || opt . Method || 'get' ) . toLowerCase ( ) ; var queryParams = clone ( opt . Query || opt . params || { } ) ; var headers = clone ( opt . Headers || opt . headers || { } ) ; var Key = opt . Key || '' ; var pathname ; if ( opt . UseRawKey ) { pathname = opt . Pathname || opt . pathname || '/' + Key ; } else { pathname = opt . Pathname || opt . pathname || Key ; pathname . indexOf ( '/' ) !== 0 && ( pathname = '/' + pathname ) ; } if ( ! SecretId ) return console . error ( 'missing param SecretId' ) ; if ( ! SecretKey ) return console . error ( 'missing param SecretKey' ) ; var getObjectKeys = function ( obj ) { var list = [ ] ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) { list . push ( key ) ; } } return list . sort ( function ( a , b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; return a === b ? 0 : ( a > b ? 1 : - 1 ) ; } ) ; } ; var obj2str = function ( obj ) { var i , key , val ; var list = [ ] ; var keyList = getObjectKeys ( obj ) ; for ( i = 0 ; i < keyList . length ; i ++ ) { key = keyList [ i ] ; val = ( obj [ key ] === undefined || obj [ key ] === null ) ? '' : ( '' + obj [ key ] ) ; key = key . toLowerCase ( ) ; key = camSafeUrlEncode ( key ) ; val = camSafeUrlEncode ( val ) || '' ; list . push ( key + '=' + val ) } return list . join ( '&' ) ; } ; 
function ( obj ) { var retObj = { } ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) && obj [ key ] !== undefined && obj [ key ] !== null ) { retObj [ key ] = obj [ key ] ; } } return retObj ; } 
function ( blob , callback ) { readAsBinaryString ( blob , function ( content ) { var hash = md5 ( content , true ) ; callback ( null , hash ) ; } ) ; } 
function ( result ) { if ( result && result . headers ) { result . headers [ 'x-cos-version-id' ] && ( result . VersionId = result . headers [ 'x-cos-version-id' ] ) ; result . headers [ 'x-cos-delete-marker' ] && ( result . DeleteMarker = result . headers [ 'x-cos-delete-marker' ] ) ; } return result ; } 
function getUploadIdAndPartList ( params , callback ) { var TaskId = params . TaskId ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var StorageClass = params . StorageClass ; var self = this ; 
function ( PartList , callback ) { var PartCount = PartList . length ; 
function ( index ) { if ( index < PartCount ) { var Part = PartList [ index ] ; getChunkETag ( Part . PartNumber , function ( err , chunk ) { if ( chunk && chunk . ETag === Part . ETag && chunk . Size === Part . Size ) { next ( index + 1 ) ; } else { callback ( null , false ) ; } } ) ; } else { callback ( null , true ) ; } } 
function wholeMultipartList ( params , callback ) { var self = this ; var UploadList = [ ] ; var sendParams = { Bucket : params . Bucket , Region : params . Region , Prefix : params . Key } ; var next = function ( ) { self . multipartList ( sendParams , function ( err , data ) { if ( err ) return callback ( err ) ; UploadList . push . apply ( UploadList , data . Upload || [ ] ) ; if ( data . IsTruncated === 'true' ) { 
function wholeMultipartListPart ( params , callback ) { var self = this ; var PartList = [ ] ; var sendParams = { Bucket : params . Bucket , Region : params . Region , Key : params . Key , UploadId : params . UploadId } ; var next = function ( ) { self . multipartListPart ( sendParams , function ( err , data ) { if ( err ) return callback ( err ) ; PartList . push . apply ( PartList , data . Part || [ ] ) ; if ( data . IsTruncated === 'true' ) { 
function uploadSliceList ( params , cb ) { var self = this ; var TaskId = params . TaskId ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var UploadData = params . UploadData ; var FileSize = params . FileSize ; var SliceSize = params . SliceSize ; var ChunkParallel = Math . min ( params . AsyncLimit || self . options . ChunkParallelLimit || 1 , 256 ) ; var Body = params . Body ; var SliceCount = Math . ceil ( FileSize / SliceSize ) ; var FinishSize = 0 ; var ServerSideEncryption = params . ServerSideEncryption ; var needUploadSlices = util . filter ( UploadData . PartList , function ( SliceItem ) { if ( SliceItem [ 'Uploaded' ] ) { FinishSize += SliceItem [ 'PartNumber' ] >= SliceCount ? ( FileSize % SliceSize || SliceSize ) : SliceSize ; } return ! SliceItem [ 'Uploaded' ] ; } ) ; var onProgress = params . onProgress ; Async . eachLimit ( needUploadSlices , ChunkParallel , function ( SliceItem , asyncCallback ) { if ( ! self . _isRunningTask ( TaskId ) ) return ; var PartNumber = SliceItem [ 'PartNumber' ] ; var currentSize = Math . min ( FileSize , SliceItem [ 'PartNumber' ] * SliceSize ) - ( SliceItem [ 'PartNumber' ] - 1 ) * SliceSize ; var preAddSize = 0 ; uploadSliceItem . call ( self , { TaskId : TaskId , Bucket : Bucket , Region : Region , Key : Key , SliceSize : SliceSize , FileSize : FileSize , PartNumber : PartNumber , ServerSideEncryption : ServerSideEncryption , Body : Body , UploadData : UploadData , onProgress : function ( data ) { FinishSize += data . loaded - preAddSize ; preAddSize = data . loaded ; onProgress ( { loaded : FinishSize , total : FileSize } ) ; } , } , function ( err , data ) { if ( ! self . _isRunningTask ( TaskId ) ) return ; if ( util . isBrowser && ! err && ! data . ETag ) { err = 'get ETag error, please add "ETag" to CORS ExposeHeader setting.' ; } if ( err ) { FinishSize -= preAddSize ; } else { FinishSize += currentSize - preAddSize ; SliceItem . ETag = data . ETag ; } asyncCallback ( err || null , data ) ; } ) ; } , function ( err ) { if ( ! self . _isRunningTask ( TaskId ) ) return ; if ( err ) return cb ( err ) ; cb ( null , { UploadId : UploadData . UploadId , SliceList : UploadData . PartList } ) ; } ) ; } 
function uploadSliceComplete ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var UploadId = params . UploadId ; var SliceList = params . SliceList ; var self = this ; var ChunkRetryTimes = this . options . ChunkRetryTimes + 1 ; var Parts = SliceList . map ( function ( item ) { return { PartNumber : item . PartNumber , ETag : item . ETag } ; } ) ; 
function abortUploadTask ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var UploadId = params . UploadId ; var Level = params . Level || 'task' ; var AsyncLimit = params . AsyncLimit ; var self = this ; var ep = new EventProxy ( ) ; ep . on ( 'error' , function ( errData ) { return callback ( errData ) ; } ) ; 
function abortUploadTaskArray ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var AbortArray = params . AbortArray ; var AsyncLimit = params . AsyncLimit || 1 ; var self = this ; var index = 0 ; var resultList = new Array ( AbortArray . length ) ; Async . eachLimit ( AbortArray , AsyncLimit , function ( AbortItem , callback ) { var eachIndex = index ; if ( Key && Key !== AbortItem . Key ) { resultList [ eachIndex ] = { error : { KeyNotMatch : true } } ; callback ( null ) ; return ; } var UploadId = AbortItem . UploadId || AbortItem . UploadID ; self . multipartAbort ( { Bucket : Bucket , Region : Region , Key : AbortItem . Key , Headers : params . Headers , UploadId : UploadId } , function ( err , data ) { var task = { Bucket : Bucket , Region : Region , Key : AbortItem . Key , UploadId : UploadId } ; resultList [ eachIndex ] = { error : err , task : task } ; callback ( null ) ; } ) ; index ++ ; } , function ( err ) { if ( err ) { return callback ( err ) ; } var successList = [ ] ; var errorList = [ ] ; for ( var i = 0 , len = resultList . length ; i < len ; i ++ ) { var item = resultList [ i ] ; if ( item [ 'task' ] ) { if ( item [ 'error' ] ) { errorList . push ( item [ 'task' ] ) ; } else { successList . push ( item [ 'task' ] ) ; } } } return callback ( null , { successList : successList , errorList : errorList } ) ; } ) ; } 
function sliceCopyFile ( params , callback ) { var ep = new EventProxy ( ) ; var self = this ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var CopySource = params . CopySource ; var m = CopySource . match ( / ^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^/]+\/(.+)$ / ) ; if ( ! m ) { callback ( { error : 'CopySource format error' } ) ; return ; } var SourceBucket = m [ 1 ] ; var SourceRegion = m [ 3 ] ; var SourceKey = decodeURIComponent ( m [ 4 ] ) ; var CopySliceSize = params . SliceSize === undefined ? self . options . CopySliceSize : params . SliceSize ; CopySliceSize = Math . max ( 0 , Math . min ( CopySliceSize , 5 * 1024 * 1024 * 1024 ) ) ; var ChunkSize = params . ChunkSize || this . options . CopyChunkSize ; var ChunkParallel = this . options . CopyChunkParallelLimit ; var FinishSize = 0 ; var FileSize ; var onProgress ; 
function copySliceItem ( params , callback ) { var TaskId = params . TaskId ; var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var CopySource = params . CopySource ; var UploadId = params . UploadId ; var PartNumber = params . PartNumber * 1 ; var CopySourceRange = params . CopySourceRange ; var ChunkRetryTimes = this . options . ChunkRetryTimes + 1 ; var self = this ; Async . retry ( ChunkRetryTimes , function ( tryCallback ) { self . uploadPartCopy ( { TaskId : TaskId , Bucket : Bucket , Region : Region , Key : Key , CopySource : CopySource , UploadId : UploadId , PartNumber : PartNumber , CopySourceRange : CopySourceRange , onProgress : params . onProgress , } , function ( err , data ) { tryCallback ( err || null , data ) ; } ) } , function ( err , data ) { return callback ( err , data ) ; } ) ; } 
function stringify ( content ) { if ( typeof content === 'string' && stringifiedRegexp . test ( content ) ) { return content ; } return JSON . stringify ( content , null , 2 ) ; } 
function getModuleChunk ( module , modules ) { let chunks ; if ( webpackVersion . IS_4 ) { chunks = Array . from ( module . chunksIterable ) ; } else if ( parseInt ( webpackVersion ( ) , 10 ) >= 3 ) { chunks = module . mapChunks ( ) ; } else { chunks = module . chunks ; } 
function getLoaderOptions ( loaderPath , rule ) { let multiRuleProp ; if ( isWebpack1 ) { multiRuleProp = 'loaders' ; } else if ( rule . oneOf ) { multiRuleProp = 'oneOf' ; } else { multiRuleProp = 'use' ; } const multiRule = typeof rule === 'object' && Array . isArray ( rule [ multiRuleProp ] ) ? rule [ multiRuleProp ] : null ; let options ; if ( multiRule ) { const rules = [ ] . concat ( ... multiRule . map ( r => ( r . use || r ) ) ) ; options = rules . map ( normalizeRule ) . find ( r => loaderPath . includes ( r . loader ) ) . options ; } else { options = normalizeRule ( rule ) . options ; } return options ; } 
function normalizeRule ( rule ) { if ( ! rule ) { throw new Error ( 'Rule should be string or object' ) ; } let data ; if ( typeof rule === 'string' ) { const parts = rule . split ( '?' ) ; data = { loader : parts [ 0 ] , options : parts [ 1 ] ? parseQuery ( ` ${ parts [ 1 ] } ` ) : null } ; } else { const options = isWebpack1 ? rule . query : rule . options ; data = { loader : rule . loader , options : options || null } ; } return data ; } 
function findChild ( info , children , handler , reverse ) { const len = children . length if ( reverse ) { for ( let i = len - 1 ; i >= 0 ; i -- ) { const item = children [ i ] 
function findParent ( node , handle ) { let current = node while ( current ) { if ( handle ( current ) ) { return current } current = current . parent } } 
function pure ( node , withChildren , after ) { var _this2 = this ; var t = assign$1 ( { } , node ) ; delete t . _id ; delete t . parent ; delete t . children ; delete t . open ; delete t . active ; delete t . style ; delete t . class ; delete t . innerStyle ; delete t . innerClass ; delete t . innerBackStyle ; delete t . innerBackClass ; var _arr = keys$1 ( t ) ; for ( var _i = 0 ; _i < _arr . length ; _i ++ ) { var key = _arr [ _i ] ; if ( key [ 0 ] === '_' ) { delete t [ key ] ; } } if ( withChildren && node . children ) { t . children = node . children . slice ( ) ; t . children . forEach ( function ( v , k ) { t . children [ k ] = _this2 . pure ( v , withChildren ) ; } ) ; } if ( after ) { return after ( t , node ) || t ; } return t ; } 
function findChild ( info , children , handler , reverse ) { var len = children . length ; if ( reverse ) { for ( var i = len - 1 ; i >= 0 ; i -- ) { var item = children [ i ] ; 
function currentTreeEmpty ( info ) { return ! findChild ( info , info . currentTree . rootData . children , function ( v ) { return v ; } ) ; } 
function targetNodeHasChildrenExcludingPlaceholder ( info ) { return findChild ( info , info . targetNode . children , function ( v ) { return v !== info . dplh ; } ) ; } 
function targetNodeIs1stChild ( info ) { return findChild ( info , info . targetNode . parent . children , function ( v ) { return v ; } ) === info . targetNode ; } 
function targetNodeIsLastChild ( info ) { return findChild ( info , info . targetNode . parent . children , function ( v ) { return v ; } , true ) === info . targetNode ; } 
function atIndentRight ( info ) { return info . offset . x > info . tiOffset . x + info . currentTree . indent ; } 
function autoMoveDragPlaceHolder ( draggableHelperInfo ) { var trees = this . store . trees ; var dhStore = draggableHelperInfo . store ; 
function offset2 ( ) { return { x : this . offset . x + this . nodeInnerEl . offsetWidth , y : this . offset . y + this . nodeInnerEl . offsetHeight } ; } 
function offsetToViewPort ( ) { var r = this . nodeInnerEl . getBoundingClientRect ( ) ; r . x = r . left ; r . y = r . top ; return r ; } 
function currentTreeRootSecondChildExcludingDragging ( ) { var _this = this ; return this . currentTree . rootData . children . slice ( 0 , 3 ) . filter ( function ( v ) { return v !== _this . node ; } ) [ 1 ] ; } 
function exec ( ruleId ) { if ( ! executedRuleCache . hasOwnProperty ( ruleId ) ) { var r ; try { r = rules [ ruleId ] ( info ) ; } catch ( e ) { r = e ; try { if ( process . env . DEVELOPE_SELF ) { 
function appendPrev ( info ) { if ( isNodeDroppable ( info . targetPrev ) ) { th . appendTo ( info . dplh , info . targetPrev ) ; if ( ! info . targetPrev . open ) info . store . toggleOpen ( info . targetPrev ) ; } else { insertDplhAfterTo ( info . dplh , info . targetPrev , info ) ; } } 
function appendCurrentTree ( info ) { if ( isNodeDroppable ( info . currentTree . rootData ) ) { th . appendTo ( info . dplh , info . currentTree . rootData ) ; } } 
function currentTree ( ) { 
function targetNode ( ) { var currentTree = this . currentTree ; if ( ! currentTree ) { throw 'no currentTree' ; } 
function stripViewFromSelector ( selector ) { 
async function getPidUsingPattern ( pgrepPattern ) { const args = [ '-nif' , pgrepPattern ] ; try { const { stdout } = await exec ( 'pgrep' , args ) ; const pid = parseInt ( stdout , 10 ) ; if ( isNaN ( pid ) ) { log . debug ( ` ${ args . join ( ' ' ) } ${ stdout } ` ) ; return null ; } return ` ${ pid } ` ; } catch ( err ) { log . debug ( ` ${ args . join ( ' ' ) } ${ err . code } ` ) ; return null ; } } 
async function killAppUsingPattern ( pgrepPattern ) { for ( const signal of [ 2 , 15 , 9 ] ) { if ( ! await getPidUsingPattern ( pgrepPattern ) ) { return ; } const args = [ ` ${ signal } ` , '-if' , pgrepPattern ] ; try { await exec ( 'pkill' , args ) ; } catch ( err ) { log . debug ( ` ${ args . join ( ' ' ) } ${ err . message } ` ) ; } await B . delay ( 100 ) ; } } 
async function getPIDsListeningOnPort ( port , filteringFunc = null ) { const result = [ ] ; try { 
async function encodeBase64OrUpload ( localFile , remotePath = null , uploadOptions = { } ) { if ( ! await fs . exists ( localFile ) ) { log . errorAndThrow ( ` ${ localFile } ` ) ; } const { size } = await fs . stat ( localFile ) ; log . debug ( ` ${ util . toReadableSizeString ( size ) } ` ) ; if ( _ . isEmpty ( remotePath ) ) { const maxMemoryLimit = v8 . getHeapStatistics ( ) . total_available_size / 2 ; if ( size >= maxMemoryLimit ) { log . info ( ` ` + ` ${ util . toReadableSizeString ( size ) } ${ util . toReadableSizeString ( maxMemoryLimit ) } ` + ` ` + ` ` ) ; } const content = await fs . readFile ( localFile ) ; return content . toString ( 'base64' ) ; } const remoteUrl = url . parse ( remotePath ) ; let options = { } ; const { user , pass , method } = uploadOptions ; if ( remoteUrl . protocol . startsWith ( 'http' ) ) { options = { url : remoteUrl . href , method : method || 'PUT' , multipart : [ { body : _fs . createReadStream ( localFile ) } ] , } ; if ( user && pass ) { options . auth = { user , pass } ; } } else if ( remoteUrl . protocol === 'ftp:' ) { options = { host : remoteUrl . hostname , port : remoteUrl . port || 21 , } ; if ( user && pass ) { options . user = user ; options . pass = pass ; } } await net . uploadFile ( localFile , remotePath , options ) ; return '' ; } 
async function removeAllSessionWebSocketHandlers ( server , sessionId ) { if ( ! server || ! _ . isFunction ( server . getWebSocketHandlers ) ) { return ; } const activeHandlers = await server . getWebSocketHandlers ( sessionId ) ; for ( const pathname of _ . keys ( activeHandlers ) ) { await server . removeWebSocketHandler ( pathname ) ; } } 
async function verifyApplicationPlatform ( app , isSimulator ) { log . debug ( 'Verifying application platform' ) ; const infoPlist = path . resolve ( app , 'Info.plist' ) ; if ( ! await fs . exists ( infoPlist ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const { CFBundleSupportedPlatforms } = await plist . parsePlistFile ( infoPlist ) ; log . debug ( ` ${ JSON . stringify ( CFBundleSupportedPlatforms ) } ` ) ; if ( ! _ . isArray ( CFBundleSupportedPlatforms ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const isAppSupported = ( isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneSimulator' ) ) || ( ! isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneOS' ) ) ; if ( isAppSupported ) { return true ; } throw new Error ( ` ${ isSimulator ? 'Simulator' : 'Real device' } ${ app } ` + ` ` ) ; } 
function isLocalHost ( urlString ) { try { const { hostname } = url . parse ( urlString ) ; return [ 'localhost' , '127.0.0.1' , '::1' , '::ffff:127.0.0.1' ] . includes ( hostname ) ; } catch { log . warn ( ` ${ urlString } ` ) ; } return false ; } 
function normalizePlatformVersion ( originalVersion ) { const normalizedVersion = util . coerceVersion ( originalVersion , false ) ; if ( ! normalizedVersion ) { throw new Error ( ` ${ originalVersion } ` ) ; } const { major , minor } = new semver . SemVer ( normalizedVersion ) ; return ` ${ major } ${ minor } ` ; } 
async function updateProjectFile ( agentPath , newBundleId ) { let projectFilePath = ` ${ agentPath } ${ PROJECT_FILE } ` ; try { 
async function resetProjectFile ( agentPath ) { let projectFilePath = ` ${ agentPath } ${ PROJECT_FILE } ` ; try { 
function getAdditionalRunContent ( platformName , wdaRemotePort ) { const runner = ` ${ isTvOS ( platformName ) ? '_tvOS' : '' } ` ; return { [ runner ] : { EnvironmentVariables : { USE_PORT : wdaRemotePort } } } ; } 
async function getWDAUpgradeTimestamp ( bootstrapPath ) { const carthageRootPath = path . resolve ( bootstrapPath , CARTHAGE_ROOT ) ; if ( await fs . exists ( carthageRootPath ) ) { const { mtime } = await fs . stat ( carthageRootPath ) ; return mtime . getTime ( ) ; } return null ; } 
function toMobileConfig ( certBuffer , commonName ) { const getUUID = ( ) => UUID . create ( ) . hex . toUpperCase ( ) ; const contentUuid = getUUID ( ) ; return { PayloadContent : [ { PayloadCertificateFileName : ` ${ commonName } ` , PayloadContent : certBuffer , PayloadDescription : 'Adds a CA root certificate' , PayloadDisplayName : commonName , PayloadIdentifier : ` ${ contentUuid } ` , PayloadType : 'com.apple.security.root' , PayloadUUID : contentUuid , PayloadVersion : 1 } ] , PayloadDisplayName : commonName , PayloadIdentifier : ` ${ os . hostname ( ) . split ( '.' ) [ 0 ] } ${ getUUID ( ) } ` , PayloadRemovalDisallowed : false , PayloadType : 'Configuration' , PayloadUUID : getUUID ( ) , PayloadVersion : 1 } ; } 
function getTreeForXML ( srcTree ) { function getTree ( element , elementIndex , parentPath ) { let curPath = ` ${ parentPath } ${ elementIndex } ` ; let rect = element . rect || { } ; let subtree = { '@' : { type : ` ${ element . type } ` , enabled : parseInt ( element . isEnabled , 10 ) === 1 , visible : parseInt ( element . isVisible , 10 ) === 1 , x : rect . x , y : rect . y , width : rect . width , height : rect . height , } , '>' : [ ] } ; if ( element . name !== null ) { subtree [ '@' ] . name = element . name ; } if ( element . label !== null ) { subtree [ '@' ] . label = element . label ; } if ( element . value !== null ) { subtree [ '@' ] . value = element . value ; } for ( let i = 0 ; i < ( element . children || [ ] ) . length ; i ++ ) { subtree [ '>' ] . push ( getTree ( element . children [ i ] , i , curPath ) ) ; } return { [ ` ${ element . type } ` ] : subtree } ; } let tree = getTree ( srcTree , 0 , '' ) ; return tree ; } 
async function parseContainerPath ( remotePath , containerRootSupplier ) { const match = CONTAINER_PATH_PATTERN . exec ( remotePath ) ; if ( ! match ) { log . errorAndThrow ( ` ` + ` ${ CONTAINER_PATH_MARKER } ` + ` ${ remotePath } ` ) ; } let [ , bundleId , relativePath ] = match ; let containerType = null ; const typeSeparatorPos = bundleId . indexOf ( CONTAINER_TYPE_SEPARATOR ) ; 
async function pushFileToSimulator ( device , remotePath , base64Data ) { const buffer = Buffer . from ( base64Data , 'base64' ) ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; if ( ! await fs . exists ( path . dirname ( dstPath ) ) ) { log . debug ( ` ${ path . dirname ( dstPath ) } ` ) ; await mkdirp ( path . dirname ( dstPath ) ) ; } await fs . writeFile ( dstPath , buffer ) ; return ; } const dstFolder = await tempDir . openDir ( ) ; const dstPath = path . resolve ( dstFolder , path . basename ( remotePath ) ) ; try { await fs . writeFile ( dstPath , buffer ) ; await addMedia ( device . udid , dstPath ) ; } finally { await fs . rimraf ( dstFolder ) ; } } 
async function pushFileToRealDevice ( device , remotePath , base64Data ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( path . dirname ( dstPath ) ) ) { log . debug ( ` ${ path . dirname ( dstPath ) } ` ) ; await mkdirp ( path . dirname ( dstPath ) ) ; } await fs . writeFile ( dstPath , Buffer . from ( base64Data , 'base64' ) ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } } 
async function pullFromSimulator ( device , remotePath , isFile ) { let pathOnServer ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; pathOnServer = dstPath ; } else { const simRoot = device . getDir ( ) ; pathOnServer = path . posix . join ( simRoot , remotePath ) ; verifyIsSubPath ( pathOnServer , simRoot ) ; log . info ( ` ${ pathOnServer } ` ) ; } if ( ! await fs . exists ( pathOnServer ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ pathOnServer } ` ) ; } const buffer = isFile ? await fs . readFile ( pathOnServer ) : await zip . toInMemoryZip ( pathOnServer ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } 
async function pullFromRealDevice ( device , remotePath , isFile ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( dstPath ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ dstPath } ` ) ; } const buffer = isFile ? await fs . readFile ( dstPath ) : await zip . toInMemoryZip ( dstPath ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } } 
async function createSim ( caps , platform = PLATFORM_NAME_IOS ) { const appiumTestDeviceName = ` ${ UUID . create ( ) . toString ( ) . toUpperCase ( ) } ${ caps . deviceName } ` ; const udid = await createDevice ( appiumTestDeviceName , caps . deviceName , caps . platformVersion , { platform } ) ; return await getSimulator ( udid ) ; } 
async function getExistingSim ( opts ) { const devices = await getDevices ( opts . platformVersion ) ; const appiumTestDeviceName = ` ${ opts . deviceName } ` ; let appiumTestDevice ; for ( const device of _ . values ( devices ) ) { if ( device . name === opts . deviceName ) { return await getSimulator ( device . udid ) ; } if ( device . name === appiumTestDeviceName ) { appiumTestDevice = device ; } } if ( appiumTestDevice ) { log . warn ( ` ${ opts . deviceName } ${ appiumTestDevice . name } ${ appiumTestDevice . udid } ` ) ; return await getSimulator ( appiumTestDevice . udid ) ; } return null ; } 
function ( ) { const el = this . el ; this . velocityCtrl = null ; this . velocity = new THREE . Vector3 ( ) ; this . heading = new THREE . Quaternion ( ) ; 
function ( ) { const data = this . data ; if ( data . enabled ) { for ( let i = 0 , l = data . controls . length ; i < l ; i ++ ) { const control = this . el . components [ data . controls [ i ] + COMPONENT_SUFFIX ] ; if ( control && control . isVelocityActive ( ) ) { this . velocityCtrl = control ; return ; } } this . velocityCtrl = null ; } } 
function parsePhysicsModel ( xml ) { var data = { name : xml . getAttribute ( 'name' ) || '' , rigidBodies : { } } ; for ( var i = 0 ; i < xml . childNodes . length ; i ++ ) { var child = xml . childNodes [ i ] ; if ( child . nodeType !== 1 ) continue ; switch ( child . nodeName ) { case 'rigid_body' : data . rigidBodies [ child . getAttribute ( 'name' ) ] = { } ; parsePhysicsRigidBody ( child , data . rigidBodies [ child . getAttribute ( 'name' ) ] ) ; break ; } } library . physicsModels [ xml . getAttribute ( 'id' ) ] = data ; } 
function prepareNodes ( xml ) { var elements = xml . getElementsByTagName ( 'node' ) ; 
function parseVisualScene ( xml ) { var data = { name : xml . getAttribute ( 'name' ) , children : [ ] } ; prepareNodes ( xml ) ; var elements = getElementsByTagName ( xml , 'node' ) ; for ( var i = 0 ; i < elements . length ; i ++ ) { data . children . push ( parseNode ( elements [ i ] ) ) ; } library . visualScenes [ xml . getAttribute ( 'id' ) ] = data ; } 
function ( ) { const data = this . data ; let objectEls ; 
function intersect ( el ) { let radius , mesh , distance , extent ; if ( ! el . isEntity ) { return ; } mesh = el . getObject3D ( 'mesh' ) ; if ( ! mesh ) { return ; } box . setFromObject ( mesh ) . getSize ( size ) ; extent = Math . max ( size . x , size . y , size . z ) / 2 ; radius = Math . sqrt ( 2 * extent * extent ) ; box . getCenter ( meshPosition ) ; if ( ! radius ) { return ; } distance = position . distanceTo ( meshPosition ) ; if ( distance < radius + colliderRadius ) { collisions . push ( el ) ; distanceMap . set ( el , distance ) ; } } 
function ( ) { this . system = this . el . sceneEl . systems . physics ; this . system . addComponent ( this ) ; const el = this . el , data = this . data , position = ( new CANNON . Vec3 ( ) ) . copy ( el . object3D . getWorldPosition ( new THREE . Vector3 ( ) ) ) ; this . body = new CANNON . Body ( { material : this . system . getMaterial ( 'staticMaterial' ) , position : position , mass : data . mass , linearDamping : data . linearDamping , fixedRotation : true } ) ; this . body . addShape ( new CANNON . Sphere ( data . radius ) , new CANNON . Vec3 ( 0 , data . radius , 0 ) ) ; this . body . el = this . el ; this . el . body = this . body ; this . system . addBody ( this . body ) ; if ( el . hasAttribute ( 'wasd-controls' ) ) { console . warn ( '[kinematic-body] Not compatible with wasd-controls, use movement-controls.' ) ; } } 
function ( t , dt ) { if ( ! dt ) return ; const el = this . el ; const data = this . data const body = this . body ; if ( ! data . enableJumps ) body . velocity . set ( 0 , 0 , 0 ) ; body . position . copy ( el . getAttribute ( 'position' ) ) ; } 
function ( groundBody , groundNormal ) { let ray , hitNormal , vFrom = this . body . position , vTo = this . body . position . clone ( ) ; ray = new CANNON . Ray ( vFrom , vTo ) ; ray . _updateDirection ( ) ; 
function ( ) { const scene = this . el . sceneEl ; this . prevTime = window . performance . now ( ) ; 
function ( ) { if ( ! this . data . enabled || ! this . isConnected ( ) ) return false ; const dpad = this . getDpad ( ) , joystick0 = this . getJoystick ( 0 ) , inputX = dpad . x || joystick0 . x , inputY = dpad . y || joystick0 . y ; return Math . abs ( inputX ) > JOYSTICK_EPS || Math . abs ( inputY ) > JOYSTICK_EPS ; } 
function ( ) { if ( ! this . data . enabled || ! this . isConnected ( ) ) return false ; const joystick1 = this . getJoystick ( 1 ) ; return Math . abs ( joystick1 . x ) > JOYSTICK_EPS || Math . abs ( joystick1 . y ) > JOYSTICK_EPS ; } 
function ( index ) { const gamepad = this . getGamepad ( ) ; switch ( index ) { case 0 : return new THREE . Vector2 ( gamepad . axes [ 0 ] , gamepad . axes [ 1 ] ) ; case 1 : return new THREE . Vector2 ( gamepad . axes [ 2 ] , gamepad . axes [ 3 ] ) ; default : throw new Error ( 'Unexpected joystick index "%d".' , index ) ; } } 
function ( ) { const gamepad = this . getGamepad ( ) ; if ( ! gamepad . buttons [ GamepadButton . DPAD_RIGHT ] ) { return new THREE . Vector2 ( ) ; } return new THREE . Vector2 ( ( gamepad . buttons [ GamepadButton . DPAD_RIGHT ] . pressed ? 1 : 0 ) + ( gamepad . buttons [ GamepadButton . DPAD_LEFT ] . pressed ? - 1 : 0 ) , ( gamepad . buttons [ GamepadButton . DPAD_UP ] . pressed ? - 1 : 0 ) + ( gamepad . buttons [ GamepadButton . DPAD_DOWN ] . pressed ? 1 : 0 ) ) ; } 
function ( ) { const el = this . el , data = this . data ; let material = el . components . material ; const geometry = new THREE . PlaneGeometry ( data . width , data . depth , data . density , data . density ) ; geometry . mergeVertices ( ) ; this . waves = [ ] ; for ( let v , i = 0 , l = geometry . vertices . length ; i < l ; i ++ ) { v = geometry . vertices [ i ] ; this . waves . push ( { z : v . z , ang : Math . random ( ) * Math . PI * 2 , amp : data . amplitude + Math . random ( ) * data . amplitudeVariance , speed : ( data . speed + Math . random ( ) * data . speedVariance ) / 1000 
function URLSearchParamsPolyfill ( search ) { search = search || "" ; 
function LDAPResult ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalNumber ( options . status ) ; assert . optionalString ( options . matchedDN ) ; assert . optionalString ( options . errorMessage ) ; assert . optionalArrayOfString ( options . referrals ) ; LDAPMessage . call ( this , options ) ; this . status = options . status || 0 ; 
function BindResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_BIND ; LDAPResult . call ( this , options ) ; } 
function Change ( options ) { if ( options ) { assert . object ( options ) ; assert . optionalString ( options . operation ) ; } else { options = { } ; } this . _modification = false ; this . operation = options . operation || options . type || 'add' ; this . modification = options . modification || { } ; } 
function DeleteResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_DELETE ; LDAPResult . call ( this , options ) ; } 
function Control ( options ) { assert . optionalObject ( options ) ; options = options || { } ; assert . optionalString ( options . type ) ; assert . optionalBool ( options . criticality ) ; if ( options . value ) { assert . buffer ( options . value ) ; } this . type = options . type || '' ; this . criticality = options . critical || options . criticality || false ; this . value = options . value || null ; } 
function UnbindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_UNBIND ; LDAPMessage . call ( this , options ) ; } 
function SearchResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_SEARCH ; LDAPResult . call ( this , options ) ; this . attributes = options . attributes ? options . attributes . slice ( ) : [ ] ; this . notAttributes = [ ] ; this . sentEntries = 0 ; } 
function ModifyResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_MODIFY ; LDAPResult . call ( this , options ) ; } 
function RequestQueue ( opts ) { if ( ! opts || typeof ( opts ) !== 'object' ) { opts = { } ; } this . size = ( opts . size > 0 ) ? opts . size : Infinity ; this . timeout = ( opts . timeout > 0 ) ? opts . timeout : 0 ; this . _queue = [ ] ; this . _timer = null ; this . _frozen = false ; } 
function MessageTracker ( opts ) { assert . object ( opts ) ; assert . string ( opts . id ) ; assert . object ( opts . parser ) ; this . id = opts . id ; this . _msgid = 0 ; this . _messages = { } ; this . _abandoned = { } ; this . parser = opts . parser ; var self = this ; this . __defineGetter__ ( 'pending' , function ( ) { return Object . keys ( self . _messages ) ; } ) ; } 
function geWindow ( ref , comp ) { var max = ref + ( MAX_MSGID / 2 ) ; var min = ref ; if ( max >= MAX_MSGID ) { 
function Client ( options ) { assert . ok ( options ) ; EventEmitter . call ( this , options ) ; var self = this ; var _url ; if ( options . url ) _url = url . parse ( options . url ) ; this . host = _url ? _url . hostname : undefined ; this . port = _url ? _url . port : false ; this . secure = _url ? _url . secure : false ; this . url = _url ; this . tlsOptions = options . tlsOptions ; this . socketPath = options . socketPath || false ; this . log = options . log . child ( { clazz : 'Client' } , true ) ; this . timeout = parseInt ( ( options . timeout || 0 ) , 10 ) ; this . connectTimeout = parseInt ( ( options . connectTimeout || 0 ) , 10 ) ; this . idleTimeout = parseInt ( ( options . idleTimeout || 0 ) , 10 ) ; if ( options . reconnect ) { 
function connectSocket ( cb ) { cb = once ( cb ) ; function onResult ( err , res ) { if ( err ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } self . emit ( 'connectError' , err ) ; } cb ( err , res ) ; } function onConnect ( ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'connect' ) . removeAllListeners ( 'secureConnect' ) ; tracker . id = nextClientId ( ) + '__' + tracker . id ; self . log = self . log . child ( { ldap_id : tracker . id } , true ) ; 
function initSocket ( ) { tracker = new MessageTracker ( { id : self . url ? self . url . href : self . socketPath , parser : new Parser ( { log : log } ) } ) ; 
function setupClient ( cb ) { cb = once ( cb ) ; 
function postSetup ( ) { socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'close' ) . removeAllListeners ( 'end' ) . removeAllListeners ( 'timeout' ) ; 
function SearchEntry ( options ) { options = options || { } ; assert . object ( options ) ; lassert . optionalStringDN ( options . objectName ) ; options . protocolOp = Protocol . LDAP_REP_SEARCH_ENTRY ; LDAPMessage . call ( this , options ) ; this . objectName = options . objectName || null ; this . setAttributes ( options . attributes || [ ] ) ; } 
function Attribute ( options ) { if ( options ) { if ( typeof ( options ) !== 'object' ) throw new TypeError ( 'options must be an object' ) ; if ( options . type && typeof ( options . type ) !== 'string' ) throw new TypeError ( 'options.type must be a string' ) ; } else { options = { } ; } this . type = options . type || '' ; this . _vals = [ ] ; if ( options . vals !== undefined && options . vals !== null ) this . vals = options . vals ; } 
function SearchRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_SEARCH ; LDAPMessage . call ( this , options ) ; if ( options . baseObject !== undefined ) { this . baseObject = options . baseObject ; } else { this . baseObject = dn . parse ( '' ) ; } this . scope = options . scope || 'base' ; this . derefAliases = options . derefAliases || Protocol . NEVER_DEREF_ALIASES ; this . sizeLimit = options . sizeLimit || 0 ; this . timeLimit = options . timeLimit || 0 ; this . typesOnly = options . typesOnly || false ; this . filter = options . filter || null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; } 
function mergeFunctionArgs ( argv , start , end ) { assert . ok ( argv ) ; if ( ! start ) start = 0 ; if ( ! end ) end = argv . length ; var handlers = [ ] ; for ( var i = start ; i < end ; i ++ ) { if ( argv [ i ] instanceof Array ) { var arr = argv [ i ] ; for ( var j = 0 ; j < arr . length ; j ++ ) { if ( ! ( arr [ j ] instanceof Function ) ) { throw new TypeError ( 'Invalid argument type: ' + typeof ( arr [ j ] ) ) ; } handlers . push ( arr [ j ] ) ; } } else if ( argv [ i ] instanceof Function ) { handlers . push ( argv [ i ] ) ; } else { throw new TypeError ( 'Invalid argument type: ' + typeof ( argv [ i ] ) ) ; } } return handlers ; } 
function Server ( options ) { if ( options ) { if ( typeof ( options ) !== 'object' ) throw new TypeError ( 'options (object) required' ) ; if ( typeof ( options . log ) !== 'object' ) throw new TypeError ( 'options.log must be an object' ) ; if ( options . certificate || options . key ) { if ( ! ( options . certificate && options . key ) || ( typeof ( options . certificate ) !== 'string' && ! Buffer . isBuffer ( options . certificate ) ) || ( typeof ( options . key ) !== 'string' && ! Buffer . isBuffer ( options . key ) ) ) { throw new TypeError ( 'options.certificate and options.key ' + '(string or buffer) are both required for TLS' ) ; } } } else { options = { } ; } var self = this ; EventEmitter . call ( this , options ) ; this . _chain = [ ] ; this . log = options . log ; this . strictDN = ( options . strictDN !== undefined ) ? options . strictDN : true ; var log = this . log ; function setupConnection ( c ) { assert . ok ( c ) ; if ( c . type === 'unix' ) { c . remoteAddress = self . server . path ; c . remotePort = c . fd ; } else if ( c . socket ) { 
function _assert ( arg , type , name ) { name = name || type ; throw new assert . AssertionError ( { message : util . format ( '%s (%s) required' , name , type ) , actual : typeof ( arg ) , expected : type , operator : '===' , stackStartFunction : _assert . caller } ) ; } 
function AddResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_ADD ; LDAPResult . call ( this , options ) ; } 
function Parser ( options ) { assert . object ( options ) ; assert . object ( options . log ) ; EventEmitter . call ( this ) ; this . buffer = null ; this . log = options . log ; } 
function ModifyRequest ( options ) { options = options || { } ; assert . object ( options ) ; lassert . optionalStringDN ( options . object ) ; lassert . optionalArrayOfAttribute ( options . attributes ) ; options . protocolOp = Protocol . LDAP_REQ_MODIFY ; LDAPMessage . call ( this , options ) ; this . object = options . object || null ; this . changes = options . changes ? options . changes . slice ( 0 ) : [ ] ; } 
function ServerSideSortingRequestControl ( options ) { assert . optionalObject ( options ) ; options = options || { } ; options . type = ServerSideSortingRequestControl . OID ; if ( options . value ) { if ( Buffer . isBuffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( Array . isArray ( options . value ) ) { assert . arrayOfObject ( options . value , 'options.value must be Objects' ) ; for ( var i = 0 ; i < options . value . length ; i ++ ) { if ( ! options . value [ i ] . hasOwnProperty ( 'attributeType' ) ) { throw new Error ( 'Missing required key: attributeType' ) ; } } this . _value = options . value ; } else if ( typeof ( options . value ) === 'object' ) { if ( ! options . value . hasOwnProperty ( 'attributeType' ) ) { throw new Error ( 'Missing required key: attributeType' ) ; } this . _value = [ options . value ] ; } else { throw new TypeError ( 'options.value must be a Buffer, Array or Object' ) ; } options . value = null ; } Control . call ( this , options ) ; } 
function LDAPError ( message , dn , caller ) { if ( Error . captureStackTrace ) Error . captureStackTrace ( this , caller || LDAPError ) ; this . lde_message = message ; this . lde_dn = dn ; } 
function UnbindResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = 0 ; LDAPMessage . call ( this , options ) ; } 
function ExtendedRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalString ( options . requestName ) ; if ( options . requestValue && ! ( Buffer . isBuffer ( options . requestValue ) || typeof ( options . requestValue ) === 'string' ) ) { throw new TypeError ( 'options.requestValue must be a buffer or a string' ) ; } options . protocolOp = Protocol . LDAP_REQ_EXTENSION ; LDAPMessage . call ( this , options ) ; this . requestName = options . requestName || '' ; this . requestValue = options . requestValue ; } 
function _parse ( ber ) { assert . ok ( ber ) ; function parseSet ( f ) { var end = ber . offset + ber . length ; while ( ber . offset < end ) f . addFilter ( _parse ( ber ) ) ; } var f ; var type = ber . readSequence ( ) ; switch ( type ) { case Protocol . FILTER_AND : f = new AndFilter ( ) ; parseSet ( f ) ; break ; case Protocol . FILTER_APPROX : f = new ApproximateFilter ( ) ; f . parse ( ber ) ; break ; case Protocol . FILTER_EQUALITY : f = new EqualityFilter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER_EXT : f = new ExtensibleFilter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER_GE : f = new GreaterThanEqualsFilter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER_LE : f = new LessThanEqualsFilter ( ) ; f . parse ( ber ) ; return f ; case Protocol . FILTER_NOT : var _f = _parse ( ber ) ; f = new NotFilter ( { filter : _f } ) ; break ; case Protocol . FILTER_OR : f = new OrFilter ( ) ; parseSet ( f ) ; break ; case Protocol . FILTER_PRESENT : f = new PresenceFilter ( ) ; f . parse ( ber ) ; break ; case Protocol . FILTER_SUBSTRINGS : f = new SubstringFilter ( ) ; f . parse ( ber ) ; break ; default : throw new Error ( 'Invalid search filter type: 0x' + type . toString ( 16 ) ) ; } assert . ok ( f ) ; return f ; } 
function SearchReference ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_SEARCH_REF ; LDAPMessage . call ( this , options ) ; this . uris = options . uris || [ ] ; } 
function ExtendedResponse ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalString ( options . responseName ) ; assert . optionalString ( options . responsevalue ) ; this . responseName = options . responseName || undefined ; this . responseValue = options . responseValue || undefined ; options . protocolOp = Protocol . LDAP_REP_EXTENSION ; LDAPResult . call ( this , options ) ; } 
function CompareResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_COMPARE ; LDAPResult . call ( this , options ) ; } 
function ModifyDNRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalBool ( options . deleteOldRdn ) ; lassert . optionalStringDN ( options . entry ) ; lassert . optionalDN ( options . newRdn ) ; lassert . optionalDN ( options . newSuperior ) ; options . protocolOp = Protocol . LDAP_REQ_MODRDN ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . newRdn = options . newRdn || null ; this . deleteOldRdn = options . deleteOldRdn || true ; this . newSuperior = options . newSuperior || null ; } 
function AbandonRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalNumber ( options . abandonID ) ; options . protocolOp = Protocol . LDAP_REQ_ABANDON ; LDAPMessage . call ( this , options ) ; this . abandonID = options . abandonID || 0 ; } 
function authorize ( req , res , next ) { var isSearch = ( req instanceof ldap . SearchRequest ) ; if ( ! req . connection . ldap . bindDN . equals ( 'cn=root' ) && ! isSearch ) return next ( new ldap . InsufficientAccessRightsError ( ) ) ; return next ( ) ; } 
function invalidDN ( name ) { var e = new Error ( ) ; e . name = 'InvalidDistinguishedNameError' ; e . message = name ; return e ; } 
function RDN ( obj ) { var self = this ; this . attrs = { } ; if ( obj ) { Object . keys ( obj ) . forEach ( function ( k ) { self . set ( k , obj [ k ] ) ; } ) ; } } 
function parse ( name ) { if ( typeof ( name ) !== 'string' ) throw new TypeError ( 'name (string) required' ) ; var cur = 0 ; var len = name . length ; function parseRdn ( ) { var rdn = new RDN ( ) ; var order = 0 ; rdn . spLead = trim ( ) ; while ( cur < len ) { var opts = { order : order } ; var attr = parseAttrType ( ) ; trim ( ) ; if ( cur >= len || name [ cur ++ ] !== '=' ) throw invalidDN ( name ) ; trim ( ) ; 
function SearchPager ( opts ) { assert . object ( opts ) ; assert . func ( opts . callback ) ; assert . number ( opts . pageSize ) ; EventEmitter . call ( this , { } ) ; this . callback = opts . callback ; this . controls = opts . controls ; this . pageSize = opts . pageSize ; this . pagePause = opts . pagePause ; this . controls . forEach ( function ( control ) { if ( control . type === PagedControl . OID ) { 
function ModifyDNResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_MODRDN ; LDAPResult . call ( this , options ) ; } 
function DeleteRequest ( options ) { options = options || { } ; assert . object ( options ) ; lassert . optionalStringDN ( options . entry ) ; options . protocolOp = Protocol . LDAP_REQ_DELETE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; } 
function AddRequest ( options ) { options = options || { } ; assert . object ( options ) ; lassert . optionalStringDN ( options . entry ) ; lassert . optionalArrayOfAttribute ( options . attributes ) ; options . protocolOp = Protocol . LDAP_REQ_ADD ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; } 
function xor ( ) { var b = false ; for ( var i = 0 ; i < arguments . length ; i ++ ) { if ( arguments [ i ] && ! b ) { b = true ; } else if ( arguments [ i ] && b ) { return false ; } } return b ; } 
function CompareRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalString ( options . attribute ) ; assert . optionalString ( options . value ) ; lassert . optionalStringDN ( options . entry ) ; options . protocolOp = Protocol . LDAP_REQ_COMPARE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . attribute = options . attribute || '' ; this . value = options . value || '' ; } 
function BindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_BIND ; LDAPMessage . call ( this , options ) ; this . version = options . version || 0x03 ; this . name = options . name || null ; this . authentication = options . authentication || LDAP_BIND_SIMPLE ; this . credentials = options . credentials || '' ; } 
function AbandonResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = 0 ; LDAPMessage . call ( this , options ) ; } 
function PagedResultsControl ( options ) { assert . optionalObject ( options ) ; options = options || { } ; options . type = PagedResultsControl . OID ; if ( options . value ) { if ( Buffer . isBuffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( typeof ( options . value ) === 'object' ) { this . _value = options . value ; } else { throw new TypeError ( 'options.value must be a Buffer or Object' ) ; } options . value = null ; } Control . call ( this , options ) ; } 
function isFilter ( filter ) { if ( ! filter || typeof ( filter ) !== 'object' ) { return false ; } 
function LDAPMessage ( options ) { assert . object ( options ) ; this . messageID = options . messageID || 0 ; this . protocolOp = options . protocolOp || undefined ; this . controls = options . controls ? options . controls . slice ( 0 ) : [ ] ; this . log = options . log ; } 
function ( graph , start , end , options ) { graph . cleanDirty ( ) ; options = options || { } ; var heuristic = options . heuristic || astar . heuristics . manhattan ; var closest = options . closest || false ; var openHeap = getHeap ( ) ; var closestNode = start ; 
function Graph ( gridIn , options ) { options = options || { } ; this . nodes = [ ] ; this . diagonal = ! ! options . diagonal ; this . grid = [ ] ; for ( var x = 0 ; x < gridIn . length ; x ++ ) { this . grid [ x ] = [ ] ; for ( var y = 0 , row = gridIn [ x ] ; y < row . length ; y ++ ) { var node = new GridNode ( x , y , row [ y ] ) ; this . grid [ x ] [ y ] = node ; this . nodes . push ( node ) ; } } this . init ( ) ; } 
function ( path , i ) { if ( i >= path . length ) { 
function ( model , schema ) { debug ( 'applying virtuals' ) ; for ( const i in schema . virtuals ) { schema . virtuals [ i ] . applyVirtuals ( model ) ; } } 
function ( model , schema ) { debug ( 'applying methods' ) ; for ( const i in schema . methods ) { model . prototype [ i ] = schema . methods [ i ] ; } } 
function ( model , schema ) { debug ( 'applying statics' ) ; for ( const i in schema . statics ) { model [ i ] = schema . statics [ i ] . bind ( model ) ; } } 
function Operations ( ) { this . ifNotExistsSet = { } ; this . SET = { } ; this . ADD = { } ; this . REMOVE = { } ; this . LISTAPPEND = { } ; this . addIfNotExistsSet = function ( name , item ) { this . ifNotExistsSet [ name ] = item ; } ; this . addSet = function ( name , item ) { if ( schema . hashKey . name !== name && ( schema . rangeKey || { } ) . name !== name ) { this . SET [ name ] = item ; } } ; this . addListAppend = function ( name , item ) { if ( schema . hashKey . name !== name && ( schema . rangeKey || { } ) . name !== name ) { this . LISTAPPEND [ name ] = item ; } } ; this . addAdd = function ( name , item ) { if ( schema . hashKey . name !== name && ( schema . rangeKey || { } ) . name !== name ) { this . ADD [ name ] = item ; } } ; this . addRemove = function ( name , item ) { if ( schema . hashKey . name !== name && ( schema . rangeKey || { } ) . name !== name ) { this . REMOVE [ name ] = item ; } } ; this . getUpdateExpression = function ( getUpdateReq ) { let attrCount = 0 ; let updateExpression = '' ; let attrName ; let valName ; let name ; let item ; const setExpressions = [ ] ; for ( name in this . ifNotExistsSet ) { item = this . ifNotExistsSet [ name ] ; attrName = ` ${ attrCount } ` ; valName = ` ${ attrCount } ` ; getUpdateReq . ExpressionAttributeNames [ attrName ] = name ; getUpdateReq . ExpressionAttributeValues [ valName ] = item ; setExpressions . push ( ` ${ attrName } ${ attrName } ${ valName } ` ) ; attrCount += 1 ; } for ( name in this . SET ) { item = this . SET [ name ] ; attrName = ` ${ attrCount } ` ; valName = ` ${ attrCount } ` ; getUpdateReq . ExpressionAttributeNames [ attrName ] = name ; getUpdateReq . ExpressionAttributeValues [ valName ] = item ; setExpressions . push ( ` ${ attrName } ${ valName } ` ) ; attrCount += 1 ; } for ( name in this . LISTAPPEND ) { item = this . LISTAPPEND [ name ] ; attrName = ` ${ attrCount } ` ; valName = ` ${ attrCount } ` ; getUpdateReq . ExpressionAttributeNames [ attrName ] = name ; getUpdateReq . ExpressionAttributeValues [ valName ] = item ; setExpressions . push ( ` ${ attrName } ${ attrName } ${ valName } ` ) ; attrCount += 1 ; } if ( setExpressions . length > 0 ) { updateExpression += ` ${ setExpressions . join ( ',' ) } ` ; } const addExpressions = [ ] ; for ( name in this . ADD ) { item = this . ADD [ name ] ; attrName = ` ${ attrCount } ` ; valName = ` ${ attrCount } ` ; getUpdateReq . ExpressionAttributeNames [ attrName ] = name ; getUpdateReq . ExpressionAttributeValues [ valName ] = item ; addExpressions . push ( ` ${ attrName } ${ valName } ` ) ; attrCount += 1 ; } if ( addExpressions . length > 0 ) { updateExpression += ` ${ addExpressions . join ( ',' ) } ` ; } const removeExpressions = [ ] ; for ( name in this . REMOVE ) { item = this . REMOVE [ name ] ; attrName = ` ${ attrCount } ` ; getUpdateReq . ExpressionAttributeNames [ attrName ] = name ; removeExpressions . push ( attrName ) ; attrCount += 1 ; } if ( removeExpressions . length > 0 ) { updateExpression += ` ${ removeExpressions . join ( ',' ) } ` ; } getUpdateReq . UpdateExpression = updateExpression ; } ; } 
function createAttrDefFromDynamo ( dynamoAttribute ) { let dynamoType ; const attrDef = { 'type' : module . exports . lookupType ( dynamoAttribute ) } ; if ( attrDef . type === Object ) { attrDef . type = 'map' ; for ( dynamoType in dynamoAttribute ) { attrDef . map = { } ; for ( const subAttrName in dynamoAttribute [ dynamoType ] ) { attrDef . map [ subAttrName ] = createAttrDefFromDynamo ( dynamoAttribute [ dynamoType ] [ subAttrName ] ) ; } } } else if ( attrDef . type === Array ) { attrDef . type = 'list' ; for ( dynamoType in dynamoAttribute ) { attrDef . list = dynamoAttribute [ dynamoType ] . map ( createAttrDefFromDynamo ) ; } } return attrDef ; } 
function parseAnchorOption ( anchor ) { let horizontal = anchor . match ( / left|center|right / gi ) || [ ] ; horizontal = horizontal . length === 0 ? 'left' : horizontal [ 0 ] ; let vertical = anchor . match ( / baseline|top|bottom|middle / gi ) || [ ] ; vertical = vertical . length === 0 ? 'baseline' : vertical [ 0 ] ; return { horizontal , vertical } ; } 
function forEach ( array , callback ) { if ( array ) { for ( var i = 0 , len = array . length ; i < len ; i ++ ) { var result = callback ( array [ i ] , i ) ; if ( result ) { return result ; } } } return undefined ; } 
function binarySearch ( array , value ) { var low = 0 ; var high = array . length - 1 ; while ( low <= high ) { var middle = low + ( ( high - low ) >> 1 ) ; var midValue = array [ middle ] ; if ( midValue === value ) { return middle ; } else if ( midValue > value ) { high = middle - 1 ; } else { low = middle + 1 ; } } return ~ low ; } 
function arrayToMap ( array , makeKey ) { var result = { } ; forEach ( array , function ( value ) { result [ makeKey ( value ) ] = value ; } ) ; return result ; } 
function getRootLength ( path ) { if ( path . charCodeAt ( 0 ) === 47 ) { if ( path . charCodeAt ( 1 ) !== 47 ) return 1 ; var p1 = path . indexOf ( "/" , 2 ) ; if ( p1 < 0 ) return 2 ; var p2 = path . indexOf ( "/" , p1 + 1 ) ; if ( p2 < 0 ) return p1 + 1 ; return p2 + 1 ; } if ( path . charCodeAt ( 1 ) === 58 ) { if ( path . charCodeAt ( 2 ) === 47 ) return 3 ; return 2 ; } 
function createWatchedFileSet ( interval , chunkSize ) { if ( interval === void 0 ) { interval = 2500 ; } if ( chunkSize === void 0 ) { chunkSize = 30 ; } var watchedFiles = [ ] ; var nextFileToCheck = 0 ; var watchTimer ; function getModifiedTime ( fileName ) { return _fs . statSync ( fileName ) . mtime ; } function poll ( checkedIndex ) { var watchedFile = watchedFiles [ checkedIndex ] ; if ( ! watchedFile ) { return ; } _fs . stat ( watchedFile . fileName , function ( err , stats ) { if ( err ) { watchedFile . callback ( watchedFile . fileName ) ; } else if ( watchedFile . mtime . getTime ( ) !== stats . mtime . getTime ( ) ) { watchedFile . mtime = getModifiedTime ( watchedFile . fileName ) ; watchedFile . callback ( watchedFile . fileName , watchedFile . mtime . getTime ( ) === 0 ) ; } } ) ; } 
function startWatchTimer ( ) { watchTimer = setInterval ( function ( ) { var count = 0 ; var nextToCheck = nextFileToCheck ; var firstCheck = - 1 ; while ( ( count < chunkSize ) && ( nextToCheck !== firstCheck ) ) { poll ( nextToCheck ) ; if ( firstCheck < 0 ) { firstCheck = nextToCheck ; } nextToCheck ++ ; if ( nextToCheck === watchedFiles . length ) { nextToCheck = 0 ; } count ++ ; } nextFileToCheck = nextToCheck ; } , interval ) ; } 
function isUnicodeIdentifierStart ( code , languageVersion ) { return languageVersion >= 1 ? lookupInUnicodeMap ( code , unicodeES5IdentifierStart ) : lookupInUnicodeMap ( code , unicodeES3IdentifierStart ) ; } 
function computeLineStarts ( text ) { var result = new Array ( ) ; var pos = 0 ; var lineStart = 0 ; while ( pos < text . length ) { var ch = text . charCodeAt ( pos ++ ) ; switch ( ch ) { case 13 : if ( text . charCodeAt ( pos ) === 10 ) { pos ++ ; } case 10 : result . push ( lineStart ) ; lineStart = pos ; break ; default : if ( ch > 127 && isLineBreak ( ch ) ) { result . push ( lineStart ) ; lineStart = pos ; } break ; } } result . push ( lineStart ) ; return result ; } 
function computePositionOfLineAndCharacter ( lineStarts , line , character ) { ts . Debug . assert ( line >= 0 && line < lineStarts . length ) ; return lineStarts [ line ] + character ; } 
function computeLineAndCharacterOfPosition ( lineStarts , position ) { var lineNumber = ts . binarySearch ( lineStarts , position ) ; if ( lineNumber < 0 ) { 
function createScanner ( languageVersion , skipTrivia , languageVariant , text , onError , start , length ) { if ( languageVariant === void 0 ) { languageVariant = 0 ; } * Scans the given number of hexadecimal digits in the text, * returning -1 if the given number is unavailable. */ function scanExactNumberOfHexDigits ( count ) { return scanHexDigits ( count , false ) ; } function scanMinimumNumberOfHexDigits ( count ) { return scanHexDigits ( count , true ) ; } function scanHexDigits ( minCount , scanAsManyAsPossible ) { var digits = 0 ; var value = 0 ; while ( digits < minCount || scanAsManyAsPossible ) { var ch = text . charCodeAt ( pos ) ; if ( ch >= 48 && ch <= 57 ) { value = value * 16 + ch - 48 ; } else if ( ch >= 65 && ch <= 70 ) { value = value * 16 + ch - 65 + 10 ; } else if ( ch >= 97 && ch <= 102 ) { value = value * 16 + ch - 97 + 10 ; } else { break ; } pos ++ ; digits ++ ; } if ( digits < minCount ) { value = - 1 ; } return value ; } function scanString ( ) { var quote = text . charCodeAt ( pos ++ ) ; var result = "" ; var start = pos ; while ( true ) { if ( pos >= end ) { result += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_string_literal ) ; break ; } var ch = text . charCodeAt ( pos ) ; if ( ch === quote ) { result += text . substring ( start , pos ) ; pos ++ ; break ; } if ( ch === 92 ) { result += text . substring ( start , pos ) ; result += scanEscapeSequence ( ) ; start = pos ; continue ; } if ( isLineBreak ( ch ) ) { result += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_string_literal ) ; break ; } pos ++ ; } return result ; } function scanTemplateAndSetTokenValue ( ) { var startedWithBacktick = text . charCodeAt ( pos ) === 96 ; pos ++ ; var start = pos ; var contents = "" ; var resultingToken ; while ( true ) { if ( pos >= end ) { contents += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_template_literal ) ; resultingToken = startedWithBacktick ? 11 : 14 ; break ; } var currChar = text . charCodeAt ( pos ) ; * Unconditionally back up and scan a template expression portion. */ function reScanTemplateToken ( ) { ts . Debug . assert ( token === 16 , "'reScanTemplateToken' should only be called on a '}'" ) ; pos = tokenPos ; return token = scanTemplateAndSetTokenValue ( ) ; } function reScanJsxToken ( ) { pos = tokenPos = startPos ; return token = scanJsxToken ( ) ; } function scanJsxToken ( ) { startPos = tokenPos = pos ; if ( pos >= end ) { return token = 1 ; } var char = text . charCodeAt ( pos ) ; if ( char === 60 ) { if ( text . charCodeAt ( pos + 1 ) === 47 ) { pos += 2 ; return token = 26 ; } pos ++ ; return token = 25 ; } if ( char === 123 ) { pos ++ ; return token = 15 ; } while ( pos < end ) { pos ++ ; char = text . charCodeAt ( pos ) ; if ( ( char === 123 ) || ( char === 60 ) ) { break ; } } return token = 236 ; } 
function scanTemplateAndSetTokenValue ( ) { var startedWithBacktick = text . charCodeAt ( pos ) === 96 ; pos ++ ; var start = pos ; var contents = "" ; var resultingToken ; while ( true ) { if ( pos >= end ) { contents += text . substring ( start , pos ) ; tokenIsUnterminated = true ; error ( ts . Diagnostics . Unterminated_template_literal ) ; resultingToken = startedWithBacktick ? 11 : 14 ; break ; } var currChar = text . charCodeAt ( pos ) ; 
function utf16EncodeAsString ( codePoint ) { ts . Debug . assert ( 0x0 <= codePoint && codePoint <= 0x10FFFF ) ; if ( codePoint <= 65535 ) { return String . fromCharCode ( codePoint ) ; } var codeUnit1 = Math . floor ( ( codePoint - 65536 ) / 1024 ) + 0xD800 ; var codeUnit2 = ( ( codePoint - 65536 ) % 1024 ) + 0xDC00 ; return String . fromCharCode ( codeUnit1 , codeUnit2 ) ; } 
function peekUnicodeEscape ( ) { if ( pos + 5 < end && text . charCodeAt ( pos + 1 ) === 117 ) { var start_1 = pos ; pos += 2 ; var value = scanExactNumberOfHexDigits ( 4 ) ; pos = start_1 ; return value ; } return - 1 ; } 
function scanJsxIdentifier ( ) { if ( tokenIsIdentifierOrKeyword ( token ) ) { var firstCharPosition = pos ; while ( pos < end ) { var ch = text . charCodeAt ( pos ) ; if ( ch === 45 || ( ( firstCharPosition === pos ) ? isIdentifierStart ( ch , languageVersion ) : isIdentifierPart ( ch , languageVersion ) ) ) { pos ++ ; } else { break ; } } tokenValue += text . substr ( firstCharPosition , pos - firstCharPosition ) ; } return token ; } 
function getDeclarationName ( node ) { if ( node . name ) { if ( node . kind === 218 && node . name . kind === 9 ) { return "\"" + node . name . text + "\"" ; } if ( node . name . kind === 136 ) { var nameExpression = node . name . expression ; ts . Debug . assert ( ts . isWellKnownSymbolSyntactically ( nameExpression ) ) ; return ts . getPropertyNameForKnownSymbolName ( nameExpression . name . text ) ; } return node . name . text ; } switch ( node . kind ) { case 144 : return "__constructor" ; case 152 : case 147 : return "__call" ; case 153 : case 148 : return "__new" ; case 149 : return "__index" ; case 228 : return "__export" ; case 227 : return node . isExportEquals ? "export=" : "default" ; case 213 : case 214 : return node . flags & 1024 ? "default" : undefined ; } } 
function bindChildren ( node ) { 
function nodePosToString ( node ) { var file = getSourceFileOfNode ( node ) ; var loc = ts . getLineAndCharacterOfPosition ( file , node . pos ) ; return file . fileName + "(" + ( loc . line + 1 ) + "," + ( loc . character + 1 ) + ")" ; } 
function nodeIsMissing ( node ) { if ( ! node ) { return true ; } return node . pos === node . end && node . pos >= 0 && node . kind !== 1 ; } 
function escapeIdentifier ( identifier ) { return identifier . length >= 2 && identifier . charCodeAt ( 0 ) === 95 && identifier . charCodeAt ( 1 ) === 95 ? "_" + identifier : identifier ; } 
function unescapeIdentifier ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 && identifier . charCodeAt ( 1 ) === 95 && identifier . charCodeAt ( 2 ) === 95 ? identifier . substr ( 1 ) : identifier ; } 
function getEnclosingBlockScopeContainer ( node ) { var current = node . parent ; while ( current ) { if ( isFunctionLike ( current ) ) { return current ; } switch ( current . kind ) { case 248 : case 220 : case 244 : case 218 : case 199 : case 200 : case 201 : return current ; case 192 : 
function getCombinedNodeFlags ( node ) { node = walkUpBindingElementsAndPatterns ( node ) ; var flags = node . flags ; if ( node . kind === 211 ) { node = node . parent ; } if ( node && node . kind === 212 ) { flags |= node . flags ; node = node . parent ; } if ( node && node . kind === 193 ) { flags |= node . flags ; } return flags ; } 
function forEachReturnStatement ( body , visitor ) { return traverse ( body ) ; function traverse ( node ) { switch ( node . kind ) { case 204 : return visitor ( node ) ; case 220 : case 192 : case 196 : case 197 : case 198 : case 199 : case 200 : case 201 : case 205 : case 206 : case 241 : case 242 : case 207 : case 209 : case 244 : return ts . forEachChild ( node , traverse ) ; } } } 
function isDeclarationName ( name ) { if ( name . kind !== 69 && name . kind !== 9 && name . kind !== 8 ) { return false ; } var parent = name . parent ; if ( parent . kind === 226 || parent . kind === 230 ) { if ( parent . propertyName ) { return true ; } } if ( isDeclaration ( parent ) ) { return parent . name === name ; } return false ; } 
function isIdentifierName ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 141 : case 140 : case 143 : case 142 : case 145 : case 146 : case 247 : case 245 : case 166 : 
function isAliasSymbolDeclaration ( node ) { return node . kind === 221 || node . kind === 223 && ! ! node . name || node . kind === 224 || node . kind === 226 || node . kind === 230 || node . kind === 227 && node . expression . kind === 69 ; } 
function hasDynamicName ( declaration ) { return declaration . name && declaration . name . kind === 136 && ! isWellKnownSymbolSyntactically ( declaration . name . expression ) ; } 
function escapeString ( s ) { s = escapedCharsRegExp . test ( s ) ? s . replace ( escapedCharsRegExp , getReplacement ) : s ; return s ; function getReplacement ( c ) { return escapedCharsMap [ c ] || get16BitUnicodeEscapeSequence ( c . charCodeAt ( 0 ) ) ; } } 
function getExpandedCharCodes ( input ) { var output = [ ] ; var length = input . length ; for ( var i = 0 ; i < length ; i ++ ) { var charCode = input . charCodeAt ( i ) ; 
function textSpanContainsTextSpan ( span , other ) { return other . start >= span . start && textSpanEnd ( other ) <= textSpanEnd ( span ) ; } 
function forEachChild ( node , cbNode , cbNodeArray ) { if ( ! node ) { return ; } 
function updateSourceFile ( sourceFile , newText , textChangeRange , aggressiveChecks ) { return IncrementalParser . updateSourceFile ( sourceFile , newText , textChangeRange , aggressiveChecks ) ; } 
function parseIsolatedJSDocComment ( content , start , length ) { return Parser . JSDocParser . parseIsolatedJSDocComment ( content , start , length ) ; } 
function createIdentifier ( isIdentifier , diagnosticMessage ) { identifierCount ++ ; if ( isIdentifier ) { var node = createNode ( 69 ) ; 
function isListTerminator ( kind ) { if ( token === 1 ) { 
function parseEntityName ( allowReservedWords , diagnosticMessage ) { var entity = parseIdentifier ( diagnosticMessage ) ; while ( parseOptional ( 21 ) ) { var node = createNode ( 135 , entity . pos ) ; node . left = entity ; node . right = parseRightSideOfDot ( allowReservedWords ) ; entity = finishNode ( node ) ; } return entity ; } 
function parseTypeReferenceOrTypePredicate ( ) { var typeName = parseEntityName ( false , ts . Diagnostics . Type_expected ) ; if ( typeName . kind === 69 && token === 124 && ! scanner . hasPrecedingLineBreak ( ) ) { nextToken ( ) ; var node_1 = createNode ( 150 , typeName . pos ) ; node_1 . parameterName = typeName ; node_1 . type = parseType ( ) ; return finishNode ( node_1 ) ; } var node = createNode ( 151 , typeName . pos ) ; node . typeName = typeName ; if ( ! scanner . hasPrecedingLineBreak ( ) && token === 25 ) { node . typeArguments = parseBracketedList ( 18 , parseType , 25 , 27 ) ; } return finishNode ( node ) ; } 
function parseBlock ( ignoreMissingOpenBrace , diagnosticMessage ) { var node = createNode ( 192 ) ; if ( parseExpected ( 15 , diagnosticMessage ) || ignoreMissingOpenBrace ) { node . statements = parseList ( 1 , parseStatement ) ; parseExpected ( 16 ) ; } else { node . statements = createMissingList ( ) ; } return finishNode ( node ) ; } 
function parseTryStatement ( ) { var node = createNode ( 209 ) ; parseExpected ( 100 ) ; node . tryBlock = parseBlock ( false ) ; node . catchClause = token === 72 ? parseCatchClause ( ) : undefined ; 
function parseArrayBindingElement ( ) { if ( token === 24 ) { return createNode ( 187 ) ; } var node = createNode ( 163 ) ; node . dotDotDotToken = parseOptionalToken ( 22 ) ; node . name = parseIdentifierOrPattern ( ) ; node . initializer = parseBindingElementInitializer ( false ) ; return finishNode ( node ) ; } 
function parseJSDocTypeExpression ( start , length ) { scanner . setText ( sourceText , start , length ) ; 
function findHighestListElementThatStartsAtPosition ( position ) { 
function resolveName ( location , name , meaning , nameNotFoundMessage , nameArg ) { var result ; var lastLocation ; var propertyWithInvalidInitializer ; var errorLocation = location ; var grandparent ; loop : while ( location ) { 
function isSameScopeDescendentOf ( initial , parent , stopAt ) { if ( ! parent ) { return false ; } for ( var current = initial ; current && current !== stopAt && ! ts . isFunctionLike ( current ) ; current = current . parent ) { if ( current === parent ) { return true ; } } return false ; } 
function combineValueAndTypeSymbols ( valueSymbol , typeSymbol ) { if ( valueSymbol . flags & ( 793056 | 1536 ) ) { return valueSymbol ; } var result = createSymbol ( valueSymbol . flags | typeSymbol . flags , valueSymbol . name ) ; result . declarations = ts . concatenate ( valueSymbol . declarations , typeSymbol . declarations ) ; result . parent = valueSymbol . parent || typeSymbol . parent ; if ( valueSymbol . valueDeclaration ) result . valueDeclaration = valueSymbol . valueDeclaration ; if ( typeSymbol . members ) result . members = typeSymbol . members ; if ( valueSymbol . exports ) result . exports = valueSymbol . exports ; return result ; } 
function markAliasSymbolAsReferenced ( symbol ) { var links = getSymbolLinks ( symbol ) ; if ( ! links . referenced ) { links . referenced = true ; var node = getDeclarationOfAliasSymbol ( symbol ) ; if ( node . kind === 227 ) { 
function getSymbolOfPartOfRightHandSideOfImportEquals ( entityName , importDeclaration ) { if ( ! importDeclaration ) { importDeclaration = ts . getAncestor ( entityName , 221 ) ; ts . Debug . assert ( importDeclaration !== undefined ) ; } 
function resolveEntityName ( name , meaning , ignoreErrors ) { if ( ts . nodeIsMissing ( name ) ) { return undefined ; } var symbol ; if ( name . kind === 69 ) { var message = meaning === 1536 ? ts . Diagnostics . Cannot_find_namespace_0 : ts . Diagnostics . Cannot_find_name_0 ; symbol = resolveName ( name , name . text , meaning , ignoreErrors ? undefined : message , name ) ; if ( ! symbol ) { return undefined ; } } else if ( name . kind === 135 || name . kind === 166 ) { var left = name . kind === 135 ? name . left : name . expression ; var right = name . kind === 135 ? name . right : name . name ; var namespace = resolveEntityName ( left , 1536 , ignoreErrors ) ; if ( ! namespace || namespace === unknownSymbol || ts . nodeIsMissing ( right ) ) { return undefined ; } symbol = getSymbol ( getExportsOfSymbol ( namespace ) , right . text , meaning ) ; if ( ! symbol ) { if ( ! ignoreErrors ) { error ( right , ts . Diagnostics . Module_0_has_no_exported_member_1 , getFullyQualifiedName ( namespace ) , ts . declarationNameToString ( right ) ) ; } return undefined ; } } else { ts . Debug . fail ( "Unknown entity name kind." ) ; } ts . Debug . assert ( ( symbol . flags & 16777216 ) === 0 , "Should never get an instantiated symbol here." ) ; return symbol . flags & meaning ? symbol : resolveAlias ( symbol ) ; } 
function resolveESModuleSymbol ( moduleSymbol , moduleReferenceExpression ) { var symbol = resolveExternalModuleSymbol ( moduleSymbol ) ; if ( symbol && ! ( symbol . flags & ( 1536 | 3 ) ) ) { error ( moduleReferenceExpression , ts . Diagnostics . Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct , symbolToString ( moduleSymbol ) ) ; symbol = undefined ; } return symbol ; } 
function isReservedMemberName ( name ) { return name . charCodeAt ( 0 ) === 95 && name . charCodeAt ( 1 ) === 95 && name . charCodeAt ( 2 ) !== 95 && name . charCodeAt ( 2 ) !== 64 ; } 
function isSymbolUsedInExportAssignment ( symbol ) { if ( exportAssignmentSymbol === symbol ) { return true ; } if ( exportAssignmentSymbol && ! ! ( exportAssignmentSymbol . flags & 8388608 ) ) { 
function getTypeOfPropertyOfType ( type , name ) { var prop = getPropertyOfType ( type , name ) ; return prop ? getTypeOfSymbol ( prop ) : undefined ; } 
function getTypeForBindingElementParent ( node ) { var symbol = getSymbolOfNode ( node ) ; return symbol && getSymbolLinks ( symbol ) . type || getTypeForVariableLikeDeclaration ( node ) ; } 
function getTypeForBindingElement ( declaration ) { var pattern = declaration . parent ; var parentType = getTypeForBindingElementParent ( pattern . parent ) ; 
function getTypeForVariableLikeDeclaration ( declaration ) { 
function getTypeFromBindingElement ( element , includePatternInType ) { if ( element . initializer ) { return getWidenedType ( checkExpressionCached ( element . initializer ) ) ; } if ( ts . isBindingPattern ( element . name ) ) { return getTypeFromBindingPattern ( element . name , includePatternInType ) ; } return anyType ; } 
function getTypeFromObjectBindingPattern ( pattern , includePatternInType ) { var members = { } ; ts . forEach ( pattern . elements , function ( e ) { var flags = 4 | 67108864 | ( e . initializer ? 536870912 : 0 ) ; var name = e . propertyName || e . name ; var symbol = createSymbol ( flags , name . text ) ; symbol . type = getTypeFromBindingElement ( e , includePatternInType ) ; symbol . bindingElement = e ; members [ symbol . name ] = symbol ; } ) ; var result = createAnonymousType ( undefined , members , emptyArray , emptyArray , undefined , undefined ) ; if ( includePatternInType ) { result . pattern = pattern ; } return result ; } 
function getTypeFromBindingPattern ( pattern , includePatternInType ) { return pattern . kind === 161 ? getTypeFromObjectBindingPattern ( pattern , includePatternInType ) : getTypeFromArrayBindingPattern ( pattern , includePatternInType ) ; } 
function getWidenedTypeForVariableLikeDeclaration ( declaration , reportErrors ) { var type = getTypeForVariableLikeDeclaration ( declaration ) ; if ( type ) { if ( reportErrors ) { reportErrorsFromWidening ( declaration , type ) ; } 
function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias ( symbol ) { var result ; for ( var _i = 0 , _a = symbol . declarations ; _i < _a . length ; _i ++ ) { var node = _a [ _i ] ; if ( node . kind === 215 || node . kind === 214 || node . kind === 186 || node . kind === 216 ) { var declaration = node ; if ( declaration . typeParameters ) { result = appendTypeParameters ( result , declaration . typeParameters ) ; } } } return result ; } 
function getBaseConstructorTypeOfClass ( type ) { if ( ! type . resolvedBaseConstructorType ) { var baseTypeNode = getBaseTypeNodeOfClass ( type ) ; if ( ! baseTypeNode ) { return type . resolvedBaseConstructorType = undefinedType ; } if ( ! pushTypeResolution ( type , 1 ) ) { return unknownType ; } var baseConstructorType = checkExpression ( baseTypeNode . expression ) ; if ( baseConstructorType . flags & 80896 ) { 
function isIndependentTypeReference ( node ) { if ( node . typeArguments ) { for ( var _i = 0 , _a = node . typeArguments ; _i < _a . length ; _i ++ ) { var typeNode = _a [ _i ] ; if ( ! isIndependentType ( typeNode ) ) { return false ; } } } return true ; } 
function isIndependentVariableLikeDeclaration ( node ) { return node . type && isIndependentType ( node . type ) || ! node . type && ! node . initializer ; } 
function isIndependentFunctionLikeDeclaration ( node ) { if ( node . kind !== 144 && ( ! node . type || ! isIndependentType ( node . type ) ) ) { return false ; } for ( var _i = 0 , _a = node . parameters ; _i < _a . length ; _i ++ ) { var parameter = _a [ _i ] ; if ( ! isIndependentVariableLikeDeclaration ( parameter ) ) { return false ; } } return true ; } 
function createInstantiatedSymbolTable ( symbols , mapper , mappingThisOnly ) { var result = { } ; for ( var _i = 0 ; _i < symbols . length ; _i ++ ) { var symbol = symbols [ _i ] ; result [ symbol . name ] = mappingThisOnly && isIndependentMember ( symbol ) ? symbol : instantiateSymbol ( symbol , mapper ) ; } return result ; } 
function getUnionSignatures ( types , kind ) { var signatureLists = ts . map ( types , function ( t ) { return getSignaturesOfType ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signatureLists . length ; i ++ ) { for ( var _i = 0 , _a = signatureLists [ i ] ; _i < _a . length ; _i ++ ) { var signature = _a [ _i ] ; 
function getPropertyOfObjectType ( type , name ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( ts . hasProperty ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbolIsValue ( symbol ) ) { return symbol ; } } } } 
function getApparentType ( type ) { if ( type . flags & 512 ) { do { type = getConstraintOfTypeParameter ( type ) ; } while ( type && type . flags & 512 ) ; if ( ! type ) { type = emptyObjectType ; } } if ( type . flags & 258 ) { type = globalStringType ; } else if ( type . flags & 132 ) { type = globalNumberType ; } else if ( type . flags & 8 ) { type = globalBooleanType ; } else if ( type . flags & 16777216 ) { type = globalESSymbolType ; } return type ; } 
function getPropertyOfType ( type , name ) { type = getApparentType ( type ) ; if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( ts . hasProperty ( resolved . members , name ) ) { var symbol = resolved . members [ name ] ; if ( symbolIsValue ( symbol ) ) { return symbol ; } } if ( resolved === anyFunctionType || resolved . callSignatures . length || resolved . constructSignatures . length ) { var symbol = getPropertyOfObjectType ( globalFunctionType , name ) ; if ( symbol ) { return symbol ; } } return getPropertyOfObjectType ( globalObjectType , name ) ; } if ( type . flags & 49152 ) { return getPropertyOfUnionOrIntersectionType ( type , name ) ; } return undefined ; } 
function getTypeParametersFromDeclaration ( typeParameterDeclarations ) { var result = [ ] ; ts . forEach ( typeParameterDeclarations , function ( node ) { var tp = getDeclaredTypeOfTypeParameter ( node . symbol ) ; if ( ! ts . contains ( result , tp ) ) { result . push ( tp ) ; } } ) ; return result ; } 
function getPropagatingFlagsOfTypes ( types ) { var result = 0 ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; result |= type . flags ; } return result & 14680064 ; } 
function getTypeFromClassOrInterfaceReference ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var typeParameters = type . localTypeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , typeToString ( type , undefined , 1 ) , typeParameters . length ) ; return unknownType ; } 
function getTypeFromTypeAliasReference ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var links = getSymbolLinks ( symbol ) ; var typeParameters = links . typeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , symbolToString ( symbol ) , typeParameters . length ) ; return unknownType ; } var typeArguments = ts . map ( node . typeArguments , getTypeFromTypeNode ) ; var id = getTypeListId ( typeArguments ) ; return links . instantiations [ id ] || ( links . instantiations [ id ] = instantiateType ( type , createTypeMapper ( typeParameters , typeArguments ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return type ; } 
function getTypeFromNonGenericTypeReference ( node , symbol ) { if ( symbol . flags & 262144 && isTypeParameterReferenceIllegalInConstraint ( node , symbol ) ) { 
function getExportedTypeFromNamespace ( namespace , name ) { var namespaceSymbol = getGlobalSymbol ( namespace , 1536 , undefined ) ; var typeSymbol = namespaceSymbol && getSymbol ( namespaceSymbol . exports , name , 793056 ) ; return typeSymbol && getDeclaredTypeOfSymbol ( typeSymbol ) ; } 
function createTypedPropertyDescriptorType ( propertyType ) { var globalTypedPropertyDescriptorType = getGlobalTypedPropertyDescriptorType ( ) ; return globalTypedPropertyDescriptorType !== emptyGenericType ? createTypeReference ( globalTypedPropertyDescriptorType , [ propertyType ] ) : emptyObjectType ; } 
function addTypesToSet ( typeSet , types , typeSetKind ) { for ( var _i = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; addTypeToSet ( typeSet , type , typeSetKind ) ; } } 
function getUnionType ( types , noSubtypeReduction ) { if ( types . length === 0 ) { return emptyObjectType ; } var typeSet = [ ] ; addTypesToSet ( typeSet , types , 16384 ) ; if ( containsTypeAny ( typeSet ) ) { return anyType ; } if ( noSubtypeReduction ) { removeAllButLast ( typeSet , undefinedType ) ; removeAllButLast ( typeSet , nullType ) ; } else { removeSubtypes ( typeSet ) ; } if ( typeSet . length === 1 ) { return typeSet [ 0 ] ; } var id = getTypeListId ( typeSet ) ; var type = unionTypes [ id ] ; if ( ! type ) { type = unionTypes [ id ] = createObjectType ( 16384 | getPropagatingFlagsOfTypes ( typeSet ) ) ; type . types = typeSet ; } return type ; } 
function getIntersectionType ( types ) { if ( types . length === 0 ) { return emptyObjectType ; } var typeSet = [ ] ; addTypesToSet ( typeSet , types , 32768 ) ; if ( containsTypeAny ( typeSet ) ) { return anyType ; } if ( typeSet . length === 1 ) { return typeSet [ 0 ] ; } var id = getTypeListId ( typeSet ) ; var type = intersectionTypes [ id ] ; if ( ! type ) { type = intersectionTypes [ id ] = createObjectType ( 32768 | getPropagatingFlagsOfTypes ( typeSet ) ) ; type . types = typeSet ; } return type ; } 
function checkTypeRelatedTo ( source , target , relation , errorNode , headMessage , containingMessageChain ) { var errorInfo ; var sourceStack ; var targetStack ; var maybeStack ; var expandingFlags ; var depth = 0 ; var overflow = false ; var elaborateErrors = false ; ts . Debug . assert ( relation !== identityRelation || ! errorNode , "no error reporting in identity checking" ) ; var result = isRelatedTo ( source , target , errorNode !== undefined , headMessage ) ; if ( overflow ) { error ( errorNode , ts . Diagnostics . Excessive_stack_depth_comparing_types_0_and_1 , typeToString ( source ) , typeToString ( target ) ) ; } else if ( errorInfo ) { 
function isRelatedTo ( source , target , reportErrors , headMessage ) { var result ; 
function isKnownProperty ( type , name ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( relation === assignableRelation && ( type === globalObjectType || resolved . properties . length === 0 ) || resolved . stringIndexType || resolved . numberIndexType || getPropertyOfType ( type , name ) ) { return true ; } return false ; } if ( type . flags & 49152 ) { for ( var _i = 0 , _a = type . types ; _i < _a . length ; _i ++ ) { var t = _a [ _i ] ; if ( isKnownProperty ( t , name ) ) { return true ; } } return false ; } return true ; } 
function objectTypeRelatedTo ( source , target , reportErrors ) { if ( overflow ) { return 0 ; } var id = relation !== identityRelation || source . id < target . id ? source . id + "," + target . id : target . id + "," + source . id ; var related = relation [ id ] ; if ( related !== undefined ) { 
function isDeeplyNestedGeneric ( type , stack , depth ) { 
function removeTypesFromUnionType ( type , typeKind , isOfTypeKind , allowEmptyUnionResult ) { if ( type . flags & 16384 ) { var types = type . types ; if ( ts . forEach ( types , function ( t ) { return ! ! ( t . flags & typeKind ) === isOfTypeKind ; } ) ) { 
function isVariableAssignedWithin ( symbol , node ) { var links = getNodeLinks ( node ) ; if ( links . assignmentChecks ) { var cachedResult = links . assignmentChecks [ symbol . id ] ; if ( cachedResult !== undefined ) { return cachedResult ; } } else { links . assignmentChecks = { } ; } return links . assignmentChecks [ symbol . id ] = isAssignedIn ( node ) ; function isAssignedInBinaryExpression ( node ) { if ( node . operatorToken . kind >= 56 && node . operatorToken . kind <= 68 ) { var n = node . left ; while ( n . kind === 172 ) { n = n . expression ; } if ( n . kind === 69 && getResolvedSymbol ( n ) === symbol ) { return true ; } } return ts . forEachChild ( node , isAssignedIn ) ; } function isAssignedInVariableDeclaration ( node ) { if ( ! ts . isBindingPattern ( node . name ) && getSymbolOfNode ( node ) === symbol && hasInitializer ( node ) ) { return true ; } return ts . forEachChild ( node , isAssignedIn ) ; } function isAssignedIn ( node ) { switch ( node . kind ) { case 181 : return isAssignedInBinaryExpression ( node ) ; case 211 : case 163 : return isAssignedInVariableDeclaration ( node ) ; case 161 : case 162 : case 164 : case 165 : case 166 : case 167 : case 168 : case 169 : case 171 : case 189 : case 172 : case 179 : case 175 : case 178 : case 176 : case 177 : case 180 : case 184 : case 182 : case 185 : case 192 : case 193 : case 195 : case 196 : case 197 : case 198 : case 199 : case 200 : case 201 : case 204 : case 205 : case 206 : case 241 : case 242 : case 207 : case 208 : case 209 : case 244 : case 233 : case 234 : case 238 : case 239 : case 235 : case 240 : return ts . forEachChild ( node , isAssignedIn ) ; } return false ; } } 
function getNarrowedTypeOfSymbol ( symbol , node ) { var type = getTypeOfSymbol ( symbol ) ; 
function narrowType ( type , expr , assumeTrue ) { switch ( expr . kind ) { case 168 : return narrowTypeByTypePredicate ( type , expr , assumeTrue ) ; case 172 : return narrowType ( type , expr . expression , assumeTrue ) ; case 181 : var operator = expr . operatorToken . kind ; if ( operator === 32 || operator === 33 ) { return narrowTypeByEquality ( type , expr , assumeTrue ) ; } else if ( operator === 51 ) { return narrowTypeByAnd ( type , expr , assumeTrue ) ; } else if ( operator === 52 ) { return narrowTypeByOr ( type , expr , assumeTrue ) ; } else if ( operator === 91 ) { return narrowTypeByInstanceof ( type , expr , assumeTrue ) ; } break ; case 179 : if ( expr . operator === 49 ) { return narrowType ( type , expr . operand , ! assumeTrue ) ; } break ; } return type ; } 
function getContextuallyTypedParameterType ( parameter ) { var func = parameter . parent ; if ( isFunctionExpressionOrArrowFunction ( func ) || ts . isObjectLiteralMethod ( func ) ) { if ( isContextSensitive ( func ) ) { var contextualSignature = getContextualSignature ( func ) ; if ( contextualSignature ) { var funcHasRestParameters = ts . hasRestParameter ( func ) ; var len = func . parameters . length - ( funcHasRestParameters ? 1 : 0 ) ; var indexOfParameter = ts . indexOf ( func . parameters , parameter ) ; if ( indexOfParameter < len ) { return getTypeAtPosition ( contextualSignature , indexOfParameter ) ; } 
function getContextualTypeForInitializerExpression ( node ) { var declaration = node . parent ; if ( node === declaration . initializer ) { if ( declaration . type ) { return getTypeFromTypeNode ( declaration . type ) ; } if ( declaration . kind === 138 ) { var type = getContextuallyTypedParameterType ( declaration ) ; if ( type ) { return type ; } } if ( ts . isBindingPattern ( declaration . name ) ) { return getTypeFromBindingPattern ( declaration . name , true ) ; } } return undefined ; } 
function applyToContextualType ( type , mapper ) { if ( ! ( type . flags & 16384 ) ) { return mapper ( type ) ; } var types = type . types ; var mappedType ; var mappedTypes ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; var t = mapper ( current ) ; if ( t ) { if ( ! mappedType ) { mappedType = t ; } else if ( ! mappedTypes ) { mappedTypes = [ mappedType , t ] ; } else { mappedTypes . push ( t ) ; } } } return mappedTypes ? getUnionType ( mappedTypes ) : mappedType ; } 
function contextualTypeHasIndexSignature ( type , kind ) { return ! ! ( type . flags & 16384 ? ts . forEach ( type . types , function ( t ) { return getIndexTypeOfStructuredType ( t , kind ) ; } ) : getIndexTypeOfStructuredType ( type , kind ) ) ; } 
function getContextualTypeForObjectLiteralMethod ( node ) { ts . Debug . assert ( ts . isObjectLiteralMethod ( node ) ) ; if ( isInsideWithStatementBody ( node ) ) { 
function getContextualTypeForElementExpression ( node ) { var arrayLiteral = node . parent ; var type = getContextualType ( arrayLiteral ) ; if ( type ) { var index = ts . indexOf ( arrayLiteral . elements , node ) ; return getTypeOfPropertyOfContextualType ( type , "" + index ) || getIndexTypeOfContextualType ( type , 1 ) || ( languageVersion >= 2 ? getElementTypeOfIterable ( type , undefined ) : undefined ) ; } return undefined ; } 
function getContextualTypeForConditionalOperand ( node ) { var conditional = node . parent ; return node === conditional . whenTrue || node === conditional . whenFalse ? getContextualType ( conditional ) : undefined ; } 
function getNonGenericSignature ( type ) { var signatures = getSignaturesOfStructuredType ( type , 0 ) ; if ( signatures . length === 1 ) { var signature = signatures [ 0 ] ; if ( ! signature . typeParameters ) { return signature ; } } } 
function getContextualSignature ( node ) { ts . Debug . assert ( node . kind !== 143 || ts . isObjectLiteralMethod ( node ) ) ; var type = ts . isObjectLiteralMethod ( node ) ? getContextualTypeForObjectLiteralMethod ( node ) : getContextualType ( node ) ; if ( ! type ) { return undefined ; } if ( ! ( type . flags & 16384 ) ) { return getNonGenericSignature ( type ) ; } var signatureList ; var types = type . types ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; var signature = getNonGenericSignature ( current ) ; if ( signature ) { if ( ! signatureList ) { 
function isAssignmentTarget ( node ) { var parent = node . parent ; if ( parent . kind === 181 && parent . operatorToken . kind === 56 && parent . left === node ) { return true ; } if ( parent . kind === 245 ) { return isAssignmentTarget ( parent . parent ) ; } if ( parent . kind === 164 ) { return isAssignmentTarget ( parent ) ; } return false ; } 
function getJsxIntrinsicElementsType ( ) { if ( ! jsxIntrinsicElementsType ) { jsxIntrinsicElementsType = getExportedTypeFromNamespace ( JsxNames . JSX , JsxNames . IntrinsicElements ) || unknownType ; } return jsxIntrinsicElementsType ; } 
function getJsxElementTagSymbol ( node ) { var flags = 8 ; var links = getNodeLinks ( node ) ; if ( ! links . resolvedSymbol ) { if ( isJsxIntrinsicIdentifier ( node . tagName ) ) { links . resolvedSymbol = lookupIntrinsicTag ( node ) ; } else { links . resolvedSymbol = lookupClassTag ( node ) ; } } return links . resolvedSymbol ; function lookupIntrinsicTag ( node ) { var intrinsicElementsType = getJsxIntrinsicElementsType ( ) ; if ( intrinsicElementsType !== unknownType ) { 
function getJsxElementInstanceType ( node ) { 
function getJsxElementAttributesType ( node ) { var links = getNodeLinks ( node ) ; if ( ! links . resolvedJsxType ) { var sym = getJsxElementTagSymbol ( node ) ; if ( links . jsxFlags & 4 ) { var elemInstanceType = getJsxElementInstanceType ( node ) ; if ( isTypeAny ( elemInstanceType ) ) { return links . resolvedJsxType = elemInstanceType ; } var propsName = getJsxElementPropertiesName ( ) ; if ( propsName === undefined ) { 
function getJsxAttributePropertySymbol ( attrib ) { var attributesType = getJsxElementAttributesType ( attrib . parent ) ; var prop = getPropertyOfType ( attributesType , attrib . name . text ) ; return prop || unknownSymbol ; } 
function checkClassPropertyAccess ( node , left , type , prop ) { var flags = getDeclarationFlagsFromSymbol ( prop ) ; var declaringClass = getDeclaredTypeOfSymbol ( prop . parent ) ; if ( left . kind === 95 ) { var errorNode = node . kind === 166 ? node . name : node . right ; 
function getPropertyNameForIndexedAccess ( indexArgumentExpression , indexArgumentType ) { if ( indexArgumentExpression . kind === 9 || indexArgumentExpression . kind === 8 ) { return indexArgumentExpression . text ; } if ( indexArgumentExpression . kind === 167 || indexArgumentExpression . kind === 166 ) { var value = getConstantValue ( indexArgumentExpression ) ; if ( value !== undefined ) { return value . toString ( ) ; } } if ( checkThatExpressionIsProperSymbolReference ( indexArgumentExpression , indexArgumentType , false ) ) { var rightHandSideName = indexArgumentExpression . name . text ; return ts . getPropertyNameForKnownSymbolName ( rightHandSideName ) ; } return undefined ; } 
function reorderCandidates ( signatures , result ) { var lastParent ; var lastSymbol ; var cutoffIndex = 0 ; var index ; var specializedIndex = - 1 ; var spliceIndex ; ts . Debug . assert ( ! result . length ) ; for ( var _i = 0 ; _i < signatures . length ; _i ++ ) { var signature = signatures [ _i ] ; var symbol = signature . declaration && getSymbolOfNode ( signature . declaration ) ; var parent_5 = signature . declaration && signature . declaration . parent ; if ( ! lastSymbol || symbol === lastSymbol ) { if ( lastParent && parent_5 === lastParent ) { index ++ ; } else { lastParent = parent_5 ; index = cutoffIndex ; } } else { 
function getSingleCallSignature ( type ) { if ( type . flags & 80896 ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( resolved . callSignatures . length === 1 && resolved . constructSignatures . length === 0 && resolved . properties . length === 0 && ! resolved . stringIndexType && ! resolved . numberIndexType ) { return resolved . callSignatures [ 0 ] ; } } return undefined ; } 
function instantiateSignatureInContextOf ( signature , contextualSignature , contextualMapper ) { var context = createInferenceContext ( signature . typeParameters , true ) ; forEachMatchingParameterType ( contextualSignature , signature , function ( source , target ) { 
function getEffectiveCallArguments ( node ) { var args ; if ( node . kind === 170 ) { var template = node . template ; args = [ undefined ] ; if ( template . kind === 183 ) { ts . forEach ( template . templateSpans , function ( span ) { args . push ( span . expression ) ; } ) ; } } else if ( node . kind === 139 ) { 
function getEffectiveArgumentCount ( node , args , signature ) { if ( node . kind === 139 ) { switch ( node . parent . kind ) { case 214 : case 186 : 
function getEffectiveDecoratorSecondArgumentType ( node ) { 
function getEffectiveDecoratorArgumentType ( node , argIndex ) { if ( argIndex === 0 ) { return getEffectiveDecoratorFirstArgumentType ( node . parent ) ; } else if ( argIndex === 1 ) { return getEffectiveDecoratorSecondArgumentType ( node . parent ) ; } else if ( argIndex === 2 ) { return getEffectiveDecoratorThirdArgumentType ( node . parent ) ; } ts . Debug . fail ( "Decorators should not have a fourth synthetic argument." ) ; return unknownType ; } 
function getEffectiveArgumentType ( node , argIndex , arg ) { 
function getEffectiveArgument ( node , args , argIndex ) { 
function getEffectiveArgumentErrorNode ( node , argIndex , arg ) { if ( node . kind === 139 ) { 
function getDiagnosticHeadMessageForDecoratorResolution ( node ) { switch ( node . parent . kind ) { case 214 : case 186 : return ts . Diagnostics . Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression ; case 138 : return ts . Diagnostics . Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression ; case 141 : return ts . Diagnostics . Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression ; case 143 : case 145 : case 146 : return ts . Diagnostics . Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression ; } } 
function resolveDecorator ( node , candidatesOutArray ) { var funcType = checkExpression ( node . expression ) ; var apparentType = getApparentType ( funcType ) ; if ( apparentType === unknownType ) { return resolveErrorCall ( node ) ; } var callSignatures = getSignaturesOfType ( apparentType , 0 ) ; if ( funcType === anyType || ( ! callSignatures . length && ! ( funcType . flags & 16384 ) && isTypeAssignableTo ( funcType , globalFunctionType ) ) ) { return resolveUntypedCall ( node ) ; } var headMessage = getDiagnosticHeadMessageForDecoratorResolution ( node ) ; if ( ! callSignatures . length ) { var errorInfo ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . Cannot_invoke_an_expression_whose_type_lacks_a_call_signature ) ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , headMessage ) ; diagnostics . add ( ts . createDiagnosticForNodeFromMessageChain ( node , errorInfo ) ) ; return resolveErrorCall ( node ) ; } return resolveCall ( node , callSignatures , candidatesOutArray , headMessage ) ; } 
function getResolvedSignature ( node , candidatesOutArray ) { var links = getNodeLinks ( node ) ; 
function checkCallExpression ( node ) { 
function assignBindingElementTypes ( node ) { if ( ts . isBindingPattern ( node . name ) ) { for ( var _i = 0 , _a = node . name . elements ; _i < _a . length ; _i ++ ) { var element = _a [ _i ] ; if ( element . kind !== 187 ) { if ( element . name . kind === 69 ) { getSymbolLinks ( getSymbolOfNode ( element ) ) . type = getTypeForBindingElement ( element ) ; } assignBindingElementTypes ( element ) ; } } } } 
function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment ( func , returnType ) { if ( ! produceDiagnostics ) { return ; } 
function someConstituentTypeHasKind ( type , kind ) { if ( type . flags & kind ) { return true ; } if ( type . flags & 49152 ) { var types = type . types ; for ( var _i = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; if ( current . flags & kind ) { return true ; } } return false ; } return false ; } 
function checkTypeParameter ( node ) { 
function getPromisedType ( promise ) { 
function checkDecorator ( node ) { var signature = getResolvedSignature ( node ) ; var returnType = getReturnTypeOfSignature ( signature ) ; if ( returnType . flags & 1 ) { return ; } var expectedReturnType ; var headMessage = getDiagnosticHeadMessageForDecoratorResolution ( node ) ; var errorInfo ; switch ( node . parent . kind ) { case 214 : var classSymbol = getSymbolOfNode ( node . parent ) ; var classConstructorType = getTypeOfSymbol ( classSymbol ) ; expectedReturnType = getUnionType ( [ classConstructorType , voidType ] ) ; break ; case 138 : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any ) ; break ; case 141 : expectedReturnType = voidType ; errorInfo = ts . chainDiagnosticMessages ( errorInfo , ts . Diagnostics . The_return_type_of_a_property_decorator_function_must_be_either_void_or_any ) ; break ; case 143 : case 145 : case 146 : var methodType = getTypeOfNode ( node . parent ) ; var descriptorType = createTypedPropertyDescriptorType ( methodType ) ; expectedReturnType = getUnionType ( [ descriptorType , voidType ] ) ; break ; } checkTypeAssignableTo ( returnType , expectedReturnType , node , headMessage , errorInfo ) ; } 
function checkTypeNodeAsExpression ( node ) { 
function checkTypeAnnotationAsExpression ( node ) { switch ( node . kind ) { case 141 : checkTypeNodeAsExpression ( node . type ) ; break ; case 138 : checkTypeNodeAsExpression ( node . type ) ; break ; case 143 : checkTypeNodeAsExpression ( node . type ) ; break ; case 145 : checkTypeNodeAsExpression ( node . type ) ; break ; case 146 : checkTypeNodeAsExpression ( ts . getSetAccessorTypeAnnotationNode ( node ) ) ; break ; } } 
function checkParameterTypeAnnotationsAsExpressions ( node ) { 
function checkDecorators ( node ) { if ( ! node . decorators ) { return ; } 
function checkIfThisIsCapturedInEnclosingScope ( node ) { var current = node ; while ( current ) { if ( getNodeCheckFlags ( current ) & 4 ) { var isDeclaration_1 = node . kind !== 69 ; if ( isDeclaration_1 ) { error ( node . name , ts . Diagnostics . Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference ) ; } else { error ( node , ts . Diagnostics . Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference ) ; } return ; } current = current . parent ; } } 
function checkParameterInitializer ( node ) { if ( ts . getRootDeclaration ( node ) . kind !== 138 ) { return ; } var func = ts . getContainingFunction ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind === 69 ) { var referencedSymbol = getNodeLinks ( n ) . resolvedSymbol ; 
function checkVariableLikeDeclaration ( node ) { checkDecorators ( node ) ; checkSourceElement ( node . type ) ; 
function checkElementTypeOfIterable ( iterable , errorNode ) { var elementType = getElementTypeOfIterable ( iterable , errorNode ) ; 
function checkTypeParameters ( typeParameterDeclarations ) { if ( typeParameterDeclarations ) { for ( var i = 0 , n = typeParameterDeclarations . length ; i < n ; i ++ ) { var node = typeParameterDeclarations [ i ] ; checkTypeParameter ( node ) ; if ( produceDiagnostics ) { for ( var j = 0 ; j < i ; j ++ ) { if ( typeParameterDeclarations [ j ] . symbol === node . symbol ) { error ( node . name , ts . Diagnostics . Duplicate_identifier_0 , ts . declarationNameToString ( node . name ) ) ; } } } } } } 
function checkFunctionAndClassExpressionBodies ( node ) { switch ( node . kind ) { case 173 : case 174 : ts . forEach ( node . parameters , checkFunctionAndClassExpressionBodies ) ; checkFunctionExpressionOrObjectLiteralMethodBody ( node ) ; break ; case 186 : ts . forEach ( node . members , checkSourceElement ) ; ts . forEachChild ( node , checkFunctionAndClassExpressionBodies ) ; break ; case 143 : case 142 : ts . forEach ( node . decorators , checkFunctionAndClassExpressionBodies ) ; ts . forEach ( node . parameters , checkFunctionAndClassExpressionBodies ) ; if ( ts . isObjectLiteralMethod ( node ) ) { checkFunctionExpressionOrObjectLiteralMethodBody ( node ) ; } break ; case 144 : case 145 : case 146 : case 213 : ts . forEach ( node . parameters , checkFunctionAndClassExpressionBodies ) ; break ; case 205 : checkFunctionAndClassExpressionBodies ( node . expression ) ; break ; case 139 : case 138 : case 141 : case 140 : case 161 : case 162 : case 163 : case 164 : case 165 : case 245 : case 166 : case 167 : case 168 : case 169 : case 170 : case 183 : case 190 : case 171 : case 189 : case 172 : case 176 : case 177 : case 178 : case 175 : case 179 : case 180 : case 181 : case 182 : case 185 : case 184 : case 192 : case 219 : case 193 : case 195 : case 196 : case 197 : case 198 : case 199 : case 200 : case 201 : case 202 : case 203 : case 204 : case 206 : case 220 : case 241 : case 242 : case 207 : case 208 : case 209 : case 244 : case 211 : case 212 : case 214 : case 243 : case 188 : case 217 : case 247 : case 227 : case 248 : case 240 : case 233 : case 234 : case 238 : case 239 : case 235 : ts . forEachChild ( node , checkFunctionAndClassExpressionBodies ) ; break ; } } 
function checkSourceFileWorker ( node ) { var links = getNodeLinks ( node ) ; if ( ! ( links . flags & 1 ) ) { 
function copySymbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; 
function getParentTypeOfClassElement ( node ) { var classSymbol = getSymbolOfNode ( node . parent ) ; return node . flags & 128 ? getTypeOfSymbol ( classSymbol ) : getDeclaredTypeOfSymbol ( classSymbol ) ; } 
function getAugmentedPropertiesOfType ( type ) { type = getApparentType ( type ) ; var propsByName = createSymbolTable ( getPropertiesOfType ( type ) ) ; if ( getSignaturesOfType ( type , 0 ) . length || getSignaturesOfType ( type , 1 ) . length ) { ts . forEach ( getPropertiesOfType ( globalFunctionType ) , function ( p ) { if ( ! ts . hasProperty ( propsByName , p . name ) ) { propsByName [ p . name ] = p ; } } ) ; } return getNamedMembers ( propsByName ) ; } 
function getReferencedExportContainer ( node ) { var symbol = getReferencedValueSymbol ( node ) ; if ( symbol ) { if ( symbol . flags & 1048576 ) { 
function getReferencedImportDeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && symbol . flags & 8388608 ? getDeclarationOfAliasSymbol ( symbol ) : undefined ; } 
function getReferencedNestedRedeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && isNestedRedeclarationSymbol ( symbol ) ? symbol . valueDeclaration : undefined ; } 
function checkGrammarDecorators ( node ) { if ( ! node . decorators ) { return false ; } if ( ! ts . nodeCanBeDecorated ( node ) ) { return grammarErrorOnFirstToken ( node , ts . Diagnostics . Decorators_are_not_valid_here ) ; } else if ( node . kind === 145 || node . kind === 146 ) { var accessors = ts . getAllAccessorDeclarations ( node . parent . members , node ) ; if ( accessors . firstAccessor . decorators && node === accessors . secondAccessor ) { return grammarErrorOnFirstToken ( node , ts . Diagnostics . Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name ) ; } } return false ; } 
function getExportDefaultTempVariableName ( ) { var baseName = "_default" ; if ( ! ts . hasProperty ( currentSourceFile . identifiers , baseName ) ) { return baseName ; } var count = 0 ; while ( true ) { var name_18 = baseName + "_" + ( ++ count ) ; if ( ! ts . hasProperty ( currentSourceFile . identifiers , name_18 ) ) { return name_18 ; } } } 
function writeDeclarationFile ( jsFilePath , sourceFile , host , resolver , diagnostics ) { var emitDeclarationResult = emitDeclarations ( host , resolver , diagnostics , jsFilePath , sourceFile ) ; 
function emitFiles ( resolver , host , targetSourceFile ) { * This by default writes the text provided with the given tokenKind * but if optional emitFn callback is provided the text is emitted using the callback instead of default text * @param tokenKind the kind of the token to search and emit * @param startPos the position in the source to start searching for the token * @param emitFn if given will be invoked to emit the text instead of actual token emit */ var emitToken = emitTokenText ; var scopeEmitStart = function ( scopeDeclaration , scopeName ) { } ; var scopeEmitEnd = function ( ) { } ; var sourceMapData ; var emitLeadingCommentsOfPosition = compilerOptions . removeComments ? function ( pos ) { } : emitLeadingCommentsOfPositionWorker ; var moduleEmitDelegates = ( _a = { } , _a [ 5 ] = emitES6Module , _a [ 2 ] = emitAMDModule , _a [ 4 ] = emitSystemModule , _a [ 3 ] = emitUMDModule , _a [ 1 ] = emitCommonJSModule , _a ) ; if ( compilerOptions . sourceMap || compilerOptions . inlineSourceMap ) { initializeEmitterWithSourceMaps ( ) ; } if ( root ) { * Returns whether the expression has lesser, greater, * or equal precedence to the binary '+' operator */ function comparePrecedenceToBinaryPlus ( expression ) { * Checks if given node is a source file level declaration (not nested in module/function). * If 'isExported' is true - then declaration must also be exported. * This function is used in two cases: * - check if node is a exported source file level value to determine * if we should also export the value after its it changed * - check if node is a source level declaration to emit it differently, * i.e non-exported variable statement 'var x = 1' is hoisted so * we we emit variable statement 'var' should be dropped. */ function isSourceFileLevelDeclarationInSystemJsModule ( node , isExported ) { if ( ! node || languageVersion >= 2 || ! isCurrentFileSystemExternalModule ( ) ) { return false ; } var current = node ; while ( current ) { if ( current . kind === 248 ) { return ! isExported || ( ( ts . getCombinedNodeFlags ( node ) & 1 ) !== 0 ) ; } else if ( ts . isFunctionLike ( current ) || current . kind === 219 ) { return false ; } else { current = current . parent ; } } } function emitExponentiationOperator ( node ) { var leftHandSideExpression = node . left ; if ( node . operatorToken . kind === 60 ) { var synthesizedLHS ; var shouldEmitParentheses = false ; if ( ts . isElementAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 167 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; if ( leftHandSideExpression . argumentExpression . kind !== 8 && leftHandSideExpression . argumentExpression . kind !== 9 ) { var tempArgumentExpression = createAndRecordTempVariable ( 268435456 ) ; synthesizedLHS . argumentExpression = tempArgumentExpression ; emitAssignment ( tempArgumentExpression , leftHandSideExpression . argumentExpression , true ) ; } else { synthesizedLHS . argumentExpression = leftHandSideExpression . argumentExpression ; } write ( ", " ) ; } else if ( ts . isPropertyAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 166 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; synthesizedLHS . dotToken = leftHandSideExpression . dotToken ; synthesizedLHS . name = leftHandSideExpression . name ; write ( ", " ) ; } emit ( synthesizedLHS || leftHandSideExpression ) ; write ( " = " ) ; write ( "Math.pow(" ) ; emit ( synthesizedLHS || leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; if ( shouldEmitParentheses ) { write ( ")" ) ; } } else { write ( "Math.pow(" ) ; emit ( leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; } } function emitBinaryExpression ( node ) { if ( languageVersion < 2 && node . operatorToken . kind === 56 && ( node . left . kind === 165 || node . left . kind === 164 ) ) { emitDestructuring ( node , node . parent . kind === 195 ) ; } else { var exportChanged = node . operatorToken . kind >= 56 && node . operatorToken . kind <= 68 && isNameOfExportedSourceLevelDeclarationInSystemExternalModule ( node . left ) ; if ( exportChanged ) { * Returns true if start of variable declaration list was emitted. * Returns false if nothing was written - this can happen for source file level variable declarations * in system modules where such variable declarations are hoisted. */ function tryEmitStartOfVariableDeclarationList ( decl , startPos ) { if ( shouldHoistVariable ( decl , true ) ) { * Emit an assignment to a given identifier, 'name', with a given expression, 'value'. * @param name an identifier as a left-hand-side operand of the assignment * @param value an expression as a right-hand-side operand of the assignment * @param shouldEmitCommaBeforeAssignment a boolean indicating whether to prefix an assignment with comma */ function emitAssignment ( name , value , shouldEmitCommaBeforeAssignment ) { if ( shouldEmitCommaBeforeAssignment ) { write ( ", " ) ; } var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule ( name ) ; if ( exportChanged ) { write ( exportFunctionForFile + "(\"" ) ; emitNodeWithCommentsAndWithoutSourcemap ( name ) ; write ( "\", " ) ; } var isVariableDeclarationOrBindingElement = name . parent && ( name . parent . kind === 211 || name . parent . kind === 163 ) ; if ( isVariableDeclarationOrBindingElement ) { emitModuleMemberName ( name . parent ) ; } else { emit ( name ) ; } write ( " = " ) ; emit ( value ) ; if ( exportChanged ) { write ( ")" ) ; } } function emitTempVariableAssignment ( expression , canDefineTempVariablesInPlace , shouldEmitCommaBeforeAssignment ) { var identifier = createTempVariable ( 0 ) ; if ( ! canDefineTempVariablesInPlace ) { recordTempDeclaration ( identifier ) ; } emitAssignment ( identifier , expression , shouldEmitCommaBeforeAssignment ) ; return identifier ; } function emitDestructuring ( root , isAssignmentExpressionStatement , value ) { var emitCount = 0 ; * Ensures that there exists a declared identifier whose value holds the given expression. * This function is useful to ensure that the expression's value can be read from in subsequent expressions. * Unless 'reuseIdentifierExpressions' is false, 'expr' will be returned if it is just an identifier. * * @param expr the expression whose value needs to be bound. * @param reuseIdentifierExpressions true if identifier expressions can simply be returned; * false if it is necessary to always emit an identifier. */ function ensureIdentifier ( expr , reuseIdentifierExpressions ) { if ( expr . kind === 69 /* Identifier */ && reuseIdentifierExpressions ) { return expr ; } var identifier = emitTempVariableAssignment ( expr , canDefineTempVariablesInPlace , emitCount > 0 ) ; emitCount ++ ; return identifier ; } function createDefaultValueCheck ( value , defaultValue ) { // The value expression will be evaluated twice, so for anything but a simple identifier // we need to generate a temporary variable value = ensureIdentifier ( value , /*reuseIdentifierExpressions*/ true ) ; // Return the expression 'value === void 0 ? defaultValue : value' var equals = ts . createSynthesizedNode ( 181 /* BinaryExpression */ ) ; equals . left = value ; equals . operatorToken = ts . createSynthesizedNode ( 32 /* EqualsEqualsEqualsToken */ ) ; equals . right = createVoidZero ( ) ; return createConditionalExpression ( equals , defaultValue , value ) ; } function createConditionalExpression ( condition , whenTrue , whenFalse ) { var cond = ts . createSynthesizedNode ( 182 /* ConditionalExpression */ ) ; cond . condition = condition ; cond . questionToken = ts . createSynthesizedNode ( 53 /* QuestionToken */ ) ; cond . whenTrue = whenTrue ; cond . colonToken = ts . createSynthesizedNode ( 54 /* ColonToken */ ) ; cond . whenFalse = whenFalse ; return cond ; } function createNumericLiteral ( value ) { var node = ts . createSynthesizedNode ( 8 /* NumericLiteral */ ) ; node . text = "" + value ; return node ; } function createPropertyAccessForDestructuringProperty ( object , propName ) { // We create a synthetic copy of the identifier in order to avoid the rewriting that might // otherwise occur when the identifier is emitted. var syntheticName = ts . createSynthesizedNode ( propName . kind ) ; syntheticName . text = propName . text ; if ( syntheticName . kind !== 69 /* Identifier */ ) { return createElementAccessExpression ( object , syntheticName ) ; } return createPropertyAccessExpression ( object , syntheticName ) ; } function createSliceCall ( value , sliceIndex ) { var call = ts . createSynthesizedNode ( 168 /* CallExpression */ ) ; var sliceIdentifier = ts . createSynthesizedNode ( 69 /* Identifier */ ) ; sliceIdentifier . text = "slice" ; call . expression = createPropertyAccessExpression ( value , sliceIdentifier ) ; call . arguments = ts . createSynthesizedNodeArray ( ) ; call . arguments [ 0 ] = createNumericLiteral ( sliceIndex ) ; return call ; } function emitObjectLiteralAssignment ( target , value ) { var properties = target . properties ; if ( properties . length !== 1 ) { // For anything but a single element destructuring we need to generate a temporary // to ensure value is evaluated exactly once. value = ensureIdentifier ( value , /*reuseIdentifierExpressions*/ true ) ; } for ( var _a = 0 ; _a < properties . length ; _a ++ ) { var p = properties [ _a ] ; if ( p . kind === 245 /* PropertyAssignment */ || p . kind === 246 /* ShorthandPropertyAssignment */ ) { var propName = p . name ; var target_1 = p . kind === 246 /* ShorthandPropertyAssignment */ ? p : p . initializer || propName ; emitDestructuringAssignment ( target_1 , createPropertyAccessForDestructuringProperty ( value , propName ) ) ; } } } function emitArrayLiteralAssignment ( target , value ) { var elements = target . elements ; if ( elements . length !== 1 ) { // For anything but a single element destructuring we need to generate a temporary // to ensure value is evaluated exactly once. value = ensureIdentifier ( value , /*reuseIdentifierExpressions*/ true ) ; } for ( var i = 0 ; i < elements . length ; i ++ ) { var e = elements [ i ] ; if ( e . kind !== 187 /* OmittedExpression */ ) { if ( e . kind !== 185 /* SpreadElementExpression */ ) { emitDestructuringAssignment ( e , createElementAccessExpression ( value , createNumericLiteral ( i ) ) ) ; } else if ( i === elements . length - 1 ) { emitDestructuringAssignment ( e . expression , createSliceCall ( value , i ) ) ; } } } } function emitDestructuringAssignment ( target , value ) { if ( target . kind === 246 /* ShorthandPropertyAssignment */ ) { if ( target . objectAssignmentInitializer ) { value = createDefaultValueCheck ( value , target . objectAssignmentInitializer ) ; } target = target . name ; } else if ( target . kind === 181 /* BinaryExpression */ && target . operatorToken . kind === 56 /* EqualsToken */ ) { value = createDefaultValueCheck ( value , target . right ) ; target = target . left ; } if ( target . kind === 165 /* ObjectLiteralExpression */ ) { emitObjectLiteralAssignment ( target , value ) ; } else if ( target . kind === 164 /* ArrayLiteralExpression */ ) { emitArrayLiteralAssignment ( target , value ) ; } else { emitAssignment ( target , value , /*shouldEmitCommaBeforeAssignment*/ emitCount > 0 ) ; emitCount ++ ; } } function emitAssignmentExpression ( root ) { var target = root . left ; var value = root . right ; if ( ts . isEmptyObjectLiteralOrArrayLiteral ( target ) ) { emit ( value ) ; } else if ( isAssignmentExpressionStatement ) { emitDestructuringAssignment ( target , value ) ; } else { if ( root . parent . kind !== 172 /* ParenthesizedExpression */ ) { write ( "(" ) ; } value = ensureIdentifier ( value , /*reuseIdentifierExpressions*/ true ) ; emitDestructuringAssignment ( target , value ) ; write ( ", " ) ; emit ( value ) ; if ( root . parent . kind !== 172 /* ParenthesizedExpression */ ) { write ( ")" ) ; } } } function emitBindingElement ( target , value ) { if ( target . initializer ) { // Combine value and initializer value = value ? createDefaultValueCheck ( value , target . initializer ) : target . initializer ; } else if ( ! value ) { // Use 'void 0' in absence of value and initializer value = createVoidZero ( ) ; } if ( ts . isBindingPattern ( target . name ) ) { var pattern = target . name ; var elements = pattern . elements ; var numElements = elements . length ; if ( numElements !== 1 ) { // For anything other than a single-element destructuring we need to generate a temporary // to ensure value is evaluated exactly once. Additionally, if we have zero elements // we need to emit *something* to ensure that in case a 'var' keyword was already emitted, // so in that case, we'll intentionally create that temporary. value = ensureIdentifier ( value , numElements !== 0 ) ; } for ( var i = 0 ; i < numElements ; i ++ ) { var element = elements [ i ] ; if ( pattern . kind === 161 ) { * Some bundlers (SystemJS builder) sometimes want to rename dependencies. * Here we check if alternative name was provided for a given moduleName and return it if possible. */ function tryRenameExternalModule ( moduleName ) { if ( currentSourceFile . renamedDependencies && ts . hasProperty ( currentSourceFile . renamedDependencies , moduleName . text ) ) { return "\"" + currentSourceFile . renamedDependencies [ moduleName . text ] + "\"" ; } return undefined ; } function emitRequire ( moduleName ) { if ( moduleName . kind === 9 ) { write ( "require(" ) ; var text = tryRenameExternalModule ( moduleName ) ; if ( text ) { write ( text ) ; } else { emitStart ( moduleName ) ; emitLiteral ( moduleName ) ; emitEnd ( moduleName ) ; } emitToken ( 18 , moduleName . end ) ; } else { write ( "require()" ) ; } } function getNamespaceDeclarationNode ( node ) { if ( node . kind === 221 ) { return node ; } var importClause = node . importClause ; if ( importClause && importClause . namedBindings && importClause . namedBindings . kind === 224 ) { return importClause . namedBindings ; } } function isDefaultImport ( node ) { return node . kind === 222 && node . importClause && ! ! node . importClause . name ; } function emitExportImportAssignments ( node ) { if ( ts . isAliasSymbolDeclaration ( node ) && resolver . isValueAliasDeclaration ( node ) ) { emitExportMemberAssignments ( node . name ) ; } ts . forEachChild ( node , emitExportImportAssignments ) ; } function emitImportDeclaration ( node ) { if ( modulekind !== 5 ) { return emitExternalImportDeclaration ( node ) ; } * Determine if the given comment is a triple-slash * * @return true if the comment is a triple-slash comment else false **/ function isTripleSlashComment ( comment ) { * Emit comments associated with node that will not be emitted into JS file */ function emitCommentsOnNotEmittedNode ( node ) { emitLeadingCommentsWorker ( node , false ) ; } function emitLeadingComments ( node ) { return emitLeadingCommentsWorker ( node , true ) ; } function emitLeadingCommentsWorker ( node , isEmittedNode ) { if ( compilerOptions . removeComments ) { return ; } var leadingComments ; if ( isEmittedNode ) { leadingComments = getLeadingCommentsToEmit ( node ) ; } else { * Emit trailing comments at the position. The term trailing comment is used here to describe following comment: * x, /comment1/ y * ^ => pos; the function will emit "comment1" in the emitJS */ function emitTrailingCommentsOfPosition ( pos ) { if ( compilerOptions . removeComments ) { return ; } var trailingComments = ts . getTrailingCommentRanges ( currentSourceFile . text , pos ) ; 
function makeTempVariableName ( flags ) { if ( flags && ! ( tempFlags & flags ) ) { var name_19 = flags === 268435456 ? "_i" : "_n" ; if ( isUniqueName ( name_19 ) ) { tempFlags |= flags ; return name_19 ; } } while ( true ) { var count = tempFlags & 268435455 ; tempFlags ++ ; 
function makeUniqueName ( baseName ) { 
function encodeLastRecordedSourceMapSpan ( ) { if ( ! lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan ) { return ; } var prevEncodedEmittedColumn = lastEncodedSourceMapSpan . emittedColumn ; 
function createTempVariable ( flags ) { var result = ts . createSynthesizedNode ( 69 ) ; result . text = makeTempVariableName ( flags ) ; return result ; } 
function emitTagName ( name ) { if ( name . kind === 69 && ts . isIntrinsicJsxName ( name . text ) ) { write ( "\"" ) ; emit ( name ) ; write ( "\"" ) ; } else { emit ( name ) ; } } 
function emitExpressionForPropertyName ( node ) { ts . Debug . assert ( node . kind !== 163 ) ; if ( node . kind === 9 ) { emitLiteral ( node ) ; } else if ( node . kind === 136 ) { 
function indentIfOnDifferentLines ( parent , node1 , node2 , valueToWriteWhenNotIndenting ) { var realNodesAreOnDifferentLines = ! ts . nodeIsSynthesized ( parent ) && ! nodeEndIsOnSameLineAsNodeStart ( node1 , node2 ) ; 
function isSourceFileLevelDeclarationInSystemJsModule ( node , isExported ) { if ( ! node || languageVersion >= 2 || ! isCurrentFileSystemExternalModule ( ) ) { return false ; } var current = node ; while ( current ) { if ( current . kind === 248 ) { return ! isExported || ( ( ts . getCombinedNodeFlags ( node ) & 1 ) !== 0 ) ; } else if ( ts . isFunctionLike ( current ) || current . kind === 219 ) { return false ; } else { current = current . parent ; } } } 
function emitExponentiationOperator ( node ) { var leftHandSideExpression = node . left ; if ( node . operatorToken . kind === 60 ) { var synthesizedLHS ; var shouldEmitParentheses = false ; if ( ts . isElementAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 167 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; if ( leftHandSideExpression . argumentExpression . kind !== 8 && leftHandSideExpression . argumentExpression . kind !== 9 ) { var tempArgumentExpression = createAndRecordTempVariable ( 268435456 ) ; synthesizedLHS . argumentExpression = tempArgumentExpression ; emitAssignment ( tempArgumentExpression , leftHandSideExpression . argumentExpression , true ) ; } else { synthesizedLHS . argumentExpression = leftHandSideExpression . argumentExpression ; } write ( ", " ) ; } else if ( ts . isPropertyAccessExpression ( leftHandSideExpression ) ) { shouldEmitParentheses = true ; write ( "(" ) ; synthesizedLHS = ts . createSynthesizedNode ( 166 , false ) ; var identifier = emitTempVariableAssignment ( leftHandSideExpression . expression , false , false ) ; synthesizedLHS . expression = identifier ; synthesizedLHS . dotToken = leftHandSideExpression . dotToken ; synthesizedLHS . name = leftHandSideExpression . name ; write ( ", " ) ; } emit ( synthesizedLHS || leftHandSideExpression ) ; write ( " = " ) ; write ( "Math.pow(" ) ; emit ( synthesizedLHS || leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; if ( shouldEmitParentheses ) { write ( ")" ) ; } } else { write ( "Math.pow(" ) ; emit ( leftHandSideExpression ) ; write ( ", " ) ; emit ( node . right ) ; write ( ")" ) ; } } 
function tryEmitStartOfVariableDeclarationList ( decl , startPos ) { if ( shouldHoistVariable ( decl , true ) ) { 
function emitAssignment ( name , value , shouldEmitCommaBeforeAssignment ) { if ( shouldEmitCommaBeforeAssignment ) { write ( ", " ) ; } var exportChanged = isNameOfExportedSourceLevelDeclarationInSystemExternalModule ( name ) ; if ( exportChanged ) { write ( exportFunctionForFile + "(\"" ) ; emitNodeWithCommentsAndWithoutSourcemap ( name ) ; write ( "\", " ) ; } var isVariableDeclarationOrBindingElement = name . parent && ( name . parent . kind === 211 || name . parent . kind === 163 ) ; if ( isVariableDeclarationOrBindingElement ) { emitModuleMemberName ( name . parent ) ; } else { emit ( name ) ; } write ( " = " ) ; emit ( value ) ; if ( exportChanged ) { write ( ")" ) ; } } 
function emitTempVariableAssignment ( expression , canDefineTempVariablesInPlace , shouldEmitCommaBeforeAssignment ) { var identifier = createTempVariable ( 0 ) ; if ( ! canDefineTempVariablesInPlace ) { recordTempDeclaration ( identifier ) ; } emitAssignment ( identifier , expression , shouldEmitCommaBeforeAssignment ) ; return identifier ; } 
function ensureIdentifier ( expr , reuseIdentifierExpressions ) { if ( expr . kind === 69 && reuseIdentifierExpressions ) { return expr ; } var identifier = emitTempVariableAssignment ( expr , canDefineTempVariablesInPlace , emitCount > 0 ) ; emitCount ++ ; return identifier ; } 
function emitSerializedTypeOfNode ( node ) { 
function emitSerializedReturnTypeOfNode ( node ) { if ( node && ts . isFunctionLike ( node ) && node . type ) { emitSerializedTypeNode ( node . type ) ; return ; } write ( "void 0" ) ; } 
function tryRenameExternalModule ( moduleName ) { if ( currentSourceFile . renamedDependencies && ts . hasProperty ( currentSourceFile . renamedDependencies , moduleName . text ) ) { return "\"" + currentSourceFile . renamedDependencies [ moduleName . text ] + "\"" ; } return undefined ; } 
function emitTrailingCommentsOfPosition ( pos ) { if ( compilerOptions . removeComments ) { return ; } var trailingComments = ts . getTrailingCommentRanges ( currentSourceFile . text , pos ) ; 
function findSourceFile ( fileName , isDefaultLib , refFile , refPos , refEnd ) { if ( filesByName . contains ( fileName ) ) { 
function getOptionNameMap ( ) { if ( optionNameMapCache ) { return optionNameMapCache ; } var optionNameMap = { } ; var shortOptionNames = { } ; ts . forEach ( ts . optionDeclarations , function ( option ) { optionNameMap [ option . name . toLowerCase ( ) ] = option ; if ( option . shortName ) { shortOptionNames [ option . shortName ] = option . name ; } } ) ; optionNameMapCache = { optionNameMap : optionNameMap , shortOptionNames : shortOptionNames } ; return optionNameMapCache ; } 
function readConfigFile ( fileName , readFile ) { var text = "" ; try { text = readFile ( fileName ) ; } catch ( e ) { return { error : ts . createCompilerDiagnostic ( ts . Diagnostics . Cannot_read_file_0_Colon_1 , fileName , e . message ) } ; } return parseConfigFileTextToJson ( fileName , text ) ; } 
function parseConfigFileTextToJson ( fileName , jsonText ) { try { return { config : / \S / . test ( jsonText ) ? JSON . parse ( jsonText ) : { } } ; } catch ( e ) { return { error : ts . createCompilerDiagnostic ( ts . Diagnostics . Failed_to_parse_file_0_Colon_1 , fileName , e . message ) } ; } } 
function parseJsonConfigFileContent ( json , host , basePath ) { var errors = [ ] ; return { options : getCompilerOptions ( ) , fileNames : getFileNames ( ) , errors : errors } ; function getCompilerOptions ( ) { var options = { } ; var optionNameMap = { } ; ts . forEach ( ts . optionDeclarations , function ( option ) { optionNameMap [ option . name ] = option ; } ) ; var jsonOptions = json [ "compilerOptions" ] ; if ( jsonOptions ) { for ( var id in jsonOptions ) { if ( ts . hasProperty ( optionNameMap , id ) ) { var opt = optionNameMap [ id ] ; var optType = opt . type ; var value = jsonOptions [ id ] ; var expectedType = typeof optType === "string" ? optType : "string" ; if ( typeof value === expectedType ) { if ( typeof optType !== "string" ) { var key = value . toLowerCase ( ) ; if ( ts . hasProperty ( optType , key ) ) { value = optType [ key ] ; } else { errors . push ( ts . createCompilerDiagnostic ( opt . error ) ) ; value = 0 ; } } if ( opt . isFilePath ) { value = ts . normalizePath ( ts . combinePaths ( basePath , value ) ) ; if ( value === "" ) { value = "." ; } } options [ opt . name ] = value ; } else { errors . push ( ts . createCompilerDiagnostic ( ts . Diagnostics . Compiler_option_0_requires_a_value_of_type_1 , id , expectedType ) ) ; } } else { errors . push ( ts . createCompilerDiagnostic ( ts . Diagnostics . Unknown_compiler_option_0 , id ) ) ; } } } return options ; } function getFileNames ( ) { var fileNames = [ ] ; if ( ts . hasProperty ( json , "files" ) ) { if ( json [ "files" ] instanceof Array ) { fileNames = ts . map ( json [ "files" ] , function ( s ) { return ts . combinePaths ( basePath , s ) ; } ) ; } else { errors . push ( ts . createCompilerDiagnostic ( ts . Diagnostics . Compiler_option_0_requires_a_value_of_type_1 , "files" , "Array" ) ) ; } } else { var exclude = json [ "exclude" ] instanceof Array ? ts . map ( json [ "exclude" ] , ts . normalizeSlashes ) : undefined ; var sysFiles = host . readDirectory ( basePath , ".ts" , exclude ) . concat ( host . readDirectory ( basePath , ".tsx" , exclude ) ) ; for ( var i = 0 ; i < sysFiles . length ; i ++ ) { var name_28 = sysFiles [ i ] ; if ( ts . fileExtensionIs ( name_28 , ".d.ts" ) ) { var baseName = name_28 . substr ( 0 , name_28 . length - ".d.ts" . length ) ; if ( ! ts . contains ( sysFiles , baseName + ".tsx" ) && ! ts . contains ( sysFiles , baseName + ".ts" ) ) { fileNames . push ( name_28 ) ; } } else if ( ts . fileExtensionIs ( name_28 , ".ts" ) ) { if ( ! ts . contains ( sysFiles , name_28 + "x" ) ) { fileNames . push ( name_28 ) ; } } else { fileNames . push ( name_28 ) ; } } } return fileNames ; } } 
function removeDynamicallyNamedProperties ( node ) { return ts . filter ( node . members , function ( member ) { return ! ts . hasDynamicName ( member ) ; } ) ; } 
function patternMatchCompareTo ( match1 , match2 ) { return compareType ( match1 , match2 ) || compareCamelCase ( match1 , match2 ) || compareCase ( match1 , match2 ) || comparePunctuation ( match1 , match2 ) ; } 
function indexOfIgnoringCase ( string , value ) { for ( var i = 0 , n = string . length - value . length ; i <= n ; i ++ ) { if ( startsWithIgnoringCase ( string , value , i ) ) { return i ; } } return - 1 ; } 
function startsWithIgnoringCase ( string , value , start ) { for ( var i = 0 , n = value . length ; i < n ; i ++ ) { var ch1 = toLowerCase ( string . charCodeAt ( i + start ) ) ; var ch2 = value . charCodeAt ( i ) ; if ( ch1 !== ch2 ) { return false ; } } return true ; } 
function getImmediatelyContainingArgumentInfo ( node ) { if ( node . parent . kind === 168 || node . parent . kind === 169 ) { var callExpression = node . parent ; 
function selectBestInvalidOverloadIndex ( candidates , argumentCount ) { var maxParamsSignatureIndex = - 1 ; var maxParams = - 1 ; for ( var i = 0 ; i < candidates . length ; i ++ ) { var candidate = candidates [ i ] ; if ( candidate . hasRestParameter || candidate . parameters . length >= argumentCount ) { return i ; } if ( candidate . parameters . length > maxParams ) { maxParams = candidate . parameters . length ; maxParamsSignatureIndex = i ; } } return maxParamsSignatureIndex ; } 
function nodeEndsWith ( n , expectedLastToken , sourceFile ) { var children = n . getChildren ( sourceFile ) ; if ( children . length ) { var last = ts . lastOrUndefined ( children ) ; if ( last . kind === expectedLastToken ) { return true ; } else if ( last . kind === 23 && children . length !== 1 ) { return children [ children . length - 2 ] . kind === expectedLastToken ; } } return false ; } 
function getTouchingWord ( sourceFile , position ) { return getTouchingToken ( sourceFile , position , function ( n ) { return isWord ( n . kind ) ; } ) ; } 
function getTouchingPropertyName ( sourceFile , position ) { return getTouchingToken ( sourceFile , position , function ( n ) { return isPropertyName ( n . kind ) ; } ) ; } 
function getTokenAtPositionWorker ( sourceFile , position , allowPositionInLeadingTrivia , includeItemAtEndPosition ) { var current = sourceFile ; outer : while ( true ) { if ( isToken ( current ) ) { 
function findTokenOnLeftOfPosition ( file , position ) { 
function findRightmostChildNodeWithTokens ( children , exclusiveStartPosition ) { for ( var i = exclusiveStartPosition - 1 ; i >= 0 ; -- i ) { if ( nodeHasTokens ( children [ i ] ) ) { return children [ i ] ; } } } 
function getJsDocTagAtPosition ( sourceFile , position ) { var node = ts . getTokenAtPosition ( sourceFile , position ) ; if ( isToken ( node ) ) { switch ( node . kind ) { case 102 : case 108 : case 74 : 
function stripQuotes ( name ) { var length = name . length ; if ( length >= 2 && name . charCodeAt ( 0 ) === name . charCodeAt ( length - 1 ) && ( name . charCodeAt ( 0 ) === 34 || name . charCodeAt ( 0 ) === 39 ) ) { return name . substring ( 1 , length - 1 ) ; } ; return name ; } 
function fixTokenKind ( tokenInfo , container ) { if ( ts . isToken ( container ) && tokenInfo . token . kind !== container . kind ) { tokenInfo . token . kind = container . kind ; } return tokenInfo ; } 
function isListElement ( parent , node ) { switch ( parent . kind ) { case 214 : case 215 : return ts . rangeContainsRange ( parent . members , node ) ; case 218 : var body = parent . body ; return body && body . kind === 192 && ts . rangeContainsRange ( body . statements , node ) ; case 248 : case 192 : case 219 : return ts . rangeContainsRange ( parent . statements , node ) ; case 244 : return ts . rangeContainsRange ( parent . block . statements , node ) ; } return false ; } 
function findEnclosingNode ( range , sourceFile ) { return find ( sourceFile ) ; function find ( n ) { var candidate = ts . forEachChild ( n , function ( c ) { return ts . startEndContainsRange ( c . getStart ( sourceFile ) , c . end , range ) && c ; } ) ; if ( candidate ) { var result = find ( candidate ) ; if ( result ) { return result ; } } return n ; } } 
function prepareRangeContainsErrorFunction ( errors , originalRange ) { if ( ! errors . length ) { return rangeHasNoErrors ; } 
function getOwnOrInheritedDelta ( n , options , sourceFile ) { var previousLine = - 1 ; var childKind = 0 ; while ( n ) { var line = sourceFile . getLineAndCharacterOfPosition ( n . getStart ( sourceFile ) ) . line ; if ( previousLine !== - 1 && line !== previousLine ) { break ; } if ( formatting . SmartIndenter . shouldIndentChildNode ( n . kind , childKind ) ) { return options . IndentSize ; } previousLine = line ; childKind = n . kind ; n = n . parent ; } return 0 ; } 
function getActualIndentationForListItemBeforeComma ( commaToken , sourceFile , options ) { 
function getActualIndentationForNode ( current , parent , currentLineAndChar , parentAndChildShareLine , sourceFile , options ) { 
function findFirstNonWhitespaceCharacterAndColumn ( startPos , endPos , sourceFile , options ) { var character = 0 ; var column = 0 ; for ( var pos = startPos ; pos < endPos ; ++ pos ) { var ch = sourceFile . text . charCodeAt ( pos ) ; if ( ! ts . isWhiteSpace ( ch ) ) { break ; } if ( ch === 9 ) { column += options . TabSize + ( column % options . TabSize ) ; } else { column ++ ; } character ++ ; } return { column : column , character : character } ; } 
function transpileModule ( input , transpileOptions ) { var options = transpileOptions . compilerOptions ? ts . clone ( transpileOptions . compilerOptions ) : getDefaultCompilerOptions ( ) ; options . isolatedModules = true ; 
function transpile ( input , compilerOptions , fileName , diagnostics , moduleName ) { var output = transpileModule ( input , { compilerOptions : compilerOptions , fileName : fileName , reportDiagnostics : ! ! diagnostics , moduleName : moduleName } ) ; 
function getTargetLabel ( referenceNode , labelName ) { while ( referenceNode ) { if ( referenceNode . kind === 207 && referenceNode . label . text === labelName ) { return referenceNode . label ; } referenceNode = referenceNode . parent ; } return undefined ; } 
function isNameOfPropertyAssignment ( node ) { return ( node . kind === 69 || node . kind === 9 || node . kind === 8 ) && ( node . parent . kind === 245 || node . parent . kind === 246 ) && node . parent . name === node ; } 
function isInsideComment ( sourceFile , token , position ) { 
function getSemanticDiagnostics ( fileName ) { synchronizeHostData ( ) ; var targetSourceFile = getValidSourceFile ( fileName ) ; 
function getCompletionEntryDisplayName ( name , target , performCharacterChecks ) { if ( ! name ) { return undefined ; } name = ts . stripQuotes ( name ) ; if ( ! name ) { return undefined ; } 
function getScopeNode ( initialToken , position , sourceFile ) { var scope = initialToken ; while ( scope && ! ts . positionBelongsToNode ( scope , position , sourceFile ) ) { scope = scope . parent ; } return scope ; } 
function tryGetObjectLikeCompletionSymbols ( objectLikeContainer ) { 
function tryGetImportOrExportClauseCompletionSymbols ( namedImportsOrExports ) { var declarationKind = namedImportsOrExports . kind === 225 ? 222 : 228 ; var importOrExportDeclaration = ts . getAncestor ( namedImportsOrExports , declarationKind ) ; var moduleSpecifier = importOrExportDeclaration . moduleSpecifier ; if ( ! moduleSpecifier ) { return false ; } isMemberCompletion = true ; isNewIdentifierLocation = false ; var exports ; var moduleSpecifierSymbol = typeChecker . getSymbolAtLocation ( importOrExportDeclaration . moduleSpecifier ) ; if ( moduleSpecifierSymbol ) { exports = typeChecker . getExportsOfModule ( moduleSpecifierSymbol ) ; } symbols = exports ? filterNamedImportOrExportCompletionItems ( exports , namedImportsOrExports . elements ) : emptyArray ; return true ; } 
function tryGetObjectLikeCompletionContainer ( contextToken ) { if ( contextToken ) { switch ( contextToken . kind ) { case 15 : 
function filterNamedImportOrExportCompletionItems ( exportsOfModule , namedImportsOrExports ) { var exisingImportsOrExports = { } ; for ( var _i = 0 ; _i < namedImportsOrExports . length ; _i ++ ) { var element = namedImportsOrExports [ _i ] ; 
function filterObjectMembersList ( contextualMemberSymbols , existingMembers ) { if ( ! existingMembers || existingMembers . length === 0 ) { return contextualMemberSymbols ; } var existingMemberNames = { } ; for ( var _i = 0 ; _i < existingMembers . length ; _i ++ ) { var m = existingMembers [ _i ] ; 
function filterJsxAttributes ( symbols , attributes ) { var seenNames = { } ; for ( var _i = 0 ; _i < attributes . length ; _i ++ ) { var attr = attributes [ _i ] ; 
function getSymbolKind ( symbol , location ) { var flags = symbol . getFlags ( ) ; if ( flags & 32 ) return ts . getDeclarationOfKind ( symbol , 186 ) ? ScriptElementKind . localClassElement : ScriptElementKind . classElement ; if ( flags & 384 ) return ScriptElementKind . enumElement ; if ( flags & 524288 ) return ScriptElementKind . typeElement ; if ( flags & 64 ) return ScriptElementKind . interfaceElement ; if ( flags & 262144 ) return ScriptElementKind . typeParameterElement ; var result = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar ( symbol , flags , location ) ; if ( result === ScriptElementKind . unknown ) { if ( flags & 262144 ) return ScriptElementKind . typeParameterElement ; if ( flags & 8 ) return ScriptElementKind . variableElement ; if ( flags & 8388608 ) return ScriptElementKind . alias ; if ( flags & 1536 ) return ScriptElementKind . moduleElement ; } return result ; } 
function getDefinitionAtPosition ( fileName , position ) { synchronizeHostData ( ) ; var sourceFile = getValidSourceFile ( fileName ) ; var node = ts . getTouchingPropertyName ( sourceFile , position ) ; if ( ! node ) { return undefined ; } 
function aggregateOwnedThrowStatements ( node ) { var statementAccumulator = [ ] ; aggregate ( node ) ; return statementAccumulator ; function aggregate ( node ) { if ( node . kind === 208 ) { statementAccumulator . push ( node ) ; } else if ( node . kind === 209 ) { var tryStatement = node ; if ( tryStatement . catchClause ) { aggregate ( tryStatement . catchClause ) ; } else { 
function getThrowStatementOwner ( throwStatement ) { var child = throwStatement ; while ( child . parent ) { var parent_12 = child . parent ; if ( ts . isFunctionBlock ( parent_12 ) || parent_12 . kind === 248 ) { return parent_12 ; } 
function getReferencesInNode ( container , searchSymbol , searchText , searchLocation , searchMeaning , findInStrings , findInComments , result , symbolToIndex ) { var sourceFile = container . getSourceFile ( ) ; var tripleSlashDirectivePrefixRegex = / ^\/\/\/\s*< / ; var possiblePositions = getPossibleSymbolReferencePositions ( sourceFile , searchText , container . getStart ( ) , container . getEnd ( ) ) ; if ( possiblePositions . length ) { 
function getIntersectingMeaningFromDeclarations ( meaning , declarations ) { if ( declarations ) { var lastIterationMeaning ; do { 
function isWriteAccess ( node ) { if ( node . kind === 69 && ts . isDeclarationName ( node ) ) { return true ; } var parent = node . parent ; if ( parent ) { if ( parent . kind === 180 || parent . kind === 179 ) { return true ; } else if ( parent . kind === 181 && parent . left === node ) { var operator = parent . operatorToken . kind ; return 56 <= operator && operator <= 68 ; } } return false ; } 
function getNavigateToItems ( searchValue , maxResultCount ) { synchronizeHostData ( ) ; return ts . NavigateTo . getNavigateToItems ( program , cancellationToken , searchValue , maxResultCount ) ; } 
function getSignatureHelpItems ( fileName , position ) { synchronizeHostData ( ) ; var sourceFile = getValidSourceFile ( fileName ) ; return ts . SignatureHelp . getSignatureHelpItems ( program , sourceFile , position , cancellationToken ) ; } 
function hasValueSideModule ( symbol ) { return ts . forEach ( symbol . declarations , function ( declaration ) { return declaration . kind === 218 && ts . getModuleInstanceState ( declaration ) === 1 ; } ) ; } 
function classifyTokenType ( tokenKind , token ) { if ( ts . isKeyword ( tokenKind ) ) { return 3 ; } 
function getParametersFromRightHandSideOfAssignment ( rightHandSide ) { while ( rightHandSide . kind === 172 ) { rightHandSide = rightHandSide . expression ; } switch ( rightHandSide . kind ) { case 173 : case 174 : return rightHandSide . parameters ; case 186 : for ( var _i = 0 , _a = rightHandSide . members ; _i < _a . length ; _i ++ ) { var member = _a [ _i ] ; if ( member . kind === 144 ) { return member . parameters ; } } break ; } return emptyArray ; } 
function getDefaultLibFilePath ( options ) { 
function spanInOpenBraceToken ( node ) { switch ( node . parent . kind ) { case 217 : var enumDeclaration = node . parent ; return spanInNodeIfStartsOnSameLine ( ts . findPrecedingToken ( node . pos , sourceFile , node . parent ) , enumDeclaration . members . length ? enumDeclaration . members [ 0 ] : enumDeclaration . getLastToken ( sourceFile ) ) ; case 214 : var classDeclaration = node . parent ; return spanInNodeIfStartsOnSameLine ( ts . findPrecedingToken ( node . pos , sourceFile , node . parent ) , classDeclaration . members . length ? classDeclaration . members [ 0 ] : classDeclaration . getLastToken ( sourceFile ) ) ; case 220 : return spanInNodeIfStartsOnSameLine ( node . parent . parent , node . parent . clauses [ 0 ] ) ; } 
async function serveGUI ( url ) { let res , fileType ; const headerContentTypes = { 'html' : 'text/html' , 'js' : 'application/javascript' , 'css' : 'text/css' } const pathname = ( url . pathname === '/' ) ? '/index.html' : url . pathname ; res = await fetch ( 'file://build' + pathname ) ; fileType = pathname . split ( '.' ) . pop ( ) ; if ( res . status === 200 && Object . keys ( headerContentTypes ) . includes ( fileType ) ) { let fileText = await res . text ( ) ; return { data : fileText , status : 200 , contentType : headerContentTypes [ fileType ] } ; } return { data : "<p>Not found.</p>" , status : 404 , contentType : "text/html" } ; } 
async function getGitHubData ( req , url ) { let cacheKey = "" , queryString = "" ; let reqString = await req . text ( ) ; const client = new GraphQLClient ( 'https://api.github.com/graphql' , { headers : { 'User-Agent' : req . headers . get ( 'User-Agent' ) || app . config . userAgent , 'Authorization' : req . headers . get ( 'Authorization' ) || 'Bearer ' + app . config . userToken } } ) ; 
function addRequiredQueryFields ( query ) { let stringCondensed = query . replace ( / \s+ / g , " " ) ; let starti = stringCondensed . indexOf ( 'node {' ) + 6 ; let endi = stringCondensed . indexOf ( '}' , starti ) ; let currentParams = ( stringCondensed . substring ( starti , endi ) ) . split ( " " ) ; const requiredParams = [ "id" , "number" , "title" , "bodyText" ] ; requiredParams . forEach ( function ( p ) { if ( ! currentParams . includes ( p ) ) { currentParams . push ( p ) } } ) ; currentParams = currentParams . join ( " " ) ; return stringCondensed . substr ( 0 , starti ) + currentParams + stringCondensed . substr ( endi ) ; } 
async function getIssues ( query , client , cacheKey ) { let data , dataString , dataJson , status , cachedResponse = null ; if ( cacheKey ) { cachedResponse = await cache . getString ( cacheKey ) ; } if ( cachedResponse !== null ) { status = 200 ; dataString = cachedResponse ; return { dataString , status } ; } else { 
function getSentiment ( response ) { const issuesToEvaluate = response . repository . issues . edges ; for ( let i = issuesToEvaluate . length - 1 ; i >= 0 ; i -- ) { let sent = polarity ( ( issuesToEvaluate [ i ] . node . title + " " + issuesToEvaluate [ i ] . node . bodyText ) . split ( " " ) ) ; issuesToEvaluate [ i ] . node . sentiment = sent ; } ; return response ; } 
function balancer ( backends ) { const tracked = backends . map ( ( h ) => { if ( typeof h !== "function" ) { throw Error ( "Backend must be a fetch like function" ) ; } return { proxy : h , requestCount : 0 , scoredRequestCount : 0 , statuses : Array ( 10 ) , lastError : 0 , healthScore : 1 , errorCount : 0 } ; } ) ; const fn = async function fetchBalancer ( req , init ) { if ( typeof req === "string" ) { req = new Request ( req ) ; } const attempted = new Set ( ) ; while ( attempted . size < tracked . length ) { let backend = null ; const [ backendA , backendB ] = chooseBackends ( tracked , attempted ) ; if ( ! backendA ) { return new Response ( "No backend available" , { status : 502 } ) ; } if ( ! backendB ) { backend = backendA ; } else { 
function score ( backend , errorBasis ) { if ( typeof errorBasis !== "number" && ! errorBasis ) errorBasis = Date . now ( ) ; const timeSinceError = ( errorBasis - backend . lastError ) ; const statuses = backend . statuses ; const timeWeight = ( backend . lastError === 0 && 0 ) || ( ( timeSinceError < 1000 ) && 1 ) || ( ( timeSinceError < 3000 ) && 0.8 ) || ( ( timeSinceError < 5000 ) && 0.3 ) || ( ( timeSinceError < 10000 ) && 0.1 ) || 0 ; if ( statuses . length == 0 ) return 0 ; let requests = 0 ; let errors = 0 ; for ( let i = 0 ; i < statuses . length ; i ++ ) { const status = statuses [ i ] ; if ( status && ! isNaN ( status ) ) { requests += 1 ; if ( status >= 500 && status < 600 ) { errors += 1 ; } } } const score = ( 1 - ( timeWeight * ( errors / requests ) ) ) ; backend . healthScore = score ; backend . scoredRequestCount = backend . requestCount ; return score ; } 
async function origin ( req , init ) { const url = new URL ( req . url ) const status = parseInt ( url . searchParams . get ( 'status' ) || '200' ) if ( status === 200 ) { return new Response ( ` ${ req . url } ${ new Date ( ) } ` ) } else { return new Response ( ` ${ status } ` , { status : status } ) } } 
async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case "/" : return new Response ( ` ${ new Date ( ) } ` , { headers : { "Cache-Control" : "max-age=600" } } ) case "/never-cache" : return new Response ( ` ${ new Date ( ) } ` ) } return new Response ( "not found" , { status : 404 } ) } 
function ( dest , src ) { return gulp . src ( src ) . pipe ( sourcemaps . init ( ) ) . pipe ( concat ( dest ) ) . pipe ( gulp . dest ( path . join ( 'dist' , 'js' ) ) ) . pipe ( uglify ( ) ) . pipe ( rename ( { suffix : '.min' } ) ) . pipe ( sourcemaps . write ( '.' ) ) . pipe ( gulp . dest ( path . join ( 'dist' , 'js' ) ) ) ; } 
function ( element , transform , touch ) { 
function ( scope , id , options ) { options = options || { } ; var isNewScope = scopes [ scope ] === undefined ; var defaultValue = options . defaultValue ; var exclusionGroup = options . exclusionGroup ; scopes [ scope . $id ] = scopes [ scope . $id ] || [ ] ; scopes [ scope . $id ] . push ( id ) ; if ( ! statusesMeta [ id ] ) { 
function ( id , value ) { if ( statusesMeta [ id ] !== undefined ) { var prev = values [ id ] ; values [ id ] = value ; if ( prev !== value ) { $rootScope . $broadcast ( 'mobile-angular-ui.state.changed.' + id , value , prev ) ; } return value ; } $log . warn ( 'Warning: Attempt to set uninitialized shared state: ' + id ) ; } 
function ( idOrMap , value ) { if ( ! idOrMap ) { return ; } else if ( angular . isObject ( idOrMap ) ) { this . setMany ( idOrMap ) ; } else { this . setOne ( idOrMap , value ) ; } } 
function ( id ) { 
function ( elem , attrs ) { var attr = attrs [ directiveName ] ; var needsInterpolation = attr . match ( / \{\{ / ) ; var exprFn = function ( $scope ) { var res = attr ; if ( needsInterpolation ) { var interpolateFn = $interpolate ( res ) ; res = interpolateFn ( $scope ) ; } if ( methodName === 'set' ) { res = ( $parse ( res ) ) ( $scope ) ; } return res ; } ; return function ( scope , elem , attrs ) { var callback = function ( ) { var arg = exprFn ( scope ) ; return method . call ( SharedState , arg ) ; } ; uiBindEvent ( scope , elem , attrs . uiTriggers , callback ) ; } ; } 
function ( attr ) { if ( ! attr || attr === '' ) { return [ ] ; } var vars = attr ? attr . trim ( ) . split ( / *, * / ) : [ ] ; var res = [ ] ; for ( var i = 0 ; i < vars . length ; i ++ ) { var item = vars [ i ] . split ( / *as * / ) ; if ( item . length > 2 || item . length < 1 ) { throw new Error ( 'Error parsing uiScopeContext="' + attr + '"' ) ; } res . push ( item ) ; } return res ; } 
function ( val ) { inputs = elem . querySelectorAll ( "textarea, input" ) ; for ( var i = 0 , il = inputs . length ; i < il ; i ++ ) { inputs [ i ] . style . pointerEvents = val ; } } 
function ( startEvent , ascend ) { if ( doc . createEvent ) { var newTarget = ( ! ascend || ascend === undefined ) && elem . parentNode || elem . touchchild || elem , tEnd ; if ( newTarget !== elem ) { tEnd = doc . createEvent ( "HTMLEvents" ) ; tEnd . initEvent ( "touchend" , true , true ) ; elem . dispatchEvent ( tEnd ) ; newTarget . touchchild = elem ; elem = newTarget ; newTarget . dispatchEvent ( startEvent ) ; } } } 
function ( e ) { 
function ( $element , dragOptions , touchOptions ) { $element = angular . element ( $element ) ; dragOptions = dragOptions || { } ; touchOptions = touchOptions || { } ; var startEventHandler = dragOptions . start ; var endEventHandler = dragOptions . end ; var moveEventHandler = dragOptions . move ; var cancelEventHandler = dragOptions . cancel ; var transformEventHandler = dragOptions . transform || this . TRANSLATE_BOTH ; var domElement = $element [ 0 ] ; var tO = $transform . get ( $element ) ; 
function ( t ) { var absAngle = abs ( t . angle ) ; absAngle = absAngle >= 90 ? absAngle - 90 : absAngle ; var validDistance = t . total - t . distance <= TURNAROUND_MAX ; var validAngle = absAngle <= ANGLE_THRESHOLD || absAngle >= 90 - ANGLE_THRESHOLD ; var validVelocity = t . averageVelocity >= VELOCITY_THRESHOLD ; return validDistance && validAngle && validVelocity ; } 
function ( element , eventHandlers , options ) { options = angular . extend ( { } , defaultOptions , options || { } ) ; return $touch . bind ( element , eventHandlers , options ) ; } 
function ( type , c , t0 , tl ) { 
function ( event ) { 
function ( e ) { e = e . length ? e [ 0 ] : e ; var tr = window . getComputedStyle ( e , null ) . getPropertyValue ( transformProperty ) ; return tr ; } 
function ( elem , value ) { elem = elem . length ? elem [ 0 ] : elem ; elem . style [ styleProperty ] = value ; } 
function ( e , t ) { var str = ( typeof t === 'string' ) ? t : this . toCss ( t ) ; setElementTransformProperty ( e , str ) ; } 
function ( _path ) { if ( / ^((pre|post)?loader)s? / ig . test ( _path ) ) { return _path . replace ( / ^((pre|post)?loader)s? / ig , 'module.$1s' ) } if ( / ^(plugin)s? / g . test ( _path ) ) { return _path . replace ( / ^(plugin)s? / g , '$1s' ) } return _path } 
function ( extend , cooking , options ) { require ( ` ${ extend } ` ) ( cooking , options ) logger . success ( ` ${ extend } ` ) } 
function getPayload ( token ) { const payloadBase64 = token . split ( "." ) [ 1 ] . replace ( "-" , "+" ) . replace ( "_" , "/" ) ; const payloadDecoded = base64 . decode ( payloadBase64 ) ; const payloadObject = JSON . parse ( payloadDecoded ) ; if ( AV . isNumber ( payloadObject . exp ) ) { payloadObject . exp = new Date ( payloadObject . exp * 1000 ) ; } return payloadObject ; } 
function SDK ( options = { } ) { let token ; let url ; let project = "_" ; let localExp ; let tokenExpiryTime = 5 ; if ( options . storage ) { let storedInfo = options . storage . getItem ( "directus-sdk-js" ) ; if ( storedInfo ) { storedInfo = JSON . parse ( storedInfo ) ; token = storedInfo . token ; url = storedInfo . url ; project = storedInfo . project ; localExp = storedInfo . localExp ; } } if ( options . token ) { token = options . token ; } if ( options . url ) { url = options . url ; } if ( options . project ) { project = options . project ; } if ( options . localExp ) { localExp = options . localExp ; } if ( options . tokenExpiryTime ) { tokenExpiryTime = options . tokenExpiryTime ; } const SDK = { url : url , token : token , project : project , * Directus API request promise * @promise RequestPromise * @fulfill {object} Directus data * @reject {Error} Network error (if no connection to API) * @reject {Error} Directus error (eg not logged in or 404) */ request ( method , endpoint , params = { } , data = { } , noEnv = false , headers = { } , ignoreJson = false ) { AV . string ( method , "method" ) ; AV . string ( endpoint , "endpoint" ) ; AV . objectOrEmpty ( params , "params" ) ; Array . isArray ( data ) ? AV . arrayOrEmpty ( data , "data" ) : AV . objectOrEmpty ( data , "data" ) ; AV . string ( this . url , "this.url" ) ; let baseURL = ` ${ this . url } ` ; if ( noEnv === false ) { baseURL += ` ${ this . project } ` ; } const requestOptions = { url : endpoint , method , baseURL , params , data } ; if ( this . token && typeof this . token === "string" && this . token . length > 0 ) { requestOptions . headers = headers ; requestOptions . headers . Authorization = ` ${ this . token } ` ; } return this . axios . request ( requestOptions ) . then ( res => res . data ) . then ( data => { if ( ! data || data . length === 0 ) return data ; if ( ignoreJson ) return data ; if ( typeof data !== "object" ) { try { return JSON . parse ( data ) ; } catch ( error ) { throw { json : true , error , data } ; } } return data ; } ) . catch ( error => { if ( error . response ) { throw error . response . data . error ; } else if ( error . json === true ) { throw { * GET convenience method. Calls the request method for you * @param {string} endpoint The endpoint to get * @param {Object} [params={}] The HTTP query parameters (GET only) * @return {RequestPromise} */ get ( endpoint , params = { } ) { AV . string ( endpoint , "endpoint" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . request ( "get" , endpoint , params ) ; } , post ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint" ) ; Array . isArray ( body ) ? AV . arrayOrEmpty ( body , "body" ) : AV . objectOrEmpty ( body , "body" ) ; return this . request ( "post" , endpoint , params , body ) ; } , patch ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint" ) ; Array . isArray ( body ) ? AV . arrayOrEmpty ( body , "body" ) : AV . objectOrEmpty ( body , "body" ) ; return this . request ( "patch" , endpoint , params , body ) ; } , put ( endpoint , body = { } , params = { } ) { AV . string ( endpoint , "endpoint" ) ; Array . isArray ( body ) ? AV . arrayOrEmpty ( body , "body" ) : AV . objectOrEmpty ( body , "body" ) ; return this . request ( "put" , endpoint , params , body ) ; } , delete ( endpoint ) { AV . string ( endpoint , "endpoint" ) ; return this . request ( "delete" , endpoint ) ; } , * Logging in promise * @promise LoginPromise * @fulfill {Object} Object containing URL, ENV, and TOKEN * @reject {Error} Network error (if no connection to API) * @reject {Error} Directus error (eg not logged in or 404) */ login ( credentials , options = { persist : true } ) { AV . object ( credentials , "credentials" ) ; AV . keysWithString ( credentials , [ "email" , "password" ] , "credentials" ) ; this . token = null ; if ( AV . hasKeysWithString ( credentials , [ "url" ] ) ) { this . url = credentials . url ; } if ( AV . hasKeysWithString ( credentials , [ "project" ] ) ) { this . project = credentials . project ; } if ( credentials . persist || options . persist ) { this . startInterval ( ) ; } return new Promise ( ( resolve , reject ) => { this . post ( "/auth/authenticate" , { email : credentials . email , password : credentials . password } ) . then ( res => res . data . token ) . then ( token => { this . token = token ; * Logs the user out by "forgetting" the token, and clearing the refresh interval */ logout ( ) { this . token = null ; if ( this . refreshInterval ) { this . stopInterval ( ) ; } if ( this . storage ) { this . storage . removeItem ( "directus-sdk-js" ) ; } } , reset ( ) { this . logout ( ) ; this . url = null ; this . project = null ; } , startInterval ( fireImmediately ) { if ( fireImmediately ) this . refreshIfNeeded ( ) ; this . refreshInterval = setInterval ( this . refreshIfNeeded . bind ( this ) , 10000 ) ; } , stopInterval ( ) { clearInterval ( this . refreshInterval ) ; this . refreshInterval = null ; } , refreshIfNeeded ( ) { if ( ! AV . hasStringKeys ( this , [ "token" , "url" , "project" ] ) ) return ; if ( ! this . payload || ! this . payload . exp ) return ; const timeDiff = this . localExp - Date . now ( ) ; if ( timeDiff <= 0 ) { if ( AV . isFunction ( this . onAutoRefreshError ) ) { this . onAutoRefreshError ( { message : "auth_expired_token" , code : 102 } ) ; } return ; } if ( timeDiff < 30000 ) { this . refresh ( this . token ) . then ( res => { this . token = res . data . token ; this . localExp = new Date ( Date . now ( ) + this . tokenExpiryTime * 60000 ) . getTime ( ) ; if ( AV . isFunction ( this . onAutoRefreshSuccess ) ) { this . onAutoRefreshSuccess ( { url : this . url , project : this . project , token : this . token , localExp : this . localExp } ) ; } if ( this . storage ) { this . storage . setItem ( "directus-sdk-js" , JSON . stringify ( { token : this . token , url : this . url , project : this . project , localExp : this . localExp } ) ) ; } } ) . catch ( error => { if ( AV . isFunction ( this . onAutoRefreshError ) ) { this . onAutoRefreshError ( error ) ; } } ) ; } } , refresh ( token ) { AV . string ( token , "token" ) ; return this . post ( "/auth/refresh" , { token } ) ; } , requestPasswordReset ( email ) { AV . string ( email , "email" ) ; return this . post ( "/auth/password/request" , { email : email } ) ; } , * Get activity * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getActivity ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/activity" , params ) ; } , * Get the bookmarks of the current user * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getMyBookmarks ( params = { } ) { AV . string ( this . token , "this.token" ) ; AV . objectOrEmpty ( params ) ; return Promise . all ( [ this . get ( "/collection_presets" , { "filter[title][nnull]" : 1 , "filter[user][eq]" : this . payload . id } ) , this . get ( "/collection_presets" , { "filter[title][nnull]" : 1 , "filter[role][eq]" : this . payload . role , "filter[user][null]" : 1 } ) ] ) . then ( values => { const [ user , role ] = values ; * Get all available collections * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getCollections ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/collections" , params ) ; } , getCollection ( collection , params = { } ) { AV . string ( collection , "collection" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . get ( ` ${ collection } ` , params ) ; } , createCollection ( data ) { AV . object ( data , "data" ) ; return this . post ( "/collections" , data ) ; } , updateCollection ( collection , data ) { AV . string ( collection , "collection" ) ; AV . object ( data , "data" ) ; return this . patch ( ` ${ collection } ` , data ) ; } , deleteCollection ( collection ) { AV . string ( collection , "collection" ) ; return this . delete ( ` ${ collection } ` ) ; } , * Create a new collection preset (bookmark / listing preferences) * @param {Object} data The bookmark info * @return {RequestPromise} */ createCollectionPreset ( data ) { AV . object ( data ) ; return this . post ( "/collection_presets" , data ) ; } , updateCollectionPreset ( primaryKey , data ) { AV . notNull ( primaryKey , "primaryKey" ) ; AV . object ( data , "data" ) ; return this . patch ( ` ${ primaryKey } ` , data ) ; } , deleteCollectionPreset ( primaryKey ) { AV . notNull ( primaryKey , "primaryKey" ) ; return this . delete ( ` ${ primaryKey } ` ) ; } , * This will update the database of the API instance to the latest version * using the migrations in the API * @return {RequestPromise} */ updateDatabase ( ) { return this . post ( "/update" ) ; } , * Get the meta information of all installed interfaces * @return {RequestPromise} */ getInterfaces ( ) { return this . request ( "get" , "/interfaces" , { } , { } , true ) ; } , getLayouts ( ) { return this . request ( "get" , "/layouts" , { } , { } , true ) ; } , getPages ( ) { return this . request ( "get" , "/pages" , { } , { } , true ) ; } , * Get all fields that are in Directus * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getAllFields ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/fields" , params ) ; } , getFields ( collection , params = { } ) { AV . string ( collection , "collection" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . get ( ` ${ collection } ` , params ) ; } , getField ( collection , fieldName , params = { } ) { AV . string ( collection , "collection" ) ; AV . string ( fieldName , "fieldName" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . get ( ` ${ collection } ${ fieldName } ` , params ) ; } , createField ( collection , fieldInfo ) { AV . string ( collection , "collection" ) ; AV . object ( fieldInfo , "fieldInfo" ) ; return this . post ( ` ${ collection } ` , fieldInfo ) ; } , updateField ( collection , fieldName , fieldInfo ) { AV . string ( collection , "collection" ) ; AV . string ( fieldName , "fieldName" ) ; AV . object ( fieldInfo , "fieldInfo" ) ; return this . patch ( ` ${ collection } ${ fieldName } ` , fieldInfo ) ; } , updateFields ( collection , fieldsInfoOrFieldNames , fieldInfo = null ) { AV . string ( collection , "collection" ) ; AV . array ( fieldsInfoOrFieldNames , "fieldsInfoOrFieldNames" ) ; if ( fieldInfo ) { AV . object ( fieldInfo ) ; } if ( fieldInfo ) { return this . patch ( ` ${ collection } ${ fieldsInfoOrFieldNames . join ( "," ) } ` , fieldInfo ) ; } return this . patch ( ` ${ collection } ` , fieldsInfoOrFieldNames ) ; } , deleteField ( collection , fieldName ) { AV . string ( collection , "collection" ) ; AV . string ( fieldName , "fieldName" ) ; return this . delete ( ` ${ collection } ${ fieldName } ` ) ; } , * Upload multipart files in multipart/form-data * @param {Object} data FormData object containing files * @return {RequestPromise} */ uploadFiles ( data , onUploadProgress = ( ) => { } ) { const headers = { "Content-Type" : "multipart/form-data" , Authorization : ` ${ this . token } ` } ; return this . axios . post ( ` ${ this . url } ${ this . project } ` , data , { headers , onUploadProgress } ) . then ( res => res . data ) . catch ( error => { if ( error . response ) { throw error . response . data . error ; } else { throw { * Update an existing item * @param {String} collection The collection to add the item to * @param {String|Number} primaryKey Primary key of the item * @param {Object} body The item's field values * @param {Object} params Query parameters * @return {RequestPromise} */ updateItem ( collection , primaryKey , body , params = { } ) { AV . string ( collection , "collection" ) ; AV . notNull ( primaryKey , "primaryKey" ) ; AV . object ( body , "body" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . patch ( ` ${ collection . substring ( 9 ) } ${ primaryKey } ` , body , params ) ; } return this . patch ( ` ${ collection } ${ primaryKey } ` , body , params ) ; } , /** * Update multiple items * @param {String} collection The collection to add the item to * @param {Array} body The item's field values * @param {Object} params Query Parameters * @return {RequestPromise} */ updateItems ( collection , body , params = { } ) { AV . string ( collection , "collection" ) ; AV . array ( body , "body" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . patch ( ` ${ collection . substring ( 9 ) } ` , body , params ) ; } return this . patch ( ` ${ collection } ` , body , params ) ; } , createItem ( collection , body ) { AV . string ( collection , "collection" ) ; AV . object ( body , "body" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . post ( ` ${ collection . substring ( 9 ) } ` , body ) ; } return this . post ( ` ${ collection } ` , body ) ; } , createItems ( collection , body ) { AV . string ( collection , "collection" ) ; AV . array ( body , "body" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . post ( ` ${ collection . substring ( 9 ) } ` , body ) ; } return this . post ( ` ${ collection } ` , body ) ; } , getItems ( collection , params = { } ) { AV . string ( collection , "collection" ) ; AV . objectOrEmpty ( params , "params" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . get ( ` ${ collection . substring ( 9 ) } ` , params ) ; } return this . get ( ` ${ collection } ` , params ) ; } , getItem ( collection , primaryKey , params = { } ) { AV . string ( collection , "collection" ) ; AV . notNull ( primaryKey , "primaryKey" ) ; AV . objectOrEmpty ( params , "params" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . get ( ` ${ collection . substring ( 9 ) } ${ primaryKey } ` , params ) ; } return this . get ( ` ${ collection } ${ primaryKey } ` , params ) ; } , deleteItem ( collection , primaryKey ) { AV . string ( collection , "collection" ) ; AV . notNull ( primaryKey , "primaryKey" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . delete ( ` ${ collection . substring ( 9 ) } ${ primaryKey } ` ) ; } return this . delete ( ` ${ collection } ${ primaryKey } ` ) ; } , deleteItems ( collection , primaryKeys ) { AV . string ( collection , "collection" ) ; AV . array ( primaryKeys , "primaryKeys" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . delete ( ` ${ collection . substring ( 9 ) } ${ primaryKeys . join ( ) } ` ) ; } return this . delete ( ` ${ collection } ${ primaryKeys . join ( ) } ` ) ; } , * Get the collection presets of the current user for a single collection * @param {String} collection Collection to fetch the preferences for * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getMyListingPreferences ( collection , params = { } ) { AV . string ( this . token , "this.token" ) ; AV . objectOrEmpty ( params , "params" ) ; return Promise . all ( [ this . get ( "/collection_presets" , { limit : 1 , "filter[title][null]" : 1 , "filter[collection][eq]" : collection , "filter[role][null]" : 1 , "filter[user][null]" : 1 , sort : "-id" } ) , this . get ( "/collection_presets" , { limit : 1 , "filter[title][null]" : 1 , "filter[collection][eq]" : collection , "filter[role][eq]" : this . payload . role , "filter[user][null]" : 1 , sort : "-id" } ) , this . get ( "/collection_presets" , { limit : 1 , "filter[title][null]" : 1 , "filter[collection][eq]" : collection , "filter[role][eq]" : this . payload . role , "filter[user][eq]" : this . payload . id , sort : "-id" } ) ] ) . then ( values => { const [ collection , role , user ] = values ; * Get permissions * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getPermissions ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . getItems ( "directus_permissions" , params ) ; } , getMyPermissions ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/permissions/me" , params ) ; } , createPermissions ( data ) { AV . array ( data ) ; return this . post ( "/permissions" , data ) ; } , updatePermissions ( data ) { AV . array ( data ) ; return this . patch ( "/permissions" , data ) ; } , * Get all relationships * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getRelations ( params = { } ) { AV . objectOrEmpty ( params ) ; return this . get ( "/relations" , params ) ; } , createRelation ( data ) { return this . post ( "/relations" , data ) ; } , updateRelation ( primaryKey , data ) { return this . patch ( ` ${ primaryKey } ` , data ) ; } , getCollectionRelations ( collection , params = { } ) { AV . string ( collection , "collection" ) ; AV . objectOrEmpty ( params ) ; return Promise . all ( [ this . get ( "/relations" , { "filter[collection_a][eq]" : collection } ) , this . get ( "/relations" , { "filter[collection_b][eq]" : collection } ) ] ) ; } , * Get a single item's revisions by primary key * @param {String} collection The collection to fetch the revisions from * @param {String|Number} primaryKey Primary key of the item * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getItemRevisions ( collection , primaryKey , params = { } ) { AV . string ( collection , "collection" ) ; AV . notNull ( primaryKey , "primaryKey" ) ; AV . objectOrEmpty ( params , "params" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . get ( ` ${ collection . substring ( 9 ) } ${ primaryKey } ` , params ) ; } return this . get ( ` ${ collection } ${ primaryKey } ` , params ) ; } , /** * revert an item to a previous state * @param {String} collection The collection to fetch the revisions from * @param {String|Number} primaryKey Primary key of the item * @param {Number} revisionID The ID of the revision to revert to * @return {RequestPromise} */ revert ( collection , primaryKey , revisionID ) { AV . string ( collection , "collection" ) ; AV . notNull ( primaryKey , "primaryKey" ) ; AV . number ( revisionID , "revisionID" ) ; if ( collection . startsWith ( "directus_" ) ) { return this . patch ( ` ${ collection . substring ( 9 ) } ${ primaryKey } ${ revisionID } ` ) ; } return this . patch ( ` ${ collection } ${ primaryKey } ${ revisionID } ` ) ; } , // ROLES // ------------------------------------------------------------------------- /** * Get a single user role * @param {Number} primaryKey The id of the user rol to get * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getRole ( primaryKey , params = { } ) { AV . number ( primaryKey , "primaryKey" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . get ( ` ${ primaryKey } ` , params ) ; } , /** * Get the user roles * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getRoles ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/roles" , params ) ; } , /** * Update a user role * @param {Number} primaryKey The ID of the role * @param {Object} body The fields to update * @return {RequestPromise} */ updateRole ( primaryKey , body ) { AV . notNull ( primaryKey , "primaryKey" ) ; AV . object ( body , "body" ) ; return this . updateItem ( "directus_roles" , primaryKey , body ) ; } , /** * Create a new user role * @param {Object} body The role information * @return {RequestPromise} */ createRole ( body ) { AV . object ( body , "body" ) ; return this . createItem ( "directus_roles" , body ) ; } , /** * Delete a user rol by primary key * @param {Number | String} primaryKey Primary key of the user role * @return {RequestPromise} */ deleteRole ( primaryKey ) { AV . notNull ( primaryKey , "primaryKey" ) ; return this . deleteItem ( "directus_roles" , primaryKey ) ; } , // SETTINGS // ------------------------------------------------------------------------- /** * Get Directus' global settings * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getSettings ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/settings" , params ) ; } , getSettingsFields ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/settings/fields" , params ) ; } , * Get a list of available users in Directus * @param {Object} [params={}] Query parameters * @return {RequestPromise} */ getUsers ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/users" , params ) ; } , getUser ( primaryKey , params = { } ) { AV . notNull ( primaryKey , "primaryKey" ) ; AV . objectOrEmpty ( params , "params" ) ; return this . get ( ` ${ primaryKey } ` , params ) ; } , getMe ( params = { } ) { AV . objectOrEmpty ( params , "params" ) ; return this . get ( "/users/me" , params ) ; } , updateUser ( primaryKey , body ) { AV . notNull ( primaryKey , "primaryKey" ) ; AV . object ( body , "body" ) ; return this . updateItem ( "directus_users" , primaryKey , body ) ; } , * Ping the API to check if it exists / is up and running * @return {RequestPromise} */ ping ( ) { return this . request ( "get" , "/server/ping" , { } , { } , true , true ) ; } , serverInfo ( ) { return this . request ( "get" , "/" , { } , { } , true ) ; } , projectInfo ( ) { return this . request ( "get" , "/" ) ; } , getThirdPartyAuthProviders ( ) { return this . get ( "/auth/sso" ) ; } } ; 
function scrollToHash ( hash ) { var $scroller = getScroller ( ) , dest = 0 ; 
function getElementTopPosition ( id ) { 
function setChapterActive ( $chapter , hash ) { 
function getChapterHash ( $chapter ) { var $link = $chapter . children ( 'a' ) , hash = $link . attr ( 'href' ) . split ( '#' ) [ 1 ] ; if ( hash ) hash = '#' + hash ; return ( ! ! hash ) ? hash : '' ; } 
function handleScrolling ( ) { 
function handleLinkClick ( e ) { var $this = $ ( this ) ; var target = $this . attr ( 'target' ) ; if ( isModifiedEvent ( e ) || ! isLeftClickEvent ( e ) || target ) { return ; } e . stopPropagation ( ) ; e . preventDefault ( ) ; var url = $this . attr ( 'href' ) ; if ( url ) handleNavigation ( url , true ) ; } 
function insertAt ( parent , selector , index , element ) { var lastIndex = parent . children ( selector ) . length ; if ( index < 0 ) { index = Math . max ( 0 , lastIndex + 1 + index ) ; } parent . append ( element ) ; if ( index < lastIndex ) { parent . children ( selector ) . eq ( index ) . before ( parent . children ( selector ) . last ( ) ) ; } } 
function createDropdownMenu ( dropdown ) { var $menu = $ ( '<div>' , { 'class' : 'dropdown-menu' , 'html' : '<div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div>' } ) ; if ( typeof dropdown == 'string' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . isArray ( group ) ) return group ; else return [ group ] ; } ) ; 
function createButton ( opts ) { opts = $ . extend ( { 
function removeButton ( id ) { buttons = $ . grep ( buttons , function ( button ) { return button . id != id ; } ) ; updateAllButtons ( ) ; } 
function removeButtons ( ids ) { buttons = $ . grep ( buttons , function ( button ) { return ids . indexOf ( button . id ) == - 1 ; } ) ; updateAllButtons ( ) ; } 
function toggleSidebar ( _state , animation ) { if ( gitbook . state != null && isOpen ( ) == _state ) return ; if ( animation == null ) animation = true ; gitbook . state . $book . toggleClass ( 'without-animation' , ! animation ) ; gitbook . state . $book . toggleClass ( 'with-summary' , _state ) ; gitbook . storage . set ( 'sidebar' , isOpen ( ) ) ; } 
function init ( ) { 
function filterSummary ( paths ) { var $summary = $ ( '.book-summary' ) ; $summary . find ( 'li' ) . each ( function ( ) { var path = $ ( this ) . data ( 'path' ) ; var st = paths == null || paths . indexOf ( path ) !== - 1 ; $ ( this ) . toggle ( st ) ; if ( st ) $ ( this ) . parents ( 'li' ) . show ( ) ; } ) ; } 
function init ( ) { $ ( document ) . on ( 'click' , '.toggle-dropdown' , toggleDropdown ) ; $ ( document ) . on ( 'click' , '.dropdown-menu' , function ( e ) { e . stopPropagation ( ) ; } ) ; $ ( document ) . on ( 'click' , closeDropdown ) ; } 
function init ( ) { 
function hasChanged ( ctx ) { console . log ( 'page has changed' , ctx ) ; 
function setState ( newState ) { 
function addDirective ( type ) { return function ( name , directive ) { if ( typeof name === 'function' ) { directive = name } if ( typeof directive !== 'function' ) { throw new TypeError ( 'Directive must be a function' ) } name = typeof name === 'string' ? name : directive . name if ( ! name ) { throw new TypeError ( 'Directive function must have a name' ) } directive . $name = name Toxy [ type ] [ name ] = directive return Toxy } } 
function outgoingInterceptor ( proxy ) { const responseBody = rocky . middleware . responseBody responseBody . $name = '$outgoingInterceptor$' const interceptor = responseBody ( function ( req , res , next ) { proxy . _outPoisons . run ( req , res , next ) } ) proxy . _outgoingEnabled = true proxy . poison ( interceptor ) } 
function Directive ( directive ) { Rule . call ( this ) this . enabled = true this . directive = directive this . name = directive . $name || directive . name } 
function Toxy ( opts ) { if ( ! ( this instanceof Toxy ) ) return new Toxy ( opts ) opts = Object . assign ( { } , Toxy . defaults , opts ) Proxy . call ( this , opts ) this . routes = [ ] this . _rules = midware ( ) this . _inPoisons = midware ( ) this . _outPoisons = midware ( ) setupMiddleware ( this ) } 
function finalHandler ( route ) { var isFinalHandler = false route . use ( function ( req , res , next ) { if ( ! isFinalHandler ) { isFinalHandler = true useRouteFinalHandler ( route ) } next ( ) } ) } 
function appendRow ( row ) { var that = this ; function exists ( item ) { return that . identifier && item [ that . identifier ] === row [ that . identifier ] ; } if ( ! this . rows . contains ( exists ) ) { this . rows . push ( row ) ; return true ; } return false ; } 
function loadData ( ) { var that = this ; this . element . _bgBusyAria ( true ) . trigger ( "load" + namespace ) ; showLoading . call ( this ) ; function containsPhrase ( row ) { var column , searchPattern = new RegExp ( that . searchPhrase , ( that . options . caseSensitive ) ? "g" : "gi" ) ; for ( var i = 0 ; i < that . columns . length ; i ++ ) { column = that . columns [ i ] ; if ( column . searchable && column . visible && column . converter . to ( row [ column . id ] ) . search ( searchPattern ) > - 1 ) { return true ; } } return false ; } function update ( rows , total ) { that . currentRows = rows ; setTotals . call ( that , total ) ; if ( ! that . options . keepSelection ) { that . selectedRows = [ ] ; } renderRows . call ( that , rows ) ; renderInfos . call ( that ) ; renderPagination . call ( that ) ; that . element . _bgBusyAria ( false ) . trigger ( "loaded" + namespace ) ; } if ( this . options . ajax ) { var request = getRequest . call ( this ) , url = getUrl . call ( this ) ; if ( url == null || typeof url !== "string" || url . length === 0 ) { throw new Error ( "Url setting must be a none empty string or a function that returns one." ) ; } 
function ( element , options ) { this . element = $ ( element ) ; this . origin = this . element . clone ( ) ; this . options = $ . extend ( true , { } , Grid . defaults , this . element . data ( ) , options ) ; 
function getModifiedConfigModuleIndex ( fileStr , snakedEnv , classedEnv ) { 
function ( path ) { const data = fs . readFileSync ( path , 'utf8' ) ; const ast = esprima . parse ( data ) ; 
function ( e ) { if ( e . code === 'EADDRINUSE' ) { logger . error ( 'Error: Port ' + port + ' is already in use.' ) ; logger . error ( 'Try another one, e.g. pouchdb-server -p ' + ( parseInt ( port ) + 1 ) + '\n' ) ; } else { logger . error ( 'Uncaught error: ' + e ) ; logger . error ( e . stack ) ; } } 
function redirectToSkimdb ( req , res ) { var skimUrl = 'http://localhost:' + pouchPort + '/skimdb' ; var get = request . get ( req . originalUrl . replace ( / ^\/_skimdb / , skimUrl ) ) ; get . on ( 'error' , ( err ) => { logger . warn ( "couldn't proxy to skimdb" ) ; logger . warn ( err ) ; } ) ; get . pipe ( res ) ; } 
function Metadata ( options , controlConnection ) { if ( ! options ) { throw new errors . ArgumentError ( 'Options are not defined' ) ; } Object . defineProperty ( this , 'options' , { value : options , enumerable : false , writable : false } ) ; Object . defineProperty ( this , 'controlConnection' , { value : controlConnection , enumerable : false , writable : false } ) ; this . keyspaces = { } ; this . initialized = false ; this . _schemaParser = schemaParserFactory . getByVersion ( options , controlConnection , this . getUdt . bind ( this ) ) ; const self = this ; this . _preparedQueries = new PreparedQueries ( options . maxPrepared , function ( ) { self . log . apply ( self , arguments ) ; } ) ; } 
function checkUdtTypes ( type ) { if ( type . code === types . dataTypes . udt ) { const udtName = type . info . split ( '.' ) ; type . info = { keyspace : udtName [ 0 ] , name : udtName [ 1 ] } ; if ( ! type . info . name ) { if ( ! keyspace ) { throw new TypeError ( 'No keyspace specified for udt: ' + udtName . join ( '.' ) ) ; } 
function PreparedQueries ( maxPrepared , logger ) { this . length = 0 ; this . _maxPrepared = maxPrepared ; this . _mapByKey = { } ; this . _mapById = { } ; this . _logger = logger ; } 
function DriverError ( message ) { Error . call ( this , message ) ; Error . captureStackTrace ( this , this . constructor ) ; this . name = this . constructor . name ; this . info = 'Cassandra Driver Error' ; 
function NoHostAvailableError ( innerErrors , message ) { DriverError . call ( this , message ) ; this . innerErrors = innerErrors ; this . info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.' ; if ( ! message ) { this . message = 'All host(s) tried for query failed.' ; if ( innerErrors ) { const hostList = Object . keys ( innerErrors ) ; if ( hostList . length > 0 ) { const host = hostList [ 0 ] ; this . message += util . format ( ' First host tried, %s: %s. See innerErrors.' , host , innerErrors [ host ] ) ; } } } } 
function OperationTimedOutError ( message , host ) { DriverError . call ( this , message , this . constructor ) ; this . info = 'Represents a client-side error that is raised when the client did not hear back from the server ' + 'within socketOptions.readTimeout' ; this . host = host ; } 
function BusyConnectionError ( address , maxRequestsPerConnection , connectionLength ) { const message = util . format ( 'All connections to host %s are busy, %d requests are in-flight on %s' , address , maxRequestsPerConnection , connectionLength === 1 ? 'a single connection' : 'each connection' ) ; DriverError . call ( this , message , this . constructor ) ; this . info = 'Represents a client-side error indicating that all connections to a certain host have reached ' + 'the maximum amount of in-flight requests supported (pooling.maxRequestsPerConnection)' ; } 
function extend ( baseOptions , userOptions ) { if ( arguments . length === 1 ) { userOptions = arguments [ 0 ] ; baseOptions = { } ; } const options = utils . deepExtend ( baseOptions , defaultOptions ( ) , userOptions ) ; if ( ! util . isArray ( options . contactPoints ) || options . contactPoints . length === 0 ) { throw new TypeError ( 'Contacts points are not defined.' ) ; } for ( let i = 0 ; i < options . contactPoints . length ; i ++ ) { const hostName = options . contactPoints [ i ] ; if ( ! hostName ) { throw new TypeError ( util . format ( 'Contact point %s (%s) is not a valid host name, ' + 'the following values are valid contact points: ipAddress, hostName or ipAddress:port' , i , hostName ) ) ; } } if ( ! options . logEmitter ) { options . logEmitter = function ( ) { } ; } if ( ! options . queryOptions ) { throw new TypeError ( 'queryOptions not defined in options' ) ; } if ( options . requestTracker !== null && ! ( options . requestTracker instanceof tracker . RequestTracker ) ) { throw new TypeError ( 'requestTracker must be an instance of RequestTracker' ) ; } if ( ! ( options . metrics instanceof metrics . ClientMetrics ) ) { throw new TypeError ( 'metrics must be an instance of ClientMetrics' ) ; } validatePoliciesOptions ( options . policies ) ; validateProtocolOptions ( options . protocolOptions ) ; validateSocketOptions ( options . socketOptions ) ; options . encoding = options . encoding || { } ; validateEncodingOptions ( options . encoding ) ; if ( options . profiles && ! util . isArray ( options . profiles ) ) { throw new TypeError ( 'profiles must be an Array of ExecutionProfile instances' ) ; } return options ; } 
function validatePoliciesOptions ( policiesOptions ) { if ( ! policiesOptions ) { throw new TypeError ( 'policies not defined in options' ) ; } if ( ! ( policiesOptions . loadBalancing instanceof policies . loadBalancing . LoadBalancingPolicy ) ) { throw new TypeError ( 'Load balancing policy must be an instance of LoadBalancingPolicy' ) ; } if ( ! ( policiesOptions . reconnection instanceof policies . reconnection . ReconnectionPolicy ) ) { throw new TypeError ( 'Reconnection policy must be an instance of ReconnectionPolicy' ) ; } if ( ! ( policiesOptions . retry instanceof policies . retry . RetryPolicy ) ) { throw new TypeError ( 'Retry policy must be an instance of RetryPolicy' ) ; } if ( ! ( policiesOptions . addressResolution instanceof policies . addressResolution . AddressTranslator ) ) { throw new TypeError ( 'Address resolution policy must be an instance of AddressTranslator' ) ; } if ( policiesOptions . timestampGeneration !== null && ! ( policiesOptions . timestampGeneration instanceof policies . timestampGeneration . TimestampGenerator ) ) { throw new TypeError ( 'Timestamp generation policy must be an instance of TimestampGenerator' ) ; } } 
function validateProtocolOptions ( protocolOptions ) { if ( ! protocolOptions ) { throw new TypeError ( 'protocolOptions not defined in options' ) ; } const version = protocolOptions . maxVersion ; if ( version && ( typeof version !== 'number' || ! types . protocolVersion . isSupported ( version ) ) ) { throw new TypeError ( util . format ( 'protocolOptions.maxVersion provided (%s) is invalid' , version ) ) ; } } 
function validateSocketOptions ( socketOptions ) { if ( ! socketOptions ) { throw new TypeError ( 'socketOptions not defined in options' ) ; } if ( typeof socketOptions . readTimeout !== 'number' ) { throw new TypeError ( 'socketOptions.readTimeout must be a Number' ) ; } if ( typeof socketOptions . coalescingThreshold !== 'number' || socketOptions . coalescingThreshold <= 0 ) { throw new TypeError ( 'socketOptions.coalescingThreshold must be a positive Number' ) ; } } 
function validateEncodingOptions ( encodingOptions ) { if ( encodingOptions . map ) { const mapConstructor = encodingOptions . map ; if ( typeof mapConstructor !== 'function' || typeof mapConstructor . prototype . forEach !== 'function' || typeof mapConstructor . prototype . set !== 'function' ) { throw new TypeError ( 'Map constructor not valid' ) ; } } if ( encodingOptions . set ) { const setConstructor = encodingOptions . set ; if ( typeof setConstructor !== 'function' || typeof setConstructor . prototype . forEach !== 'function' || typeof setConstructor . prototype . add !== 'function' ) { throw new TypeError ( 'Set constructor not valid' ) ; } } if ( ( encodingOptions . useBigIntAsLong || encodingOptions . useBigIntAsVarint ) && typeof BigInt === 'undefined' ) { throw new TypeError ( 'BigInt is not supported by the JavaScript engine' ) ; } } 
function setProtocolDependentDefaults ( options , version ) { let coreConnectionsPerHost = coreConnectionsPerHostV3 ; let maxRequestsPerConnection = maxRequestsPerConnectionV3 ; if ( ! types . protocolVersion . uses2BytesStreamIds ( version ) ) { coreConnectionsPerHost = coreConnectionsPerHostV2 ; maxRequestsPerConnection = maxRequestsPerConnectionV2 ; } options . pooling = utils . deepExtend ( { } , { coreConnectionsPerHost , maxRequestsPerConnection } , options . pooling ) ; } 
function ( name ) { name = name . toLowerCase ( ) ; if ( name . indexOf ( '<' ) > 0 ) { const listMatches = / ^(list|set)<(.+)>$ / . exec ( name ) ; if ( listMatches ) { return { code : this [ listMatches [ 1 ] ] , info : this . getByName ( listMatches [ 2 ] ) } ; } const mapMatches = / ^(map)< *(.+) *, *(.+)>$ / . exec ( name ) ; if ( mapMatches ) { return { code : this [ mapMatches [ 1 ] ] , info : [ this . getByName ( mapMatches [ 2 ] ) , this . getByName ( mapMatches [ 3 ] ) ] } ; } const udtMatches = / ^(udt)<(.+)>$ / . exec ( name ) ; if ( udtMatches ) { 
function timeuuid ( options , buffer , offset ) { let date ; let ticks ; let nodeId ; let clockId ; if ( options ) { if ( typeof options . msecs === 'number' ) { date = new Date ( options . msecs ) ; } if ( options . msecs instanceof Date ) { date = options . msecs ; } if ( util . isArray ( options . node ) ) { nodeId = utils . allocBufferFromArray ( options . node ) ; } if ( typeof options . clockseq === 'number' ) { clockId = utils . allocBufferUnsafe ( 2 ) ; clockId . writeUInt16BE ( options . clockseq , 0 ) ; } if ( typeof options . nsecs === 'number' ) { ticks = options . nsecs ; } } const uuid = new TimeUuid ( date , ticks , nodeId , clockId ) ; if ( buffer instanceof Buffer ) { 
function uuid ( options , buffer , offset ) { let uuid ; if ( options ) { if ( util . isArray ( options . random ) ) { uuid = new Uuid ( utils . allocBufferFromArray ( options . random ) ) ; } } if ( ! uuid ) { uuid = Uuid . random ( ) ; } if ( buffer instanceof Buffer ) { 
function getDataTypeNameByCode ( item ) { if ( ! item || typeof item . code !== 'number' ) { throw new errors . ArgumentError ( 'Invalid signature type definition' ) ; } const typeName = _dataTypesByCode [ item . code ] ; if ( ! typeName ) { throw new errors . ArgumentError ( util . format ( 'Type with code %d not found' , item . code ) ) ; } if ( ! item . info ) { return typeName ; } if ( util . isArray ( item . info ) ) { return ( typeName + '<' + item . info . map ( function ( t ) { return getDataTypeNameByCode ( t ) ; } ) . join ( ', ' ) + '>' ) ; } if ( typeof item . info . code === 'number' ) { return typeName + '<' + getDataTypeNameByCode ( item . info ) + '>' ; } return typeName ; } 
function FrameHeader ( version , flags , streamId , opcode , bodyLength ) { this . version = version ; this . flags = flags ; this . streamId = streamId ; this . opcode = opcode ; this . bodyLength = bodyLength ; } 
function generateTimestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let longMicro = Long . ZERO ; if ( typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000 ) { longMicro = Long . fromInt ( microseconds ) ; } else { if ( _timestampTicks > 999 ) { _timestampTicks = 0 ; } longMicro = Long . fromInt ( _timestampTicks ) ; _timestampTicks ++ ; } return Long . fromNumber ( date . getTime ( ) ) . multiply ( _longOneThousand ) . add ( longMicro ) ; } 
function QueryParserError ( e ) { QueryParserError . super_ . call ( this , e . message , this . constructor ) ; this . internalError = e ; } 
function MutableLong ( b00 , b16 , b32 , b48 ) { 
function Aggregate ( ) { this . name = null ; this . keyspaceName = null ; this . signature = null ; this . argumentTypes = null ; this . stateFunction = null ; this . stateType = null ; this . finalFunction = null ; this . initConditionRaw = null ; this . initCondition = null ; this . returnType = null ; } 
function Host ( address , protocolVersion , options , metadata ) { events . EventEmitter . call ( this ) ; this . address = address ; this . setDownAt = 0 ; this . isUpSince = null ; Object . defineProperty ( this , 'options' , { value : options , enumerable : false , writable : false } ) ; Object . defineProperty ( this , 'pool' , { value : new HostConnectionPool ( this , protocolVersion ) , enumerable : false } ) ; const self = this ; this . pool . on ( 'open' , this . _onNewConnectionOpen . bind ( this ) ) ; this . pool . on ( 'remove' , function onConnectionRemovedFromPool ( ) { self . _checkPoolState ( ) ; } ) ; this . cassandraVersion = null ; this . datacenter = null ; this . rack = null ; this . tokens = null ; this . hostId = null ; 
function HostMap ( ) { events . EventEmitter . call ( this ) ; this . _items = { } ; this . _values = null ; Object . defineProperty ( this , 'length' , { get : function ( ) { return this . values ( ) . length ; } , enumerable : true } ) ; } 
function ConstantSpeculativeExecutionPolicy ( delay , maxSpeculativeExecutions ) { if ( ! ( delay >= 0 ) ) { throw new errors . ArgumentError ( 'delay must be a positive number or zero' ) ; } if ( ! ( maxSpeculativeExecutions > 0 ) ) { throw new errors . ArgumentError ( 'maxSpeculativeExecutions must be a positive number' ) ; } this . _delay = delay ; this . _maxSpeculativeExecutions = maxSpeculativeExecutions ; } 
function MaterializedView ( name ) { DataCollection . call ( this , name ) ; this . tableName = null ; this . whereClause = null ; this . includeAllColumns = false ; } 
function ExecutionProfile ( name , options ) { if ( typeof name !== 'string' ) { throw new TypeError ( 'Execution profile name must be a string' ) ; } options = options || utils . emptyObject ; this . name = name ; this . consistency = options . consistency ; this . loadBalancing = options . loadBalancing ; this . readTimeout = options . readTimeout ; this . retry = options . retry ; this . serialConsistency = options . serialConsistency ; } 
function isValidIPv4Mapped ( buffer ) { 
function DataCollection ( name ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; * Name of the object * @type {String} */ this . name = name ; this . bloomFilterFalsePositiveChance = 0 ; this . caching = null ; this . comment = null ; this . gcGraceSeconds = 0 ; this . compactionClass = null ; this . compactionOptions = null ; this . compression = null ; this . localReadRepairChance = 0 ; this . readRepairChance = 0 ; this . extensions = null ; this . crcCheckChance = null ; this . populateCacheOnFlush = false ; this . defaultTtl = 0 ; this . speculativeRetry = 'NONE' ; this . minIndexInterval = 128 ; this . maxIndexInterval = 2048 ; this . columns = null ; this . columnsByName = null ; this . partitionKeys = [ ] ; this . clusteringKeys = [ ] ; this . clusteringOrder = [ ] ; } 
function Integer ( bits , sign ) { this . bits_ = [ ] ; this . sign_ = sign ; 
function Protocol ( options ) { Transform . call ( this , options ) ; this . header = null ; this . bodyLength = 0 ; this . clearHeaderChunks ( ) ; this . version = 0 ; this . headerSize = 0 ; } 
async function example ( ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; 
function TableMetadata ( name ) { DataCollection . call ( this , name ) ; this . replicateOnWrite = true ; this . memtableFlushPeriod = 0 ; this . indexInterval = null ; this . isCompact = false ; this . indexes = null ; this . cdc = null ; this . virtual = false ; } 
function SchemaParserV1 ( options , cc ) { SchemaParser . call ( this , options , cc ) ; this . selectTable = _selectTableV1 ; this . selectColumns = _selectColumnsV1 ; this . selectUdt = _selectUdtV1 ; this . selectAggregates = _selectAggregatesV1 ; this . selectFunctions = _selectFunctionsV1 ; } 
function SchemaParserV2 ( options , cc , udtResolver ) { SchemaParser . call ( this , options , cc ) ; this . udtResolver = udtResolver ; this . selectTable = _selectTableV2 ; this . selectColumns = _selectColumnsV2 ; this . selectUdt = _selectUdtV2 ; this . selectAggregates = _selectAggregatesV2 ; this . selectFunctions = _selectFunctionsV2 ; this . selectIndexes = _selectIndexesV2 ; } 
function SchemaParserV3 ( options , cc , udtResolver ) { SchemaParserV2 . call ( this , options , cc , udtResolver ) ; this . supportsVirtual = true ; } 
function pruneStaticCompactTableColumns ( tableInfo ) { let i ; let c ; 
function pruneDenseTableColumns ( tableInfo ) { let i = tableInfo . columns . length ; while ( i -- ) { const c = tableInfo . columns [ i ] ; if ( ! c . isStatic && c . type . code === types . dataTypes . custom && c . type . info === 'empty' ) { 
function getByVersion ( options , cc , udtResolver , version , currentInstance ) { let parserConstructor = SchemaParserV1 ; if ( version && version [ 0 ] === 3 ) { parserConstructor = SchemaParserV2 ; } else if ( version && version [ 0 ] >= 4 ) { parserConstructor = SchemaParserV3 ; } if ( ! currentInstance || ! ( currentInstance instanceof parserConstructor ) ) { return new parserConstructor ( options , cc , udtResolver ) ; } return currentInstance ; } 
function Client ( options ) { events . EventEmitter . call ( this ) ; this . options = clientOptions . extend ( { logEmitter : this . emit . bind ( this ) } , options ) ; Object . defineProperty ( this , 'profileManager' , { value : new ProfileManager ( this . options ) } ) ; Object . defineProperty ( this , 'controlConnection' , { value : new ControlConnection ( this . options , this . profileManager ) , writable : true } ) ; * Gets the name of the active keyspace. * @type {String} */ this . keyspace = options . keyspace ; this . metadata = this . controlConnection . metadata ; this . hosts = this . controlConnection . hosts ; this . metrics = this . options . metrics ; } 
function encodeRoutingKey ( fromUser ) { const encoder = self . _getEncoder ( ) ; try { if ( fromUser ) { encoder . setRoutingKeyFromUser ( params , execOptions ) ; } else { encoder . setRoutingKeyFromMeta ( meta , params , execOptions ) ; } } catch ( err ) { return callback ( err ) ; } callback ( ) ; } 
function getJsFiles ( dir , fileArray ) { const files = fs . readdirSync ( dir ) ; fileArray = fileArray || [ ] ; files . forEach ( function ( file ) { if ( file === 'node_modules' ) { return ; } if ( fs . statSync ( dir + file ) . isDirectory ( ) ) { getJsFiles ( dir + file + '/' , fileArray ) ; return ; } if ( file . substring ( file . length - 3 , file . length ) !== '.js' ) { return ; } fileArray . push ( dir + file ) ; } ) ; return fileArray ; } 
async function example ( ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; 
function SchemaFunction ( ) { this . name = null ; this . keyspaceName = null ; this . signature = null ; this . argumentNames = null ; this . argumentTypes = null ; this . body = null ; this . calledOnNullInput = null ; this . language = null ; this . returnType = null ; } 
function executeConcurrent ( client , query , parameters , options ) { if ( ! client ) { throw new TypeError ( 'Client instance is not defined' ) ; } if ( typeof query === 'string' ) { if ( Array . isArray ( parameters ) ) { return new ArrayBasedExecutor ( client , query , parameters , options ) . execute ( ) ; } if ( parameters instanceof Stream ) { return new StreamBasedExecutor ( client , query , parameters , options ) . execute ( ) ; } throw new TypeError ( 'parameters should be an Array or a Stream instance' ) ; } if ( Array . isArray ( query ) ) { options = parameters ; return new ArrayBasedExecutor ( client , null , query , options ) . execute ( ) ; } throw new TypeError ( 'A string query or query and parameters array should be provided' ) ; } 
function copyBuffer ( buf ) { const targetBuffer = allocBufferUnsafe ( buf . length ) ; buf . copy ( targetBuffer ) ; return targetBuffer ; } 
function fixStack ( stackTrace , error ) { if ( stackTrace ) { error . stack += '\n (event loop)\n' + stackTrace . substr ( stackTrace . indexOf ( "\n" ) + 1 ) ; } return error ; } 
function log ( type , info , furtherInfo ) { if ( ! this . logEmitter ) { if ( ! this . options || ! this . options . logEmitter ) { throw new Error ( 'Log emitter not defined' ) ; } this . logEmitter = this . options . logEmitter ; } this . logEmitter ( 'log' , type , this . constructor . name , info , furtherInfo || '' ) ; } 
function extend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { if ( ! source ) { return ; } const keys = Object . keys ( source ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const value = source [ key ] ; if ( value === undefined ) { continue ; } target [ key ] = value ; } } ) ; return target ; } 
function toLowerCaseProperties ( obj ) { const keys = Object . keys ( obj ) ; const result = { } ; for ( let i = 0 ; i < keys . length ; i ++ ) { const k = keys [ i ] ; result [ k . toLowerCase ( ) ] = obj [ k ] ; } return result ; } 
function deepExtend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( const prop in source ) { if ( ! source . hasOwnProperty ( prop ) ) { continue ; } const targetProp = target [ prop ] ; const targetType = ( typeof targetProp ) ; 
function arrayIterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index >= arr . length ) { return { done : true } ; } return { value : arr [ index ++ ] , done : false } ; } } ; } 
function iteratorToArray ( iterator ) { const values = [ ] ; let item = iterator . next ( ) ; while ( ! item . done ) { values . push ( item . value ) ; item = iterator . next ( ) ; } return values ; } 
function binarySearch ( arr , key , compareFunc ) { let low = 0 ; let high = arr . length - 1 ; while ( low <= high ) { const mid = ( low + high ) >>> 1 ; const midVal = arr [ mid ] ; const cmp = compareFunc ( midVal , key ) ; if ( cmp < 0 ) { low = mid + 1 ; } else if ( cmp > 0 ) { high = mid - 1 ; } else { 
function insertSorted ( arr , item , compareFunc ) { if ( arr . length === 0 ) { return arr . push ( item ) ; } let position = binarySearch ( arr , item , compareFunc ) ; if ( position < 0 ) { position = ~ position ; } arr . splice ( position , 0 , item ) ; } 
function validateFn ( fn , name ) { if ( typeof fn !== 'function' ) { throw new errors . ArgumentError ( util . format ( '%s is not a function' , name || 'callback' ) ) ; } return fn ; } 
function adaptNamedParamsPrepared ( params , columns ) { if ( ! params || util . isArray ( params ) || ! columns || columns . length === 0 ) { 
function adaptNamedParamsWithHints ( params , execOptions ) { if ( ! params || util . isArray ( params ) ) { 
function stringRepeat ( val , times ) { if ( ! times || times < 0 ) { return null ; } if ( times === 1 ) { return val ; } return new Array ( times + 1 ) . join ( val ) ; } 
function objectValues ( obj ) { if ( ! obj ) { return exports . emptyArray ; } const keys = Object . keys ( obj ) ; const values = new Array ( keys . length ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { values [ i ] = obj [ keys [ i ] ] ; } return values ; } 
function promiseWrapper ( options , originalCallback , handler ) { if ( typeof originalCallback === 'function' ) { 
function series ( arr , callback ) { if ( ! Array . isArray ( arr ) ) { throw new TypeError ( 'First parameter must be an Array' ) ; } callback = callback || noop ; let index = 0 ; let sync ; next ( ) ; function next ( err , result ) { if ( err ) { return callback ( err ) ; } if ( index === arr . length ) { return callback ( null , result ) ; } if ( sync ) { return process . nextTick ( function ( ) { sync = true ; arr [ index ++ ] ( next ) ; sync = false ; } ) ; } sync = true ; arr [ index ++ ] ( next ) ; sync = false ; } } 
function TokenAwareIterator ( keyspace , execOptions , replicas , childPolicy ) { this . keyspace = keyspace ; this . childPolicy = childPolicy ; this . options = execOptions ; this . localReplicas = [ ] ; this . replicaIndex = 0 ; this . replicaMap = { } ; this . childIterator = null ; 
function WhiteListPolicy ( childPolicy , whiteList ) { if ( ! childPolicy ) { throw new Error ( "You must specify a child load balancing policy" ) ; } if ( ! util . isArray ( whiteList ) ) { throw new Error ( "You must provide the white list of host addresses" ) ; } this . childPolicy = childPolicy ; const map = { } ; whiteList . forEach ( function ( address ) { map [ address ] = true ; } ) ; this . whiteList = map ; } 
function MonotonicTimestampGenerator ( warningThreshold , minLogInterval ) { if ( warningThreshold < 0 ) { throw new errors . ArgumentError ( 'warningThreshold can not be lower than 0' ) ; } this . _warningThreshold = warningThreshold || 1000 ; this . _minLogInterval = 1000 ; if ( typeof minLogInterval === 'number' ) { 
function ExponentialReconnectionPolicy ( baseDelay , maxDelay , startWithNoDelay ) { this . baseDelay = baseDelay ; this . maxDelay = maxDelay ; this . startWithNoDelay = startWithNoDelay ; } 
function ControlConnection ( options , profileManager , context ) { this . protocolVersion = null ; this . hosts = new HostMap ( ) ; this . setMaxListeners ( 0 ) ; Object . defineProperty ( this , "options" , { value : options , enumerable : false , writable : false } ) ; this . metadata = new Metadata ( this . options , this ) ; this . addressTranslator = this . options . policies . addressResolution ; this . reconnectionPolicy = this . options . policies . reconnection ; this . reconnectionSchedule = this . reconnectionPolicy . newSchedule ( ) ; this . initialized = false ; this . isShuttingDown = false ; this . host = null ; this . connection = null ; this . encoder = null ; this . debouncer = new EventDebouncer ( options . refreshSchemaDelay , this . log . bind ( this ) ) ; this . profileManager = profileManager ; this . topologyChangeTimeout = null ; this . nodeStatusChangeTimeout = null ; this . reconnectionTimeout = null ; this . hostIterator = null ; this . triedHosts = null ; this . _resolvedContactPoints = new Map ( ) ; this . _contactPoints = new Set ( ) ; if ( context && context . borrowHostConnection ) { this . borrowHostConnection = context . borrowHostConnection ; } if ( context && context . createConnection ) { this . createConnection = context . createConnection ; } } 
function resolveAll ( name , callback ) { const addresses = [ ] ; utils . parallel ( [ function resolve4 ( next ) { dns . resolve4 ( name , function resolve4Callback ( err , arr ) { if ( arr ) { arr . forEach ( address => addresses . push ( { address , isIPv6 : false } ) ) ; } 
function ClientState ( hosts , openConnections , inFlightQueries ) { this . _hosts = hosts ; this . _openConnections = openConnections ; this . _inFlightQueries = inFlightQueries ; } 
function EventDebouncer ( delay , logger ) { this . _delay = delay ; this . _logger = logger ; this . _queue = null ; this . _timeout = null ; } 
function FrameReader ( header , body , offset ) { this . header = header ; this . opcode = header . opcode ; this . offset = offset || 0 ; this . buf = body ; } 
function Connection ( endpoint , protocolVersion , options ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; if ( ! options ) { throw new Error ( 'options is not defined' ) ; } this . endpoint = endpoint ; this . endpointFriendlyName = endpoint ; if ( ! this . endpoint || this . endpoint . indexOf ( ':' ) < 0 ) { throw new Error ( 'EndPoint must contain the ip address and port separated by : symbol' ) ; } const portSeparatorIndex = this . endpoint . lastIndexOf ( ':' ) ; this . address = this . endpoint . substr ( 0 , portSeparatorIndex ) ; this . port = this . endpoint . substr ( portSeparatorIndex + 1 ) ; Object . defineProperty ( this , "options" , { value : options , enumerable : false , writable : false } ) ; if ( protocolVersion === null ) { * The timeout state for the idle request (heartbeat) */ this . _idleTimeout = null ; this . timedOutOperations = 0 ; this . _streamIds = new StreamIdStack ( this . protocolVersion ) ; this . _metrics = options . metrics ; this . encoder = new Encoder ( protocolVersion , options ) ; this . keyspace = null ; this . emitDrain = false ; this . connected = false ; this . isSocketOpen = false ; } 
function TimeUuid ( value , ticks , nodeId , clockId ) { let buffer ; if ( value instanceof Buffer ) { if ( value . length !== 16 ) { throw new Error ( 'Buffer for v1 uuid not valid' ) ; } buffer = value ; } else { buffer = generateBuffer ( value , ticks , nodeId , clockId ) ; } Uuid . call ( this , buffer ) ; } 
function getClockId ( clockId ) { let buffer = clockId ; if ( typeof clockId === 'string' ) { buffer = utils . allocBufferFromString ( clockId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { 
function getNodeId ( nodeId ) { let buffer = nodeId ; if ( typeof nodeId === 'string' ) { buffer = utils . allocBufferFromString ( nodeId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { 
function getTicks ( ticks ) { if ( typeof ticks !== 'number' || ticks >= _ticksInMs ) { _ticks ++ ; if ( _ticks >= _ticksInMs ) { _ticks = 0 ; } ticks = _ticks ; } return ticks ; } 
function getTimeWithTicks ( date , ticks ) { if ( ! ( date instanceof Date ) || isNaN ( date . getTime ( ) ) ) { 
function generateBuffer ( date , ticks , nodeId , clockId ) { const timeWithTicks = getTimeWithTicks ( date , ticks ) ; nodeId = getNodeId ( nodeId ) ; clockId = getClockId ( clockId ) ; const buffer = utils . allocBufferUnsafe ( 16 ) ; 
function Encoder ( protocolVersion , options ) { this . encodingOptions = options . encoding || utils . emptyObject ; defineInstanceMembers . call ( this ) ; this . setProtocolVersion ( protocolVersion ) ; setEncoders . call ( this ) ; if ( this . encodingOptions . copyBuffer ) { this . handleBuffer = handleBufferCopy ; } else { this . handleBuffer = handleBufferRef ; } } 
function defineInstanceMembers ( ) { this . setProtocolVersion = function ( value ) { this . protocolVersion = value ; * Reads a list from bytes */ this . decodeList = function ( bytes , subtype ) { const totalItems = this . decodeCollectionLength ( bytes , 0 ) ; let offset = this . collectionLengthSize ; const list = new Array ( totalItems ) ; for ( let i = 0 ; i < totalItems ; i ++ ) { * Reads a Set from bytes */ this . decodeSet = function ( bytes , subtype ) { const arr = this . decodeList ( bytes , subtype ) ; if ( this . encodingOptions . set ) { const setConstructor = this . encodingOptions . set ; return new setConstructor ( arr ) ; } return arr ; } ; this . decodeMap = function ( bytes , subtypes ) { let map ; const totalItems = this . decodeCollectionLength ( bytes , 0 ) ; let offset = this . collectionLengthSize ; const self = this ; function readValues ( callback , thisArg ) { for ( let i = 0 ; i < totalItems ; i ++ ) { const keyLength = self . decodeCollectionLength ( bytes , offset ) ; offset += self . collectionLengthSize ; const key = self . decode ( bytes . slice ( offset , offset + keyLength ) , subtypes [ 0 ] ) ; offset += keyLength ; const valueLength = self . decodeCollectionLength ( bytes , offset ) ; offset += self . collectionLengthSize ; if ( valueLength < 0 ) { callback . call ( thisArg , key , null ) ; continue ; } const value = self . decode ( bytes . slice ( offset , offset + valueLength ) , subtypes [ 1 ] ) ; offset += valueLength ; callback . call ( thisArg , key , value ) ; } } if ( this . encodingOptions . map ) { const mapConstructor = this . encodingOptions . map ; map = new mapConstructor ( ) ; readValues ( map . set , map ) ; } else { map = { } ; readValues ( function ( key , value ) { map [ key ] = value ; } ) ; } return map ; } ; this . decodeUuid = function ( bytes ) { return new types . Uuid ( this . handleBuffer ( bytes ) ) ; } ; this . decodeTimeUuid = function ( bytes ) { return new types . TimeUuid ( this . handleBuffer ( bytes ) ) ; } ; this . decodeInet = function ( bytes ) { return new types . InetAddress ( this . handleBuffer ( bytes ) ) ; } ; this . decodeUdt = function ( bytes , udtInfo ) { const result = { } ; let offset = 0 ; for ( let i = 0 ; i < udtInfo . fields . length && offset < bytes . length ; i ++ ) { * @param {Date|String|Long|Number} value * @private */ this . encodeTimestamp = function ( value ) { const originalValue = value ; if ( typeof value === 'string' ) { value = new Date ( value ) ; } if ( value instanceof Date ) { * @param {Date|String|LocalDate} value * @returns {Buffer} * @throws {TypeError} * @private */ this . encodeDate = function ( value ) { const originalValue = value ; try { if ( typeof value === 'string' ) { value = types . LocalDate . fromString ( value ) ; } if ( value instanceof Date ) { value = types . LocalDate . fromDate ( value ) ; } } catch ( err ) { * @param {String|LocalDate} value * @returns {Buffer} * @throws {TypeError} * @private */ this . encodeTime = function ( value ) { const originalValue = value ; try { if ( typeof value === 'string' ) { value = types . LocalTime . fromString ( value ) ; } } catch ( err ) { * @param {Uuid|String|Buffer} value * @private */ this . encodeUuid = function ( value ) { if ( typeof value === 'string' ) { try { value = types . Uuid . fromString ( value ) . getBuffer ( ) ; } catch ( err ) { throw new TypeError ( err . message ) ; } } else if ( value instanceof types . Uuid ) { value = value . getBuffer ( ) ; } else { throw new TypeError ( 'Not a valid Uuid, expected Uuid/String/Buffer, obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . encodeInet = function ( value ) { if ( typeof value === 'string' ) { value = types . InetAddress . fromString ( value ) ; } if ( value instanceof types . InetAddress ) { value = value . getBuffer ( ) ; } if ( ! ( value instanceof Buffer ) ) { throw new TypeError ( 'Not a valid Inet, expected InetAddress/Buffer, obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . _encodeBigIntFromLong = function ( value ) { if ( typeof value === 'number' ) { value = Long . fromNumber ( value ) ; } else if ( typeof value === 'string' ) { value = Long . fromString ( value ) ; } let buf = null ; if ( value instanceof Long ) { buf = Long . toBuffer ( value ) ; } else if ( value instanceof MutableLong ) { buf = Long . toBuffer ( value . toImmutable ( ) ) ; } if ( buf === null ) { throw new TypeError ( 'Not a valid bigint, expected Long/Number/String/Buffer, obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . _encodeBigIntFromBigInt = function ( value ) { * @param {Integer|Buffer|String|Number} value * @returns {Buffer} * @private */ this . _encodeVarintFromInteger = function ( value ) { if ( typeof value === 'number' ) { value = Integer . fromNumber ( value ) ; } if ( typeof value === 'string' ) { value = Integer . fromString ( value ) ; } let buf = null ; if ( value instanceof Buffer ) { buf = value ; } if ( value instanceof Integer ) { buf = Integer . toBuffer ( value ) ; } if ( buf === null ) { throw new TypeError ( 'Not a valid varint, expected Integer/Number/String/Buffer, obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . _encodeVarintFromBigInt = function ( value ) { * @param {BigDecimal|Buffer|String|Number} value * @returns {Buffer} * @private */ this . encodeDecimal = function ( value ) { if ( typeof value === 'number' ) { value = BigDecimal . fromNumber ( value ) ; } else if ( typeof value === 'string' ) { value = BigDecimal . fromString ( value ) ; } let buf = null ; if ( value instanceof BigDecimal ) { buf = BigDecimal . toBuffer ( value ) ; } else { throw new TypeError ( 'Not a valid varint, expected BigDecimal/Number/String/Buffer, obtained ' + util . inspect ( value ) ) ; } return buf ; } ; this . encodeString = function ( value , encoding ) { if ( typeof value !== 'string' ) { throw new TypeError ( 'Not a valid text value, expected String obtained ' + util . inspect ( value ) ) ; } return utils . allocBufferFromString ( value , encoding ) ; } ; this . encodeUtf8String = function ( value ) { return this . encodeString ( value , 'utf8' ) ; } ; this . encodeAsciiString = function ( value ) { return this . encodeString ( value , 'ascii' ) ; } ; this . encodeBlob = function ( value ) { if ( ! ( value instanceof Buffer ) ) { throw new TypeError ( 'Not a valid blob, expected Buffer obtained ' + util . inspect ( value ) ) ; } return value ; } ; this . encodeCustom = function ( value , name ) { const handler = customEncoders [ name ] ; if ( handler ) { return handler . call ( this , value ) ; } throw new TypeError ( 'No encoding handler found for type ' + name ) ; } ; this . encodeDuration = function ( value ) { if ( ! ( value instanceof types . Duration ) ) { throw new TypeError ( 'Not a valid duration, expected Duration/Buffer obtained ' + util . inspect ( value ) ) ; } return value . toBuffer ( ) ; } ; this . encodeBoolean = function ( value ) { return value ? buffers . int8One : buffers . int8Zero ; } ; this . encodeInt = function ( value ) { if ( isNaN ( value ) ) { throw new TypeError ( 'Expected Number, obtained ' + util . inspect ( value ) ) ; } const buf = utils . allocBufferUnsafe ( 4 ) ; buf . writeInt32BE ( value , 0 ) ; return buf ; } ; this . encodeSmallint = function ( value ) { if ( isNaN ( value ) ) { throw new TypeError ( 'Expected Number, obtained ' + util . inspect ( value ) ) ; } const buf = utils . allocBufferUnsafe ( 2 ) ; buf . writeInt16BE ( value , 0 ) ; return buf ; } ; this . encodeTinyint = function ( value ) { if ( isNaN ( value ) ) { throw new TypeError ( 'Expected Number, obtained ' + util . inspect ( value ) ) ; } const buf = utils . allocBufferUnsafe ( 1 ) ; buf . writeInt8 ( value , 0 ) ; return buf ; } ; this . encodeList = function ( value , subtype ) { if ( ! util . isArray ( value ) ) { throw new TypeError ( 'Not a valid list value, expected Array obtained ' + util . inspect ( value ) ) ; } if ( value . length === 0 ) { return null ; } const parts = [ ] ; parts . push ( this . getLengthBuffer ( value ) ) ; for ( let i = 0 ; i < value . length ; i ++ ) { const val = value [ i ] ; if ( val === null || typeof val === 'undefined' || val === types . unset ) { throw new TypeError ( 'A collection can\'t contain null or unset values' ) ; } const bytes = this . encode ( val , subtype ) ; //include item byte length parts . push ( this . getLengthBuffer ( bytes ) ) ; //include item parts . push ( bytes ) ; } return Buffer . concat ( parts ) ; } ; this . encodeSet = function ( value , subtype ) { if ( this . encodingOptions . set && value instanceof this . encodingOptions . set ) { const arr = [ ] ; value . forEach ( function ( x ) { arr . push ( x ) ; } ) ; return this . encodeList ( arr , subtype ) ; } return this . encodeList ( value , subtype ) ; } ; /** * Serializes a map into a Buffer * @param value * @param {Array} [subtypes] * @returns {Buffer} * @private */ this . encodeMap = function ( value , subtypes ) { const parts = [ ] ; let propCounter = 0 ; let keySubtype = null ; let valueSubtype = null ; const self = this ; if ( subtypes ) { keySubtype = subtypes [ 0 ] ; valueSubtype = subtypes [ 1 ] ; } function addItem ( val , key ) { if ( key === null || typeof key === 'undefined' || key === types . unset ) { throw new TypeError ( 'A map can\'t contain null or unset keys' ) ; } if ( val === null || typeof val === 'undefined' || val === types . unset ) { throw new TypeError ( 'A map can\'t contain null or unset values' ) ; } const keyBuffer = self . encode ( key , keySubtype ) ; //include item byte length parts . push ( self . getLengthBuffer ( keyBuffer ) ) ; //include item parts . push ( keyBuffer ) ; //value const valueBuffer = self . encode ( val , valueSubtype ) ; //include item byte length parts . push ( self . getLengthBuffer ( valueBuffer ) ) ; //include item if ( valueBuffer !== null ) { parts . push ( valueBuffer ) ; } propCounter ++ ; } if ( this . encodingOptions . map && value instanceof this . encodingOptions . map ) { //Use Map#forEach() method to iterate value . forEach ( addItem ) ; } else { //Use object for ( const key in value ) { if ( ! value . hasOwnProperty ( key ) ) { continue ; } const val = value [ key ] ; addItem ( val , key ) ; } } parts . unshift ( this . getLengthBuffer ( propCounter ) ) ; return Buffer . concat ( parts ) ; } ; this . encodeUdt = function ( value , udtInfo ) { const parts = [ ] ; let totalLength = 0 ; for ( let i = 0 ; i < udtInfo . fields . length ; i ++ ) { const field = udtInfo . fields [ i ] ; const item = this . encode ( value [ field . name ] , field . type ) ; if ( ! item ) { parts . push ( nullValueBuffer ) ; totalLength += 4 ; continue ; } if ( item === types . unset ) { parts . push ( unsetValueBuffer ) ; totalLength += 4 ; continue ; } const lengthBuffer = utils . allocBufferUnsafe ( 4 ) ; lengthBuffer . writeInt32BE ( item . length , 0 ) ; parts . push ( lengthBuffer ) ; parts . push ( item ) ; totalLength += item . length + 4 ; } return Buffer . concat ( parts , totalLength ) ; } ; this . encodeTuple = function ( value , tupleInfo ) { const parts = [ ] ; let totalLength = 0 ; for ( let i = 0 ; i < tupleInfo . length ; i ++ ) { const type = tupleInfo [ i ] ; const item = this . encode ( value . get ( i ) , type ) ; if ( ! item ) { parts . push ( nullValueBuffer ) ; totalLength += 4 ; continue ; } if ( item === types . unset ) { parts . push ( unsetValueBuffer ) ; totalLength += 4 ; continue ; } const lengthBuffer = utils . allocBufferUnsafe ( 4 ) ; lengthBuffer . writeInt32BE ( item . length , 0 ) ; parts . push ( lengthBuffer ) ; parts . push ( item ) ; totalLength += item . length + 4 ; } return Buffer . concat ( parts , totalLength ) ; } ; /** * If not provided, it uses the array of buffers or the parameters and hints to build the routingKey * @param {Array} params * @param {ExecutionOptions} execOptions * @param [keys] parameter keys and positions in the params array * @throws TypeError * @internal * @ignore */ this . setRoutingKeyFromUser = function ( params , execOptions , keys ) { let totalLength = 0 ; const userRoutingKey = execOptions . getRoutingKey ( ) ; if ( util . isArray ( userRoutingKey ) ) { if ( userRoutingKey . length === 1 ) { execOptions . setRoutingKey ( userRoutingKey [ 0 ] ) ; return ; } // Its a composite routing key totalLength = 0 ; for ( let i = 0 ; i < userRoutingKey . length ; i ++ ) { const item = userRoutingKey [ i ] ; if ( ! item ) { // Invalid routing key part provided by the user, clear the value execOptions . setRoutingKey ( null ) ; return ; } totalLength += item . length + 3 ; } execOptions . setRoutingKey ( concatRoutingKey ( userRoutingKey , totalLength ) ) ; return ; } // If routingKey is present, ensure it is a Buffer, Token, or TokenRange. Otherwise throw an error. if ( userRoutingKey ) { if ( userRoutingKey instanceof Buffer || userRoutingKey instanceof token . Token || userRoutingKey instanceof token . TokenRange ) { return ; } throw new TypeError ( ` ${ util . inspect ( userRoutingKey ) } ` + ` ` ) ; } // If no params are present, return as routing key cannot be determined. if ( ! params || params . length === 0 ) { return ; } let routingIndexes = execOptions . getRoutingIndexes ( ) ; if ( execOptions . getRoutingNames ( ) ) { routingIndexes = execOptions . getRoutingNames ( ) . map ( k => keys [ k ] ) ; } if ( ! routingIndexes ) { return ; } const parts = [ ] ; const hints = execOptions . getHints ( ) || utils . emptyArray ; const encodeParam = ! keys ? ( i => this . encode ( params [ i ] , hints [ i ] ) ) : ( i => this . encode ( params [ i ] . value , hints [ i ] ) ) ; try { totalLength = this . _encodeRoutingKeyParts ( parts , routingIndexes , encodeParam ) ; } catch ( e ) { // There was an error encoding a parameter that is part of the routing key, // ignore now to fail afterwards } if ( totalLength === 0 ) { return ; } execOptions . setRoutingKey ( concatRoutingKey ( parts , totalLength ) ) ; } ; /** * Sets the routing key in the options based on the prepared statement metadata. * @param {Object} meta Prepared metadata * @param {Array} params Array of parameters * @param {ExecutionOptions} execOptions * @throws TypeError * @internal * @ignore */ this . setRoutingKeyFromMeta = function ( meta , params , execOptions ) { const routingIndexes = execOptions . getRoutingIndexes ( ) ; if ( ! routingIndexes ) { return ; } const parts = new Array ( routingIndexes . length ) ; const encodeParam = i => { const columnInfo = meta . columns [ i ] ; return this . encode ( params [ i ] , columnInfo ? columnInfo . type : null ) ; } ; let totalLength = 0 ; try { totalLength = this . _encodeRoutingKeyParts ( parts , routingIndexes , encodeParam ) ; } catch ( e ) { // There was an error encoding a parameter that is part of the routing key, // ignore now to fail afterwards } if ( totalLength === 0 ) { return ; } execOptions . setRoutingKey ( concatRoutingKey ( parts , totalLength ) ) ; } ; /** * @param {Array} parts * @param {Array} routingIndexes * @param {Function} encodeParam * @returns {Number} The total length * @private */ this . _encodeRoutingKeyParts = function ( parts , routingIndexes , encodeParam ) { let totalLength = 0 ; for ( let i = 0 ; i < routingIndexes . length ; i ++ ) { const paramIndex = routingIndexes [ i ] ; if ( paramIndex === undefined ) { // Bad input from the user, ignore return 0 ; } const item = encodeParam ( paramIndex ) ; if ( item === null || item === undefined || item === types . unset ) { // The encoded partition key should an instance of Buffer // Let it fail later in the pipeline for null/undefined parameter values return 0 ; } // Per each part of the routing key, 3 extra bytes are needed totalLength += item . length + 3 ; parts [ i ] = item ; } return totalLength ; } ; /** * Parses a CQL name string into data type information * @param {String} keyspace * @param {String} typeName * @param {Number} startIndex * @param {Number|null} length * @param {Function} udtResolver * @param {Function} callback Callback invoked with err and {{code: number, info: Object|Array|null, options: {frozen: Boolean}}} * @internal * @ignore */ this . parseTypeName = function ( keyspace , typeName , startIndex , length , udtResolver , callback ) { startIndex = startIndex || 0 ; if ( ! length ) { length = typeName . length ; } const dataType = { code : 0 , info : null , options : { frozen : false } } ; let innerTypes ; if ( typeName . indexOf ( "'" , startIndex ) === startIndex ) { //If quoted, this is a custom type. dataType . info = typeName . substr ( startIndex + 1 , length - 2 ) ; return callback ( null , dataType ) ; } if ( ! length ) { length = typeName . length ; } if ( typeName . indexOf ( cqlNames . frozen , startIndex ) === startIndex ) { //Remove the frozen token startIndex += cqlNames . frozen . length + 1 ; length -= cqlNames . frozen . length + 2 ; dataType . options . frozen = true ; } if ( typeName . indexOf ( cqlNames . list , startIndex ) === startIndex ) { //move cursor across the name and bypass the angle brackets startIndex += cqlNames . list . length + 1 ; length -= cqlNames . list . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length , '<' , '>' ) ; if ( innerTypes . length !== 1 ) { return callback ( new TypeError ( 'Not a valid type ' + typeName ) ) ; } dataType . code = dataTypes . list ; return this . parseTypeName ( keyspace , innerTypes [ 0 ] , 0 , null , udtResolver , function ( err , childType ) { if ( err ) { return callback ( err ) ; } dataType . info = childType ; callback ( null , dataType ) ; } ) ; } if ( typeName . indexOf ( cqlNames . set , startIndex ) === startIndex ) { //move cursor across the name and bypass the angle brackets startIndex += cqlNames . set . length + 1 ; length -= cqlNames . set . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length , '<' , '>' ) ; if ( innerTypes . length !== 1 ) { return callback ( new TypeError ( 'Not a valid type ' + typeName ) ) ; } dataType . code = dataTypes . set ; return this . parseTypeName ( keyspace , innerTypes [ 0 ] , 0 , null , udtResolver , function ( err , childType ) { if ( err ) { return callback ( err ) ; } dataType . info = childType ; callback ( null , dataType ) ; } ) ; } if ( typeName . indexOf ( cqlNames . map , startIndex ) === startIndex ) { //move cursor across the name and bypass the angle brackets startIndex += cqlNames . map . length + 1 ; length -= cqlNames . map . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length , '<' , '>' ) ; //It should contain the key and value types if ( innerTypes . length !== 2 ) { return callback ( new TypeError ( 'Not a valid type ' + typeName ) ) ; } dataType . code = dataTypes . map ; return this . _parseChildTypes ( keyspace , dataType , innerTypes , udtResolver , callback ) ; } if ( typeName . indexOf ( cqlNames . tuple , startIndex ) === startIndex ) { //move cursor across the name and bypass the angle brackets startIndex += cqlNames . tuple . length + 1 ; length -= cqlNames . tuple . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length , '<' , '>' ) ; if ( innerTypes . length < 1 ) { throw new TypeError ( 'Not a valid type ' + typeName ) ; } dataType . code = dataTypes . tuple ; return this . _parseChildTypes ( keyspace , dataType , innerTypes , udtResolver , callback ) ; } const quoted = typeName . indexOf ( '"' , startIndex ) === startIndex ; if ( quoted ) { //Remove quotes startIndex ++ ; length -= 2 ; } //Quick check if its a single type if ( startIndex > 0 ) { typeName = typeName . substr ( startIndex , length ) ; } // Un-escape double quotes if quoted. if ( quoted ) { typeName = typeName . replace ( '""' , '"' ) ; } const typeCode = dataTypes [ typeName ] ; if ( typeof typeCode === 'number' ) { dataType . code = typeCode ; return callback ( null , dataType ) ; } if ( typeName === cqlNames . duration ) { dataType . info = durationTypeName ; return callback ( null , dataType ) ; } if ( typeName === cqlNames . empty ) { //set as custom dataType . info = 'empty' ; return callback ( null , dataType ) ; } udtResolver ( keyspace , typeName , function ( err , udtInfo ) { if ( err ) { return callback ( err ) ; } if ( udtInfo ) { dataType . code = dataTypes . udt ; dataType . info = udtInfo ; return callback ( null , dataType ) ; } callback ( new TypeError ( 'Not a valid type "' + typeName + '"' ) ) ; } ) ; } ; /** * @param {String} keyspace * @param dataType * @param {Array} typeNames * @param {Function} udtResolver * @param {Function} callback * @private */ this . _parseChildTypes = function ( keyspace , dataType , typeNames , udtResolver , callback ) { const self = this ; utils . mapSeries ( typeNames , function ( name , next ) { self . parseTypeName ( keyspace , name . trim ( ) , 0 , null , udtResolver , next ) ; } , function ( err , childTypes ) { if ( err ) { return callback ( err ) ; } dataType . info = childTypes ; callback ( null , dataType ) ; } ) ; } ; /** * Parses a Cassandra fully-qualified class name string into data type information * @param {String} typeName * @param {Number} [startIndex] * @param {Number} [length] * @throws TypeError * @returns {{code: number, info: Object|Array|null, options: {frozen: Boolean, reversed: Boolean}}} * @internal * @ignore */ this . parseFqTypeName = function ( typeName , startIndex , length ) { const dataType = { code : 0 , info : null , options : { reversed : false , frozen : false } } ; startIndex = startIndex || 0 ; let innerTypes ; if ( ! length ) { length = typeName . length ; } if ( length > complexTypeNames . reversed . length && typeName . indexOf ( complexTypeNames . reversed ) === startIndex ) { //Remove the reversed token startIndex += complexTypeNames . reversed . length + 1 ; length -= complexTypeNames . reversed . length + 2 ; dataType . options . reversed = true ; } if ( length > complexTypeNames . frozen . length && typeName . indexOf ( complexTypeNames . frozen , startIndex ) === startIndex ) { //Remove the frozen token startIndex += complexTypeNames . frozen . length + 1 ; length -= complexTypeNames . frozen . length + 2 ; dataType . options . frozen = true ; } if ( typeName === complexTypeNames . empty ) { //set as custom dataType . info = 'empty' ; return dataType ; } //Quick check if its a single type if ( length <= singleFqTypeNamesLength ) { if ( startIndex > 0 ) { typeName = typeName . substr ( startIndex , length ) ; } const typeCode = singleTypeNames [ typeName ] ; if ( typeof typeCode === 'number' ) { dataType . code = typeCode ; return dataType ; } throw new TypeError ( 'Not a valid type "' + typeName + '"' ) ; } if ( typeName . indexOf ( complexTypeNames . list , startIndex ) === startIndex ) { //Its a list //org.apache.cassandra.db.marshal.ListType(innerType) //move cursor across the name and bypass the parenthesis startIndex += complexTypeNames . list . length + 1 ; length -= complexTypeNames . list . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length ) ; if ( innerTypes . length !== 1 ) { throw new TypeError ( 'Not a valid type ' + typeName ) ; } dataType . code = dataTypes . list ; dataType . info = this . parseFqTypeName ( innerTypes [ 0 ] ) ; return dataType ; } if ( typeName . indexOf ( complexTypeNames . set , startIndex ) === startIndex ) { //Its a set //org.apache.cassandra.db.marshal.SetType(innerType) //move cursor across the name and bypass the parenthesis startIndex += complexTypeNames . set . length + 1 ; length -= complexTypeNames . set . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length ) ; if ( innerTypes . length !== 1 ) { throw new TypeError ( 'Not a valid type ' + typeName ) ; } dataType . code = dataTypes . set ; dataType . info = this . parseFqTypeName ( innerTypes [ 0 ] ) ; return dataType ; } if ( typeName . indexOf ( complexTypeNames . map , startIndex ) === startIndex ) { //org.apache.cassandra.db.marshal.MapType(keyType,valueType) //move cursor across the name and bypass the parenthesis startIndex += complexTypeNames . map . length + 1 ; length -= complexTypeNames . map . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length ) ; //It should contain the key and value types if ( innerTypes . length !== 2 ) { throw new TypeError ( 'Not a valid type ' + typeName ) ; } dataType . code = dataTypes . map ; dataType . info = [ this . parseFqTypeName ( innerTypes [ 0 ] ) , this . parseFqTypeName ( innerTypes [ 1 ] ) ] ; return dataType ; } if ( typeName . indexOf ( complexTypeNames . udt , startIndex ) === startIndex ) { //move cursor across the name and bypass the parenthesis startIndex += complexTypeNames . udt . length + 1 ; length -= complexTypeNames . udt . length + 2 ; return this . _parseUdtName ( typeName , startIndex , length ) ; } if ( typeName . indexOf ( complexTypeNames . tuple , startIndex ) === startIndex ) { //move cursor across the name and bypass the parenthesis startIndex += complexTypeNames . tuple . length + 1 ; length -= complexTypeNames . tuple . length + 2 ; innerTypes = parseParams ( typeName , startIndex , length ) ; if ( innerTypes . length < 1 ) { throw new TypeError ( 'Not a valid type ' + typeName ) ; } dataType . code = dataTypes . tuple ; dataType . info = innerTypes . map ( x => this . parseFqTypeName ( x ) ) ; return dataType ; } // Assume custom type if cannot be parsed up to this point. dataType . info = typeName . substr ( startIndex , length ) ; return dataType ; } ; /** * Parses type names with composites * @param {String} typesString * @returns {{types: Array, isComposite: Boolean, hasCollections: Boolean}} * @internal * @ignore */ this . parseKeyTypes = function ( typesString ) { let i = 0 ; let length = typesString . length ; const isComposite = typesString . indexOf ( complexTypeNames . composite ) === 0 ; if ( isComposite ) { i = complexTypeNames . composite . length + 1 ; length -- ; } const types = [ ] ; let startIndex = i ; let nested = 0 ; let inCollectionType = false ; let hasCollections = false ; //as collection types are not allowed, it is safe to split by , while ( ++ i < length ) { switch ( typesString [ i ] ) { case ',' : if ( nested > 0 ) { break ; } if ( inCollectionType ) { //remove type id startIndex = typesString . indexOf ( ':' , startIndex ) + 1 ; } types . push ( typesString . substring ( startIndex , i ) ) ; startIndex = i + 1 ; break ; case '(' : if ( nested === 0 && typesString . indexOf ( complexTypeNames . collection , startIndex ) === startIndex ) { inCollectionType = true ; hasCollections = true ; //skip collection type i ++ ; startIndex = i ; break ; } nested ++ ; break ; case ')' : if ( inCollectionType && nested === 0 ) { types . push ( typesString . substring ( typesString . indexOf ( ':' , startIndex ) + 1 , i ) ) ; startIndex = i + 1 ; break ; } nested -- ; break ; } } if ( startIndex < length ) { types . push ( typesString . substring ( startIndex , length ) ) ; } return { types : types . map ( name => this . parseFqTypeName ( name ) ) , hasCollections : hasCollections , isComposite : isComposite } ; } ; this . _parseUdtName = function ( typeName , startIndex , length ) { const udtParams = parseParams ( typeName , startIndex , length ) ; if ( udtParams . length < 2 ) { //It should contain at least the keyspace, name of the udt and a type throw new TypeError ( 'Not a valid type ' + typeName ) ; } const dataType = { code : dataTypes . udt , info : null } ; const udtInfo = { keyspace : udtParams [ 0 ] , name : utils . allocBufferFromString ( udtParams [ 1 ] , 'hex' ) . toString ( ) , fields : [ ] } ; for ( let i = 2 ; i < udtParams . length ; i ++ ) { const p = udtParams [ i ] ; const separatorIndex = p . indexOf ( ':' ) ; const fieldType = this . parseFqTypeName ( p , separatorIndex + 1 , p . length - ( separatorIndex + 1 ) ) ; udtInfo . fields . push ( { name : utils . allocBufferFromString ( p . substr ( 0 , separatorIndex ) , 'hex' ) . toString ( ) , type : fieldType } ) ; } dataType . info = udtInfo ; return dataType ; } ; customDecoders [ durationTypeName ] = this . decodeDuration ; customEncoders [ durationTypeName ] = this . encodeDuration ; } 
function setEncoders ( ) { this . decoders = { [ dataTypes . custom ] : this . decodeCustom , [ dataTypes . ascii ] : this . decodeAsciiString , [ dataTypes . bigint ] : this . decodeLong , [ dataTypes . blob ] : this . decodeBlob , [ dataTypes . boolean ] : this . decodeBoolean , [ dataTypes . counter ] : this . decodeLong , [ dataTypes . decimal ] : this . decodeDecimal , [ dataTypes . double ] : this . decodeDouble , [ dataTypes . float ] : this . decodeFloat , [ dataTypes . int ] : this . decodeInt , [ dataTypes . text ] : this . decodeUtf8String , [ dataTypes . timestamp ] : this . decodeTimestamp , [ dataTypes . uuid ] : this . decodeUuid , [ dataTypes . varchar ] : this . decodeUtf8String , [ dataTypes . varint ] : this . decodeVarint , [ dataTypes . timeuuid ] : this . decodeTimeUuid , [ dataTypes . inet ] : this . decodeInet , [ dataTypes . date ] : this . decodeDate , [ dataTypes . time ] : this . decodeTime , [ dataTypes . smallint ] : this . decodeSmallint , [ dataTypes . tinyint ] : this . decodeTinyint , [ dataTypes . list ] : this . decodeList , [ dataTypes . map ] : this . decodeMap , [ dataTypes . set ] : this . decodeSet , [ dataTypes . udt ] : this . decodeUdt , [ dataTypes . tuple ] : this . decodeTuple } ; this . encoders = { [ dataTypes . custom ] : this . encodeCustom , [ dataTypes . ascii ] : this . encodeAsciiString , [ dataTypes . bigint ] : this . encodeLong , [ dataTypes . blob ] : this . encodeBlob , [ dataTypes . boolean ] : this . encodeBoolean , [ dataTypes . counter ] : this . encodeLong , [ dataTypes . decimal ] : this . encodeDecimal , [ dataTypes . double ] : this . encodeDouble , [ dataTypes . float ] : this . encodeFloat , [ dataTypes . int ] : this . encodeInt , [ dataTypes . text ] : this . encodeUtf8String , [ dataTypes . timestamp ] : this . encodeTimestamp , [ dataTypes . uuid ] : this . encodeUuid , [ dataTypes . varchar ] : this . encodeUtf8String , [ dataTypes . varint ] : this . encodeVarint , [ dataTypes . timeuuid ] : this . encodeUuid , [ dataTypes . inet ] : this . encodeInet , [ dataTypes . date ] : this . encodeDate , [ dataTypes . time ] : this . encodeTime , [ dataTypes . smallint ] : this . encodeSmallint , [ dataTypes . tinyint ] : this . encodeTinyint , [ dataTypes . list ] : this . encodeList , [ dataTypes . map ] : this . encodeMap , [ dataTypes . set ] : this . encodeSet , [ dataTypes . udt ] : this . encodeUdt , [ dataTypes . tuple ] : this . encodeTuple } ; } 
function getLengthBufferV2 ( value ) { if ( ! value ) { return buffers . int16Zero ; } const lengthBuffer = utils . allocBufferUnsafe ( 2 ) ; if ( typeof value === 'number' ) { lengthBuffer . writeUInt16BE ( value , 0 ) ; } else { lengthBuffer . writeUInt16BE ( value . length , 0 ) ; } return lengthBuffer ; } 
function getLengthBufferV3 ( value ) { if ( ! value ) { return buffers . int32Zero ; } const lengthBuffer = utils . allocBufferUnsafe ( 4 ) ; if ( typeof value === 'number' ) { lengthBuffer . writeInt32BE ( value , 0 ) ; } else { lengthBuffer . writeInt32BE ( value . length , 0 ) ; } return lengthBuffer ; } 
function Duration ( months , days , nanoseconds ) { this . months = months ; this . days = days ; this . nanoseconds = typeof nanoseconds === 'number' ? Long . fromNumber ( nanoseconds ) : nanoseconds ; } 
function numberOfLeadingZeros ( value ) { if ( value . equals ( Long . ZERO ) ) { return 64 ; } let n = 1 ; let x = value . getHighBits ( ) ; if ( x === 0 ) { n += 32 ; x = value . getLowBits ( ) ; } if ( x >>> 16 === 0 ) { n += 16 ; x <<= 16 ; } if ( x >>> 24 === 0 ) { n += 8 ; x <<= 8 ; } if ( x >>> 28 === 0 ) { n += 4 ; x <<= 4 ; } if ( x >>> 30 === 0 ) { n += 2 ; x <<= 2 ; } n -= x >>> 31 ; return n ; } 
function Index ( name , target , kind , options ) { this . name = name ; this . target = target ; this . kind = typeof kind === 'string' ? getKindByName ( kind ) : kind ; this . options = options ; } 
function ( key ) { return _ . sortBy ( files , function ( el ) { return Number ( $ ( el ) . find ( 'span[data-lint]' ) . attr ( key ) ) * - 1 ; } ) ; } 
function ( ) { $this . css ( 'font-size' , Math . max ( Math . min ( $this . width ( ) / ( compressor * 10 ) , parseFloat ( settings . maxFontSize ) ) , parseFloat ( settings . minFontSize ) ) ) ; } 
function CodeMirror ( place , options ) { if ( ! ( this instanceof CodeMirror ) ) return new CodeMirror ( place , options ) ; this . options = options = options || { } ; 
function makeDisplay ( place ) { var d = { } ; var input = d . input = elt ( "textarea" , null , null , "position: absolute; padding: 0; width: 1px; height: 1em; outline: none;" ) ; input . setAttribute ( "wrap" , "off" ) ; input . setAttribute ( "autocorrect" , "off" ) ; input . setAttribute ( "autocapitalize" , "off" ) ; 
function makeView ( doc ) { var selPos = { line : 0 , ch : 0 } ; return { doc : doc , 
function loadMode ( cm ) { var doc = cm . view . doc ; cm . view . mode = CodeMirror . getMode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . stateAfter = null ; } ) ; cm . view . frontier = 0 ; startWorker ( cm , 100 ) ; } 
function updateScrollbars ( d , docHeight ) { var totalHeight = docHeight + 2 * paddingTop ( d ) ; d . sizer . style . minHeight = d . heightForcer . style . top = totalHeight + "px" ; var scrollHeight = Math . max ( totalHeight , d . scroller . scrollHeight ) ; var needsH = d . scroller . scrollWidth > d . scroller . clientWidth ; var needsV = scrollHeight > d . scroller . clientHeight ; if ( needsV ) { d . scrollbarV . style . display = "block" ; d . scrollbarV . style . bottom = needsH ? scrollbarWidth ( d . measure ) + "px" : "0" ; d . scrollbarV . firstChild . style . height = ( scrollHeight - d . scroller . clientHeight + d . scrollbarV . clientHeight ) + "px" ; } else d . scrollbarV . style . display = "" ; if ( needsH ) { d . scrollbarH . style . display = "block" ; d . scrollbarH . style . right = needsV ? scrollbarWidth ( d . measure ) + "px" : "0" ; d . scrollbarH . firstChild . style . width = ( d . scroller . scrollWidth - d . scroller . clientWidth + d . scrollbarH . clientWidth ) + "px" ; } else d . scrollbarH . style . display = "" ; if ( needsH && needsV ) { d . scrollbarFiller . style . display = "block" ; d . scrollbarFiller . style . height = d . scrollbarFiller . style . width = scrollbarWidth ( d . measure ) + "px" ; } else d . scrollbarFiller . style . display = "" ; if ( mac_geLion && scrollbarWidth ( d . measure ) === 0 ) d . scrollbarV . style . minWidth = d . scrollbarH . style . minHeight = mac_geMountainLion ? "18px" : "12px" ; } 
function updateDisplay ( cm , changes , viewPort ) { var oldFrom = cm . display . showingFrom , oldTo = cm . display . showingTo ; var updated = updateDisplayInner ( cm , changes , viewPort ) ; if ( updated ) { signalLater ( cm , cm , "update" , cm ) ; if ( cm . display . showingFrom != oldFrom || cm . display . showingTo != oldTo ) signalLater ( cm , cm , "viewportChange" , cm , cm . display . showingFrom , cm . display . showingTo ) ; } updateSelection ( cm ) ; updateScrollbars ( cm . display , cm . view . doc . height ) ; return updated ; } 
function updateDisplayInner ( cm , changes , viewPort ) { var display = cm . display , doc = cm . view . doc ; if ( ! display . wrapper . clientWidth ) { display . showingFrom = display . showingTo = display . viewOffset = 0 ; return ; } 
function updateSelectionRange ( cm ) { var display = cm . display , doc = cm . view . doc , sel = cm . view . sel ; var fragment = document . createDocumentFragment ( ) ; var clientWidth = display . lineSpace . offsetWidth , pl = paddingLeft ( cm . display ) ; function add ( left , top , width , bottom ) { if ( top < 0 ) top = 0 ; fragment . appendChild ( elt ( "div" , null , "CodeMirror-selected" , "position: absolute; left: " + left + "px; top: " + top + "px; width: " + ( width == null ? clientWidth - left : width ) + "px; height: " + ( bottom - top ) + "px" ) ) ; } function drawForLine ( line , fromArg , toArg , retTop ) { var lineObj = getLine ( doc , line ) ; var lineLen = lineObj . text . length , rVal = retTop ? Infinity : - Infinity ; function coords ( ch ) { return charCoords ( cm , { line : line , ch : ch } , "div" , lineObj ) ; } iterateBidiSections ( getOrder ( lineObj ) , fromArg || 0 , toArg == null ? lineLen : toArg , function ( from , to , dir ) { var leftPos = coords ( dir == "rtl" ? to - 1 : from ) ; var rightPos = coords ( dir == "rtl" ? from : to - 1 ) ; var left = leftPos . left , right = rightPos . right ; if ( rightPos . top - leftPos . top > 3 ) { 
function restartBlink ( cm ) { var display = cm . display ; clearInterval ( display . blinker ) ; var on = true ; display . cursor . style . visibility = display . otherCursor . style . visibility = "" ; display . blinker = setInterval ( function ( ) { if ( ! display . cursor . offsetHeight ) return ; display . cursor . style . visibility = display . otherCursor . style . visibility = ( on = ! on ) ? "" : "hidden" ; } , cm . options . cursorBlinkRate ) ; } 
function startWorker ( cm , time ) { if ( cm . view . frontier < cm . display . showingTo ) cm . view . highlight . set ( time , bind ( highlightWorker , cm ) ) ; } 
function intoCoordSystem ( cm , lineObj , rect , context ) { if ( lineObj . widgets ) for ( var i = 0 ; i < lineObj . widgets . length ; ++ i ) if ( lineObj . widgets [ i ] . above ) { var size = lineObj . widgets [ i ] . node . offsetHeight ; rect . top += size ; rect . bottom += size ; } if ( context == "line" ) return rect ; if ( ! context ) context = "local" ; var yOff = heightAtLine ( cm , lineObj ) ; if ( context != "local" ) yOff -= cm . display . viewOffset ; if ( context == "page" ) { var lOff = cm . display . lineSpace . getBoundingClientRect ( ) ; yOff += lOff . top + ( window . pageYOffset || ( document . documentElement || document . body ) . scrollTop ) ; var xOff = lOff . left + ( window . pageXOffset || ( document . documentElement || document . body ) . scrollLeft ) ; rect . left += xOff ; rect . right += xOff ; } rect . top += yOff ; rect . bottom += yOff ; return rect ; } 
function coordsChar ( cm , x , y ) { var doc = cm . view . doc ; y += cm . display . viewOffset ; if ( y < 0 ) return { line : 0 , ch : 0 , outside : true } ; var lineNo = lineAtHeight ( doc , y ) ; if ( lineNo >= doc . size ) return { line : doc . size - 1 , ch : getLine ( doc , doc . size - 1 ) . text . length } ; if ( x < 0 ) x = 0 ; for ( ; ; ) { var lineObj = getLine ( doc , lineNo ) ; var found = coordsCharInner ( cm , lineObj , lineNo , x , y ) ; var merged = collapsedSpanAtEnd ( lineObj ) ; if ( merged && found . ch == lineRight ( lineObj ) ) lineNo = merged . find ( ) . to . line ; else return found ; } } 
function startOperation ( cm ) { if ( cm . curOp ) ++ cm . curOp . depth ; else cm . curOp = { 
function readInput ( cm ) { var input = cm . display . input , prevInput = cm . display . prevInput , view = cm . view , sel = view . sel ; if ( ! view . focused || hasSelection ( input ) || isReadOnly ( cm ) ) return false ; var text = input . value ; if ( text == prevInput && posEq ( sel . from , sel . to ) ) return false ; startOperation ( cm ) ; view . sel . shift = false ; var same = 0 , l = Math . min ( prevInput . length , text . length ) ; while ( same < l && prevInput [ same ] == text [ same ] ) ++ same ; var from = sel . from , to = sel . to ; if ( same < prevInput . length ) from = { line : from . line , ch : from . ch - ( prevInput . length - same ) } ; else if ( view . overwrite && posEq ( from , to ) && ! cm . display . pasteIncoming ) to = { line : to . line , ch : Math . min ( getLine ( cm . view . doc , to . line ) . text . length , to . ch + ( text . length - same ) ) } ; var updateInput = cm . curOp . updateInput ; updateDoc ( cm , from , to , splitLines ( text . slice ( same ) ) , "end" , cm . display . pasteIncoming ? "paste" : "input" , { from : from , to : to } ) ; cm . curOp . updateInput = updateInput ; if ( text . length > 1000 ) input . value = cm . display . prevInput = "" ; else cm . display . prevInput = text ; endOperation ( cm ) ; cm . display . pasteIncoming = false ; return true ; } 
function registerEventHandlers ( cm ) { var d = cm . display ; on ( d . scroller , "mousedown" , operation ( cm , onMouseDown ) ) ; on ( d . scroller , "dblclick" , operation ( cm , e_preventDefault ) ) ; on ( d . lineSpace , "selectstart" , function ( e ) { if ( ! mouseEventInWidget ( d , e ) ) e_preventDefault ( e ) ; } ) ; 
function updateDoc ( cm , from , to , newText , selUpdate , origin ) { 
function setSelection ( cm , anchor , head , bias , checkAtomic ) { cm . view . goalColumn = null ; var sel = cm . view . sel ; 
function ( pos ) { var doc = this . view . doc ; pos = clipPos ( doc , pos ) ; var state = getStateBefore ( this , pos . line ) , mode = this . view . mode ; var line = getLine ( doc , pos . line ) ; var stream = new StringStream ( line . text , this . options . tabSize ) ; while ( stream . pos < pos . ch && ! stream . eol ( ) ) { stream . start = stream . pos ; var style = mode . token ( stream , state ) ; } return { start : stream . start , end : stream . pos , string : stream . current ( ) , className : style || null , 
function makeLine ( text , markedSpans , height ) { var line = { text : text , height : height } ; attachMarkedSpans ( line , markedSpans ) ; if ( lineIsHidden ( line ) ) line . height = 0 ; return line ; } 
function highlightLine ( cm , line , state ) { var mode = cm . view . mode , flattenSpans = cm . options . flattenSpans ; var changed = ! line . styles , pos = 0 , curText = "" , curStyle = null ; var stream = new StringStream ( line . text , cm . options . tabSize ) , st = line . styles || ( line . styles = [ ] ) ; if ( line . text == "" && mode . blankLine ) mode . blankLine ( state ) ; while ( ! stream . eol ( ) ) { var style = mode . token ( stream , state ) , substr = stream . current ( ) ; stream . start = stream . pos ; if ( ! flattenSpans || curStyle != style ) { if ( curText ) { changed = changed || pos >= st . length || curText != st [ pos ] || curStyle != st [ pos + 1 ] ; st [ pos ++ ] = curText ; st [ pos ++ ] = curStyle ; } curText = substr ; curStyle = style ; } else curText = curText + substr ; 
function e_prop ( e , prop ) { var overridden = e . override && e . override . hasOwnProperty ( prop ) ; return overridden ? e . override [ prop ] : e [ prop ] ; } 
function moveVisually ( line , start , dir , byUnit ) { var bidi = getOrder ( line ) ; if ( ! bidi ) return moveLogically ( line , start , dir , byUnit ) ; var moveOneUnit = byUnit ? function ( pos , dir ) { do pos += dir ; while ( pos > 0 && isExtendingChar . test ( line . text . charAt ( pos ) ) ) ; return pos ; } : function ( pos , dir ) { return pos + dir ; } ; var linedir = bidi [ 0 ] . level ; for ( var i = 0 ; i < bidi . length ; ++ i ) { var part = bidi [ i ] , sticky = part . level % 2 == linedir ; if ( ( part . from < start && part . to > start ) || ( sticky && ( part . from == start || part . to == start ) ) ) break ; } var target = moveOneUnit ( start , part . level % 2 ? - dir : dir ) ; while ( target != null ) { if ( part . level % 2 == linedir ) { if ( target < part . from || target > part . to ) { part = bidi [ i += dir ] ; target = part && ( dir > 0 == part . level % 2 ? moveOneUnit ( part . to , - 1 ) : moveOneUnit ( part . from , 1 ) ) ; } else break ; } else { if ( target == bidiLeft ( part ) ) { part = bidi [ -- i ] ; target = part && bidiRight ( part ) ; } else if ( target == bidiRight ( part ) ) { part = bidi [ ++ i ] ; target = part && bidiLeft ( part ) ; } else break ; } } return target < 0 || target > line . text . length ? null : target ; } 
function Flow ( opts ) { this . support = ( typeof File !== 'undefined' && typeof Blob !== 'undefined' && typeof FileList !== 'undefined' && ( ! ! Blob . prototype . slice || ! ! Blob . prototype . webkitSlice || ! ! Blob . prototype . mozSlice || false ) * Check if directory upload is supported * @type {boolean} */ this . supportDirectory = ( / Chrome / . test ( window . navigator . userAgent ) || / Firefox / . test ( window . navigator . userAgent ) || / Edge / . test ( window . navigator . userAgent ) ) ; this . files = [ ] ; this . defaults = { chunkSize : 1024 * 1024 , forceChunkSize : false , simultaneousUploads : 3 , singleFile : false , fileParameterName : 'file' , progressCallbacksInterval : 500 , speedSmoothingFactor : 0.1 , query : { } , headers : { } , withCredentials : false , preprocess : null , method : 'multipart' , testMethod : 'GET' , uploadMethod : 'POST' , prioritizeFirstAndLastChunk : false , allowDuplicateUploads : false , target : '/' , testChunks : true , generateUniqueIdentifier : null , maxChunkRetries : 0 , chunkRetryInterval : null , permanentErrors : [ 404 , 413 , 415 , 500 , 501 ] , successStatuses : [ 200 , 201 , 202 ] , onDropStopPropagation : false , initFileFn : null , readFileFn : webAPIFileRead } ; this . opts = { } ; this . events = { } ; var $ = this ; this . onDrop = function ( event ) { if ( $ . opts . onDropStopPropagation ) { event . stopPropagation ( ) ; } event . preventDefault ( ) ; var dataTransfer = event . dataTransfer ; if ( dataTransfer . items && dataTransfer . items [ 0 ] && dataTransfer . items [ 0 ] . webkitGetAsEntry ) { $ . webkitReadDataTransfer ( event ) ; } else { $ . addFiles ( dataTransfer . files , event ) ; } } ; this . preventEvent = function ( event ) { event . preventDefault ( ) ; } ; this . opts = Flow . extend ( { } , this . defaults , opts || { } ) ; } 
function ( event , callback ) { event = event . toLowerCase ( ) ; if ( ! this . events . hasOwnProperty ( event ) ) { this . events [ event ] = [ ] ; } this . events [ event ] . push ( callback ) ; } 
function ( event , fn ) { if ( event !== undefined ) { event = event . toLowerCase ( ) ; if ( fn !== undefined ) { if ( this . events . hasOwnProperty ( event ) ) { arrayRemove ( this . events [ event ] , fn ) ; } } else { delete this . events [ event ] ; } } else { this . events = { } ; } } 
function ( event , args ) { 
function ( event ) { var $ = this ; var queue = event . dataTransfer . items . length ; var files = [ ] ; each ( event . dataTransfer . items , function ( item ) { var entry = item . webkitGetAsEntry ( ) ; if ( ! entry ) { decrement ( ) ; return ; } if ( entry . isFile ) { 
function ( file ) { var custom = this . opts . generateUniqueIdentifier ; if ( typeof custom === 'function' ) { return custom ( file ) ; } 
function ( preventEvents ) { 
function ( domNodes , isDirectory , singleFile , attributes ) { if ( domNodes instanceof Element ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { var input ; if ( domNode . tagName === 'INPUT' && domNode . type === 'file' ) { input = domNode ; } else { input = document . createElement ( 'input' ) ; input . setAttribute ( 'type' , 'file' ) ; 
function ( domNodes ) { if ( typeof domNodes . length === 'undefined' ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { domNode . addEventListener ( 'dragover' , this . preventEvent , false ) ; domNode . addEventListener ( 'dragenter' , this . preventEvent , false ) ; domNode . addEventListener ( 'drop' , this . onDrop , false ) ; } , this ) ; } 
function ( domNodes ) { if ( typeof domNodes . length === 'undefined' ) { domNodes = [ domNodes ] ; } each ( domNodes , function ( domNode ) { domNode . removeEventListener ( 'dragover' , this . preventEvent ) ; domNode . removeEventListener ( 'dragenter' , this . preventEvent ) ; domNode . removeEventListener ( 'drop' , this . onDrop ) ; } , this ) ; } 
function ( ) { var uploading = false ; each ( this . files , function ( file ) { if ( file . isUploading ( ) ) { uploading = true ; return false ; } } ) ; return uploading ; } 
function ( ) { var num = 0 ; var should = true ; var simultaneousUploads = this . opts . simultaneousUploads ; each ( this . files , function ( file ) { each ( file . chunks , function ( chunk ) { if ( chunk . status ( ) === 'uploading' ) { num ++ ; if ( num >= simultaneousUploads ) { should = false ; return false ; } } } ) ; } ) ; 
function ( ) { 
function ( fileList , event ) { var files = [ ] ; each ( fileList , function ( file ) { 
function ( file ) { for ( var i = this . files . length - 1 ; i >= 0 ; i -- ) { if ( this . files [ i ] === file ) { this . files . splice ( i , 1 ) ; file . abort ( ) ; this . fire ( 'fileRemoved' , file ) ; } } } 
function ( uniqueIdentifier ) { var ret = false ; each ( this . files , function ( file ) { if ( file . uniqueIdentifier === uniqueIdentifier ) { ret = file ; } } ) ; return ret ; } 
function ( ) { var sizeDelta = 0 ; var averageSpeed = 0 ; each ( this . files , function ( file ) { if ( ! file . paused && ! file . error ) { sizeDelta += file . size - file . sizeUploaded ( ) ; averageSpeed += file . averageSpeed ; } } ) ; if ( sizeDelta && ! averageSpeed ) { return Number . POSITIVE_INFINITY ; } if ( ! sizeDelta && ! averageSpeed ) { return 0 ; } return Math . floor ( sizeDelta / averageSpeed ) ; } 
function FlowFile ( flowObj , file , uniqueIdentifier ) { this . flowObj = flowObj ; this . bytes = null ; this . file = file ; this . name = file . fileName || file . name ; this . size = file . size ; this . relativePath = file . relativePath || file . webkitRelativePath || this . name ; this . uniqueIdentifier = ( uniqueIdentifier === undefined ? flowObj . generateUniqueIdentifier ( file ) : uniqueIdentifier ) ; this . chunks = [ ] ; this . paused = false ; this . error = false ; this . averageSpeed = 0 ; this . currentSpeed = 0 ; this . _lastProgressCallback = Date . now ( ) ; this . _prevUploadedSize = 0 ; this . _prevProgress = 0 ; this . bootstrap ( ) ; } 
function ( ) { var timeSpan = Date . now ( ) - this . _lastProgressCallback ; if ( ! timeSpan ) { return ; } var smoothingFactor = this . flowObj . opts . speedSmoothingFactor ; var uploaded = this . sizeUploaded ( ) ; 
function ( chunk , event , message ) { switch ( event ) { case 'progress' : if ( Date . now ( ) - this . _lastProgressCallback < this . flowObj . opts . progressCallbacksInterval ) { break ; } this . measureSpeed ( ) ; this . flowObj . fire ( 'fileProgress' , this , chunk ) ; this . flowObj . fire ( 'progress' ) ; this . _lastProgressCallback = Date . now ( ) ; break ; case 'error' : this . error = true ; this . abort ( true ) ; this . flowObj . fire ( 'fileError' , this , message , chunk ) ; this . flowObj . fire ( 'error' , message , this , chunk ) ; break ; case 'success' : if ( this . error ) { return ; } this . measureSpeed ( ) ; this . flowObj . fire ( 'fileProgress' , this , chunk ) ; this . flowObj . fire ( 'progress' ) ; this . _lastProgressCallback = Date . now ( ) ; if ( this . isComplete ( ) ) { this . currentSpeed = 0 ; this . averageSpeed = 0 ; this . flowObj . fire ( 'fileSuccess' , this , message , chunk ) ; } break ; case 'retry' : this . flowObj . fire ( 'fileRetry' , this , chunk ) ; break ; } } 
function ( reset ) { this . currentSpeed = 0 ; this . averageSpeed = 0 ; var chunks = this . chunks ; if ( reset ) { this . chunks = [ ] ; } each ( chunks , function ( c ) { if ( c . status ( ) === 'uploading' ) { c . abort ( ) ; this . flowObj . uploadNextChunk ( ) ; } } , this ) ; } 
function ( ) { if ( typeof this . flowObj . opts . initFileFn === "function" ) { this . flowObj . opts . initFileFn ( this ) ; } this . abort ( true ) ; this . error = false ; 
function ( ) { if ( this . error ) { return 1 ; } if ( this . chunks . length === 1 ) { this . _prevProgress = Math . max ( this . _prevProgress , this . chunks [ 0 ] . progress ( ) ) ; return this . _prevProgress ; } 
function ( ) { var outstanding = false ; each ( this . chunks , function ( chunk ) { var status = chunk . status ( ) ; if ( status === 'pending' || status === 'uploading' || status === 'reading' || chunk . preprocessState === 1 || chunk . readState === 1 ) { outstanding = true ; return false ; } } ) ; return ! outstanding ; } 
function ( ) { if ( this . paused || this . error ) { return 0 ; } var delta = this . size - this . sizeUploaded ( ) ; if ( delta && ! this . averageSpeed ) { return Number . POSITIVE_INFINITY ; } if ( ! delta && ! this . averageSpeed ) { return 0 ; } return Math . floor ( delta / this . averageSpeed ) ; } 
function webAPIFileRead ( fileObj , startByte , endByte , fileType , chunk ) { var function_name = 'slice' ; if ( fileObj . file . slice ) function_name = 'slice' ; else if ( fileObj . file . mozSlice ) function_name = 'mozSlice' ; else if ( fileObj . file . webkitSlice ) function_name = 'webkitSlice' ; chunk . readFinished ( fileObj . file [ function_name ] ( startByte , endByte , fileType ) ) ; } 
function FlowChunk ( flowObj , fileObj , offset ) { this . flowObj = flowObj ; this . fileObj = fileObj ; this . offset = offset ; this . tested = false ; this . retries = 0 ; this . pendingRetry = false ; this . preprocessState = 0 ; this . readState = 0 ; this . loaded = 0 ; this . total = 0 ; this . chunkSize = this . flowObj . opts . chunkSize ; this . startByte = this . offset * this . chunkSize ; this . computeEndByte = function ( ) { var endByte = Math . min ( this . fileObj . size , ( this . offset + 1 ) * this . chunkSize ) ; if ( this . fileObj . size - endByte < this . chunkSize && ! this . flowObj . opts . forceChunkSize ) { * Chunk end byte in a file * @type {number} */ this . endByte = this . computeEndByte ( ) ; this . xhr = null ; var $ = this ; this . event = function ( event , args ) { args = Array . prototype . slice . call ( arguments ) ; args . unshift ( $ ) ; $ . fileObj . chunkEvent . apply ( $ . fileObj , args ) ; } ; this . progressHandler = function ( event ) { if ( event . lengthComputable ) { $ . loaded = event . loaded ; $ . total = event . total ; } $ . event ( 'progress' , event ) ; } ; this . testHandler = function ( event ) { var status = $ . status ( true ) ; if ( status === 'error' ) { $ . event ( status , $ . message ( ) ) ; $ . flowObj . uploadNextChunk ( ) ; } else if ( status === 'success' ) { $ . tested = true ; $ . event ( status , $ . message ( ) ) ; $ . flowObj . uploadNextChunk ( ) ; } else if ( ! $ . fileObj . paused ) { * Upload has stopped * @param {Event} event */ this . doneHandler = function ( event ) { var status = $ . status ( ) ; if ( status === 'success' || status === 'error' ) { delete this . data ; $ . event ( status , $ . message ( ) ) ; $ . flowObj . uploadNextChunk ( ) ; } else { $ . event ( 'retry' , $ . message ( ) ) ; $ . pendingRetry = true ; $ . abort ( ) ; $ . retries ++ ; var retryInterval = $ . flowObj . opts . chunkRetryInterval ; if ( retryInterval !== null ) { setTimeout ( function ( ) { $ . send ( ) ; } , retryInterval ) ; } else { $ . send ( ) ; } } } ; } 
function ( ) { 
function ( ) { var preprocess = this . flowObj . opts . preprocess ; var read = this . flowObj . opts . readFileFn ; if ( typeof preprocess === 'function' ) { switch ( this . preprocessState ) { case 0 : this . preprocessState = 1 ; preprocess ( this ) ; return ; case 1 : return ; } } switch ( this . readState ) { case 0 : this . readState = 1 ; read ( this . fileObj , this . startByte , this . endByte , this . fileObj . file . type , this ) ; return ; case 1 : return ; } if ( this . flowObj . opts . testChunks && ! this . tested ) { this . test ( ) ; return ; } this . loaded = 0 ; this . total = 0 ; this . pendingRetry = false ; 
function ( isTest ) { if ( this . readState === 1 ) { return 'reading' ; } else if ( this . pendingRetry || this . preprocessState === 1 ) { 
function ( method , isTest , paramsMethod , blob ) { 
function evalOpts ( data , args ) { if ( typeof data === "function" ) { 
function extend ( dst , src ) { each ( arguments , function ( obj ) { if ( obj !== dst ) { each ( obj , function ( value , key ) { dst [ key ] = value ; } ) ; } } ) ; return dst ; } 
function each ( obj , callback , context ) { if ( ! obj ) { return ; } var key ; 
function createTable ( ) { tableName = arguments [ 0 ] ; var fname = '' ; var callback ; if ( arguments . length === 2 ) { callback = arguments [ 1 ] ; fname = path . join ( userData , tableName + '.json' ) ; } else if ( arguments . length === 3 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 2 ] ; } 
function valid ( ) { var fName = '' if ( arguments . length == 2 ) { 
function insertTableContent ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var tableRow ; if ( arguments . length === 3 ) { callback = arguments [ 2 ] ; fname = path . join ( userData , arguments [ 0 ] + '.json' ) ; tableRow = arguments [ 1 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; tableRow = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { 
function getAll ( ) { var fname = '' ; var callback ; var tableName = arguments [ 0 ] ; if ( arguments . length === 2 ) { fname = path . join ( userData , tableName + '.json' ) ; callback = arguments [ 1 ] ; } else if ( arguments . length === 3 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { try { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; callback ( true , table [ tableName ] ) ; return ; } catch ( e ) { callback ( false , [ ] ) ; return ; } } else { callback ( false , 'Table file does not exist!' ) ; return ; } } 
function getField ( ) { let fname = '' let tableName = arguments [ 0 ] let callback let key if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; callback = arguments [ 2 ] ; key = arguments [ 1 ] } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; key = arguments [ 2 ] } let exists = fs . existsSync ( fname ) if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; const rows = table [ tableName ] let data = [ ] for ( let i = 0 ; i < rows . length ; i ++ ) { if ( rows [ i ] . hasOwnProperty ( key ) ) { data . push ( rows [ i ] [ key ] ) } } callback ( true , data ) } else { callback ( false , 'The table you are trying to access does not exist.' ) return } } 
function count ( ) { let tableName = arguments [ 0 ] let callback if ( arguments . length === 2 ) { callback = arguments [ 1 ] getAll ( tableName , ( succ , data ) => { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else if ( arguments . length === 3 ) { callback = arguments [ 2 ] getAll ( tableName , arguments [ 1 ] , ( succ , data ) => { if ( succ ) { callback ( true , data . length ) return } else { callback ( false , data ) return } } ) } else { callback ( false , 'Wrong number of arguments. Must be either 2 or 3 arguments including callback function.' ) return } } 
function getRows ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var where ; if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; callback = arguments [ 2 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; callback = arguments [ 3 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys ; 
function updateRow ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var where ; var set ; var callback ; if ( arguments . length === 4 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; set = arguments [ 2 ] ; callback = arguments [ 3 ] ; } else if ( arguments . length === 5 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; set = arguments [ 3 ] ; callback = arguments [ 4 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys = Object . keys ( where ) ; let setKeys = Object . keys ( set ) ; if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; let matched = 0 ; 
function search ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var field ; var keyword ; var callback ; if ( arguments . length === 4 ) { fname = path . join ( userData , tableName + '.json' ) ; field = arguments [ 1 ] ; keyword = arguments [ 2 ] ; callback = arguments [ 3 ] ; } else if ( arguments . length === 5 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; field = arguments [ 2 ] ; keyword = arguments [ 3 ] ; callback = arguments [ 4 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; if ( rows . length > 0 ) { 
function createHeaderGetter ( str ) { var name = str . toLowerCase ( ) return function ( req , res ) { 
function assignNotNull ( target , ... sources ) { sources . forEach ( source => { Object . keys ( source ) . forEach ( key => { if ( source [ key ] != null ) { target [ key ] = source [ key ] ; } } ) } ) ; return target ; } 
function Layer ( options ) { this . options = { } ; if ( options != null ) { [ "resourceType" , "type" , "publicId" , "format" ] . forEach ( ( function ( _this ) { return function ( key ) { var ref ; return _this . options [ key ] = ( ref = options [ key ] ) != null ? ref : options [ Util . snakeCase ( key ) ] ; } ; } ) ( this ) ) ; } } 
function Param ( name , shortName , process ) { if ( process == null ) { process = cloudinary . Util . identity ; } this . name = name ; this . shortName = shortName ; this . process = process ; } 
function ArrayParam ( name , shortName , sep , process ) { if ( sep == null ) { sep = '.' ; } this . sep = sep ; ArrayParam . __super__ . constructor . call ( this , name , shortName , process ) ; } 
function TransformationParam ( name , shortName , sep , process ) { if ( shortName == null ) { shortName = "t" ; } if ( sep == null ) { sep = '.' ; } this . sep = sep ; TransformationParam . __super__ . constructor . call ( this , name , shortName , process ) ; } 
function RangeParam ( name , shortName , process ) { if ( process == null ) { process = this . norm_range_value ; } RangeParam . __super__ . constructor . call ( this , name , shortName , process ) ; } 
function Expression ( expressionStr ) { this . expressions = [ ] ; if ( expressionStr != null ) { this . expressions . push ( Expression . normalize ( expressionStr ) ) ; } } 
function Configuration ( options ) { if ( options == null ) { options = { } ; } this . configuration = Util . cloneDeep ( options ) ; Util . defaults ( this . configuration , DEFAULT_CONFIGURATION_PARAMS ) ; } 
function TransformationBase ( options ) { var parent , trans ; if ( options == null ) { options = { } ; } parent = void 0 ; trans = { } ; this . toOptions || ( this . toOptions = function ( withChain ) { var key , list , opt , ref , ref1 , tr , value ; if ( withChain == null ) { withChain = true ; } opt = { } ; for ( key in trans ) { value = trans [ key ] ; opt [ key ] = value . origValue ; } ref = this . otherOptions ; for ( key in ref ) { value = ref [ key ] ; if ( value !== void 0 ) { opt [ key ] = value ; } } if ( withChain && ! Util . isEmpty ( this . chained ) ) { list = ( function ( ) { var j , len , ref1 , results ; ref1 = this . chained ; results = [ ] ; for ( j = 0 , len = ref1 . length ; j < len ; j ++ ) { tr = ref1 [ j ] ; results . push ( tr . toOptions ( ) ) ; } return results ; } ) . call ( this ) ; list . push ( opt ) ; opt = { } ; ref1 = this . otherOptions ; for ( key in ref1 ) { value = ref1 [ key ] ; if ( value !== void 0 ) { opt [ key ] = value ; } } opt . transformation = list ; } return opt ; } ) ; this . setParent || ( this . setParent = function ( object ) { parent = object ; if ( object != null ) { this . fromOptions ( typeof object . toOptions === "function" ? object . toOptions ( ) : void 0 ) ; } return this ; } ) ; this . getParent || ( this . getParent = function ( ) { return parent ; } ) ; this . param || ( this . param = function ( value , name , abbr , defaultValue , process ) { if ( process == null ) { if ( Util . isFunction ( defaultValue ) ) { process = defaultValue ; } else { process = Util . identity ; } } trans [ name ] = new Param ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . rawParam || ( this . rawParam = function ( value , name , abbr , defaultValue , process ) { if ( process == null ) { process = Util . identity ; } process = lastArgCallback ( arguments ) ; trans [ name ] = new RawParam ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . rangeParam || ( this . rangeParam = function ( value , name , abbr , defaultValue , process ) { if ( process == null ) { process = Util . identity ; } process = lastArgCallback ( arguments ) ; trans [ name ] = new RangeParam ( name , abbr , process ) . set ( value ) ; return this ; } ) ; this . arrayParam || ( this . arrayParam = function ( value , name , abbr , sep , defaultValue , process ) { if ( sep == null ) { sep = ":" ; } if ( defaultValue == null ) { defaultValue = [ ] ; } if ( process == null ) { process = Util . identity ; } process = lastArgCallback ( arguments ) ; trans [ name ] = new ArrayParam ( name , abbr , sep , process ) . set ( value ) ; return this ; } ) ; this . transformationParam || ( this . transformationParam = function ( value , name , abbr , sep , defaultValue , process ) { if ( sep == null ) { sep = "." ; } if ( process == null ) { process = Util . identity ; } process = lastArgCallback ( arguments ) ; trans [ name ] = new TransformationParam ( name , abbr , sep , process ) . set ( value ) ; return this ; } ) ; this . layerParam || ( this . layerParam = function ( value , name , abbr ) { trans [ name ] = new LayerParam ( name , abbr ) . set ( value ) ; return this ; } ) ; this . getValue || ( this . getValue = function ( name ) { var ref , ref1 ; return ( ref = ( ref1 = trans [ name ] ) != null ? ref1 . value ( ) : void 0 ) != null ? ref : this . otherOptions [ name ] ; } ) ; this . get || ( this . get = function ( name ) { return trans [ name ] ; } ) ; this . remove || ( this . remove = function ( name ) { var temp ; switch ( false ) { case trans [ name ] == null : temp = trans [ name ] ; delete trans [ name ] ; return temp . origValue ; case this . otherOptions [ name ] == null : temp = this . otherOptions [ name ] ; delete this . otherOptions [ name ] ; return temp ; default : return null ; } } ) ; this . keys || ( this . keys = function ( ) { var key ; return ( ( function ( ) { var results ; results = [ ] ; for ( key in trans ) { if ( key != null ) { results . push ( key . match ( VAR_NAME_RE ) ? key : Util . snakeCase ( key ) ) ; } } return results ; } ) ( ) ) . sort ( ) ; } ) ; this . toPlainObject || ( this . toPlainObject = function ( ) { var hash , key , list , tr ; hash = { } ; for ( key in trans ) { hash [ key ] = trans [ key ] . value ( ) ; if ( Util . isPlainObject ( hash [ key ] ) ) { hash [ key ] = Util . cloneDeep ( hash [ key ] ) ; } } if ( ! Util . isEmpty ( this . chained ) ) { list = ( function ( ) { var j , len , ref , results ; ref = this . chained ; results = [ ] ; for ( j = 0 , len = ref . length ; j < len ; j ++ ) { tr = ref [ j ] ; results . push ( tr . toPlainObject ( ) ) ; } return results ; } ) . call ( this ) ; list . push ( hash ) ; hash = { transformation : list } ; } return hash ; } ) ; this . chain || ( this . chain = function ( ) { var names , tr ; names = Object . getOwnPropertyNames ( trans ) ; if ( names . length !== 0 ) { tr = new this . constructor ( this . toOptions ( false ) ) ; this . resetTransformations ( ) ; this . chained . push ( tr ) ; } return this ; } ) ; this . resetTransformations || ( this . resetTransformations = function ( ) { trans = { } ; return this ; } ) ; this . otherOptions || ( this . otherOptions = { } ) ; this . chained = [ ] ; if ( ! Util . isEmpty ( options ) ) { this . fromOptions ( options ) ; } } 
function Transformation ( options ) { if ( options == null ) { options = { } ; } Transformation . __super__ . constructor . call ( this , options ) ; this ; } 
function ImageTag ( publicId , options ) { if ( options == null ) { options = { } ; } ImageTag . __super__ . constructor . call ( this , "img" , publicId , options ) ; } 
function VideoTag ( publicId , options ) { if ( options == null ) { options = { } ; } options = Util . defaults ( { } , options , Cloudinary . DEFAULT_VIDEO_PARAMS ) ; VideoTag . __super__ . constructor . call ( this , "video" , publicId . replace ( / \.(mp4|ogv|webm)$ / , '' ) , options ) ; } 
function ClientHintsMetaTag ( options ) { ClientHintsMetaTag . __super__ . constructor . call ( this , 'meta' , void 0 , Util . assign ( { "http-equiv" : "Accept-CH" , content : "DPR, Viewport-Width, Width" } , options ) ) ; } 
function Cloudinary ( options ) { var configuration ; this . devicePixelRatioCache = { } ; this . responsiveConfig = { } ; this . responsiveResizeInitialized = false ; configuration = new Configuration ( options ) ; this . config = function ( newConfig , newValue ) { return configuration . config ( newConfig , newValue ) ; } ; this . fromDocument = function ( ) { configuration . fromDocument ( ) ; return this ; } ; this . fromEnvironment = function ( ) { configuration . fromEnvironment ( ) ; return this ; } ; this . init = function ( ) { configuration . init ( ) ; return this ; } ; } 
function getMode ( env , argv ) { 
function resolveLodash ( context , request , callback ) { if ( / ^lodash\/ / . test ( request ) ) { callback ( null , { commonjs : request , commonjs2 : request , amd : request , root : [ '_' , request . split ( '/' ) [ 1 ] ] } ) ; } else { callback ( ) ; } } 
function baseConfig ( name , mode ) { const config = { name : ` ${ name } ${ mode } ` , mode , output : { library : 'cloudinary' , libraryTarget : 'umd' , globalObject : "this" , pathinfo : false } , optimization : { concatenateModules : true , moduleIds : 'named' , usedExports : true , minimizer : [ new TerserPlugin ( { terserOptions : { mangle : { keep_classnames : true , reserved : reserved , ie8 : true } } , } ) ] } , resolve : { extensions : [ '.js' ] } , externals : [ { jquery : 'jQuery' } ] , node : { Buffer : false , process : false } , devtool : "source-map" , module : { rules : [ { test : / \.m?js$ / , exclude : / (node_modules|bower_components) / , use : { loader : 'babel-loader' } } ] } , plugins : [ new webpack . BannerPlugin ( { banner : ` ${ version } ` , 
function cloudinaryUrlPrefix ( publicId , options ) { var cdnPart , host , path , protocol , ref , subdomain ; if ( ( ( ref = options . cloud_name ) != null ? ref . indexOf ( "/" ) : void 0 ) === 0 ) { return '/res' + options . cloud_name ; } 
function finalizeResourceType ( resourceType = "image" , type = "upload" , urlSuffix , useRootPath , shorten ) { var options ; resourceType = resourceType == null ? "image" : resourceType ; type = type == null ? "upload" : type ; if ( isPlainObject ( resourceType ) ) { options = resourceType ; resourceType = options . resource_type ; type = options . type ; urlSuffix = options . url_suffix ; useRootPath = options . use_root_path ; shorten = options . shorten ; } if ( type == null ) { type = 'upload' ; } if ( urlSuffix != null ) { resourceType = SEO_TYPES [ ` ${ resourceType } ${ type } ` ] ; type = null ; if ( resourceType == null ) { throw new Error ( ` ${ Object . keys ( SEO_TYPES ) . join ( ', ' ) } ` ) ; } } if ( useRootPath ) { if ( resourceType === 'image' && type === 'upload' || resourceType === "images" ) { resourceType = null ; type = null ; } else { throw new Error ( "Root path only supported for image/upload" ) ; } } if ( shorten && resourceType === 'image' && type === 'upload' ) { resourceType = 'iu' ; type = null ; } return [ resourceType , type ] . join ( "/" ) ; } 
function Wheel ( parent , options ) { _classCallCheck ( this , Wheel ) ; var _this = _possibleConstructorReturn ( this , ( Wheel . __proto__ || Object . getPrototypeOf ( Wheel ) ) . call ( this , parent ) ) ; options = options || { } ; _this . percent = options . percent || 0.1 ; _this . center = options . center ; _this . reverse = options . reverse ; _this . smooth = options . smooth ; _this . interrupt = typeof options . interrupt === 'undefined' ? true : options . interrupt ; return _this ; } 
function MouseEdges ( parent , options ) { _classCallCheck ( this , MouseEdges ) ; var _this = _possibleConstructorReturn ( this , ( MouseEdges . __proto__ || Object . getPrototypeOf ( MouseEdges ) ) . call ( this , parent ) ) ; options = options || { } ; _this . options = options ; _this . reverse = options . reverse ? 1 : - 1 ; _this . noDecelerate = options . noDecelerate ; _this . linear = options . linear ; _this . radiusSquared = Math . pow ( options . radius , 2 ) ; _this . resize ( ) ; _this . speed = options . speed || 8 ; return _this ; } 
function Drag ( parent , options ) { _classCallCheck ( this , Drag ) ; options = options || { } ; var _this = _possibleConstructorReturn ( this , ( Drag . __proto__ || Object . getPrototypeOf ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheelActive = utils . defaults ( options . wheel , true ) ; _this . wheelScroll = options . wheelScroll || 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clampWheel = options . clampWheel ; _this . factor = options . factor || 1 ; _this . xDirection = ! options . direction || options . direction === 'all' || options . direction === 'x' ; _this . yDirection = ! options . direction || options . direction === 'all' || options . direction === 'y' ; _this . parseUnderflow ( options . underflow || 'center' ) ; _this . mouseButtons ( options . mouseButtons ) ; return _this ; } 
function SnapZoom ( parent , options ) { _classCallCheck ( this , SnapZoom ) ; var _this = _possibleConstructorReturn ( this , ( SnapZoom . __proto__ || Object . getPrototypeOf ( SnapZoom ) ) . call ( this , parent ) ) ; options = options || { } ; _this . width = options . width ; _this . height = options . height ; if ( _this . width > 0 ) { _this . x_scale = parent . _screenWidth / _this . width ; } if ( _this . height > 0 ) { _this . y_scale = parent . _screenHeight / _this . height ; } _this . xIndependent = utils . exists ( _this . x_scale ) ; _this . yIndependent = utils . exists ( _this . y_scale ) ; _this . x_scale = _this . xIndependent ? _this . x_scale : _this . y_scale ; _this . y_scale = _this . yIndependent ? _this . y_scale : _this . x_scale ; _this . time = utils . defaults ( options . time , 1000 ) ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . center = options . center ; _this . noMove = options . noMove ; _this . stopOnResize = options . stopOnResize ; _this . removeOnInterrupt = options . removeOnInterrupt ; _this . removeOnComplete = utils . defaults ( options . removeOnComplete , true ) ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; if ( _this . time === 0 ) { parent . container . scale . x = _this . x_scale ; parent . container . scale . y = _this . y_scale ; if ( _this . removeOnComplete ) { _this . parent . removePlugin ( 'snap-zoom' ) ; } } else if ( options . forceStart ) { _this . createSnapping ( ) ; } return _this ; } 
function Snap ( parent , x , y , options ) { _classCallCheck ( this , Snap ) ; var _this = _possibleConstructorReturn ( this , ( Snap . __proto__ || Object . getPrototypeOf ( Snap ) ) . call ( this , parent ) ) ; options = options || { } ; _this . friction = options . friction || 0.8 ; _this . time = options . time || 1000 ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . x = x ; _this . y = y ; _this . topLeft = options . topLeft ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; _this . removeOnComplete = options . removeOnComplete ; _this . removeOnInterrupt = options . removeOnInterrupt ; if ( options . forceStart ) { _this . startEase ( ) ; } return _this ; } 
function each ( object , fn ) { keys ( object ) . forEach ( function ( key ) { return fn ( object [ key ] , key ) ; } ) ; } 
function reduce ( object , fn ) { var initial = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 0 ; return keys ( object ) . reduce ( function ( accum , key ) { return fn ( accum , object [ key ] , key ) ; } , initial ) ; } 
function assign ( target ) { for ( var _len = arguments . length , sources = Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { sources [ _key - 1 ] = arguments [ _key ] ; } if ( Object . assign ) { return Object . assign . apply ( Object , [ target ] . concat ( sources ) ) ; } sources . forEach ( function ( source ) { if ( ! source ) { return ; } each ( source , function ( value , key ) { target [ key ] = value ; } ) ; } ) ; return target ; } 
function isPlain ( value ) { return isObject ( value ) && toString . call ( value ) === '[object Object]' && value . constructor === Object ; } 
function logByType ( type , args ) { var stringify = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : ! ! IE_VERSION && IE_VERSION < 11 ; var lvl = log . levels [ level ] ; var lvlRegExp = new RegExp ( '^(' + lvl + ')$' ) ; if ( type !== 'log' ) { 
function computedStyle ( el , prop ) { if ( ! el || ! prop ) { return '' ; } if ( typeof window . getComputedStyle === 'function' ) { var cs = window . getComputedStyle ( el ) ; return cs ? cs [ prop ] : '' ; } return el . currentStyle [ prop ] || '' ; } 
function createEl ( ) { var tagName = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 'div' ; var properties = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var attributes = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; var content = arguments [ 3 ] ; var el = document . createElement ( tagName ) ; Object . getOwnPropertyNames ( properties ) . forEach ( function ( propName ) { var val = properties [ propName ] ; 
function addClass ( element , classToAdd ) { if ( element . classList ) { element . classList . add ( classToAdd ) ; 
function toggleClass ( element , classToToggle , predicate ) { 
function getBoundingClientRect ( el ) { if ( el && el . getBoundingClientRect && el . parentNode ) { var rect = el . getBoundingClientRect ( ) ; var result = { } ; [ 'bottom' , 'height' , 'left' , 'right' , 'top' , 'width' ] . forEach ( function ( k ) { if ( rect [ k ] !== undefined ) { result [ k ] = rect [ k ] ; } } ) ; if ( ! result . height ) { result . height = parseFloat ( computedStyle ( el , 'height' ) ) ; } if ( ! result . width ) { result . width = parseFloat ( computedStyle ( el , 'width' ) ) ; } return result ; } } 
function getPointerPosition ( el , event ) { var position = { } ; var box = findPosition ( el ) ; var boxW = el . offsetWidth ; var boxH = el . offsetHeight ; var boxY = box . top ; var boxX = box . left ; var pageY = event . pageY ; var pageX = event . pageX ; if ( event . changedTouches ) { pageX = event . changedTouches [ 0 ] . pageX ; pageY = event . changedTouches [ 0 ] . pageY ; } position . y = Math . max ( 0 , Math . min ( 1 , ( boxY - pageY + boxH ) / boxH ) ) ; position . x = Math . max ( 0 , Math . min ( 1 , ( pageX - boxX ) / boxW ) ) ; return position ; } 
function appendContent ( el , content ) { normalizeContent ( content ) . forEach ( function ( node ) { return el . appendChild ( node ) ; } ) ; return el ; } 
function getData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { id = el [ elIdAttr ] = newGUID ( ) ; } if ( ! elData [ id ] ) { elData [ id ] = { } ; } return elData [ id ] ; } 
function hasData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { return false ; } return ! ! Object . getOwnPropertyNames ( elData [ id ] ) . length ; } 
function removeData ( el ) { var id = el [ elIdAttr ] ; if ( ! id ) { return ; } 
function _cleanUpEvents ( elem , type ) { var data = getData ( elem ) ; 
function _handleMultipleEvents ( fn , elem , types , callback ) { types . forEach ( function ( type ) { 
function on ( elem , type , fn ) { if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( on , elem , type , fn ) ; } var data = getData ( elem ) ; 
function off ( elem , type , fn ) { 
function one ( elem , type , fn ) { if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( one , elem , type , fn ) ; } var func = function func ( ) { off ( elem , type , func ) ; fn . apply ( this , arguments ) ; } ; 
function autoSetup ( ) { 
function autoSetupTimeout ( wait , vjs ) { if ( vjs ) { videojs$2 = vjs ; } window . setTimeout ( autoSetup , wait ) ; } 
function setTextContent ( el , content ) { if ( el . styleSheet ) { el . styleSheet . cssText = content ; } else { el . textContent = content ; } } 
function bind ( context , fn , uid ) { 
function throttle ( fn , wait ) { var last = Date . now ( ) ; var throttled = function throttled ( ) { var now = Date . now ( ) ; if ( now - last >= wait ) { fn . apply ( undefined , arguments ) ; last = now ; } } ; return throttled ; } 
function isEvented ( object ) { return object instanceof EventTarget || ! ! object . eventBusEl_ && [ 'on' , 'one' , 'off' , 'trigger' ] . every ( function ( k ) { return typeof object [ k ] === 'function' ; } ) ; } 
function isValidEventType ( type ) { return ( 
function normalizeListenArgs ( self , args ) { 
function listen ( target , method , type , listener ) { validateTarget ( target ) ; if ( target . nodeName ) { Events [ method ] ( target , type , listener ) ; } else { target [ method ] ( type , listener ) ; } } 
function on$$1 ( ) { var _this = this ; for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } var _normalizeListenArgs = normalizeListenArgs ( this , args ) , isTargetingSelf = _normalizeListenArgs . isTargetingSelf , target = _normalizeListenArgs . target , type = _normalizeListenArgs . type , listener = _normalizeListenArgs . listener ; listen ( target , 'on' , type , listener ) ; 
function one$$1 ( ) { var _this2 = this ; for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } var _normalizeListenArgs2 = normalizeListenArgs ( this , args ) , isTargetingSelf = _normalizeListenArgs2 . isTargetingSelf , target = _normalizeListenArgs2 . target , type = _normalizeListenArgs2 . type , listener = _normalizeListenArgs2 . listener ; 
function off$$1 ( targetOrType , typeOrListener , listener ) { 
function evented ( target ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var eventBusKey = options . eventBusKey ; 
function setState ( stateUpdates ) { var _this = this ; * An event triggered on an object that is both * {@link module:stateful|stateful} and {@link module:evented|evented} * indicating that its state has changed. * * @event module:stateful~StatefulMixin#statechanged * @type {Object} * @property {Object} changes * A hash containing the properties that were changed and * the values they were changed `from` and `to`. */ this . trigger ( { changes : changes , type : 'statechanged' } ) ; } return changes ; } 
function stateful ( target , defaultState ) { assign ( target , StatefulMixin ) ; 
function mergeOptions ( ) { var result = { } ; for ( var _len = arguments . length , sources = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { sources [ _key ] = arguments [ _key ] ; } sources . forEach ( function ( source ) { if ( ! source ) { return ; } each ( source , function ( value , key ) { if ( ! isPlain ( value ) ) { result [ key ] = value ; return ; } if ( ! isPlain ( result [ key ] ) ) { result [ key ] = { } ; } result [ key ] = mergeOptions ( result [ key ] , value ) ; } ) ; } ) ; return result ; } 
function Component ( player , options , ready ) { classCallCheck ( this , Component ) ; 
function rangeCheck ( fnName , index , maxIndex ) { if ( typeof index !== 'number' || index < 0 || index > maxIndex ) { throw new Error ( 'Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').' ) ; } } 
function getRange ( fnName , valueIndex , ranges , rangeIndex ) { rangeCheck ( fnName , rangeIndex , ranges . length - 1 ) ; return ranges [ rangeIndex ] [ valueIndex ] ; } 
function createTimeRangesObj ( ranges ) { if ( ranges === undefined || ranges . length === 0 ) { return { length : 0 , start : function start ( ) { throw new Error ( 'This TimeRanges object is empty' ) ; } , end : function end ( ) { throw new Error ( 'This TimeRanges object is empty' ) ; } } ; } return { length : ranges . length , start : getRange . bind ( null , 'start' , 0 , ranges ) , end : getRange . bind ( null , 'end' , 1 , ranges ) } ; } 
function createTimeRanges ( start , end ) { if ( Array . isArray ( start ) ) { return createTimeRangesObj ( start ) ; } else if ( start === undefined || end === undefined ) { return createTimeRangesObj ( ) ; } return createTimeRangesObj ( [ [ start , end ] ] ) ; } 
function bufferedPercent ( buffered , duration ) { var bufferedDuration = 0 ; var start = void 0 ; var end = void 0 ; if ( ! duration ) { return 0 ; } if ( ! buffered || ! buffered . length ) { buffered = createTimeRanges ( 0 , 0 ) ; } for ( var i = 0 ; i < buffered . length ; i ++ ) { start = buffered . start ( i ) ; end = buffered . end ( i ) ; 
function MediaError ( value ) { 
function trackToJson_ ( track ) { var ret = [ 'kind' , 'label' , 'language' , 'id' , 'inBandMetadataTrackDispatchType' , 'mode' , 'src' ] . reduce ( function ( acc , prop , i ) { if ( track [ prop ] ) { acc [ prop ] = track [ prop ] ; } return acc ; } , { cues : track . cues && Array . prototype . map . call ( track . cues , function ( cue ) { return { startTime : cue . startTime , endTime : cue . endTime , text : cue . text , id : cue . id } ; } ) } ) ; return ret ; } 
function textTracksToJson ( tech ) { var trackEls = tech . $$ ( 'track' ) ; var trackObjs = Array . prototype . map . call ( trackEls , function ( t ) { return t . track ; } ) ; var tracks = Array . prototype . map . call ( trackEls , function ( trackEl ) { var json = trackToJson_ ( trackEl . track ) ; if ( trackEl . src ) { json . src = trackEl . src ; } return json ; } ) ; return tracks . concat ( Array . prototype . filter . call ( tech . textTracks ( ) , function ( track ) { return trackObjs . indexOf ( track ) === - 1 ; } ) . map ( trackToJson_ ) ) ; } 
function jsonToTextTracks ( json , tech ) { json . forEach ( function ( track ) { var addedTrack = tech . addRemoteTextTrack ( track ) . track ; if ( ! track . src && track . cues ) { track . cues . forEach ( function ( cue ) { return addedTrack . addCue ( cue ) ; } ) ; } } ) ; return tech . textTracks ( ) ; } 
function TrackList ( ) { var tracks = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : [ ] ; var _ret ; var list = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : null ; classCallCheck ( this , TrackList ) ; var _this = possibleConstructorReturn ( this , _EventTarget . call ( this ) ) ; if ( ! list ) { list = _this ; * @memberof TrackList * @member {number} length * The current number of `Track`s in the this Trackist. * @instance */ Object . defineProperty ( list , 'length' , { get : function get$$1 ( ) { return this . tracks_ . length ; } } ) ; for ( var i = 0 ; i < tracks . length ; i ++ ) { list . addTrack ( tracks [ i ] ) ; } 
function AudioTrackList ( ) { var _this , _ret ; var tracks = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : [ ] ; classCallCheck ( this , AudioTrackList ) ; var list = void 0 ; 
function disableOthers ( list , track ) { for ( var i = 0 ; i < list . length ; i ++ ) { if ( ! Object . keys ( list [ i ] ) . length || track . id === list [ i ] . id ) { continue ; } 
function VideoTrackList ( ) { var _this , _ret ; var tracks = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : [ ] ; classCallCheck ( this , VideoTrackList ) ; var list = void 0 ; * @member {number} VideoTrackList#selectedIndex * The current index of the selected {@link VideoTrack`}. */ Object . defineProperty ( list , 'selectedIndex' , { get : function get$$1 ( ) { for ( var _i = 0 ; _i < this . length ; _i ++ ) { if ( this [ _i ] . selected ) { return _i ; } } return - 1 ; } , set : function set$$1 ( ) { } } ) ; return _ret = list , possibleConstructorReturn ( _this , _ret ) ; } 
function TextTrackList ( ) { var _this , _ret ; var tracks = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : [ ] ; classCallCheck ( this , TextTrackList ) ; var list = void 0 ; 
function HtmlTrackElementList ( ) { var trackElements = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : [ ] ; classCallCheck ( this , HtmlTrackElementList ) ; var list = this ; * @memberof HtmlTrackElementList * @member {number} length * The current number of `Track`s in the this Trackist. * @instance */ Object . defineProperty ( list , 'length' , { get : function get$$1 ( ) { return this . trackElements_ . length ; } } ) ; for ( var i = 0 , length = trackElements . length ; i < length ; i ++ ) { list . addTrackElement_ ( trackElements [ i ] ) ; } if ( IS_IE8 ) { return list ; } } 
function TextTrackCueList ( cues ) { classCallCheck ( this , TextTrackCueList ) ; var list = this ; * @memberof TextTrackCueList * @member {number} length * The current number of `TextTrackCue`s in the TextTrackCueList. * @instance */ Object . defineProperty ( list , 'length' , { get : function get$$1 ( ) { return this . length_ ; } } ) ; if ( IS_IE8 ) { return list ; } } 
function getFileExtension ( path ) { if ( typeof path === 'string' ) { var splitPathRe = / ^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$ / i ; var pathParts = splitPathRe . exec ( path ) ; if ( pathParts ) { return pathParts . pop ( ) . toLowerCase ( ) ; } } return '' ; } 
function parseCues ( srcContent , track ) { var parser = new window . WebVTT . Parser ( window , window . vttjs , window . WebVTT . StringDecoder ( ) ) ; var errors = [ ] ; parser . oncue = function ( cue ) { track . addCue ( cue ) ; } ; parser . onparsingerror = function ( error ) { errors . push ( error ) ; } ; parser . onflush = function ( ) { track . trigger ( { type : 'loadeddata' , target : track } ) ; } ; parser . parse ( srcContent ) ; if ( errors . length > 0 ) { if ( window . console && window . console . groupCollapsed ) { window . console . groupCollapsed ( 'Text Track parsing errors for ' + track . src ) ; } errors . forEach ( function ( error ) { return log$1 . error ( error ) ; } ) ; if ( window . console && window . console . groupEnd ) { window . console . groupEnd ( ) ; } } parser . flush ( ) ; } 
function loadTrack ( src , track ) { var opts = { uri : src } ; var crossOrigin = isCrossOrigin ( src ) ; if ( crossOrigin ) { opts . cors = crossOrigin ; } xhr ( opts , bind ( this , function ( err , response , responseBody ) { if ( err ) { return log$1 . error ( err , response ) ; } track . loaded_ = true ; 
function createTrackHelper ( self , kind , label , language ) { var options = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : { } ; var tracks = self . textTracks ( ) ; options . kind = kind ; if ( label ) { options . label = label ; } if ( language ) { options . language = language ; } options . tech = self ; var track = new ALL . text . TrackClass ( options ) ; tracks . addTrack ( track ) ; return track ; } 
function Tech ( ) { var options = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; var ready = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : function ( ) { } ; classCallCheck ( this , Tech ) ; 
function filterSource ( src ) { 
function ClickableComponent ( player , options ) { classCallCheck ( this , ClickableComponent ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . emitTapEvents ( ) ; _this . enable ( ) ; return _this ; } 
function PosterImage ( player , options ) { classCallCheck ( this , PosterImage ) ; var _this = possibleConstructorReturn ( this , _ClickableComponent . call ( this , player , options ) ) ; _this . update ( ) ; player . on ( 'posterchange' , bind ( _this , _this . update ) ) ; return _this ; } 
function constructColor ( color , opacity ) { return 'rgba(' + 
function TextTrackDisplay ( player , options , ready ) { classCallCheck ( this , TextTrackDisplay ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options , ready ) ) ; player . on ( 'loadstart' , bind ( _this , _this . toggleDisplay ) ) ; player . on ( 'texttrackchange' , bind ( _this , _this . updateDisplay ) ) ; player . on ( 'loadstart' , bind ( _this , _this . preselectTrack ) ) ; 
function CloseButton ( player , options ) { classCallCheck ( this , CloseButton ) ; var _this = possibleConstructorReturn ( this , _Button . call ( this , player , options ) ) ; _this . controlText ( options && options . controlText || _this . localize ( 'Close' ) ) ; return _this ; } 
function PlayToggle ( player , options ) { classCallCheck ( this , PlayToggle ) ; var _this = possibleConstructorReturn ( this , _Button . call ( this , player , options ) ) ; _this . on ( player , 'play' , _this . handlePlay ) ; _this . on ( player , 'pause' , _this . handlePause ) ; _this . on ( player , 'ended' , _this . handleEnded ) ; return _this ; } 
function formatTime ( seconds ) { var guide = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : seconds ; seconds = seconds < 0 ? 0 : seconds ; var s = Math . floor ( seconds % 60 ) ; var m = Math . floor ( seconds / 60 % 60 ) ; var h = Math . floor ( seconds / 3600 ) ; var gm = Math . floor ( guide / 60 % 60 ) ; var gh = Math . floor ( guide / 3600 ) ; 
function RemainingTimeDisplay ( player , options ) { classCallCheck ( this , RemainingTimeDisplay ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . throttledUpdateContent = throttle ( bind ( _this , _this . updateContent ) , 25 ) ; _this . on ( player , [ 'timeupdate' , 'durationchange' ] , _this . throttledUpdateContent ) ; return _this ; } 
function LiveDisplay ( player , options ) { classCallCheck ( this , LiveDisplay ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . updateShowing ( ) ; _this . on ( _this . player ( ) , 'durationchange' , _this . updateShowing ) ; return _this ; } 
function Slider ( player , options ) { classCallCheck ( this , Slider ) ; 
function LoadProgressBar ( player , options ) { classCallCheck ( this , LoadProgressBar ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . partEls_ = [ ] ; _this . on ( player , 'progress' , _this . update ) ; return _this ; } 
function MouseTimeDisplay ( player , options ) { classCallCheck ( this , MouseTimeDisplay ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . update = throttle ( bind ( _this , _this . update ) , 25 ) ; return _this ; } 
function SeekBar ( player , options ) { classCallCheck ( this , SeekBar ) ; var _this = possibleConstructorReturn ( this , _Slider . call ( this , player , options ) ) ; _this . update = throttle ( bind ( _this , _this . update ) , 50 ) ; _this . on ( player , [ 'timeupdate' , 'ended' ] , _this . update ) ; return _this ; } 
function ProgressControl ( player , options ) { classCallCheck ( this , ProgressControl ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . handleMouseMove = throttle ( bind ( _this , _this . handleMouseMove ) , 25 ) ; _this . on ( _this . el_ , 'mousemove' , _this . handleMouseMove ) ; _this . throttledHandleMouseSeek = throttle ( bind ( _this , _this . handleMouseSeek ) , 25 ) ; _this . on ( [ 'mousedown' , 'touchstart' ] , _this . handleMouseDown ) ; return _this ; } 
function FullscreenToggle ( player , options ) { classCallCheck ( this , FullscreenToggle ) ; var _this = possibleConstructorReturn ( this , _Button . call ( this , player , options ) ) ; _this . on ( player , 'fullscreenchange' , _this . handleFullscreenChange ) ; return _this ; } 
function checkVolumeSupport ( self , player ) { 
function VolumeBar ( player , options ) { classCallCheck ( this , VolumeBar ) ; var _this = possibleConstructorReturn ( this , _Slider . call ( this , player , options ) ) ; _this . on ( 'slideractive' , _this . updateLastVolume_ ) ; _this . on ( player , 'volumechange' , _this . updateARIAAttributes ) ; player . ready ( function ( ) { return _this . updateARIAAttributes ( ) ; } ) ; return _this ; } 
function VolumeControl ( player ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; classCallCheck ( this , VolumeControl ) ; options . vertical = options . vertical || false ; 
function MuteToggle ( player , options ) { classCallCheck ( this , MuteToggle ) ; 
function VolumePanel ( player ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; classCallCheck ( this , VolumePanel ) ; if ( typeof options . inline !== 'undefined' ) { options . inline = options . inline ; } else { options . inline = true ; } 
function Menu ( player , options ) { classCallCheck ( this , Menu ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; if ( options ) { _this . menuButton_ = options . menuButton ; } _this . focusedChild_ = - 1 ; _this . on ( 'keydown' , _this . handleKeyPress ) ; return _this ; } 
function MenuButton ( player ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; classCallCheck ( this , MenuButton ) ; var _this = possibleConstructorReturn ( this , _Component . call ( this , player , options ) ) ; _this . menuButton_ = new Button ( player , options ) ; _this . menuButton_ . controlText ( _this . controlText_ ) ; _this . menuButton_ . el_ . setAttribute ( 'aria-haspopup' , 'true' ) ; 
function MenuItem ( player , options ) { classCallCheck ( this , MenuItem ) ; var _this = possibleConstructorReturn ( this , _ClickableComponent . call ( this , player , options ) ) ; _this . selectable = options . selectable ; _this . selected ( options . selected ) ; if ( _this . selectable ) { 
function TextTrackMenuItem ( player , options ) { classCallCheck ( this , TextTrackMenuItem ) ; var track = options . track ; var tracks = player . textTracks ( ) ; 
function OffTextTrackMenuItem ( player , options ) { classCallCheck ( this , OffTextTrackMenuItem ) ; 
function TextTrackButton ( player ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; classCallCheck ( this , TextTrackButton ) ; options . tracks = player . textTracks ( ) ; return possibleConstructorReturn ( this , _TrackButton . call ( this , player , options ) ) ; } 
function ChaptersTrackMenuItem ( player , options ) { classCallCheck ( this , ChaptersTrackMenuItem ) ; var track = options . track ; var cue = options . cue ; var currentTime = player . currentTime ( ) ; 
function ChaptersButton ( player , options , ready ) { classCallCheck ( this , ChaptersButton ) ; return possibleConstructorReturn ( this , _TextTrackButton . call ( this , player , options , ready ) ) ; } 
function DescriptionsButton ( player , options , ready ) { classCallCheck ( this , DescriptionsButton ) ; var _this = possibleConstructorReturn ( this , _TextTrackButton . call ( this , player , options , ready ) ) ; var tracks = player . textTracks ( ) ; var changeHandler = bind ( _this , _this . handleTracksChange ) ; tracks . addEventListener ( 'change' , changeHandler ) ; _this . on ( 'dispose' , function ( ) { tracks . removeEventListener ( 'change' , changeHandler ) ; } ) ; return _this ; } 
function SubtitlesButton ( player , options , ready ) { classCallCheck ( this , SubtitlesButton ) ; return possibleConstructorReturn ( this , _TextTrackButton . call ( this , player , options , ready ) ) ; } 
function CaptionSettingsMenuItem ( player , options ) { classCallCheck ( this , CaptionSettingsMenuItem ) ; options . track = { player : player , kind : options . kind , label : options . kind + ' settings' , selectable : false , 'default' : false , mode : 'disabled' } ; 
function CaptionsButton ( player , options , ready ) { classCallCheck ( this , CaptionsButton ) ; return possibleConstructorReturn ( this , _TextTrackButton . call ( this , player , options , ready ) ) ; } 
function AudioTrackMenuItem ( player , options ) { classCallCheck ( this , AudioTrackMenuItem ) ; var track = options . track ; var tracks = player . audioTracks ( ) ; 
function AudioTrackButton ( player ) { var options = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; classCallCheck ( this , AudioTrackButton ) ; options . tracks = player . audioTracks ( ) ; return possibleConstructorReturn ( this , _TrackButton . call ( this , player , options ) ) ; } 
function PlaybackRateMenuItem ( player , options ) { classCallCheck ( this , PlaybackRateMenuItem ) ; var label = options . rate ; var rate = parseFloat ( label , 10 ) ; 
function PlaybackRateMenuButton ( player , options ) { classCallCheck ( this , PlaybackRateMenuButton ) ; var _this = possibleConstructorReturn ( this , _MenuButton . call ( this , player , options ) ) ; _this . updateVisibility ( ) ; _this . updateLabel ( ) ; _this . on ( player , 'loadstart' , _this . updateVisibility ) ; _this . on ( player , 'ratechange' , _this . updateLabel ) ; return _this ; } 
function ErrorDisplay ( player , options ) { classCallCheck ( this , ErrorDisplay ) ; var _this = possibleConstructorReturn ( this , _ModalDialog . call ( this , player , options ) ) ; _this . on ( player , 'error' , _this . open ) ; return _this ; } 
function parseOptionValue ( value , parser ) { if ( parser ) { value = parser ( value ) ; } if ( value && value !== 'none' ) { return value ; } } 
function getSelectedOptionValue ( el , parser ) { var value = el . options [ el . options . selectedIndex ] . value ; return parseOptionValue ( value , parser ) ; } 
function setSelectedOption ( el , value , parser ) { if ( ! value ) { return ; } for ( var i = 0 ; i < el . options . length ; i ++ ) { if ( parseOptionValue ( el . options [ i ] . value , parser ) === value ) { el . selectedIndex = i ; break ; } } } 
function TextTrackSettings ( player , options ) { classCallCheck ( this , TextTrackSettings ) ; options . temporary = false ; var _this = possibleConstructorReturn ( this , _ModalDialog . call ( this , player , options ) ) ; _this . updateDisplay = bind ( _this , _this . updateDisplay ) ; 
function Html5 ( options , ready ) { classCallCheck ( this , Html5 ) ; var _this = possibleConstructorReturn ( this , _Tech . call ( this , options , ready ) ) ; var source = options . source ; var crossoriginTracks = false ; 
function checkProgress ( ) { if ( _this3 . el_ . currentTime > 0 ) { 
function Player ( tag , options , ready ) { classCallCheck ( this , Player ) ; * Store the internal state of scrubbing * * @private * @return {Boolean} True if the user is scrubbing */ _this . scrubbing_ = false ; _this . el_ = _this . createEl ( ) ; 
function findFirstPassingTechSourcePair ( outerArray , innerArray , tester ) { var found = void 0 ; outerArray . some ( function ( outerChoice ) { return innerArray . some ( function ( innerChoice ) { found = tester ( outerChoice , innerChoice ) ; if ( found ) { return true ; } } ) ; } ) ; return found ; } 
function markPluginAsActive ( player , name ) { player [ PLUGIN_CACHE_KEY ] = player [ PLUGIN_CACHE_KEY ] || { } ; player [ PLUGIN_CACHE_KEY ] [ name ] = true ; } 
function triggerSetupEvent ( player , hash , before ) { var eventName = ( before ? 'before' : '' ) + 'pluginsetup' ; player . trigger ( eventName , hash ) ; player . trigger ( eventName + ':' + hash . name , hash ) ; } 
function createBasicPlugin ( name , plugin ) { var basicPluginWrapper = function basicPluginWrapper ( ) { 
function createPluginFactory ( name , PluginSubClass ) { 
function Plugin ( player ) { classCallCheck ( this , Plugin ) ; if ( this . constructor === Plugin ) { throw new Error ( 'Plugin must be sub-classed; not directly instantiated.' ) ; } this . player = player ; 
function videojs ( id , options , ready ) { var tag = void 0 ; 
function ( component , name , animation ) { var html5 = exports var transition = { property : html5 . getPrefixedName ( 'transition-property' ) , delay : html5 . getPrefixedName ( 'transition-delay' ) , duration : html5 . getPrefixedName ( 'transition-duration' ) , timing : html5 . getPrefixedName ( 'transition-timing-function' ) } var element = component . element element . forceLayout ( ) 
function byteCount ( testName , len , baseLen ) { console . log ( testName + " Byte Count: " + len + ( baseLen ? ', ' + Math . round ( len / baseLen * 100 ) + '%' : '' ) ) ; } 
function ( ) { var bytes = this . _messageQueue . reduce ( function ( acc , message ) { if ( typeof message === 'string' ) { acc += message . length ; // not byte size } else if ( message instanceof Blob ) { acc += message . size ; } else { acc += message . byteLength ; } return acc ; } , 0 ) ; return bytes + ( this . _ws ? this . _ws . bufferedAmount : 0 ) ; } 
function ( ) { var colors = [ ] var trs = _$sortableDataList . find ( "li" ) ; for ( var i = 0 ; i < trs . length ; i ++ ) { colors . push ( utils . rgb2hex ( $ ( trs [ i ] ) . find ( ".segmentColor" ) . css ( "background-color" ) ) ) ; } colors = utils . shuffleArray ( colors ) ; _setColors ( colors ) ; } 
function ( moduleID , message , data ) { if ( C . DEBUG ) { console . log ( "[" + moduleID + "] publish(): " , message , data ) ; } for ( var i in _modules ) { var subscriptions = _modules [ i ] . subscriptions ; 
function ( ) { $ ( document ) . on ( "click" , ".selectPage" , function ( e ) { e . preventDefault ( ) ; _selectPage ( this . hash ) ; } ) ; $ ( window ) . on ( "resize" , function ( ) { var width = $ ( window ) . width ( ) ; var height = $ ( window ) . height ( ) ; var breakPoint = _updateBodySizeClass ( width ) ; mediator . publish ( _MODULE_ID , C . EVENT . PAGE . RESIZE , { width : width , height : height , breakPoint : breakPoint } ) ; } ) ; } 
function ( width ) { var breakPointIndex = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i ++ ) { if ( width >= C . OTHER . BREAKPOINTS [ i ] ) { breakPointIndex = i ; } } $ ( "body" ) . removeClass ( "size768 size992 size1200" ) ; var breakPoint = null ; if ( breakPointIndex !== null ) { breakPoint = C . OTHER . BREAKPOINTS [ breakPointIndex ] ; $ ( "body" ) . addClass ( "size" + breakPoint ) ; } return breakPoint ; } 
function ( pageCandidate ) { 
function template ( templateSpec , env ) { if ( ! env ) { throw new Exception ( "No environment passed to template" ) ; } 
function ( partial , name , context , helpers , partials , data ) { var result = env . VM . invokePartial . apply ( this , arguments ) ; if ( result != null ) { return result ; } if ( env . compile ) { var options = { helpers : helpers , partials : partials , data : data } ; partials [ name ] = env . compile ( partial , { data : data !== undefined } , env ) ; return partials [ name ] ( context , options ) ; } else { throw new Exception ( "The partial " + name + " could not be compiled when running in runtime-only mode" ) ; } } 
function ( ) { var hb = new base . HandlebarsEnvironment ( ) ; Utils . extend ( hb , base ) ; hb . SafeString = SafeString ; hb . Exception = Exception ; hb . Utils = Utils ; hb . VM = runtime ; hb . template = function ( spec ) { return runtime . template ( spec , hb ) ; } ; return hb ; } 
function ( parent , name ) { var wrap , ret ; if ( parent . indexOf ( 'depth' ) === 0 ) { wrap = true ; } if ( / ^[0-9]+$ / . test ( name ) ) { ret = parent + "[" + name + "]" ; } else if ( JavaScriptCompiler . isValidJavaScriptVariableName ( name ) ) { ret = parent + "." + name ; } else { ret = parent + "['" + name + "']" ; } if ( wrap ) { return '(' + parent + ' && ' + ret + ')' ; } else { return ret ; } } 
function ( environment , options , context , asObject ) { this . environment = environment ; this . options = options || { } ; log ( 'debug' , this . environment . disassemble ( ) + "\n\n" ) ; this . name = this . environment . name ; this . isChild = ! ! context ; this . context = context || { programs : [ ] , environments : [ ] , aliases : { } } ; this . preamble ( ) ; this . stackSlot = 0 ; this . stackVars = [ ] ; this . registers = { list : [ ] } ; this . hashes = [ ] ; this . compileStack = [ ] ; this . inlineStack = [ ] ; this . compileChildren ( environment , options ) ; var opcodes = environment . opcodes , opcode ; this . i = 0 ; for ( var l = opcodes . length ; this . i < l ; this . i ++ ) { opcode = opcodes [ this . i ] ; if ( opcode . opcode === 'DECLARE' ) { this [ opcode . name ] = opcode . value ; } else { this [ opcode . opcode ] . apply ( this , opcode . args ) ; } 
function ( ) { this . context . aliases . blockHelperMissing = 'helpers.blockHelperMissing' ; var params = [ "depth0" ] ; this . setupParams ( 0 , params ) ; var current = this . topStack ( ) ; params . splice ( 1 , 0 , current ) ; this . pushSource ( "if (!" + this . lastHelper + ") { " + current + " = blockHelperMissing.call(" + params . join ( ", " ) + "); }" ) ; } 
function ( content ) { if ( this . pendingContent ) { content = this . pendingContent + content ; } if ( this . stripNext ) { content = content . replace ( / ^\s+ / , '' ) ; } this . pendingContent = content ; } 
function ( string , type ) { this . pushStackLiteral ( 'depth' + this . lastContext ) ; this . pushString ( type ) ; 
function ( paramSize , name , isRoot ) { this . context . aliases . helperMissing = 'helpers.helperMissing' ; this . useRegister ( 'helper' ) ; var helper = this . lastHelper = this . setupHelper ( paramSize , name , true ) ; var nonHelper = this . nameLookup ( 'depth' + this . lastContext , name , 'context' ) ; var lookup = 'helper = ' + helper . name + ' || ' + nonHelper ; if ( helper . paramsInit ) { lookup += ',' + helper . paramsInit ; } this . push ( '(' + lookup + ',helper ' + '? helper.call(' + helper . callParams + ') ' + ': helperMissing.call(' + helper . helperMissingParams + '))' ) ; 
function ( paramSize , name ) { var helper = this . setupHelper ( paramSize , name ) ; this . push ( helper . name + ".call(" + helper . callParams + ")" ) ; } 
function ( name , helperCall ) { this . context . aliases . functionType = '"function"' ; this . useRegister ( 'helper' ) ; this . emptyHash ( ) ; var helper = this . setupHelper ( 0 , name , helperCall ) ; var helperName = this . lastHelper = this . nameLookup ( 'helpers' , name , 'helper' ) ; var nonHelper = this . nameLookup ( 'depth' + this . lastContext , name , 'context' ) ; var nextStack = this . nextStack ( ) ; if ( helper . paramsInit ) { this . pushSource ( helper . paramsInit ) ; } this . pushSource ( 'if (helper = ' + helperName + ') { ' + nextStack + ' = helper.call(' + helper . callParams + '); }' ) ; this . pushSource ( 'else { helper = ' + nonHelper + '; ' + nextStack + ' = typeof helper === functionType ? helper.call(' + helper . callParams + ') : helper; }' ) ; } 
function ( key ) { var value = this . popStack ( ) , context , type ; if ( this . options . stringParams ) { type = this . popStack ( ) ; context = this . popStack ( ) ; } var hash = this . hash ; if ( context ) { hash . contexts . push ( "'" + key + "': " + context ) ; } if ( type ) { hash . types . push ( "'" + key + "': " + type ) ; } hash . values . push ( "'" + key + "': (" + value + ")" ) ; } 
function ( paramSize , params , useRegister ) { var options = '{' + this . setupOptions ( paramSize , params ) . join ( ',' ) + '}' ; if ( useRegister ) { this . useRegister ( 'options' ) ; params . push ( 'options' ) ; return 'options=' + options ; } else { params . push ( options ) ; return '' ; } } 
function ( msg ) { _canvasWidth = msg . data . config . size . canvasWidth ; _canvasHeight = msg . data . config . size . canvasHeight ; } 
function ( ) { var scope = this ; THREE . Geometry . call ( this ) ; v ( 5 , 0 , 0 ) ; v ( - 5 , - 2 , 1 ) ; v ( - 5 , 0 , 0 ) ; v ( - 5 , - 2 , - 1 ) ; v ( 0 , 2 , - 6 ) ; v ( 0 , 2 , 6 ) ; v ( 2 , 0 , 0 ) ; v ( - 3 , 0 , 0 ) ; f3 ( 0 , 2 , 1 ) ; f3 ( 4 , 7 , 6 ) ; f3 ( 5 , 6 , 7 ) ; this . computeCentroids ( ) ; this . computeFaceNormals ( ) ; function v ( x , y , z ) { scope . vertices . push ( new THREE . Vector3 ( x , y , z ) ) ; } function f3 ( a , b , c ) { scope . faces . push ( new THREE . Face3 ( a , b , c ) ) ; } } 
function ( ) { var vector = new THREE . Vector3 ( ) , _acceleration , _width = 500 , _height = 500 , _depth = 200 , _goal , _neighborhoodRadius = 100 , _maxSpeed = 4 , _maxSteerForce = 0.1 , _avoidWalls = false ; this . position = new THREE . Vector3 ( ) ; this . velocity = new THREE . Vector3 ( ) ; _acceleration = new THREE . Vector3 ( ) ; this . setGoal = function ( target ) { _goal = target ; } ; this . setAvoidWalls = function ( value ) { _avoidWalls = value ; } ; this . setWorldSize = function ( width , height , depth ) { _width = width ; _height = height ; _depth = depth ; } ; this . run = function ( boids ) { if ( _avoidWalls ) { vector . set ( - _width , this . position . y , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( _width , this . position . y , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , - _height , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , _height , this . position . z ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , this . position . y , - _depth ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; vector . set ( this . position . x , this . position . y , _depth ) ; vector = this . avoid ( vector ) ; vector . multiplyScalar ( 5 ) ; _acceleration . add ( vector ) ; } if ( Math . random ( ) > 0.5 ) { this . flock ( boids ) ; } this . move ( ) ; } this . flock = function ( boids ) { if ( _goal ) { _acceleration . add ( this . reach ( _goal , 0.005 ) ) ; } _acceleration . add ( this . alignment ( boids ) ) ; _acceleration . add ( this . cohesion ( boids ) ) ; _acceleration . add ( this . separation ( boids ) ) ; } this . move = function ( ) { this . velocity . add ( _acceleration ) ; var l = this . velocity . length ( ) ; if ( l > _maxSpeed ) { this . velocity . divideScalar ( l / _maxSpeed ) ; } this . position . add ( this . velocity ) ; _acceleration . set ( 0 , 0 , 0 ) ; } this . checkBounds = function ( ) { if ( this . position . x > _width ) this . position . x = - _width ; if ( this . position . x < - _width ) this . position . x = _width ; if ( this . position . y > _height ) this . position . y = - _height ; if ( this . position . y < - _height ) this . position . y = _height ; if ( this . position . z > _depth ) this . position . z = - _depth ; if ( this . position . z < - _depth ) this . position . z = _depth ; } this . avoid = function ( target ) { var steer = new THREE . Vector3 ( ) ; steer . copy ( this . position ) ; steer . sub ( target ) ; steer . multiplyScalar ( 1 / this . position . distanceToSquared ( target ) ) ; return steer ; } this . repulse = function ( target ) { var distance = this . position . distanceTo ( target ) ; if ( distance < 150 ) { var steer = new THREE . Vector3 ( ) ; steer . subVectors ( this . position , target ) ; steer . multiplyScalar ( 0.5 / distance ) ; _acceleration . add ( steer ) ; } } this . reach = function ( target , amount ) { var steer = new THREE . Vector3 ( ) ; steer . subVectors ( target , this . position ) ; steer . multiplyScalar ( amount ) ; return steer ; } this . alignment = function ( boids ) { var boid , velSum = new THREE . Vector3 ( ) , count = 0 ; for ( var i = 0 , il = boids . length ; i < il ; i ++ ) { if ( Math . random ( ) > 0.6 ) continue ; boid = boids [ i ] ; distance = boid . position . distanceTo ( this . position ) ; if ( distance > 0 && distance <= _neighborhoodRadius ) { velSum . add ( boid . velocity ) ; count ++ ; } } if ( count > 0 ) { velSum . divideScalar ( count ) ; var l = velSum . length ( ) ; if ( l > _maxSteerForce ) { velSum . divideScalar ( l / _maxSteerForce ) ; } } return velSum ; } this . cohesion = function ( boids ) { var boid , distance , posSum = new THREE . Vector3 ( ) , steer = new THREE . Vector3 ( ) , count = 0 ; for ( var i = 0 , il = boids . length ; i < il ; i ++ ) { if ( Math . random ( ) > 0.6 ) continue ; boid = boids [ i ] ; distance = boid . position . distanceTo ( this . position ) ; if ( distance > 0 && distance <= _neighborhoodRadius ) { posSum . add ( boid . position ) ; count ++ ; } } if ( count > 0 ) { posSum . divideScalar ( count ) ; } steer . subVectors ( posSum , this . position ) ; var l = steer . length ( ) ; if ( l > _maxSteerForce ) { steer . divideScalar ( l / _maxSteerForce ) ; } return steer ; } this . separation = function ( boids ) { var boid , distance , posSum = new THREE . Vector3 ( ) , repulse = new THREE . Vector3 ( ) ; for ( var i = 0 , il = boids . length ; i < il ; i ++ ) { if ( Math . random ( ) > 0.6 ) continue ; boid = boids [ i ] ; distance = boid . position . distanceTo ( this . position ) ; if ( distance > 0 && distance <= _neighborhoodRadius ) { repulse . subVectors ( this . position , boid . position ) ; repulse . normalize ( ) ; repulse . divideScalar ( distance ) ; posSum . add ( repulse ) ; } } return posSum ; } } 
function ( msg ) { if ( ! _firstPageLoaded ) { _firstPage = msg . data . page ; _firstPageLoaded = true ; if ( _firstPage === "about" ) { setTimeout ( function ( ) { _renderContent ( ) ; var width = $ ( window ) . width ( ) ; var breakPointIndex = null ; for ( var i = 0 ; i < C . OTHER . BREAKPOINTS . length ; i ++ ) { if ( width >= C . OTHER . BREAKPOINTS [ i ] ) { breakPointIndex = i ; } } if ( breakPointIndex === null ) { _handleViewport ( "small" ) ; } } , 10 ) ; } return ; } if ( msg . data . page === "about" ) { if ( ! _isRendered ) { _renderContent ( ) ; } $ ( "#aboutPageSlides" ) . slidesjs ( "refresh" ) ; } } 
function ( number ) { switch ( number ) { case 1 : _demoPie2 . redraw ( ) ; _demoPie3 . redraw ( ) ; break ; case 2 : _demoPie1 . redraw ( ) ; _demoPie3 . redraw ( ) ; break ; case 3 : _demoPie1 . redraw ( ) ; _demoPie2 . redraw ( ) ; break ; } } 
function ( ) { config . template . indexFile . options . data . C = _CONSTANTS . DEV ; config . template . indexFile . options . data . D3PIE_VERSION = packageFile . version ; config . template . devRequireConfig . options . data . handlebarsLib = _CONSTANTS . DEV . HANDLEBARS_LIB ; config . template . devRequireConfig . options . data . baseUrl = _CONSTANTS . DEV . BASE_URL ; var lines = [ ] ; for ( var i in _requireJSModulePaths ) { var file = _requireJSModulePaths [ i ] . replace ( / \.js$ / , "" ) ; lines . push ( '\t\t"' + i + '": "' + file + '"' ) ; } config . template . devRequireConfig . options . data . moduleStr = lines . join ( ",\n" ) ; config . template . constants . options . data . VERSION = packageFile . version ; config . template . constants . options . data . MINIMIZED = _CONSTANTS . DEV . MINIMIZED ; config . template . constants . options . data . DEBUG = _CONSTANTS . DEV . DEBUG ; } 
function ( ) { mediator . register ( _MODULE_ID ) ; var subscriptions = { } ; subscriptions [ C . EVENT . DEMO_PIE . SEND_DATA ] = _onSelectTab ; mediator . subscribe ( _MODULE_ID , subscriptions ) ; } 
function ( allSettings ) { var finalObj = { } ; 
function ( ) { _addTabEventHandlers ( ) ; var config = { hideMainContent : false } ; if ( document . location . hash === "#generator-result" ) { config = { hideMainContent : true } } $ ( "#generator" ) . html ( generatorPageTemplate ( config ) ) ; 
function ( ) { return { header : titleTab . getTabData ( ) , footer : footerTab . getTabData ( ) , size : sizeTab . getTabData ( ) , data : dataTab . getTabData ( ) , labels : labelsTab . getTabData ( ) , tooltips : tooltipsTab . getTabData ( ) , effects : effectsTab . getTabData ( ) , callbacks : eventsTab . getTabData ( ) , misc : miscTab . getTabData ( ) } ; } 
function ( msg ) { if ( ! _firstPageLoaded ) { if ( msg . data . pageHash !== "generator-result" ) { _firstPage = msg . data . page ; } _firstPageLoaded = true ; } if ( msg . data . page !== "generator" ) { return ; } var pageHash = msg . data . pageHash ; var tab = ( _currentTab ) ? _currentTab : "generator-start" ; if ( $ . inArray ( pageHash , _tabs ) !== - 1 ) { tab = pageHash ; } if ( pageHash === "generator-result" ) { _sendDemoPieData ( ) ; $ ( "#sidebar,#pieChartDiv" ) . addClass ( "fadeOut" ) ; setTimeout ( function ( ) { $ ( "#sidebar,#pieChartDiv" ) . addClass ( "hidden" ) . removeClass ( "fadeOut" ) ; $ ( "#generator-result" ) . removeClass ( "hidden fadeOut" ) . addClass ( "fadeIn" ) ; } , C . OTHER . PAGE_LOAD_SPEED ) ; } else if ( pageHash === "generator" && tab === "generator-result" ) { 
function getOrDef ( obj , prop ) { return obj [ prop ] === undefined ? options [ prop ] : obj [ prop ] ; } 
function triggerEvent ( event , $el ) { var handler = options [ 'on' + event ] ; if ( handler ) { if ( $isFunction ( handler ) ) { handler . call ( $el [ 0 ] ) ; } else { if ( handler . addClass ) { $el . addClass ( handler . addClass ) ; } if ( handler . removeClass ) { $el . removeClass ( handler . removeClass ) ; } } } $el . trigger ( 'lazy' + event , [ $el ] ) ; 
function checkLazyElements ( force ) { if ( ! elements . length ) { return ; } force = force || options . forceLoad ; topLazy = Infinity ; var viewportTop = scrollTop ( ) , viewportHeight = window . innerHeight || docElement . clientHeight , viewportWidth = window . innerWidth || docElement . clientWidth , i , length ; for ( i = 0 , length = elements . length ; i < length ; i ++ ) { var $el = elements [ i ] , el = $el [ 0 ] , objData = $el [ lazyLoadXT ] , removeNode = false , visible = force || $data ( el , dataLazied ) < 0 , topEdge ; 
function queueCheckLazyElements ( e ) { if ( ! elements . length ) { return ; } 
function calcViewport ( ) { var scrollTop = $window . scrollTop ( ) , scrollLeft = window . pageXOffset || 0 , edgeX = options . edgeX , edgeY = options . edgeY ; viewportTop = scrollTop - edgeY ; viewportBottom = scrollTop + ( window . innerHeight || $window . height ( ) ) + edgeY ; viewportLeft = scrollLeft - edgeX ; viewportRight = scrollLeft + ( window . innerWidth || $window . width ( ) ) + edgeX ; } 
function checkLazyElements ( ) { if ( ! elements . length ) { return ; } topLazy = Infinity ; calcViewport ( ) ; var i = elements . length - 1 , srcAttr = options . srcAttr ; for ( ; i >= 0 ; i -- ) { var $el = elements [ i ] , el = $el [ 0 ] ; 
function queueCheckLazyElements ( e ) { if ( ! elements . length ) { return ; } 
function checkVersion ( ) { var nextVersionCheckTimestamp = parseInt ( Cookies . get ( 'nextVersionCheckTimestamp' ) ) || 0 ; if ( ! nextVersionCheckTimestamp || ( Date . now ( ) >= nextVersionCheckTimestamp ) ) { $http . get ( '/api/build-info' ) . then ( function success ( res ) { var currentVersion = parseVersion ( res . data && res . data . version ) ; $http . get ( 'https://api.github.com/repos/mcdcorp/opentest/releases' ) . then ( function success ( res ) { var eightDaysLater = Date . now ( ) + ( 8 * 24 * 60 * 60 * 1000 ) ; Cookies . set ( 'nextVersionCheckTimestamp' , eightDaysLater ) ; var latestVersionStr = res . data && res . data [ 0 ] && res . data [ 0 ] . tag_name ; var latestVersionUrl = res . data && res . data [ 0 ] && res . data [ 0 ] . html_url ; var latestVersion = parseVersion ( latestVersionStr ) ; if ( latestVersion && ( compareVersions ( latestVersion , currentVersion ) === 1 ) ) { $ . notify ( { message : 'A new OpenTest version is now available: <a href="' + latestVersionUrl + '" target="_blank">' + latestVersionStr + '</a>. ' + 'You should always stay on the latest version to benefit from new features and security updates.' } , { type : 'info' , delay : 0 , placement : { from : 'bottom' } } ) } } , function error ( res ) { var oneHourLater = Date . now ( ) + ( 60 * 60 * 1000 ) ; Cookies . set ( 'nextVersionCheckTimestamp' , oneHourLater ) ; } ) ; } ) ; } } 
function parseVersion ( versionString ) { if ( typeof versionString !== 'string' ) { return null ; } var versionRegexMatch = versionString . match ( / v?(\d+)\.(\d+)\.(\d+) / i ) ; if ( versionRegexMatch ) { return [ parseInt ( versionRegexMatch [ 1 ] ) , parseInt ( versionRegexMatch [ 2 ] ) , parseInt ( versionRegexMatch [ 3 ] ) ] ; } else { return null ; } } 
function $randomString ( length , characterPool ) { if ( typeof characterPool !== 'string' ) { characterPool = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" ; } var text = "" ; for ( var i = 0 ; i < length ; i ++ ) { text += characterPool . charAt ( Math . floor ( Math . random ( ) * characterPool . length ) ) ; } return text ; } 
function $range ( start , length ) { if ( arguments . length === 1 ) { length = arguments [ 0 ] ; start = 0 ; } return Array . apply ( null , Array ( length ) ) . map ( function ( _ , index ) { return index + start ; } ) ; } 
function removeInvalidXml ( str ) { return Array . from ( str ) . map ( c => { const cp = c . codePointAt ( 0 ) ; if ( cp >= 65536 && cp <= 1114111 ) { return c } else if ( c . match ( validXmlRegex ) ) { return c ; } else { return '' ; } } ) . join ( '' ) ; } 
function cellAccessor ( row1 , col1 , row2 , col2 , isMerged ) { let theseCells = new cellBlock ( ) ; theseCells . ws = this ; row2 = row2 ? row2 : row1 ; col2 = col2 ? col2 : col1 ; if ( row2 > this . lastUsedRow ) { this . lastUsedRow = row2 ; } if ( col2 > this . lastUsedCol ) { this . lastUsedCol = col2 ; } for ( let r = row1 ; r <= row2 ; r ++ ) { for ( let c = col1 ; c <= col2 ; c ++ ) { let ref = ` ${ utils . getExcelAlpha ( c ) } ${ r } ` ; if ( ! this . cells [ ref ] ) { this . cells [ ref ] = new Cell ( r , c ) ; } if ( ! this . rows [ r ] ) { this . rows [ r ] = new Row ( r , this ) ; } if ( this . rows [ r ] . cellRefs . indexOf ( ref ) < 0 ) { this . rows [ r ] . cellRefs . push ( ref ) ; } theseCells . cells . push ( this . cells [ ref ] ) ; theseCells . excelRefs . push ( ref ) ; } } if ( isMerged ) { theseCells . merged = true ; mergeCells ( theseCells ) ; } return theseCells ; } 
function add ( project , email , accessLevel , inviter , done ) { User . findOne ( { email : email } , function ( err , user ) { if ( err ) { return done ( err ) ; } if ( user ) { var p = _ . find ( user . projects , function ( p ) { return p . name === project . toLowerCase ( ) ; } ) ; if ( p ) { return done ( 'user already a collaborator' , true ) ; } User . update ( { email : email } , { $push : { 'projects' : { name : project . toLowerCase ( ) , display_name : project , access_level : accessLevel } } } , function ( err ) { if ( err ) return done ( err , true ) ; done ( null , true ) ; } ) ; } else { var collaboration = { project : project , invited_by : inviter . _id , access_level : accessLevel } ; InviteCode . findOne ( { emailed_to : email , consumed_timestamp : null } , function ( err , invite ) { if ( err ) return done ( err ) ; if ( invite ) { return updateInvite ( invite , collaboration , done ) ; } sendInvite ( inviter , email , collaboration , done ) ; } ) ; } } ) ; } 
function allProjects ( done ) { User . find ( { } , function ( err , users ) { if ( err ) return done ( err ) ; Project . find ( ) . sort ( { _id : - 1 } ) . exec ( function ( err , projects ) { if ( err ) return done ( err ) ; done ( null , projects . map ( function ( project ) { project = utils . sanitizeProject ( project ) ; project . created_date = utils . timeFromId ( project . _id ) ; project . users = [ ] ; for ( var i = 0 ; i < users . length ; i ++ ) { if ( 'undefined' !== typeof users [ i ] . projects [ project . name ] ) { project . users . push ( { email : users [ i ] . email , access : users [ i ] . projects [ project . name ] } ) ; } } return project ; } ) ) ; } ) ; } ) ; } 
function getConfig ( ) { process . env = filterEnv ( deprecated ( process . env ) , envDefaults ) ; var rc = require ( 'rc' ) ( 'strider' , defaults ) ; if ( ! rc . smtp ) rc . smtp = smtp ( rc ) ; if ( ! rc . smtp ) rc . stubSmtp = true ; rc . ldap = getConfigByName ( 'ldap' ) ; addPlugins ( rc , process . env ) ; 
function filterEnv ( env , defaults ) { var res = { } ; for ( var k in env ) { if ( defaults [ k . toLowerCase ( ) ] !== undefined ) { res [ ` ${ k . toLowerCase ( ) } ` ] = env [ k ] ; } else { res [ k ] = env [ k ] ; } } return res ; } 
function mergePlugins ( branch , sjson ) { if ( ! branch ) return sjson ; if ( ! sjson ) return branch ; 
function multijob ( req , res ) { var type = req . accepts ( 'html' , 'json' , 'plain' ) ; switch ( type ) { case 'json' : return data ( req , res ) ; case 'plain' : return output ( req , res ) ; default : return html ( req , res ) ; } } 
function requireBody ( key , req , res ) { var val = req . body [ key ] ; if ( val === undefined ) { return res . status ( 400 ) . json ( { status : 'error' , errors : [ ` ${ key } ` ] } ) ; } return val ; } 
function loadTemplates ( list , type ) { if ( ! list ) { return ; } var result = { } ; type = type || 'plaintext' ; list . forEach ( function ( name ) { var templatePath = path . join ( templateBasePath , type , ` ${ name } ` ) ; result [ name ] = renderPug ( templatePath ) ; } ) ; return result ; } 
function registerTemplate ( name , template , dir ) { cache [ name ] = function ( context , cb ) { if ( / \.html$ / . test ( template ) ) { dir = dir || '.' ; template = fs . readFileSync ( path . join ( dir , template ) , 'utf8' ) ; } cb ( null , template ) ; } ; } 
function getPluginTemplate ( name , context ) { return function ( cb ) { if ( cache [ name ] ) { cache [ name ] ( context , function ( err , res ) { if ( err ) return cb ( err ) ; cb ( null , [ name , res ] ) ; } ) ; } else { cb ( null , null ) ; } } ; } 
function engine ( path , options , fn ) { options . filename = path ; fs . readFile ( path , 'utf8' , function ( err , str ) { if ( err ) return fn ( err ) ; engine . render ( str , options , fn ) ; } ) ; } 
function UserSockets ( sio , sessionStore ) { this . sio = sio ; this . sockets = { } ; this . sessionStore = sessionStore ; 
function ( uid , socket ) { var socks = this . sockets [ uid ] ; if ( ! socks ) return false ; return socks . remove ( socket ) ; } 
function ( socket ) { var session = socket . handshake . session ; if ( session && session . passport ) { this . addSocket ( session . passport . user , socket ) ; } else { console . debug ( 'Websocket connection does not have authorization - nothing to do.' ) ; } } 
function ( users , args ) { for ( var i = 0 ; i < users . length ; i ++ ) { if ( ! this . sockets [ users [ i ] ] ) continue ; this . sockets [ users [ i ] ] . emit ( args ) ; } } 
function ( users , fn ) { for ( var i = 0 ; i < users . length ; i ++ ) { if ( ! this . sockets [ users [ i ] ] || ! this . sockets [ users [ i ] ] . user ) continue ; this . sockets [ users [ i ] ] . emit ( fn ( this . sockets [ users [ i ] ] . user ) ) ; } } 
function ( users , args ) { for ( var id in this . sockets ) { if ( users . indexOf ( id ) !== - 1 ) continue ; this . sockets [ id ] . emit ( args ) ; } } 
function status ( job ) { if ( job . errored ) return 'errored' ; if ( ! job . started ) return 'submitted' ; if ( ! job . finished ) return 'running' ; if ( job . test_exitcode !== 0 ) return 'failed' ; if ( job . type !== TEST_ONLY && job . deploy_exitcode !== 0 ) return 'failed' ; return 'passed' ; } 
function Dashboard ( socket , $scope ) { JobMonitor . call ( this , socket , $scope . $digest . bind ( $scope ) ) ; this . scope = $scope ; this . scope . loadingJobs = false ; this . scope . jobs = global . jobs ; } 
function prepareJob ( emitter , job ) { Project . findOne ( { name : job . project } ) . populate ( 'creator' ) . exec ( function ( err , project ) { if ( err || ! project ) return debug ( 'job.prepare - failed to get project' , job . project , err ) ; 
function ( project , event , args ) { if ( this . waiting [ project ] ) { return this . waiting [ project ] . push ( [ event , args ] ) ; } this . send ( project , event , args ) ; if ( event === 'job.status.started' ) { Job . findById ( args [ 0 ] , function ( err , job ) { if ( err ) return debug ( '[backchannel][job.status.started] error getting job' , args [ 0 ] , err ) ; if ( ! job ) return debug ( '[backchannel][job.status.started] job not found' , args [ 0 ] ) ; job . started = args [ 1 ] ; job . save ( ) ; } ) ; } } 
function normalize ( val , single ) { var margin = 0.1 ; if ( val >= single && val <= single * ( 1 + margin ) ) { return single ; } return val ; } 
function killAttrs ( model , attrs ) { for ( var i = 0 ; i < attrs . length ; i ++ ) { delete model [ attrs [ i ] ] ; } } 
function bodySetter ( req , res , next ) { if ( req . _post_body ) { return next ( ) ; } req . post_body = req . post_body || '' ; if ( 'POST' !== req . method ) { return next ( ) ; } req . _post_body = true ; req . on ( 'data' , function ( chunk ) { req . post_body += chunk ; } ) ; next ( ) ; } 
function requireBody ( paramsList ) { return function ( req , res , next ) { var errors = [ ] ; var status = 'ok' ; for ( var i = 0 ; i < paramsList . length ; i ++ ) { var val = req . body [ paramsList [ i ] ] ; if ( ! val ) { errors . push ( ` \` ${ paramsList [ i ] } \` ` ) ; status = 'error' ; } } if ( errors . length === 0 ) { next ( ) ; } else { return res . status ( 400 ) . json ( { errors : errors , status : status } ) ; } } ; } 
function projectProvider ( req , res , next ) { var project = req . project ; req . providerConfig = function ( config , next ) { if ( arguments . length === 0 ) { return project . provider . config ; } project . provider . config = config ; project . markModified ( 'provider' ) ; project . save ( next ) ; } ; 
function projectPlugin ( req , res , next ) { var pluginid ; 
function anonProject ( req , res , next ) { var name = ` ${ req . params . org } ${ req . params . repo } ` ; name = name . toLowerCase ( ) ; Project . findOne ( { name : name } ) . populate ( 'creator' ) . exec ( function ( err , project ) { if ( err ) { return res . status ( 500 ) . send ( { error : 'Failed to find project' , info : err } ) ; } if ( ! project ) { return res . status ( 404 ) . send ( 'Project not found' ) ; } if ( ! project . creator ) { return res . status ( 400 ) . send ( 'Project malformed; project creator user is missing.' ) ; } req . project = project ; req . accessLevel = User . projectAccessLevel ( req . user , project ) ; if ( req . user && project . creator ) { req . user . isProjectCreator = project . creator . _id . toString ( ) === req . user . _id . toString ( ) ; } next ( ) ; } ) ; } 
function project ( req , res , next ) { if ( req . params . org === 'auth' ) { return next ( ) ; } anonProject ( req , res , function ( ) { if ( req . accessLevel > - 1 ) { return next ( ) ; } if ( ! req . user ) { req . session . return_to = req . url ; return res . redirect ( '/login' ) ; } res . status ( 401 ) . send ( 'Not authorized' ) ; } ) ; } 
function ( req , res , next ) { getPluginList ( function ( err , list ) { if ( err ) return next ( err ) ; res . render ( 'admin/plugins.html' , { plugins : list } ) ; } ) ; } 
function ( req , res ) { pluginManager [ req . body . action ] ( req . body . id , function ( err ) { if ( err ) return res . status ( 500 ) . end ( err . message ) ; res . json ( { ok : 'restarting strider' } ) ; restart ( ) ; } ) ; } 
function requireUser ( req , res , next ) { if ( req . user ) { next ( ) ; } else { req . session . return_to = req . url ; res . redirect ( '/login' ) ; } } 
function requireAdminOr401 ( req , res , next ) { if ( ! req . user || ! req . user [ 'account_level' ] || req . user . account_level < 1 ) { res . status ( 401 ) . send ( 'not authorized' ) ; } else { next ( ) ; } } 
function requireProjectAdmin ( req , res , next ) { if ( ! req . project ) return res . status ( 404 ) . send ( 'Project not loaded' ) ; if ( ! req . user ) return res . status ( 401 ) . send ( 'No user' ) ; var isAdmin = req . user . account_level && req . user . account_level > 0 ; var notAuthed = ( ! req . accessLevel || req . accessLevel < 2 ) && ! isAdmin ; if ( notAuthed ) return res . status ( 401 ) . send ( 'Not authorized for configuring this project' ) ; next ( ) ; } 
function pluginBlock ( indent , parser ) { var template = this . args [ 0 ] ; var output = '' ; 
function findAnchorByContent ( content , cb ) { element . all ( by . css ( 'a' ) ) . then ( function ( anchors ) { anchors . forEach ( function ( anchor ) { anchor . getText ( ) . then ( function ( anchorText ) { if ( anchorText === content ) { cb ( anchor ) ; } } ) ; } ) ; } ) ; } 
function ( fun ) { var ret = fun . toString ( ) ; ret = ret . substr ( 'function ' . length ) ; ret = ret . substr ( 0 , ret . indexOf ( '(' ) ) ; return ret ? ret . trim ( ) : ret ; } 
function getInnerLibraryMethod ( name , libName ) { libName = libName || config . lib ; var library = innerAuth0libraryConfiguration [ libName ] . library ( ) ; return library [ innerAuth0libraryConfiguration [ libName ] [ name ] ] ; } 
function getInnerLibraryConfigField ( name , libName ) { libName = libName || config . lib ; return innerAuth0libraryConfiguration [ libName ] [ name ] ; } 
function constructorName ( fun ) { if ( fun ) { return { lib : authUtilsProvider . fnName ( fun ) , constructor : fun } ; } if ( null != window . Auth0Lock ) { return { lib : 'Auth0Lock' , constructor : window . Auth0Lock } ; } if ( null != window . Auth0 ) { return { lib : 'Auth0' , constructor : window . Auth0 } ; } if ( typeof Auth0Widget !== 'undefined' ) { throw new Error ( 'Auth0Widget is not supported with this version of auth0-angular' + 'anymore. Please try with an older one' ) ; } throw new Error ( 'Cannot initialize Auth0Angular. Auth0Lock or Auth0 must be available' ) ; } 
function ( idToken , accessToken , state , refreshToken , profile , isRefresh ) { idToken = idToken || ( profile ? profile . idToken : null ) ; accessToken = accessToken || ( profile ? profile . accessToken : null ) ; state = state || ( profile ? profile . state : null ) ; refreshToken = refreshToken || ( profile ? profile . refreshToken : null ) ; var profilePromise = auth . getProfile ( idToken ) ; var response = { idToken : idToken , accessToken : accessToken , state : state , refreshToken : refreshToken , profile : profile , isAuthenticated : true } ; $rootScope . isAuthenticated = true ; angular . extend ( auth , response ) ; callHandler ( ! isRefresh ? 'loginSuccess' : 'authenticated' , angular . extend ( { profilePromise : profilePromise } , response ) ) ; return profilePromise ; } 
function verifyRoute ( requiresLogin , e , getState , redirectToLogin ) { if ( ! auth . isAuthenticated && ! auth . refreshTokenPromise ) { if ( config . sso ) { if ( requiresLogin ) { e . preventDefault ( ) ; } config . auth0js . getSSOData ( authUtils . applied ( function ( err , ssoData ) { if ( ssoData . sso ) { var loginOptions = { popup : false , callbackOnLocationHash : true , connection : ssoData . lastUsedConnection . name , authParams : { state : getState ( ) } } ; callHandler ( 'ssoLogin' , { loginOptions : loginOptions } ) ; auth . signin ( loginOptions , null , null , 'Auth0' ) ; } else if ( requiresLogin ) { e . preventDefault ( ) ; redirectToLogin ( ) ; } } ) ) ; } else if ( requiresLogin ) { e . preventDefault ( ) ; redirectToLogin ( ) ; } } } 
function string_of_enum ( e , value ) { for ( var k in e ) if ( e [ k ] == value ) return k ; return "Unknown(" + value + ")" ; } 
function ( ) { this . init = function ( blynk ) { } ; this . process = function ( values ) { switch ( values [ 0 ] ) { case 'pm' : return true ; case 'dw' : case 'dr' : case 'aw' : case 'ar' : console . log ( "No direct pin operations available." ) ; console . log ( "Maybe you need to install mraa or onoff modules?" ) ; return true ; } } ; } 
function ( auth , options ) { var self = this ; if ( needsEmitter ( ) ) { events . EventEmitter . call ( this ) ; } this . auth = auth ; var options = options || { } ; this . heartbeat = options . heartbeat || 10000 ; console . log ( "\n\ ___ __ __\n\ / _ )/ /_ _____ / /__\n\ / _ / / // / _ \\/ '_/\n\ /____/_/\\_, /_//_/_/\\_\\\n\ /___/\n\ \n\ Give Blynk a Github star! => https://github.com/vshymanskyy/blynk-library-js\n\ " ) ; 
function ( auth , options ) { var self = this ; this . auth = auth ; var options = options || { } ; this . heartbeat = options . heartbeat || 10000 ; 
function orphanedLibraries ( src , dst ) { 
function _findNested ( d ) { let nested = [ ] ; walk . walkSync ( d , ( basedir , filename , stat ) => { const file = path . join ( basedir , filename ) ; if ( file . indexOf ( '.app/Info.plist' ) !== - 1 ) { const nest = file . lastIndexOf ( '.app/' ) ; nested . push ( file . substring ( 0 , nest + 4 ) ) ; } } ) ; return nested ; } 
function binAbsLibs ( file , o ) { try { return bin . enumerateLibraries ( file ) . filter ( ( l ) => { return ! ( l . startsWith ( '/' ) ) ; } ) . map ( ( l ) => { if ( l [ 0 ] === '@' ) { const ll = depSolver . resolvePath ( o . exe , file , l , o . libs ) ; if ( ll ) { l = ll ; } else { console . error ( 'Warning: Cannot resolve dependency library: ' + file ) ; } } return l ; } ) ; } catch ( e ) { console . error ( 'Warning: missing file:' , file ) ; return [ ] ; } } 
function _findLibraries ( appdir , appbin , disklibs ) { const exe = path . join ( appdir , appbin ) ; const o = { exe : exe , lib : exe , libs : disklibs } ; const libraries = [ ] ; const pending = [ exe ] ; while ( pending . length > 0 ) { const target = pending . pop ( ) ; if ( libraries . indexOf ( target ) === - 1 ) { libraries . push ( target ) ; } let res = binAbsLibs ( target , o ) ; const unexplored = res . filter ( l => libraries . indexOf ( l ) === - 1 ) ; pending . push ( ... unexplored . filter ( l => pending . indexOf ( l ) === - 1 ) ) ; libraries . push ( ... unexplored ) ; } return libraries ; } 
function fix ( file , options , emit ) { const { appdir , bundleid , forceFamily , allowHttp } = options ; if ( ! file || ! appdir ) { throw new Error ( 'Invalid parameters for fixPlist' ) ; } let changed = false ; const data = plist . readFileSync ( file ) ; delete data [ '' ] ; if ( allowHttp ) { emit ( 'message' , 'Adding NSAllowArbitraryLoads' ) ; if ( ! Object . isObject ( data [ 'NSAppTransportSecurity' ] ) ) { data [ 'NSAppTransportSecurity' ] = { } ; } data [ 'NSAppTransportSecurity' ] [ 'NSAllowsArbitraryLoads' ] = true ; changed = true ; } if ( forceFamily ) { if ( performForceFamily ( data , emit ) ) { changed = true ; } } if ( bundleid ) { setBundleId ( data , bundleid ) ; changed = true ; } if ( changed ) { plist . writeFileSync ( file , data ) ; } } 
function getResignedFilename ( input ) { if ( ! input ) { return null ; } const pos = input . lastIndexOf ( path . sep ) ; if ( pos !== - 1 ) { const tmp = input . substring ( pos + 1 ) ; const dot = tmp . lastIndexOf ( '.' ) ; input = ( dot !== - 1 ) ? tmp . substring ( 0 , dot ) : tmp ; } else { const dot = input . lastIndexOf ( '.' ) ; if ( dot !== - 1 ) { input = input . substring ( 0 , dot ) ; } } return input + '-resigned.ipa' ; } 
function generateAccessor ( accessor ) { return function ( ) { let value = container [ varName ] if ( typeof value === 'undefined' ) { if ( typeof defValue === 'undefined' ) { 
function ( isRequired ) { if ( isRequired === false ) { return accessors } if ( typeof container [ varName ] === 'undefined' && typeof defValue === 'undefined' ) { throw new EnvVarError ( ` ${ varName } ` ) } return accessors } 
function getRefText ( ast ) { var ret = ast . leader ; var isFn = ast . args !== undefined ; if ( ast . type === 'macro_call' ) { ret = '#' ; } if ( ast . isWraped ) ret += '{' ; if ( isFn ) { ret += getMethodText ( ast ) ; } else { ret += ast . id ; } utils . forEach ( ast . path , function ( ref ) { 
function convert ( str ) { if ( typeof str !== 'string' ) return str ; var result = "" var escape = false var i , c , cstr ; for ( i = 0 ; i < str . length ; i ++ ) { c = str . charAt ( i ) ; if ( ( ' ' <= c && c <= '~' ) || ( c === '\r' ) || ( c === '\n' ) ) { if ( c === '&' ) { cstr = "&amp;" escape = true } else if ( c === '<' ) { cstr = "&lt;" escape = true } else if ( c === '>' ) { cstr = "&gt;" escape = true } else { cstr = c . toString ( ) } } else { cstr = "&#" + c . charCodeAt ( ) . toString ( ) + ";" } result = result + cstr } return escape ? result : str } 
function ( key ) { if ( ! utils . isArray ( key ) ) key = [ key ] utils . forEach ( key , function ( key ) { this . config . unescape [ key ] = true } , this ) } 
function ( ast , isVal ) { if ( ast . prue ) { var define = this . defines [ ast . id ] ; if ( utils . isArray ( define ) ) { return this . _render ( define ) ; } if ( ast . id in this . config . unescape ) ast . prue = false ; } var escape = this . config . escape ; var isSilent = this . silence || ast . leader === "$!" ; var isfn = ast . args !== undefined ; var context = this . context ; var ret = context [ ast . id ] ; var local = this . getLocal ( ast ) ; var text = Velocity . Helper . getRefText ( ast ) ; if ( text in context ) { return ( ast . prue && escape ) ? convert ( context [ text ] ) : context [ text ] ; } if ( ret !== undefined && isfn ) { ret = this . getPropMethod ( ast , context , ast ) ; } if ( local . isLocaled ) ret = local [ 'value' ] ; if ( ast . path ) { utils . some ( ast . path , function ( property , i , len ) { if ( ret === undefined ) { this . _throw ( ast , property ) ; } 
function ( ast ) { var id = ast . id ; var local = this . local ; var ret = false ; var isLocaled = utils . some ( this . conditions , function ( contextId ) { var _local = local [ contextId ] ; if ( id in _local ) { ret = _local [ id ] ; return true ; } return false ; } , this ) ; return { value : ret , isLocaled : isLocaled } ; } 
function ( property , baseRef , ast ) { * typevelocity.yyattribute: method, index, property */ var type = property . type ; var ret ; var id = property . id ; if ( type === 'method' ) { ret = this . getPropMethod ( property , baseRef , ast ) ; } else if ( type === 'property' ) { ret = baseRef [ id ] ; } else { ret = this . getPropIndex ( property , baseRef ) ; } return ret ; } 
function ( property , baseRef ) { var ast = property . id ; var key ; if ( ast . type === 'references' ) { key = this . getReferences ( ast ) ; } else if ( ast . type === 'integer' ) { key = ast . value ; } else { key = ast . value ; } return baseRef [ key ] ; } 
function ( property , baseRef , ast ) { var id = property . id ; var ret = '' ; 
function ( literal ) { var type = literal . type ; var ret = '' ; if ( type === 'string' ) { ret = this . getString ( literal ) ; } else if ( type === 'integer' ) { ret = parseInt ( literal . value , 10 ) ; } else if ( type === 'decimal' ) { ret = parseFloat ( literal . value , 10 ) ; } else if ( type === 'array' ) { ret = this . getArray ( literal ) ; } else if ( type === 'map' ) { ret = { } ; var map = literal . value ; utils . forEach ( map , function ( exp , key ) { ret [ key ] = this . getLiteral ( exp ) ; } , this ) ; } else if ( type === 'bool' ) { if ( literal . value === "null" ) { ret = null ; } else if ( literal . value === 'false' ) { ret = false ; } else if ( literal . value === 'true' ) { ret = true ; } } else { return this . getReferences ( literal ) ; } return ret ; } 
function ( literal ) { var val = literal . value ; var ret = val ; if ( literal . isEval && ( val . indexOf ( '#' ) !== - 1 || val . indexOf ( "$" ) !== - 1 ) ) { ret = this . evalStr ( val ) ; } return ret ; } 
function ( literal ) { var ret = [ ] ; if ( literal . isRange ) { var begin = literal . value [ 0 ] ; if ( begin . type === 'references' ) { begin = this . getReferences ( begin ) ; } var end = literal . value [ 1 ] ; if ( end . type === 'references' ) { end = this . getReferences ( end ) ; } end = parseInt ( end , 10 ) ; begin = parseInt ( begin , 10 ) ; var i ; if ( ! isNaN ( begin ) && ! isNaN ( end ) ) { if ( begin < end ) { for ( i = begin ; i <= end ; i ++ ) ret . push ( i ) ; } else { for ( i = begin ; i >= end ; i -- ) ret . push ( i ) ; } } } else { utils . forEach ( literal . value , function ( exp ) { ret . push ( this . getLiteral ( exp ) ) ; } , this ) ; } return ret ; } 
function ( block ) { var ast = block [ 0 ] ; var ret = '' ; switch ( ast . type ) { case 'if' : ret = this . getBlockIf ( block ) ; break ; case 'foreach' : ret = this . getBlockEach ( block ) ; break ; case 'macro' : this . setBlockMacro ( block ) ; break ; case 'noescape' : ret = this . _render ( block . slice ( 1 ) ) ; break ; case 'define' : this . setBlockDefine ( block ) ; break ; case 'macro_body' : ret = this . getMacroBody ( block ) ; break ; default : ret = this . _render ( block ) ; } return ret || '' ; } 
function ( block ) { var ast = block [ 0 ] ; var _block = block . slice ( 1 ) ; var defines = this . defines ; defines [ ast . id ] = _block ; } 
function ( block ) { var ast = block [ 0 ] ; var _block = block . slice ( 1 ) ; var macros = this . macros ; macros [ ast . id ] = { asts : _block , args : ast . args } ; } 
function ( ast , bodyContent ) { var macro = this . macros [ ast . id ] ; var ret = '' ; if ( ! macro ) { var jsmacros = this . jsmacros ; macro = jsmacros [ ast . id ] ; var jsArgs = [ ] ; if ( macro && macro . apply ) { utils . forEach ( ast . args , function ( a ) { jsArgs . push ( this . getLiteral ( a ) ) ; } , this ) ; var self = this ; 
function ( str , local , contextId ) { if ( ! local ) { if ( utils . isArray ( str ) ) { return this . _render ( str ) ; } else { return this . evalStr ( str ) ; } } else { var asts = [ ] ; var parse = Velocity . parse ; contextId = contextId || ( 'eval:' + utils . guid ( ) ) ; if ( utils . isArray ( str ) ) { asts = str ; } else if ( parse ) { asts = parse ( str ) ; } if ( asts . length ) { this . local [ contextId ] = local ; var ret = this . _render ( asts , contextId ) ; this . local [ contextId ] = { } ; this . conditions . shift ( ) ; this . condition = this . conditions [ 0 ] || '' ; return ret ; } } } 
function ( block ) { var ast = block [ 0 ] ; var _from = this . getLiteral ( ast . from ) ; var _block = block . slice ( 1 ) ; var _to = ast . to ; var local = { foreach : { count : 0 } } ; var ret = '' ; var guid = utils . guid ( ) ; var contextId = 'foreach:' + guid ; var type = ( { } ) . toString . call ( _from ) ; if ( ! _from || ( type !== '[object Array]' && type !== '[object Object]' ) ) { return '' ; } if ( utils . isArray ( _from ) ) { var len = _from . length ; utils . forEach ( _from , function ( val , i ) { if ( this . _state . break ) { return ; } 
function ( block ) { var received = false ; var asts = [ ] ; utils . some ( block , function ( ast ) { if ( ast . condition ) { if ( received ) { return true ; } received = this . getExpression ( ast . condition ) ; } else if ( ast . type === 'else' ) { if ( received ) { return true ; } received = true ; } else if ( received ) { asts . push ( ast ) ; } return false ; } , this ) ; 
function ( ast ) { var local = this . getLocal ( ast ) ; var real = local . real || ast ; var ret = { ignore : false , type : 'string' , real : real , foreach : false } ; if ( local . real === undefined && local . isGlobal !== true ) { ret . ignore = true ; } var m = this . hasMethod ( real ) ; var eachTo ; if ( local . type == 'foreach' ) { if ( ast . id == local . ast . to ) { 
function ( ast ) { var exp = ast . expression ; var ret ; if ( ast . type === 'math' ) { switch ( ast . operator ) { case '+' : ret = this . getExpression ( exp [ 0 ] ) + this . getExpression ( exp [ 1 ] ) ; break ; case '-' : ret = this . getExpression ( exp [ 0 ] ) - this . getExpression ( exp [ 1 ] ) ; break ; case '/' : ret = this . getExpression ( exp [ 0 ] ) / this . getExpression ( exp [ 1 ] ) ; break ; case '%' : ret = this . getExpression ( exp [ 0 ] ) % this . getExpression ( exp [ 1 ] ) ; break ; case '*' : ret = this . getExpression ( exp [ 0 ] ) * this . getExpression ( exp [ 1 ] ) ; break ; case '||' : ret = this . getExpression ( exp [ 0 ] ) || this . getExpression ( exp [ 1 ] ) ; break ; case '&&' : ret = this . getExpression ( exp [ 0 ] ) && this . getExpression ( exp [ 1 ] ) ; break ; case '>' : ret = this . getExpression ( exp [ 0 ] ) > this . getExpression ( exp [ 1 ] ) ; break ; case '<' : ret = this . getExpression ( exp [ 0 ] ) < this . getExpression ( exp [ 1 ] ) ; break ; case '==' : ret = this . getExpression ( exp [ 0 ] ) == this . getExpression ( exp [ 1 ] ) ; break ; case '>=' : ret = this . getExpression ( exp [ 0 ] ) >= this . getExpression ( exp [ 1 ] ) ; break ; case '<=' : ret = this . getExpression ( exp [ 0 ] ) <= this . getExpression ( exp [ 1 ] ) ; break ; case '!=' : ret = this . getExpression ( exp [ 0 ] ) != this . getExpression ( exp [ 1 ] ) ; break ; case 'minus' : ret = - this . getExpression ( exp [ 0 ] ) ; break ; case 'not' : ret = ! this . getExpression ( exp [ 0 ] ) ; break ; case 'parenthesis' : ret = this . getExpression ( exp [ 0 ] ) ; break ; default : return ; 
function ( asts , contextId ) { var str = '' ; asts = asts || this . asts ; if ( contextId ) { if ( contextId !== this . condition && utils . indexOf ( contextId , this . conditions ) === - 1 ) { this . conditions . unshift ( contextId ) ; } this . condition = contextId ; } else { this . condition = null ; } utils . forEach ( asts , function ( ast ) { 
function getAllModules ( compilation ) { let modules = compilation . modules ; * @see https: * In webpack@3.5.1 `modules` public property was removed * To workaround this private `_orderedConcatenationList` property is used to collect modules */ const subModules = 'modules' in m ? m . modules : m . _orderedConcatenationList . map ( entry => entry . module ) ; return acc . concat ( subModules ) ; } , [ ] ) ; if ( concatenatedModules . length > 0 ) { modules = modules . concat ( concatenatedModules ) ; } } return modules . filter ( m => m . rawRequest ) ; } 
function getModuleChunk ( module ) { let chunks ; const webpackVersion = getWebpackMajorVersion ( ) ; if ( webpackVersion >= 4 ) { chunks = Array . from ( module . chunksIterable ) ; } else if ( webpackVersion >= 3 ) { chunks = module . mapChunks ( ) ; } else { chunks = module . chunks ; } if ( Array . isArray ( chunks ) && chunks . length > 0 ) { return chunks [ chunks . length - 1 ] ; } else if ( module . issuer ) { return getModuleChunk ( module . issuer ) ; } return null ; } 
function checkBinReferences_ ( file , data , warn , cb ) { if ( ! ( data . bin instanceof Object ) ) return cb ( ) var keys = Object . keys ( data . bin ) var keysLeft = keys . length if ( ! keysLeft ) return cb ( ) function handleExists ( relName , result ) { keysLeft -- if ( ! result ) warn ( 'No bin file found at ' + relName ) if ( ! keysLeft ) cb ( ) } keys . forEach ( function ( key ) { var dirName = path . dirname ( file ) var relName = data . bin [ key ] try { var binPath = path . resolve ( dirName , relName ) fs . stat ( binPath , ( err ) => handleExists ( relName , ! err ) ) } catch ( error ) { if ( error . message === 'Arguments to path.resolve must be strings' || error . message . indexOf ( 'Path must be a string' ) === 0 ) { warn ( 'Bin filename for ' + key + ' is not a string: ' + util . inspect ( relName ) ) handleExists ( relName , true ) } else { cb ( error ) } } } ) } 
function parseIndex ( data ) { data = data . split ( / ^\/\*\*package(?:\s|$) / m ) if ( data . length < 2 ) return null data = data [ 1 ] data = data . split ( / \*\*\/$ / m ) if ( data . length < 2 ) return null data = data [ 0 ] data = data . replace ( / ^\s*\* / mg , '' ) try { return safeJSON ( data ) } catch ( er ) { return null } } 
function ( ) { var self = this ; self . bind ( 'RuntimeInit' , function ( e , runtime ) { self . ruid = runtime . uid ; self . shimid = runtime . shimid ; self . bind ( "Ready" , function ( ) { self . trigger ( "Refresh" ) ; } , 999 ) ; 
function ( name , value ) { if ( ! options . hasOwnProperty ( name ) ) { return ; } var oldValue = options [ name ] ; switch ( name ) { case 'accept' : if ( typeof ( value ) === 'string' ) { value = Mime . mimes2extList ( value ) ; } break ; case 'container' : case 'required_caps' : throw new x . FileException ( x . FileException . NO_MODIFICATION_ALLOWED_ERR ) ; } options [ name ] = value ; this . exec ( 'FileInput' , 'setOption' , name , value ) ; this . trigger ( 'OptionChanged' , name , value , oldValue ) ; } 
function ( mimeData ) { var items = mimeData . split ( / , / ) , i , ii , ext ; for ( i = 0 ; i < items . length ; i += 2 ) { ext = items [ i + 1 ] . split ( / / ) ; 
function ( from , to , text , all ) { var pos = text . indexOf ( from ) ; if ( pos == - 1 ) { return text ; } text = text . substring ( 0 , pos ) + to + text . substring ( pos + from . length ) ; return ! all ? text : replace . call ( null , from , to , text , all ) ; } 
function ( e , runtime ) { self . unbind ( "RuntimeInit" , cb ) ; _run . call ( self , type , runtime ) ; } 
function ( ) { this . result = null ; if ( Basic . inArray ( this . readyState , [ FileReader . EMPTY , FileReader . DONE ] ) !== - 1 ) { return ; } else if ( this . readyState === FileReader . LOADING ) { this . readyState = FileReader . DONE ; } this . exec ( 'FileReader' , 'abort' ) ; this . trigger ( 'abort' ) ; this . trigger ( 'loadend' ) ; } 
function ( uastring ) { var ua = uastring || ( ( window && window . navigator && window . navigator . userAgent ) ? window . navigator . userAgent : EMPTY ) ; this . getBrowser = function ( ) { return mapper . rgx . apply ( this , regexes . browser ) ; } ; this . getEngine = function ( ) { return mapper . rgx . apply ( this , regexes . engine ) ; } ; this . getOS = function ( ) { return mapper . rgx . apply ( this , regexes . os ) ; } ; this . getResult = function ( ) { return { ua : this . getUA ( ) , browser : this . getBrowser ( ) , engine : this . getEngine ( ) , os : this . getOS ( ) } ; } ; this . getUA = function ( ) { return ua ; } ; this . setUA = function ( uastring ) { ua = uastring ; return this ; } ; this . setUA ( ua ) ; } 
function ( v ) { v = ( '' + v ) . replace ( / [_\-+] / g , '.' ) ; v = v . replace ( / ([^.\d]+) / g , '.$1.' ) . replace ( / \.{2,} / g , '.' ) ; return ( ! v . length ? [ - 8 ] : v . split ( '.' ) ) ; } 
function ( type ) { var list ; if ( type ) { type = type . toLowerCase ( ) ; list = eventpool [ this . uid ] && eventpool [ this . uid ] [ type ] ; } else { list = eventpool [ this . uid ] ; } return list ? list : false ; } 
function ( type , fn ) { var self = this , list , i ; type = type . toLowerCase ( ) ; if ( / \s / . test ( type ) ) { 
function ( type , fn , priority , scope ) { var self = this ; self . bind . call ( this , type , function cb ( ) { self . unbind ( type , cb ) ; return fn . apply ( this , arguments ) ; } , priority , scope ) ; } 
function ( dispatches ) { var self = this ; this . bind ( dispatches . join ( ' ' ) , function ( e ) { var prop = 'on' + e . type . toLowerCase ( ) ; if ( Basic . typeOf ( this [ prop ] ) === 'function' ) { this [ prop ] . apply ( this , arguments ) ; } } ) ; 
function ( cap , value ) { var refCaps = arguments [ 2 ] || caps ; 
function ( component , action ) { var args = [ ] . slice . call ( arguments , 2 ) ; return self . getShim ( ) . exec . call ( this , this . uid , component , action , args ) ; } 
function ( component , action ) { 
function ( ) { if ( ! self ) { return ; 
function getShimVersion ( ) { var version ; try { version = navigator . plugins [ 'Shockwave Flash' ] ; version = version . description ; } catch ( e1 ) { try { version = new ActiveXObject ( 'ShockwaveFlash.ShockwaveFlash' ) . GetVariable ( '$version' ) ; } catch ( e2 ) { version = '0.0' ; } } version = version . match ( / \d+ / g ) ; return parseFloat ( version [ 0 ] + '.' + version [ 1 ] ) ; } 
function removeSWF ( id ) { var obj = Dom . get ( id ) ; if ( obj && obj . nodeName == "OBJECT" ) { if ( Env . browser === 'IE' ) { obj . style . display = "none" ; ( function onInit ( ) { 
function ( url ) { function origin ( url ) { return [ url . scheme , url . host , url . port ] . join ( '/' ) ; } if ( typeof url === 'string' ) { url = parseUrl ( url ) ; } return origin ( parseUrl ( ) ) === origin ( url ) ; } 
function inherit ( child , parent ) { 
function ctor ( ) { this . constructor = child ; if ( MXI_DEBUG ) { var getCtorName = function ( fn ) { var m = fn . toString ( ) . match ( / ^function\s([^\(\s]+) / ) ; return m ? m [ 1 ] : false ; } ; this . ctorName = getCtorName ( child ) ; } } 
function inArray ( needle , array ) { if ( array ) { if ( Array . prototype . indexOf ) { return Array . prototype . indexOf . call ( array , needle ) ; } for ( var i = 0 , length = array . length ; i < length ; i ++ ) { if ( array [ i ] === needle ) { return i ; } } } return - 1 ; } 
function arrayDiff ( needles , array ) { var diff = [ ] ; if ( typeOf ( needles ) !== 'array' ) { needles = [ needles ] ; } if ( typeOf ( array ) !== 'array' ) { array = [ array ] ; } for ( var i in needles ) { if ( inArray ( needles [ i ] , array ) === - 1 ) { diff . push ( needles [ i ] ) ; } } return diff . length ? diff : false ; } 
function arrayIntersect ( array1 , array2 ) { var result = [ ] ; each ( array1 , function ( item ) { if ( inArray ( item , array2 ) !== - 1 ) { result . push ( item ) ; } } ) ; return result . length ? result : null ; } 
function parseSizeStr ( size ) { if ( typeof ( size ) !== 'string' ) { return size ; } var muls = { t : 1099511627776 , g : 1073741824 , m : 1048576 , k : 1024 } , mul ; size = / ^([0-9\.]+)([tmgk]?)$ / . exec ( size . toLowerCase ( ) . replace ( / [^0-9\.tmkg] / g , '' ) ) ; mul = size [ 2 ] ; size = + size [ 1 ] ; if ( muls . hasOwnProperty ( mul ) ) { size *= muls [ mul ] ; } return Math . floor ( size ) ; } 
function sprintf ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; return str . replace ( / %([a-z]) / g , function ( $0 , $1 ) { var value = args . shift ( ) ; switch ( $1 ) { case 's' : return value + '' ; case 'd' : return parseInt ( value , 10 ) ; case 'f' : return parseFloat ( value ) ; case 'c' : return '' ; default : return value ; } } ) ; } 
function ( name , value ) { var self = this , valueType = Basic . typeOf ( value ) ; 
function ( cb ) { Basic . each ( _fields , function ( field ) { cb ( field . value , field . name ) ; } ) ; if ( _blob ) { cb ( _blob . value , _blob . name ) ; } } 
function ( obj , name ) { if ( ! obj . className ) { return false ; } var regExp = new RegExp ( "(^|\\s+)" + name + "(\\s+|$)" ) ; return regExp . test ( obj . className ) ; } 
function ( obj , name ) { if ( ! hasClass ( obj , name ) ) { obj . className = ! obj . className ? name : obj . className . replace ( / \s+$ / , '' ) + ' ' + name ; } } 
function ( obj , name ) { if ( obj . className ) { var regExp = new RegExp ( "(^|\\s+)" + name + "(\\s+|$)" ) ; obj . className = obj . className . replace ( regExp , function ( $0 , $1 , $2 ) { return $1 === ' ' && $2 === ' ' ? ' ' : '' ; } ) ; } } 
function ( obj , name ) { if ( obj . currentStyle ) { return obj . currentStyle [ name ] ; } else if ( window . getComputedStyle ) { return window . getComputedStyle ( obj , null ) [ name ] ; } } 
function ( node , root ) { var x = 0 , y = 0 , parent , doc = document , nodeRect , rootRect ; node = node ; root = root || doc . body ; 
function getIEPos ( node ) { var bodyElm , rect , x = 0 , y = 0 ; if ( node ) { rect = node . getBoundingClientRect ( ) ; bodyElm = doc . compatMode === "CSS1Compat" ? doc . documentElement : doc . body ; x = rect . left + bodyElm . scrollLeft ; y = rect . top + bodyElm . scrollTop ; } return { x : x , y : y } ; } 
function ( node ) { return { w : node . offsetWidth || node . clientWidth , h : node . offsetHeight || node . clientHeight } ; } 
function ( obj , name , callback , key ) { var func , events ; name = name . toLowerCase ( ) ; 
function ( obj , name , callback ) { var type , undef ; name = name . toLowerCase ( ) ; if ( obj [ uid ] && eventhash [ obj [ uid ] ] && eventhash [ obj [ uid ] ] [ name ] ) { type = eventhash [ obj [ uid ] ] [ name ] ; } else { return ; } for ( var i = type . length - 1 ; i >= 0 ; i -- ) { 
function ( obj , key ) { if ( ! obj || ! obj [ uid ] ) { return ; } Basic . each ( eventhash [ obj [ uid ] ] , function ( events , name ) { removeEvent ( obj , name , key ) ; } ) ; } 
function _preloadAndSend ( meta , data ) { var target = this , blob , fr ; 
function _rotateToOrientaion ( img , orientation ) { var RADIANS = Math . PI / 180 ; var canvas = document . createElement ( 'canvas' ) ; var ctx = canvas . getContext ( '2d' ) ; var width = img . width ; var height = img . height ; if ( Basic . inArray ( orientation , [ 5 , 6 , 7 , 8 ] ) > - 1 ) { canvas . width = height ; canvas . height = width ; } else { canvas . width = width ; canvas . height = height ; } switch ( orientation ) { case 2 : 
function ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; return str . replace ( / %[a-z] / g , function ( ) { var value = args . shift ( ) ; return Basic . typeOf ( value ) !== 'undefined' ? value : '' ; } ) ; } 
function getEntries ( cbcb ) { dirReader . readEntries ( function ( moreEntries ) { if ( moreEntries . length ) { [ ] . push . apply ( entries , moreEntries ) ; getEntries ( cbcb ) ; } else { cbcb ( ) ; } } , cbcb ) ; } 
function ( method , url , async , user , password ) { var urlp ; 
function ( header , value ) { var uaHeaders = [ if (/[\u0100-\uffff]/.test(value) || Encode.utf8_encode(value) !== value) { throw new x.DOMException(x.DOMException.SYNTAX_ERR); }*/ header = Basic . trim ( header ) . toLowerCase ( ) ; 
function ( header ) { header = header . toLowerCase ( ) ; if ( _error_flag || ! ! ~ Basic . inArray ( header , [ 'set-cookie' , 'set-cookie2' ] ) ) { return null ; } if ( _responseHeaders && _responseHeaders !== '' ) { 
function ( mime ) { var matches , charset ; 
function ( data , options ) { if ( Basic . typeOf ( options ) === 'string' ) { _options = { ruid : options } ; } else if ( ! options ) { _options = { } ; } else { _options = options ; } 
function ( ) { _error_flag = true ; _sync_flag = false ; if ( ! ~ Basic . inArray ( _p ( 'readyState' ) , [ XMLHttpRequest . UNSENT , XMLHttpRequest . OPENED , XMLHttpRequest . DONE ] ) ) { _p ( 'readyState' , XMLHttpRequest . DONE ) ; _send_flag = false ; if ( _xhr ) { _xhr . getRuntime ( ) . exec . call ( _xhr , 'XMLHttpRequest' , 'abort' , _upload_complete_flag ) ; } else { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } _upload_complete_flag = true ; } else { _p ( 'readyState' , XMLHttpRequest . UNSENT ) ; } } 
function _p ( prop , value ) { if ( ! props . hasOwnProperty ( prop ) ) { return ; } if ( arguments . length === 1 ) { 
function addInput ( ) { var comp = this , I = comp . getRuntime ( ) , shimContainer , browseButton , currForm , form , input , uid ; uid = Basic . guid ( 'uid_' ) ; shimContainer = I . getShimContainer ( ) ; 
function ( obj , callback ) { var length , key , i ; if ( obj ) { length = obj . length ; if ( length === undefined ) { 
function ( target ) { var undef ; each ( arguments , function ( arg , i ) { if ( i > 0 ) { each ( arg , function ( value , key ) { if ( value !== undef ) { if ( typeof ( target [ key ] ) === typeof ( value ) && ( typeof ( value ) === 'object' || util . isArray ( value ) ) ) { extend ( target [ key ] , value ) ; } else { target [ key ] = value ; } } } ) ; } } ) ; return target ; } 
function ( options ) { var self = this ; var orientation ; var scale ; var srcRect = { x : 0 , y : 0 , width : self . width , height : self . height } ; var opts = Basic . extendIf ( { width : self . width , height : self . height , type : self . type || 'image/jpeg' , quality : 90 , crop : false , fit : true , preserveHeaders : true , resample : 'default' , multipass : true } , options ) ; try { if ( ! self . size ) { 
function ( options ) { var defaults = { width : this . width , height : this . height , type : this . type || 'image/jpeg' , quality : 90 , crop : false , fit : false , preserveHeaders : true , resample : 'default' } , opts ; if ( typeof ( options ) === 'object' ) { opts = Basic . extend ( defaults , options ) ; } else { 
function ( type , quality ) { if ( ! this . size ) { throw new x . DOMException ( x . DOMException . INVALID_STATE_ERR ) ; } return this . exec ( 'Image' , 'getAsBlob' , type || 'image/jpeg' , quality || 90 ) ; } 
function ( type , quality ) { var dataUrl = this . getAsDataURL ( type , quality ) ; return Encode . atob ( dataUrl . substring ( dataUrl . indexOf ( 'base64,' ) + 7 ) ) ; } 
function ( el , options ) { var self = this , runtime tr.destroy(); runtime.destroy(); onResize.call(self); });*/ runtime = null ; 
function ( ) { if ( this . ruid ) { this . getRuntime ( ) . exec . call ( this , 'Image' , 'destroy' ) ; this . disconnectRuntime ( ) ; } if ( this . meta && this . meta . thumb ) { 
function ( obj , prop , desc ) { if ( o . typeOf ( desc ) === 'object' ) { defineGSetter . call ( obj , prop , desc , 'get' ) ; if ( ! Object . defineProperty ) { 
function ( prop , desc , type ) { var defaults = { enumerable : true , configurable : true } , fn , camelType , self = this ; type = type . toLowerCase ( ) ; camelType = type . replace ( / ^[gs] / , function ( $1 ) { return $1 . toUpperCase ( ) ; } ) ; 
function initializeWatchers ( ) { var watcher = chokidar . watch ( '**/*.js' , { ignored : 'node_modules' } ) ; watcher . on ( 'change' , main ) . on ( 'unlink' , main ) ; watchersInitialized = true ; console . log ( 'Watchers initialized' ) ; } 
function SyntaxError ( message , expected , found , offset , line , column ) { Error . call ( this , message ) this . name = 'SyntaxError' this . message = message this . expected = expected this . found = found this . offset = offset this . line = line this . column = column } 
function MessageFormat ( pattern , locales , options ) { if ( ! ( this instanceof MessageFormat ) || internals . has ( this ) ) { throw new TypeError ( 'calling MessageFormat constructor without new is invalid' ) } var ast = parse ( pattern ) internals . set ( this , { ast : ast , format : interpret ( ast , locales , options && options . types ) , locale : MessageFormat . supportedLocalesOf ( locales ) [ 0 ] || 'en' , locales : locales , options : options } ) } 
function ( twist ) { var i , m , o , ori , parity , v ; if ( twist != null ) { parity = 0 ; for ( i = m = 6 ; m >= 0 ; i = -- m ) { ori = twist % 3 ; twist = ( twist / 3 ) | 0 ; this . co [ i ] = ori ; parity += ori ; } this . co [ 7 ] = ( 3 - parity % 3 ) % 3 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o <= 6 ; i = ++ o ) { v = 3 * v + this . co [ i ] ; } return v ; } } 
function ( flip ) { var i , m , o , ori , parity , v ; if ( flip != null ) { parity = 0 ; for ( i = m = 10 ; m >= 0 ; i = -- m ) { ori = flip % 2 ; flip = flip / 2 | 0 ; this . eo [ i ] = ori ; parity += ori ; } this . eo [ 11 ] = ( 2 - parity % 2 ) % 2 ; return this ; } else { v = 0 ; for ( i = o = 0 ; o <= 10 ; i = ++ o ) { v = 2 * v + this . eo [ i ] ; } return v ; } } 
function ( ) { var i , j , m , o , ref , ref1 , ref2 , ref3 , s ; s = 0 ; for ( i = m = ref = DRB , ref1 = URF + 1 ; ( ref <= ref1 ? m <= ref1 : m >= ref1 ) ; i = ref <= ref1 ? ++ m : -- m ) { for ( j = o = ref2 = i - 1 , ref3 = URF ; ( ref2 <= ref3 ? o <= ref3 : o >= ref3 ) ; j = ref2 <= ref3 ? ++ o : -- o ) { if ( this . cp [ j ] > this . cp [ i ] ) { s ++ ; } } } return s % 2 ; } 
function ( ) { var i , j , m , o , ref , ref1 , ref2 , ref3 , s ; s = 0 ; for ( i = m = ref = BR , ref1 = UR + 1 ; ( ref <= ref1 ? m <= ref1 : m >= ref1 ) ; i = ref <= ref1 ? ++ m : -- m ) { for ( j = o = ref2 = i - 1 , ref3 = UR ; ( ref2 <= ref3 ? o <= ref3 : o >= ref3 ) ; j = ref2 <= ref3 ? ++ o : -- o ) { if ( this . ep [ j ] > this . ep [ i ] ) { s ++ ; } } } return s % 2 ; } 
function parseXY ( config , _chartProps , callback , parseOpts ) { 
function parseChartgrid ( config , _chartProps , callback , parseOpts ) { 
function make_mults ( Outer , outerProps , data , gridScales , renderDataFunc ) { var colDomain = gridScales . cols . domain ( ) ; var numCols = colDomain [ colDomain . length - 1 ] + 1 ; 
function all_modulo ( tickValues , interval ) { 
function detectDelimiter ( input ) { var numRows = input . split ( / \r\n|\r|\n / ) . length ; var numTabs = input . replace ( tabRegex , "" ) . length ; if ( numTabs >= numRows - 1 ) { return "\t" ; } else { return "," ; } } 
function autoDateFormatAndFrequency ( minDate , maxDate , dateFormat , availableWidth ) { var timespan = Math . abs ( maxDate - minDate ) ; var years = timespan / 31536000000 ; var months = timespan / 2628000000 ; var days = timespan / 86400000 ; var yearGap ; var hourGap ; var interval ; var targetPixelGap = 64 ; var maximum_ticks = Math . max ( Math . floor ( availableWidth / targetPixelGap ) , 1 ) ; var time_gap = timespan / maximum_ticks ; if ( dateFormat == "auto" ) { 
function validate_chart_model ( modelStr ) { var parsed ; try { parsed = JSON . parse ( modelStr ) ; } catch ( e ) { throw new TypeError ( "Chart model is not valid JSON" ) ; } var isValidChartModel = ( parsed . hasOwnProperty ( "chartProps" ) && parsed . hasOwnProperty ( "metadata" ) ) ; if ( isValidChartModel ) { return parsed ; } else { throw new TypeError ( "Not a valid Chartbuilder model" ) ; } } 
function chartGridDimensions ( width , opts ) { var height ; var metadata = opts . metadata ; var grid = opts . grid ; if ( metadata . size == "auto" || opts . enableResponsive ) { 
function registeredCallback ( payload ) { var action = payload . action ; var data ; switch ( action . eventName ) { case "receive-model" : Dispatcher . waitFor ( [ ChartPropertiesStore . dispatchToken ] ) ; _metadata = action . model . metadata ; data = ChartPropertiesStore . get ( "data" ) ; _metadata . title = defaultTitle ( data ) ; ChartMetadataStore . emitChange ( ) ; break ; case "update-metadata" : _metadata [ action . key ] = action . value ; 
function exact_ticks ( domain , numticks ) { numticks -= 1 ; var ticks = [ ] ; var delta = domain [ 1 ] - domain [ 0 ] ; var i ; for ( i = 0 ; i < numticks ; i ++ ) { ticks . push ( domain [ 0 ] + ( delta / numticks ) * i ) ; } ticks . push ( domain [ 1 ] ) ; if ( domain [ 1 ] * domain [ 0 ] < 0 ) { 
function compute_scale_domain ( scaleObj , data , opts ) { 
function round_to_precision ( num , precision , supress_thou_sep ) { 
function combine_margin_pading ( m , p ) { return { top : m . top + p . top , right : m . right + p . right , bottom : m . bottom + p . bottom , left : m . left + p . left } ; } 
function precision ( a ) { 
function transform_coords ( transformString ) { 
function merge_or_apply ( defaults , source ) { var defaultKeys = keys ( defaults ) ; var sourceKeys = keys ( source ) ; return reduce ( defaultKeys , function ( result , key ) { if ( sourceKeys . indexOf ( key ) > - 1 ) { result [ key ] = source [ key ] ; return result ; } else { result [ key ] = defaults [ key ] ; return result ; } } , { } ) ; } 
function suggest_tick_num ( domain ) { var MAX_TICKS = 10 ; var INTERVAL_BASE_VALS = [ 1 , 2 , 2.5 , 5 , 10 , 25 ] ; var range = Math . abs ( domain [ 0 ] - domain [ 1 ] ) var minimum = range / MAX_TICKS ; var digits = Math . floor ( range ) . toString ( ) . length ; var multiplier = Math . pow ( 10 , ( digits - 2 ) ) ; var acceptable_intervals = reduce ( INTERVAL_BASE_VALS , function ( prev , curr ) { var mult = curr * multiplier ; if ( mult >= minimum ) { prev = prev . concat ( [ mult ] ) ; } return prev ; } , [ ] ) ; for ( var i = 0 ; i < acceptable_intervals . length ; i ++ ) { var interval = acceptable_intervals [ i ] if ( range % interval == 0 ) { return ( range / interval ) + 1 } } ; return 11 ; } 
function tz_offset_to_minutes ( offset ) { if ( offset == "Z" ) { return 0 } var offset = offset . split ( ":" ) if ( offset . length == 1 ) { offset = offset [ 0 ] split_loc = offset . length - 2 offset = [ offset . substring ( 0 , split_loc ) , offset . substring ( split_loc ) ] } sign = offset [ 0 ] . indexOf ( "-" ) > - 1 ? - 1 : 1 offset = offset . map ( parseFloat ) return ( offset [ 0 ] * 60 ) + ( sign * offset [ 1 ] ) } 
function ChartConfig ( settings ) { this . displayName = settings . displayName ; this . parser = settings . parser ; this . calculateDimensions = settings . calculateDimensions ; this . display = settings . display ; this . defaultProps = settings . defaultProps ; } 
function dataBySeries ( input , opts ) { var series ; opts = opts || { } ; var parsedInput = parseDelimInput ( input , { checkForDate : opts . checkForDate , type : opts . type } ) ; var columnNames = parsedInput . columnNames ; var keyColumn = columnNames . shift ( ) ; if ( columnNames . length === 0 ) { series = [ { name : keyColumn , values : parsedInput . data . map ( function ( d ) { return { name : keyColumn , value : d [ keyColumn ] } ; } ) } ] ; } else { series = columnNames . map ( function ( header , i ) { return { name : header , values : parsedInput . data . map ( function ( d ) { return { name : header , entry : d [ keyColumn ] , value : d [ header ] } ; } ) } ; } ) ; } return { series : series , input : { raw : input , type : opts . type } , hasDate : parsedInput . hasDate && ( ! opts . type || opts . type == "date" ) , isNumeric : parsedInput . isNumeric && ( ! opts . type || opts . type == "numeric" ) } ; } 
function generate_scale ( type , scaleOptions , data , range , additionalOpts ) { if ( ! scaleOptions ) return { } ; return scale_types [ type ] ( scaleOptions , data , range , additionalOpts ) ; } 
function _ordinalAdjust ( scale , value ) { var isOrdinal = scale . hasOwnProperty ( "bandwidth" ) ; if ( isOrdinal ) { return scale ( value ) + scale . bandwidth ( ) / 2 ; } else { return scale ( value ) ; } } 
function get_tick_widths ( scaleOptions , font ) { if ( ! scaleOptions ) return { width : [ ] , max : 0 } ; var numTicks = scaleOptions . tickValues . length - 1 ; var formattedTicks = reduce ( scaleOptions . tickValues , function ( prev , tick , i ) { if ( i === numTicks ) { return prev . concat ( [ scaleOptions . prefix , help . roundToPrecision ( tick , scaleOptions . precision ) , scaleOptions . suffix ] . join ( "" ) ) ; } else { return prev . concat ( help . roundToPrecision ( tick , scaleOptions . precision ) ) ; } } , [ ] ) ; var widths = map ( formattedTicks , function ( text ) { return help . computeTextWidth ( text , font ) ; } ) ; return { widths : widths , max : d3 . max ( widths . slice ( 0 , - 1 ) ) 
function detectNumberSeparators ( ) { var n = 1000.50 ; var l = n . toLocaleString ( ) ; var s = n . toString ( ) ; var o = { decimal : l . substring ( 5 , 6 ) , thousands : l . substring ( 1 , 2 ) } ; if ( l . substring ( 5 , 6 ) == s . substring ( 5 , 6 ) ) { o . decimal = "." ; } if ( l . substring ( 1 , 2 ) == s . substring ( 1 , 2 ) ) { o . thousands = "," ; } return o ; } 
function validateDataInput ( chartProps ) { var input = chartProps . input . raw ; var series = chartProps . data ; var hasDate = chartProps . scale . hasDate ; var isNumeric = chartProps . scale . isNumeric ; var type = chartProps . input . type ; var scale = chartProps . scale ; var inputErrors = [ ] ; 
function registeredCallback ( payload ) { var action = payload . action ; var chartProps ; var error_messages ; var input_errors ; switch ( action . eventName ) { case "update-data-input" : case "update-and-reparse" : Dispatcher . waitFor ( [ ChartPropertiesStore . dispatchToken ] ) ; chartProps = ChartPropertiesStore . getAll ( ) ; error_messages = [ ] ; input_errors = validateDataInput ( chartProps ) ; error_messages = error_messages . concat ( input_errors ) ; _errors . messages = error_messages . map ( function ( err_name ) { return errorNames [ err_name ] ; } ) ; var isInvalid = some ( _errors . messages , { type : "error" } ) ; _errors . valid = ! isInvalid ; ErrorStore . emitChange ( ) ; break ; default : 
function calculate_xy_dimensions ( width , opts ) { var height ; var aspectRatio = opts . displayConfig . aspectRatio ; var metadata = opts . metadata ; if ( metadata . size == "auto" || opts . enableResponsive ) { 
function getErrorMessage ( key , action ) { var actionType = action && action . type ; var actionName = actionType && ` ${ actionType . toString ( ) } ` || 'an action' ; return ( ` ${ key } ${ actionName } ` + ` ` ) ; } 
function cliCompleter ( set , done ) { var exposed = { } set . valueOf ( ) . forEach ( expose ) set . valueOf ( ) . forEach ( checkFactory ( exposed ) ) done ( ) function expose ( file ) { var landmarks = file . data [ landmarkId ] if ( landmarks ) { xtend ( exposed , landmarks ) } } } 
function transformerFactory ( fileSet , info ) { return transformer 
function validate ( exposed , file ) { var references = file . data [ referenceId ] var filePath = file . path var reference var nodes var real var hash var pathname var warning var suggestion var ruleId for ( reference in references ) { nodes = references [ reference ] real = exposed [ reference ] hash = getHash ( reference ) 
function gatherReferences ( file , tree , info , fileSet ) { var cache = { } var getDefinition = definitions ( tree ) var prefix = '' var headingPrefix = '#' var lines if ( info && info . type in viewPaths ) { prefix = '/' + info . path ( ) + '/' + viewPaths [ info . type ] + '/' } if ( info && info . type in headingPrefixes ) { headingPrefix = headingPrefixes [ info . type ] } lines = info && info . type in lineLinks ? lineLinks [ info . type ] : false visit ( tree , [ 'link' , 'image' , 'linkReference' , 'imageReference' ] , onresource ) return cache 
function onresource ( node ) { var link = node . url var definition var index var uri var pathname var hash 
function warnAll ( file , nodes , reason , ruleId ) { nodes . forEach ( one ) function one ( node ) { file . message ( reason , node , [ sourceId , ruleId ] . join ( ':' ) ) } } 
function getClosest ( pathname , references ) { var hash = getHash ( pathname ) var base = getPathname ( pathname ) var dictionary = [ ] var reference var subhash var subbase for ( reference in references ) { subbase = getPathname ( reference ) subhash = getHash ( reference ) if ( getPathname ( reference ) === base ) { if ( subhash && hash ) { dictionary . push ( subhash ) } } else if ( ! subhash && ! hash ) { dictionary . push ( subbase ) } } return propose ( hash ? hash : base , dictionary , { threshold : 0.7 } ) } 
function getHash ( uri ) { var hash = parse ( uri ) . hash return hash ? hash . slice ( 1 ) : null } 
function getPrevMap ( from ) { if ( typeof options . map . prev === 'string' ) { var mapPath = options . map . prev + path . basename ( from ) + '.map' ; if ( grunt . file . exists ( mapPath ) ) { return grunt . file . read ( mapPath ) ; } } } 
function ( req , res , next ) { if ( req . url . indexOf ( '.' ) === - 1 && req . url . indexOf ( startDir ) > - 1 ) { req . url = startPath ; } return next ( ) ; } 
function one ( node ) { var type = node && node . type if ( type in map ) { node = map [ type ] ( node ) } if ( 'length' in node ) { node = all ( node ) } if ( node . children ) { node . children = all ( node . children ) } return node } 
function Server ( options ) { if ( typeof ( options ) !== 'object' ) throw new TypeError ( 'options (object) is required' ) ; this . _log = options . log . child ( { component : 'agent' } , true ) ; this . _name = options . name || "named" ; this . _socket = null ; } 
function parseIPv4 ( addr ) { if ( typeof ( addr ) !== 'string' ) throw new TypeError ( 'addr (string) is required' ) ; var octets = addr . split ( / \. / ) . map ( function ( octet ) { return ( parseInt ( octet , 10 ) ) ; } ) ; if ( octets . length !== 4 ) throw new TypeError ( 'valid IP address required' ) ; var uint32 = ( ( octets [ 0 ] * Math . pow ( 256 , 3 ) ) + ( octets [ 1 ] * Math . pow ( 256 , 2 ) ) + ( octets [ 2 ] * 256 ) + octets [ 3 ] ) ; return ( uint32 ) ; } 
function getNested ( obj , prop ) { var service = obj [ prop ] ; if ( service === undefined && Bottle . config . strict ) { throw new Error ( 'Bottle was unable to resolve a service. `' + prop + '` is undefined.' ) ; } return service ; } 
function getNestedBottle ( name ) { var bottle ; if ( ! this . nested [ name ] ) { bottle = Bottle . pop ( ) ; this . nested [ name ] = bottle ; this . factory ( name , function SubProviderFactory ( ) { return bottle . container ; } ) ; } return this . nested [ name ] ; } 
function applyMiddleware ( middleware , name , instance , container ) { var descriptor = { configurable : true , enumerable : true } ; if ( middleware . length ) { descriptor . get = function getWithMiddlewear ( ) { var index = 0 ; var next = function nextMiddleware ( err ) { if ( err ) { throw err ; } if ( middleware [ index ] ) { middleware [ index ++ ] ( instance , next ) ; } } ; next ( ) ; return instance ; } ; } else { descriptor . value = instance ; descriptor . writable = true ; } Object . defineProperty ( container , name , descriptor ) ; return container [ name ] ; } 
function middleware ( fullname , func ) { var parts , name ; if ( typeof fullname === FUNCTION_TYPE ) { func = fullname ; fullname = GLOBAL_NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . middleware ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . middlewares [ name ] ) { this . middlewares [ name ] = [ ] ; } this . middlewares [ name ] . push ( func ) ; } return this ; } 
function createProvider ( name , Provider ) { var providerName , properties , container , id , decorators , middlewares ; id = this . id ; container = this . container ; decorators = this . decorators ; middlewares = this . middlewares ; providerName = name + PROVIDER_SUFFIX ; properties = Object . create ( null ) ; properties [ providerName ] = { configurable : true , enumerable : true , get : function getProvider ( ) { var instance = new Provider ( ) ; delete container [ providerName ] ; container [ providerName ] = instance ; return instance ; } } ; properties [ name ] = { configurable : true , enumerable : true , get : function getService ( ) { var provider = container [ providerName ] ; var instance ; if ( provider ) { 
function provider ( fullname , Provider ) { var parts , name ; parts = fullname . split ( DELIMITER ) ; if ( this . providerMap [ fullname ] && parts . length === 1 && ! this . container [ fullname + PROVIDER_SUFFIX ] ) { return console . error ( fullname + ' provider already instantiated.' ) ; } this . originalProviders [ fullname ] = Provider ; this . providerMap [ fullname ] = true ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . provider ( parts . join ( DELIMITER ) , Provider ) ; return this ; } return createProvider . call ( this , name , Provider ) ; } 
function createService ( name , Service , isClass ) { var deps = arguments . length > 3 ? slice . call ( arguments , 3 ) : [ ] ; var bottle = this ; return factory . call ( this , name , function GenericFactory ( ) { var serviceFactory = Service ; 
function service ( name , Service ) { return createService . apply ( this , [ name , Service , true ] . concat ( slice . call ( arguments , 2 ) ) ) ; } 
function serviceFactory ( name , factoryService ) { return createService . apply ( this , [ name , factoryService , false ] . concat ( slice . call ( arguments , 2 ) ) ) ; } 
function defineValue ( name , val ) { Object . defineProperty ( this , name , { configurable : true , enumerable : true , value : val , writable : true } ) ; } 
function setValueObject ( container , name ) { var nestedContainer = container [ name ] ; if ( ! nestedContainer ) { nestedContainer = { } ; defineValue . call ( container , name , nestedContainer ) ; } return nestedContainer ; } 
function value ( name , val ) { var parts ; parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; defineValue . call ( parts . reduce ( setValueObject , this . container ) , name , val ) ; return this ; } 
function constant ( name , value ) { var parts = name . split ( DELIMITER ) ; name = parts . pop ( ) ; defineConstant . call ( parts . reduce ( setValueObject , this . container ) , name , value ) ; return this ; } 
function decorator ( fullname , func ) { var parts , name ; if ( typeof fullname === FUNCTION_TYPE ) { func = fullname ; fullname = GLOBAL_NAME ; } parts = fullname . split ( DELIMITER ) ; name = parts . shift ( ) ; if ( parts . length ) { getNestedBottle . call ( this , name ) . decorator ( parts . join ( DELIMITER ) , func ) ; } else { if ( ! this . decorators [ name ] ) { this . decorators [ name ] = [ ] ; } this . decorators [ name ] . push ( func ) ; } return this ; } 
function instanceFactory ( name , Factory ) { return factory . call ( this , name , function GenericInstanceFactory ( container ) { return { instance : Factory . bind ( Factory , container ) } ; } ) ; } 
function pop ( name ) { var instance ; if ( typeof name === STRING_TYPE ) { instance = bottles [ name ] ; if ( ! instance ) { bottles [ name ] = instance = new Bottle ( ) ; instance . constant ( 'BOTTLE_NAME' , name ) ; } return instance ; } return new Bottle ( ) ; } 
function register ( Obj ) { var value = Obj . $value === undefined ? Obj : Obj . $value ; return this [ Obj . $type || 'service' ] . apply ( this , [ Obj . $name , value ] . concat ( Obj . $inject || [ ] ) ) ; } 
function resetProviders ( names ) { var tempProviders = this . originalProviders ; var shouldFilter = Array . isArray ( names ) ; Object . keys ( this . originalProviders ) . forEach ( function resetProvider ( originalProviderName ) { if ( shouldFilter && names . indexOf ( originalProviderName ) === - 1 ) { return ; } var parts = originalProviderName . split ( DELIMITER ) ; if ( parts . length > 1 ) { parts . forEach ( removeProviderMap , getNestedBottle . call ( this , parts [ 0 ] ) ) ; } removeProviderMap . call ( this , originalProviderName ) ; this . provider ( originalProviderName , tempProviders [ originalProviderName ] ) ; } , this ) ; } 
function determinationCoefficient ( data , results ) { const predictions = [ ] ; const observations = [ ] ; data . forEach ( ( d , i ) => { if ( d [ 1 ] !== null ) { observations . push ( d ) ; predictions . push ( results [ i ] ) ; } } ) ; const sum = observations . reduce ( ( a , observation ) => a + observation [ 1 ] , 0 ) ; const mean = sum / observations . length ; const ssyy = observations . reduce ( ( a , observation ) => { const difference = observation [ 1 ] - mean ; return a + ( difference * difference ) ; } , 0 ) ; const sse = observations . reduce ( ( accum , observation , index ) => { const prediction = predictions [ index ] ; const residual = observation [ 1 ] - prediction [ 1 ] ; return accum + ( residual * residual ) ; } , 0 ) ; return 1 - ( sse / ssyy ) ; } 
function gaussianElimination ( input , order ) { const matrix = input ; const n = input . length - 1 ; const coefficients = [ order ] ; for ( let i = 0 ; i < n ; i ++ ) { let maxrow = i ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( matrix [ i ] [ j ] ) > Math . abs ( matrix [ i ] [ maxrow ] ) ) { maxrow = j ; } } for ( let k = i ; k < n + 1 ; k ++ ) { const tmp = matrix [ k ] [ i ] ; matrix [ k ] [ i ] = matrix [ k ] [ maxrow ] ; matrix [ k ] [ maxrow ] = tmp ; } for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = n ; k >= i ; k -- ) { matrix [ k ] [ j ] -= ( matrix [ k ] [ i ] * matrix [ i ] [ j ] ) / matrix [ i ] [ i ] ; } } } for ( let j = n - 1 ; j >= 0 ; j -- ) { let total = 0 ; for ( let k = j + 1 ; k < n ; k ++ ) { total += matrix [ k ] [ j ] * coefficients [ k ] ; } coefficients [ j ] = ( matrix [ n ] [ j ] - total ) / matrix [ j ] [ j ] ; } return coefficients ; } 
function throwIfInvalidNode ( node , functionName ) { if ( ! exports . isASTNode ( node ) ) { throw new Error ( functionName + "(): " + util . inspect ( node ) + " is not a valid AST node." ) ; } } 
function create ( context ) { const events = [ ] , callExpressions = [ ] , sourceCode = context . getSourceCode ( ) ; 
function isEvent ( expr , eventDeclarations ) { for ( let { node , enclosingContract } of eventDeclarations ) { if ( expr . callee . name === node . name && sourceCode . isAChildOf ( expr , enclosingContract ) ) { return true ; } } return false ; } 
function registerEventName ( emitted ) { const { node } = emitted ; ( ! emitted . exit ) && events . push ( { node , enclosingContract : sourceCode . getParent ( node ) } ) ; } 
function inspectVariableDeclarator ( emitted ) { let node = emitted . node ; if ( ! emitted . exit ) { allVariableDeclarations [ node . id . name ] = node ; } } 
function inspectProgram ( emitted ) { if ( emitted . exit ) { Object . keys ( allVariableDeclarations ) . forEach ( function ( name ) { context . report ( { node : allVariableDeclarations [ name ] , message : "Variable '" + name + "' is declared but never used." } ) ; } ) ; } } 
function inspectIdentifier ( emitted ) { if ( ! emitted . exit ) { let node = emitted . node , sourceCode = context . getSourceCode ( ) ; if ( allVariableDeclarations [ node . name ] && sourceCode . getParent ( node ) . type !== "VariableDeclarator" ) { delete allVariableDeclarations [ node . name ] ; } } } 
function inspectFunctionsOfContract ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , { body } = node ; let cursor = 0 ; 
function inspectModifierDeclaration ( emitted ) { let node = emitted . node ; if ( emitted . exit ) { return ; } 
function inspectCallExpression ( emitted ) { let node = emitted . node , callArgs = node . arguments ; if ( emitted . exit ) { return ; } let nodeCode = sourceCode . getText ( node ) ; 
function inspectProgram ( emitted ) { let node = emitted . node , body = node . body ; if ( ! emitted . exit || missingNodeOnTopErrorReported ) { return ; } ( body . length > 0 ) && ( body [ 0 ] . type !== "PragmaStatement" ) && context . report ( { node : node , message : "No Pragma directive found at the top of file." } ) ; } 
function inspectExperimentalPragmaStatement ( emitted ) { if ( emitted . exit ) { return ; } const { node } = emitted , nodesAllowedAbove = [ "ExperimentalPragmaStatement" , "PragmaStatement" ] , programNode = context . getSourceCode ( ) . getParent ( node ) ; for ( let childNode of programNode . body ) { 
function ( sourceCode , errorMessages ) { let fixedSourceCode = "" , fixes = [ ] , fixesApplied = [ ] , remainingMessages = [ ] ; let cursor = Number . NEGATIVE_INFINITY ; function attemptFix ( fix ) { let start = fix . range [ 0 ] , end = fix . range [ 1 ] ; 
function getIndentDescription ( indentStyle , level ) { 
function inspectProgram ( emitted ) { let node = emitted . node ; if ( emitted . exit ) { return ; } function inspectProgramChild ( programChild ) { 
function inspectTopLevelDeclaration ( emitted ) { let body = emitted . node . body || [ ] , levelOneIndentRegExp = new RegExp ( "^\\n" + BASE_INDENTATION_STYLE + "$" ) , endingLineRegExp = new RegExp ( "^" + BASE_INDENTATION_STYLE + "(\\S| \\*)$" ) , 
function inspectBlockStatement ( emitted ) { let node = emitted . node ; * If the block item spans over multiple lines, make sure the ending line also follows the indent rule * An exception to this is the if-else statements when they don't have BlockStatement as their body * eg- * if (a) * foo(); * else * bar(); * * Another exception is chaining. * eg- * function() { * myObject * .funcA() * .funcB() * [0]; * } * Ending line has 1 extra indentation but this is acceptable. */ if ( blockItem . type !== "IfStatement" && sourceCode . getLine ( blockItem ) !== endingLineNum && ! endingLineRegExp . test ( sourceCode . getTextOnLine ( endingLineNum ) ) ) { context . report ( { node : blockItem , location : { line : endingLineNum , column : 0 } , message : ` ${ blockIndentDesc } ` } ) ; } } currentIndent = parentDeclarationLineText . slice ( 0 , parentDeclarationLineText . indexOf ( parentDeclarationLineText . trim ( ) ) ) ; //in case of no match, match() returns null. Return [] instead to avoid crash currentIndentLevel = ( currentIndent . match ( BASE_INDENTATION_STYLE_REGEXP_GLOBAL ) || [ ] ) . length ; //ensure that there is only whitespace of correct level before the block's parent's code if ( getIndentString ( BASE_INDENTATION_STYLE , currentIndentLevel ) !== currentIndent ) { return ; //exit now, we can' proceed further unless this is fixed } 
function inspectFunctionDeclaration ( emitted ) { let node = emitted . node , params = node . params || [ ] ; let startLine = sourceCode . getLine ( node ) , lastArgLine = params . length ? sourceCode . getEndingLine ( params . slice ( - 1 ) [ 0 ] ) : startLine , functionDeclarationLineText , currentIndent , currentIndentLevel ; function inspectParam ( paramIndent , paramIndentDesc , param ) { let indentRegExp = new RegExp ( "^" + paramIndent + "[^\\s(\/\*)]" ) , paramLineText = sourceCode . getTextOnLine ( sourceCode . getLine ( param ) ) ; 
function checkNodes ( nodes ) { if ( ! Array . isArray ( nodes ) ) { nodes = [ nodes ] ; } nodes . forEach ( node => { let lineNumber = sourceCode . getLine ( node ) - 1 ; if ( lineNumber > lastLine && lines [ lineNumber ] . length > maxLineLength ) { context . report ( { node , message : ` ${ maxLineLength } ` } ) ; lastLine = lineNumber ; } checkNodes ( node . body || [ ] ) ; } ) ; } 
function ( node , beforeCount , afterCount ) { let sourceCodeText = this . text ; if ( node ) { if ( astUtils . isASTNode ( node ) ) { return this . text . slice ( Math . max ( 0 , node . start - ( Math . abs ( beforeCount ) || 0 ) ) , node . end + ( Math . abs ( afterCount ) || 0 ) ) ; } throw new Error ( "Invalid Node object" ) ; } return sourceCodeText ; } 
function ( prevNode , currentNode ) { if ( prevNode && astUtils . isASTNode ( prevNode ) && currentNode && astUtils . isASTNode ( currentNode ) && prevNode . start <= currentNode . start ) { return this . text . slice ( prevNode . end , currentNode . start ) ; } throw new Error ( "Invalid argument for one or both nodes" ) ; } 
function ( lineNumber ) { 
function inspectVariableDeclaration ( emitted ) { let node = emitted . node , code = sourceCode . getText ( node ) ; if ( emitted . exit ) { return ; } 
function RuleContext ( ruleName , ruleDesc , ruleMeta , Solium ) { let contextObject = this ; * wrapper around Solium.report () which adds some additional information to the error object * @param {Object} error An object describing the lint error, sent by the rule currently running */ contextObject . report = function ( error ) { if ( ! isErrObjectValid ( error ) ) { throw new Error ( ` ${ ruleName } ${ EOL } ${ util . inspect ( isErrObjectValid . errors ) } ` ) ; } Object . assign ( error , { ruleName : ruleName , ruleMeta : ruleMeta , type : contextObject . meta . type } ) ; Solium . report ( error ) ; } ; } 
function resolveUpstream ( upstream ) { let coreRulesetRegExp = / ^solium:[a-z_]+$ / ; 
function resolvePluginConfig ( name , plugin ) { let config = { } ; Object . keys ( plugin . rules ) . forEach ( function ( ruleName ) { config [ name + "/" + ruleName ] = plugin . rules [ ruleName ] . meta . docs . type ; } ) ; return config ; } 
function load ( listOfRules ) { let ruleDefs = { } ; listOfRules . forEach ( function ( name ) { 
function writeConfigFile ( config ) { try { fs . writeFileSync ( SOLIUMRC_FILENAME_ABSOLUTE , JSON . stringify ( config , null , 2 ) ) ; } catch ( e ) { errorReporter . reportFatal ( ` ${ SOLIUMRC_FILENAME_ABSOLUTE } ${ EOL } ${ e . message } ` ) ; process . exit ( errorCodes . WRITE_FAILED ) ; } } 
function createDefaultSoliumIgnore ( ) { try { fs . writeFileSync ( SOLIUMIGNORE_FILENAME_ABSOLUTE , fs . readFileSync ( DEFAULT_SOLIUMIGNORE_PATH ) ) ; } catch ( e ) { errorReporter . reportFatal ( ` ${ SOLIUMIGNORE_FILENAME_ABSOLUTE } ${ EOL } ${ e . message } ` ) ; process . exit ( errorCodes . WRITE_FAILED ) ; } } 
function lintString ( sourceCode , userConfig , errorReporter , fileName ) { let lintErrors , fixesApplied ; try { if ( userConfig . options . autofix || userConfig . options . autofixDryrun ) { let result = solium . lintAndFix ( sourceCode , userConfig ) ; lintErrors = result . errorMessages ; if ( userConfig . options . autofix ) { applyFixes ( fileName , result ) ; fixesApplied = result . fixesApplied ; } else { errorReporter . reportDiff ( fileName , sourceCode , result . fixedSourceCode , result . fixesApplied . length ) ; } } else { lintErrors = solium . lint ( sourceCode , userConfig ) ; } } catch ( e ) { 
function lintFile ( fileName , userConfig , errorReporter ) { let sourceCode ; try { sourceCode = fs . readFileSync ( fileName , "utf8" ) ; } catch ( e ) { errorReporter . reportFatal ( "Unable to read " + fileName + ": " + e . message ) ; process . exit ( errorCodes . FILE_NOT_FOUND ) ; } return lintString ( sourceCode , userConfig , errorReporter , fileName ) ; } 
function lint ( userConfig , input , ignore , errorReporter ) { let filesToLint , errorCount ; 
function createCliOptions ( cliObject ) { function collect ( val , memo ) { memo . push ( val ) ; return memo ; } cliObject . version ( ` ${ version } ` ) . description ( "Linter to find & fix style and security issues in Solidity smart contracts." ) . usage ( "[options] <keyword>" ) . option ( "-i, --init" , "Create default rule configuration files" ) . option ( "-f, --file [filepath::String]" , "Solidity file to lint" ) . option ( "-d, --dir [dirpath::String]" , "Directory containing Solidity files to lint" ) . option ( "-R, --reporter [name::String]" , "Format to report lint issues in (pretty | gcc)" , "pretty" ) . option ( "-c, --config [filepath::String]" , "Path to the .soliumrc configuration file" ) . option ( "-, --stdin" , "Read input file from stdin" ) . option ( "--fix" , "Fix Lint issues where possible" ) . option ( "--fix-dry-run" , "Output fix diff without applying it" ) . option ( "--debug" , "Display debug information" ) . option ( "--watch" , "Watch for file changes" ) . option ( "--hot" , "(Deprecated) Same as --watch" ) . option ( "--no-soliumignore" , "Do not look for .soliumignore file" ) . option ( "--no-soliumrc" , "Do not look for soliumrc configuration file" ) . option ( "--rule [rule]" , "Rule to execute. This overrides the specified rule's configuration in soliumrc if present" , collect , [ ] ) . option ( "--plugin [plugin]" , "Plugin to execute. This overrides the specified plugin's configuration in soliumrc if present" , collect , [ ] ) ; } 
function execute ( programArgs ) { let userConfig = { } , ignore , errorReporter ; createCliOptions ( cli ) ; programArgs . length === 2 ? cli . help ( ) : cli . parse ( programArgs ) ; if ( cli . init ) { return setupDefaultUserConfig ( ) ; } try { errorReporter = getErrorReporter ( cli . reporter ) ; } catch ( e ) { process . stderr . write ( ` ${ e . message } ${ EOL } ` ) ; process . exit ( errorCodes . INVALID_PARAMS ) ; } if ( cli . soliumrc ) { const soliumrcAbsPath = cli . config ? ( path . isAbsolute ( cli . config ) ? cli . config : path . join ( CWD , cli . config ) ) : SOLIUMRC_FILENAME_ABSOLUTE ; try { userConfig = require ( soliumrcAbsPath ) ; } catch ( e ) { 
function ( options , listItemsSchema ) { let validateOptionsList = SchemaValidator . compile ( { type : "array" , minItems : listItemsSchema . length , additionalItems : false , items : listItemsSchema } ) ; return validateOptionsList ( options ) ; } 
function inspectFD ( emitted ) { const { node } = emitted , visibilityModifiers = [ "public" , "external" , "internal" , "private" ] ; const modifiers = ( node . modifiers || [ ] ) , firstVisibilityModifierIndex = modifiers . findIndex ( m => visibilityModifiers . includes ( m . name ) ) ; 
function inspectFunctionDeclaration ( emitted ) { let node = emitted . node , params = node . params || [ ] ; let startLine = sourceCode . getLine ( node ) , lastArgLine = params . length ? sourceCode . getEndingLine ( params . slice ( - 1 ) [ 0 ] ) : startLine ; if ( emitted . exit ) { return ; } if ( startLine === lastArgLine ) { if ( params . length > MAX_IN_SINGLE_LINE ) { context . report ( { node : node , message : "In case of more than " + MAX_IN_SINGLE_LINE + " parameters, drop each into its own line." } ) ; } return ; } } 
function isHex ( literal ) { let reg = / ^[0-9a-f]+$ / i ; 
function Soundfont ( ctx , nameToUrl ) { console . warn ( 'new Soundfont() is deprected' ) console . log ( 'Please use Soundfont.instrument() instead of new Soundfont().instrument()' ) if ( ! ( this instanceof Soundfont ) ) return new Soundfont ( ctx ) this . nameToUrl = nameToUrl || Soundfont . nameToUrl this . ctx = ctx this . instruments = { } this . promises = [ ] } 
function loadBuffers ( ac , name , options ) { console . warn ( 'Soundfont.loadBuffers is deprecate.' ) console . log ( 'Use Soundfont.instrument(..) and get buffers properties from the result.' ) return Soundfont . instrument ( ac , name , options ) . then ( function ( inst ) { return inst . buffers } ) } 
function oscillatorPlayer ( ctx , defaultOptions ) { defaultOptions = defaultOptions || { } return function ( note , time , duration , options ) { console . warn ( 'The oscillator player is deprecated.' ) console . log ( 'Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.' ) var midi = note > 0 && note < 129 ? + note : parser . midi ( note ) var freq = midi ? parser . midiToFreq ( midi , 440 ) : null if ( ! freq ) return duration = duration || 0.2 options = options || { } var destination = options . destination || defaultOptions . destination || ctx . destination var vcoType = options . vcoType || defaultOptions . vcoType || 'sine' var gain = options . gain || defaultOptions . gain || 0.4 var vco = ctx . createOscillator ( ) vco . type = vcoType vco . frequency . value = freq var vca = ctx . createGain ( ) vca . gain . value = gain vco . connect ( vca ) vca . connect ( destination ) vco . start ( time ) if ( duration > 0 ) vco . stop ( time + duration ) return vco } } 
function instrument ( ac , name , options ) { if ( arguments . length === 1 ) return function ( n , o ) { return instrument ( ac , n , o ) } var opts = options || { } var isUrl = opts . isSoundfontURL || isSoundfontURL var toUrl = opts . nameToUrl || nameToUrl var url = isUrl ( name ) ? name : toUrl ( name , opts . soundfont , opts . format ) return load ( ac , url , { only : opts . only || opts . notes } ) . then ( function ( buffers ) { var p = player ( ac , buffers , opts ) . connect ( opts . destination ? opts . destination : ac . destination ) p . url = url p . name = name return p } ) } 
function nameToUrl ( name , sf , format ) { format = format === 'ogg' ? format : 'mp3' sf = sf === 'FluidR3_GM' ? sf : 'MusyngKite' return 'https://gleitz.github.io/midi-js-soundfonts/' + sf + '/' + name + '-' + format + '.js' } 
function hasSystemLib ( lib ) { var libName = 'lib' + lib + '.+(so|dylib)' var libNameRegex = new RegExp ( libName ) 
function hasLdconfig ( ) { try { 
async function thenify ( fn ) { return await new Promise ( function ( resolve , reject ) { function callback ( err , res ) { if ( err ) return reject ( err ) ; return resolve ( res ) ; } fn ( callback ) ; } ) ; } 
function startWatching ( opts ) { var chokidarOpts = createChokidarOpts ( opts ) ; var watcher = chokidar . watch ( opts . patterns , chokidarOpts ) ; var throttledRun = _ . throttle ( run , opts . throttle ) ; var debouncedRun = _ . debounce ( throttledRun , opts . debounce ) ; watcher . on ( 'all' , function ( event , path ) { var description = EVENT_DESCRIPTIONS [ event ] + ':' ; if ( opts . verbose ) { console . error ( description , path ) ; } else { if ( ! opts . silent ) { console . log ( event + ':' + path ) ; } } 
function _resolveIgnoreOpt ( ignoreOpt ) { if ( ! ignoreOpt ) { return ignoreOpt ; } var ignores = ! _ . isArray ( ignoreOpt ) ? [ ignoreOpt ] : ignoreOpt ; return _ . map ( ignores , function ( ignore ) { var isRegex = ignore [ 0 ] === '/' && ignore [ ignore . length - 1 ] === '/' ; if ( isRegex ) { 
function run ( cmd , opts ) { if ( ! SHELL_PATH ) { 
function requireProp ( props , propName , componentName ) { return isEmpty ( props [ propName ] ) ? new Error ( ` \` ${ propName } \` \` ${ componentName } \` ` ) : null } 
function _0to1 ( props , propName , componentName ) { if ( isEmpty ( props [ propName ] ) ) { return null } if ( typeof props [ propName ] === 'number' && props [ propName ] >= 0 && props [ propName ] <= 1 ) { return null } return new Error ( ` \` ${ propName } \` \` ${ componentName } \` ` ) } 
function babel ( options = { } ) { return ( context , { addLoader } ) => addLoader ( { 
function extractCss ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.css$ / , use : [ { loader : MiniCssExtractPlugin . loader , } , ] , ... context . match , } ) } 
function imageLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.(gif|ico|jpg|jpeg|png|webp)$ / , loader : 'url-loader' , options : { limit : 10000 , name : fileNameTemplate , } , } ) } 
function csvLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.csv$ / , loader : 'csv-loader' , options : { dynamicTyping : true , header : true , skipEmptyLines : true , } , } ) } 
function reactSvgLoader ( ) { return ( context , { addLoader } ) => addLoader ( { test : / \.svg$ / , issuer : { test : / \.(js|jsx|ts|tsx)$ / , } , use : [ 
function cssSvgLoader ( ) { return ( context , { addLoader } ) => addLoader ( { 
function prependEntry ( entry ) { const blockFunction = ( context , util ) => { if ( ! context . entriesToPrepend ) context . entriesToPrepend = [ ] context . entriesToPrepend . unshift ( entry ) return config => config } return Object . assign ( blockFunction , { post : prependEntryPostHook , } ) } 
function build ( ) { log . info ( ` ` ) const compiler = createWebpackCompiler ( ( ) => { log . ok ( ` ${ chalk . cyan ( relativeAppBuildPath ) } ` ) } , ( ) => { log . err ( ` ` ) process . exit ( 2 ) } ) return new Promise ( ( resolve , reject ) => { compiler . run ( ( err , stats ) => { if ( err ) { return reject ( err ) } return resolve ( stats ) } ) } ) } 
function createWebpackCompiler ( onFirstReadyCallback = ( ) => { } , onError = ( ) => { } ) { let compiler try { const config = readWebpackConfig ( ) compiler = webpack ( config ) } catch ( err ) { log . err ( ` \n ${ err . message || err } ` ) process . exit ( 1 ) } const useTypeScript = fs . existsSync ( ` ${ appDir } ` ) 
function mergeData ( to , from ) { if ( ! from ) { return to } var key , toVal , fromVal ; var keys = Object . keys ( from ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { key = keys [ i ] ; toVal = to [ key ] ; fromVal = from [ key ] ; if ( ! hasOwn ( to , key ) ) { set ( to , key , fromVal ) ; } else if ( toVal !== fromVal && isPlainObject ( toVal ) && isPlainObject ( fromVal ) ) { mergeData ( toVal , fromVal ) ; } } return to } 
function withMacroTask ( fn ) { return fn . _withTask || ( fn . _withTask = function ( ) { useMacroTask = true ; try { return fn . apply ( null , arguments ) } finally { useMacroTask = false ; } } ) } 
function transformNode ( el , options ) { var warn = options . warn || baseWarn ; var staticClass = getAndRemoveAttr ( el , 'class' ) ; if ( staticClass ) { var res = parseText ( staticClass , options . delimiters ) ; if ( res ) { warn ( "class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.' ) ; } } if ( staticClass ) { el . staticClass = JSON . stringify ( staticClass ) ; } var classBinding = getBindingAttr ( el , 'class' , false ) ; if ( classBinding ) { el . classBinding = classBinding ; } } 
function transformNode$1 ( el , options ) { var warn = options . warn || baseWarn ; var staticStyle = getAndRemoveAttr ( el , 'style' ) ; if ( staticStyle ) { { var res = parseText ( staticStyle , options . delimiters ) ; if ( res ) { warn ( "style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.' ) ; } } el . staticStyle = JSON . stringify ( parseStyleText ( staticStyle ) ) ; } var styleBinding = getBindingAttr ( el , 'style' , false ) ; if ( styleBinding ) { el . styleBinding = styleBinding ; } } 
function isPlainObject ( value ) { if ( ! isObjectLike_1 ( value ) || _baseGetTag ( value ) != objectTag ) { return false ; } var proto = _getPrototype ( value ) ; if ( proto === null ) { return true ; } var Ctor = hasOwnProperty$1 . call ( proto , 'constructor' ) && proto . constructor ; return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString . call ( Ctor ) == objectCtorString ; } 
function getType ( fn ) { var type = fn !== null && fn !== undefined ? fn . type ? fn . type : fn : null ; var match = type && type . toString ( ) . match ( FN_MATCH_REGEXP ) ; return match && match [ 1 ] ; } 
function withDefault ( type ) { return Object . defineProperty ( type , 'def' , { value : function value ( def ) { if ( def === undefined && ! this . default ) { return this ; } if ( ! isFunction ( def ) && ! validateType ( this , def ) ) { warn ( this . _vueTypes_name + " - invalid default value: \"" + def + "\"" , def ) ; return this ; } if ( isArray ( def ) ) { this . default = function ( ) { return [ ] . concat ( def ) ; } ; } else if ( isPlainObject_1 ( def ) ) { this . default = function ( ) { return Object . assign ( { } , def ) ; } ; } else { this . default = def ; } return this ; } , enumerable : false , writable : false } ) ; } 
function withRequired ( type ) { return Object . defineProperty ( type , 'isRequired' , { get : function get ( ) { this . required = true ; return this ; } , enumerable : false } ) ; } 
function withValidate ( type ) { return Object . defineProperty ( type , 'validate' , { value : function value ( fn ) { this . validator = fn . bind ( this ) ; return this ; } , enumerable : false } ) ; } 
function toType ( name , obj , validateFn ) { if ( validateFn === void 0 ) { validateFn = false ; } Object . defineProperty ( obj , '_vueTypes_name' , { enumerable : false , writable : false , value : name } ) ; withDefault ( withRequired ( obj ) ) ; if ( validateFn ) { withValidate ( obj ) ; } if ( isFunction ( obj . validator ) ) { obj . validator = obj . validator . bind ( obj ) ; } return obj ; } 
function validateType ( type , value , silent ) { if ( silent === void 0 ) { silent = false ; } var typeToCheck = type ; var valid = true ; var expectedType ; if ( ! isPlainObject_1 ( type ) ) { typeToCheck = { type : type } ; } var namePrefix = typeToCheck . _vueTypes_name ? typeToCheck . _vueTypes_name + ' - ' : '' ; if ( hasOwn . call ( typeToCheck , 'type' ) && typeToCheck . type !== null ) { if ( isArray ( typeToCheck . type ) ) { valid = typeToCheck . type . some ( function ( type ) { return validateType ( type , value , true ) ; } ) ; expectedType = typeToCheck . type . map ( function ( type ) { return getType ( type ) ; } ) . join ( ' or ' ) ; } else { expectedType = getType ( typeToCheck ) ; if ( expectedType === 'Array' ) { valid = isArray ( value ) ; } else if ( expectedType === 'Object' ) { valid = isPlainObject_1 ( value ) ; } else if ( expectedType === 'String' || expectedType === 'Number' || expectedType === 'Boolean' || expectedType === 'Function' ) { valid = getNativeType ( value ) === expectedType ; } else { valid = value instanceof typeToCheck . type ; } } } if ( ! valid ) { silent === false && warn ( namePrefix + "value \"" + value + "\" should be of type \"" + expectedType + "\"" ) ; return false ; } if ( hasOwn . call ( typeToCheck , 'validator' ) && isFunction ( typeToCheck . validator ) ) { 
function CustomEvent ( type , eventInitDict ) { var event = document . createEvent ( eventName ) ; if ( typeof type != 'string' ) { throw new Error ( 'An event name must be provided' ) ; } if ( eventName == 'Event' ) { event . initCustomEvent = initCustomEvent ; } if ( eventInitDict == null ) { eventInitDict = defaultInitDict ; } event . initCustomEvent ( type , eventInitDict . bubbles , eventInitDict . cancelable , eventInitDict . detail ) ; return event ; } 
function initCustomEvent ( type , bubbles , cancelable , detail ) { this . initEvent ( type , bubbles , cancelable ) ; this . detail = detail ; } 
function createEventListener ( type , callback , options ) { function eventListener ( e ) { if ( eventListener . once ) { e . currentTarget . removeEventListener ( e . type , callback , eventListener ) ; eventListener . removed = true ; } if ( eventListener . passive ) { e . preventDefault = createEventListener . preventDefault ; } if ( typeof eventListener . callback === 'function' ) { eventListener . callback . call ( this , e ) ; } else if ( eventListener . callback ) { eventListener . callback . handleEvent ( e ) ; } if ( eventListener . passive ) { delete e . preventDefault ; } } eventListener . type = type ; eventListener . callback = callback ; eventListener . capture = ! ! options . capture ; eventListener . passive = ! ! options . passive ; eventListener . once = ! ! options . once ; 
function cleanUpRuntimeEvents ( ) { 
function addRuntimeEvents ( ) { cleanUpRuntimeEvents ( ) ; 
function normalizeEvent ( ev ) { if ( ev . type === 'touchmove' || ev . type === 'touchstart' || ev . type === 'touchend' ) { var touch = ev . targetTouches [ 0 ] || ev . changedTouches [ 0 ] ; return { x : touch . clientX , y : touch . clientY , id : touch . identifier } ; } else { 
function onDown ( ev ) { var event = normalizeEvent ( ev ) ; if ( ! pointerActive && ! paused ) { pointerActive = true ; decelerating = false ; pointerId = event . id ; pointerLastX = pointerCurrentX = event . x ; pointerLastY = pointerCurrentY = event . y ; trackingPoints = [ ] ; addTrackingPoint ( pointerLastX , pointerLastY ) ; addRuntimeEvents ( ) ; } } 
function onMove ( ev ) { ev . preventDefault ( ) ; var event = normalizeEvent ( ev ) ; if ( pointerActive && event . id === pointerId ) { pointerCurrentX = event . x ; pointerCurrentY = event . y ; addTrackingPoint ( pointerLastX , pointerLastY ) ; requestTick ( ) ; } } 
function onUp ( ev ) { var event = normalizeEvent ( ev ) ; if ( pointerActive && event . id === pointerId ) { stopTracking ( ) ; } } 
function addTrackingPoint ( x , y ) { var time = Date . now ( ) ; while ( trackingPoints . length > 0 ) { if ( time - trackingPoints [ 0 ] . time <= 100 ) { break ; } trackingPoints . shift ( ) ; } trackingPoints . push ( { x : x , y : y , time : time } ) ; } 
function updateAndRender ( ) { var pointerChangeX = pointerCurrentX - pointerLastX ; var pointerChangeY = pointerCurrentY - pointerLastY ; targetX += pointerChangeX * multiplier ; targetY += pointerChangeY * multiplier ; if ( bounce ) { var diff = checkBounds ( ) ; if ( diff . x !== 0 ) { targetX -= pointerChangeX * dragOutOfBoundsMultiplier ( diff . x ) * multiplier ; } if ( diff . y !== 0 ) { targetY -= pointerChangeY * dragOutOfBoundsMultiplier ( diff . y ) * multiplier ; } } else { checkBounds ( true ) ; } callUpdateCallback ( ) ; pointerLastX = pointerCurrentX ; pointerLastY = pointerCurrentY ; ticking = false ; } 
function startDecelAnim ( ) { var firstPoint = trackingPoints [ 0 ] ; var lastPoint = trackingPoints [ trackingPoints . length - 1 ] ; var xOffset = lastPoint . x - firstPoint . x ; var yOffset = lastPoint . y - firstPoint . y ; var timeOffset = lastPoint . time - firstPoint . time ; var D = timeOffset / 15 / multiplier ; decVelX = xOffset / D || 0 ; 
function stepDecelAnim ( ) { if ( ! decelerating ) { return ; } decVelX *= friction ; decVelY *= friction ; targetX += decVelX ; targetY += decVelY ; var diff = checkBounds ( ) ; if ( Math . abs ( decVelX ) > stopThreshold || Math . abs ( decVelY ) > stopThreshold || ! diff . inBounds ) { if ( bounce ) { var reboundAdjust = 2.5 ; if ( diff . x !== 0 ) { if ( diff . x * decVelX <= 0 ) { decVelX += diff . x * bounceDeceleration ; } else { var adjust = diff . x > 0 ? reboundAdjust : - reboundAdjust ; decVelX = ( diff . x + adjust ) * bounceAcceleration ; } } if ( diff . y !== 0 ) { if ( diff . y * decVelY <= 0 ) { decVelY += diff . y * bounceDeceleration ; } else { var adjust = diff . y > 0 ? reboundAdjust : - reboundAdjust ; decVelY = ( diff . y + adjust ) * bounceAcceleration ; } } } else { if ( diff . x !== 0 ) { if ( diff . x > 0 ) { targetX = boundXmin ; } else { targetX = boundXmax ; } decVelX = 0 ; } if ( diff . y !== 0 ) { if ( diff . y > 0 ) { targetY = boundYmin ; } else { targetY = boundYmax ; } decVelY = 0 ; } } callUpdateCallback ( ) ; requestAnimFrame ( stepDecelAnim ) ; } else { decelerating = false ; } } 
function checkBounds ( restrict ) { var xDiff = 0 ; var yDiff = 0 ; if ( boundXmin !== undefined && targetX < boundXmin ) { xDiff = boundXmin - targetX ; } else if ( boundXmax !== undefined && targetX > boundXmax ) { xDiff = boundXmax - targetX ; } if ( boundYmin !== undefined && targetY < boundYmin ) { yDiff = boundYmin - targetY ; } else if ( boundYmax !== undefined && targetY > boundYmax ) { yDiff = boundYmax - targetY ; } if ( restrict ) { if ( xDiff !== 0 ) { targetX = ( xDiff > 0 ) ? boundXmin : boundXmax ; } if ( yDiff !== 0 ) { targetY = ( yDiff > 0 ) ? boundYmin : boundYmax ; } } return { x : xDiff , y : yDiff , inBounds : xDiff === 0 && yDiff === 0 } ; } 
function values ( obj ) { var keys = Object . keys ( obj ) ; var length = keys . length ; var vals = new Array ( length ) ; for ( var i = 0 ; i < length ; i ++ ) { vals [ i ] = obj [ keys [ i ] ] ; } return vals ; } 
function imgpath ( browser ) { var a = browser . options . desiredCapabilities ; var meta = [ a . platform ] ; meta . push ( a . browserName ? a . browserName : 'any' ) ; meta . push ( a . version ? a . version : 'any' ) ; meta . push ( a . name ) ; 
function ( req , res , next ) { var filePath = req . originalUrl . replace ( '/abe/editor' , '' ) if ( filePath === '' || filePath === '/' ) { filePath = null } if ( filePath != null && path . extname ( filePath ) != ` ${ config . files . templates . extension } ` && path . extname ( filePath ) != '.json' ) { next ( ) return } if ( filePath != null ) { var testXSS = xss ( filePath , { whiteList : [ ] , stripIgnoreTag : true } ) if ( testXSS !== filePath ) { filePath = testXSS } } abeExtend . hooks . instance . trigger ( 'beforeRoute' , req , res , next ) if ( typeof res . _header !== 'undefined' && res . _header !== null ) return var isHome = true var jsonPath = null var template = null var fileName = null var folderPath = null var EditorVariables = { user : res . user , slugs : Manager . instance . getSlugs ( ) , express : { res : res , req : req } , filename : fileName , folderPath : folderPath , abeUrl : '/abe/editor/' , isHome : isHome , config : config , Locales : coreUtils . locales . instance . i18n , abeVersion : pkg . version } let p = new Promise ( resolve => { if ( filePath != null ) { fileName = path . basename ( filePath ) folderPath = path . dirname ( filePath ) EditorVariables . isHome = false EditorVariables . isEditor = true var filePathTest = cmsData . revision . getDocumentRevision ( filePath ) if ( typeof filePathTest !== 'undefined' && filePathTest !== null ) { jsonPath = filePathTest . path template = filePathTest . abe_meta . template } if ( jsonPath === null || ! coreUtils . file . exist ( jsonPath ) ) { res . redirect ( '/abe/editor' ) return } var json = { } if ( coreUtils . file . exist ( jsonPath ) ) { json = cmsData . file . get ( jsonPath , 'utf8' ) } var text = cmsTemplates . template . getTemplate ( template , json ) cmsEditor . editor . create ( text , json ) . then ( result => { resolve ( result ) } ) . catch ( function ( e ) { console . error ( e ) } ) } else { resolve ( { json : { } , manager : { } } ) } } ) . catch ( function ( e ) { console . error ( e ) 
function stringify ( obj , replacer , spaces , cycleReplacer ) { if ( typeof replacer !== 'function' ) { replacer = null ; } return JSON . stringify ( obj , serializer ( replacer , cycleReplacer ) , spaces ) ; } 
function getIEVersion ( ) { var agent = navigator . userAgent var reg = / MSIE\s?(\d+)(?:\.(\d+))? / i var matches = agent . match ( reg ) if ( matches != null ) { return { major : matches [ 1 ] , minor : matches [ 2 ] } } return { major : '-1' , minor : '-1' } } 
function initCompDirs ( ) { var compRoot = path . resolve ( process . cwd ( ) , 'src/components' ) , compReg = / ^[A-Z]\w+$ / ; 
function appendLogToFileStream ( fileName , newLog , headerLineCount ) { const filePath = path . join ( __dirname , '../../' , fileName ) const oldChangelog = grunt . file . read ( filePath ) . toString ( ) . split ( '\n' ) ; let wStr = fs . createWriteStream ( filePath ) let logHeader = oldChangelog . slice ( 0 , headerLineCount ) ; let prevLogs = oldChangelog . slice ( headerLineCount ) ; var s = new Readable ; s . pipe ( wStr ) ; s . push ( logHeader . join ( '\n' ) + '\n' ) ; s . push ( newLog ) ; s . push ( prevLogs . join ( '\n' ) ) ; s . push ( null ) ; 
function InfTree ( ) { var that = this ; var hn ; 
function InfCodes ( ) { var that = this ; var mode ; 
function inflate_fast ( bl , bd , tl , tl_index , td , td_index , s , z ) { var t ; 
function Inflater ( ) { var that = this ; var z = new ZStream ( ) ; var bufsize = 512 ; var flush = Z_NO_FLUSH ; var buf = new Uint8Array ( bufsize ) ; var nomoreinput = false ; z . inflateInit ( ) ; z . next_out = buf ; that . append = function ( data , onprogress ) { var err , buffers = [ ] , lastIndex = 0 , bufferIndex = 0 , bufferSize = 0 , array ; if ( data . length === 0 ) return ; z . next_in_index = 0 ; z . next_in = data ; z . avail_in = data . length ; do { z . next_out_index = 0 ; z . avail_out = bufsize ; if ( ( z . avail_in === 0 ) && ( ! nomoreinput ) ) { 
function launchWorkerProcess ( worker , initialMessage , reader , writer , offset , size , onprogress , onend , onreaderror , onwriteerror ) { var chunkIndex = 0 , index , outputSize , sn = initialMessage . sn , crc ; function onflush ( ) { worker . removeEventListener ( 'message' , onmessage , false ) ; onend ( outputSize , crc ) ; } function onmessage ( event ) { var message = event . data , data = message . data , err = message . error ; if ( err ) { err . toString = function ( ) { return 'Error: ' + this . message ; } ; onreaderror ( err ) ; return ; } if ( message . sn !== sn ) return ; if ( typeof message . codecTime === 'number' ) worker . codecTime += message . codecTime ; 
function decodeASCII ( str ) { var i , out = "" , charCode , extendedASCII = [ '\u00C7' , '\u00FC' , '\u00E9' , '\u00E2' , '\u00E4' , '\u00E0' , '\u00E5' , '\u00E7' , '\u00EA' , '\u00EB' , '\u00E8' , '\u00EF' , '\u00EE' , '\u00EC' , '\u00C4' , '\u00C5' , '\u00C9' , '\u00E6' , '\u00C6' , '\u00F4' , '\u00F6' , '\u00F2' , '\u00FB' , '\u00F9' , '\u00FF' , '\u00D6' , '\u00DC' , '\u00F8' , '\u00A3' , '\u00D8' , '\u00D7' , '\u0192' , '\u00E1' , '\u00ED' , '\u00F3' , '\u00FA' , '\u00F1' , '\u00D1' , '\u00AA' , '\u00BA' , '\u00BF' , '\u00AE' , '\u00AC' , '\u00BD' , '\u00BC' , '\u00A1' , '\u00AB' , '\u00BB' , '_' , '_' , '_' , '\u00A6' , '\u00A6' , '\u00C1' , '\u00C2' , '\u00C0' , '\u00A9' , '\u00A6' , '\u00A6' , '+' , '+' , '\u00A2' , '\u00A5' , '+' , '+' , '-' , '-' , '+' , '-' , '+' , '\u00E3' , '\u00C3' , '+' , '+' , '-' , '-' , '\u00A6' , '-' , '+' , '\u00A4' , '\u00F0' , '\u00D0' , '\u00CA' , '\u00CB' , '\u00C8' , 'i' , '\u00CD' , '\u00CE' , '\u00CF' , '+' , '+' , '_' , '_' , '\u00A6' , '\u00CC' , '_' , '\u00D3' , '\u00DF' , '\u00D4' , '\u00D2' , '\u00F5' , '\u00D5' , '\u00B5' , '\u00FE' , '\u00DE' , '\u00DA' , '\u00DB' , '\u00D9' , '\u00FD' , '\u00DD' , '\u00AF' , '\u00B4' , '\u00AD' , '\u00B1' , '_' , '\u00BE' , '\u00B6' , '\u00A7' , '\u00F7' , '\u00B8' , '\u00B0' , '\u00A8' , '\u00B7' , '\u00B9' , '\u00B3' , '\u00B2' , '_' , ' ' ] ; for ( i = 0 ; i < str . length ; i ++ ) { charCode = str . charCodeAt ( i ) & 0xFF ; if ( charCode > 127 ) out += extendedASCII [ charCode - 128 ] ; else out += String . fromCharCode ( charCode ) ; } return out ; } 
function doSeek ( length , eocdrNotFoundCallback ) { reader . readUint8Array ( reader . size - length , length , function ( bytes ) { for ( var i = bytes . length - EOCDR_MIN ; i >= 0 ; i -- ) { if ( bytes [ i ] === 0x50 && bytes [ i + 1 ] === 0x4b && bytes [ i + 2 ] === 0x05 && bytes [ i + 3 ] === 0x06 ) { eocdrCallback ( new DataView ( bytes . buffer , i , EOCDR_MIN ) ) ; return ; } } eocdrNotFoundCallback ( ) ; } , function ( ) { onerror ( ERR_READ ) ; } ) ; } 
function CardJs ( elem ) { this . elem = jQuery ( elem ) ; this . captureName = this . elem . data ( "capture-name" ) ? this . elem . data ( "capture-name" ) : false ; this . iconColour = this . elem . data ( "icon-colour" ) ? this . elem . data ( "icon-colour" ) : false ; this . stripe = this . elem . data ( "stripe" ) ? this . elem . data ( "stripe" ) : false ; if ( this . stripe ) { this . captureName = false ; } 
function ( err , inData ) { 
function DBGetRowArrayNative ( cursor ) { 
function DBGetRowArrayString ( cursor ) { 
function DBGetRowObjectString ( cursor ) { 
function Database ( dbname , options , callback ) { if ( ! this instanceof Database ) { 
function toCharPtr ( str ) { const objcStr = NSString . stringWithString ( str ) ; const bufferSize = strlen ( objcStr . UTF8String ) + 1 ; const buffer = interop . alloc ( bufferSize ) ; objcStr . getCStringMaxLengthEncoding ( buffer , bufferSize , NSUTF8StringEncoding ) ; return buffer ; } 
function CursorStatement ( statement , resultType , valuesType ) { this . statement = statement ; this . resultType = resultType ; this . valuesType = valuesType ; this . built = false ; this . columns = [ ] ; } 
function Database ( dbname , options , callback ) { if ( ! this instanceof Database ) { 
function CronJob ( sandbox , job ) { assign ( this , job ) ; if ( job . token ) { this . claims = Decode ( job . token ) ; } else { this . claims = { jtn : job . name , ten : this . container , } ; } this . sandbox = sandbox ; Object . defineProperty ( this , 'url' , { enumerable : true , get : function ( ) { return this . sandbox . url + '/api/run/' + this . container + '/' + this . name ; } } ) ; } 
function Sandbox ( options ) { var securityVersion = 'v1' ; this . url = options . url ; this . container = options . container ; this . token = options . token ; this . onBeforeRequest = [ ] . concat ( options . onBeforeRequest ) . filter ( hook => typeof hook === 'function' ) ; try { var typ = Decode ( options . token , { header : true } ) . typ ; if ( typ && typ . toLowerCase ( ) === 'jwt' ) { securityVersion = 'v2' ; } } catch ( _ ) { 
function Webtask ( sandbox , token , options ) { if ( ! options ) options = { } ; if ( sandbox . securityVersion === 'v1' ) { try { this . claims = Decode ( token ) ; this . token = token ; } catch ( _ ) { throw new Error ( 'token must be a valid JWT' ) ; } } if ( sandbox . securityVersion === 'v2' ) { if ( typeof options . name !== 'string' ) { throw new Error ( 'name must be a valid string' ) ; } this . claims = { jtn : options . name , ten : options . container || sandbox . container , } } this . sandbox = sandbox ; this . meta = options . meta || { } ; this . secrets = options . secrets ; this . code = options . code ; Object . defineProperty ( this , 'container' , { enumerable : true , get : function ( ) { return options . container || this . sandbox . container ; } } ) ; Object . defineProperty ( this , 'url' , { enumerable : true , get : function ( ) { var url = options . webtask_url ; if ( ! url ) { if ( this . claims . host ) { var surl = Url . parse ( this . sandbox . url ) ; url = surl . protocol + '//' + this . claims . host + ( surl . port ? ( ':' + surl . port ) : '' ) + '/' + this . sandbox . container ; } else { url = this . sandbox . url + '/api/run/' + this . sandbox . container ; } if ( this . claims . jtn ) url += '/' + this . claims . jtn ; else url += '?key=' + this . token ; } return url ; } } ) ; } 
function CcZnp ( ) { EventEmitter . call ( this ) ; var self = this ; this . MT = MT ; 
function ZpiObject ( subsys , cmd , args ) { 
function wrappedPromise ( executor ) { if ( ! ( this instanceof wrappedPromise ) ) { return Promise ( executor ) ; } if ( typeof executor !== 'function' ) { return new Promise ( executor ) ; } var context , args ; var promise = new Promise ( wrappedExecutor ) ; promise . __proto__ = wrappedPromise . prototype ; try { executor . apply ( context , args ) ; } catch ( err ) { args [ 1 ] ( err ) ; } return promise ; function wrappedExecutor ( resolve , reject ) { context = this ; args = [ wrappedResolve , wrappedReject ] ; 
function bind ( fn ) { if ( typeof fn !== 'function' ) return fn ; return wrapCallback ( function ( val ) { var result = ( promise . __asl_wrapper || propagateAslWrapper ) ( this , fn , val , next ) ; if ( result . error ) { throw result . errorVal } else { return result . returnVal } } ) ; } 
function union ( dest , added ) { var destLength = dest . length ; var addedLength = added . length ; var returned = [ ] ; if ( destLength === 0 && addedLength === 0 ) return returned ; for ( var j = 0 ; j < destLength ; j ++ ) returned [ j ] = dest [ j ] ; if ( addedLength === 0 ) return returned ; for ( var i = 0 ; i < addedLength ; i ++ ) { var missing = true ; for ( j = 0 ; j < destLength ; j ++ ) { if ( dest [ j ] . uid === added [ i ] . uid ) { missing = false ; break ; } } if ( missing ) returned . push ( added [ i ] ) ; } return returned ; } 
function simpleWrap ( original , list , length ) { inAsyncTick = true ; for ( var i = 0 ; i < length ; ++ i ) { var listener = list [ i ] ; if ( listener . create ) listener . create ( listener . data ) ; } inAsyncTick = false ; 
function wrapCallback ( original ) { var length = listeners . length ; 
function ( dir , options , internal ) { 
function makeAsyncFunc ( config ) { 
function makeAsyncIterator ( bodyFunc , config , semaphore ) { 
function ( expr ) { 
function makeAsyncNonIterator ( bodyFunc , config , semaphore ) { 
function makeFuncWithArity ( fn , arity ) { 
function runInFiber ( runCtx ) { try { tryBlock ( runCtx ) ; } catch ( err ) { catchBlock ( runCtx , err ) ; } finally { finallyBlock ( runCtx ) ; } } 
function adjustFiberCount ( delta ) { activeFiberCount += delta ; if ( activeFiberCount >= fiberPoolSize ) { fiberPoolSize += 100 ; Fiber . poolSize = fiberPoolSize ; } } 
function makeAwaitFunc ( variant ) { 
function getExtraInfo ( traverse , topN ) { return function await ( ) { 
function traverseInPlace ( o , visitor ) { if ( _ . isArray ( o ) ) { var len = o . length ; for ( var i = 0 ; i < len ; ++ i ) { traverseInPlace ( o [ i ] , visitor ) ; visitor ( o , i ) ; } } else if ( _ . isPlainObject ( o ) ) { for ( var key in o ) { if ( ! o . hasOwnProperty ( key ) ) continue ; traverseInPlace ( o [ key ] , visitor ) ; visitor ( o , key ) ; } } return o ; } 
function traverseClone ( o , visitor ) { var result ; if ( _ . isArray ( o ) ) { var len = o . length ; result = new Array ( len ) ; for ( var i = 0 ; i < len ; ++ i ) { result [ i ] = traverseClone ( o [ i ] , visitor ) ; visitor ( result , i ) ; } } else if ( _ . isPlainObject ( o ) ) { result = { } ; for ( var key in o ) { if ( o . hasOwnProperty ( key ) ) { result [ key ] = traverseClone ( o [ key ] , visitor ) ; visitor ( result , key ) ; } } } else { result = o ; } return result ; } 
function thunkToPromise ( thunk ) { return new Promise ( function ( resolve , reject ) { var callback = function ( err , val ) { return ( err ? reject ( err ) : resolve ( val ) ) ; } ; thunk ( callback ) ; } ) ; } 
function ( dir ) { var files = fs . readdirSync ( dir ) ; 
function requestDone ( method , where , cb ) { return function ( er , response , data ) { if ( er ) return cb ( er ) var urlObj = url . parse ( where ) if ( urlObj . auth ) urlObj . auth = '***' this . log . http ( response . statusCode , url . format ( urlObj ) ) if ( Buffer . isBuffer ( data ) ) { data = data . toString ( ) } var parsed if ( data && typeof data === 'string' && response . statusCode !== 304 ) { try { parsed = JSON . parse ( data ) } catch ( ex ) { ex . message += '\n' + data this . log . verbose ( 'bad json' , data ) this . log . error ( 'registry' , 'error parsing json' ) return cb ( ex , null , data , response ) } } else if ( data ) { parsed = data data = JSON . stringify ( parsed ) } 
function get ( uri , params , cb ) { assert ( typeof uri === 'string' , 'must pass registry URI to get' ) assert ( params && typeof params === 'object' , 'must pass params to get' ) assert ( typeof cb === 'function' , 'must pass callback to get' ) var parsed = url . parse ( uri ) assert ( parsed . protocol === 'http:' || parsed . protocol === 'https:' , 'must have a URL that starts with http: or https:' ) this . request ( uri , params , cb ) } 
async function scopedCopyIndex ( client , sourceIndex , targetIndex ) { const { taskID } = await client . copyIndex ( sourceIndex . indexName , targetIndex . indexName , [ 'settings' , 'synonyms' , 'rules' ] ) ; return targetIndex . waitTask ( taskID ) ; } 
async function moveIndex ( client , sourceIndex , targetIndex ) { const { taskID } = await client . moveIndex ( sourceIndex . indexName , targetIndex . indexName ) ; return targetIndex . waitTask ( taskID ) ; } 
async function indexExists ( index ) { try { const { nbHits } = await index . search ( ) ; return nbHits > 0 ; } catch ( e ) { return false ; } } 
function setStatus ( activity , status ) { if ( activity && activity . setStatus ) { activity . setStatus ( status ) ; } else { console . log ( 'Algolia:' , status ) ; } } 
function loadModule ( moduleName ) { var module = modules [ moduleName ] ; if ( module !== undefined ) { return module ; } 
function parseAcceptLanguage ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var language = parseLanguage ( accepts [ i ] . trim ( ) , i ) ; if ( language ) { accepts [ j ++ ] = language ; } } 
function parseLanguage ( str , i ) { var match = simpleLanguageRegExp . exec ( str ) ; if ( ! match ) return null ; var prefix = match [ 1 ] , suffix = match [ 2 ] , full = prefix ; if ( suffix ) full += "-" + suffix ; var q = 1 ; if ( match [ 3 ] ) { var params = match [ 3 ] . split ( ';' ) for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . split ( '=' ) ; if ( p [ 0 ] === 'q' ) q = parseFloat ( p [ 1 ] ) ; } } return { prefix : prefix , suffix : suffix , q : q , i : i , full : full } ; } 
function getLanguagePriority ( language , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( language , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( language , spec , index ) { var p = parseLanguage ( language ) if ( ! p ) return null ; var s = 0 ; if ( spec . full . toLowerCase ( ) === p . full . toLowerCase ( ) ) { s |= 4 ; } else if ( spec . prefix . toLowerCase ( ) === p . full . toLowerCase ( ) ) { s |= 2 ; } else if ( spec . full . toLowerCase ( ) === p . prefix . toLowerCase ( ) ) { s |= 1 ; } else if ( spec . full !== '*' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } } 
function preferredLanguages ( accept , provided ) { 
function compareSpecs ( a , b ) { return ( b . q - a . q ) || ( b . s - a . s ) || ( a . o - b . o ) || ( a . i - b . i ) || 0 ; } 
function parseAcceptCharset ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var charset = parseCharset ( accepts [ i ] . trim ( ) , i ) ; if ( charset ) { accepts [ j ++ ] = charset ; } } 
function parseCharset ( str , i ) { var match = simpleCharsetRegExp . exec ( str ) ; if ( ! match ) return null ; var charset = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ';' ) for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . trim ( ) . split ( '=' ) ; if ( p [ 0 ] === 'q' ) { q = parseFloat ( p [ 1 ] ) ; break ; } } } return { charset : charset , q : q , i : i } ; } 
function getCharsetPriority ( charset , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( charset , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( charset , spec , index ) { var s = 0 ; if ( spec . charset . toLowerCase ( ) === charset . toLowerCase ( ) ) { s |= 1 ; } else if ( spec . charset !== '*' ) { return null } return { i : index , o : spec . i , q : spec . q , s : s } } 
function preferredCharsets ( accept , provided ) { 
function parseEncoding ( str , i ) { var match = simpleEncodingRegExp . exec ( str ) ; if ( ! match ) return null ; var encoding = match [ 1 ] ; var q = 1 ; if ( match [ 2 ] ) { var params = match [ 2 ] . split ( ';' ) ; for ( var j = 0 ; j < params . length ; j ++ ) { var p = params [ j ] . trim ( ) . split ( '=' ) ; if ( p [ 0 ] === 'q' ) { q = parseFloat ( p [ 1 ] ) ; break ; } } } return { encoding : encoding , q : q , i : i } ; } 
function getEncodingPriority ( encoding , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( encoding , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function preferredEncodings ( accept , provided ) { var accepts = parseAcceptEncoding ( accept || '' ) ; if ( ! provided ) { 
function parseAccept ( accept ) { var accepts = splitMediaTypes ( accept ) ; for ( var i = 0 , j = 0 ; i < accepts . length ; i ++ ) { var mediaType = parseMediaType ( accepts [ i ] . trim ( ) , i ) ; if ( mediaType ) { accepts [ j ++ ] = mediaType ; } } 
function parseMediaType ( str , i ) { var match = simpleMediaTypeRegExp . exec ( str ) ; if ( ! match ) return null ; var params = Object . create ( null ) ; var q = 1 ; var subtype = match [ 2 ] ; var type = match [ 1 ] ; if ( match [ 3 ] ) { var kvps = splitParameters ( match [ 3 ] ) . map ( splitKeyValuePair ) ; for ( var j = 0 ; j < kvps . length ; j ++ ) { var pair = kvps [ j ] ; var key = pair [ 0 ] . toLowerCase ( ) ; var val = pair [ 1 ] ; 
function getMediaTypePriority ( type , accepted , index ) { var priority = { o : - 1 , q : 0 , s : 0 } ; for ( var i = 0 ; i < accepted . length ; i ++ ) { var spec = specify ( type , accepted [ i ] , index ) ; if ( spec && ( priority . s - spec . s || priority . q - spec . q || priority . o - spec . o ) < 0 ) { priority = spec ; } } return priority ; } 
function specify ( type , spec , index ) { var p = parseMediaType ( type ) ; var s = 0 ; if ( ! p ) { return null ; } if ( spec . type . toLowerCase ( ) == p . type . toLowerCase ( ) ) { s |= 4 } else if ( spec . type != '*' ) { return null ; } if ( spec . subtype . toLowerCase ( ) == p . subtype . toLowerCase ( ) ) { s |= 2 } else if ( spec . subtype != '*' ) { return null ; } var keys = Object . keys ( spec . params ) ; if ( keys . length > 0 ) { if ( keys . every ( function ( k ) { return spec . params [ k ] == '*' || ( spec . params [ k ] || '' ) . toLowerCase ( ) == ( p . params [ k ] || '' ) . toLowerCase ( ) ; } ) ) { s |= 1 } else { return null } } return { i : index , o : spec . i , q : spec . q , s : s , } } 
function preferredMediaTypes ( accept , provided ) { 
function quoteCount ( string ) { var count = 0 ; var index = 0 ; while ( ( index = string . indexOf ( '"' , index ) ) !== - 1 ) { count ++ ; index ++ ; } return count ; } 
function splitKeyValuePair ( str ) { var index = str . indexOf ( '=' ) ; var key ; var val ; if ( index === - 1 ) { key = str ; } else { key = str . substr ( 0 , index ) ; val = str . substr ( index + 1 ) ; } return [ key , val ] ; } 
function splitMediaTypes ( accept ) { var accepts = accept . split ( ',' ) ; for ( var i = 1 , j = 0 ; i < accepts . length ; i ++ ) { if ( quoteCount ( accepts [ j ] ) % 2 == 0 ) { accepts [ ++ j ] = accepts [ i ] ; } else { accepts [ j ] += ',' + accepts [ i ] ; } } 
function splitParameters ( str ) { var parameters = str . split ( ';' ) ; for ( var i = 1 , j = 0 ; i < parameters . length ; i ++ ) { if ( quoteCount ( parameters [ j ] ) % 2 == 0 ) { parameters [ ++ j ] = parameters [ i ] ; } else { parameters [ j ] += ';' + parameters [ i ] ; } } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version' ) . use ( Version ) , this . key ( 'privateKeyAlgorithm' ) . use ( AlgorithmIdentifier ) , this . key ( 'privateKey' ) . octstr ( ) , this . key ( 'attributes' ) . optional ( ) . any ( ) ) ; } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version' ) . use ( Version ) , this . key ( 'privateKey' ) . octstr ( ) , this . key ( 'parameters' ) . explicit ( 0 ) . optional ( ) . any ( ) , this . key ( 'publicKey' ) . explicit ( 1 ) . optional ( ) . bitstr ( ) ) ; } 
function ( ) { this . seq ( ) . obj ( this . key ( 'version' ) . use ( Version ) , this . key ( 'modulus' ) . int ( ) , this . key ( 'publicExponent' ) . int ( ) , this . key ( 'privateExponent' ) . int ( ) , this . key ( 'prime1' ) . int ( ) , this . key ( 'prime2' ) . int ( ) , this . key ( 'exponent1' ) . int ( ) , this . key ( 'exponent2' ) . int ( ) , this . key ( 'coefficient' ) . int ( ) ) ; } 
function Module ( process , name , path , base , size ) { 
function Hash ( data ) { 
function ( details ) { console . warn ( mColors . yellow . bold ( "WARNING: robot-js precompiled binaries could " + "not be downloaded, an attempt to compile them" + " manually will be made. For more information," + " please visit http://getrobot.net/docs/node.html." + " Details: " + details ) ) ; try { 
function ( details ) { console . error ( mColors . red . bold ( "ERROR: robot-js precompiled binaries could not " + "be verified. This could be a result of a man-in" + "-the-middle attack. If you want to continue " + "anyway, use the following command to disable" + " verification: 'npm config set robot-js:verify " + "false'. Details: " + details ) ) ; try { 
function ( url , success , failure ) { 
function Size ( aw , ah ) { 
function Screen ( bounds , usable ) { 
function Region ( ) { 
function loadWebpackConfig ( ) { var webpackConfig = require ( './webpack.config.js' ) ; webpackConfig . devtool = 'inline-source-map' ; webpackConfig . module . preLoaders = [ { test : / \.jsx?$ / , include : path . resolve ( 'lib' ) , loader : 'isparta' } ] ; return webpackConfig ; } 
function assign ( obj , keyPath , value ) { const lastKeyIndex = keyPath . length - 1 for ( let i = 0 ; i < lastKeyIndex ; ++ i ) { const key = keyPath [ i ] if ( ! ( key in obj ) ) obj [ key ] = { } obj = obj [ key ] } obj [ keyPath [ lastKeyIndex ] ] = value } 
function getFilterString ( selectedValues ) { if ( selectedValues && Object . keys ( selectedValues ) . length ) { return Object 
function evaluatePage ( page , fn ) { var args = Array . prototype . slice . call ( arguments , 2 ) ; return this . ready . then ( function ( ) { var stack ; page = page || this . page ; var res = HorsemanPromise . fromCallback ( function ( done ) { 
function waitForPage ( page , optsOrFn ) { var self = this ; var args , value , fname , timeout = self . options . timeout , fn ; if ( typeof optsOrFn === "function" ) { fn = optsOrFn ; args = Array . prototype . slice . call ( arguments ) ; value = args . pop ( ) ; fname = fn . name || '<anonymous>' ; } else if ( typeof optsOrFn === "object" ) { fn = optsOrFn . fn ; args = [ page , fn ] . concat ( optsOrFn . args || [ ] ) ; value = optsOrFn . value ; fname = fn . name || '<anonymous>' ; if ( optsOrFn . timeout ) { timeout = optsOrFn . timeout ; } } debug . apply ( debug , [ '.waitFor()' , fname ] . concat ( args . slice ( 2 ) ) ) ; return this . ready . then ( function ( ) { return new HorsemanPromise ( function ( resolve , reject ) { var start = Date . now ( ) ; var checkInterval = setInterval ( function waitForCheck ( ) { var _page = page || self . page ; var diff = Date . now ( ) - start ; if ( diff > timeout ) { clearInterval ( checkInterval ) ; debug ( '.waitFor() timed out' ) ; if ( typeof _page . onTimeout === 'function' ) { _page . onTimeout ( 'waitFor' ) ; } reject ( new TimeoutError ( 'timeout during .waitFor() after ' + diff + ' ms' ) ) ; } else { return evaluatePage . apply ( self , args ) . tap ( function ( res ) { debugv ( '.waitFor() iteration' , fname , res , diff , self . id ) ; } ) . then ( function ( res ) { if ( res === value ) { debug ( '.waitFor() completed successfully' ) ; clearInterval ( checkInterval ) ; resolve ( ) ; } } ) . catch ( function ( err ) { clearInterval ( checkInterval ) ; reject ( err ) ; } ) ; } } , self . options . interval ) ; } ) ; } ) ; } 
function Horseman ( options ) { this . ready = false ; if ( ! ( this instanceof Horseman ) ) { return new Horseman ( options ) ; } this . options = defaults ( clone ( options ) || { } , DEFAULTS ) ; this . id = ++ instanceId ; debug ( '.setup() creating phantom instance %s' , this . id ) ; var phantomOptions = { 'load-images' : this . options . loadImages , 'ssl-protocol' : this . options . sslProtocol } ; if ( typeof this . options . ignoreSSLErrors !== 'undefined' ) { phantomOptions [ 'ignore-ssl-errors' ] = this . options . ignoreSSLErrors ; } if ( typeof this . options . webSecurity !== 'undefined' ) { phantomOptions [ 'web-security' ] = this . options . webSecurity ; } if ( typeof this . options . proxy !== 'undefined' ) { phantomOptions . proxy = this . options . proxy ; } if ( typeof this . options . proxyType !== 'undefined' ) { phantomOptions [ 'proxy-type' ] = this . options . proxyType ; } if ( typeof this . options . proxyAuth !== 'undefined' ) { phantomOptions [ 'proxy-auth' ] = this . options . proxyAuth ; } if ( typeof this . options . diskCache !== 'undefined' ) { phantomOptions [ 'disk-cache' ] = this . options . diskCache ; } if ( typeof this . options . diskCachePath !== 'undefined' ) { phantomOptions [ 'disk-cache-path' ] = this . options . diskCachePath ; } if ( typeof this . options . cookiesFile !== 'undefined' ) { phantomOptions [ 'cookies-file' ] = this . options . cookiesFile ; } if ( this . options . debugPort ) { phantomOptions [ 'remote-debugger-port' ] = this . options . debugPort ; phantomOptions [ 'remote-debugger-autorun' ] = 'no' ; if ( this . options . debugAutorun !== false ) { phantomOptions [ 'remote-debugger-autorun' ] = 'yes' ; } } Object . keys ( this . options . phantomOptions || { } ) . forEach ( function ( key ) { if ( typeof phantomOptions [ key ] !== 'undefined' ) { debug ( 'Horseman option ' + key + ' overridden by phantomOptions' ) ; } phantomOptions [ key ] = this . options . phantomOptions [ key ] ; } . bind ( this ) ) ; var instantiationOptions = { parameters : phantomOptions } ; if ( typeof this . options . phantomPath !== 'undefined' ) { instantiationOptions [ 'path' ] = this . options . phantomPath ; } 
function loadFinishedSetup ( status ) { var args = arguments ; self . pageCnt ++ ; debug ( 'phantomjs onLoadFinished triggered' , status , self . pageCnt ) ; return self . ready = HorsemanPromise . try ( function checkStatus ( ) { if ( status !== 'success' ) { var err = new Error ( 'Failed to load url' ) ; return HorsemanPromise . reject ( err ) ; } } ) . then ( function injectJQuery ( ) { if ( ! self . options . injectJquery ) { return ; } return HorsemanPromise . fromCallback ( function hasJQuery ( done ) { return page . evaluate ( function hasJQuery ( ) { return ( typeof window . jQuery !== 'undefined' ) ; } , done ) ; } ) . then ( function ( hasJquery ) { if ( hasJquery ) { debug ( 'jQuery not injected - already exists on page' ) ; return ; } var jQueryLocation = path . join ( __dirname , '../files/jquery-2.1.1.min.js' ) ; return HorsemanPromise . fromCallback ( function ( done ) { return page . injectJs ( jQueryLocation , done ) ; } ) . tap ( function ( successful ) { if ( ! successful ) { var err = new Error ( 'jQuery injection failed' ) ; return HorsemanPromise . reject ( err ) ; } debug ( 'injected jQuery' ) ; } ) ; } ) ; } ) . then ( function injectBluebird ( ) { var inject = self . options . injectBluebird ; if ( ! inject ) { return ; } return HorsemanPromise . fromCallback ( function hasPromise ( done ) { return page . evaluate ( function hasPromise ( ) { return ( typeof window . Promise !== 'undefined' ) ; } , done ) ; } ) . then ( function ( hasPromise ) { if ( hasPromise && inject !== 'bluebird' ) { debug ( 'bluebird not injected - ' + 'Promise already exists on page' ) ; return ; } var bbLoc = 'bluebird/js/browser/bluebird' + ( self . options . bluebirdDebug ? '' : '.min' ) + '.js' ; return HorsemanPromise . fromCallback ( function ( done ) { return page . injectJs ( require . resolve ( bbLoc ) , done ) ; } ) . tap ( function ( successful ) { if ( ! successful ) { var err = new Error ( 'bluebird injection failed' ) ; return HorsemanPromise . reject ( err ) ; } debug ( 'injected bluebird' ) ; } ) ; } ) . then ( function configBluebird ( ) { return HorsemanPromise . fromCallback ( function ( done ) { return page . evaluate ( function configBluebird ( noConflict , debug ) { if ( debug ) { 
function getColors ( image , cb ) { var data = [ ] ; var img = createImage ( image ) ; var promise = new Promise ( function ( resolve ) { img . onload = function ( ) { var canvas = document . createElement ( 'canvas' ) ; canvas . width = img . width ; canvas . height = img . height ; canvas . getContext ( '2d' ) . drawImage ( img , 0 , 0 , img . width , img . height ) ; var ctx = canvas . getContext ( '2d' ) ; var imageData = ctx . getImageData ( 0 , 0 , img . width , 1 ) . data ; for ( var i = 0 ; i < img . width ; i ++ ) { data . push ( [ imageData [ i * 4 ] / 255 , imageData [ i * 4 + 1 ] / 255 , imageData [ i * 4 + 2 ] / 255 ] ) ; } resolve ( data ) ; } ; } ) ; return promise ; } 
function createCubehelix ( steps , opts ) { var data = [ ] ; for ( var i = 0 ; i < steps ; i ++ ) { data . push ( cubehelix . rgb ( i / steps , opts ) . map ( ( v ) => v / 255 ) ) ; } return data ; } 
function toImageData ( colors ) { return colors . map ( ( color ) => color . map ( ( v ) => v * 255 ) . concat ( 255 ) ) . reduce ( ( prev , curr ) => prev . concat ( curr ) ) ; } 
function compress ( colors , factor ) { var data = [ ] ; var len = ( colors . length ) / factor ; var step = ( colors . length - 1 ) / len ; for ( var i = 0 ; i < colors . length ; i += step ) { data . push ( colors [ i | 0 ] ) ; } return data ; } 
function toColormap ( data ) { var stops = [ ] ; for ( var i = 0 ; i < data . length ; i ++ ) { stops . push ( { index : Math . round ( i * 100 / ( data . length - 1 ) ) / 100 , rgb : data [ i ] . map ( ( v ) => Math . round ( v * 255 ) ) } ) ; } return stops ; } 
function show ( pixels , title ) { if ( typeof pixels === 'string' ) { var img = createImage ( pixels ) ; img . style . height = '40px' ; img . style . width = '100%' ; title && img . setAttribute ( 'title' , title ) ; document . body . appendChild ( img ) ; return ; } var canvas = document . createElement ( 'canvas' ) ; var w = ( pixels . length / 4 ) | 0 ; canvas . width = w ; canvas . height = 1 ; canvas . style . height = '40px' ; canvas . style . width = '100%' ; var ctx = canvas . getContext ( '2d' ) ; var imageData = ctx . createImageData ( w , 1 ) ; imageData . data . set ( pixels ) ; ctx . putImageData ( imageData , 0 , 0 ) ; title && canvas . setAttribute ( 'title' , title ) ; document . body . appendChild ( canvas ) ; document . body . appendChild ( document . createElement ( 'br' ) ) ; } 
function ( ) { var prop = 'pageYOffset' , method = 'scrollTop' ; return win ? ( prop in win ) ? win [ prop ] : win . document . documentElement [ method ] : win . document . body [ method ] ; } 
function getRealWidth ( element ) { var width = 0 ; var $target = element ; var css_class = 'hidden_element' ; $target = $target . clone ( ) . attr ( 'class' , css_class ) . appendTo ( 'body' ) ; width = $target . width ( true ) ; $target . remove ( ) ; return width ; } 
function upsertInner ( db , docId , diffFun ) { if ( typeof docId !== 'string' ) { return PouchPromise . reject ( new Error ( 'doc id is required' ) ) ; } return db . get ( docId ) . catch ( function ( err ) { if ( err . status !== 404 ) { throw err ; } return { } ; } ) . then ( function ( doc ) { 
function startDownload ( src , storageFile ) { var uri = Windows . Foundation . Uri ( src ) ; var downloader = new Windows . Networking . BackgroundTransfer . BackgroundDownloader ( ) ; var download = downloader . createDownload ( uri , storageFile ) ; return download . startAsync ( ) ; } 
function ( options ) { this . _handlers = { 'progress' : [ ] , 'cancel' : [ ] , 'error' : [ ] , 'complete' : [ ] } ; 
function ( fileUrl , dirUrl , callback , progressCallback ) { var win = function ( result ) { if ( result && result . progress ) { if ( progressCallback ) { progressCallback ( result ) ; } } else if ( callback ) { callback ( 0 ) ; } } ; var fail = function ( result ) { if ( callback ) { callback ( - 1 ) ; } } ; exec ( win , fail , 'Zip' , 'unzip' , [ fileUrl , dirUrl ] ) ; } 
function ( url , headers , cb ) { var callback = ( typeof headers == "function" ? headers : cb ) ; exec ( callback , callback , 'Sync' , 'download' , [ url , null , headers ] ) ; } 
function createAppChannel ( app , key ) { assert ( ~ [ 'consumerChannel' , 'publisherChannel' ] . indexOf ( key ) , 'Channel key must be "consumerChannel" or "publisherChannel"' ) assert ( app . connection , 'Cannot create a channel without a connection' ) assert ( ! app [ key ] , 'Channel "' + key + '" already exists' ) return co ( function * ( ) { const channel = app [ key ] = yield app . connection . createChannel ( ) channel . __coworkersCloseHandler = module . exports . closeHandler . bind ( null , app , key ) channel . __coworkersErrorHandler = module . exports . errorHandler . bind ( null , app , key ) channel . once ( 'close' , channel . __coworkersCloseHandler ) channel . once ( 'error' , channel . __coworkersErrorHandler ) app . emit ( 'channel:create' , channel ) 
function errorHandler ( app , key , err ) { 
function createAppConnection ( app , url , socketOptions ) { assert ( ! app . connection , 'Cannot create connection if it already exists' ) return co ( function * ( ) { const conn = app . connection = yield amqplib . connect ( url , socketOptions ) conn . __coworkersCloseHandler = module . exports . closeHandler . bind ( null , app ) conn . __coworkersErrorHandler = module . exports . errorHandler . bind ( null , app ) conn . once ( 'close' , conn . __coworkersCloseHandler ) conn . once ( 'error' , conn . __coworkersErrorHandler ) app . emit ( 'connection:create' , conn ) return conn } ) } 
function errorHandler ( app , err ) { delete app . connection 
function respond ( ) { const context = this const consumeOpts = context . consumeOpts const channel = context . consumerChannel let method let args const methods = [ 'ack' , 'nack' , 'ackAll' , 'nackAll' , 'reject' ] method = methods . find ( function ( method ) { if ( context [ method ] ) { args = context [ method ] return true } } ) if ( method ) { args = values ( pick ( args , [ 'allUpTo' , 'requeue' ] ) ) if ( method === 'ack' || method === 'nack' ) { args . unshift ( context . message ) } channel [ method ] . apply ( channel , args ) } else if ( ! consumeOpts . noAck ) { 
function Application ( options ) { if ( ! ( this instanceof Application ) ) return new Application ( options ) EventEmitter . call ( this ) this.connection = <amqplibConnection> this.consumerChannel = <amqplibChannel> this.publisherChannel = <amqplibChannel> this.consumerTags = [...] */ } 
function assertAndConsumeAppQueue ( app , queueName ) { return co ( function * ( ) { const queue = app . queueMiddlewares [ queueName ] const queueOpts = queue . queueOpts const consumeOpts = queue . consumeOpts const handler = app . messageHandler ( queueName ) yield app . consumerChannel . assertQueue ( queueName , queueOpts ) return yield app . consumerChannel . consume ( queueName , handler , consumeOpts ) } ) } 
function getSelection ( el ) { var start = 0 , end = 0 , normalizedValue , range , textInputRange , len , endRange ; if ( typeof el . selectionStart == "number" && typeof el . selectionEnd == "number" ) { start = el . selectionStart ; end = el . selectionEnd ; } else { range = document . selection . createRange ( ) ; if ( range && range . parentElement ( ) == el ) { len = el . value . length ; normalizedValue = el . value . replace ( / \r\n / g , "\n" ) ; 
function parseShardFun ( str ) { str = str . trim ( ) if ( str . length === 0 ) { throw new Error ( 'empty shard string' ) } if ( ! str . startsWith ( PREFIX ) ) { throw new Error ( ` ${ str } ` ) } const parts = str . slice ( PREFIX . length ) . split ( '/' ) const version = parts [ 0 ] if ( version !== 'v1' ) { throw new Error ( ` ${ version } ` ) } const name = parts [ 1 ] if ( ! parts [ 2 ] ) { throw new Error ( 'missing param' ) } const param = parseInt ( parts [ 2 ] , 10 ) switch ( name ) { case 'prefix' : return new Prefix ( param ) case 'suffix' : return new Suffix ( param ) case 'next-to-last' : return new NextToLast ( param ) default : throw new Error ( ` ${ name } ` ) } } 
function setDOM ( oldNode , newNode ) { 
function setNode ( oldNode , newNode ) { if ( oldNode . nodeType === newNode . nodeType ) { 
function setAttributes ( oldAttributes , newAttributes ) { var i , a , b , ns , name 
function setChildNodes ( oldParent , newParent ) { var checkOld , oldKey , checkNew , newKey , foundNode , keyedNodes var oldNode = oldParent . firstChild var newNode = newParent . firstChild var extra = 0 
function getKey ( node ) { if ( node . nodeType !== ELEMENT_TYPE ) return var key = node . getAttribute ( setDOM . KEY ) || node . id if ( key ) return KEY_PREFIX + key } 
function isEqualNode ( a , b ) { return ( 
function dispatch ( node , type ) { 
function join ( socket , multiaddr , pub , cb ) { const log = socket . log = config . log . bind ( config . log , '[' + socket . id + ']' ) if ( getConfig ( ) . strictMultiaddr && ! util . validateMa ( multiaddr ) ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) return cb ( 'Invalid multiaddr' ) } if ( getConfig ( ) . cryptoChallenge ) { if ( ! pub . length ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) return cb ( 'Crypto Challenge required but no Id provided' ) } if ( ! nonces [ socket . id ] ) { nonces [ socket . id ] = { } } if ( nonces [ socket . id ] [ multiaddr ] ) { log ( 'response cryptoChallenge' , multiaddr ) nonces [ socket . id ] [ multiaddr ] . key . verify ( Buffer . from ( nonces [ socket . id ] [ multiaddr ] . nonce ) , Buffer . from ( pub , 'hex' ) , ( err , ok ) => { if ( err || ! ok ) { joinsTotal . inc ( ) joinsFailureTotal . inc ( ) } if ( err ) { return cb ( 'Crypto error' ) } 
function ( reference , options ) { reference = reference . trim ( ) if ( reference . lastIndexOf ( '#' , 0 ) < 0 ) { console . warn ( 'Remote references not supported yet. Reference must start with "#" (but was ' + reference + ')' ) return { } } var components = reference . split ( '#' ) 
function dataType ( value ) { if ( ! value ) return null if ( value [ 'anyOf' ] || value [ 'allOf' ] || value [ 'oneOf' ] ) { return '' } if ( ! value . type ) { return 'object' } if ( value . type === 'array' ) { return dataType ( value . items || { } ) + '[]' } return value . type } 
function connect ( ) { const args = normalizeConnectArgs ( arguments ) ; const options = { host : 'localhost' , port : 61613 , timeout : 3000 , connectHeaders : { } , ... args [ 0 ] } ; const connectListener = args [ 1 ] ; let client = null ; let socket = null ; let timeout = null ; let originalSocketDestroy = null ; const cleanup = function ( ) { if ( timeout ) { clearTimeout ( timeout ) ; } client . removeListener ( 'error' , onError ) ; client . removeListener ( 'connect' , onConnected ) ; } ; const onError = function ( error ) { cleanup ( ) ; error . connectArgs = options ; if ( typeof connectListener === 'function' ) { connectListener ( error ) ; } } ; const onConnected = function ( ) { if ( originalSocketDestroy ) { socket . destroy = originalSocketDestroy ; } cleanup ( ) ; client . emit ( 'socket-connect' ) ; const connectOpts = Object . assign ( { host : options . host } , options . connectHeaders ) ; client . connect ( connectOpts , connectListener ) ; } ; let transportConnect = net . connect ; if ( 'connect' in options ) { transportConnect = options . connect ; } else { if ( 'ssl' in options ) { if ( typeof options . ssl === 'boolean' ) { if ( options . ssl === true ) { transportConnect = tls . connect ; } } else { if ( options . ssl !== void 0 ) { throw new Error ( 'expected ssl property to have boolean value' ) ; } } } } socket = transportConnect ( options , onConnected ) ; if ( options . timeout > 0 ) { timeout = setTimeout ( function ( ) { client . destroy ( client . createTransportError ( 'connect timed out' ) ) ; } , options . timeout ) ; originalSocketDestroy = socket . destroy ; socket . destroy = function ( ) { clearTimeout ( timeout ) ; socket . destroy = originalSocketDestroy ; originalSocketDestroy . apply ( socket , arguments ) ; } ; } client = new Client ( socket , options ) ; client . on ( 'error' , onError ) ; return client ; } 
function parseServerUri ( uri ) { const comps = uri . match ( / ^\s*((\w+):\/\/)?(([^:]+):([^@]+)@)?([\w-.]+)(:(\d+))?\s*$ / ) ; if ( ! comps ) { throw new Error ( 'could not parse server uri \'' + uri + '\'' ) ; } const scheme = comps [ 2 ] ; const login = comps [ 4 ] ; const passcode = comps [ 5 ] ; const hostname = comps [ 6 ] ; const port = comps [ 8 ] ; const server = { host : hostname , connectHeaders : { } } ; if ( scheme !== void 0 ) { server . ssl = scheme === 'ssl' || scheme === 'stomp+ssl' ; } if ( port !== void 0 ) { server . port = parseInt ( port , 10 ) ; } if ( login !== void 0 ) { server . connectHeaders . login = login ; } if ( passcode !== void 0 ) { server . connectHeaders . passcode = passcode ; } if ( scheme === 'unix' || hostname [ 0 ] === '/' ) { if ( port !== void 0 ) { throw new Error ( 'invalid server uri \'' + uri + '\'' ) ; } server . path = hostname ; server . ssl = false ; } return server ; } 
function getAddressInfo ( args ) { let info ; if ( typeof args . connect === 'function' && typeof args . connect . getAddressInfo === 'function' ) { info = args . connect . getAddressInfo ( args ) ; } const hasPath = typeof args . path === 'string' ; const hasHost = typeof args . host === 'string' ; const hasPort = ! isNaN ( args . port ) ; const hasSSL = args . ssl === true ; const hasConnectHeaders = typeof args . connectHeaders === 'object' ; const login = hasConnectHeaders && args . connectHeaders . login ; const hasHostHeader = hasConnectHeaders && typeof args . connectHeaders . host === 'string' && args . connectHeaders . host . length > 0 ; let transport ; if ( hasHost ) { transport = hasSSL ? 'ssl' : 'tcp' ; } else if ( hasPath ) { transport = 'unix' ; } let pseudoUri = 'stomp+' + transport + '://' ; if ( login ) { pseudoUri += login + '@' ; } let transportPath = '' ; if ( hasHost ) { transportPath += args . host ; } else if ( hasPath ) { transportPath += args . path ; } if ( hasHost && hasPort ) { transportPath += ':' + args . port ; } pseudoUri += transportPath ; if ( hasHostHeader ) { pseudoUri += '/' + args . connectHeaders . host ; } return Object . assign ( { connectArgs : args , transport : transport , transportPath : transportPath , path : args . path , host : args . host , port : args . port , pseudoUri : pseudoUri } , info || { } ) ; } 
function ( err , images ) { var alert = $ ( '<div class="alert alert-dismissable fade show">' ) ; alert . append ( '<button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>' ) ; if ( err ) { alert . addClass ( 'alert-danger' ) ; alert . append ( '<p class="mb-0"><strong>Error:</strong> ' + err . message + '</p>' ) ; } else { alert . addClass ( 'alert-success' ) ; alert . append ( '<p><strong>Success:</strong></p>' ) ; images . forEach ( function ( image , index ) { var text = image . width + 'x' + image . height + ', ' + image . bpp + 'bit' ; var url = URL . createObjectURL ( new Blob ( [ image . buffer ] , { type : mime } ) ) ; alert . append ( '<p class="mb-' + ( index === images . length - 1 ? 0 : 3 ) + '"><a href="' + url + '" target="_blank"><img src="' + url + '" /> ' + text + '</a></p>' ) ; } ) ; } alert . prependTo ( '#demos-parse-results' ) ; } 
function forceUpdateSuiteData ( suites , test ) { const id = getSuiteId ( test ) ; suites [ id ] = cloneDeep ( suites [ id ] ) ; } 
function pd ( event ) { const retv = privateData . get ( event ) ; console . assert ( retv != null , "'this' is expected an Event object, but got" , event ) ; return retv } 
function setCancelFlag ( data ) { if ( data . passiveListener != null ) { if ( typeof console !== "undefined" && typeof console . error === "function" ) { console . error ( "Unable to preventDefault inside passive event listener invocation." , data . passiveListener ) ; } return } if ( ! data . event . cancelable ) { return } data . canceled = true ; if ( typeof data . event . preventDefault === "function" ) { data . event . preventDefault ( ) ; } } 
function defineRedirectDescriptor ( key ) { return { get ( ) { return pd ( this ) . event [ key ] } , set ( value ) { pd ( this ) . event [ key ] = value ; } , configurable : true , enumerable : true , } } 
function defineCallDescriptor ( key ) { return { value ( ) { const event = pd ( this ) . event ; return event [ key ] . apply ( event , arguments ) } , configurable : true , enumerable : true , } } 
function defineWrapper ( BaseEvent , proto ) { const keys = Object . keys ( proto ) ; if ( keys . length === 0 ) { return BaseEvent } function CustomEvent ( eventTarget , event ) { BaseEvent . call ( this , eventTarget , event ) ; } CustomEvent . prototype = Object . create ( BaseEvent . prototype , { constructor : { value : CustomEvent , configurable : true , writable : true } , } ) ; 
function getWrapper ( proto ) { if ( proto == null || proto === Object . prototype ) { return Event } let wrapper = wrappers . get ( proto ) ; if ( wrapper == null ) { wrapper = defineWrapper ( getWrapper ( Object . getPrototypeOf ( proto ) ) , proto ) ; wrappers . set ( proto , wrapper ) ; } return wrapper } 
function wrapEvent ( eventTarget , event ) { const Wrapper = getWrapper ( Object . getPrototypeOf ( event ) ) ; return new Wrapper ( eventTarget , event ) } 
function getListeners ( eventTarget ) { const listeners = listenersMap . get ( eventTarget ) ; if ( listeners == null ) { throw new TypeError ( "'this' is expected an EventTarget object, but got another value." ) } return listeners } 
function defineEventAttributeDescriptor ( eventName ) { return { get ( ) { const listeners = getListeners ( this ) ; let node = listeners . get ( eventName ) ; while ( node != null ) { if ( node . listenerType === ATTRIBUTE ) { return node . listener } node = node . next ; } return null } , set ( listener ) { if ( typeof listener !== "function" && ! isObject ( listener ) ) { listener = null ; 
function defineCustomEventTarget ( eventNames ) { function CustomEventTarget ( ) { EventTarget . call ( this ) ; } CustomEventTarget . prototype = Object . create ( EventTarget . prototype , { constructor : { value : CustomEventTarget , configurable : true , writable : true , } , } ) ; for ( let i = 0 ; i < eventNames . length ; ++ i ) { defineEventAttribute ( CustomEventTarget . prototype , eventNames [ i ] ) ; } return CustomEventTarget } 
function EventTarget ( ) { if ( this instanceof EventTarget ) { listenersMap . set ( this , new Map ( ) ) ; return } if ( arguments . length === 1 && Array . isArray ( arguments [ 0 ] ) ) { return defineCustomEventTarget ( arguments [ 0 ] ) } if ( arguments . length > 0 ) { const types = new Array ( arguments . length ) ; for ( let i = 0 ; i < arguments . length ; ++ i ) { types [ i ] = arguments [ i ] ; } return defineCustomEventTarget ( types ) } throw new TypeError ( "Cannot call a class as a function" ) } 
function ( fileName , retrying ) { let file = assets [ fileName ] || { } ; let key = path . posix . join ( uploadPath , fileName ) ; let putPolicy = new qiniu . rs . PutPolicy ( { scope : bucket + ':' + key } ) ; let uploadToken = putPolicy . uploadToken ( mac ) ; let formUploader = new qiniu . form_up . FormUploader ( qiniuConfig ) ; let putExtra = new qiniu . form_up . PutExtra ( ) ; return new Promise ( ( resolve ) => { let begin = Date . now ( ) ; formUploader . putFile ( uploadToken , key , file . existsAt , putExtra , function ( err , body ) { 
function ( err ) { if ( err ) { 
function ( ev ) { var cts , i , nextPointers if ( ! ev . defaultPrevented ) { if ( _preventDefault ) { ev . preventDefault ( ) } nextPointers = utils . clone ( _currPointers ) 
function ( ev ) { var nextPointers if ( ! ev . defaultPrevented ) { if ( _preventDefault ) { ev . preventDefault ( ) } if ( ! _mouseDown ) { _mouseDown = true nextPointers = utils . clone ( _currPointers ) 
function ( space ) { 
function ( select2_data ) { var model ; if ( opts . simple_tags ) { model = [ ] ; angular . forEach ( select2_data , function ( value , index ) { model . push ( value . id ) ; } ) ; } else { model = select2_data ; } return model ; } 
function ( angular_data ) { var model = [ ] ; if ( ! angular_data ) { return model ; } if ( opts . simple_tags ) { model = [ ] ; angular . forEach ( angular_data , function ( value , index ) { model . push ( { 'id' : value , 'text' : value } ) ; } ) ; } else { model = angular_data ; } return model ; } 
function teamcity ( runner ) { Base . call ( this , runner ) ; var stats = this . stats ; var flowId = document . title || new Date ( ) . getTime ( ) ; runner . on ( 'suite' , function ( suite ) { if ( suite . root ) return ; suite . startDate = new Date ( ) ; log ( '##teamcity[testSuiteStarted name=\'' + escape ( suite . title ) + '\' flowId=\'' + flowId + '\']' ) ; } ) ; runner . on ( 'test' , function ( test ) { log ( '##teamcity[testStarted name=\'' + escape ( test . title ) + '\' flowId=\'' + flowId + '\' captureStandardOutput=\'true\']' ) ; } ) ; runner . on ( 'fail' , function ( test , err ) { log ( '##teamcity[testFailed name=\'' + escape ( test . title ) + '\' flowId=\'' + flowId + '\' message=\'' + escape ( err . message ) + '\' captureStandardOutput=\'true\' details=\'' + escape ( err . stack ) + '\']' ) ; } ) ; runner . on ( 'pending' , function ( test ) { log ( '##teamcity[testIgnored name=\'' + escape ( test . title ) + '\' flowId=\'' + flowId + '\' message=\'pending\']' ) ; } ) ; runner . on ( 'test end' , function ( test ) { log ( '##teamcity[testFinished name=\'' + escape ( test . title ) + '\' flowId=\'' + flowId + '\' duration=\'' + test . duration + '\']' ) ; } ) ; runner . on ( 'suite end' , function ( suite ) { if ( suite . root ) return ; log ( '##teamcity[testSuiteFinished name=\'' + escape ( suite . title ) + '\' duration=\'' + ( new Date ( ) - suite . startDate ) + '\' flowId=\'' + flowId + '\']' ) ; } ) ; runner . on ( 'end' , function ( ) { log ( '##teamcity[testSuiteFinished name=\'mocha.suite\' duration=\'' + stats . duration + '\' flowId=\'' + flowId + '\']' ) ; } ) ; } 
function Teamcity ( runner , options ) { options = options || { } ; const reporterOptions = options . reporterOptions || { } ; let flowId , useStdError , recordHookFailures ; ( reporterOptions . flowId ) ? flowId = reporterOptions . flowId : flowId = process . env [ 'MOCHA_TEAMCITY_FLOWID' ] || processPID ; ( reporterOptions . useStdError ) ? useStdError = reporterOptions . useStdError : useStdError = process . env [ 'USE_STD_ERROR' ] ; ( reporterOptions . recordHookFailures ) ? recordHookFailures = reporterOptions . recordHookFailures : recordHookFailures = process . env [ 'RECORD_HOOK_FAILURES' ] ; ( useStdError ) ? useStdError = ( useStdError . toLowerCase ( ) === 'true' ) : useStdError = false ; ( recordHookFailures ) ? recordHookFailures = ( recordHookFailures . toLowerCase ( ) === 'true' ) : recordHookFailures = false ; Base . call ( this , runner ) ; let stats = this . stats ; const topLevelSuite = reporterOptions . topLevelSuite || process . env [ 'MOCHA_TEAMCITY_TOP_LEVEL_SUITE' ] ; runner . on ( 'suite' , function ( suite ) { if ( suite . root ) { if ( topLevelSuite ) { log ( formatString ( SUITE_START , topLevelSuite , flowId ) ) ; } return ; } suite . startDate = new Date ( ) ; log ( formatString ( SUITE_START , suite . title , flowId ) ) ; } ) ; runner . on ( 'test' , function ( test ) { log ( formatString ( TEST_START , test . title , flowId ) ) ; } ) ; runner . on ( 'fail' , function ( test , err ) { if ( useStdError ) { logError ( formatString ( TEST_FAILED , test . title , err . message , err . stack , flowId ) ) ; } else { log ( formatString ( TEST_FAILED , test . title , err . message , err . stack , flowId ) ) ; } } ) ; runner . on ( 'pending' , function ( test ) { log ( formatString ( TEST_IGNORED , test . title , test . title , flowId ) ) ; } ) ; runner . on ( 'test end' , function ( test ) { log ( formatString ( TEST_END , test . title , test . duration , flowId ) ) ; } ) ; runner . on ( 'hook' , function ( test ) { if ( recordHookFailures ) { log ( formatString ( TEST_START , test . title , flowId ) ) ; } } ) ; runner . on ( 'suite end' , function ( suite ) { if ( suite . root ) return ; log ( formatString ( SUITE_END , suite . title , new Date ( ) - suite . startDate , flowId ) ) ; } ) ; runner . on ( 'end' , function ( ) { if ( topLevelSuite ) { log ( formatString ( SUITE_END , topLevelSuite , stats . duration , flowId ) ) ; } log ( formatString ( SUITE_END , 'mocha.suite' , stats . duration , flowId ) ) ; } ) ; } 
function convert ( integer ) { var str = Number ( integer ) . toString ( 16 ) ; return str . length === 1 ? '0' + str : str ; } 
function parse ( text , options ) { options = Object . assign ( { } , { relaxed : true } , options ) ; 
function stringify ( value , replacer , space , options ) { if ( space != null && typeof space === 'object' ) ( options = space ) , ( space = 0 ) ; if ( replacer != null && typeof replacer === 'object' ) ( options = replacer ) , ( replacer = null ) , ( space = 0 ) ; options = Object . assign ( { } , { relaxed : true } , options ) ; const doc = Array . isArray ( value ) ? serializeArray ( value , options ) : serializeDocument ( value , options ) ; return JSON . stringify ( doc , replacer , space ) ; } 
function serialize ( bson , options ) { options = options || { } ; return JSON . parse ( stringify ( bson , options ) ) ; } 
function deserialize ( ejson , options ) { options = options || { } ; return parse ( JSON . stringify ( ejson ) , options ) ; } 
function Facade ( obj , opts ) { opts = opts || { } ; if ( ! ( 'clone' in opts ) ) opts . clone = true ; if ( opts . clone ) obj = clone ( obj ) ; if ( ! ( 'traverse' in opts ) ) opts . traverse = true ; if ( ! ( 'timestamp' in obj ) ) obj . timestamp = new Date ( ) ; else obj . timestamp = newDate ( obj . timestamp ) ; if ( opts . traverse ) traverse ( obj ) ; this . opts = opts ; this . obj = obj ; } 
function makeDefineVirtualModule ( loader , load , addDep , args ) { function namer ( loadName ) { var baseName = loadName . substr ( 0 , loadName . indexOf ( "!" ) ) ; return function ( part , plugin ) { return baseName + "-" + part + ( plugin ? ( "." + plugin ) : "" ) ; } ; } function addresser ( loadAddress ) { return function ( part , plugin ) { var base = loadAddress + "." + part ; return base + ( plugin ? ( "." + plugin ) : "" ) ; } ; } var name = namer ( load . name ) ; var address = addresser ( load . address ) ; 
function getFilename ( name ) { var hash = name . indexOf ( '#' ) ; var bang = name . indexOf ( '!' ) ; return name . slice ( hash < bang ? ( hash + 1 ) : 0 , bang ) ; } 
function translate ( load ) { var filename ; 
function ( depName , isVirtual ) { deps . push ( depName ) ; if ( isVirtual !== false ) load . metadata . virtualDeps . push ( depName ) ; } 
function MIDIFile ( buffer , strictMode ) { var track ; var curIndex ; var i ; var j ; 
function MIDIFileTrack ( buffer , start ) { let a ; let trackLength ; 
function matchSemver ( myProtocol , senderProtocol , callback ) { const mps = myProtocol . split ( '/' ) const sps = senderProtocol . split ( '/' ) const myName = mps [ 1 ] const myVersion = mps [ 2 ] const senderName = sps [ 1 ] const senderVersion = sps [ 2 ] if ( myName !== senderName ) { return callback ( null , false ) } 
function encode ( msg , callback ) { pull ( values ( Buffer . isBuffer ( msg ) ? [ msg ] : [ Buffer . from ( msg ) ] ) , pullLP . encode ( ) , collect ( ( err , encoded ) => { if ( err ) { return callback ( err ) } callback ( null , encoded [ 0 ] ) } ) ) } 
function matchExact ( myProtocol , senderProtocol , callback ) { const result = myProtocol === senderProtocol callback ( null , result ) } 
function diffArrays ( arr1 , arr2 ) { if ( ! Array . isArray ( arr1 ) || ! Array . isArray ( arr2 ) ) { return true ; } if ( arr1 . length !== arr2 . length ) { return true ; } for ( var i = 0 , len = arr1 . length ; i < len ; i ++ ) { if ( arr1 [ i ] !== arr2 [ i ] ) { return true ; } } return false ; } 
function getSourceRuleString ( sourceRule ) { function getRuleString ( rule ) { if ( rule . length === 1 ) { return '"' + rule + '"' ; } return '("' + rule . join ( '" AND "' ) + '")' ; } return sourceRule . map ( getRuleString ) . join ( ' OR ' ) ; } 
function getTimelineArgs ( scope ) { var timelineArgs = { sourceType : scope . sourceType } ; 
function ( method , klass ) { while ( ! ! klass ) { var key = null , pro = klass . prototype ; 
function ( config ) { _logger . info ( 'begin dump files ...' ) ; var map = { } ; [ 'fileInclude' , 'fileExclude' ] . forEach ( function ( name ) { var value = config [ name ] ; if ( ! ! value ) { if ( typeof value === 'string' ) { var reg = new RegExp ( value , 'i' ) ; config [ name ] = function ( file ) { return reg . test ( file ) ; } ; } else if ( ! ! value . test ) { config [ name ] = function ( file ) { return value . test ( file ) ; } } } if ( ! _util . isFunction ( config [ name ] ) ) { var flag = name !== 'fileExclude' ; config [ name ] = function ( file ) { return flag ; } ; } } ) ; ( config . resRoot || '' ) . split ( ',' ) . forEach ( function ( dir ) { if ( ! dir ) { return ; } var ret = _fs . lsfile ( dir , function ( name , file ) { return ! config . fileExclude ( file ) && config . fileInclude ( file ) ; } ) ; ret . forEach ( function ( v ) { map [ v ] = v . replace ( config . webRoot , config . temp ) ; } ) ; } ) ; _logger . debug ( 'package file map -> %j' , map ) ; Object . keys ( map ) . forEach ( function ( src ) { var dst = map [ src ] ; _fs . copy ( src , dst , function ( a ) { _logger . info ( 'copy file %s' , a ) ; } ) ; } ) ; } 
function ( config ) { _logger . info ( 'begin zip package ...' ) ; var cmd = [ 'java' , '-jar' , JSON . stringify ( config . zip ) , JSON . stringify ( config . temp ) , JSON . stringify ( config . output ) ] . join ( ' ' ) ; _logger . debug ( 'do command: %s' , cmd ) ; exec ( cmd , function ( error , stdout , stderr ) { if ( error ) { _logger . error ( 'zip package error for reason:\n%s' , error . stack ) ; process . abort ( ) ; return ; } if ( stdout ) { _logger . info ( stdout ) ; } if ( stderr ) { _logger . error ( stderr ) ; } uploadToServer ( config ) ; } ) ; } 
function ( config ) { if ( ! _fs . exist ( config . output ) ) { return abortProcess ( config , 'no package to be uploaded' ) ; } _logger . info ( 'begin build upload form ...' ) ; var form = new FormData ( ) ; var ex = _util . merge ( { version : '0.1' , platform : 'ios&android' } , config . extension ) ; 
function ( config ) { _logger . info ( 'clear temporary directory and files' ) ; _fs . rmdir ( config . temp ) ; _fs . rm ( config . output ) ; } 
function ( config ) { var args = [ ] . slice . call ( arguments , 0 ) ; clearTemp ( args . shift ( ) ) ; _logger . error . apply ( _logger , args ) ; process . abort ( ) ; } 
function ( content ) { var ret , handler = function ( map ) { ret = map ; } , sandbox = { NEJ : { deps : handler , config : handler } } ; 
function ( patform , deps , func ) { var args = exports . formatARG . apply ( exports , arguments ) ; if ( ! this . patches ) { this . patches = [ ] ; } 
function ( content ) { 
function ( uri , deps , func ) { var args = exports . formatARG . apply ( exports , arguments ) ; this . isNEJ = ! 0 ; this . dependency = args [ 1 ] ; this . source = ( args [ 2 ] || '' ) . toString ( ) ; } 
function ( result , exp ) { switch ( exp . op ) { case '<' : case '<=' : result . lower = exp ; break ; case '>' : case '>=' : result . upper = exp ; break ; case '=' : case '==' : result . midle = exp ; break ; } delete exp . op ; } 
function ( result , exp ) { switch ( exp . op ) { case '<' : case '<=' : 
function ( name , config ) { var patch = config . patch ; if ( ! patch ) { return ; } 
function ( name , config , plugins ) { var plugin = config . plugin ; if ( ! plugin ) { return ; } 
function ( event ) { if ( event . type == 'script' ) { event . value = this . _checkResInScript ( event . file , event . content , options ) ; } } 
function ( uri , config ) { 
function ( uri , config ) { config = _util . merge ( config , { domain : config . csDomain } ) ; return this . _formatRSURI ( uri , '.css' , config ) ; } 
function ( uri , config ) { config = _util . merge ( config , { domain : config . jsDomain } ) ; return this . _formatRSURI ( uri , '.js' , config ) ; } 
function ( uri , config ) { return this . _formatURI ( uri , { fromPage : config . fromPage , pathRoot : config . output , webRoot : config . webRoot } ) ; } 
function ( uri , config ) { _io . resource ( 'manifested' , ! 0 ) ; return this . _formatURI ( config . manOutput , { pathRoot : config . output , webRoot : config . webRoot , domain : config . manRoot } ) ; } 
function ( uri , config ) { uri = uri . replace ( config . srcRoot , config . outHtmlRoot ) ; return this . _formatURI ( uri , { pathRoot : config . output , webRoot : config . webRoot , domain : config . mdlRoot } ) ; } 
function ( uri , config ) { return uri . replace ( config . srcRoot , config . outHtmlRoot ) . replace ( config . webRoot , '/' ) ; } 
function global ( map ) { Object . keys ( map ) . forEach ( function ( key ) { var file = map [ key ] , arr = file . split ( '#' ) , mdl = require ( './lib/' + arr [ 0 ] + '.js' ) ; 
function ( src , events ) { 
function fmix32 ( hash ) { hash ^= hash >>> 16 hash = multiply ( hash , 0x85ebca6b ) hash ^= hash >>> 13 hash = multiply ( hash , 0xc2b2ae35 ) hash ^= hash >>> 16 return hash } 
function fmix32_pure ( hash ) { hash = ( hash ^ ( hash >>> 16 ) ) >>> 0 hash = multiply ( hash , 0x85ebca6b ) hash = ( hash ^ ( hash >>> 13 ) ) >>> 0 hash = multiply ( hash , 0xc2b2ae35 ) hash = ( hash ^ ( hash >>> 16 ) ) >>> 0 return hash } 
function Strata ( options ) { this . options = options this . options . comparator = options . comparator || compare this . journalist = new Journalist ( this , options ) this . housekeeper = new Turnstile this . writer = new Turnstile this . _cursors = [ ] } 
function bindKeys ( scope , obj , def , parentNode , path ) { var meta , key if ( typeof obj !== 'object' || obj === null ) throw new TypeError ( 'Invalid type of value "' + obj + '", object expected.' ) Object . defineProperty ( obj , memoizedObjectKey , { value : { } , configurable : true } ) Object . defineProperty ( obj , metaKey , { value : { } , configurable : true } ) meta = obj [ metaKey ] for ( key in def ) { meta [ key ] = { keyPath : { key : key , root : path . root , target : obj } , activeNodes : [ ] , previousValues : [ ] , 
function bindKey ( scope , obj , def , key , parentNode ) { var memoizedObject = obj [ memoizedObjectKey ] var meta = obj [ metaKey ] [ key ] var branch = def [ key ] var node = branch [ 0 ] var change = ! branch [ hasDefinitionKey ] && branch [ 1 ] var definition = branch [ hasDefinitionKey ] && branch [ 1 ] var mount = branch [ 2 ] var isMarkerLast = branch [ isMarkerLastKey ] 
function parentSetter ( x ) { var previousValue = memoizedObject [ key ] var returnValue 
function replaceNode ( value , previousValue , i ) { var activeNode = activeNodes [ i ] var currentNode = node var returnValue 
function pop ( ) { var i = this . length - 1 var previousValue = previousValues [ i ] var value = Array . prototype . pop . call ( this ) removeNode ( null , previousValue , i ) previousValues . length = activeNodes . length = this . length return value } 
function changeValue ( node , value , attribute ) { var firstChild switch ( attribute ) { case 'textContent' : firstChild = node . firstChild if ( firstChild && ! firstChild . nextSibling && firstChild . nodeType === TEXT_NODE ) firstChild . textContent = value else node . textContent = value break case 'checked' : node . checked = Boolean ( value ) break case 'value' : 
function getNextNode ( index , activeNodes ) { var i , j , nextNode for ( i = index , j = activeNodes . length ; i < j ; i ++ ) if ( activeNodes [ i ] ) { nextNode = activeNodes [ i ] break } return nextNode } 
function updateChange ( targetKey , path , key ) { var target = path . target var index = path . index var replaceKey = key if ( typeof index === 'number' ) { target = target [ key ] replaceKey = index } return function handleChange ( event ) { target [ replaceKey ] = event . target [ targetKey ] } } 
function simulacra ( obj , def , matchNode ) { var document = this ? this . document : window . document var Node = this ? this . Node : window . Node var node , query 
function ensureNodes ( parentNode , def ) { var adjacentNodes = [ ] var i , j , key , query , branch , boundNode , matchedNodes var adjacentNode , adjacentKey if ( typeof def !== 'object' ) throw new TypeError ( 'The second position must be an object.' ) for ( key in def ) { branch = def [ key ] 
function cleanNode ( scope , node ) { 
function processNodes ( scope , node , def ) { var document = scope ? scope . document : window . document var key , branch , result , mirrorNode , parent , marker , indices var i , j , treeWalker , orderedKeys result = def [ templateKey ] if ( ! result ) { node = node . cloneNode ( true ) indices = [ ] matchNodes ( scope , node , def ) orderedKeys = Object . keys ( def ) . sort ( function ( a , b ) { var nodeA = def [ a ] [ 0 ] [ matchedNodeKey ] var nodeB = def [ b ] [ 0 ] [ matchedNodeKey ] if ( nodeA && nodeB ) return nodeA . index - nodeB . index return 0 } ) for ( i = 0 ; i < orderedKeys . length ; i ++ ) { key = orderedKeys [ i ] branch = def [ key ] if ( branch [ isBoundToParentKey ] ) continue result = branch [ 0 ] [ matchedNodeKey ] indices . push ( result . index ) mirrorNode = result . node parent = mirrorNode . parentNode 
function matchNodes ( scope , node , def ) { var document = scope ? scope . document : window . document var treeWalker = document . createTreeWalker ( node , showAll , acceptNode , false ) var nodes = [ ] var i , j , key , currentNode , childWalker var nodeIndex = 0 
function rehydrate ( scope , obj , def , node , matchNode ) { var document = scope ? scope . document : window . document var key , branch , x , value , change , definition , mount , keyPath var meta , valueIsArray , activeNodes , index , treeWalker , currentNode for ( key in def ) { branch = def [ key ] meta = obj [ metaKey ] [ key ] change = ! branch [ hasDefinitionKey ] && branch [ 1 ] definition = branch [ hasDefinitionKey ] && branch [ 1 ] mount = branch [ 2 ] keyPath = meta . keyPath if ( branch [ isBoundToParentKey ] ) { x = obj [ key ] if ( definition && x !== null && x !== void 0 ) bindKeys ( scope , x , definition , matchNode , keyPath ) else if ( change ) change ( matchNode , x , null , keyPath ) continue } activeNodes = meta . activeNodes if ( ! activeNodes . length ) continue valueIsArray = meta . valueIsArray x = valueIsArray ? obj [ key ] : [ obj [ key ] ] index = 0 treeWalker = document . createTreeWalker ( matchNode , whatToShow , acceptNode , false ) while ( index < activeNodes . length && treeWalker . nextNode ( ) ) { currentNode = activeNodes [ index ] if ( treeWalker . currentNode . isEqualNode ( currentNode ) ) { activeNodes . splice ( index , 1 , treeWalker . currentNode ) value = x [ index ] if ( valueIsArray ) keyPath . index = index else delete keyPath . index if ( definition ) { rehydrate ( scope , value , definition , currentNode , treeWalker . currentNode ) if ( mount ) { keyPath . target = value mount ( treeWalker . currentNode , value , null , keyPath ) } } else if ( change ) change ( treeWalker . currentNode , value , null , keyPath ) index ++ } } if ( index !== activeNodes . length ) throw new Error ( 'Matching nodes could not be found on key "' + key + '", expected ' + activeNodes . length + ', found ' + index + '.' ) 
function render ( obj , def , html ) { var i , nodes , handler , parser , element , elementPrototype 
function featureCheck ( globalScope , features ) { var i , j , k , l , feature , path for ( i = 0 , j = features . length ; i < j ; i ++ ) { path = features [ i ] if ( typeof path [ 0 ] === 'string' ) { feature = globalScope for ( k = 0 , l = path . length ; k < l ; k ++ ) { if ( ! ( path [ k ] in feature ) ) throw new Error ( 'Missing ' + path . slice ( 0 , k + 1 ) . join ( '.' ) + ' feature which is required.' ) feature = feature [ path [ k ] ] } } else { feature = path [ 0 ] for ( k = 1 , l = path . length ; k < l ; k ++ ) { if ( k > 1 ) feature = feature [ path [ k ] ] if ( typeof feature === 'undefined' ) throw new Error ( 'Missing ' + path [ 0 ] . name + path . slice ( 1 , k + 1 ) . join ( '.' ) + ' feature which is required.' ) } } } } 
function bemNames ( entitys , delimiters ) { var resultString = '' ; var names = entitys || { mods : { } , mixin : '' } ; var delims = _extends ( { ns : '' , el : '__' , mod : '--' , modVal : '-' } , delimiters ) ; var mixin = isString ( names . mixin ) ? ' ' + names . mixin : '' ; if ( ! names . block ) return '' ; resultString = delims . ns ? delims . ns + names . block : names . block ; if ( names . el ) resultString += delims . el + names . el ; if ( isPObject ( names . mods ) ) { resultString += Object . keys ( names . mods ) . reduce ( function ( prev , name ) { var val = names . mods [ name ] ; if ( val === true ) { prev += ' ' + resultString + delims . mod + name ; } else if ( isString ( val ) || isNumber ( val ) ) { prev += ' ' + resultString + delims . mod + name + delims . modVal + names . mods [ name ] ; } return prev ; } , '' ) ; } return resultString + mixin ; } 
function write ( dest , code ) { return new Promise ( function ( resolve , reject ) { fs . writeFile ( dest , code , function ( err ) { if ( err ) return reject ( err ) 
function deepMergeConfigs ( configs , options ) { return merge . all ( configs . filter ( config => config ) , options ) ; } 
async function loadYaml ( context , params ) { try { const response = await context . github . repos . getContents ( params ) ; return parseConfig ( response . data . content ) ; } catch ( e ) { if ( e . code === 404 ) { return null ; } throw e ; } } 
function getBaseParams ( params , base ) { if ( typeof base !== 'string' ) { throw new Error ( ` ${ BASE_KEY } ` ) ; } const match = base . match ( BASE_REGEX ) ; if ( match == null ) { throw new Error ( ` ${ BASE_KEY } ${ base } ` ) ; } return { owner : match [ 1 ] || params . owner , repo : match [ 2 ] , path : match [ 3 ] || params . path , } ; } 
async function getConfig ( context , fileName , defaultConfig , deepMergeOptions ) { const filePath = path . posix . join ( CONFIG_PATH , fileName ) ; const params = context . repo ( { path : filePath , } ) ; const config = await loadYaml ( context , params ) ; let baseRepo ; if ( config == null ) { baseRepo = DEFAULT_BASE ; } else if ( config != null && BASE_KEY in config ) { baseRepo = config [ BASE_KEY ] ; delete config [ BASE_KEY ] ; } let baseConfig ; if ( baseRepo ) { const baseParams = getBaseParams ( params , baseRepo ) ; baseConfig = await loadYaml ( context , baseParams ) ; } if ( config == null && baseConfig == null && ! defaultConfig ) { return null ; } return deepMergeConfigs ( [ defaultConfig , baseConfig , config ] , deepMergeOptions ) ; } 
function defineProperty ( obj , name , value ) { var enumerable = ! ! obj [ name ] && obj . propertyIsEnumerable ( name ) Object . defineProperty ( obj , name , { configurable : true , enumerable : enumerable , writable : true , value : value } ) } 
function shimmer ( options ) { if ( options && options . logger ) { if ( ! isFunction ( options . logger ) ) logger ( "new logger isn't a function, not replacing" ) else logger = options . logger } } 
function injectManifest ( data ) { let manifestHtml = ` ${ hexo . config . pwa . manifest . path } ` ; if ( data . indexOf ( manifestHtml ) === - 1 ) { data = data . replace ( '<head>' , manifestHtml ) ; } return data ; } 
function injectSWRegister ( data ) { let swHtml = ` ${ compiledSWRegTpl } ` ; if ( data . indexOf ( compiledSWRegTpl ) === - 1 ) { data = data . replace ( '</body>' , swHtml ) ; } return data ; } 
function injectAsyncLoadPageJS ( data ) { let injectHtml = ` ${ asyncLoadPageJSTpl } ` ; if ( data . indexOf ( injectHtml ) === - 1 ) { data = data . replace ( '</head>' , injectHtml ) ; } return data ; } 
function rehype2react ( options ) { var settings = options || { } ; var createElement = settings . createElement ; var components = settings . components || { } ; this . Compiler = compiler ; function compiler ( node ) { if ( node . type === 'root' ) { if ( node . children . length === 1 && node . children [ 0 ] . type === 'element' ) { node = node . children [ 0 ] ; } else { node = { type : 'element' , tagName : 'div' , properties : node . properties || { } , children : node . children } ; } } return toH ( h , tableCellStyle ( node ) , settings . prefix ) ; } function h ( name , props , children ) { var component = has ( components , name ) ? components [ name ] : name ; return createElement ( component , props , children ) ; } } 
function compiler ( node ) { if ( node . type === 'root' ) { if ( node . children . length === 1 && node . children [ 0 ] . type === 'element' ) { node = node . children [ 0 ] ; } else { node = { type : 'element' , tagName : 'div' , properties : node . properties || { } , children : node . children } ; } } return toH ( h , tableCellStyle ( node ) , settings . prefix ) ; } 
function h ( name , props , children ) { var component = has ( components , name ) ? components [ name ] : name ; return createElement ( component , props , children ) ; } 
function doExec ( method , args ) { var cp ; var cpPromise = new ChildProcessPromise ( ) ; var reject = cpPromise . _cpReject ; var resolve = cpPromise . _cpResolve ; var finalArgs = slice . call ( args , 0 ) ; finalArgs . push ( callback ) ; cp = child_process [ method ] . apply ( child_process , finalArgs ) ; function callback ( err , stdout , stderr ) { if ( err ) { var commandStr = args [ 0 ] + ( Array . isArray ( args [ 1 ] ) ? ( ' ' + args [ 1 ] . join ( ' ' ) ) : '' ) ; err . message += ' `' + commandStr + '` (exited with error code ' + err . code + ')' ; err . stdout = stdout ; err . stderr = stderr ; var cpError = new ChildProcessError ( err . message , err . code , child_process , stdout , stderr ) ; reject ( cpError ) ; } else { resolve ( { childProcess : cp , stdout : stdout , stderr : stderr } ) ; } } cpPromise . childProcess = cp ; return cpPromise ; } 
function doSpawn ( method , command , args , options ) { var result = { } ; var cp ; var cpPromise = new ChildProcessPromise ( ) ; var reject = cpPromise . _cpReject ; var resolve = cpPromise . _cpResolve ; var successfulExitCodes = ( options && options . successfulExitCodes ) || [ 0 ] ; cp = method ( command , args , options ) ; 
function slope3 ( that , x2 , y2 ) { var h0 = that . _x1 - that . _x0 , h1 = x2 - that . _x1 , s0 = ( that . _y1 - that . _y0 ) / ( h0 || h1 < 0 && - 0 ) , s1 = ( y2 - that . _y1 ) / ( h1 || h0 < 0 && - 0 ) , p = ( s0 * h1 + s1 * h0 ) / ( h0 + h1 ) ; return ( sign ( s0 ) + sign ( s1 ) ) * Math . min ( Math . abs ( s0 ) , Math . abs ( s1 ) , 0.5 * Math . abs ( p ) ) || 0 ; } 
function slope2 ( that , t ) { var h = that . _x1 - that . _x0 ; return h ? ( 3 * ( that . _y1 - that . _y0 ) / h - t ) / 2 : t ; } 
function point ( that , t0 , t1 ) { var x0 = that . _x0 , y0 = that . _y0 , x1 = that . _x1 , y1 = that . _y1 , dx = ( x1 - x0 ) / 3 ; that . _context . bezierCurveTo ( x0 + dx , y0 + dx * t0 , x1 - dx , y1 - dx * t1 , x1 , y1 ) ; } 
function shouldSetAttribute ( name , value ) { if ( isReservedProp ( name ) ) { return false ; } if ( name . length > 2 && ( name [ 0 ] === 'o' || name [ 0 ] === 'O' ) && ( name [ 1 ] === 'n' || name [ 1 ] === 'N' ) ) { return false ; } if ( value === null ) { return true ; } switch ( typeof value ) { case 'boolean' : return shouldAttributeAcceptBooleanValue ( name ) ; case 'undefined' : case 'number' : case 'string' : case 'object' : return true ; default : 
function createMarkupForProperty ( name , value ) { var propertyInfo = getPropertyInfo ( name ) ; if ( propertyInfo ) { if ( shouldIgnoreValue ( propertyInfo , value ) ) { return '' ; } var attributeName = propertyInfo . attributeName ; if ( propertyInfo . hasBooleanValue || propertyInfo . hasOverloadedBooleanValue && value === true ) { return attributeName + '=""' ; } else if ( typeof value !== 'boolean' || shouldAttributeAcceptBooleanValue ( name ) ) { return attributeName + '=' + quoteAttributeValueForBrowser ( value ) ; } } else if ( shouldSetAttribute ( name , value ) ) { if ( value == null ) { return '' ; } return name + '=' + quoteAttributeValueForBrowser ( value ) ; } return null ; } 
function renderToString ( element ) { var renderer = new ReactDOMServerRenderer$1 ( element , false ) ; var markup = renderer . read ( Infinity ) ; return markup ; } 
function renderToStaticMarkup ( element ) { var renderer = new ReactDOMServerRenderer$1 ( element , true ) ; var markup = renderer . read ( Infinity ) ; return markup ; } 
function trapBubbledEvent ( topLevelType , handlerBaseName , element ) { if ( ! element ) { return null ; } return EventListener . listen ( element , handlerBaseName , dispatchEvent . bind ( null , topLevelType ) ) ; } 
function getModernOffsetsFromPoints ( outerNode , anchorNode , anchorOffset , focusNode$$1 , focusOffset ) { var length = 0 ; var start = - 1 ; var end = - 1 ; var indexWithinAnchor = 0 ; var indexWithinFocus = 0 ; var node = outerNode ; var parentNode = null ; outer : while ( true ) { var next = null ; while ( true ) { if ( node === anchorNode && ( anchorOffset === 0 || node . nodeType === TEXT_NODE ) ) { start = length + anchorOffset ; } if ( node === focusNode$$1 && ( focusOffset === 0 || node . nodeType === TEXT_NODE ) ) { end = length + focusOffset ; } if ( node . nodeType === TEXT_NODE ) { length += node . nodeValue . length ; } if ( ( next = node . firstChild ) === null ) { break ; } 
function createUpdateQueue ( baseState ) { var queue = { baseState : baseState , expirationTime : NoWork , first : null , last : null , callbackList : null , hasForceUpdate : false , isInitialized : false } ; { queue . isProcessing = false ; } return queue ; } 
function mountClassInstance ( workInProgress , renderExpirationTime ) { var current = workInProgress . alternate ; { checkClassInstance ( workInProgress ) ; } var instance = workInProgress . stateNode ; var state = instance . state || null ; var props = workInProgress . pendingProps ; ! props ? invariant ( false , 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.' ) : void 0 ; var unmaskedContext = getUnmaskedContext ( workInProgress ) ; instance . props = props ; instance . state = workInProgress . memoizedState = state ; instance . refs = emptyObject ; instance . context = getMaskedContext ( workInProgress , unmaskedContext ) ; if ( enableAsyncSubtreeAPI && workInProgress . type != null && workInProgress . type . prototype != null && workInProgress . type . prototype . unstable_isAsyncReactComponent === true ) { workInProgress . internalContextTag |= AsyncUpdates ; } if ( typeof instance . componentWillMount === 'function' ) { callComponentWillMount ( workInProgress , instance ) ; 
function commitUnmount ( current ) { if ( typeof onCommitUnmount === 'function' ) { onCommitUnmount ( current ) ; } switch ( current . tag ) { case ClassComponent : { safelyDetachRef ( current ) ; var instance = current . stateNode ; if ( typeof instance . componentWillUnmount === 'function' ) { safelyCallComponentWillUnmount ( current , instance ) ; } return ; } case HostComponent : { safelyDetachRef ( current ) ; return ; } case CallComponent : { commitNestedUnmounts ( current . stateNode ) ; return ; } case HostPortal : { 
function requestWork ( root , expirationTime ) { if ( nestedUpdateCount > NESTED_UPDATE_LIMIT ) { invariant ( false , 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.' ) ; } 
function shouldYield ( ) { if ( deadline === null ) { return false ; } if ( deadline . timeRemaining ( ) > timeHeuristicForUnitOfWork ) { return false ; } deadlineDidExpire = true ; return true ; } 
function batchedUpdates ( fn , a ) { var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return fn ( a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; if ( ! isBatchingUpdates && ! isRendering ) { performWork ( Sync , null ) ; } } } 
function unbatchedUpdates ( fn ) { if ( isBatchingUpdates && ! isUnbatchingUpdates ) { isUnbatchingUpdates = true ; try { return fn ( ) ; } finally { isUnbatchingUpdates = false ; } } return fn ( ) ; } 
function flushSync ( fn ) { var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return syncUpdates ( fn ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; performWork ( Sync , null ) ; } } 
function setValueForProperty ( node , name , value ) { var propertyInfo = getPropertyInfo ( name ) ; if ( propertyInfo && shouldSetAttribute ( name , value ) ) { var mutationMethod = propertyInfo . mutationMethod ; if ( mutationMethod ) { mutationMethod ( node , value ) ; } else if ( shouldIgnoreValue ( propertyInfo , value ) ) { deleteValueForProperty ( node , name ) ; return ; } else if ( propertyInfo . mustUseProperty ) { 
function deleteValueForProperty ( node , name ) { var propertyInfo = getPropertyInfo ( name ) ; if ( propertyInfo ) { var mutationMethod = propertyInfo . mutationMethod ; if ( mutationMethod ) { mutationMethod ( node , undefined ) ; } else if ( propertyInfo . mustUseProperty ) { var propName = propertyInfo . propertyName ; if ( propertyInfo . hasBooleanValue ) { node [ propName ] = false ; } else { node [ propName ] = '' ; } } else { node . removeAttribute ( propertyInfo . attributeName ) ; } } else { node . removeAttribute ( name ) ; } } 
function getHostProps ( element , props ) { var node = element ; var value = props . value ; var checked = props . checked ; var hostProps = _assign ( { 
function updateProperties$1 ( domElement , updatePayload , tag , lastRawProps , nextRawProps ) { var wasCustomComponentTag = isCustomComponent ( tag , lastRawProps ) ; var isCustomComponentTag = isCustomComponent ( tag , nextRawProps ) ; 
function PureComponent ( props , context , updater ) { 
function cloneElement ( element , config , children ) { var propName ; 
function validatePropTypes ( element ) { var componentClass = element . type ; if ( typeof componentClass !== 'function' ) { return ; } var name = componentClass . displayName || componentClass . name ; var propTypes = componentClass . propTypes ; if ( propTypes ) { currentlyValidatingElement = element ; checkPropTypes ( propTypes , element . props , 'prop' , name , getStackAddendum ) ; currentlyValidatingElement = null ; } if ( typeof componentClass . getDefaultProps === 'function' ) { warning ( componentClass . getDefaultProps . isReactClassApproved , 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.' ) ; } } 
function validateFragmentProps ( fragment ) { currentlyValidatingElement = fragment ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = Object . keys ( fragment . props ) [ Symbol . iterator ] ( ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var key = _step . value ; if ( ! VALID_FRAGMENT_PROPS . has ( key ) ) { warning ( false , 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s' , key , getStackAddendum ( ) ) ; break ; } } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator [ 'return' ] ) { _iterator [ 'return' ] ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } if ( fragment . ref !== null ) { warning ( false , 'Invalid attribute `ref` supplied to `React.Fragment`.%s' , getStackAddendum ( ) ) ; } currentlyValidatingElement = null ; } 
async function sympact ( code , options ) { if ( typeof code !== 'string' ) { throw new TypeError ( "The 'code' paramater must a string'" ) ; } if ( typeof options === 'undefined' ) { options = { } ; } if ( typeof options !== 'object' ) { throw new TypeError ( "The 'options' paramater must an object'" ) ; } const interval = options . interval || 125 ; const cwd = options . cwd || path . dirname ( caller ( ) ) ; if ( interval < 1 ) { throw new TypeError ( "The 'interval' paramater must be greater than 0'" ) ; } return new Promise ( ( resolve , reject ) => { const slave = new Worker ( code , cwd ) ; const probe = new Profiler ( slave . pid ( ) , interval ) ; slave . on ( 'ready' , async ( ) => { await probe . watch ( ) ; slave . run ( ) ; } ) ; slave . on ( 'after' , async ( start , end ) => { await probe . unwatch ( ) ; slave . kill ( ) ; resolve ( probe . report ( start , end ) ) ; } ) ; slave . on ( 'error' , async err => { await probe . unwatch ( ) ; slave . kill ( ) ; reject ( err ) ; } ) ; } ) ; } 
function BackoffStrategy ( options ) { options = options || { } ; if ( isDef ( options . initialDelay ) && options . initialDelay < 1 ) { throw new Error ( 'The initial timeout must be greater than 0.' ) ; } else if ( isDef ( options . maxDelay ) && options . maxDelay < 1 ) { throw new Error ( 'The maximal timeout must be greater than 0.' ) ; } this . initialDelay_ = options . initialDelay || 100 ; this . maxDelay_ = options . maxDelay || 10000 ; if ( this . maxDelay_ <= this . initialDelay_ ) { throw new Error ( 'The maximal backoff delay must be ' + 'greater than the initial backoff delay.' ) ; } if ( isDef ( options . randomisationFactor ) && ( options . randomisationFactor < 0 || options . randomisationFactor > 1 ) ) { throw new Error ( 'The randomisation factor must be between 0 and 1.' ) ; } this . randomisationFactor_ = options . randomisationFactor || 0 ; } 
function ExponentialBackoffStrategy ( options ) { BackoffStrategy . call ( this , options ) ; this . backoffDelay_ = 0 ; this . nextBackoffDelay_ = this . getInitialDelay ( ) ; this . factor_ = ExponentialBackoffStrategy . DEFAULT_FACTOR ; if ( options && options . factor !== undefined ) { precond . checkArgument ( options . factor > 1 , 'Exponential factor should be greater than 1 but got %s.' , options . factor ) ; this . factor_ = options . factor ; } } 
function Backoff ( backoffStrategy ) { events . EventEmitter . call ( this ) ; this . backoffStrategy_ = backoffStrategy ; this . maxNumberOfRetry_ = - 1 ; this . backoffNumber_ = 0 ; this . backoffDelay_ = 0 ; this . timeoutID_ = - 1 ; this . handlers = { backoff : this . onBackoff_ . bind ( this ) } ; } 
function FunctionCall ( fn , args , callback ) { events . EventEmitter . call ( this ) ; precond . checkIsFunction ( fn , 'Expected fn to be a function.' ) ; precond . checkIsArray ( args , 'Expected args to be an array.' ) ; precond . checkIsFunction ( callback , 'Expected callback to be a function.' ) ; this . function_ = fn ; this . arguments_ = args ; this . callback_ = callback ; this . lastResult_ = [ ] ; this . numRetries_ = 0 ; this . backoff_ = null ; this . strategy_ = null ; this . failAfter_ = - 1 ; this . retryPredicate_ = FunctionCall . DEFAULT_RETRY_PREDICATE_ ; this . state_ = FunctionCall . State_ . PENDING ; } 
function Channel ( connection , name , options ) { options || ( options = { } ) ; options . capped = true ; 
function Connection ( uri , options ) { var self = this ; options || ( options = { } ) ; options . autoReconnect != null || ( options . autoReconnect = true ) ; 
function addLoadEvent ( func ) { 'use strict' ; var oldonload = window . onload ; if ( typeof window . onload !== 'function' ) { window . onload = func ; } else { window . onload = function ( ) { oldonload ( ) ; func ( ) ; } ; } } 
function isTryBody ( path , { stackOffset = 0 } = { } ) { const node = path . getParentNode ( stackOffset - 1 ) const parent = path . getParentNode ( stackOffset ) const grandparent = path . getParentNode ( stackOffset + 1 ) const greatgrandparent = path . getParentNode ( stackOffset + 2 ) if ( parent . type === 'TryStatement' && node === parent . block ) { return true } if ( singleExpressionBlock ( parent ) && grandparent . type === 'TryStatement' && parent === grandparent . block ) { return true } if ( parent . type === 'ExpressionStatement' && singleExpressionBlock ( grandparent ) && greatgrandparent . type === 'TryStatement' && grandparent === greatgrandparent . block ) { return true } return false } 
function handleIfStatementComments ( text , precedingNode , enclosingNode , followingNode , comment ) { if ( ! enclosingNode || ! ( enclosingNode . type === 'IfStatement' || enclosingNode . type === 'ConditionalExpression' ) || ! followingNode ) { return false } if ( precedingNode === enclosingNode . consequent && followingNode === enclosingNode . alternate ) { 
function parse ( text ) { 
function Draggable ( target , options ) { if ( ! ( this instanceof Draggable ) ) { return new Draggable ( target , options ) ; } var that = this ; 
function q ( str ) { if ( Array . isArray ( str ) ) { return str . map ( q ) . reduce ( function ( prev , curr ) { return prev . concat ( curr ) ; } , [ ] ) ; } else if ( str instanceof HTMLElement ) { return [ str ] ; } else { return [ ] . slice . call ( document . querySelectorAll ( str ) ) ; } } 
function Functor ( name , args ) { let _name = name ; let _args = args ; let _argsCount = 0 ; let _variableHash = null ; if ( typeof _args === 'undefined' ) { _args = [ ] ; } else { _argsCount = args . length ; } this . getName = function getName ( ) { return _name ; } ; this . getId = function getId ( ) { return _name + '/' + _argsCount ; } ; this . evaluate = function evaluate ( ) { return this . toString ( ) ; } ; this . getGoal = function getGoal ( ) { return this ; } ; this . getArgumentCount = function getArgumentCount ( ) { return _argsCount ; } ; this . getVariables = function getVariables ( ) { return Object . keys ( this . getVariableHash ( ) ) ; } ; this . getVariableHash = function getVariableHash ( existingHash ) { let hash = existingHash ; if ( _variableHash !== null ) { if ( hash === undefined ) { return _variableHash ; } Object . keys ( _variableHash ) . forEach ( ( v ) => { hash [ v ] = true ; } ) ; return hash ; } if ( hash === undefined ) { hash = { } ; } let storedHash = { } ; _args . forEach ( ( arg ) => { arg . getVariableHash ( hash ) ; arg . getVariableHash ( storedHash ) ; } ) ; _variableHash = storedHash ; return hash ; } ; this . isGround = function isGround ( ) { let result = true ; for ( let i = 0 ; i < _argsCount ; i += 1 ) { let arg = _args [ i ] ; if ( ! arg . isGround ( ) ) { result = false ; break ; } } return result ; } ; this . getArguments = function getArguments ( ) { 
function ConjunctionMap ( ) { let _conjunctions = [ ] ; this . add = function add ( conjunction , value ) { if ( value === undefined ) { return ; } let map = new LiteralTreeMap ( ) ; conjunction . forEach ( ( conjunct ) => { map . add ( conjunct ) ; } ) ; _conjunctions . push ( [ map . size ( ) , map , value ] ) ; } ; this . get = function get ( conjunction ) { let result ; for ( let i = 0 ; i < _conjunctions . length ; i += 1 ) { let pair = _conjunctions [ i ] ; let containMismatch = false ; if ( conjunction . length !== pair [ 0 ] ) { continue ; } for ( let j = 0 ; j < conjunction . length ; j += 1 ) { let conjunct = conjunction [ j ] ; if ( ! pair [ 1 ] . contains ( conjunct ) ) { containMismatch = true ; break ; } } if ( ! containMismatch ) { result = pair [ 2 ] ; break ; } } return result ; } ; } 
function Profiler ( ) { let _values = { } ; this . reset = function reset ( key ) { _values [ key ] = 0 ; } ; this . increment = function increment ( key ) { if ( _values [ key ] === undefined || typeof _values [ key ] !== 'number' ) { return ; } _values [ key ] += 1 ; } ; this . increaseBy = function increaseBy ( key , value ) { if ( _values [ key ] === undefined || typeof _values [ key ] !== 'number' ) { return ; } _values [ key ] += value ; } ; this . set = function set ( key , value ) { _values [ key ] = value ; } ; this . add = function add ( key , value ) { if ( _values [ key ] === undefined || ! Array . isArray ( _values [ key ] ) ) { return ; } _values [ key ] . push ( value ) ; } ; this . get = function get ( key ) { return _values [ key ] ; } ; } 
function sortTimables ( conjunction , forTime ) { let earlyConjuncts = [ ] ; let laterConjuncts = [ ] ; let dependentTimeVariables = { } ; 
function AstNode ( type , token ) { let _type = type ; let _token = token ; let _children = [ ] ; this . getType = function getType ( ) { return _type ; } ; this . getToken = function getToken ( ) { return _token ; } ; this . getChildren = function getChildren ( ) { return _children ; } ; this . setToken = function setToken ( t ) { _token = t ; } ; this . isLeaf = function isLeaf ( ) { return _children . length === 0 ; } ; this . addChild = function addChild ( childNode ) { _children . push ( childNode ) ; } ; this . print = function print ( nArg ) { let n = nArg ; if ( ! n ) { n = 0 ; } console . log ( ' ' . repeat ( n ) + String ( _type ) + ( _token ? ( ': ' + _token . value ) : '' ) ) ; n += 1 ; _children . forEach ( ( child ) => { child . print ( n ) ; } ) ; } ; } 
function ( programArgs ) { let _programArgs = programArgs ; if ( programArgs === undefined ) { _programArgs = [ ] ; } 
function createProgramArgsUpdaterFunc ( programArgs ) { return ( program ) => { let programArgsFact = buildProgramArgsPredicate ( programArgs ) ; program . getFacts ( ) . add ( programArgsFact ) ; return Promise . resolve ( program ) ; } ; } 
function List ( head , tail ) { let _head = head ; let _tail = tail ; let _variableHash = null ; if ( tail === undefined ) { * Get the head of the list * @return {Array} Return the array representing the head of the list */ this . getHead = function getHead ( ) { return _head . concat ( ) ; } ; this . getTail = function getTail ( ) { return _tail ; } ; this . isGround = function isGround ( ) { if ( _tail !== null ) { return _tail . isGround ( ) ; } for ( let i = 0 ; i < _head . length ; i += 1 ) { if ( ! _head [ i ] . isGround ( ) ) { return false ; } } return true ; } ; this . getVariables = function getVariables ( ) { return Object . keys ( this . getVariableHash ( ) ) ; } ; this . getVariableHash = function getVariableHash ( existingHash ) { let hash = existingHash ; if ( _variableHash !== null ) { if ( hash === undefined ) { return _variableHash ; } Object . keys ( _variableHash ) . forEach ( ( v ) => { hash [ v ] = true ; } ) ; return hash ; } * Perform a substitution on this term. * @param {Object} theta The substitution theta * @return {List} Return the substituted list */ this . substitute = function substitute ( theta ) { let newHead = head . map ( ( element ) => { return element . substitute ( theta ) ; } ) ; let newTail = _tail ; if ( newTail instanceof List || newTail instanceof Variable ) { newTail = newTail . substitute ( theta ) ; } return new List ( newHead , newTail ) ; } ; this . flatten = function flatten ( ) { let result = [ ] ; if ( _head . length > 0 ) { result = result . concat ( _head ) ; if ( _tail instanceof List ) { result = result . concat ( _tail . flatten ( ) ) ; } } return result ; } ; this . isEmpty = function isEmpty ( ) { return _head . length === 0 && ( _tail instanceof List && _tail . isEmpty ( ) ) ; } ; this . toString = function toString ( ) { let result = '' ; result += '[' ; for ( let j = 0 ; j < _head . length ; j += 1 ) { result += _head [ j ] ; if ( j < _head . length - 1 ) { result += ', ' ; } } if ( _tail !== null && ( ! ( _tail instanceof List ) || ! _tail . isEmpty ( ) ) ) { result += '|' + _tail . toString ( ) ; } result += ']' ; return result ; } ; } 
function observeProcessor ( engine , program ) { let result = engine . query ( observeLiteral ) ; result . forEach ( ( r ) => { if ( r . theta . O === undefined || r . theta . ST === undefined || r . theta . ET === undefined ) { 
function Manager ( ) { let _events = { } ; this . addListener = function addListener ( event , listener ) { if ( _events [ event ] === undefined ) { _events [ event ] = [ ] ; } _events [ event ] . push ( listener ) ; } ; this . clearListeners = function clearListeners ( event ) { delete _events [ event ] ; } ; this . notify = function notify ( event , sender ) { if ( _events [ event ] === undefined ) { return Promise . resolve ( ) ; } _events [ event ] . forEach ( ( listener ) => { listener ( sender ) ; } ) ; return Promise . resolve ( ) ; } ; } 
function processCycleObservations ( ) { let activeObservations = new LiteralTreeMap ( ) ; if ( _observations [ _currentTime ] === undefined ) { 
function actionsSelector ( goalTrees ) { const recursiveActionsSelector = ( actionsSoFar , programSoFar , l ) => { if ( l >= goalTrees . length ) { let actions = new LiteralTreeMap ( ) ; actionsSoFar . forEach ( ( map ) => { map . forEach ( ( literal ) => { actions . add ( literal ) ; } ) ; } ) ; return actions ; } let goalTree = goalTrees [ l ] ; let resultSet = null ; goalTree . forEachCandidateActions ( _currentTime , ( candidateActions ) => { let cloneProgram = programSoFar . clone ( ) ; let cloneExecutedActions = cloneProgram . getExecutedActions ( ) ; candidateActions . forEach ( ( a ) => { cloneExecutedActions . add ( a ) ; } ) ; 
function performCycle ( ) { _currentTime += 1 ; let selectedAndExecutedActions = new LiteralTreeMap ( ) ; let executedObservations = new LiteralTreeMap ( ) ; 
function applyArgs ( func , thisObj , args ) { return func . apply ( thisObj , Array . prototype . slice . call ( args ) ) ; } 
function define ( ) { var thisFlow = function ( ) { applyArgs ( thisFlow . exec , thisFlow , arguments ) ; } thisFlow . blocks = arguments ; thisFlow . exec = function ( ) { 
function ( ) { if ( flowState . __frozen ) return ; if ( flowState . __timeoutId ) { clearTimeout ( flowState . __timeoutId ) ; delete flowState . __timeoutId ; } var blockIdx = flowState . __nextBlockIdx ++ ; var block = thisFlow . blocks [ blockIdx ] ; if ( block === undefined ) { return ; } else { applyArgs ( block , flowState , arguments ) ; } } 
function exec ( ) { var flow = typeof exports != 'undefined' ? exports : window . flow ; applyArgs ( flow . define , flow , arguments ) ( ) ; } 
function anyError ( results ) { var r , _i , _len ; for ( _i = 0 , _len = results . length ; _i < _len ; _i ++ ) { r = results [ _i ] ; if ( r [ 0 ] ) { return r [ 0 ] ; } } return null ; } 
function padStart ( str , length , padChar ) { if ( str . length >= length ) { return str ; } else { return padChar . repeat ( length - str . length ) + str ; } } 
function SM2Curve ( params ) { if ( ! ( this instanceof SM2Curve ) ) { return new SM2Curve ( params ) ; } elliptic . curve . short . call ( this , params ) ; } 
function _sm2Point ( x , y , parity ) { if ( x == null ) { return SM2 . point ( ) ; } var pt ; if ( y != null ) { pt = SM2 . point ( x , y ) ; if ( ! SM2 . validate ( pt ) ) { throw 'point is not on curve' ; } } else { var px = new BN ( x , 16 ) . toRed ( SM2 . red ) ; var py = px . redSqr ( ) . redMul ( px ) ; py = py . redIAdd ( px . redMul ( SM2 . a ) ) . redIAdd ( SM2 . b ) . redSqrt ( ) ; if ( ( parity === 'odd' ) != py . fromRed ( ) . isOdd ( ) ) { py = py . redNeg ( ) ; } pt = SM2 . point ( px , py ) ; } return pt ; } 
function SM2KeyPair ( pub , pri ) { if ( ! ( this instanceof SM2KeyPair ) ) { return new SM2KeyPair ( pub , pri ) ; } this . curve = SM2 ; 
function ( ) { this . _default_baud_rate = 57600 ; this . _baud_rate = 57600 ; this . _path = '' ; this . _devices = { } ; this . _port = null ; this . _telegram_buffer = null ; this . _gateway = null ; mEventEmitter . call ( this ) ; } 
function gulpStaticI18n ( options ) { return through . obj ( function ( target , encoding , cb ) { var stream = this ; var build = new StaticI18n ( target , options , stream ) ; build . translate ( cb ) ; } ) ; } 
function ( obj , type , fn , scope ) { scope = scope || obj ; var wrappedFn = function ( e ) { fn . call ( scope , e ) ; } ; obj . addEventListener ( type , wrappedFn , false ) ; cache . push ( [ obj , type , fn , wrappedFn ] ) ; } 
function ( obj , type , fn ) { var wrappedFn , item , len = cache . length , i ; for ( i = 0 ; i < len ; i ++ ) { item = cache [ i ] ; if ( item [ 0 ] === obj && item [ 1 ] === type && item [ 2 ] === fn ) { wrappedFn = item [ 3 ] ; if ( wrappedFn ) { obj . removeEventListener ( type , wrappedFn , false ) ; cache = cache . slice ( i ) ; return true ; } } } } 
function ( obj , type , fn , scope ) { scope = scope || obj ; var wrappedFn = function ( ) { var e = window . event ; e . target = e . target || e . srcElement ; e . preventDefault = function ( ) { e . returnValue = false ; } ; fn . call ( scope , e ) ; } ; obj . attachEvent ( 'on' + type , wrappedFn ) ; cache . push ( [ obj , type , fn , wrappedFn ] ) ; } 
function ( obj , type , fn ) { var wrappedFn , item , len = cache . length , i ; for ( i = 0 ; i < len ; i ++ ) { item = cache [ i ] ; if ( item [ 0 ] === obj && item [ 1 ] === type && item [ 2 ] === fn ) { wrappedFn = item [ 3 ] ; if ( wrappedFn ) { obj . detachEvent ( 'on' + type , wrappedFn ) ; cache = cache . slice ( i ) ; return true ; } } } } 
function View ( model ) { var wrapper ; this . el = wrapper = document . createElement ( 'div' ) ; this . model = model ; this . isShowing = false ; 
function Product ( data ) { data . quantity = parser . quantity ( data . quantity ) ; data . amount = parser . amount ( data . amount ) ; data . href = parser . href ( data . href ) ; this . _data = data ; this . _options = null ; this . _discount = null ; this . _amount = null ; this . _total = null ; Pubsub . call ( this ) ; } 
function Cart ( name , duration ) { var data , items , settings , len , i ; this . _items = [ ] ; this . _settings = { bn : constants . BN } ; Pubsub . call ( this ) ; Storage . call ( this , name , duration ) ; if ( ( data = this . load ( ) ) ) { items = data . items ; settings = data . settings ; if ( settings ) { this . _settings = settings ; } if ( items ) { for ( i = 0 , len = items . length ; i < len ; i ++ ) { this . add ( items [ i ] ) ; } } } } 
function ( opts ) { 
function ( opts ) { var wrapper = path . join ( ROOT , 'gradlew' ) ; var args = this . getArgs ( opts . buildType == 'debug' ? 'debug' : 'release' , opts ) ; return Q ( ) . then ( function ( ) { console . log ( 'Running: ' + wrapper + ' ' + args . join ( ' ' ) ) ; return spawn ( wrapper , args ) ; } ) ; } 
function onRejected ( error ) { attemts_left -= 1 ; if ( attemts_left < 1 ) { throw error ; } console . log ( "A retried call failed. Retrying " + attemts_left + " more time(s)." ) ; 
function collectDependencies ( bowerJson , dependencies ) { if ( bowerJson != null && bowerJson != undefined ) { if ( bowerJson . hasOwnProperty ( "dependencies" ) ) { var dependenciesJson = bowerJson . dependencies ; var dependencisKeys = Object . keys ( dependenciesJson ) ; var key ; for ( key in dependencisKeys ) { var dependecyJson = dependenciesJson [ dependencisKeys [ key ] ] ; var dependency = createDependency ( dependecyJson ) ; if ( dependency != null ) { dependencies . push ( dependency ) ; collectDependencies ( dependecyJson , dependencies ) ; } } } } } 
function createTree ( entries , callback ) { if ( ! callback ) return createTree . bind ( repo , entries ) ; var toDelete = entries . base && entries . filter ( function ( entry ) { return ! entry . mode ; } ) . map ( function ( entry ) { return entry . path ; } ) ; var toCreate = entries . filter ( function ( entry ) { return bodec . isBinary ( entry . content ) ; } ) ; if ( ! toCreate . length ) return next ( ) ; var done = false ; var left = entries . length ; toCreate . forEach ( function ( entry ) { repo . saveAs ( "blob" , entry . content , function ( err , hash ) { if ( done ) return ; if ( err ) { done = true ; return callback ( err ) ; } delete entry . content ; entry . hash = hash ; left -- ; if ( ! left ) next ( ) ; } ) ; } ) ; function next ( err ) { if ( err ) return callback ( err ) ; if ( toDelete && toDelete . length ) { return slowUpdateTree ( entries , toDelete , callback ) ; } return fastUpdateTree ( entries , callback ) ; } } 
function slowUpdateTree ( entries , toDelete , callback ) { callback = singleCall ( callback ) ; var root = entries . base ; var left = 0 ; 
function fixDate ( type , value , hash ) { if ( type !== "commit" && type !== "tag" ) return ; 
function toGlobalCoordinates ( svgdoc : any , elem : any , x : number , y : number ) { var offset = svgdoc . getBoundingClientRect ( ) ; var matrix = elem . getScreenCTM ( ) ; return { x : matrix . a * x + matrix . c * y + matrix . e - offset . left , y : matrix . b * x + matrix . d * y + matrix . f - offset . top } ; } 
function getAngleForPoint ( x : number , y : number ) { if ( x == 0 && y == 0 ) return 0 ; const angle = Math . atan ( x / y ) ; let angleDeg = angle * 180 / Math . PI ; 
function transformBoundingClientRectToDocument ( box ) { var t ; const scrollX = ( ( ( t = document . documentElement ) || ( t = document . body . parentNode ) ) && typeof t . scrollLeft == "number" ? t : document . body ) . scrollLeft ; const scrollY = ( ( ( t = document . documentElement ) || ( t = document . body . parentNode ) ) && typeof t . scrollTop == "number" ? t : document . body ) . scrollTop ; 
function ( position , handleWidth ) { if ( position === "stickToSides" ) { _naked_bar_deltas = { toEndWidth : handleWidth , toBeginLeft : 0 , toBeginWidth : handleWidth } ; } else if ( position === "middle" ) { 
function ( nextLeftGripPositionPx , nextRightGripPositionPx ) { var $this = this ; var draggableAreaLengthPx = _methods . getSliderWidthPx . call ( $this ) - $this . data ( 'left_grip_width' ) ; 
function ( ) { var $this = this , settings = $this . data ( 'settings' ) , $leftGrip = $this . find ( settings . left_grip_selector ) ; 
function ( ) { var $this = this , settings = $this . data ( 'settings' ) ; if ( $this . data ( 'has_right_grip' ) ) { return _methods . getGripPositionPx . call ( $this , $this . find ( settings . right_grip_selector ) ) ; } 
function ( array , searchElement , getElementFunc , compareFunc ) { var minIndex = 0 ; var maxIndex = array . length - 1 ; var currentIndex ; var currentElement ; while ( minIndex <= maxIndex ) { currentIndex = ( minIndex + maxIndex ) / 2 | 0 ; currentElement = getElementFunc ( array , currentIndex ) ; 
function ( ) { var $this = this , lowerLimit = $this . data ( 'lower-limit' ) , upperLimit = $this . data ( 'upper-limit' ) , haveLimits = false ; if ( typeof lowerLimit !== 'undefined' && typeof upperLimit !== 'undefined' ) { haveLimits = true ; } return haveLimits ; } 
function ( ) { var $this = this , settings = $this . data ( 'settings' ) ; 
function ( cur_min , cur_max ) { var $this = this ; 
function ( leftPx , rightPx ) { var $this = this ; 
function ( leftPx , rightPx ) { var $this = this ; var settings = $this . data ( 'settings' ) ; var left_grip_selector = settings . left_grip_selector , right_grip_selector = settings . right_grip_selector , value_bar_selector = settings . value_bar_selector ; var handleWidth = $this . data ( 'left_grip_width' ) ; 
function ( search , array , currentIdx ) { 
function ( isLeftGrip ) { var $this = this , current_min_value = methods . get_current_min_value . call ( $this ) , current_max_value = methods . get_current_max_value . call ( $this ) , didValuesChange = false ; 
function ( cause , prevMin , prevMax ) { var $this = this ; var force = false ; if ( cause === 'init' || cause === 'refresh' ) { force = true ; } var curMin = methods . get_current_min_value . call ( $this ) , curMax = methods . get_current_max_value . call ( $this ) ; if ( ! force ) { prevMin = methods . round_value_according_to_rounding . call ( $this , prevMin ) ; prevMax = methods . round_value_according_to_rounding . call ( $this , prevMax ) ; } if ( force || curMin !== prevMin || curMax !== prevMax ) { _methods . notify_changed_explicit . call ( $this , cause , prevMin , prevMax , curMin , curMax ) ; force = 1 ; } return force ; } 
function ( val , n ) { var $this = this ; var rangeMin = $this . data ( 'range_min' ) ; var rangeMax = $this . data ( 'range_max' ) ; if ( val <= rangeMin ) { return 0 ; } if ( val >= rangeMax ) { return n ; } return Math . floor ( ( n * val - n * rangeMin ) / ( rangeMax - rangeMin ) ) ; } 
function ( val , max ) { var $this = this ; var rangeMin = $this . data ( 'range_min' ) ; var rangeMax = $this . data ( 'range_max' ) ; if ( val <= 0 ) { return rangeMin ; } if ( val >= max ) { return rangeMax ; } 
function ( ) { var $this = this ; 
function ( ) { var $this = this ; 
function ( min , max ) { var $this = this ; var prev_min = $this . data ( 'cur_min' ) , prev_max = $this . data ( 'cur_max' ) ; if ( min > max ) { _methods . set_position_from_val . call ( $this , max , min ) ; } else { _methods . set_position_from_val . call ( $this , min , max ) ; } 
function ( histogram ) { var $this = this ; $this . data ( 'last_step_histogram' , histogram ) ; if ( typeof histogram === 'undefined' ) { $ . error ( 'got an undefined histogram in set_step_histogram' ) ; _methods . unset_step_histogram . call ( $this ) ; } var sliderWidthPx = _methods . getSliderWidthPx . call ( $this ) - $this . data ( 'left_grip_width' ) , nbuckets = histogram . length ; if ( sliderWidthPx <= 0 ) { 
function ( rangeMin , rangeMax ) { var $this = this ; var settings = $this . data ( 'settings' ) ; if ( typeof settings . highlight === "undefined" ) { $ . error ( 'you cannot call highlight_range if you haven\' specified the "highlight" parameter in construction!' ) ; } // avoid empty string if ( ! rangeMin ) { rangeMin = 0 ; } if ( ! rangeMax ) { rangeMax = 0 ; } // we need to map rangeMin and rangeMax into pixels. var leftPx = methods . value_to_px . call ( $this , rangeMin ) , rightPx = methods . value_to_px . call ( $this , rangeMax ) , barWidth = rightPx - leftPx + $this . data ( 'left_grip_width' ) ; // set position var $highlightPanel = $this . find ( settings . highlight . panel_selector ) ; $highlightPanel . css ( 'left' , leftPx + "px" ) ; $highlightPanel . css ( 'width' , barWidth + "px" ) ; // keep the latest highlighted range, because if set_range is called // we must be able to update the highlighting. $this . data ( 'highlightedRangeMin' , rangeMin ) ; $this . data ( 'highlightedRangeMax' , rangeMax ) ; 
function ( rounding ) { var $this = this ; if ( typeof rounding === 'string' && rounding . indexOf ( '{' ) > - 1 ) { 
function ( v ) { var $this = this ; var rounding = _methods . get_rounding_for_value . call ( $this , v ) ; if ( rounding > 0 ) { 
function ( value ) { var $this = this , value_to_pixel_mapping_func = $this . data ( 'value_to_pixel_mapping' ) ; 
function append ( fieldName , props , appendToken ) { var params = '' ; var notFirst = false ; fieldName += '.' ; for ( var key in props ) { var obj = props [ key ] ; if ( notFirst ) params += appendToken ; else notFirst = true ; params += fieldName + key + '={' + key + '}' ; } return params ; } 
function remove ( fieldName , props ) { var removes = '' , notFirst = false , i = props . length ; fieldName += '.' ; while ( i -- ) { if ( notFirst ) { removes += ',' ; } else { notFirst = true ; } removes += fieldName + props [ i ] ; } return removes ; } 
function whereSetProperties ( fieldName , oldProps , newProps ) { var prefix = 'xQ_' , whereClause = '' , setClause = '' , notFirst = false , props = { } , i = 0 , obj ; fieldName += '.' ; 
function labels ( array ) { var res = '' ; if ( typeof array === 'string' ) { return ':' + array ; } for ( var i = 0 ; i < array . length ; i ++ ) { res += ':' + array [ i ] ; } return res ; } 
function ( node_id , node_data , callback ) { var that = this ; request . put ( that . url + '/db/data/node/' + node_id + '/properties' ) . set ( this . header ) . send ( that . stringifyValueObjects ( that . replaceNullWithString ( node_data ) ) ) . end ( function ( result ) { switch ( result . statusCode ) { case 204 : callback ( null , true ) ; break ; case 404 : callback ( null , false ) ; break ; default : callback ( new Error ( 'HTTP Error ' + result . statusCode + ' when updating a Node.' ) , null ) ; } } ) ; } 
function ( label , property_key , callback ) { var that = this ; var val = new Validator ( ) ; val . label ( label ) . property ( property_key ) ; if ( val . hasErrors ) { return callback ( val . error ( ) , null ) ; } request . post ( that . url + '/db/data/schema/constraint/' + label + '/uniqueness' ) . set ( this . header ) . send ( { 'property_keys' : [ property_key ] } ) . end ( function ( result ) { switch ( result . statusCode ) { case 200 : callback ( null , result . body ) ; break ; case 409 : callback ( null , false ) ; 
function ( node_id , options , callback ) { var that = this ; if ( typeof options === 'function' ) { callback = options ; } var url = that . url + '/db/data/node/' + node_id + '/relationships/' ; 
function Client ( options ) { if ( ! ( this instanceof Client ) ) { return new Client ( options ) ; } const self = this ; this . setOption = function ( option , value ) { self . options [ option ] = value ; } ; this . setPosition = function ( latitude , longitude , accuracy , altitude ) { if ( typeof latitude === 'object' ) { const pos = latitude ; latitude = pos . latitude ; longitude = pos . longitude ; accuracy = pos . accuracy ; altitude = pos . altitude ; } self . playerLatitude = latitude ; self . playerLongitude = longitude ; self . playerLocationAccuracy = accuracy || 0 ; self . playerAltitude = altitude || 0 ; } ; this . init = function ( downloadSettings ) { * Sets batch mode. All further API requests will be held and executed in one RPC call when * {@link #batchCall} is called. * @return {Client} this */ this . batchStart = function ( ) { if ( ! self . batchRequests ) { self . batchRequests = [ ] ; } return self ; } ; this . batchClear = function ( ) { delete self . batchRequests ; } ; this . batchCall = function ( ) { var p = self . callRPC ( self . batchRequests || [ ] ) ; self . batchClear ( ) ; return p ; } ; this . getSignatureRateInfo = function ( ) { return self . signatureBuilder . rateInfos ; } ; this . getPlayer = function ( country , language , timezone ) { return self . callOrChain ( { type : RequestType . GET_PLAYER , message : new RequestMessages . GetPlayerMessage ( { player_locale : { country : country , language : language , timezone : timezone } } ) , responseType : Responses . GetPlayerResponse } ) ; } ; this . getInventory = function ( lastTimestamp ) { return self . callOrChain ( { type : RequestType . GET_INVENTORY , message : new RequestMessages . GetInventoryMessage ( { last_timestamp_ms : lastTimestamp } ) , responseType : Responses . GetInventoryResponse } ) ; } ; this . downloadSettings = function ( hash ) { return self . callOrChain ( { type : RequestType . DOWNLOAD_SETTINGS , message : new RequestMessages . DownloadSettingsMessage ( { hash : hash } ) , responseType : Responses . DownloadSettingsResponse } ) ; } ; this . downloadItemTemplates = function ( paginate , pageOffset , pageTimestamp ) { return self . callOrChain ( { type : RequestType . DOWNLOAD_ITEM_TEMPLATES , message : new RequestMessages . DownloadItemTemplatesMessage ( { paginate : paginate , page_offset : pageOffset , page_timestamp : pageTimestamp } ) , responseType : Responses . DownloadItemTemplatesResponse } ) ; } ; this . downloadRemoteConfigVersion = function ( platform , deviceManufacturer , deviceModel , locale , appVersion ) { return self . callOrChain ( { type : RequestType . DOWNLOAD_REMOTE_CONFIG_VERSION , message : new RequestMessages . DownloadRemoteConfigVersionMessage ( { platform : platform , device_manufacturer : deviceManufacturer , device_model : deviceModel , locale : locale , app_version : appVersion } ) , responseType : Responses . DownloadRemoteConfigVersionResponse } ) ; } ; this . registerBackgroundDevice = function ( deviceType , deviceID ) { return self . callOrChain ( { type : RequestType . REGISTER_BACKGROUND_DEVICE , message : new RequestMessages . RegisterBackgroundDeviceMessage ( { device_type : deviceType , device_id : deviceID } ) , responseType : Responses . RegisterBackgroundDeviceResponse } ) ; } ; this . fortSearch = function ( fortID , fortLatitude , fortLongitude ) { return self . callOrChain ( { type : RequestType . FORT_SEARCH , message : new RequestMessages . FortSearchMessage ( { fort_id : fortID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude , fort_latitude : fortLatitude , fort_longitude : fortLongitude } ) , responseType : Responses . FortSearchResponse } ) ; } ; this . encounter = function ( encounterID , spawnPointID ) { return self . callOrChain ( { type : RequestType . ENCOUNTER , message : new RequestMessages . EncounterMessage ( { encounter_id : encounterID , spawn_point_id : spawnPointID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . EncounterResponse } ) ; } ; this . catchPokemon = function ( encounterID , pokeballItemID , normalizedReticleSize , spawnPointID , hitPokemon , spinModifier , normalizedHitPosition ) { return self . callOrChain ( { type : RequestType . CATCH_POKEMON , message : new RequestMessages . CatchPokemonMessage ( { encounter_id : encounterID , pokeball : pokeballItemID , normalized_reticle_size : normalizedReticleSize , spawn_point_id : spawnPointID , hit_pokemon : hitPokemon , spin_modifier : spinModifier , normalized_hit_position : normalizedHitPosition } ) , responseType : Responses . CatchPokemonResponse } ) ; } ; this . fortDetails = function ( fortID , fortLatitude , fortLongitude ) { return self . callOrChain ( { type : RequestType . FORT_DETAILS , message : new RequestMessages . FortDetailsMessage ( { fort_id : fortID , latitude : fortLatitude , longitude : fortLongitude } ) , responseType : Responses . FortDetailsResponse } ) ; } ; this . getMapObjects = function ( cellIDs , sinceTimestamps ) { return self . callOrChain ( { type : RequestType . GET_MAP_OBJECTS , message : new RequestMessages . GetMapObjectsMessage ( { cell_id : cellIDs , since_timestamp_ms : sinceTimestamps , latitude : self . playerLatitude , longitude : self . playerLongitude } ) , responseType : Responses . GetMapObjectsResponse } ) ; } ; this . fortDeployPokemon = function ( fortID , pokemonID ) { return self . callOrChain ( { type : RequestType . FORT_DEPLOY_POKEMON , message : new RequestMessages . FortDeployPokemonMessage ( { fort_id : fortID , pokemon_id : pokemonID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . FortDeployPokemonResponse } ) ; } ; this . fortRecallPokemon = function ( fortID , pokemonID ) { return self . callOrChain ( { type : RequestType . FORT_RECALL_POKEMON , message : new RequestMessages . FortRecallPokemonMessage ( { fort_id : fortID , pokemon_id : pokemonID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . FortRecallPokemonResponse } ) ; } ; this . releasePokemon = function ( pokemonIDs ) { if ( ! Array . isArray ( pokemonIDs ) ) pokemonIDs = [ pokemonIDs ] ; return self . callOrChain ( { type : RequestType . RELEASE_POKEMON , message : new RequestMessages . ReleasePokemonMessage ( { pokemon_id : pokemonIDs . length === 1 ? pokemonIDs [ 0 ] : undefined , pokemon_ids : pokemonIDs . length > 1 ? pokemonIDs : undefined } ) , responseType : Responses . ReleasePokemonResponse } ) ; } ; this . useItemPotion = function ( itemID , pokemonID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_POTION , message : new RequestMessages . UseItemPotionMessage ( { item_id : itemID , pokemon_id : pokemonID } ) , responseType : Responses . UseItemPotionResponse } ) ; } ; this . useItemCapture = function ( itemID , encounterID , spawnPointID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_CAPTURE , message : new RequestMessages . UseItemCaptureMessage ( { item_id : itemID , encounter_id : encounterID , spawn_point_id : spawnPointID } ) , responseType : Responses . UseItemCaptureResponse } ) ; } ; this . useItemRevive = function ( itemID , pokemonID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_REVIVE , message : new RequestMessages . UseItemReviveMessage ( { item_id : itemID , pokemon_id : pokemonID } ) , responseType : Responses . UseItemReviveResponse } ) ; } ; this . getPlayerProfile = function ( playerName ) { return self . callOrChain ( { type : RequestType . GET_PLAYER_PROFILE , message : new RequestMessages . GetPlayerProfileMessage ( { player_name : playerName } ) , responseType : Responses . GetPlayerProfileResponse } ) ; } ; this . evolvePokemon = function ( pokemonID , evolutionRequirementItemID ) { return self . callOrChain ( { type : RequestType . EVOLVE_POKEMON , message : new RequestMessages . EvolvePokemonMessage ( { pokemon_id : pokemonID , evolution_item_requirement : evolutionRequirementItemID } ) , responseType : Responses . EvolvePokemonResponse } ) ; } ; this . getHatchedEggs = function ( ) { return self . callOrChain ( { type : RequestType . GET_HATCHED_EGGS , responseType : Responses . GetHatchedEggsResponse } ) ; } ; this . encounterTutorialComplete = function ( pokemonID ) { return self . callOrChain ( { type : RequestType . ENCOUNTER_TUTORIAL_COMPLETE , message : new RequestMessages . EncounterTutorialCompleteMessage ( { pokemon_id : pokemonID } ) , responseType : Responses . EncounterTutorialCompleteResponse } ) ; } ; this . levelUpRewards = function ( level ) { return self . callOrChain ( { type : RequestType . LEVEL_UP_REWARDS , message : new RequestMessages . LevelUpRewardsMessage ( { level : level } ) , responseType : Responses . LevelUpRewardsResponse } ) ; } ; this . checkAwardedBadges = function ( ) { return self . callOrChain ( { type : RequestType . CHECK_AWARDED_BADGES , responseType : Responses . CheckAwardedBadgesResponse } ) ; } ; this . useItemGym = function ( itemID , gymID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_GYM , message : new RequestMessages . UseItemGymMessage ( { item_id : itemID , gym_id : gymID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . UseItemGymResponse } ) ; } ; this . getGymDetails = function ( gymID , gymLatitude , gymLongitude , clientVersion ) { return self . callOrChain ( { type : RequestType . GET_GYM_DETAILS , message : new RequestMessages . GetGymDetailsMessage ( { gym_id : gymID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude , gym_latitude : gymLatitude , gym_longitude : gymLongitude , client_version : clientVersion } ) , responseType : Responses . GetGymDetailsResponse } ) ; } ; this . startGymBattle = function ( gymID , attackingPokemonIDs , defendingPokemonID ) { return self . callOrChain ( { type : RequestType . START_GYM_BATTLE , message : new RequestMessages . StartGymBattleMessage ( { gym_id : gymID , attacking_pokemon_ids : attackingPokemonIDs , defending_pokemon_id : defendingPokemonID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . StartGymBattleResponse } ) ; } ; this . attackGym = function ( gymID , battleID , attackActions , lastRetrievedAction ) { return self . callOrChain ( { type : RequestType . ATTACK_GYM , message : new RequestMessages . AttackGymMessage ( { gym_id : gymID , battle_id : battleID , attack_actions : attackActions , last_retrieved_action : lastRetrievedAction , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . AttackGymResponse } ) ; } ; this . recycleInventoryItem = function ( itemID , count ) { return self . callOrChain ( { type : RequestType . RECYCLE_INVENTORY_ITEM , message : new RequestMessages . RecycleInventoryItemMessage ( { item_id : itemID , count : count } ) , responseType : Responses . RecycleInventoryItemResponse } ) ; } ; this . collectDailyBonus = function ( ) { return self . callOrChain ( { type : RequestType . COLLECT_DAILY_BONUS , responseType : Responses . CollectDailyBonusResponse } ) ; } ; this . useItemXPBoost = function ( itemID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_XP_BOOST , message : new RequestMessages . UseItemXpBoostMessage ( { item_id : itemID } ) , responseType : Responses . UseItemXpBoostResponse } ) ; } ; this . useItemEggIncubator = function ( itemID , pokemonID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_EGG_INCUBATOR , message : new RequestMessages . UseItemEggIncubatorMessage ( { item_id : itemID , pokemon_id : pokemonID } ) , responseType : Responses . UseItemEggIncubatorResponse } ) ; } ; this . useIncense = function ( itemID ) { return self . callOrChain ( { type : RequestType . USE_INCENSE , message : new RequestMessages . UseIncenseMessage ( { incense_type : itemID } ) , responseType : Responses . UseIncenseResponse } ) ; } ; this . getIncensePokemon = function ( ) { return self . callOrChain ( { type : RequestType . GET_INCENSE_POKEMON , message : new RequestMessages . GetIncensePokemonMessage ( { player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . GetIncensePokmeonResponse } ) ; } ; this . incenseEncounter = function ( encounterID , encounterLocation ) { return self . callOrChain ( { type : RequestType . INCENSE_ENCOUNTER , message : new RequestMessages . IncenseEncounterMessage ( { encounter_id : encounterID , encounter_location : encounterLocation } ) , responseType : Responses . IncenseEncounterResponse } ) ; } ; this . addFortModifier = function ( modifierItemID , fortID ) { return self . callOrChain ( { type : RequestType . ADD_FORT_MODIFIER , message : new RequestMessages . AddFortModifierMessage ( { modifier_type : modifierItemID , fort_id : fortID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) } ) ; } ; this . diskEncounter = function ( encounterID , fortID ) { return self . callOrChain ( { type : RequestType . DISK_ENCOUNTER , message : new RequestMessages . DiskEncounterMessage ( { encounter_id : encounterID , fort_id : fortID , player_latitude : self . playerLatitude , player_longitude : self . playerLongitude } ) , responseType : Responses . DiskEncounterResponse } ) ; } ; this . collectDailyDefenderBonus = function ( ) { return self . callOrChain ( { type : RequestType . COLLECT_DAILY_DEFENDER_BONUS , responseType : Responses . CollectDailyDefenderBonusResponse } ) ; } ; this . upgradePokemon = function ( pokemonID ) { return self . callOrChain ( { type : RequestType . UPGRADE_POKEMON , message : new RequestMessages . UpgradePokemonMessage ( { pokemon_id : pokemonID } ) , responseType : Responses . UpgradePokemonResponse } ) ; } ; this . setFavoritePokemon = function ( pokemonID , isFavorite ) { return self . callOrChain ( { type : RequestType . SET_FAVORITE_POKEMON , message : new RequestMessages . SetFavoritePokemonMessage ( { pokemon_id : pokemonID , is_favorite : isFavorite } ) , responseType : Responses . SetFavoritePokemonResponse } ) ; } ; this . nicknamePokemon = function ( pokemonID , nickname ) { return self . callOrChain ( { type : RequestType . NICKNAME_POKEMON , message : new RequestMessages . NicknamePokemonMessage ( { pokemon_id : pokemonID , nickname : nickname } ) , responseType : Responses . NicknamePokemonResponse } ) ; } ; this . equipBadge = function ( badgeType ) { return self . callOrChain ( { type : RequestType . EQUIP_BADGE , message : new RequestMessages . EquipBadgeMessage ( { badge_type : badgeType } ) , responseType : Responses . EquipBadgeResponse } ) ; } ; this . setContactSettings = function ( sendMarketingEmails , sendPushNotifications ) { return self . callOrChain ( { type : RequestType . SET_CONTACT_SETTINGS , message : new RequestMessages . SetContactSettingsMessage ( { contact_settings : { send_marketing_emails : sendMarketingEmails , send_push_notifications : sendPushNotifications } } ) , responseType : Responses . SetContactSettingsResponse } ) ; } ; this . setBuddyPokemon = function ( pokemonID ) { return self . callOrChain ( { type : RequestType . SET_BUDDY_POKEMON , message : new RequestMessages . SetBuddyPokemonMessage ( { pokemon_id : pokemonID } ) , responseType : Responses . SetBuddyPokemonResponse } ) ; } ; this . getBuddyWalked = function ( ) { return self . callOrChain ( { type : RequestType . GET_BUDDY_WALKED , responseType : Responses . GetBuddyWalkedResponse } ) ; } ; this . useItemEncounter = function ( itemID , encounterID , spawnPointGUID ) { return self . callOrChain ( { type : RequestType . USE_ITEM_ENCOUNTER , message : new RequestMessages . UseItemEncounterMessage ( { item : itemID , encounter_id : encounterID , spawn_point_guid : spawnPointGUID } ) , responseType : Responses . UseItemEncounterResponse } ) ; } ; this . getAssetDigest = function ( platform , deviceManufacturer , deviceModel , locale , appVersion ) { return self . callOrChain ( { type : RequestType . GET_ASSET_DIGEST , message : new RequestMessages . GetAssetDigestMessage ( { platform : platform , device_manufacturer : deviceManufacturer , device_model : deviceModel , locale : locale , app_version : appVersion } ) , responseType : Responses . GetAssetDigestResponse } ) ; } ; this . getDownloadURLs = function ( assetIDs ) { return self . callOrChain ( { type : RequestType . GET_DOWNLOAD_URLS , message : new RequestMessages . GetDownloadUrlsMessage ( { asset_id : assetIDs } ) , responseType : Responses . GetDownloadUrlsResponse } ) ; } ; this . claimCodename = function ( codename ) { return self . callOrChain ( { type : RequestType . CLAIM_CODENAME , message : new RequestMessages . ClaimCodenameMessage ( { codename : codename } ) , responseType : Responses . ClaimCodenameResponse } ) ; } ; this . setAvatar = function ( playerAvatar ) { return self . callOrChain ( { type : RequestType . SET_AVATAR , message : new RequestMessages . SetAvatarMessage ( { player_avatar : playerAvatar } ) , responseType : Responses . SetAvatarResponse } ) ; } ; this . setPlayerTeam = function ( teamColor ) { return self . callOrChain ( { type : RequestType . SET_PLAYER_TEAM , message : new RequestMessages . SetPlayerTeamMessage ( { team : teamColor } ) , responseType : Responses . SetPlayerTeamResponse } ) ; } ; this . markTutorialComplete = function ( tutorialsCompleted , sendMarketingEmails , sendPushNotifications ) { return self . callOrChain ( { type : RequestType . MARK_TUTORIAL_COMPLETE , message : new RequestMessages . MarkTutorialCompleteMessage ( { tutorials_completed : tutorialsCompleted , send_marketing_emails : sendMarketingEmails , send_push_notifications : sendPushNotifications } ) , responseType : Responses . MarkTutorialCompleteResponse } ) ; } ; this . checkChallenge = function ( isDebugRequest ) { return self . callOrChain ( { type : RequestType . CHECK_CHALLENGE , message : new RequestMessages . CheckChallengeMessage ( { debug_request : isDebugRequest } ) , responseType : Responses . CheckChallengeResponse } ) ; } ; this . verifyChallenge = function ( token ) { return self . callOrChain ( { type : RequestType . VERIFY_CHALLENGE , message : new RequestMessages . VerifyChallengeMessage ( { token : token } ) , responseType : Responses . VerifyChallengeResponse } ) ; } ; this . echo = function ( ) { return self . callOrChain ( { type : RequestType . ECHO , responseType : Responses . EchoResponse } ) ; } ; this . sfidaActionLog = function ( ) { return self . callOrChain ( { type : RequestType . SFIDA_ACTION_LOG , responseType : Responses . SfidaActionLogResponse } ) ; } ; this . listAvatarCustomizations = function ( avatarType , slots , filters , start , limit ) { return self . callOrChain ( { type : RequestType . LIST_AVATAR_CUSTOMIZATIONS , message : new RequestMessages . ListAvatarCustomizationsMessage ( { avatar_type : avatarType , slot : slots , filters : filters , start : start , limit : limit } ) , responseType : Responses . ListAvatarCustomizationsResponse } ) ; } ; this . setAvatarItemAsViewed = function ( avatarTemplateIDs ) { return self . callOrChain ( { type : RequestType . SET_AVATAR_ITEM_AS_VIEWED , message : new RequestMessages . SetAvatarItemAsViewedMessage ( { avatar_template_id : avatarTemplateIDs } ) , responseType : Responses . SetAvatarItemAsViewdResponse } ) ; } ; this . request = request . defaults ( { headers : { 'User-Agent' : 'Niantic App' , 'Accept' : '*/*' , 'Content-Type' : 'application/x-www-form-urlencoded' } , encoding : null } ) ; this . options = Object . assign ( { } , defaultOptions , options || { } ) ; this . authTicket = null ; this . rpcId = 2 ; this . lastHashingKeyIndex = 0 ; this . firstGetMapObjects = true ; this . lehmer = new Lehmer ( 16807 ) ; this . ptr8 = INITIAL_PTR8 ; this . callOrChain = function ( requestMessage ) { if ( self . batchRequests ) { self . batchRequests . push ( requestMessage ) ; return self ; } else { return self . callRPC ( [ requestMessage ] ) ; } } ; this . getRequestID = function ( ) { return new Long ( self . rpcId ++ , this . lehmer . nextInt ( ) ) ; } ; this . buildEnvelope = function ( requests ) { var envelopeData = { status_code : 2 , request_id : self . getRequestID ( ) , ms_since_last_locationfix : 100 + Math . floor ( Math . random ( ) * 900 ) } ; if ( self . playerLatitude ) envelopeData . latitude = self . playerLatitude ; if ( self . playerLongitude ) envelopeData . longitude = self . playerLongitude ; if ( self . playerLocationAccuracy ) { envelopeData . accuracy = self . playerLocationAccuracy ; } else { const values = [ 5 , 5 , 5 , 5 , 10 , 10 , 10 , 30 , 30 , 50 , 65 ] ; values . unshift ( Math . floor ( Math . random ( ) * ( 80 - 66 ) ) + 66 ) ; envelopeData . accuracy = values [ Math . floor ( values . length * Math . random ( ) ) ] ; } if ( self . authTicket ) { envelopeData . auth_ticket = self . authTicket ; } else if ( ! self . options . authType || ! self . options . authToken ) { throw Error ( 'No auth info provided' ) ; } else { let unknown2 = 0 ; if ( self . options . authType === 'ptc' ) { const values = [ 2 , 8 , 21 , 21 , 21 , 28 , 37 , 56 , 59 , 59 , 59 ] ; unknown2 = values [ Math . floor ( values . length * Math . random ( ) ) ] ; } envelopeData . auth_info = { provider : self . options . authType , token : { contents : self . options . authToken , unknown2 : unknown2 , } } ; } if ( requests ) { self . emit ( 'request' , { request_id : envelopeData . request_id . toString ( ) , requests : requests . map ( r => ( { name : Utils . getEnumKeyByValue ( RequestType , r . type ) , type : r . type , data : r . message } ) ) } ) ; envelopeData . requests = requests . map ( r => { var requestData = { request_type : r . type } ; if ( r . message ) { requestData . request_message = r . message . encode ( ) ; } return requestData ; } ) ; } self . emit ( 'raw-request' , envelopeData ) ; return new POGOProtos . Networking . Envelopes . RequestEnvelope ( envelopeData ) ; } ; this . addPlatformRequestToEnvelope = function ( envelope , requestType , requestMessage ) { envelope . platform_requests . push ( new POGOProtos . Networking . Envelopes . RequestEnvelope . PlatformRequest ( { type : requestType , request_message : requestMessage . encode ( ) } ) ) ; return envelope ; } ; this . needsPtr8 = function ( requests ) { * Creates an RPC envelope with the given list of requests and adds the encrypted signature, * or adds the signature to an existing envelope. * @private * @param {Object[]} requests - Array of requests to build * @param {RequestEnvelope} [envelope] - Pre-built request envelope to sign * @return {Promise} - A Promise that will be resolved with a RequestEnvelope instance */ this . buildSignedEnvelope = function ( requests , envelope ) { if ( ! envelope ) { try { envelope = self . buildEnvelope ( requests ) ; } catch ( e ) { throw new retry . StopError ( e ) ; } } if ( self . needsPtr8 ( requests ) ) { self . addPlatformRequestToEnvelope ( envelope , PlatformRequestType . UNKNOWN_PTR_8 , new PlatformRequestMessages . UnknownPtr8Request ( { message : self . ptr8 , } ) ) ; } let authTicket = envelope . auth_ticket ; if ( ! authTicket ) { authTicket = envelope . auth_info ; } if ( ! authTicket ) { * Executes an RPC call with the given list of requests, retrying if necessary. * @private * @param {Object[]} requests - Array of requests to send * @param {RequestEnvelope} [envelope] - Pre-built request envelope to use * @return {Promise} - A Promise that will be resolved with the (list of) response messages, * or true if there aren't any */ this . callRPC = function ( requests , envelope ) { // If the requests include a map objects request, make sure the minimum delay // since the last call has passed if ( requests . some ( r => r . type === RequestType . GET_MAP_OBJECTS ) ) { var now = new Date ( ) . getTime ( ) , delayNeeded = self . lastMapObjectsCall + self . options . mapObjectsMinDelay - now ; if ( delayNeeded > 0 && self . options . mapObjectsThrottling ) { return Promise . delay ( delayNeeded ) . then ( ( ) => self . callRPC ( requests , envelope ) ) ; } self . lastMapObjectsCall = now ; } if ( self . options . maxTries <= 1 ) return self . tryCallRPC ( requests , envelope ) ; return retry ( ( ) => self . tryCallRPC ( requests , envelope ) , { interval : 300 , backoff : 2 , max_tries : self . options . maxTries } ) ; } ; /** * Handle redirection to new API endpoint and resend last request to new endpoint. * @private * @param {Object[]} requests - Array of requests * @param {RequestEnvelope} signedEnvelope - Request envelope * @param {ResponseEnvelope} responseEnvelope - Result from API call * @return {Promise} */ this . redirect = function ( requests , signedEnvelope , responseEnvelope ) { return new Promise ( ( resolve , reject ) => { if ( ! responseEnvelope . api_url ) { reject ( Error ( 'Fetching RPC endpoint failed, none supplied in response' ) ) ; return ; } self . endpoint = 'https: * Executes an RPC call with the given list of requests. * @private * @param {Object[]} requests - Array of requests to send * @param {RequestEnvelope} [envelope] - Pre-built request envelope to use * @return {Promise} - A Promise that will be resolved with the (list of) response messages, * or true if there aren't any */ this . tryCallRPC = function ( requests , envelope ) { return self . buildSignedEnvelope ( requests , envelope ) . then ( signedEnvelope => new Promise ( ( resolve , reject ) => { self . request ( { method : 'POST' , url : self . endpoint , proxy : self . options . proxy , body : signedEnvelope . toBuffer ( ) } , ( err , response , body ) => { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . statusCode !== 200 ) { if ( response . statusCode >= 400 && response . statusCode < 500 ) { /* These are permanent errors so throw StopError */ reject ( new retry . StopError ( ` ${ response . statusCode } ` ) ) ; } else { /* Anything else might be recoverable so throw regular Error */ reject ( Error ( ` ${ response . statusCode } ` ) ) ; } return ; } var responseEnvelope ; try { responseEnvelope = POGOProtos . Networking . Envelopes . ResponseEnvelope . decode ( body ) ; } catch ( e ) { self . emit ( 'parse-envelope-error' , body , e ) ; if ( e . decoded ) { responseEnvelope = e . decoded ; } else { reject ( new retry . StopError ( e ) ) ; return ; } } self . emit ( 'raw-response' , responseEnvelope ) ; if ( responseEnvelope . error ) { reject ( new retry . StopError ( responseEnvelope . error ) ) ; return ; } if ( responseEnvelope . auth_ticket ) self . authTicket = responseEnvelope . auth_ticket ; if ( responseEnvelope . status_code === 53 || ( responseEnvelope . status_code === 2 && self . endpoint === INITIAL_ENDPOINT ) ) { resolve ( self . redirect ( requests , signedEnvelope , responseEnvelope ) ) ; return ; } responseEnvelope . platform_returns . forEach ( platformReturn => { if ( platformReturn . type === PlatformRequestType . UNKNOWN_PTR_8 ) { const ptr8 = PlatformResponses . UnknownPtr8Response . decode ( platformReturn . response ) ; if ( ptr8 ) self . ptr8 = ptr8 . message ; } } ) ; /* Throttling, retry same request later */ if ( responseEnvelope . status_code === 52 ) { signedEnvelope . platform_requests = [ ] ; Promise . delay ( 2000 ) . then ( ( ) => { resolve ( self . callRPC ( requests , signedEnvelope ) ) ; } ) ; return ; } /* These codes indicate invalid input, no use in retrying so throw StopError */ if ( responseEnvelope . status_code === 3 || responseEnvelope . status_code === 51 || responseEnvelope . status_code >= 100 ) { reject ( new retry . StopError ( ` ${ responseEnvelope . status_code } ` ) ) ; } /* These can be temporary so throw regular Error */ if ( responseEnvelope . status_code !== 2 && responseEnvelope . status_code !== 1 ) { reject ( Error ( ` ${ responseEnvelope . status_code } ` ) ) ; return ; } var responses = [ ] ; if ( requests ) { if ( requests . length !== responseEnvelope . returns . length ) { reject ( Error ( 'Request count does not match response count' ) ) ; return ; } for ( var i = 0 ; i < responseEnvelope . returns . length ; i ++ ) { if ( ! requests [ i ] . responseType ) continue ; var responseMessage ; try { responseMessage = requests [ i ] . responseType . decode ( responseEnvelope . returns [ i ] ) ; } catch ( e ) { self . emit ( 'parse-response-error' , responseEnvelope . returns [ i ] . toBuffer ( ) , e ) ; reject ( new retry . StopError ( e ) ) ; return ; } if ( self . options . includeRequestTypeInResponse ) { // eslint-disable-next-line no-underscore-dangle responseMessage . _requestType = requests [ i ] . type ; } responses . push ( responseMessage ) ; } } self . emit ( 'response' , { status_code : responseEnvelope . status_code , request_id : responseEnvelope . request_id . toString ( ) , responses : responses . map ( ( r , h ) => ( { name : Utils . getEnumKeyByValue ( RequestType , requests [ h ] . type ) , type : requests [ h ] . type , data : r } ) ) } ) ; if ( self . options . automaticLongConversion ) { responses = Utils . convertLongs ( responses ) ; } if ( ! responses . length ) resolve ( true ) ; else if ( responses . length === 1 ) resolve ( responses [ 0 ] ) ; else resolve ( responses ) ; } ) ; } ) ) ; } ; /** * Processes the data received from the downloadSettings API call during init(). * @private * @param {Object} settingsResponse - Response from API call * @return {Object} response - Unomdified response (to send back to Promise) */ this . processSettingsResponse = function ( settingsResponse ) { // Extract the minimum delay of getMapObjects() if ( settingsResponse && ! settingsResponse . error && settingsResponse . settings && settingsResponse . settings . map_settings && settingsResponse . settings . map_settings . get_map_objects_min_refresh_seconds ) { self . setOption ( 'mapObjectsMinDelay' , settingsResponse . settings . map_settings . get_map_objects_min_refresh_seconds * 1000 ) ; } return settingsResponse ; } ; /** * Makes an initial call to the hashing server to verify API version. * @private * @return {Promise} */ this . initializeHashingServer = function ( ) { if ( ! self . options . hashingServer ) throw new Error ( 'Hashing server enabled without host' ) ; if ( ! self . options . hashingKey ) throw new Error ( 'Hashing server enabled without key' ) ; if ( self . options . hashingServer . slice ( - 1 ) !== '/' ) { self . setOption ( 'hashingServer' , self . options . hashingServer + '/' ) ; } return Signature . versions . getHashingEndpoint ( self . options . hashingServer , self . options . version ) . then ( version => { self . hashingVersion = version ; } ) ; } ; /* * DEPRECATED METHODS */ /** * Sets the authType and authToken options. * @deprecated Use options object or setOption() instead * @param {string} authType * @param {string} authToken */ this . setAuthInfo = function ( authType , authToken ) { self . setOption ( 'authType' , authType ) ; self . setOption ( 'authToken' , authToken ) ; } ; /** * Sets the includeRequestTypeInResponse option. * @deprecated Use options object or setOption() instead * @param {bool} includeRequestTypeInResponse */ this . setIncludeRequestTypeInResponse = function ( includeRequestTypeInResponse ) { self . setOption ( 'includeRequestTypeInResponse' , includeRequestTypeInResponse ) ; } ; /** * Sets the maxTries option. * @deprecated Use options object or setOption() instead * @param {integer} maxTries */ this . setMaxTries = function ( maxTries ) { self . setOption ( 'maxTries' , maxTries ) ; } ; /** * Sets the proxy option. * @deprecated Use options object or setOption() instead * @param {string} proxy */ this . setProxy = function ( proxy ) { self . setOption ( 'proxy' , proxy ) ; } ; /** * Sets the mapObjectsThrottling option. * @deprecated Use options object or setOption() instead * @param {boolean} enable */ this . setMapObjectsThrottlingEnabled = function ( enable ) { self . setOption ( 'mapObjectsThrottling' , enable ) ; } ; /** * Sets a callback to be called for any envelope or request just before it is sent to * the server (mostly for debugging purposes). * @deprecated Use the raw-request event instead * @param {function} callback - function to call on requests */ this . setRequestCallback = function ( callback ) { self . on ( 'raw-request' , callback ) ; } ; /** * Sets a callback to be called for any envelope or response just after it has been * received from the server (mostly for debugging purposes). * @deprecated Use the raw-response event instead * @param {function} callback - function to call on responses */ this . setResponseCallback = function ( callback ) { self . on ( 'raw-response' , callback ) ; } ; /** * Sets the automaticLongConversion option. * @deprecated Use options object or setOption() instead * @param {boolean} enable */ this . setAutomaticLongConversionEnabled = function ( enable ) { if ( typeof enable !== 'boolean' ) return ; self . setOption ( 'automaticLongConversion' , enable ) ; } ; } 
function PTCLogin ( ) { if ( ! ( this instanceof PTCLogin ) ) { return new PTCLogin ( ) ; } const self = this ; self . request = request . defaults ( { headers : { 'User-Agent' : 'pokemongo/1 CFNetwork/808.2.16 Darwin/16.3.0' } , jar : request . jar ( ) } ) ; this . login = function ( username , password ) { return self . getSession ( ) . then ( sessionData => self . getTicket ( sessionData , username , password ) ) . then ( self . getToken ) ; } ; this . getSession = function ( ) { return new Promise ( ( resolve , reject ) => { self . request ( { method : 'GET' , url : 'https://sso.pokemon.com/sso/login' , qs : { service : 'https://sso.pokemon.com/sso/oauth2.0/callbackAuthorize' } } , ( err , response , body ) => { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . statusCode !== 200 ) { reject ( Error ( ` ${ response . statusCode } ` ) ) ; return ; } var sessionResponse = null ; try { sessionResponse = JSON . parse ( body ) ; } catch ( e ) { reject ( Error ( 'Unexpected response received from PTC login' ) ) ; return ; } if ( ! sessionResponse || ! sessionResponse . lt && ! sessionResponse . execution ) { reject ( Error ( 'No session data received from PTC login' ) ) ; return ; } resolve ( { lt : sessionResponse . lt , execution : sessionResponse . execution } ) ; } ) ; } ) ; } ; this . getTicket = function ( sessionData , username , password ) { return new Promise ( ( resolve , reject ) => { self . request ( { method : 'POST' , url : 'https://sso.pokemon.com/sso/login' , qs : { service : 'https://sso.pokemon.com/sso/oauth2.0/callbackAuthorize' } , form : { 'lt' : sessionData . lt , 'execution' : sessionData . execution , '_eventId' : 'submit' , 'username' : username , 'password' : password } } , ( err , response ) => { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . statusCode !== 302 || ! response . headers . location ) { reject ( Error ( 'Invalid response received from PTC login' ) ) ; return ; } var ticketURL = url . parse ( response . headers . location , true ) ; if ( ! ticketURL || ! ticketURL . query . ticket ) { reject ( Error ( 'No login ticket received from PTC login' ) ) ; return ; } resolve ( ticketURL . query . ticket ) ; } ) ; } ) ; } ; this . getToken = function ( ticket ) { return new Promise ( ( resolve , reject ) => { self . request ( { method : 'POST' , url : 'https://sso.pokemon.com/sso/oauth2.0/accessToken' , form : { client_id : 'mobile-app_pokemon-go' , client_secret : 'w8ScCUXJQc6kXKw8FiOhd8Fixzht18Dq3PEVkUCP5ZPxtgyWsbTvWHFLm2wNY0JR' , redirect_uri : 'https://www.nianticlabs.com/pokemongo/error' , grant_type : 'refresh_token' , code : ticket } } , ( err , response , body ) => { if ( err ) { reject ( Error ( err ) ) ; return ; } if ( response . statusCode !== 200 ) { reject ( Error ( ` ${ response . statusCode } ` ) ) ; return ; } var qs = querystring . parse ( body ) ; if ( ! qs || ! qs . access_token ) { reject ( Error ( 'Invalid data received from PTC OAuth' ) ) ; return ; } resolve ( qs . access_token ) ; } ) ; } ) ; } ; this . setProxy = function ( proxy ) { self . request = self . request . defaults ( { proxy : proxy } ) ; } ; } 
function GoogleLogin ( ) { if ( ! ( this instanceof GoogleLogin ) ) { return new GoogleLogin ( ) ; } const self = this ; const GOOGLE_LOGIN_ANDROID_ID = '9774d56d682e549c' ; const GOOGLE_LOGIN_SERVICE = 'audience:server:client_id:848232511240-7so421jotr2609rmqakceuu1luuq0ptb.apps.googleusercontent.com' ; const GOOGLE_LOGIN_APP = 'com.nianticlabs.pokemongo' ; const GOOGLE_LOGIN_CLIENT_SIG = '321187995bc7cdc2b5fc91b11a96e2baa8602c62' ; this . setProxy = function ( proxy ) { google . setProxy ( proxy ) ; } ; this . login = function ( username , password ) { return self . getMasterToken ( username , password ) . then ( loginData => self . getToken ( username , loginData ) ) . then ( authData => authData . Auth ) ; } ; this . loginWithToken = function ( username , token ) { var loginData = { androidId : GOOGLE_LOGIN_ANDROID_ID , masterToken : token } ; return self . getToken ( username , loginData ) . then ( authData => authData . Auth ) ; } ; this . getMasterToken = function ( username , password ) { return new Promise ( ( resolve , reject ) => { google . login ( username , password , GOOGLE_LOGIN_ANDROID_ID , ( err , data ) => { if ( err ) { if ( err . response . statusCode === 403 ) { reject ( Error ( 'Received code 403 from Google login. This could be because your account has ' + '2-Step-Verification enabled. If that is the case, you need to generate an ' + 'App Password and use that instead of your regular password: ' + 'https://security.google.com/settings/security/apppasswords' ) ) ; } else { reject ( Error ( err . response . statusCode + ': ' + err . response . statusMessage ) ) ; } return ; } resolve ( data ) ; } ) ; } ) ; } ; this . getToken = function ( username , loginData ) { return new Promise ( ( resolve , reject ) => { google . oauth ( username , loginData . masterToken , loginData . androidId , GOOGLE_LOGIN_SERVICE , GOOGLE_LOGIN_APP , GOOGLE_LOGIN_CLIENT_SIG , ( err , data ) => { if ( err ) { reject ( Error ( err . response . statusCode + ': ' + err . response . statusMessage ) ) ; return ; } resolve ( data ) ; } ) ; } ) ; } ; } 
function ( lat , lng , radius , level ) { if ( typeof radius === 'undefined' ) radius = 3 ; if ( typeof level === 'undefined' ) level = 15 ; var origin = s2 . S2Cell . FromLatLng ( { lat : lat , lng : lng } , level ) ; var cells = [ ] ; cells . push ( origin . toHilbertQuadkey ( ) ) ; 
function ( inventory ) { if ( ! inventory || ! inventory . success || ! inventory . inventory_delta || ! inventory . inventory_delta . inventory_items ) { return { } ; } var ret = { pokemon : [ ] , removed_pokemon : [ ] , items : [ ] , pokedex : [ ] , player : null , currency : [ ] , camera : null , inventory_upgrades : [ ] , applied_items : [ ] , egg_incubators : [ ] , candies : [ ] , quests : [ ] } ; inventory . inventory_delta . inventory_items . forEach ( item => { if ( item . inventory_item_data ) { const itemdata = item . inventory_item_data ; if ( itemdata . pokemon_data ) { ret . pokemon . push ( itemdata . pokemon_data ) ; } if ( itemdata . item ) { ret . items . push ( itemdata . item ) ; } if ( itemdata . pokedex_entry ) { ret . pokedex . push ( itemdata . pokedex_entry ) ; } if ( itemdata . player_stats ) { ret . player = itemdata . player_stats ; } if ( itemdata . player_currency ) { ret . currency . push ( itemdata . player_currency ) ; } if ( itemdata . player_camera ) { ret . camera = itemdata . player_camera ; } if ( itemdata . inventory_upgrades ) { ret . inventory_upgrades . push ( itemdata . inventory_upgrades ) ; } if ( itemdata . applied_items ) { ret . applied_items . push ( itemdata . applied_items ) ; } if ( itemdata . egg_incubators ) { const incubators = itemdata . egg_incubators . egg_incubator || [ ] ; ret . egg_incubators = ret . egg_incubators . concat ( incubators ) ; } if ( itemdata . candy ) { ret . candies . push ( itemdata . candy ) ; } if ( itemdata . quest ) { ret . quests . push ( itemdata . quest ) ; } } if ( item . deleted_item && item . deleted_item . pokemon_id ) { ret . removed_pokemon . push ( item . deleted_item . pokemon_id ) ; } } ) ; return ret ; } 
function ( templates ) { if ( ! templates || ! templates . success || ! templates . item_templates ) return { } ; var ret = { pokemon_settings : [ ] , item_settings : [ ] , move_settings : [ ] , move_sequence_settings : [ ] , type_effective_settings : [ ] , badge_settings : [ ] , camera_settings : null , player_level_settings : null , gym_level_settings : null , battle_settings : null , encounter_settings : null , iap_item_display : [ ] , iap_settings : null , pokemon_upgrade_settings : null , equipped_badge_settings : null } ; templates . item_templates . forEach ( template => { if ( template . pokemon_settings ) { ret . pokemon_settings . push ( template . pokemon_settings ) ; } if ( template . item_settings ) { ret . item_settings . push ( template . item_settings ) ; } if ( template . move_settings ) { ret . move_settings . push ( template . move_settings ) ; } if ( template . move_sequence_settings ) { ret . move_sequence_settings . push ( template . move_sequence_settings . sequence ) ; } if ( template . type_effective ) { ret . type_effective_settings . push ( template . type_effective ) ; } if ( template . badge_settings ) { ret . badge_settings . push ( template . badge_settings ) ; } if ( template . camera ) { ret . camera_settings = template . camera ; } if ( template . player_level ) { ret . player_level_settings = template . player_level ; } if ( template . gym_level ) { ret . gym_level_settings = template . gym_level ; } if ( template . battle_settings ) { ret . battle_settings = template . battle_settings ; } if ( template . encounter_settings ) { ret . encounter_settings = template . encounter_settings ; } if ( template . iap_item_display ) { ret . iap_item_display . push ( template . iap_item_display ) ; } if ( template . iap_settings ) { ret . iap_settings = template . iap_settings ; } if ( template . pokemon_upgrades ) { ret . pokemon_upgrade_settings = template . pokemon_upgrades ; } if ( template . equipped_badges ) { ret . equipped_badge_settings = template . equipped_badges ; } } ) ; return ret ; } 
function ( enumObj , val ) { for ( var key of Object . keys ( enumObj ) ) { if ( enumObj [ key ] === val ) { return key . split ( '_' ) . map ( word => word . charAt ( 0 ) . toUpperCase ( ) + word . slice ( 1 ) . toLowerCase ( ) ) . join ( ' ' ) ; } } return null ; } 
function ( pokemon , decimals ) { if ( typeof decimals === 'undefined' ) decimals = - 1 ; decimals = Math . min ( decimals , 20 ) ; var att = pokemon . individual_attack , def = pokemon . individual_defense , stam = pokemon . individual_stamina ; var unroundedPercentage = ( att + def + stam ) / 45 * 100 ; var percent = decimals < 0 ? unroundedPercentage : + unroundedPercentage . toFixed ( decimals ) ; return { att : att , def : def , stam : stam , percent : percent } ; } 
function ( object ) { if ( ! object || typeof object !== 'object' ) return object ; if ( object instanceof ByteBuffer ) return object ; if ( Long . isLong ( object ) ) { return object . lessThanOrEqual ( Number . MAX_SAFE_INTEGER ) && object . greaterThanOrEqual ( Number . MIN_SAFE_INTEGER ) ? object . toNumber ( ) : object . toString ( ) ; } for ( var i in object ) { if ( object . hasOwnProperty ( i ) ) { if ( Long . isLong ( object [ i ] ) ) { object [ i ] = object [ i ] . lessThanOrEqual ( Number . MAX_SAFE_INTEGER ) && object [ i ] . greaterThanOrEqual ( Number . MIN_SAFE_INTEGER ) ? object [ i ] . toNumber ( ) : object [ i ] . toString ( ) ; } else if ( typeof object [ i ] === 'object' ) { object [ i ] = this . convertLongs ( object [ i ] ) ; } } } return object ; } 
function Random ( seed ) { this . multiplier = 16807 ; this . modulus = 0x7fffffff ; this . seed = seed ; this . mq = Math . floor ( this . modulus / this . multiplier ) ; this . mr = this . modulus % this . multiplier ; } 
function prettyDate ( time ) { var diff = ( ( ( new Date ( ) ) . getTime ( ) - time ) / 1000 ) , day_diff = Math . floor ( diff / 86400 ) ; if ( isNaN ( day_diff ) || day_diff < 0 || day_diff >= 31 ) return ; return day_diff == 0 && ( diff < 60 && "just now" || diff < 120 && "1 minute ago" || diff < 3600 && Math . floor ( diff / 60 ) + " minutes ago" || diff < 7200 && "1 hour ago" || diff < 86400 && Math . floor ( diff / 3600 ) + " hours ago" ) || day_diff == 1 && "Yesterday" || day_diff < 7 && day_diff + " days ago" || day_diff < 31 && Math . ceil ( day_diff / 7 ) + " weeks ago" ; } 
function ( content , options ) { this . settings = $ . extend ( { } , $ . fn . alert . defaults , options ) this . $element = $ ( content ) . delegate ( this . settings . selector , 'click' , this . close ) } 
function LoggerFactory ( options ) { options = options || { prefix : true } ; 
function runRequestQueue ( socket ) { var queue = socket . requestQueue ; if ( ! queue ) return ; for ( var i in queue ) { 
function jsonp ( opts , cb ) { opts = opts || { } ; if ( typeof window === 'undefined' ) { 
function JWR ( responseCtx ) { this . body = responseCtx . body ; this . headers = responseCtx . headers || { } ; this . statusCode = ( typeof responseCtx . statusCode === 'undefined' ) ? 200 : responseCtx . statusCode ; 
function _emitFrom ( socket , requestCtx ) { if ( ! socket . _raw ) { throw new Error ( 'Failed to emit from socket- raw SIO socket is missing.' ) ; } 
function SailsSocket ( opts ) { var self = this ; opts = opts || { } ; 
function _afterReplacingAllCollections ( err ) { if ( err ) { return done ( err ) ; } 
function _constructor ( host , port , schema , adapter , user , password , database , identity ) { if ( _self . cleanArguments ( arguments ) . length == 1 && typeof arguments [ 0 ] === 'object' ) { _self . host = arguments [ 0 ] . host ; _self . port = arguments [ 0 ] . port ; _self . schema = arguments [ 0 ] . schema ; _self . adapter = arguments [ 0 ] . adapter ; _self . user = arguments [ 0 ] . user ; _self . password = arguments [ 0 ] . password ; _self . database = arguments [ 0 ] . database ; _self . identity = arguments [ 0 ] . identity ; _self . validate ( ) ; } else { _self . host = host ; _self . port = port ; _self . schema = schema ; _self . adapter = adapter ; _self . user = user ; _self . password = password ; _self . database = database ; if ( identity ) _self . identity = identity ; } } 
function _beginBatchMaybe ( next ) { 
function validateParameterValue ( parameter , type , format , value ) { if ( type === 'integer' ) { const parsedValue = Number . parseInt ( value ) if ( _ . isNaN ( parsedValue ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return parsedValue } else if ( type === 'number' ) { const parsedValue = Number . parseFloat ( value ) if ( _ . isNaN ( parsedValue ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return Number . isInteger ( parsedValue ) ? Number . parseInt ( value ) : parsedValue } else if ( type === 'string' && format ) { if ( format === 'date-time' && ! moment ( value , moment . ISO_8601 ) . isValid ( ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } else if ( format === 'date' && ! moment ( value , 'YYYY-MM-DD' ) . isValid ( ) ) { throw new Error ( ` ${ parameter } ${ value } ` ) } return value } return value } 
function parameterDeclarationToYargs ( yargs , parameter , declaration ) { const optionName = _ . kebabCase ( parameter ) let option = { } if ( declaration . description ) { option . describe = declaration . description } if ( declaration . type ) { if ( declaration . type === 'integer' ) { option . type = 'number' } else { option . type = declaration . type } } if ( declaration . enum ) { option . choices = declaration . enum } if ( declaration . default ) { option . default = declaration . default } if ( declaration . required ) { option . demandOption = declaration . required } if ( declaration . conflicts ) { option . conflicts = declaration . conflicts } yargs . option ( optionName , option ) yargs . coerce ( optionName , ( value ) => { if ( declaration . type === 'array' ) { return _ . map ( value , ( value ) => { return validateParameterValue ( ` ${ optionName } ` , declaration . item , declaration . format , value ) } ) } return validateParameterValue ( optionName , declaration . type , declaration . format , value ) } ) } 
function configDeclarationToYargs ( yargs , configDeclaration ) { _ . forOwn ( configDeclaration , ( parameter , parameterName ) => { parameterDeclarationToYargs ( yargs , parameterName , parameter ) } ) return yargs } 
function createModal ( id , title , body , footer ) { var $modalHeaderButton = $ ( '<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>' ) ; var $modalHeaderTitle = $ ( '<h4 class="modal-title" id="' + id + '_modal_title">' + title + '</h4>' ) ; var $modalHeader = $ ( '<div class="modal-header"></div>' ) ; $modalHeader . append ( $modalHeaderButton ) ; $modalHeader . append ( $modalHeaderTitle ) ; var $modalBody = $ ( '<div class="modal-body" id="' + id + '_modal_body">' + body + '</div>' ) ; var $modalFooter = $ ( '<div class="modal-footer" id="' + id + '_modal_footer"></div>' ) ; if ( typeof ( footer ) !== 'undefined' ) { var $modalFooterAddOn = $ ( '<div>' + footer + '</div>' ) ; $modalFooter . append ( $modalFooterAddOn ) ; } var $modalContent = $ ( '<div class="modal-content"></div>' ) ; $modalContent . append ( $modalHeader ) ; $modalContent . append ( $modalBody ) ; $modalContent . append ( $modalFooter ) ; var $modalDialog = $ ( '<div class="modal-dialog"></div>' ) ; $modalDialog . append ( $modalContent ) ; var $modalFade = $ ( '<div class="modal fade" id="' + id + '_modal" tabindex="-1" role="dialog" aria-labelledby="' + id + '_modal_title" aria-hidden="true"></div>' ) ; $modalFade . append ( $modalDialog ) ; $modalFade . data ( 'dateId' , id ) ; $modalFade . attr ( "dateId" , id ) ; return $modalFade ; } 
function checkEvents ( $calendarElement , year , month ) { var jsonData = $calendarElement . data ( 'jsonData' ) ; var ajaxSettings = $calendarElement . data ( 'ajaxSettings' ) ; $calendarElement . data ( 'events' , false ) ; if ( false !== jsonData ) { return jsonEvents ( $calendarElement ) ; } else if ( false !== ajaxSettings ) { return ajaxEvents ( $calendarElement , year , month ) ; } return true ; } 
function isToday ( year , month , day ) { var todayObj = new Date ( ) ; var dateObj = new Date ( year , month , day ) ; return ( dateObj . toDateString ( ) == todayObj . toDateString ( ) ) ; } 
function ensureSecure ( req , res , next ) { if ( req . headers [ "x-forwarded-proto" ] === "https" ) { 
function signupEmail ( user ) { var port = process . env . MAIL_PORT var useremail = process . env . MAIL_USERNAME var passwords = process . env . MAIL_PASSWORD var host = process . env . MAIL_HOST var temp = { } 'use strict' ; var nodemailer = require ( 'nodemailer' ) ; 
function binarySearch ( arr , searchValue ) { function find ( arr , searchValue , left , right ) { if ( right < left ) return - 1 ; var mid = Math . floor ( ( left + right ) >>> 1 ) ; if ( searchValue > arr [ mid ] ) return find ( arr , searchValue , mid + 1 , right ) ; if ( searchValue < arr [ mid ] ) return find ( arr , searchValue , left , mid - 1 ) ; return mid ; } ; return find ( arr , searchValue , 0 , arr . length - 1 ) ; } 
function IteratedChar ( ) { this . charValue = 0 ; 
function NGramParser ( theNgramList , theByteMap ) { var N_GRAM_MASK = 0xFFFFFF ; this . byteIndex = 0 ; this . ngram = 0 ; this . ngramList = theNgramList ; this . byteMap = theByteMap ; this . ngramCount = 0 ; this . hitCount = 0 ; this . spaceChar ; this . search = function ( table , value ) { var index = 0 ; if ( table [ index + 32 ] <= value ) index += 32 ; if ( table [ index + 16 ] <= value ) index += 16 ; if ( table [ index + 8 ] <= value ) index += 8 ; if ( table [ index + 4 ] <= value ) index += 4 ; if ( table [ index + 2 ] <= value ) index += 2 ; if ( table [ index + 1 ] <= value ) index += 1 ; if ( table [ index ] > value ) index -= 1 ; if ( index < 0 || table [ index ] != value ) return - 1 ; return index ; } ; this . lookup = function ( thisNgram ) { this . ngramCount += 1 ; if ( this . search ( this . ngramList , thisNgram ) >= 0 ) { this . hitCount += 1 ; } } ; this . addByte = function ( b ) { this . ngram = ( ( this . ngram << 8 ) + ( b & 0xFF ) ) & N_GRAM_MASK ; this . lookup ( this . ngram ) ; } this . nextByte = function ( det ) { if ( this . byteIndex >= det . fInputLen ) return - 1 ; return det . fInputBytes [ this . byteIndex ++ ] & 0xFF ; } this . parse = function ( det , spaceCh ) { var b , ignoreSpace = false ; this . spaceChar = spaceCh ; while ( ( b = this . nextByte ( det ) ) >= 0 ) { var mb = this . byteMap [ b ] ; 
function Iconic ( ) { * Sets the path used to locate the iconic SVG files * @param {string} path - the base path used to locate the iconic SVG files */ this . setAssetPath = function ( path ) { assetPath = angular . isString ( path ) ? path : assetPath ; } ; this . $get = function ( ) { var iconicObject = new IconicJS ( ) ; var service = { getAccess : getAccess , getAssetPath : getAssetPath } ; return service ; function getAccess ( ) { return iconicObject ; } function getAssetPath ( ) { return assetPath ; } } ; } 
function getParentsUntil ( elem , parent ) { for ( ; elem && elem !== document . body ; elem = elem . parentNode ) { if ( elem . hasAttribute ( parent ) ) { if ( elem . classList . contains ( 'is-active' ) ) { return elem ; } break ; } } return false ; } 
function collectScenariosFromElement ( parentElement ) { var scenarios = [ ] ; var templates = [ ] ; var elements = parentElement . children ( ) ; var i = 0 ; angular . forEach ( elements , function ( el ) { var elem = angular . element ( el ) ; 
function zfAccordionItem ( ) { var directive = { restrict : 'EA' , templateUrl : 'components/accordion/accordion-item.html' , transclude : true , scope : { title : '@' } , require : '^zfAccordion' , replace : true , controller : function ( ) { } , link : link } ; return directive ; function link ( scope , element , attrs , controller , transclude ) { scope . active = false ; controller . addSection ( scope ) ; scope . activate = function ( ) { controller . select ( scope ) ; } ; } } 
function watchPath ( rootPath , options , eventCallback ) { const watcher = PathWatcherManager . instance ( ) . createWatcher ( rootPath , options , eventCallback ) return watcher . getStartPromise ( ) . then ( ( ) => watcher ) } 
function absolute ( ... parts ) { let candidate = parts . length !== 1 ? path . join ( ... parts ) : parts [ 0 ] if ( process . platform === 'win32' && / ^[A-Z]:$ / . test ( candidate ) ) candidate += '\\' return path . isAbsolute ( candidate ) ? candidate : path . join ( path . sep , candidate ) } 
function middleware ( opts ) { const srv = new Server ( opts ) ; servers . push ( srv ) ; return function tinylr ( req , res , next ) { srv . handler ( req , res , next ) ; } ; } 
function changed ( done ) { const files = [ ] . slice . call ( arguments ) ; if ( typeof files [ files . length - 1 ] === 'function' ) done = files . pop ( ) ; done = typeof done === 'function' ? done : ( ) => { } ; debug ( 'Notifying %d servers - Files: ' , servers . length , files ) ; servers . forEach ( srv => { const params = { params : { files : files } } ; srv && srv . changed ( params ) ; } ) ; done ( ) ; } 
function initialize ( appId ) { if ( Platform . OS == 'android' ) { usabillaEventEmitter . addListener ( 'UBFormNotFoundFragmentActivity' , ( ) => console . log ( "The Activity does not extend FragmentActivity and cannot call getSupportFragmentManager()" ) ) } UsabillaBridge . initialize ( appId ) } 
function ( children , element ) { this . portalNode = document . createElement ( 'div' ) ; ( element || document . body ) . appendChild ( this . portalNode ) ; ReactDOM . render ( children , this . portalNode ) ; } 
function ( ) { var close = typeof this . portalConfirmOnCloseMessage === 'string' ? confirm ( this . portalConfirmOnCloseMessage ) : true ; if ( this . portalNode && this . portalNode . parentNode && close ) { ReactDOM . unmountComponentAtNode ( this . portalNode ) ; this . portalNode . parentNode . removeChild ( this . portalNode ) ; this . portalNode = null ; } } 
function ( id , definition , dataFormatter ) { this . id = id ; this . url = definition . url ; this . cols = definition . cols ; this . sortColIndex = definition . sortColIndex ; this . pagination = definition . pagination ; this . cursor = definition . cursor ; this . rowClick = definition . rowClick ; this . advancedFilters = definition . advancedFilters ; this . data = null ; this . filteredData = null ; this . displayedData = null ; this . dataCount = null ; this . dataFormatter = dataFormatter ; this . selectedItems = { } ; this . selectDataProperty = _ . result ( _ . find ( this . cols , { 'dataType' : 'select' } ) , 'dataProperty' ) ; } 
function ( data ) { this . data = _ . values ( _ . cloneDeep ( data ) ) ; 
function ( ) { this . dataCount = this . data . length ; this . filteredData = this . filterData ( this . data ) ; this . displayedData = this . pagination ? this . sliceData ( this . filteredData ) : this . filteredData ; return this . displayedData ; } 
function ( data ) { if ( this . filterValue ) { data = this . quickFilterData ( data , this . filterValue ) ; } if ( this . advancedFilters ) { data = this . advancedFilterData ( data , this . advancedFilters ) ; } this . dataCount = data . length ; return data ; } 
function ( data , filterValue ) { var filterCol ; filterValue = filterValue . toString ( ) . toLowerCase ( ) . split ( ':' ) ; if ( filterValue . length > 1 ) { filterCol = filterValue [ 0 ] ; filterValue = filterValue [ 1 ] ; } else { filterValue = filterValue [ 0 ] ; } var filterProperties = [ ] ; 
function ( data , filters ) { return _ . filter ( _ . map ( data , function ( item ) { var shown = true ; _ . each ( filters , function ( filter ) { if ( item [ filter . dataProperty ] === filter . filterValue ) { if ( filter . checked ) { item = _ . cloneDeep ( item ) ; 
function ( colIndex , direction ) { this . sortColIndex = colIndex ; this . cols [ colIndex ] . sortDirection = direction ; var defaultDirection = this . cols [ colIndex ] . defaultSortDirection ; var dataType = this . cols [ this . sortColIndex ] . dataType ; var key = this . cols [ this . sortColIndex ] . dataProperty ; if ( this . pagination ) { this . resetPagination ( ) ; } this . data . sort ( function ( a , b ) { var first = a [ key ] ; var second = b [ key ] ; 
function ( deselect ) { _ . forEach ( this . filteredData , function ( data ) { if ( deselect ) { delete this . selectedItems [ data [ this . selectDataProperty ] ] ; } else { this . selectedItems [ data [ this . selectDataProperty ] ] = data ; } } , this ) ; } 
function ( rowIndex ) { var key = this . displayedData [ rowIndex ] [ this . selectDataProperty ] ; if ( this . selectedItems [ key ] ) { delete this . selectedItems [ key ] ; } else { this . selectedItems [ key ] = this . displayedData [ rowIndex ] ; } } 
function ( id , definition , dataFormatter ) { this . collection [ id ] = new Table ( id , definition , dataFormatter ) ; return this . collection [ id ] ; } 
function ( payload ) { var action = payload . action ; if ( ! this . shouldHandleAction ( action . component ) ) { return ; } switch ( action . actionType ) { case ActionTypes . REQUEST_DATA : this . handleRequestDataAction ( action ) ; break ; case ActionTypes . TABLE_SORT : this . collection [ action . id ] . sortData ( action . data . colIndex , action . data . direction ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . FILTER : this . collection [ action . id ] . setFilterValue ( action . data . value ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . ADVANCED_FILTER : this . collection [ action . id ] . setAdvancedFilters ( action . data . advancedFilters ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . PAGINATE : this . collection [ action . id ] . paginate ( action . data . direction ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . TOGGLE_BULK_SELECT : this . collection [ action . id ] . updateBulkSelection ( action . data . deselect ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . TOGGLE_ROW_SELECT : this . collection [ action . id ] . updateRowSelection ( action . data . rowIndex ) ; this . emitChange ( action . id ) ; break ; case ActionTypes . DESTROY_INSTANCE : this . destroyInstance ( action . id ) ; break ; } } 
function ( nextProps ) { if ( this . props . filters !== nextProps . filters && JSON . stringify ( this . props . filters ) !== JSON . stringify ( nextProps . filters ) ) { setTimeout ( function ( ) { this . requestData ( ) ; } . bind ( this ) , 0 ) ; } } 
function ( store ) { return { componentDidMount : function ( ) { store . on ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . on ( 'fail:' + this . props . componentId , this . onError ) ; } , componentWillUnmount : function ( ) { store . removeListener ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . removeListener ( 'fail:' + this . props . componentId , this . onError ) ; } } ; } 
function ( ) { store . on ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . on ( 'fail:' + this . props . componentId , this . onError ) ; } 
function ( ) { store . removeListener ( 'change:' + this . props . componentId , this . onDataReceived ) ; store . removeListener ( 'fail:' + this . props . componentId , this . onError ) ; } 
function ( id , definition , dataFormatter , filters ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . REQUEST_DATA , component : 'Table' , id : id , data : { definition : definition , dataFormatter : dataFormatter , filters : filters } } ) ; } 
function ( id , value ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . FILTER , component : 'Table' , id : id , data : { value : value } } ) ; } 
function ( id , advancedFilters ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . ADVANCED_FILTER , component : 'Table' , id : id , data : { advancedFilters : advancedFilters } } ) ; } 
function ( id , direction ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . PAGINATE , component : 'Table' , id : id , data : { direction : direction } } ) ; } 
function ( id , colIndex , direction ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . TABLE_SORT , component : 'Table' , id : id , data : { colIndex : colIndex , direction : direction } } ) ; } 
function ( id , deselect ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . TOGGLE_BULK_SELECT , component : 'Table' , id : id , data : { deselect : deselect } } ) ; } 
function ( id , rowIndex ) { AppDispatcher . dispatchAction ( { actionType : this . actionTypes . TOGGLE_ROW_SELECT , component : 'Table' , id : id , data : { rowIndex : rowIndex } } ) ; } 
function extractValue ( attr , node ) { if ( attr === 'translate' ) { return node . html ( ) || getAttr ( attr ) || '' ; } return getAttr ( attr ) || node . html ( ) || '' ; } 
function cleanerEval$624 ( str$629 , oldConsole$630 ) { var logArr$631 = [ ] ; var console$632 = { log : function ( msg$633 ) { logArr$631 . push ( msg$633 ) ; oldConsole$630 . log ( msg$633 ) ; } } ; eval ( str$629 ) ; return logArr$631 ; } 
function ( obj , callback , thisArg ) { return obj . map ? obj . map . call ( obj , callback , thisArg ) : map . call ( obj , callback , thisArg ) ; } 
function ( obj , callback , thisArg ) { return obj . filter ? obj . filter . call ( obj , callback , thisArg ) : filter . call ( obj , callback , thisArg ) ; } 
function ( obj , elements ) { return elements === undefined ? [ ] : utils . map ( elements , function ( item ) { return utils . indexOf ( obj , item ) ; } ) ; } 
function ( array , item ) { var index = utils . indexOf ( array , item ) ; if ( index === - 1 ) { array . push ( item ) ; } } 
function ( array , idx , amt , objects ) { if ( array . replace ) { return array . replace ( idx , amt , objects ) ; } else { return utils . _replace ( array , idx , amt , objects ) ; } } 
function ( array1 , array2 ) { var intersection = [ ] ; utils . forEach ( array1 , function ( element ) { if ( utils . indexOf ( array2 , element ) >= 0 ) { intersection . push ( element ) ; } } ) ; return intersection ; } 
function removeListener ( obj , eventName , target , method ) { Ember . assert ( "You must pass at least an object and event name to Ember.removeListener" , ! ! obj && ! ! eventName ) ; if ( ! method && 'function' === typeof target ) { method = target ; target = null ; } function _removeListener ( target , method ) { var actions = actionsFor ( obj , eventName ) , actionIndex = indexOf ( actions , target , method ) ; 
function suspendListener ( obj , eventName , target , method , callback ) { if ( ! method && 'function' === typeof target ) { method = target ; target = null ; } var actions = actionsFor ( obj , eventName ) , actionIndex = indexOf ( actions , target , method ) ; if ( actionIndex !== - 1 ) { actions [ actionIndex + 2 ] |= SUSPENDED ; 
function dependentKeysDidChange ( obj , depKey , meta ) { if ( obj . isDestroying ) { return ; } var seen = DID_SEEN , top = ! seen ; if ( top ) { seen = DID_SEEN = { } ; } iterDeps ( propertyDidChange , obj , depKey , seen , meta ) ; if ( top ) { DID_SEEN = null ; } } 
function set ( obj , keyName , value , tolerant ) { if ( typeof obj === 'string' ) { Ember . assert ( "Path '" + obj + "' must be global if no obj is given." , IS_GLOBAL . test ( obj ) ) ; value = keyName ; keyName = obj ; obj = null ; } Ember . assert ( "Cannot call set with " + keyName + " key." , ! ! keyName ) ; if ( ! obj || keyName . indexOf ( '.' ) !== - 1 ) { return setPath ( obj , keyName , value , tolerant ) ; } Ember . assert ( "You need to provide an object and key to `set`." , ! ! obj && keyName !== undefined ) ; Ember . assert ( 'calling set on destroyed object' , ! obj . isDestroyed ) ; var meta = obj [ META_KEY ] , desc = meta && meta . descs [ keyName ] , isUnknown , currentValue ; if ( desc ) { desc . set ( obj , keyName , value ) ; } else { isUnknown = 'object' === typeof obj && ! ( keyName in obj ) ; 
function ( key , value ) { var keys = this . keys , values = this . values , guid = guidFor ( key ) ; keys . add ( key ) ; values [ guid ] = value ; set ( this , 'length' , keys . list . length ) ; } 
function ( key ) { 
function ( callback , self ) { var keys = this . keys , values = this . values ; keys . forEach ( function ( key ) { var guid = guidFor ( key ) ; callback . call ( self , key , values [ guid ] ) ; } ) ; } 
function ComputedProperty ( func , opts ) { this . func = func ; if ( Ember . FEATURES . isEnabled ( 'composable-computed-properties' ) ) { setDependentKeys ( this , opts && opts . dependentKeys ) ; } else { this . _dependentKeys = opts && opts . dependentKeys ; } this . _cacheable = ( opts && opts . cacheable !== undefined ) ? opts . cacheable : true ; this . _readOnly = opts && ( opts . readOnly !== undefined || ! ! opts . readOnly ) ; } 
function ( ) { var queue = this . _queue , options = this . options , before = options && options . before , after = options && options . after , target , method , args , stack , i , l = queue . length ; if ( l && before ) { before ( ) ; } for ( i = 0 ; i < l ; i += 4 ) { target = queue [ i ] ; method = queue [ i + 1 ] ; args = queue [ i + 2 ] ; stack = queue [ i + 3 ] ; 
function ( toPath , fromPath ) { this . _direction = 'fwd' ; this . _from = fromPath ; this . _to = toPath ; this . _directionMap = Ember . Map . create ( ) ; } 
function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember.Binding.connect()' , ! ! obj ) ; var fromPath = this . _from , toPath = this . _to ; Ember . trySet ( obj , toPath , getWithGlobals ( obj , fromPath ) ) ; 
function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember.Binding.disconnect()' , ! ! obj ) ; var twoWay = ! this . _oneWay ; 
function ( from , flag ) { var C = this , binding = new C ( null , from ) ; return binding . oneWay ( flag ) ; } 
function filter ( promises , filterFn , label ) { return all ( promises , label ) . then ( function ( values ) { if ( ! isArray ( promises ) ) { throw new TypeError ( 'You must pass an array to filter.' ) ; } if ( ! isFunction ( filterFn ) ) { throw new TypeError ( "You must pass a function to filter's second argument." ) ; } return map ( promises , filterFn , label ) . then ( function ( filterResults ) { var i , valuesLen = values . length , filtered = [ ] ; for ( i = 0 ; i < valuesLen ; i ++ ) { if ( filterResults [ i ] ) filtered . push ( values [ i ] ) ; } return filtered ; } ) ; } ) ; } 
function Container ( parent ) { this . parent = parent ; this . children = [ ] ; this . resolver = parent && parent . resolver || function ( ) { } ; this . registry = new InheritingDict ( parent && parent . registry ) ; this . cache = new InheritingDict ( parent && parent . cache ) ; this . factoryCache = new InheritingDict ( parent && parent . factoryCache ) ; this . resolveCache = new InheritingDict ( parent && parent . resolveCache ) ; this . typeInjections = new InheritingDict ( parent && parent . typeInjections ) ; this . injections = { } ; this . factoryTypeInjections = new InheritingDict ( parent && parent . factoryTypeInjections ) ; this . factoryInjections = { } ; this . _options = new InheritingDict ( parent && parent . _options ) ; this . _typeOptions = new InheritingDict ( parent && parent . _typeOptions ) ; } 
function ( fullName , factory , options ) { validateFullName ( fullName ) ; if ( factory === undefined ) { throw new TypeError ( 'Attempting to register an unknown factory: `' + fullName + '`' ) ; } var normalizedName = this . normalize ( fullName ) ; if ( this . cache . has ( normalizedName ) ) { throw new Error ( 'Cannot re-register: `' + fullName + '`, as it has already been looked up.' ) ; } this . registry . set ( normalizedName , factory ) ; this . _options . set ( normalizedName , options || { } ) ; } 
function ( fullName ) { validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; this . registry . remove ( normalizedName ) ; this . cache . remove ( normalizedName ) ; this . factoryCache . remove ( normalizedName ) ; this . resolveCache . remove ( normalizedName ) ; this . _options . remove ( normalizedName ) ; } 
function ( fullName ) { validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; var cached = this . resolveCache . get ( normalizedName ) ; if ( cached ) { return cached ; } var resolved = this . resolver ( normalizedName ) || this . registry . get ( normalizedName ) ; this . resolveCache . set ( normalizedName , resolved ) ; return resolved ; } 
function ( type , property , fullName ) { validateFullName ( fullName ) ; if ( this . parent ) { illegalChildOperation ( 'typeInjection' ) ; } addTypeInjection ( this . typeInjections , type , property , fullName ) ; } 
function ( fullName , property , injectionName ) { if ( this . parent ) { illegalChildOperation ( 'injection' ) ; } validateFullName ( injectionName ) ; var normalizedInjectionName = this . normalize ( injectionName ) ; if ( fullName . indexOf ( ':' ) === - 1 ) { return this . typeInjection ( fullName , property , normalizedInjectionName ) ; } validateFullName ( fullName ) ; var normalizedName = this . normalize ( fullName ) ; addInjection ( this . injections , normalizedName , property , normalizedInjectionName ) ; } 
function ( type , property , fullName ) { if ( this . parent ) { illegalChildOperation ( 'factoryTypeInjection' ) ; } addTypeInjection ( this . factoryTypeInjections , type , property , this . normalize ( fullName ) ) ; } 
function ( key ) { var dict = this . dict ; if ( dict . hasOwnProperty ( key ) ) { return dict [ key ] ; } if ( this . parent ) { return this . parent . get ( key ) ; } } 
function ( key ) { var dict = this . dict ; if ( dict . hasOwnProperty ( key ) ) { return true ; } if ( this . parent ) { return this . parent . has ( key ) ; } return false ; } 
function ( callback , binding ) { var dict = this . dict ; for ( var prop in dict ) { if ( dict . hasOwnProperty ( prop ) ) { callback . call ( binding , prop , dict [ prop ] ) ; } } } 
function ( str , formats ) { 
function ( str , formats ) { str = Ember . STRINGS [ str ] || str ; return Ember . String . fmt ( str , formats ) ; } 
function ( str ) { var cache = STRING_DASHERIZE_CACHE , hit = cache . hasOwnProperty ( str ) , ret ; if ( hit ) { return cache [ str ] ; } else { ret = Ember . String . decamelize ( str ) . replace ( STRING_DASHERIZE_REGEXP , '-' ) ; cache [ str ] = ret ; } return ret ; } 
function ( keyName , increment ) { if ( Ember . isNone ( increment ) ) { increment = 1 ; } Ember . assert ( "Must pass a numeric value to incrementProperty" , ( ! isNaN ( parseFloat ( increment ) ) && isFinite ( increment ) ) ) ; set ( this , keyName , ( get ( this , keyName ) || 0 ) + increment ) ; return get ( this , keyName ) ; } 
function ( keyName , decrement ) { if ( Ember . isNone ( decrement ) ) { decrement = 1 ; } Ember . assert ( "Must pass a numeric value to decrementProperty" , ( ! isNaN ( parseFloat ( decrement ) ) && isFinite ( decrement ) ) ) ; set ( this , keyName , ( get ( this , keyName ) || 0 ) - decrement ) ; return get ( this , keyName ) ; } 
function ( ) { var Class = makeCtor ( ) , proto ; Class . ClassMixin = Mixin . create ( this . ClassMixin ) ; Class . PrototypeMixin = Mixin . create ( this . PrototypeMixin ) ; Class . ClassMixin . ownerConstructor = Class ; Class . PrototypeMixin . ownerConstructor = Class ; reopen . apply ( Class . PrototypeMixin , arguments ) ; Class . superclass = this ; Class . __super__ = this . prototype ; proto = Class . prototype = o_create ( this . prototype ) ; proto . constructor = Class ; generateGuid ( proto ) ; meta ( proto ) . proto = proto ; 
function ( key ) { var meta = this . proto ( ) [ META_KEY ] , desc = meta && meta . descs [ key ] ; Ember . assert ( "metaForProperty() could not find a computed property with key '" + key + "'." , ! ! desc && desc instanceof Ember . ComputedProperty ) ; return desc . _meta || { } ; } 
function ( callback , binding ) { var proto = this . proto ( ) , descs = meta ( proto ) . descs , empty = { } , property ; for ( var name in descs ) { property = descs [ name ] ; if ( property instanceof Ember . ComputedProperty ) { callback . call ( binding || this , name , property . _meta || empty ) ; } } } 
function ( key , value ) { var exactValue = function ( item ) { return get ( item , key ) === value ; } , hasValue = function ( item ) { return ! ! get ( item , key ) ; } , use = ( arguments . length === 2 ? exactValue : hasValue ) ; return this . reject ( use ) ; } 
function ( value ) { if ( ! this . contains ( value ) ) return this ; 
function ( ) { var ret = Ember . A ( ) ; this . forEach ( function ( k ) { if ( a_indexOf ( ret , k ) < 0 ) ret . push ( k ) ; } ) ; return ret ; } 
function ( target , opts ) { var willChange = ( opts && opts . willChange ) || 'arrayWillChange' , didChange = ( opts && opts . didChange ) || 'arrayDidChange' ; var hasObservers = get ( this , 'hasArrayObservers' ) ; if ( ! hasObservers ) Ember . propertyWillChange ( this , 'hasArrayObservers' ) ; Ember . addListener ( this , '@array:before' , target , willChange ) ; Ember . addListener ( this , '@array:change' , target , didChange ) ; if ( ! hasObservers ) Ember . propertyDidChange ( this , 'hasArrayObservers' ) ; return this ; } 
function ( startIdx , removeAmt , addAmt ) { 
function ( startIdx , removeAmt , addAmt ) { 
function ReduceComputedProperty ( options ) { var cp = this ; this . options = options ; this . _dependentKeys = null ; 
function ( objects ) { Ember . beginPropertyChanges ( this ) ; forEach ( objects , function ( obj ) { this . addObject ( obj ) ; } , this ) ; Ember . endPropertyChanges ( this ) ; return this ; } 
function ( objects ) { Ember . beginPropertyChanges ( this ) ; forEach ( objects , function ( obj ) { this . removeObject ( obj ) ; } , this ) ; Ember . endPropertyChanges ( this ) ; return this ; } 
function ( idx , object ) { if ( idx > get ( this , 'length' ) ) throw new Ember . Error ( OUT_OF_RANGE_EXCEPTION ) ; this . replace ( idx , 0 , [ object ] ) ; return this ; } 
function ( ) { var len = get ( this , 'length' ) ; if ( len === 0 ) return null ; var ret = this . objectAt ( len - 1 ) ; this . removeAt ( len - 1 , 1 ) ; return ret ; } 
function ( obj ) { var loc = get ( this , 'length' ) || 0 ; while ( -- loc >= 0 ) { var curObject = this . objectAt ( loc ) ; if ( curObject === obj ) this . removeAt ( loc ) ; } return this ; } 
function ( opts ) { opts = opts || { } ; var action = opts . action || get ( this , 'action' ) , target = opts . target || get ( this , 'targetObject' ) , actionContext = opts . actionContext ; function args ( options , actionName ) { var ret = [ ] ; if ( actionName ) { ret . push ( actionName ) ; } return ret . concat ( options ) ; } if ( typeof actionContext === 'undefined' ) { actionContext = get ( this , 'actionContextObject' ) || this ; } if ( target && action ) { var ret ; if ( target . send ) { ret = target . send . apply ( target , args ( actionContext , action ) ) ; } else { Ember . assert ( "The action '" + action + "' did not exist on " + target , typeof target [ action ] === 'function' ) ; ret = target [ action ] . apply ( target , args ( actionContext ) ) ; } if ( ret !== false ) ret = true ; return ret ; } else { return false ; } } 
function ( name ) { var args = [ ] , i , l ; for ( i = 1 , l = arguments . length ; i < l ; i ++ ) { args . push ( arguments [ i ] ) ; } Ember . sendEvent ( this , name , args ) ; } 
function ( resolve , reject , label ) { var deferred , promise , entity ; entity = this ; deferred = get ( this , '_deferred' ) ; promise = deferred . promise ; function fulfillmentHandler ( fulfillment ) { if ( fulfillment === promise ) { return resolve ( entity ) ; } else { return resolve ( fulfillment ) ; } } return promise . then ( resolve && fulfillmentHandler , reject , label ) ; } 
function ( value ) { var deferred , promise ; deferred = get ( this , '_deferred' ) ; promise = deferred . promise ; if ( value === this ) { deferred . resolve ( promise ) ; } else { deferred . resolve ( value ) ; } } 
function ( props ) { var hashName ; if ( ! props . _actions ) { Ember . assert ( "'actions' should not be a function" , typeof ( props . actions ) !== 'function' ) ; if ( typeOf ( props . actions ) === 'object' ) { hashName = 'actions' ; } else if ( typeOf ( props . events ) === 'object' ) { Ember . deprecate ( 'Action handlers contained in an `events` object are deprecated in favor of putting them in an `actions` object' , false ) ; hashName = 'events' ; } if ( hashName ) { props . _actions = Ember . merge ( props . _actions || { } , props [ hashName ] ) ; } delete props [ hashName ] ; } } 
function ( actionName ) { var args = [ ] . slice . call ( arguments , 1 ) , target ; if ( this . _actions && this . _actions [ actionName ] ) { if ( this . _actions [ actionName ] . apply ( this , args ) === true ) { 
function ( index , newItems ) { var count = get ( newItems , 'length' ) ; if ( count < 1 ) { return ; } var match = this . _findArrayOperation ( index ) , arrayOperation = match . operation , arrayOperationIndex = match . index , arrayOperationRangeStart = match . rangeStart , composeIndex , splitIndex , splitItems , splitArrayOperation , newArrayOperation ; newArrayOperation = new ArrayOperation ( INSERT , count , newItems ) ; if ( arrayOperation ) { if ( ! match . split ) { 
function ( index , count ) { if ( count < 1 ) { return ; } var match = this . _findArrayOperation ( index ) , arrayOperation = match . operation , arrayOperationIndex = match . index , arrayOperationRangeStart = match . rangeStart , newArrayOperation , composeIndex ; newArrayOperation = new ArrayOperation ( DELETE , count ) ; if ( ! match . split ) { 
function ( callback ) { var items = [ ] , offset = 0 ; forEach ( this . _operations , function ( arrayOperation ) { callback ( arrayOperation . items , offset , arrayOperation . type ) ; if ( arrayOperation . type !== DELETE ) { offset += arrayOperation . count ; items = items . concat ( arrayOperation . items ) ; } } ) ; this . _operations = [ new ArrayOperation ( RETAIN , items . length , items ) ] ; } 
function ( index ) { var newArrayOperation = this . _operations [ index ] , leftArrayOperation = this . _operations [ index - 1 ] , 
function ArrayOperation ( operation , count , items ) { this . type = operation ; 
function ArrayOperationMatch ( operation , index , split , rangeStart ) { this . operation = operation ; this . index = index ; this . split = split ; this . rangeStart = rangeStart ; } 
function ( index , match ) { var returnValue = - 1 , itemType = match ? RETAIN : FILTER , self = this ; this . _findOperation ( index , function ( operation , operationIndex , rangeStart , rangeEnd , seenInSubArray ) { var newOperation , splitOperation ; if ( itemType === operation . type ) { ++ operation . count ; } else if ( index === rangeStart ) { 
function ( index ) { var returnValue = - 1 , self = this ; this . _findOperation ( index , function ( operation , operationIndex , rangeStart , rangeEnd , seenInSubArray ) { if ( operation . type === RETAIN ) { returnValue = seenInSubArray + ( index - rangeStart ) ; } if ( operation . count > 1 ) { -- operation . count ; } else { self . _operations . splice ( operationIndex , 1 ) ; self . _composeAt ( operationIndex ) ; } } , function ( ) { throw new Ember . Error ( "Can't remove an item that has never been added." ) ; } ) ; return returnValue ; } 
function ( keyName , value ) { var ret ; ret = new EachArray ( this . _content , keyName , this ) ; Ember . defineProperty ( this , keyName , null , ret ) ; this . beginObservingContentKey ( keyName ) ; return ret ; } 
function ( idx , amt , objects ) { if ( this . isFrozen ) throw Ember . FROZEN_ERROR ; 
function ( ) { if ( this . isFrozen ) { throw new Ember . Error ( Ember . FROZEN_ERROR ) ; } var len = get ( this , 'length' ) ; if ( len === 0 ) { return this ; } var guid ; this . enumerableContentWillChange ( len , 0 ) ; Ember . propertyWillChange ( this , 'firstObject' ) ; Ember . propertyWillChange ( this , 'lastObject' ) ; for ( var i = 0 ; i < len ; i ++ ) { guid = guidFor ( this [ i ] ) ; delete this [ guid ] ; delete this [ i ] ; } set ( this , 'length' , 0 ) ; Ember . propertyDidChange ( this , 'firstObject' ) ; Ember . propertyDidChange ( this , 'lastObject' ) ; this . enumerableContentDidChange ( len , 0 ) ; return this ; } 
function ( ) { if ( get ( this , 'isFrozen' ) ) throw new Ember . Error ( Ember . FROZEN_ERROR ) ; var obj = this . length > 0 ? this [ this . length - 1 ] : null ; this . remove ( obj ) ; return obj ; } 
function ( element , id ) { if ( element . getAttribute ( 'id' ) === id ) { return element ; } var len = element . childNodes . length , idx , node , found ; for ( idx = 0 ; idx < len ; idx ++ ) { node = element . childNodes [ idx ] ; found = node . nodeType === 1 && findChildById ( node , id ) ; if ( found ) { return found ; } } } 
function ( className ) { 
function ( name , value ) { var attributes = this . elementAttributes = ( this . elementAttributes || { } ) ; if ( arguments . length === 1 ) { return attributes [ name ] ; } else { attributes [ name ] = value ; } return this ; } 
function ( name , value ) { var properties = this . elementProperties = ( this . elementProperties || { } ) ; if ( arguments . length === 1 ) { return properties [ name ] ; } else { properties [ name ] = value ; } return this ; } 
function ( ) { if ( this . _hasElement && this . _element ) { 
function ( addedEvents , rootElement ) { var event , events = get ( this , 'events' ) ; Ember . $ . extend ( events , addedEvents || { } ) ; if ( ! Ember . isNone ( rootElement ) ) { set ( this , 'rootElement' , rootElement ) ; } rootElement = Ember . $ ( get ( this , 'rootElement' ) ) ; Ember . assert ( fmt ( 'You cannot use the same root element (%@) multiple times in an Ember.Application' , [ rootElement . selector || rootElement [ 0 ] . tagName ] ) , ! rootElement . is ( '.ember-application' ) ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application' , ! rootElement . closest ( '.ember-application' ) . length ) ; Ember . assert ( 'You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application' , ! rootElement . find ( '.ember-application' ) . length ) ; rootElement . addClass ( 'ember-application' ) ; Ember . assert ( 'Unable to add "ember-application" class to rootElement. Make sure you set rootElement to the body or an element in the body.' , rootElement . is ( '.ember-application' ) ) ; for ( event in events ) { if ( events . hasOwnProperty ( event ) ) { this . setupHandler ( rootElement , event , events [ event ] ) ; } } } 
function ( rootElement , event , eventName ) { var self = this ; rootElement . on ( event + '.ember' , '.ember-view' , function ( evt , triggeringManager ) { var view = Ember . View . views [ this . id ] , result = true , manager = null ; manager = self . _findNearestEventManager ( view , eventName ) ; if ( manager && manager !== triggeringManager ) { result = self . _dispatchEvent ( manager , evt , eventName , view ) ; } else if ( view ) { result = self . _bubbleEvent ( view , evt , eventName ) ; } else { evt . stopPropagation ( ) ; } return result ; } ) ; rootElement . on ( event + '.ember' , '[data-ember-action]' , function ( evt ) { var actionId = Ember . $ ( evt . currentTarget ) . attr ( 'data-ember-action' ) , action = Ember . Handlebars . ActionHelper . registeredActions [ actionId ] ; 
function ( parentBuffer , bufferOperation ) { var name = 'render.' + this . instrumentName , details = { } ; this . instrumentDetails ( details ) ; return Ember . instrument ( name , details , function instrumentRenderToBuffer ( ) { return this . _renderToBuffer ( parentBuffer , bufferOperation ) ; } , this ) ; } 
function ( name ) { this . _super . apply ( this , arguments ) ; var method = this [ name ] ; if ( method ) { var args = [ ] , i , l ; for ( i = 1 , l = arguments . length ; i < l ; i ++ ) { args . push ( arguments [ i ] ) ; } return method . apply ( this , args ) ; } } 
function ( klass ) { Ember . deprecate ( "nearestInstanceOf is deprecated and will be removed from future releases. Use nearestOfType." ) ; var view = get ( this , 'parentView' ) ; while ( view ) { if ( view instanceof klass ) { return view ; } view = get ( view , 'parentView' ) ; } } 
function ( property ) { var view = get ( this , 'parentView' ) ; while ( view ) { if ( property in view ) { return view ; } view = get ( view , 'parentView' ) ; } } 
function ( klass ) { var view = get ( this , 'parentView' ) ; while ( view ) { if ( get ( view , 'parentView' ) instanceof klass ) { return view ; } view = get ( view , 'parentView' ) ; } } 
function ( buffer ) { 
function ( ) { 
function ( buffer , attributeBindings ) { var attributeValue , unspecifiedAttributeBindings = this . _unspecifiedAttributeBindings = this . _unspecifiedAttributeBindings || { } ; a_forEach ( attributeBindings , function ( binding ) { var split = binding . split ( ':' ) , property = split [ 0 ] , attributeName = split [ 1 ] || property ; if ( property in this ) { this . _setupAttributeBindingObservation ( property , attributeName ) ; 
function ( key , value ) { var attributeName = this . _unspecifiedAttributeBindings && this . _unspecifiedAttributeBindings [ key ] ; if ( attributeName ) { this . _setupAttributeBindingObservation ( key , attributeName ) ; } defineProperty ( this , key ) ; return set ( this , key , value ) ; } 
function ( fn , includeSelf ) { var childViews = ( includeSelf === false ) ? this . _childViews : [ this ] ; var currentViews , view , currentChildViews ; while ( childViews . length ) { currentViews = childViews . slice ( ) ; childViews = [ ] ; for ( var i = 0 , l = currentViews . length ; i < l ; i ++ ) { view = currentViews [ i ] ; currentChildViews = view . _childViews ? view . _childViews . slice ( 0 ) : null ; fn ( view ) ; if ( currentChildViews ) { childViews . push . apply ( childViews , currentChildViews ) ; } } } } 
function ( ) { this . elementId = this . elementId || guidFor ( this ) ; this . _super ( ) ; 
function ( ) { var childViews = this . _childViews , 
function ( view , attrs ) { if ( ! view ) { throw new TypeError ( "createChildViews first argument must exist" ) ; } if ( view . isView && view . _parentView === this && view . container === this . container ) { return view ; } attrs = attrs || { } ; attrs . _parentView = this ; if ( Ember . CoreView . detect ( view ) ) { attrs . templateData = attrs . templateData || get ( this , 'templateData' ) ; attrs . container = this . container ; view = view . create ( attrs ) ; 
function ( path ) { var split = path . split ( ':' ) , propertyPath = split [ 0 ] , classNames = "" , className , falsyClassName ; 
function ( view , fn ) { view . createElement ( ) ; var viewCollection = view . viewHierarchyCollection ( ) ; viewCollection . trigger ( 'willInsertElement' ) ; fn . call ( view ) ; 
function ( view , childView , options ) { var buffer = view . buffer , _childViews = view . _childViews ; childView = view . createChildView ( childView , options ) ; if ( ! _childViews . length ) { _childViews = view . _childViews = _childViews . slice ( ) ; } _childViews . push ( childView ) ; childView . renderToBuffer ( buffer ) ; view . propertyDidChange ( 'childViews' ) ; return childView ; } 
function ( view ) { view . clearBuffer ( ) ; var viewCollection = view . _notifyWillDestroyElement ( ) ; viewCollection . transitionTo ( 'preRender' , false ) ; return view ; } 
function ( view ) { view . triggerRecursively ( 'willClearRender' ) ; view . clearRenderedChildren ( ) ; view . domManager . replace ( view ) ; return view ; } 
function ( view ) { view . _notifyWillDestroyElement ( ) ; view . domManager . remove ( view ) ; set ( view , 'element' , null ) ; if ( view . _scheduledInsert ) { Ember . run . cancel ( view . _scheduledInsert ) ; view . _scheduledInsert = null ; } return view ; } 
function ( view , eventName , evt ) { if ( view . has ( eventName ) ) { 
function ( views , start , removed ) { this . propertyWillChange ( 'childViews' ) ; if ( removed > 0 ) { var changedViews = views . slice ( start , start + removed ) ; 
function ( views , start , removed , added ) { if ( added > 0 ) { var changedViews = views . slice ( start , start + added ) ; this . initializeViews ( changedViews , this , get ( this , 'templateData' ) ) ; this . currentState . childViewsDidChange ( this , views , start , added ) ; } this . propertyDidChange ( 'childViews' ) ; } 
function ( content , start , removedCount ) { 
function ( content , start , removed , added ) { var addedViews = [ ] , view , item , idx , len , itemViewClass , emptyView ; len = content ? get ( content , 'length' ) : 0 ; if ( len ) { itemViewClass = get ( this , 'itemViewClass' ) ; if ( 'string' === typeof itemViewClass ) { itemViewClass = get ( itemViewClass ) || itemViewClass ; } Ember . assert ( fmt ( "itemViewClass must be a subclass of Ember.View, not %@" , [ itemViewClass ] ) , 'string' === typeof itemViewClass || Ember . View . detect ( itemViewClass ) ) ; for ( idx = start ; idx < start + added ; idx ++ ) { item = content . objectAt ( idx ) ; view = this . createChildView ( itemViewClass , { content : item , contentIndex : idx } ) ; addedViews . push ( view ) ; } } else { emptyView = get ( this , 'emptyView' ) ; if ( ! emptyView ) { return ; } if ( 'string' === typeof emptyView ) { emptyView = get ( emptyView ) || emptyView ; } emptyView = this . createChildView ( emptyView ) ; addedViews . push ( emptyView ) ; set ( this , 'emptyView' , emptyView ) ; if ( Ember . CoreView . detect ( emptyView ) ) { this . _createdEmptyView = emptyView ; } } this . replace ( start , 0 , addedViews ) ; } 
function ( props ) { 
function ( action ) { var actionName , contexts = a_slice . call ( arguments , 1 ) ; 
function ( html ) { var self ; if ( this instanceof Metamorph ) { self = this ; } else { self = new K ( ) ; } self . innerHTML = html ; var myGuid = 'metamorph-' + ( guid ++ ) ; self . start = myGuid + '-start' ; self . end = myGuid + '-end' ; return self ; } 
function ( parentNode , html ) { var arr = wrapMap [ parentNode . tagName . toLowerCase ( ) ] || wrapMap . _default ; var depth = arr [ 0 ] , start = arr [ 1 ] , end = arr [ 2 ] ; if ( needsShy ) { html = '&shy;' + html ; } var element = document . createElement ( 'div' ) ; setInnerHTML ( element , start + html + end ) ; for ( var i = 0 ; i <= depth ; i ++ ) { element = element . firstChild ; } 
function ( start , end ) { if ( start . parentNode !== end . parentNode ) { end . parentNode . insertBefore ( start , end . parentNode . firstChild ) ; } } 
function evaluateUnboundHelper ( context , fn , normalizedProperties , options ) { var args = [ ] , hash = options . hash , boundOptions = hash . boundOptions , types = slice . call ( options . types , 1 ) , loc , len , property , propertyType , boundOption ; for ( boundOption in boundOptions ) { if ( ! boundOptions . hasOwnProperty ( boundOption ) ) { continue ; } hash [ boundOption ] = Ember . Handlebars . get ( context , boundOptions [ boundOption ] , options ) ; } for ( loc = 0 , len = normalizedProperties . length ; loc < len ; ++ loc ) { property = normalizedProperties [ loc ] ; propertyType = types [ loc ] ; if ( propertyType === "ID" ) { args . push ( Ember . Handlebars . get ( property . root , property . path , options ) ) ; } else { args . push ( property . path ) ; } } args . push ( options ) ; return fn . apply ( context , args ) ; } 
function ( view ) { var morph = view . morph ; view . transitionTo ( 'preRender' ) ; Ember . run . schedule ( 'render' , this , function renderMetamorphView ( ) { if ( view . isDestroying ) { return ; } view . clearRenderedChildren ( ) ; var buffer = view . renderToBuffer ( ) ; view . invokeRecursively ( function ( view ) { view . propertyWillChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'willInsertElement' ) ; morph . replaceWith ( buffer . string ( ) ) ; view . transitionTo ( 'inDOM' ) ; view . invokeRecursively ( function ( view ) { view . propertyDidChange ( 'element' ) ; } ) ; view . triggerRecursively ( 'didInsertElement' ) ; notifyMutationListeners ( ) ; } ) ; } 
function bind ( property , options , preserveContext , shouldDisplay , valueNormalizer , childProperties ) { var data = options . data , fn = options . fn , inverse = options . inverse , view = data . view , currentContext = this , normalized , observer , i ; normalized = normalizePath ( currentContext , property , data ) ; 
function ( path , data ) { var normalized = Ember . Handlebars . normalizePath ( null , path , data ) ; if ( normalized . isKeyword ) { return 'templateData.keywords.' + path ; } else if ( Ember . isGlobalPath ( path ) ) { return null ; } else if ( path === 'this' || path === '' ) { return '_parentView.context' ; } else { return '_parentView.context.' + path ; } } 
function _addMetamorphCheck ( ) { Ember . Handlebars . EachView . reopen ( { _checkMetamorph : Ember . on ( 'didInsertElement' , function ( ) { Ember . assert ( "The metamorph tags, " + this . morph . start + " and " + this . morph . end + ", have different parents.\nThe browser has fixed your template to output valid HTML (for example, check that you have properly closed all tags and have used a TBODY tag when creating a table with '{{#each}}')" , document . getElementById ( this . morph . start ) . parentNode === document . getElementById ( this . morph . end ) . parentNode ) ; } ) } ) ; } 
function ( intent , isIntermediate ) { var wasTransitioning = ! ! this . activeTransition ; var oldState = wasTransitioning ? this . activeTransition . state : this . state ; var newTransition ; var router = this ; try { var newState = intent . applyToState ( oldState , this . recognizer , this . getHandler , isIntermediate ) ; if ( handlerInfosEqual ( newState . handlerInfos , oldState . handlerInfos ) ) { 
function ( ) { if ( this . state ) { forEach ( this . state . handlerInfos , function ( handlerInfo ) { var handler = handlerInfo . handler ; if ( handler . exit ) { handler . exit ( ) ; } } ) ; } this . state = new TransitionState ( ) ; this . currentHandlerInfos = null ; } 
function ( url ) { 
function setupContexts ( router , newState , transition ) { var partition = partitionHandlers ( router . state , newState ) ; forEach ( partition . exited , function ( handlerInfo ) { var handler = handlerInfo . handler ; delete handler . context ; if ( handler . exit ) { handler . exit ( ) ; } } ) ; var oldState = router . oldState = router . state ; router . state = newState ; var currentHandlerInfos = router . currentHandlerInfos = partition . unchanged . slice ( ) ; try { forEach ( partition . updatedContext , function ( handlerInfo ) { return handlerEnteredOrUpdated ( currentHandlerInfos , handlerInfo , false , transition ) ; } ) ; forEach ( partition . entered , function ( handlerInfo ) { return handlerEnteredOrUpdated ( currentHandlerInfos , handlerInfo , true , transition ) ; } ) ; } catch ( e ) { router . state = oldState ; router . currentHandlerInfos = oldState . handlerInfos ; throw e ; } router . state . queryParams = finalizeQueryParamChange ( router , currentHandlerInfos , newState . queryParams ) ; } 
function handlerEnteredOrUpdated ( currentHandlerInfos , handlerInfo , enter , transition ) { var handler = handlerInfo . handler , context = handlerInfo . context ; if ( enter && handler . enter ) { handler . enter ( transition ) ; } if ( transition && transition . isAborted ) { throw new TransitionAborted ( ) ; } handler . context = context ; if ( handler . contextDidChange ) { handler . contextDidChange ( ) ; } if ( handler . setup ) { handler . setup ( context , transition ) ; } if ( transition && transition . isAborted ) { throw new TransitionAborted ( ) ; } currentHandlerInfos . push ( handlerInfo ) ; return true ; } 
function doTransition ( router , args , isIntermediate ) { 
function ( ) { if ( this . isAborted ) { return this ; } log ( this . router , this . sequence , this . targetName + ": transition was aborted" ) ; this . isAborted = true ; this . isActive = false ; this . router . activeTransition = null ; return this ; } 
function ( ) { var router = this . router ; return this . promise [ 'catch' ] ( function ( reason ) { if ( router . activeTransition ) { return router . activeTransition . followRedirects ( ) ; } return reject ( reason ) ; } ) ; } 
function extractQueryParams ( array ) { var len = ( array && array . length ) , head , queryParams ; if ( len && len > 0 && array [ len - 1 ] && array [ len - 1 ] . hasOwnProperty ( 'queryParams' ) ) { queryParams = array [ len - 1 ] . queryParams ; head = slice . call ( array , 0 , len - 1 ) ; return [ head , queryParams ] ; } else { return [ array , null ] ; } } 
function serialize ( handler , model , names ) { var object = { } ; if ( isParam ( model ) ) { object [ names [ 0 ] ] = model ; return object ; } 
function ( ) { this . router = this . router || this . constructor . map ( Ember . K ) ; var router = this . router , location = get ( this , 'location' ) , container = this . container , self = this , initialURL = get ( this , 'initialURL' ) ; 
function ( results , queryParams , callback ) { for ( var name in queryParams ) { var parts = name . split ( ':' ) ; var controller = controllerOrProtoFor ( parts [ 0 ] , this . container ) ; Ember . assert ( fmt ( "Could not lookup controller '%@' while setting up query params" , [ controller ] ) , controller ) ; 
function ( context , transition ) { var controllerName = this . controllerName || this . routeName , controller = this . controllerFor ( controllerName , true ) ; if ( ! controller ) { controller = this . generateController ( controllerName , context ) ; } 
function ( params , transition ) { var match , name , sawParams , value ; for ( var prop in params ) { if ( prop === 'queryParams' ) { continue ; } if ( match = prop . match ( / ^(.*)_id$ / ) ) { name = match [ 1 ] ; value = params [ prop ] ; } sawParams = true ; } if ( ! name && sawParams ) { return Ember . copy ( params ) ; } else if ( ! name ) { if ( transition . resolveIndex !== transition . state . handlerInfos . length - 1 ) { return ; } var parentModel = transition . state . handlerInfos [ transition . resolveIndex - 1 ] . context ; return parentModel ; } return this . findModel ( name , value ) ; } 
function ( model , params ) { if ( params . length < 1 ) { return ; } if ( ! model ) { return ; } var name = params [ 0 ] , object = { } ; if ( / _id$ / . test ( name ) && params . length === 1 ) { object [ name ] = get ( model , "id" ) ; } else { object = getProperties ( model , params ) ; } return object ; } 
function ( name , _skipAssert ) { var container = this . container , route = container . lookup ( 'route:' + name ) , controller ; if ( route && route . controllerName ) { name = route . controllerName ; } controller = container . lookup ( 'controller:' + name ) ; 
function ( options ) { if ( ! options || typeof options === "string" ) { var outletName = options ; options = { } ; options . outlet = outletName ; } options . parentView = options . parentView ? options . parentView . replace ( / \/ / g , '.' ) : parentTemplate ( this ) ; options . outlet = options . outlet || 'main' ; var parentView = this . router . _lookupActiveView ( options . parentView ) ; if ( parentView ) { parentView . disconnectOutlet ( options . outlet ) ; } } 
function ( ) { 
function ( ) { var helperParameters = this . parameters , linkTextPath = helperParameters . options . linkTextPath , paths = getResolvedPaths ( helperParameters ) , length = paths . length , path , i , normalizedPath ; if ( linkTextPath ) { normalizedPath = Ember . Handlebars . normalizePath ( helperParameters . context , linkTextPath , helperParameters . options . data ) ; this . registerObserver ( normalizedPath . root , normalizedPath . path , this , this . rerender ) ; } for ( i = 0 ; i < length ; i ++ ) { path = paths [ i ] ; if ( null === path ) { 
function ( event ) { if ( ! isSimpleClick ( event ) ) { return true ; } if ( this . preventDefault !== false ) { event . preventDefault ( ) ; } if ( this . bubbles === false ) { event . stopPropagation ( ) ; } if ( get ( this , '_isDisabled' ) ) { return false ; } if ( get ( this , 'loading' ) ) { Ember . Logger . warn ( "This link-to is in an inactive loading state because at least one of its parameters presently has a null/undefined value, or the provided route name is invalid." ) ; return false ; } var router = get ( this , 'router' ) , routeArgs = get ( this , 'routeArgs' ) ; var transition ; if ( get ( this , 'replace' ) ) { transition = router . replaceWith . apply ( router , routeArgs ) ; } else { transition = router . transitionTo . apply ( router , routeArgs ) ; } 
function ( ) { 
function ( ) { 
function ( outletName , view ) { var existingView = get ( this , '_outlets.' + outletName ) ; return existingView && existingView . constructor === view . constructor && existingView . get ( 'template' ) === view . get ( 'template' ) && existingView . get ( 'context' ) === view . get ( 'context' ) ; } 
function ( ) { if ( this . isDestroyed ) return ; 
function ( ) { 
function ( path ) { var state = { path : path } ; get ( this , 'history' ) . replaceState ( state , null , path ) ; 
function ( callback ) { var guid = Ember . guidFor ( this ) , self = this ; Ember . $ ( window ) . on ( 'popstate.ember-location-' + guid , function ( e ) { 
function ( ) { 
function ( ) { var window = this . _window , documentMode = window . document . documentMode ; return ( 'onhashchange' in window && ( documentMode === undefined || documentMode > 7 ) ) ; } 
function ( options ) { if ( options && options . rootURL ) { Ember . assert ( 'rootURL must end with a trailing forward slash e.g. "/app/"' , options . rootURL . charAt ( options . rootURL . length - 1 ) === '/' ) ; this . rootURL = options . rootURL ; } var historyPath , hashPath , cancelRouterSetup = false , implementationClass = this . _NoneLocation , currentPath = this . _getFullPath ( ) ; if ( this . _getSupportsHistory ( ) ) { historyPath = this . _getHistoryPath ( ) ; 
function ( fullName ) { var parsedName = this . parseName ( fullName ) , resolveMethodName = parsedName . resolveMethodName ; if ( ! ( parsedName . name && parsedName . type ) ) { throw new TypeError ( "Invalid fullName: `" + fullName + "`, must be of the form `type:name` " ) ; } if ( this [ resolveMethodName ] ) { var resolved = this [ resolveMethodName ] ( parsedName ) ; if ( resolved ) { return resolved ; } } return this . resolveOther ( parsedName ) ; } 
function ( fullName ) { var nameParts = fullName . split ( ":" ) , type = nameParts [ 0 ] , fullNameWithoutType = nameParts [ 1 ] , name = fullNameWithoutType , namespace = get ( this , 'namespace' ) , root = namespace ; if ( type !== 'template' && name . indexOf ( '/' ) !== - 1 ) { var parts = name . split ( '/' ) ; name = parts [ parts . length - 1 ] ; var namespaceName = capitalize ( parts . slice ( 0 , - 1 ) . join ( '.' ) ) ; root = Ember . Namespace . byName ( namespaceName ) ; Ember . assert ( 'You are looking for a ' + name + ' ' + type + ' in the ' + namespaceName + ' namespace, but the namespace could not be found' , root ) ; } return { fullName : fullName , type : type , fullNameWithoutType : fullNameWithoutType , name : name , root : root , resolveMethodName : "resolve" + classify ( type ) } ; } 
function ( parsedName ) { var templateName = parsedName . fullNameWithoutType . replace ( / \. / g , '/' ) ; if ( Ember . TEMPLATES [ templateName ] ) { return Ember . TEMPLATES [ templateName ] ; } templateName = decamelize ( templateName ) ; if ( Ember . TEMPLATES [ templateName ] ) { return Ember . TEMPLATES [ templateName ] ; } } 
function ( ) { if ( this . Router === false ) { return ; } var container = this . __container__ ; if ( this . Router ) { container . unregister ( 'router:main' ) ; container . register ( 'router:main' , this . Router ) ; } return container . lookupFactory ( 'router:main' ) ; } 
function ( ) { var self = this ; if ( ! this . $ || this . $ . isReady ) { Ember . run . schedule ( 'actions' , self , '_initialize' ) ; } else { this . $ ( ) . ready ( function runInitialize ( ) { Ember . run ( self , '_initialize' ) ; } ) ; } } 
function ( ) { Ember . assert ( "You must call advanceReadiness on an instance of Ember.Application" , this instanceof Ember . Application ) ; this . _readinessDeferrals -- ; if ( this . _readinessDeferrals === 0 ) { Ember . run . once ( this , this . didBecomeReady ) ; } } 
function ( ) { this . _readinessDeferrals = 1 ; function handleReset ( ) { var router = this . __container__ . lookup ( 'router:main' ) ; router . reset ( ) ; Ember . run ( this . __container__ , 'destroy' ) ; this . buildContainer ( ) ; Ember . run . schedule ( 'actions' , this , function ( ) { this . _initialize ( ) ; } ) ; } Ember . run . join ( this , handleReset ) ; } 
function ( ) { var customEvents = get ( this , 'customEvents' ) , rootElement = get ( this , 'rootElement' ) , dispatcher = this . __container__ . lookup ( 'event_dispatcher:main' ) ; set ( this , 'eventDispatcher' , dispatcher ) ; dispatcher . setup ( customEvents , rootElement ) ; } 
function ( namespace ) { var container = new Ember . Container ( ) ; Ember . Container . defaultContainer = new DeprecatedContainer ( container ) ; container . set = Ember . set ; container . resolver = resolverFor ( namespace ) ; container . normalize = container . resolver . normalize ; container . describe = container . resolver . describe ; container . makeToString = container . resolver . makeToString ; container . optionsForType ( 'component' , { singleton : false } ) ; container . optionsForType ( 'view' , { singleton : false } ) ; container . optionsForType ( 'template' , { instantiate : false } ) ; container . optionsForType ( 'helper' , { instantiate : false } ) ; container . register ( 'application:main' , namespace , { instantiate : false } ) ; container . register ( 'controller:basic' , Ember . Controller , { instantiate : false } ) ; container . register ( 'controller:object' , Ember . ObjectController , { instantiate : false } ) ; container . register ( 'controller:array' , Ember . ArrayController , { instantiate : false } ) ; container . register ( 'route:basic' , Ember . Route , { instantiate : false } ) ; container . register ( 'event_dispatcher:main' , Ember . EventDispatcher ) ; container . register ( 'router:main' , Ember . Router ) ; container . injection ( 'router:main' , 'namespace' , 'application:main' ) ; container . register ( 'location:auto' , Ember . AutoLocation ) ; container . register ( 'location:hash' , Ember . HashLocation ) ; container . register ( 'location:history' , Ember . HistoryLocation ) ; container . register ( 'location:none' , Ember . NoneLocation ) ; container . injection ( 'controller' , 'target' , 'router:main' ) ; container . injection ( 'controller' , 'namespace' , 'application:main' ) ; container . injection ( 'route' , 'router' , 'router:main' ) ; container . injection ( 'location' , 'rootURL' , '-location-setting:root-url' ) ; 
function ( type , recordsAdded , recordsUpdated , recordsRemoved ) { var self = this , releaseMethods = Ember . A ( ) , records = this . getRecords ( type ) , release ; var recordUpdated = function ( updatedRecord ) { recordsUpdated ( [ updatedRecord ] ) ; } ; var recordsToSend = records . map ( function ( record ) { releaseMethods . push ( self . observeRecord ( record , recordUpdated ) ) ; return self . wrapRecord ( record ) ; } ) ; var contentDidChange = function ( array , idx , removedCount , addedCount ) { for ( var i = idx ; i < idx + addedCount ; i ++ ) { var record = array . objectAt ( i ) ; var wrapped = self . wrapRecord ( record ) ; releaseMethods . push ( self . observeRecord ( record , recordUpdated ) ) ; recordsAdded ( [ wrapped ] ) ; } if ( removedCount ) { recordsRemoved ( idx , removedCount ) ; } } ; var observer = { didChange : contentDidChange , willChange : Ember . K } ; records . addArrayObserver ( self , observer ) ; release = function ( ) { releaseMethods . forEach ( function ( fn ) { fn ( ) ; } ) ; records . removeArrayObserver ( self , observer ) ; self . releaseMethods . removeObject ( release ) ; } ; recordsAdded ( recordsToSend ) ; this . releaseMethods . pushObject ( release ) ; return release ; } 
function ( type , typesUpdated ) { var self = this , records = this . getRecords ( type ) ; var onChange = function ( ) { typesUpdated ( [ self . wrapModelType ( type ) ] ) ; } ; var observer = { didChange : function ( ) { Ember . run . scheduleOnce ( 'actions' , this , onChange ) ; } , willChange : Ember . K } ; records . addArrayObserver ( this , observer ) ; var release = function ( ) { records . removeArrayObserver ( self , observer ) ; } ; return release ; } 
function ( ) { var namespaces = Ember . A ( Ember . Namespace . NAMESPACES ) , types = Ember . A ( ) ; namespaces . forEach ( function ( namespace ) { for ( var key in namespace ) { if ( ! namespace . hasOwnProperty ( key ) ) { continue ; } var name = Ember . String . dasherize ( key ) ; if ( ! ( namespace instanceof Ember . Application ) && namespace . toString ( ) ) { name = namespace + '/' + name ; } types . push ( name ) ; } } ) ; return types ; } 
function ( context , callback ) { if ( arguments . length === 1 ) { callback = context ; context = null ; } if ( ! this . waiters ) { this . waiters = Ember . A ( ) ; } this . waiters . push ( [ context , callback ] ) ; } 
function ( context , callback ) { var pair ; if ( ! this . waiters ) { return ; } if ( arguments . length === 1 ) { callback = context ; context = null ; } pair = [ context , callback ] ; this . waiters = Ember . A ( this . waiters . filter ( function ( elt ) { return Ember . compare ( elt , pair ) !== 0 ; } ) ) ; } 
function ( helperContainer ) { if ( helperContainer ) { this . helperContainer = helperContainer ; } this . testHelpers = { } ; for ( var name in helpers ) { this . originalMethods [ name ] = this . helperContainer [ name ] ; this . testHelpers [ name ] = this . helperContainer [ name ] = helper ( this , name ) ; protoWrap ( Ember . Test . Promise . prototype , name , helper ( this , name ) , helpers [ name ] . meta . wait ) ; } for ( var i = 0 , l = injectHelpersCallbacks . length ; i < l ; i ++ ) { injectHelpersCallbacks [ i ] ( this ) ; } } 
function ( ) { for ( var name in helpers ) { this . helperContainer [ name ] = this . originalMethods [ name ] ; delete this . testHelpers [ name ] ; delete this . originalMethods [ name ] ; } } 
function protoWrap ( proto , name , callback , isAsync ) { proto [ name ] = function ( ) { var args = arguments ; if ( isAsync ) { return callback . apply ( this , args ) ; } else { return this . then ( function ( ) { return callback . apply ( this , args ) ; } ) ; } } ; } 
function cleanerEval ( str , oldConsole ) { var logArr = [ ] ; var console = { log : function ( msg ) { logArr . push ( msg ) ; oldConsole . log ( msg ) ; } } ; eval ( str ) ; return logArr ; } 
function toPropertyDescriptor ( obj ) { if ( Object ( obj ) !== obj ) { throw new TypeError ( "property descriptor should be an Object, given: " + obj ) ; } var desc = { } ; if ( 'enumerable' in obj ) { desc . enumerable = ! ! obj . enumerable ; } if ( 'configurable' in obj ) { desc . configurable = ! ! obj . configurable ; } if ( 'value' in obj ) { desc . value = obj . value ; } if ( 'writable' in obj ) { desc . writable = ! ! obj . writable ; } if ( 'get' in obj ) { var getter = obj . get ; if ( getter !== undefined && typeof getter !== "function" ) { throw new TypeError ( "property descriptor 'get' attribute must be " + "callable or undefined, given: " + getter ) ; } desc . get = getter ; } if ( 'set' in obj ) { var setter = obj . set ; if ( setter !== undefined && typeof setter !== "function" ) { throw new TypeError ( "property descriptor 'set' attribute must be " + "callable or undefined, given: " + setter ) ; } desc . set = setter ; } if ( 'get' in desc || 'set' in desc ) { if ( 'value' in desc || 'writable' in desc ) { throw new TypeError ( "property descriptor cannot be both a data and an " + "accessor descriptor: " + obj ) ; } } return desc ; } 
function normalizeAndCompletePropertyDescriptor ( attributes ) { if ( attributes === undefined ) { return undefined ; } var desc = toCompletePropertyDescriptor ( attributes ) ; 
function normalizePropertyDescriptor ( attributes ) { var desc = toPropertyDescriptor ( attributes ) ; 
function isCompatibleDescriptor ( extensible , current , desc ) { if ( current === undefined && extensible === false ) { return false ; } if ( current === undefined && extensible === true ) { return true ; } if ( isEmptyDescriptor ( desc ) ) { return true ; } if ( isEquivalentDescriptor ( current , desc ) ) { return true ; } if ( current . configurable === false ) { if ( desc . configurable === true ) { return false ; } if ( 'enumerable' in desc && desc . enumerable !== current . enumerable ) { return false ; } } if ( isGenericDescriptor ( desc ) ) { return true ; } if ( isDataDescriptor ( current ) !== isDataDescriptor ( desc ) ) { if ( current . configurable === false ) { return false ; } return true ; } if ( isDataDescriptor ( current ) && isDataDescriptor ( desc ) ) { if ( current . configurable === false ) { if ( current . writable === false && desc . writable === true ) { return false ; } if ( current . writable === false ) { if ( 'value' in desc && ! sameValue ( desc . value , current . value ) ) { return false ; } } } return true ; } if ( isAccessorDescriptor ( current ) && isAccessorDescriptor ( desc ) ) { if ( current . configurable === false ) { if ( 'set' in desc && ! sameValue ( desc . set , current . set ) ) { return false ; } if ( 'get' in desc && ! sameValue ( desc . get , current . get ) ) { return false ; } } } return true ; } 
function ( trapName ) { var trap = this . handler [ trapName ] ; if ( trap === undefined ) { 
function ( name ) { "use strict" ; var trap = this . getTrap ( "getOwnPropertyDescriptor" ) ; if ( trap === undefined ) { return Reflect . getOwnPropertyDescriptor ( this . target , name ) ; } name = String ( name ) ; var desc = trap . call ( this . handler , this . target , name ) ; desc = normalizeAndCompletePropertyDescriptor ( desc ) ; var targetDesc = Object . getOwnPropertyDescriptor ( this . target , name ) ; var extensible = Object . isExtensible ( this . target ) ; if ( desc === undefined ) { if ( isSealedDesc ( targetDesc ) ) { throw new TypeError ( "cannot report non-configurable property '" + name + "' as non-existent" ) ; } if ( ! extensible && targetDesc !== undefined ) { 
function ( name ) { var handler = this ; if ( ! handler . has ( name ) ) return undefined ; return { get : function ( ) { return handler . get ( this , name ) ; } , set : function ( val ) { if ( handler . set ( this , name , val ) ) { return val ; } else { throw new TypeError ( "failed assignment to " + name ) ; } } , enumerable : true , configurable : true } ; } 
function ( ) { var trap = this . getTrap ( "freeze" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "seal" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "preventExtensions" ) ; if ( trap === undefined ) { 
function ( name ) { "use strict" ; var trap = this . getTrap ( "deleteProperty" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "isExtensible" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "getPrototypeOf" ) ; if ( trap === undefined ) { 
function ( newProto ) { var trap = this . getTrap ( "setPrototypeOf" ) ; if ( trap === undefined ) { 
function ( name ) { "use strict" ; var trap = this . getTrap ( "hasOwn" ) ; if ( trap === undefined ) { 
function ( receiver , name ) { if (name === '__noSuchMethod__') { var handler = this; return function(name, args) { return handler.invoke(receiver, name, args); } } */ var trap = this . getTrap ( "get" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "iterate" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "keys" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "ownKeys" ) ; if ( trap === undefined ) { 
function ( target , thisBinding , args ) { var trap = this . getTrap ( "apply" ) ; if ( trap === undefined ) { return Reflect . apply ( target , thisBinding , args ) ; } if ( typeof this . target === "function" ) { return trap . call ( this . handler , target , thisBinding , args ) ; } else { throw new TypeError ( "apply: " + target + " is not a function" ) ; } } 
function ( target , args ) { var trap = this . getTrap ( "construct" ) ; if ( trap === undefined ) { return Reflect . construct ( target , args ) ; } if ( typeof this . target === "function" ) { return trap . call ( this . handler , target , args ) ; } else { throw new TypeError ( "new: " + target + " is not a function" ) ; } } 
function ( ) { var trap = this . getTrap ( "isSealed" ) ; if ( trap === undefined ) { 
function ( ) { var trap = this . getTrap ( "isFrozen" ) ; if ( trap === undefined ) { 
function makeUnwrapping0ArgMethod ( primitive ) { return function builtin ( ) { var vHandler = safeWeakMapGet ( directProxies , this ) ; if ( vHandler !== undefined ) { return builtin . call ( vHandler . target ) ; } else { return primitive . call ( this ) ; } } } 
function ( target ) { var handler = directProxies . get ( target ) ; if ( handler !== undefined ) { return handler . ownKeys ( handler . target ) ; } var result = Reflect . getOwnPropertyNames ( target ) ; var l = + result . length ; var idx = 0 ; return { next : function ( ) { if ( idx === l ) throw StopIteration ; return result [ idx ++ ] ; } } ; } 
function ( target ) { var success = this . preventExtensions ( target ) ; success = ! ! success ; 
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; return vHandler . apply ( target , this , args ) ; } 
function load ( obj ) { var name , root ; root = typeof global !== "undefined" && global !== null ? global : this ; for ( name in obj ) { if ( obj . hasOwnProperty ( name ) ) { root [ name ] = obj [ name ] ; } } } 
function ( type , data ) { type . eachTransformedAttribute ( function ( key , type ) { var transform = this . transformFor ( type ) ; data [ key ] = transform . deserialize ( data [ key ] ) ; } , this ) ; return data ; } 
function ( record , options ) { var json = { } ; if ( options && options . includeId ) { var id = get ( record , 'id' ) ; if ( id ) { json [ get ( this , 'primaryKey' ) ] = id ; } } record . eachAttribute ( function ( key , attribute ) { this . serializeAttribute ( record , json , key , attribute ) ; } , this ) ; record . eachRelationship ( function ( key , relationship ) { if ( relationship . kind === 'belongsTo' ) { this . serializeBelongsTo ( record , json , relationship ) ; } else if ( relationship . kind === 'hasMany' ) { this . serializeHasMany ( record , json , relationship ) ; } } , this ) ; return json ; } 
function ( record , json , key , attribute ) { var attrs = get ( this , 'attrs' ) ; var value = get ( record , key ) , type = attribute . type ; if ( type ) { var transform = this . transformFor ( type ) ; value = transform . serialize ( value ) ; } 
function ( record , json , relationship ) { var key = relationship . key ; var belongsTo = get ( record , key ) ; key = this . keyForRelationship ? this . keyForRelationship ( key , "belongsTo" ) : key ; if ( isNone ( belongsTo ) ) { json [ key ] = belongsTo ; } else { json [ key ] = get ( belongsTo , 'id' ) ; } if ( relationship . options . polymorphic ) { this . serializePolymorphicType ( record , json , relationship ) ; } } 
function ( record , json , relationship ) { var key = relationship . key ; var relationshipType = DS . RelationshipChange . determineRelationshipType ( record . constructor , relationship ) ; if ( relationshipType === 'manyToNone' || relationshipType === 'manyToMany' ) { json [ key ] = get ( record , key ) . mapBy ( 'id' ) ; 
function ( store , type , payload , id , requestType ) { this . extractMeta ( store , type , payload ) ; var specificExtract = "extract" + requestType . charAt ( 0 ) . toUpperCase ( ) + requestType . substr ( 1 ) ; return this [ specificExtract ] ( store , type , payload , id , requestType ) ; } 
function ( store , type , payload ) { if ( payload && payload . meta ) { store . metaForType ( type , payload . meta ) ; delete payload . meta ; } } 
function ( attributeType , skipAssertion ) { var transform = this . container . lookup ( 'transform:' + attributeType ) ; Ember . assert ( "Unable to find transform for '" + attributeType + "'" , skipAssertion || ! ! transform ) ; return transform ; } 
function ( ) { var promiseLabel = "DS: RecordArray#save " + get ( this , 'type' ) ; var promise = Ember . RSVP . all ( this . invoke ( "save" ) , promiseLabel ) . then ( function ( array ) { return Ember . A ( array ) ; } , null , "DS: RecordArray#save apply Ember.NativeArray" ) ; return DS . PromiseArray . create ( { promise : promise } ) ; } 
function ( index , removed , added ) { 
function ( hash ) { var owner = get ( this , 'owner' ) , store = get ( owner , 'store' ) , type = get ( this , 'type' ) , record ; Ember . assert ( "You cannot add '" + type . typeKey + "' records to this polymorphic relationship." , ! get ( this , 'isPolymorphic' ) ) ; record = store . createRecord . call ( store , type , hash ) ; this . pushObject ( record ) ; return record ; } 
function ( type , properties ) { type = this . modelFor ( type ) ; properties = copy ( properties ) || { } ; 
function ( type ) { var adapter = this . adapterFor ( type ) ; if ( adapter && adapter . generateIdForRecord ) { return adapter . generateIdForRecord ( this ) ; } return null ; } 
function ( type , id ) { if ( id === undefined ) { return this . findAll ( type ) ; } 
function ( type , id ) { type = this . modelFor ( type ) ; var record = this . recordForId ( type , id ) ; var promise = this . fetchRecord ( record ) || resolve ( record , "DS: Store#findById " + type + " with id: " + id ) ; return promiseObject ( promise ) ; } 
function ( type , ids ) { var store = this ; var promiseLabel = "DS: Store#findByIds " + type ; return promiseArray ( Ember . RSVP . all ( map ( ids , function ( id ) { return store . findById ( type , id ) ; } ) ) . then ( Ember . A , null , "DS: Store#findByIds of " + type + " complete" ) ) ; } 
function ( record ) { if ( isNone ( record ) ) { return null ; } if ( record . _loadingPromise ) { return record . _loadingPromise ; } if ( ! get ( record , 'isEmpty' ) ) { return null ; } var type = record . constructor , id = get ( record , 'id' ) ; var adapter = this . adapterFor ( type ) ; Ember . assert ( "You tried to find a record but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to find a record but your adapter (for " + type + ") does not implement 'find'" , adapter . find ) ; var promise = _find ( adapter , this , type , id ) ; record . loadingData ( promise ) ; return promise ; } 
function ( record ) { var type = record . constructor , adapter = this . adapterFor ( type ) , id = get ( record , 'id' ) ; Ember . assert ( "You cannot reload a record without an ID" , id ) ; Ember . assert ( "You tried to reload a record but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to reload a record but your adapter does not implement `find`" , adapter . find ) ; return _find ( adapter , this , type , id ) ; } 
function ( records , owner , resolver ) { if ( ! records . length ) { return ; } 
function ( type , id ) { id = coerceId ( id ) ; type = this . modelFor ( type ) ; return ! ! this . typeMapFor ( type ) . idToRecord [ id ] ; } 
function ( type , id ) { type = this . modelFor ( type ) ; id = coerceId ( id ) ; var record = this . typeMapFor ( type ) . idToRecord [ id ] ; if ( ! record ) { record = this . buildRecord ( type , id ) ; } return record ; } 
function ( owner , link , relationship , resolver ) { var adapter = this . adapterFor ( owner . constructor ) ; Ember . assert ( "You tried to load a hasMany relationship but you have no adapter (for " + owner . constructor + ")" , adapter ) ; Ember . assert ( "You tried to load a hasMany relationship from a specified `link` in the original payload but your adapter does not implement `findHasMany`" , adapter . findHasMany ) ; var records = this . recordArrayManager . createManyArray ( relationship . type , Ember . A ( [ ] ) ) ; resolver . resolve ( _findHasMany ( adapter , this , owner , link , relationship ) ) ; return records ; } 
function ( type , query ) { type = this . modelFor ( type ) ; var array = this . recordArrayManager . createAdapterPopulatedRecordArray ( type , query ) ; var adapter = this . adapterFor ( type ) , promiseLabel = "DS: Store#findQuery " + type , resolver = Ember . RSVP . defer ( promiseLabel ) ; Ember . assert ( "You tried to load a query but you have no adapter (for " + type + ")" , adapter ) ; Ember . assert ( "You tried to load a query but your adapter does not implement `findQuery`" , adapter . findQuery ) ; resolver . resolve ( _findQuery ( adapter , this , type , query , array ) ) ; return promiseArray ( resolver . promise ) ; } 
function ( type ) { type = this . modelFor ( type ) ; var typeMap = this . typeMapFor ( type ) , findAllCache = typeMap . findAllCache ; if ( findAllCache ) { return findAllCache ; } var array = this . recordArrayManager . createRecordArray ( type ) ; typeMap . findAllCache = array ; return array ; } 
function ( type ) { type = this . modelFor ( type ) ; var typeMap = this . typeMapFor ( type ) , records = typeMap . records , record ; while ( record = records . pop ( ) ) { record . unloadRecord ( ) ; } typeMap . findAllCache = null ; } 
function ( type , query , filter ) { var promise ; 
function ( type , id ) { if ( ! this . hasRecordForId ( type , id ) ) { return false ; } return ! get ( this . recordForId ( type , id ) , 'isEmpty' ) ; } 
function ( ) { var pending = this . _pendingSave . slice ( ) ; this . _pendingSave = [ ] ; forEach ( pending , function ( tuple ) { var record = tuple [ 0 ] , resolver = tuple [ 1 ] , adapter = this . adapterFor ( record . constructor ) , operation ; if ( get ( record , 'isNew' ) ) { operation = 'createRecord' ; } else if ( get ( record , 'isDeleted' ) ) { operation = 'deleteRecord' ; } else { operation = 'updateRecord' ; } resolver . resolve ( _commit ( adapter , this , operation , record ) ) ; } , this ) ; } 
function ( record , data ) { if ( data ) { 
function ( record , data ) { var oldId = get ( record , 'id' ) , id = coerceId ( data . id ) ; Ember . assert ( "An adapter cannot assign a new id to a record that already has an id. " + record + " had id: " + oldId + " and you tried to update it with " + id + ". This likely happened because your server returned data in response to a find or update that had a different id than the one you sent." , oldId === null || id === oldId ) ; this . typeMapFor ( record . constructor ) . idToRecord [ id ] = record ; set ( record , 'id' , id ) ; } 
function ( type ) { var typeMaps = get ( this , 'typeMaps' ) , guid = Ember . guidFor ( type ) , typeMap ; typeMap = typeMaps [ guid ] ; if ( typeMap ) { return typeMap ; } typeMap = { idToRecord : { } , records : [ ] , metadata : { } } ; typeMaps [ guid ] = typeMap ; return typeMap ; } 
function ( type , data , partial ) { var id = coerceId ( data . id ) , record = this . recordForId ( type , id ) ; record . setupData ( data , partial ) ; this . recordArrayManager . recordDidChange ( record ) ; return record ; } 
function ( key ) { var factory ; if ( typeof key === 'string' ) { var normalizedKey = this . container . normalize ( 'model:' + key ) ; factory = this . container . lookupFactory ( normalizedKey ) ; if ( ! factory ) { throw new Ember . Error ( "No model was found for '" + key + "'" ) ; } factory . typeKey = normalizedKey . split ( ':' , 2 ) [ 1 ] ; } else { 
function ( type , data , _partial ) { 
function ( type , payload ) { var serializer ; if ( ! payload ) { payload = type ; serializer = defaultSerializer ( this . container ) ; Ember . assert ( "You cannot use `store#pushPayload` without a type unless your default serializer defines `pushPayload`" , serializer . pushPayload ) ; } else { serializer = this . serializerFor ( type ) ; } serializer . pushPayload ( this , payload ) ; } 
function ( type , metadata ) { type = this . modelFor ( type ) ; Ember . merge ( this . typeMapFor ( type ) . metadata , metadata ) ; } 
function ( type , id , data ) { var typeMap = this . typeMapFor ( type ) , idToRecord = typeMap . idToRecord ; Ember . assert ( 'The id ' + id + ' has already been used with another record of type ' + type . toString ( ) + '.' , ! id || ! idToRecord [ id ] ) ; 
function ( record ) { var type = record . constructor , typeMap = this . typeMapFor ( type ) , id = get ( record , 'id' ) ; record . updateRecordArrays ( ) ; if ( id ) { delete typeMap . idToRecord [ id ] ; } var loc = indexOf ( typeMap . records , record ) ; typeMap . records . splice ( loc , 1 ) ; } 
function ( childRecord , childKey , parentRecord , parentKey , change ) { var clientId = childRecord . clientId , parentClientId = parentRecord ? parentRecord : parentRecord ; var key = childKey + parentKey ; var changes = this . _relationshipChanges ; if ( ! ( clientId in changes ) ) { changes [ clientId ] = { } ; } if ( ! ( parentClientId in changes [ clientId ] ) ) { changes [ clientId ] [ parentClientId ] = { } ; } if ( ! ( key in changes [ clientId ] [ parentClientId ] ) ) { changes [ clientId ] [ parentClientId ] [ key ] = { } ; } changes [ clientId ] [ parentClientId ] [ key ] [ change . changeType ] = change ; } 
function ( type ) { var container = this . container , adapter ; if ( container ) { adapter = container . lookup ( 'adapter:' + type . typeKey ) || container . lookup ( 'adapter:application' ) ; } return adapter || get ( this , 'defaultAdapter' ) ; } 
function ( type ) { type = this . modelFor ( type ) ; var adapter = this . adapterFor ( type ) ; return serializerFor ( this . container , type . typeKey , adapter && adapter . defaultSerializer ) ; } 
function addUnsavedRecords ( record , key , data ) { if ( record ) { data . pushObjects ( record . get ( key ) . filterBy ( 'isNew' ) ) ; } } 
function ( object ) { 
function deepClone ( object ) { var clone = { } , value ; for ( var prop in object ) { value = object [ prop ] ; if ( value && typeof value === 'object' ) { clone [ prop ] = deepClone ( value ) ; } else { clone [ prop ] = value ; } } return clone ; } 
function ( attribute , messages ) { var wasEmpty = get ( this , 'isEmpty' ) ; messages = this . _findOrCreateMessages ( attribute , messages ) ; get ( this , 'content' ) . addObjects ( messages ) ; this . notifyPropertyChange ( attribute ) ; this . enumerableContentDidChange ( ) ; if ( wasEmpty && ! get ( this , 'isEmpty' ) ) { this . trigger ( 'becameInvalid' ) ; } } 
function ( attribute ) { if ( get ( this , 'isEmpty' ) ) { return ; } var content = get ( this , 'content' ) . rejectBy ( 'attribute' , attribute ) ; get ( this , 'content' ) . setObjects ( content ) ; this . notifyPropertyChange ( attribute ) ; this . enumerableContentDidChange ( ) ; if ( get ( this , 'isEmpty' ) ) { this . trigger ( 'becameValid' ) ; } } 
function ( options ) { 
function ( ) { var oldData = get ( this , '_data' ) , newData = get ( this , '_attributes' ) , diffData = { } , prop ; for ( prop in newData ) { diffData [ prop ] = [ oldData [ prop ] , newData [ prop ] ] ; } return diffData ; } 
function ( data ) { set ( this , 'isError' , false ) ; if ( data ) { this . _data = data ; } else { Ember . mixin ( this . _data , this . _inFlightAttributes ) ; } this . _inFlightAttributes = { } ; this . send ( 'didCommit' ) ; this . updateRecordArraysLater ( ) ; if ( ! data ) { return ; } this . suspendRelationshipObservers ( function ( ) { this . notifyPropertyChange ( 'data' ) ; } ) ; } 
function ( ) { this . _attributes = { } ; if ( get ( this , 'isError' ) ) { this . _inFlightAttributes = { } ; set ( this , 'isError' , false ) ; } if ( ! get ( this , 'isValid' ) ) { this . _inFlightAttributes = { } ; } this . send ( 'rolledBack' ) ; this . suspendRelationshipObservers ( function ( ) { this . notifyPropertyChange ( 'data' ) ; } ) ; } 
function ( callback , binding ) { var observers = get ( this . constructor , 'relationshipNames' ) . belongsTo ; var self = this ; try { this . _suspendedRelationships = true ; Ember . _suspendObservers ( self , observers , null , 'belongsToDidChange' , function ( ) { Ember . _suspendBeforeObservers ( self , observers , null , 'belongsToWillChange' , function ( ) { callback . call ( binding || self ) ; } ) ; } ) ; } finally { this . _suspendedRelationships = false ; } } 
function ( ) { var promiseLabel = "DS: Model#save " + this ; var resolver = Ember . RSVP . defer ( promiseLabel ) ; this . get ( 'store' ) . scheduleSave ( this , resolver ) ; this . _inFlightAttributes = this . _attributes ; this . _attributes = { } ; return DS . PromiseObject . create ( { promise : resolver . promise } ) ; } 
function ( ) { set ( this , 'isReloading' , true ) ; var record = this ; var promiseLabel = "DS: Model#reload of " + this ; var promise = new Ember . RSVP . Promise ( function ( resolve ) { record . send ( 'reloadRecord' , resolve ) ; } , promiseLabel ) . then ( function ( ) { record . set ( 'isReloading' , false ) ; record . set ( 'isError' , false ) ; return record ; } , function ( reason ) { record . set ( 'isError' , true ) ; throw reason ; } , "DS: Model#reload complete, update flags" ) ; return DS . PromiseObject . create ( { promise : promise } ) ; } 
function ( attributeName , value ) { 
function ( name ) { Ember . tryInvoke ( this , name , [ ] . slice . call ( arguments , 1 ) ) ; this . _super . apply ( this , arguments ) ; } 
function ( callback , binding ) { get ( this , 'attributes' ) . forEach ( function ( name , meta ) { callback . call ( binding , name , meta ) ; } , binding ) ; } 
function ( callback , binding ) { get ( this , 'transformedAttributes' ) . forEach ( function ( name , type ) { callback . call ( binding , name , type ) ; } ) ; } 
function ( proto , key , value ) { 
function ( callback , binding ) { get ( this , 'relationshipsByName' ) . forEach ( function ( name , relationship ) { callback . call ( binding , name , relationship ) ; } ) ; } 
function ( ) { forEach ( this . changedRecords , function ( record ) { if ( get ( record , 'isDeleted' ) ) { this . _recordWasDeleted ( record ) ; } else { this . _recordWasChanged ( record ) ; } } , this ) ; this . changedRecords = [ ] ; } 
function ( array , filter , type , record ) { var shouldBeInArray ; if ( ! filter ) { shouldBeInArray = true ; } else { shouldBeInArray = filter ( record ) ; } var recordArrays = this . recordArraysForRecord ( record ) ; if ( shouldBeInArray ) { recordArrays . add ( array ) ; array . addRecord ( record ) ; } else if ( ! shouldBeInArray ) { recordArrays . remove ( array ) ; array . removeRecord ( record ) ; } } 
function ( array , type , filter ) { var typeMap = this . store . typeMapFor ( type ) , records = typeMap . records , record ; for ( var i = 0 , l = records . length ; i < l ; i ++ ) { record = records [ i ] ; if ( ! get ( record , 'isDeleted' ) && ! get ( record , 'isEmpty' ) ) { this . updateRecordArray ( array , filter , type , record ) ; } } } 
function ( type , records ) { var manyArray = DS . ManyArray . create ( { type : type , content : records , store : this . store } ) ; forEach ( records , function ( record ) { var arrays = this . recordArraysForRecord ( record ) ; arrays . add ( manyArray ) ; } , this ) ; return manyArray ; } 
function ( type ) { var array = DS . RecordArray . create ( { type : type , content : Ember . A ( ) , store : this . store , isLoaded : true } ) ; this . registerFilteredRecordArray ( array , type ) ; return array ; } 
function ( type , filter ) { var array = DS . FilteredRecordArray . create ( { type : type , content : Ember . A ( ) , store : this . store , manager : this , filterFunction : filter } ) ; this . registerFilteredRecordArray ( array , type , filter ) ; return array ; } 
function ( type , query ) { return DS . AdapterPopulatedRecordArray . create ( { type : type , query : query , content : Ember . A ( ) , store : this . store } ) ; } 
function ( array , type , filter ) { var recordArrays = this . filteredRecordArrays . get ( type ) ; recordArrays . push ( array ) ; this . updateFilter ( array , type , filter ) ; } 
function ( record , array ) { var loadingRecordArrays = record . _loadingRecordArrays || [ ] ; loadingRecordArrays . push ( array ) ; record . _loadingRecordArrays = loadingRecordArrays ; } 
function ( record , options ) { return get ( record , 'store' ) . serializerFor ( record . constructor . typeKey ) . serialize ( record , options ) ; } 
function ( store , type , ids ) { var promises = map . call ( ids , function ( id ) { return this . find ( store , type , id ) ; } , this ) ; return Ember . RSVP . all ( promises ) ; } 
function ( type ) { if ( type . FIXTURES ) { var fixtures = Ember . A ( type . FIXTURES ) ; return fixtures . map ( function ( fixture ) { var fixtureIdType = typeof fixture . id ; if ( fixtureIdType !== "number" && fixtureIdType !== "string" ) { throw new Error ( fmt ( 'the id property must be defined as a number or string for fixture %@' , [ fixture ] ) ) ; } fixture . id = fixture . id + '' ; return fixture ; } ) ; } return null ; } 
function ( store , type , record ) { return store . serializerFor ( type ) . serialize ( record , { includeId : true } ) ; } 
function ( type , record ) { var existingFixture = this . findExistingFixture ( type , record ) ; if ( existingFixture ) { var index = indexOf ( type . FIXTURES , existingFixture ) ; type . FIXTURES . splice ( index , 1 ) ; return true ; } } 
function ( type , record ) { var fixtures = this . fixturesForType ( type ) ; var id = get ( record , 'id' ) ; return this . findFixtureById ( fixtures , id ) ; } 
function ( fixtures , id ) { return Ember . A ( fixtures ) . find ( function ( r ) { if ( '' + get ( r , 'id' ) === '' + id ) { return true ; } else { return false ; } } ) ; } 
function ( type , hash , prop ) { this . normalizeId ( hash ) ; this . normalizeAttributes ( type , hash ) ; this . normalizeRelationships ( type , hash ) ; this . normalizeUsingDeclaredMapping ( type , hash ) ; if ( this . normalizeHash && this . normalizeHash [ prop ] ) { this . normalizeHash [ prop ] ( hash ) ; } return this . _super ( type , hash , prop ) ; } 
function ( store , primaryType , payload , recordId , requestType ) { payload = this . normalizePayload ( primaryType , payload ) ; var primaryTypeName = primaryType . typeKey , primaryRecord ; for ( var prop in payload ) { var typeName = this . typeForRoot ( prop ) , isPrimary = typeName === primaryTypeName ; 
function ( store , primaryType , payload ) { payload = this . normalizePayload ( primaryType , payload ) ; var primaryTypeName = primaryType . typeKey , primaryArray ; for ( var prop in payload ) { var typeKey = prop , forcedSecondary = false ; if ( prop . charAt ( 0 ) === '_' ) { forcedSecondary = true ; typeKey = prop . substr ( 1 ) ; } var typeName = this . typeForRoot ( typeKey ) , type = store . modelFor ( typeName ) , typeSerializer = store . serializerFor ( type ) , isPrimary = ( ! forcedSecondary && ( typeName === primaryTypeName ) ) ; var normalizedArray = map . call ( payload [ prop ] , function ( hash ) { return typeSerializer . normalize ( type , hash , prop ) ; } , this ) ; if ( isPrimary ) { primaryArray = normalizedArray ; } else { store . pushMany ( typeName , normalizedArray ) ; } } return primaryArray ; } 
function ( store , payload ) { payload = this . normalizePayload ( null , payload ) ; for ( var prop in payload ) { var typeName = this . typeForRoot ( prop ) , type = store . modelFor ( typeName ) ; var normalizedArray = map . call ( Ember . makeArray ( payload [ prop ] ) , function ( hash ) { return this . normalize ( type , hash , prop ) ; } , this ) ; store . pushMany ( typeName , normalizedArray ) ; } } 
function ( hash , type , record , options ) { hash [ type . typeKey ] = this . serialize ( record , options ) ; } 
function ( record , json , relationship ) { var key = relationship . key , belongsTo = get ( record , key ) ; key = this . keyForAttribute ? this . keyForAttribute ( key ) : key ; json [ key + "Type" ] = belongsTo . constructor . typeKey ; } 
function ( store , type , sinceToken ) { var query ; if ( sinceToken ) { query = { since : sinceToken } ; } return this . ajax ( this . buildURL ( type . typeKey ) , 'GET' , { data : query } ) ; } 
function ( store , type , ids ) { return this . ajax ( this . buildURL ( type . typeKey ) , 'GET' , { data : { ids : ids } } ) ; } 
function ( store , record , url ) { var host = get ( this , 'host' ) , id = get ( record , 'id' ) , type = record . constructor . typeKey ; if ( host && url . charAt ( 0 ) === '/' && url . charAt ( 1 ) !== '/' ) { url = host + url ; } return this . ajax ( this . urlPrefix ( url , this . buildURL ( type , id ) ) , 'GET' ) ; } 
function ( store , record , url ) { var id = get ( record , 'id' ) , type = record . constructor . typeKey ; return this . ajax ( this . urlPrefix ( url , this . buildURL ( type , id ) ) , 'GET' ) ; } 
function ( store , type , record ) { var data = { } ; var serializer = store . serializerFor ( type . typeKey ) ; serializer . serializeIntoHash ( data , type , record , { includeId : true } ) ; return this . ajax ( this . buildURL ( type . typeKey ) , "POST" , { data : data } ) ; } 
function ( store , type , record ) { var data = { } ; var serializer = store . serializerFor ( type . typeKey ) ; serializer . serializeIntoHash ( data , type , record ) ; var id = get ( record , 'id' ) ; return this . ajax ( this . buildURL ( type . typeKey , id ) , "PUT" , { data : data } ) ; } 
function ( store , type , record ) { var id = get ( record , 'id' ) ; return this . ajax ( this . buildURL ( type . typeKey , id ) , "DELETE" ) ; } 
function ( type , id ) { var url = [ ] , host = get ( this , 'host' ) , prefix = this . urlPrefix ( ) ; if ( type ) { url . push ( this . pathForType ( type ) ) ; } if ( id ) { url . push ( id ) ; } if ( prefix ) { url . unshift ( prefix ) ; } url = url . join ( '/' ) ; if ( ! host && url ) { url = '/' + url ; } return url ; } 
function ( url , type , hash ) { var adapter = this ; return new Ember . RSVP . Promise ( function ( resolve , reject ) { hash = adapter . ajaxOptions ( url , type , hash ) ; hash . success = function ( json ) { Ember . run ( null , resolve , json ) ; } ; hash . error = function ( jqXHR , textStatus , errorThrown ) { Ember . run ( null , reject , adapter . ajaxError ( jqXHR ) ) ; } ; Ember . $ . ajax ( hash ) ; } , "DS: RestAdapter#ajax " + type + " to " + url ) ; } 
function Inflector ( ruleSet ) { ruleSet = ruleSet || { } ; ruleSet . uncountable = ruleSet . uncountable || { } ; ruleSet . irregularPairs = ruleSet . irregularPairs || { } ; var rules = this . rules = { plurals : ruleSet . plurals || [ ] , singular : ruleSet . singular || [ ] , irregular : { } , irregularInverse : { } , uncountable : { } } ; loadUncountable ( rules , ruleSet . uncountable ) ; loadIrregular ( rules , ruleSet . irregularPairs ) ; } 
function ( word , typeRules , irregular ) { var inflection , substitution , result , lowercase , isBlank , isUncountable , isIrregular , isIrregularInverse , rule ; isBlank = BLANK_REGEX . test ( word ) ; if ( isBlank ) { return word ; } lowercase = word . toLowerCase ( ) ; isUncountable = this . rules . uncountable [ lowercase ] ; if ( isUncountable ) { return word ; } isIrregular = irregular && irregular [ lowercase ] ; if ( isIrregular ) { return isIrregular ; } for ( var i = typeRules . length , min = 0 ; i > min ; i -- ) { inflection = typeRules [ i - 1 ] ; rule = inflection [ 0 ] ; if ( rule . test ( word ) ) { break ; } } inflection = inflection || [ ] ; rule = inflection [ 0 ] ; substitution = inflection [ 1 ] ; result = word . replace ( rule , substitution ) ; return result ; } 
function ( key , kind ) { key = Ember . String . decamelize ( key ) ; if ( kind === "belongsTo" ) { return key + "_id" ; } else if ( kind === "hasMany" ) { return Ember . String . singularize ( key ) + "_ids" ; } else { return key ; } } 
function ( data , type , record , options ) { var root = Ember . String . decamelize ( type . typeKey ) ; data [ root ] = this . serialize ( record , options ) ; } 
function ( record , json , relationship ) { var key = relationship . key , belongsTo = get ( record , key ) ; key = this . keyForAttribute ( key ) ; json [ key + "_type" ] = Ember . String . capitalize ( belongsTo . constructor . typeKey ) ; } 
function ( root ) { var camelized = Ember . String . camelize ( root ) ; return Ember . String . singularize ( camelized ) ; } 
function ( data ) { if ( data . links ) { var links = data . links ; for ( var link in links ) { var camelizedLink = Ember . String . camelize ( link ) ; if ( camelizedLink !== link ) { links [ camelizedLink ] = links [ link ] ; delete links [ link ] ; } } } } 
function ( type , hash ) { var payloadKey , payload ; if ( this . keyForRelationship ) { type . eachRelationship ( function ( key , relationship ) { if ( relationship . options . polymorphic ) { payloadKey = this . keyForAttribute ( key ) ; payload = hash [ payloadKey ] ; if ( payload && payload . type ) { payload . type = this . typeForRoot ( payload . type ) ; } else if ( payload && relationship . kind === "hasMany" ) { var self = this ; forEach ( payload , function ( single ) { single . type = self . typeForRoot ( single . type ) ; } ) ; } } else { payloadKey = this . keyForRelationship ( key , relationship . kind ) ; payload = hash [ payloadKey ] ; } hash [ key ] = payload ; if ( key !== payloadKey ) { delete hash [ payloadKey ] ; } } , this ) ; } } 
function ( record , json , relationship ) { var key = relationship . key , attrs = get ( this , 'attrs' ) , embed = attrs && attrs [ key ] && attrs [ key ] . embedded === 'always' ; if ( embed ) { json [ this . keyForAttribute ( key ) ] = get ( record , key ) . map ( function ( relation ) { var data = relation . serialize ( ) , primaryKey = get ( this , 'primaryKey' ) ; data [ primaryKey ] = get ( relation , primaryKey ) ; return data ; } , this ) ; } } 
function ( store , primaryType , payload , recordId , requestType ) { var root = this . keyForAttribute ( primaryType . typeKey ) , partial = payload [ root ] ; updatePayloadWithEmbedded ( store , this , primaryType , partial , payload ) ; return this . _super ( store , primaryType , payload , recordId , requestType ) ; } 
function ( store , type , payload ) { var root = this . keyForAttribute ( type . typeKey ) , partials = payload [ Ember . String . pluralize ( root ) ] ; forEach ( partials , function ( partial ) { updatePayloadWithEmbedded ( store , this , type , partial , payload ) ; } , this ) ; return this . _super ( store , type , payload ) ; } 
function ( type ) { var decamelized = Ember . String . decamelize ( type ) ; return Ember . String . pluralize ( decamelized ) ; } 
function ( jqXHR ) { var error = this . _super ( jqXHR ) ; if ( jqXHR && jqXHR . status === 422 ) { var jsonErrors = Ember . $ . parseJSON ( jqXHR . responseText ) [ "errors" ] , errors = { } ; forEach ( Ember . keys ( jsonErrors ) , function ( key ) { errors [ Ember . String . camelize ( key ) ] = jsonErrors [ key ] ; } ) ; return new DS . InvalidError ( errors ) ; } else { return error ; } } 
function extend ( dst ) { var h = dst . $$hashKey ; forEach ( arguments , function ( obj ) { if ( obj !== dst ) { forEach ( obj , function ( value , key ) { dst [ key ] = value ; } ) ; } } ) ; setHashKey ( dst , h ) ; return dst ; } 
function copy ( source , destination ) { if ( isWindow ( source ) || isScope ( source ) ) { throw ngMinErr ( 'cpws' , "Can't copy! Making copies of Window or Scope instances is not supported." ) ; } if ( ! destination ) { destination = source ; if ( source ) { if ( isArray ( source ) ) { destination = copy ( source , [ ] ) ; } else if ( isDate ( source ) ) { destination = new Date ( source . getTime ( ) ) ; } else if ( isRegExp ( source ) ) { destination = new RegExp ( source . source ) ; } else if ( isObject ( source ) ) { destination = copy ( source , { } ) ; } } } else { if ( source === destination ) throw ngMinErr ( 'cpi' , "Can't copy! Source and destination are identical." ) ; if ( isArray ( source ) ) { destination . length = 0 ; for ( var i = 0 ; i < source . length ; i ++ ) { destination . push ( copy ( source [ i ] ) ) ; } } else { var h = destination . $$hashKey ; forEach ( destination , function ( value , key ) { delete destination [ key ] ; } ) ; for ( var key in source ) { destination [ key ] = copy ( source [ key ] ) ; } setHashKey ( destination , h ) ; } } return destination ; } 
function parseKeyValue ( keyValue ) { var obj = { } , key_value , key ; forEach ( ( keyValue || "" ) . split ( '&' ) , function ( keyValue ) { if ( keyValue ) { key_value = keyValue . split ( '=' ) ; key = tryDecodeURIComponent ( key_value [ 0 ] ) ; if ( isDefined ( key ) ) { var val = isDefined ( key_value [ 1 ] ) ? tryDecodeURIComponent ( key_value [ 1 ] ) : true ; if ( ! obj [ key ] ) { obj [ key ] = val ; } else if ( isArray ( obj [ key ] ) ) { obj [ key ] . push ( val ) ; } else { obj [ key ] = [ obj [ key ] , val ] ; } } } } ) ; return obj ; } 
function loadModules ( modulesToLoad ) { var runBlocks = [ ] ; forEach ( modulesToLoad , function ( module ) { if ( loadedModules . get ( module ) ) return ; loadedModules . put ( module , true ) ; try { if ( isString ( module ) ) { var moduleFn = angularModule ( module ) ; runBlocks = runBlocks . concat ( loadModules ( moduleFn . requires ) ) . concat ( moduleFn . _runBlocks ) ; for ( var invokeQueue = moduleFn . _invokeQueue , i = 0 , ii = invokeQueue . length ; i < ii ; i ++ ) { var invokeArgs = invokeQueue [ i ] , provider = providerInjector . get ( invokeArgs [ 0 ] ) ; provider [ invokeArgs [ 1 ] ] . apply ( provider , invokeArgs [ 2 ] ) ; } } else if ( isFunction ( module ) ) { runBlocks . push ( providerInjector . invoke ( module ) ) ; } else if ( isArray ( module ) ) { runBlocks . push ( providerInjector . invoke ( module ) ) ; } else { assertArgFn ( module , 'module' ) ; } } catch ( e ) { if ( isArray ( module ) ) { module = module [ module . length - 1 ] ; } if ( e . message && e . stack && e . stack . indexOf ( e . message ) == - 1 ) { 
function $AnchorScrollProvider ( ) { var autoScrollingEnabled = true ; this . disableAutoScrolling = function ( ) { autoScrollingEnabled = false ; } ; this . $get = [ '$window' , '$location' , '$rootScope' , function ( $window , $location , $rootScope ) { var document = $window . document ; 
function ( element , parent , after , done ) { var afterNode = after && after [ after . length - 1 ] ; var parentNode = parent && parent [ 0 ] || afterNode && afterNode . parentNode ; 
function ( element , className , done ) { className = isString ( className ) ? className : isArray ( className ) ? className . join ( ' ' ) : '' ; forEach ( element , function ( element ) { JQLiteAddClass ( element , className ) ; } ) ; done && $timeout ( done , 0 , false ) ; } 
function Browser ( window , document , $log , $sniffer ) { var self = this , rawDocument = document [ 0 ] , location = window . location , history = window . history , setTimeout = window . setTimeout , clearTimeout = window . clearTimeout , pendingDeferIds = { } ; self . isMock = false ; var outstandingRequestCount = 0 ; var outstandingRequestCallbacks = [ ] ; * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks` * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed. */ function completeOutstandingRequest ( fn ) { try { fn . apply ( null , sliceArgs ( arguments , 1 ) ) ; } finally { outstandingRequestCount -- ; if ( outstandingRequestCount === 0 ) { while ( outstandingRequestCallbacks . length ) { try { outstandingRequestCallbacks . pop ( ) ( ) ; } catch ( e ) { $log . error ( e ) ; } } } } } self . notifyWhenNoOutstandingRequests = function ( callback ) { * @name ng.$browser#addPollFn * @methodOf ng.$browser * * @param {function()} fn Poll function to add * * @description * Adds a function to the list of functions that poller periodically executes, * and starts polling if not started yet. * * @returns {function()} the added function */ self . addPollFn = function ( fn ) { if ( isUndefined ( pollTimeout ) ) startPoller ( 100 , setTimeout ) ; pollFns . push ( fn ) ; return fn ; } ; function startPoller ( interval , setTimeout ) { ( function check ( ) { forEach ( pollFns , function ( pollFn ) { pollFn ( ) ; } ) ; pollTimeout = setTimeout ( check , interval ) ; } ) ( ) ; } * @name ng.$browser#url * @methodOf ng.$browser * * @description * GETTER: * Without any argument, this method just returns current value of location.href. * * SETTER: * With at least one argument, this method sets url to new value. * If html5 history api supported, pushState/replaceState is used, otherwise * location.href/location.replace is used. * Returns its own instance to allow chaining * * NOTE: this api is intended for use only by the $location service. Please use the * {@link ng.$location $location service} to change url. * * @param {string} url New url (when used as setter) * @param {boolean=} replace Should new url replace current history record ? */ self . url = function ( url , replace ) { * @name ng.$browser#onUrlChange * @methodOf ng.$browser * @TODO(vojta): refactor to use node's syntax for events * * @description * Register callback function that will be called, when url changes. * * It's only called when the url is changed by outside of angular: * - user types different url into address bar * - user clicks on history (forward/back) button * - user clicks on a link * * It's not called when url is changed by $browser.url() method * * The listener gets called with new url as parameter. * * NOTE: this api is intended for use only by the $location service. Please use the * {@link ng.$location $location service} to monitor url changes in angular apps. * * @param {function(string)} listener Listener function to be called when url changes. * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous. */ self . onUrlChange = function ( callback ) { if ( ! urlChangeInit ) { // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera) // don't fire popstate when user change the address bar and don't fire hashchange when url // changed by push/replaceState // html5 history api - popstate event if ( $sniffer . history ) jqLite ( window ) . on ( 'popstate' , fireUrlChange ) ; // hashchange event if ( $sniffer . hashchange ) jqLite ( window ) . on ( 'hashchange' , fireUrlChange ) ; // polling else self . addPollFn ( fireUrlChange ) ; urlChangeInit = true ; } urlChangeListeners . push ( callback ) ; return callback ; } ; ////////////////////////////////////////////////////////////// // Misc API ////////////////////////////////////////////////////////////// /** * @name ng.$browser#baseHref * @methodOf ng.$browser * * @description * Returns current <base href> * (always relative - without domain) * * @returns {string=} current <base href> */ self . baseHref = function ( ) { var href = baseElement . attr ( 'href' ) ; return href ? href . replace ( / ^https?\:\/\/[^\/]* / , '' ) : '' ; } ; ////////////////////////////////////////////////////////////// // Cookies API ////////////////////////////////////////////////////////////// var lastCookies = { } ; var lastCookieString = '' ; var cookiePath = self . baseHref ( ) ; /** * @name ng.$browser#cookies * @methodOf ng.$browser * * @param {string=} name Cookie name * @param {string=} value Cookie value * * @description * The cookies method provides a 'private' low level access to browser cookies. * It is not meant to be used directly, use the $cookie service instead. * * The return values vary depending on the arguments that the method was called with as follows: * <ul> * <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li> * <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li> * <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li> * </ul> * * @returns {Object} Hash of all cookies (if called without any parameter) */ self . cookies = function ( name , value ) { var cookieLength , cookieArray , cookie , i , index ; if ( name ) { if ( value === undefined ) { rawDocument . cookie = escape ( name ) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" ; } else { if ( isString ( value ) ) { cookieLength = ( rawDocument . cookie = escape ( name ) + '=' + escape ( value ) + ';path=' + cookiePath ) . length + 1 ; // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum: // - 300 cookies // - 20 cookies per unique domain // - 4096 bytes per cookie if ( cookieLength > 4096 ) { $log . warn ( "Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!" ) ; } } } } else { if ( rawDocument . cookie !== lastCookieString ) { lastCookieString = rawDocument . cookie ; cookieArray = lastCookieString . split ( "; " ) ; lastCookies = { } ; for ( i = 0 ; i < cookieArray . length ; i ++ ) { cookie = cookieArray [ i ] ; index = cookie . indexOf ( '=' ) ; if ( index > 0 ) { //ignore nameless cookies var name = unescape ( cookie . substring ( 0 , index ) ) ; // the first value that is seen for a cookie is the most // specific one. values for the same cookie name that // follow are for less specific paths. if ( lastCookies [ name ] === undefined ) { lastCookies [ name ] = unescape ( cookie . substring ( index + 1 ) ) ; } } } } return lastCookies ; } } ; /** * @name ng.$browser#defer * @methodOf ng.$browser * @param {function()} fn A function, who's execution should be deferred. * @param {number=} [delay=0] of milliseconds to defer the function execution. * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`. * * @description * Executes a fn asynchronously via `setTimeout(fn, delay)`. * * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed * via `$browser.defer.flush()`. * */ self . defer = function ( fn , delay ) { var timeoutId ; outstandingRequestCount ++ ; timeoutId = setTimeout ( function ( ) { delete pendingDeferIds [ timeoutId ] ; completeOutstandingRequest ( fn ) ; } , delay || 0 ) ; pendingDeferIds [ timeoutId ] = true ; return timeoutId ; } ; self . defer . cancel = function ( deferId ) { if ( pendingDeferIds [ deferId ] ) { delete pendingDeferIds [ deferId ] ; clearTimeout ( deferId ) ; completeOutstandingRequest ( noop ) ; return true ; } return false ; } ; } 
function ( key , value , writeAttr , attrName ) { 
function compileNodes ( nodeList , transcludeFn , $rootElement , maxPriority , ignoreDirective ) { var linkFns = [ ] , nodeLinkFn , childLinkFn , directives , attrs , linkFnFound ; for ( var i = 0 ; i < nodeList . length ; i ++ ) { attrs = new Attributes ( ) ; 
function groupElementsLinkFnWrapper ( linkFn , attrStart , attrEnd ) { return function ( scope , element , attrs , controllers ) { element = groupScan ( element [ 0 ] , attrStart , attrEnd ) ; return linkFn ( scope , element , attrs , controllers ) ; } } 
function addLinkFns ( pre , post , attrStart , attrEnd ) { if ( pre ) { if ( attrStart ) pre = groupElementsLinkFnWrapper ( pre , attrStart , attrEnd ) ; pre . require = directive . require ; preLinkFns . push ( pre ) ; } if ( post ) { if ( attrStart ) post = groupElementsLinkFnWrapper ( post , attrStart , attrEnd ) ; post . require = directive . require ; postLinkFns . push ( post ) ; } } 
function replaceWith ( $rootElement , elementsToRemove , newNode ) { var firstElementToRemove = elementsToRemove [ 0 ] , removeCount = elementsToRemove . length , parent = firstElementToRemove . parentNode , i , ii ; if ( $rootElement ) { for ( i = 0 , ii = $rootElement . length ; i < ii ; i ++ ) { if ( $rootElement [ i ] == firstElementToRemove ) { $rootElement [ i ++ ] = newNode ; for ( var j = i , j2 = j + removeCount - 1 , jj = $rootElement . length ; j < jj ; j ++ , j2 ++ ) { if ( j2 < jj ) { $rootElement [ j ] = $rootElement [ j2 ] ; } else { delete $rootElement [ j ] ; } } $rootElement . length -= removeCount - 1 ; break ; } } } if ( parent ) { parent . replaceChild ( newNode , firstElementToRemove ) ; } var fragment = document . createDocumentFragment ( ) ; fragment . appendChild ( firstElementToRemove ) ; newNode [ jqLite . expando ] = firstElementToRemove [ jqLite . expando ] ; for ( var k = 1 , kk = elementsToRemove . length ; k < kk ; k ++ ) { var element = elementsToRemove [ k ] ; jqLite ( element ) . remove ( ) ; 
function $ControllerProvider ( ) { var controllers = { } , CNTRL_REG = / ^(\S+)(\s+as\s+(\w+))?$ / ; this . register = function ( name , constructor ) { if ( isObject ( name ) ) { extend ( controllers , name ) } else { controllers [ name ] = constructor ; } } ; this . $get = [ '$injector' , '$window' , function ( $injector , $window ) { return function ( expression , locals ) { var instance , match , constructor , identifier ; if ( isString ( expression ) ) { match = expression . match ( CNTRL_REG ) , constructor = match [ 1 ] , identifier = match [ 3 ] ; expression = controllers . hasOwnProperty ( constructor ) ? controllers [ constructor ] : getter ( locals . $scope , constructor , true ) || getter ( $window , constructor , true ) ; assertArgFn ( expression , constructor , true ) ; } instance = $injector . instantiate ( expression , locals ) ; if ( identifier ) { if ( ! ( locals && typeof locals . $scope == 'object' ) ) { throw minErr ( '$controller' ) ( 'noscp' , "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`." , constructor || expression . name , identifier ) ; } locals . $scope [ identifier ] = instance ; } return instance ; } ; } ] ; } 
function LocationHtml5Url ( appBase , basePrefix ) { this . $$html5 = true ; basePrefix = basePrefix || '' ; var appBaseNoFile = stripFile ( appBase ) ; this . $$parse = function ( url ) { var parsed = { } matchUrl ( url , parsed ) ; var pathUrl = beginsWith ( appBaseNoFile , url ) ; if ( ! isString ( pathUrl ) ) { throw $locationMinErr ( 'ipthprfx' , 'Invalid url "{0}", missing path prefix "{1}".' , url , appBaseNoFile ) ; } matchAppUrl ( pathUrl , parsed ) ; extend ( this , parsed ) ; if ( ! this . $$path ) { this . $$path = '/' ; } this . $$compose ( ) ; } ; this . $$compose = function ( ) { var search = toKeyValue ( this . $$search ) , hash = this . $$hash ? '#' + encodeUriSegment ( this . $$hash ) : '' ; this . $$url = encodePath ( this . $$path ) + ( search ? '?' + search : '' ) + hash ; this . $$absUrl = appBaseNoFile + this . $$url . substr ( 1 ) ; 
function LocationHashbangUrl ( appBase , hashPrefix ) { var appBaseNoFile = stripFile ( appBase ) ; matchUrl ( appBase , this ) ; this . $$parse = function ( url ) { var withoutBaseUrl = beginsWith ( appBase , url ) || beginsWith ( appBaseNoFile , url ) ; var withoutHashUrl = withoutBaseUrl . charAt ( 0 ) == '#' ? beginsWith ( hashPrefix , withoutBaseUrl ) : ( this . $$html5 ) ? withoutBaseUrl : '' ; if ( ! isString ( withoutHashUrl ) ) { throw $locationMinErr ( 'ihshprfx' , 'Invalid url "{0}", missing hash prefix "{1}".' , url , hashPrefix ) ; } matchAppUrl ( withoutHashUrl , this ) ; this . $$compose ( ) ; } ; this . $$compose = function ( ) { var search = toKeyValue ( this . $$search ) , hash = this . $$hash ? '#' + encodeUriSegment ( this . $$hash ) : '' ; this . $$url = encodePath ( this . $$path ) + ( search ? '?' + search : '' ) + hash ; this . $$absUrl = appBase + ( this . $$url ? hashPrefix + this . $$url : '' ) ; } ; this . $$rewrite = function ( url ) { if ( stripHash ( appBase ) == stripHash ( url ) ) { return url ; } } } 
function LocationHashbangInHtml5Url ( appBase , hashPrefix ) { this . $$html5 = true ; LocationHashbangUrl . apply ( this , arguments ) ; var appBaseNoFile = stripFile ( appBase ) ; this . $$rewrite = function ( url ) { var appUrl ; if ( appBase == stripHash ( url ) ) { return url ; } else if ( ( appUrl = beginsWith ( appBaseNoFile , url ) ) ) { return appBase + hashPrefix + appUrl ; } else if ( appBaseNoFile === url + '/' ) { return appBaseNoFile ; } } } 
function ( search , paramValue ) { switch ( arguments . length ) { case 0 : return this . $$search ; case 1 : if ( isString ( search ) ) { this . $$search = parseKeyValue ( search ) ; } else if ( isObject ( search ) ) { this . $$search = search ; } else { throw $locationMinErr ( 'isrcharg' , 'The first argument of the `$location#search()` call must be a string or an object.' ) ; } break ; default : if ( paramValue == undefined || paramValue == null ) { delete this . $$search [ search ] ; } else { this . $$search [ search ] = paramValue ; } } this . $$compose ( ) ; return this ; } 
function arrayDeclaration ( ) { var elementFns = [ ] ; var allConstant = true ; if ( peekToken ( ) . text != ']' ) { do { var elementFn = expression ( ) ; elementFns . push ( elementFn ) ; if ( ! elementFn . constant ) { allConstant = false ; } } while ( expect ( ',' ) ) ; } consume ( ']' ) ; return extend ( function ( self , locals ) { var array = [ ] ; for ( var i = 0 ; i < elementFns . length ; i ++ ) { array . push ( elementFns [ i ] ( self , locals ) ) ; } return array ; } , { literal : true , constant : allConstant } ) ; } 
function setter ( obj , path , setValue , fullExp ) { var element = path . split ( '.' ) , key ; for ( var i = 0 ; element . length > 1 ; i ++ ) { key = ensureSafeMemberName ( element . shift ( ) , fullExp ) ; var propertyObj = obj [ key ] ; if ( ! propertyObj ) { propertyObj = { } ; obj [ key ] = propertyObj ; } obj = propertyObj ; if ( obj . then ) { if ( ! ( "$$v" in obj ) ) { ( function ( promise ) { promise . then ( function ( val ) { promise . $$v = val ; } ) ; } ) ( obj ) ; } if ( obj . $$v === undefined ) { obj . $$v = { } ; } obj = obj . $$v ; } } key = ensureSafeMemberName ( element . shift ( ) , fullExp ) ; obj [ key ] = setValue ; return setValue ; } 
function ( reason ) { return { then : function ( callback , errback ) { var result = defer ( ) ; nextTick ( function ( ) { try { result . resolve ( ( isFunction ( errback ) ? errback : defaultErrback ) ( reason ) ) ; } catch ( e ) { result . reject ( e ) ; exceptionHandler ( e ) ; } } ) ; return result . promise ; } } ; } 
function ( value , callback , errback , progressback ) { var result = defer ( ) , done ; var wrappedCallback = function ( value ) { try { return ( isFunction ( callback ) ? callback : defaultCallback ) ( value ) ; } catch ( e ) { exceptionHandler ( e ) ; return reject ( e ) ; } } ; var wrappedErrback = function ( reason ) { try { return ( isFunction ( errback ) ? errback : defaultErrback ) ( reason ) ; } catch ( e ) { exceptionHandler ( e ) ; return reject ( e ) ; } } ; var wrappedProgressback = function ( progress ) { try { return ( isFunction ( progressback ) ? progressback : defaultCallback ) ( progress ) ; } catch ( e ) { exceptionHandler ( e ) ; } } ; nextTick ( function ( ) { ref ( value ) . then ( function ( value ) { if ( done ) return ; done = true ; result . resolve ( ref ( value ) . then ( wrappedCallback , wrappedErrback , wrappedProgressback ) ) ; } , function ( reason ) { if ( done ) return ; done = true ; result . resolve ( wrappedErrback ( reason ) ) ; } , function ( progress ) { if ( done ) return ; result . notify ( wrappedProgressback ( progress ) ) ; } ) ; } ) ; return result . promise ; } 
function ( isolate ) { var Child , child ; if ( isolate ) { child = new Scope ( ) ; child . $root = this . $root ; 
function ( watchExp , listener , objectEquality ) { var scope = this , get = compileToFn ( watchExp , 'watch' ) , array = scope . $$watchers , watcher = { fn : listener , last : initWatchVal , get : get , exp : watchExp , eq : ! ! objectEquality } ; 
function ( obj , listener ) { var self = this ; var oldValue ; var newValue ; var changeDetected = 0 ; var objGetter = $parse ( obj ) ; var internalArray = [ ] ; var internalObject = { } ; var oldLength = 0 ; function $watchCollectionWatch ( ) { newValue = objGetter ( self ) ; var newLength , key ; if ( ! isObject ( newValue ) ) { if ( oldValue !== newValue ) { oldValue = newValue ; changeDetected ++ ; } } else if ( isArrayLike ( newValue ) ) { if ( oldValue !== internalArray ) { 
function ( name , listener ) { var namedListeners = this . $$listeners [ name ] ; if ( ! namedListeners ) { this . $$listeners [ name ] = namedListeners = [ ] ; } namedListeners . push ( listener ) ; return function ( ) { namedListeners [ indexOf ( namedListeners , listener ) ] = null ; } ; } 
function ( name , args ) { var empty = [ ] , namedListeners , scope = this , stopPropagation = false , event = { name : name , targetScope : scope , stopPropagation : function ( ) { stopPropagation = true ; } , preventDefault : function ( ) { event . defaultPrevented = true ; } , defaultPrevented : false } , listenerArgs = concat ( [ event ] , arguments , 1 ) , i , length ; do { namedListeners = scope . $$listeners [ name ] || empty ; event . currentScope = scope ; for ( i = 0 , length = namedListeners . length ; i < length ; i ++ ) { 
function trustAs ( type , trustedValue ) { var constructor = ( byType . hasOwnProperty ( type ) ? byType [ type ] : null ) ; if ( ! constructor ) { throw $sceMinErr ( 'icontext' , 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}' , type , trustedValue ) ; } if ( trustedValue === null || trustedValue === undefined || trustedValue === '' ) { return trustedValue ; } 
function resolve ( url , parse ) { var href = url ; if ( msie <= 11 ) { 
function isSameOrigin ( requestUrl ) { var parsed = ( typeof requestUrl === 'string' ) ? resolve ( requestUrl , true ) : requestUrl ; return ( parsed . protocol === originUrl . protocol && parsed . host === originUrl . host ) ; } 
function ConsumingMatcher ( matchers ) { return _ . create ( { } , { unmatchedMatchers : _ . clone ( matchers ) , matches : function ( actual ) { let matched = false ; _ . forEach ( this . unmatchedMatchers , ( matcher , index ) => { if ( matcher . matches ( actual ) ) { matched = true ; this . unmatchedMatchers . splice ( index , 1 ) ; return false ; } } , this ) ; return matched ; } } ) ; } 
function traverse ( node , opt_onEnter , opt_onLeave ) { if ( opt_onEnter ) opt_onEnter ( node ) ; var childNodes = _collectChildNodes ( node ) ; childNodes . forEach ( function ( childNode ) { traverse ( childNode , opt_onEnter , opt_onLeave ) ; } ) ; if ( opt_onLeave ) opt_onLeave ( node ) ; } 
function Client ( ) { logger ( 'new Client' ) ; this . type = 'client' ; this . id = uuid ( ) ; this . browser = ( WebSocket . Server === undefined ) ; Base . call ( this ) ; } 
function jsonParse ( data ) { var payload ; try { payload = JSON . parse ( data ) ; } catch ( error ) { logger ( error ) ; payload = null ; } return payload ; } 
function Connection ( socket , parent ) { logger ( 'new Connection to %s' , parent . type ) ; this . id = uuid ( ) ; this . socket = socket ; this . parent = parent ; this . responseHandlers = { } ; if ( this . parent . browser ) { this . socket . onmessage = this . message . bind ( this ) ; this . socket . onclose = socketClosed . bind ( this ) ; this . socket . onerror = socketError . bind ( this ) ; } else { this . socket . on ( 'message' , this . message . bind ( this ) ) ; this . socket . once ( 'close' , this . close . bind ( this ) ) ; this . socket . once ( 'error' , this . close . bind ( this ) ) ; } } 
function escapeJSDiff ( s ) { var n = s ; n = n . replace ( / & / g , "&amp;" ) ; n = n . replace ( / < / g , "&lt;" ) ; n = n . replace ( / > / g , "&gt;" ) ; n = n . replace ( / " / g , "&quot;" ) ; return n ; } 
function Dialog ( opts ) { var self = this , options = this . options = angular . extend ( { } , defaults , globalOptions , opts ) ; this . _open = false ; this . backdropEl = createElement ( options . backdropClass ) ; if ( options . backdropFade ) { this . backdropEl . addClass ( options . transitionClass ) ; this . backdropEl . removeClass ( options . triggerClass ) ; } this . modalEl = createElement ( options . dialogClass ) ; if ( options . dialogFade ) { this . modalEl . addClass ( options . transitionClass ) ; this . modalEl . removeClass ( options . triggerClass ) ; } this . handledEscapeKey = function ( e ) { if ( e . which === 27 ) { self . close ( ) ; e . preventDefault ( ) ; self . $scope . $apply ( ) ; } } ; this . handleBackDropClick = function ( e ) { self . close ( ) ; e . preventDefault ( ) ; self . $scope . $apply ( ) ; } ; this . handleLocationChange = function ( ) { self . close ( ) ; } ; } 
function ( title , message , buttons ) { return new Dialog ( { templateUrl : 'plugins/ui-bootstrap/html/message.html' , controller : 'MessageBoxController' , resolve : { model : function ( ) { return { title : title , message : message , buttons : buttons } ; } } } ) ; } 
function block ( type , attrs ) { let result = function ( ... args ) { let myAttrs = takeAttrs ( attrs , args ) let { nodes , tag } = flatten ( type . schema , args , id ) let node = type . create ( myAttrs , nodes ) if ( tag != noTag ) node . tag = tag return node } if ( type . isLeaf ) try { result . flat = [ type . create ( attrs ) ] } catch ( _ ) { } return result } 
function mark ( type , attrs ) { return function ( ... args ) { let mark = type . create ( takeAttrs ( attrs , args ) ) let { nodes , tag } = flatten ( type . schema , args , n => mark . type . isInSet ( n . marks ) ? n : n . mark ( mark . addToSet ( n . marks ) ) ) return { flat : nodes , tag } } } 
function _createStore ( ) { 
function serverRequest ( config ) { var defer = $q . defer ( ) ; if ( provider . debug ) $log . info ( '$sails ' + config . method + ' ' + config . url , config . data || '' ) ; if ( config . timeout > 0 ) { $timeout ( timeoutRequest , config . timeout ) ; } else if ( isPromiseLike ( config . timeout ) ) { config . timeout . then ( timeoutRequest ) ; } socket [ 'legacy_' + config . method . toLowerCase ( ) ] ( config . url , config . data , serverResponse ) ; function timeoutRequest ( ) { serverResponse ( null ) ; } function serverResponse ( result , jwr ) { if ( ! jwr ) { jwr = { body : result , headers : result . headers || { } , statusCode : result . statusCode || result . status || 0 , error : ( function ( ) { if ( this . statusCode < 200 || this . statusCode >= 400 ) { return this . body || this . statusCode ; } } ) ( ) } ; } jwr . data = jwr . body ; 
function figureOutRootComponent ( ) { var rootComponents = [ '../../../src/app/app.module.ts' , '../../../src/app.ts' , '../../../boot.ts' , '../../../src/main.ts' ] ; for ( var i = 0 ; i < rootComponents . length ; i ++ ) { if ( fs . existsSync ( rootComponents [ i ] ) ) { var result = processBootStrap ( rootComponents [ i ] ) ; if ( result ) { return result ; } } } 
function processBootStrap ( file ) { var data = fs . readFileSync ( file ) . toString ( ) ; var idx = data . indexOf ( 'bootstrap(' ) ; if ( idx === - 1 ) { return null ; } else { idx += 10 ; } var odx1 = data . indexOf ( ',' , idx ) ; var odx2 = data . indexOf ( ')' , idx ) ; if ( odx2 < odx1 && odx2 !== - 1 || odx1 === - 1 ) { odx1 = odx2 ; } if ( odx1 === - 1 ) { return null ; } var componentRef = data . substring ( idx , odx1 ) ; var exp = "import\\s+\\{(" + componentRef + ")\\}\\s+from+\\s+[\'|\"](\\S+)[\'|\"][;?]" ; if ( debugging ) { console . log ( "Searching for" , exp ) ; } var result = function ( r ) { return { name : r [ 1 ] , path : r [ r . length - 1 ] } ; } ; //noinspection JSPotentiallyInvalidConstructorUsage var r = RegExp ( exp , 'i' ) . exec ( data ) ; if ( r === null || r . length <= 1 ) { // check if using current style guide with spaces exp = "import\\s+\\{\\s+(" + componentRef + ")\\,\\s+([A-Z]{0,300})\\w+\\s+\\}\\s+from+\\s+[\'|\"](\\S+)[\'|\"][;?]" ; if ( debugging ) { console . log ( "Searching for" , exp ) ; } r = RegExp ( exp , 'i' ) . exec ( data ) ; if ( r === null || r . length <= 1 ) { // try just spaces with no angular cli style (, environment) etc. exp = "import\\s+\\{\\s+(" + componentRef + ")\\s+\\}\\s+from+\\s+[\'|\"](\\S+)[\'|\"][;?]" ; if ( debugging ) { console . log ( "Searching for" , exp ) ; } r = RegExp ( exp , 'i' ) . exec ( data ) ; if ( r !== null && r . length > 1 ) { return result ( r ) ; } } else { 
function createSymLink ( ) { if ( debugging ) { console . log ( "Attempting to Symlink" , angularSeedPath , nativescriptClientPath ) ; } fs . symlinkSync ( resolve ( angularSeedPath ) , resolve ( nativescriptClientPath ) , 'junction' ) ; } 
function fixTsConfig ( ) { var tsConfig = { } , tsFile = '../../tsconfig.json' ; if ( fs . existsSync ( tsFile ) ) { tsConfig = require ( tsFile ) ; } if ( ! tsConfig . compilerOptions || ! tsConfig . compilerOptions . typeRoots ) { tsConfig . compilerOptions = { target : "es5" , module : "commonjs" , declaration : false , removeComments : true , noLib : false , emitDecoratorMetadata : true , experimentalDecorators : true , lib : [ "dom" ] , sourceMap : true , pretty : true , allowUnreachableCode : false , allowUnusedLabels : false , noImplicitAny : false , noImplicitReturns : true , noImplicitUseStrict : false , noFallthroughCasesInSwitch : true , typeRoots : [ "node_modules/@types" , "node_modules" ] , types : [ "jasmine" ] } ; } 
function fixRefFile ( ) { var existingRef = '' , refFile = '../../references.d.ts' ; if ( fs . existsSync ( refFile ) ) { existingRef = fs . readFileSync ( refFile ) . toString ( ) ; } if ( existingRef . indexOf ( 'typescript/lib/lib.d.ts' ) === - 1 ) { 
function fixNativeScriptPackage ( ) { var packageJSON = { } , packageFile = '../../package.json' ; packageJSON . name = "NativeScriptApp" ; packageJSON . version = "0.0.0" ; 
function fixAngularPackage ( ) { var packageJSON = { } , packageFile = '../../../package.json' ; if ( fs . existsSync ( packageFile ) ) { packageJSON = require ( packageFile ) ; } else { console . log ( "This should not happen, your are missing your main package.json file!" ) ; return ; } if ( ! packageJSON . scripts ) { packageJSON . scripts = { } ; } packageJSON . scripts [ "start.ios" ] = "cd nativescript && tns emulate ios" ; packageJSON . scripts [ "start.livesync.ios" ] = "cd nativescript && tns livesync ios --emulator --watch" ; packageJSON . scripts [ "start.android" ] = "cd nativescript && tns emulate android" ; packageJSON . scripts [ "start.livesync.android" ] = "cd nativescript && tns livesync android --emulator --watch" ; fs . writeFileSync ( packageFile , JSON . stringify ( packageJSON , null , 4 ) , 'utf8' ) ; } 
function fixMainFile ( component ) { var mainTS = '' , mainFile = '../../app/main.ts' ; if ( fs . existsSync ( mainFile ) ) { mainTS = fs . readFileSync ( mainFile ) . toString ( ) ; } if ( mainTS . indexOf ( 'MagicService' ) === - 1 ) { 
function fixGitIgnore ( ignorePattern ) { var fileString = '' , ignoreFile = '../../../.gitignore' ; if ( fs . existsSync ( ignoreFile ) ) { fileString = fs . readFileSync ( ignoreFile ) . toString ( ) ; } if ( fileString . indexOf ( ignorePattern ) === - 1 ) { 
function displayFinalHelp ( ) { console . log ( "-------------- Welcome to the Magical World of NativeScript -----------------------------" ) ; console . log ( "To finish, follow this guide https://github.com/NathanWalker/nativescript-ng2-magic#usage" ) ; console . log ( "After you have completed the steps in the usage guide, you can then:" ) ; console . log ( "" ) ; console . log ( "Run your app in the iOS Simulator with these options:" ) ; console . log ( " npm run start.ios" ) ; console . log ( " npm run start.livesync.ios" ) ; console . log ( "" ) ; console . log ( "Run your app in an Android emulator with these options:" ) ; console . log ( " npm run start.android" ) ; console . log ( " npm run start.livesync.android" ) ; console . log ( "-----------------------------------------------------------------------------------------" ) ; console . log ( "" ) ; } 
function bind ( func , thisObject , var_args ) { var args = slice ( arguments , 2 ) ; function bound ( var_args ) { return InjectedScriptHost . callFunction ( func , thisObject , concat ( args , slice ( arguments ) ) ) ; } bound . toString = function ( ) { return "bound: " + toString ( func ) ; } ; return bound ; } 
function ( object , objectGroupName , forceValueType , generatePreview , columnNames , isTable , doNotBind , customObjectConfig ) { try { return new InjectedScript . RemoteObject ( object , objectGroupName , doNotBind , forceValueType , generatePreview , columnNames , isTable , undefined , customObjectConfig ) ; } catch ( e ) { try { var description = injectedScript . _describe ( e ) ; } catch ( ex ) { var description = "<failed to convert exception to string>" ; } return new InjectedScript . RemoteObject ( description ) ; } } 
function ( callArgumentJson ) { callArgumentJson = nullifyObjectProto ( callArgumentJson ) ; var objectId = callArgumentJson . objectId ; if ( objectId ) { var parsedArgId = this . _parseObjectId ( objectId ) ; if ( ! parsedArgId || parsedArgId [ "injectedScriptId" ] !== injectedScriptId ) throw "Arguments should belong to the same JavaScript world as the target object." ; var resolvedArg = this . _objectForId ( parsedArgId ) ; if ( ! this . _isDefined ( resolvedArg ) ) throw "Could not find object with given id" ; return resolvedArg ; } else if ( "value" in callArgumentJson ) { var value = callArgumentJson . value ; if ( callArgumentJson . type === "number" && typeof value !== "number" ) value = Number ( value ) ; return value ; } return undefined ; } 
function ( topCallFrame , callFrameId , functionObjectId , scopeNumber , variableName , newValueJsonString ) { try { var newValueJson = ( InjectedScriptHost . eval ( "(" + newValueJsonString + ")" ) ) ; var resolvedValue = this . _resolveCallArgument ( newValueJson ) ; if ( typeof callFrameId === "string" ) { var callFrame = this . _callFrameForId ( topCallFrame , callFrameId ) ; if ( ! callFrame ) return "Could not find call frame with given id" ; callFrame . setVariableValue ( scopeNumber , variableName , resolvedValue ) } else { var parsedFunctionId = this . _parseObjectId ( ( functionObjectId ) ) ; var func = this . _objectForId ( parsedFunctionId ) ; if ( typeof func !== "function" ) return "Could not resolve function by id" ; InjectedScriptHost . setFunctionVariableValue ( func , scopeNumber , variableName , resolvedValue ) ; } } catch ( e ) { return toString ( e ) ; } return undefined ; } 
function validate ( tj ) { if ( Object . prototype . hasOwnProperty . call ( tj , 'tilejson' ) ) { if ( tj . tilejson !== '2.2.0' ) { return false ; } } else { return false ; } if ( Object . prototype . hasOwnProperty . call ( tj , 'name' ) ) { if ( typeof tj . name !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'description' ) ) { if ( typeof tj . description !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'version' ) ) { if ( typeof tj . version !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'attribution' ) ) { if ( typeof tj . attribution !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'template' ) ) { if ( typeof tj . template !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'legend' ) ) { if ( typeof tj . legend !== 'string' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'scheme' ) ) { if ( typeof tj . scheme !== 'string' ) { return false ; } if ( tj . scheme !== 'xyz' && tj . scheme !== 'tms' ) { return false ; } } if ( Object . prototype . hasOwnProperty . call ( tj , 'tiles' ) ) { if ( tj . tiles . constructor !== Array ) { return false ; } if ( tj . tiles . length < 1 ) { return false ; } for ( let i = 0 ; i < tj . tiles . length ; i += 1 ) { if ( typeof tj . tiles [ i ] !== 'string' ) { return false ; } } } else { return false ; } if ( Object . prototype . hasOwnProperty . call ( tj , 'grids' ) ) { if ( tj . grids . constructor !== Array ) { return false ; } for ( let i = 0 ; i < tj . grids . length ; i += 1 ) { if ( typeof tj . grids [ i ] !== 'string' ) { return false ; } } } if ( Object . prototype . hasOwnProperty . call ( tj , 'data' ) ) { if ( tj . data . constructor !== Array ) { return false ; } for ( let i = 0 ; i < tj . data . length ; i += 1 ) { if ( typeof tj . data [ i ] !== 'string' ) { return false ; } } } let minzoom = 0 ; if ( Object . prototype . hasOwnProperty . call ( tj , 'minzoom' ) ) { if ( typeof tj . minzoom !== 'number' ) { return false ; } if ( ! Number . isInteger ( tj . minzoom ) ) { return false ; } if ( tj . minzoom < 0 || tj . minzoom > 30 ) { return false ; } minzoom = tj . minzoom ; } let maxzoom = 30 ; if ( Object . prototype . hasOwnProperty . call ( tj , 'maxzoom' ) ) { if ( typeof tj . maxzoom !== 'number' ) { return false ; } if ( ! Number . isInteger ( tj . maxzoom ) ) { return false ; } if ( tj . maxzoom < 0 || tj . maxzoom > 30 ) { return false ; } maxzoom = tj . maxzoom ; } if ( minzoom > maxzoom ) { return false ; } if ( Object . prototype . hasOwnProperty . call ( tj , 'bounds' ) ) { if ( tj . bounds . constructor !== Array ) { return false ; } for ( let i = 0 ; i < tj . bounds . length ; i += 1 ) { if ( typeof tj . bounds [ i ] !== 'number' ) { return false ; } } } if ( Object . prototype . hasOwnProperty . call ( tj , 'center' ) ) { if ( tj . center . constructor !== Array ) { return false ; } for ( let i = 0 ; i < tj . center . length ; i += 1 ) { if ( typeof tj . center [ i ] !== 'number' ) { return false ; } } } return true ; } 
function validate ( str ) { let tj ; if ( typeof str === 'object' ) { tj = str ; } else if ( typeof str === 'string' ) { try { tj = jsonlint . parse ( str ) ; } catch ( err ) { return false ; } } else { return false ; } return tilejsonValidateObject . validate ( tj ) ; } 
function validatesNumber ( ) { var names = Array . from ( arguments ) , opts = util . type ( names [ names . length - 1 ] ) === 'object' ? names . pop ( ) : { } ; names . forEach ( function ( name ) { this . validate ( name , function ( ) { this . validateNumber ( name , opts ) ; } ) ; } , this ) ; return this ; } 
function validatesDate ( ) { Array . from ( arguments ) . forEach ( function ( name ) { this . validate ( name , function ( ) { this . validateDate ( name ) ; } ) ; } , this ) ; } 
function validatesEmail ( ) { Array . from ( arguments ) . forEach ( function ( name ) { this . validate ( name , function ( ) { this . validateEmail ( name ) ; } ) ; } , this ) ; return this ; } 
function validatesPhone ( ) { Array . from ( arguments ) . forEach ( function ( name ) { this . validate ( name , function ( ) { this . validatePhone ( name ) ; } ) ; } , this ) ; return this ; } 
function validatesDuration ( ) { Array . from ( arguments ) . forEach ( function ( name ) { this . validate ( name , function ( ) { this . validateDuration ( name ) ; } ) ; } , this ) ; return this ; } 
function parseNumber ( s ) { s = String ( s ) . replace ( / [^\d-.] / g , '' ) . replace ( / \.$ / , '' ) ; if ( ! s . match ( NUMBER_RE ) ) { return null ; } return parseFloat ( s , 10 ) ; } 
function parsePercent ( s ) { var n = parseNumber ( String ( s ) . replace ( '%' , '' ) ) ; return n == null ? null : n / 100 ; } 
function parseDate ( s ) { var m , d , y , date , parts ; s = String ( s ) . replace ( / \s / g , '' ) ; if ( parts = s . match ( ISO8601_DATE_RE ) ) { y = parseInt ( parts [ 1 ] , 10 ) ; m = parseInt ( parts [ 2 ] , 10 ) - 1 ; d = parseInt ( parts [ 3 ] , 10 ) ; date = new Date ( y , m , d ) ; return date . getMonth ( ) === m ? date : null ; } else if ( parts = s . match ( MDY_DATE_RE ) ) { m = parseInt ( parts [ 1 ] , 10 ) - 1 ; d = parseInt ( parts [ 2 ] , 10 ) ; y = parts [ 3 ] ? parseInt ( parts [ 3 ] , 10 ) : new Date ( ) . getFullYear ( ) ; if ( 0 <= y && y <= 68 ) { y += 2000 ; } if ( 69 <= y && y <= 99 ) { y += 1900 ; } date = new Date ( y , m , d ) ; return date . getMonth ( ) === m ? date : null ; } else { return null ; } } 
function parseDateTime ( s ) { var n ; s = String ( s ) ; if ( s . match ( NO_TZ_RE ) ) { s += 'Z' ; } return ( n = Date . parse ( s ) ) ? new Date ( n ) : null ; } 
function parseEmail ( s ) { s = String ( s ) ; return EMAIL_FORMAT . test ( s ) ? s : null ; } 
function parsePhone ( s ) { s = String ( s ) ; return PHONE_FORMAT . test ( s . replace ( PHONE_CHARS , '' ) ) ? s : null ; } 
function parseDuration ( s ) { s = String ( s ) ; if ( ! DURATION_RE . test ( s ) ) { return null ; } var parts = s . split ( ':' ) . map ( function ( p ) { return + p ; } ) ; if ( parts . length === 3 ) { return parts [ 0 ] * 3600 + parts [ 1 ] * 60 + parts [ 2 ] ; } else if ( parts . length === 2 ) { return parts [ 0 ] * 60 + parts [ 1 ] ; } else { return parts [ 0 ] ; } } 
function seen ( o1 , o2 ) { var i , len ; for ( i = 0 , len = seenObjects . length ; i < len ; i ++ ) { if ( seenObjects [ i ] [ 0 ] === o1 && seenObjects [ i ] [ 1 ] === o2 ) { return true ; } } return false ; } 
function unmark ( o1 , o2 ) { var i , n ; for ( i = 0 , n = seenObjects . length ; i < n ; i ++ ) { if ( seenObjects [ i ] [ 0 ] === o1 && seenObjects [ i ] [ 1 ] === o2 ) { seenObjects . splice ( i , 1 ) ; return ; } } } 
function _getPath ( o , pathSegments ) { if ( o == null ) { return undefined ; } var head = pathSegments [ 0 ] , tail = pathSegments . slice ( 1 ) ; if ( Array . isArray ( o ) && ! ( head in o ) ) { o = o . reduce ( function ( acc , x ) { if ( ! x ) { return acc ; } var y = x [ head ] ; if ( Array . isArray ( y ) ) { acc . push . apply ( acc , y ) ; } else { acc . push ( y ) ; } return acc ; } , [ ] ) ; } else { o = o [ head ] ; } if ( ! tail . length ) { return o ; } else { return o ? _getPath ( o , tail ) : undefined ; } } 
function detectRecursion ( o1 , o2 , f ) { if ( arguments . length === 2 ) { f = o2 ; o2 = undefined ; } if ( seen ( o1 , o2 ) ) { return true ; } else { mark ( o1 , o2 ) ; try { f ( ) ; } finally { unmark ( o1 , o2 ) ; } return false ; } } 
function type ( o ) { if ( o === null ) { return 'null' ; } if ( o === undefined ) { return 'undefined' ; } switch ( toString . call ( o ) ) { case '[object Array]' : return 'array' ; case '[object Arguments]' : return 'arguments' ; case '[object Function]' : return 'function' ; case '[object String]' : return 'string' ; case '[object Number]' : return 'number' ; case '[object Boolean]' : return 'boolean' ; case '[object Date]' : return 'date' ; case '[object RegExp]' : return 'regexp' ; case '[object Object]' : if ( o . hasOwnProperty ( 'callee' ) ) { return 'arguments' ; } 
function eq ( a , b ) { var atype , btype ; 
function arrayEq ( a , b ) { var r ; if ( ! Array . isArray ( a ) || ! Array . isArray ( b ) ) { return false ; } if ( a . length !== b . length ) { return false ; } r = true ; detectRecursion ( a , b , function ( ) { var i , len ; for ( i = 0 , len = a . length ; i < len ; i ++ ) { if ( ! eq ( a [ i ] , b [ i ] ) ) { r = false ; break ; } } } ) ; return r ; } 
function objectEq ( a , b ) { var akeys = Object . keys ( a ) , bkeys = Object . keys ( b ) , r ; if ( akeys . length !== bkeys . length ) { return false ; } r = true ; detectRecursion ( a , b , function ( ) { var i , len , key ; for ( i = 0 , len = akeys . length ; i < len ; i ++ ) { key = akeys [ i ] ; if ( ! b . hasOwnProperty ( key ) ) { r = false ; break ; } if ( ! eq ( a [ key ] , b [ key ] ) ) { r = false ; break ; } } } ) ; return r ; } 
function camelize ( s ) { return typeof s === 'string' ? s . replace ( / (?:[-_])(\w) / g , function ( _ , c ) { return c ? c . toUpperCase ( ) : '' ; } ) : s ; } 
function underscore ( s ) { return typeof s === 'string' ? s . replace ( / ([a-z\d])([A-Z]+) / g , '$1_$2' ) . replace ( / [-\s]+ / g , '_' ) . toLowerCase ( ) : s ; } 
function capitalize ( s ) { return typeof s === 'string' && s . length ? s [ 0 ] . toUpperCase ( ) + s . slice ( 1 ) : s ; } 
function resolve ( name ) { var raise = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; var klass = typeof name === 'function' ? name : subclasses [ name ] ; if ( ! klass && raise ) { throw new Error ( "Transis.Model.resolve: could not resolve subclass: `" + name + "`" ) ; } return klass ; } 
function checkAssociatedType ( desc , o ) { var klass = resolve ( desc . klass ) ; if ( o && ! ( o instanceof klass ) ) { throw new Error ( desc . debugName + ": expected an object of type `" + desc . klass + "` but received `" + o + "` instead" ) ; } } 
function wrapPromise ( promise ) { return promise . then ( function ( value ) { return new Promise ( function ( resolve , reject ) { _object2 . default . delay ( function ( ) { resolve ( value ) ; } ) ; _object2 . default . _queueFlush ( ) ; } ) ; } , function ( reason ) { return new Promise ( function ( resolve , reject ) { _object2 . default . delay ( function ( ) { reject ( reason ) ; } ) ; _object2 . default . _queueFlush ( ) ; } ) ; } ) ; } 
function hasManySplice ( i , n , added ) { var owner = this . __owner__ , desc = this . __desc__ , inverse = desc . inverse , name = desc . name , removed , changes , i ; added . forEach ( function ( o ) { return checkAssociatedType ( desc , o ) ; } ) ; removed = _array2 . default . prototype . _splice . call ( this , i , n , added ) ; if ( inverse && ! this . __handlingInverse__ ) { removed . forEach ( function ( model ) { model . _inverseRemoved ( inverse , owner ) ; } , this ) ; added . forEach ( function ( model ) { model . _inverseAdded ( inverse , owner ) ; } , this ) ; } if ( desc . owner && ! loads . length ) { changes = owner . ownChanges [ name ] = owner . ownChanges [ name ] || { added : [ ] , removed : [ ] } ; removed . forEach ( function ( m ) { if ( ( i = changes . added . indexOf ( m ) ) !== - 1 ) { changes . added . splice ( i , 1 ) ; } else if ( changes . removed . indexOf ( m ) === - 1 ) { changes . removed . push ( m ) ; } } ) ; added . forEach ( function ( m ) { if ( ( i = changes . removed . indexOf ( m ) ) !== - 1 ) { changes . removed . splice ( i , 1 ) ; } else if ( changes . added . indexOf ( m ) === - 1 ) { changes . added . push ( m ) ; } } ) ; if ( ! changes . added . length && ! changes . removed . length ) { owner . _clearChange ( name ) ; } else { owner . _setChange ( name , changes ) ; } } return removed ; } 
function hasManyInverseRemove ( model ) { var i = this . indexOf ( model ) ; if ( i >= 0 ) { this . __handlingInverse__ = true ; this . splice ( i , 1 ) ; this . __handlingInverse__ = false ; } } 
function hasManyArray ( owner , desc ) { var a = _array2 . default . of ( ) ; a . proxy ( owner , desc . name ) ; a . __owner__ = owner ; a . __desc__ = desc ; a . _splice = hasManySplice ; a . _inverseAdd = hasManyInverseAdd ; a . _inverseRemove = hasManyInverseRemove ; return a ; } 
function queryArrayQuery ( ) { var _this = this ; var queryOpts = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : { } ; var opts = Object . assign ( { } , this . baseOpts , queryOpts ) ; if ( this . isPaged ) { opts . page = opts . page || 1 ; } if ( this . isBusy ) { if ( util . eq ( opts , this . currentOpts ) ) { return this ; } if ( ! this . __queued__ ) { this . __promise__ = this . __promise__ . then ( function ( ) { _this . query ( _this . __queued__ ) ; _this . __queued__ = undefined ; return _this . __promise__ ; } ) ; } this . __queued__ = opts ; } else { this . isBusy = true ; this . currentOpts = opts ; this . __promise__ = wrapPromise ( this . __modelClass__ . _callMapper ( 'query' , [ opts ] ) . then ( function ( result ) { var results = Array . isArray ( result ) ? result : result . results ; var meta = Array . isArray ( result ) ? { } : result . meta ; _this . isBusy = false ; _this . meta = meta ; _this . error = undefined ; if ( ! results ) { throw new Error ( _this + "#query: mapper failed to return any results" ) ; } if ( _this . isPaged && typeof meta . totalCount !== 'number' ) { throw new Error ( _this + "#query: mapper failed to return total count for paged query" ) ; } try { var models = _this . __modelClass__ . loadAll ( results ) ; if ( _this . isPaged ) { _this . length = meta . totalCount ; _this . splice . apply ( _this , [ ( opts . page - 1 ) * _this . baseOpts . pageSize , models . length ] . concat ( models ) ) ; } else { _this . replace ( models ) ; } } catch ( e ) { console . error ( e ) ; throw e ; } } , function ( e ) { _this . isBusy = false ; _this . error = e ; return Promise . reject ( e ) ; } ) ) ; } return this ; } 
function queryArrayAt ( i ) { var r = _array2 . default . prototype . at . apply ( this , arguments ) ; var pageSize = this . baseOpts && this . baseOpts . pageSize ; if ( arguments . length === 1 && ! r && pageSize ) { this . query ( { page : Math . floor ( i / pageSize ) + 1 } ) ; } return r ; } 
function mapperDeleteSuccess ( ) { var _this2 = this ; _id_map2 . default . delete ( this ) ; this . isBusy = false ; this . sourceState = DELETED ; this . _clearErrors ( ) ; var _loop = function _loop ( name ) { var desc = _this2 . associations [ name ] ; if ( ! desc . inverse ) { return "continue" ; } if ( desc . type === 'hasOne' ) { var m = void 0 ; if ( m = _this2 [ name ] ) { m . _inverseRemoved ( desc . inverse , _this2 ) ; } } else if ( desc . type === 'hasMany' ) { _this2 [ name ] . slice ( 0 ) . forEach ( function ( m ) { m . _inverseRemoved ( desc . inverse , _this2 ) ; } ) ; } } ; for ( var name in this . associations ) { var _ret = _loop ( name ) ; if ( _ret === "continue" ) continue ; } } 
function _loop2 ( _name ) { var klass = resolve ( associations [ _name ] . klass ) ; var data = associated [ _name ] ; 
function propagateChanges ( ) { var seen = { } ; var head = void 0 ; for ( var id in changedObjects ) { var _changedObjects$id = changedObjects [ id ] , object = _changedObjects$id . object , props = _changedObjects$id . props ; for ( var k in props ) { head = { object : object , name : k , next : head } ; seen [ id + k ] = true ; } } while ( head ) { var _head = head , name = _head . name , object = _head . object , _head$object = _head . object , _objectId = _head$object . objectId , __deps__ = _head$object . __deps__ , __proxies__ = _head$object . __proxies__ ; var deps = __deps__ && __deps__ [ name ] ; head = head . next ; registerChange ( object , name ) ; if ( object . __cache__ ) { var val = object . __cache__ [ name ] ; if ( val && typeof val . unproxy === 'function' ) { val . unproxy ( object , name ) ; } delete object . __cache__ [ name ] ; } if ( deps ) { for ( var i = 0 , n = deps . length ; i < n ; i ++ ) { var seenKey = _objectId + deps [ i ] ; if ( ! seen [ seenKey ] ) { head = { object : object , name : deps [ i ] , next : head } ; seen [ seenKey ] = true ; } } } if ( __proxies__ && name . indexOf ( '.' ) === - 1 ) { for ( var _k in __proxies__ ) { var proxy = __proxies__ [ _k ] ; var proxyObject = proxy . object ; var proxyName = proxy . name + '.' + name ; var proxySeenKey = proxyObject . objectId + proxyName ; if ( ! seen [ proxySeenKey ] ) { head = { object : proxyObject , name : proxyName , next : head } ; seen [ proxySeenKey ] = true ; } } } } } 
function flush ( ) { var f = void 0 ; while ( f = delayPreFlushCallbacks . shift ( ) ) { f ( ) ; } propagateChanges ( ) ; var curChangedObjects = changedObjects ; changedObjects = { } ; flushTimer = null ; for ( var id in curChangedObjects ) { var _curChangedObjects$id = curChangedObjects [ id ] , object = _curChangedObjects$id . object , props = _curChangedObjects$id . props ; var star = false ; for ( var k in props ) { if ( k . indexOf ( '.' ) === - 1 ) { star = true ; } object . notify ( 
function defineProp ( object , name , opts = { } ) { validateOptions ( opts ) ; var descriptor = Object . assign ( { name : name , get : null , set : null , default : undefined , on : [ ] , cache : false , pure : ! ! ( opts . get && opts . on && ! opts . set ) , } , opts , { readonly : opts . get && ! opts . set } ) ; if ( ! object . hasOwnProperty ( '__props__' ) ) { object . __props__ = Object . create ( object . __props__ || null ) ; } object . __props__ [ name ] = descriptor ; if ( ! object . hasOwnProperty ( '__deps__' ) ) { object . __deps__ = Object . create ( object . __deps__ || null ) ; } descriptor . on . forEach ( function ( prop ) { ( object . __deps__ [ prop ] = object . __deps__ [ prop ] || [ ] ) . push ( name ) ; if ( prop . indexOf ( '.' ) !== - 1 ) { let segments = prop . split ( '.' ) , first = segments [ 0 ] , last = segments [ 1 ] ; if ( segments . length > 2 ) { throw new Error ( ` \` ${ prop } \` ` ) ; } ( object . __deps__ [ first ] = object . __deps__ [ first ] || [ ] ) . push ( name ) ; ( object . __deps__ [ ` ${ first } ` ] = object . __deps__ [ ` ${ first } ` ] || [ ] ) . push ( name ) ; ( object . __deps__ [ ` ${ first } ${ last } ` ] = object . __deps__ [ ` ${ first } ${ last } ` ] || [ ] ) . push ( name ) ; } else { ( object . __deps__ [ ` ${ prop } ` ] = object . __deps__ [ ` ${ prop } ` ] || [ ] ) . push ( name ) ; } } ) ; Object . defineProperty ( object , name , { get : function ( ) { return this . _getProp ( name ) ; } , set : descriptor . readonly ? undefined : function ( value ) { this . _setProp ( name , value ) ; } , configurable : false , enumerable : true } ) ; } 
function resolve ( name , raise = true ) { var klass = ( typeof name === 'function' ) ? name : subclasses [ name ] ; if ( ! klass && raise ) { throw new Error ( ` \` ${ name } \` ` ) ; } return klass ; } 
function hasOneSet ( desc , v , sync ) { var name = desc . name , k = ` ${ name } ` , prev = this [ k ] , inv = desc . inverse ; checkAssociatedType ( desc , v ) ; this [ k ] = v ; if ( sync && inv && prev ) { prev . _inverseRemoved ( inv , this ) ; } if ( sync && inv && v ) { v . _inverseAdded ( inv , this ) ; } if ( prev ) { prev . unproxy ( this , name ) ; } if ( v ) { v . proxy ( this , name ) ; } } 
function mapperDeleteSuccess ( ) { IdMap . delete ( this ) ; this . isBusy = false ; this . sourceState = DELETED ; this . _clearErrors ( ) ; for ( let name in this . associations ) { let desc = this . associations [ name ] ; if ( ! desc . inverse ) { continue ; } if ( desc . type === 'hasOne' ) { let m ; if ( m = this [ name ] ) { m . _inverseRemoved ( desc . inverse , this ) ; } } else if ( desc . type === 'hasMany' ) { this [ name ] . slice ( 0 ) . forEach ( ( m ) => { m . _inverseRemoved ( desc . inverse , this ) ; } ) ; } } } 
function file ( relpath ) { return { name : basename ( relpath ) , path : ` ${ relpath } ` , size : 123 , type : vcard . FILE_TYPES [ 0 ] } } 
function handleErrors ( errors , data ) { const message = errors [ 0 ] . message ; const error = new Error ( ` ${ message } ` ) ; error . rawError = errors ; error . rawData = data ; throw error ; } 
function zip ( zipFile , srcList , dstPath ) { if ( ! dstPath ) { dstPath = false ; } const output = fs . createWriteStream ( zipFile ) ; const archive = archiver ( 'zip' , { zlib : { level : 9 } 
function exec ( cmd , verbose ) { verbose = verbose === false ? verbose : true ; const stdout = execSync ( cmd ) ; if ( verbose ) { console . log ( stdout . toString ( ) ) ; } return stdout ; } 
function configureAws ( region , profile , role ) { if ( region ) { AWS . config . update ( { region } ) ; } if ( profile ) { AWS . config . credentials = new AWS . SharedIniFileCredentials ( { profile } ) ; } if ( role ) { AWS . config . credentials = new AWS . TemporaryCredentials ( { RoleArn : role } ) ; } } 
function fileToString ( file ) { try { const stat = fs . lstatSync ( file ) ; if ( stat . isFile ( ) ) { const content = fs . readFileSync ( file , 'utf8' ) ; return content . toString ( ) ; } } catch ( e ) { if ( ! e . message . includes ( 'ENOENT' ) && ! e . message . includes ( 'name too long, lstat' ) ) { throw e ; } } return file ; } 
function mergeYamls ( file1 , file2 ) { const obj1 = yaml . safeLoad ( fileToString ( file1 ) , { schema : yamlfiles . YAML_FILES_SCHEMA } ) ; const obj2 = yaml . safeLoad ( fileToString ( file2 ) , { schema : yamlfiles . YAML_FILES_SCHEMA } ) ; return yaml . safeDump ( merge ( { } , obj1 , obj2 ) ) ; } 
function loadKesOverride ( kesFolder , kesClass = 'kes.js' ) { let kesOverridePath = path . resolve ( kesFolder , kesClass ) ; let KesOverride ; try { KesOverride = require ( kesOverridePath ) ; } catch ( e ) { 
function determineKesClass ( options , Kes ) { let KesOverride ; 
function failure ( e ) { if ( e . message ) { console . log ( e . message ) ; } else { console . log ( e ) ; } process . exit ( 1 ) ; } 
function getSystemBucket ( config ) { let bucket = get ( config , 'buckets.internal' ) ; if ( bucket && typeof bucket === 'string' ) { return bucket ; } bucket = get ( config , 'system_bucket' ) ; if ( bucket && typeof bucket === 'string' ) { return bucket ; } return undefined ; } 
function buildNestedCfs ( config , KesClass , options ) { const limit = pLimit ( 1 ) ; if ( config . nested_templates ) { const nested = config . nested_templates ; console . log ( 'Nested templates are found!' ) ; const ps = Object . keys ( nested ) . map ( ( name ) => limit ( ( ) => { console . log ( ` ${ name } ` ) ; const newOptions = Object . assign ( { } , options ) ; newOptions . cfFile = nested [ name ] . cfFile ; newOptions . configFile = nested [ name ] . configFile ; 
function buildCf ( options , cmd ) { const KesClass = utils . determineKesClass ( options , Kes ) ; let parentConfig ; try { parentConfig = new Config ( options ) ; } catch ( e ) { return Promise . reject ( e ) ; } return buildNestedCfs ( parentConfig , KesClass , options ) . then ( ( config ) => { const kes = new KesClass ( config ) ; switch ( cmd ) { case 'create' : deprecate ( '"kes cf create" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . createStack ( ) ; case 'update' : deprecate ( '"kes cf update" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . updateStack ( ) ; case 'upsert' : deprecate ( '"kes cf upsert" command is deprecated. Use "kes cf deploy" instead' ) ; return kes . upsertStack ( ) ; case 'deploy' : return kes . deployStack ( ) ; case 'validate' : return kes . validateTemplate ( ) ; case 'compile' : return kes . compileCF ( ) ; case 'delete' : return kes . deleteStack ( ) ; default : console . log ( 'Wrong choice. Accepted arguments: [create|update|upsert|deploy|validate|compile]' ) ; } } ) ; } 
function buildLambda ( options , cmd ) { if ( cmd ) { const KesClass = utils . determineKesClass ( options , Kes ) ; const config = new Config ( options ) ; const kes = new KesClass ( config ) ; kes . updateSingleLambda ( cmd ) . then ( r => utils . success ( r ) ) . catch ( e => utils . failure ( e ) ) ; } else { utils . failure ( new Error ( 'Lambda name is missing' ) ) ; } } 
function sendResponse ( event , context , responseStatus , responseData ) { const responseBody = JSON . stringify ( { Status : responseStatus , Reason : 'See the details in CloudWatch Log Stream: ' + context . logStreamName , PhysicalResourceId : context . logStreamName , StackId : event . StackId , RequestId : event . RequestId , LogicalResourceId : event . LogicalResourceId , Data : responseData } ) ; console . log ( 'RESPONSE BODY:\n' , responseBody ) ; const https = require ( 'https' ) ; const url = require ( 'url' ) ; const parsedUrl = url . parse ( event . ResponseURL ) ; const options = { hostname : parsedUrl . hostname , port : 443 , path : parsedUrl . path , method : 'PUT' , headers : { 'content-type' : '' , 'content-length' : responseBody . length } } ; console . log ( 'SENDING RESPONSE...\n' ) ; const request = https . request ( options , function ( response ) { console . log ( 'STATUS: ' + response . statusCode ) ; console . log ( 'HEADERS: ' + JSON . stringify ( response . headers ) ) ; 
function optionsToString ( options ) { return Object . keys ( options ) . map ( function processOption ( key ) { return key + "=" + options [ key ] ; } ) . join ( "," ) ; } 
function optionsResolveCentered ( options ) { var result = options ; var width = window . outerWidth - options . width ; var height = window . outerHeight - options . height ; if ( options . centered ) { result . left = options . left || Math . round ( window . screenX + width / 2 ) ; result . top = options . top || Math . round ( window . screenY + height / 2.5 ) ; delete result . centered ; } return result ; } 
function assign ( target ) { var sources = Array . prototype . slice . call ( arguments , 1 ) ; function assignArgument ( previous , source ) { Object . keys ( source ) . forEach ( function assignItem ( key ) { previous [ key ] = source [ key ] ; 
function openPopupWithPost ( url , postData , name , options ) { var form = document . createElement ( "form" ) ; var win ; form . setAttribute ( "method" , "post" ) ; form . setAttribute ( "action" , url ) ; form . setAttribute ( "target" , name ) ; Object . keys ( postData ) . forEach ( function addFormItem ( key ) { var input = document . createElement ( "input" ) ; input . type = "hidden" ; input . name = key ; input . value = postData [ key ] ; form . appendChild ( input ) ; } ) ; document . body . appendChild ( form ) ; win = window . open ( "/" , name , options ) ; win . document . write ( "Loading..." ) ; form . submit ( ) ; document . body . removeChild ( form ) ; return win ; } 
function popupExecute ( execute , url , name , options , callback ) { var popupName = name || defaultPopupName ( ) ; var popupOptions = optionsResolveCentered ( assign ( { } , defaultOptions , options ) ) ; var popupCallback = callback || function noop ( ) { } ; var optionsString = optionsToString ( popupOptions ) ; var win = execute ( url , popupName , optionsString ) ; var isMessageSent = false ; var interval ; function popupCallbackOnce ( err , data ) { if ( ! isMessageSent ) { isMessageSent = true ; popupCallback ( err , data ) ; } } function onMessage ( message ) { var data = message ? message . data : undefined ; if ( data ) { popupCallbackOnce ( undefined , data ) ; window . removeEventListener ( "message" , onMessage ) ; } } window . addEventListener ( "message" , onMessage , false ) ; if ( win ) { interval = setInterval ( function closePopupCallback ( ) { if ( win == null || win . closed ) { setTimeout ( function delayWindowClosing ( ) { clearInterval ( interval ) ; popupCallbackOnce ( new Error ( "Popup closed" ) ) ; } , 500 ) ; } } , 100 ) ; } else { popupCallbackOnce ( new Error ( "Popup blocked" ) ) ; } return win ; } 
function popup ( url , name , options , callback ) { return popupExecute ( window . open , url , name , options , callback ) ; } 
function popupWithPost ( url , postData , name , options , callback ) { function openWithPostData ( popupUrl , popupName , optionsString ) { return openPopupWithPost ( popupUrl , postData , popupName , optionsString ) ; } return popupExecute ( openWithPostData , url , name , options , callback ) ; } 
function Selector ( filter , timeout , window , http , q ) { this . restrict = 'EAC' ; this . replace = true ; this . transclude = true ; this . scope = { name : '@?' , value : '=model' , disabled : '=?disable' , disableSearch : '=?' , required : '=?require' , multiple : '=?multi' , placeholder : '@?' , valueAttr : '@' , labelAttr : '@?' , groupAttr : '@?' , options : '=?' , debounce : '=?' , create : '&?' , limit : '=?' , rtl : '=?' , api : '=?' , change : '&?' , remote : '&?' , remoteParam : '@?' , remoteValidation : '&?' , remoteValidationParam : '@?' , removeButton : '=?' , softDelete : '=?' , closeAfterSelection : '=?' , viewItemTemplate : '=?' , dropdownItemTemplate : '=?' , dropdownCreateTemplate : '=?' , dropdownGroupTemplate : '=?' } ; this . templateUrl = 'selector/selector.html' ; $filter = filter ; $timeout = timeout ; $window = window ; $http = http ; $q = q ; } 
function getSyntax ( editor ) { const mode = editor . getMode ( ) ; if ( mode . name === 'htmlmixed' ) { return 'html' ; } return mode . name === 'xml' ? mode . configuration : mode . name ; } 
function getWrappingContentRange ( editor ) { if ( editor . somethingSelected ( ) ) { const sel = editor . listSelections ( ) . filter ( sel => sel . anchor !== sel . head ) [ 0 ] ; if ( sel ) { return comparePos ( sel . anchor , sel . head ) < 0 ? { from : sel . anchor , to : sel . head } : { from : sel . head , to : sel . anchor } ; } } 
function getTagRangeForPos ( editor , pos ) { const model = editor . getEmmetDocumentModel ( ) ; const tag = model && model . nodeForPoint ( pos ) ; if ( ! tag ) { return null ; } 
function betweenTags ( editor , range ) { if ( equalCursorPos ( range . anchor , range . head ) ) { const cursor = range . anchor ; const mode = editor . getModeAt ( cursor ) ; if ( mode . name === 'xml' ) { const left = editor . getTokenAt ( cursor ) ; const right = editor . getTokenAt ( Object . assign ( { } , cursor , { ch : cursor . ch + 1 } ) ) ; return left . type === 'tag bracket' && left . string === '>' && right . type === 'tag bracket' && right . string === '</' ; } } } 
function canExtract ( editor , pos , config ) { const tokenType = editor . getTokenTypeAt ( pos ) ; if ( config . type === 'stylesheet' ) { return tokenType !== 'comment' && tokenType !== 'string' ; } if ( config . syntax === 'html' ) { return tokenType === null ; } if ( config . syntax === 'slim' || config . syntax === 'pug' ) { return tokenType === null || tokenType === 'tag' || ( tokenType && / attribute / . test ( tokenType ) ) ; } if ( config . syntax === 'haml' ) { return tokenType === null || tokenType === 'attribute' ; } if ( config . syntax === 'jsx' ) { 
function getMarkupCompletions ( editor , pos , config ) { const line = editor . getLine ( pos . line ) . slice ( 0 , pos . ch ) ; const prefix = extractPrefix ( line , / [\w:\-$@] / ) ; 
function getStylesheetCompletions ( editor , pos , config ) { const line = editor . getLine ( pos . line ) . slice ( 0 , pos . ch ) ; const prefix = extractPrefix ( line , / [\w-@$] / ) ; if ( prefix ) { 
function getSnippetCompletions ( editor , pos , config ) { const { type , syntax } = config ; if ( ! editor . state . emmetCompletions ) { editor . state . emmetCompletions = { } ; } const cache = editor . state . emmetCompletions ; if ( ! ( syntax in cache ) ) { const registry = createSnippetsRegistry ( type , syntax , config . snippets ) ; cache [ syntax ] = type === 'stylesheet' ? getStylesheetSnippets ( registry , config ) : getMarkupSnippets ( registry , config ) ; } return cache [ syntax ] ; } 
function getStylesheetSnippets ( registry ) { return convertToCSSSnippets ( registry ) . map ( snippet => { let preview = snippet . property ; const keywords = snippet . keywords ( ) ; if ( keywords . length ) { preview += ` ${ removeFields ( keywords . join ( ' | ' ) ) } ` ; } else if ( snippet . value ) { preview += ` ${ removeFields ( snippet . value ) } ` ; } return { key : snippet . key , value : snippet . value , snippet : snippet . key , property : snippet . property , keywords : keywords . map ( kw => { const m = kw . match ( / ^[\w-]+ / ) ; return m && { key : m [ 0 ] , preview : removeFields ( kw ) , snippet : kw } ; } ) . filter ( Boolean ) , preview } ; } ) ; } 
function getMarkupSnippets ( registry , config ) { return registry . all ( { type : 'string' } ) . map ( snippet => ( { key : snippet . key , value : snippet . value , preview : removeFields ( expand ( snippet . value , config ) ) , snippet : snippet . key } ) ) ; } 
function extractPrefix ( str , match ) { let offset = str . length ; while ( offset > 0 ) { if ( ! match . test ( str [ offset - 1 ] ) ) { break ; } offset -- ; } return str . slice ( offset ) ; } 
function isValidMarker ( editor , marker ) { const range = marker . find ( ) ; 
function ( property ) { var def = this . _definition [ property ] ; if ( def . type === 'boolean' ) { 
function ( attr ) { if ( attr == null ) return ! ! Object . keys ( this . _changed ) . length ; if ( has ( this . _derived , attr ) ) { return this . _derived [ attr ] . depList . some ( function ( dep ) { return this . hasChanged ( dep ) ; } , this ) ; } return has ( this . _changed , attr ) ; } 
function ( propertyName ) { if ( ! this . _eventBubblingHandlerCache [ propertyName ] ) { this . _eventBubblingHandlerCache [ propertyName ] = function ( name , model , newValue ) { if ( changeRE . test ( name ) ) { this . trigger ( 'change:' + propertyName + '.' + name . split ( ':' ) [ 1 ] , model , newValue ) ; } else if ( name === 'change' ) { this . trigger ( 'change' , this ) ; } } . bind ( this ) ; } return this . _eventBubblingHandlerCache [ propertyName ] ; } 
function createPropertyDefinition ( object , name , desc , isSession ) { var def = object . _definition [ name ] = { } ; var type , descArray ; if ( isString ( desc ) ) { 
function createDerivedProperty ( modelProto , name , definition ) { var def = modelProto . _derived [ name ] = { fn : isFunction ( definition ) ? definition : definition . fn , cache : ( definition . cache !== false ) , depList : definition . deps || [ ] } ; 
function queue ( ) { while ( current < config . concurLimit && files . length > 0 ) { var file = files . shift ( ) allFiles . push ( Promise . resolve ( file ) . then ( function ( file ) { return clean . processOneClean ( file ) . then ( function ( filePath ) { if ( typeof filePath === 'string' ) { filesCleaned . push ( filePath ) } proceed ( ) } ) . catch ( function ( err ) { proceed ( ) functions . logError ( err ) throw err } ) } ) ) current ++ } } 
function reWriter ( goCrazy , filePath , data ) { if ( goCrazy ) { data = data || 'changed data' fs . writeFileSync ( filePath , data ) reWriteTimer = setTimeout ( function ( ) { reWriter ( goCrazy , filePath , data ) } , 500 ) } else { clearTimeout ( reWriteTimer ) } } 
function missingSource ( ) { let preferredPath = path . basename ( config . path . source ) let source = obj . source source = source . replace ( config . path . source , preferredPath ) source = source . replace ( config . path . dest , preferredPath ) source = source . replace ( path . basename ( config . path . dest ) , preferredPath ) if ( source . toLowerCase ( ) . endsWith ( '.map' ) ) { source = functions . removeExt ( source ) } if ( shared . slash !== '/' ) { 
function queue ( ) { while ( current < config . concurLimit && files . length > 0 ) { var file = files . shift ( ) allFiles . push ( Promise . resolve ( file ) . then ( function ( file ) { return build . processOneBuild ( file ) . then ( function ( filePath ) { if ( typeof filePath === 'string' ) { filesBuilt . push ( filePath ) } proceed ( ) } ) . catch ( function ( err ) { proceed ( ) functions . logError ( err ) throw err } ) } ) ) current ++ } } 
function Image ( image , address ) { var at = this . attributes = image . attribs ; this . name = path . basename ( at . src , path . extname ( at . src ) ) ; this . saveTo = path . dirname ( require . main . filename ) + "/" ; this . extension = path . extname ( at . src ) ; this . address = url . resolve ( address , at . src ) ; this . fromAddress = address ; } 
function shipitTask ( grunt ) { 'use strict' ; 
function injectTemplate ( s , node , offset , id ) { const t = node . src ? readSrc ( id , node . src ) : node . content 
function listen ( ) { if ( state . listening ) return EjsElectron 
function stopListening ( ) { if ( ! state . listening ) return EjsElectron 
function compileEjs ( pathname , contentBuffer ) { state . data . ejse = EjsElectron state . options . filename = pathname let contentString = contentBuffer . toString ( ) let compiledEjs = ejs . render ( contentString , state . data , state . options ) return new Buffer ( compiledEjs ) } 
function _defaultCheckSize ( size ) { return function ( raw ) { if ( raw . length < size ) { return false ; } this . buffer = raw . substr ( size ) ; return raw . substr ( 0 , size ) ; } ; } 
function rstr_hmac_sha512 ( key , data ) { var bkey = rstr2binb ( key ) ; if ( bkey . length > 32 ) bkey = binb_sha512 ( bkey , key . length * 8 ) ; var ipad = Array ( 32 ) , opad = Array ( 32 ) ; for ( var i = 0 ; i < 32 ; i ++ ) { ipad [ i ] = bkey [ i ] ^ 0x36363636 ; opad [ i ] = bkey [ i ] ^ 0x5C5C5C5C ; } var hash = binb_sha512 ( ipad . concat ( rstr2binb ( data ) ) , 1024 + data . length * 8 ) ; return binb2rstr ( binb_sha512 ( opad . concat ( hash ) , 1024 + 512 ) ) ; } 
function int64add5 ( dst , a , b , c , d , e ) { var w0 = ( a . l & 0xffff ) + ( b . l & 0xffff ) + ( c . l & 0xffff ) + ( d . l & 0xffff ) + ( e . l & 0xffff ) ; var w1 = ( a . l >>> 16 ) + ( b . l >>> 16 ) + ( c . l >>> 16 ) + ( d . l >>> 16 ) + ( e . l >>> 16 ) + ( w0 >>> 16 ) ; var w2 = ( a . h & 0xffff ) + ( b . h & 0xffff ) + ( c . h & 0xffff ) + ( d . h & 0xffff ) + ( e . h & 0xffff ) + ( w1 >>> 16 ) ; var w3 = ( a . h >>> 16 ) + ( b . h >>> 16 ) + ( c . h >>> 16 ) + ( d . h >>> 16 ) + ( e . h >>> 16 ) + ( w2 >>> 16 ) ; dst . l = ( w0 & 0xffff ) | ( w1 << 16 ) ; dst . h = ( w2 & 0xffff ) | ( w3 << 16 ) ; } 
function ( configFile , options ) { DataStream . call ( this ) ; this . options = options || { } ; var self = this ; 
function getSandboxMap ( ast ) { var map = { } ; walker . with_walkers ( { 
function ( vars ) { for ( var i = 0 , c = vars . length , varItem ; i < c ; i ++ ) { varItem = vars [ i ] ; if ( varItem [ 0 ] === 'sandbox' ) { varItem [ 1 ] [ 1 ] . forEach ( function ( objectVar ) { map [ objectVar [ 0 ] ] = objectVar [ 1 ] [ 1 ] ; } ) ; throw 0 ; } } } 
function breakSandbox ( ast , replaceMap ) { var sandboxName = ast [ 2 ] [ 0 ] || 'sb' ; var newAst = walker . with_walkers ( { 
function brakeSandboxes ( ast ) { var map = getSandboxMap ( ast ) , isSandboxVariableWiped = false ; return walker . with_walkers ( { 
function ( ) { if ( isSandboxVariableWiped ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem [ 0 ] === 'sandbox' ) { isSandboxVariableWiped = true ; this [ 1 ] . splice ( i , 1 ) ; return this ; } } } 
function getEvents ( ast ) { var usage = { } , eventIndex = 0 ; walker . with_walkers ( { 
function ( ) { if ( this [ 1 ] && this [ 2 ] [ 0 ] ) { var functionName = this [ 1 ] [ 1 ] ; switch ( functionName ) { case "lmd_on" : case "lmd_trigger" : var eventName = this [ 2 ] [ 0 ] [ 1 ] ; if ( ! usage [ eventName ] ) { usage [ eventName ] = { on : 0 , trigger : 0 , eventIndex : eventIndex } ; eventIndex ++ ; } if ( functionName === "lmd_on" ) { usage [ eventName ] . on ++ ; } else { usage [ eventName ] . trigger ++ ; } break ; } } } 
function wipeLmdEvents ( ast ) { var itemsToWipe = [ 'lmd_on' , 'lmd_trigger' , 'lmd_events' ] ; return walker . with_walkers ( { 
function ( ) { if ( ! itemsToWipe . length ) { return ; } for ( var i = 0 , c = this [ 1 ] . length , varItem ; i < c ; i ++ ) { varItem = this [ 1 ] [ i ] ; if ( varItem ) { var itemIndex = itemsToWipe . indexOf ( varItem [ 0 ] ) ; if ( itemIndex !== - 1 ) { itemsToWipe . splice ( itemIndex , 1 ) ; this [ 1 ] . splice ( i , 1 ) ; i -- ; } } } } 
function reduceAndShortenLmdEvents ( ast ) { var events = getEvents ( ast ) , isWipeLmdEvents = true ; for ( var eventName in events ) { if ( isWipeLmdEvents ) { if ( events [ eventName ] . on !== 0 && events [ eventName ] . trigger !== 0 ) { [ "call", ["name", "lmd_trigger"], [ ["string", "lmd-register:call-sandboxed-module"], ["name", "moduleName"], ["name", "require"] ] ] ---> [ "array", [ ["name", "moduleName"], ["name", "require"] ] ] */ return [ "array" , this [ 2 ] . slice ( 1 ) ] ; } [main][0] ---> main */ return this [ 1 ] [ 1 ] [ index ] ; } } } } , function ( ) { return walker . walk ( ast ) ; } ) ; return ast ; } 
function ( ) { if ( this [ 1 ] && this [ 2 ] [ 0 ] ) { var functionName = this [ 1 ] [ 1 ] , eventName , eventDescriptor ; switch ( functionName ) { case "lmd_on" : eventName = this [ 2 ] [ 0 ] [ 1 ] ; eventDescriptor = events [ eventName ] ; [ "call", ["name", "lmd_trigger"], [ ["string", "lmd-register:call-sandboxed-module"], ["name", "moduleName"], ["name", "require"] ] ] ---> [ "array", [ ["name", "moduleName"], ["name", "require"] ] ] */ return [ "array" , this [ 2 ] . slice ( 1 ) ] ; } 
function ( optionName , isApply , isInline ) { 
function ( e ) { if ( isNotLoaded ) { isNotLoaded = 0 ; 
function d3_layout_hierarchyRebind ( object , hierarchy ) { object . sort = d3 . rebind ( object , hierarchy . sort ) ; object . children = d3 . rebind ( object , hierarchy . children ) ; object . links = d3_layout_hierarchyLinks ; object . value = d3 . rebind ( object , hierarchy . value ) ; 
function position ( row , u , rect , flush ) { var i = - 1 , n = row . length , x = rect . x , y = rect . y , v = u ? round ( row . area / u ) : 0 , o ; if ( u == rect . dx ) { 
function ( classes ) { var map = { } ; function find ( name , data ) { var node = map [ name ] , i ; if ( ! node ) { node = map [ name ] = data || { name : name , children : [ ] } ; if ( name . length ) { node . parent = find ( "" ) ; node . parent . children . push ( node ) ; node . name = name ; node . key = escapeId ( name ) ; } } return node ; } classes . forEach ( function ( d ) { find ( d . name , d ) ; } ) ; return map [ "" ] ; } 
function stringify ( object ) { var properties = [ ] ; for ( var key in object ) { if ( object . hasOwnProperty ( key ) ) { properties . push ( quote ( key ) + ':' + getValue ( object [ key ] ) ) ; } } return "{" + properties . join ( "," ) + "}" ; } 
function ( ) { this . input = this . $ ( '#new-todo' ) ; this . allCheckbox = this . $ ( '#toggle-all' ) [ 0 ] ; this . $footer = this . $ ( '#footer' ) ; this . $main = this . $ ( '#main' ) ; todos . on ( 'add' , this . addOne , this ) ; todos . on ( 'reset' , this . addAll , this ) ; todos . on ( 'change:completed' , this . filterOne , this ) ; todos . on ( "filter" , this . filterAll , this ) ; todos . on ( 'all' , this . render , this ) ; todos . fetch ( ) ; } 
function ( ) { var completed = todos . completed ( ) . length ; var remaining = todos . remaining ( ) . length ; if ( todos . length ) { this . $main . show ( ) ; this . $footer . show ( ) ; this . $footer . html ( this . template ( { completed : completed , remaining : remaining } ) ) ; this . $ ( '#filters li a' ) . removeClass ( 'selected' ) . filter ( '[href="#/' + ( common . TodoFilter || '' ) + '"]' ) . addClass ( 'selected' ) ; } else { this . $main . hide ( ) ; this . $footer . hide ( ) ; } this . allCheckbox . checked = ! remaining ; } 
function ( e ) { if ( e . which !== common . ENTER_KEY || ! this . input . val ( ) . trim ( ) ) { return ; } todos . create ( this . newAttributes ( ) ) ; this . input . val ( '' ) ; } 
function countLine ( ) { var ret ; 
function countIf ( ) { var self = this , ret ; if ( self [ 0 ] . start && analyzing . indexOf ( self ) < 0 ) { var decision = self [ 1 ] ; var lineId = self [ 0 ] . name + ':' + ( self [ 0 ] . start . line + lineOffset ) ; self [ 1 ] = wrapCondition ( decision , lineId ) ; 
function wrapCondition ( decision , lineId , parentPos ) { if ( options . condition === false ) { 
function isSingleCondition ( decision ) { if ( decision [ 0 ] . start && decision [ 0 ] . name != "binary" ) { return true ; } else if ( decision [ 1 ] == "&&" || decision [ 1 ] == "||" ) { return false ; } else { return true ; } } 
function countLabel ( ) { var ret ; if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 ) { var content = this [ 2 ] ; if ( content [ 0 ] . name == "for" && content [ 4 ] && content [ 4 ] . name != "block" ) { content [ 4 ] = [ "block" , [ content [ 4 ] ] ] ; } analyzing . push ( content ) ; var ret = countLine . call ( this ) ; analyzing . pop ( content ) ; } return ret ; } 
function countFunction ( ) { var ret ; if ( isFirstLine ) { isFirstLine = false ; return ret ; } if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 ) { var defun = this [ 0 ] . name === "defun" ; var lineId = this [ 0 ] . start . line + lineOffset + '' ; 
function giveNameToAnonymousFunction ( ) { var node = this ; if ( node [ 0 ] . name == "var" || node [ 0 ] . name == "object" ) { node [ 1 ] . forEach ( function ( assignemt ) { if ( assignemt [ 1 ] ) { if ( assignemt [ 1 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } else if ( assignemt [ 1 ] [ 0 ] . name === "conditional" ) { if ( assignemt [ 1 ] [ 2 ] [ 0 ] && assignemt [ 1 ] [ 2 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 2 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } if ( assignemt [ 1 ] [ 3 ] [ 0 ] && assignemt [ 1 ] [ 3 ] [ 0 ] . name === "function" ) { assignemt [ 1 ] [ 3 ] [ 0 ] . anonymousName = assignemt [ 0 ] ; } } } } ) ; } else if ( node [ 0 ] . name == "assign" && node [ 1 ] === true ) { if ( node [ 3 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } else if ( node [ 3 ] [ 0 ] === "conditional" ) { if ( node [ 3 ] [ 2 ] [ 0 ] && node [ 3 ] [ 2 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 2 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } if ( node [ 3 ] [ 3 ] [ 0 ] && node [ 3 ] [ 3 ] [ 0 ] . name === "function" ) { node [ 3 ] [ 3 ] [ 0 ] . anonymousName = getNameFromAssign ( node ) ; } } } } 
function wrapConditionals ( ) { if ( options . condition === false ) { 
function ( name , deps , module ) { switch ( arguments . length ) { case 1 : 
function stats_calculate_coverage ( moduleName ) { var stats = sb . trigger ( '*:stats-get' , moduleName , null ) [ 1 ] , total , covered , lineId , lineNum , parts ; var lineReport = { } ; if ( ! stats . lines ) { return ; } stats . coverage = { } ; covered = 0 ; total = stats . lines . length ; for ( lineId in stats . runLines ) { if ( stats . runLines [ lineId ] > 0 ) { covered ++ ; } else { lineNum = lineId ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } lineReport [ lineNum ] . lines = false ; } } stats . coverage . lines = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . functions . length ; for ( lineId in stats . runFunctions ) { if ( stats . runFunctions [ lineId ] > 0 ) { covered ++ ; } else { parts = lineId . split ( ':' ) ; lineNum = parts [ 1 ] ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } if ( ! lineReport [ lineNum ] . functions ) { lineReport [ lineNum ] . functions = [ ] ; } lineReport [ lineNum ] . functions . push ( parts [ 0 ] ) ; } } stats . coverage . functions = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; covered = 0 ; total = stats . conditions . length ; for ( lineId in stats . runConditions ) { if ( stats . runConditions [ lineId ] [ 1 ] > 0 ) { covered += 1 ; } if ( stats . runConditions [ lineId ] [ 1 ] === 0 ) { parts = lineId . split ( ':' ) ; lineNum = parts [ 1 ] ; if ( ! lineReport [ lineNum ] ) { lineReport [ lineNum ] = { } ; } if ( ! lineReport [ lineNum ] . conditions ) { lineReport [ lineNum ] . conditions = [ ] ; } lineReport [ lineNum ] . conditions . push ( stats . runConditions [ lineId ] ) ; } } stats . coverage . conditions = { total : total , covered : covered , percentage : 100.0 * ( total ? covered / total : 1 ) } ; stats . coverage . report = lineReport ; } 
function Roster ( element ) { element . innerHTML += this . renderWrapper ( ) ; var contactsHtml = [ ] ; for ( var i = 100 ; i -- > 0 ; ) { contactsHtml . push ( this . renderItem ( ) ) ; } $ ( '.b-roster' ) . innerHTML = contactsHtml . join ( '' ) ; $ ( '.b-roster' ) . addEventListener ( 'click' , function ( e ) { // Preload talk for dialog using parallel resource loading require . async ( [ 'js/lmd/modules/b-dialog.min.js' , 'js/lmd/modules/b-talk.min.js' ] , function ( Dialog ) { new Dialog ( element ) ; } ) ; } , false ) ; } 
function renderMap ( ) { var $map = $ ( '#map' ) ; 
function interpolateConfigStrings ( config , data ) { data = data || config ; for ( var key in config ) { var value = config [ key ] ; if ( typeof value === "object" ) { config [ key ] = interpolateConfigStrings ( value , data ) ; } else if ( typeof value === "string" ) { var currentInterpolation = 0 ; while ( templateParts . test ( value ) ) { currentInterpolation ++ ; if ( currentInterpolation > maxInterpolateRecursion ) { break ; } config [ key ] = value = template ( value , data ) ; } } } return config ; } 
function ( config , mixins ) { if ( Array . isArray ( config . mixins ) && Array . isArray ( mixins ) ) { config . mixins . push . apply ( config . mixins , mixins ) ; return config ; } return deepDestructableMerge ( config , { mixins : mixins } ) ; } 
function ( left , right ) { for ( var prop in right ) { if ( right . hasOwnProperty ( prop ) ) { if ( typeof left [ prop ] === "object" ) { deepDestructableMerge ( left [ prop ] , right [ prop ] ) ; } else { left [ prop ] = right [ prop ] ; } } } return left ; } 
function ( config , configDir ) { config = config || { } ; if ( typeof config . extends !== "string" ) { return config ; } var parentConfig = tryExtend ( readConfig ( configDir , config . extends ) , configDir ) ; return deepDestructableMerge ( parentConfig , config ) ; } 
function ( modulePath , dependsFileMask ) { modulePath = [ ] . concat ( modulePath ) ; return modulePath . map ( function ( modulePath ) { var fileName = modulePath . replace ( / ^.*\/|\.[a-z0-9]+$ / g , '' ) ; return path . join ( path . dirname ( modulePath ) , dependsFileMask . replace ( '*' , fileName ) ) ; } ) ; } 
function ( configA , configB , flagsNames , isMasterConfig ) { 
function ( configA , configB , flagsNames , inheritableFields , isMasterConfig , context ) { if ( isMasterConfig ) { 
function ( rawConfig , configFile , configDir , flagsNames , extraOptions , usedConfigs ) { flagsNames = flagsNames || Object . keys ( LMD_PLUGINS ) ; var isFirstRun = typeof usedConfigs === "undefined" ; usedConfigs = usedConfigs || { } ; usedConfigs [ configFile ] = true ; 
function ( configFile , flagsNames , extraOptions , usedConfigs ) { var configDir = path . dirname ( configFile ) , rawConfig = readConfig ( configFile ) ; configFile = fs . realpathSync ( configFile ) ; return assembleLmdConfigAsObject ( rawConfig , configFile , configDir , flagsNames , extraOptions , usedConfigs ) ; } 
function addPluginsFromBundles ( resultConfig ) { if ( resultConfig . bundles ) { var bundles = Object . keys ( resultConfig . bundles ) , lmdPlugins = Object . keys ( LMD_PLUGINS ) ; 
function ( config , configDir ) { var modules = { } , globalLazy = config . lazy || false , globalDepends = ( config . depends === true ? DEFAULT_DEPENDS_MASK : config . depends ) || false , moduleLazy = false , moduleTypeHint , moduleName , modulePath , moduleRealPath , moduleExists , moduleExports , moduleRequire , moduleBind , moduleFileName , moduleFilePath , moduleDesciptor , wildcardRegex , isMultiPathModule , moduleData , isThirdPartyModule , modulesDirPath = config . root || config . path || '' ; modulesDirPath = path . resolve ( configDir , modulesDirPath ) ; 
function ( code , options ) { var exports = [ ] , requires = [ ] , bind = [ ] , extra_exports = options . extra_exports , extra_require = options . extra_require , extra_bind = options . extra_bind , exportCode , bindModuleName ; 
function ( code , moduleOptions , moduleType ) { switch ( moduleType ) { case "3-party" : 
function getModuleType ( code ) { var ast ; if ( typeof code === "object" ) { ast = code ; } else { try { JSON . parse ( code ) ; return "json" ; } catch ( e ) { } try { ast = parser . parse ( code ) ; } catch ( e ) { return "string" ; } } 
function getModuleFileByShortName ( lmdDir , shortName ) { var files ; try { files = fs . readdirSync ( lmdDir ) ; } catch ( e ) { return void 0 ; } for ( var i = 0 , c = files . length , fileName ; i < c ; i ++ ) { fileName = files [ i ] ; var fileExtension = ( fileName . match ( reLmdFile ) || 0 ) [ 0 ] ; if ( fileExtension && path . basename ( fileName , fileExtension ) === shortName ) { return fileName ; } } } 
function d3_transform ( m ) { var r0 = [ m . a , m . b ] , r1 = [ m . c , m . d ] , kx = d3_transformNormalize ( r0 ) , kz = d3_transformDot ( r0 , r1 ) , ky = d3_transformNormalize ( d3_transformCombine ( r1 , r0 , - kz ) ) ; this . translate = [ m . e , m . f ] ; this . rotate = Math . atan2 ( m . b , m . a ) * d3_transformDegrees ; this . scale = [ kx , ky || 0 ] ; this . skew = ky ? kz / ky * d3_transformDegrees : 0 ; } 
function d3_svg_linePoints ( self , d , x , y ) { var points = [ ] , i = - 1 , n = d . length , fx = typeof x === "function" , fy = typeof y === "function" , value ; if ( fx && fy ) { while ( ++ i < n ) points . push ( [ x . call ( self , value = d [ i ] , i ) , y . call ( self , value , i ) ] ) ; } else if ( fx ) { while ( ++ i < n ) points . push ( [ x . call ( self , d [ i ] , i ) , y ] ) ; } else if ( fy ) { while ( ++ i < n ) points . push ( [ x , y . call ( self , d [ i ] , i ) ] ) ; } else { while ( ++ i < n ) points . push ( [ x , y ] ) ; } return points ; } 
function chord ( d , i ) { var s = subgroup ( this , source , d , i ) , t = subgroup ( this , target , d , i ) ; return "M" + s . p0 + arc ( s . r , s . p1 ) + ( equals ( s , t ) ? curve ( s . r , s . p1 , s . r , s . p0 ) : curve ( s . r , s . p1 , t . r , t . p0 ) + arc ( t . r , t . p1 ) + curve ( t . r , t . p1 , s . r , s . p0 ) ) + "Z" ; } 
function brush ( g ) { var resizes = x && y ? [ "n" , "e" , "s" , "w" , "nw" , "ne" , "se" , "sw" ] : x ? [ "e" , "w" ] : y ? [ "n" , "s" ] : [ ] ; g . each ( function ( ) { var g = d3 . select ( this ) . on ( "mousedown.brush" , down ) , bg = g . selectAll ( ".background" ) . data ( [ , ] ) , fg = g . selectAll ( ".extent" ) . data ( [ , ] ) , tz = g . selectAll ( ".resize" ) . data ( resizes , String ) , e ; 
function start ( ) { d3_behavior_dragEvent = event ; d3_behavior_dragEventTarget = d3 . event . target ; d3_behavior_dragTarget = this ; d3_behavior_dragArguments = arguments ; d3_behavior_dragOrigin = d3_behavior_dragPoint ( ) ; if ( origin ) { d3_behavior_dragOffset = origin . apply ( d3_behavior_dragTarget , d3_behavior_dragArguments ) ; d3_behavior_dragOffset = [ d3_behavior_dragOffset . x - d3_behavior_dragOrigin [ 0 ] , d3_behavior_dragOffset . y - d3_behavior_dragOrigin [ 1 ] ] ; } else { d3_behavior_dragOffset = [ 0 , 0 ] ; } d3_behavior_dragMoved = 0 ; } 
function start ( ) { d3_behavior_zoomXyz = xyz ; d3_behavior_zoomExtent = extent ; d3_behavior_zoomDispatch = event . zoom ; d3_behavior_zoomEventTarget = d3 . event . target ; d3_behavior_zoomTarget = this ; d3_behavior_zoomArguments = arguments ; } 
function mousewheel ( ) { start . apply ( this , arguments ) ; if ( ! d3_behavior_zoomZooming ) d3_behavior_zoomZooming = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ; d3_behavior_zoomTo ( d3_behavior_zoomDelta ( ) + xyz [ 2 ] , d3 . svg . mouse ( d3_behavior_zoomTarget ) , d3_behavior_zoomZooming ) ; } 
function touchstart ( ) { start . apply ( this , arguments ) ; var touches = d3_behavior_zoomTouchup ( ) , touch , now = Date . now ( ) ; if ( ( touches . length === 1 ) && ( now - d3_behavior_zoomLast < 300 ) ) { d3_behavior_zoomTo ( 1 + Math . floor ( xyz [ 2 ] ) , touch = touches [ 0 ] , d3_behavior_zoomLocations [ touch . identifier ] ) ; } d3_behavior_zoomLast = now ; } 
function d3_behavior_zoomDelta ( ) { 
function d3_behavior_zoomTouchup ( ) { var touches = d3 . svg . touches ( d3_behavior_zoomTarget ) , i = - 1 , n = touches . length , touch ; while ( ++ i < n ) d3_behavior_zoomLocations [ ( touch = touches [ i ] ) . identifier ] = d3_behavior_zoomLocation ( touch ) ; return touches ; } 
function ( _main , _modules , _modules_options ) { if ( typeof _main === "object" ) { _modules_options = _modules ; _modules = _main ; } for ( var moduleName in _modules ) { 
function drawImageOnCanvas ( img ) { var ctx = $ ( 'canvas' ) [ 0 ] . getContext ( '2d' ) ; ctx . drawImage ( img , 0 , 0 ) ; ctx . rotate ( - Math . PI / 12 ) ; ctx . translate ( 0 , 150 ) ; } 
function ( data ) { var config ; 
function stillCurrent ( urlNode , options ) { var lesser , greater , oPath ; var now = Date . now ( ) ; var lMod = _ . first ( urlNode . lastmod ) ; var cFreq = _ . first ( urlNode . changefreq ) ? _ . first ( urlNode . changefreq ) . toLowerCase ( ) : null ; 
function parse ( options , document , callback ) { xml2js . parseString ( document , { trim : true , normalizeTags : true , normalize : true } , function ( err , result ) { var source = options . source ; if ( ! err ) { 
function convert ( options , buffer , next , callback ) { var gunzip = path . extname ( options . source ) === ".gz" ; if ( gunzip ) { zlib . gunzip ( buffer , function ( err , result ) { if ( err ) { callback ( common . prependMsgToErr ( err , options . source , true ) ) ; } else { next ( options , result && result . toString ( ) , callback ) ; } } ) ; } else { next ( options , buffer . toString ( ) , callback ) ; } } 
function getUrl ( options , parseFn , callback ) { request ( { url : options . source , encoding : null , timeout : options . timeout ( ) 
function getFile ( options , parseFn , callback ) { fs . readFile ( options . source , function ( err , data ) { if ( err ) { callback ( common . prependMsgToErr ( err , options . source , true ) ) ; } else { convert ( options , data , parseFn , callback ) ; } } ) ; } 
function ( ) { var options = { } ; var defaults = { 
function ( options , must ) { if ( must ) { for ( var prop in must ) { if ( options [ prop ] === void 0 || options [ prop ] === null ) { options [ prop ] = must [ prop ] ; } } } return options ; } 
function ( error , message , quoteInput ) { var result , prepend , empty = "" , quote = "'" ; if ( error ) { if ( message ) { prepend = quoteInput ? empty . concat ( quote , message , quote ) : message ; } 
function ( res , mediaTypes ) { var contentTypeOk , result = "status: '" + res . statusCode + "', GET failed." ; mediaTypes = ! Array . isArray ( mediaTypes ) ? [ mediaTypes ] : mediaTypes ; if ( res . statusCode === 200 ) { 
function nodeCall ( nodeFunc ) { var nodeArgs = Array . prototype . slice . call ( arguments , 1 ) ; return new Promise ( function ( resolve , reject ) { function nodeResolver ( err , value ) { if ( err ) { reject ( err ) ; } else { resolve ( value ) ; } } nodeArgs . push ( nodeResolver ) ; nodeFunc . apply ( nodeFunc , nodeArgs ) ; } ) ; } 
function prepareWrite ( outputPath , callback ) { var path = pathLib . parse ( outputPath ) ; var dir = pathLib . join ( path . root , path . dir ) ; mkdirp ( dir , callback ) ; } 
function processSitemap ( options , document , callback ) { smLib . parse ( options , document , function ( err ) { var sitemapIndexOpts = options . __sitemapIndex ; var outputPath = base . outputFile ( sitemapIndexOpts , options . source ) ; if ( ! err && sitemapIndexOpts . sitemapOutputDir ) { prepareWrite ( outputPath , function ( err ) { if ( ! err ) { fs . writeFile ( outputPath , document , callback ) ; } else { callback ( common . prependMsgToErr ( err , outputPath , true ) ) ; } } ) ; } else { callback ( err ) ; } } ) ; } 
function parse ( options , document , callback ) { xml2js . parseString ( document , { trim : true , normalizeTags : true , normalize : true } , function ( err , result ) { var sitemapUrls = [ ] ; var sitemapIndexOptions = Object . assign ( { } , options , { outputPath : undefined } ) ; if ( ! err ) { 
function generateInput ( options ) { return nodeCall ( common . isUrl ( options . source ) ? smLib . getUrl : smLib . getFile , options , parse ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( ) { base . EOI ( sitemapIndex ) ; } ) ; } 
function ( options , listener ) { var opts = Object . assign ( { } , base . defaults ( defaults ) , options ) ; return base . run ( opts , generateInput , listener ) ; } 
function generateInput ( options ) { return nodeCall ( fs . readFile , options . source ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( data ) { var error ; if ( data ) { data . toString ( ) . split ( '\n' ) . every ( function ( line ) { var page = line . replace ( / ^\s+|\s+$ / g , "" ) ; if ( ! base . input ( options , page ) ) { error = common . prependMsgToErr ( base . generatorError ( ) , page , true ) ; return false ; } return true ; } ) ; if ( error ) { console . error ( error ) ; options . _abort ( error ) ; } } base . EOI ( textfile ) ; } ) ; } 
function generateInput ( options ) { var result = new Promise ( function ( resolve , reject ) { var all ; if ( Array . isArray ( options . source ) ) { all = options . source . every ( function ( sourceUrl ) { var url = urlm . parse ( sourceUrl ) ; var opts = Object . assign ( { } , options , { protocol : url . protocol , auth : url . auth , hostname : url . hostname , port : url . port } ) ; if ( ! base . input ( opts , sourceUrl ) ) { reject ( common . prependMsgToErr ( base . generatorError ( ) , sourceUrl , true ) ) ; return false ; } return true ; } ) ; if ( all ) { resolve ( ) ; } } else { reject ( new Error ( "options.source must be an array" ) ) ; } } ) ; return result . catch ( function ( error ) { options . _abort ( error ) ; } ) . then ( function ( ) { base . EOI ( array ) ; } ) ; } 
function verbose ( page ) { page . onResourceError = function ( resourceError ) { system . stderr . writeLine ( '= onResourceError()' ) ; system . stderr . writeLine ( ' - unable to load url: "' + resourceError . url + '"' ) ; system . stderr . writeLine ( ' - error code: ' + resourceError . errorCode + ', description: ' + resourceError . errorString ) ; } ; page . onError = function ( msg , trace ) { system . stderr . writeLine ( '= onError()' ) ; var msgStack = [ ' ERROR: ' + msg ] ; if ( trace ) { msgStack . push ( ' TRACE:' ) ; trace . forEach ( function ( t ) { msgStack . push ( ' -> ' + t . file + ': ' + t . line + ( t . function ? ' (in function "' + t . function + '")' : '' ) ) ; } ) ; } system . stderr . writeLine ( msgStack . join ( '\n' ) ) ; } ; page . onResourceRequested = function ( request ) { system . stderr . writeLine ( '= onResourceRequested()' ) ; system . stderr . writeLine ( ' request: ' + JSON . stringify ( request , undefined , 4 ) ) ; } ; page . onResourceReceived = function ( response ) { system . stderr . writeLine ( '= onResourceReceived()' ) ; system . stderr . writeLine ( ' id: ' + response . id + ', stage: "' + response . stage + '", response: ' + JSON . stringify ( response ) ) ; } ; page . onLoadStarted = function ( ) { system . stderr . writeLine ( '= onLoadStarted()' ) ; var currentUrl = page . evaluate ( function ( ) { return window . location . href ; } ) ; system . stderr . writeLine ( ' leaving url: ' + currentUrl ) ; } ; page . onNavigationRequested = function ( url , type , willNavigate , main ) { system . stderr . writeLine ( '= onNavigationRequested' ) ; system . stderr . writeLine ( ' destination_url: ' + url ) ; system . stderr . writeLine ( ' type (cause): ' + type ) ; system . stderr . writeLine ( ' will navigate: ' + willNavigate ) ; system . stderr . writeLine ( ' from page\'s main frame: ' + main ) ; } ; page . onLoadFinished = function ( status ) { system . stderr . writeLine ( '= onLoadFinished()' ) ; system . stderr . writeLine ( ' status: ' + status ) ; } ; } 
function ( input ) { var result = { run : function ( ) { return [ ] ; } , __null : true } , hasInput ; if ( input ) { input = ( "" + input ) . replace ( " " , "" ) . toLowerCase ( ) ; hasInput = input && input . charAt ( 0 ) !== '_' && input !== "index" ; } try { if ( hasInput ) { result = require ( "./" + input ) ; } } catch ( e ) { console . error ( "Input generator load failed '" + input + "'" , e ) } return result ; } 
function normalize ( obj ) { var result = obj ; if ( typeof obj !== "function" ) { if ( typeof obj !== "undefined" ) { if ( Object . prototype . toString . call ( obj ) !== "[object Object]" ) { result = ( function ( value ) { return function ( ) { return value ; } ; } ( obj ) ) ; } else { result = ( function ( o ) { return function ( key , passthru ) { if ( o [ key ] === void 0 ) { return o . __default || ( passthru ? key : undefined ) ; } else { return o [ key ] ; } } ; } ( obj ) ) ; } } else { result = function ( passthru ) { return passthru ; } ; } } return result ; } 
function supplyMissingDefault ( options , name ) { if ( options [ name ] ( ) === void 0 ) { options [ name ] = _ . wrap ( options [ name ] , function ( func , key ) { var res = func ( key ) ; return res === void 0 ? defaults [ name ] : res ; } ) ; } } 
function prepOptions ( options , listener ) { 
function getOutputPath ( options , page , parse ) { var pagePart = urlm . parse ( page ) , 
function mapOutputFile ( options , page , parse ) { if ( ! _ . isFunction ( options . outputPath ) ) { options . outputPath = normalize ( options . outputPath ) ; } var outputPath = getOutputPath ( options , page , parse ) ; var outputDir = options . outputDir ; var fileName = "index.html" ; if ( options . sitemapOutputDir ) { outputDir = path . join ( options . outputDir , options . sitemapOutputDir ) ; fileName = "" ; } return ( outputPath && path . join ( outputDir , outputPath , fileName ) ) || false ; } 
function ( options , generator , listener ) { options = options || { } ; prepOptions ( options , listener ) ; return generator ( options ) ; } 
function ( options , page ) { var parse = { } ; var outputFile = mapOutputFile ( options , page , parse ) ; if ( outputFile ) { options . _inputEmitter . emit ( "input" , { outputFile : outputFile , 
function pathExists ( path , options ) { options = options || { returnFile : false } ; 
function ( ) { 
function worker ( input , options , notifier , qcb ) { var cp , customModule , snapshotScript = options . snapshotScript , phantomjsOptions = Array . isArray ( input . phantomjsOptions ) ? input . phantomjsOptions : [ input . phantomjsOptions ] ; 
function prepOptions ( options ) { 
function ( options , listener ) { var inputGenerator , notifier , started , result , q , emitter , completion ; options = options || { } ; prepOptions ( options ) ; 
function createLockFactory ( ) { * Force a serial execution context. * * @param {Function} fn - The function to guard. * @param {Number} timeout - The max time to wait for the lock. */ return function lockFactory ( fn , timeout ) { return function protectedContext ( ) { lock . acquire ( "cs-guard-" + rid , function ( done ) { fn ( function ( ) { done ( null , 0 ) ; } ) ; } , NOOP , { timeout : timeout } ) ; } ; } ; } 
function Notifier ( ) { 
function start ( pollInterval , input , listener ) { var result = ( pollInterval > 0 && typeof listener === "function" && ( ! ! input ) ) ; if ( result ) { if ( this . isStarted ( ) ) { throw new Error ( "Notifier already started" ) ; } this . callback = listener ; this . interval = parseInt ( pollInterval , 10 ) ; 
function add ( outputFile , timeout ) { var failTimeout = timeout ; var timer ; if ( ! this . isStarted ( ) ) { throw new Error ( "MUST call `start` before `add`" ) ; } if ( ! this . _exists ( outputFile ) ) { 
function known ( outputFile ) { var result = false ; this . csFactory ( function ( done ) { result = this . _exists ( outputFile ) || this . filesDone . indexOf ( outputFile ) > - 1 ; done ( ) ; } . bind ( this ) , L_WAIT ) ( ) ; return result ; } 
function _remove ( outputFile , done ) { if ( this . _exists ( outputFile ) ) { if ( done ) { this . filesDone . push ( outputFile ) ; } else { this . filesNotDone . push ( outputFile ) ; } clearTimeout ( this . files [ outputFile ] . timer ) ; delete this . files [ outputFile ] ; } } 
function remove ( outputFile , done ) { this . csFactory ( function ( _done ) { this . _remove ( outputFile , done ) ; _done ( ) ; } . bind ( this ) , L_WAIT ) ( ) ; } 
function abort ( q , err ) { this . csFactory ( function ( done ) { try { 
function waitFor ( testFx , onReady , onTimeout , timeout , checkInterval ) { var condition = false , interval = setInterval ( function ( ) { if ( ( new Date ( ) . getTime ( ) - start < timeout ) && ! condition ) { 
function snapshot ( options , detector , filter ) { filter = filter || function ( content ) { return content ; } ; console . log ( "Creating snapshot for " + options . url + "..." ) ; 
function ( time ) { fs . write ( options . outputFile , filter ( page . content ) , "w" ) ; globals . exit ( 0 , "snapshot for " + options . url + " finished in " + time + " ms\n written to " + options . outputFile ) ; } 
function oneline ( line , options ) { var key = "Allow: " , index = line . indexOf ( key ) ; if ( index !== - 1 ) { var page = line . substr ( index + key . length ) . replace ( / ^\s+|\s+$ / g , "" ) ; return page . indexOf ( "*" ) === - 1 && base . input ( options , page ) ; } return true ; } 
function getRobotsUrl ( options , callback ) { request ( { url : options . source , timeout : options . timeout ( ) } , function ( err , res , body ) { var error = err || common . checkResponse ( res , "text/plain" ) ; if ( error ) { callback ( common . prependMsgToErr ( error , options . source , true ) ) ; } else { body . toString ( ) . split ( '\n' ) . every ( function ( line ) { 
function getRobotsFile ( options , callback ) { fs . readFile ( options . source , function ( err , data ) { if ( ! err ) { data . toString ( ) . split ( '\n' ) . every ( function ( line ) { 
function generateInput ( options ) { return nodeCall ( common . isUrl ( options . source ) ? getRobotsUrl : getRobotsFile , options ) . catch ( function ( err ) { options . _abort ( err ) ; } ) . then ( function ( ) { base . EOI ( robots ) ; } ) ; } 
function ( options ) { var result = false ; var el = document . querySelector ( options . selector ) ; if ( el ) { 
function bubble ( values ) { return values . map ( d => { if ( d . key && d . values ) { if ( d . values [ 0 ] . key === "undefined" ) return d . values [ 0 ] . values [ 0 ] ; else d . values = bubble ( d . values ) ; } return d ; } ) ; } 
function exclude ( a , b , v ) { const aStart = a . start ( { type : "bigInteger" } ) ; const bStart = b . start ( { type : "bigInteger" } ) ; const aEnd = a . end ( { type : "bigInteger" } ) ; const bEnd = b . end ( { type : "bigInteger" } ) ; const parts = [ ] ; 
function heartBeat ( ) { var isEmpty = true ; 
function log ( ) { if ( conf . debug && typeof console !== "undefined" ) { if ( arguments [ 1 ] && typeof arguments [ 1 ] === "object" ) { arguments [ 1 ] = JSON . stringify ( arguments [ 1 ] ) ; } console . log ( Array . prototype . slice . call ( arguments ) . join ( "\n" ) ) ; } } 
function getMsTimestamp ( ) { var ts = new Date ( ) . getTime ( ) ; if ( lastMsTs >= ts ) { lastMsTs ++ ; } else { lastMsTs = ts ; } return lastMsTs ; } 
function parseUrl ( url ) { var serverOptions = { host : "localhost" , port : 80 } ; if ( url . indexOf ( "https" ) === 0 ) { serverOptions . port = 443 ; } var host = url . split ( "://" ) . pop ( ) ; serverOptions . host = host ; var lastPos = host . indexOf ( ":" ) ; if ( lastPos > - 1 ) { serverOptions . host = host . slice ( 0 , lastPos ) ; serverOptions . port = Number ( host . slice ( lastPos + 1 , host . length ) ) ; } return serverOptions ; } 
function prepareParams ( params ) { var str = [ ] ; for ( var i in params ) { str . push ( i + "=" + encodeURIComponent ( params [ i ] ) ) ; } return str . join ( "&" ) ; } 
function stripTrailingSlash ( str ) { if ( str . substr ( str . length - 1 ) === "/" ) { return str . substr ( 0 , str . length - 1 ) ; } return str ; } 
function getProperties ( orig , props ) { var ob = { } ; var prop ; for ( var i = 0 ; i < props . length ; i ++ ) { prop = props [ i ] ; if ( typeof orig [ prop ] !== "undefined" ) { ob [ prop ] = orig [ prop ] ; } } return ob ; } 
function add_cly_events ( event ) { if ( ! event . key ) { log ( "Event must have key property" ) ; return ; } if ( cluster . isMaster ) { if ( ! event . count ) { event . count = 1 ; } var props = [ "key" , "count" , "sum" , "dur" , "segmentation" ] ; var e = getProperties ( event , props ) ; e . timestamp = getMsTimestamp ( ) ; var date = new Date ( ) ; e . hour = date . getHours ( ) ; e . dow = date . getDay ( ) ; log ( "Adding event: " , event ) ; eventQueue . push ( e ) ; storeSet ( "cly_event" , eventQueue ) ; } else { process . send ( { cly : { event : event } } ) ; } } 
function reportViewDuration ( ) { if ( lastView ) { if ( ! platform ) { getMetrics ( ) ; } var segments = { "name" : lastView , "segment" : platform } ; 
function prepareRequest ( request ) { request . app_key = Countly . app_key ; request . device_id = Countly . device_id ; request . sdk_name = SDK_NAME ; request . sdk_version = SDK_VERSION ; if ( Countly . check_consent ( "location" ) ) { if ( Countly . country_code ) { request . country_code = Countly . country_code ; } if ( Countly . city ) { request . city = Countly . city ; } if ( Countly . ip_address !== null ) { request . ip_address = Countly . ip_address ; } } else { request . location = "" ; } request . timestamp = getMsTimestamp ( ) ; var date = new Date ( ) ; request . hour = date . getHours ( ) ; request . dow = date . getDay ( ) ; } 
function toRequestQueue ( request ) { if ( cluster . isMaster ) { if ( ! Countly . app_key || ! Countly . device_id ) { log ( "app_key or device_id is missing" ) ; return ; } prepareRequest ( request ) ; if ( requestQueue . length > queueSize ) { requestQueue . shift ( ) ; } requestQueue . push ( request ) ; storeSet ( "cly_queue" , requestQueue ) ; } else { process . send ( { cly : { cly_queue : request } } ) ; } } 
function heartBeat ( ) { 
function getMetrics ( ) { var m = JSON . parse ( JSON . stringify ( metrics ) ) ; 
function makeRequest ( url , path , params , callback ) { try { log ( "Sending HTTP request" ) ; var serverOptions = parseUrl ( url ) ; var data = prepareParams ( params ) ; var method = "GET" ; var options = { host : serverOptions . host , port : serverOptions . port , path : path + "?" + data , method : "GET" } ; if ( data . length >= 2000 ) { method = "POST" ; } else if ( Countly . force_post ) { method = "POST" ; } if ( method === "POST" ) { options . method = "POST" ; options . path = path ; options . headers = { "Content-Type" : "application/x-www-form-urlencoded" , "Content-Length" : Buffer . byteLength ( data ) } ; } var protocol = http ; if ( url . indexOf ( "https" ) === 0 ) { protocol = https ; } var req = protocol . request ( options , function ( res ) { var str = "" ; res . on ( "data" , function ( chunk ) { str += chunk ; } ) ; res . on ( "end" , function ( ) { if ( res . statusCode >= 200 && res . statusCode < 300 ) { callback ( false , params , str ) ; } else { callback ( true , params ) ; } } ) ; } ) ; if ( method === "POST" ) { 
function allSettled ( promises ) { "use strict" ; const wrappedPromises = promises . map ( ( curPromise ) => curPromise . reflect ( ) ) ; return Promise . all ( wrappedPromises ) ; } 
function firstWord ( parent , index ) { var siblings = parent . children while ( index -- ) { if ( is ( 'WordNode' , siblings [ index ] ) ) { return false } } return true } 
function after ( parent , index ) { var siblings = parent . children var sibling = siblings [ ++ index ] var other if ( is ( 'WhiteSpaceNode' , sibling ) ) { sibling = siblings [ ++ index ] if ( is ( 'PunctuationNode' , sibling ) && punctuation . test ( toString ( sibling ) ) ) { sibling = siblings [ ++ index ] } if ( is ( 'WordNode' , sibling ) ) { other = sibling } } return other } 
function classify ( value ) { var type = null var normal value = value . replace ( digits , toWords ) . split ( split , 1 ) [ 0 ] normal = lower ( value ) if ( requiresA ( value ) ) { type = 'a' } if ( requiresAn ( value ) ) { type = type === 'a' ? 'a-or-an' : 'an' } if ( ! type && normal === value ) { type = vowel . test ( normal . charAt ( 0 ) ) ? 'an' : 'a' } return type } 
function factory ( list ) { var expressions = [ ] var sensitive = [ ] var insensitive = [ ] construct ( ) return test function construct ( ) { var length = list . length var index = - 1 var value var normal while ( ++ index < length ) { value = list [ index ] normal = value === lower ( value ) if ( value . charAt ( value . length - 1 ) === '*' ) { 
function ( dbctrl , forcerebind ) { var octrls = forcerebind ? [ ] : cchistory ; var nctrls = [ ] ; var dbMeta = cdb . jb . getDBMeta ( ) ; if ( dbMeta && dbMeta . collections ) { for ( var j = 0 ; j < dbMeta . collections . length ; ++ j ) { var collection = dbMeta . collections [ j ] ; var ci ; if ( ( ci = octrls . indexOf ( collection . name ) ) != - 1 ) { nctrls . push ( collection . name ) ; octrls . splice ( ci , 1 ) ; } else if ( ! dbctrl [ collection . name ] ) { nctrls . push ( collection . name ) ; dbctrl [ collection . name ] = colctl ( dbctrl , collection . name ) ; } } } for ( var i = 0 ; i < octrls . length ; ++ i ) { delete dbctrl [ octrls [ i ] ] ; } 
function ( db , cname ) { 
function ( args ) { var result = [ cname ] ; 
function ( db , mname , frc ) { return function ( ) { var cname = arguments [ 0 ] ; var args = [ cname ] ; 
function ( rcb ) { return function ( ) { if ( frc || ! db [ cname ] ) { bindColCtls ( db ) ; } if ( rcb ) { rcb . apply ( this , arguments ) ; } } } 
function ( ) { Object . defineProperty ( this , "_impl" , { value : new EJDBImpl ( ) , configurable : false , enumerable : false , writable : false } ) ; return this ; } 
function parseQueryArgs ( args ) { var cname , qobj , orarr , hints , cb ; var i = 0 ; cname = args [ i ++ ] ; if ( typeof cname !== "string" ) { throw new Error ( "Collection name 'cname' argument must be specified" ) ; } var next = args [ i ++ ] ; if ( typeof next === "function" ) { cb = next ; } else { qobj = next ; } next = args [ i ++ ] ; if ( next !== undefined ) { if ( Array . isArray ( next ) ) { orarr = next ; next = args [ i ++ ] ; } else if ( typeof next === "object" ) { hints = next ; orarr = null ; next = args [ i ++ ] ; } if ( ! hints && typeof next === "object" ) { hints = next ; next = args [ i ++ ] ; } if ( typeof next === "function" ) { cb = next ; } } return [ cname , ( qobj || { } ) , ( orarr || [ ] ) , ( hints || { } ) , ( cb || null ) ] ; } 
function dummyText ( opts ) { var corpus = opts . corpus || 'lorem' , i = opts . start , isRandom = typeof ( i ) === 'undefined' , mustReset = typeof ( origin ) === 'undefined' , skip = opts . skip || 1 , sentences = opts . sentences || 1 , words = opts . words , text = texts [ corpus ] || texts . lorem , len = text . length , output = [ ] , s ; if ( isRandom ) { i = Math . floor ( Math . random ( ) * len ) ; } if ( mustReset ) { origin = i ; } if ( isRandom ) { 
function Back ( options ) { if ( ! ( this instanceof Back ) ) { return new Back ( options ) ; } this . settings = extend ( options ) ; this . reconnect = null ; } 
function ( baseMap ) { Construct . setup . apply ( this , arguments ) ; this.List = Map.List.extend({ Map: this }, {}); }*/ } 
function ( obj ) { if ( canReflect . isObservableLike ( obj ) && typeof obj . serialize === "function" ) { obj = obj . serialize ( ) ; } 
function ( ) { this . _computedAttrs = Object . create ( null ) ; var computes = this . constructor . _computedPropertyNames ; for ( var i = 0 , len = computes . length ; i < len ; i ++ ) { var attrName = computes [ i ] ; mapHelpers . addComputedAttr ( this , attrName , this [ attrName ] ) ; } } 
function ( attr , val ) { var type = typeof attr ; if ( attr === undefined ) { return this . _getAttrs ( ) ; } else if ( type !== "string" && type !== "number" ) { 
function ( attr ) { attr = attr + "" ; var dotIndex = attr . indexOf ( '.' ) ; if ( dotIndex >= 0 ) { 
function ( attr ) { if ( ! unobservable [ attr ] && ! this . _computedAttrs [ attr ] ) { ObservationRecorder . add ( this , attr ) ; } return this . ___get ( attr ) ; } 
function ( attr ) { if ( attr !== undefined ) { var computedAttr = this . _computedAttrs [ attr ] ; if ( computedAttr ) { 
function ( attr , value , keepKey ) { attr = attr + "" ; var dotIndex = attr . indexOf ( '.' ) , current ; if ( dotIndex >= 0 && ! keepKey ) { var first = attr . substr ( 0 , dotIndex ) , second = attr . substr ( dotIndex + 1 ) ; current = this [ inSetupSymbol ] ? undefined : this . ___get ( first ) ; if ( canReflect . isMapLike ( current ) ) { canReflect . setKeyValue ( current , second , value ) ; } else { current = this [ inSetupSymbol ] ? undefined : this . ___get ( attr ) ; 
function ( value , prop ) { if ( typeof value === "object" && ! canReflect . isObservableLike ( value ) && mapHelpers . canMakeObserve ( value ) && ! canReflect . isListLike ( value ) ) { var cached = mapHelpers . getMapFromObject ( value ) ; if ( cached ) { return cached ; } var MapConstructor = this . constructor . Map || Map ; return new MapConstructor ( value ) ; } return value ; } 
function ( prop , value , current ) { if ( value !== current || ! Object . prototype . hasOwnProperty . call ( this . _data , prop ) ) { var computedAttr = this . _computedAttrs [ prop ] ; 
function ( prop , val ) { var computedAttr = this . _computedAttrs [ prop ] ; if ( computedAttr ) { canReflect . setValue ( computedAttr . compute , val ) ; } else { this . _data [ prop ] = val ; } 
function ( attr ) { 
function ( prop , current ) { if ( prop in this . _data ) { this . ___remove ( prop ) ; 
function ( name , val ) { if ( this . _legacyAttrBehavior ) { return mapHelpers . getValue ( this , name , val , "serialize" ) ; } else { return canReflect . serialize ( val , CIDMap ) ; } } 
function ( props , remove ) { if ( this . _legacyAttrBehavior ) { return this . __setAttrs ( props , remove ) ; } if ( remove === true || remove === "true" ) { this [ canSymbol . for ( "can.updateDeep" ) ] ( props ) ; } else { this [ canSymbol . for ( "can.assignDeep" ) ] ( props ) ; } return this ; } 
function ( attr , how , newVal , oldVal , batchNum ) { canQueues . batch . start ( ) ; if ( bubble . isBubbling ( this , "change" ) ) { canEvent . dispatch . call ( this , { type : "change" , target : this , batchNum : batchNum } , [ attr , how , newVal , oldVal ] ) ; } canEvent . dispatch . call ( this , { type : attr , target : this , batchNum : batchNum , patches : [ { type : "set" , key : attr , value : newVal } ] } , [ newVal , oldVal ] ) ; if ( how === "remove" || how === "add" ) { canEvent . dispatch . call ( this , { type : "__keys" , target : this , batchNum : batchNum } ) ; } canQueues . batch . stop ( ) ; } 
function ( prop ) { if ( typeof this . constructor . prototype [ prop ] === "function" ) { return canCompute ( this [ prop ] , this ) ; } else { var reads = ObserveReader . reads ( prop ) ; var last = reads . length - 1 ; return canCompute ( function ( newVal ) { if ( arguments . length ) { ObserveReader . write ( this , reads [ last ] . key , newVal , { } ) ; } else { return ObserveReader . get ( this , prop ) ; } } , this ) ; } } 
function ( callback , context ) { var key , item ; var keys = canReflect . getOwnEnumerableKeys ( this ) ; for ( var i = 0 , len = keys . length ; i < len ; i ++ ) { key = keys [ i ] ; item = this . attr ( key ) ; if ( callback . call ( context || item , item , key , this ) === false ) { break ; } } return this ; } 
function ( callback ) { var data = this . ___get ( ) ; for ( var prop in data ) { if ( hasOwnProperty . call ( data , prop ) ) { callback ( data [ prop ] , prop ) ; } } } 
function ( ) { if ( ! this [ inSetupSymbol ] ) { ObservationRecorder . add ( this , '__keys' ) ; } var enumerable = this . constructor . enumerable ; if ( enumerable ) { return Object . keys ( this . _data ) . filter ( function ( key ) { return enumerable [ key ] !== false ; } , this ) ; } else { return Object . keys ( this . _data ) ; } } 
function ( source ) { canQueues . batch . start ( ) ; 
function ( key , handler , queue ) { var translationHandler = function ( ev , newValue , oldValue ) { handler . call ( this , newValue , oldValue ) ; } ; singleReference . set ( handler , this , translationHandler , key ) ; this . addEventListener ( key , translationHandler , queue ) ; } 
function v1 ( options , buf , offset ) { var i = buf && offset || 0 ; var b = buf || [ ] ; options = options || { } ; var clockseq = options . clockseq !== undefined ? options . clockseq : _clockseq ; 
function css ( files , output , options ) { options = Object . assign ( { banner : false } , options ) ; return ( ) => { var build = gulp . src ( files ) if ( options . banner ) build = build . pipe ( $ . header ( banner , { pkg } ) ) ; build = build . pipe ( $ . rename ( 'd3.compose.css' ) ) . pipe ( gulp . dest ( output ) ) ; return build ; } ; } 
function series ( ) { const tasks = Array . prototype . slice . call ( arguments ) ; var fn = cb => cb ( ) ; if ( typeof tasks [ tasks . length - 1 ] === 'function' ) fn = tasks . pop ( ) ; return ( cb ) => { const tasks_with_cb = tasks . concat ( [ ( err ) => { if ( err ) return cb ( err ) ; fn ( cb ) ; } ] ) ; runSequence . apply ( this , tasks_with_cb ) ; } } 
function toSurround ( description ) { if ( ! Array . isArray ( description ) ) { description = [ layered ( description ) ] ; } var positions = extractSurroundPositions ( description ) ; var top = positions . top ; var right = positions . right ; var bottom = positions . bottom ; var left = positions . left ; var middle = positions . middle ; var container = { _id : '_container' } ; var topEdge = top [ top . length - 1 ] && constraint . eq ( top [ top . length - 1 ] , 'bottom' ) || 0 ; var rightEdge = right [ 0 ] && constraint . eq ( right [ 0 ] , 'left' ) || constraint . eq ( container , 'right' ) ; var bottomEdge = bottom [ 0 ] && constraint . eq ( bottom [ 0 ] , 'top' ) || constraint . eq ( container , 'bottom' ) ; var leftEdge = left [ left . length - 1 ] && constraint . eq ( left [ left . length - 1 ] , 'right' ) || 0 ; top = top . map ( function ( item , i , items ) { var layout = { _position : 'top' , top : items [ i - 1 ] && constraint . eq ( items [ i - 1 ] , 'bottom' ) || 0 , left : leftEdge , right : rightEdge , width : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; right = right . map ( function ( item , i , items ) { var layout = { _position : 'right' , right : items [ i + 1 ] && constraint . eq ( items [ i + 1 ] , 'left' ) || constraint . eq ( container , 'right' ) , top : topEdge , bottom : bottomEdge , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; bottom = bottom . map ( function ( item , i , items ) { var layout = { _position : 'bottom' , bottom : items [ i + 1 ] && constraint . eq ( items [ i + 1 ] , 'top' ) || constraint . eq ( container , 'bottom' ) , left : leftEdge , right : rightEdge , width : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; left = left . map ( function ( item , i , items ) { var layout = { _position : 'left' , left : items [ i - 1 ] && constraint . eq ( items [ i - 1 ] , 'right' ) || 0 , top : topEdge , bottom : bottomEdge , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; middle = middle . map ( function ( item ) { var layout = { _position : 'middle' , top : topEdge , right : rightEdge , bottom : bottomEdge , left : leftEdge , width : constraint . flex ( ) , height : constraint . flex ( ) } ; item = assign ( { } , item ) ; item . props = assign ( layout , item . props ) ; return item ; } ) ; var allItems = top . concat ( left ) . concat ( middle ) . concat ( right ) . concat ( bottom ) ; var byId = { } ; var ordered = [ ] ; allItems . forEach ( function ( item ) { byId [ item . _id ] = item ; ordered . push ( item . _id ) ; } ) ; return { byId : byId , ordered : ordered } ; } 
function synctos ( doc , oldDoc ) { 
function simpleTypeFilter ( doc , oldDoc , candidateDocType ) { if ( oldDoc ) { if ( doc . _deleted ) { return oldDoc . type === candidateDocType ; } else { return doc . type === oldDoc . type && oldDoc . type === candidateDocType ; } } else { return doc . type === candidateDocType ; } } 
function padRight ( value , desiredLength , padding ) { while ( value . length < desiredLength ) { value += padding ; } return value ; } 
function resolveCollectionItems ( originalItems , itemPrefix ) { if ( utils . isValueNullOrUndefined ( originalItems ) ) { return [ ] ; } else if ( Array . isArray ( originalItems ) ) { var resultItems = [ ] ; for ( var i = 0 ; i < originalItems . length ; i ++ ) { var item = originalItems [ i ] ; if ( utils . isValueNullOrUndefined ( item ) ) { continue ; } resultItems . push ( prefixItem ( item , itemPrefix ) ) ; } return resultItems ; } else { 
function resolveCollectionDefinition ( doc , oldDoc , collectionDefinition , itemPrefix ) { if ( utils . isValueNullOrUndefined ( collectionDefinition ) ) { return [ ] ; } else { if ( typeof collectionDefinition === 'function' ) { var fnResults = collectionDefinition ( doc , oldDoc ) ; return resolveCollectionItems ( fnResults , itemPrefix ) ; } else { return resolveCollectionItems ( collectionDefinition , itemPrefix ) ; } } } 
function assignChannelsToUsersAndRoles ( doc , oldDoc , accessAssignmentDefinition ) { var usersAndRoles = [ ] ; var users = resolveCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . users ) ; for ( var userIndex = 0 ; userIndex < users . length ; userIndex ++ ) { usersAndRoles . push ( users [ userIndex ] ) ; } var roles = resolveRoleCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . roles ) ; for ( var roleIndex = 0 ; roleIndex < roles . length ; roleIndex ++ ) { usersAndRoles . push ( roles [ roleIndex ] ) ; } var channels = resolveCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . channels ) ; access ( usersAndRoles , channels ) ; return { type : 'channel' , usersAndRoles : usersAndRoles , channels : channels } ; } 
function assignRolesToUsers ( doc , oldDoc , accessAssignmentDefinition ) { var users = resolveCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . users ) ; var roles = resolveRoleCollectionDefinition ( doc , oldDoc , accessAssignmentDefinition . roles ) ; role ( users , roles ) ; return { type : 'role' , users : users , roles : roles } ; } 
function assignUserAccess ( doc , oldDoc , documentDefinition ) { var effectiveOldDoc = utils . resolveOldDoc ( ) ; var accessAssignmentDefinitions = resolveAccessAssignmentsDefinition ( doc , effectiveOldDoc , documentDefinition . accessAssignments ) ; var effectiveAssignments = [ ] ; for ( var assignmentIndex = 0 ; assignmentIndex < accessAssignmentDefinitions . length ; assignmentIndex ++ ) { var definition = accessAssignmentDefinitions [ assignmentIndex ] ; if ( definition . type === 'role' ) { effectiveAssignments . push ( assignRolesToUsers ( doc , effectiveOldDoc , definition ) ) ; } else if ( definition . type === 'channel' || utils . isValueNullOrUndefined ( definition . type ) ) { effectiveAssignments . push ( assignChannelsToUsersAndRoles ( doc , effectiveOldDoc , definition ) ) ; } } return effectiveAssignments ; } 
function appendToAuthorizationList ( allAuthorizations , authorizationsToAdd ) { if ( ! utils . isValueNullOrUndefined ( authorizationsToAdd ) ) { if ( Array . isArray ( authorizationsToAdd ) ) { for ( var i = 0 ; i < authorizationsToAdd . length ; i ++ ) { var authorization = authorizationsToAdd [ i ] ; if ( allAuthorizations . indexOf ( authorization ) < 0 ) { allAuthorizations . push ( authorization ) ; } } } else if ( allAuthorizations . indexOf ( authorizationsToAdd ) < 0 ) { allAuthorizations . push ( authorizationsToAdd ) ; } } } 
function getAllDocChannels ( docDefinition ) { var docChannelMap = utils . resolveDocumentConstraint ( docDefinition . channels ) ; var allChannels = [ ] ; if ( docChannelMap ) { appendToAuthorizationList ( allChannels , docChannelMap . view ) ; appendToAuthorizationList ( allChannels , docChannelMap . write ) ; appendToAuthorizationList ( allChannels , docChannelMap . add ) ; appendToAuthorizationList ( allChannels , docChannelMap . replace ) ; appendToAuthorizationList ( allChannels , docChannelMap . remove ) ; } return allChannels ; } 
function getRequiredAuthorizations ( doc , oldDoc , authorizationDefinition ) { var authorizationMap = utils . resolveDocumentConstraint ( authorizationDefinition ) ; if ( utils . isValueNullOrUndefined ( authorizationMap ) ) { 
function authorize ( doc , oldDoc , docDefinition ) { var authorizedChannels = getRequiredAuthorizations ( doc , oldDoc , docDefinition . channels ) ; var authorizedRoles = getRequiredAuthorizations ( doc , oldDoc , docDefinition . authorizedRoles ) ; var authorizedUsers = getRequiredAuthorizations ( doc , oldDoc , docDefinition . authorizedUsers ) ; var channelMatch = false ; if ( authorizedChannels ) { try { requireAccess ( authorizedChannels ) ; channelMatch = true ; } catch ( ex ) { 
function outputHelpIfNecessary ( cmd , options ) { options = options || [ ] ; for ( var i = 0 ; i < options . length ; i ++ ) { if ( options [ i ] === '--help' || options [ i ] === '-h' ) { cmd . outputHelp ( ) ; process . exit ( 0 ) ; } } } 
function humanReadableArgName ( arg ) { var nameOutput = arg . name + ( arg . variadic === true ? '...' : '' ) ; return arg . required ? '<' + nameOutput + '>' : '[' + nameOutput + ']' ; } 
function validateObjectProperties ( propertyValidators , allowUnknownProperties , ignoreInternalProperties ) { var currentItemEntry = itemStack [ itemStack . length - 1 ] ; var objectValue = currentItemEntry . itemValue ; var oldObjectValue = currentItemEntry . oldItemValue ; var supportedProperties = [ ] ; for ( var propertyValidatorName in propertyValidators ) { var validator = propertyValidators [ propertyValidatorName ] ; if ( utils . isValueNullOrUndefined ( validator ) || utils . isValueNullOrUndefined ( resolveItemConstraint ( validator . type ) ) ) { 
function buildItemPath ( itemStack ) { var nameComponents = [ ] ; for ( var i = 0 ; i < itemStack . length ; i ++ ) { var itemName = itemStack [ i ] . itemName ; if ( ! itemName ) { 
function typeSpecificConstraintSchemas ( ) { return { any : { } , string : { mustNotBeEmpty : dynamicConstraintSchema ( joi . boolean ( ) ) , mustBeTrimmed : dynamicConstraintSchema ( joi . boolean ( ) ) , regexPattern : dynamicConstraintSchema ( regexSchema ) , minimumLength : dynamicConstraintSchema ( integerSchema . min ( 0 ) ) , maximumLength : maximumSizeConstraintSchema ( 'minimumLength' ) , minimumValue : dynamicConstraintSchema ( joi . string ( ) ) , minimumValueExclusive : dynamicConstraintSchema ( joi . string ( ) ) , maximumValue : dynamicConstraintSchema ( joi . string ( ) ) , maximumValueExclusive : dynamicConstraintSchema ( joi . string ( ) ) , mustEqualIgnoreCase : dynamicConstraintSchema ( joi . string ( ) ) } , integer : { minimumValue : dynamicConstraintSchema ( integerSchema ) , minimumValueExclusive : dynamicConstraintSchema ( integerSchema ) , maximumValue : maximumValueInclusiveNumberConstraintSchema ( integerSchema ) , maximumValueExclusive : maximumValueExclusiveNumberConstraintSchema ( integerSchema ) } , float : { minimumValue : dynamicConstraintSchema ( joi . number ( ) ) , minimumValueExclusive : dynamicConstraintSchema ( joi . number ( ) ) , maximumValue : maximumValueInclusiveNumberConstraintSchema ( joi . number ( ) ) , maximumValueExclusive : maximumValueExclusiveNumberConstraintSchema ( joi . number ( ) ) } , boolean : { } , datetime : { minimumValue : dynamicConstraintSchema ( datetimeSchema ) , minimumValueExclusive : dynamicConstraintSchema ( datetimeSchema ) , maximumValue : dynamicConstraintSchema ( datetimeSchema ) , maximumValueExclusive : dynamicConstraintSchema ( datetimeSchema ) } , date : { minimumValue : dynamicConstraintSchema ( dateOnlySchema ) , minimumValueExclusive : dynamicConstraintSchema ( dateOnlySchema ) , maximumValue : dynamicConstraintSchema ( dateOnlySchema ) , maximumValueExclusive : dynamicConstraintSchema ( dateOnlySchema ) } , time : { minimumValue : dynamicConstraintSchema ( timeOnlySchema ) , minimumValueExclusive : dynamicConstraintSchema ( timeOnlySchema ) , maximumValue : dynamicConstraintSchema ( timeOnlySchema ) , maximumValueExclusive : dynamicConstraintSchema ( timeOnlySchema ) } , timezone : { minimumValue : dynamicConstraintSchema ( timezoneSchema ) , minimumValueExclusive : dynamicConstraintSchema ( timezoneSchema ) , maximumValue : dynamicConstraintSchema ( timezoneSchema ) , maximumValueExclusive : dynamicConstraintSchema ( timezoneSchema ) } , enum : { predefinedValues : dynamicConstraintSchema ( joi . array ( ) . required ( ) . min ( 1 ) . items ( [ integerSchema , joi . string ( ) ] ) ) } , uuid : { minimumValue : dynamicConstraintSchema ( uuidSchema ) , minimumValueExclusive : dynamicConstraintSchema ( uuidSchema ) , maximumValue : dynamicConstraintSchema ( uuidSchema ) , maximumValueExclusive : dynamicConstraintSchema ( uuidSchema ) } , attachmentReference : { maximumSize : dynamicConstraintSchema ( integerSchema . min ( 1 ) . max ( 20971520 ) ) , supportedExtensions : dynamicConstraintSchema ( joi . array ( ) . min ( 1 ) . items ( joi . string ( ) ) ) , supportedContentTypes : dynamicConstraintSchema ( joi . array ( ) . min ( 1 ) . items ( joi . string ( ) . min ( 1 ) ) ) , regexPattern : dynamicConstraintSchema ( regexSchema ) } , array : { mustNotBeEmpty : dynamicConstraintSchema ( joi . boolean ( ) ) , minimumLength : dynamicConstraintSchema ( integerSchema . min ( 0 ) ) , maximumLength : maximumSizeConstraintSchema ( 'minimumLength' ) , arrayElementsValidator : dynamicConstraintSchema ( joi . lazy ( ( ) => schema ) ) } , object : { allowUnknownProperties : dynamicConstraintSchema ( joi . boolean ( ) ) , propertyValidators : dynamicConstraintSchema ( joi . object ( ) . min ( 1 ) . pattern ( / ^.+$ / , joi . lazy ( ( ) => schema ) ) ) } , hashtable : { minimumSize : dynamicConstraintSchema ( integerSchema . min ( 0 ) ) , maximumSize : maximumSizeConstraintSchema ( 'minimumSize' ) , hashtableKeysValidator : dynamicConstraintSchema ( joi . object ( ) . keys ( { mustNotBeEmpty : dynamicConstraintSchema ( joi . boolean ( ) ) , regexPattern : dynamicConstraintSchema ( regexSchema ) } ) ) , hashtableValuesValidator : dynamicConstraintSchema ( joi . lazy ( ( ) => schema ) ) } , conditional : { validationCandidates : dynamicConstraintSchema ( conditionalValidationCandidatesSchema ( ) ) . required ( ) } } ; } 
function validateBusinessIdProperty ( doc , oldDoc , currentItemEntry , validationItemStack ) { var parentObjectElement = validationItemStack [ validationItemStack . length - 1 ] ; var businessId = currentItemEntry . itemValue ; var oldBusinessId = currentItemEntry . oldItemValue ; var validationErrors = [ ] ; if ( parentObjectElement . oldItemValue && oldBusinessId !== businessId ) { validationErrors . push ( 'cannot change "businessId" property' ) ; } return validationErrors ; } 
function getBusinessId ( doc , oldDoc ) { var regex = / ^biz\.([A-Za-z0-9_-]+)(?:\..+)?$ / ; var matchGroups = regex . exec ( doc . _id ) ; if ( matchGroups ) { return matchGroups [ 1 ] ; } else if ( oldDoc && oldDoc . businessId ) { 
function toDefaultSyncChannels ( doc , oldDoc , basePrivilegeName ) { var businessId = getBusinessId ( doc , oldDoc ) ; return function ( doc , oldDoc ) { return { view : [ toSyncChannel ( businessId , 'VIEW_' + basePrivilegeName ) ] , add : [ toSyncChannel ( businessId , 'ADD_' + basePrivilegeName ) ] , replace : [ toSyncChannel ( businessId , 'CHANGE_' + basePrivilegeName ) ] , remove : [ toSyncChannel ( businessId , 'REMOVE_' + basePrivilegeName ) ] } ; } ; } 
function isIso8601DateTimeString ( value ) { var dateAndTimePieces = splitDateAndTime ( value ) ; var date = extractDateStructureFromDateAndTime ( dateAndTimePieces ) ; if ( date ) { var timeAndTimezone = extractTimeStructuresFromDateAndTime ( dateAndTimePieces ) ; var time = timeAndTimezone . time ; var timezone = timeAndTimezone . timezone ; return isValidDateStructure ( date ) && isValidTimeStructure ( time ) && ( timezone === null || isValidTimeZoneStructure ( timezone ) ) ; } else { return false ; } } 
function normalizeIso8601Time ( time , timezoneOffsetMinutes ) { var msPerSecond = 1000 ; var msPerMinute = 60000 ; var msPerHour = 3600000 ; var effectiveTimezoneOffset = timezoneOffsetMinutes || 0 ; var rawTimeMs = ( time . hour * msPerHour ) + ( time . minute * msPerMinute ) + ( time . second * msPerSecond ) + time . millisecond ; return rawTimeMs - ( effectiveTimezoneOffset * msPerMinute ) ; } 
function compareTimes ( a , b ) { if ( typeof a !== 'string' || typeof b !== 'string' ) { return NaN ; } return normalizeIso8601Time ( parseIso8601Time ( a ) ) - normalizeIso8601Time ( parseIso8601Time ( b ) ) ; } 
function compareDates ( a , b ) { var aPieces = extractDatePieces ( a ) ; var bPieces = extractDatePieces ( b ) ; if ( aPieces === null || bPieces === null ) { return NaN ; } for ( var pieceIndex = 0 ; pieceIndex < aPieces . length ; pieceIndex ++ ) { if ( aPieces [ pieceIndex ] < bPieces [ pieceIndex ] ) { return - 1 ; } else if ( aPieces [ pieceIndex ] > bPieces [ pieceIndex ] ) { return 1 ; } } 
function normalizeIso8601TimeZone ( value ) { return value ? value . multiplicationFactor * ( ( value . hour * 60 ) + value . minute ) : - ( new Date ( ) . getTimezoneOffset ( ) ) ; } 
async function initiate ( ) { log . i ( '--Nexus/Initiate' ) ; let Setup = { } ; let Start = { } ; cacheInterface = new CacheInterface ( { path : __options . cache , log } ) ; let cache = await cacheInterface . loadCache ( ) ; Start = cache . start ; Setup = cache . setup ; Stop = Object . assign ( Stop , cache . stop ) ; await setup ( ) ; await start ( ) ; run ( ) ; * Call setup on the required Module Apexes */ async function setup ( ) { log . i ( '--Nexus/Setup' ) ; * Call Start on the required Module Apexes */ async function start ( ) { log . i ( '--Nexus/Start' ) ; * Send Finished command if the process was generated */ function run ( ) { log . i ( '--Nexus/Run' ) ; if ( 'send' in process ) { process . send ( '{"Cmd":"Finished"}' ) ; } } } 
async function setup ( ) { log . i ( '--Nexus/Setup' ) ; 
async function start ( ) { log . i ( '--Nexus/Start' ) ; 
async function exit ( code = 0 ) { log . i ( '--Nexus/Stop' ) ; 
function sendMessage ( com , fun = _ => _ ) { if ( ! ( 'Passport' in com ) ) { log . w ( 'Message has no Passport, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No Passport' ) ; return ; } if ( ! ( 'To' in com . Passport ) || ! com . Passport . To ) { log . w ( 'Message has no destination entity, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No recipient in message' , com ) ; return ; } if ( ! ( 'Pid' in com . Passport ) ) { log . w ( 'Message has no message id, ignored' ) ; log . w ( ' ' + JSON . stringify ( com ) ) ; fun ( 'No message id' , com ) ; return ; } let pid = com . Passport . To ; let apx = com . Passport . Apex || pid ; if ( pid in EntCache ) { done ( null , EntCache [ pid ] ) ; return ; } else { getEntityContext ( pid , done ) ; } async function done ( err , entContextVolatile ) { let entApex = await new Promise ( res => entContextVolatile . lock ( ( val ) => { res ( val . Apex ) ; return val ; } ) ) ; if ( err ) { log . w ( err ) ; log . w ( JSON . stringify ( com , null , 2 ) ) ; fun ( err , com ) ; return ; } 
async function genEntity ( par , fun = _ => log . e ( _ ) ) { if ( ! ( 'Entity' in par ) ) { fun ( 'No Entity defined in Par' ) ; return ; } par . Pid = par . Pid || genPid ( ) ; let impkey = ( par . Module + '/' + par . Entity ) ; let mod = ModCache [ par . Module ] ; if ( ! ( par . Entity in mod . files ) ) { log . e ( '<' + par . Entity + '> not in module <' + par . Module + '>' ) ; fun ( 'Null entity' ) ; return ; } if ( ! ( impkey in ImpCache ) ) { let entString = await new Promise ( async ( res , _rej ) => { mod . file ( par . Entity ) . async ( 'string' ) . then ( ( string ) => res ( string ) ) ; } ) ; ImpCache [ impkey ] = indirectEvalImp ( impkey , entString , log , createRequireFromModuleType ( par . Module ) ) ; } EntCache [ par . Pid ] = new Volatile ( new Entity ( Nxs , ImpCache [ impkey ] , par , log ) ) ; fun ( null , par . Pid ) ; } 
function deleteEntity ( pid , fun = ( err , _pid ) => { if ( err ) log . e ( err ) ; } ) { cacheInterface . deleteEntity ( pid , ( err , removedPidArray ) => { 
async function saveEntity ( par , fun = ( err , _pid ) => { if ( err ) log . e ( err ) ; } ) { let saveEntity = ( async ( par ) => { await new Promise ( ( res , rej ) => { cacheInterface . saveEntityPar ( par , ( err , pid ) => { if ( err ) { log . e ( err , 'saving ' , pid ) ; rej ( err ) ; } log . v ( ` ${ par . Pid } ` ) ; res ( ) ; } ) ; } ) ; } ) ; 
async function addModule ( modName , modZip , fun ) { 
function getFile ( module , filename , fun = _ => _ ) { let mod = ModCache [ module ] ; if ( filename in mod . files ) { mod . file ( filename ) . async ( 'string' ) . then ( ( dat ) => { fun ( null , dat ) ; } ) ; return ; } let err = ` ${ filename } ${ module } ` ; log . e ( err ) ; fun ( err ) ; } 
async function getEntityContext ( pid , fun = _ => _ ) { EntCache [ pid ] = new Volatile ( { } ) ; await EntCache [ pid ] . lock ( ( _entityContext ) => { return new Promise ( ( res , _rej ) => { cacheInterface . getEntityPar ( pid , ( err , data ) => { let par = JSON . parse ( data . toString ( ) ) ; if ( err ) { log . e ( ` ${ data . moduleType } ${ pid } ` ) ; log . e ( err ) ; fun ( 'Unavailable' ) ; return ; } let impkey = par . Module + '/' + par . Entity ; if ( impkey in ImpCache ) { BuildEnt ( ) ; return ; } GetModule ( par . Module , async function ( err , mod ) { if ( err ) { log . e ( 'Module <' + par . Module + '> not available' ) ; fun ( 'Module not available' ) ; return ; } if ( ! ( par . Entity in mod . files ) ) { log . e ( '<' + par . Entity + '> not in module <' + par . Module + '>' ) ; fun ( 'Null entity' ) ; return ; } let entString = await new Promise ( async ( res , _rej ) => { mod . file ( par . Entity ) . async ( 'string' ) . then ( ( string ) => res ( string ) ) ; } ) ; log . v ( ` ${ par . Module } ${ par . Entity . split ( '.' ) [ 0 ] } ` ) ; ImpCache [ impkey ] = indirectEvalImp ( impkey , entString , log , createRequireFromModuleType ( par . Module ) ) ; BuildEnt ( ) ; } ) ; function BuildEnt ( ) { 
async function genModule ( moduleDefinition , fun = _ => _ ) { moduleDefinition = JSON . parse ( JSON . stringify ( moduleDefinition ) ) ; let moduleDefinitions = moduleDefinition ; if ( 'Module' in moduleDefinition && ( typeof moduleDefinition . Module == 'string' ) ) { moduleDefinitions = { 'Top' : moduleDefinition } ; } let Setup = { } ; let Start = { } ; let PromiseArray = [ ] ; let symbols = { } ; * Call setup on the required Module Apexes */ async function setup ( ) { * Call Start on the required Module Apexes */ async function start ( ) { 
async function compileInstance ( pidapx , inst , saveRoot = false ) { log . v ( 'compileInstance' , pidapx , JSON . stringify ( inst , null , 2 ) ) ; let Local = { } ; let modnam = ( typeof inst . Module == 'object' ) ? inst . Module . Module : inst . Module ; let mod ; let ents = [ ] ; modnam = modnam . replace ( / :\/ / g , '.' ) ; if ( modnam in ModCache ) { mod = ModCache [ modnam ] ; } else { log . e ( 'Module <' + modnam + '> not in ModCache' ) ; process . exit ( 1 ) ; return ; } let schema = await new Promise ( async ( res , rej ) => { if ( 'schema.json' in mod . files ) { mod . file ( 'schema.json' ) . async ( 'string' ) . then ( function ( schemaString ) { res ( JSON . parse ( schemaString ) ) ; } ) ; } else { log . e ( 'Module <' + modnam + '> schema not in ModCache' ) ; process . exit ( 1 ) ; rej ( ) ; return ; } } ) ; let entkeys = Object . keys ( schema ) ; 
function GetModule ( ModName , fun = _ => _ ) { ModName = ModName . replace ( / :\/ / g , '.' ) ; if ( ModName in ModCache ) return fun ( null , ModCache [ ModName ] ) ; else cacheInterface . getModule ( ModName , ( err , moduleZip ) => { if ( err ) return fun ( err ) ; ModCache [ ModName ] = moduleZip ; return fun ( null , ModCache [ ModName ] ) ; } ) ; } 
function Strategy ( options , verify ) { var supportedApiVersions = [ '1' , '2' ] , defaultOptionsByApiVersion = { 1 : { authorizationURL : 'https://www.dropbox.com/1/oauth2/authorize' , tokenURL : 'https://api.dropbox.com/1/oauth2/token' , scopeSeparator : ',' , customHeaders : { } } , 2 : { authorizationURL : 'https://www.dropbox.com/oauth2/authorize' , tokenURL : 'https://api.dropbox.com/oauth2/token' , scopeSeparator : ',' , customHeaders : { 'Content-Type' : 'application/json' } } } ; options = options || { } ; if ( options . apiVersion != null && supportedApiVersions . indexOf ( options . apiVersion . toString ( ) ) === - 1 ) { throw new Error ( 'Unsupported Dropbox API version. Supported versions are "1" and "2".' ) ; } this . _apiVersion = options . apiVersion || '1' ; options . authorizationURL = options . authorizationURL || defaultOptionsByApiVersion [ this . _apiVersion ] . authorizationURL ; options . tokenURL = options . tokenURL || defaultOptionsByApiVersion [ this . _apiVersion ] . tokenURL ; options . scopeSeparator = options . scopeSeparator || defaultOptionsByApiVersion [ this . _apiVersion ] . scopeSeparator ; options . customHeaders = options . customHeaders || defaultOptionsByApiVersion [ this . _apiVersion ] . customHeaders ; OAuth2Strategy . call ( this , options , verify ) ; this . name = 'dropbox-oauth2' ; } 
async function retrieveModules ( modules ) { modules = JSON . parse ( JSON . stringify ( modules ) ) ; const xgrls = [ ] ; for ( const moduleName in modules ) { const xgrl = Config . Sources [ modules [ moduleName ] . Source ] ; if ( xgrls . indexOf ( xgrl ) === - 1 ) xgrls . push ( xgrl ) ; modules [ moduleName ] . Source = xgrl } 
function processSources ( cfg ) { if ( typeof cfg [ 'Sources' ] === 'undefined' ) { log . e ( 'You must defined a Sources object.\n' ) ; rejectSetup ( 'You must defined a Sources object.' ) ; return ; } let val , sources , subval ; for ( let key in cfg ) { val = cfg [ key ] ; if ( key == 'Sources' ) { Config . Sources = { } ; sources = cfg [ 'Sources' ] ; for ( let subkey in sources ) { subval = sources [ subkey ] ; switch ( typeof subval ) { case 'string' : { Config . Sources [ subkey ] = Macro ( subval ) ; break ; } case 'object' : { Config . Sources [ subkey ] = { } ; for ( let id in subval ) { Config . Sources [ subkey ] [ id . toLowerCase ( ) ] = ( typeof subval [ id ] == 'string' ) ? Macro ( subval [ id ] ) : subval [ id ] ; } if ( ! ( 'port' in Config . Sources [ subkey ] ) ) { Config . Sources [ subkey ] [ 'port' ] = 27000 ; } break ; } default : { log . e ( ` ${ subkey } ${ typeof subval } ` + 'Must be of type string or object' ) ; } } } } else { Config [ key ] = val ; } } } 
function generateModuleCatalog ( ) { * Add the module to the Modules object if unique * @param {object} mod The module object * @param {string} mod.Module The name of the module * @param {object, string} mod.Source The Module broker or path reference */ function logModule ( key , mod ) { let folder = mod . Module . replace ( / [/:] / g , '.' ) ; if ( ! ( 'Source' in mod ) ) { log . e ( ` ${ key } ${ mod . Module } ` ) ; rejectSetup ( ` ${ key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source != source . Source || ( Modules [ folder ] . Version != source . Version ) ) { log . e ( ` ${ key } \n ` + ` ${ JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n ${ JSON . stringify ( source , null , 2 ) } ` ) ; rejectSetup ( 'Broker Mismatch Exception' ) ; return ; } } } } 
function logModule ( key , mod ) { let folder = mod . Module . replace ( / [/:] / g , '.' ) ; if ( ! ( 'Source' in mod ) ) { log . e ( ` ${ key } ${ mod . Module } ` ) ; rejectSetup ( ` ${ key } ` ) ; return ; } let source = { Source : mod . Source , Version : mod . Version } ; if ( ! ( folder in Modules ) ) { Modules [ folder ] = source ; } else { if ( Modules [ folder ] . Source != source . Source || ( Modules [ folder ] . Version != source . Version ) ) { log . e ( ` ${ key } \n ` + ` ${ JSON . stringify ( Modules [ folder ] , null , 2 ) } ` + ` \n ${ JSON . stringify ( source , null , 2 ) } ` ) ; rejectSetup ( 'Broker Mismatch Exception' ) ; return ; } } } 
async function buildApexInstances ( processPidReferences ) { if ( processPidReferences ) { 
async function processApexPar ( apx , inst , processPidReferences ) { inst = symbolPhase0 ( inst ) ; if ( processPidReferences ) inst . Par = await symbolPhase1 ( inst . Par ) ; inst . Par = await symbolPhase2 ( inst . Par ) ; inst . Par = await symbolPhase3 ( inst . Par ) ; return ; 
function symbolPhase0 ( obj ) { for ( let key in obj ) { if ( typeof obj [ key ] == 'string' ) obj [ key ] = Macro ( obj [ key ] ) ; else if ( typeof obj [ key ] == 'object' ) obj [ key ] = symbolPhase0 ( obj [ key ] ) ; } return obj ; } 
async function symbolPhase1 ( val ) { if ( typeof val === 'object' ) { if ( Array . isArray ( val ) ) { val = await Promise . all ( val . map ( v => symbolPhase1 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbolPhase1 ( val [ key ] ) ; } } return val ; } if ( typeof val !== 'string' ) return val ; let sym = val . substr ( 1 ) ; if ( val . charAt ( 0 ) === '$' ) { if ( sym in Apex ) return Apex [ sym ] ; else { log . v ( sym , Apex ) ; log . e ( ` ${ val } ` ) ; rejectSetup ( ` ${ val } ` ) ; return ; } } return val ; } 
async function symbolPhase2 ( val ) { if ( typeof val === 'object' ) { if ( Array . isArray ( val ) ) { val = await Promise . all ( val . map ( v => symbolPhase2 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbolPhase2 ( val [ key ] ) ; } } return val ; } if ( typeof val !== 'string' || ( ! val . startsWith ( '@' ) ) ) return val ; let [ directive , path ] = val . split ( ':' ) . map ( v => v . toLocaleLowerCase ( ) . trim ( ) ) ; if ( directive == '@system' ) { let directiveTimer = log . time ( val ) ; let stepTimer = log . time ( 'fs' ) ; let systemPath = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( ! ( Path . isAbsolute ( path ) ) ) { path = Path . join ( Path . resolve ( systemPath ) , path ) ; } let tempConfig ; if ( ! fs . existsSync ( path ) ) { rejectSetup ( ` ${ path } ` ) ; return ; } try { tempConfig = JSON . parse ( fs . readFileSync ( path ) ) ; } catch ( e ) { rejectSetup ( 'Specified configuration file is in an unparsable format.' ) ; return ; } log . timeEnd ( stepTimer ) ; 
async function symbolPhase3 ( val ) { if ( typeof val === 'object' ) { if ( Array . isArray ( val ) ) { val = await Promise . all ( val . map ( v => symbolPhase3 ( v ) ) ) ; } else { for ( let key in val ) { val [ key ] = await symbolPhase3 ( val [ key ] ) ; } } return val ; } if ( typeof val !== 'string' || ( ! val . startsWith ( '@' ) ) ) return val ; if ( val . charAt ( 0 ) === '@' ) { let directive = val . substr ( 0 ) ; val = val . split ( ':' ) ; let key = val [ 0 ] . toLocaleLowerCase ( ) . trim ( ) ; let encoding = undefined ; if ( key . split ( ',' ) . length == 2 ) { key = key . split ( ',' ) [ 0 ] . trim ( ) ; let _encoding = key . split ( ',' ) [ 1 ] . trim ( ) ; } val = val . slice ( 1 ) . join ( ':' ) . trim ( ) ; let directiveTimer = log . time ( directive ) ; switch ( key ) { case '@filename' : case '@file' : { log . v ( ` ${ directive } ` ) ; let path ; try { let systemPath = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( Path . isAbsolute ( val ) ) path = val ; else { path = Path . join ( Path . resolve ( systemPath ) , val ) ; } log . timeEnd ( directiveTimer ) ; return fs . readFileSync ( path ) . toString ( encoding ) ; } catch ( err ) { log . e ( '@file: (compileInstance) Error reading file ' , path ) ; log . w ( ` ${ inst . Module } ` ) ; } break ; } case '@folder' : case '@directory' : { log . v ( ` ${ directive } ` ) ; let dir ; try { let systemPath = Params . config ? Path . dirname ( Params . config ) : CWD ; if ( Path . isAbsolute ( val ) ) dir = val ; else dir = Path . join ( Path . resolve ( systemPath ) , val ) ; let _return = await buildDir ( dir ) ; log . timeEnd ( directiveTimer ) ; return _return ; } catch ( err ) { og . e ( 'Error reading directory ' , dir ) ; og . w ( ` ${ inst . Module } ` ) ; } break ; } default : { log . w ( ` ${ key } ` + ` ${ inst . Module } ` ) ; } } log . timeEnd ( directiveTimer ) ; } return val ; } 
async function buildDir ( path ) { let dirObj = { } ; if ( fs . existsSync ( path ) ) { let files = fs . readdirSync ( path ) ; let itemPromises = [ ] ; for ( let file of files ) { itemPromises . push ( new Promise ( async ( resolve ) => { let curPath = path + '/' + file ; if ( fs . lstatSync ( curPath ) . isDirectory ( ) ) { 
function genPid ( ) { if ( ! Uuid ) { 
function Macro ( str ) { str = str . substr ( 0 ) ; 
async function genesis ( system ) { log . i ( ' [Save Cache]' . padStart ( 80 , '=' ) ) ; log . i ( 'Genesis Compile Start:' ) ; let cacheState = null ; if ( fs . existsSync ( CacheDir ) ) cacheState = 'exists' ; cacheInterface = new CacheInterface ( { path : CacheDir , log } ) ; cleanCache ( ) ; log . i ( 'Saving modules and updating dependencies ...' ) ; await cacheModules ( system . ModCache ) ; if ( ! ( __options . state == 'updateOnly' ) ) { log . i ( 'Saving entities ...' ) ; await cacheApexes ( system . Apex , system . Config . Modules ) ; } Stop ( ) ; * Remove the cache if it currently exists in the given directory */ function cleanCache ( ) { * Write the modules to the cache * @param {Object} ModCache */ async function cacheModules ( ModCache ) { let timer = log . time ( 'cacheModules' ) ; let ModulePromiseArray = [ ] ; for ( let folder in ModCache ) { ModulePromiseArray . push ( new Promise ( async ( res ) => { await cacheInterface . addModule ( folder , ModCache [ folder ] ) ; log . v ( ` ${ folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( ModulePromiseArray ) ; log . timeEnd ( timer ) ; } async function cacheApexes ( Apexes , ModuleDefinitions ) { let ModulePromiseArray = [ ] ; for ( let moduleId in Apexes ) { ModulePromiseArray . push ( await cacheInterface . createInstance ( ModuleDefinitions [ moduleId ] , Apexes [ moduleId ] ) ) ; } await Promise . all ( ModulePromiseArray ) ; } async function Stop ( ) { log . i ( ` ${ new Date ( ) . toString ( ) } ` ) ; log . i ( ' [Finished]' . padStart ( 80 , '=' ) ) ; for ( const xgrl in BrokerCache ) { const broker = BrokerCache [ xgrl ] ; broker . cleanup ( ) ; } log . timeEnd ( compileTimer ) ; resolveMain ( ) ; } } 
function cleanCache ( ) { 
async function cacheModules ( ModCache ) { let timer = log . time ( 'cacheModules' ) ; let ModulePromiseArray = [ ] ; for ( let folder in ModCache ) { ModulePromiseArray . push ( new Promise ( async ( res ) => { await cacheInterface . addModule ( folder , ModCache [ folder ] ) ; log . v ( ` ${ folder } ` ) ; res ( ) ; } ) ) ; } await Promise . all ( ModulePromiseArray ) ; log . timeEnd ( timer ) ; } 
async function cacheApexes ( Apexes , ModuleDefinitions ) { let ModulePromiseArray = [ ] ; for ( let moduleId in Apexes ) { ModulePromiseArray . push ( await cacheInterface . createInstance ( ModuleDefinitions [ moduleId ] , Apexes [ moduleId ] ) ) ; } await Promise . all ( ModulePromiseArray ) ; } 
async function Stop ( ) { log . i ( ` ${ new Date ( ) . toString ( ) } ` ) ; log . i ( ' [Finished]' . padStart ( 80 , '=' ) ) ; for ( const xgrl in BrokerCache ) { const broker = BrokerCache [ xgrl ] ; broker . cleanup ( ) ; } log . timeEnd ( compileTimer ) ; resolveMain ( ) ; } 
function getProtocolModule ( protocol ) { return new Promise ( function ( resolve , reject ) { let cacheFilepath = path . join ( appdata , protocol ) ; if ( fs . existsSync ( cacheFilepath ) ) { return resolve ( JSON . parse ( fs . readFileSync ( cacheFilepath ) . toString ( ) ) ) ; } let options = { host : 'protocols.xgraphdev.com' , port : 443 , path : '/' + protocol , method : 'GET' , rejectUnauthorized : false , } ; let req = https . request ( options , function ( res ) { res . setEncoding ( 'utf8' ) ; let response = '' ; res . on ( 'data' , function ( chunk ) { response += chunk ; } ) ; res . on ( 'end' , _ => { try { resolve ( JSON . parse ( response ) ) ; try { fs . writeFileSync ( cacheFilepath , response ) ; } catch ( e ) { reject ( { code : 1 , text : ` ${ cacheFilepath } ` + '\n delete file and try again' } ) ; } } catch ( e ) { reject ( { code : 0 , text : 'try and retrieve locally' } ) ; } } ) ; } ) ; req . on ( 'error' , function ( e ) { log . e ( 'problem with request: ' + e . message ) ; reject ( { code : 1 , text : 'problem with request: ' + e . message } ) ; } ) ; 
function remDir ( path ) { return ( new Promise ( async ( resolve , _reject ) => { if ( fs . existsSync ( path ) ) { let files = fs . readdirSync ( path ) ; let promiseArray = [ ] ; for ( let fileIndex = 0 ; fileIndex < files . length ; fileIndex ++ ) { promiseArray . push ( new Promise ( async ( resolve2 , _reject2 ) => { let curPath = path + '/' + files [ fileIndex ] ; if ( fs . lstatSync ( curPath ) . isDirectory ( ) ) { 
function getMousePosition ( e ) { var mouseObj = void 0 , originalEvent = e . originalEvent ? e . originalEvent : e ; mouseObj = 'changedTouches' in originalEvent && originalEvent . changedTouches ? originalEvent . changedTouches [ 0 ] : originalEvent ; 
function proxyRequest ( req , res , rule ) { var router , target , path ; injectProxyHeaders ( req , rule ) ; 
function createRouter ( target ) { var key = util . format ( '%s//%s:%s' , target . protocol , target . host , target . port ) , router = routers [ key ] , options ; 
function injectAuthHeader ( req ) { if ( useGateway === true && typeof ( config . gateway . auth ) === 'string' && req . headers [ 'authorization' ] === undefined ) { req . headers [ 'authorization' ] = 'Basic ' + new Buffer ( config . gateway . auth ) . toString ( 'base64' ) ; } } 
function injectProxyHeaders ( req , rule ) { 
function parseFile ( filepath , config ) { var contents ; filepath = filepath || path . join ( process . cwd ( ) , '/json-proxy.json' ) ; 
function parseConfig ( contents , config ) { contents . server = contents . server || { } ; contents . proxy = contents . proxy || { } ; if ( contents . proxy . gateway && typeof ( contents . proxy . gateway ) === "string" && contents . proxy . gateway . length > 0 ) { contents . proxy . gateway = parseGateway ( contents . proxy . gateway ) ; } contents . proxy . forward = parseConfigMap ( contents . proxy . forward , parseForwardRule ) ; contents . proxy . headers = parseConfigMap ( contents . proxy . headers , parseHeaderRule ) ; 
function parseConfigMap ( map , callback ) { var result = [ ] ; if ( ! ( map instanceof Object ) ) { return map ; } for ( var property in map ) { if ( map . hasOwnProperty ( property ) ) { result . push ( callback ( property , map [ property ] ) ) ; } } return result ; } 
function parseCommandLine ( argv , config ) { if ( argv ) { 
function parseCommandLineArgument ( arg , fn ) { if ( typeof ( fn ) !== 'function' ) return ; if ( Array . isArray ( arg ) ) { arg . forEach ( function ( item ) { fn . call ( null , item ) ; } ) ; } else { if ( arg !== null && arg !== undefined ) { fn . call ( null , arg ) ; } } } 
function parseForwardRule ( ) { var token , rule ; if ( arguments [ 0 ] === undefined || arguments [ 0 ] === null ) { return ; } if ( typeof ( arguments [ 0 ] ) === "object" ) { return arguments [ 0 ] ; } try { token = tokenize . apply ( null , arguments ) ; rule = { regexp : new RegExp ( '^' + token . name , 'i' ) , target : parseTargetServer ( token . value ) } ; } catch ( e ) { throw new Error ( 'cannot parse the forwarding rule ' + arguments [ 0 ] + ' - ' + e ) ; } return rule ; } 
function parseTargetServer ( value ) { var target , path ; 
function tokenize ( ) { var token = { name : null , value : null } , temp = null ; if ( arguments . length !== 1 ) { token . name = arguments [ 0 ] ; token . value = arguments [ 1 ] ; return token ; } temp = arguments [ 0 ] ; if ( undefined !== temp && null !== temp ) { temp = temp . split ( '=' ) ; } if ( Array . isArray ( temp ) && temp . length > 1 ) { token . name = temp [ 0 ] ; token . value = temp [ 1 ] ; } return token ; } 
function withCode ( code , msg ) { const err = new Error ( msg ) ; err . code = code ; return err ; } 
function updateWorkingState ( repoState , branch , newWorkingState ) { let workingStates = repoState . getWorkingStates ( ) ; const key = branch . getFullName ( ) ; if ( newWorkingState === null ) { 
function fetchTree ( repoState , driver , branch ) { 
function checkout ( repoState , branch ) { let _branch = branch ; if ( ! ( branch instanceof Branch ) ) { _branch = repoState . getBranch ( branch ) ; if ( branch === null ) { throw Error ( 'Unknown branch ' + branch ) ; } } if ( ! repoState . isFetched ( _branch ) ) { throw Error ( 'Tree for branch ' + _branch . getFullName ( ) + ' must be fetched first' ) ; } return repoState . set ( 'currentBranchName' , _branch . getFullName ( ) ) ; } 
function fetchBranches ( repoState , driver ) { const oldBranches = repoState . getBranches ( ) ; return driver . fetchBranches ( ) . then ( ( branches ) => { return repoState . set ( 'branches' , branches ) ; } ) . then ( function refreshWorkingStates ( repoState ) { 
function initialize ( driver ) { const repoState = RepositoryState . createEmpty ( ) ; return fetchBranches ( repoState , driver ) . then ( ( repoState ) => { const branches = repoState . getBranches ( ) ; const master = branches . find ( function isMaster ( branch ) { return branch . getFullName ( ) === 'master' ; } ) ; const branch = master || branches . first ( ) ; return fetchTree ( repoState , driver , branch ) . then ( ( repoState ) => { return checkout ( repoState , branch ) ; } ) ; } ) ; } 
function enforceArrayBuffer ( b , encoding ) { if ( isArrayBuffer ( b ) ) return b ; else if ( isBuffer ( b ) ) return fromBuffer ( b ) ; else return fromString ( b , encoding ) ; } 
function enforceString ( b , encoding ) { if ( is . string ( b ) ) return b ; if ( isArrayBuffer ( b ) ) b = toBuffer ( b ) ; return b . toString ( encoding ) ; } 
function equals ( buf1 , buf2 ) { if ( buf1 . byteLength != buf2 . byteLength ) return false ; const dv1 = new Int8Array ( buf1 ) ; const dv2 = new Int8Array ( buf2 ) ; for ( let i = 0 ; i != buf1 . byteLength ; i ++ ) { if ( dv1 [ i ] != dv2 [ i ] ) return false ; } return true ; } 
function getChange ( parent , sha ) { if ( parent === sha ) { return CHANGE . IDENTICAL ; } else if ( parent === null ) { return CHANGE . ADDED ; } else if ( sha === null ) { return CHANGE . DELETED ; } else { 
function getMergedFileSet ( workingState ) { return Immutable . Set . fromKeys ( getMergedTreeEntries ( workingState ) . filter ( treeEntry => treeEntry . getType ( ) === TreeEntry . TYPES . BLOB ) ) ; } 
function getMergedTreeEntries ( workingState ) { const removedOrModified = workingState . getChanges ( ) . groupBy ( ( change , path ) => { if ( change . getType ( ) === CHANGES . REMOVE ) { return 'remove' ; } else { 
function hasPendingChanges ( workingState , filepath ) { 
function findSha ( workingState , filepath ) { 
function prepare ( repoState , opts ) { const workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) ; 
function flush ( repoState , driver , commitBuilder , options = { } ) { options = Object . assign ( { branch : repoState . getCurrentBranch ( ) , ignoreEmpty : true } , options ) ; if ( options . ignoreEmpty && commitBuilder . isEmpty ( ) && commitBuilder . getParents ( ) . count ( ) < 2 ) { return Q ( repoState ) ; } 
function format ( color , messages ) { var length = messages . length ; if ( length === 0 || typeof ( color ) !== 'string' ) { return ; } return ( util . format . apply ( null , messages ) [ color ] ) ; } 
function push ( repoState , driver , opts = { } ) { opts = Object . assign ( { branch : repoState . getCurrentBranch ( ) , force : false , remote : { name : 'origin' } } , opts ) ; return driver . push ( opts ) 
function pull ( repoState , driver , opts = { } ) { opts = Object . assign ( { branch : repoState . getCurrentBranch ( ) , force : false , remote : { name : 'origin' } } , opts ) ; return driver . pull ( opts ) 
function sync ( repoState , driver , opts = { } ) { opts = Object . assign ( { branch : repoState . getCurrentBranch ( ) , force : false , remote : { name : 'origin' } } , opts ) ; return pull ( repoState , driver , opts ) . fail ( ( err ) => { if ( err . code === ERRORS . REF_NOT_FOUND ) { return Promise ( repoState ) ; } return Promise . reject ( err ) ; } ) . then ( ( newRepoState ) => { return push ( newRepoState , driver , opts ) ; } ) ; } 
function compareRefs ( driver , base , head ) { const baseRef = base instanceof Branch ? base . getFullName ( ) : base ; const headRef = head instanceof Branch ? head . getFullName ( ) : head ; return driver . findParentCommit ( baseRef , headRef ) . then ( ( parentCommit ) => { 
function solveTree ( treeConflict , solved ) { solved = treeConflict . getConflicts ( ) . merge ( solved ) 
function mergeCommit ( treeConflict , parents , options ) { options = options || { } ; const opts = { } ; 
function _compareTrees ( parentEntries , baseEntries , headEntries ) { const headDiff = _diffEntries ( parentEntries , headEntries ) ; const baseDiff = _diffEntries ( parentEntries , baseEntries ) ; 
function _getSolvedEntries ( treeConflict ) { const parentEntries = treeConflict . getParent ( ) . getTreeEntries ( ) ; const baseEntries = treeConflict . getBase ( ) . getTreeEntries ( ) ; const headEntries = treeConflict . getHead ( ) . getTreeEntries ( ) ; const baseDiff = _diffEntries ( parentEntries , baseEntries ) ; const headDiff = _diffEntries ( parentEntries , headEntries ) ; const resolvedEntries = treeConflict . getConflicts ( ) . map ( ( solvedConflict ) => { 
function addBlob ( cache , sha , blob ) { const blobs = cache . getBlobs ( ) ; const newBlobs = blobs . set ( sha , blob ) ; const newCache = cache . set ( 'blobs' , newBlobs ) ; return newCache ; } 
function pathToKeySeq ( path ) { 
function get ( repoState , dirPath ) { 
function normCreatedCommit ( ghCommit ) { const commit = Commit . create ( { sha : ghCommit . sha , message : ghCommit . message , author : getSimpleAuthor ( ghCommit . author ) , date : ghCommit . author . date , parents : ghCommit . parents . map ( function getSha ( o ) { return o . sha ; } ) } ) ; return commit ; } 
function normListedCommit ( ghCommit ) { const commit = Commit . create ( { sha : ghCommit . sha , message : ghCommit . commit . message , author : getCompleteAuthor ( ghCommit ) , date : ghCommit . commit . author . date , files : ghCommit . files , parents : ghCommit . parents . map ( c => c . sha ) } ) ; return commit ; } 
function getSimpleAuthor ( author ) { return Author . create ( { name : author . name , email : author . email , date : author . date } ) ; } 
function getCompleteAuthor ( commit ) { const author = getSimpleAuthor ( commit . commit . author ) ; const avatar = commit . author ? commit . author . avatar_url : gravatar . url ( author . getEmail ( ) ) ; return author . set ( 'avatar' , avatar ) ; } 
function fetch ( repoState , driver , filepath ) { if ( isFetched ( repoState , filepath ) ) { 
function stat ( repoState , filepath ) { const workingState = repoState . getCurrentState ( ) ; 
function readAsString ( repoState , filepath , encoding ) { const blob = read ( repoState , filepath ) ; return blob . getAsString ( encoding ) ; } 
function exists ( repoState , filepath ) { const workingState = repoState . getCurrentState ( ) ; const mergedFileSet = WorkingUtils . getMergedTreeEntries ( workingState ) ; return mergedFileSet . has ( filepath ) ; } 
function create ( repoState , filepath , content ) { content = content || '' ; if ( exists ( repoState , filepath ) ) { throw error . fileAlreadyExist ( filepath ) ; } const change = Change . createCreate ( content ) ; return ChangeUtils . setChange ( repoState , filepath , change ) ; } 
function write ( repoState , filepath , content ) { if ( ! exists ( repoState , filepath ) ) { throw error . fileNotFound ( filepath ) ; } const change = Change . createUpdate ( content ) ; return ChangeUtils . setChange ( repoState , filepath , change ) ; } 
function remove ( repoState , filepath ) { if ( ! exists ( repoState , filepath ) ) { throw error . fileNotFound ( filepath ) ; } const change = Change . createRemove ( ) ; return ChangeUtils . setChange ( repoState , filepath , change ) ; } 
function move ( repoState , filepath , newFilepath ) { if ( filepath === newFilepath ) { return repoState ; } const initialWorkingState = repoState . getCurrentState ( ) ; 
function hasChanged ( previousState , newState , filepath ) { const previouslyExists = exists ( previousState , filepath ) ; const newExists = exists ( newState , filepath ) ; if ( ! previouslyExists && ! newExists ) { 
function setup ( connection , done ) { var config = createDefaultConfig ( ) , options = { proxy : false , headers : { } } ; 
function configureNock ( options , config ) { var result = { } ; 
function configureExpress ( config , done ) { var portfinder = require ( 'portfinder' ) ; tmp . dir ( function ( err , filepath ) { handles . filepath = filepath ; portfinder . getPort ( function ( err , port ) { if ( err ) throw ( err ) ; handles . port = port ; fs . writeFileSync ( path . join ( handles . filepath , 'index.txt' ) , 'hello, world' ) ; app . use ( proxy . initialize ( config ) ) ; app . use ( express . static ( handles . filepath ) ) ; handles . server = require ( 'http' ) . createServer ( app ) ; handles . server . listen ( handles . port , function ( ) { done ( null , handles . port ) ; } ) ; } ) ; } ) ; } 
function configureLanProxy ( options , config , done ) { var portfinder = require ( 'portfinder' ) , request = require ( 'request' ) , credentials = config . proxy . gateway . auth , gatewayPort , expectedAuthorizationHeader , requestViaHeader , responseViaHeader ; handles = handles || { } ; handles . gatewayServer = require ( 'http' ) . createServer ( function ( req , res ) { expectedAuthorizationHeader = 'Basic ' + new Buffer ( credentials ) . toString ( 'base64' ) ; 
function cleanup ( done ) { config = null ; rules . forEach ( function ( rule ) { rule . done ( ) ; } ) ; nock . cleanAll ( ) ; handles . server . close ( ) ; if ( handles . gatewayServer !== undefined && handles . gatewayServer !== null ) { handles . gatewayServer . close ( ) ; } fs . unlinkSync ( path . join ( handles . filepath , '/index.txt' ) ) ; handles = null ; done ( ) ; } 
function setChange ( repoState , filepath , change ) { let workingState = repoState . getCurrentState ( ) ; let changes = workingState . getChanges ( ) ; const type = change . getType ( ) ; 
function revertAll ( repoState ) { let workingState = repoState . getCurrentState ( ) ; 
function revertForFile ( repoState , filePath ) { let workingState = repoState . getCurrentState ( ) ; 
function revertForDir ( repoState , dirPath ) { let workingState = repoState . getCurrentState ( ) ; let changes = workingState . getChanges ( ) ; 
function revertAllRemoved ( repoState ) { let workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) . filter ( 
function normPath ( p ) { p = path . normalize ( p ) ; if ( p [ 0 ] == '/' ) p = p . slice ( 1 ) ; if ( p [ p . length - 1 ] == '/' ) p = p . slice ( 0 , - 1 ) ; if ( p == '.' ) p = '' ; return p ; } 
function pathContains ( dir , path ) { dir = dir ? normPath ( dir ) + '/' : dir ; path = normPath ( path ) ; return path . indexOf ( dir ) === 0 ; } 
function read ( repoState , dirName ) { dirName = PathUtils . norm ( dirName ) ; const workingState = repoState . getCurrentState ( ) ; const changes = workingState . getChanges ( ) ; const treeEntries = WorkingUtils . getMergedTreeEntries ( workingState ) ; const files = [ ] ; treeEntries . forEach ( ( treeEntry , filepath ) => { 
function readRecursive ( repoState , dirName ) { 
function readFilenames ( repoState , dirName ) { const files = read ( repoState , dirName ) ; return files . map ( ( file ) => { return file . getPath ( ) ; } ) ; } 
function readFilenamesRecursive ( repoState , dirName ) { dirName = PathUtils . norm ( dirName ) ; const workingState = repoState . getCurrentState ( ) ; const fileSet = WorkingUtils . getMergedFileSet ( workingState ) ; return fileSet . filter ( ( path ) => { return PathUtils . contains ( dirName , path ) ; } ) . toArray ( ) ; } 
function move ( repoState , dirName , newDirName ) { 
function remove ( repoState , dirName ) { 
function create ( repositoryState , driver , name , opts = { } ) { const { 
function update ( repoState , driver , branchName ) { branchName = Normalize . branchName ( branchName || repoState . getCurrentBranch ( ) ) ; return driver . fetchBranches ( ) . then ( ( branches ) => { const newBranch = branches . find ( ( branch ) => { return branch . getFullName ( ) === branchName ; } ) ; if ( ! newBranch ) { return repoState ; } else { return RepoUtils . fetchTree ( repoState , driver , newBranch ) ; } } ) ; } 
function remove ( repoState , driver , branch ) { return driver . deleteBranch ( branch ) . then ( ( ) => { return repoState . updateBranch ( branch , null ) ; } ) ; } 
function merge ( repoState , driver , from , into , options = { } ) { options = Object . assign ( { fetch : true } , options ) ; let updatedInto ; 
function fetch ( repoState , driver , sha ) { if ( isFetched ( repoState , sha ) ) { 
function ( context , options , callback ) { 
function PokitDok ( clientId , clientSecret , version ) { this . clientId = clientId ; this . clientSecret = clientSecret ; this . version = version || 'v4' ; this . refreshActive = false ; this . retryQueue = [ ] ; this . accessToken = null ; } 
function findRouterNode ( root ) { return root . find ( j . JSXElement , { openingElement : { name : { name : 'Router' } } } ) . nodes ( ) [ 0 ] ; } 
function _action ( type , payload , checklist , optional = [ ] ) { for ( let checkitem of [ 'namespace' , ... checklist ] ) { if ( optional . indexOf ( checkitem ) === - 1 ) { assert ( payload [ checkitem ] , ` ${ type } ${ checkitem } ` ) ; } } const filePath = join ( payload . sourcePath , payload . filePath ) ; const source = readFile ( filePath ) ; const root = j ( source ) ; const models = root . findModels ( payload . namespace ) ; const args = checklist . map ( checkitem => payload [ checkitem ] ) ; models [ type ] . apply ( models , args ) ; writeFile ( filePath , root . toSource ( ) ) ; } 
function featureArrayToFeatureString ( features , bias , firstFeatureNumber ) { if ( ! Array . isArray ( features ) ) throw new Error ( "Expected an array, but got " + JSON . stringify ( features ) ) var line = ( bias ? " " + firstFeatureNumber + ":" + bias : "" ) ; for ( var feature = 0 ; feature < features . length ; ++ feature ) { var value = features [ feature ] ; if ( value ) line += ( " " + ( feature + firstFeatureNumber + ( bias ? 1 : 0 ) ) + ":" + value . toPrecision ( 5 ) ) ; } return line ; } 
function ( feature ) { if ( ! ( feature in this . featureNameToFeatureIndex ) ) { var newIndex = this . featureIndexToFeatureName . length ; this . featureIndexToFeatureName . push ( feature ) ; this . featureNameToFeatureIndex [ feature ] = newIndex ; } } 
function ( hash ) { if ( hash instanceof Array ) { for ( var index in hash ) this . addFeature ( hash [ index ] ) ; } else if ( hash instanceof Object ) { for ( var feature in hash ) this . addFeature ( feature ) ; } else throw new Error ( "FeatureLookupTable.addFeatures expects a hash or an array, but got: " + JSON . stringify ( hash ) ) ; } 
function ( hash ) { this . addFeatures ( hash ) ; var array = [ ] ; for ( var featureIndex = 0 ; featureIndex < this . featureIndexToFeatureName . length ; ++ featureIndex ) array [ featureIndex ] = 0 ; if ( hash instanceof Array ) { for ( var i in hash ) array [ this . featureNameToFeatureIndex [ hash [ i ] ] ] = true ; } else if ( hash instanceof Object ) { for ( var feature in hash ) array [ this . featureNameToFeatureIndex [ feature ] ] = hash [ feature ] ; } else throw new Error ( "Unsupported type: " + JSON . stringify ( hash ) ) ; return array ; } 
function ( hashes ) { this . addFeaturess ( hashes ) ; var arrays = [ ] ; for ( var i = 0 ; i < hashes . length ; ++ i ) { arrays [ i ] = [ ] ; for ( var feature in this . featureNameToFeatureIndex ) arrays [ i ] [ this . featureNameToFeatureIndex [ feature ] ] = hashes [ i ] [ feature ] || 0 ; } return arrays ; } 
function ( array ) { var hash = { } ; for ( var feature in this . featureNameToFeatureIndex ) { if ( array [ this . featureNameToFeatureIndex [ feature ] ] ) hash [ feature ] = array [ this . featureNameToFeatureIndex [ feature ] ] ; } return hash ; } 
function ( arrays ) { var hashes = [ ] ; for ( var i = 0 ; i < arrays . length ; ++ i ) hashes [ i ] = this . arrayToHash ( arrays [ i ] ) ; return hashes ; } 
function ( opts ) { opts = opts || { } ; if ( ! opts . multilabelClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multilabelClassifierType is null" ) ; } this . multilabelClassifierType = opts . multilabelClassifierType ; this . splitLabel = opts . splitLabel || function ( label ) { return label . split ( / @ / ) ; } this . joinLabel = opts . joinLabel || function ( superlabel ) { return superlabel . join ( "@" ) ; } this . root = { superlabelClassifier : this . newMultilabelClassifier ( ) , mapSuperlabelToBranch : { } } this . allClasses = { } ; } 
function ( sample , labels ) { labels = multilabelutils . normalizeOutputLabels ( labels ) ; for ( var i in labels ) this . allClasses [ labels [ i ] ] = true ; return this . trainOnlineRecursive ( sample , labels . map ( this . splitLabel ) , this . root ) ; } 
function ( sample , splitLabels , treeNode ) { var superlabels = { } ; 
function ( dataset ) { dataset = dataset . map ( function ( datum ) { var normalizedLabels = multilabelutils . normalizeOutputLabels ( datum . output ) ; for ( var i in normalizedLabels ) this . allClasses [ normalizedLabels [ i ] ] = true ; return { input : datum . input , output : normalizedLabels . map ( this . splitLabel ) } } , this ) ; 
function ( dataset , treeNode ) { var superlabelsDataset = [ ] ; var mapSuperlabelToRestDataset = { } ; dataset . forEach ( function ( datum ) { var splitLabels = datum . output ; { Offer: [ [ 'Leased Car', 'Without leased car' ], [ 'Working Hours', '9 hours' ] ] } Sample of superlabelsDataset, initial dataset with superlabel instead of entire output '. [end]': 0.965080896043587 }, output: [ 'Offer' ] } ] */ superlabelsDataset . push ( { input : datum . input , output : Object . keys ( superlabels ) } ) ; for ( var superlabel in mapSuperlabelToRest ) { if ( ! ( superlabel in mapSuperlabelToRestDataset ) ) mapSuperlabelToRestDataset [ superlabel ] = [ ] ; mapSuperlabelToRestDataset [ superlabel ] . push ( { input : datum . input , output : mapSuperlabelToRest [ superlabel ] } ) ; } } , this ) ; with the dataset from new structure mapSuperlabelToRestDataset (see above) */ this . trainBatchRecursive ( mapSuperlabelToRestDataset [ superlabel ] , treeNode . mapSuperlabelToBranch [ superlabel ] ) ; } } 
function ( sample , explain ) { var splitLabels = this . classifyRecursive ( sample , explain , this . root ) ; 
function ( sample , explain , treeNode , depth ) { if ( ! depth ) depth = 1 ; 
function ( featureLookupTable , treeNode ) { if ( treeNode . superlabelClassifier && treeNode . superlabelClassifier . setFeatureLookupTable ) treeNode . superlabelClassifier . setFeatureLookupTable ( featureLookupTable ) ; for ( var superlabel in treeNode . mapSuperlabelToBranch ) this . setFeatureLookupTableRecursive ( featureLookupTable , treeNode . mapSuperlabelToBranch [ superlabel ] ) ; } 
function ( opts ) { if ( ! ( 'binaryClassifierType' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain binaryClassifierType" ) ; } if ( ! opts . binaryClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.binaryClassifierType is null" ) ; } this . binaryClassifierType = opts . binaryClassifierType ; this . classifier = new this . binaryClassifierType ( ) ; switch ( opts . segmentSplitStrategy ) { case 'shortestSegment' : this . segmentSplitStrategy = this . shortestSegmentSplitStrategy ; break ; case 'longestSegment' : this . segmentSplitStrategy = this . longestSegmentSplitStrategy ; break ; case 'cheapestSegment' : this . segmentSplitStrategy = this . cheapestSegmentSplitStrategy ; break ; default : this . segmentSplitStrategy = null ; } this . mapClassnameToClassifier = { } ; } 
function ( sample , classes ) { sample = this . sampleToFeatures ( sample , this . featureExtractors ) ; classes = hash . normalized ( classes ) ; for ( var positiveClass in classes ) { this . makeSureClassifierExists ( positiveClass ) ; this . mapClassnameToClassifier [ positiveClass ] . trainOnline ( sample , 1 ) ; } for ( var negativeClass in this . mapClassnameToClassifier ) { if ( ! classes [ negativeClass ] ) this . mapClassnameToClassifier [ negativeClass ] . trainOnline ( sample , 0 ) ; } } 
function ( dataset ) { 
function ( segment , explain ) { var classes = this . classifySegment ( segment , explain ) ; if ( classes . classes . length == 0 ) { 
function ( words , accumulatedClasses , explain , explanations ) { 
function ( words , accumulatedClasses , explain , explanations ) { var currentStart = 0 ; for ( var currentEnd = 1 ; currentEnd <= words . length ; ++ currentEnd ) { var segment = words . slice ( currentStart , currentEnd ) . join ( " " ) ; var segmentClassesWithExplain = this . classifySegment ( segment , explain ) ; var segmentClasses = ( segmentClassesWithExplain . classes ? segmentClassesWithExplain . classes : segmentClassesWithExplain ) ; if ( segmentClasses . length == 1 ) { 
function ( words , accumulatedClasses , explain , explanations ) { var currentStart = 0 ; var segment = null ; var segmentClassesWithExplain = null ; var segmentClasses = null ; for ( var currentEnd = 1 ; currentEnd <= words . length ; ++ currentEnd ) { var nextSegment = words . slice ( currentStart , currentEnd ) . join ( " " ) ; var nextSegmentClassesWithExplain = this . classifySegment ( nextSegment , explain ) ; var nextSegmentClasses = ( nextSegmentClassesWithExplain . classes ? nextSegmentClassesWithExplain . classes : nextSegmentClassesWithExplain ) ; console.dir(explanations); process.exit(1); }*/ } 
function ( sentence , explain ) { 
function ( opts ) { this . retrain_count = opts . retrain_count || 10 ; this . Constant = opts . Constant || 5.0 ; this . weights = { 
function ( sample , classes ) { var classesSet = hash . normalized ( classes ) ; var ranks = this . predict ( sample , false ) ; 
function ( dataset ) { 
function ( features , explain , withScores ) { this . editFeatureValues ( features , true ) ; var scoresVector = this . predict ( features , true , explain ) ; return multilabelutils . mapScoresVectorToMultilabelResult ( scoresVector , explain , withScores , 0 ) ; } 
function ( classes ) { classes = hash . normalized ( classes ) ; for ( var aClass in classes ) { if ( ! ( aClass in this . weights ) ) { this . weights [ aClass ] = { } ; this . weights_sum [ aClass ] = { } ; } } } 
function ( opts ) { opts = opts || { } ; if ( ! opts . multilabelClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multilabelClassifierType is null" ) ; } if ( ! opts . numberofclassifiers ) { console . dir ( opts ) ; throw new Error ( "opts.numberofclassifiers is null" ) ; } 
function ( ) { this . count = 0 ; this . TP = 0 ; this . TN = 0 ; this . FP = 0 ; this . FN = 0 ; this . TRUE = 0 ; this . startTime = new Date ( ) ; this . labels = { } this . dep = { } this . confusion = { } } 
function ( expected , actual ) { this . count ++ ; if ( expected && actual ) this . TP ++ ; if ( ! expected && actual ) this . FP ++ ; if ( expected && ! actual ) this . FN ++ ; if ( ! expected && ! actual ) this . TN ++ ; if ( expected == actual ) this . TRUE ++ ; } 
function ( expectedClasses , actualClasses ) { var explanations = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; if ( ! ( Object . keys ( expectedClasses ) [ 0 ] in this . confusion ) ) this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] = { } if ( ! ( Object . keys ( actualClasses ) [ 0 ] in this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] ) ) this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] [ Object . keys ( actualClasses ) [ 0 ] ] = 0 this . confusion [ Object . keys ( expectedClasses ) [ 0 ] ] [ Object . keys ( actualClasses ) [ 0 ] ] += 1 for ( var actualClass in actualClasses ) { if ( ! ( actualClass in this . confusion ) ) this . confusion [ actualClass ] = { } if ( ! ( actualClass in this . labels ) ) { this . labels [ actualClass ] = { } this . labels [ actualClass ] [ 'TP' ] = 0 this . labels [ actualClass ] [ 'FP' ] = 0 this . labels [ actualClass ] [ 'FN' ] = 0 } if ( actualClass in expectedClasses ) { this . labels [ actualClass ] [ 'TP' ] += 1 } else { this . labels [ actualClass ] [ 'FP' ] += 1 } } for ( var expectedClass in expectedClasses ) { if ( ! ( expectedClass in this . labels ) ) { this . labels [ expectedClass ] = { } this . labels [ expectedClass ] [ 'TP' ] = 0 this . labels [ expectedClass ] [ 'FP' ] = 0 this . labels [ expectedClass ] [ 'FN' ] = 0 } if ( ! ( expectedClass in actualClasses ) ) { this . labels [ expectedClass ] [ 'FN' ] += 1 } } } 
function ( expectedClasses , actualClasses , logTruePositives ) { var explanations = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; for ( var actualClass in actualClasses ) { if ( actualClass in expectedClasses ) { if ( logTruePositives ) explanations . push ( "\t\t+++ TRUE POSITIVE: " + actualClass ) ; this . TP ++ ; } else { explanations . push ( "\t\t--- FALSE POSITIVE: " + actualClass ) ; this . FP ++ ; allTrue = false ; } } for ( var expectedClass in expectedClasses ) { if ( ! ( expectedClass in actualClasses ) ) { explanations . push ( "\t\t--- FALSE NEGATIVE: " + expectedClass ) ; this . FN ++ ; allTrue = false ; } } if ( allTrue ) { if ( logTruePositives ) explanations . push ( "\t\t*** ALL TRUE!" ) ; this . TRUE ++ ; } this . count ++ ; return explanations ; } 
function ( expectedClasses , actualClasses , logTruePositives ) { var explanations = { } ; explanations [ 'TP' ] = [ ] ; explanations [ 'FP' ] = [ ] ; explanations [ 'FN' ] = [ ] ; actualClasses = hash . normalized ( actualClasses ) ; expectedClasses = hash . normalized ( expectedClasses ) ; var allTrue = true ; for ( var actualClass in actualClasses ) { if ( actualClass in expectedClasses ) { if ( logTruePositives ) explanations [ 'TP' ] . push ( actualClass ) ; this . TP ++ ; } else { explanations [ 'FP' ] . push ( actualClass ) ; this . FP ++ ; allTrue = false ; } } for ( var expectedClass in expectedClasses ) { if ( ! ( expectedClass in actualClasses ) ) { explanations [ 'FN' ] . push ( expectedClass ) ; this . FN ++ ; allTrue = false ; } } if ( allTrue ) { 
function ( expectedClasses , actualClasses , logTruePositives ) { var ex = [ ] var ac = [ ] var matchlist = [ ] 
function ( begin , end ) { if ( ( begin [ 0 ] <= end [ 0 ] ) && ( begin [ 1 ] >= end [ 0 ] ) ) return true if ( ( begin [ 0 ] >= end [ 0 ] ) && ( begin [ 0 ] <= end [ 1 ] ) ) return true return false } 
function WinnowHash ( opts ) { if ( ! opts ) opts = { } this . debug = opts . debug || false ; 
function ( dataset ) { 
function ( dataset ) { if ( this . debug ) console . log ( "trainBatch start" ) ; var timestamp = new Date ( ) . getTime ( ) + "_" + process . pid var learnFile = svmcommon . writeDatasetToFile ( dataset , this . bias , true , this . model_file_prefix + "_" + timestamp , "SvmPerf" , FIRST_FEATURE_NUMBER ) ; var modelFile = learnFile . replace ( / [.]learn / , ".model" ) ; var command = "svm_perf_learn " + this . learn_args + " " + learnFile + " " + modelFile ; if ( this . debug ) console . log ( "running " + command ) ; console . log ( command ) var result = execSync ( command ) ; if ( result . code > 0 ) { console . dir ( result ) ; console . log ( fs . readFileSync ( learnFile , 'utf-8' ) ) ; throw new Error ( "Failed to execute: " + command ) ; } this . setModel ( fs . readFileSync ( modelFile , "utf-8" ) ) ; if ( this . debug ) console . log ( "trainBatch end" ) ; } 
function modelStringToModelMap ( modelString ) { var matches = SVM_PERF_MODEL_PATTERN . exec ( modelString ) ; if ( ! matches ) { console . log ( modelString ) ; throw new Error ( "Model does not match SVM-perf format" ) ; } ; 
function ( dataset , relationName , featureLookupTable ) { var arff = "% Automatically generated by Node.js\n" ; arff += "@relation " + relationName + "\n" ; featureLookupTable . featureIndexToFeatureName . forEach ( function ( featureName ) { if ( _ . isUndefined ( featureName ) ) arff += "@attribute undefined {0,1}" + "\n" ; else if ( ! _ . isString ( featureName ) ) throw new Error ( "Expected featureName to be a string, but found " + JSON . stringify ( featureName ) ) ; else arff += "@attribute " + featureName . replace ( / [^a-zA-Z0-9] / g , "_" ) + " " + "{0,1}" + "\n" ; } ) ; arff += "\n@data\n" ; dataset . forEach ( function ( datum ) { var datumArff = _ . clone ( datum . input , { } ) ; for ( var i = 0 ; i < datum . output . length ; ++ i ) datumArff [ datum . output [ i ] ] = 1 ; 
function SvmLinear ( opts ) { this . learn_args = opts . learn_args || "" ; this . model_file_prefix = opts . model_file_prefix || null ; this . bias = opts . bias || 1.0 ; this . multiclass = opts . multiclass || false ; this . debug = opts . debug || false ; this . train_command = opts . train_command || 'liblinear_train' ; this . test_command = opts . test_command || 'liblinear_test' ; this . timestamp = "" if ( ! SvmLinear . isInstalled ( ) ) { var msg = "Cannot find the executable 'liblinear_train'. Please download it from the LibLinear website, and put a link to it in your path." ; console . error ( msg ) throw new Error ( msg ) ; } } 
function ( dataset ) { this . timestamp = new Date ( ) . getTime ( ) + "_" + process . pid 
function modelStringToModelMap ( modelString ) { var matches = LIB_LINEAR_MODEL_PATTERN . exec ( modelString ) ; if ( ! matches ) { console . log ( modelString ) ; throw new Error ( "Model does not match SVM-Linear format" ) ; } ; var labels = matches [ 1 ] . split ( / \s+ / ) ; var mapLabelToMapFeatureToWeight = { } ; for ( var iLabel in labels ) { var label = labels [ iLabel ] ; mapLabelToMapFeatureToWeight [ label ] = { } ; } var weightsMatrix = matches [ 3 ] ; 
function ( opts ) { if ( ! opts . rankerType ) { console . dir ( opts ) ; throw new Error ( "opts.rankerType not found" ) ; } if ( ! opts . counterType ) { console . dir ( opts ) ; throw new Error ( "opts.counterType not found" ) ; } this . ranker = new opts . rankerType ( ) ; this . counter = new opts . counterType ( ) ; } 
function ( sample , labels ) { 
function ( dataset ) { 
function ( sample , explain ) { var rankedLabelsWithExplain = this . ranker . classify ( sample , explain , true ) ; var rankedLabels = ( explain > 0 ? rankedLabelsWithExplain . classes : rankedLabelsWithExplain ) ; var labelCountWithExplain = this . counter . classify ( sample , explain , true ) ; var labelCount = ( explain > 0 ? labelCountWithExplain . classes [ 0 ] [ 0 ] : labelCountWithExplain [ 0 ] [ 0 ] ) ; if ( _ . isString ( labelCount ) ) labelCount = parseInt ( labelCount ) ; 
function ( featureLookupTable ) { if ( this . ranker . setFeatureLookupTable ) this . ranker . setFeatureLookupTable ( featureLookupTable ) ; if ( this . counter . setFeatureLookupTable ) this . counter . setFeatureLookupTable ( featureLookupTable ) ; } 
function ( opts ) { if ( ! opts . binaryClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.binaryClassifierType not found" ) ; } this . binaryClassifierType = opts . binaryClassifierType ; this . debug = opts . debug || false this . mapClassnameToClassifier = { } ; } 
function ( sample , labels ) { labels = multilabelutils . normalizeOutputLabels ( labels ) ; for ( var l in labels ) { var positiveLabel = labels [ l ] ; this . makeSureClassifierExists ( positiveLabel ) ; this . mapClassnameToClassifier [ positiveLabel ] . trainOnline ( sample , 1 ) ; } for ( var negativeLabel in this . mapClassnameToClassifier ) { if ( labels . indexOf ( negativeLabel ) < 0 ) this . mapClassnameToClassifier [ negativeLabel ] . trainOnline ( sample , 0 ) ; } } 
function ( dataset ) { 
function ( sample , explain , withScores ) { var labels = [ ] var scores = [ ] var explanations = [ ] ; var positive_explanations = { } ; var negative_explanations = [ ] for ( var label in this . mapClassnameToClassifier ) { var classifier = this . mapClassnameToClassifier [ label ] ; if ( this . debug ) console . dir ( "Classify for class=" + label ) 
function ( featureLookupTable ) { 
function ( label ) { if ( ! this . mapClassnameToClassifier [ label ] ) { 
function ( opts ) { opts = opts || { } ; if ( ! ( 'multiclassClassifierType' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain multiclassClassifierType" ) ; } if ( ! opts . multiclassClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multiclassClassifierType is null" ) ; } if ( ! ( 'evaluateMeasureToMaximize' in opts ) ) { console . dir ( opts ) ; throw new Error ( "opts must contain evaluateMeasureToMaximize" ) ; } if ( ! opts . evaluateMeasureToMaximize ) { console . dir ( opts ) ; throw new Error ( "opts.evaluateMeasureToMaximize is null" ) ; } if ( ! opts . numOfFoldsForThresholdCalculation ) { console . dir ( opts ) ; throw new Error ( "opts.numOfFoldsForThresholdCalculation is null" ) ; } this . multiclassClassifier = new opts . multiclassClassifierType ( ) ; 
function ( dataset ) { _ . times ( 3 , function ( n ) { dataset = _ . shuffle ( dataset ) } ) if ( this . numOfFoldsForThresholdCalculation > 1 ) { thresholds = [ ] best_performances = [ ] average_performances = [ ] median_performances = [ ] partitions . partitions_consistent ( dataset , this . numOfFoldsForThresholdCalculation , ( function ( trainSet , testSet , index ) { this . multiclassClassifier . trainBatch ( trainSet ) ; result = this . receiveScores ( testSet ) performance = this . CalculatePerformance ( result [ 0 ] , testSet , result [ 1 ] ) best_performances . push ( performance ) } ) . bind ( this ) ) this . stats = best_performances threshold_average = ulist . average ( _ . pluck ( best_performances , 'Threshold' ) ) threshold_median = ulist . median ( _ . pluck ( best_performances , 'Threshold' ) ) Threshold = threshold_median } else { dataset = partitions . partition ( dataset , 1 , Math . round ( dataset . length * this . devsetsize ) ) trainSet = dataset [ 'train' ] testSet = dataset [ 'test' ] this . multiclassClassifier . trainBatch ( trainSet ) ; result = this . receiveScores ( testSet ) performance = this . CalculatePerformance ( result [ 0 ] , testSet , result [ 1 ] ) Threshold = performance [ 'Threshold' ] } this . multiclassClassifier . threshold = Threshold } 
function ( dataset ) { list_of_scores = [ ] ; FN = 0 for ( var i = 0 ; i < dataset . length ; ++ i ) { var scoresVector = this . multiclassClassifier . classify ( dataset [ i ] . input , false , true ) ; for ( score in scoresVector ) { if ( dataset [ i ] . output . indexOf ( scoresVector [ score ] [ 0 ] ) > - 1 ) { scoresVector [ score ] . push ( "+" ) FN += 1 } else { scoresVector [ score ] . push ( "-" ) } scoresVector [ score ] . push ( i ) } list_of_scores = list_of_scores . concat ( scoresVector ) } 
function ( list_of_scores , testSet , FN ) { current_set = [ ] TRUE = 0 FP = 0 TP = 0 result = [ ] for ( var th = 0 ; th < list_of_scores . length ; ++ th ) { if ( list_of_scores [ th ] [ 2 ] == "+" ) { TP += 1 ; FN -= 1 } if ( list_of_scores [ th ] [ 2 ] == "-" ) { FP += 1 ; } 
function ( opts ) { if ( ! opts . multiclassClassifierType ) { console . dir ( opts ) ; throw new Error ( "opts.multiclassClassifierType not found" ) ; } this . multiclassClassifierType = opts . multiclassClassifierType ; this . featureExtractor = FeaturesUnit . normalize ( opts . featureExtractor ) ; this . multiclassClassifier = new this . multiclassClassifierType ( ) ; } 
function ( sample , classes ) { sample = this . sampleToFeatures ( sample , this . featureExtractor ) ; var category = ( Array . isArray ( classes ) ? classes [ 0 ] : classes ) ; this . multiclassClassifier . trainOnline ( sample , category ) ; } 
function ( dataset ) { for ( var i = 0 ; i < dataset . length ; ++ i ) { dataset [ i ] = { input : this . sampleToFeatures ( dataset [ i ] . input , this . featureExtractor ) , output : ( Array . isArray ( dataset [ i ] . output ) ? dataset [ i ] . output [ 0 ] : dataset [ i ] . output ) } ; } this . multiclassClassifier . trainBatch ( dataset ) ; } 
function ( segment , explain ) { var sample = this . sampleToFeatures ( segment , this . featureExtractor ) ; return this . multiclassClassifier . classify ( sample , explain ) ; } 
function ( words , accumulatedClasses , explain , explanations ) { 
function ( sentence , explain ) { var minWordsToSplit = 2 ; var words = sentence . split ( / / ) ; if ( words . length >= minWordsToSplit ) { var accumulatedClasses = { } ; var explanations = [ ] ; this . cheapestSegmentSplitStrategy ( words , accumulatedClasses , explain , explanations ) ; var classes = Object . keys ( accumulatedClasses ) ; return ( explain > 0 ? { classes : classes , explanation : explanations } : classes ) ; } else { return this . classifySegment ( sentence , explain ) ; } } 
function ( sample , featureExtractor ) { var features = sample ; if ( featureExtractor ) { try { features = { } ; featureExtractor ( sample , features ) ; } catch ( err ) { throw new Error ( "Cannot extract features from '" + JSON . stringify ( sample ) + "': " + JSON . stringify ( err ) ) ; } } return features ; } 
function loadPackageProperties ( grunt ) { var packageFile = 'package.json' ; if ( grunt . file . exists ( packageFile ) ) { return _ . pick ( grunt . file . readJSON ( packageFile ) , [ 'name' , 'version' , 'description' ] ) ; } return { } ; } 
function concatOptionDataArrays ( options , data , prop ) { if ( ! _ . has ( options , prop ) && ! _ . has ( data , prop ) ) { return ; } var combined = [ ] ; if ( _ . isArray ( options [ prop ] ) ) { combined = combined . concat ( options [ prop ] ) ; } if ( _ . isArray ( data [ prop ] ) ) { combined = combined . concat ( data [ prop ] ) ; } options [ prop ] = combined ; } 
function applySpecSettings ( grunt , options , spec ) { spec . tags . name = options . name || spec . tags . name ; if ( ! _ . has ( options , 'version' ) ) { _defaultOptionNotice ( grunt , 'version' , '0.0.0' ) ; } spec . tags . version = options . version || '0.0.0' ; if ( ! _ . has ( options , 'release' ) ) { _defaultOptionNotice ( grunt , 'release' , '1' ) ; } spec . tags . release = options . release || '1' ; if ( ! _ . has ( options , 'buildArch' ) ) { _defaultOptionNotice ( grunt , 'buildArch' , 'noarch' ) ; } spec . tags . buildArch = options . buildArch || 'noarch' ; if ( ! _ . has ( options , 'description' ) ) { _defaultOptionNotice ( grunt , 'description' , 'No Description' ) ; } spec . tags . description = options . description || 'No Description' ; if ( ! _ . has ( options , 'summary' ) ) { _defaultOptionNotice ( grunt , 'summary' , 'No Summary' ) ; } spec . tags . summary = options . summary || 'No Summary' ; if ( ! _ . has ( options , 'license' ) ) { _defaultOptionNotice ( grunt , 'license' , 'MIT' ) ; } spec . tags . license = options . license || 'MIT' ; spec . tags . epoch = options . epoch || spec . tags . epoch ; spec . tags . distribution = options . distribution || spec . tags . distribution ; if ( ! _ . has ( options , 'vendor' ) ) { _defaultOptionNotice ( grunt , 'vendor' , 'Vendor' ) ; } spec . tags . vendor = options . vendor || 'Vendor' ; spec . tags . url = options . url || spec . tags . url ; if ( ! _ . has ( options , 'group' ) ) { _defaultOptionNotice ( grunt , 'group' , 'Development/Tools' ) ; } spec . tags . group = options . group || 'Development/Tools' ; spec . tags . packager = options . packager || spec . tags . packager ; if ( _ . has ( options , 'defines' ) ) { spec . addDefines . apply ( spec , options . defines ) ; } 
function Couch ( opts ) { var self = this ; self . url = ( typeof opts . url === 'string' ) ? opts . url : null ; self . userCtx = opts . userCtx || null ; self . time_C = opts . time_C || null ; self . known_dbs = null ; self . log = debug ( 'cqs:couch:' + self . url ) ; } 
function uuids_for ( couch ) { UUIDS [ couch . url ] = UUIDS [ couch . url ] || new UUIDGetter ( couch ) ; return UUIDS [ couch . url ] ; } 
function templated_ddoc ( name ) { return stringify_functions ( TEMPLATE ) function stringify_functions ( obj ) { var copy = { } ; if ( Array . isArray ( obj ) ) return obj . map ( stringify_functions ) else if ( typeof obj === 'object' && obj !== null ) { Object . keys ( obj ) . forEach ( function ( key ) { copy [ key ] = stringify_functions ( obj [ key ] ) ; } ) return copy ; } else if ( typeof obj === 'function' ) return func_from_template ( obj ) else return lib . JDUP ( obj ) ; } } 
function pluralize ( number , words ) { var magnitude = number % 100 ; var pluralWord = '' if ( ( magnitude > 10 && magnitude < 20 ) || ( number === 0 ) ) { pluralWord = words [ 2 ] ; } else { switch ( Math . abs ( number % 10 ) ) { case 1 : pluralWord = words [ 0 ] ; break case 2 : case 3 : case 4 : pluralWord = words [ 1 ] ; break default : pluralWord = words [ 2 ] ; break } } return [ number , pluralWord ] . join ( ' ' ) } 
function Message ( opts ) { var self = this ; events . EventEmitter . call ( self ) ; lib . copy ( opts , self , 'uppercase' ) ; self . MessageId = opts . MessageId || opts . _id || null ; self . Body = opts . MessageBody || opts . Body || opts . _str || null ; self . MD5OfMessageBody = null ; self . IdExtra = opts . IdExtra || null ; self . queue = opts . queue || null ; self . is_heartbeat = opts . is_heartbeat || false ; self . seq = opts . seq || null ; self . log = debug ( 'cqs:message:' + ( self . MessageId || 'untitled' ) ) ; } 
function Queue ( opts ) { var self = this ; if ( typeof opts == 'string' ) opts = { 'name' : opts } ; opts = defaultable . merge ( opts , DEFS ) ; self . name = opts . name || opts . QueueName || opts . _str || null ; self . time_C = opts . time_C || null ; self . db = new couch . Database ( { 'couch' : opts . couch , 'db' : opts . db , time_C : self . time_C } ) ; self . VisibilityTimeout = opts . DefaultVisibilityTimeout || opts . VisibilityTimeout || DEFS . visibility_timeout ; self . cache_confirmation = true ; self . browser_attachments = ! ! ( opts . browser_attachments ) ; self . allow_foreign_docs = opts . allow_foreign_docs self . log = debug ( 'cqs:queue:' + ( self . name || 'untitled' ) ) ; } 
function preorder ( node , nodeIndex , parent ) { var children var length var index var position var child if ( is ( test , node , nodeIndex , parent ) ) { return null } children = node . children if ( ! children || children . length === 0 ) { return node } 
function asAAAA ( consumer , packet ) { var data = '' ; for ( var i = 0 ; i < 7 ; i ++ ) { data += consumer . short ( ) . toString ( 16 ) + ':' ; } data += consumer . short ( ) . toString ( 16 ) ; packet . address = data ; } 
function filterRelations ( relation ) { var mappedData = includedData . find ( function ( inc ) { return inc . id === relation . id ; } ) ; var RelationModel = getModel ( relation . type ) ; var modeledData = new RelationModel ( mappedData ) ; return checkForRelations ( modeledData , modeledData . data ) ; } 
function BundleLocator ( options ) { this . _options = options || { } ; if ( this . _options . applicationDirectory ) { this . _options . applicationDirectory = libpath . resolve ( process . cwd ( ) , this . _options . applicationDirectory ) ; } else { this . _options . applicationDirectory = process . cwd ( ) ; } this . _options . maxPackageDepth = this . _options . maxPackageDepth || DEFAULT_MAX_PACKAGES_DEPTH ; this . _options . exclude = this . _options . exclude || [ ] ; this . _cacheRules = { } ; 
function ( dir , options ) { var self = this , bundleSeeds ; 
function ( bundleName , filter ) { var bundle , files = [ ] ; bundle = this . _bundles [ bundleName ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle "' + bundleName + '"' ) ; } Object . keys ( bundle . files ) . forEach ( function ( fullpath ) { var res = { ext : libpath . extname ( fullpath ) . substr ( 1 ) } ; if ( this . _filterResource ( res , filter ) ) { files . push ( fullpath ) ; } } , this ) ; return files ; } 
function ( bundleName , filter ) { var bundle = this . _bundles [ bundleName ] ; if ( ! bundle ) { throw new Error ( 'Unknown bundle "' + bundleName + '"' ) ; } return this . _walkBundleResources ( bundle , filter ) ; } 
function ( filter ) { var self = this , ress = [ ] ; Object . keys ( this . _bundles ) . forEach ( function ( bundleName ) { var bundle = self . _bundles [ bundleName ] ; self . _walkBundleResources ( bundle , filter ) . forEach ( function ( res ) { ress . push ( res ) ; } ) ; } ) ; return ress ; } 
function ( filter ) { var bundleName , bundles = this . _bundles , bundleNames = [ ] ; if ( 'function' !== typeof filter ) { return Object . keys ( this . _bundles ) ; } for ( bundleName in bundles ) { if ( bundles . hasOwnProperty ( bundleName ) ) { if ( filter ( bundles [ bundleName ] ) ) { bundleNames . push ( bundleName ) ; } } } return bundleNames ; } 
function ( findPath ) { 
function ( baseDirectory , name , version , pkg , options ) { var seed ; seed = { baseDirectory : baseDirectory , name : name , version : version } ; if ( pkg ) { seed . name = ( pkg . locator && pkg . locator . name ? pkg . locator . name : pkg . name ) ; seed . version = pkg . version ; seed . options = pkg . locator ; seed . pkg = pkg ; } if ( options ) { if ( seed . options ) { 
function ( seed , parent ) { var bundle , ruleset = this . _loadRuleset ( seed ) , msg ; if ( seed . options . location ) { 
function ( fullPath ) { var bundleName , bundle , ruleset , relativePath , pathParts , subBundleSeed , res ; bundleName = this . _getBundleNameByPath ( fullPath ) ; bundle = this . _bundles [ bundleName ] ; if ( bundle . baseDirectory === fullPath . substr ( 0 , bundle . baseDirectory . length ) ) { relativePath = fullPath . substr ( bundle . baseDirectory . length + 1 ) ; } 
function ( fullPath , relativePath , rule ) { var r , regex ; relativePath = BundleLocator . _toUnixPath ( relativePath ) ; for ( r = 0 ; r < rule . length ; r += 1 ) { regex = rule [ r ] ; if ( regex . test ( relativePath ) ) { return true ; } } return false ; } 
function ( fullPath , relativePath , rule , parent ) { var r , matches , defaultVersion = DEFAULT_VERSION , pkg ; if ( parent ) { defaultVersion = parent . version ; } relativePath = BundleLocator . _toUnixPath ( relativePath ) ; for ( r = 0 ; r < rule . length ; r += 1 ) { matches = relativePath . match ( rule [ r ] . regex ) ; if ( matches ) { try { pkg = require ( libpath . resolve ( fullPath , 'package.json' ) ) ; } catch ( packageErr ) { 
function ( res , ruleset ) { var bundle = this . _bundles [ res . bundleName ] , ruleName , rule , relativePath = BundleLocator . _toUnixPath ( res . relativePath ) , match ; bundle . files [ res . fullPath ] = true ; for ( ruleName in ruleset ) { if ( ruleset . hasOwnProperty ( ruleName ) ) { 
function ( res ) { var bundle = this . _bundles [ res . bundleName ] , type = res . type , subtype , selector = res . selector , name = res . name ; if ( ! bundle . resources [ selector ] ) { bundle . resources [ selector ] = { } ; } if ( ! bundle . resources [ selector ] [ type ] ) { bundle . resources [ selector ] [ type ] = { } ; } if ( res . hasOwnProperty ( 'subtype' ) ) { subtype = res . subtype ; if ( ! bundle . resources [ selector ] [ type ] [ subtype ] ) { bundle . resources [ selector ] [ type ] [ subtype ] = { } ; } bundle . resources [ selector ] [ type ] [ subtype ] [ name ] = res ; } else { bundle . resources [ selector ] [ type ] [ name ] = res ; } } 
function ( res , filter ) { if ( ! filter || Object . keys ( filter ) . length === 0 ) { return true ; } var prop ; for ( prop in filter ) { if ( 'extensions' === prop ) { 
function ( dir , _depth ) { var self = this , pkg , seed , seeds = [ ] , subdirs ; _depth = _depth || 0 ; try { pkg = require ( libpath . resolve ( dir , 'package.json' ) ) ; 
function ( pkgDepths ) { 
function ( all ) { var byDepth = { } ; 
function ( bundleSeed ) { var self = this , parentName , parent , bundle , filters ; 
function ( bundle ) { var name = ( bundle . options && bundle . options . ruleset ) || DEFAULT_RULESET , cacheKey = name + '@' + bundle . baseDirectory , rulesetsPath , rulesets , dir , rules ; rules = this . _cacheRules [ cacheKey ] ; if ( rules ) { return rules ; } if ( bundle . options && bundle . options . rulesets ) { try { rulesetsPath = libpath . resolve ( bundle . baseDirectory , bundle . options . rulesets ) ; rulesets = require ( rulesetsPath ) ; } catch ( errLocal ) { if ( 'MODULE_NOT_FOUND' !== errLocal . code ) { throw errLocal ; } } if ( ! rulesets ) { dir = bundle . baseDirectory ; while ( dir ) { try { rulesetsPath = libpath . resolve ( dir , bundle . options . rulesets ) ; rulesets = require ( rulesetsPath ) ; break ; } catch ( errDir ) { if ( 'MODULE_NOT_FOUND' !== errDir . code ) { throw errDir ; } } try { rulesetsPath = libpath . resolve ( dir , 'node_modules' , bundle . options . rulesets ) ; rulesets = require ( rulesetsPath ) ; break ; } catch ( errDep ) { if ( 'MODULE_NOT_FOUND' !== errDep . code ) { throw errDep ; } } 
function ( srcObject , excludeKeys ) { var destObject = { } , key ; for ( key in srcObject ) { if ( srcObject . hasOwnProperty ( key ) ) { if ( - 1 === excludeKeys . indexOf ( key ) ) { destObject [ key ] = srcObject [ key ] ; } } } return destObject ; } 
function Bundle ( baseDirectory , options ) { this . options = options || { } ; this . name = libpath . basename ( baseDirectory ) ; this . baseDirectory = baseDirectory ; this . type = undefined ; this . files = { } ; this . resources = { } ; } 
function getBaseScales ( type , domain , range , nice , tickCount ) { const factory = ( type === 'time' && scaleUtc ) || ( type === 'log' && scaleLog ) || scaleLinear const scale = createScale ( factory , domain , range ) if ( nice ) scale . nice ( tickCount ) return scale } 
function getLineRenderData ( props , data , idx ) { if ( isEmpty ( data ) ) return undefined const path2D = getPath2D ( ) const values = getPlotValues ( props , head ( data ) , idx , { hoverAlpha : 0.2 } ) if ( props . interpolate ) { splineInterpolation ( props , data , path2D ) } else { path2D . moveTo ( values . x , values . y ) reduce ( data , ( shouldDrawPoint , d ) => { const x = plotValue ( props , d , idx , 'x' ) const y = plotValue ( props , d , idx , 'y' ) if ( notPlotNumber ( [ x , y ] ) ) return false if ( shouldDrawPoint ) path2D . lineTo ( x , y ) else path2D . moveTo ( x , y ) return true } , true ) } return { ... values , data , hoverSolver , path2D , type : 'line' , } } 
function getPointRenderData ( props , datum , idx ) { const values = getPlotValues ( props , datum , idx , { hoverAlpha : 0.75 , radius : 4 , x : getMidX ( props . plotRect ) , y : getMidY ( props . plotRect ) , } ) const path2D = getPath2D ( ) const hover2ndPath2D = getPath2D ( ) path2D . arc ( values . x , values . y , values . radius , 0 , 2 * Math . PI ) hover2ndPath2D . arc ( values . x , values . y , values . radius + 8 , 0 , 2 * Math . PI ) return { ... values , hover2ndPath2D , path2D , type : 'area' , } } 
function removeDimArrays ( props ) { const names = map ( props . groupedKeys , key => ` ${ key } ` ) return omit ( props , names ) } 
function getTextRenderData ( props , datum , idx ) { const { plotRect , theme , width , height } = props const values = getPlotValues ( props , datum , idx , { x : getMidX ( props . plotRect ) , y : getMidY ( props . plotRect ) , } ) if ( values . textSnap === 'top' ) values . y = getMinY ( plotRect ) if ( values . textSnap === 'bottom' ) values . y = getMaxY ( plotRect ) if ( values . textSnap === 'left' ) values . x = getMinX ( plotRect ) if ( values . textSnap === 'right' ) values . x = getMaxX ( plotRect ) if ( values . textSnap === 'topLeft' ) { values . x = getMinX ( plotRect ) values . y = getMinY ( plotRect ) } if ( values . textSnap === 'topRight' ) { values . x = getMaxX ( plotRect ) values . y = getMinY ( plotRect ) } if ( values . textSnap === 'bottomLeft' ) { values . x = getMinX ( plotRect ) values . y = getMaxY ( plotRect ) } if ( values . textSnap === 'bottomRight' ) { values . x = getMaxX ( plotRect ) values . y = getMaxY ( plotRect ) } const newValues = fitCheckText ( values , width , height , theme ) return { ... newValues , type : 'text' } } 
function BufferingTracer ( tracer , options ) { options = options || { } ; var self = this ; this . _tracer = tracer ; this . _maxTraces = options . maxTraces || 50 ; this . _sendInterval = options . sendInterval ? ( options . sendInterval * 1000 ) : 10 * 1000 ; this . _lastSentTs = Date . now ( ) ; this . _buffer = [ ] ; this . _stopped = false ; this . _periodSendTimeoutId = setTimeout ( this . _periodicSendFunction . bind ( this ) , this . _sendInterval ) ; } 
function RawRESTkinHTTPTracer ( traceUrl , keystoneClient ) { if ( traceUrl . charAt ( traceUrl . length - 1 ) === '/' ) { traceUrl = traceUrl . slice ( 0 , - 1 ) ; } this . _traceUrl = traceUrl ; this . _keystoneClient = keystoneClient ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function RESTkinHTTPTracer ( traceUrl , keystoneClient , options ) { var rawTracer = new module . exports . RawRESTkinHTTPTracer ( traceUrl , keystoneClient ) ; this . _tracer = new module . exports . BufferingTracer ( rawTracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function RawZipkinQueryServiceHTTPTracer ( traceUrl ) { if ( traceUrl . charAt ( traceUrl . length - 1 ) === '/' ) { traceUrl = traceUrl . slice ( 0 , - 1 ) ; } this . _traceUrl = traceUrl ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function ZipkinQueryServiceHTTPTracer ( serviceUrl , options ) { var rawTracer = new module . exports . RawZipkinQueryServiceHTTPTracer ( serviceUrl ) ; this . _tracer = new module . exports . BufferingTracer ( rawTracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function RawZipkinTracer ( scribeClient , category ) { this . scribeClient = scribeClient ; this . category = ( category ) ? category : 'zipkin' ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function ZipkinTracer ( scribeClient , category , options ) { var rawTracer = new RawZipkinTracer ( scribeClient , category ) ; this . _tracer = new BufferingTracer ( rawTracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function RawRESTkinScribeTracer ( scribeClient , category ) { this . scribeClient = scribeClient ; this . category = ( category ) ? category : 'restkin' ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function RESTkinScribeTracer ( scribeClient , category , options ) { var rawTracer = new RawRESTkinScribeTracer ( scribeClient , category ) ; this . _tracer = new module . exports . BufferingTracer ( rawTracer , options ) ; this . stop = this . _tracer . stop . bind ( this . _tracer ) ; EndAnnotationTracer . call ( this , this . sendTraces ) ; } 
function build ( gulp ) { 
function chunk ( str , maxLen ) { var len = maxLen || OPTIONS . lineWidth ; var curr = len ; var prev = 0 ; var out = [ ] ; while ( str [ curr ] ) { if ( str [ curr ++ ] == ' ' ) { out . push ( str . substring ( prev , curr ) ) ; prev = curr ; curr += len ; } } out . push ( str . substr ( prev ) ) ; return out ; } 
function usage ( gulp , options ) { 
function ( options ) { 
function ( options ) { 
function ( information , images ) { 
function Strategy ( options , verify ) { options = options || { } ; options . authorizationURL = options . authorizationURL || 'https://api.weibo.com/oauth2/authorize' ; options . tokenURL = options . tokenURL || 'https://api.weibo.com/oauth2/access_token' ; options . scopeSeparator = options . scopeSeparator || ',' ; options . customHeaders = options . customHeaders || { } ; if ( ! options . customHeaders [ 'User-Agent' ] ) { options . customHeaders [ 'User-Agent' ] = options . userAgent || 'passport-weibo' ; } OAuth2Strategy . call ( this , options , verify ) ; this . name = 'weibo' ; this . _getuidAPI = options . getuidAPI || 'https://api.weibo.com/2/account/get_uid.json' ; this . _getProfileAPI = options . getProfileAPI || 'https://api.weibo.com/2/users/show.json' ; } 
function filterArray ( arr , toKeep ) { var i = 0 while ( i < arr . length ) { if ( toKeep ( arr [ i ] ) ) { i ++ } else { arr . splice ( i , 1 ) } } } 
function filterAndSortOne ( args , adapters ) { var results = decorateAndFilter ( args , adapters ) if ( results . length === 0 ) { return } 
function filterAndSort ( args , adapters ) { var results = decorateAndFilter ( args , adapters ) 
function getAdd ( opts ) { opts = opts || { } var times = opts . times var doesConsume = opts . doesConsume return function add ( ) { var lastArg = arguments [ arguments . length - 1 ] var func = typeof lastArg === 'function' ? lastArg : function ( ) { return lastArg } var validators = arguments . length > 1 ? Array . prototype . slice . call ( arguments , 0 , - 1 ) : [ ] var newAdapter = { doesConsume : doesConsume , 
function adapt ( ) { var context = this var args = ut . getArgs ( arguments ) var filteredAdapter = ut . filterAndSortOne ( args , _adapters ) 
function all ( ) { var context = this var args = ut . getArgs ( arguments ) var filteredAdapters = ut . filterAndSort ( args , _adapters ) 
function trigger ( ) { var context = this var args = ut . getArgs ( arguments ) var filteredAdapters = ut . filterAndSort ( args , _adapters ) filteredAdapters . forEach ( ut . countdown ) ut . filterArray ( _adapters , ut . notExausted ) ut . triggerAll ( context , args , filteredAdapters ) return or } 
function stick ( ) { var context = this var args = ut . getArgs ( arguments ) var filteredAdapters = ut . filterAndSort ( args , _adapters ) var consumeAdapters = filteredAdapters . filter ( function ( adapter ) { return adapter . doesConsume } ) 
function cssExtract ( bundle , opts ) { opts = opts || { } var outFile = opts . out || opts . o || 'bundle.css' var sourceMap = d ( opts . sourceMap , bundle && bundle . _options && bundle . _options . debug , false ) assert . equal ( typeof bundle , 'object' , 'bundle should be an object' ) assert . equal ( typeof opts , 'object' , 'opts should be an object' ) 
function fakeOccamsrazor ( hiddenPropertyName , objectPropertyName , globalObj , customAttrs ) { return buildFakeObject ( hiddenPropertyName , objectPropertyName , globalObj , defaultAttrs . concat ( customAttrs ) ) } 
function githubCompareCommits ( options , parseOptions ) { return compareCommits ( options ) . then ( function ( commits ) { return massageGithubCommits ( commits , parseOptions ) ; } ) ; } 
function compareCommits ( options ) { assert ( "You MUST include 'project' in the options passed to compareCommits." + "It should be the path to the project's git root." , options . project ) ; assert ( "You MUST include 'base' in the options passed to compareCommits. " + "It should be either a branch name or tag name." , options . base ) ; assert ( "You MUST include 'head' in the options passed to compareCommits. " + "It should be either a branch name or tag name." , options . head ) ; assert ( "Branch or Tag names passed to compareCommit via 'options.head' must be strings." , typeof options . head === 'string' ) ; assert ( "Branch or Tag names passed to compareCommit via 'options.base' must be strings." , typeof options . base === 'string' ) ; return getRepository ( options . project ) . then ( function ( repository ) { return RSVP . hash ( { head : getReference ( repository , options . head ) , base : getReference ( repository , options . base ) , repository : repository } ) ; } ) . then ( function ( references ) { return RSVP . hash ( { head : getTargetCommit ( references . repository , references . head ) , base : getTargetCommit ( references . repository , references . base ) , repository : references . repository } ) ; } ) . then ( function ( heads ) { return walkCommits ( heads . repository , heads . head , heads . base ) ; } ) ; } 
function genStringify ( options ) { var stringifyFn ; if ( options . headers [ 'Content-Type' ] && options . headers [ 'Content-Type' ] . toLowerCase ( ) === 'application/x-www-form-urlencoded' ) { stringifyFn = querystring . stringify ; } else { switch ( options . method . toUpperCase ( ) ) { case 'POST' : case 'PUT' : stringifyFn = JSON . stringify ; break ; } } return stringifyFn ; } 
function decrement ( count ) { count = count || 0 ; if ( count <= MINUEND ) { count = 0 ; } else { count -= MINUEND ; } return count ; } 
function ( options , params ) { var self = this ; return this . onBeforeHandle ( ) . then ( function ( ) { 
function ( ) { var self = this ; if ( this . counted ) { return this . getRequestCount ( ) . then ( function ( count ) { count = count || 0 ; 
function ( count ) { var delayMs = count * config . requestTimeout ; if ( this . counted ) { if ( this . getRequestCount && this . saveRequestCount ) return this . saveRequestCount ( count ) . delay ( delayMs ) . then ( this . getRequestCount ) . then ( decrement ) . then ( this . saveRequestCount ) ; } return Promise . resolve ( ) ; } 
function ( hmac , bodyData ) { if ( arguments . length < 2 ) { throw paramError ; } var calculatedHmac = crypto . createHmac ( 'sha256' , this . token ) . update ( bodyData , 'utf8' ) . digest ( 'base64' ) ; return hmac === calculatedHmac ; } 
function ( token , fn ) { return function ( ) { 
function ( token , option ) { if ( arguments . length < 1 ) { throw paramError ; } check ( option ) ; this . token = token ; this . host = ( option && option . host ) || config . apiHost ; 
function ( path , query ) { if ( arguments . length < 1 ) { throw paramError ; } return this . request ( 'GET' , query ? path + '?' + querystring . stringify ( query ) : path , null ) ; } 
function ( method , path , params ) { return this . _request . request ( { hostname : this . host , path : '/v1/' + path , method : method , headers : { 'Content-Type' : 'application/json' , 'X-API-ACCESS-TOKEN' : this . token } } , params ) ; } 
function ( options ) { if ( arguments . length < 1 || ! options . appKey || ! options . appSecret ) { throw paramError ; } if ( ! options . private ) { if ( ! options . callbackUrl ) { throw paramError ; } options . scope || ( options . scope = [ 'read_basic' ] ) ; } this . app_key = options . appKey || '' ; this . app_secret = options . appSecret || '' ; this . private = options . private || false ; this . callback_url = options . callbackUrl || '' ; this . scope = options . scope || '' ; this . redirect_url = options . redirectUrl || '' ; this . protocol = options . protocol || config . httpProtocol ; this . host = options . host || config . appHost ; this . _request = new Request ( { protocol : this . protocol , } ) ; } 
function ( queryObj ) { if ( arguments . length < 1 ) { throw paramError ; } var hmac = queryObj . hmac ; delete queryObj . hmac ; return ( Date . now ( ) - new Date ( queryObj . time_stamp ) . getTime ( ) < timeOffset ) && ( hmac === crypto . createHmac ( 'sha256' , this . app_secret ) . update ( decodeURIComponent ( querystring . stringify ( queryObj ) ) , 'utf8' ) . digest ( 'hex' ) ) ; } 
function ( shopKey , state ) { if ( arguments . length < 1 ) { throw paramError ; } return this . protocol + '://' + this . host + '/oauth2/authorize?' + querystring . stringify ( { response_type : 'code' , client_id : this . app_key , shop_key : shopKey , scope : this . scope . join ( ',' ) , state : state , redirect_uri : this . redirect_url } , null , null , { encodeURIComponent : null } ) ; } 
function ( code ) { var params ; var headers = { 'Content-Type' : 'application/x-www-form-urlencoded' } ; if ( this . private ) { headers . Authorization = 'Basic ' + Buffer . from ( this . app_key + ':' + this . app_secret ) . toString ( 'base64' ) ; params = { grant_type : 'client_credentials' } ; } else { if ( arguments . length < 1 ) { throw paramError ; } params = { grant_type : 'authorization_code' , code : code , client_id : this . app_key , redirect_uri : this . redirect_url ? this . redirect_url : this . callback_url } ; } var option = { hostname : this . host , path : '/oauth2/token' , method : 'POST' , headers : headers } ; return this . _request . request ( option , params ) . then ( function ( data ) { if ( ! data . token . length ) { throw new Error ( ' token'); } return data . token ; } ) ; } 
function validatePlaceholders ( { id , idPlural , translations } , validationErrors ) { 
function validateTranslatedPlaceholders ( { id , translations } , validationErrors ) { 
function groupGettextItems ( gettextItems ) { return gettextItems . filter ( ( item ) => item . messageId ) 
function traverseJson ( json , callback ) { let { translations } = json ; Object . keys ( translations ) . forEach ( ( namespace ) => { Object . keys ( translations [ namespace ] ) . forEach ( ( k ) => { callback ( translations [ namespace ] [ k ] , translations [ namespace ] , k ) ; } ) ; } ) ; } 
function autoParse ( value , type ) { if ( type ) { return parseType ( value , type ) } var orignalValue = value if ( value === null ) { return null } if ( value === void 0 ) { return undefined } if ( value instanceof Date || value instanceof RegExp ) { return value } if ( typeof value === 'number' || typeof value === 'boolean' ) { return value } if ( typeof value === 'function' ) { return parseFunction ( value ) } if ( typeof value === 'object' ) { return parseObject ( value ) } if ( value === 'NaN' ) { return NaN } var jsonParsed = null try { jsonParsed = JSON . parse ( value ) } catch ( e ) { try { jsonParsed = JSON . parse ( value . trim ( ) . replace ( / (\\\\")|(\\") / gi , '"' ) . replace ( / (\\n|\\\\n) / gi , '' ) . replace ( / (^"|"$)|(^'|'$) / gi , '' ) ) } catch ( e ) { } } if ( jsonParsed && typeof jsonParsed === 'object' ) { return autoParse ( jsonParsed ) } value = stripTrimLower ( value ) if ( value === 'undefined' || value === '' ) { return undefined } if ( value === 'null' ) { return null } var num = Number ( value ) if ( typpy ( num , Number ) ) { return num } var boo = checkBoolean ( value ) if ( typpy ( boo , Boolean ) ) { return boo } return String ( orignalValue ) } 
function traceWebpackLoader ( file ) { var traceName = ( __webpack_require__ . p || '/' ) + '' + file + '.bundle.js' 
function ArangoStore ( options , readyCallback ) { options = options || { } ; if ( options . hash ) { var defaultSalt = "connect-arango" ; var defaultAlgorithm = "sha1" ; this . hash = { } ; this . hash . salt = options . hash . salt ? options . hash . salt : defaultSalt ; this . hash . algorithm = options . hash . algorithm ? options . hash . algorithm : defaultAlgorithm ; } Store . call ( this , options ) ; if ( ! options . db ) { throw new Error ( 'Required ArangoStore option `db` missing' ) ; } this . db_collection_name = options . collection || defaultOptions . collection ; if ( options . stringify || ( ! ( 'stringify' in options ) && ! ( 'serialize' in options ) && ! ( 'unserialize' in options ) ) ) { this . _serialize_session = JSON . stringify ; this . _unserialize_session = JSON . parse ; } else { this . _serialize_session = options . serialize || defaultSerializer ; this . _unserialize_session = options . unserialize || identity ; } var self = this ; var host = options . host || defaultOptions . host ; var port = options . port || defaultOptions . port ; if ( typeof options . db === 'object' ) { this . dbHelper = new DatabaseHelper ( options . db , self . db_collection_name ) ; } else { this . dbHelper = new DatabaseHelper ( { host : host , port : port , username : options . username , password : options . password } ) ; self . dbHelper . use ( options . db ) ; } self . dbHelper . ensureCollection ( self . db_collection_name , function ( err , db ) { if ( err ) { if ( readyCallback ) { readyCallback ( err ) ; } else { throw e ; } } else { db . index . createSkipListIndex ( self . db_collection_name , [ "expires" ] , false ) . then ( function ( res ) { if ( readyCallback ) { readyCallback ( ) ; } } , function ( err ) { debug ( "Unable to create skip-list" ) ; if ( readyCallback ) { readyCallback ( err ) ; } } ) . catch ( function ( e ) { throw e ; } ) ; } } ) ; this . db_clear_expires_time = 0 ; this . db_clear_expires_interval = options . clear_interval || defaultOptions . clear_interval ; } 
function findAllDependencies ( file , knownDependencies , sourceDirectories , knownFiles ) { if ( ! knownDependencies ) { knownDependencies = [ ] ; } if ( typeof knownFiles === "undefined" ) { knownFiles = [ ] ; } else if ( knownFiles . indexOf ( file ) > - 1 ) { return knownDependencies ; } if ( sourceDirectories ) { return findAllDependenciesHelp ( file , knownDependencies , sourceDirectories , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } else { return getBaseDir ( file ) . then ( getElmPackageSourceDirectories ) . then ( function ( newSourceDirs ) { return findAllDependenciesHelp ( file , knownDependencies , newSourceDirs , knownFiles ) . then ( function ( thing ) { return thing . knownDependencies ; } ) ; } ) ; } } 
function getElmPackageSourceDirectories ( baseDir , currentDir ) { if ( typeof currentDir === "undefined" ) { baseDir = path . resolve ( baseDir ) ; currentDir = baseDir ; } var elmPackagePath = path . join ( currentDir , 'elm.json' ) ; if ( fs . existsSync ( elmPackagePath ) ) { var sourceDirectories = getSourceDirectories ( elmPackagePath ) ; if ( _ . includes ( sourceDirectories , baseDir ) ) { return sourceDirectories ; } } if ( isRoot ( currentDir ) ) { return [ ] ; } return getElmPackageSourceDirectories ( baseDir , path . dirname ( currentDir ) ) ; } 
function readImports ( file ) { return new Promise ( function ( resolve , reject ) { 
function inlineStyle ( fileContent , filePath ) { return fileContent . replace ( / styleUrls\s*:\s*\[(.+)\] / g , ( _match , templateUrl ) => { let styleContent = '' const styleList = templateUrl . replace ( / '|\s / g , '' ) . split ( ',' ) styleList . forEach ( s => { const stylePath = path . join ( path . dirname ( filePath ) , s ) styleContent += loadResourceFile ( stylePath ) } ) return ` \[ \` ${ styleContent } \` \] ` } ) } 
function changeVersion ( ) { log . info ( 'Updating version number...' ) ; const packageJson = path . join ( __dirname , '../components/package.json' ) ; const currentVersion = fs . readFileSync ( packageJson , 'utf-8' ) . match ( / "version": "([0-9.]+)" / ) [ 1 ] ; let versionNumberValid = false ; let version ; function checkVersionNumber ( cur , next ) { 
function isElement ( node , tagNames ) { var name if ( ! ( tagNames === null || tagNames === undefined || typeof tagNames === 'string' || ( typeof tagNames === 'object' && tagNames . length !== 0 ) ) ) { throw new Error ( 'Expected `string` or `Array.<string>` for `tagNames`, not `' + tagNames + '`' ) } if ( ! node || typeof node !== 'object' || node . type !== 'element' || typeof node . tagName !== 'string' ) { return false } if ( tagNames === null || tagNames === undefined ) { return true } name = node . tagName if ( typeof tagNames === 'string' ) { return name === tagNames } return tagNames . indexOf ( name ) !== - 1 } 
function parse ( query ) { if ( query [ 0 ] == "?" ) query = query . slice ( 1 ) ; var pairs = query . split ( "&" ) , obj = { } ; for ( var i in pairs ) { var pair = pairs [ i ] . split ( "=" ) , key = decodeURIComponent ( pair [ 0 ] ) , value = pair [ 1 ] ? decodeURIComponent ( pair [ 1 ] ) : "" ; obj [ key ] = value ; } return obj ; } 
function stringify ( obj ) { var arr = [ ] ; for ( var x in obj ) { arr . push ( encodeURIComponent ( x ) + "=" + encodeURIComponent ( obj [ x ] ) ) ; } return arr . join ( "&" ) ; } 
function replaceLink ( target ) { var lang = QueryString . parse ( location . search ) . lang ; if ( lang ) { target = target || $ ( "body" ) ; target . find ( "a" ) . each ( function ( ) { var href = $ ( this ) . attr ( "href" ) , query = QueryString . parse ( href ) ; if ( href . indexOf ( "javascript:" ) !== 0 && href . indexOf ( "http" ) !== 0 && href . indexOf ( "#" ) !== 0 && ! query . lang ) { href = QueryString . setUrl ( href , { lang : lang } ) ; $ ( this ) . attr ( "href" , href ) ; } } ) } } 
function initialize ( middlewareOpts ) { const logger = middlewareOpts . logger . fork ( 'BindingsDocs' ) , ensureAuthenticated = middlewareOpts . ensureAuthenticated ; function servePythonDocFile ( rootDir , fileName , res , logger ) { const options = { root : rootDir , dotfiles : 'deny' , headers : { 'x-timestamp' : Date . now ( ) , 'x-sent' : true } } ; res . sendFile ( fileName , options , function ( err ) { if ( err ) { logger . error ( 'Failed to send ' + fileName , err ) ; res . status ( err . status ) . end ( ) ; } } ) ; } 
function murmurhash ( str ) { let l = str . length | 0 , h = l | 0 , i = 0 , k ; while ( l >= 4 ) { k = ( ( str . charCodeAt ( i ) & 0xff ) ) | ( ( str . charCodeAt ( ++ i ) & 0xff ) << 8 ) | ( ( str . charCodeAt ( ++ i ) & 0xff ) << 16 ) | ( ( str . charCodeAt ( ++ i ) & 0xff ) << 24 ) ; k = ( ( ( k & 0xffff ) * 0x5bd1e995 ) + ( ( ( ( k >>> 16 ) * 0x5bd1e995 ) & 0xffff ) << 16 ) ) ; k ^= k >>> 24 ; k = ( ( ( k & 0xffff ) * 0x5bd1e995 ) + ( ( ( ( k >>> 16 ) * 0x5bd1e995 ) & 0xffff ) << 16 ) ) ; h = ( ( ( h & 0xffff ) * 0x5bd1e995 ) + ( ( ( ( h >>> 16 ) * 0x5bd1e995 ) & 0xffff ) << 16 ) ) ^ k ; l -= 4 ; ++ i ; } switch ( l ) { case 3 : h ^= ( str . charCodeAt ( i + 2 ) & 0xff ) << 16 ; case 2 : h ^= ( str . charCodeAt ( i + 1 ) & 0xff ) << 8 ; case 1 : h ^= ( str . charCodeAt ( i ) & 0xff ) ; h = ( ( ( h & 0xffff ) * 0x5bd1e995 ) + ( ( ( ( h >>> 16 ) * 0x5bd1e995 ) & 0xffff ) << 16 ) ) ; } h ^= h >>> 13 ; h = ( ( ( h & 0xffff ) * 0x5bd1e995 ) + ( ( ( ( h >>> 16 ) * 0x5bd1e995 ) & 0xffff ) << 16 ) ) ; h ^= h >>> 15 ; return h >>> 0 ; } 
function _setObject ( obj ) { var args = arguments , o = obj , len = args . length , 
function uniqueSort ( arr , isSorted ) { if ( isSorted == null ) isSorted = false if ( ! isSorted ) arr . sort ( ) var out = [ ] , ix , item for ( ix = 0 ; ix < arr . length ; ix ++ ) { item = arr [ ix ] if ( ix > 0 && arr [ ix - 1 ] === arr [ ix ] ) continue out . push ( item ) } return out } 
function _d ( ) { for ( var ix = 0 ; ix < arguments . length ; ix ++ ) if ( arguments [ ix ] != null ) return arguments [ ix ] return null } 
function _e ( fn , msg ) { msg = _d ( msg , fn , '' ) fn = _d ( fn , 0 ) var pfx = "oj: " if ( fn ) pfx = "oj." + fn + ": " throw new Error ( pfx + msg ) } 
function _v ( fn , n , v , type ) { n = { 1 : 'first' , 2 : 'second' , 3 : 'third' , 4 : 'fourth' } [ n ] _a ( ! type || ( typeof v === type ) , fn , "" + type + " expected for " + n + " argument" ) } 
function _splitAndTrim ( str , seperator , limit ) { return str . split ( seperator , limit ) . map ( function ( v ) { return v . trim ( ) } ) } 
function _getInstanceOnElement ( el ) { if ( ( el != null ? el . oj : 0 ) != null ) return el . oj else return null } 
function _flattenCSSMap ( cssMap ) { var flatMap = { } , plugin , cssMap_ for ( plugin in cssMap ) { cssMap_ = cssMap [ plugin ] _flattenCSSMap_ ( cssMap_ , flatMap , [ '' ] , [ '' ] , plugin ) } return flatMap } 
function _flattenCSSMap_ ( cssMap , flatMapAcc , selectorsAcc , mediasAcc , plugin ) { 
function _cssFromPluginObject ( flatCSSMap , options ) { options = _d ( options , { } ) var mediaMap , plugin , minify = options . minify != null ? options . minify : 0 , tags = options . tags != null ? options . tags : 0 , 
function _compileAny ( any , options ) { 
function _compileTag ( ojml , options ) { 
function _attributesProcessedForOJ ( attr ) { var jqEvents = { bind : 1 , on : 1 , off : 1 , live : 1 , blur : 1 , change : 1 , click : 1 , dblclick : 1 , focus : 1 , focusin : 1 , focusout : 1 , hover : 1 , keydown : 1 , keypress : 1 , keyup : 1 , mousedown : 1 , mouseenter : 1 , mouseleave : 1 , mousemove : 1 , mouseout : 1 , mouseup : 1 , ready : 1 , resize : 1 , scroll : 1 , select : 1 , insert : 1 } , events , k , v 
function _attributesBindEventsToDOM ( events , el , inserts ) { var ek , ev , _results = [ ] for ( ek in events ) { ev = events [ ek ] _a ( oj . $ != null , "jquery is missing when binding a '" + ek + "' event" ) 
function ( k , v ) { var key , obj = k , value 
function ( ) { var json = { } , prop , ix = 0 for ( ; ix < this . properties . length ; ix ++ ) { prop = this . properties [ ix ] json [ prop ] = this [ prop ] } return json } 
function ( ) { _a ( oj . isDOM ( this . el ) , this . typeName , 'constructor did not set this.el' ) 
function ( ) { 
function ( ix , count , message ) { var ixNew = ix < 0 ? ix + count : ix if ( ! ( 0 <= ixNew && ixNew < count ) ) _e ( this . typeName , message + " is out of bounds (" + ix + " in [0," + ( count - 1 ) + "])" ) return ixNew } 
function ( ) { if ( ! this . isConstructed ) return 
function ( rx , listOJML ) { rx = this . _bound ( rx , this . rowCount , ".row: rx" ) if ( listOJML != null ) { _a ( listOJML . length === cellCount ( rx ) , this . typeName , "array expected for second argument with length (" + rx + ")" ) 
function ( rx , listOJML ) { if ( listOJML == null ) { listOJML = rx rx = - 1 } rx = this . _bound ( rx , this . rowCount + 1 , ".addRow: rx" ) _a ( oj . isArray ( listOJML ) , 'addRow' , 'expected array for row content' ) this . _addRowTR ( rx , function ( ) { oj . tr ( function ( ) { listOJML . forEach ( function ( cell ) { oj . td ( cell ) } ) } ) } ) } 
function ( rx , tr ) { 
function ( ix , count , message ) { var ixNew = ix < 0 ? ix + count : ix if ( ! ( 0 <= ixNew && ixNew < count ) ) { throw new Error ( "oj." + this . typeName + message + " is out of bounds (" + ix + " in [0," + ( count - 1 ) + "])" ) } return ixNew } 
function ( $el , args ) { 
function ( attributes ) { var attr = _clone ( attributes ) , events = _attributesProcessedForOJ ( attr ) , k , v 
function ( ix , ojml ) { ix = this . _bound ( ix , this . count , ".item: index" ) if ( ojml != null ) { if ( typeof ojml == 'object' && ojml . isListItem ) this . $item ( ix ) . ojReplaceWith ( ojml ) else this . $item ( ix ) . oj ( ojml ) this . itemsChanged ( ) } else return this . $item ( ix ) . ojValue ( ) } 
function ( model ) { var _t = this if ( oj . isOJType ( _t . each ) ) return new _t . each ( model ) return oj ( function ( ) { return _t . each ( model ) } ) } 
function ( ix , ojml ) { 
function _jqGetValue ( $el , args ) { var el = $el [ 0 ] , child = el . firstChild 
function _styleFromObject ( obj , options ) { options = _extend ( { inline : true , indent : '' } , options ) 
function _attributesFromObject ( obj ) { if ( ! oj . isPlainObject ( obj ) ) return obj 
function _cssFromMediaObject ( mediaMap , options ) { options = _d ( options , { } ) var indent , indentRule , media , rules , selector , selectorMap , space , styles , minify = options . minify != null ? options . minify : 0 , tags = options . tags != null ? options . tags : 0 , 
function _inherit ( Child , Parent ) { var Ctor , prop 
function ( k ) { 
function ( rx ) { if ( rx == null ) rx = - 1 rx = this . _bound ( rx , this . rowCount , ".removeRow: index" ) ; var out = this . row ( rx ) this . $tr ( rx ) . remove ( ) this . bodyChanged ( ) return out } 
function ( describe , fileBuffer ) { if ( describe && ! util . isArray ( describe ) && describe . m ) { 
function ( describe , fileInfo ) { if ( ! describe || ! util . isArray ( describe ) ) { return when . reject ( 'wrong describe payload given' ) ; } if ( ! fileInfo ) { return when . reject ( 'no fileInfo provided' ) ; } console . log ( 'resolving dependencies for ' , fileInfo . filename ) ; var that = this ; return pipeline ( [ function ( ) { 
function ( filename ) { if ( ! fs . existsSync ( filename ) ) { return false ; } if ( ! this . _moduleStorage ) { this . _moduleStorage = [ ] ; } var that = this ; var parser = new HalModuleParser ( ) ; return parser . parseFile ( filename ) . then ( function ( fileInfo ) { fileInfo . describe = that . _binaryToDescribe ( fileInfo . prefixInfo ) ; that . _moduleStorage . push ( fileInfo ) ; } , function ( err ) { console . error ( 'assimilateModule err: ' , err ) ; } ) ; } 
function ( modules ) { 
function ( deviceModules , binaryInfo ) { var safeDeviceModules = this . _repairDescribeErrors ( deviceModules ) ; var safeBinaryRequires = this . _binaryDepsToDescribe ( binaryInfo ) ; var safeBinaryRequires2 = this . _binaryDepsToDescribe ( binaryInfo , 2 ) ; var result = this . _walkChain ( safeDeviceModules , safeBinaryRequires ) ; this . _walkChain ( safeDeviceModules , safeBinaryRequires2 , result ) ; return result ; } 
function ( deviceModules , firmwareModule ) { var safeDeviceModules = this . _repairDescribeErrors ( deviceModules ) ; var safeModuleRequires = firmwareModule . toDescribe ( ) ; return this . _walkChain ( safeDeviceModules , safeModuleRequires ) ; } 
function ( describe ) { if ( ! Array . isArray ( describe . m ) ) { return when . reject ( 'no modules in describe message' ) ; } var modules = [ ] ; var userModule = null ; for ( var i = 0 ; i < describe . m . length ; i ++ ) { var module = new FirmwareModule ( describe . m [ i ] ) ; 
function ( describe ) { if ( ! Array . isArray ( describe . m ) ) { return when . reject ( 'no modules in describe message' ) ; } var allDeps = [ ] ; var modules = describe . m ; for ( var i = 0 ; i < modules . length ; i ++ ) { var checkModule = modules [ i ] ; 
function ( modules , needs , arr ) { arr = arr || [ ] ; 
function ( describeInfo ) { var arr = describeInfo ; 
function ( moduleFunction ) { var result ; 
function ( binaryInfo , dep ) { var result = { } ; dep = dep || 1 ; var depString = '' ; if ( dep > 1 ) { depString = '' + dep ; } if ( ! binaryInfo ) { return result ; } var keys = Object . keys ( binaryInfo ) ; 
function ( left , right ) { if ( ( left === null ) && ( right === null ) ) { return true ; } else if ( ( left === null ) || ( right === null ) ) { return false ; } if ( ! Buffer . isBuffer ( left ) ) { left = new Buffer ( left ) ; } if ( ! Buffer . isBuffer ( right ) ) { right = new Buffer ( right ) ; } var same = ( left . length === right . length ) , i = 0 , max = left . length ; while ( i < max ) { same &= ( left [ i ] == right [ i ] ) ; 
function ( filename , callback ) { var fileInfo = { filename : filename } ; var that = this ; var allDone = pipeline ( [ function ( ) { return that . _loadFile ( filename ) ; } , function ( fileBuffer ) { fileInfo . fileBuffer = fileBuffer ; return that . parseBuffer ( fileInfo ) ; } ] ) ; if ( callback ) { when ( allDone ) . then ( function ( info ) { callback ( info , null ) ; } , function ( err ) { callback ( null , err ) ; } ) ; } return allDone ; } 
function ( fileInfo , callback ) { if ( ! Buffer . isBuffer ( fileInfo . fileBuffer ) ) { return when . reject ( 'fileBuffer was invalid' ) ; } var that = this ; var allDone = pipeline ( [ function ( ) { return that . _validateCRC ( fileInfo . fileBuffer ) ; } , function ( crcInfo ) { fileInfo . crc = crcInfo ; return that . _readPrefix ( fileInfo . fileBuffer ) ; } , function ( prefixInfo ) { fileInfo . prefixInfo = prefixInfo ; return that . _readSuffix ( fileInfo . fileBuffer ) ; } , function ( suffixInfo ) { fileInfo . suffixInfo = suffixInfo ; return when . resolve ( ) ; } , function ( ) { return fileInfo ; } ] ) ; if ( callback ) { when ( allDone ) . then ( function ( info ) { callback ( info , null ) ; } , function ( err ) { callback ( null , err ) ; } ) ; } return allDone ; } 
function ( filename ) { if ( ! fs . existsSync ( filename ) ) { return when . reject ( filename + ' doesn\'t exist' ) ; } var fileBuffer = fs . readFileSync ( filename ) ; if ( ! fileBuffer || ( fileBuffer . length === 0 ) ) { return when . reject ( filename + ' was empty!' ) ; } return when . resolve ( fileBuffer ) ; } 
function ( fileBuffer ) { if ( ! fileBuffer || ( fileBuffer . length === 0 ) ) { 
function ( fileBuffer ) { 
function ( fileBuffer ) { var prefixOffset = this . _divineModulePrefixOffset ( fileBuffer ) ; var r = new buffers . BufferReader ( fileBuffer ) ; 
function ( fileBuffer ) { 
async function main ( ) { 
function Shortline ( options ) { const self = this ; self . _input = ( options && options . input ) || process . stdin ; self . _output = ( options && options . output ) || process . stderr ; self . inputError = null ; self . _input . on ( 'end' , ( ) => { self . inputError = new EOFError ( EOF_MESSAGE ) ; } ) ; 
function findElements ( node , name ) { return name in node && Array . isArray ( node [ name ] ) ? node [ name ] : [ ] ; } 
async function main ( ) { 
function TravisStatusHttp ( endpoint , options ) { if ( endpoint && typeof endpoint !== 'string' ) { throw new TypeError ( 'endpoint must be a string' ) ; } endpoint = endpoint && trimSlash ( endpoint ) ; if ( options && typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } options = Object . assign ( { gzip : true } , options ) ; options . headers = Object . assign ( { } , options . headers ) ; 
function git ( ... args ) { return new Promise ( ( resolve , reject ) => { const child = execFile ( 'git' , args , ( err , stdout , stderr ) => { if ( err ) { reject ( err ) ; } else { 
function travisStatusCmd ( args , options , callback ) { if ( ! callback && typeof options === 'function' ) { callback = options ; options = null ; } if ( ! callback ) { return new Promise ( ( resolve , reject ) => { travisStatusCmd ( args , options , ( err , result ) => { if ( err ) { reject ( err ) ; } else { resolve ( result ) ; } } ) ; } ) ; } if ( typeof callback !== 'function' ) { throw new TypeError ( 'callback must be a function' ) ; } try { if ( args === undefined || args === null || args . length === 0 ) { 
function SlugDetectionError ( message ) { if ( ! ( this instanceof SlugDetectionError ) ) { return new SlugDetectionError ( message ) ; } Error . captureStackTrace ( this , SlugDetectionError ) ; 
function createScopedCss ( html , scope , filepath , cssVariables ) { scope = typeof scope === 'string' ? { ns : scope , vars : new Map ( ) } : scope ; const style = html . match ( styleMatcher ) ; if ( ! style ) { return [ { } , scope . vars , '' ] ; } const cssom = css . parse ( style [ 1 ] , { source : filepath } ) ; const vars = new Map ( scope . vars . entries ( ) ) ; getVariables ( cssom ) . forEach ( ( value , key ) => vars . set ( key , value ) ) ; if ( cssVariables ) { resolveScopeVariables ( cssom , vars ) ; } const [ classes , transformMap ] = rewriteSelectors ( ` ${ decamelize ( scope . ns , '-' ) } ` , cssom ) ; return [ classes , vars , css . stringify ( cssom ) , transformMap ] ; } 
function createHash ( input ) { let hash = 0 ; if ( input . length === 0 ) { return hash ; } for ( let i = 0 ; i < input . length ; i ++ ) { const char = input . charCodeAt ( i ) ; hash = ( ( hash << 5 ) - hash ) + char ; 
function combineCss ( templates , scopedCss ) { if ( ! Array . isArray ( scopedCss ) ) { scopedCss = [ scopedCss ] ; } return [ ... Object . keys ( templates ) . map ( name => templates [ name ] . css ) , ... scopedCss ] . join ( '\n' ) . trim ( ) ; } 
function InvalidSlugError ( message ) { if ( ! ( this instanceof InvalidSlugError ) ) { return new InvalidSlugError ( message ) ; } Error . captureStackTrace ( this , InvalidSlugError ) ; 
function checkBuildCommit ( build , localCommit ) { const buildCommit = build . commit ; let message = ` ${ buildCommit . sha } ${ localCommit . sha } ` ; if ( localCommit . name ) { message += ` ${ localCommit . name } ` ; } 
function travisStatus ( options , callback ) { if ( ! callback && typeof options === 'function' ) { callback = options ; options = null ; } if ( callback && typeof callback !== 'function' ) { throw new TypeError ( 'callback must be a function' ) ; } let agent , gitChecker , travisChecker ; try { if ( options && typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } options = options || { } ; if ( options . repo ) { GitStatusChecker . checkSlugFormat ( options . repo ) ; } if ( options . storeRepo ) { GitStatusChecker . checkSlugFormat ( options . storeRepo ) ; } 
function trimSlash ( string ) { if ( typeof string !== 'string' ) { return string ; } if ( string . length > 0 && string . charAt ( string . length - 1 ) === '/' ) { return string . slice ( 0 , string . length - 1 ) ; } return string ; } 
function parseOptions ( opts ) { return removeEmpty ( { plugins : convertFn . call ( this , opts . plugins ) , locals : convertFn . call ( this , opts . locals ) , filename : convertFn . call ( this , opts . filename ) , parserOptions : convertFn . call ( this , opts . parserOptions ) , generatorOptions : convertFn . call ( this , opts . generatorOptions ) , runtime : convertFn . call ( this , opts . runtime ) , parser : convertFnSpecial . call ( this , opts . parser ) , multi : convertFn . call ( this , opts . multi ) } ) } 
function serializeVerbatim ( obj ) { let i = 0 const fns = [ ] let res = JSON . stringify ( obj , ( k , v ) => { if ( typeof v === 'function' ) { fns . push ( v . toString ( ) ) return ` ${ i ++ } ` } else { return v } } ) res = res . replace ( / "__REPLACE(\d{1})" / g , ( m , v ) => { return fns [ v ] } ) return res } 
function renderPages ( filepaths , dest , { templates , vars , statics , disableValidation , cssVariables , host } ) { console . log ( ` \n ` ) ; return Promise . all ( filepaths . map ( filepath => { return sander . readFile ( filepath ) . then ( content => renderPage ( content , filepath , { templates , vars , dest , cssVariables } ) ) . then ( ( [ html , destinationPath , cssParts ] ) => sander . writeFile ( destinationPath , html ) . then ( ( ) => [ destinationPath , cssParts ] ) ) . then ( ( [ destinationPath , cssParts ] ) => { console . log ( ` ${ chalk . bold . green ( figures . tick ) } ${ filepath } ${ destinationPath } ` ) ; return [ destinationPath , cssParts ] ; } ) ; } ) ) . then ( pageResults => disableValidation || validatePages ( host , dest , pageResults . map ( result => result [ 0 ] ) , statics ) . then ( ( ) => pageResults . map ( result => result [ 1 ] ) ) ) ; } 
function TravisStatusChecker ( options ) { if ( options && typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } options = options || { } ; const apiEndpoint = options . apiEndpoint && trimSlash ( options . apiEndpoint ) ; this . _travis = new Travis ( { pro : apiEndpoint === constants . PRO_URI , version : '2.0.0' } ) ; this . _travis . agent = new TravisStatusHttp ( apiEndpoint , options . requestOpts ) ; if ( options . token ) { this . _travis . agent . setAccessToken ( options . token ) ; } } 
function queryWithWait ( query , valueIsPending , options ) { const maxWaitMs = options && options . wait ? Number ( options . wait ) : 0 ; if ( Number . isNaN ( maxWaitMs ) ) { return Promise . reject ( new TypeError ( 'wait must be a number' ) ) ; } if ( maxWaitMs < 0 ) { return Promise . reject ( new RangeError ( 'wait must be non-negative' ) ) ; } const startMs = Date . now ( ) ; 
function ( input ) { var result = / @charset\s+['|"](\w*)["|']; / . exec ( input ) , charset = 'UTF-8' ; if ( result && result [ 1 ] ) { charset = result [ 1 ] ; } 
function ( text ) { text = escape ( text . toString ( ) ) . replace ( / \+ / g , "%2B" ) ; var matches = text . match ( / (%([0-9A-F]{2})) / gi ) ; if ( matches ) { for ( var matchid = 0 ; matchid < matches . length ; matchid ++ ) { var code = matches [ matchid ] . substring ( 1 , 3 ) ; if ( parseInt ( code , 16 ) >= 128 ) { text = text . replace ( matches [ matchid ] , '%u00' + code ) ; } } } text = text . replace ( '%25' , '%u0025' ) ; return text ; } 
function ( content ) { var reg = / @import\s*(url)?\s*[\('"]+([^'"]+)\.css(\?[^\s]*)?\s*['"\)]+\s*[^;]*; / ig ; var result = reg . exec ( content ) ; if ( result && result [ 2 ] ) { return { match : result [ 0 ] , filePath : result [ 2 ] + '.css' } ; } return null ; } 
function ( content , filePath ) { 'use strict' ; var self = this ; var regImport = / @import\s*(url)?\(?['"]([^'"%]+)\.css['"]\)?[^;]*; / ig , regImageOrFont = / (url)?\(['"]?([^:\)]+\.(png|jpg|gif|jpeg|ttf|eot|woff|svg))([^\)]*)['"]?\) / ig , importResult , picAndFontResult ; var importFilePath = path . dirname ( path . resolve ( self . config . sourceDir , filePath ) ) ; // import importResult = regImport . exec ( content ) ; if ( typeof importResult !== 'undefined' && importResult && importResult [ 2 ] ) { var importAbsoluteUrl = path . resolve ( importFilePath , importResult [ 2 ] ) ; // %import, //  var regimportReplace = new RegExp ( importResult [ 2 ] , 'g' ) ; content = content . replace ( regimportReplace , "%" + path . relative ( self . config . sourceDir , importAbsoluteUrl ) ) ; return self . modifySubImportsPath ( content , filePath ) ; } // font picAndFontResult = regImageOrFont . exec ( content ) ; if ( typeof picAndFontResult !== 'undefined' && picAndFontResult && picAndFontResult [ 2 ] && ! / ^\/\/[^\/]+ / . test ( picAndFontResult [ 2 ] ) ) { var regpicReplace = new RegExp ( picAndFontResult [ 2 ] , 'g' ) ; var picAbsolutePath = path . resolve ( importFilePath , picAndFontResult [ 2 ] ) ; //win var isWin = ( process . platform === 'win32' ) ; var _path = path . relative ( self . config . sourceDir , picAbsolutePath ) ; if ( isWin ) { _path = path . relative ( self . config . sourceDir , picAbsolutePath ) . split ( path . sep ) . join ( "\/" ) ; } // import content = content . replace ( regpicReplace , ":" + _path ) ; return self . modifySubImportsPath ( content , filePath ) ; } return content ; } 
function GitStatusChecker ( options ) { if ( options && typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } options = Object . assign ( { in : process . stdin , out : process . stdout , err : process . stderr } , options ) ; if ( ! options . in || typeof options . in . read !== 'function' ) { throw new TypeError ( 'options.in must be a stream.Readable' ) ; } if ( ! options . out || typeof options . out . write !== 'function' ) { throw new TypeError ( 'options.out must be a stream.Writable' ) ; } if ( ! options . err || typeof options . err . write !== 'function' ) { throw new TypeError ( 'options.err must be a stream.Writable' ) ; } this . _options = options ; this . _chalk = new Chalk ( { enabled : Boolean ( options . interactive !== undefined ? options . interactive : options . out . isTTY ) } ) ; } 
function gitUrlPath ( gitUrl ) { 
function ( ) { var appEnv = this . app . env ; if ( process . env . DEPLOY_TARGET ) { appEnv = process . env . DEPLOY_TARGET ; } var publicFiles = new Funnel ( this . app . trees . public ) ; this . _requireBuildPackages ( ) ; fs . stat ( path . join ( this . project . root , 'public' , 'robots.txt' ) , function ( err , stats ) { if ( stats && stats . isFile ( ) ) { console . log ( chalk . yellow ( 'There is a robots.txt in /public and ENV specific robots.txt are ignored!' ) ) ; } } ) ; publicFiles = stew . rename ( publicFiles , 'robots-' + appEnv + '.txt' , 'robots.txt' ) ; return new Funnel ( publicFiles , { srcDir : '/' , destDir : '/' } ) ; } 
function BalanceSheet ( options ) { * ### BalanceSheet.options * * Reference to current configuration * */ this . options = options || { } ; * ### BalanceSheet.init * * Configures the BalanceSheet instance * * Takes the configuration as an input parameter or * recycles the settings in `this.options`. * * The configuration object is of the type * * var options = { * returnAt: 'first', * triggers: [ myFunc, * myFunc2 * ], * } * * @param {object} options Optional. Configuration object * */ BalanceSheet . prototype . init = function ( options ) { this . options = options || this . options ; if ( this . options . returnAt === BalanceSheet . first || this . options . returnAt === BalanceSheet . last ) { this . returnAt = this . options . returnAt ; } this . resetTriggers ( ) ; } ; 
function Group ( ) { this . elements = [ ] ; this . matched = [ ] ; this . leftOver = [ ] ; this . pointer = 0 ; this . matches = { } ; this . matches . total = 0 ; this . matches . requested = 0 ; this . matches . done = false ; this . rowLimit = 3 ; this . noSelf = true ; this . pool = [ ] ; this . shuffle = true ; this . stretch = true ; } 
function Group ( options ) { this . name = null ; this . elements = [ ] ; this . pool = [ ] ; this . matched = [ ] ; this . leftOver = [ ] ; this . pointer = 0 ; this . matches = { total : 0 , requested : 0 , done : false } ; this . rowLimit = 1 ; this . noSelf = true ; this . shuffle = true ; this . stretch = true ; 
function simulateMatch ( N ) { for ( var i = 0 ; i < N ; i ++ ) { var rm = new RMatcher ( ) , elements = getElements ( ) , pools = getPools ( ) ; 
function SocketDirect ( node , options ) { options = options || { } ; * ### SocketDirect.node * * Reference to the node object. */ this . node = node ; this . socket = options . socket ; this . connected = false ; } 
function myGame ( ) { this . solo_mode = false ; this . auto_wait = false ; this . auto_step = false ; this . observer = false ; this . minPlayers = 1 ; this . maxPlayers = 1000 ; } 
function GameSession ( node ) { SessionManager . call ( this ) ; this . node = node ; 
function compileIndex ( ) { fs . readFile ( path . join ( __dirname , 'templates' , 'index.hogan' ) , function ( err , data ) { if ( err ) throw err ; 
function sortMentions ( mentions ) { return mentions . slice ( ) . sort ( ( a , b ) => b . length - a . length ) ; } 
function findEmoji ( names , match ) { const compare = match . toLowerCase ( ) ; for ( let i = 0 ; i < names . length ; i += 1 ) { const name = names [ i ] . toLowerCase ( ) ; if ( name === compare ) { return names [ i ] ; } } return null ; } 
function _request ( path , method , headers , body , withCredentials , callback ) { const xhr = new XMLHttpRequest ( { } ) ; 
function RpcMessage ( opts ) { assert . object ( opts , 'options' ) ; assert . bool ( opts . incoming , 'options.incoming' ) ; assert . optionalNumber ( opts . type , 'options.type' ) ; assert . optionalNumber ( opts . xid , 'options.xid' ) ; stream . Transform . call ( this , opts ) ; this . type = opts . type ; this . xid = opts . xid ; this . incoming = opts . incoming ; this . _rpc_wrote_head = false ; this . _rpc_message = true ; 
function parseAuth ( xdr ) { assert . object ( xdr , 'xdr' ) ; var msg = { } ; var type = xdr . readInt ( ) ; var len = xdr . readInt ( ) ; switch ( type ) { case 0 : 
function PortmapGetPortCall ( opts ) { RpcCall . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 } ; this . _rpc_portmap_get_port_call = true ; 
function RpcClient ( opts ) { assert . object ( opts , 'options' ) ; assert . object ( opts . log , 'options.log' ) ; assert . number ( opts . program , 'options.program' ) ; assert . number ( opts . version , 'options.version' ) ; assert . string ( opts . url , 'options.url' ) ; EventEmitter . call ( this , opts ) ; var self = this ; this . conn = null ; this . log = opts . log . child ( { component : 'RpcClient' , serializers : require ( './bunyan' ) . serializers } ) ; this . messages = { } ; this . program = opts . program ; this . url = mod_url . parse ( opts . url ) ; this . version = opts . version ; var ID = 0 ; this . _next_xid = function ( ) { if ( ++ ID === ( Math . pow ( 2 , 32 ) - 1 ) ) ID = 0 ; return ( ID ) ; } ; this . _rpc_client = true ; 
function RpcCall ( opts ) { assert . object ( opts , 'options' ) ; RpcMessage . call ( this , opts ) ; this . rpcvers = opts . rpcvers || 2 ; this . prog = opts . prog ; this . vers = opts . vers ; this . proc = opts . proc ; this . auth = opts . auth || { } ; this . verifier = opts . verifier ; this . type = 0 ; this . _buffer = null ; this . _rpc_call = true ; 
function PortmapSetCall ( opts ) { RpcCall . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 , port : 0 } ; this . _rpc_portmap_set_call = true ; 
function RpcError ( cause , msg ) { var off = 0 ; if ( cause instanceof Error ) off = 1 ; var args = Array . prototype . slice . call ( arguments , off ) ; args . unshift ( { cause : off ? cause : undefined , ctor : RpcError } ) ; WError . apply ( this , args ) ; this . type = 1 ; 
function PortmapClient ( opts ) { assert . object ( opts , 'options' ) ; if ( opts . log ) { var l = opts . log ; delete opts . log ; } var _opts = clone ( opts ) ; _opts . log = opts . log = l ; _opts . name = 'portmap' ; _opts . program = 100000 ; _opts . version = 2 ; RpcClient . call ( this , _opts ) ; } 
function ifError ( n ) { function _ifError ( err ) { if ( err ) { err . _rpc_next = n ; throw err ; } } return ( _ifError ) ; } 
function RpcServer ( opts ) { assert . object ( opts , 'options' ) ; assert . object ( opts . log , 'options.log' ) ; assert . number ( opts . program , 'options.program' ) ; var v = opts . version ; if ( typeof ( v ) === 'number' ) v = [ v ] ; assert . arrayOfNumber ( v , 'options.version' ) ; net . Server . call ( this , opts ) ; this . log = opts . log . child ( { component : 'RpcServer' } , true ) ; this . name = opts . name || 'RpcServer' ; this . program = opts . program ; this . rpc_table = { } ; this . saved_handlers = [ ] ; this . version = v . slice ( ) ; this . on ( 'connection' , onConnection . bind ( this ) ) ; } 
function RpcParser ( opts ) { assert . optionalObject ( opts , 'options' ) ; stream . Writable . call ( this , opts ) ; this . _buffer = null ; this . rpc_table = { } ; 
function RpcReply ( opts ) { RpcMessage . call ( this , opts ) ; this . _buffer = null ; this . rpc_reply_header_sent = false ; this . type = 1 ; } 
function PortmapUnsetCall ( opts ) { RpcCall . call ( this , opts ) ; this . mapping = { prog : 0 , vers : 0 , prot : 0 , port : 0 } ; this . _rpc_portmap_unset_call = true ; 
function PortmapServer ( opts ) { assert . object ( opts , 'options' ) ; if ( opts . log ) { var l = opts . log ; delete opts . log ; } var _opts = clone ( opts ) ; _opts . log = opts . log = l ; _opts . name = 'portmap' ; _opts . program = 100000 ; _opts . version = 2 ; RpcServer . call ( this , _opts ) ; } 
function XDR ( buf ) { if ( buf ) assert . ok ( Buffer . isBuffer ( buf ) , 'buffer is required' ) ; this . xdr_buffer = buf || null ; this . xdr_offset = 0 ; } 
function notify ( opts ) { const isNpm = require ( 'is-npm' ) ; if ( ! process . stdout . isTTY || isNpm ) { return ; } const boxen = require ( 'boxen' ) ; opts = opts || { } ; opts . defer = typeof opts . defer === 'boolean' ? opts . defer : false ; opts . message = opts . message || '' ; opts . boxenOpts = opts . boxenOpts || { padding : 1 , margin : 1 , align : 'center' , borderColor : 'yellow' , borderStyle : 'round' , } ; const message = '\n' + boxen ( opts . message , opts . boxenOpts ) ; if ( opts . defer === false ) { console . error ( message ) ; } else { process . on ( 'exit' , function ( ) { console . error ( message ) ; } ) ; process . on ( 'SIGINT' , function ( ) { console . error ( '\n' + message ) ; } ) ; } } 
function ( cb ) { var templatesDir = self . data . _templatesDir ; var templatesPath = path . join ( self . src , "extracted" , templatesDir ) ; fs . stat ( templatesPath , function ( err , stats ) { if ( err ) { if ( err . code === "ENOENT" ) { return void cb ( new Error ( "Templates path '" + templatesPath + "' directory not found" ) ) ; } return void cb ( err ) ; } if ( ! stats . isDirectory ( ) ) { return void cb ( new Error ( "Templates path '" + templatesPath + "' exists, but is not a directory" ) ) ; } cb ( null , templatesPath ) ; } ) ; } 
function ( cb ) { fs . stat ( self . dest , function ( err ) { if ( err ) { 
function npmInstallPackage ( deps , opts , cb ) { if ( ! cb ) { cb = opts opts = { } } deps = Array . isArray ( deps ) ? deps : [ deps ] opts = opts || opts cb = cb || noop var args = [ ] if ( opts . save ) args . push ( '-S' ) if ( opts . saveDev ) args . push ( '-D' ) if ( opts . global ) args . push ( '-g' ) if ( opts . cache ) args . push ( '--cache-min Infinity' ) if ( opts . silent === false ) { deps . forEach ( function ( dep ) { process . stdout . write ( 'pkg: ' + dep + '\n' ) } ) } var cliArgs = [ 'npm i' ] . concat ( args , deps ) . join ( ' ' ) exec ( cliArgs , function ( err , name ) { if ( err ) return cb ( err ) cb ( ) } ) } 
function fiberize ( fn ) { return function ( done ) { var self = this ; Fiber ( function ( ) { try { if ( fn . length == 1 ) { fn . call ( self , done ) ; } else { fn . call ( self ) ; done ( ) ; } } catch ( e ) { process . nextTick ( function ( ) { throw ( e ) ; } ) ; } } ) . run ( ) ; } ; } 
function ( regex , type , types , selector ) { var matches = selector . match ( regex ) ; if ( matches ) { for ( var i = 0 ; i < matches . length ; i ++ ) { types [ type ] ++ ; 
function ( selector ) { var commaIndex = selector . indexOf ( ',' ) ; if ( commaIndex !== - 1 ) { selector = selector . substring ( 0 , commaIndex ) ; } var types = { a : 0 , b : 0 , c : 0 } ; 
function ( value ) { var flagUndefined = function flagUndefined ( key , value ) { return value === undefined ? "/* void(undefined) */" : value ; } ; return JSON . stringify ( value , flagUndefined , " " ) . replace ( / "\/\* void\(undefined\) \*\/" / g , "undefined" ) ; } 
function ( collectionName , indexName , columns , unique , callback ) { var options = { indexName : indexName , columns : columns , unique : unique } ; return this . _run ( 'createIndex' , collectionName , options ) . nodeify ( callback ) ; } 
function ( name , callback ) { return this . _run ( 'insert' , this . internals . migrationTable , { name : name , run_on : new Date ( ) } ) . nodeify ( callback ) ; } 
function ( name , callback ) { return this . _run ( 'insert' , this . internals . seedTable , { name : name , run_on : new Date ( ) } ) . nodeify ( callback ) ; } 
function ( command , collection , options , callback ) { var args = this . _makeParamArgs ( arguments ) , sort = null , callback = args [ 2 ] ; log . sql . apply ( null , arguments ) ; if ( options && typeof ( options ) === 'object' ) { if ( options . sort ) sort = options . sort ; } if ( this . internals . dryRun ) { return Promise . resolve ( ) . nodeify ( callback ) ; } return new Promise ( function ( resolve , reject ) { var prCB = function ( err , data ) { return ( err ? reject ( err ) : resolve ( data ) ) ; } ; 
function ( err , data ) { if ( err ) { prCB ( err ) ; } prCB ( null , data ) ; db . close ( ) ; } 
function parseParameters ( options ) { var opt = { maximumAge : 0 , enableHighAccuracy : true , timeout : Infinity , interval : 6000 , fastInterval : 1000 , priority : PRIORITY_HIGH_ACCURACY } ; if ( options ) { if ( options . maximumAge !== undefined && ! isNaN ( options . maximumAge ) && options . maximumAge > 0 ) { opt . maximumAge = options . maximumAge ; } if ( options . enableHighAccuracy !== undefined ) { opt . enableHighAccuracy = options . enableHighAccuracy ; } if ( options . timeout !== undefined && ! isNaN ( options . timeout ) ) { if ( options . timeout < 0 ) { opt . timeout = 0 ; } else { opt . timeout = options . timeout ; } } if ( options . interval !== undefined && ! isNaN ( options . interval ) && options . interval > 0 ) { opt . interval = options . interval ; } if ( options . fastInterval !== undefined && ! isNaN ( options . fastInterval ) && options . fastInterval > 0 ) { opt . fastInterval = options . fastInterval ; } if ( options . priority !== undefined && ! isNaN ( options . priority ) && options . priority >= PRIORITY_NO_POWER && options . priority <= PRIORITY_HIGH_ACCURACY ) { if ( options . priority === PRIORITY_NO_POWER ) { opt . priority = PRIORITY_NO_POWER ; } if ( options . priority === PRIORITY_LOW_POWER ) { opt . priority = PRIORITY_LOW_POWER ; } if ( options . priority === PRIORITY_BALANCED_POWER_ACCURACY ) { opt . priority = PRIORITY_BALANCED_POWER_ACCURACY ; } if ( options . priority === PRIORITY_HIGH_ACCURACY ) { opt . priority = PRIORITY_HIGH_ACCURACY ; } } } return opt ; } 
function noProp ( props , propNameOrFunction ) { if ( ! props ) { throw new Error ( 'Headful: You must pass all declared props when you use headful.props.x() calls.' ) ; } const propName = typeof propNameOrFunction === 'function' ? propNameOrFunction . name : propNameOrFunction ; return ! props . hasOwnProperty ( propName ) ; } 
function GifCli ( path , callback ) { var frames = [ ] ; OneByOne ( [ Tmp . dir , function ( next , tmpDir ) { var str = Fs . createReadStream ( path ) , isFinished = false , complete = [ ] , i = 0 ; str . on ( "end" , function ( ) { isFinished = true ; } ) ; str . pipe ( GifExplode ( function ( frame ) { Tmp . file ( { postfix : ".gif" , } , function ( err , cImg ) { ( function ( i , cImg ) { if ( err ) { return next ( err ) ; } var wStr = Fs . createWriteStream ( cImg ) ; frame . pipe ( wStr ) ; complete [ i ] = false ; wStr . on ( "close" , function ( ) { 
function ( test , message , optionalParams ) { return invoke ( 'CONSOLE' , { type : 'assert' , test : test , message : message , optionalParams : optionalParams || [ ] } ) ; } 
function operationDataBase ( webview , db ) { console . log ( 'open then' ) ; db . executeSql ( 'SELECT 1 FROM Version LIMIT 1' ) . then ( function ( result ) { console . log ( 'executeSql then' ) ; console . log ( result ) ; function queryEmployees ( tx ) { console . log ( "Executing employee query" ) ; tx . executeSql ( 'SELECT a.name, b.name as deptName FROM Employees a, Departments b WHERE a.department = b.department_id' ) . then ( ( [ tx , results ] ) => { var payload = { } payload . result = [ ] payload . type = 'OPERATION_DATABASEE_DONE_QUERY_DB' ; var len = results . rows . length ; for ( let i = 0 ; i < len ; i ++ ) { let row = results . rows . item ( i ) ; payload . result . push ( row ) } webview . postMessage ( JSON . stringify ( payload ) ) ; } ) . catch ( ( error ) => { console . log ( error ) ; } ) ; } db . transaction ( queryEmployees ) . then ( ( ) => { console . log ( 'query done.' ) } ) ; } ) . catch ( function ( err ) { console . log ( 'executeSql catch' ) ; console . log ( err ) ; db . transaction ( function ( tx ) { tx . executeSql ( 'DROP TABLE IF EXISTS Employees;' ) ; tx . executeSql ( 'DROP TABLE IF EXISTS Offices;' ) ; tx . executeSql ( 'DROP TABLE IF EXISTS Departments;' ) ; tx . executeSql ( 'CREATE TABLE IF NOT EXISTS Version( ' + 'version_id INTEGER PRIMARY KEY NOT NULL); ' ) . catch ( ( error ) => { console . log ( error ) ; } ) ; tx . executeSql ( 'CREATE TABLE IF NOT EXISTS Departments( ' + 'department_id INTEGER PRIMARY KEY NOT NULL, ' + 'name VARCHAR(30) ); ' ) . catch ( ( error ) => { console . log ( error ) } ) ; tx . executeSql ( 'CREATE TABLE IF NOT EXISTS Offices( ' + 'office_id INTEGER PRIMARY KEY NOT NULL, ' + 'name VARCHAR(20), ' + 'longtitude FLOAT, ' + 'latitude FLOAT ) ; ' ) . catch ( ( error ) => { console . log ( error ) } ) ; tx . executeSql ( 'CREATE TABLE IF NOT EXISTS Employees( ' + 'employe_id INTEGER PRIMARY KEY NOT NULL, ' + 'name VARCHAR(55), ' + 'office INTEGER, ' + 'department INTEGER, ' + 'FOREIGN KEY ( office ) REFERENCES Offices ( office_id ) ' + 'FOREIGN KEY ( department ) REFERENCES Departments ( department_id ));' ) . catch ( ( error ) => { console . log ( error ) } ) ; tx . executeSql ( 'INSERT INTO Departments (name) VALUES ("Client Services");' ) ; tx . executeSql ( 'INSERT INTO Departments (name) VALUES ("Investor Services");' ) ; tx . executeSql ( 'INSERT INTO Departments (name) VALUES ("Shipping");' ) ; tx . executeSql ( 'INSERT INTO Departments (name) VALUES ("Direct Sales");' ) ; tx . executeSql ( 'INSERT INTO Offices (name, longtitude, latitude) VALUES ("Denver", 59.8, 34.1);' ) ; tx . executeSql ( 'INSERT INTO Offices (name, longtitude, latitude) VALUES ("Warsaw", 15.7, 54.1);' ) ; tx . executeSql ( 'INSERT INTO Offices (name, longtitude, latitude) VALUES ("Berlin", 35.3, 12.1);' ) ; tx . executeSql ( 'INSERT INTO Offices (name, longtitude, latitude) VALUES ("Paris", 10.7, 14.1);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Sylvester Stallone", 2, 4);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Elvis Presley", 2, 4);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Leslie Nelson", 3, 4);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Fidel Castro", 3, 3);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Bill Clinton", 1, 3);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Margaret Thatcher", 1, 3);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Donald Trump", 1, 3);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Dr DRE", 2, 2);' ) ; tx . executeSql ( 'INSERT INTO Employees (name, office, department) VALUES ("Samantha Fox", 2, 1);' ) ; console . log ( "all executed SQL done" ) ; webview . postMessage ( JSON . stringify ( { type : "OPERATION_DATABASEE_DONE_CREATE_TABLE_AND_INSERT_DATA" , result : 'init table done.' } ) ) ; } ) } ) } 
function delegate ( method , _args ) { var callPosition = metalogger . callposition ( ) , file , line ; if ( ! metalogger . shouldLog ( method , _level ) ) { return ; } var args = Array . prototype . slice . call ( _args ) ; var message = [ ] ; if ( args . length === 1 ) { message . push ( util . inspect ( args [ 0 ] , { showHidden : true , depth : null } ) ) ; } if ( args . length === 2 ) { message . push ( args . shift ( ) ) ; message . push ( util . inspect ( args [ 0 ] , { showHidden : true , depth : null } ) ) ; } if ( args . length > 2 ) { message . push ( args . shift ( ) ) ; message . push ( util . format . apply ( null , args ) ) ; } try { file = callPosition . split ( ':' ) [ 0 ] . replace ( ' [' , '' ) ; line = callPosition . split ( ':' ) [ 1 ] . replace ( '] ' , '' ) ; } catch ( e ) { 
function delegate ( method , _args ) { var callPosition = metalogger . callposition ( ) , file , line ; if ( ! metalogger . shouldLog ( method , _level ) ) { return ; } var args = Array . prototype . slice . call ( _args ) ; var message = '' , inspect = null ; message = util . inspect ( args . shift ( ) , { showHidden : true , depth : null } ) . replace ( / \n / g , ' ' ) ; inspect = args [ 0 ] ; if ( args . length > 2 ) { inspect = util . format . apply ( null , args ) ; } try { file = callPosition . split ( ':' ) [ 0 ] . replace ( ' [' , '' ) ; line = callPosition . split ( ':' ) [ 1 ] . replace ( '] ' , '' ) ; } catch ( e ) { 
function shouldLog ( testlevel , thresholdLevel ) { var allowed = logLevelAllowedGranular ( testlevel ) ; if ( allowed ) { return true ; } return logLevelAllowed ( testlevel , thresholdLevel ) ; } 
function logLevelAllowedGranular ( testlevel ) { if ( ! _granularlevels ) { return ; } var pos = callpositionObj ( ) ; if ( pos ) { var key = 'NODE_LOGGER_LEVEL_' + pos . filename . replace ( / [\.\/] / gi , '_' ) ; if ( key in process . env && process . env [ key ] ) { var thresholdLevel = process . env [ key ] . toLowerCase ( ) ; return logLevelsObj [ testlevel ] <= logLevelsObj [ thresholdLevel ] ; } } } 
function ( ) { if ( attrs . type === 'radio' ) { return attrs . value || $parse ( attrs . ngValue ) ( scope ) || true ; } var trueValue = ( $parse ( attrs . ngTrueValue ) ( scope ) ) ; if ( angular . isUndefined ( trueValue ) ) { trueValue = true ; } return trueValue ; } 
function ( attrName ) { var map = { 'switchRadioOff' : getBooleanFromStringDefTrue , 'switchActive' : function ( value ) { return ! getBooleanFromStringDefTrue ( value ) ; } , 'switchAnimate' : getBooleanFromStringDefTrue , 'switchLabel' : function ( value ) { return value ? value : '&nbsp;' ; } , 'switchIcon' : function ( value ) { if ( value ) { return '<span class=\'' + value + '\'></span>' ; } } , 'switchWrapper' : function ( value ) { return value || 'wrapper' ; } , 'switchInverse' : getBooleanFromString , 'switchReadonly' : getBooleanFromString , 'switchChange' : getExprFromString } ; var transFn = map [ attrName ] || getValueOrUndefined ; return transFn ( attrs [ attrName ] ) ; } 
function ( element , attr , modelAttr ) { if ( ! isInit ) { return ; } var newValue = getSwitchAttrValue ( modelAttr ) ; element . bootstrapSwitch ( attr , newValue ) ; } 
function ( ) { 
function ( ) { attrs . $observe ( 'switchActive' , function ( newValue ) { var active = getBooleanFromStringDefTrue ( newValue ) ; 
function ( ) { if ( attrs . type === 'radio' ) { 
function ( msg ) { if ( typeof scope . console === 'object' && scope . console !== null && typeof scope . console . warn === 'function' ) { warn = function ( msg ) { scope . console . warn ( msg ) ; } ; warn ( msg ) ; } } 
function ( o ) { var r , e ; if ( typeof o !== 'object' || o === null ) { r = default_options ; } else { r = { expires : default_options . expires , path : default_options . path , domain : default_options . domain , secure : default_options . secure } ; if ( typeof o . expires === 'object' && o . expires instanceof Date ) { r . expires = o . expires ; } else if ( typeof o . expires_at === 'object' && o . expires_at instanceof Date ) { r . expires = o . expires_at ; warn ( 'Cookie option "expires_at" has been deprecated. Rename to "expires". Support for "expires_at" will be removed in a version to come.' ) ; } else if ( typeof o . expiresAt === 'object' && o . expiresAt instanceof Date ) { r . expires = o . expiresAt ; warn ( 'Cookie option "expiresAt" has been deprecated. Rename to "expires". Support for "expiresAt" will be removed in a version to come.' ) ; } else if ( typeof o . hoursToLive === 'number' && o . hoursToLive !== 0 ) { e = new Date ( ) ; e . setTime ( e . getTime ( ) + ( o . hoursToLive * 60 * 60 * 1000 ) ) ; r . expires = e ; warn ( 'Cookie option "hoursToLive" has been deprecated. Rename to "expires" and prodvide a Date instance (see documentation). Support for "hoursToLive" will be removed in a version to come.' ) ; } if ( typeof o . path === 'string' && o . path !== '' ) { r . path = o . path ; } if ( typeof o . domain === 'string' && o . domain !== '' ) { r . domain = o . domain ; } if ( o . secure === true ) { r . secure = o . secure ; } } return r ; } 
function ( o ) { o = resolveOptions ( o ) ; return ( [ ( typeof o . expires === 'object' && o . expires instanceof Date ? '; expires=' + o . expires . toGMTString ( ) : '' ) , ( '; path=' + o . path ) , ( typeof o . domain === 'string' ? '; domain=' + o . domain : '' ) , ( o . secure === true ? '; secure' : '' ) ] . join ( '' ) ) ; } 
function ( n ) { var r , i , c = parseCookies ( ) ; if ( typeof n === 'string' ) { r = ( c [ n ] !== undef ) ? c [ n ] : null ; } else if ( typeof n === 'object' && n !== null ) { r = { } ; for ( i in n ) { if ( Object . prototype . hasOwnProperty . call ( n , i ) ) { if ( c [ n [ i ] ] !== undef ) { r [ n [ i ] ] = c [ n [ i ] ] ; } else { r [ n [ i ] ] = null ; } } } } else { r = c ; } return r ; } 
function ( p ) { var n , r = { } , c = parseCookies ( ) ; if ( typeof p === 'string' ) { p = new RegExp ( p ) ; } for ( n in c ) { if ( Object . prototype . hasOwnProperty . call ( c , n ) && n . match ( p ) ) { r [ n ] = c [ n ] ; } } return r ; } 
function ( n , v , o ) { if ( typeof o !== 'object' || o === null ) { o = { } ; } if ( v === undef || v === null ) { v = '' ; o . expires = new Date ( ) ; o . expires . setFullYear ( 1978 ) ; } else { v = ( v === true ) ? 'true' : ( v === false ) ? 'false' : ! isNaN ( v ) ? String ( v ) : v ; if ( typeof v !== 'string' ) { if ( typeof JSON === 'object' && JSON !== null && typeof JSON . stringify === 'function' ) { v = JSON . stringify ( v ) ; } else { throw new Error ( 'cookies.set() could not be serialize the value' ) ; } } } document . cookie = n + '=' + encodeURIComponent ( v ) + cookieOptions ( o ) ; } 
function ( n , o ) { var d = { } , i ; if ( typeof o !== 'object' || o === null ) { o = { } ; } if ( typeof n === 'boolean' && n === true ) { d = this . get ( ) ; } else if ( typeof n === 'string' ) { d [ n ] = true ; } for ( i in d ) { if ( Object . prototype . hasOwnProperty . call ( d , i ) && typeof i === 'string' && i !== '' ) { this . set ( i , null , o ) ; } } } 
function ( ) { var r = false , n = 'test_cookies_jaaulde_js' , v = 'data' ; this . set ( n , v ) ; if ( this . get ( n ) === v ) { this . del ( n ) ; r = true ; } return r ; } 
function formatMessage ( str ) { return String ( str ) . split ( '\n' ) . map ( function ( s ) { return s . magenta ; } ) . join ( '\n' ) ; } 
function applyZoom ( options , chart ) { if ( angular . isObject ( options . state ) && angular . isObject ( options . state ) && angular . isArray ( options . state . range ) ) { chart . zoom ( options . state . range ) ; } else { chart . unzoom ( ) ; } } 
function createZoomRangePath ( options ) { if ( ! angular . isObject ( options . state ) ) { options . state = { } ; } if ( ! angular . isObject ( options . state . range ) ) { options . state . range = [ ] ; } } 
function synchronizeZoom ( options , configuration , watcher ) { if ( angular . isObject ( options . chart ) && angular . isObject ( options . chart . zoom ) && options . chart . zoom . enabled === true ) { 
function addSelections ( chart , selections ) { service . disableSelectionListener = true ; selections . forEach ( function ( selection ) { chart . select ( [ selection . id ] , [ selection . index ] ) ; } ) ; service . disableSelectionListener = false ; } 
function removeAllSelections ( chart ) { service . disableSelectionListener = true ; chart . unselect ( ) ; service . disableSelectionListener = false ; } 
function applySelection ( options , chart ) { if ( angular . isObject ( options . state ) && angular . isArray ( options . state . selected ) ) { 
function createSelectionsPath ( options ) { if ( ! angular . isObject ( options . state ) ) { options . state = { } ; } if ( ! angular . isArray ( options . state . selected ) ) { options . state . selected = [ ] ; } } 
function synchronizeSelection ( options , configuration , watcher ) { if ( angular . isObject ( options . chart ) && angular . isObject ( options . chart . data ) && angular . isObject ( options . chart . data . selection ) && options . chart . data . selection . enabled === true ) { 
function init ( scope ) { var watcher = { scope : scope , dimensionsCallback : null , dimensionsTypeCallback : null , chartCallback : null , stateCallback : null , dataCallback : null , dataSmallWatcher : null , dataBigWatcher : null , disableStateWatcher : false } ; setupDimensionsWatcher ( watcher ) ; setupDimensionsTypeWatcher ( watcher ) ; setupChartWatcher ( watcher ) ; setupStateWatcher ( watcher ) ; setupWatchLimitWatcher ( watcher ) ; setupDataWatcher ( watcher ) ; return watcher ; } 
function setupDimensionsWatcher ( watcher ) { watcher . scope . $watch ( function ( ) { var check = watcher . scope . options && watcher . scope . options . dimensions ; 
function setupDataSmallWatcher ( watcher ) { return watcher . scope . $watch ( 'options.data' , function ( ) { if ( angular . isFunction ( watcher . dataCallback ) ) { watcher . dataCallback ( ) ; } setupDataWatcher ( watcher ) ; } , true ) ; } 
function setupDataBigWatcher ( watcher ) { return watcher . scope . $watch ( function ( ) { if ( watcher . scope . options . data && angular . isArray ( watcher . scope . options . data ) ) { return watcher . scope . options . data . length ; } else { return 0 ; } } , function ( ) { if ( angular . isFunction ( watcher . dataCallback ) ) { watcher . dataCallback ( ) ; } setupDataWatcher ( watcher ) ; } ) ; } 
function updateState ( watcher , func ) { watcher . disableStateWatcher = true ; watcher . scope . $apply ( func ) ; watcher . disableStateWatcher = false ; } 
function convertData ( options , configuration ) { 
function addIdentifier ( ) { $scope . dataAttributeChartID = 'chartid' + Math . floor ( Math . random ( ) * 1000000001 ) ; angular . element ( $element ) . attr ( 'id' , $scope . dataAttributeChartID ) ; configuration . bindto = '#' + $scope . dataAttributeChartID ; } 
function loadEntity ( name , promise , options ) { if ( ! name || typeof name !== 'string' ) throw new Error ( 'Missing required entity name' ) ; if ( ! promise || ! promise . then ) throw new Error ( 'Missing required entity promise' ) ; try { ! ( 0 , _validateOptions . default ) ( options ) ; } catch ( error ) { throw error ; } var entityLifecycle = new _entityLifecycle . default ( name , options ) ; return function ( dispatch , getState ) { entityLifecycle . setDispatch ( dispatch ) ; entityLifecycle . setGetState ( getState ) ; entityLifecycle . onLoad ( ) ; return new Promise ( function ( resolve , reject ) { promise . then ( function ( data ) { resolve ( entityLifecycle . onSuccess ( data ) ) ; } ) . catch ( function ( error ) { reject ( entityLifecycle . onFailure ( error ) ) ; } ) ; } ) ; } ; } 
function generateAction ( action , keys , values ) { var generatedAction = Object . assign ( { } , action ) ; keys . forEach ( function ( arg , index ) { generatedAction [ keys [ index ] ] = values [ index ] ; } ) ; return generatedAction ; } 
function makeActionCreator ( type ) { for ( var _len = arguments . length , keys = new Array ( _len > 1 ? _len - 1 : 0 ) , _key = 1 ; _key < _len ; _key ++ ) { keys [ _key - 1 ] = arguments [ _key ] ; } if ( ! type ) throw new Error ( 'Type cannot be null/undefined' ) ; return function ( ) { for ( var _len2 = arguments . length , values = new Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { values [ _key2 ] = arguments [ _key2 ] ; } return generateAction ( { type : type } , keys , values ) ; } ; } 
function makeEntityActionCreator ( type , entity ) { for ( var _len3 = arguments . length , keys = new Array ( _len3 > 2 ? _len3 - 2 : 0 ) , _key3 = 2 ; _key3 < _len3 ; _key3 ++ ) { keys [ _key3 - 2 ] = arguments [ _key3 ] ; } if ( ! type ) throw new Error ( 'Type cannot be null/undefined' ) ; if ( ! entity ) throw new Error ( 'Entity cannot be null/undefined' ) ; return function ( ) { for ( var _len4 = arguments . length , values = new Array ( _len4 ) , _key4 = 0 ; _key4 < _len4 ; _key4 ++ ) { values [ _key4 ] = arguments [ _key4 ] ; } return generateAction ( { type : type , entity : entity } , keys , values ) ; } ; } 
function _getRandomDelayBetween ( min , max , roundTo ) { return Number ( Math . random ( ) * ( max - min ) + min ) . toFixed ( roundTo ) ; } 
function _logDetails ( action ) { if ( action ) { console . log ( ` ${ chalk . white . bgRed ( ' Prev State:' ) } ${ __toString ( state ) } ` ) ; console . log ( ` ${ chalk . white . bgBlue ( ' Action:' ) } ${ __toString ( action ) } ` ) ; } else { console . log ( ` ${ chalk . white . bgGreen ( ' Next State:' ) } ${ __toString ( state ) } ` ) ; console . log ( '\n' ) ; } } 
function jgeParse ( s , callback , context ) { if ( context && context . newState ) { if ( ! context . keepToken ) context . token = '' ; context . state = context . newState ; } else { context = { } ; reset ( context ) ; } var c ; for ( var i = context . position ; i < s . length ; i ++ ) { c = s . charAt ( i ) ; if ( ( c . charCodeAt ( 0 ) < 32 ) && ( context . validControlChars . indexOf ( c ) < 0 ) ) { context . newState = context . state = sError ; } if ( context . state != sContent ) { if ( context . validControlChars . indexOf ( c ) >= 0 ) { 
function jptr ( obj , prop , newValue ) { 
function fetchFromObject ( obj , prop , newValue ) { 
function ( obj , attrPrefix , standalone , indent , indentStr , fragment ) { var attributePrefix = ( attrPrefix ? attrPrefix : '@' ) ; if ( fragment ) { xmlWrite . startFragment ( indent , indentStr ) ; } else { xmlWrite . startDocument ( 'UTF-8' , standalone , indent , indentStr ) ; } traverse ( obj , '' , attributePrefix ) ; return xmlWrite . endDocument ( ) ; } 
function _removeSubscribers ( aSubscribers , oSubscriber ) { let nUnsubscribed = 0 ; if ( ! isTypeOf ( aSubscribers , sNotDefined ) ) { let nIndex = aSubscribers . length - 1 ; for ( ; nIndex >= 0 ; nIndex -- ) { if ( aSubscribers [ nIndex ] . subscriber === oSubscriber ) { nUnsubscribed ++ ; aSubscribers . splice ( nIndex , 1 ) ; } } } return nUnsubscribed ; } 
function _removeSubscribersPerEvent ( oEventsCallbacks , sChannelId , oSubscriber ) { let nUnsubscribed = 0 ; iterateObject ( oEventsCallbacks , function ( oItem , sEvent ) { const aEventsParts = sEvent . split ( ':' ) ; let sChannel = sChannelId ; let sEventType = sEvent ; if ( aEventsParts [ 0 ] === 'global' ) { sChannel = aEventsParts [ 0 ] ; sEventType = aEventsParts [ 1 ] ; } nUnsubscribed += _removeSubscribers ( oChannels [ sChannel ] [ sEventType ] , oSubscriber ) ; } ) ; return nUnsubscribed ; } 
function _addSubscribers ( oEventsCallbacks , sChannelId , oSubscriber ) { iterateObject ( oEventsCallbacks , function ( oItem , sEvent ) { subscribeTo ( sChannelId , sEvent , oItem , oSubscriber ) ; } ) ; } 
function _getChannelEvents ( sChannelId , sEvent ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } if ( oChannels [ sChannelId ] [ sEvent ] === und ) { oChannels [ sChannelId ] [ sEvent ] = [ ] ; } return oChannels [ sChannelId ] [ sEvent ] ; } 
function subscribersByEvent ( oChannel , sEventName ) { let aSubscribers = [ ] ; if ( ! isTypeOf ( oChannel , sNotDefined ) ) { iterateObject ( oChannel , function ( oItem , sKey ) { if ( sKey === sEventName ) { aSubscribers = oItem ; } } ) ; } return aSubscribers ; } 
function subscribeTo ( sChannelId , sEventType , fpHandler , oSubscriber ) { const aChannelEvents = _getChannelEvents ( sChannelId , sEventType ) ; aChannelEvents . push ( { subscriber : oSubscriber , handler : fpHandler } ) ; } 
function unsubscribeFrom ( sChannelId , sEventType , oSubscriber ) { const aChannelEvents = _getChannelEvents ( sChannelId , sEventType ) ; for ( let nEvent = aChannelEvents . length - 1 ; nEvent >= 0 ; nEvent -- ) { const oItem = aChannelEvents [ nEvent ] ; if ( oItem . subscriber === oSubscriber ) { aChannelEvents . splice ( nEvent , 1 ) ; } } } 
function subscribe ( oSubscriber ) { const oEventsCallbacks = oSubscriber . events ; if ( ! oSubscriber || oEventsCallbacks === und ) { return false ; } iterateObject ( oEventsCallbacks , function ( oItem , sChannelId ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } _addSubscribers ( oItem , sChannelId , oSubscriber ) ; } ) ; return true ; } 
function unsubscribe ( oSubscriber ) { let nUnsubscribed = 0 ; const oEventsCallbacks = oSubscriber . events ; if ( ! oSubscriber || oEventsCallbacks === und ) { return false ; } iterateObject ( oEventsCallbacks , function ( oItem , sChannelId ) { if ( oChannels [ sChannelId ] === und ) { oChannels [ sChannelId ] = { } ; } nUnsubscribed = _removeSubscribersPerEvent ( oItem , sChannelId , oSubscriber ) ; } ) ; return nUnsubscribed > 0 ; } 
function _executeHandler ( oHandlerObject , oData , sChannelId , sEvent ) { oHandlerObject . handler . call ( oHandlerObject . subscriber , oData ) ; if ( getDebug ( ) ) { const ErrorHandler = errorHandler ( ) ; ErrorHandler . log ( sChannelId , sEvent , oHandlerObject ) ; } } 
function publish ( sChannelId , sEvent , oData ) { const aSubscribers = copyArray ( this . subscribers ( sChannelId , sEvent ) ) ; let oSubscriber ; const nLenSubscribers = aSubscribers . length ; if ( nLenSubscribers === 0 ) { return false ; } oData = preprocessorsPublishData ( oData ) ; while ( ! ! ( oSubscriber = aSubscribers . shift ( ) ) ) { _executeHandler ( oSubscriber , oData , sChannelId , sEvent ) ; } return true ; } 
function resolveNamespace ( sNamespace ) { var oObj = root , aElements = sNamespace . split ( '.' ) , sElement ; while ( ! ! ( sElement = aElements . shift ( ) ) ) { oObj = oObj [ sElement ] !== und ? oObj [ sElement ] : oObj [ sElement ] = { } ; } return oObj ; } 
function getResolveDICallback ( oMapping ) { return function ( sDependency ) { var oPromise = getPromise ( ) ; if ( ! oMapping . __map__ [ sDependency ] ) { return false ; } oPromise . resolve ( oMapping . __map__ [ sDependency ] ) ; return oPromise ; } ; } 
function getDependencyThroughAllMaps ( sDependency ) { var oMap , oDependency , nIndexOrder , nLenOrder , aOrderDependency = oMappingMaps . ___order___ ; createMapping ( oMappingMaps , '__' , root , function ( sDependency ) { var oDependency , oPromise = getPromise ( ) ; oDependency = resolveNamespace ( sDependency ) ; oPromise . resolve ( oDependency ) ; return oPromise ; } ) ; for ( nIndexOrder = 0 , nLenOrder = aOrderDependency . length ; nIndexOrder < nLenOrder ; nIndexOrder ++ ) { oMap = oMappingMaps [ aOrderDependency [ nIndexOrder ] ] ; oDependency = oMap . __resolveDI__ ( sDependency ) ; if ( oDependency ) { delete oMappingMaps [ '__' ] ; return oDependency ; } } delete oMappingMaps [ '__' ] ; return false ; } 
function getPromiseCallbacks ( oContext , sType ) { return function ( ) { var aCompleted , nLenPromises , oDeferred , aPromises , nPromise , oPromise , aResults = [ ] ; oContext . bCompleted = true ; oContext . sType = sType ; oContext . oResult = arguments ; while ( oContext . aPending [ 0 ] ) { oContext . aPending . shift ( ) [ sType ] . apply ( oContext , arguments ) ; } oDeferred = oContext . oDeferred ; if ( oDeferred ) { aCompleted = [ ] ; aPromises = oDeferred . aPromises ; nLenPromises = aPromises . length ; aResults = [ ] ; for ( nPromise = 0 ; nPromise < nLenPromises ; nPromise ++ ) { oPromise = aPromises [ nPromise ] ; aCompleted . push ( Number ( oPromise . bCompleted ) ) ; aResults . push ( oPromise . oResult ) ; } if ( aCompleted . join ( '' ) . indexOf ( '0' ) === - 1 ) { oDeferred [ sType ] . apply ( oDeferred , aResults ) ; } } } ; } 
function ( fpSuccess , fpFailure ) { var oResult = this . oResult ; if ( this . bCompleted ) { if ( this . sType === 'resolve' ) { fpSuccess . apply ( fpSuccess , oResult ) ; } else { fpFailure . apply ( fpFailure , oResult ) ; } } else { this . aPending . push ( { resolve : fpSuccess , reject : fpFailure } ) ; } return this ; } 
function FakeModule ( sModuleId , fpCreator ) { if ( isTypeOf ( fpCreator , sNotDefined ) ) { throw new Error ( 'Something goes wrong!' ) ; } this . creator = fpCreator ; this . instances = { } ; this . sModuleId = sModuleId ; } 
function isJqueryObject ( oObj ) { var isJquery = false , $ = getRoot ( ) . jQuery ; if ( $ ) { isJquery = isInstanceOf ( oObj , $ ) ; } return isJquery ; } 
function isEvent ( oObj ) { try { return isInstanceOf ( oObj , Event ) ; } catch ( erError ) { 
function addPropertiesAndMethodsToModule ( sModuleId , aDependencies , fpCallback ) { var oPromise ; function success ( mapping ) { const oModules = getModules ( ) ; var oModule , fpInitProxy ; oModule = oModules [ sModuleId ] . creator . apply ( oModules [ sModuleId ] , [ ] . slice . call ( arguments , 1 ) ) ; oModule . __children__ = [ ] ; oModule . dependencies = aDependencies || [ ] . slice . call ( arguments , 1 ) ; oModule . resolvedDependencies = mapping ; oModule . __module_id__ = sModuleId ; fpInitProxy = oModule . init || nullFunc ; 
function wrapMethod ( oInstance , sName , sModuleId , fpMethod ) { oInstance [ sName ] = ( function ( sName , fpMethod ) { return function ( ) { var aArgs = copyArray ( arguments ) ; try { return fpMethod . apply ( this , aArgs ) ; } catch ( erError ) { const ErrorHandler = errorHandler ( ) ; ErrorHandler . error ( sModuleId , sName , erError ) ; return false ; } } ; } ( sName , fpMethod ) ) ; } 
function register ( sModuleId , aDependencies , fpCreator ) { const oModules = getModules ( ) ; if ( isFunction ( aDependencies ) ) { fpCreator = aDependencies ; aDependencies = [ '$$_bus' , '$$_module' , '$$_log' , 'gl_Hydra' ] ; } oModules [ sModuleId ] = new FakeModule ( sModuleId , fpCreator ) ; oModules [ sModuleId ] . dependencies = aDependencies ; return oModules [ sModuleId ] ; } 
function setInstance ( sModuleId , sIdInstance , oInstance ) { const oModules = getModules ( ) ; var oModule = oModules [ sModuleId ] ; if ( ! oModule ) { fpThrowErrorModuleNotRegistered ( sModuleId , true ) ; } oModule . instances [ sIdInstance ] = oInstance ; return oModule ; } 
function _multiModuleStart ( oInstance , aModulesIds , sIdInstance , oData , bSingle ) { var aInstancesIds , aData , aSingle , nIndex , nLenModules , sModuleId ; if ( isArray ( sIdInstance ) ) { aInstancesIds = copyArray ( sIdInstance ) ; } if ( isArray ( oData ) ) { aData = copyArray ( oData ) ; } if ( isArray ( bSingle ) ) { aSingle = copyArray ( bSingle ) ; } for ( nIndex = 0 , nLenModules = aModulesIds . length ; nIndex < nLenModules ; nIndex ++ ) { sModuleId = aModulesIds [ nIndex ] ; sIdInstance = aInstancesIds && aInstancesIds [ nIndex ] || generateUniqueKey ( ) ; oData = aData && aData [ nIndex ] || oData ; bSingle = aSingle && aSingle [ nIndex ] || bSingle ; startSingleModule ( oInstance , sModuleId , sIdInstance , oData , bSingle ) ; } } 
function beforeInit ( oInstance , oData , bSingle ) { iterateObject ( oModifyInit , function ( oMember ) { if ( oMember && isTypeOf ( oMember , sFunctionType ) ) { oMember ( oInstance , oData , bSingle ) ; } } ) ; } 
function startSingleModule ( oWrapper , sModuleId , sIdInstance , oData , bSingle ) { const oModules = getModules ( ) ; var oModule ; oModule = oModules [ sModuleId ] ; if ( ( bSingle && isModuleStarted ( sModuleId ) ) || isModuleStarted ( sModuleId , sIdInstance ) ) { oWrapper . stop ( sModuleId , sIdInstance ) ; } if ( ! isTypeOf ( oModule , sNotDefined ) ) { createInstance ( sModuleId , undefined , function ( oInstance ) { oModule . instances [ sIdInstance ] = oInstance ; oInstance . __instance_id__ = sIdInstance ; beforeInit ( oInstance , oData , bSingle ) ; if ( ! isTypeOf ( oData , sNotDefined ) ) { oInstance . init ( oData ) ; } else { oInstance . init ( ) ; } } ) ; } else { const ErrorHandler = errorHandler ( ) ; ErrorHandler . error ( new Error ( ) , fpThrowErrorModuleNotRegistered ( sModuleId ) ) ; } } 
function _singleModuleStart ( oInstance , sModuleId , sIdInstance , oData , bSingle ) { if ( ! isTypeOf ( sIdInstance , 'string' ) ) { bSingle = oData ; oData = sIdInstance ; sIdInstance = generateUniqueKey ( ) ; } startSingleModule ( oInstance , sModuleId , sIdInstance , oData , bSingle ) ; } 
function start ( oModuleId , oIdInstance , oData , oSingle ) { var bStartMultipleModules = isArray ( oModuleId ) ; if ( bStartMultipleModules ) { _multiModuleStart ( this , copyArray ( oModuleId ) , oIdInstance , oData , oSingle ) ; } else { _singleModuleStart ( this , oModuleId , oIdInstance , oData , oSingle ) ; } } 
function createInstance ( sModuleId , aDependencies , fpCallback ) { const oModules = getModules ( ) ; if ( isTypeOf ( oModules [ sModuleId ] , sNotDefined ) ) { fpThrowErrorModuleNotRegistered ( sModuleId , true ) ; } addPropertiesAndMethodsToModule ( sModuleId , aDependencies , function ( oInstance ) { if ( ! getDebug ( ) ) { iterateObject ( oInstance , function ( oItem , sName ) { if ( isFunction ( oItem ) ) { wrapMethod ( oInstance , sName , sModuleId , oInstance [ sName ] ) ; } } ) ; } fpCallback ( oInstance ) ; } ) ; } 
function getCallbackToSetObjectFromTemplate ( oMethodsObject , oPropertiesObject ) { return function ( oValue , sKey ) { if ( typeof oValue === 'function' ) { oMethodsObject [ sKey ] = getSimpleFunction ( oValue ) ; } else if ( isArray ( oValue ) ) { oPropertiesObject [ sKey ] = copyArray ( oValue ) ; } else if ( typeof oValue === 'object' && oValue !== null ) { oPropertiesObject [ sKey ] = simpleMerge ( { } , oValue ) ; } else if ( isInstanceOf ( oValue , Date ) ) { oPropertiesObject [ sKey ] = new Date ( ) ; oPropertiesObject [ sKey ] . setTime ( oValue . getTime ( ) ) ; } else { oPropertiesObject [ sKey ] = oValue ; } } ; } 
function startAll ( ) { const oModules = getModules ( ) ; iterateObject ( oModules , function ( _oModule , sModuleId ) { if ( ! isTypeOf ( _oModule , sNotDefined ) ) { start ( sModuleId , generateUniqueKey ( ) ) ; } } ) ; } 
function stop ( sModuleId , sInstanceId ) { const oModules = getModules ( ) ; var oModule ; oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return false ; } if ( ! isTypeOf ( sInstanceId , sNotDefined ) ) { _singleModuleStop ( oModule , sInstanceId ) ; } else { _multiModuleStop ( oModule ) ; } return true ; } 
function _multiModuleStop ( oModule ) { iterateObject ( oModule . instances , function ( oInstance ) { if ( ! isTypeOf ( oModule , sNotDefined ) && ! isTypeOf ( oInstance , sNotDefined ) ) { oInstance . destroy ( ) ; } } ) ; oModule . instances = { } ; } 
function _singleModuleStop ( oModule , sInstanceId ) { var oInstance = oModule . instances [ sInstanceId ] ; if ( ! isTypeOf ( oModule , sNotDefined ) && ! isTypeOf ( oInstance , sNotDefined ) ) { oInstance . destroy ( ) ; delete oModule . instances [ sInstanceId ] ; } } 
function stopAll ( ) { const oModules = getModules ( ) ; iterateObject ( oModules , function ( _oModule , sModuleId ) { if ( ! isTypeOf ( _oModule , sNotDefined ) ) { _stopOneByOne ( _oModule , sModuleId ) ; } } ) ; } 
function _stopOneByOne ( oModule , sModuleId ) { iterateObject ( oModule . instances , function ( oItem , sInstanceId ) { stop ( sModuleId , sInstanceId ) ; } ) ; } 
function remove ( sModuleId ) { const oModules = getModules ( ) ; var oModule = oModules [ sModuleId ] ; if ( isTypeOf ( oModule , sNotDefined ) ) { return null ; } if ( ! isTypeOf ( oModule , sNotDefined ) ) { try { return Module ; } finally { _delete ( sModuleId ) ; createMapping ( getMappingMaps ( ) , 'hm_' , oModules ) ; } } return null ; } 
function _delete ( sModuleId ) { const oModules = getModules ( ) ; if ( ! isTypeOf ( oModules [ sModuleId ] , sNotDefined ) ) { delete oModules [ sModuleId ] ; return true ; } return false ; } 
function main ( ) { return __awaiter ( this , void 0 , void 0 , function ( ) { var outputDataSize , interval , dataFrame , dateFormat , api ; return __generator ( this , function ( _a ) { switch ( _a . label ) { case 0 : outputDataSize = "compact" ; if ( argv . outputDataSize ) { outputDataSize = argv . outputDataSize ; } interval = '60min' ; if ( argv . interval ) { interval = argv . interval ; } api = new index_1 . AlphaVantageAPI ( argv . apiKey , outputDataSize , argv . verbose ) ; if ( ! ( argv . type === 'daily' ) ) return [ 3 , 2 ] ; return [ 4 , api . getDailyDataFrame ( argv . symbol ) ] ; case 1 : dataFrame = _a . sent ( ) ; dateFormat = 'YYYY-MM-DD' ; return [ 3 , 5 ] ; case 2 : if ( ! ( argv . type === 'intraday' ) ) return [ 3 , 4 ] ; return [ 4 , api . getIntradayDataFrame ( argv . symbol , interval ) ] ; case 3 : dataFrame = _a . sent ( ) ; dateFormat = "YYYY-MM-DD HH:mm:ss" ; return [ 3 , 5 ] ; case 4 : throw new Error ( "Unexpected data type: " + argv . type + ", expected it to be either 'daily' or 'intrday'" ) ; case 5 : if ( ! argv . verbose ) { console . log ( '>> ' + argv . out ) ; } dataFrame . transformSeries ( { Timestamp : function ( t ) { return moment ( t ) . format ( dateFormat ) ; } , } ) . asCSV ( ) . writeFileSync ( argv . out ) ; return [ 2 ] ; } } ) ; } ) ; } 
function ( name , opts ) { 
function ( val ) { 
function ( val ) { 
function ( val ) { val = this . setValue ( val ) ; if ( ( val !== false ) && ( val !== '' ) ) { if ( this . hasInput ( ) ) { this . input . val ( this . getValue ( ) ) ; } else { this . element . data ( 'pickerValue' , this . getValue ( ) ) ; } this . _trigger ( 'pickerSetSourceValue' , { pickerValue : val } ) ; } return val ; } 
function ( defaultValue ) { 
function ( e , p ) { if ( ! e ) return false ; var el = e . target || e . srcElement || e || false ; while ( el && el != p ) { el = el . parentNode || false ; } return ( el !== false ) ; } 
function ( el , options ) { events . EventEmitter . call ( this ) ; this . el = el ; this . options = extend ( { } , this . options ) ; this . options = extend ( this . options , options ) ; this . _init ( ) ; } 
function findUuidIndex ( array , uuid ) { for ( let i = 0 , len = array . length ; i < len ; i ++ ) { if ( array [ i ] . uuid == uuid ) { // eslint-disable-line return i ; } } return - 1 ; } 
function createMarkdownSerializer ( indentCodeBlocks ) { return { serialize : ( name , suite ) => snapshotToMarkdown ( name , suite , indentCodeBlocks ) , deserialize : markdownToSnapshot , } ; } 
function markdownToSnapshot ( content ) { const tree = mdParser . parse ( content ) ; const state = { name : null , suite : null , suiteStack : [ ] , currentSuite : null , currentSnapshotList : null , depth : 0 } ; const children = tree . children ; for ( let i = 0 ; i < children . length ; i ++ ) { const c = children [ i ] ; switch ( c . type ) { case 'heading' : if ( c . depth === 1 ) { enterRootSuite ( state , c ) ; } else if ( c . depth === 2 ) { tryExit ( state , suiteDepth ( c ) ) ; enterSuite ( state , c ) ; } else if ( c . depth === 4 ) { enterSnapshot ( state , c ) ; } break ; case 'code' : pushSnapshotCode ( state , c ) ; break ; } } return { name : state . name , suite : state . suite } ; } 
function tryExit ( state , depth ) { while ( state . depth >= depth ) { state . suiteStack . pop ( ) ; state . currentSuite = state . suiteStack [ state . suiteStack . length - 1 ] ; state . currentSnapshotList = null ; state . depth -- ; } } 
function enterRootSuite ( state , node ) { const inlineCode = node . children [ 0 ] ; const name = inlineCode . value ; const suite = { children : { } , snapshots : { } } state . name = name ; state . suite = suite ; state . suiteStack . push ( suite ) ; state . currentSuite = suite ; state . currentSnapshotList = null ; state . depth = 0 ; } 
function enterSnapshot ( state , node ) { const inlineCode = node . children [ 0 ] ; const name = inlineCode . value ; const snapshotList = [ ] ; state . currentSuite . snapshots [ name ] = snapshotList ; state . currentSnapshotList = snapshotList ; } 
function pushSnapshotCode ( state , node ) { state . currentSnapshotList . push ( { lang : node . lang , code : normalizeNewlines ( node . value ) } ) ; } 
function transformSuite ( name , suite , depth , indentCodeBlocks ) { const children = suite . children ; const snapshots = suite . snapshots ; const nextDepth = depth + 1 ; let result = suiteHeader ( name , depth ) ; let keys , i ; keys = Object . keys ( snapshots ) ; for ( i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const snapshotList = snapshots [ key ] ; result += transformSnapshotList ( key , snapshotList , nextDepth , indentCodeBlocks ) ; } keys = Object . keys ( children ) ; for ( i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; result += transformSuite ( key , children [ key ] , nextDepth , indentCodeBlocks ) ; } return result ; } 
function transformSnapshotList ( name , snapshotList , depth , indentCodeBlocks ) { let result = snapshotHeader ( name , depth ) ; for ( let i = 0 ; i < snapshotList . length ; i ++ ) { if ( i > 0 && indentCodeBlocks ) { result += '---\n\n' ; } const snapshot = snapshotList [ i ] ; const lang = snapshot . lang ; const code = snapshot . code ; const delimiter = safeDelimiter ( code ) ; if ( indentCodeBlocks ) { const lines = code . split ( '\n' ) ; for ( let i = 0 ; i < lines . length ; i ++ ) { result += ' ' + lines [ i ] + '\n' ; } } else { result += delimiter ; if ( lang ) { result += lang ; } result += '\n' + code + '\n' + delimiter + '\n' ; } result += '\n' ; } return result ; } 
function suiteHeader ( name , depth ) { if ( depth === - 1 ) { return "# " + serializeName ( name ) + "\n\n" ; } return "## " + indent ( depth ) + serializeName ( name ) + "\n\n" ; } 
function safeDelimiter ( s , delimiter ) { if ( delimiter === undefined ) { delimiter = '```' ; } while ( s . indexOf ( delimiter ) !== - 1 ) { delimiter += '`' ; } return delimiter ; } 
function defaultPathResolver ( basePath , suiteName ) { const suiteSourcePath = path . join ( basePath , suiteName ) ; const suiteSourceDir = path . dirname ( suiteSourcePath ) ; const sourceFileName = path . basename ( suiteName ) ; return path . join ( suiteSourceDir , "__snapshots__" , sourceFileName + ".md" ) ; } 
function formatSnapshotList ( list , limit ) { limit = ( typeof limit != 'undefined' ) ? limit : - 1 ; const limitedList = limit > 0 ? list . slice ( 0 , limit ) : list ; const hasMore = list . length > limitedList . length ; const buildList = ( snapshots ) => snapshots . map ( ( s ) => s . join ( ' > ' ) ) . join ( '\n' ) ; if ( hasMore ) { return buildList ( limitedList . slice ( 0 , - 1 ) ) + ` \n ${ list . length - limitedList . length + 1 } ` ; } return buildList ( limitedList ) ; } 
function formatUnusedSnapshotsWarning ( list , limit ) { if ( limit == 0 ) { return ` ${ list . length } ` ; } const prunedList = formatSnapshotList ( list , limit ) ; return ` ${ list . length } \n ${ prunedList } ` ; } 
function snapshotFramework ( files , config , emitter , loggerFactory ) { const logger = loggerFactory . create ( 'framework.snapshot' ) ; const snapshotConfig = Object . assign ( { update : false , prune : false , format : "md" , checkSourceFile : false , pathResolver : defaultPathResolver , limitUnusedSnapshotsInWarning : - 1 } , config . snapshot ) ; if ( typeof snapshotConfig . format === "string" ) { switch ( snapshotConfig . format ) { case "indented-md" : snapshotSerializer = createMarkdownSerializer ( true ) ; break ; case "md" : default : snapshotSerializer = createMarkdownSerializer ( false ) ; } } else { snapshotSerializer = snapshotConfig . format ; } 
function snapshotPreprocessor ( basePath , loggerFactory ) { const logger = loggerFactory . create ( 'preprocessor.snapshot' ) ; return function ( content , file , done ) { const root = snapshotSerializer . deserialize ( content ) ; done ( iifeWrapper ( 'window.__snapshot__.addSuite("' + root . name + '",' + JSON . stringify ( root . suite ) + ');' ) ) ; } ; } 
function singleLinePlugin ( options = { } ) { options = Object . assign ( { } , defaultOptions , options ) return { blockRenderMap : Map ( { 'unstyled' : { element : 'div' , } , } ) , onChange ( editorState ) { const blocks = editorState . getCurrentContent ( ) . getBlocksAsArray ( ) * Stop new lines being inserted by always handling the return * * @param {KeyboardEvent} e Synthetic keyboard event from draftjs * @return {String} Did we handle the return or not? (pro-trip: yes, we did) */ handleReturn ( e ) { return 'handled' } , } } 
function replaceNewlines ( str ) { var replacement = arguments . length <= 1 || arguments [ 1 ] === undefined ? ' ' : arguments [ 1 ] ; return str . replace ( NEWLINE_REGEX , replacement ) ; } 
function condenseBlocks ( editorState , blocks , options ) { blocks = blocks || editorState . getCurrentContent ( ) . getBlocksAsArray ( ) ; var text = ( 0 , _immutable . List ) ( ) ; var characterList = ( 0 , _immutable . List ) ( ) ; 
function characterListhasEntities ( characterList ) { var hasEntities = false ; characterList . forEach ( function ( characterMeta ) { if ( characterMeta . get ( 'entity' ) !== null ) { hasEntities = true ; } } ) ; return hasEntities ; } 
function getClosestVersion ( ) { if ( ! process . versions . v8 ) { 
function GstLaunch ( ) { const gst_launch_executable = 'gst-launch-1.0' ; const gst_launch_versionarg = '--version' ; const SpawnSync = require ( 'child_process' ) . spawnSync ; const Spawn = require ( 'child_process' ) . spawn ; const Assert = require ( 'assert' ) ; const Path = require ( 'path' ) ; const OS = require ( 'os' ) ; const FS = require ( 'fs' ) ; var getPath = function ( ) { var detected_path = undefined ; if ( OS . platform ( ) == 'win32' ) { * @fn getVersion * @brief Returns version string of GStreamer on this machine by * invoking the gst-launch executable or 'undefined' on failure. */ var getVersion = function ( ) { var version_str = undefined ; try { var gst_launch_path = getPath ( ) ; Assert . ok ( typeof ( gst_launch_path ) , 'string' ) ; var output = SpawnSync ( gst_launch_path , [ gst_launch_versionarg ] , { 'timeout' : 1000 } ) . stdout ; if ( output && output . toString ( ) . includes ( 'GStreamer' ) ) { version_str = output . toString ( ) . match ( / GStreamer\s+.+ / g ) [ 0 ] . replace ( / GStreamer\s+ / , '' ) ; } } catch ( ex ) { version_str = undefined ; } return version_str ; } var isAvailable = function ( ) { return getVersion ( ) != undefined ; } var spawnPipeline = function ( pipeline ) { Assert . ok ( typeof ( pipeline ) , 'string' ) ; Assert . ok ( isAvailable ( ) , "gst-launch is not available." ) ; var gst_launch_path = getPath ( ) ; Assert . ok ( typeof ( gst_launch_path ) , 'string' ) ; return Spawn ( gst_launch_path , pipeline . split ( ' ' ) ) ; } return { 'getPath' : getPath , 'getVersion' : getVersion , 'isAvailable' : isAvailable , 'spawnPipeline' : spawnPipeline } } 
function ( pipeline ) { Assert . ok ( typeof ( pipeline ) , 'string' ) ; Assert . ok ( isAvailable ( ) , "gst-launch is not available." ) ; var gst_launch_path = getPath ( ) ; Assert . ok ( typeof ( gst_launch_path ) , 'string' ) ; return Spawn ( gst_launch_path , pipeline . split ( ' ' ) ) ; } 
function GstLiveCamServer ( config ) { const Assert = require ( 'assert' ) ; const OS = require ( 'os' ) ; Assert . ok ( [ 'win32' , 'linux' , 'darwin' ] . indexOf ( OS . platform ( ) ) > - 1 , "livecam module supports Windows, Linux, and Mac OSX for broadcasting." ) ; config = config || { } ; Assert . ok ( typeof ( config ) , 'object' ) ; const fake = config . fake || false ; const width = config . width || 800 ; const height = config . height || 600 ; const framerate = config . framerate || 30 ; const grayscale = config . grayscale || false ; const deviceIndex = config . deviceIndex || - 1 ; Assert . ok ( typeof ( fake ) , 'boolean' ) ; Assert . ok ( typeof ( width ) , 'number' ) ; Assert . ok ( typeof ( height ) , 'number' ) ; Assert . ok ( typeof ( framerate ) , 'number' ) ; Assert . ok ( typeof ( grayscale ) , 'boolean' ) ; var gst_multipart_boundary = '--videoboundary' ; var gst_video_src = '' ; if ( ! fake ) { if ( OS . platform ( ) == 'win32' ) gst_video_src = 'ksvideosrc device-index=' + deviceIndex + ' ! decodebin' ; else if ( OS . platform ( ) == 'linux' ) gst_video_src = 'v4l2src ! decodebin' ; else if ( OS . platform ( ) == 'darwin' ) gst_video_src = 'avfvideosrc device-index=' + deviceIndex ; else Assert . ok ( false , 'unsupported platform' ) } else { gst_video_src = 'videotestsrc' ; } if ( width > 0 || height > 0 ) { gst_video_src += ' ! videoscale ! video/x-raw,width=' + parseInt ( width ) + ',height=' + parseInt ( height ) ; } if ( framerate > 0 ) { gst_video_src += ' ! videorate ! video/x-raw,framerate=' + parseInt ( framerate ) + '/1' ; } if ( grayscale ) { gst_video_src += ' ! videobalance saturation=0.0 ! videoconvert' ; } var start = function ( tcp_addr , tcp_port ) { Assert . ok ( typeof ( tcp_addr ) , 'string' ) ; Assert . ok ( typeof ( tcp_port ) , 'number' ) ; const cam_pipeline = gst_video_src + ' ! jpegenc ! multipartmux boundary="' + gst_multipart_boundary + '" ! tcpserversink host=' + tcp_addr + ' port=' + tcp_port ; var gst_launch = new GstLaunch ( ) ; if ( gst_launch . isAvailable ( ) ) { console . log ( 'GstLaunch found: ' + gst_launch . getPath ( ) ) ; console . log ( 'GStreamer version: ' + gst_launch . getVersion ( ) ) ; console . log ( 'GStreamer pipeline: ' + cam_pipeline ) ; return gst_launch . spawnPipeline ( cam_pipeline ) ; } else { throw new Error ( 'GstLaunch not found.' ) ; } } return { 'start' : start } } 
function ( tcp_addr , tcp_port ) { Assert . ok ( typeof ( tcp_addr ) , 'string' ) ; Assert . ok ( typeof ( tcp_port ) , 'number' ) ; const cam_pipeline = gst_video_src + ' ! jpegenc ! multipartmux boundary="' + gst_multipart_boundary + '" ! tcpserversink host=' + tcp_addr + ' port=' + tcp_port ; var gst_launch = new GstLaunch ( ) ; if ( gst_launch . isAvailable ( ) ) { console . log ( 'GstLaunch found: ' + gst_launch . getPath ( ) ) ; console . log ( 'GStreamer version: ' + gst_launch . getVersion ( ) ) ; console . log ( 'GStreamer pipeline: ' + cam_pipeline ) ; return gst_launch . spawnPipeline ( cam_pipeline ) ; } else { throw new Error ( 'GstLaunch not found.' ) ; } } 
function SocketCamWrapper ( gst_tcp_addr , gst_tcp_port , broadcast_tcp_addr , broadcast_tcp_port ) { const Net = require ( 'net' ) ; const Http = require ( 'http' ) ; const Dicer = require ( 'dicer' ) ; const Assert = require ( 'assert' ) ; const SocketIO = require ( 'socket.io' ) ; const gst_multipart_boundary = '--videoboundary' ; var wrap = function ( gst_tcp_addr , gst_tcp_port , broadcast_tcp_addr , broadcast_tcp_port ) { Assert . ok ( typeof ( gst_tcp_addr ) , 'string' ) ; Assert . ok ( typeof ( gst_tcp_port ) , 'number' ) ; Assert . ok ( typeof ( broadcast_tcp_addr ) , 'string' ) ; Assert . ok ( typeof ( broadcast_tcp_port ) , 'number' ) ; var socket = Net . Socket ( ) ; socket . connect ( gst_tcp_port , gst_tcp_addr , function ( ) { var io = SocketIO . listen ( Http . createServer ( ) . listen ( broadcast_tcp_port , broadcast_tcp_addr ) ) ; var dicer = new Dicer ( { boundary : gst_multipart_boundary } ) ; dicer . on ( 'part' , function ( part ) { var frameEncoded = '' ; part . setEncoding ( 'base64' ) ; part . on ( 'data' , function ( data ) { frameEncoded += data ; } ) ; part . on ( 'end' , function ( ) { io . sockets . emit ( 'image' , frameEncoded ) ; } ) ; } ) ; dicer . on ( 'finish' , function ( ) { console . log ( 'Dicer finished: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port ) ; } ) ; socket . on ( 'close' , function ( ) { console . log ( 'Socket closed: ' + broadcast_tcp_addr + ':' + broadcast_tcp_port ) ; } ) ; socket . pipe ( dicer ) ; } ) ; } return { 'wrap' : wrap } } 
function LiveCamUI ( ) { const Http = require ( 'http' ) ; const Assert = require ( 'assert' ) ; const template = ( function ( ) { } ) . toString ( ) . match ( / \/\*\s*([\s\S]*?)\s*\*\/ / m ) [ 1 ] ; var server = undefined ; var serve = function ( ui_addr , ui_port , webcam_addr , webcam_port ) { Assert . ok ( typeof ( ui_addr ) , 'object' ) ; Assert . ok ( typeof ( ui_port ) , 'number' ) ; Assert . ok ( typeof ( webcam_addr ) , 'object' ) ; Assert . ok ( typeof ( webcam_port ) , 'number' ) ; close ( ) ; server = Http . createServer ( function ( request , response ) { response . writeHead ( 200 , { "Content-Type" : "text/html" } ) ; response . write ( template . replace ( '@WEBCAM_ADDR@' , webcam_addr ) . replace ( '@WEBCAM_PORT@' , webcam_port ) ) ; response . end ( ) ; } ) ; server . listen ( ui_port , ui_addr ) ; console . log ( 'Open http://' + ui_addr + ':' + ui_port + '/ in your browser!' ) ; } var close = function ( ) { if ( server ) { server . close ( ) ; server = undefined ; } } return { 'serve' : serve , 'close' : close } } 
function LiveCam ( config ) { const Assert = require ( 'assert' ) ; config = config || { } ; Assert . ok ( typeof ( config ) , 'object' ) ; const gst_tcp_addr = config . gst_addr || "127.0.0.1" ; const gst_tcp_port = config . gst_port || 10000 ; const ui_addr = config . ui_addr || "127.0.0.1" ; const ui_port = config . ui_port || 11000 ; const broadcast_addr = config . broadcast_addr || "127.0.0.1" ; const broadcast_port = config . broadcast_port || 12000 ; const start = config . start ; const webcam = config . webcam || { } ; if ( start ) Assert . ok ( typeof ( start ) , 'function' ) ; if ( broadcast_port ) Assert . ok ( typeof ( broadcast_port ) , 'number' ) ; if ( broadcast_addr ) Assert . ok ( typeof ( broadcast_addr ) , 'string' ) ; if ( ui_port ) Assert . ok ( typeof ( ui_port ) , 'number' ) ; if ( ui_addr ) Assert . ok ( typeof ( ui_addr ) , 'string' ) ; if ( gst_tcp_port ) Assert . ok ( typeof ( gst_tcp_port ) , 'number' ) ; if ( gst_tcp_addr ) Assert . ok ( typeof ( gst_tcp_addr ) , 'string' ) ; if ( webcam ) Assert . ok ( typeof ( webcam ) , 'object' ) ; if ( ! ( new GstLaunch ( ) ) . isAvailable ( ) ) { console . log ( "==================================================" ) ; console . log ( "Unable to locate gst-launch executable." ) ; console . log ( "Look at https://github.com/sepehr-laal/livecam" ) ; console . log ( "You are most likely missing the GStreamer runtime." ) ; console . log ( "==================================================" ) ; throw new Error ( 'Unable to broadcast.' ) ; } console . log ( "LiveCam parameters:" , { 'broadcast_addr' : broadcast_addr , 'broadcast_port' : broadcast_port , 'ui_addr' : ui_addr , 'ui_port' : ui_port , 'gst_tcp_addr' : gst_tcp_addr , 'gst_tcp_port' : gst_tcp_port } ) ; var broadcast = function ( ) { var gst_cam_ui = new LiveCamUI ( ) ; var gst_cam_wrap = new SocketCamWrapper ( ) ; var gst_cam_server = new GstLiveCamServer ( webcam ) ; var gst_cam_process = gst_cam_server . start ( gst_tcp_addr , gst_tcp_port ) ; gst_cam_process . stdout . on ( 'data' , function ( data ) { console . log ( data . toString ( ) ) ; 
function hexRgb ( hex ) { let shorthandCheck = / ^([a-f\d])([a-f\d])([a-f\d])$ / i , rgbRegex = / ^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$ / i , rgb ; hex = hex . replace ( shorthandCheck , function ( m , r , g , b ) { return r + r + g + g + b + b ; } ) ; rgb = hex . replace ( / ^\s+|\s+$ / g , '' ) . match ( rgbRegex ) ; 
function ruleHandler ( decl , result ) { let input = decl . value ; 
function Segment ( config ) { this . config = config ; 
function ( ) { for ( var i = 0 ; i < this . config . methods . length ; i ++ ) { var key = this . config . methods [ i ] ; 
function SegmentProvider ( segmentDefaultConfig ) { this . config = angular . copy ( segmentDefaultConfig ) ; 
function es2020 ( filename , options ) { if ( / \.json$ / i . test ( filename ) ) return through ( ) const bufs = [ ] const transformStream = through ( write , end ) return transformStream function write ( buf , enc , next ) { bufs . push ( buf ) next ( ) } function end ( ) { const src = Buffer . concat ( bufs ) . toString ( 'utf8' ) try { var res = babel . transform ( src , { plugins : preset . plugins , sourceMaps : options . _flags . debug ? 'inline' : false , filename : filename , compact : false } ) } catch ( err ) { this . emit ( 'error' , err ) return } this . push ( res . code ) this . push ( null ) } } 
function bulvar ( g ) { g . each ( function ( d , i ) { var rangez = ranges . call ( this , d , i ) . slice ( ) . sort ( d3Descending ) , markerz = markers . call ( this , d , i ) . slice ( ) . sort ( d3Descending ) , measurez = measures . call ( this , d , i ) . slice ( ) . sort ( d3Descending ) , g2 = d3Select ( this ) , extentX , extentY ; var wrap = g2 . select ( "g.wrap" ) ; if ( wrap . empty ( ) ) wrap = g2 . append ( "g" ) . attr ( "class" , "wrap" ) ; if ( vertical ) { extentX = height , extentY = width ; wrap . attr ( "transform" , "rotate(90)translate(0," + - width + ")" ) ; } else { extentX = width , extentY = height ; wrap . attr ( "transform" , null ) ; } 
function generateUuid ( target , namespace , version ) { if ( typeof target !== 'string' ) { throw TypeError ( 'Value must be string' ) ; } if ( typeof namespace === 'number' ) { return generateUuid ( target , undefined , namespace ) ; } if ( version == null ) { return generateUuid ( target , namespace , 5 ) ; } if ( version !== 3 && version !== 5 ) { throw TypeError ( 'Version of UUID can be only 3 or 5' ) ; } 
function getColorGrad ( pct , col , maxBri ) { var no , inc , colors , percentage , rval , gval , bval , lower , upper , range , rangePct , pctLower , pctUpper , color , pow ; no = col . length ; if ( no === 1 ) return col [ 0 ] ; inc = 1 / ( no - 1 ) ; colors = [ ] ; for ( var i = 0 ; i < col . length ; i ++ ) { if ( typeof col [ i ] === 'object' ) { percentage = col [ i ] . pct ? col [ i ] . pct : inc * i ; pow = col [ i ] . pow || 1 ; rval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 0 , 2 ) , 16 ) ; gval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 2 , 4 ) , 16 ) ; bval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 4 , 6 ) , 16 ) ; } else { percentage = inc * i ; pow = 1 ; rval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 0 , 2 ) , 16 ) ; gval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 2 , 4 ) , 16 ) ; bval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 4 , 6 ) , 16 ) ; } colors [ i ] = { pct : percentage , pow : pow , color : { r : rval , g : gval , b : bval } } ; } if ( pct === 0 ) { return 'rgb(' + [ colors [ 0 ] . color . r , colors [ 0 ] . color . g , colors [ 0 ] . color . b ] . join ( ',' ) + ')' ; } for ( var j = 0 ; j < colors . length ; j ++ ) { if ( pct <= colors [ j ] . pct ) { var colorMax = Math . max ( colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ) ; lower = colors [ j - 1 ] ; upper = colors [ j ] ; range = upper . pct - lower . pct ; rangePct = Math . pow ( ( pct - lower . pct ) / range , colors [ j ] . pow / colors [ j - 1 ] . pow ) ; pctLower = 1 - rangePct ; pctUpper = rangePct ; color = { r : Math . floor ( lower . color . r * pctLower + upper . color . r * pctUpper ) , g : Math . floor ( lower . color . g * pctLower + upper . color . g * pctUpper ) , b : Math . floor ( lower . color . b * pctLower + upper . color . b * pctUpper ) } ; if ( maxBri ) { var colorMax2 = Math . max ( color . r , color . g , color . b ) ; return 'rgb(' + [ Math . floor ( color . r / colorMax2 * colorMax ) , Math . floor ( color . g / colorMax2 * colorMax ) , Math . floor ( color . b / colorMax2 * colorMax ) ] . join ( ',' ) + ')' ; } else { return 'rgb(' + [ color . r , color . g , color . b ] . join ( ',' ) + ')' ; } } } } 
function kvLookup ( key , tablea , tableb , defval , datatype , delimiter ) { var val = defval ; var canConvert = false ; if ( ! ( key === null || key === undefined ) ) { if ( tableb !== null && tableb !== undefined && typeof tableb === "object" && key in tableb ) { val = tableb [ key ] ; canConvert = true ; } else if ( tablea !== null && tablea !== undefined && typeof tablea === "object" && key in tablea ) { val = tablea [ key ] ; canConvert = true ; } else { val = defval ; } if ( canConvert === true ) { if ( datatype !== null && datatype !== undefined ) { switch ( datatype ) { case 'int' : val = parseInt ( val , 10 ) ; break ; case 'float' : val = parseFloat ( val ) ; break ; default : break ; } } } } return val ; } 
function getColor ( val , pct , col , noGradient , custSec , fullBri ) { var no , inc , colors , percentage , rval , gval , bval , lower , upper , range , rangePct , pctLower , pctUpper , color , pow ; var noGradient = noGradient || custSec . length > 0 ; if ( custSec . length > 0 ) { for ( var i = 0 ; i < custSec . length ; i ++ ) { if ( val >= custSec [ i ] . lo && val <= custSec [ i ] . hi ) { return custSec [ i ] . color ; } } } no = col . length ; if ( no === 1 ) return col [ 0 ] ; inc = ( noGradient ) ? ( 1 / no ) : ( 1 / ( no - 1 ) ) ; colors = [ ] ; for ( i = 0 ; i < col . length ; i ++ ) { if ( typeof col [ i ] === 'object' ) { percentage = col [ i ] . pct ? col [ i ] . pct : ( ( noGradient ) ? ( inc * ( i + 1 ) ) : ( inc * i ) ) ; pow = col [ i ] . pow || 1 ; rval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 0 , 2 ) , 16 ) ; gval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 2 , 4 ) , 16 ) ; bval = parseInt ( ( cutHex ( col [ i ] . color ) ) . substring ( 4 , 6 ) , 16 ) ; } else { percentage = ( noGradient ) ? ( inc * ( i + 1 ) ) : ( inc * i ) ; pow = 1 ; rval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 0 , 2 ) , 16 ) ; gval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 2 , 4 ) , 16 ) ; bval = parseInt ( ( cutHex ( col [ i ] ) ) . substring ( 4 , 6 ) , 16 ) ; } colors [ i ] = { pct : percentage , pow : pow , color : { r : rval , g : gval , b : bval } } ; } if ( pct === 0 ) { return 'rgb(' + [ colors [ 0 ] . color . r , colors [ 0 ] . color . g , colors [ 0 ] . color . b ] . join ( ',' ) + ')' ; } for ( var j = 0 ; j < colors . length ; j ++ ) { if ( pct <= colors [ j ] . pct ) { var colorMax = Math . max ( colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ) ; if ( noGradient ) { return 'rgb(' + [ colors [ j ] . color . r , colors [ j ] . color . g , colors [ j ] . color . b ] . join ( ',' ) + ')' ; } else { lower = colors [ j - 1 ] ; upper = colors [ j ] ; range = upper . pct - lower . pct ; rangePct = Math . pow ( ( pct - lower . pct ) / range , colors [ j ] . pow / colors [ j - 1 ] . pow ) ; pctLower = 1 - rangePct ; pctUpper = rangePct ; color = { r : Math . floor ( lower . color . r * pctLower + upper . color . r * pctUpper ) , g : Math . floor ( lower . color . g * pctLower + upper . color . g * pctUpper ) , b : Math . floor ( lower . color . b * pctLower + upper . color . b * pctUpper ) } ; if ( fullBri ) { colorMax2 = Math . max ( color . r , color . g , color . b ) ; return 'rgb(' + [ Math . floor ( color . r / colorMax2 * colorMax ) , Math . floor ( color . g / colorMax2 * colorMax ) , Math . floor ( color . b / colorMax2 * colorMax ) ] . join ( ',' ) + ')' ; } else { return 'rgb(' + [ color . r , color . g , color . b ] . join ( ',' ) + ')' ; } } } } } 
function setDy ( elem , fontSize , txtYpos ) { if ( ( ! ie || ie > 9 ) && elem . node . firstChild . attributes . dy ) { elem . node . firstChild . attributes . dy . value = 0 ; } } 
function humanFriendlyNumber ( n , d ) { var p , d2 , i , s ; p = Math . pow ; d2 = p ( 10 , d ) ; i = 7 ; while ( i ) { s = p ( 10 , i -- * 3 ) ; if ( s <= n ) { n = Math . round ( n * d2 / s ) / d2 + "KMGTPE" [ i ] ; } } return n ; } 
function formatNumber ( x ) { var parts = x . toString ( ) . split ( "." ) ; parts [ 0 ] = parts [ 0 ] . replace ( / \B(?=(\d{3})+(?!\d)) / g , "," ) ; return parts . join ( "." ) ; } 
function fmtShort ( ms ) { if ( ms >= d$1 ) { return Math . round ( ms / d$1 ) + 'd' } if ( ms >= h ) { return Math . round ( ms / h ) + 'h' } if ( ms >= m ) { return Math . round ( ms / m ) + 'm' } if ( ms >= s ) { return Math . round ( ms / s ) + 's' } return ms + 'ms' } 
function fmtLong ( ms ) { return plural ( ms , d$1 , 'day' ) || plural ( ms , h , 'hour' ) || plural ( ms , m , 'minute' ) || plural ( ms , s , 'second' ) || ms + ' ms' } 
function debug ( namespace ) { 
function enable ( namespaces ) { exports . save ( namespaces ) ; var split = ( namespaces || '' ) . split ( / [\s,]+ / ) ; var len = split . length ; for ( var i = 0 ; i < len ; i ++ ) { if ( ! split [ i ] ) continue ; 
function ( val , options ) { options = options || { } ; if ( 'string' == typeof val ) return parse$1 ( val ) ; return options . long ? long ( val ) : short ( val ) ; } 
function parse$1 ( str ) { str = '' + str ; if ( str . length > 10000 ) return ; var match = / ^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$ / i . exec ( str ) ; if ( ! match ) return ; var n = parseFloat ( match [ 1 ] ) ; var type = ( match [ 2 ] || 'ms' ) . toLowerCase ( ) ; switch ( type ) { case 'years' : case 'year' : case 'yrs' : case 'yr' : case 'y' : return n * y$1 ; case 'days' : case 'day' : case 'd' : return n * d$2 ; case 'hours' : case 'hour' : case 'hrs' : case 'hr' : case 'h' : return n * h$1 ; case 'minutes' : case 'minute' : case 'mins' : case 'min' : case 'm' : return n * m$1 ; case 'seconds' : case 'second' : case 'secs' : case 'sec' : case 's' : return n * s$1 ; case 'milliseconds' : case 'millisecond' : case 'msecs' : case 'msec' : case 'ms' : return n ; } } 
function short ( ms ) { if ( ms >= d$2 ) return Math . round ( ms / d$2 ) + 'd' ; if ( ms >= h$1 ) return Math . round ( ms / h$1 ) + 'h' ; if ( ms >= m$1 ) return Math . round ( ms / m$1 ) + 'm' ; if ( ms >= s$1 ) return Math . round ( ms / s$1 ) + 's' ; return ms + 'ms' ; } 
function long ( ms ) { return plural$1 ( ms , d$2 , 'day' ) || plural$1 ( ms , h$1 , 'hour' ) || plural$1 ( ms , m$1 , 'minute' ) || plural$1 ( ms , s$1 , 'second' ) || ms + ' ms' ; } 
function plural$1 ( ms , n , name ) { if ( ms < n ) return ; if ( ms < n * 1.5 ) return Math . floor ( ms / n ) + ' ' + name ; return Math . ceil ( ms / n ) + ' ' + name + 's' ; } 
function isBuf$1 ( obj ) { return ( commonjsGlobal . Buffer && commonjsGlobal . Buffer . isBuffer ( obj ) ) || ( commonjsGlobal . ArrayBuffer && obj instanceof ArrayBuffer ) ; } 
function encode$1 ( num ) { var encoded = '' ; do { encoded = alphabet [ num % length ] + encoded ; num = Math . floor ( num / length ) ; } while ( num > 0 ) ; return encoded ; } 
function decode$1 ( str ) { var decoded = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { decoded = decoded * length + map [ str . charAt ( i ) ] ; } return decoded ; } 
function yeast$1 ( ) { var now = encode$1 ( + new Date ( ) ) ; if ( now !== prev ) return seed = 0 , prev = now ; return now + '.' + encode$1 ( seed ++ ) ; } 
function ( val , options ) { options = options || { } ; var type = typeof val ; if ( type === 'string' && val . length > 0 ) { return parse$2 ( val ) } else if ( type === 'number' && isNaN ( val ) === false ) { return options . long ? fmtLong$1 ( val ) : fmtShort$1 ( val ) } throw new Error ( 'val is not a non-empty string or a valid number. val=' + JSON . stringify ( val ) ) } 
function parse$2 ( str ) { str = String ( str ) ; if ( str . length > 10000 ) { return } var match = / ^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$ / i . exec ( str ) ; if ( ! match ) { return } var n = parseFloat ( match [ 1 ] ) ; var type = ( match [ 2 ] || 'ms' ) . toLowerCase ( ) ; switch ( type ) { case 'years' : case 'year' : case 'yrs' : case 'yr' : case 'y' : return n * y$2 case 'days' : case 'day' : case 'd' : return n * d$3 case 'hours' : case 'hour' : case 'hrs' : case 'hr' : case 'h' : return n * h$2 case 'minutes' : case 'minute' : case 'mins' : case 'min' : case 'm' : return n * m$2 case 'seconds' : case 'second' : case 'secs' : case 'sec' : case 's' : return n * s$2 case 'milliseconds' : case 'millisecond' : case 'msecs' : case 'msec' : case 'ms' : return n default : return undefined } } 
function fmtShort$1 ( ms ) { if ( ms >= d$3 ) { return Math . round ( ms / d$3 ) + 'd' } if ( ms >= h$2 ) { return Math . round ( ms / h$2 ) + 'h' } if ( ms >= m$2 ) { return Math . round ( ms / m$2 ) + 'm' } if ( ms >= s$2 ) { return Math . round ( ms / s$2 ) + 's' } return ms + 'ms' } 
function fmtLong$1 ( ms ) { return plural$2 ( ms , d$3 , 'day' ) || plural$2 ( ms , h$2 , 'hour' ) || plural$2 ( ms , m$2 , 'minute' ) || plural$2 ( ms , s$2 , 'second' ) || ms + ' ms' } 
function plural$2 ( ms , n , name ) { if ( ms < n ) { return } if ( ms < n * 1.5 ) { return Math . floor ( ms / n ) + ' ' + name } return Math . ceil ( ms / n ) + ' ' + name + 's' } 
function Polling$1 ( opts ) { var forceBase64 = ( opts && opts . forceBase64 ) ; if ( ! hasXHR2 || forceBase64 ) { this . supportsBinary = false ; } Transport . call ( this , opts ) ; } 
function JSONPPolling ( opts ) { Polling$2 . call ( this , opts ) ; this . query = this . query || { } ; 
function onupgrade ( to ) { if ( transport$$1 && to . name !== transport$$1 . name ) { debug$2 ( '"%s" works - aborting "%s"' , to . name , transport$$1 . name ) ; freezeTransport ( ) ; } } 
function cleanup ( ) { transport$$1 . removeListener ( 'open' , onTransportOpen ) ; transport$$1 . removeListener ( 'error' , onerror ) ; transport$$1 . removeListener ( 'close' , onTransportClose ) ; self . removeListener ( 'close' , onclose ) ; self . removeListener ( 'upgrading' , onupgrade ) ; } 
function Backoff$1 ( opts ) { opts = opts || { } ; this . ms = opts . min || 100 ; this . max = opts . max || 10000 ; this . factor = opts . factor || 2 ; this . jitter = opts . jitter > 0 && opts . jitter <= 1 ? opts . jitter : 0 ; this . attempts = 0 ; } 
function ( val , options ) { options = options || { } ; var type = typeof val ; if ( type === 'string' && val . length > 0 ) { return parse$3 ( val ) ; } else if ( type === 'number' && isNaN ( val ) === false ) { return options . long ? fmtLong$2 ( val ) : fmtShort$2 ( val ) ; } throw new Error ( 'val is not a non-empty string or a valid number. val=' + JSON . stringify ( val ) ) ; } 
function parse$3 ( str ) { str = String ( str ) ; if ( str . length > 100 ) { return ; } var match = / ^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$ / i . exec ( str ) ; if ( ! match ) { return ; } var n = parseFloat ( match [ 1 ] ) ; var type = ( match [ 2 ] || 'ms' ) . toLowerCase ( ) ; switch ( type ) { case 'years' : case 'year' : case 'yrs' : case 'yr' : case 'y' : return n * y$3 ; case 'days' : case 'day' : case 'd' : return n * d$4 ; case 'hours' : case 'hour' : case 'hrs' : case 'hr' : case 'h' : return n * h$3 ; case 'minutes' : case 'minute' : case 'mins' : case 'min' : case 'm' : return n * m$3 ; case 'seconds' : case 'second' : case 'secs' : case 'sec' : case 's' : return n * s$3 ; case 'milliseconds' : case 'millisecond' : case 'msecs' : case 'msec' : case 'ms' : return n ; default : return undefined ; } } 
function fmtShort$2 ( ms ) { if ( ms >= d$4 ) { return Math . round ( ms / d$4 ) + 'd' ; } if ( ms >= h$3 ) { return Math . round ( ms / h$3 ) + 'h' ; } if ( ms >= m$3 ) { return Math . round ( ms / m$3 ) + 'm' ; } if ( ms >= s$3 ) { return Math . round ( ms / s$3 ) + 's' ; } return ms + 'ms' ; } 
function fmtLong$2 ( ms ) { return plural$3 ( ms , d$4 , 'day' ) || plural$3 ( ms , h$3 , 'hour' ) || plural$3 ( ms , m$3 , 'minute' ) || plural$3 ( ms , s$3 , 'second' ) || ms + ' ms' ; } 
function plural$3 ( ms , n , name ) { if ( ms < n ) { return ; } if ( ms < n * 1.5 ) { return Math . floor ( ms / n ) + ' ' + name ; } return Math . ceil ( ms / n ) + ' ' + name + 's' ; } 
function extract ( str , options ) { const res = babylon . parse ( str , options ) ; return res . comments ; } 
function extendApi ( api ) { api . $on = ( eventName , callback ) => { const wrappedCallback = ( ) => { $timeout ( ( ) => { callback ( api . get ( ) ) ; } ) ; } ; api . on ( eventName , wrappedCallback ) ; return ( ) => { api . off ( eventName , wrappedCallback ) ; } ; } ; return api ; } 
function setOptionsWatcher ( api ) { scope . $watch ( 'options' , ( newOptions , oldOptions ) => { if ( angular . equals ( newOptions , oldOptions ) ) { return ; } options = angular . copy ( scope . options ) ; api . updateOptions ( options ) ; } ) ; } 
function bindNgModelControls ( api ) { ngModel . $render = ( ) => { api . set ( ngModel . $modelValue ) ; } ; api . on ( 'update' , ( ) => { const positions = api . get ( ) ; ngModel . $setViewValue ( positions ) ; } ) ; } 
function initializeNgModel ( ) { if ( ngModel === null ) { return $q . resolve ( null ) ; } return $q ( ( resolve ) => { $timeout ( ( ) => { if ( ! ( angular . isArray ( ngModel . $modelValue ) || angular . isNumber ( ngModel . $modelValue ) ) ) { throw new Error ( ` ${ ngModel . $modelValue } ` ) ; } resolve ( ngModel . $modelValue ) ; } ) ; } ) ; } 
function createInstance ( ) { const api = extendApi ( noUiSlider . create ( htmlElement , options ) ) ; setCreatedWatcher ( api ) ; setOptionsWatcher ( api ) ; if ( ngModel !== null ) { bindNgModelControls ( api ) ; } } 
function postprocess ( arr ) { 
function ( w ) { let vow = / [aeiouy]$ / ; let chars = w . split ( '' ) ; let before = '' ; let after = '' ; let current = '' ; for ( let i = 0 ; i < chars . length ; i ++ ) { before = chars . slice ( 0 , i ) . join ( '' ) ; current = chars [ i ] ; after = chars . slice ( i + 1 , chars . length ) . join ( '' ) ; let candidate = before + chars [ i ] ; 
function addApi ( self , apiName , api ) { for ( var name in api ) { var fn = api [ name ] ; if ( typeof fn === "function" ) api [ name ] = api [ name ] . bind ( self ) ; } var tmp = null ; api . replied = new Promise ( ( resolve , reject ) => { tmp = { resolve , reject } ; } ) ; api . replied . resolve = tmp . resolve ; api . replied . reject = tmp . reject ; self [ apiName ] = api ; } 
function getJson ( path ) { return httpGet ( { hostname : t . options . remoteClientHostname , port : t . options . remoteClientPort , path : path , method : 'GET' } ) . then ( ( obj ) => { var contentType = getContentType ( obj . response ) ; if ( contentType !== "application/json" ) LOG . warn ( "Expecting JSON from " + path + " but found wrong content type: " + contentType ) ; try { return JSON . parse ( obj . data ) ; } catch ( ex ) { LOG . warn ( "Cannot parse JSON returned from " + path ) ; return null ; } } ) ; } 
function splitName ( method ) { var pos = method . indexOf ( '.' ) ; if ( pos < 0 ) return [ null , method ] ; var domainName = method . substring ( 0 , pos ) ; var methodName = method . substring ( pos + 1 ) ; return [ domainName , methodName ] ; } 
function copyToClient ( req , res ) { return httpGet ( { hostname : t . options . remoteClientHostname , port : t . options . remoteClientPort , path : req . originalUrl , method : 'GET' } ) . then ( function ( obj ) { var contentType = getContentType ( obj . response ) ; if ( contentType ) res . set ( "Content-Type" , contentType ) ; res . send ( obj . data ) ; } ) ; } 
function promisify ( fn ) { return new Promise ( function ( resolve , reject ) { fn ( function ( err , value ) { if ( err ) reject ( err ) ; else resolve ( value ) ; } ) ; } ) ; } 
function toFixed ( value , precision ) { var power = Math . pow ( 10 , precision ) ; return ( Math . round ( value * power ) / power ) . toFixed ( precision ) ; } 
function ( code , stdout , stderr ) { 
function ( ) { 
function capture ( streams , opts , exec ) { var args = _shift ( opts , exec ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; if ( ! Array . isArray ( streams ) ) { streams = [ streams ] ; } var outputs = [ ] ; streams . forEach ( function ( stream , index ) { outputs [ index ] = '' ; startCapture ( stream , opts , function ( output ) { outputs [ index ] += output ; } ) ; } ) ; exec ( ) ; streams . forEach ( stopCapture ) ; return outputs ; } 
function captureStdio ( opts , exec ) { var streams = [ process . stdout , process . stderr ] ; var outputs = capture ( streams , opts , exec ) ; return { stdout : outputs . shift ( ) , stderr : outputs . shift ( ) } ; } 
function hook ( stream , opts , exec ) { var args = _shift ( opts , exec ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; var old_write = stream . write ; stream . write = ( function override ( stream , writer ) { return function write ( string , encoding , fd ) { exec ( string , encoding , fd ) ; if ( ! opts [ 'quiet' ] ) { writer . apply ( stream , [ string , encoding , fd ] ) ; } } } ) ( stream , stream . write ) ; return function unhook ( ) { stream . write = old_write ; return true ; } } 
function startCapture ( stream , opts , exec ) { var unhook = hook ( stream , opts , exec ) ; var str_id = random . generate ( ) ; unhooks [ str_id ] = unhook ; stream . _id = str_id ; return true ; } 
function _wrapIntercept ( func , stream , opts , exec ) { var idex = Number ( arguments . length > 3 ) ; var args = _shift ( arguments [ idex + 1 ] , arguments [ idex + 2 ] ) ; opts = args [ 0 ] ; exec = args [ 1 ] ; opts . quiet = true ; return idex ? func ( stream , opts , exec ) : func ( opts , exec ) ; } 
function getNearest ( $select , value ) { var delta = { } ; $select . children ( 'option' ) . each ( function ( i , opt ) { var optValue = $ ( opt ) . attr ( 'value' ) , distance ; if ( optValue === '' ) return ; distance = Math . abs ( optValue - value ) ; if ( typeof delta . distance === 'undefined' || distance < delta . distance ) { delta = { value : optValue , distance : distance } ; } } ) ; return delta . value ; } 
function evenRound ( x ) { 
function addFrameAt ( time , value , delay , array ) { array . push ( { time : time , value : value , delay : delay } ) ; } 
function addPreservationFrameAt ( time , value , delay , array ) { addFrameAt ( time , value , delay , array ) ; } 
function relateTime ( time , extendedDur , resolution ) { 
function delay ( data , definedLoop ) { var preDelay = data . sequence [ 0 ] [ definedLoop ? "begin" : "beginStatic" ] ; data . sequence . forEach ( function ( value , i ) { data . sequence [ i ] . begin = value . begin - preDelay ; } ) ; return preDelay ; } 
function isCompatible ( instance ) { var supported = instance . $root . find ( definitions . selectors . supported ) ; var unsupported = instance . $root . find ( definitions . selectors . unsupported ) ; if ( unsupported . length ) { 
function smil2css ( options ) { var defaults = { compress : true , force : false , targetBrowsers : null 
function sentiment ( options ) { return transformer function transformer ( node ) { var concatenate = concatenateFactory ( ) visit ( node , any ( options ) ) visit ( node , concatenate ) concatenate . done ( ) } } 
function concatenateFactory ( ) { var queue = [ ] concatenate . done = done return concatenate 
function one ( node ) { var children = node . children var length = children . length var polarity = 0 var index = - 1 var child var hasNegation while ( ++ index < length ) { child = children [ index ] if ( child . data && child . data . polarity ) { polarity += ( hasNegation ? - 1 : 1 ) * child . data . polarity } 
function done ( ) { var length = queue . length var index = - 1 queue . reverse ( ) while ( ++ index < length ) { one ( queue [ index ] ) } } 
function any ( config ) { return setter 
function patch ( node , polarity ) { var data = node . data || { } data . polarity = polarity || 0 data . valence = classify ( polarity ) node . data = data } 
function isNegation ( node ) { var value value = nlcstToString ( node ) . toLowerCase ( ) if ( value === 'not' || value === 'neither' || value === 'nor' || / n[']t/. t e st(v a lue) ) { return true } return false } 
function fire ( event , target , listener ) { var returned , oldData ; if ( listener . d !== null ) { oldData = event . data ; event . data = listener . d ; returned = listener . h . call ( target , event , target ) ; event . data = oldData ; } else { returned = listener . h . call ( target , event , target ) ; } return returned ; } 
function handle ( listenerList , root , event ) { var listener , returned , specificList , target ; if ( event [ EVENT_IGNORE ] === true ) { return ; } target = event . target ; if ( target . nodeType === Node . TEXT_NODE ) { target = target . parentNode ; } specificList = listenerList [ event . type ] ; 
function on ( that , listenerList , root , eventType , selector , eventData , handler ) { var matcher , matcherParam ; if ( ! eventType ) { throw new TypeError ( 'Invalid event type: ' + eventType ) ; } if ( ! selector ) { throw new TypeError ( 'Invalid selector: ' + selector ) ; } 
function off ( that , listenerList , root , eventType , selector , handler ) { var listener , nextListener , firstListener , specificList , singleEventType ; if ( ! eventType ) { for ( singleEventType in listenerList ) { if ( listenerList . hasOwnProperty ( singleEventType ) ) { off . call ( that , that , listenerList , root , singleEventType , selector , handler ) ; } } return ; } specificList = listenerList [ eventType ] ; if ( ! specificList ) { return ; } 
function Delegate ( root ) { var that = this , listenerList = { } ; if ( typeof root === 'string' ) { root = document . querySelector ( root ) ; } if ( ! root || ! root . addEventListener ) { throw new TypeError ( 'Root node not specified' ) ; } this . on = function ( ) { Array . prototype . unshift . call ( arguments , that , listenerList , root ) ; on . apply ( that , arguments ) ; return this ; } ; this . off = function ( ) { Array . prototype . unshift . call ( arguments , that , listenerList , root ) ; off . apply ( that , arguments ) ; return this ; } ; this . handle = function ( event ) { handle . call ( that , listenerList , root , event ) ; } ; } 
function setArticle ( id ) { database . getAsync ( id , function ( article ) { orange . model . set ( article ) ; orange . render ( ) . setup ( ) ; } ) ; } 
function Module ( options ) { 
function fm ( options ) { var Module = fm . modules [ options . module ] ; if ( Module ) { return new Module ( options ) ; } throw new Error ( "Unable to find module '" + options . module + "'" ) ; } 
function Service ( oodbc , _config ) { this . instanceConfig = _config ; this . databaseConfig = _config . database || "MySQL" ; // this . oodbc = oodbc ; } 
function service ( oodbc , _config ) { if ( _config === undefined ) { throw new TypeError ( 'Expected object for argument _config' ) } if ( ! ( this instanceof Service ) ) { return new Service ( oodbc , _config ) } throw new TypeError ( 'Expected object for argument _config' ) ; } 
function Service ( oodbc , _database , _instance ) { //MYSQL var database = _database || "MYSQL" ; database = database . toUpperCase ( ) ; this . database = database ; var source = oodbc [ database ] ; // if ( source ) { // var dbsource = source [ _instance . toUpperCase ( ) ] ; if ( dbsource ) { // this . db = dbsource ; } else { console . log ( '' + _instance.toUpperCase() + '  ); throw new TypeError ( '' + _instance.toUpperCase() + '  ); } } else { console . log ( '' + this.database.toUpperCase() + '  ' ) ; throw new TypeError ( '' + this.database.toUpperCase() + '  ' ) ; } } 
function ( instance , sql , parameters ) { return new Promise ( function ( resolve , reject ) { // console . time ( 'onelaSQL'); //console.log('sql', sql, '', parameters); if ( instance ) { instance . query ( sql , parameters , function ( err , doc ) { console . timeEnd ( 'onelaSQL'); if ( err ) { reject ( err ) ; } else { resolve ( doc ) ; } } ) ; } else { reject ( "instanceoodbconelaInstanceConfig.json"); } } ) ; } 
function ( structure = [ ] ) { return new Promise ( ( resolve , reject ) => { if ( Array . isArray ( structure ) === false ) { throw new Error ( ` ` ) } parseStructure ( structure , opts . cwd ) . then ( ( parsedStructure ) => writeStructure ( parsedStructure ) ) . then ( ( parsedStructure ) => binStructure ( parsedStructure , bin , opts . persistent ) ) . then ( resolve , reject ) } ) } 
function addAndWhereDate ( queryBuilder , column , from , to ) { if ( from && to ) { queryBuilder . whereBetween ( column , [ from , to ] ) ; } else if ( from ) { queryBuilder . andWhere ( column , '>=' , from ) ; } else if ( to ) { queryBuilder . andWhere ( column , '<=' , to ) ; } } 
function _handleMultiValuedParameters ( knexBuilder , attrName , parameter ) { if ( parameter instanceof Set ) { knexBuilder = knexBuilder . whereIn ( attrName , Array . from ( parameter ) ) ; } else if ( Array . isArray ( parameter ) ) { knexBuilder = knexBuilder . whereIn ( attrName , parameter ) ; } else { knexBuilder = knexBuilder . where ( attrName , parameter ) ; } return knexBuilder ; } 
function cleanDb ( knex , tableNames , logger , verboseLog = false ) { validate . notNil ( tableNames ) ; return tableCleaner . cleanTables ( knex , tableNames , verboseLog ) . then ( ( ) => { if ( logger ) { logger . info ( 'Tables cleaned successfully: ' , tableNames . join ( ', ' ) ) ; } } ) . catch ( err => { if ( logger ) { logger . error ( 'Error cleaning tables' , err ) ; } throw err ; } ) ; } 
function getKnexInstance ( config , registry = _registry , logger = console ) { validate . notNil ( config , 'Config is null or undefined' ) ; validate . notNil ( config . client , 'DB client is null or undefined' ) ; const { host , database , user } = config . connection ; const connectionTimeout = config . acquireConnectionTimeout ; logger . info ( ` ${ user } ${ host } ${ database } ` ) ; logger . info ( ` ${ connectionTimeout } ` ) ; const knex = module . exports . _initKnexInstance ( config ) ; module . exports . registerKnexInstance ( knex , registry ) ; // unfortunately, we can't check heartbeat here and fail-fast, as this initialization is synchronous return knex ; } 
function closeAllInstances ( registry = _registry ) { const promises = [ ] ; const errors = [ ] ; while ( registry . length > 0 ) { const knex = registry . pop ( ) ; const destructionPromise = knex . destroy ( ) . catch ( e => { errors . push ( { knex , cause : e } ) ; } ) ; promises . push ( destructionPromise ) ; } return Promise . all ( promises ) . then ( ( ) => { return errors ; } ) ; } 
function remarkCustomTags ( customTags ) { return ast => visit ( ast , 'html' , node => { if ( node . value . startsWith ( '<x-' ) ) { 
function remarkHljs ( { aliases } ) { return ast => visit ( ast , 'code' , node => { if ( ! node . data ) { node . data = { } ; } const lang = node . lang ; const highlighted = lang ? low . highlight ( aliases [ lang ] || lang , node . value ) . value : low . highlightAuto ( node . value ) . value ; node . data . hChildren = highlighted ; node . data . hProperties = { className : [ 'hljs' , lang && ` ${ lang } ` ] , } ; } ) ; } 
function render ( processor , source ) { try { return processor . processSync ( source ) . contents ; } catch ( exception ) { const error = ` ${ exception . message } ` ; console . error ( error ) ; return errorInlineHtml ( error ) . toString ( ) ; } } 
function readTemplate ( doc ) { return fs . readFileAsync ( flags . template , "utf8" ) . then ( template => ( { doc , template } ) ) ; } 
function createColorArrow ( defElement , color ) { defElement . append ( "marker" ) . attr ( "id" , "arrow-" + color ) . attr ( "viewBox" , "0 -5 10 10" ) . attr ( "refX" , 8 ) . attr ( "markerWidth" , 6 ) . attr ( "markerHeight" , 6 ) . attr ( "fill" , color ) . attr ( "orient" , "auto" ) . append ( "path" ) . attr ( "d" , "M0,-5L10,0L0,5" ) . attr ( "class" , "arrowHead" ) ; } 
function cssValues ( property , value ) { if ( typeof value === 'string' ) { value = valueParser ( value ) ; } var first = value . nodes [ 0 ] ; if ( value . nodes . length === 1 && ( isKeyword ( first , cssGlobals ) || isVariable ( first ) ) ) { return true ; } if ( validators [ property ] ) { var result = validators [ property ] ( value ) ; if ( result . type ) { return result ; } if ( ! ! result === false ) { return invalidMessage ( '"' + value + '" is not a valid value for "' + property + '".' ) ; } return true ; } 
function valueParserNodesLength ( length , operator = '===' ) { return t . binaryExpression ( operator , valueParserASTNodesLength , t . numericLiteral ( length ) ) ; } 
function ( data ) { data = ( data || "" ) . toString ( ) . trim ( ) ; _ . any ( SEL_LOG_COLORS , function ( val , key ) { if ( data . indexOf ( key ) > NOT_FOUND ) { data = data . split ( key ) . join ( key [ val ] ) ; return true ; } } ) ; return data ; } 
function known ( parsed ) { return parsed . every ( node => { return node . type === 'keyword' || node . type === 'string' || node . type === 'group' && ! node . order && ! node . min && node . values . every ( n => n . type === 'keyword' ) || ( node . type === 'data' && validators [ dataValidator ( node . value ) ] ) ; 
function decrypt ( buf , key ) { key = ripemd128 . ripemd128 ( key ) ; var byte , keylen = key . length , prev = 0x36 , i = 0 , len = buf . length ; for ( ; i < len ; i ++ ) { byte = buf [ i ] ; byte = ( ( byte >> 4 ) | ( byte << 4 ) ) ; 
function spreadus ( ) { var args = Array . prototype . slice . apply ( arguments ) ; args . _spreadus_ = true ; return args ; } 
function sliceThen ( file , offset , len ) { var p = new Promise ( function ( _resolve ) { fs . open ( file , 'r' , function ( err , fd ) { if ( err ) { throw err ; } var res = new Buffer ( len ) ; fs . read ( fd , res , 0 , len , offset , function ( err , bytesRead , buffer ) { if ( err ) { throw err ; } _resolve ( buffer ) ; } ) ; } ) ; } ) ; p . exec = function ( proc ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; return p . then ( function ( data ) { args . unshift ( data ) ; var ret = proc . apply ( null , args ) ; return resolve ( ret !== UNDEFINED && ret . _spreadus_ ? ret : [ ret ] ) ; } ) ; } ; return p ; } 
function harvest ( outcomes ) { return Promise . settle ( outcomes ) . then ( function ( results ) { if ( results . length === 0 ) { return reject ( "** NOT FOUND **" ) ; } var solved = [ ] , failed = [ ] ; for ( var i = 0 ; i < results . length ; i ++ ) { if ( results [ i ] . isResolved ( ) ) { solved . push ( results [ i ] . value ( ) ) ; } else { failed . push ( results [ i ] . reason ( ) ) ; } } return solved . length ? solved : failed ; } ) ; } 
function createRecordBlockTable ( ) { var pos = 0 , 
function ( keyAt ) { var hi = ( arr . length >> 1 ) - 1 , lo = 0 , i = ( lo + hi ) >> 1 , val = arr [ ( i << 1 ) + 1 ] ; if ( keyAt > arr [ ( hi << 1 ) + 1 ] || keyAt < 0 ) { return ; } while ( true ) { if ( hi - lo <= 1 ) { if ( i < hi ) { return { block_no : i , comp_offset : arr [ i <<= 1 ] , comp_size : arr [ i + 2 ] - arr [ i ] , decomp_offset : arr [ i + 1 ] , decomp_size : arr [ i + 3 ] - arr [ i + 1 ] } ; } else { return ; } } ( keyAt < val ) ? hi = i : lo = i ; i = ( lo + hi ) >> 1 ; val = arr [ ( i << 1 ) + 1 ] ; } } 
function parse_mdict ( file , ext ) { var KEY_INDEX , * Config scanner according to dictionary attributes. */ function config ( ) { attrs . Encoding = attrs . Encoding || 'UTF-16' ; _searchTextLen = ( attrs . Encoding === 'UTF-16' ) ? function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint16 ( offset ++ ) ) { } ; return offset - mark ; } : function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint8 ( offset ++ ) ) { } return offset - mark - 1 ; } ; _decoder = new TextDecoder ( attrs . Encoding || 'UTF-16LE' ) ; _bpu = ( attrs . Encoding === 'UTF-16' ) ? 2 : 1 ; if ( parseInt ( attrs . GeneratedByEngineVersion , 10 ) >= 2.0 ) { _v2 = true ; _tail = _bpu ; * Read the first 4 bytes of mdx/mdd file to get length of header_str. * @see https: * @param input sliced file (start = 0, length = 4) * @return length of header_str */ function read_file_head ( input ) { return Scanner ( input ) . readInt ( ) ; } function read_header_sect ( input , len ) { var scanner = Scanner ( input ) , header_str = scanner . readUTF16 ( len ) . replace ( / \0$ / , '' ) ; * Read keyword summary at the begining of keyword section. * @see https: * @param input sliced file, same as input passed to read_header_sect() * @param offset start position of keyword section in sliced file, equals to length of header string plus checksum.\ * @return keyword_sect object */ function read_keyword_summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , key_index_decomp_len : _v2 && scanner . readNum ( ) , * Read keyword index part of keyword section. * @see https: * @see https: * @param input sliced file, remained part of keyword section after keyword summary which can also be used to read following key blocks. * @param keyword_summary * @return [keyword_summary, array of keyword index] */ function read_keyword_index ( input , keyword_summary ) { var scanner = Scanner ( input ) . readBlock ( keyword_summary . key_index_comp_len , keyword_summary . key_index_decomp_len , _decryptors [ 1 ] ) , keyword_index = Array ( keyword_summary . num_blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword_summary . num_blocks ; i ++ ) { keyword_index [ i ] = { num_entries : conseq ( scanner . readNum ( ) , size = scanner . readShort ( ) ) , * Read keyword entries inside a keyword block and fill KEY_TABLE. * @param scanner scanner object to read key entries, which starts at begining of target key block * @param kdx corresponding keyword index object * NOTE: no need to read keyword block anymore, for debug only. */ function read_key_block ( scanner , kdx ) { var scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { * Delay to scan key table, for debug onyl. * @param slicedKeyBlock a promise object which will resolve to an ArrayBuffer containing keyword blocks * sliced from mdx/mdd file. * @param num_entries number of keyword entries * @param keyword_index array of keyword index * @param delay time to delay for scanning key table */ function willScanKeyTable ( slicedKeyBlock , num_entries , keyword_index , delay ) { slicedKeyBlock . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword_index . length ; i < size ; i ++ ) { * Read record summary at the begining of record section. * @see https: * @param input sliced file, start = begining of record section, length = 32 (max length of record summary) * @param pos begining of record section * @returj record summary object */ function read_record_summary ( input , pos ) { var scanner = Scanner ( input ) , record_summary = { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , index_len : scanner . readNum ( ) , blocks_len : scanner . readNum ( ) , * Read record block index part in record section, and fill RECORD_BLOCK_TABLE * @see https: * @param input sliced file, start = begining of record block index, length = record_summary.index_len * @param record_summary record summary object */ function read_record_block ( input , record_summary ) { var scanner = Scanner ( input ) , size = record_summary . num_blocks , record_index = Array ( size ) , p0 = record_summary . block_pos , p1 = 0 ; RECORD_BLOCK_TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i ++ ) { record_index [ i ] = rdx = { comp_size : scanner . readNum ( ) , decomp_size : scanner . readNum ( ) } ; RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; p0 += rdx . comp_size ; p1 += rdx . decomp_size ; } RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; } function read_definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readText ( ) ; } function followLink ( definition , lookup ) { return ( definition . substring ( 0 , 8 ) !== '@@@LINK=' ) ? definition : lookup ( definition . substring ( 8 ) ) ; } function read_object ( input , block , keyinfo ) { if ( input . byteLength > 0 ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readRaw ( keyinfo . size ) ; } else { throw '* OUT OF FILE RANGE * ' + keyinfo + ' @offset=' + block . comp_offset ; } } function findWord ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( followLink ( definition , LOOKUP . mdx ) ) ; } ) ; } function findResource ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_object , block , keyinfo ) . spread ( function ( blob ) { return resolve ( blob ) ; } ) ; } * Reduce the key index array to an element which contains or is the nearest one matching a given phrase. */ function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len >> 1 ; return phrase > _adaptKey ( arr [ len - 1 ] . last_word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } } function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len >> 1 ; var key = _adaptKey ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos || 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos || 0 ) + ( phrase <= _adaptKey ( arr [ 0 ] ) ? 0 : 1 ) ; } } function loadKeys ( kdx ) { if ( _cached_keys && _cached_keys . pilot === kdx . first_word ) { return resolve ( _cached_keys . list ) ; } else { return slicedKeyBlock . then ( function ( input ) { var scanner = Scanner ( input ) , list = Array ( kdx . num_entries ) ; scanner . forward ( kdx . offset ) ; scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { var offset = scanner . readNum ( ) ; list [ i ] = new Object ( scanner . readText ( ) ) ; list [ i ] . offset = offset ; if ( i > 0 ) { list [ i - 1 ] . size = offset - list [ i - 1 ] . offset ; } } _cached_keys = { list : list , pilot : kdx . first_word } ; return list ; } ) ; } } function seekVanguard ( phrase ) { phrase = _adaptKey ( phrase ) ; var kdx = reduce ( KEY_INDEX , phrase ) ; * Append more to word list according to a filter or expected size. */ function appendMore ( word , list , nextKdx , expectedSize , filter , ticket ) { if ( ticket !== mutual_ticket ) { throw 'force terminated' ; } if ( filter ) { if ( _trail . count < expectedSize && nextKdx && nextKdx . first_word . substr ( 0 , word . length ) === word ) { return loadKeys ( nextKdx ) . delay ( 30 ) . then ( function ( more ) { _trail . offset = 0 ; _trail . block = nextKdx . index ; Array . prototype . push . apply ( list , more . filter ( filter , _trail ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( list . length === 0 ) { _trail . exhausted = true ; } return resolve ( list ) ; } } else { var shortage = expectedSize - list . length ; if ( shortage > 0 && nextKdx ) { _trail . block = nextKdx . index ; return loadKeys ( nextKdx ) . then ( function ( more ) { _trail . offset = 0 ; _trail . pos = Math . min ( shortage , more . length ) ; Array . prototype . push . apply ( list , more . slice ( 0 , shortage ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( _trail . pos > expectedSize ) { _trail . pos = expectedSize ; } list = list . slice ( 0 , expectedSize ) ; _trail . count = list . length ; _trail . total += _trail . count ; return resolve ( list ) ; } } } function followUp ( ) { var kdx = KEY_INDEX [ _trail . block ] ; return loadKeys ( kdx ) . then ( function ( list ) { return [ kdx , Math . min ( _trail . offset + _trail . pos , list . length - 1 ) , list ] ; } ) ; } function matchKeys ( phrase , expectedSize , follow ) { expectedSize = Math . max ( expectedSize || 0 , 10 ) ; var str = phrase . trim ( ) . toLowerCase ( ) , m = / ([^?*]+)[?*]+ / . exec ( str ) , word ; if ( m ) { word = m [ 1 ] ; var wildcard = new RegExp ( '^' + str . replace ( / ([\.\\\+\[\^\]\$\(\)]) / g , '\\$1' ) . replace ( / \*+ / g , '.*' ) . replace ( / \? / g , '.' ) + '$' ) , tester = phrase [ phrase . length - 1 ] === ' ' ? function ( s ) { return wildcard . test ( s ) ; } : function ( s ) { return wildcard . test ( s ) && ! / / . test ( s ) ; } , filter = function ( s , i ) { if ( _trail . count < expectedSize && tester ( s ) ) { _trail . count ++ ; _trail . total ++ ; _trail . pos = i + 1 ; return true ; } return false ; } ; } else { word = phrase . trim ( ) ; } if ( _trail && _trail . phrase !== phrase ) { follow = false ; } if ( follow && _trail && _trail . exhausted ) { return resolve ( [ ] ) ; } var startFrom = follow && _trail ? followUp ( ) : seekVanguard ( word ) ; return startFrom . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; _trail = { phrase : phrase , block : kdx . index , offset : idx , pos : list . length , count : 0 , total : follow ? _trail && _trail . total || 0 : 0 } ; if ( filter ) { list = list . filter ( filter , _trail ) ; } return appendMore ( word , list , KEY_INDEX [ kdx . index + 1 ] , expectedSize , filter , ++ mutual_ticket ) . then ( function ( result ) { if ( _trail . block === KEY_INDEX . length - 1 ) { if ( _trail . offset + _trail . pos >= KEY_INDEX [ _trail . block ] . num_entries ) { _trail . exhausted = true ; * Match the first element in list with given offset. */ function matchOffset ( list , offset ) { return list . some ( function ( el ) { return el . offset === offset ? list = [ el ] : false ; } ) ? list : [ ] ; } * @param query * String * {phrase: .., max: .., follow: true} object */ mdx : function ( query ) { if ( typeof query === 'string' || query instanceof String ) { _trail = null ; var word = query . trim ( ) . toLowerCase ( ) , offset = query . offset ; return seekVanguard ( word ) . spread ( function ( kdx , idx , list ) { list = list . slice ( idx ) ; if ( offset !== UNDEFINED ) { list = matchOffset ( list , offset ) ; } else { list = list . filter ( function ( el ) { return el . toLowerCase ( ) === word ; } ) ; } return harvest ( list . map ( findWord ) ) ; } ) ; } else { return matchKeys ( query . phrase , query . max , query . follow ) ; } } , 
function config ( ) { attrs . Encoding = attrs . Encoding || 'UTF-16' ; _searchTextLen = ( attrs . Encoding === 'UTF-16' ) ? function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint16 ( offset ++ ) ) { } ; return offset - mark ; } : function ( dv , offset ) { offset = offset ; var mark = offset ; while ( dv . getUint8 ( offset ++ ) ) { } return offset - mark - 1 ; } ; _decoder = new TextDecoder ( attrs . Encoding || 'UTF-16LE' ) ; _bpu = ( attrs . Encoding === 'UTF-16' ) ? 2 : 1 ; if ( parseInt ( attrs . GeneratedByEngineVersion , 10 ) >= 2.0 ) { _v2 = true ; _tail = _bpu ; 
function Scanner ( buf , len ) { var offset = 0 , dv = new DataView ( buf ) ; var methods = { 
function ( ) { var len = _searchTextLen ( dv , offset ) ; return conseq ( _decoder . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len + _bpu ) ) ; } 
function ( len ) { len *= _bpu ; var read = conseq ( _decoder . decode ( newUint8Array ( buf , offset , len ) ) , this . forward ( len + _tail ) ) ; return read ; } 
function ( len , expectedBufSize , decryptor ) { var comp_type = dv . getUint8 ( offset , false ) ; 
function ( len ) { return conseq ( newUint8Array ( buf , offset , len ) , this . forward ( len === UNDEFINED ? buf . length - offset : len ) ) ; } 
function read_header_sect ( input , len ) { var scanner = Scanner ( input ) , header_str = scanner . readUTF16 ( len ) . replace ( / \0$ / , '' ) ; 
function read_keyword_summary ( input , offset ) { var scanner = Scanner ( input ) ; scanner . forward ( offset ) ; return { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , key_index_decomp_len : _v2 && scanner . readNum ( ) , 
function read_keyword_index ( input , keyword_summary ) { var scanner = Scanner ( input ) . readBlock ( keyword_summary . key_index_comp_len , keyword_summary . key_index_decomp_len , _decryptors [ 1 ] ) , keyword_index = Array ( keyword_summary . num_blocks ) , offset = 0 ; for ( var i = 0 , size ; i < keyword_summary . num_blocks ; i ++ ) { keyword_index [ i ] = { num_entries : conseq ( scanner . readNum ( ) , size = scanner . readShort ( ) ) , 
function read_key_block ( scanner , kdx ) { var scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { 
function willScanKeyTable ( slicedKeyBlock , num_entries , keyword_index , delay ) { slicedKeyBlock . delay ( delay ) . then ( function ( input ) { var scanner = Scanner ( input ) ; for ( var i = 0 , size = keyword_index . length ; i < size ; i ++ ) { 
function read_record_summary ( input , pos ) { var scanner = Scanner ( input ) , record_summary = { num_blocks : scanner . readNum ( ) , num_entries : scanner . readNum ( ) , index_len : scanner . readNum ( ) , blocks_len : scanner . readNum ( ) , 
function read_record_block ( input , record_summary ) { var scanner = Scanner ( input ) , size = record_summary . num_blocks , record_index = Array ( size ) , p0 = record_summary . block_pos , p1 = 0 ; RECORD_BLOCK_TABLE . alloc ( size + 1 ) ; for ( var i = 0 , rdx ; i < size ; i ++ ) { record_index [ i ] = rdx = { comp_size : scanner . readNum ( ) , decomp_size : scanner . readNum ( ) } ; RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; p0 += rdx . comp_size ; p1 += rdx . decomp_size ; } RECORD_BLOCK_TABLE . put ( p0 , p1 ) ; } 
function read_definition ( input , block , keyinfo ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readText ( ) ; } 
function read_object ( input , block , keyinfo ) { if ( input . byteLength > 0 ) { var scanner = Scanner ( input ) . readBlock ( block . comp_size , block . decomp_size ) ; scanner . forward ( keyinfo . offset - block . decomp_offset ) ; return scanner . readRaw ( keyinfo . size ) ; } else { throw '* OUT OF FILE RANGE * ' + keyinfo + ' @offset=' + block . comp_offset ; } } 
function findWord ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_definition , block , keyinfo ) . spread ( function ( definition ) { return resolve ( followLink ( definition , LOOKUP . mdx ) ) ; } ) ; } 
function findResource ( keyinfo ) { var block = RECORD_BLOCK_TABLE . find ( keyinfo . offset ) ; return _slice ( block . comp_offset , block . comp_size ) . exec ( read_object , block , keyinfo ) . spread ( function ( blob ) { return resolve ( blob ) ; } ) ; } 
function reduce ( arr , phrase ) { var len = arr . length ; if ( len > 1 ) { len = len >> 1 ; return phrase > _adaptKey ( arr [ len - 1 ] . last_word ) ? reduce ( arr . slice ( len ) , phrase ) : reduce ( arr . slice ( 0 , len ) , phrase ) ; } else { return arr [ 0 ] ; } } 
function shrink ( arr , phrase ) { var len = arr . length , sub ; if ( len > 1 ) { len = len >> 1 ; var key = _adaptKey ( arr [ len ] ) ; if ( phrase < key ) { sub = arr . slice ( 0 , len ) ; sub . pos = arr . pos ; } else { sub = arr . slice ( len ) ; sub . pos = ( arr . pos || 0 ) + len ; } return shrink ( sub , phrase ) ; } else { return ( arr . pos || 0 ) + ( phrase <= _adaptKey ( arr [ 0 ] ) ? 0 : 1 ) ; } } 
function loadKeys ( kdx ) { if ( _cached_keys && _cached_keys . pilot === kdx . first_word ) { return resolve ( _cached_keys . list ) ; } else { return slicedKeyBlock . then ( function ( input ) { var scanner = Scanner ( input ) , list = Array ( kdx . num_entries ) ; scanner . forward ( kdx . offset ) ; scanner = scanner . readBlock ( kdx . comp_size , kdx . decomp_size ) ; for ( var i = 0 ; i < kdx . num_entries ; i ++ ) { var offset = scanner . readNum ( ) ; list [ i ] = new Object ( scanner . readText ( ) ) ; list [ i ] . offset = offset ; if ( i > 0 ) { list [ i - 1 ] . size = offset - list [ i - 1 ] . offset ; } } _cached_keys = { list : list , pilot : kdx . first_word } ; return list ; } ) ; } } 
function seekVanguard ( phrase ) { phrase = _adaptKey ( phrase ) ; var kdx = reduce ( KEY_INDEX , phrase ) ; 
function appendMore ( word , list , nextKdx , expectedSize , filter , ticket ) { if ( ticket !== mutual_ticket ) { throw 'force terminated' ; } if ( filter ) { if ( _trail . count < expectedSize && nextKdx && nextKdx . first_word . substr ( 0 , word . length ) === word ) { return loadKeys ( nextKdx ) . delay ( 30 ) . then ( function ( more ) { _trail . offset = 0 ; _trail . block = nextKdx . index ; Array . prototype . push . apply ( list , more . filter ( filter , _trail ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( list . length === 0 ) { _trail . exhausted = true ; } return resolve ( list ) ; } } else { var shortage = expectedSize - list . length ; if ( shortage > 0 && nextKdx ) { _trail . block = nextKdx . index ; return loadKeys ( nextKdx ) . then ( function ( more ) { _trail . offset = 0 ; _trail . pos = Math . min ( shortage , more . length ) ; Array . prototype . push . apply ( list , more . slice ( 0 , shortage ) ) ; return appendMore ( word , list , KEY_INDEX [ nextKdx . index + 1 ] , expectedSize , filter , ticket ) ; } ) ; } else { if ( _trail . pos > expectedSize ) { _trail . pos = expectedSize ; } list = list . slice ( 0 , expectedSize ) ; _trail . count = list . length ; _trail . total += _trail . count ; return resolve ( list ) ; } } } 
function matchOffset ( list , offset ) { return list . some ( function ( el ) { return el . offset === offset ? list = [ el ] : false ; } ) ? list : [ ] ; } 
function ( phrase ) { var word = phrase . trim ( ) . toLowerCase ( ) ; word = '\\' + word . replace ( / (^[/\\])|([/]$) / , '' ) ; word = word . replace ( / \/ / g , '\\' ) ; return seekVanguard ( word ) . spread ( function ( kdx , idx , list ) { return list . slice ( idx ) . filter ( function ( one ) { return one . toLowerCase ( ) === word ; } ) ; } ) . then ( function ( candidates ) { if ( candidates . length === 0 ) { throw '*RESOURCE NOT FOUND* ' + phrase ; } else { return findResource ( candidates [ 0 ] ) ; } } ) ; } 
function isValidModifierKeyCombo ( modifierKeys , e ) { var modifierKeyNames = [ 'alt' , 'ctrl' , 'meta' , 'shift' ] , numModKeys = modifierKeys . length , i , j , currModifierKey , isValid = true ; 
function createKeyComboFunction ( keyFunc , modifierKeys ) { return function ( keyCode , modifierKeyNames ) { var i , keyCombo = '' ; if ( arguments . length ) { if ( typeof keyCode === 'number' ) { keyFunc ( keyCode ) ; modifierKeys . length = 0 ; 
function overrideKeyDown ( e ) { e = e || event ; 
function overrideKeyPress ( e ) { e = e || event ; var key = e . keyCode ; if ( tabKeyComboPressed ( key , e ) || untabKeyComboPressed ( key , e ) || ( key === 13 && autoIndent && ! inWhitespace ) ) { if ( e . preventDefault ) { e . preventDefault ( ) ; } else { e . returnValue = false ; return false ; } } } 
function executeExtensions ( hook , args ) { var i , extensions = hooks [ hook ] || [ ] , len = extensions . length ; for ( i = 0 ; i < len ; i += 1 ) { extensions [ i ] . apply ( null , args ) ; } } 
function createListeners ( handlerList ) { var i , len = handlerList . length , remove , add ; function loop ( func ) { for ( i = 0 ; i < len ; i += 1 ) { func ( handlerList [ i ] . type , handlerList [ i ] . handler ) ; } } 
function generateImagesToPreload ( totalImages ) { for ( var i = 0 , images = [ ] , index ; i < totalImages ; i ++ ) { index = ( i < 10 ) ? '0' + i : i images . push ( 'https://github.com/rbartoli/threesixty/raw/master/example/images/sequence-' + index + '.png' ) } return images } 
function ( imapMessage ) { var deferred = Q . defer ( ) ; var message = new Message ( ) ; imapMessage . on ( 'body' , function ( stream , info ) { var buffer = '' ; stream . on ( 'data' , function ( chunk ) { buffer += chunk . toString ( 'utf8' ) ; } ) ; stream . on ( 'end' , function ( ) { if ( info . which === 'TEXT' ) { message . body = buffer ; } else { message . headers = Imap . parseHeader ( buffer ) ; } } ) ; } ) ; imapMessage . on ( 'attributes' , function ( attrs ) { message . attributes = attrs ; } ) ; imapMessage . on ( 'end' , function ( ) { deferred . resolve ( message ) ; } ) ; return deferred . promise ; } 
function GPT ( options ) { if ( ! ( this instanceof GPT ) ) { return new GPT ( options ) } options = options != null ? options : { } this . blockSize = options . blockSize || 512 this . guid = options . guid || GPT . GUID . ZERO this . revision = options . revision || 0 this . headerSize = options . headerSize || GPT . HEADER_SIZE this . headerChecksum = 0 this . currentLBA = options . currentLBA || 1 this . backupLBA = options . backupLBA || 0 this . firstLBA = options . firstLBA || 34 this . lastLBA = options . lastLBA || 0 this . tableOffset = options . tableOffset || GPT . TABLE_OFFSET this . entries = options . entries || GPT . TABLE_ENTRIES this . entrySize = options . entrySize || GPT . TABLE_ENTRY_SIZE this . tableChecksum = 0 
function normalizeString ( path , allowAboveRoot ) { var res = '' var lastSegmentLength = 0 var lastSlash = - 1 var dots = 0 var code for ( var i = 0 ; i <= path . length ; i += 1 ) { if ( i < path . length ) code = path . charCodeAt ( i ) else if ( code === CHAR_FORWARD_SLASH ) break else code = CHAR_FORWARD_SLASH if ( code === CHAR_FORWARD_SLASH ) { if ( lastSlash === i - 1 || dots === 1 ) { 
function resolve ( ) { var resolvedPath = '' var resolvedAbsolute = false var cwd for ( var i = arguments . length - 1 ; i >= - 1 && ! resolvedAbsolute ; i -= 1 ) { var path if ( i >= 0 ) { path = arguments [ i ] } else { if ( cwd === undefined ) { cwd = posix . dirname ( sketchSpecifics . cwd ( ) ) } path = cwd } path = sketchSpecifics . getString ( path , 'path' ) 
function readBackupGPT ( primaryGPT ) { var backupGPT = new GPT ( { blockSize : primaryGPT . blockSize } ) var buffer = Buffer . alloc ( 33 * primaryGPT . blockSize ) var offset = ( ( primaryGPT . backupLBA - 32 ) * blockSize ) fs . readSync ( fd , buffer , 0 , buffer . length , offset ) backupGPT . parseBackup ( buffer ) return backupGPT } 
function PartitionEntry ( options ) { if ( ! ( this instanceof PartitionEntry ) ) { return new PartitionEntry ( options ) } options = options != null ? options : { } this . type = options . type || GUID . ZERO this . guid = options . guid || GUID . ZERO this . name = options . name || '' this . firstLBA = options . firstLBA || 0 this . lastLBA = options . lastLBA || 0 
function stopcock ( fn , options ) { options = Object . assign ( { queueSize : Math . pow ( 2 , 32 ) - 1 , bucketSize : 40 , interval : 1000 , limit : 2 } , options ) ; const bucket = new TokenBucket ( options ) ; const queue = [ ] ; let timer = null ; function shift ( ) { clearTimeout ( timer ) ; while ( queue . length ) { const delay = bucket . consume ( ) ; if ( delay > 0 ) { timer = setTimeout ( shift , delay ) ; break ; } const data = queue . shift ( ) ; data [ 2 ] ( fn . apply ( data [ 0 ] , data [ 1 ] ) ) ; } } function limiter ( ) { const args = arguments ; return new Promise ( ( resolve , reject ) => { if ( queue . length === options . queueSize ) { return reject ( new Error ( 'Queue is full' ) ) ; } queue . push ( [ this , args , resolve ] ) ; shift ( ) ; } ) ; } Object . defineProperty ( limiter , 'size' , { get : ( ) => queue . length } ) ; return limiter ; } 
function formatQuantity ( value , encode , pad ) { if ( [ 'string' , 'number' , 'object' ] . indexOf ( typeof value ) === - 1 || value === null ) { return value ; } const numberValue = numberToBN ( value ) ; const numPadding = numberValue . lt ( ten ) && pad === true && ! numberValue . isZero ( ) ? '0' : '' ; if ( numberToBN ( value ) . isNeg ( ) ) { throw new Error ( ` ${ numberValue . toString ( 10 ) } ` ) ; } return encode ? ` ${ numPadding } ${ numberValue . toString ( 16 ) } ` : numberValue ; } 
function formatQuantityOrTag ( value , encode ) { var output = value ; 
function formatData ( value , byteLength ) { var output = value ; 
function formatObject ( formatter , value , encode ) { var output = Object . assign ( { } , value ) ; 
function formatArray ( formatter , value , encode , lengthRequirement ) { var output = value . slice ( ) ; 
function format ( formatter , value , encode , lengthRequirement ) { var output = value ; 
function formatInputs ( method , inputs ) { return format ( schema . methods [ method ] [ 0 ] , inputs , true , schema . methods [ method ] [ 2 ] ) ; } 
function ( model , schema ) { function apply ( method , schema ) { Object . defineProperty ( model . prototype , method , { get : function ( ) { var h = { } ; for ( var k in schema . methods [ method ] ) { h [ k ] = schema . methods [ method ] [ k ] . bind ( this ) ; } return h ; } , configurable : true , } ) ; } for ( var method in schema . methods ) { if ( typeof schema . methods [ method ] === 'function' ) { model . prototype [ method ] = schema . methods [ method ] ; } else { apply ( method , schema ) ; } } } 
function ( model , schema ) { for ( var i in schema . statics ) { model [ i ] = schema . statics [ i ] ; } } 
function ( files ) { if ( ! _ . isArray ( files ) ) { throw new Error ( 'Arguments to config-helper.mergeConfig should be an array' ) ; } var appConfig = { } ; files . forEach ( function ( filePath ) { if ( gruntFile . exists ( filePath ) ) { var fileConfig = gruntFile . readYAML ( filePath ) ; 
function parseBinding ( node ) { consume ( ) ; 
function parseArrayList ( node ) { consume ( ) ; * Use clear() to allow whitespace on certain locations: * (n,n@x), (n, n@x), ( n , n@x ) are all accepted. * (n, n @x) is not accepted: bindings do not allow * any whitespace. */ clear ( ) ; stage1 ( node . nodes ) ; clear ( ) ; if ( peek ( ) !== ',' ) { break ; } consume ( ) ; 
function parseProperty ( node , proto ) { consume ( ) ; * Properties may have type specifiers. This is the way to go * to match nested objects. * * e.g. 'o(.coord:o(.x, .y))' matches objects like * '{coord: {x: 5, y: 7} }' */ if ( hasNext ( ) && peek ( ) === ':' ) { consume ( ) ; 
function parseProperties ( node ) { consume ( ) ; * Properties always have to start with '.' or ':' * o(.x, :y) matches an object with at least an owned property * 'x' and a owned or inherited property 'y'. */ if ( peek ( ) === '.' ) { parseProperty ( node , false ) ; 
function parseLiteralList ( AST , parseFunction ) { consume ( ) ; 
function extractStringLiteral ( ) { var literal = [ ] , enclosing = next ( ) ; if ( ! ( enclosing === '"' || enclosing === "'" ) ) { throw "Unexpected token at index " + index + " expected 'string' but found " + enclosing ; } while ( hasNext ( ) && peek ( ) !== enclosing ) { literal [ literal . length ] = next ( ) ; } consume ( ) ; 
function parseStringLiteral ( AST ) { if ( peek ( ) === '/' ) { newNode ( extractRegex ( ) , newNode ( 'r=' , AST ) . nodes ) ; } else { newNode ( extractStringLiteral ( ) , newNode ( '=' , AST ) . nodes ) ; } } 
function parseNumericLiteral ( AST ) { var literal = [ ] , value ; while ( hasNext ( ) && validNum ( peek ( ) ) ) { literal [ literal . length ] = next ( ) ; } value = parseFloat ( literal . join ( '' ) ) ; if ( ! isNaN ( value ) && isFinite ( value ) ) { newNode ( value , newNode ( '=' , AST ) . nodes ) ; } else { unexpectedTokenException ( 'numeric' ) ; } } 
function parseGeneric ( AST , type ) { var node = newNode ( next ( ) , AST ) ; 
function stage1 ( AST ) { if ( hasNext ( ) ) { switch ( peek ( ) ) { case 'a' : parseArray ( AST ) ; break ; case 'o' : parseObject ( AST ) ; break ; default : if ( / [nsSbfdr_] / . test ( peek ( ) ) ) { parseGeneric ( AST , peek ( ) ) ; } else { unexpectedTokenException ( 'one of (a,o,n,s,S,b,f,d,r,_)' ) ; } } } return AST ; } 
function curry ( fun , args ) { return function ( x ) { return fun . apply ( bindingContext , args . concat ( [ x ] ) ) ; } ; } 
function bind ( n , p , v ) { var m = p ( v ) ; if ( m . result ) { * When the rest of an array is matched, the binding value has to * be changed after executing bind. Thats because at bind time the * rest of the array is not known. Therefore the name of the last * binding is stored and can be retrieved in the continuing function. */ m . this_binding = n ; return m ; } 
function equalsDate ( x , o ) { return { result : x . getTime ( ) === o . getTime ( ) , param : x } ; } 
function hasProperty ( m , x , o ) { return testProperty ( m , x , o , o . hasOwnProperty ( x ) ) ; } 
function hasPrototypeProperty ( m , x , o ) { return testProperty ( m , x , o , x in o ) ; } 
function or ( m , o ) { var index , result = { result : false , param : o } ; for ( index = 0 ; index < m . length ; index ++ ) { if ( m [ index ] ( o ) . result ) { result . result = true ; break ; } } return result ; } 
function matchArray ( m , a ) { var from = 0 , rest = false , restBindingResult , index , matcher , item , matchResult , restOfArray = [ ] , i , result = { result : false , param : a } ; * If there are no predicates at all, this matches because it is * already ensured that argument a is an array. */ if ( m . length === 0 ) { result . result = true ; return result ; } for ( index = 0 ; index < a . length ; index ++ ) { matcher = m [ index ] ; item = a [ index ] ; if ( ! matcher ) { return result ; } matchResult = matcher ( item ) ; if ( ! matchResult . result ) { return result ; } if ( matchResult . rest ) { restBindingResult = matchResult ; from = index ; rest = true ; break ; } } if ( rest && restBindingResult . this_binding ) { for ( i = from ; i < a . length ; i ++ ) { restOfArray [ restOfArray . length ] = a [ i ] ; } bindingContext [ restBindingResult . this_binding ] = restOfArray ; } result . result = true ; return result ; } 
function compileNode ( ast ) { var result = [ ] , index , node , matcher ; for ( index = 0 ; index < ast . length ; index ++ ) { node = ast [ index ] ; switch ( node . type ) { case 'a' : matcher = curry ( matchArray , [ compileNode ( node . nodes ) ] ) ; break ; case 'o' : matcher = curry ( matchObject , [ compileNode ( node . nodes ) ] ) ; break ; case '.' : matcher = curry ( hasProperty , [ compileNode ( node . nodes ) , node . name ] ) ; break ; case ':' : matcher = curry ( hasPrototypeProperty , [ compileNode ( node . nodes ) , node . name ] ) ; break ; case '=' : matcher = curry ( equals , [ node . nodes [ 0 ] . type ] ) ; break ; case 'd=' : matcher = curry ( equalsDate , [ node . nodes [ 0 ] . type ] ) ; break ; case 'r=' : matcher = curry ( matchesRegex , [ node . nodes [ 0 ] . type ] ) ; break ; case '||' : matcher = curry ( or , [ compileNode ( node . nodes ) ] ) ; break ; case 'n' : matcher = curry ( matchType , [ 'number' ] ) ; break ; case 's' : matcher = curry ( matchType , [ 'string' ] ) ; break ; case 'S' : matcher = matchNonBlankString ; break ; case 'b' : matcher = curry ( matchType , [ 'boolean' ] ) ; break ; case 'f' : matcher = curry ( matchType , [ 'function' ] ) ; break ; case '_' : matcher = any ; break ; case '|' : matcher = rest ; break ; case '()' : matcher = matchEmptyArray ; break ; case 'd' : matcher = curry ( matchInstanceOf , [ '[object Date]' ] ) ; break ; case 'r' : matcher = curry ( matchInstanceOf , [ '[object RegExp]' ] ) ; break ; default : throw "Unknown AST entity: " + node . type ; } 
function arrayToObject ( array ) { var obj = { } , i ; if ( array . length % 2 !== 0 ) { throw "Missing handler for pattern" ; } for ( i = 0 ; i < array . length ; i += 2 ) { obj [ array [ i ] ] = array [ i + 1 ] ; } return obj ; } 
function getName ( tag ) { return tag . name ? tag . name . value . toLowerCase ( ) : ` ${ tag . type } ` ; } 
function eatAttributeValue ( stream ) { const start = stream . pos ; if ( eatQuoted ( stream ) ) { 
function isUnquoted ( code ) { return ! isNaN ( code ) && ! isQuote ( code ) && ! isSpace ( code ) && ! isTerminator ( code ) ; } 
function Sentiment ( args ) { this . path = args . path || "" ; this . language = args . language ; this . confidence = args . confidence || null ; this . synset = args . synset ; this . synsets = { } ; this . labeler = { } ; this . negations = def ( args . negations , [ "no" , "not" , "n't" , "never" ] ) ; this . modifiers = def ( args . modifiers , [ "RB" ] ) ; this . modifier = def ( args . modifier , function ( w ) { return _str . endsWith ( w , "ly" ) ; } ) ; this . tokenizer = def ( args . tokenizer , find_tokens ) ; } 
function avgAssessment ( assessments , weighted ) { var w ; var s = 0 ; var n = 0 ; assessments . forEach ( function ( ws ) { w = weighted ( ws [ 0 ] ) ; s += w * ws [ 1 ] ; n += w ; } ) ; if ( n === 0 ) { return 0 ; } else { return s / n ; } } 
function avg ( vct ) { if ( vct . length === 0 ) { return 0 ; } return ( vct . reduce ( function ( a , c ) { return a + c ; } , 0 ) / vct . length ) ; } 
function setDefault ( obj , key , val ) { if ( _ . isUndefined ( obj [ key ] ) ) { obj [ key ] = val ; return val ; } return obj [ key ] ; } 
function getXml ( path , finish ) { fs . readFile ( path , function ( err , data ) { if ( err ) throw err ; xmlParser . parseString ( data , function ( err , result ) { if ( err ) throw err ; finish ( result ) ; } ) ; } ) ; } 
function toParameter ( val , key ) { var str = '--' + key . replace ( / ([A-Z]) / g , function ( a ) { return '-' + a . toLowerCase ( ) ; } ) ; return ( val === true ) ? [ str ] : [ str , val ] ; } 
function injectDependencies ( func , args , callback ) { var declaredArguments = toolbox . parseDeclaredArguments ( func ) ; declaredArguments = declaredArguments . replace ( / \s+ / g , "" ) . split ( "," ) ; logger . trace ( "injectDependencies() declaredArguments: " , declaredArguments , "provided args:" , args ) ; var useCallback = false ; var len = args . length > declaredArguments . length ? args . length : declaredArguments . length ; for ( var i = 0 ; i < len ; i ++ ) { 
function appendUISource ( client ) { angoose . getLogger ( 'angoose' ) . debug ( "Appending angoose-ui sources" ) ; 
function error ( msg , addHint ) { console . log ( '\x1b[31m' ) ; console . log ( 'The compiler has stopped on an error' ) console . log ( ` \x1b ${ msg } \x1b ` ) ; if ( addHint ) console . log ( ` \n ` ) ; process . exit ( 1 ) ; } 
function compile ( modelName , schema , dependencies ) { logger . trace ( "Compiling schema " , modelName ) var model = function AngooseModule ( data ) { //@todo proper clone for ( var i in data ) { this [ i ] = data [ i ] ; } } ; model . toString = function ( ) { return "PROXY: function " + modelName + "()" ; } // static methods for ( var name in schema . statics ) { model [ name ] = createProxy ( model , name , schema . statics [ name ] , 'static' ) ; } for ( var name in schema . methods ) { model . prototype [ name ] = createProxy ( model , name , schema . methods [ name ] , 'instance' ) ; } //model.angoose$ = staticInvoker; model . dependencies$ = dependencies ; model . schema = schema ; //model.prototype.angoose$ = instanceInvoker; //model.prototype.classname$ = modelName; //model.prototype.schema$ = schema; model . prototype . get = getter ; model . prototype . set = setter ; model . modelName = modelName ; // this is to be compatible with backend mongoose model . name = modelName ; 
function addProps ( props , options ) { if ( ! props ) return '## No props' const keys = Object . keys ( props ) . filter ( key => filterProps ( key , props [ key ] , options ) , ) const filteredProps = keys . reduce ( ( last , key ) => ( { ... last , [ key ] : props [ key ] } ) , { } , ) let output = '\n## Props\n' let isFlow = false const items = [ TABLE_HEADERS , ... keys . map ( key => { const prop = filteredProps [ key ] if ( isFlowType ( prop ) ) isFlow = true const row = [ isFlowType ( prop ) ? key : getKey ( key , getType ( prop ) ) , getTypeName ( getType ( prop ) ) , getDefaultValue ( prop ) , prop . required , prop . description , ] return row . map ( rowValue => { if ( typeof rowValue === 'string' ) { return rowValue . split ( '\n' ) . join ( '<br>' ) } return rowValue } ) } ) , ] output += ` ${ table ( items ) } \n ` 
function debounce ( quietMillis , fn , ctx ) { ctx = ctx || undefined ; var timeout ; return function ( ) { var args = arguments ; clearTimeout ( timeout ) ; timeout = setTimeout ( function ( ) { fn . apply ( ctx , args ) ; } , quietMillis ) ; } ; } 
function matroshka ( fn ) { var babushka = fn ; Object . keys ( process . namespaces ) . forEach ( function ( name ) { babushka = process . namespaces [ name ] . bind ( babushka ) ; } ) ; return babushka ; } 
function findTagged ( modelClass , tag ) { if ( ! modelClass || ! modelClass . schema ) return [ ] ; var cols = [ ] ; Object . keys ( modelClass . schema . paths ) . forEach ( function ( path ) { var data = modelClass . schema . paths [ path ] ; if ( data . options . tags && data . options . tags . indexOf ( tag ) >= 0 ) cols . push ( data ) ; } ) ; return cols ; } 
function enterscope ( scope , name , arg1 ) { angoose . logger . trace ( "Entering scope " , name , scope . $id , arg1 ) window [ 'scope' + scope . $id ] = scope ; } 
function postPack ( next , invocation ) { 
function error ( msg ) { if ( exports . error ) exports . error ( msg ) ; else console . log ( 'Error: ' + msg ) ; } 
function call ( name , isLong ) { var obj = isLong ? long [ name ] : short [ name ] ; if ( ! obj ) return error ( ` ${ name } ` ) ; if ( n + obj . length > count ) return error ( ` ${ name } ` ) ; var arr = process . argv . slice ( n , n + obj . length ) ; n += obj . length ; obj . callback ( arr ) ; } 
function extend ( target , options ) { options = options || { } ; var parentClass = this ; logger . trace ( "Extending from " , parentClass . _angoosemeta . name , options ) ; var rv = null ; if ( typeof ( target ) == 'function' ) { rv = target ; mixinInstance ( parentClass , rv , options ) ; bindMongooseMethods ( rv ) ; } else { rv = parentClass . $extend ( target ) ; } rv = mixinStatic ( parentClass , rv , options ) ; if ( rv . _angoosemeta . name ) { 
function addHook ( loc , method , func ) { var tmp = hooks [ loc ] [ method ] ; logger . debug ( "ADdding bundle hook to" , loc , method , tmp ) ; if ( ! tmp ) return false ; tmp . push ( func ) ; return true ; } 
function findInputElement ( templateElement ) { return angular . element ( templateElement . find ( 'input' ) [ 0 ] || templateElement . find ( 'select' ) [ 0 ] || templateElement . find ( 'textarea' ) [ 0 ] ) ; } 
function getValidationMessageMap ( originalElement ) { 
function mapDirective ( path , pathSchema , modelSchema , itemIndex ) { if ( itemIndex !== undefined ) return null ; 
function mapTemplate ( path , pathSchema , modelSchema ) { if ( pathSchema . options . template ) return pathSchema . options . template ; if ( pathSchema . options . multiline ) return "textarea" var template = 'input' ; var opts = pathSchema . options || { } ; 
function init ( app , conf , force ) { if ( this . initialized && ! force ) return ; 
function lookupOrRegister ( name , target ) { if ( arguments . length == 0 ) return null ; if ( arguments . length == 1 ) return getClass ( name ) ; if ( arguments . length == 2 ) return registerClass ( name , target ) ; } 
function registerClass ( nameOrOpts , claz ) { var opts = typeof ( nameOrOpts ) == 'object' ? nameOrOpts : { name : nameOrOpts } ; var className = opts . name ; if ( ! className ) throw "Missing module name: " + className if ( beans [ className ] ) logger . warn ( "Overriding existing bean: " , className ) ; if ( claz . _angoosemeta && ( claz . _angoosemeta . baseClass == 'Service' || claz . _angoosemeta . baseClass == 'Model' ) ) { 
function getContext ( ) { if ( ! domain . active || ! domain . active . context ) { if ( this . mockContext ) return this . mockContext logger . error ( "getContext called but no active domain" , domain . active ) ; logger . error ( "Caller is " , arguments . callee && arguments . callee . caller && arguments . callee . caller . name , arguments . callee && arguments . callee . caller ) ; throw "Context not available. This may happen if the code was not originated by Angoose" ; } return domain . active . context ; } 
function scanDir ( dirname ) { if ( ! dirname || dirname . indexOf ( "node_modules" ) >= 0 ) return ; logger . debug ( "Scanning directory for modules: " , dirname ) ; if ( fs . existsSync ( path . resolve ( dirname , 'index.js' ) ) ) { files . push ( path . resolve ( dirname , 'index.js' ) ) ; return ; } fs . readdirSync ( dirname ) . forEach ( function ( file ) { var fullpath = path . resolve ( dirname , file ) ; if ( ! fs . statSync ( fullpath ) . isFile ( ) ) scanDir ( fullpath ) ; else if ( file . match ( / .+\.js / g ) !== null ) { files . push ( fullpath ) ; } } ) ; } 
function generateClient ( ) { logger . debug ( "Generating angoose client file: " ) ; var bundle = new Bundle ( ) ; var client = { } ; bundle . generateClient ( client ) ; var filename = angoose . config ( ) [ 'client-file' ] ; writeToFile ( filename , client . source ) 
function config ( path , val ) { if ( ! path ) return options ; if ( ! angoose . initialized && typeof ( path ) == 'string' ) throw "Cannot call config(" + path + ") before angoose is intialized" ; 
function connect ( url , next ) { log ( 'connecting to %s' , url ) ; mongo . Db . connect ( url , { db : { w : 1 } } , next ) ; } 
function startShell ( db , program , files ) { var repl = global . repl = term ( db ) ; createContext ( db , repl , function ( ) { var code = program . eval ; if ( code ) { executeJS ( code ) ; if ( ! program . shell ) { repl . emit ( 'exit' ) ; return ; } } if ( files . length ) { executeFiles ( files ) ; printCloseMsg ( ) ; } repl . prompt = prompt ; repl . displayPrompt ( ) } ) ; } 
function executeFiles ( files ) { var dir = process . cwd ( ) ; files . forEach ( function ( file ) { require ( dir + '/' + file ) ; } ) ; } 
function executeJS ( script ) { if ( ! script ) return ; try { var ret = vm . runInThisContext ( script , '[eval]' ) ; if ( 'undefined' != typeof ret ) { console . log ( ret ) ; } } catch ( err ) { if ( ! ( err instanceof Error ) ) { err = new Error ( err ) ; } console . log ( err . stack . split ( '\n' ) [ 0 ] ) ; process . exit ( 1 ) ; } } 
function ErrorFunction ( message : string ) { const Err = Error Err . call ( this , message ) if ( noFallback ) { Error . captureStackTrace ( this , ErrorFunction ) } else { this . stack = ( new Error ( ) ) . stack } this . name = this . constructor . name this . message = message } 
function createConstructor ( db ) { var collections = [ ] ; function DB ( ) { this . cols ( false , noop ) ; } ; ( DB . prototype . help = function ( ) { var proto = this . constructor . prototype ; var len = 0 ; var msgs = [ ] ; Object . keys ( proto ) . forEach ( function ( method ) { if ( proto [ method ] . help ) { var msg = proto [ method ] . help ( true ) ; len = Math . max ( len , method . length ) ; msgs . push ( { method : method , text : msg } ) } } ) msgs . sort ( function ( a , b ) { return a . method > b . method ? 1 : a . method < b . method ? - 1 : 0 } ) msgs . forEach ( function ( msg ) { var space = Array ( len - msg . method . length + 1 ) . join ( ' ' ) ; log ( "db." + msg . method + "() " + space + msg . text ) ; } ) } ) . help = help ( "Logs help text for all db methods" ) ; ; ( DB . prototype . drop = function ( cb ) { var name = db . databaseName ; db . dropDatabase ( cb || function ( err ) { if ( err ) { return console . error ( err ) ; } db . collections ( function ( ) { log ( 'database "%s" was dropped' , name ) ; } ) ; } ) ; } ) . help = help ( "Drops the database" ) ; wrap ( DB . prototype , 'drop' ) ; ; ( DB . prototype . close = function ( cb ) { if ( 'function' != typeof cb ) { cb = handleError ; } db . close ( true , cb ) ; } ) . help = help ( "Closes the database connection" ) ; wrap ( DB . prototype , 'close' ) ; ; ( DB . prototype . open = function ( cb ) { db . open ( function ( err ) { if ( err ) { return handleError ( err , cb ) ; } if ( 'function' == typeof cb ) { cb ( ) ; } } ) ; } ) . help = help ( "Opens the database connection" ) wrap ( DB . prototype , 'open' ) ; ; ( DB . prototype . use = function ( name ) { return create ( db . db ( name ) ) ; } ) . help = help ( "Changes to a different database" ) ; ( DB . prototype . col = function ( name , opts ) { if ( this [ name ] ) { return this [ name ] ; } * Creates a collection * * @param {String} name * @param {Object} [options] * @param {Function} [cb] */ ; ( DB . prototype . createCol = function ( name , opts , cb ) { if ( 'function' == typeof opts ) { cb = opts ; opts = { } ; } if ( 'string' != typeof name ) { error ( new TypeError ( 'collection name must be a string' ) ) ; return ; } if ( ! opts ) opts = { } ; * Refresh and return the list of collections on this database * * @param {Boolean} [print] if the collection names should be printed * @param {Function} [cb] passed any error and the result array */ ; ( DB . prototype . cols = function ( print , cb ) { var self = this ; if ( 'function' == typeof print ) { cb = print ; print = false ; } if ( undefined == print ) print = true db . collectionNames ( { namesOnly : true } , function ( err , names ) { if ( err ) { if ( cb ) return cb ( err ) ; console . error ( err . stack ) ; return ; } if ( ! Array . isArray ( names ) ) { names = [ ] ; } * Execute a command on the database * * @param {Object} cmd * @param {Object} [opts] * @param {Function} [cb] */ ; ( DB . prototype . runCommand = function ( cmd , opts , cb ) { if ( 'function' == typeof opts ) { cb = opts ; opts = { } ; } if ( ! cmd ) { var err = new Error ( 'missing command' ) ; if ( cb ) return cb ( err ) ; console . error ( err ) ; return ; } if ( ! cb ) cb = p ; if ( ! opts ) opts = { } ; var admin = ! ! opts . admin ; delete opts . admin ; var method = admin ? 'executeDbAdminCommand' : 'executeDbCommand' db [ method ] ( cmd , opts , cb ) ; } ) . help = help ( "Runs a command on the database" ) wrap ( DB . prototype , 'runCommand' ) ; ; ( DB . prototype . stats = function ( scale , cb ) { if ( 'function' == typeof scale ) cb = scale ; scale |= 0 ; db . stats ( function ( err , stats ) { cb ( err , stats ) ; } ) } ) . help = help ( 'Retreive database stats' ) ; wrap ( DB . prototype , 'stats' ) ; ; ( DB . prototype . inspect = function ( ) { return db . databaseName ; } ) . help = help ( "Returns the name of the database" ) ; return DB ; } 
function wrap ( proto , name ) { var old = proto [ name ] ; proto [ name ] = function ( ) { if ( global . repl ) global . repl . bufferStart ( ) ; var args = slice ( arguments ) ; var last = args [ args . length - 1 ] ; if ( 'function' == typeof last ) { args [ args . length - 1 ] = function ( ) { if ( global . repl ) global . repl . bufferEnd ( ) if ( p != last ) console . log ( ) ; last . apply ( null , arguments ) if ( global . repl ) { global . repl . displayPrompt ( ) ; global . repl . moveCursorToEnd ( ) ; } } } else { args . push ( function ( ) { if ( global . repl ) global . repl . bufferEnd ( ) p . apply ( null , arguments ) ; if ( global . repl ) global . repl . moveCursorToEnd ( ) ; } ) ; } old . apply ( this , args ) ; } if ( old . help ) { proto [ name ] . help = old . help ; } } 
function handleError ( err , cb ) { if ( err ) { if ( cb ) { return process . nextTick ( function ( ) { cb ( err ) ; } ) ; } console . error ( err ) ; } } 
function tablature ( conf ) { const { keys = [ ] , data = [ ] , headings = { } , replacements = { } , centerValues = [ ] , centerHeadings = [ ] , } = conf const [ i ] = data if ( ! i ) return '' const cv = makeBinaryHash ( centerValues ) const hv = makeBinaryHash ( centerHeadings ) const k = Object . keys ( i ) . reduce ( ( acc , key ) => { const h = headings [ key ] return { ... acc , [ key ] : h ? h . length : key . length , 
function metric ( name , val , message ) { 
function StdError ( message ) { if ( ! ( this instanceof StdError ) ) { return new StdError ( message ) ; } Error . captureStackTrace ( this , this . constructor ) ; this . code = this . _defaults . code ; this . name = this . _defaults . name ; this . message = this . _defaults . message ; switch ( typeof ( message ) ) { case "string" : this . message = message ; break ; case "object" : ( message . code ) && ( this . code = message . code ) ; ( message . name ) && ( this . name = message . name ) ; ( message . message ) && ( this . message = message . message ) ; break ; } } 
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; if ( ! ( this instanceof child ) ) { var obj = Object . create ( child . prototype ) ; child . apply ( obj , args ) ; return obj ; } self . apply ( this , args ) ; } 
function sanatize ( str ) { return str . replace ( / \.\w+$ / , '' ) 
function fixRedirectPost ( ) { 
function lowChain ( _ , array , save ) { var chain = _ . chain ( array ) ; _ . functionsIn ( chain ) . forEach ( function ( method ) { chain [ method ] = _ . flow ( chain [ method ] , function ( arg ) { var v = void 0 ; if ( arg ) { v = _ . isFunction ( arg . value ) ? arg . value ( ) : arg ; } var s = save ( ) ; if ( s ) return s . then ( function ( ) { return Promise . resolve ( v ) ; } ) ; return v ; } ) ; } ) ; return chain ; } 
function _save ( ) { if ( db . source && db . write && writeOnChange ) { var str = JSON . stringify ( db . object ) ; if ( str !== db . _checksum ) { db . _checksum = str ; return db . write ( db . source , db . object ) ; } } } 
function Picklr ( startDir , options ) { options = options || { } ; let defaultExcludeDirsRe ; if ( / ^\. / . test ( startDir ) ) { defaultExcludeDirsRe = / \/\.|node_modules / i ; } else { defaultExcludeDirsRe = / ^\.|\/\.|node_modules / i ; } this . totalFileCount = 0 ; this . matchedFileCount = 0 ; this . startDir = startDir || '.' ; this . targetText = options . targetText || '' ; this . replacementText = options . replacementText || '' ; this . action = options . action || 'echo' ; this . includeExts = options . includeExts || [ '.js' ] ; this . excludeDirs = options . excludeDirsRe || defaultExcludeDirsRe ; this . logger = options . logger || console . log ; this . picklrActions = picklrActions ; } 
function ( p ) { fs . readdirSync ( p ) . forEach ( function ( file ) { const curPath = path . join ( p , path . sep , file ) ; const stats = fs . statSync ( curPath ) ; if ( this . isDirectory ( stats , curPath ) ) { this . recurseFiles ( curPath ) ; } else if ( this . isFile ( stats , curPath ) ) { this . picklrActions [ this . action ] . call ( this , curPath ) ; } } , this ) ; if ( p === this . startDir ) { this . logger ( 'Total file count = ' + this . totalFileCount ) ; if ( this . action !== 'echo' ) { this . logger ( 'Matched file count = ' + this . matchedFileCount ) ; } } } 
function ( stats , p ) { let result = stats . isFile ( ) ; if ( result ) { const ext = path . extname ( p ) ; result = this . includeExts . indexOf ( ext ) !== - 1 ; } return result ; } 
function ( stats , p ) { let result = stats . isDirectory ( ) ; if ( result ) { result = ! this . excludeDirs . test ( p ) ; } return result ; } 
function processAllFiles ( startDir , options ) { const picklr = new Picklr ( startDir , options ) ; picklr . recurseFiles ( startDir ) ; } 
function processFile ( filePath , update ) { let change , found = false ; const lines = fs . readFileSync ( filePath , { encoding : 'utf8' } ) . split ( '\n' ) ; for ( let i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] . indexOf ( this . targetText ) !== - 1 ) { found = true ; change = lines [ i ] . replace ( this . targetText , this . replacementText ) ; if ( update ) { lines [ i ] = change ; } else { 
function extractEncoding ( headers ) { var type = headers [ "content-type" ] ; if ( ! type ) { return "utf8" ; } var split = type . split ( '=' ) ; return split . length == 2 ? split [ 1 ] : "utf8" ; } 
function substr ( string , start , length ) { if ( ! isString ( string ) ) { return string ; } return string . substr ( start , length ) ; } 
async function initHTTPServer ( { ENV = { } , HOST = '127.0.0.1' , PORT = 8080 , MAX_HEADERS_COUNT = 800 , KEEP_ALIVE_TIMEOUT = ms ( '5m' ) , TIMEOUT = ms ( '2m' ) , MAX_CONNECTIONS , httpRouter , log = noop , } ) { const sockets = ENV . DESTROY_SOCKETS ? new Set ( ) : { } . undef ; const httpServer = http . createServer ( httpRouter ) ; const listenPromise = new Promise ( resolve => { httpServer . listen ( PORT , HOST , ( ) => { log ( 'info' , ` ${ HOST } ${ PORT } ` ) ; resolve ( httpServer ) ; } ) ; } ) ; const errorPromise = new Promise ( ( resolve , reject ) => { httpServer . once ( 'error' , reject ) ; } ) ; httpServer . timeout = TIMEOUT ; httpServer . keepAliveTimeout = KEEP_ALIVE_TIMEOUT ; httpServer . maxHeadersCount = MAX_HEADERS_COUNT ; httpServer . maxConnections = MAX_CONNECTIONS ; if ( 'undefined' !== typeof MAX_CONNECTIONS ) { httpServer . maxConnections = MAX_CONNECTIONS ; } if ( ENV . DESTROY_SOCKETS ) { httpServer . on ( 'connection' , socket => { sockets . add ( socket ) ; socket . on ( 'close' , ( ) => { sockets . delete ( socket ) ; } ) ; } ) ; } return Promise . race ( [ listenPromise , errorPromise ] ) . then ( ( ) => ( { service : httpServer , errorPromise , dispose : ( ) => new Promise ( ( resolve , reject ) => { log ( 'debug' , 'Closing HTTP server.' ) ; 
function sortAndAddFirstElement ( array , sortBy , element ) { return _ ( array ) . sortBy ( sortBy ) . unshift ( element ) . value ( ) ; } 
function objectInterface ( config ) { return function ( obj ) { var result = { } ; for ( var i = 0 ; i < config . length ; i ++ ) { var OR , NEXT , REAL ; if ( ( OR = config [ i ] . split ( '/' ) ) && OR [ 1 ] ) { result [ OR [ 0 ] ] = obj [ OR [ 0 ] ] || Function ( 'return ' + OR [ 1 ] ) ( ) ; } else if ( ( NEXT = config [ i ] . split ( '|' ) ) && NEXT [ 1 ] ) { result [ NEXT [ 0 ] ] = Function ( 'return ' + NEXT [ 1 ] ) . call ( obj ) ; } else if ( ( REAL = config [ i ] . split ( ':' ) ) && REAL [ 1 ] ) { result [ REAL [ 0 ] ] = Function ( 'return ' + REAL [ 1 ] ) ( ) ; } else { result [ config [ i ] ] = obj [ config [ i ] ] ; } } return result ; } } 
function initHTTPTransaction ( { TIMEOUT = DEFAULT_TIMEOUT , TRANSACTIONS , log = noop , time , delay , uniqueId = createIncrementor ( ) , } ) { * Create a new HTTP transaction * @param {HTTPRequest} req * A raw NodeJS HTTP incoming message * @param {HTTPResponse} res * A raw NodeJS HTTP response * @return {Array} * The normalized request and the HTTP * transaction created in an array. */ function httpTransaction ( req , res ) { let initializationPromise ; return Promise . resolve ( ) . then ( ( ) => { const request = { url : req . url , method : req . method . toLowerCase ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https' : 'http' , ip : ( req . headers [ 'x-forwarded-for' ] || '' ) . split ( ',' ) [ 0 ] || req . connection . remoteAddress , startInBytes : req . socket . bytesRead , startOutBytes : req . socket . bytesWritten , startTime : time ( ) , url : req . url , method : req . method , reqHeaders : req . headers , errored : false , } ; const delayPromise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction-id' ] || uniqueId ( ) ; Once initiated, the transaction can be started. It basically spawns a promise that will be resolved to the actual response or rejected if the timeout is reached. */ return Promise . race ( [ initializationPromise . then ( ( ) => buildResponse ( ) ) , delayPromise . then ( ( ) => { throw new HTTPError ( 504 , 'E_TRANSACTION_TIMEOUT' , TIMEOUT , id ) ; } ) , ] ) ; } function catchTransaction ( { id , req } , err ) { err = HTTPError . cast ( err , err . httpCode || 500 ) ; log ( 'error' , 'An error occured' , { guruMeditation : id , request : TRANSACTIONS [ id ] . protocol + '://' + ( req . headers . host || 'localhost' ) + TRANSACTIONS [ id ] . url , verb : req . method , status : err . httpCode , code : err . code , stack : err . stack , details : err . params , } ) ; TRANSACTIONS [ id ] . errored = true ; throw err ; } function endTransaction ( { id , req , res , delayPromise } , response ) { return new Promise ( ( resolve , reject ) => { res . on ( 'error' , reject ) ; res . on ( 'finish' , resolve ) ; res . writeHead ( response . status , statuses [ response . status ] , Object . assign ( { } , response . headers , { 'Transaction-Id' : id } ) , ) ; if ( response . body && response . body . pipe ) { response . body . pipe ( res ) ; } else { res . end ( ) ; } } ) . catch ( err => { TRANSACTIONS [ id ] . errored = true ; log ( 'error' , 'An error occured' , { guruMeditation : id , request : TRANSACTIONS [ id ] . protocol + '://' + ( req . headers . host || 'localhost' ) + TRANSACTIONS [ id ] . url , method : req . method , stack : err . stack || err , } ) ; } ) . then ( ( ) => { TRANSACTIONS [ id ] . endTime = time ( ) ; TRANSACTIONS [ id ] . endInBytes = req . socket . bytesRead ; TRANSACTIONS [ id ] . endOutBytes = req . socket . bytesWritten ; TRANSACTIONS [ id ] . statusCode = response . status ; TRANSACTIONS [ id ] . resHeaders = response . headers || { } ; log ( 'info' , TRANSACTIONS [ id ] ) ; delete TRANSACTIONS [ id ] ; return delay . clear ( delayPromise ) ; } ) ; } } 
function httpTransaction ( req , res ) { let initializationPromise ; return Promise . resolve ( ) . then ( ( ) => { const request = { url : req . url , method : req . method . toLowerCase ( ) , headers : req . headers , body : req , } ; const transaction = { protocol : req . connection . encrypted ? 'https' : 'http' , ip : ( req . headers [ 'x-forwarded-for' ] || '' ) . split ( ',' ) [ 0 ] || req . connection . remoteAddress , startInBytes : req . socket . bytesRead , startOutBytes : req . socket . bytesWritten , startTime : time ( ) , url : req . url , method : req . method , reqHeaders : req . headers , errored : false , } ; const delayPromise = delay . create ( TIMEOUT ) ; let id = req . headers [ 'transaction-id' ] || uniqueId ( ) ; 
function dateDifference ( date1 , date2 , differenceType ) { var diffMilliseconds = Math . abs ( date1 - date2 ) ; switch ( differenceType ) { case 'days' : return dates . _getDaysDiff ( diffMilliseconds ) ; case 'hours' : return dates . _differenceInHours ( diffMilliseconds ) ; case 'minutes' : return dates . _differenceInMinutes ( diffMilliseconds ) ; case 'milliseconds' : return diffMilliseconds ; default : return { days : dates . _getDaysDiff ( diffMilliseconds ) , hours : dates . _getHoursDiff ( diffMilliseconds ) , minutes : dates . _getMinutesDiff ( diffMilliseconds ) , milliseconds : diffMilliseconds } } } 
function initErrorHandler ( { ENV = { } , DEBUG_NODE_ENVS = DEFAULT_DEBUG_NODE_ENVS , STRINGIFYERS = DEFAULT_STRINGIFYERS , } ) { return Promise . resolve ( errorHandler ) ; function errorHandler ( transactionId , responseSpec , err ) { return Promise . resolve ( ) . then ( ( ) => { const response = { } ; response . status = err . httpCode || 500 ; response . headers = Object . assign ( { } , err . headers || { } , { 
function dateDifferenceFromNow ( date , differenceType ) { var now = new Date ( ) , diffMilliseconds = Math . abs ( date - now ) ; switch ( differenceType ) { case 'days' : return dates . _getDaysDiff ( diffMilliseconds ) ; case 'hours' : return dates . _differenceInHours ( diffMilliseconds ) ; case 'minutes' : return dates . _differenceInMinutes ( diffMilliseconds ) ; case 'milliseconds' : return diffMilliseconds ; default : return { days : dates . _getDaysDiff ( diffMilliseconds ) , hours : dates . _getHoursDiff ( diffMilliseconds ) , minutes : dates . _getMinutesDiff ( diffMilliseconds ) , milliseconds : diffMilliseconds } } } 
function initHTTPRouter ( { ENV = { } , DEBUG_NODE_ENVS = DEFAULT_DEBUG_NODE_ENVS , BUFFER_LIMIT = DEFAULT_BUFFER_LIMIT , HANDLERS , API , PARSERS = DEFAULT_PARSERS , STRINGIFYERS = DEFAULT_STRINGIFYERS , DECODERS = DEFAULT_DECODERS , ENCODERS = DEFAULT_ENCODERS , QUERY_PARSER = strictQs , log = noop , httpTransaction , errorHandler , } ) { const bufferLimit = bytes . parse ( BUFFER_LIMIT ) ; const ajv = new Ajv ( { verbose : ENV && DEBUG_NODE_ENVS . includes ( ENV . NODE_ENV ) , } ) ; const consumableCharsets = Object . keys ( DECODERS ) ; const produceableCharsets = Object . keys ( ENCODERS ) ; const defaultResponseSpec = { contentTypes : Object . keys ( STRINGIFYERS ) , charsets : produceableCharsets , } ; return flattenSwagger ( API ) . then ( _createRouters . bind ( null , { HANDLERS , ajv } ) ) . then ( routers => { let handleFatalError ; log ( 'debug' , 'HTTP Router initialized.' ) ; return { service : httpRouter , fatalErrorPromise : { promise : new Promise ( ( resolve , reject ) => { handleFatalError = reject ; } ) , } , } ; function httpRouter ( req , res ) { let operation ; let responseSpec = defaultResponseSpec ; return httpTransaction ( req , res ) . then ( ( [ request , transaction ] ) => transaction . start ( ( ) => Promise . resolve ( ) . then ( ( ) => { const method = request . method ; const path = request . url . split ( SEARCH_SEPARATOR ) [ 0 ] ; const search = request . url . substr ( path . length ) ; const parts = path . split ( '/' ) . filter ( a => a ) ; let [ result , pathParameters ] = routers [ method ] ? routers [ method ] . find ( parts ) : [ ] ; 
function httpRouter ( req , res ) { let operation ; let responseSpec = defaultResponseSpec ; return httpTransaction ( req , res ) . then ( ( [ request , transaction ] ) => transaction . start ( ( ) => Promise . resolve ( ) . then ( ( ) => { const method = request . method ; const path = request . url . split ( SEARCH_SEPARATOR ) [ 0 ] ; const search = request . url . substr ( path . length ) ; const parts = path . split ( '/' ) . filter ( a => a ) ; let [ result , pathParameters ] = routers [ method ] ? routers [ method ] . find ( parts ) : [ ] ; 
function offsetPastAutoClosed ( line , pos , options ) { 
function getStartOffset ( line , pos , prefix ) { if ( ! prefix ) { return 0 ; } const stream = new StreamReader ( line ) ; const compiledPrefix = String ( prefix ) . split ( '' ) . map ( code ) ; stream . pos = pos ; let result ; while ( ! stream . sol ( ) ) { if ( consumePair ( stream , SQUARE_BRACE_R , SQUARE_BRACE_L ) || consumePair ( stream , CURLY_BRACE_R , CURLY_BRACE_L ) ) { continue ; } result = stream . pos ; if ( consumeArray ( stream , compiledPrefix ) ) { return result ; } stream . pos -- ; } return - 1 ; } 
function consumePair ( stream , close , open ) { const start = stream . pos ; if ( stream . eat ( close ) ) { while ( ! stream . sol ( ) ) { if ( stream . eat ( open ) ) { return true ; } stream . pos -- ; } } stream . pos = start ; return false ; } 
function consumeArray ( stream , arr ) { const start = stream . pos ; let consumed = false ; for ( let i = arr . length - 1 ; i >= 0 && ! stream . sol ( ) ; i -- ) { if ( ! stream . eat ( arr [ i ] ) ) { break ; } consumed = i === 0 ; } if ( ! consumed ) { stream . pos = start ; } return consumed ; } 
function isIdent ( c ) { return c === COLON || c === DASH || isAlpha ( c ) || isNumber ( c ) ; } 
async function hela ( opts ) { const options = Object . assign ( { argv : { } , prefix : 'hela-config-' , stdio : 'inherit' } , opts ) if ( options . tasks || ( options . presets || options . extends ) ) { return presetResolver ( options ) } return prettyConfig ( 'hela' , options ) . then ( ( config ) => { if ( ! config ) { throw new Error ( 'hela: no config' ) } return presetResolver ( Object . assign ( { } , config , options ) ) } ) } 
function factory ( type , opts ) { return ( cmds , options ) => { const cmd = { exec : execa . exec , shell : execa . shell } return cmd [ type ] ( cmds , Object . assign ( { } , opts , options ) ) } } 
function presetResolver ( opts ) { const presets = arrayify ( opts . presets || opts . extends ) if ( presets . length > 0 ) { const arg = Object . assign ( { } , opts ) const options = Object . assign ( { first : arg } , opts ) const tasks = resolvePlugins ( presets , options ) . reduce ( ( acc , preset ) => presetReducer ( acc , preset ) , { } ) return transformTasks ( opts , Object . assign ( { } , tasks , opts . tasks ) ) } return transformTasks ( opts , opts . tasks ) } 
async function run ( ) { const pkg = await readJson ( path . join ( options . cwd , 'package.json' ) ) const tasks = await hela ( { pkg , ... options } ) const name = options . taskName if ( Object . keys ( tasks ) . length === 0 ) { throw new Error ( 'hela: no tasks' ) } const hasOwn = ( o , k ) => Object . prototype . hasOwnProperty . call ( o , k ) if ( ! hasOwn ( tasks , name ) ) { throw new Error ( ` ${ name } ` ) } return tasks [ name ] ( ) } 
function plugin ( options ) { if ( ! options ) throw new Error ( 'no options passed' ) if ( ! options . src ) throw new Error ( 'required: options.src' ) if ( ! options . dest ) throw new Error ( 'required: options.dest' ) if ( ! options . auth ) throw new Error ( 'required: options.auth' ) 
function _write ( file , encoding , next ) { this . workers ++ vow . resolve ( file ) . then ( ( file ) => folder . downloadFile ( file ) ) . then ( ( file ) => folder . frontMatter ( file ) ) . then ( ( file ) => folder . storeFile ( file ) ) . catch ( dbg ) . then ( ( ) => { this . workers -- next ( ) } ) 
function _doAuth ( auth ) { if ( oauth ) return vow . resolve ( ) dbg ( 'doing oAuth2' ) const googleAuth = new GoogleAuth ( ) oauth = new googleAuth . OAuth2 ( auth . client_id , auth . client_secret , [ 'urn:ietf:wg:oauth:2.0:oob' , 'http://localhost' ] ) return vow . resolve ( ) . then ( ( ) => { 
function _tokenFlow ( ) { const defer = vow . defer ( ) let prompt const authUrl = oauth . generateAuthUrl ( { access_type : 'offline' , scope : [ 'https://www.googleapis.com/auth/drive.readonly' ] } ) console . log ( 'authorise metalsmith-google-drive by visiting: ' , authUrl ) prompt = readline . createInterface ( { input : process . stdin , output : process . stdout } ) prompt . question ( 'Enter the code from that page here (or "ok" to skip scrape): ' , ( code ) => { prompt . close ( ) if ( code === 'ok' ) return defer . reject ( 'skip' ) oauth . getToken ( code , ( err , result ) => { if ( err ) { dbg ( err ) defer . reject ( err ) } else { console . log ( '---------- snip ----------' ) console . log ( hjson . stringify ( { 'metalsmith-google-drive' : { token : result } } , { separator : true , spaces : 2 , bracesSameLine : true , quotes : 'all' } ) ) console . log ( '---------- snip ----------' ) console . log ( 'this token is cached automatically, but you can store' ) console . log ( 'it in a config file like config/local.js if you want.' ) valueCache . store ( 'token' , result ) defer . resolve ( result ) } } ) } ) return defer . promise ( ) } 
function onCycle ( event ) { if ( objectPool . length == 0 ) { throw new Error ( 'Pool ran out of objects' ) ; } console . log ( String ( event . target ) ) ; initPool ( ) ; } 
function modifier ( action , state ) { if ( action . type === 'example' ) { return extend ( state , { example : true } ) } else if ( action . type === 'title' ) { return extend ( state , { title : action . title } ) } } 
function json ( file ) { var filename = path . basename ( file . path , path . extname ( file . path ) ) + ".json" ; return optional ( path . join ( path . dirname ( file . path ) , filename ) ) || { } ; } 
function ( ) { const self = this ; const TIME_PER_LEVEL = 1 * 1000 ; this . level = 0 ; this . stack = [ ] ; this . fsm = new Fsm ( ) ; const open = new Fsm . State ( { fsm : self . fsm , name : 'open' , onEntry : function ( ) { const state = this ; console . log ( 'Door opened at level' , self . level ) ; setTimeout ( function ( ) { state . transitionTo ( closed ) ; } , 2000 ) ; } , onEvent : function ( event ) { if ( event . name === 'goToLevel' && event . level !== self . level ) { self . pushLevel ( event . level ) ; } } } ) ; const closed = new Fsm . State ( { fsm : self . fsm , name : 'closed' , onEntry : function ( ) { console . log ( 'Door closed' ) ; * When the elevator's doors are closed, * we wait for a request to move to another * level. */ onEvent : function ( event ) { if ( event . name === 'goToLevel' ) { if ( event . level === self . level ) { this . transitionTo ( open ) ; } else { self . pushLevel ( event . level ) ; this . transitionTo ( moving ) ; } } } } ) ; /** * The elevator is currently moving from a * level to another. */ const moving = new Fsm . State ( { fsm : self . fsm , name : 'moving' , onEntry : function ( ) { const state = this ; const next = self . stack . shift ( ) ; console . log ( 'Moving to level' , next ) ; setTimeout ( function ( ) { console . log ( 'Reached level' , next ) ; self . level = next ; state . transitionTo ( open ) ; } , TIME_PER_LEVEL * Math . abs ( next - self . level ) ) ; } , /** * As the elevator is currently moving and * cannot change direction nor open the * doors, we push any user request to go to * a level on the level stack. */ onEvent : function ( event ) { if ( event . name === 'goToLevel' ) { self . pushLevel ( event . level ) ; } } } ) ; 
function ( event ) { if ( event . name === 'goToLevel' && event . level !== self . level ) { self . pushLevel ( event . level ) ; } } 
function ( event ) { if ( event . name === 'goToLevel' ) { if ( event . level === self . level ) { this . transitionTo ( open ) ; } else { self . pushLevel ( event . level ) ; this . transitionTo ( moving ) ; } } } 
function decryptCBC ( encryptedComponents , keyDerivationInfo ) { 
function decryptGCM ( encryptedComponents , keyDerivationInfo ) { 
function encryptCBC ( text , keyDerivationInfo , iv ) { return Promise . resolve ( ) . then ( ( ) => { const ivHex = iv . toString ( "hex" ) ; const encryptTool = crypto . createCipheriv ( ENC_ALGORITHM_CBC , keyDerivationInfo . key , iv ) ; const hmacTool = crypto . createHmac ( HMAC_ALGORITHM , keyDerivationInfo . hmac ) ; const { rounds } = keyDerivationInfo ; 
function encryptGCM ( text , keyDerivationInfo , iv ) { return Promise . resolve ( ) . then ( ( ) => { const ivHex = iv . toString ( "hex" ) ; const { rounds } = keyDerivationInfo ; const encryptTool = crypto . createCipheriv ( ENC_ALGORITHM_GCM , keyDerivationInfo . key , iv ) ; 
function generateSalt ( length ) { if ( length <= 0 ) { return Promise . reject ( new Error ( ` ${ length } ` ) ) ; } let output = "" ; while ( output . length < length ) { output += crypto . randomBytes ( 3 ) . toString ( "base64" ) ; if ( output . length > length ) { output = output . substr ( 0 , length ) ; } } return Promise . resolve ( output ) ; } 
function packEncryptedContent ( encryptedContent , iv , salt , auth , rounds , method ) { return [ encryptedContent , iv , salt , auth , rounds , method ] . join ( "$" ) ; } 
function unpackEncryptedContent ( encryptedContent ) { const [ content , iv , salt , auth , roundsRaw , methodRaw ] = encryptedContent . split ( "$" ) ; 
function deriveFromPassword ( pbkdf2Gen , password , salt , rounds , generateHMAC = true ) { if ( ! password ) { return Promise . reject ( new Error ( "Failed deriving key: Password must be provided" ) ) ; } if ( ! salt ) { return Promise . reject ( new Error ( "Failed deriving key: Salt must be provided" ) ) ; } if ( ! rounds || rounds <= 0 ) { return Promise . reject ( new Error ( "Failed deriving key: Rounds must be greater than 0" ) ) ; } const bits = generateHMAC ? ( PASSWORD_KEY_SIZE + HMAC_KEY_SIZE ) * 8 : PASSWORD_KEY_SIZE * 8 ; return pbkdf2Gen ( password , salt , rounds , bits ) . then ( derivedKeyData => derivedKeyData . toString ( "hex" ) ) . then ( function ( derivedKeyHex ) { const dkhLength = derivedKeyHex . length ; const keyBuffer = generateHMAC ? new Buffer ( derivedKeyHex . substr ( 0 , dkhLength / 2 ) , "hex" ) : new Buffer ( derivedKeyHex , "hex" ) ; const output = { salt : salt , key : keyBuffer , rounds : rounds } ; if ( generateHMAC ) { output . hmac = new Buffer ( derivedKeyHex . substr ( dkhLength / 2 , dkhLength / 2 ) , "hex" ) ; } return output ; } ) ; } 
function pbkdf2 ( password , salt , rounds , bits ) { return new Promise ( ( resolve , reject ) => { deriveKey ( password , salt , rounds , bits / 8 , DERIVED_KEY_ALGORITHM , ( err , key ) => { if ( err ) { return reject ( err ) ; } return resolve ( key ) ; } ) ; } ) ; } 
function Node ( id , opts ) { var me = this this . id = id Object . defineProperty ( me , 'inner' , { value : opts . inner , enumerable : false , writable : true } ) Object . defineProperty ( me , 'outer' , { value : opts . outer , enumerable : false , writable : true } ) Object . defineProperty ( me , this . inner , { value : new Edge ( { inner : this . inner , outer : this . outer , id : id } ) , enumerable : false , writable : true } ) Object . defineProperty ( me , this . outer , { value : new Edge ( { inner : this . outer , outer : this . inner , id : id } ) , enumerable : false , writable : true } ) } 
function Edge ( opts ) { this . id = opts . id this . innerformat = opts . inner + '_%s' this . outerformat = opts . outer + '_%s' this . innerkey = format ( this . innerformat , this . id ) this . outerkey = format ( this . outerformat , this . id ) this [ opts . inner ] = function ( cb ) { this . all ( function ( error , array ) { if ( error ) return cb ( error ) if ( ! array || ! array . length ) return cb ( null , array || [ ] ) array = array . map ( function ( gid ) { return format ( this . innerformat , String ( gid ) ) } , this ) db . sunion ( array , cb ) } . bind ( this ) ) } this [ opts . outer ] = function ( cb ) { this . all ( function ( error , array ) { if ( error ) return cb ( error ) if ( ! array || ! array . length ) return cb ( null , array || [ ] ) array = array . map ( function ( gid ) { return format ( this . outerformat , gid ) } , this ) db . sunion ( array , cb ) } . bind ( this ) ) } } 
function getDynamicSegments ( segments ) { return segments . filter ( item => item . type === 1 || ! ! item . name ) . map ( item => item . value || item . name ) ; } 
function createEncodeStream ( schema ) { const stream = new BinaryStream ( { readableObjectMode : false , writableObjectMode : true , transform : transformEncode , } ) ; stream [ kschema ] = schema ; return stream ; } 
function createDecodeStream ( bufOrSchema ) { let schema = null ; const isBuffer = Buffer . isBuffer ( bufOrSchema ) ; if ( ! isBuffer ) { schema = bufOrSchema ; } const stream = new BinaryStream ( { transform : transformDecode , readableObjectMode : true , writableObjectMode : false , } ) ; stream [ kschema ] = schema ; if ( isBuffer ) { stream . append ( bufOrSchema ) ; } return stream ; } 
function transformEncode ( chunk , encoding , cb ) { try { encode ( chunk , this [ kschema ] , this ) ; const buf = this . slice ( ) ; this . consume ( buf . length ) ; cb ( null , buf ) ; } catch ( error ) { cb ( error ) ; } } 
function transformDecode ( chunk , encoding , cb ) { this . append ( chunk ) ; try { while ( this . length > 0 ) { const transaction = new Transaction ( this ) ; const data = decode ( transaction , this [ kschema ] ) ; transaction . commit ( ) ; this . push ( data ) ; } cb ( ) ; } catch ( error ) { if ( error instanceof NotEnoughDataError ) { cb ( ) ; } else { cb ( error ) ; } } } 
function erdosRenyi ( GraphClass , options ) { if ( ! isGraphConstructor ( GraphClass ) ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid Graph constructor.' ) ; var order = options . order , probability = options . probability , rng = options . rng || Math . random ; var graph = new GraphClass ( ) ; 
function erdosRenyiSparse ( GraphClass , options ) { if ( ! isGraphConstructor ( GraphClass ) ) throw new Error ( 'graphology-generators/random/erdos-renyi: invalid Graph constructor.' ) ; var order = options . order , probability = options . probability , rng = options . rng || Math . random ; var graph = new GraphClass ( ) ; 
function generateBLEPayloadParser ( profileData ) { var outputSrc = "" ; log ( " ***************************************************************************" ) ; log ( " Generating JavaScript source file for BLE Payload parser " ) ; log ( " ***************************************************************************" ) ; outputSrc = outputSrc + addLicenseText ( ) ; outputSrc = outputSrc + "//" + "\r\n" + "// PayloadParser.js" + "\r\n" + "//" + "\r\n" + "// Autogenerated source" + "\r\n" + "//" + "\r\n" + "// ---------------------------------" + "\r\n" + "// BLE Payload parser " + "\r\n" + "// ---------------------------------" + "\r\n" + "\r\n" + " 'use strict'" + "\r\n" + " var Int64LE = require('int64-buffer').Int64LE; " + "\r\n" + " import DLog from '../common/DLog'; " + "\r\n" + " const dp =require('./PayloadDefs'); " + "\r\n" + "\r\n" ; for ( var x = 0 ; x < profileData . Services . length ; x ++ ) { var service = profileData . Services [ x ] ; var serviceNameStr = prepareSrcString ( service . Name ) ; var svcNameSnakeStr = prepareSrcStringAsSnakeCase ( service . Name ) ; for ( var y = 0 ; y < service . Characteristics . length ; y ++ ) { var characteristic = service . Characteristics [ y ] ; var characteristicNameStr = prepareSrcString ( characteristic . Name ) ; var characteristicNameSnakeStr = prepareSrcStringAsSnakeCase ( characteristic . Name ) ; var chr_json_filename = "chr_" + characteristicNameSnakeStr ; outputSrc = outputSrc + " var " + chr_json_filename + "_JSON = require('../device_services/profile/chr/" + chr_json_filename + "'); " + "\r\n" + " var " + chr_json_filename + "_uuid = " + chr_json_filename + "_JSON.Characteristic.uuid; " + "\r\n" + " if(" + chr_json_filename + "_JSON.Characteristic.Value != undefined ){ " + "\r\n" + " var " + chr_json_filename + "_format = " + chr_json_filename + "_JSON.Characteristic.Value.Field.Format; " + "\r\n" + " } " + "\r\n" ; } } outputSrc = outputSrc + "\r\n" + " var nPayloadParserObjCnt = 0; " + "\r\n" + " var instancePayloadParser = null; " + "\r\n" + " const BLE_CHARC_VALUE_MAX_LEN = 20; " + "\r\n" + "\r\n" + " export function getPayloadParserInstance() " + "\r\n" + " { " + "\r\n" + " if(nPayloadParserObjCnt > 0 ) " + "\r\n" + " { " + "\r\n" + " DLog.printDebugMsg('Its a singleton class, returning existing instance of PayloadParser class '); " + "\r\n" + " return instancePayloadParser; " + "\r\n" + " } " + "\r\n" + " nPayloadParserObjCnt++; " + "\r\n" + " DLog.printDebugMsg('PayloadParser Object Count is ' + nPayloadParserObjCnt); " + "\r\n" + " instancePayloadParser = new PayloadParser(); " + "\r\n" + " return instancePayloadParser; " + "\r\n" + " } " + "\r\n" + "\r\n" + " class PayloadParser { " + "\r\n" + " constructor(props){ " + "\r\n" + " } " + "\r\n" + "\r\n" + " parse(svc_class_name,args) " + "\r\n" + " { " + "\r\n" + " switch(args.characteristic) " + "\r\n" + " { " + "\r\n" ; for ( var x = 0 ; x < profileData . Services . length ; x ++ ) { var service = profileData . Services [ x ] ; var serviceNameStr = prepareSrcString ( service . Name ) ; var svcNameSnakeStr = prepareSrcStringAsSnakeCase ( service . Name ) ; for ( var y = 0 ; y < service . Characteristics . length ; y ++ ) { var characteristic = service . Characteristics [ y ] ; var characteristicNameStr = prepareSrcString ( characteristic . Name ) ; var characteristicNameSnakeStr = prepareSrcStringAsSnakeCase ( characteristic . Name ) ; var chr_json_filename = "chr_" + characteristicNameSnakeStr ; var pkt_chr_name = "pkt_" + characteristicNameSnakeStr ; outputSrc = outputSrc + " case " + chr_json_filename + "_uuid.toUpperCase() : " + "\r\n" + " DLog.printDebug(this,' Characteristics format is = '+ " + chr_json_filename + "_format );" + "\r\n" + " if( " + chr_json_filename + "_format == 'uint8' || " + "\r\n" + " " + chr_json_filename + "_format == 'uint16' || " + "\r\n" + " " + chr_json_filename + "_format == 'uint32' || " + "\r\n" + " " + chr_json_filename + "_format == 'uint64') " + "\r\n" + " {" + "\r\n" + " let " + pkt_chr_name + " = {" + "\r\n" + " " + characteristicNameStr + " : {" + "\r\n" + " 'FMT':' '," + "\r\n" + " }" + "\r\n" + " }" + "\r\n" + " " + pkt_chr_name + "." + characteristicNameStr + ".FMT = " + chr_json_filename + "_format;" + "\r\n" + " return this.parseDatapayloadPkt(args.value, " + pkt_chr_name + ");" + "\r\n" + " }" + "\r\n" + " else" + "\r\n" + " {" + "\r\n" + " if(dp." + pkt_chr_name + " != undefined) {" + "\r\n" + " return this.parseDatapayloadPkt(args.value,dp." + pkt_chr_name + ");" + "\r\n" + " }" + "\r\n" + " break;" + "\r\n" + " } " + "\r\n" ; } } outputSrc = outputSrc + " default : " + "\r\n" + " return null; " + "\r\n" + " } " + "\r\n" + " return null; " + "\r\n" + " } " + "\r\n" + "\r\n" + " parseDatapayloadPkt(packetArr, datapayloadDef)" + "\r\n" + " { " + "\r\n" + " var packetBytBuf = this.byteArray2DVByteBuffer(packetArr); " + "\r\n" + " if(packetBytBuf === null) " + "\r\n" + " { " + "\r\n" + " DLog.printDebug(this,'packetBytBuf is NUll '); " + "\r\n" + " return 'parse_error'; " + "\r\n" + " } " + "\r\n" + "\r\n" + " var datapayloadStruct = {}; " + "\r\n" + " var totaldatapayloadStructKeys = Object.keys(datapayloadStruct).length; " + "\r\n" + " var totaldatapayloadStructValues = Object.values(datapayloadStruct).length; " + "\r\n" + " var totalFields = Object.keys(datapayloadDef).length; " + "\r\n" + "\r\n" + " DLog.printDebug(this,'total datapayload Fields = ' + totalFields + " + "\r\n" + " ' /totaldatapayloadStructKeys = ' + totaldatapayloadStructKeys + " + "\r\n" + " ' /totaldatapayloadStructValues = ' + totaldatapayloadStructValues ); " + "\r\n" + "\r\n" + " for (var [keyFieldName, valueFieldDef] of Object.entries(datapayloadDef)) { " + "\r\n" + " datapayloadStruct[keyFieldName] = this.extractData(packetBytBuf, valueFieldDef); " + "\r\n" + " } " + "\r\n" + "\r\n" + " totaldatapayloadStructKeys = Object.keys(datapayloadStruct).length " + "\r\n" + " totaldatapayloadStructValues = Object.values(datapayloadStruct).length; " + "\r\n" + "\r\n" + " DLog.printDebug(this,'/totaldatapayloadStructKeys = ' + totaldatapayloadStructKeys + " + "\r\n" + " ' /totaldatapayloadStructValues = ' + totaldatapayloadStructValues ); " + "\r\n" + " DLog.printDebug(this,datapayloadStruct); " + "\r\n" + "\r\n" + " return datapayloadStruct; " + "\r\n" + " } " + "\r\n" + "\r\n" + " extractData(payloadDataBytBuf, payloadDataFieldDef) " + "\r\n" + " { " + "\r\n" + " let dataPos = payloadDataFieldDef.POS || 0; " + "\r\n" + " let dataType = payloadDataFieldDef.FMT || 'uint8'; " + "\r\n" + " let dataLenInBytes = payloadDataFieldDef.LEN || 1; " + "\r\n" + "\r\n" + " DLog.printDebug(this,' payloadDataFieldDef = ' + dataPos + '/' + dataType + '/' + dataLenInBytes); " + "\r\n" + "\r\n" + " switch (dataType) { " + "\r\n" + " case 'uint8': " + "\r\n" + " return payloadDataBytBuf.getUint8(dataPos, true); // LITTLE_ENDIAN " + "\r\n" + " case 'uint16': " + "\r\n" + " return payloadDataBytBuf.getUint16(dataPos, true); " + "\r\n" + " case 'uint32': " + "\r\n" + " return payloadDataBytBuf.getUint32(dataPos, true); " + "\r\n" + " case 'uint64': " + "\r\n" + " return null; " + "\r\n" + " case 'string_ascii': " + "\r\n" + " return this.extractStringData(payloadDataBytBuf, dataPos, dataLenInBytes) " + "\r\n" + " default: " + "\r\n" + " return null; " + "\r\n" + " } " + "\r\n" + " } " + "\r\n" + "\r\n" + " extractStringData(payloadDataBytBuf, keyvalueSeekPos, keyvalueLen) { " + "\r\n" + " var keyvalueStr = ''; " + "\r\n" + " if(keyvalueLen > BLE_CHARC_VALUE_MAX_LEN) " + "\r\n" + " { " + "\r\n" + " keyvalueLen = BLE_CHARC_VALUE_MAX_LEN; " + "\r\n" + " } " + "\r\n" + "\r\n" + " var keyvalueSeekPos = 0; " + "\r\n" + " for(var m=0;m<keyvalueLen;m++) " + "\r\n" + " { " + "\r\n" + " var keyvaluebyte = payloadDataBytBuf.getUint8(keyvalueSeekPos, true); " + "\r\n" + " keyvalueStr = keyvalueStr + String.fromCharCode(keyvaluebyte); " + "\r\n" + " DLog.printDebug(this, 'keyvalueStr= ' + keyvalueStr); " + "\r\n" + " keyvalueSeekPos++; " + "\r\n" + " } " + "\r\n" + " DLog.printDebug(this, 'keyvalueStr= ' + keyvalueStr); " + "\r\n" + " return keyvalueStr; " + "\r\n" + " }" + "\r\n" + "\r\n" + " byteArray2DVByteBuffer(byteArray) " + "\r\n" + " { " + "\r\n" + " var byteArrayLen = byteArray.length; " + "\r\n" + "\r\n" + " if(byteArrayLen < 1) " + "\r\n" + " { " + "\r\n" + " DLog.printDebug(this,'packet byte arr size is zero = ' + byteArrayLen); " + "\r\n" + " return null; " + "\r\n" + " } " + "\r\n" + "\r\n" + " DLog.printDebug(this,'packet byte arr size = ' + byteArrayLen); " + "\r\n" + "\r\n" + " var objUint8Array = new Uint8Array(new ArrayBuffer(byteArrayLen)); " + "\r\n" + " objUint8Array.set(byteArray); " + "\r\n" + "\r\n" + " var dvByteBuf = new DataView(objUint8Array.buffer); " + "\r\n" + " for(var m=0;m<byteArrayLen;m++) " + "\r\n" + " { " + "\r\n" + " DLog.printDebug(this,'DVByteBuf = ' + dvByteBuf.getUint8(m)); " + "\r\n" + " } " + "\r\n" + " return dvByteBuf; " + "\r\n" + " } " + "\r\n" + " } " + "\r\n" ; FileManager . CreateFile ( ".\\protocols\\PayloadParser.js" , outputSrc ) ; log ( "PayloadParser.js generated sucessfully " ) ; log ( " ---------------------------------------------------------------------" ) ; } 
function validateFiles ( files , stateLint ) { let ok = true for ( const file of files ) { try { ok = validate ( file , stateLint ) && ok } catch ( err ) { console . log ( ` ${ file } \n \t ${ err . message } ` ) ok = false } } 
function validate ( file , stateLint ) { const json = readAndParse ( file ) const problems = stateLint . validate ( json ) if ( problems . length ) { console . log ( ` ${ file } ` ) problems . forEach ( p => console . log ( ` \t ${ p } ` ) ) } return ( problems . length === 0 ) } 
function showIfHelp ( args , description ) { const name = path . basename ( args [ 1 ] ) const opts = args . slice ( 2 ) if ( ! ( opts . length === 1 && [ '--help' , '-h' , '-?' ] . includes ( opts [ 0 ] ) ) ) { return false } console . log ( ` ${ name } ` ) console . log ( '' ) console . log ( description ) return true } 
function getRange ( ) { if ( __ . nullValueSeparator == "bottom" ) { return [ h ( ) + 1 - __ . nullValueSeparatorPadding . bottom - __ . nullValueSeparatorPadding . top , 1 ] ; } else if ( __ . nullValueSeparator == "top" ) { return [ h ( ) + 1 , 1 + __ . nullValueSeparatorPadding . bottom + __ . nullValueSeparatorPadding . top ] ; } return [ h ( ) + 1 , 1 ] ; } 
function single_curve ( d , ctx ) { var centroids = compute_centroids ( d ) ; var cps = compute_control_points ( centroids ) ; ctx . moveTo ( cps [ 0 ] . e ( 1 ) , cps [ 0 ] . e ( 2 ) ) ; for ( var i = 1 ; i < cps . length ; i += 3 ) { if ( __ . showControlPoints ) { for ( var j = 0 ; j < 3 ; j ++ ) { ctx . fillRect ( cps [ i + j ] . e ( 1 ) , cps [ i + j ] . e ( 2 ) , 2 , 2 ) ; } } ctx . bezierCurveTo ( cps [ i ] . e ( 1 ) , cps [ i ] . e ( 2 ) , cps [ i + 1 ] . e ( 1 ) , cps [ i + 1 ] . e ( 2 ) , cps [ i + 2 ] . e ( 1 ) , cps [ i + 2 ] . e ( 2 ) ) ; } } 
function color_path ( d , ctx ) { ctx . beginPath ( ) ; if ( ( __ . bundleDimension !== null && __ . bundlingStrength > 0 ) || __ . smoothness > 0 ) { single_curve ( d , ctx ) ; } else { single_path ( d , ctx ) ; } ctx . stroke ( ) ; } 
function paths ( data , ctx ) { ctx . clearRect ( - 1 , - 1 , w ( ) + 2 , h ( ) + 2 ) ; ctx . beginPath ( ) ; data . forEach ( function ( d ) { if ( ( __ . bundleDimension !== null && __ . bundlingStrength > 0 ) || __ . smoothness > 0 ) { single_curve ( d , ctx ) ; } else { single_path ( d , ctx ) ; } } ) ; ctx . stroke ( ) ; } 
function brushUpdated ( newSelection ) { __ . brushed = newSelection ; events . brush . call ( pc , __ . brushed ) ; pc . renderBrushed ( ) ; } 
function selected ( ) { var actives = d3 . keys ( __ . dimensions ) . filter ( is_brushed ) , extents = actives . map ( function ( p ) { return brushes [ p ] . extent ( ) ; } ) ; 
function consecutive ( first , second ) { var length = d3 . keys ( __ . dimensions ) . length ; return d3 . keys ( __ . dimensions ) . some ( function ( d , i ) { return ( d === first ) ? i + i < length && __ . dimensions [ i + 1 ] === second : false ; } ) ; } 
function brushFor ( axis ) { var brush = d3 . svg . multibrush ( ) ; brush . y ( __ . dimensions [ axis ] . yscale ) . on ( "brushstart" , function ( ) { if ( d3 . event . sourceEvent !== null ) { events . brushstart . call ( pc , __ . brushed ) ; d3 . event . sourceEvent . stopPropagation ( ) ; } } ) . on ( "brush" , function ( ) { brushUpdated ( selected ( ) ) ; } ) . on ( "brushend" , function ( ) { 
function ( angle ) { var ret = angle ; if ( angle > Math . PI ) { ret = angle - 1.5 * Math . PI ; ret = angle - 1.5 * Math . PI ; } else { ret = angle - 0.5 * Math . PI ; ret = angle - 0.5 * Math . PI ; } return - ret ; } 
function ( data ) { if ( data ) rq . data ( data ) ; rq . invalidate ( ) ; _clear ( ) ; rq . render ( ) ; } 
function convertProperty ( originalKey , originalValue , isRtl ) { const key = getPropertyDoppelganger ( originalKey , isRtl ) const value = getValueDoppelganger ( key , originalValue , isRtl ) return { key , value } } 
function getPropertyDoppelganger ( property , isRtl ) { const convertedProperty = isRtl ? propertiesToConvert . rtl [ property ] : propertiesToConvert . ltr [ property ] return convertedProperty || property } 
function getValueDoppelganger ( key , originalValue , isRtl ) { if ( isNullOrUndefined ( originalValue ) ) { return originalValue } const flowDirection = isRtl ? 'rtl' : 'ltr' if ( isObject ( originalValue ) ) { return convert ( originalValue , flowDirection ) 
function analyzeOriginalValue ( originalValue ) { const isNum = isNumber ( originalValue ) const logicallessValue = isNum ? originalValue : originalValue . replace ( / ^\s*logical\s* / i , '' ) const isLogical = ! isNum && logicallessValue . length !== originalValue . length const importantlessValue = isNum ? logicallessValue : logicallessValue . replace ( / \s*!important.*?$ / , '' ) const isImportant = ! isNum && importantlessValue . length !== logicallessValue . length return { isLogical , logicallessValue , isImportant , importantlessValue } } 
function DirWatcher ( inputPath , persistent ) { assert . ok ( this instanceof DirWatcher ) ; var self = this ; var absPath = path . resolve ( inputPath ) ; if ( ! fs . statSync ( absPath ) . isDirectory ( ) ) { throw new Error ( inputPath + "is not a directory!" ) ; } EventEmitter . call ( self ) ; self . ready = false ; self . on ( "ready" , function ( ) { self . ready = true ; } ) ; Object . defineProperties ( self , { 
function ( options ) { this . body = options . body ; this . data = options . data ; this . type = options . type ; } 
function init ( app , context , swagger ) { logger . log ( 'debug' , '%s|adding|routes|context=%s' + ( swagger ? "|SWAGGER" : "" ) , meta . module , context , meta ) ; if ( swagger ) { describeModels ( swagger ) ; swagger . addGET ( { 'spec' : { "description" : "Text To Speech REST API" , "path" : context + format + '/play/{voice}/{text}' , "notes" : "The REST API /play/ transform a text phrase into a spoken audio stream playable through an HTML5 <audio> element. You can pre-generate the audio by calling the REST API /generate/ before calling this one, to have the audio start playing as soon as you call the /play/ API." , "method" : "GET" , "summary" : "Transform a text phrase into an Audio Stream." , "nickname" : "play" , "responseClass" : "BinaryAudioStream" , "produces" : [ "audio/mp4" , "application/json" ] , "params" : [ swagger . params . path ( "voice" , "A 'human' voice to use, to speak the phrase" , "string" , { "values" : voices , "valueType" : "LIST" } , "Alex" ) , swagger . params . path ( "text" , "The text phrase to be spoken." , "string" ) ] , "errorResponses" : [ fix ( swagger . errors . notFound ( 'voice' ) ) , fix ( swagger . errors . notFound ( 'text' ) ) , fix ( swagger . errors . invalid ( 'voice' ) ) ] } , 'action' : function ( req , res ) { logger . log ( 'debug' , '%s|say|voice=%s|text=%s' , meta . module , req . params . voice , req . params . text , meta ) ; if ( voices . indexOf ( req . params . voice ) < 0 ) { swagger . stopWithError ( res , { code : 400 , reason : 'The voice ' + req . params . voice + ' is not supported' } ) ; return ; } tts . play ( req . param ( 'text' , 'No text passed' ) , req . param ( 'voice' , voice ) , function ( err , data ) { if ( err ) { if ( ! err . code || ! err . reason ) err = { code : 500 , reason : util . inspect ( err ) } ; swagger . stopWithError ( res , err ) ; } else { res . writeHead ( 200 , { 'Content-Type' : 'audio/mp4' } ) ; res . end ( data ) ; } } ) ; } } ) . addPost ( { 'spec' : { "description" : "Text To Speech REST API" , "path" : context + format + '/generate' , "notes" : "To avoid latency, when using the REST API /play/, you can pre-generate the audio on the server by calling this API." , "method" : "POST" , "summary" : "Generate the audio on the server." , "nickname" : "generate" , "responseClass" : "Status" , "params" : [ swagger . params . body ( "params" , "The text phrase to be pre-generated on the server" , 'TextToSpeech' , '{"voice" : "Alex", "text":"Hello world", "async" : true}' ) ] , "errorResponses" : [ fix ( swagger . errors . notFound ( 'voice' ) ) , fix ( swagger . errors . notFound ( 'text' ) ) , fix ( swagger . errors . invalid ( 'voice' ) ) , fix ( swagger . errors . invalid ( 'async' ) ) ] } , 'action' : function ( req , res ) { if ( ! req . body ) { swagger . stopWithError ( res , { code : 400 , reason : 'The BODY of the request is empty' } ) ; return ; } logger . log ( 'debug' , '%s|generate|voice=%s|text=%s|async=%s' , meta . module , req . body . voice , req . body . text , req . body . async , meta ) ; if ( voices . indexOf ( req . body . voice ) < 0 ) { swagger . stopWithError ( res , { code : 400 , reason : 'The voice ' + req . params . voice + ' is not supported' } ) ; return ; } var async ; if ( typeof req . body . async != 'undefined' ) { if ( req . body . async === true || req . body . async === 'true' ) { async = true ; } else if ( req . body . async === false || req . body . async === 'false' ) { async = false ; } else { swagger . stopWithError ( res , { code : 400 , reason : 'The async must be true or false' } ) ; return ; } } else async = false ; tts . play ( req . param ( 'text' , 'No text passed' ) , req . param ( 'voice' , voice ) , function ( err ) { if ( async === false ) { if ( err ) { if ( ! err . code || ! err . reason ) err = { code : 500 , reason : util . inspect ( err ) } ; swagger . stopWithError ( res , err ) ; } else { res . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; res . end ( '{"result":"OK","async":false}' ) ; } } } ) ; if ( async ) { res . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; res . end ( '{"result":"OK","async":true}' ) ; } } } ) ; } else { router . add ( app , context + '/tts.json/play' , 'GET' , function ( req , res ) { tts . play ( req . param ( 'text' , 'No text passed' ) , req . param ( 'voice' , voice ) , function ( err , data ) { if ( err ) { res . writeHead ( 404 , { "Content-Type" : "text/html" } ) ; res . end ( '<html><body><pre>Unable to generate tts <br/>\n' + err + '</pre></body></html>' ) ; } else { res . writeHead ( 200 , { 'Content-Type' : 'audio/mp4' } ) ; res . end ( data ) ; } } ) ; } ) ; router . add ( app , context + '/tts.json/generate' , 'POST' , function ( req , res ) { var async = req . param ( 'async' , 'true' ) === 'true' ? true : false ; tts . play ( req . param ( 'text' , 'No text passed' ) , req . param ( 'voice' , voice ) , function ( err ) { if ( async === false ) { if ( err ) { res . writeHead ( 404 , { 'Content-Type' : 'application/json' } ) ; res . end ( '{"result":"FAILED","async":false,"error":' + JSON . stringify ( err ) + '}' ) ; } else { res . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; res . end ( '{"result":"OK","async":false}' ) ; } } } ) ; if ( async ) { res . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; res . end ( '{"result":"OK","async":true}' ) ; } } ) ; } tts . init ( ) ; } 
function ReadFileCache ( sourceDir , charset ) { assert . ok ( this instanceof ReadFileCache ) ; assert . strictEqual ( typeof sourceDir , "string" ) ; this . charset = charset ; EventEmitter . call ( this ) ; Object . defineProperties ( this , { sourceDir : { value : sourceDir } , sourceCache : { value : { } } } ) ; } 
function done ( err , resource ) { totalRequestElapsed += ( ( new Date ( ) . getTime ( ) ) - started ) ; ++ totalRequests ; stats . avgFetchTime = parseInt ( totalRequestElapsed / totalRequests ) ; if ( err || verbose ) util . log ( 'cache|execute|done|err=' + err + '|result=' + ( resource ? 'found' : 'null' ) ) ; if ( err ) { ++ stats . failed ; } if ( ! err && defaultCacheTTL ) { 
function Cache ( size , ttl ) { defaultCacheSize = size || defaultCacheSize ; defaultCacheTTL = ttl || defaultCacheTTL ; if ( verbose ) util . log ( 'Cache|defaultCacheSize=' + defaultCacheSize + '|defaultCacheTTL=' + defaultCacheTTL ) ; if ( defaultCacheSize > 10000 ) { util . log ( 'Cache|WARNING|Weeding out a BIG (' + defaultCacheSize + ') cache when it is full can degrade the NODE server performance since it is not async' ) ; } } 
function API ( apiUrl , requester ) { var _this = this ; _this . apiUrl = apiUrl ; * Creates a new user account * @param user {object} the user to be created. Requires username, email, password * @param authUser {object} the user authenticating this request. Requires token or username and password * @param notify {boolean} send notification email to user * @return {Promise<object>} the newly created user */ _this . createUser = function ( user , authUser , notify ) { user . send_notify = notify ; return request ( 'admin/users' , authUser , user ) . then ( stat . checkCreatedResponse ) ; } ; _this . editUser = function ( user , authUser ) { return request ( 'admin/users/' + user . username , authUser , user , 'PATCH' ) . then ( stat . checkStandardResponse ) ; } ; _this . deleteUser = function ( user , authUser ) { if ( user . username === authUser . username ) { return Promise . reject ( 'Users cannot delete themselves!' ) ; } return request ( 'admin/users/' + user . username , authUser , null , 'DELETE' ) . then ( stat . checkNoContentResponse ) ; } ; _this . searchUsers = function ( query , limit , authUser ) { limit = limit || 10 ; * Retrieves a user * @param user {object} the user to retrieve. Requires username * @param authUser {object} the user to authenticate as. If null the email field in the response will be empty. Requires token or username and password * @returns {Promise<object>} the found user object */ _this . getUser = function ( user , authUser ) { return request ( 'users/' + user . username , authUser ) . then ( stat . checkStandardResponse ) ; } ; _this . searchRepos = function ( query , uid , limit ) { uid = uid || 0 ; limit = limit || 10 ; return request ( 'repos/search?q=' + query + '&uid=' + uid + '&limit=' + limit ) . then ( stat . checkOkResponse ) ; } ; _this . createRepo = function ( repo , user ) { return request ( 'user/repos' , user , { name : repo . name , description : repo . description , private : repo . private } , null ) . then ( stat . checkCreatedResponse ) ; } ; _this . getRepo = function ( repo , authUser ) { return request ( 'repos/' + repo . full_name , authUser ) . then ( stat . checkStandardResponse ) ; } ; _this . listRepos = function ( user ) { return request ( 'user/repos' , user ) . then ( stat . checkStandardResponse ) ; } ; _this . deleteRepo = function ( repo , user ) { return request ( 'repos/' + user . username + '/' + repo . name , user , null , 'DELETE' ) . then ( stat . checkNoContentResponse ) ; } ; _this . createToken = function ( token , user ) { return request ( 'users/' + user . username + '/tokens' , user , { name : token . name } ) . then ( stat . checkCreatedResponse ) ; } ; _this . listTokens = function ( user ) { return request ( 'users/' + user . username + '/tokens' , user ) . then ( stat . checkStandardResponse ) ; } ; _this . createPublicKey = function ( key , user ) { return request ( 'user/keys' , user , { title : key . title , key : key . key } ) . then ( stat . checkCreatedResponse ) ; } ; _this . listPublicKeys = function ( user ) { return request ( 'users/' + user . username + '/keys' , user ) . then ( stat . checkStandardResponse ) ; } ; _this . getPublicKey = function ( key , user ) { return request ( 'user/keys/' + key . id , user ) . then ( stat . checkStandardResponse ) ; } ; _this . deletePublicKey = function ( key , user ) { return request ( 'user/keys/' + key . id , user , null , 'DELETE' ) . then ( stat . checkNoContentResponse ) ; } ; return _this ; } 
function sortReadingFrames ( a , b ) { var aSort = a . length var bSort = b . length if ( bSort - aSort === 0 ) { var aStartCodon = a . slice ( 0 , 3 ) . toUpperCase ( ) . replace ( 'T' , 'U' ) var bStartCodon = b . slice ( 0 , 3 ) . toUpperCase ( ) . replace ( 'T' , 'U' ) if ( aStartCodon === 'AUG' ) { aSort ++ } if ( bStartCodon === 'AUG' ) { bSort ++ } } return bSort - aSort } 
function ( options ) { options = ( options || { } ) ; this . agent = options . agent ; this . defaults = options . defaults || { } ; this . log = options . logger || ( new Ax ( { level : "info" } ) ) ; this . _sharedCookieJar = new CookieJar ( ) ; this . logCurl = options . logCurl || false ; } 
function ( level , message ) { var debug = ( level == "debug" || level == "error" ) ; if ( ! message ) { return message . toString ( ) ; } if ( typeof ( message ) == "object" ) { if ( message instanceof Error && debug ) { return message . stack ; } else { return inspect ( message ) ; } } else { return message . toString ( ) ; } } 
function ( options ) { this . log = options . logger ; this . cookieJar = options . cookieJar ; this . encoding = options . encoding ; this . logCurl = options . logCurl ; processOptions ( this , options || { } ) ; createRequest ( this ) ; } 
function ( timeout ) { var request = this , milliseconds = 0 ; ; if ( ! timeout ) return this ; if ( typeof timeout === "number" ) { milliseconds = timeout ; } else { milliseconds = ( timeout . milliseconds || 0 ) + ( 1000 * ( ( timeout . seconds || 0 ) + ( 60 * ( ( timeout . minutes || 0 ) + ( 60 * ( timeout . hours || 0 ) ) ) ) ) ) ; } this . _timeout = milliseconds ; return this ; } 
function ( request , options ) { request . log . debug ( "Processing request options .." ) ; 
function ( request ) { var timeout ; request . log . debug ( "Creating request .." ) ; request . log . debug ( request ) ; var reqParams = { host : request . host , port : request . port , method : request . method , path : request . path + ( request . query ? '?' + request . query : "" ) , headers : request . getHeaders ( ) , 
function ( event ) { var emitter = request . emitter ; var textStatus = STATUS_CODES [ response . status ] ? STATUS_CODES [ response . status ] . toLowerCase ( ) : null ; if ( emitter . listeners ( response . status ) . length > 0 || emitter . listeners ( textStatus ) . length > 0 ) { emitter . emit ( response . status , response ) ; emitter . emit ( textStatus , response ) ; } else { if ( emitter . listeners ( event ) . length > 0 ) { emitter . emit ( event , response ) ; } else if ( ! response . isRedirect ) { emitter . emit ( "response" , response ) ; 
function ( req ) { var headers = req . getHeaders ( ) ; var headerString = "" ; for ( var key in headers ) { headerString += '-H "' + key + ": " + headers [ key ] + '" ' ; } var bodyString = "" if ( req . content ) { bodyString += "-d '" + req . content . body + "' " ; } var query = req . query ? '?' + req . query : "" ; console . log ( "curl " + "-X " + req . method . toUpperCase ( ) + " " + req . scheme + "://" + req . host + ":" + req . port + req . path + query + " " + headerString + bodyString ) ; } 
function ( raw , request , callback ) { var response = this ; this . _raw = raw ; 
function ( object , names ) { var keys = ( names && names . length > 0 ) ? names : Object . keys ( $H ( object ) ) ; var hash = keys . reduce ( function ( hash , key ) { hash [ key ] = getHeader ( object , key ) ; return hash ; } , { } ) ; 
function ( constructor ) { constructor . prototype . getHeader = function ( name ) { return getHeader ( this , name ) ; } ; constructor . prototype . getHeaders = function ( ) { return getHeaders ( this , arguments ) ; } ; } 
function ( constructor ) { constructor . prototype . _setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . _setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; } 
function ( constructor ) { constructor . prototype . setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; } 
function ( constructor ) { constructor . prototype . getHeader = function ( name ) { return getHeader ( this , name ) ; } ; constructor . prototype . getHeaders = function ( ) { return getHeaders ( this , arguments ) ; } ; constructor . prototype . setHeader = function ( key , value ) { return setHeader ( this , key , value ) ; } ; constructor . prototype . setHeaders = function ( hash ) { return setHeaders ( this , hash ) ; } ; } 
function ( encoding ) { var enc = encoding || "utf8" ; var codecOptions = undefined ; while ( 1 ) { if ( getType ( enc ) === "String" ) enc = enc . replace ( / [- ] / g , "" ) . toLowerCase ( ) ; var codec = iconv . encodings [ enc ] ; var type = getType ( codec ) ; if ( type === "String" ) { 
function ( options ) { 
function ( options ) { var table = options . table , key , revCharsTable = options . revCharsTable ; if ( ! table ) { throw new Error ( "Encoding '" + options . type + "' has incorect 'table' option" ) ; } if ( ! revCharsTable ) { revCharsTable = options . revCharsTable = { } ; for ( key in table ) { revCharsTable [ table [ key ] ] = parseInt ( key ) ; } } return { toEncoding : function ( str ) { str = ensureString ( str ) ; var strLen = str . length ; var bufLen = strLen ; for ( var i = 0 ; i < strLen ; i ++ ) if ( str . charCodeAt ( i ) >> 7 ) bufLen ++ ; var newBuf = new Buffer ( bufLen ) , gbkcode , unicode , defaultChar = revCharsTable [ iconv . defaultCharUnicode . charCodeAt ( 0 ) ] ; for ( var i = 0 , j = 0 ; i < strLen ; i ++ ) { unicode = str . charCodeAt ( i ) ; if ( unicode >> 7 ) { gbkcode = revCharsTable [ unicode ] || defaultChar ; newBuf [ j ++ ] = gbkcode >> 8 ; 
function copyFile ( opts ) { var importStr , ext ; if ( ! opts ) return console . log ( 'incomplete options' ) ; ext = opts . ext ; if ( typeof ext === 'string' ) { ext = [ ext ] ; 
function encodeUserAuth ( user ) { if ( ! user ) { return null ; } var token = user . token ; if ( token ) { var sha1 = typeof token === 'object' ? token . sha1 : token ; return 'token ' + sha1 ; } return 'Basic ' + base64 . encode ( user . username + ':' + user . password ) } 
function addRoute ( app , route , method , destination ) { if ( method === 'GET' ) { app . get ( route , destination ) ; } else if ( method === 'POST' ) { app . post ( route , destination ) ; } else if ( method === 'PUT' ) { app . put ( route , destination ) ; } else if ( method === 'DELETE' ) { app . delete ( route , destination ) ; } else { throw new Error ( meta . module + '|addRoute|EXCEPTION|unknown method:"' + method + '"|expecter=GET,POST,PUT,DELETE' ) ; } logger . log ( 'debug' , '%s|add|method=%s|route=%s' , meta . module , method , route , meta ) ; } 
function add ( app , route , method , destination ) { var methods ; if ( typeof ( method ) === 'string' ) { methods = method . split ( ',' ) ; } else if ( typeof ( method ) === 'object' ) { 
function ( projectName ) { var self = this ; this . projectName = projectName ; this . projDir = './' + projectName + '/' ; this . packages = this . projDir + '.meteor/packages' ; this . _runTerminalCommand ( 'meteor create ' + projectName , function ( ) { 
function ( command , callback ) { var exec = require ( 'child_process' ) . exec ; exec ( command , function ( err ) { if ( err ) puts ( 'exec error: ' + err ) ; callback . call ( this ) ; } ) ; } 
function ( ) { fs . copySync ( this . initSource , this . projDir ) ; fs . removeSync ( this . projDir + 'client/.gitkeep' ) ; fs . removeSync ( this . projDir + 'server/.gitkeep' ) ; puts ( ' Created: .jshintrc' ) ; puts ( ' Created: .jshintignore' ) ; puts ( ' Created: makefile' ) ; } 
function ( ) { fs . removeSync ( this . projDir + this . projectName + '.js' ) ; fs . removeSync ( this . projDir + this . projectName + '.html' ) ; fs . removeSync ( this . projDir + this . projectName + '.css' ) ; puts ( ' Removed: original boilerplate' ) ; } 
function ( packageName ) { var oldPackages , newPackages ; oldPackages = fs . readFileSync ( this . packages , { encoding : 'utf-8' } ) ; newPackages = oldPackages . replace ( packageName + '\n' , '' ) ; fs . writeFileSync ( this . packages , newPackages ) ; } 
function ( projPath ) { 
function ( resName , action ) { var route , newContent , oldFileStr , newFileStr , res ; resName = resName || '' ; res = require ( './parse_name' ) ( resName ) 
function ( resName , opts ) { 
function ( action ) { var templateStr = fs . readFileSync ( this . contrTemplates + action + '.js' , { encoding : 'utf-8' } ) ; 
function ( ) { if ( fs . existsSync ( this . controllerPath + '_app.js' ) ) return ; fs . copySync ( this . contrTemplates + '_app.js' , this . controllerPath + '_app.js' ) ; console . log ( ' Created: ' + this . controllerPath + '_app.js' ) ; } 
function Vec4 ( ) { switch ( arguments . length ) { case 1 : 
function create ( EConstructor ) { FormattedError . displayName = EConstructor . displayName || EConstructor . name return FormattedError function FormattedError ( format ) { if ( format ) { format = formatter . apply ( null , arguments ) } return new EConstructor ( format ) } } 
function Mat44 ( that ) { that = that || [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] ; if ( that instanceof Array ) { this . data = that ; } else { this . data = new Array ( 16 ) ; this . data [ 0 ] = that . data [ 0 ] ; this . data [ 1 ] = that . data [ 1 ] ; this . data [ 2 ] = that . data [ 2 ] ; this . data [ 3 ] = that . data [ 3 ] ; this . data [ 4 ] = that . data [ 4 ] ; this . data [ 5 ] = that . data [ 5 ] ; this . data [ 6 ] = that . data [ 6 ] ; this . data [ 7 ] = that . data [ 7 ] ; this . data [ 8 ] = that . data [ 8 ] ; this . data [ 9 ] = that . data [ 9 ] ; this . data [ 10 ] = that . data [ 10 ] ; this . data [ 11 ] = that . data [ 11 ] ; this . data [ 12 ] = that . data [ 12 ] ; this . data [ 13 ] = that . data [ 13 ] ; this . data [ 14 ] = that . data [ 14 ] ; this . data [ 15 ] = that . data [ 15 ] ; } } 
function Discovery ( options ) { var self = this ; if ( options && ! is . obj ( options ) ) debug ( 'Dicovery constructor bad options argument: ' + inspect ( options ) ) ; 
function plugin ( options , callback ) { options = options || { } ; return function ( style ) { if ( options . resolveUrl !== false ) { style . define ( 'url' , stylus . resolver ( ) ) ; } style . use ( rider ( { implicit : options . implicit } ) ) ; style . on ( 'end' , postprocessor ( options , callback ) ) ; if ( options . husl ) { 
function Vec2 ( ) { switch ( arguments . length ) { case 1 : 
function Quaternion ( ) { switch ( arguments . length ) { case 1 : 
function wrap ( fn ) { return wrapped function wrapped ( node , parent ) { try { fn ( node , parent ) } catch ( error ) { if ( ! error [ ID ] ) { error [ ID ] = true error . message += ': `' + view ( node ) + '`' if ( parent ) { error . message += ' in `' + view ( parent ) + '`' } } throw error } } } 
function unist ( node ) { var type var children var value var key var index var length assert . ok ( object ( node ) , 'node should be an object' ) type = node . type children = node . children value = node . value assert . ok ( 'type' in node , 'node should have a type' ) assert . strictEqual ( typeof type , 'string' , '`type` should be a string' ) assert . notStrictEqual ( type , '' , '`type` should not be empty' ) if ( value != null ) { assert . strictEqual ( typeof value , 'string' , '`value` should be a string' ) } location ( node . position ) for ( key in node ) { if ( defined . indexOf ( key ) === - 1 ) { vanilla ( key , node [ key ] ) } } if ( children != null ) { assert . ok ( array ( children ) , '`children` should be an array' ) index = - 1 length = children . length while ( ++ index < length ) { exports ( children [ index ] , node ) } } } 
function vanilla ( key , value ) { try { assert . deepStrictEqual ( value , JSON . parse ( JSON . stringify ( value ) ) ) } catch ( error ) { assert . fail ( 'non-specced property `' + key + '` should be JSON' ) } } 
function view ( value ) { try { if ( inspect ) { return inspect ( value , { colors : false } ) } else { return JSON . stringify ( value ) } } catch ( error ) { return String ( value ) } } 
function parent ( node ) { unist ( node ) assert . strictEqual ( 'value' in node , false , 'parent should not have `value`' ) assert . ok ( 'children' in node , 'parent should have `children`' ) } 
function text ( node ) { unist ( node ) assert . strictEqual ( 'children' in node , false , 'text should not have `children`' ) assert . ok ( 'value' in node , 'text should have `value`' ) } 
function empty ( node ) { unist ( node ) assert . strictEqual ( 'value' in node , false , 'void should not have `value`' ) assert . strictEqual ( 'children' in node , false , 'void should not have `children`' ) } 
function location ( location ) { if ( location != null ) { assert . ok ( object ( location ) , '`position` should be an object' ) position ( location . start , 'position.start' ) position ( location . end , 'position.end' ) } } 
function position ( position , name ) { if ( position != null ) { assert . ok ( object ( position ) , '`' + name + '` should be an object' ) if ( position . line != null ) { assert . ok ( 'line' in position , '`' + name + '` should have numeric `line`' ) assert . ok ( position . line >= 1 , '`' + name + '.line` should be gte `1`' ) } if ( position . column != null ) { assert . ok ( 'column' in position , '`' + name + '` should have numeric `column`' ) assert . ok ( position . column >= 1 , '`' + name + '.column` should be gte `1`' ) } } } 
function Vec3 ( ) { switch ( arguments . length ) { case 1 : 
function Snackbar ( data , options , callback ) { if ( data !== "" ) { this . options = this . activateOptions ( options ) ; this . data = data ; this . callback = callback ; this . start ( ) ; this . snackbar ( ) ; } else { console . warn ( "SnackbarLight: You can not create a empty snackbar please give it a string." ) ; } } 
function ( ) { if ( ! document . getElementById ( "snackbar-container" ) ) { var snackbarContainer = document . createElement ( "div" ) ; snackbarContainer . setAttribute ( "id" , "snackbar-container" ) ; document . body . appendChild ( snackbarContainer ) ; } } 
function ( callback , delay ) { var remaining = delay ; this . timer = { 
function ( ) { var __self = this , snackbar = document . createElement ( "div" ) ; 
function ( element ) { var __self = this ; 
function ( newOptions ) { var __self = this , options = newOptions || { } ; for ( var opt in this . options ) { if ( __self . options . hasOwnProperty ( opt ) && ! options . hasOwnProperty ( opt ) ) { options [ opt ] = __self . options [ opt ] ; } } return options ; } 
function ( Vue ) { var __self = this ; Vue . prototype . $snackbar = { } ; Vue . prototype . $snackbar . create = function ( data , options , callback ) { __self . create ( data , options , callback ) ; } ; } 
function privKeyToWIF ( privKey ) { var toCompressed = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var wif = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : zconfig . mainnet . wif ; if ( toCompressed ) privKey = privKey + '01' ; return bs58check . encode ( Buffer . from ( wif + privKey , 'hex' ) ) ; } 
function privKeyToPubKey ( privKey ) { var toCompressed = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : false ; var pkBuffer = Buffer . from ( privKey , 'hex' ) ; var publicKey = secp256k1 . publicKeyCreate ( pkBuffer , toCompressed ) ; return publicKey . toString ( 'hex' ) ; } 
function WIFToPrivKey ( wifPk ) { var og = bs58check . decode ( wifPk , 'hex' ) . toString ( 'hex' ) ; og = og . substr ( 2 , og . length ) ; 
function mkMultiSigRedeemScript ( pubKeys , M , N ) { 
function multiSigRSToAddress ( redeemScript ) { var scriptHash = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : zconfig . mainnet . scriptHash ; 
function Transform ( that ) { that = that || { } ; if ( that . data instanceof Array ) { 
function vuePack ( file , encoding , callback ) { if ( ! file ) { throw new PluginError ( 'gulp-vue-pack' , 'file'); } if ( file . isStream ( ) ) { throw new PluginError ( 'gulp-vue-pack' , '.vue'); } if ( ! file . contents ) { 
function convertToJSContent ( script , template , style , fileName , filePath ) { if ( ! script ) { return "" ; } 
function processJavascript ( fileName , script , processedTemplate , style , filePath ) { script = script . replace ( VUE_COMPONENT_IMPORT_REG , function ( matchedLine , variableName , vuePath , index , contents ) { return "var " + variableName + " = global.__FORGE_ES6_VUE_COMPONENTS__['" + path . resolve ( filePath , vuePath ) . replace ( / \\ / g , "/" ) + "']" ; } ) ; script = script . replace ( SCRIPT_REPLACER_REG , "var " + fileName + " = Vue.extend(" ) ; script += ");\n" ; script += fileName + ".options.template = " + processedTemplate ; 
function Triangle ( ) { switch ( arguments . length ) { case 1 : 
function mkPubkeyHashReplayScript ( address , blockHeight , blockHash ) { var pubKeyHash = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : zconfig . mainnet . pubKeyHash ; 
function mkScriptHashReplayScript ( address , blockHeight , blockHash ) { var addrHex = bs58check . decode ( address ) . toString ( 'hex' ) ; var subAddrHex = addrHex . substring ( 4 , addrHex . length ) ; 
function addressToScript ( address , blockHeight , blockHash ) { 
function serializeTx ( txObj ) { var serializedTx = '' ; var _buf16 = Buffer . alloc ( 4 ) ; 
function createRawTx ( history , recipients , blockHeight , blockHash ) { var txObj = { locktime : 0 , version : 1 , ins : [ ] , outs : [ ] } ; txObj . ins = history . map ( function ( h ) { return { output : { hash : h . txid , vout : h . vout } , script : '' , prevScriptPubKey : h . scriptPubKey , sequence : 'ffffffff' } ; } ) ; txObj . outs = recipients . map ( function ( o ) { return { script : addressToScript ( o . address , blockHeight , blockHash ) , satoshis : o . satoshis } ; } ) ; return txObj ; } 
function getScriptSignature ( privKey , signingTx , hashcode ) { 
function signTx ( _txObj , i , privKey ) { var compressPubKey = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : false ; var hashcode = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : zconstants . SIGHASH_ALL ; 
function multiSign ( _txObj , i , privKey , redeemScript ) { var hashcode = arguments . length > 4 && arguments [ 4 ] !== undefined ? arguments [ 4 ] : zconstants . SIGHASH_ALL ; 
function applyMultiSignatures ( _txObj , i , signatures , redeemScript ) { 
function bash ( str , pattern , options ) { if ( typeof str !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } if ( typeof pattern !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } if ( isWindows ( ) ) { throw new Error ( 'bash-match does not work on windows' ) ; } try { var opts = createOptions ( pattern , options ) ; var res = spawn . sync ( getBashPath ( ) , cmd ( str , pattern , opts ) , opts ) ; var err = toString ( res . stderr ) ; if ( err ) { return handleError ( err , opts ) ; } return ! ! toString ( res . stdout ) ; } catch ( err ) { return handleError ( err , opts ) ; } } 
function cmd ( str , pattern , options ) { var valid = [ 'dotglob' , 'extglob' , 'failglob' , 'globstar' , 'nocaseglob' , 'nullglob' ] ; var args = [ ] ; for ( var key in options ) { if ( options . hasOwnProperty ( key ) && valid . indexOf ( key ) !== - 1 ) { args . push ( '-O' , key ) ; } } args . push ( '-c' , 'IFS=$"\n"; if [[ "' + str + '" = ' + pattern + ' ]]; then echo true; fi' ) ; return args ; } 
function createOptions ( pattern , options ) { if ( options && options . normalized === true ) return options ; var opts = extend ( { cwd : process . cwd ( ) } , options ) ; if ( opts . nocase === true ) opts . nocaseglob = true ; if ( opts . nonull === true ) opts . nullglob = true ; if ( opts . dot === true ) opts . dotglob = true ; if ( ! opts . hasOwnProperty ( 'globstar' ) && pattern . indexOf ( '**' ) !== - 1 ) { opts . globstar = true ; } if ( ! opts . hasOwnProperty ( 'extglob' ) && isExtglob ( pattern ) ) { opts . extglob = true ; } opts . normalized = true ; return opts ; } 
function getBashPath ( ) { if ( bashPath ) return bashPath ; if ( fs . existsSync ( '/usr/local/bin/bash' ) ) { bashPath = '/usr/local/bin/bash' ; } else if ( fs . existsSync ( '/bin/bash' ) ) { bashPath = '/bin/bash' ; } else { bashPath = 'bash' ; } return bashPath ; } 
function isBetween ( p , left , right ) { if ( p >= left && p <= right ) return true ; return false ; } 
function ( reporter , definition ) { this . reporter = reporter this . definition = definition this . reporter . beforeRenderListeners . add ( definition . name , this , Statistics . prototype . handleBeforeRender ) this . reporter . afterRenderListeners . add ( definition . name , this , Statistics . prototype . handleAfterRender ) this . _defineEntities ( ) } 
function zSecretKeyToTransmissionKey ( a_sk ) { var sk_enc = prf . PRF_addr_sk_enc ( Buffer . from ( a_sk , 'hex' ) ) ; 
function changeEvent ( event ) { var srcPattern = new RegExp ( '/.*(?=/' + config . source + ')/' ) ; log ( 'File ' + event . path . replace ( srcPattern , '' ) + ' ' + event . type ) ; } 
function Memory ( options ) { options = options || { } ; var self = this ; self . flush = options . db . _db . _memory . flush || false ; self . flushInterval = options . db . _db . _memory . flushInterval || 10000 ; self . flushFile = options . file ; self . memoryTable = [ ] ; console . log ( 'Data will be handled using \'Memory\' driver' ) ; 
function VarStreamWriter ( callback , options ) { this . lastContext = '' ; this . callback = callback ; // Output stream callback this . options = options ; this . imbricatedArrayEntries = new Array ( ) ; this . scopes = new Array ( ) ; this . contexts = new Array ( ) ; this . previousContext = '' ; } 
function deductcost ( ) { var cost = [ ] ; if ( ! giving . have || giving . have . length < 1 ) return ; 
function DataHandler ( options ) { options = options || { } ; var dataHandler = options . db . _db . _driver || 'disk' ; switch ( dataHandler ) { 
function VarStreamReader ( scope , prop , options ) { // Keep a ref to the root scope this . rootScope = { root : scope , prop : prop } ; // Save the options this . options = options ; // Store current scopes for backward references this . previousNodes = [ ] ; // The parse state this . state = PARSE_NEWLINE ; // The current values this . leftValue = '' ; this . rightValue = '' ; this . operator = '' ; this . escaped = ESC_NONE ; } 
function VarStream ( rootObject , rootProperty , options ) { var self = this ; // Ensure new were used if ( ! ( this instanceof VarStream ) ) { return new VarStream ( rootObject , rootProperty , options ) ; } // Ensure we had root object and property if ( ! ( rootObject instanceof Object ) ) { throw new Error ( 'No root object provided.' ) ; } if ( 'string' !== typeof rootProperty || ootProperty = ') throw new Error ( 'No root property name given.' ) ; } // Parent constructor DuplexStream . call ( this ) ; this . _varstreamReader = new VarStreamReader ( rootObject , rootProperty , options ? options & VarStreamReader . OPTIONS : 0 ) ; this . _varstreamWriter = new VarStreamWriter ( function ( str ) { self . push ( new Buffer ( str , 'utf8' ) ) ; } , options ? options & VarStreamWriter . OPTIONS : 0 ) ; // Parse input this . _write = function _write ( chunk , encoding , done ) { this . _varstreamReader . read ( chunk . toString ( encoding !== 'buffer' ? encoding : 'utf8' ) ) ; done ( ) ; } ; // Output data this . _read = function _read ( ) { this . _varstreamWriter . write ( rootObject [ rootProperty ] ) ; this . push ( null ) ; } ; } 
function ( sub_node ) { if ( sub_node ) { walk ( sub_node , depth + 1 ) ; } else if ( node . pages ) { node . pages . forEach ( function ( sub_node , name ) { walk ( sub_node , depth + 1 ) ; } ) ; } } 
function find ( list , version ) { for ( let v = 0 , vLength = list . length ; v < vLength ; v += 1 ) { const candidate = list [ v ] if ( candidate . version === version ) { return candidate } } throw new Error ( ` ${ version } ` ) } 
function Duplexer ( options , writableStream , readableStream ) { const _this = this ; 
function ( provides ) { if ( _ . isArray ( provides ) ) { this . _arguments = this . _provides = ( ! this . _provides ) ? provides : this . _provides . concat ( provides ) ; } else { this . _provides = _ . extend ( { } , this . _provides , provides ) ; this . _arguments = _ . map ( this . deps , function ( key ) { return this . _provides [ key ] ; } , this ) ; } return this ; } 
function ( context , callback ) { if ( arguments . length === 1 ) { callback = context ; context = this . _context ; } if ( this . isAsync ) { 
function each ( arr , callback ) { var wrapper = this ; if ( this . isAsync ) { return async . each ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { arr . each ( function ( item ) { wrapper . call ( item ) ; } ) ; if ( callback ) { callback ( ) ; } } } 
function map ( arr , callback ) { var wrapper = this ; if ( this . isAsync ) { async . map ( arr , function ( item , cb ) { wrapper . call ( item , cb ) ; } , callback ) ; } else { callback ( null , arr . map ( function ( item ) { return wrapper . call ( item ) ; } ) ) ; } } 
function ( selectedDates , dateStr , instance ) { that . setProperty ( "dateValue" , selectedDates , true ) ; that . fireOnChange ( { selectedDates : selectedDates , dateStr : dateStr , instance : instance } ) ; } 
function ( selectedDates , dateStr , instance ) { this . fireOnChange ( { selectedDates : selectedDates , dateStr : dateStr , instance : instance } ) ; } 
function XOR128 ( x , y , z , w ) { if ( ( x && x < 1 ) || ( y && y < 1 ) || ( z && z < 1 ) || ( w && w < 1 ) ) { throw new Error ( 'Invalid Seed' ) ; } this . x = x ? x : Math . random ( ) * 4294967296 ; this . y = y ? y : Math . random ( ) * 4294967296 ; this . z = z ? z : Math . random ( ) * 4294967296 ; this . w = w ? w : Math . random ( ) * 4294967296 ; } 
function initOptions ( options ) { var defaultOptions = { root : process . cwd ( ) , port : '3333' , style : path . resolve ( __dirname , '../public/screen.css' ) , dtpl : path . resolve ( __dirname , '../public/dir_template.html' ) , ftpl : path . resolve ( __dirname , '../public/file_template.html' ) , view : 'details' , silent : false } ; return merge ( defaultOptions , options ) ; } 
function startServer ( options ) { options = initOptions ( options ) ; var app = connect ( ) , root = options . root , TEST = process . env . TEST , isSilent = options . silent || TEST ; if ( ! isSilent ) { app . use ( log ) ; } var smOpts = { } ; var smOptMap = { ftpl : 'template' , style : 'style' } ; Object . keys ( smOptMap ) . forEach ( function ( key ) { if ( options [ key ] !== undefined ) smOpts [ smOptMap [ key ] ] = options [ key ] ; } ) ; 
function showSuccessInfo ( options ) { 
function log ( req , res , next ) { console . log ( '[' + chalk . grey ( ts ( ) ) + '] ' + chalk . white ( decodeURI ( req . url ) ) ) ; next ( ) ; } 
function ( valueToSet , type , iface , propertyKeys ) { type = type . toLowerCase ( ) ; propertyKeys . forEach ( function ( propertyKey ) { if ( type == 'get' ) valueToSet [ 'Get' + propertyKey ] = function ( callback ) { iface . getProperty ( propertyKey , callback ) ; } else valueToSet [ 'Set' + propertyKey ] = function ( value , callback ) { iface . setProperty ( propertyKey , value , callback ) ; } } ) ; } 
function md5 ( data ) { var md5sum = crypto . createHash ( 'md5' ) ; md5sum . update ( data ) ; return md5sum . digest ( 'hex' ) ; } 
function init ( user_id , secret , storage ) { API_USER_ID = user_id ; API_SECRET = secret ; TOKEN_STORAGE = storage ; var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; if ( fs . existsSync ( TOKEN_STORAGE + hashName ) ) { TOKEN = fs . readFileSync ( TOKEN_STORAGE + hashName , { encoding : 'utf8' } ) ; } if ( ! TOKEN . length ) { getToken ( ) ; } } 
function sendRequest ( path , method , data , useToken , callback ) { var headers = { } headers [ 'Content-Type' ] = 'application/json' ; headers [ 'Content-Length' ] = Buffer . byteLength ( JSON . stringify ( data ) ) ; if ( useToken && TOKEN . length ) { headers [ 'Authorization' ] = 'Bearer ' + TOKEN ; } if ( method === undefined ) { method = 'POST' ; } if ( useToken === undefined ) { useToken = false ; } var options = { 
function getToken ( ) { var data = { grant_type : 'client_credentials' , client_id : API_USER_ID , client_secret : API_SECRET } sendRequest ( 'oauth/access_token' , 'POST' , data , false , saveToken ) ; function saveToken ( data ) { TOKEN = data . access_token ; var hashName = md5 ( API_USER_ID + '::' + API_SECRET ) ; fs . writeFileSync ( TOKEN_STORAGE + hashName , TOKEN ) ; } } 
function returnError ( message ) { var data = { is_error : 1 } ; if ( message !== undefined && message . length ) { data [ 'message' ] = message } return data ; } 
function createAddressBook ( callback , bookName ) { if ( ( bookName === undefined ) || ( ! bookName . length ) ) { return callback ( returnError ( "Empty book name" ) ) ; } var data = { bookName : bookName } ; sendRequest ( 'addressbooks' , 'POST' , data , true , callback ) ; } 
function editAddressBook ( callback , id , bookName ) { if ( ( id === undefined ) || ( bookName === undefined ) || ( ! bookName . length ) ) { return callback ( returnError ( "Empty book name or book id" ) ) ; } var data = { name : bookName } ; sendRequest ( 'addressbooks/' + id , 'PUT' , data , true , callback ) ; } 
function removeAddressBook ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id , 'DELETE' , { } , true , callback ) ; } 
function getBookInfo ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id , 'GET' , { } , true , callback ) ; } 
function getEmailsFromBook ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id + '/emails' , 'GET' , { } , true , callback ) ; } 
function addEmails ( callback , id , emails ) { if ( ( id === undefined ) || ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( "Empty email or book id" ) ) ; } var data = { emails : serialize ( emails ) } ; sendRequest ( 'addressbooks/' + id + '/emails' , 'POST' , data , true , callback ) ; } 
function getEmailInfo ( callback , id , email ) { if ( ( id === undefined ) || ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( "Empty email or book id" ) ) ; } sendRequest ( 'addressbooks/' + id + '/emails/' + email , 'GET' , { } , true , callback ) ; } 
function campaignCost ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'addressbooks/' + id + '/cost' , 'GET' , { } , true , callback ) ; } 
function listCampaigns ( callback , limit , offset ) { var data = { } if ( limit === undefined ) { limit = null ; } else { data [ 'limit' ] = limit ; } if ( offset === undefined ) { offset = null ; } else { data [ 'offset' ] = offset ; } sendRequest ( 'campaigns' , 'GET' , data , true , callback ) ; } 
function getCampaignInfo ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id , 'GET' , { } , true , callback ) ; } 
function campaignStatByCountries ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id + '/countries' , 'GET' , { } , true , callback ) ; } 
function campaignStatByReferrals ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty book id' ) ) ; } sendRequest ( 'campaigns/' + id + '/referrals' , 'GET' , { } , true , callback ) ; } 
function createCampaign ( callback , senderName , senderEmail , subject , body , bookId , name , attachments ) { if ( ( senderName === undefined ) || ( ! senderName . length ) || ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( subject === undefined ) || ( ! subject . length ) || ( body === undefined ) || ( ! body . length ) || ( bookId === undefined ) ) { return callback ( returnError ( 'Not all data.' ) ) ; } if ( name === undefined ) { name = '' ; } if ( attachments === undefined ) { attachments = '' ; } if ( attachments . length ) { attachments = serialize ( attachments ) ; } var data = { sender_name : senderName , sender_email : senderEmail , 
function cancelCampaign ( callback , id ) { if ( id === undefined ) { return callback ( returnError ( 'Empty campaign id' ) ) ; } sendRequest ( 'campaigns/' + id , 'DELETE' , { } , true , callback ) ; } 
function addSender ( callback , senderName , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( senderName === undefined ) || ( ! senderName . length ) ) { return callback ( returnError ( 'Empty sender name or email' ) ) ; } var data = { email : senderEmail , name : senderName } sendRequest ( 'senders' , 'POST' , data , true , callback ) ; } 
function removeSender ( callback , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } var data = { email : senderEmail } sendRequest ( 'senders' , 'DELETE' , data , true , callback ) ; } 
function activateSender ( callback , senderEmail , code ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) || ( code === undefined ) || ( ! code . length ) ) { return callback ( returnError ( 'Empty email or activation code' ) ) ; } var data = { code : code } sendRequest ( 'senders/' + senderEmail + '/code' , 'POST' , data , true , callback ) ; } 
function getSenderActivationMail ( callback , senderEmail ) { if ( ( senderEmail === undefined ) || ( ! senderEmail . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'senders/' + senderEmail + '/code' , 'GET' , { } , true , callback ) ; } 
function getEmailGlobalInfo ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email , 'GET' , { } , true , callback ) ; } 
function removeEmailFromAllBooks ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email , 'DELETE' , { } , true , callback ) ; } 
function emailStatByCampaigns ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'emails/' + email + '/campaigns' , 'GET' , { } , true , callback ) ; } 
function addToBlackList ( callback , emails , comment ) { if ( ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } if ( comment === undefined ) { comment = '' ; } var data = { emails : base64 ( emails ) , comment : comment } sendRequest ( 'blacklist' , 'POST' , data , true , callback ) ; } 
function removeFromBlackList ( callback , emails ) { if ( ( emails === undefined ) || ( ! emails . length ) ) { return callback ( returnError ( 'Empty emails' ) ) ; } var data = { emails : base64 ( emails ) , } sendRequest ( 'blacklist' , 'DELETE' , data , true , callback ) ; } 
function getBalance ( callback , currency ) { if ( currency === undefined ) { var url = 'balance' ; } else { var url = 'balance/' + currency . toUpperCase ( ) ; } sendRequest ( url , 'GET' , { } , true , callback ) ; } 
function smtpListEmails ( callback , limit , offset , fromDate , toDate , sender , recipient ) { if ( limit === undefined ) { limit = 0 ; } if ( offset === undefined ) { offset = 0 ; } if ( fromDate === undefined ) { fromDate = '' ; } if ( toDate === undefined ) { toDate = '' ; } if ( sender === undefined ) { sender = '' ; } if ( recipient === undefined ) { recipient = '' ; } var data = { limit : limit , offset : offset , from : fromDate , to : toDate , sender : sender , recipient : recipient } sendRequest ( 'smtp/emails' , 'GET' , data , true , callback ) ; } 
function smtpGetEmailInfoById ( callback , id ) { if ( ( id === undefined ) || ( ! id . length ) ) { return callback ( returnError ( 'Empty id' ) ) ; } sendRequest ( 'smtp/emails/' + id , 'GET' , { } , true , callback ) ; } 
function smtpUnsubscribeEmails ( callback , emails ) { if ( emails === undefined ) { return callback ( returnError ( 'Empty emails' ) ) ; } var data = { emails : serialize ( emails ) } sendRequest ( 'smtp/unsubscribe' , 'POST' , data , true , callback ) ; } 
function smtpAddDomain ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } var data = { email : email } sendRequest ( 'smtp/domains' , 'POST' , data , true , callback ) ; } 
function smtpVerifyDomain ( callback , email ) { if ( ( email === undefined ) || ( ! email . length ) ) { return callback ( returnError ( 'Empty email' ) ) ; } sendRequest ( 'smtp/domains/' + email , 'GET' , { } , true , callback ) ; } 
function smtpSendMail ( callback , email ) { if ( email === undefined ) { return callback ( returnError ( 'Empty email data' ) ) ; } email [ 'html' ] = base64 ( email [ 'html' ] ) ; var data = { email : serialize ( email ) } ; sendRequest ( 'smtp/emails' , 'POST' , data , true , callback ) ; } 
function getOpt ( resHtml , outputPath ) { if ( commandLine . minifyall ) { console . log ( '' ) ; console . log ( 'minify all. Process may take a few minutes with large file.' ) ; console . log ( '' ) ; minifyFile ( resHtml , outputPath ) ; } else { console . log ( '' ) ; console . log ( 'Output file name : ' + outputPath ) ; console . log ( '' ) ; writeFile ( resHtml , outputPath ) ; } } 
function minifyFile ( resHtml , outputPath ) { var resHtml = minify ( resHtml , opt , function ( err ) { if ( err ) { console . error ( 'error will processing file.' ) ; } } ) ; console . log ( '' ) ; console . log ( 'Output file name : ' + outputPath ) ; console . log ( '' ) ; writeFile ( resHtml , outputPath ) ; } 
function writeFile ( resHtml , outputPath ) { fs . writeFile ( outputPath , resHtml , function ( err ) { if ( err ) { console . log ( '' ) ; console . log ( 'File error: ' + err + '. Exit.' ) ; } else { console . log ( '' ) ; console . log ( 'All done. Exit.' . green ) ; } } ) ; } 
function ( params ) { 
function AdapterRegistryException ( message , context ) { this . message = message ; this . name = "AdapterRegistryException" ; this . context = context ; this . stack = ( new Error ( ) ) . stack ; } 
function Cookie ( options ) { this . options = options || { } ; this . options . expires = typeof this . options . expires === 'number' ? this . options . expires : 30 ; this . options . path = this . options . path !== undefined ? this . options . path : '/' ; this . options . secure = typeof this . options . secure === 'boolean' ? this . options . secure : false ; } 
function set ( key , value , options ) { options = options || this . options ; var days = parseInt ( options . expires || - 1 ) ; if ( value !== undefined && typeof value !== 'function' ) { var t = new Date ( ) ; t . setDate ( ( t . getDate ( ) + days ) ) ; var res = ( document . cookie = [ this . encode ( key ) , '=' , this . stringify ( value ) , 
function get ( key , value ) { var i , parts , name , cookie ; var result = key ? undefined : { } ; var cookies = ( document . cookie || '' ) . split ( '; ' ) ; for ( i = 0 ; i < cookies . length ; i ++ ) { parts = cookies [ i ] . split ( '=' ) ; name = this . decode ( parts . shift ( ) ) ; cookie = parts . join ( '=' ) ; if ( key && key === name ) { 
function del ( key , options ) { if ( ! options ) { options = { } ; for ( var z in this . options ) { options [ z ] = this . options [ z ] ; } } options . expires = - 1 ; this . set ( key , '' , options ) ; } 
function clear ( except , options ) { var keys = this . get ( ) , z ; except = except || [ ] ; for ( z in keys ) { if ( ~ except . indexOf ( z ) ) { continue ; } this . del ( z , options ) ; } } 
function curry2 ( fn , self ) { var out = function ( ) { if ( arguments . length === 0 ) return out return arguments . length > 1 ? fn . apply ( self , arguments ) : bind . call ( fn , self , arguments [ 0 ] ) } out . uncurry = function uncurry ( ) { return fn } return out } 
function createTouchList ( target , list ) { if ( Array . isArray ( list ) && list [ 0 ] && ! Array . isArray ( list [ 0 ] ) ) { list = [ list ] ; } list = list . map ( function ( entry , index ) { var x = entry [ 0 ] ; var y = entry [ 1 ] ; var id = entry [ 2 ] || index ; return createTouch ( x , y , target , id ) ; } ) ; return document . createTouchList . apply ( document , list ) ; } 
function initTouchEvent ( touchEvent , type , touches ) { var touch1 = touches [ 0 ] ; return touchEvent . initTouchEvent ( 
function ( ) { if ( _ . isObject ( this . cache ) ) { return this . cache ; } if ( _ . has ( this . app . caches , this . cache ) ) { return this . app . caches [ this . cache ] ; } throw new errors . NoSuchCacheError ( f ( 'You should define app.caches[%j] interface' , this . cache ) ) ; } 
function createIconButton ( viewerElm , css , eventType ) { const buttonElm = $ . create ( 'div' , { 'class' : css } ) $ . listen ( buttonElm , { 'click' : ( event ) => { event . preventDefault ( ) if ( event . buttons === 0 ) { $ . dispatch ( viewerElm , eventType ) } } } ) return buttonElm } 
function Context ( params , logger ) { this . params = params ; this . result = new Obus ( ) ; this . errors = new Obus ( ) ; this . logger = logger ; } 
function ContextStack ( dict , tpl ) { this [ cache_stack ] = [ ] ; this . tpl = tpl ; this . push ( util . global ) ; if ( tpl . fallback !== U ) { this . hasFallback = true ; this . fallback = tpl . fallback ; } switch ( util . ntype ( dict ) ) { case 'object' : this . push ( dict ) ; break ; case 'array' : dict [ fn_var . dict ] ? dict . map ( this . push , this ) : this . push ( dict ) ; break ; default : ! util . exists ( dict ) || this . push ( dict ) ; } } 
function aggregatetNonEmpty ( res , str ) { util . empty ( str ) || res . push ( str ) ; return res ; } 
function Track ( app , logger ) { this . id = this . _createId ( ) ; this . logger = logger ; this . params = { } ; this . _app = app ; this . calls = { } ; this . _isFlushed = false ; } 
function cloneGalleryItem ( inst , element ) { 
function FistError ( code , msg ) { var err = new Error ( f ( '(%s) %s' , code , msg ) ) ; err . name = this . name ; Error . captureStackTrace ( err , this . constructor ) ; this . code = code ; this . message = err . message ; this . stack = err . stack ; } 
function Connect ( app , logger , req , res ) { this . req = req ; this . res = res ; * @public * @memberOf {Connect} * @property * @type {String} * */ this . route = null ; this . matches = [ ] ; this . routeIndex = - 1 ; this . _url = null ; } 
function ( localFilePath ) { let contentType = mime . lookup ( localFilePath ) ; let standerFilePath = localFilePath . replace ( / \\ / g , '/' ) ; fs . readFile ( localFilePath , function ( readFileErr , fileData ) { if ( readFileErr ) { throw readFileErr ; } const putConfig = { Bucket : bucket . Name , Body : fileData , Key : standerFilePath , ContentType : contentType , AccessControlAllowOrigin : options . AccessControlAllowOrigin || '*' , CacheControl : options . CacheControl || 'no-cache' , Expires : options . Expires || null } ; if ( options . contentEncoding ) { putConfig . ContentEncoding = options . contentEncoding ; } oss . putObject ( putConfig , function ( putObjectErr ) { if ( putObjectErr ) { console . error ( 'error:' , putObjectErr ) ; return putObjectErr ; } console . log ( 'upload success: ' + localFilePath ) ; if ( bucketPaths . indexOf ( standerFilePath ) === - 1 ) { bucketPaths . push ( standerFilePath ) ; } if ( localPaths . indexOf ( standerFilePath ) === - 1 ) { localPaths . push ( standerFilePath ) ; } 
function ( filePath ) { let standerPath = filePath . replace ( / \\ / g , '/' ) ; oss . deleteObject ( { Bucket : bucket . Name , Key : standerPath } , function ( err ) { if ( err ) { console . log ( 'error:' , err ) ; return err ; } let bucketIndex = bucketPaths . indexOf ( standerPath ) ; if ( bucketIndex !== - 1 ) { bucketPaths . splice ( bucketIndex , 1 ) ; } let localIndex = localPaths . indexOf ( standerPath ) ; if ( localIndex !== - 1 ) { localPaths . splice ( localIndex , 1 ) ; } console . log ( 'delete success:' + standerPath ) ; } ) ; } 
function Runtime ( unit , track , parent , args , done ) { * Runtime identity is a part of cacheKey and memorization key * * @public * @memberOf {Runtime} * @property * @type {String} * */ this . identity = unit . identify ( track , context ) ; this . unit = unit ; this . track = track ; this . parent = parent ; this . done = done ; this . pathsLeft = 0 ; this . keys = [ ] ; this . creationDate = 0 ; this . value = undefined ; this . statusBits = 0 ; this . context = context ; this . listeners = [ ] ; this . cacheKey = unit . app . params . name ; } 
function setupDispatch ( { actions : actionHandlers = { } , schemas = { } , services = { } , middlewares = [ ] , identOptions = { } } ) { const getService = setupGetService ( schemas , services ) let dispatch = async ( action ) => { debug ( 'Dispatch: %o' , action ) return handleAction ( action , { schemas , services , dispatch , identOptions , getService } , actionHandlers ) } if ( middlewares . length > 0 ) { dispatch = compose ( ... middlewares ) ( dispatch ) } return dispatch } 
function nextSchedule ( schedule , allowNow = false ) { if ( schedule ) { try { const dates = later . schedule ( schedule ) . next ( 2 ) return nextDate ( dates , allowNow ) } catch ( error ) { throw TypeError ( 'Invalid schedule definition' ) } } return null } 
async function deleteFn ( action , { getService } = { } ) { debug ( 'Action: DELETE' ) const { type , id , service : serviceId , endpoint } = action . payload const service = ( typeof getService === 'function' ) ? getService ( type , serviceId ) : null if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'DELETE' ) } const data = prepareData ( action . payload ) if ( data . length === 0 ) { return createError ( ` ${ service . id } ` , 'noaction' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'DELETE: Delete from service \'%s\' at %s.' , service . id , endpointDebug ) const { response } = await service . send ( appendToAction ( action , { data } ) ) return ( response . status === 'ok' ) ? { status : 'ok' } : response } 
async function request ( action , { getService , dispatch } ) { debug ( 'Action: REQUEST' ) const { type , service : serviceId = null , endpoint } = action . payload const service = getService ( type , serviceId ) if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'GET' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ` debug ( 'REQUEST: Fetch from service %s at %s' , service . id , endpointDebug ) const { response } = await service . receive ( action , dispatch ) return response } 
async function getIdent ( { payload , meta } , { getService , identOptions = { } } ) { if ( ! meta . ident ) { return createError ( 'GET_IDENT: The request has no ident' , 'noaction' ) } const { type } = identOptions if ( ! type ) { return createError ( 'GET_IDENT: Integreat is not set up with authentication' , 'noaction' ) } const service = getService ( type ) if ( ! service ) { return createUnknownServiceError ( type , null , 'GET_IDENT' ) } const propKeys = preparePropKeys ( identOptions . props ) const params = prepareParams ( meta . ident , propKeys ) if ( ! params ) { return createError ( 'GET_IDENT: The request has no ident with id or withToken' , 'noaction' ) } const { response } = await service . send ( { type : 'GET' , payload : { type , ... params } , meta : { ident : { root : true } } } ) return prepareResponse ( response , payload , propKeys ) } 
function integreat ( { schemas : typeDefs , services : serviceDefs , mappings = [ ] , auths : authDefs = [ ] , ident : identOptions = { } } , { adapters = { } , authenticators = { } , filters = { } , transformers = { } , actions = { } } = { } , middlewares = [ ] ) { if ( ! serviceDefs || ! typeDefs ) { throw new TypeError ( 'Call integreat with at least services and schemas' ) } * Function for dispatching actions to Integreat. Will be run through the * chain of middlewares before the relevant action handler is called. * @param {Object} action - The action to dispatch * @returns {Promise} Promise of result object */ dispatch : setupDispatch ( { actions , services , schemas , middlewares , identOptions } ) , on ( eventName , serviceId , listener ) { const service = services [ serviceId ] if ( service && service . on ) { service . on ( eventName , listener ) } } , typeFromPlural ( plural ) { return pluralTypes [ plural ] } } } 
function scheduleToAction ( def ) { if ( ! def ) { return null } const id = def . id || null const schedule = parseSchedule ( def . schedule ) const nextTime = nextSchedule ( schedule , true ) return { ... def . action , meta : { id , schedule , queue : ( nextTime ) ? nextTime . getTime ( ) : true } } } 
function authorizeItem ( item , access , { schemas , action , requireAuth } ) { const { ident , status } = access if ( status === 'refused' ) { return false } if ( ! item || ( ident && ident . root ) ) { return true } const schema = schemas [ item . type ] const scheme = getScheme ( schema , action ) return authorizeWithScheme ( item , scheme , ident , requireAuth ) } 
async function get ( action , { getService } = { } ) { const { type , service : serviceId = null , onlyMappedValues = false , endpoint } = action . payload const service = ( typeof getService === 'function' ) ? getService ( type , serviceId ) : null if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'GET' ) } const id = getIdFromPayload ( action . payload ) 
function sendRequest ( { adapter , serviceId } ) { return async ( { request , response , connection } ) => { if ( response ) { return response } try { response = await adapter . send ( request , connection ) return { ... response , access : request . access } } catch ( error ) { return createError ( ` ${ serviceId } ${ error } ` ) } } } 
function schema ( { id , plural , service , attributes : attrDefs , relationships : relDefs , access , internal = false } ) { const attributes = { ... expandFields ( attrDefs || { } ) , id : { type : 'string' } , type : { type : 'string' } , createdAt : { type : 'date' } , updatedAt : { type : 'date' } } const relationships = expandFields ( relDefs || { } ) const defaultAttrs = prepareDefaultAttrs ( attributes , attrDefs ) const defaultRels = prepareDefaultRels ( relationships , relDefs ) const castFn = cast ( { id , attributes , relationships , defaultAttrs , defaultRels } ) return { id , plural : plural || ` ${ id } ` , service , internal , attributes , relationships , access , cast ( data , { onlyMappedValues = false } = { } ) { return mapAny ( ( data ) => castFn ( data , { onlyMappedValues } ) , data ) } , castQueryParams ( relId , data ) { return castQueryParams ( relId , data , { relationships } ) } } } 
function mapping ( { filters , transformers , schemas = { } , mappings : mappingsArr = [ ] } = { } ) { const mappings = mappingsArr . reduce ( ( mappings , def ) => ( { ... mappings , [ def . id ] : def } ) , { } ) const createPipelineFn = createPipeline ( filters , transformers , schemas , mappings ) return ( mapping , overrideType ) => { const { id , type , schema , pipeline } = createPipelineFn ( mapping , overrideType ) if ( ! pipeline ) { return null } const mapper = mapTransform ( [ fwd ( 'data' ) , ... pipeline , rev ( set ( 'data' ) ) ] ) return { id , type , schema , fromService ( data , { onlyMappedValues = true } = { } ) { return data ? ensureArray ( ( onlyMappedValues ) ? mapper . onlyMappedValues ( data ) : mapper ( data ) ) : [ ] } , toService ( data , target = null ) { const mapped = mapper . rev . onlyMappedValues ( data ) return ( ( target ? Array . isArray ( target ) ? [ ... target ] . concat ( mapped ) : mergeDeepWith ( concatOrRight , target , mapped ) : mapped ) || null ) } } } } 
function mapFromService ( ) { return ( { response , request , responseMapper , mappings } ) => { if ( response . status !== 'ok' ) { return response } const type = request . params . type || Object . keys ( mappings ) const { onlyMappedValues , unmapped = false } = request . params if ( unmapped ) { return response } const { data , status = response . status , error , paging , params } = mapWithEndpoint ( responseMapper , response , request . action ) if ( status !== 'ok' ) { return removeDataProp ( { ... response , status , error } ) } const mapType = ( type ) => ( mappings [ type ] ) ? mappings [ type ] . fromService ( { ... request , data } , { onlyMappedValues } ) : [ ] return { ... response , status , ... ( ( paging ) ? { paging } : { } ) , ... ( ( params ) ? { params } : { } ) , data : ( data ) ? flatten ( mapAny ( mapType , type ) ) : undefined } } } 
function ( tailInfo ) { var z = this ; if ( tailInfo ) { z . q . push ( tailInfo ) ; } var ti ; 
function ( ) { var z = this ; var l = 0 ; Object . keys ( z . tails ) . forEach ( function ( k ) { l += ( z . tails [ k ] . buf || '' ) . length ; } ) ; return l ; } 
function preparePipeline ( pipeline , collection = { } ) { pipeline = [ ] . concat ( pipeline ) const replaceWithFunction = ( key ) => ( typeof key === 'string' ) ? collection [ key ] : key const isFunctionOrObject = ( obj ) => obj && [ 'function' , 'object' ] . includes ( typeof obj ) return pipeline . map ( replaceWithFunction ) . filter ( isFunctionOrObject ) } 
function prepareRevPipeline ( revPipeline , fwdPipeline , collection ) { return ( revPipeline ) ? preparePipeline ( revPipeline , collection ) : fwdPipeline . map ( ( fn ) => ( fn . rev ) ? fn . rev : null ) . filter ( Boolean ) } 
function castQueryParams ( relId , data , { relationships } ) { const relationship = relationships [ relId ] if ( ! relationship . query ) { return { } } return Object . keys ( relationship . query ) . reduce ( ( params , key ) => { const value = getField ( data , relationship . query [ key ] ) if ( value === undefined ) { throw new TypeError ( 'Missing value for query param' ) } return { ... params , [ key ] : value } } , { } ) } 
function setupQueue ( queue ) { let dispatch = null let subscribed = false return { queue , setDispatch ( dispatchFn ) { dispatch = dispatchFn if ( ! subscribed && typeof dispatch === 'function' ) { queue . subscribe ( dispatch ) subscribed = true } } , middleware ( next ) { return middleware ( next , queue ) } , async schedule ( defs ) { return schedule ( defs , queue ) } } } 
async function getMeta ( { payload , meta } , { getService } ) { debug ( 'Action: GET_META' ) const { service : serviceId , endpoint , keys } = payload const id = ` ${ serviceId } ` const service = getService ( null , serviceId ) if ( ! service ) { debug ( ` ${ serviceId } ` ) return createError ( ` ${ serviceId } ` ) } const type = service . meta const metaService = getService ( type ) if ( ! metaService ) { return createError ( ` ${ service . id } ${ service . meta } ` ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'GET_META: Get meta %s for service \'%s\' on service \'%s\' at %s' , keys , service . id , metaService . id , endpointDebug ) const { response } = await metaService . send ( { type : 'GET' , payload : { keys , type , id , endpoint } , meta : { ident : meta . ident } } ) if ( response . status === 'ok' ) { const { data } = response const meta = prepareMeta ( keys , data [ 0 ] . attributes ) return { ... response , data : { service : serviceId , meta } } } else { return response } } 
async function set ( action , { getService , schemas } ) { debug ( 'Action: SET' ) const { service : serviceId , data , endpoint , onlyMappedValues = true } = action . payload const type = extractType ( action , data ) const id = extractId ( data ) const service = getService ( type , serviceId ) if ( ! service ) { return createUnknownServiceError ( type , serviceId , 'SET' ) } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : '' debug ( 'SET: Send to service %s %s' , service . id , endpointDebug ) const { response , authorizedRequestData } = await service . send ( appendToAction ( action , { id , type , onlyMappedValues } ) ) return mergeRequestAndResponseData ( response , authorizedRequestData ) } 
function cast ( { id , attributes , relationships , defaultAttrs , defaultRels } ) { return ( data , { onlyMappedValues } ) => { if ( ! data ) { return undefined } const attrs = castAttributes ( data . attributes , attributes , ( onlyMappedValues ) ? { } : { ... defaultAttrs } ) if ( ! onlyMappedValues ) { setDates ( attrs ) } const rels = castRelationships ( data . relationships , relationships , ( onlyMappedValues ) ? { } : { ... defaultRels } ) const castId = data . id || attrs . id || uuid ( ) delete attrs . id const casted = { id : castId , type : id , attributes : attrs , relationships : rels } if ( data . isNew ) { casted . isNew = true } if ( data . isDeleted ) { casted . isDeleted = true } return casted } } 
async function setMeta ( { payload , meta } , { getService } ) { debug ( 'Action: SET_META' ) const { service : serviceId , meta : metaAttrs , endpoint } = payload const id = ` ${ serviceId } ` const service = getService ( null , serviceId ) if ( ! service ) { debug ( ` ${ serviceId } ` ) return createError ( ` ${ serviceId } ` ) } const type = service . meta const metaService = getService ( type ) if ( ! metaService ) { debug ( ` ${ service . id } ${ service . meta } ` ) return { status : 'noaction' } } const endpointDebug = ( endpoint ) ? ` ${ endpoint } ` : ` ${ type } ${ id } ` debug ( 'SET_META: Send metadata %o for service \'%s\' on service \'%s\' %s' , metaAttrs , service . id , metaService . id , endpointDebug ) const data = { id , type , attributes : metaAttrs } const { response } = await metaService . send ( { type : 'SET' , payload : { keys : Object . keys ( metaAttrs ) , type , id , data , endpoint , onlyMappedValues : true } , meta : { ident : meta . ident } } ) return response } 
function exportToJSONSchema ( expSpecifications , baseSchemaURL , baseTypeURL , flat = false ) { const namespaceResults = { } ; const endOfTypeURL = baseTypeURL [ baseTypeURL . length - 1 ] ; if ( endOfTypeURL !== '#' && endOfTypeURL !== '/' ) { baseTypeURL += '/' ; } for ( const ns of expSpecifications . namespaces . all ) { const lastLogger = logger ; logger = logger . child ( { shrId : ns . namespace } ) ; try { logger . debug ( 'Exporting namespace.' ) ; if ( flat ) { const { schemaId , schema } = flatNamespaceToSchema ( ns , expSpecifications . dataElements , baseSchemaURL , baseTypeURL ) ; namespaceResults [ schemaId ] = schema ; } else { const { schemaId , schema } = namespaceToSchema ( ns , expSpecifications . dataElements , baseSchemaURL , baseTypeURL ) ; namespaceResults [ schemaId ] = schema ; } logger . debug ( 'Finished exporting namespace.' ) ; } finally { logger = lastLogger ; } } return namespaceResults ; } 
function namespaceToSchema ( ns , dataElementsSpecs , baseSchemaURL , baseTypeURL ) { const dataElements = dataElementsSpecs . byNamespace ( ns . namespace ) ; const schemaId = ` ${ baseSchemaURL } ${ namespaceToURLPathSegment ( ns . namespace ) } ` ; let schema = { $schema : 'http://json-schema.org/draft-04/schema#' , id : schemaId , title : "TODO: Figure out what the title should be." , definitions : { } } ; const entryRef = makeRef ( new Identifier ( 'shr.base' , 'Entry' ) , ns , baseSchemaURL ) ; if ( ns . description ) { schema . description = ns . description ; } const nonEntryEntryTypeField = { $ref : makeRef ( new Identifier ( 'shr.base' , 'EntryType' ) , ns , baseSchemaURL ) } ; const defs = dataElements . sort ( function ( l , r ) { return l . identifier . name . localeCompare ( r . identifier . name ) ; } ) ; const entryRefs = [ ] ; for ( const def of defs ) { const lastLogger = logger ; logger = logger . child ( { shrId : def . identifier . fqn } ) ; try { logger . debug ( 'Exporting element' ) ; let schemaDef = { type : 'object' , properties : { } } ; let wholeDef = schemaDef ; const tbdParentDescriptions = [ ] ; let requiredProperties = [ ] ; let needsEntryType = false ; if ( def . isEntry || def . basedOn . length ) { wholeDef = { allOf : [ ] } ; let hasEntryParent = false ; for ( const supertypeId of def . basedOn ) { if ( supertypeId instanceof TBD ) { if ( supertypeId . text ) { tbdParentDescriptions . push ( supertypeId . text ) ; } else { tbdParentDescriptions . push ( 'TBD' ) ; } } else { const parent = dataElementsSpecs . findByIdentifier ( supertypeId ) ; if ( ! parent ) { logger . error ( 'Could not find definition for %s which is a supertype of %s' , supertypeId , def ) ; } else { hasEntryParent = hasEntryParent || parent . isEntry ; } wholeDef . allOf . push ( { $ref : makeRef ( supertypeId , ns , baseSchemaURL ) } ) ; } } if ( def . isEntry && ( ! hasEntryParent ) ) { wholeDef . allOf . splice ( 0 , 0 , { $ref : entryRef } ) ; } wholeDef . allOf . push ( schemaDef ) ; } else { needsEntryType = true ; } const tbdFieldDescriptions = [ ] ; if ( def . value ) { if ( def . value . inheritance !== INHERITED ) { let { value , required , tbd } = convertDefinition ( def . value , dataElementsSpecs , ns , baseSchemaURL , baseTypeURL ) ; if ( required ) { requiredProperties . push ( 'Value' ) ; } schemaDef . properties . Value = value ; if ( tbd ) { schemaDef . properties . Value . description = def . value . text ? ( 'TBD: ' + def . value . text ) : tbdValueToString ( def . value ) ; } } } if ( def . fields . length ) { const fieldNameMap = { } ; const clashingNames = { } ; for ( const field of def . fields ) { if ( ! ( field instanceof TBD ) ) { if ( ! isValidField ( field ) ) { continue ; } else if ( field . inheritance === INHERITED ) { if ( fieldNameMap [ field . identifier . name ] ) { logger . error ( ` ` , fieldNameMap [ field . identifier . name ] . fqn , field . identifier . fqn ) ; clashingNames [ field . identifier . name ] = true ; } else { fieldNameMap [ field . identifier . name ] = field . identifier ; } continue ; } if ( fieldNameMap [ field . identifier . name ] ) { logger . error ( ` ` , fieldNameMap [ field . identifier . name ] . fqn , field . identifier . fqn ) ; clashingNames [ field . identifier . name ] = true ; continue ; } else { fieldNameMap [ field . identifier . name ] = field . identifier ; } } const card = field . effectiveCard ; if ( card && card . isZeroedOut ) { continue ; } let { value , required , tbd } = convertDefinition ( field , dataElementsSpecs , ns , baseSchemaURL , baseTypeURL ) ; if ( tbd ) { tbdFieldDescriptions . push ( tbdValueToString ( field ) ) ; continue ; } if ( field . identifier . fqn === 'shr.base.EntryType' ) { needsEntryType = false ; } schemaDef . properties [ field . identifier . name ] = value ; if ( required ) { requiredProperties . push ( field . identifier . name ) ; } } for ( const clashingName in clashingNames ) { delete schemaDef . properties [ clashingName ] ; } requiredProperties = requiredProperties . filter ( propName => ! ( propName in clashingNames ) ) ; } else if ( ! def . value ) { schemaDef . type = 'object' ; schemaDef . description = 'Empty DataElement?' ; } let descriptionList = [ ] ; if ( def . description ) { descriptionList . push ( def . description ) ; } if ( def . concepts . length ) { wholeDef . concepts = def . concepts . map ( ( concept ) => makeConceptEntry ( concept ) ) ; } if ( tbdParentDescriptions . length ) { tbdParentDescriptions [ 0 ] = 'TBD Parents: ' + tbdParentDescriptions [ 0 ] ; descriptionList = descriptionList . concat ( tbdParentDescriptions ) ; } if ( tbdFieldDescriptions . length ) { tbdFieldDescriptions [ 0 ] = 'TBD Fields: ' + tbdFieldDescriptions [ 0 ] ; descriptionList = descriptionList . concat ( tbdFieldDescriptions ) ; } if ( descriptionList . length ) { wholeDef . description = descriptionList . join ( '\n' ) ; } if ( needsEntryType ) { schemaDef . properties [ 'EntryType' ] = nonEntryEntryTypeField ; if ( def . identifier . fqn !== 'shr.base.EntryType' ) { requiredProperties . push ( 'EntryType' ) ; } } if ( requiredProperties . length ) { schemaDef . required = requiredProperties ; } schema . definitions [ def . identifier . name ] = wholeDef ; if ( def . isEntry && ( ! def . isAbstract ) ) { entryRefs . push ( { $ref : makeRef ( def . identifier , ns , baseSchemaURL ) } ) ; } } finally { logger = lastLogger ; } } if ( entryRefs . length ) { schema . type = 'object' ; schema . anyOf = entryRefs ; } return { schemaId , schema } ; } 
function flatNamespaceToSchema ( ns , dataElementsSpecs , baseSchemaURL , baseTypeURL ) { const dataElements = dataElementsSpecs . byNamespace ( ns . namespace ) ; const schemaId = ` ${ baseSchemaURL } ${ namespaceToURLPathSegment ( ns . namespace ) } ` ; let schema = { $schema : 'http://json-schema.org/draft-04/schema#' , id : schemaId , title : "TODO: Figure out what the title should be." , definitions : { } } ; const expandedEntry = makeExpandedEntryDefinitions ( ns , baseSchemaURL ) ; if ( ns . description ) { schema . description = ns . description ; } const defs = dataElements . sort ( function ( l , r ) { return l . identifier . name . localeCompare ( r . identifier . name ) ; } ) ; const entryRefs = [ ] ; for ( const def of defs ) { let schemaDef = { type : 'object' , properties : { } } ; let wholeDef = schemaDef ; const tbdParentDescriptions = [ ] ; let requiredProperties = [ ] ; if ( def . isEntry ) { requiredProperties = expandedEntry . required . slice ( ) ; } const tbdFieldDescriptions = [ ] ; if ( def . value ) { let { value , required , tbd } = convertDefinition ( def . value , dataElementsSpecs , ns , baseSchemaURL , baseTypeURL ) ; if ( required ) { requiredProperties . push ( 'Value' ) ; } schemaDef . properties . Value = value ; if ( tbd ) { schemaDef . properties . Value . description = def . value . text ? ( 'TBD: ' + def . value . text ) : tbdValueToString ( def . value ) ; } } if ( def . fields . length ) { for ( const field of def . fields ) { if ( ! ( field instanceof TBD ) && ! isValidField ( field ) ) { continue ; } const card = field . effectiveCard ; if ( card && card . isZeroedOut ) { continue ; } let { value , required , tbd } = convertDefinition ( field , dataElementsSpecs , ns , baseSchemaURL , baseTypeURL ) ; if ( tbd ) { tbdFieldDescriptions . push ( tbdValueToString ( field ) ) ; continue ; } const fieldName = field . identifier . name ; schemaDef . properties [ fieldName ] = value ; if ( required && ( requiredProperties . indexOf ( fieldName ) === - 1 ) ) { requiredProperties . push ( fieldName ) ; } } if ( def . isEntry ) { for ( const name in expandedEntry . properties ) { if ( ! ( name in schemaDef . properties ) ) { schemaDef . properties [ name ] = expandedEntry . properties [ name ] ; } } } } else if ( ! def . value ) { schemaDef . type = 'object' ; schemaDef . description = 'Empty DataElement?' ; } let descriptionList = [ ] ; if ( def . description ) { descriptionList . push ( def . description ) ; } if ( def . concepts . length ) { wholeDef . concepts = def . concepts . map ( ( concept ) => makeConceptEntry ( concept ) ) ; } if ( tbdParentDescriptions . length ) { tbdParentDescriptions [ 0 ] = 'TBD Parents: ' + tbdParentDescriptions [ 0 ] ; descriptionList = descriptionList . concat ( tbdParentDescriptions ) ; } if ( tbdFieldDescriptions . length ) { tbdFieldDescriptions [ 0 ] = 'TBD Fields: ' + tbdFieldDescriptions [ 0 ] ; descriptionList = descriptionList . concat ( tbdFieldDescriptions ) ; } if ( descriptionList . length ) { wholeDef . description = descriptionList . join ( '\n' ) ; } if ( requiredProperties . length ) { schemaDef . required = requiredProperties ; } schema . definitions [ def . identifier . name ] = wholeDef ; if ( def . isEntry && ( ! def . isAbstract ) ) { entryRefs . push ( { $ref : makeRef ( def . identifier , ns , baseSchemaURL ) } ) ; } } if ( entryRefs . length ) { schema . type = 'object' ; schema . anyOf = entryRefs ; } return { schemaId , schema } ; } 
function makeRef ( id , enclosingNamespace , baseSchemaURL ) { if ( id . namespace === enclosingNamespace . namespace ) { return '#/definitions/' + id . name ; } else { return makeShrDefinitionURL ( id , baseSchemaURL ) ; } } 
function extractConstraintPath ( constraint , valueDef , dataElementSpecs ) { if ( constraint . onValue ) { return extractUnnormalizedConstraintPath ( constraint , valueDef , dataElementSpecs ) ; } else if ( constraint . path . length > 0 && constraint . path [ constraint . path . length - 1 ] . isValueKeyWord ) { 
function makeConceptEntry ( concept ) { if ( concept instanceof TBD ) { const ret = { code : 'TBD' , codeSystem : 'urn:tbd' } ; if ( concept . text ) { ret . displayText = concept . text ; } return ret ; } else { const ret = { code : concept . code , codeSystem : concept . system } ; if ( concept . display ) { ret . displayText = concept . display ; } return ret ; } } 
function isOrWasAList ( value ) { if ( value . card . isList ) { return true ; } const cardConstraints = value . constraintsFilter . own . card . constraints ; return cardConstraints . some ( ( oneCard ) => oneCard . isList ) ; } 
function findOptionInChoice ( choice , optionId , dataElementSpecs ) { 
function supportsCodeConstraint ( identifier , dataElementSpecs ) { if ( CODE . equals ( identifier ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } const element = dataElementSpecs . findByIdentifier ( identifier ) ; if ( element . value ) { if ( element . value instanceof IdentifiableValue ) { return CODE . equals ( element . value . identifier ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( element . value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ; } else if ( element . value instanceof ChoiceValue ) { for ( const value of element . value . aggregateOptions ) { if ( value instanceof IdentifiableValue ) { if ( CODE . equals ( value . identifier ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'Coding' ) , dataElementSpecs ) || checkHasBaseType ( value . identifier , new Identifier ( 'shr.core' , 'CodeableConcept' ) , dataElementSpecs ) ) { return true ; } } } } } return false ; } 
async function expire ( { payload , meta = { } } , { dispatch } ) { const { service } = payload const { ident } = meta if ( ! service ) { return createError ( ` ` ) } if ( ! payload . endpoint ) { return createError ( ` ${ service } ` ) } if ( ! payload . type ) { return createError ( ` ${ service } ` ) } const response = await getExpired ( payload , ident , dispatch ) return deleteExpired ( response , service , ident , dispatch ) } 
function Set ( target , attribute , value ) { this . type = 'Set' this . target = target this . attribute = attribute this . value = value this . hasEffect = true 
function Name ( name , action , val ) { this . type = 'Name' this . name = name this . action = action this . value = val } 
function parseCell ( cell ) { var match = cell . match ( / ([a-z]+)([0-9]+) / i ) if ( ! match ) throw new Error ( 'invalid cell id ' + cell ) return [ column . fromStr ( match [ 1 ] ) , parseInt ( match [ 2 ] ) ] } 
function transformRange ( range , ops ) { var rangeComps = range . split ( ':' ) , newRange var start = rangeComps [ 0 ] ops . forEach ( op => start = transformRangeAnchor ( start , op , true ) ) var end = rangeComps [ 1 ] ops . forEach ( op => end = transformRangeAnchor ( end , op , false ) ) if ( start === end ) return start return start + ':' + end } 
function transformRangeAnchor ( target , op , isStart ) { var thisCell = parseCell ( target ) if ( op instanceof InsertCol ) { var otherCell = parseCell ( op . newCol ) if ( otherCell [ 0 ] <= thisCell [ 0 ] ) return column . fromInt ( thisCell [ 0 ] + 1 ) + thisCell [ 1 ] } else if ( op instanceof DeleteCol ) { var otherCell = parseCell ( op . col ) if ( otherCell [ 0 ] < thisCell [ 0 ] ) return column . fromInt ( thisCell [ 0 ] - 1 ) + thisCell [ 1 ] if ( otherCell [ 0 ] === thisCell [ 0 ] ) { 
function matchEndpoint ( endpoints ) { return ( { type , payload , meta } ) => endpoints . find ( ( endpoint ) => matchId ( endpoint , { type , payload } ) && matchType ( endpoint , { type , payload } ) && matchScope ( endpoint , { type , payload } ) && matchAction ( endpoint , { type , payload } ) && matchParams ( endpoint , { type , payload } ) && matchFilters ( endpoint , { type , payload , meta } ) ) } 
function createAction ( type , payload = { } , meta ) { if ( ! type ) { return null } const action = { type , payload } if ( meta ) { action . meta = meta } return action } 
function authorizeRequest ( { schemas } ) { return ( { request } ) => { const { access = { } , params = { } , action } = request const { ident = null } = access if ( ident && ident . root ) { return authItemsAndWrap ( request , { status : 'granted' , ident , scheme : 'root' } , schemas ) } if ( ! params . type ) { return authItemsAndWrap ( request , { status : 'granted' , ident , scheme : null } , schemas ) } const requireAuth = ! ! request . auth const schema = schemas [ params . type ] const scheme = getScheme ( schema , action ) const status = ( doAuth ( scheme , ident , requireAuth ) ) ? 'granted' : 'refused' return authItemsAndWrap ( request , { status , ident , scheme } , schemas ) } } 
function requestFromAction ( { type : action , payload , meta = { } } , { endpoint , schemas = { } } = { } ) { const { data , ... params } = payload const { ident = null } = meta const typePlural = getPluralType ( params . type , schemas ) return { action , params , data , endpoint : ( endpoint && endpoint . options ) || null , access : { ident } , meta : { typePlural } } } 
function getService ( schemas , services ) { return ( type , service ) => { if ( ! service && schemas [ type ] ) { service = schemas [ type ] . service } return services [ service ] || null } } 
async function sync ( { payload , meta = { } } , { dispatch } ) { debug ( 'Action: SYNC' ) const fromParams = await generateFromParams ( payload , meta , dispatch ) const toParams = generateToParams ( payload , fromParams ) const lastSyncedAt = new Date ( ) const results = await Promise . all ( fromParams . map ( getFromService ( dispatch , payload . type , meta ) ) ) if ( results . some ( ( result ) => result . status !== 'ok' ) ) { return ( results . length === 1 ) ? results [ 0 ] : createError ( makeErrorString ( results ) ) } const data = flatten ( results . map ( ( result ) => result . data ) ) . filter ( Boolean ) if ( data . length === 0 && payload . syncNoData !== true ) { return createError ( ` ${ fromParams [ 0 ] . service } ` , 'noaction' ) } return Promise . all ( [ ... createSetMetas ( fromParams , lastSyncedAt , meta . ident , dispatch ) , dispatch ( action ( 'SET' , { data , ... toParams } , { ... meta , queue : true } ) ) ] ) . then ( ( responses ) => { return { status : 'ok' , data : responses } } ) } 
function ( gulp , cwd , config ) { if ( util . isNullOrUndefined ( gulp ) ) { throw 'gulp must be defined' ; } this . _config = config || { } , this . _cwd = cwd || __dirname ; this . _root = path . relative ( this . _cwd , __dirname ) ; this . _gulp = gulp ; } 
function ( ) { this . _colors = [ 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' , 'black' ] this . _colors_num = this . _colors . length this . _backgrounds = [ ] for ( var i = 0 ; i < this . _colors_num ; i ++ ) { this . _backgrounds [ i ] = 'bg' + this . _colors [ i ] . charAt ( 0 ) . toUpperCase ( ) + this . _colors [ i ] . slice ( 1 ) } this . _skip = [ 'black' , 'white' , 'bgBlack' , 'bgWhite' ] this . _skip_num = this . _skip . length - 1 this . _next = 0 this . _prev = - 1 this . options = { color_space : false , gap : 1 , space_color : null } this . wrapper = { bg : this . ponyfy ( true ) , r : this . ponyfy ( ) , add : this . addorskip ( 'add' ) , skip : this . addorskip ( 'skip' ) , options : ( opts ) => { for ( let i in options ) { if ( opts [ i ] ) { this . options [ i ] = opts [ i ] continue } for ( let j in opts ) { if ( options [ i ] . alias && ~ options [ i ] . alias . indexOf ( j ) ) { this . options [ i ] = opts [ j ] break } } } return this . wrapper } , colors : ( ) => this . colors ( ) , reset : ( ) => { this . _skip = [ 'black' , 'white' , 'bgBlack' , 'bgWhite' ] return this . wrapper } , _colors : this . _colors , _backgrounds : this . _backgrounds } return this . wrapper } 
function ( bg ) { bg = bg ? bg : false return ( ... args ) => { return this . output ( args . join ( ' ' ) , this . colors ( bg ) ) } } 
function ( browserify , name , source ) { if ( utility . isNullOrUndefined ( browserify ) ) { throw 'browserify must be defined.' ; } if ( ! utility . isNonEmptyString ( name ) ) { throw 'name must be defined.' ; } if ( utility . isNullOrUndefined ( source ) ) { throw 'source must be defined.' ; } this . _browserify = browserify ; this . _name = name ; this . _source = source ; this . _hasModule = false ; this . _hasResolver = false ; } 
function Strategy ( options , verify ) { options = options || { } ; if ( ! options . baseURI ) { throw new TypeError ( 'EveSeatStrategy requires a baseURI option' ) ; } 
function mapToService ( ) { return ( { request , requestMapper , mappings } ) => { const data = mapData ( request . data , request , mappings ) return { ... request , data : applyEndpointMapper ( data , request , requestMapper ) } } } 
function Router ( options ) { var self = this ; self . frontend = new Server ( { port : options . port , auth : options . auth || options . secret , certificates : options . certificates , routing : true } ) // connect to relay destination if ( options . client ) { self . backend = new Client ( { address : options . client . address , auth : options . client . auth || options . client . secret || options . auth || options . secret , certificates : options . certificates || options . client . certificates , //node: options.node, designation : 'router' , routes : self . frontend . streams } ) } else if ( options . server ) { self . backend = new Server ( { port : options . server . port , auth : options . server . auth || options . server . secret || options . auth || options . secret , certificates : options . certificates || options . server . certificates , routes : self . frontend . streams } ) } else throw new Error ( "iris-rpc::Router() requires client or server" ) self . frontend . on ( 'connect' , function ( address , uuid , stream ) { self . backend . dispatch ( { op : 'rpc::online' , uuid : uuid } ) ; } ) self . frontend . on ( 'disconnect' , function ( uuid , stream ) { self . backend . dispatch ( { op : 'rpc::offline' , uuid : uuid } ) ; } ) self . backend . on ( 'connect' , function ( address , uuid , stream ) { self . frontend . dispatch ( { op : 'rpc::online' , uuid : uuid } ) ; } ) self . backend . on ( 'disconnect' , function ( uuid , stream ) { self . frontend . dispatch ( { op : 'rpc::offline' , uuid : uuid } ) ; } ) self . frontend . digest ( function ( msg , uuid , stream ) { msg . _r = { uuid : uuid , designation : stream . designation , uuid : stream . uuid } self . backend . dispatch ( msg ) ; } ) self . backend . digest ( function ( msg , uuid ) { self . frontend . dispatch ( msg . _uuid , msg ) ; } ) } 
async function processMessengerBody ( body , context ) { const allMessages = getAllMessages ( body ) if ( ! allMessages || ! allMessages . length ) return false context = context || { } for ( let message of allMessages ) { message = _ . cloneDeep ( message ) const messageContext = Object . assign ( { } , context ) try { for ( let plugin of middleware ) { await plugin ( message , messageContext ) } } catch ( error ) { const logError = ( messageContext . log && messageContext . log . error instanceof Function ) ? messageContext . log . error : console . error logError ( 'Error running middleware' , error ) } } return true } 
function create ( prop ) { if ( typeof prop !== 'string' ) { throw new Error ( 'expected the first argument to be a string.' ) ; } return function ( app ) { if ( this . isRegistered ( 'base-' + prop ) ) return ; 
function proxy ( config ) { function fn ( key , val ) { if ( typeof val === 'string' ) { config . alias . apply ( config , arguments ) ; return config ; } if ( typeof key === 'string' ) { config . map . apply ( config , arguments ) ; return config ; } if ( ! utils . isObject ( key ) ) { throw new TypeError ( 'expected key to be a string or object' ) ; } for ( var prop in key ) { fn ( prop , key [ prop ] ) ; } return config ; } fn . __proto__ = config ; return fn ; } 
function ( proto , parentProto ) { proto . _initHooks = [ ] ; proto . _destroyHooks = [ ] ; 
function ElementMatrix ( top ) { CommanalityMatrix . call ( this , top ) ; this . row ( ' ' ) ; this . collum ( ' ' ) ; this . classlist = top . root . classlist ; } 
function publicS3URI ( string ) { return encodeURIComponent ( string ) . replace ( / %20 / img , '+' ) . replace ( / %2F / img , '/' ) . replace ( / \" / img , "%22" ) . replace ( / \# / img , "%23" ) . replace ( / \$ / img , "%24" ) . replace ( / \& / img , "%26" ) . replace ( / \' / img , "%27" ) . replace ( / \( / img , "%28" ) . replace ( / \) / img , "%29" ) . replace ( / \, / img , "%2C" ) . replace ( / \: / img , "%3A" ) . replace ( / \; / img , "%3B" ) . replace ( / \= / img , "%3D" ) . replace ( / \? / img , "%3F" ) . replace ( / \@ / img , "%40" ) ; } 
function parsePayload ( message ) { const messageParts = message && message . match ( / ^([^:]+)(?::(.*))? / ) if ( ! messageParts ) return { topic : undefined , data : undefined } const topic = messageParts [ 1 ] let data = messageParts [ 2 ] if ( data ) { try { data = JSON . parse ( data ) } catch ( error ) { data = undefined } } return { topic , data } } 
function ( done ) { fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/expected/' + item . key + '.json' ) , JSON . stringify ( { 'title' : item . title , 'text' : item . text } , null , '\t' ) + '\n' , done ) ; } 
function ( done ) { fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/source/' + item . key + '.html' ) , SOURCES [ item . key ] , done ) ; } 
function ( done ) { datamap [ item . index ] . labeled = true ; fs . writeFile ( path . resolve ( __dirname , '../../test/reallife/datamap.json' ) , JSON . stringify ( datamap , null , '\t' ) + '\n' , done ) ; } 
function attrStringify ( attr ) { var names = Object . keys ( attr ) ; var str = '' ; for ( var i = 0 , l = names . length ; i < l ; i ++ ) { str += names [ i ] + '="' + attr [ names [ i ] ] . slice ( 0 , 20 ) + ( attr [ names [ i ] ] . length > 20 ? '...' : '' ) + '" ' ; } return str ; } 
function toNLCST ( tree , file , Parser ) { var parser var location var results var doc 
function one ( node ) { var type = node . type var tagName = type === 'element' ? node . tagName : null var change var replacement if ( type === 'text' ) { change = true replacement = parser . tokenize ( node . value ) } else if ( tagName === 'wbr' ) { change = true replacement = [ parser . tokenizeWhiteSpace ( ' ' ) ] } else if ( tagName === 'br' ) { change = true replacement = [ parser . tokenizeWhiteSpace ( '\n' ) ] } else if ( sourced ( node ) ) { change = true replacement = [ parser . tokenizeSource ( textContent ( node ) ) ] } else if ( type === 'root' || ! ignored ( node ) ) { replacement = all ( node . children ) } else { return } if ( ! change ) { return replacement } return patch ( replacement , location , location . toOffset ( position . start ( node ) ) ) } 
function all ( children ) { var length = children && children . length var index = - 1 var result = [ ] var child while ( ++ index < length ) { child = one ( children [ index ] ) if ( child ) { result = result . concat ( child ) } } return result } 
function ( source , target , alias , type ) { if ( Util . isnt . Class ( source ) || Util . isnt . Class ( target ) || Util . isnt . String ( alias ) || ! alias || Association . types . indexOf ( type ) === - 1 ) { return false ; } this . id = Util . uniqId ( ) ; this . source = source ; this . target = target ; this . alias = Util . String . capitalize ( alias ) ; this . type = type ; return this . complete ( ) ; } 
function Node ( type , parent ) { this . type = type ; this . parent = parent ; this . root = parent ? parent . root : this ; this . identifyer = parent ? ( ++ parent . root . _counter ) : 0 ; 
function TextNode ( parent , text ) { Node . call ( this , 'text' , parent ) ; 
function ElementNode ( parent , tagname , attributes ) { Node . call ( this , 'element' , parent ) ; 
function ( ) { var r ; 
function distribute ( filename , content ) { content = content ; fs . appendFile ( filename , content + "\n" ) ; log ( rulecount + ': Append to ' + filename + ' -> ' + content ) ; } 
function detectTakeout ( selectors ) { var properties = { takeout : false } ; options . takeout . forEach ( function ( takeout ) { selectors . forEach ( function ( selector ) { if ( selector . indexOf ( takeout . ruleprefix ) === 0 ) { properties . takeout = true ; properties . filename = takeout . filename ; } } ) ; } ) ; return properties ; } 
function wordcountScore ( x ) { if ( x > 5 ) return 1 ; else return Math . min ( 1 , 2.27 * Math . sqrt ( x ) - 0.0507 * Math . pow ( x , 2 ) - 2.808 ) ; } 
function linebreakScore ( x ) { if ( x > 5 ) return 1 ; else return Math . min ( 1 , 0.477 * Math . sqrt ( x ) - 0.0106 * Math . pow ( x , 2 ) + 0.2 ) ; } 
function adjustLiklihood ( x ) { if ( x < 0.01 ) return 0.5 ; else if ( x > 0.1 ) return 1 ; else return Math . min ( 1 , - 1371 * Math . pow ( x , 3 ) + 226 * Math . pow ( x , 2 ) - 4.11 * x + 0.52 ) ; } 
function parseLineByLine ( text ) { var lines = text . trim ( ) . split ( "\n" ) ; var bookmarks = lines . splice ( 0 , lines . length * 3 / 4 ) ; return { bookmarks : bookmarks , lines : lines } ; } 
function CommonalityInterface ( MatrixConstructor , top ) { this . top = top ; this . length = null ; this . matrix = null ; this . MatrixConstructor = MatrixConstructor ; } 
function CommanalityMatrix ( classlist ) { 
function arrayVector ( size ) { var vec = new Array ( size ) ; for ( var i = 0 ; i < size ; i ++ ) vec [ i ] = [ ] ; return vec ; } 
function buildAttributeMatcher ( match ) { var keys = Object . keys ( match ) ; var jskey , i , l ; var transform = '' ; var bool = '' ; transform = 'transform = {\n' ; for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; transform += ' ' + jskey + ': attr.hasOwnProperty(' + jskey + ') ? attr[' + jskey + '].toLowerCase() : false' ; if ( i !== l - 1 ) transform += ',' ; transform += '\n' ; } transform += '};\n' ; bool = 'return !!(' ; for ( i = 0 , l = keys . length ; i < l ; i ++ ) { jskey = JSON . stringify ( keys [ i ] ) ; if ( i > 0 ) bool += ' || ' ; bool += ' ( transform[' + jskey + ']' ; if ( Array . isArray ( match [ keys [ i ] ] ) ) { bool += ' && ( ' ; for ( var j = 0 , s = match [ keys [ i ] ] . length ; j < s ; j ++ ) { if ( j > 0 ) bool += ' || ' ; if ( typeof match [ keys [ i ] ] [ j ] === 'string' ) { bool += 'transform[' + jskey + '] === \'' + match [ keys [ i ] ] [ j ] . toLowerCase ( ) + '\'' ; } else if ( util . isRegExp ( match [ keys [ i ] ] [ j ] ) ) { bool += 'match[' + jskey + '][' + j + '].test(transform[' + jskey + '])' ; } } bool += ' )' ; } bool += ' ) \n' ; } bool += ' );' ; var anonymous = new Function ( 'attr' , 'match' , transform + '\n' + bool ) ; return function ( attr ) { return anonymous ( attr , match ) ; } ; } 
function containerOf ( a , b ) { while ( b = b . parent ) { if ( a === b ) return true ; } return false ; } 
function commonParent ( a , b ) { if ( a === b ) { return a ; } else if ( containerOf ( a , b ) ) { return a ; } else if ( containerOf ( b , a ) ) { return b ; } else { 
function styleParser ( style ) { style = style || '' ; var tokens = style . trim ( ) . split ( / \s*(?:;|:)\s* / ) ; var output = { } ; for ( var i = 1 , l = tokens . length ; i < l ; i += 2 ) { output [ tokens [ i - 1 ] ] = tokens [ i ] ; } return output ; } 
function treeDistance ( a , b ) { if ( a === b ) return 0 ; var parent = commonParent ( a , b ) ; var aParent = a ; var aCount = 0 ; var bParent = b ; var bCount = 0 ; if ( parent !== a ) { while ( parent !== aParent . parent ) { aCount += 1 ; aParent = aParent . parent ; } } else { bCount += 1 ; } if ( parent !== b ) { while ( parent !== bParent . parent ) { bCount += 1 ; bParent = bParent . parent ; } } else { aCount += 1 ; } var abCount = 0 ; if ( parent !== a && parent !== b ) { abCount = Math . abs ( parent . children . indexOf ( aParent ) - parent . children . indexOf ( bParent ) ) ; } return aCount + bCount + abCount ; } 
function ( casper , pos ) { this . _pos = pos || { timestamp : Date . now ( ) , coords : { longitude : 0 , latitude : 0 , accuracy : 0 } } ; this . _casper = casper ; } 
function Lexer ( file , options ) { this . options = utils . extend ( { } , options ) ; this . file = file ; this . regex = new RegexCache ( ) ; this . names = [ ] ; this . ast = { tags : { } , type : 'root' , name : 'root' , nodes : [ ] } ; this . unknown = { tags : [ ] , blocks : [ ] } ; this . known = { tags : [ 'extends' , 'layout' ] , blocks : [ 'block' ] } ; this . delimiters = { variable : [ '{{' , '}}' ] , block : [ '{%' , '%}' ] , es6 : [ '${' , '}' ] , } ; this . tokens = [ this . ast ] ; this . errors = [ ] ; this . stack = [ ] ; this . stash = [ ] ; this . lexers = { } ; this . fns = [ ] ; } 
function ( ) { if ( this . isInitialized ) return ; this . isInitialized = true ; var lexer = this ; this . lineno = 1 ; this . column = 1 ; this . lexed = '' ; this . file = utils . normalize ( this . file ) ; this . file . orig = this . file . contents ; this . input = this . file . contents . toString ( ) ; this . file . ast = this . ast ; this . file . ast . variables = { } ; this . file . ast . blocks = { } ; this . input = this . input . split ( '{% body %}' ) . join ( '{% block "body" %}{% endblock %}' ) ; if ( this . file . extends ) { this . prependNode ( this . file , 'extends' ) ; } this . captureTag ( 'extends' ) ; this . captureTag ( 'layout' ) ; this . captureBlock ( 'block' ) ; this . capture ( 'text' , utils . negateDelims ( this . delimiters ) ) ; this . capture ( 'newline' , / ^\n+ / ) ; this . capture ( 'es6' , / ^\$\{([^\\}]*(?:\\.[^\\}]*)*)\} / ) ; this . capture ( 'variable' , / ^\{{2,}([^\\}]*(?:\\.[^\\}]*)*)\}{2,} / ) ; this . capture ( 'escape' , / ^\\(.) / ) ; this . capture ( 'space' , / ^[ \t]+ / ) ; var helpers = this . options . helpers || { } ; if ( utils . isObject ( helpers ) ) { helpers = Object . keys ( helpers ) ; } helpers . forEach ( function ( key ) { lexer . known . blocks . push ( key ) ; lexer . captureBlock ( key ) ; } ) ; var matches = this . input . match ( / \{%\s*([^%}]+) / g ) ; var names = utils . getNames ( matches ) ; names . tags . forEach ( function ( key ) { if ( ! utils . isRegistered ( lexer , key ) ) { lexer . unknown . tags . push ( key ) ; lexer . captureTag ( key ) ; } } ) ; names . blocks . forEach ( function ( key ) { if ( ! utils . isRegistered ( lexer , key ) ) { lexer . unknown . blocks . push ( key ) ; lexer . captureBlock ( key ) ; } } ) ; } 
function ( msg ) { var message = this . file . relative + ' line:' + this . lineno + ' column:' + this . column + ': ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . line = this . lineno ; err . column = this . column ; err . source = this . input ; err . path = this . file . path ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } } 
function ( ) { var start = { line : this . lineno , column : this . column } ; var self = this ; return function ( node ) { utils . define ( node , 'position' , new Position ( start , self ) ) ; return node ; } ; } 
function ( type , regex ) { var cached = this . regex . create ( type , regex ) ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . val ) ; if ( ! m || ! m [ 0 ] ) return ; var parent = lexer . prev ( ) ; var node = pos ( { type : type , val : m [ 0 ] } ) ; utils . define ( node , 'parent' , parent ) ; utils . define ( node , 'rawArgs' , m [ 1 ] ) ; utils . define ( node , 'args' , function ( ) { return utils . parseArgs ( m [ 1 ] ) ; } ) ; parent . nodes . push ( node ) ; } ; this . addLexer ( fn ) ; return this ; } 
function ( type ) { var cached = this . regex . createVariable ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var parent = this . prev ( ) ; var node = pos ( { type : type , known : utils . has ( lexer . known . tags , type ) , val : m [ 0 ] . trim ( ) } ) ; parent . known = node . known ; var nodes = parent . nodes ; Object . defineProperty ( file . ast . variables , type , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . defineProperty ( parent , 'nodes' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; utils . define ( node , 'parent' , parent ) ; parent . nodes . push ( node ) ; } ; this . addLexer ( fn ) ; return this ; } 
function ( type ) { this . ast . tags [ type ] = null ; this . names . push ( type ) ; var cached = this . regex . createTag ( type ) ; var file = this . file ; var lexer = this ; var fn = this . lexers [ type ] = function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . getName ( m [ 1 ] ) ; if ( this . options . strict ) { var isKnown = utils . has ( lexer . known . tags , type ) ; if ( isKnown && file . hasOwnProperty ( type ) && ! file . hasOwnProperty ( 'isParsed' ) ) { throw new Error ( ` ${ type } ` ) ; } } file [ type ] = name ; lexer . ast . tags [ type ] = name ; lexer . createNode ( type , name , m , pos ) ; } ; this . addLexer ( fn ) ; return this ; } 
function ( type , name , m , pos ) { var parent = this . prev ( ) ; var val = m [ 1 ] ; var tok = { type : 'args' , val : val } ; var node = pos ( { type : type , name : name , known : utils . has ( this . known . tags , type ) , val : val . trim ( ) , nodes : [ tok ] } ) ; utils . define ( node , 'parent' , parent ) ; utils . define ( tok , 'parent' , node ) ; parent . nodes . push ( node ) ; } 
function ( type ) { this . names . push ( type ) ; var cached = this . regex . createOpen ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var name = utils . getName ( m [ 1 ] ) ; var action = utils . getAction ( m [ 1 ] ) ; var val = m [ 0 ] ; if ( ! name && lexer . options [ type ] && lexer . options [ type ] . args === 'required' ) { throw new Error ( ` ${ type } ${ m [ 0 ] } ` ) ; } if ( ! name ) name = 'unnamed' ; var node = pos ( { type : ` ${ type } ` , known : utils . has ( lexer . known . blocks , type ) , name : name , val : val . trim ( ) } ) ; var parent = lexer . prev ( ) ; if ( parent && parent . name && parent . name !== 'root' ) { name = parent . name + '.' + name ; } var block = { type : type , name : name , known : node . known , action : action , nodes : [ node ] } ; utils . define ( node , 'parent' , block ) ; utils . define ( block , 'parent' , parent ) ; block . rawArgs = m [ 1 ] ; block . args = utils . parseArgs ( m [ 1 ] ) ; Object . defineProperty ( file . ast . blocks [ type ] , name , { configurable : true , enumerable : true , set : function ( val ) { block = val ; } , get : function ( ) { return block ; } } ) ; parent . nodes . push ( block ) ; lexer . tokens . push ( block ) ; return block ; } ; } 
function ( type ) { var cached = this . regex . createClose ( type ) ; var file = this . file ; var lexer = this ; return function ( ) { var pos = lexer . position ( ) ; var m = lexer . match ( cached . strict ) ; if ( ! m ) return ; var block = lexer . tokens . pop ( ) ; if ( typeof block === 'undefined' || block . type !== type ) { throw new Error ( ` ${ type } ` ) ; } if ( block . name === 'body' ) { lexer . ast . isLayout = true ; file . ast . isLayout = true ; } var nodes = block . nodes ; Object . defineProperty ( file . ast . blocks , block . name , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; Object . defineProperty ( block , 'nodes' , { configurable : true , set : function ( val ) { nodes = val ; } , get : function ( ) { return nodes ; } } ) ; var tok = pos ( { known : block . known , type : ` ${ type } ` , val : m [ 0 ] . trim ( ) } ) ; utils . define ( block , 'position' , tok . position ) ; utils . define ( tok , 'parent' , block ) ; block . nodes . push ( tok ) ; return block ; } ; } 
function ( type ) { this . file . ast . blocks [ type ] = this . file . ast . blocks [ type ] || { } ; this . addLexer ( this . captureOpen ( type ) ) ; this . addLexer ( this . captureClose ( type ) ) ; return this ; } 
function ( file , prop ) { return this . createNode ( prop , file [ prop ] , ` ${ prop } ${ file [ prop ] } ` , this . position ( ) ) ; } 
function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . lineno += lines . length ; var i = str . lastIndexOf ( '\n' ) ; this . column = ~ i ? len - i : this . column + len ; this . lexed += str ; this . consume ( str , len ) ; } 
function ( regex ) { var m = regex . exec ( this . input ) ; if ( m ) { this . updatePosition ( m [ 0 ] , m [ 0 ] . length ) ; return m ; } } 
function ( ) { var len = this . fns . length ; var idx = - 1 ; while ( ++ idx < len ) { this . fns [ idx ] . call ( this ) ; if ( ! this . input ) { break ; } } } 
function ( ) { while ( this . input ) { var prev = this . input ; this . advance ( ) ; if ( this . input && prev === this . input ) { throw new Error ( ` ${ this . input . substr ( 0 , 10 ) } ` ) ; } } } 
function ( file ) { debug ( 'lexing <%s>' , this . file . path ) ; if ( file ) this . file = file ; this . init ( ) ; while ( this . input ) this . next ( ) ; return this . ast ; } 
function notifyHook ( e ) { message_count ++ ; var message ; if ( ! options . enabled ) { return ; } if ( ! e ) { return ; } if ( e && e . length === 1 ) { e = e [ 0 ] ; } if ( / Task .* failed\. / . test ( e . message ) ) { message = e . message ; } else if ( e . message && e . stack ) { message = exception ( e ) ; } else { message = e + '' ; } if ( message_count > 0 && message === 'Aborted due to warnings.' ) { 
function ( ) { if ( this . _initialized && this . _isPaused ) { return false ; } this . _isPaused = true ; raf . cancel ( this . _requestID ) ; this . _pauseTime = now ( ) ; this . _onPause ( ) ; return true ; } 
function ( ) { if ( this . _initialized && ! this . _isPaused ) { return false ; } var pauseDuration ; this . _isPaused = false ; this . _prevTime = now ( ) ; pauseDuration = this . _prevTime - this . _pauseTime ; this . _onResume ( pauseDuration ) ; this . _requestID = raf . request ( this . _tick ) ; return true ; } 
function createServer ( options , callback ) { if ( options && options . cert && options . key ) { return https . createServer ( options , callback ) ; } return http . createServer ( callback || null ) ; } 
function createProxy ( api , obj , methods ) { return new Proxy ( obj , { get ( target , name ) { if ( methods . includes ( name ) ) { return ( params , callback ) => { const inject = Object . assign ( { chat_id : obj . id } , params ) ; return api . method ( name , inject , callback ) ; } ; } return target [ name ] ; } , set ( ) { return new Error ( 'Cannot change `chat` or `user`.' ) ; } , } ) ; } 
function isArrayLike ( value ) { return ( value !== void 0 && value !== null && typeof value !== 'function' && isInteger ( value . length ) && value . length >= 0 && value . length <= MAX ) ; } 
function render ( ) { shell . context . cache . clear ( ) ; shell . context . setViewport ( ) ; GLOW . defaultCamera . update ( ) shell . context . enableDepthTest ( true ) ; if ( params . cullCW ) { shell . context . enableCulling ( true , { frontFace : GL . CW , cullFace : GL . BACK } ) ; } else if ( params . cullCCW ) { shell . context . enableCulling ( true , { frontFace : GL . CCW , cullFace : GL . BACK } ) ; } else { shell . context . enableCulling ( false ) ; } shell . context . clear ( ) ; shell . events . emit ( "render" ) ; utils . nextFrame ( render ) ; } 
function create ( opts , cb ) { immediately add some options to the create procedure done by adding argument -o option=value the opts.options parameter is an array of objects, or a single object opts.options = { property: String, value: String } OR: opts.options = [ { property: String, value: String }, { property: String, value: String } ] */ if ( opts . options ) { if ( opts . options . length ) { 
function add ( opts , cb ) { "use strict" ; var params = [ 'add' , '-f' ] ; params . push ( opts . name ) ; 
function destroy ( opts , cb ) { "use strict" ; var params = [ 'destroy' , '-f' ] ; params . push ( opts . name ) ; zpool ( params , cb ) ; } 
function list ( opts , cb ) { 
function mktmpdir ( prefixSuffix , tmpdir , callback , onend ) { if ( 'function' == typeof prefixSuffix ) { onend = tmpdir ; callback = prefixSuffix ; tmpdir = null ; prefixSuffix = null ; } else if ( 'function' == typeof tmpdir ) { onend = callback ; callback = tmpdir ; tmpdir = null ; } prefixSuffix = prefixSuffix || 'd' ; onend = onend || function ( ) { } ; tmpname . create ( prefixSuffix , tmpdir , function ( err , path , next ) { if ( err ) return callback ( err ) ; fs . mkdir ( path , 0700 , next ) ; } , function ( err , path ) { if ( err ) return callback ( err ) ; callback ( null , path , function ( err ) { if ( ! path ) return onend ( err ) ; rimraf ( path , function ( _err ) { onend ( err || _err , path ) ; } ) ; } ) ; } ) ; } 
function list ( opts , cb ) { "use strict" ; if ( typeof opts === 'function' ) { cb = opts ; opts = undefined ; } var params = [ 'list' , '-H' ] ; if ( opts && opts . type ) { params . push ( '-t' ) ; params . push ( opts . type ) ; } if ( opts && opts . sort ) { params . push ( '-s' ) ; params . push ( opts . sort ) ; } if ( opts && opts . recursive ) { params . push ( '-r' ) ; } if ( opts && opts . name ) { params . push ( opts . name ) ; } zfs ( params , function ( err , stdout ) { if ( cb && typeof cb === 'function' ) { if ( err ) { cb ( err ) ; return ; } var lines = util . compact ( stdout . split ( '\n' ) ) ; var list = lines . map ( function ( x ) { return new ZFS ( x ) ; } ) ; cb ( err , list ) ; } } ) ; } 
function get ( opts , cb ) { "use strict" ; var params = [ 'get' , '-pH' ] ; if ( opts . source ) { params . push ( '-s' , opts . source ) ; } params . push ( opts . property ) ; if ( opts . name ) { params . push ( opts . name ) ; } zfs ( params , function ( err , stdout ) { if ( cb && typeof cb === 'function' ) { if ( err ) return cb ( err ) ; var lines = util . compact ( stdout . split ( '\n' ) ) ; var list = lines . map ( function ( x ) { return new util . Property ( x ) ; } ) ; cb ( err , list ) ; } } ) ; } 
function destroy ( opts , cb ) { "use strict" ; var params = [ 'destroy' ] ; if ( opts . recursive ) { params . push ( '-r' ) ; } params . push ( opts . name ) ; zfs ( params , cb ) ; } 
function create ( opts , cb ) { "use strict" ; var params = [ 'create' ] ; if ( opts . options ) { if ( opts . options . length ) { 
function set ( opts , cb ) { "use strict" ; var params = [ 'set' ] ; params . push ( opts . property + "=" + opts . value ) ; params . push ( opts . name ) ; zfs ( params , cb ) ; } 
function snapshot ( opts , cb ) { "use strict" ; var params = [ 'snapshot' ] ; if ( opts . recursive ) { params . push ( '-r' ) ; } params . push ( opts . dataset + '@' + opts . name ) ; zfs ( params , cb ) ; } 
function clone ( opts , cb ) { "use strict" ; var params = [ 'clone' ] ; params . push ( opts . snapshot , opts . dataset ) ; zfs ( params , cb ) ; } 
function mount ( opts , cb ) { "use strict" ; var params = [ 'mount' ] ; if ( opts . overlay ) { params . push ( '-O' ) ; } if ( opts . options ) { if ( opts . options . length ) { 
function unmount ( opts , cb ) { "use strict" ; var params = [ 'unmount' ] ; if ( opts . force ) { params . push ( '-f' ) ; } if ( opts . name ) { params . push ( opts . name ) ; } else { params . push ( '-a' ) ; } zfs ( params , cb ) ; } 
function send ( opts , cb ) { "use strict" ; var params = [ 'send' ] ; if ( opts . replication ) { params . push ( '-R' ) ; } if ( opts . deduplicate ) { params . push ( '-D' ) ; } if ( opts . properties ) { params . push ( '-p' ) ; } if ( opts . noop ) { params . push ( '-n' ) ; } if ( opts . parsable ) { params . push ( '-P' ) ; } if ( opts . verbose ) { params . push ( '-v' ) ; } if ( opts . incremental ) { if ( opts . intermediary ) { params . push ( '-I' ) ; } else { params . push ( '-i' ) ; } params . push ( opts . incremental ) ; } params . push ( opts . snapshot ) ; spawnzfs ( params , function ( err , child ) { if ( err ) { return cb ( err ) ; } var buffer = [ ] ; var sendStream = child . stdout ; child . stderr . on ( 'data' , function ( data ) { data = data . toString ( ) ; buffer . push ( data ) ; if ( opts . verbose ) { sendStream . emit ( 'verbose' , data ) ; } 
function receive ( opts , cb ) { "use strict" ; var params = [ 'receive' ] ; if ( opts . verbose ) { params . push ( '-v' ) ; } if ( opts . noop ) { params . push ( '-n' ) ; } if ( opts . force ) { params . push ( '-F' ) ; } if ( opts . unmounted ) { params . push ( '-u' ) ; } if ( opts . d ) { params . push ( '-d' ) ; } if ( opts . e ) { params . push ( '-e' ) ; } params . push ( opts . dataset ) ; spawnzfs ( params , function ( err , child ) { if ( err ) { return cb ( err ) ; } var buffer = [ ] ; var receiveStream = child . stdin ; child . stderr . on ( 'data' , function ( data ) { data = data . toString ( ) ; buffer . push ( data ) ; if ( opts . verbose ) { receiveStream . emit ( 'verbose' , data ) ; } 
function copyString ( buffer , length , offsetBegin , offsetEnd ) { if ( length > 2048 ) { return buffer . toString ( 'utf-8' , offsetBegin , offsetEnd ) ; } var string = '' ; while ( offsetBegin < offsetEnd ) { string += String . fromCharCode ( buffer [ offsetBegin ++ ] ) ; } return string ; } 
function parseSimpleString ( parser ) { var offset = parser . offset ; var length = parser . buffer . length ; var string = '' ; while ( offset < length ) { var c1 = parser . buffer [ offset ++ ] ; if ( c1 === 13 ) { var c2 = parser . buffer [ offset ++ ] ; if ( c2 === 10 ) { parser . offset = offset ; return string ; } string += String . fromCharCode ( c1 ) + String . fromCharCode ( c2 ) ; continue ; } string += String . fromCharCode ( c1 ) ; } return undefined ; } 
function getBaseConfig ( isProd ) { 
function getUpdateInfo ( update ) { let isChosen = false ; let isEdited = false ; let original = '' ; let name = '' ; if ( update . message ) { name = 'message' ; original = 'message' ; } else if ( update . edited_message ) { isEdited = true ; original = 'edited_message' ; name = 'message' ; } else if ( update . channel_post ) { original = 'channel_post' ; name = 'post' ; } else if ( update . edited_channel_post ) { isEdited = true ; original = 'edited_channel_post' ; name = 'post' ; } else if ( update . inline_query ) { original = 'inline_query' ; name = 'inline' ; } else if ( update . chosen_inline_result ) { isChosen = true ; original = 'chosen_inline_result' ; name = 'inline' ; } else if ( update . callback_query ) { original = 'callback_query' ; name = 'callback' ; } return { isChosen , isEdited , original , name } ; } 
function attachStreamToSocket ( readStream , socketWriteStream , callback , usePipe = false ) { if ( ! usePipe ) { _attachStreamToSocket ( readStream , socketWriteStream , callback ) ; } else { readStream . pipe ( socketWriteStream , { end : false } ) ; readStream . once ( 'end' , ( ) => { readStream . unpipe ( ) ; callback ( ) ; } ) ; } } 
function postNotification ( options , cb ) { options . title = removeColor ( options . title ) ; options . message = removeColor ( options . message ) ; if ( ! options . message ) { return cb && cb ( ! options . message && 'Message is required' ) ; } if ( ! notifyPlatform ) { notifyPlatform = choosePlatform ( ) ; } function resetPreviousTimer ( newMessage ) { previousMessage = newMessage ; clearTimeout ( previousMessageTimer ) ; previousMessageTimer = setTimeout ( function ( ) { previousMessage = false ; } , previousMessageTimeoutMS ) ; } if ( options . message === previousMessage ) { resetPreviousTimer ( options . message ) ; if ( typeof cb === 'function' ) { cb ( err ) ; } return ; } resetPreviousTimer ( options . message ) ; options . debug = debug ( notifyPlatform . name ) ; 
function Compiler ( file , options ) { this . options = options || { } ; this . parser = new Parser ( file , options ) ; this . compilers = { } ; this . files = [ ] ; this . file = file ; this . files = [ this . file ] ; this . result = '' ; } 
function dry ( file , options ) { debug ( 'rendering <%s>' , file . path ) ; var opts = utils . extend ( { } , options ) ; dry . parse ( file , opts ) ; dry . compile ( file , opts ) ; file . fn ( opts . locals ) ; return file ; } 
function generateUsername ( base ) { base = base . toLowerCase ( ) ; var entries = [ ] ; var finalName ; return userDB . allDocs ( { startkey : base , endkey : base + '\uffff' , include_docs : false } ) . then ( function ( results ) { if ( results . rows . length === 0 ) { return BPromise . resolve ( base ) ; } for ( var i = 0 ; i < results . rows . length ; i ++ ) { entries . push ( results . rows [ i ] . id ) ; } if ( entries . indexOf ( base ) === - 1 ) { return BPromise . resolve ( base ) ; } var num = 0 ; while ( ! finalName ) { num ++ ; if ( entries . indexOf ( base + num ) === - 1 ) { finalName = base + num ; } } return BPromise . resolve ( finalName ) ; } ) ; } 
function initSession ( req , res , next ) { var provider = getProvider ( req . path ) ; return user . createSession ( req . user . _id , provider , req ) . then ( function ( mySession ) { return BPromise . resolve ( { error : null , session : mySession , link : null } ) ; } ) . then ( function ( results ) { var template ; if ( config . getItem ( 'testMode.oauthTest' ) ) { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback-test.ejs' ) , 'utf8' ) ; } else { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback.ejs' ) , 'utf8' ) ; } var html = ejs . render ( template , results ) ; res . status ( 200 ) . send ( html ) ; } , function ( err ) { return next ( err ) ; } ) ; } 
function initTokenSession ( req , res , next ) { var provider = getProviderToken ( req . path ) ; return user . createSession ( req . user . _id , provider , req ) . then ( function ( mySession ) { return BPromise . resolve ( mySession ) ; } ) . then ( function ( session ) { res . status ( 200 ) . json ( session ) ; } , function ( err ) { return next ( err ) ; } ) ; } 
function linkSuccess ( req , res , next ) { var provider = getProvider ( req . path ) ; var result = { error : null , session : null , link : provider } ; var template ; if ( config . getItem ( 'testMode.oauthTest' ) ) { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback-test.ejs' ) , 'utf8' ) ; } else { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback.ejs' ) , 'utf8' ) ; } var html = ejs . render ( template , result ) ; res . status ( 200 ) . send ( html ) ; } 
function linkTokenSuccess ( req , res , next ) { var provider = getProviderToken ( req . path ) ; res . status ( 200 ) . json ( { ok : true , success : util . capitalizeFirstLetter ( provider ) + ' successfully linked' , provider : provider } ) ; } 
function oauthErrorHandler ( err , req , res , next ) { var template ; if ( config . getItem ( 'testMode.oauthTest' ) ) { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback-test.ejs' ) , 'utf8' ) ; } else { template = fs . readFileSync ( path . join ( __dirname , '../templates/oauth/auth-callback.ejs' ) , 'utf8' ) ; } var html = ejs . render ( template , { error : err . message , session : null , link : null } ) ; console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; } res . status ( 400 ) . send ( html ) ; } 
function tokenAuthErrorHandler ( err , req , res , next ) { var status ; if ( req . user && req . user . _id ) { status = 403 ; } else { status = 401 ; } console . error ( err ) ; if ( err . stack ) { console . error ( err . stack ) ; delete err . stack ; } res . status ( status ) . json ( err ) ; } 
function registerProvider ( provider , configFunction ) { provider = provider . toLowerCase ( ) ; var configRef = 'providers.' + provider ; if ( config . getItem ( configRef + '.credentials' ) ) { var credentials = config . getItem ( configRef + '.credentials' ) ; credentials . passReqToCallback = true ; var options = config . getItem ( configRef + '.options' ) || { } ; configFunction . call ( null , credentials , passport , authHandler ) ; router . get ( '/' + provider , passportCallback ( provider , options , 'login' ) ) ; router . get ( '/' + provider + '/callback' , passportCallback ( provider , options , 'login' ) , initSession , oauthErrorHandler ) ; if ( ! config . getItem ( 'security.disableLinkAccounts' ) ) { router . get ( '/link/' + provider , passport . authenticate ( 'bearer' , { session : false } ) , passportCallback ( provider , options , 'link' ) ) ; router . get ( '/link/' + provider + '/callback' , passport . authenticate ( 'bearer' , { session : false } ) , passportCallback ( provider , options , 'link' ) , linkSuccess , oauthErrorHandler ) ; } console . log ( provider + ' loaded.' ) ; } } 
function registerOAuth2 ( providerName , Strategy ) { registerProvider ( providerName , function ( credentials , passport , authHandler ) { passport . use ( new Strategy ( credentials , function ( req , accessToken , refreshToken , profile , done ) { authHandler ( req , providerName , { accessToken : accessToken , refreshToken : refreshToken } , profile ) . asCallback ( done ) ; } ) ) ; } ) ; } 
function registerTokenProvider ( providerName , Strategy ) { providerName = providerName . toLowerCase ( ) ; var configRef = 'providers.' + providerName ; if ( config . getItem ( configRef + '.credentials' ) ) { var credentials = config . getItem ( configRef + '.credentials' ) ; credentials . passReqToCallback = true ; var options = config . getItem ( configRef + '.options' ) || { } ; 
function authHandler ( req , provider , auth , profile ) { if ( req . user && req . user . _id && req . user . key ) { return user . linkSocial ( req . user . _id , provider , auth , profile , req ) ; } else { return user . socialAuth ( provider , auth , profile , req ) ; } } 
function passportCallback ( provider , options , operation ) { return function ( req , res , next ) { var theOptions = extend ( { } , options ) ; if ( provider === 'linkedin' ) { theOptions . state = true ; } var accessToken = req . query . bearer_token || req . query . state ; if ( accessToken && ( stateRequired . indexOf ( provider ) > - 1 || config . getItem ( 'providers.' + provider + '.stateRequired' ) === true ) ) { theOptions . state = accessToken ; } theOptions . callbackURL = getLinkCallbackURLs ( provider , req , operation , accessToken ) ; theOptions . session = false ; passport . authenticate ( provider , theOptions ) ( req , res , next ) ; } ; } 
function passportTokenCallback ( provider , options ) { return function ( req , res , next ) { var theOptions = extend ( { } , options ) ; theOptions . session = false ; passport . authenticate ( provider + '-token' , theOptions ) ( req , res , next ) ; } ; } 
function getProvider ( pathname ) { var items = pathname . split ( '/' ) ; var index = items . indexOf ( 'callback' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } } 
function getProviderToken ( pathname ) { var items = pathname . split ( '/' ) ; var index = items . indexOf ( 'token' ) ; if ( index > 0 ) { return items [ index - 1 ] ; } } 
function requireRole ( requiredRole ) { return function ( req , res , next ) { if ( ! req . user ) { return next ( superloginError ) ; } var roles = req . user . roles ; if ( ! roles || ! roles . length || roles . indexOf ( requiredRole ) === - 1 ) { res . status ( forbiddenError . status ) ; res . json ( forbiddenError ) ; } else { next ( ) ; } } ; } 
function getLegalDBName ( input ) { input = input . toLowerCase ( ) ; var output = encodeURIComponent ( input ) ; output = output . replace ( / \. / g , '%2E' ) ; output = output . replace ( / ! / g , '%21' ) ; output = output . replace ( / ~ / g , '%7E' ) ; output = output . replace ( / \* / g , '%2A' ) ; output = output . replace ( / ' / g , '%27' ) ; output = output . replace ( / \( / g , '%28' ) ; output = output . replace ( / \) / g , '%29' ) ; output = output . replace ( / \- / g , '%2D' ) ; output = output . toLowerCase ( ) ; output = output . replace ( / (%..) / g , function ( esc ) { esc = esc . substr ( 1 ) ; return '(' + esc + ')' ; } ) ; return output ; } 
function FileAdapter ( config ) { var sessionsRoot = config . getItem ( 'session.file.sessionsRoot' ) ; this . _sessionFolder = path . join ( process . env . PWD , sessionsRoot ) ; console . log ( 'File Adapter loaded' ) ; } 
function ( ) { var foundLayer = null ; $ . each ( projectedTiles , function ( layerName , layer ) { if ( map . hasLayer ( layer ) ) { foundLayer = layer ; } } ) ; return foundLayer ; } 
function ( tileLayer ) { if ( this . options . changingMap ) { return false ; } 
function ( ) { for ( var i in this . _layers ) { this . removeLayer ( this . _layers [ i ] ) ; } L . Map . prototype . remove . call ( this ) ; return this ; } 
function ( crs , options ) { var resolutions = [ ] ; for ( var zoom = options . minZoom ; zoom <= options . maxZoom ; zoom ++ ) { resolutions . push ( options . maxResolution / Math . pow ( 2 , zoom ) ) ; } return new L . Proj . CRS ( crs , options . proj4def , { origin : options . origin , resolutions : resolutions , bounds : options . projectedBounds } ) ; } 
function ( crs , options ) { switch ( crs ) { case "EPSG:3857" : return L . CRS . EPSG3857 ; case "EPSG:3395" : return L . CRS . EPSG3395 ; case "EPSG:4326" : return L . CRS . EPSG4326 ; default : return this . _defineMapCRS ( crs , options ) ; } } 
function ( group ) { var map = this ; if ( group . eachLayer ) { group . eachLayer ( function ( layer ) { map . _updateAllLayers ( layer ) ; } ) ; } else { if ( group . redraw ) { group . redraw ( ) ; } else if ( group . update ) { group . update ( ) ; } else { console . log ( "Don't know how to update" , group ) ; } } } 
function ( layersArray ) { var fg = this . _featureGroup , npg = this . _nonPointGroup , chunked = this . options . chunkedLoading , chunkInterval = this . options . chunkInterval , chunkProgress = this . options . chunkProgress , newMarkers , i , l , m ; if ( this . _map ) { var offset = 0 , started = ( new Date ( ) ) . getTime ( ) ; var process = L . bind ( function ( ) { var start = ( new Date ( ) ) . getTime ( ) ; for ( ; offset < layersArray . length ; offset ++ ) { if ( chunked && offset % 200 === 0 ) { 
function ( layersArray ) { var i , l , m , fg = this . _featureGroup , npg = this . _nonPointGroup ; if ( ! this . _map ) { for ( i = 0 , l = layersArray . length ; i < l ; i ++ ) { m = layersArray [ i ] ; this . _arraySplice ( this . _needsClustering , m ) ; npg . removeLayer ( m ) ; } return this ; } for ( i = 0 , l = layersArray . length ; i < l ; i ++ ) { m = layersArray [ i ] ; if ( ! m . __parent ) { npg . removeLayer ( m ) ; continue ; } this . _removeLayer ( m , true , true ) ; if ( fg . hasLayer ( m ) ) { fg . removeLayer ( m ) ; if ( m . setOpacity ) { m . setOpacity ( 1 ) ; } } } 
function ( ) { var bounds = new L . LatLngBounds ( ) ; if ( this . _topClusterLevel ) { bounds . extend ( this . _topClusterLevel . _bounds ) ; } for ( var i = this . _needsClustering . length - 1 ; i >= 0 ; i -- ) { bounds . extend ( this . _needsClustering [ i ] . getLatLng ( ) ) ; } bounds . extend ( this . _nonPointGroup . getBounds ( ) ) ; return bounds ; } 
function ( method , context ) { var markers = this . _needsClustering . slice ( ) , i ; if ( this . _topClusterLevel ) { this . _topClusterLevel . getAllChildMarkers ( markers ) ; } for ( i = markers . length - 1 ; i >= 0 ; i -- ) { method . call ( context , markers [ i ] ) ; } this . _nonPointGroup . eachLayer ( method , context ) ; } 
function ( id ) { var result = null ; this . eachLayer ( function ( l ) { if ( L . stamp ( l ) === id ) { result = l ; } } ) ; return result ; } 
function ( layer ) { if ( ! layer ) { return false ; } var i , anArray = this . _needsClustering ; for ( i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === layer ) { return true ; } } anArray = this . _needsRemoving ; for ( i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === layer ) { return false ; } } return ! ! ( layer . __parent && layer . __parent . _group === this ) || this . _nonPointGroup . hasLayer ( layer ) ; } 
function ( layer , callback ) { var showMarker = function ( ) { if ( ( layer . _icon || layer . __parent . _icon ) && ! this . _inZoomAnimation ) { this . _map . off ( 'moveend' , showMarker , this ) ; this . off ( 'animationend' , showMarker , this ) ; if ( layer . _icon ) { callback ( ) ; } else if ( layer . __parent . _icon ) { var afterSpiderfy = function ( ) { this . off ( 'spiderfied' , afterSpiderfy , this ) ; callback ( ) ; } ; this . on ( 'spiderfied' , afterSpiderfy , this ) ; layer . __parent . spiderfy ( ) ; } } } ; if ( layer . _icon && this . _map . getBounds ( ) . contains ( layer . getLatLng ( ) ) ) { 
function ( map ) { this . _map = map ; var i , l , layer ; if ( ! isFinite ( this . _map . getMaxZoom ( ) ) ) { throw "Map has no maxZoom specified" ; } this . _featureGroup . onAdd ( map ) ; this . _nonPointGroup . onAdd ( map ) ; if ( ! this . _gridClusters ) { this . _generateInitialClusters ( ) ; } for ( i = 0 , l = this . _needsRemoving . length ; i < l ; i ++ ) { layer = this . _needsRemoving [ i ] ; this . _removeLayer ( layer , true ) ; } this . _needsRemoving = [ ] ; 
function ( map ) { map . off ( 'zoomend' , this . _zoomEnd , this ) ; map . off ( 'moveend' , this . _moveEnd , this ) ; this . _unbindEvents ( ) ; 
function ( anArray , obj ) { for ( var i = anArray . length - 1 ; i >= 0 ; i -- ) { if ( anArray [ i ] === obj ) { anArray . splice ( i , 1 ) ; return true ; } } } 
function ( marker , removeFromDistanceGrid , dontUpdateMap ) { var gridClusters = this . _gridClusters , gridUnclustered = this . _gridUnclustered , fg = this . _featureGroup , map = this . _map ; 
function ( cluster ) { var childCount = cluster . getChildCount ( ) ; var c = ' marker-cluster-' ; if ( childCount < 10 ) { c += 'small' ; } else if ( childCount < 100 ) { c += 'medium' ; } else { c += 'large' ; } return new L . DivIcon ( { html : '<div><span>' + childCount + '</span></div>' , className : 'marker-cluster' + c , iconSize : new L . Point ( 40 , 40 ) } ) ; } 
function ( layer , zoom ) { var gridClusters = this . _gridClusters , gridUnclustered = this . _gridUnclustered , markerPoint , z ; if ( this . options . singleMarkerMode ) { layer . options . icon = this . options . iconCreateFunction ( { getChildCount : function ( ) { return 1 ; } , getAllChildMarkers : function ( ) { return [ layer ] ; } } ) ; } 
function ( fn ) { this . _queue . push ( fn ) ; if ( ! this . _queueTimeout ) { this . _queueTimeout = setTimeout ( L . bind ( this . _processQueue , this ) , 300 ) ; } } 
function ( ) { if ( ! this . options . removeOutsideVisibleBounds ) { return this . getBounds ( ) ; } var map = this . _map , bounds = map . getBounds ( ) , sw = bounds . _southWest , ne = bounds . _northEast , latDiff = L . Browser . mobile ? 0 : Math . abs ( sw . lat - ne . lat ) , lngDiff = L . Browser . mobile ? 0 : Math . abs ( sw . lng - ne . lng ) ; return new L . LatLngBounds ( new L . LatLng ( sw . lat - latDiff , sw . lng - lngDiff , true ) , new L . LatLng ( ne . lat + latDiff , ne . lng + lngDiff , true ) ) ; } 
function ( layer , newCluster ) { if ( newCluster === layer ) { this . _featureGroup . addLayer ( layer ) ; } else if ( newCluster . _childCount === 2 ) { newCluster . _addToMap ( ) ; var markers = newCluster . getAllChildMarkers ( ) ; this . _featureGroup . removeLayer ( markers [ 0 ] ) ; this . _featureGroup . removeLayer ( markers [ 1 ] ) ; } else { newCluster . _updateIcon ( ) ; } } 
function ( storageArray ) { storageArray = storageArray || [ ] ; for ( var i = this . _childClusters . length - 1 ; i >= 0 ; i -- ) { this . _childClusters [ i ] . getAllChildMarkers ( storageArray ) ; } for ( var j = this . _markers . length - 1 ; j >= 0 ; j -- ) { storageArray . push ( this . _markers [ j ] ) ; } return storageArray ; } 
function ( ) { var childClusters = this . _childClusters . slice ( ) , map = this . _group . _map , boundsZoom = map . getBoundsZoom ( this . _bounds ) , zoom = this . _zoom + 1 , mapZoom = map . getZoom ( ) , i ; 
function ( marker ) { var addedCount , addedLatLng = marker . _wLatLng || marker . _latlng ; if ( marker instanceof L . MarkerCluster ) { this . _bounds . extend ( marker . _bounds ) ; addedCount = marker . _childCount ; } else { this . _bounds . extend ( addedLatLng ) ; addedCount = 1 ; } if ( ! this . _cLatLng ) { 
function ( previousBounds , zoomLevel , exceptBounds ) { var m , i ; this . _recursively ( previousBounds , - 1 , zoomLevel - 1 , function ( c ) { 
function ( boundsToApplyTo , zoomLevelToStart , zoomLevelToStop , runAtEveryLevel , runAtBottomLevel ) { var childClusters = this . _childClusters , zoom = this . _zoom , i , c ; if ( zoomLevelToStart > zoom ) { 
function ( latLngs ) { 
function ( ) { if ( this . _group . _spiderfied === this || this . _group . _inZoomAnimation ) { return ; } var childMarkers = this . getAllChildMarkers ( ) , group = this . _group , map = group . _map , center = map . latLngToLayerPoint ( this . _latlng ) , positions ; this . _group . _unspiderfy ( ) ; this . _group . _spiderfied = this ; 
function ( childMarkers , positions ) { var group = this . _group , map = group . _map , fg = group . _featureGroup , i , m , leg , newPos ; for ( i = childMarkers . length - 1 ; i >= 0 ; i -- ) { newPos = map . layerPointToLatLng ( positions [ i ] ) ; m = childMarkers [ i ] ; m . _preSpiderfyLatlng = m . _latlng ; m . setLatLng ( newPos ) ; if ( m . setZIndexOffset ) { m . setZIndexOffset ( 1000000 ) ; 
function ( layer ) { if ( layer . _spiderLeg ) { this . _featureGroup . removeLayer ( layer ) ; layer . setOpacity ( 1 ) ; 
function ( projection ) { for ( var key in projectedTiles ) { if ( projectedTiles . hasOwnProperty ( key ) ) { if ( key . indexOf ( projection ) !== - 1 ) { return projectedTiles [ key ] ; } } } return null ; } 
function ( projection ) { for ( var key in tiles ) { if ( tiles . hasOwnProperty ( key ) ) { if ( key . indexOf ( projection ) !== - 1 ) { return tiles [ key ] ; } } } return null ; } 
function addToMap ( location , map ) { var marker = L . marker ( location . coordinates ) ; marker . addTo ( map ) ; } 
function ( featureData , layer ) { var coords = featureData . geometry . coordinates ; return boundsLimit . contains ( L . latLng ( [ coords [ 1 ] , coords [ 0 ] ] ) ) ; } 
function ( featureData , layer ) { var bbox = featureData . geometry . bbox ; var llBounds = L . latLngBounds ( [ bbox [ 1 ] , bbox [ 0 ] ] , [ bbox [ 3 ] , bbox [ 2 ] ] ) ; return boundsLimit . contains ( llBounds ) ; } 
function interpolate ( path , data ) { return path . replace ( / :(\w+) / g , function ( match , param ) { return data [ param ] } ) } 
function createPagesUtility ( pages , index ) { return function getPages ( number ) { var offset = Math . floor ( number / 2 ) var start , end if ( index + offset >= pages . length ) { start = Math . max ( 0 , pages . length - number ) end = pages . length } else { start = Math . max ( 0 , index - offset ) end = Math . min ( start + number , pages . length ) } return pages . slice ( start , end ) } } 
function ( ) { var templates = { data : { } } ; var stringTemplateSource = function ( template ) { this . text = function ( value ) { if ( arguments . length === 0 ) { return templates [ template ] ; } templates [ template ] = value ; } ; } ; var templateEngine = new ko . nativeTemplateEngine ( ) ; templateEngine . makeTemplateSource = function ( template ) { return new stringTemplateSource ( template ) ; } ; templateEngine . addTemplate = function ( key , value ) { templates [ key ] = value ; } ; return templateEngine ; } 
function beforeChild ( parserState , compilerState , result , checkParent ) { var _isDomMethod = checkParent !== true ? isDomMethod ( compilerState ) : isParentDomMethod ( compilerState ) ; var _numAttributes = checkParent !== true ? numAttributes ( parserState ) : numParentAttributes ( parserState ) ; var _numChildren = checkParent !== true ? numChildren ( parserState ) : numParentChildren ( parserState ) ; var _isTopLevelChild = checkParent !== true ? parserState . childCounts . length > 1 : parserState . childCounts . length > 2 ; if ( _isTopLevelChild === true ) { if ( _numAttributes <= 0 ) { if ( _numChildren <= 1 ) { if ( _isDomMethod !== true ) { 
function Job ( collection , data ) { this . collection = collection ; if ( data ) { 
function Worker ( queues , options ) { options || ( options = { } ) ; this . empty = 0 ; this . queues = queues || [ ] ; this . interval = options . interval || 5000 ; this . callbacks = options . callbacks || { } ; this . strategies = options . strategies || { } ; this . universal = options . universal || false ; 
function Uploader ( options ) { if ( typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } this . $el = this . _getElement ( options . el ) ; this . _elType = this . $el . tagName . toLowerCase ( ) ; 
function handleDragEvents ( e ) { e . stopPropagation ( ) ; e . preventDefault ( ) ; return this . emit ( e . type , e ) ; } 
function formatRecordByColumnLabel ( recode ) { const recodeBuffer = { } ; recode . forEach ( function ( value , index ) { recodeBuffer [ new Ordinal ( index + 1 ) . toAlphabet ( ) ] = value ; } ) ; return recodeBuffer ; } 
function formatRecordByMapping ( recode , mapping ) { return Object . keys ( mapping ) . reduce ( ( formatted , keyName ) => { if ( mapping [ keyName ] !== 0 ) { formatted [ keyName ] = recode [ new Ordinal ( mapping [ keyName ] ) . toNumber ( ) - 1 ] ; } return formatted ; } , { } ) ; } 
function ( deviceInfo ) { this . _handle = deviceInfo . _handle ; this . address = deviceInfo . _handle ; this . name = deviceInfo . name ; this . serviceUUIDs = deviceInfo . uuids ; this . adData = deviceInfo . adData ; this . connected = false ; this . services = { } ; } 
function ( serviceInfo ) { this . _handle = serviceInfo . _handle ; this . uuid = serviceInfo . uuid ; this . primary = serviceInfo . primary ; this . includedServices = { } ; this . characteristics = { } ; } 
function ( characteristicInfo ) { this . _handle = characteristicInfo . _handle ; this . uuid = characteristicInfo . uuid ; this . properties = characteristicInfo . properties ; this . descriptors = { } ; } 
function streamifyGulp ( pluginStream ) { var inputStream = new Stream . Transform ( { objectMode : true } ) ; var outputStream = new Stream . Transform ( { objectMode : true } ) ; var duplex = new Duplexer ( { objectMode : true } , inputStream , outputStream ) ; 
function ( value ) { if ( value != value || value === 0 ) { for ( var i = this . length ; i -- && ! is ( this [ i ] , value ) ; ) { } } else { i = [ ] . indexOf . call ( this , value ) ; } return i ; } 
function Tor ( child , port , dir ) { this . process = child ; this . port = port ; this . dir = dir ; } 
function getIncluded ( ) { var args = config . files ( ) . included || getDefaultArgs ( ) || getPackageJsonArgs ( ) || getBowerJsonArgs ( ) || [ ] ; return _expandGlobs ( args ) ; } 
function getDefaultArgs ( ) { var results = [ ] ; DEFAULT_PATHS . forEach ( function ( dir ) { if ( fs . existsSync ( dir ) ) results . push ( dir ) ; } ) ; return results . length == 0 ? null : results ; } 
function getPackageJsonArgs ( ) { var results = [ ] ; var config = _loadJson ( 'package.json' ) ; if ( config . main ) results = results . concat ( getMainFieldAsArray ( config . main ) ) ; if ( config . files ) results = results . concat ( config . files ) ; return results . length == 0 ? null : results . filter ( _uniqfilter ) ; } 
function getBowerJsonArgs ( ) { var results = [ ] ; var config = _loadJson ( 'bower.json' ) ; if ( config . main ) results = results . concat ( getMainFieldAsArray ( config . main ) ) ; return results . length == 0 ? null : results . filter ( _uniqfilter ) ; } 
function getMainFieldAsArray ( main ) { if ( main . constructor === Array ) { return main ; } else { if ( fs . existsSync ( main ) ) { return [ main ] ; } else if ( fs . existsSync ( main + '.js' ) ) { return [ main + '.js' ] ; } else { return [ ] ; } } } 
function isModuleFunction2 ( doclet ) { return doclet . longname && doclet . longname === doclet . name && doclet . longname . indexOf ( 'module:' ) === 0 && doclet . kind === 'function' ; } 
function getMembers2 ( data ) { var find = function ( data , spec ) { return data ( spec ) . get ( ) ; } ; var members = { classes : find ( data , { kind : 'class' } ) , externals : find ( data , { kind : 'external' } ) , events : find ( data , { kind : 'event' } ) , globals : find ( data , { kind : [ 'member' , 'function' , 'constant' , 'typedef' ] , memberof : { isUndefined : true } } ) , mixins : find ( data , { kind : 'mixin' } ) , modules : find ( data , { kind : 'module' } ) , namespaces : find ( data , { kind : 'namespace' } ) , typedef : find ( data , { kind : 'typedef' , isTSEnum : { is : true } } ) , callbacks : find ( data , { kind : 'typedef' , isTSEnum : { isUndefined : true } } ) } ; 
function ( field , reverse , primer ) { var key = function ( x ) { return primer ? primer ( x [ field ] ) : x [ field ] } ; return function ( a , b ) { var A = key ( a ) , B = key ( b ) ; return ( ( A < B ) ? - 1 : ( ( A > B ) ? 1 : 0 ) ) * [ - 1 , 1 ] [ + ! ! reverse ] ; } } 
function buildNav ( members ) { var seen = { } ; var nav = navigationMaster ; if ( members . modules . length ) { members . modules . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . modules . forEach ( function ( m ) { if ( ! hasOwnProp . call ( seen , m . longname ) ) { nav . module . members . push ( linkto ( m . longname , m . name ) ) ; } seen [ m . longname ] = true ; } ) ; } if ( members . externals . length ) { members . externals . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . externals . forEach ( function ( e ) { if ( ! hasOwnProp . call ( seen , e . longname ) ) { nav . external . members . push ( linkto ( e . longname , e . name . replace ( / (^"|"$) / g , '' ) ) ) ; } seen [ e . longname ] = true ; } ) ; } if ( members . classes . length ) { members . classes . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . classes . forEach ( function ( c ) { if ( ! hasOwnProp . call ( seen , c . longname ) ) { nav . class . members . push ( { link : linkto ( c . longname , c . longname ) , namespace : c } ) ; } seen [ c . longname ] = true ; } ) ; } if ( members . typedef . length ) { members . typedef . forEach ( function ( td ) { if ( ! hasOwnProp . call ( seen , td . longname ) ) { nav . typedef . members . push ( { link : linkto ( td . name , td . name ) , namespace : { longname : td . longname } } ) ; } seen [ td . longname ] = true ; } ) ; } if ( members . callbacks . length ) { members . callbacks . forEach ( function ( cb ) { if ( ! hasOwnProp . call ( seen , cb . longname ) ) { nav . callbacks . members . push ( { link : linkto ( cb . longname , cb . longname . split ( '#' ) [ 0 ] ) , namespace : { longname : cb . longname } } ) ; } seen [ cb . longname ] = true ; } ) ; } if ( members . namespaces . length ) { members . namespaces . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . namespaces . forEach ( function ( n ) { if ( ! hasOwnProp . call ( seen , n . longname ) ) { nav . namespace . members . push ( { link : linkto ( n . longname , n . longname ) , namespace : n } ) ; } seen [ n . longname ] = true ; } ) ; } if ( members . mixins . length ) { members . mixins . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . mixins . forEach ( function ( m ) { if ( ! hasOwnProp . call ( seen , m . longname ) ) { nav . mixin . members . push ( linkto ( m . longname , m . longname ) ) ; } seen [ m . longname ] = true ; } ) ; } if ( members . tutorials . length ) { members . tutorials . sort ( sort_by ( 'name' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . tutorials . forEach ( function ( t ) { nav . tutorial . members . push ( tutoriallink ( t . name ) ) ; } ) ; } if ( members . globals . length ) { members . globals . sort ( sort_by ( 'longname' , true , function ( a ) { return a . toUpperCase ( ) } ) ) ; members . globals . forEach ( function ( g ) { if ( g . kind !== 'typedef' && ! hasOwnProp . call ( seen , g . longname ) ) { nav . global . members . push ( linkto ( g . longname , g . longname ) ) ; } seen [ g . longname ] = true ; } ) ; } var topLevelNav = [ ] ; _ . each ( nav , function ( entry , name ) { if ( entry . members . length > 0 && name !== "index" ) { topLevelNav . push ( { title : entry . title , link : entry . link , members : entry . members } ) ; } } ) ; nav . topLevelNav = topLevelNav ; } 
function ( objects , inch_args ) { var cwd = process . cwd ( ) ; var excluded = config . files ( ) . excluded || [ ] ; var data = { language : 'javascript' , client_name : 'inchjs' , args : inch_args , client_version : "" + inch_config . version , git_repo_url : getGitRepoURL ( ) } ; if ( process . env . TRAVIS ) { data [ 'travis' ] = true ; data [ 'travis_job_id' ] = process . env . TRAVIS_JOB_ID ; data [ 'travis_commit' ] = process . env . TRAVIS_COMMIT ; data [ 'travis_repo_slug' ] = process . env . TRAVIS_REPO_SLUG ; } data [ 'branch_name' ] = getGitBranchName ( ) ; data [ 'objects' ] = objects . filter ( includeObjectFilter ) . map ( function ( item ) { return prepareCodeObject ( item , cwd ) ; } ) . filter ( function ( item ) { return ! excludeObjectIfMatch ( item , excluded ) ; } ) ; return data ; } 
function TorAgent ( opts ) { if ( ! ( this instanceof TorAgent ) ) { return new TorAgent ( ) ; } http . Agent . call ( this , opts ) ; this . socksHost = opts . socksHost || 'localhost' ; this . socksPort = opts . socksPort || 9050 ; this . defaultPort = 80 ; 
function ( element , options ) { this . $element = $ ( element ) ; this . options = $ . extend ( true , { } , $ . fn . typeahead . defaults , options ) ; this . $menu = $ ( this . options . menu ) . appendTo ( 'body' ) ; this . shown = false ; 
function ( ) { var that = this , query = that . $element . val ( ) ; if ( query === that . query ) { return that ; } 
function ( query ) { this . ajaxToggleLoadClass ( true ) ; 
function ( data ) { var items ; this . ajaxToggleLoadClass ( false ) ; if ( ! this . ajax . xhr ) return ; if ( this . ajax . preProcess ) { data = this . ajax . preProcess ( data ) ; } 
function ( event ) { var that = this , items ; if ( that . ajax ) { that . ajaxer ( ) ; } else { that . query = that . $element . val ( ) ; if ( ! that . query ) { return that . shown ? that . hide ( ) : that ; } items = that . grepper ( that . source ) ; if ( ! items || ! items . length ) { return that . shown ? that . hide ( ) : that ; } return that . render ( items . slice ( 0 , that . options . items ) ) . show ( ) ; } } 
function ( data ) { var that = this , items ; if ( data && data . length && ! data [ 0 ] . hasOwnProperty ( that . options . display ) ) { return null ; } items = $ . grep ( data , function ( item ) { return that . matcher ( item [ that . options . display ] , item ) ; } ) ; return this . sorter ( items ) ; } 
function ( items ) { var that = this , beginswith = [ ] , caseSensitive = [ ] , caseInsensitive = [ ] , item ; while ( item = items . shift ( ) ) { if ( ! item [ that . options . display ] . toLowerCase ( ) . indexOf ( this . query . toLowerCase ( ) ) ) { beginswith . push ( item ) ; } else if ( ~ item [ that . options . display ] . indexOf ( this . query ) ) { caseSensitive . push ( item ) ; } else { caseInsensitive . push ( item ) ; } } return beginswith . concat ( caseSensitive , caseInsensitive ) ; } 
function ( item ) { var query = this . query . replace ( / [\-\[\]{}()*+?.,\\\^$|#\s] / g , '\\$&' ) ; return item . replace ( new RegExp ( '(' + query + ')' , 'ig' ) , function ( $1 , match ) { return '<strong>' + match + '</strong>' ; } ) ; } 
function ( items ) { var that = this ; items = $ ( items ) . map ( function ( i , item ) { i = $ ( that . options . item ) . attr ( 'data-value' , item [ that . options . val ] ) ; i . find ( 'a' ) . html ( that . highlighter ( item [ that . options . display ] , item ) ) ; return i [ 0 ] ; } ) ; items . first ( ) . addClass ( 'active' ) ; this . $menu . html ( items ) ; return this ; } 
function ( event ) { var active = this . $menu . find ( '.active' ) . removeClass ( 'active' ) ; var next = active . next ( ) ; if ( ! next . length ) { next = $ ( this . $menu . find ( 'li' ) [ 0 ] ) ; } next . addClass ( 'active' ) ; } 
function ( e ) { e . stopPropagation ( ) ; if ( ! this . shown ) { return ; } switch ( e . keyCode ) { case 9 : 
function ( e ) { var that = this ; e . stopPropagation ( ) ; e . preventDefault ( ) ; setTimeout ( function ( ) { if ( ! that . $menu . is ( ':focus' ) ) { that . hide ( ) ; } } , 150 ) } 
function run ( inch_args , options ) { var callback = function ( filename ) { LocalInch . run ( inch_args || [ 'suggest' ] , filename , noop ) ; } if ( options . dry_run ) callback = noop ; retriever . run ( PathExtractor . extractPaths ( inch_args ) , callback ) ; } 
function ( options , callback ) { var data = options . data ; var target = options . target ; var features = options . features ; var featureTypes = options . featureTypes ; featureTypes . forEach ( function ( f ) { if ( [ 'number' , 'category' ] . indexOf ( f ) === - 1 ) { callback ( new Error ( 'Unrecognized feature type' ) ) ; return ; } } ) ; var targets = unique ( data . map ( function ( d ) { return d [ d . length - 1 ] ; } ) ) ; this . features = features ; this . targets = targets ; this . target = target var classify = this . classify . bind ( this ) var model = { features : this . features , targets : this . targets , 
function shutdown ( addr , b ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; if ( b ) spiTransfer ( addr , OP_SHUTDOWN , 0 ) ; else spiTransfer ( addr , OP_SHUTDOWN , 1 ) ; } 
function setScanLimit ( addr , limit ) { if ( addr < 0 || addr >= maxDevices ) return ; 
function setBrightness ( addr , intensity ) { if ( addr < 0 || addr >= maxDevices ) return ; if ( typeof intensity == 'undefined' ) return ; intensity = constrain ( intensity , 0 , 15 ) ; spiTransfer ( addr , OP_INTENSITY , intensity ) ; } 
function clearDisplay ( addr ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; var offset ; offset = addr * 8 ; for ( var i = 0 ; i < 8 ; i ++ ) { status [ offset + i ] = 0 ; spiTransfer ( addr , i + 1 , status [ offset + i ] ) ; } } 
function setDigit ( addr , digit , value , dp ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; if ( digit < 0 || digit > 7 ) throw 'invalid digit number' ; if ( value < 0 || value > 15 ) throw 'number out of range' ; var offset = addr * 8 ; var v = charTable [ value ] ; 
function showNumber ( addr , num , decimalplaces , mindigits , leftjustified , pos , dontclear ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; num = formatNumber ( num , decimalplaces , mindigits ) ; 
function setChar ( addr , digit , char , dp ) { if ( addr < 0 || addr >= maxDevices ) throw 'address out of range' ; if ( digit < 0 || digit > 7 ) throw 'invalid digit number' ; var offset = addr * 8 ; var v = charTable [ char ] || charTable [ char . toLowerCase ( ) ] ; 
function reduxifyService ( app , route ) { var _handleActions ; var name = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : route ; var options = arguments . length > 3 && arguments [ 3 ] !== undefined ? arguments [ 3 ] : { } ; var debug = ( 0 , _debug2 . default ) ( 'reducer:' + name ) ; debug ( 'route ' + route ) ; var defaults = { isError : 'isError' , isLoading : 'isLoading' , isSaving : 'isSaving' , isFinished : 'isFinished' , data : 'data' , queryResult : 'queryResult' , store : 'store' , PENDING : 'PENDING' , FULFILLED : 'FULFILLED' , REJECTED : 'REJECTED' } ; var opts = Object . assign ( { } , defaults , options ) ; var SERVICE_NAME = 'SERVICES_' + name . toUpperCase ( ) + '_' ; var service = app . service ( route ) ; if ( ! service ) { debug ( 'redux: Feathers service \'' + route + ' does not exist.' ) ; throw Error ( 'Feathers service \'' + route + ' does not exist.' ) ; } var reducerForServiceMethod = function reducerForServiceMethod ( actionType , ifLoading , isFind ) { var _ref ; return _ref = { } , _defineProperty ( _ref , actionType + '_' + opts . PENDING , function undefined ( state , action ) { var _extends2 ; debug ( 'redux:' + actionType + '_' + opts . PENDING , action ) ; return _extends ( { } , state , ( _extends2 = { } , _defineProperty ( _extends2 , opts . isError , null ) , _defineProperty ( _extends2 , opts . isLoading , ifLoading ) , _defineProperty ( _extends2 , opts . isSaving , ! ifLoading ) , _defineProperty ( _extends2 , opts . isFinished , false ) , _defineProperty ( _extends2 , opts . data , null ) , _defineProperty ( _extends2 , opts . queryResult , state [ opts . queryResult ] || null ) , _extends2 ) ) ; } ) , _defineProperty ( _ref , actionType + '_' + opts . FULFILLED , function undefined ( state , action ) { var _extends3 ; debug ( 'redux:' + actionType + '_' + opts . FULFILLED , action ) ; return _extends ( { } , state , ( _extends3 = { } , _defineProperty ( _extends3 , opts . isError , null ) , _defineProperty ( _extends3 , opts . isLoading , false ) , _defineProperty ( _extends3 , opts . isSaving , false ) , _defineProperty ( _extends3 , opts . isFinished , true ) , _defineProperty ( _extends3 , opts . data , ! isFind ? action . payload : null ) , _defineProperty ( _extends3 , opts . queryResult , isFind ? action . payload : state [ opts . queryResult ] || null ) , _extends3 ) ) ; } ) , _defineProperty ( _ref , actionType + '_' + opts . REJECTED , function undefined ( state , action ) { var _extends4 ; debug ( 'redux:' + actionType + '_' + opts . REJECTED , action ) ; return _extends ( { } , state , ( _extends4 = { } , _defineProperty ( _extends4 , opts . isError , action . payload ) , _defineProperty ( _extends4 , opts . isLoading , false ) , _defineProperty ( _extends4 , opts . isSaving , false ) , _defineProperty ( _extends4 , opts . isFinished , true ) , _defineProperty ( _extends4 , opts . data , null ) , _defineProperty ( _extends4 , opts . queryResult , isFind ? null : state [ opts . queryResult ] || null ) , _extends4 ) ) ; } ) , _ref ; } ; 
function getExampleCode ( comment ) { var expectedResult = comment . expectedResult ; var isAsync = comment . isAsync ; var testCase = comment . testCase ; if ( isAsync ) { return '\nfunction cb(err, result) {' + 'if(err) return done(err);' + 'result.should.eql(' + expectedResult + ');' + 'done();' + '}\n' + 'var returnValue = ' + testCase + ';' + 'if(returnValue && returnValue.then && typeof returnValue.then === \'function\') {' + 'returnValue.then(cb.bind(null, null), cb);' + '}' ; } else { return '(' + testCase + ').should.eql(' + expectedResult + ');' ; } } 
function hkdf ( ikm , length , { salt = '' , info = '' , hash = 'SHA-256' } = { } ) { hash = hash . toLowerCase ( ) . replace ( '-' , '' ) ; 
function request ( method , path , body , callback ) { var stream ; 
function ( options ) { "use strict" ; if ( ( options . setter && options . setter . indexOf ( '.' ) > - 1 ) || ( options . getter && options . getter . indexOf ( '.' ) > - 1 ) ) { throw new Error ( 'Getter (' + options . getter + ') and setter (' + options . setter + ') methods cannot be nested, so they cannot contain dot(.)' ) ; } this . options = Joi . attempt ( options , optionsSchema ) ; this . locales = this . getAvailableLocales ( ) ; this . default = this . options . default || this . locales [ 0 ] ; 
function fileExists ( path , shouldBeDir ) { "use strict" ; try { var lstat = fs . lstatSync ( path ) ; if ( shouldBeDir && lstat . isDirectory ( ) ) { return true ; } if ( ! shouldBeDir && lstat . isFile ( ) ) { return true ; } } catch ( err ) { return false ; } return false ; } 
async function ( server , options ) { try { var internal = new Internal ( options ) ; } catch ( err ) { throw new Boom ( err ) ; } server . expose ( 'getLocales' , function getLocales ( ) { return internal . locales ; } ) ; server . expose ( 'getDefaultLocale' , function getDefaultLocale ( ) { return internal . default ; } ) ; server . expose ( 'getLocale' , function getLocale ( request ) { try { return lodash . get ( request , internal . options . getter ) ( ) ; } catch ( err ) { return null ; } } ) ; server . ext ( internal . options . onEvent , internal . processRequest , { bind : internal } ) ; } 
function ( currDeps , loc ) { loc . deps = loc . deps || [ ] ; var covered = [ ] ; 
function ( ms , cycles ) { var removed = { } ; cycles . forEach ( function ( c ) { var last = c [ c . length - 1 ] ; 
function schema ( topic ) { if ( topic === constants . LOBSANG_CONTENT_TOPIC ) { return wrapper . fetch ( constants . LOBSANG_CONTENT_SCHEMA_URL ) } return Promise . reject ( new Error ( 'Topic is not supported' ) ) } 
function ( options ) { 
function whenRead ( args ) { let value = getValue ( args ) if ( value && typeof value . then === 'function' ) { value . then ( ( val ) => whenTest ( args , val ) ) . catch ( ( error ) => { console . error ( ` ${ action . displayName } ` , error ) } ) } else { whenTest ( args , value ) } } 
function isAsyncFunction ( value ) { if ( ! value ) return false ; const afcText = value . toString ( ) . toLocaleLowerCase ( ) . replace ( / \n / g , '' ) . replace ( / / g , '' ) ; return _testConstructor ( 'AsyncFunction' , value ) || ( ( _testConstructor ( 'Function' , value ) && ( afcText . slice ( afcText . indexOf ( '{' ) ) . indexOf ( 'returnnewpromise(function($return,$error)' ) === 1 ) ) ) ; //fast-async monkey-support } 
function isIterable ( value ) { return ( isObject ( value ) ? ! ! Object . keys ( value ) . length : false ) || ( isArray ( value ) ? ! ! value . length : false ) ; } 
function isJSON ( value ) { if ( ! isString ( value ) ) return false ; try { const obj = JSON . parse ( value ) ; return ! ! obj && typeof obj === 'object' ; } catch ( e ) { } return false ; } 
function arrayToObject ( value , toKeys ) { return ( iterate ( value , ( row , idx , iter ) => { if ( toKeys ) { if ( isInteger ( row ) || isString ( row ) ) iter . key ( idx + 1 ) ; return row ; } else { iter . key ( row ) ; return idx + 1 ; } } , { } ) ) ; } 
function objectToArray ( value , toKeys ) { return iterate ( value , ( val , key ) => toKeys ? key : val , [ ] ) ; } 
function setDefaults ( obj , name , value ) { if ( isUndefined ( obj [ name ] ) ) { obj [ name ] = value ; } return obj ; } 
function iterate ( value , callback , accumulate , assign ) { let breakFlag = false ; function newIteration ( index ) { let instance = { 'break' : ( ) => breakFlag = true , accKeyName : index , key : ( name ) => instance . accKeyName = name } ; return instance ; } let iterateInstanceAsync = async ( callback , val , index ) => { let iteration = newIteration ( index ) ; pushRet ( await callback ( val , index , iteration ) , iteration ) ; } ; let iterateInstance = ( callback , val , index ) => { let iteration = newIteration ( index ) ; pushRet ( callback ( val , index , iteration ) , iteration ) ; } ; let ret = isObject ( accumulate ) ? accumulate : isArray ( accumulate ) ? accumulate : accumulate === true ? false : value ; let pushRet = ( val , iteration ) => { if ( isUndefined ( val ) ) return ; if ( isObject ( accumulate ) ) { ret [ iteration . accKeyName ] = assign ? Object . assign ( ret [ iteration . accKeyName ] || { } , val ) : val ; } if ( isArray ( accumulate ) ) ret . push ( val ) ; if ( accumulate === true ) ret = ret || val ; } ; return isAsyncFunction ( callback ) ? new Promise ( async ( resolve ) => { if ( isArray ( value ) ) { for ( let index = 0 ; index < value . length ; ++ index ) { if ( breakFlag ) break ; await iterateInstanceAsync ( callback , value [ index ] , index ) ; } resolve ( ret ) ; } if ( isObject ( value ) ) { await iterate ( Object . keys ( value ) , async ( index , _ , iteration ) => { if ( breakFlag ) iteration . break ( ) ; await iterateInstanceAsync ( callback , value [ index ] , index ) ; } ) ; resolve ( ret ) ; } if ( isInteger ( value ) ) { for ( let index = 0 ; index < value ; ++ index ) { if ( breakFlag ) break ; await iterateInstanceAsync ( callback , index , index ) ; } resolve ( ret ) ; } resolve ( false ) ; } ) : ( ( ) => { if ( isArray ( value ) ) { for ( let index = 0 ; index < value . length ; ++ index ) { if ( breakFlag ) break ; iterateInstance ( callback , value [ index ] , index ) ; } return ret ; } if ( isObject ( value ) ) { iterate ( Object . keys ( value ) , ( index , _ , iteration ) => { if ( breakFlag ) iteration . break ( ) ; iterateInstance ( callback , value [ index ] , index ) ; } ) ; return ret ; } if ( isInteger ( value ) ) { for ( let index = 0 ; index < value ; ++ index ) { if ( breakFlag ) break ; iterateInstance ( callback , index , index ) ; } return ret ; } return false ; } ) ( ) ; } 
function iterateKeys ( value , callback , accumulate ) { return isAsyncFunction ( callback ) ? ( async ( ) => await iterate ( value , async ( row , key , iteration ) => await callback ( key , row , iteration ) , accumulate ) ) ( ) : iterate ( value , ( row , key , iteration ) => callback ( key , row , iteration ) , accumulate ) ; } 
async function iterateParallel ( value , callback ) { return Promise . all ( iterate ( value , ( val , key , iter ) => ( async ( ) => await callback ( val , key , iter ) ) ( ) , [ ] ) ) ; } 
function findAndDelete ( target , value ) { if ( ! isIterable ( target ) ) return false ; if ( isArray ( target ) ) { for ( let i = 0 ; i < target . length ; i ++ ) { if ( deep_equal_1 . default ( target [ i ] , value ) ) { target . splice ( i , 1 ) ; return true ; } } } else if ( isObject ( target ) ) { const keys = Object . keys ( target ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { if ( deep_equal_1 . default ( target [ keys [ i ] ] , value ) ) { delete target [ keys [ i ] ] ; return true ; } } } return false ; } 
function findAndDeleteAll ( target , value ) { let flag = false ; while ( findAndDelete ( target , value ) ) { flag = true ; } return flag ; } 
function SignAgreement ( data ) { var d = { 'a_name' : data . a_name , 'a_dob' : data . a_dob } ; XForm . prototype . XExecutePost ( '../agreement/_sign' , d , function ( rslt ) { if ( '_success' in rslt ) { window . location . href = jsh . _BASEURL + 'agreement/welcome/' ; } } ) ; } 
function start ( instance ) { console . log ( 'start called!' ) ; var chatClient = instance ( ) , 
function connect ( client ) { client . startClient ( ) return new Promise ( ( resolve , reject ) => { client . once ( 'sync' , ( state ) => { if ( wrapper . isSyncState ( state ) ) { return resolve ( client ) } else { return reject ( new Error ( 'Client could not sync' ) ) } } ) } ) } 
function lobsangProcessorHostname ( link ) { let parts try { parts = parseUrl ( link ) } catch ( error ) { return Promise . reject ( error ) } if ( parts . hostname === '' ) { return Promise . reject ( new Error ( 'Not an URL' ) ) } return Promise . resolve ( parts . hostname ) } 
function frameOfMind ( string , options = { } ) { const { padding = 1 } = options const l = string . split ( '\n' ) const w = l . reduce ( ( acc , { length } ) => length > acc ? length : acc , 0 ) const ww = w + padding * 2 const bt = ` ' '.rep e at(ww) } ` const bb = ` ' '.rep e at(ww) } ` const pp = ' ' . repeat ( padding ) const p = paddys ( string ) . split ( '\n' ) . map ( line => ` pp }$ { li ne}$ { pp } ` . join ( '\n' ) return ` ${ bt } \n ${ p } \n ${ bb } ` } 
function isSyncState ( state ) { if ( state === CONSTANTS . MATRIX_STATE_PREPARED ) { return true } if ( state === CONSTANTS . MATRIX_STATE_SYNCING ) { return true } return false } 
function lobsangFormatterSchema ( message , topic ) { if ( typeof message !== 'string' ) { return Promise . reject ( new Error ( 'Message is not a string' ) ) } return schema ( topic ) . then ( ( schemaObject ) => { const validator = validate ( schemaObject ) const schemaMessage = format ( message ) if ( validator ( schemaMessage ) ) { return Promise . resolve ( schemaMessage ) } return Promise . reject ( validator . errors ) } ) } 
function _resolve ( path , options , mod ) { if ( path ) { var i = path . indexOf ( ':' ) if ( i === - 1 ) { return resolveModule ( path , options , mod ) } else { var namespace = path . substring ( 0 , i ) var p = path . substring ( i + 1 ) if ( namespace === "env" ) { return resolveEnv ( p , options , mod ) } else if ( namespace === "http" || namespace === "https" ) { return resolveHttp ( path , options , mod ) } else if ( namespace === "file" ) { return resolveFile ( p , options , mod ) } else { throw new Error ( "Unable to resolve path: '" + path + "'. Unknown namespace: " + namespace ) } } } } 
function resolveEnv ( path , options , mod ) { var result = undefined if ( path ) { result = ( process [ PRIVATE_ENV ] && process [ PRIVATE_ENV ] [ path ] ) || process . env [ path ] } return result } 
function resolveModule ( path , options , mod ) { 
function resolveFilename ( path , mod ) { var result = null ; if ( path ) { try { return Module . _resolveFilename ( path , mod ) 
function resolveFile ( path , options , mod ) { if ( path ) { var f = Object ( ) Object . defineProperties ( f , { readStream : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . createReadStream ( path ) } } , writeStream : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . createWriteStream ( path , { flags : "a" } ) } } , content : { enumerable : true , configurable : false , writeable : false , get : function ( ) { return fs . readFile . sync ( path ) . toString ( ) } } } ) f . toString = function ( ) { return this . content } f . open = function ( ) { if ( ! arguments || arguments . length < 1 ) { throw ( Error ( "flags argument is required" ) ) } var flags = arguments [ 0 ] var mode = null var cb = null if ( arguments . length > 2 ) { mode = arguments [ 1 ] cb = arguments [ 2 ] } else if ( arguments . length > 1 ) { if ( typeof arguments [ 1 ] === "number" ) { mode = arguments [ 1 ] } else { cb = arguments [ 1 ] } } if ( cb ) { fs . open ( path , flags , mode , cb ) } else { return fs . openSync ( path , flags , mode ) } } return f } else { throw ( Error ( "File not found: " + path ) ) } } 
function _o ( mod ) { if ( ! ( mod instanceof Module ) ) { throw ( Error ( "Must supply a module to _o: " + mod ) ) } return function ( path , options ) { return _resolve ( path , options , mod ) } } 
function validate ( schema ) { const ajv = new Ajv ( ) try { const validator = ajv . compile ( schema ) return Promise . resolve ( validator ) } catch ( error ) { return Promise . reject ( error ) } } 
function ( options ) { assert ( options , "options are required" ) ; assert ( options . connectionString , "options.connectionString is missing" ) ; assert ( url . parse ( options . connectionString ) . protocol === 'https:' || options . allowHTTP , "InfluxDB connectionString must use HTTPS!" ) ; options = _ . defaults ( { } , options , { maxDelay : 60 * 5 , maxPendingPoints : 250 } ) ; this . _options = options ; this . _pendingPoints = { } ; this . _nbPendingPoints = 0 ; this . _flushTimeout = setTimeout ( this . flush . bind ( this , true ) , options . maxDelay * 1000 ) ; } 
function ( handler , options ) { assert ( handler instanceof Function , "A handler must be provided" ) ; assert ( options , "options required" ) ; assert ( options . drain , "options.drain is required" ) ; assert ( options . component , "options.component is required" ) ; 
function ( options ) { 
function ( options ) { options = _ . defaults ( { } , options || { } , { tags : { } , drain : undefined } ) ; assert ( options . drain , "options.drain is required" ) ; assert ( typeof options . tags === 'object' , "options.tags is required" ) ; assert ( _ . intersection ( _ . keys ( options . tags ) , series . APIClientCalls . columns ( ) ) . length === 0 , "Can't used reserved tag names!" ) ; 
function check ( message ) { if ( ! message ) { return Promise . reject ( new Error ( 'Argument must not be falsy!' ) ) } if ( typeof message !== 'string' ) { return Promise . reject ( new Error ( 'Argument must be a string!' ) ) } return Promise . resolve ( message ) } 
function generateHelp ( params ) { var output = '' ; if ( params . usage ) { var usage = result ( params , 'usage' ) ; output += EOL ; output += format ( 'Usage: %s' , usage ) ; output += EOL ; } if ( params . desc ) { var desc = result ( params , 'desc' ) ; output += EOL ; output += desc ; output += EOL ; } if ( is . object ( params . options ) && objectLength ( params . options ) > 0 ) { var options = buildOptions ( params . options ) ; output += EOL ; output += 'Options:' ; output += EOL ; output += EOL ; output += indent ( options , ' ' , 2 ) ; output += EOL ; } if ( is . array ( params . commands ) && params . commands . length > 0 ) { var commands = buildCommands ( params . commands ) ; output += EOL ; output += 'Commands:' ; output += EOL ; output += EOL ; output += indent ( commands , ' ' , 2 ) ; output += EOL ; } output += EOL ; return indent ( output , ' ' , 2 ) ; } 
function buildOptions ( options ) { var result = [ ] ; var keys = Object . keys ( options ) ; keys . forEach ( function ( key ) { var props = options [ key ] ; 
function buildCommands ( commands ) { var result = [ ] ; commands . forEach ( function ( command ) { result . push ( [ command . name , command . desc || '' ] ) ; } ) ; return table ( result ) ; } 
function initGrowlStatus ( ) { grunt . util . hooker . hook ( grunt . log , 'write' , function ( msg ) { if ( grunt . log . uncolor ( msg ) . match ( / Waiting... / ) ) { flushMessages ( 'ok' ) ; } } ) ; grunt . util . hooker . hook ( grunt . log , 'header' , function ( msg ) { msg = grunt . log . uncolor ( msg ) ; if ( ignoreWatch && msg . match ( / "watch" task / ) ) { return ; } if ( msg . match ( / ".+:.+" / ) ) { return ; } if ( ! ignoreWatch && msg . match ( / "watch" task / ) ) { msg += ' for ' + path . basename ( process . cwd ( ) ) ; ignoreWatch = true ; } messages . push ( msg ) ; } ) ; grunt . util . hooker . hook ( grunt . log , 'ok' , function ( msg ) { if ( typeof msg === 'string' ) { messages . push ( grunt . log . uncolor ( msg ) ) ; } } ) ; grunt . util . hooker . hook ( grunt , 'warn' , function ( error ) { var warning = [ ] ; if ( typeof error !== 'undefined' ) { warning . push ( messages [ 0 ] ) ; warning . push ( messages [ messages . length - 1 ] ) ; warning . push ( String ( error . message || error ) ) ; messages = warning ; flushMessages ( 'error' ) ; } } ) ; grunt . util . hooker . hook ( grunt . log , 'error' , function ( msg ) { if ( typeof msg === 'string' ) { messages . push ( grunt . log . uncolor ( msg ) ) ; flushMessages ( 'error' ) ; } } ) ; } 
function lobsangFormatterMatrix ( message ) { if ( typeof message !== 'string' ) { return Promise . reject ( new Error ( 'Message is not a string' ) ) } const formattedMessage = { body : message , msgtype : CONSTANTS . MATRIX_NOTICE_TYPE } return Promise . resolve ( formattedMessage ) } 
function Router ( options ) { const logPrefix = topLogPrefix + 'Router() - ' ; const that = this ; let defaultRouteFound = false ; that . options = options || { } ; if ( ! that . options . paths ) { that . options . paths = { 'controller' : { 'path' : 'controllers' , 'exts' : 'js' } , 'static' : { 'path' : 'public' , 'exts' : false } , 'template' : { 'path' : 'public/templates' , 'exts' : [ 'tmpl' , 'tmp' , 'ejs' , 'pug' ] } } ; } if ( ! that . options . routes ) that . options . routes = [ ] ; if ( ! that . options . basePath ) that . options . basePath = process . cwd ( ) ; if ( ! that . options . log ) { const lUtils = new LUtils ( ) ; that . options . log = new lUtils . Log ( ) ; } for ( const key of Object . keys ( that . options . paths ) ) { if ( ! Array . isArray ( that . options . paths [ key ] . exts ) && that . options . paths [ key ] . exts !== false ) { that . options . paths [ key ] . exts = [ that . options . paths [ key ] . exts ] ; } } if ( ! that . options . lfs ) { that . options . lfs = new Lfs ( { 'basePath' : that . options . basePath , 'log' : that . options . log } ) ; } for ( let i = 0 ; that . options . routes [ i ] !== undefined ; i ++ ) { if ( that . options . routes [ i ] . regex === '^/$' ) { defaultRouteFound = true ; break ; } } 
function copyProps ( src , target ) { const props = Object . getOwnPropertyNames ( src ) . filter ( prop => typeof target [ prop ] === 'undefined' ) . reduce ( ( result , prop ) => R . merge ( result , { [ prop ] : Object . getOwnPropertyDescriptor ( src , prop ) } ) , { } ) ; Object . defineProperties ( target , props ) ; } 
function lobsangProcessorPort ( link ) { let parts try { parts = parseUrl ( link ) } catch ( error ) { return Promise . reject ( error ) } if ( parts . port === '' ) { return getDefaultPortByProtocol ( parts . protocol ) } 
function getDefaultPortByProtocol ( rawProtocol ) { 
function clearScripts ( node ) { var rslt = { } ; for ( var key in node ) { var val = node [ key ] ; if ( _ . isString ( val ) ) { if ( val . trim ( ) ) rslt [ key ] = "..." ; } else { var childScripts = clearScripts ( val ) ; if ( ! _ . isEmpty ( childScripts ) ) rslt [ key ] = childScripts ; } } return rslt ; } 
function ( obj , array ) { if ( ! Array . prototype . indexOf ) { for ( var i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] === obj ) { return i ; } } return - 1 ; } else { return array . indexOf ( obj ) ; } } 
function format ( message , topic ) { const now = new Date ( ) const license = constants . LOBSANG_DEFAULT_LICENSE const id = 'toBeAdapted' const issuer = 'toBeAdapted' return { content : message , topic , license , contentType : null , created : now . toISOString ( ) , derivedFrom : null , id , issuer } } 
function setupListeners ( chat , displayWorker ) { chat . on ( displayWorker . port . emit . bind ( displayWorker . port ) ) ; displayWorker . port . on ( 'login' , function ( ) { chat . login ( ) ; } ) ; displayWorker . port . on ( 'logout' , function ( ) { chat . logout ( ) ; } ) ; displayWorker . port . on ( 'send' , function ( data ) { chat . send ( data . to , data . msg ) ; } ) ; displayWorker . port . on ( 'test' , function ( data ) { console . log ( 'Test message: ' + data ) ; } ) ; } 
function factory ( fn , options ) { var settings = options || { } var key = settings . key var indices = settings . indices var gapless = settings . gapless if ( typeof settings === 'string' ) { key = settings } if ( indices == null ) { indices = true } return all function all ( values ) { var results = [ ] var parent = values var index = - 1 var length var result if ( key ) { if ( array ( values ) ) { parent = null } else { values = parent [ key ] } } length = values . length while ( ++ index < length ) { if ( indices ) { result = fn . call ( this , values [ index ] , index , parent ) } else { result = fn . call ( this , values [ index ] , parent ) } if ( ! gapless || result != null ) { results . push ( result ) } } return results } } 
function getElementValues ( nodeList , initialScope ) { const valueList = [ ] for ( let i = 0 ; i < nodeList . length ; ++ i ) { const elementNode = nodeList [ i ] if ( elementNode == null ) { valueList . length = i + 1 } else if ( elementNode . type === "SpreadElement" ) { const argument = getStaticValueR ( elementNode . argument , initialScope ) if ( argument == null ) { return null } valueList . push ( ... argument . value ) } else { const element = getStaticValueR ( elementNode , initialScope ) if ( element == null ) { return null } valueList . push ( element . value ) } } return valueList } 
function getStaticValueR ( node , initialScope ) { if ( node != null && Object . hasOwnProperty . call ( operations , node . type ) ) { return operations [ node . type ] ( node , initialScope ) } return null } 
function isModifiedGlobal ( variable ) { return ( variable == null || variable . defs . length !== 0 || variable . references . some ( r => r . isWrite ( ) ) ) } 
function config ( ext ) { return { input : "src/index.js" , output : { file : ` ${ ext } ` , format : ext === ".mjs" ? "es" : "cjs" , sourcemap : true , sourcemapFile : ` ${ ext } ` , strict : true , banner : ` ` , } , plugins : [ sourcemaps ( ) ] , external : Object . keys ( require ( "./package.json" ) . dependencies ) , } } 
function isEscaped ( str , index ) { let escaped = false for ( let i = index - 1 ; i >= 0 && str . charCodeAt ( i ) === 0x5c ; -- i ) { escaped = ! escaped } return escaped } 
function replaceS ( matcher , str , replacement ) { const chunks = [ ] let index = 0 let match = null function replacer ( key ) { switch ( key ) { case "$$" : return "$" case "$&" : return match [ 0 ] case "$`" : return str . slice ( 0 , match . index ) case "$'" : return str . slice ( match . index + match [ 0 ] . length ) default : { const i = key . slice ( 1 ) if ( i in match ) { return match [ i ] } return key } } } for ( match of matcher . execAll ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( replacement . replace ( placeholder , replacer ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( "" ) } 
function replaceF ( matcher , str , replace ) { const chunks = [ ] let index = 0 for ( const match of matcher . execAll ( str ) ) { chunks . push ( str . slice ( index , match . index ) ) chunks . push ( String ( replace ( ... match , match . index , match . input ) ) ) index = match . index + match [ 0 ] . length } chunks . push ( str . slice ( index ) ) return chunks . join ( "" ) } 
function getParentSyntaxParen ( node , sourceCode ) { const parent = node . parent switch ( parent . type ) { case "CallExpression" : case "NewExpression" : if ( parent . arguments . length === 1 && parent . arguments [ 0 ] === node ) { return sourceCode . getTokenAfter ( parent . callee , isOpeningParenToken ) } return null case "DoWhileStatement" : if ( parent . test === node ) { return sourceCode . getTokenAfter ( parent . body , isOpeningParenToken ) } return null case "IfStatement" : case "WhileStatement" : if ( parent . test === node ) { return sourceCode . getFirstToken ( parent , 1 ) } return null case "SwitchStatement" : if ( parent . discriminant === node ) { return sourceCode . getFirstToken ( parent , 1 ) } return null case "WithStatement" : if ( parent . object === node ) { return sourceCode . getFirstToken ( parent , 1 ) } return null default : return null } } 
function psOpen ( ) { _event ( 'dev' , 'pubsub - connected successfully' ) ; let frame = { type : 'LISTEN' , nonce : 'listenToTopics' , data : { topics : [ 'channel-bits-events-v1.' + state . channel_id , 
function send ( msg ) { switch ( ps . readyState ) { case 0 : 
function parseMessage ( data ) { switch ( data . topic ) { 
function JWT ( secret , options ) { this . token = '' ; this . payload = { } ; this . secret = secret ; this . options = options ; this . valid = false ; this . expired = false ; this . stale = true ; } 
function ( payload ) { payload . stales = Date . now ( ) + this . options . stales ; this . payload = payload ; this . token = utils . sign ( this . payload , this . secret , this . options . signOptions ) ; this . valid = true ; this . expired = false ; this . stale = false ; return this ; } 
function ( res ) { if ( this . options . cookies ) { res . cookie ( this . options . cookie , this . token , this . options . cookieOptions ) ; } return this ; } 
function ( ) { return { token : this . token , payload : this . payload , valid : this . valid , expired : this . expired , stale : this . stale } ; } 
function ( token ) { this . token = token || '' ; try { this . payload = utils . verify ( this . token , this . secret , this . options . verifyOptions ) ; this . valid = true ; } catch ( err ) { this . payload = utils . decode ( this . token ) || { } ; if ( err . name == 'TokenExpiredError' ) { this . expired = true ; } } if ( this . valid && ! this . options . verify ( this ) ) { this . valid = false ; } if ( this . payload . stales && Date . now ( ) <= this . payload . stales ) { this . stale = false ; } return this ; } 
function ( secret , payload ) { if ( ! secret ) { throw new ReferenceError ( 'secret must be defined' ) ; } if ( typeof secret == 'string' ) { var _secret = secret ; secret = function ( payload ) { return _secret } ; } var jwt = new JWT ( secret ( payload ) , this . options ) ; return jwt . sign ( payload ) ; } 
function ( secret , options ) { if ( ! secret ) { throw new ReferenceError ( 'secret must be defined' ) ; } if ( typeof secret == 'string' ) { var _secret = secret ; secret = function ( req ) { return _secret } ; } options = options || { } ; var defaults = { cookie : 'jwt-express' , cookieOptions : { httpOnly : true } , cookies : true , refresh : true , reqProperty : 'jwt' , revoke : function ( jwt ) { } , signOptions : { } , stales : 900000 , verify : function ( jwt ) { return true } , verifyOptions : { } } ; for ( var key in defaults ) { this . options [ key ] = options [ key ] !== undefined ? options [ key ] : defaults [ key ] ; } return function ( req , res , next ) { var token ; if ( this . options . cookies ) { token = req . cookies [ this . options . cookie ] ; } else if ( req . headers . authorization ) { * jwt - Creates and signs a new JWT. If cookies are in use, it stores * the JWT in the cookie as well. * @param object payload The payload of the JWT * @return JWT */ res . jwt = function ( payload ) { var jwt = new JWT ( secret ( req ) , this . options ) ; return jwt . sign ( payload ) . store ( res ) ; } . bind ( this ) ; this . clear = function ( ) { if ( this . options . cookies ) { res . clearCookie ( this . options . cookie ) ; } } . bind ( this ) ; next ( ) ; } . bind ( this ) ; } 
function ( key , operator , value ) { if ( ! key ) { throw new ReferenceError ( 'key must be defined' ) ; } if ( operator && [ '==' , '===' , '!=' , '!==' , '<' , '<=' , '>' , '>=' ] . indexOf ( operator ) === - 1 ) { throw new JWTExpressError ( 'Invalid operator: ' + operator ) ; } return function ( req , res , next ) { var jwt = req [ this . options . reqProperty ] || { payload : { } } , data = jwt . payload [ key ] , ok ; if ( ! operator ) { ok = ! ! data ; } else if ( operator == '==' ) { ok = data == value ; } else if ( operator == '===' ) { ok = data === value ; } else if ( operator == '!=' ) { ok = data != value ; } else if ( operator == '!==' ) { ok = data !== value ; } else if ( operator == '<' ) { ok = data < value ; } else if ( operator == '<=' ) { ok = data <= value ; } else if ( operator == '>' ) { ok = data > value ; } else if ( operator == '>=' ) { ok = data >= value ; } if ( ! ok ) { var err = new JWTExpressError ( 'JWT is insufficient' ) ; err . key = key ; err . data = data ; err . operator = operator ; err . value = value ; next ( err ) ; } else { next ( ) ; } } . bind ( this ) ; } 
function ( ) { return function ( req , res , next ) { var jwt = req [ this . options . reqProperty ] || { } ; if ( ! jwt . valid ) { next ( new JWTExpressError ( 'JWT is invalid' ) ) ; } else { next ( ) ; } } . bind ( this ) ; } 
function setupComponent ( fixture , options ) { 
function describeComponentFactory ( componentPath , specDefinitions , isMixin ) { return function ( ) { beforeEach ( function ( done ) { 
function describeModuleFactory ( modulePath , specDefinitions ) { return function ( ) { beforeEach ( function ( done ) { this . module = null ; var requireCallback = function ( module ) { this . module = module ; done ( ) ; } . bind ( this ) ; require ( [ modulePath ] , requireCallback ) ; } ) ; specDefinitions . apply ( this ) ; } ; } 
function each ( fn ) { assert . equal ( typeof fn , 'function' ) return function ( arr ) { arr = Array . isArray ( arr ) ? arr : [ arr ] return arr . reduce ( function ( prev , curr , i ) { return prev . then ( function ( ) { return fn ( curr , i , arr . length ) } ) } , Promise . resolve ( ) ) . then ( function ( ) { return arr } ) } } 
function consul ( options , resilient ) { defineResilientOptions ( params , options ) return { 
function inHandler ( err , res , next ) { if ( err ) return next ( ) 
function outHandler ( options , next ) { options . params = options . params || { } if ( params . datacenter ) { options . params . dc = params . datacenter } if ( params . onlyHealthy ) { options . params . passing = true } if ( params . tag ) { options . params . tag = params . tag } next ( ) } 
function parsePrice ( input ) { var str = String ( input ) var decimalPart = '00' var decimalSymbol = getDecimalSymbol ( str ) if ( decimalSymbol ) { decimalPart = str . split ( decimalSymbol ) [ 1 ] } var integerPart = str . split ( decimalSymbol ) [ 0 ] return Number ( filterNumbers ( integerPart ) + '.' + filterNumbers ( decimalPart ) ) } 
function handler ( x , y , self , items , scroller ) { var transitionPixels = 100 ; var ratio = 6 ; var headerPos = Math . max ( transitionPixels - y , 0 ) / ratio ; if ( y < 0 ) { headerPos = transitionPixels / ratio ; } switch ( self . props . name ) { case "content" : return { zIndex : 3 , y : - y + items . background . rect . height , } ; case "white" : return { 
function consumptionBars ( x , y , self , items , scroller ) { 
function Pipe2Pam ( ) { if ( ! ( this instanceof Pipe2Pam ) ) { return new Pipe2Pam ( ) ; } 
function cleanupStyles ( item ) { var prop ; var reactProps ; if ( item . props . style ) { reactProps = { } ; for ( prop in item . props . style ) { reactProps [ prop ] = item . _node . style [ prop ] ; } } item . _node . removeAttribute ( 'style' ) ; if ( reactProps ) { for ( prop in reactProps ) { item . _node . style [ prop ] = reactProps [ prop ] ; } } if ( item . _prevStyles ) { for ( prop in item . _prevStyles ) { item . _node . style [ prop ] = item . _prevStyles [ prop ] ; } } } 
function getImageSearchResults ( searchTerm , callback , start , num ) { start = start < 0 || start > 90 || typeof ( start ) === 'undefined' ? 0 : start ; num = num < 1 || num > 10 || typeof ( num ) === 'undefined' ? 10 : num ; if ( ! searchTerm ) { console . error ( 'No search term' ) ; } var parameters = '&q=' + encodeURIComponent ( searchTerm ) ; parameters += '&searchType=image' ; parameters += start ? '&start=' + start : '' ; parameters += '&num=' + num ; var options = { host : 'www.googleapis.com' , path : '/customsearch/v1?key=' + process . env . CSE_API_KEY + '&cx=' + process . env . CSE_ID + parameters } ; var result = '' ; https . get ( options , function ( response ) { response . setEncoding ( 'utf8' ) ; response . on ( 'data' , function ( data ) { result += data ; } ) ; response . on ( 'end' , function ( ) { var data = JSON . parse ( result ) ; var resultsArray = [ ] ; 
function ( categoryId , event ) { event . preventDefault ( ) ; this . refs . scroller . prepareAnimationSync ( ) ; this . setState ( { mode : 'single' , selected : categoryId , previousScrollPosition : this . refs . scroller . scrollTop , } , function ( ) { this . refs . scroller . animateAndResetScroll ( 0 , 0 ) ; } ) ; } 
function ( event ) { event . preventDefault ( ) ; this . setState ( { mode : 'all' , selected : null , } , function ( ) { this . refs . scroller . animateAndResetScroll ( 0 , this . state . previousScrollPosition ) ; } ) ; } 
function handlePositionWhenShowingAllCategories ( x , y , self , items , scroller ) { var order = Data . categoryIds . indexOf ( self . props . categoryId ) ; var multiplier = Math . max ( 1 , 1 - ( y / friction ) ) ; 
function Service ( displayName , UUID , subtype ) { if ( ! UUID ) throw new Error ( "Services must be created with a valid UUID." ) ; this . displayName = displayName ; this . UUID = UUID ; this . subtype = subtype ; this . iid = null ; 
function Characteristic ( displayName , UUID , props ) { this . displayName = displayName ; this . UUID = UUID ; this . iid = null ; 
function Bridge ( displayName , serialNumber ) { Accessory . call ( this , displayName , serialNumber ) ; this . _isBridge = true ; 
function migrateDatabase ( nativeDatabase , nativeTransaction , schemaDescriptors , currentVersion ) { let descriptorsToProcess = schemaDescriptors . filter ( ( descriptor ) => { return descriptor . version > currentVersion } ) if ( ! descriptorsToProcess . length ) { return PromiseSync . resolve ( undefined ) } return migrateDatabaseVersion ( nativeDatabase , nativeTransaction , descriptorsToProcess [ 0 ] ) . then ( ( ) => { return migrateDatabase ( nativeDatabase , nativeTransaction , descriptorsToProcess , descriptorsToProcess [ 0 ] . version ) } ) } 
function migrateDatabaseVersion ( nativeDatabase , nativeTransaction , descriptor ) { let fetchPromise if ( descriptor . fetchBefore && descriptor . fetchBefore . length ) { let fetcher = new RecordFetcher ( ) let objectStores = normalizeFetchBeforeObjectStores ( descriptor . fetchBefore ) fetchPromise = fetcher . fetchRecords ( nativeTransaction , objectStores ) } else { fetchPromise = PromiseSync . resolve ( { } ) } return fetchPromise . then ( ( recordsMap ) => { let versionMigrator = new DatabaseVersionMigrator ( nativeDatabase , nativeTransaction , descriptor . objectStores ) return versionMigrator . executeMigration ( descriptor . after || ( ( ) => { } ) , recordsMap ) } ) } 
function normalizeFetchBeforeObjectStores ( objectStores ) { return objectStores . map ( ( objectStore ) => { if ( typeof objectStore === "string" ) { return { objectStore , preprocessor : record => record } } else if ( ! objectStore . preprocessor ) { return { objectStore : objectStore . objectStore , preprocessor : record => record } } else { return objectStore } } ) } 
function checkSchemaDescriptorTypes ( schemaDescriptors ) { let onlyPlainObjects = schemaDescriptors . every ( ( descriptor ) => { return descriptor . constructor === Object } ) if ( onlyPlainObjects ) { return } if ( ! ( schemaDescriptors [ 0 ] instanceof DatabaseSchema ) ) { throw new TypeError ( "The schema descriptor of the lowest described " + ` ${ schemaDescriptors [ 0 ] . version } ` + "DatabaseSchema instance, or all schema descriptors must be plain " + "objects" ) } schemaDescriptors . slice ( 1 ) . forEach ( ( descriptor ) => { if ( ! ( descriptor instanceof UpgradedDatabaseSchema ) ) { throw new TypeError ( "The schema descriptors of the upgraded database " + "versions must be UpgradedDatabaseSchema instances, but the " + ` ${ descriptor . version } ` + "UpgradedDatabaseSchema instance, or all schema descriptors must " + "be plain objects" ) } } ) } 
function list ( storage , keyRange , filter , direction , unique , pageSize , storageFactory ) { return new Promise ( ( resolve , reject ) => { let items = [ ] storage . createCursorFactory ( keyRange , direction ) ( ( cursor ) => { if ( ! filter || filter ( cursor . record , cursor . primaryKey , cursor . key ) ) { if ( items . length === pageSize ) { finalize ( true , cursor . key , cursor . primaryKey ) return } else { items . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) => finalize ( false , null , null ) ) . catch ( error => reject ( error ) ) function finalize ( hasNextPage , nextKey , nextPrimaryKey ) { resolve ( new RecordList ( items , storageFactory , nextKey , nextPrimaryKey , direction , unique , filter , pageSize , hasNextPage ) ) } } ) } 
function normalizeCompoundObjectKey ( keyPaths , key ) { let normalizedKey = [ ] keyPaths . forEach ( ( keyPath ) => { let keyValue = key keyPath . split ( "." ) . forEach ( ( fieldName ) => { if ( ! keyValue . hasOwnProperty ( fieldName ) ) { throw new Error ( ` ${ keyPath } ` + "provided compound key" ) } keyValue = keyValue [ fieldName ] } ) normalizedKey . push ( keyValue ) } ) return normalizedKey } 
function iterateCursor ( request , cursorConstructor , recordCallback ) { return new PromiseSync ( ( resolve , reject ) => { let traversedRecords = 0 let canIterate = true request . onerror = ( ) => reject ( request . error ) request . onsuccess = ( ) => { if ( ! canIterate ) { console . warn ( "Cursor iteration was requested asynchronously, " + "ignoring the new cursor position" ) return } if ( ! request . result ) { resolve ( traversedRecords ) return } traversedRecords ++ let iterationRequested = handleCursorIteration ( request , cursorConstructor , recordCallback , reject ) if ( ! iterationRequested ) { canIterate = false resolve ( traversedRecords ) } } } ) } 
function handleCursorIteration ( request , cursorConstructor , recordCallback , reject ) { let iterationRequested = false let cursor = new cursorConstructor ( request , ( ) => { iterationRequested = true } , ( subRequest ) => { return PromiseSync . resolve ( subRequest ) . catch ( ( error ) => { reject ( error ) throw error } ) } ) try { recordCallback ( cursor ) } catch ( error ) { iterationRequested = false reject ( error ) } return iterationRequested } 
function fetchAllRecords ( transaction , objectStores ) { return PromiseSync . all ( objectStores . map ( ( descriptor ) => { return fetchRecords ( transaction . getObjectStore ( descriptor . objectStore ) , descriptor . preprocessor ) } ) ) . then ( ( fetchedRecords ) => { let recordsMap = { } for ( let i = 0 ; i < objectStores . length ; i ++ ) { recordsMap [ objectStores [ i ] . objectStore ] = fetchedRecords [ i ] } return recordsMap } ) } 
function fetchRecords ( objectStore , preprocessor ) { return new PromiseSync ( ( resolve , reject ) => { let records = [ ] objectStore . openCursor ( null , CursorDirection . NEXT , ( cursor ) => { let primaryKey = cursor . primaryKey if ( primaryKey instanceof Object ) { Object . freeze ( primaryKey ) } let preprocessedRecord = preprocessor ( cursor . record , primaryKey ) if ( preprocessedRecord === UpgradedDatabaseSchema . DELETE_RECORD ) { cursor . delete ( ) cursor . continue ( ) return } else if ( preprocessedRecord !== UpgradedDatabaseSchema . SKIP_RECORD ) { records . push ( { key : primaryKey , record : preprocessedRecord } ) } else { 
function writeFileP ( outputPath , data , cb ) { outputPath = abs ( outputPath ) ; let dirname = path . dirname ( outputPath ) ; mkdirp ( dirname , err => { if ( err ) { return cb ( err ) ; } let str = data ; if ( typpy ( data , Array ) || typpy ( data , Object ) ) { str = JSON . stringify ( data , null , 2 ) ; } fs . writeFile ( outputPath , str , err => cb ( err , data ) ) ; } ) ; } 
function runTransaction ( transaction , objectStoreNames , transactionOperations ) { let callbackArguments = objectStoreNames . map ( ( objectStoreName ) => { return transaction . getObjectStore ( objectStoreName ) } ) callbackArguments . push ( ( ) => transaction . abort ( ) ) let resultPromise = transactionOperations ( ... callbackArguments ) return Promise . resolve ( resultPromise ) . then ( ( result ) => { return transaction . completionPromise . then ( ( ) => result ) } ) } 
function toNativeCursorDirection ( direction , unique ) { if ( typeof direction === "string" ) { if ( CURSOR_DIRECTIONS . indexOf ( direction . toUpperCase ( ) ) === - 1 ) { throw new Error ( "When using a string as cursor direction, use NEXT " + ` ${ direction } ` ) ; } } else { direction = direction . value } let cursorDirection = direction . toLowerCase ( ) . substring ( 0 , 4 ) if ( unique ) { cursorDirection += "unique" } return cursorDirection } 
function shouldDeleteIndex ( objectStore , schema , indexName ) { let schemaIndexes = schema . indexes || [ ] let newIndexNames = schemaIndexes . map ( indexSchema => indexSchema . name ) if ( newIndexNames . indexOf ( indexName ) === - 1 ) { return true } let index = objectStore . index ( indexName ) let indexKeyPath = index . keyPath ; if ( indexKeyPath && ( typeof indexKeyPath !== "string" ) ) { indexKeyPath = Array . from ( indexKeyPath ) } let serializedIndexKeyPath = JSON . stringify ( indexKeyPath ) let indexSchema = schemaIndexes . filter ( ( indexSchema ) => { return indexSchema . name === index . name } ) [ 0 ] return ( index . unique !== indexSchema . unique ) || ( index . multiEntry !== indexSchema . multiEntry ) || ( serializedIndexKeyPath !== JSON . stringify ( indexSchema . keyPaths ) ) } 
function createIndex ( objectStore , indexSchema ) { let indexNames = Array . from ( objectStore . indexNames ) if ( indexNames . indexOf ( indexSchema . name ) !== - 1 ) { return } objectStore . createIndex ( indexSchema . name , indexSchema . keyPath , { unique : indexSchema . unique , multiEntry : indexSchema . multiEntry } ) } 
function fetchNextPage ( storageFactory , keyRange , cursorDirection , unique , firstPrimaryKey , filter , pageSize ) { let storage = storageFactory ( ) let nextItems = [ ] return new Promise ( ( resolve , reject ) => { let idb = idbProvider ( ) let cursorFactory = storage . createCursorFactory ( keyRange , cursorDirection , unique ) cursorFactory ( ( cursor ) => { if ( ! unique ) { let shouldSkip = ( ( cursorDirection === CursorDirection . NEXT ) && ( idb . cmp ( firstPrimaryKey , cursor . primaryKey ) > 0 ) ) || ( ( cursorDirection === CursorDirection . PREVIOUS ) && ( idb . cmp ( firstPrimaryKey , cursor . primaryKey ) < 0 ) ) if ( shouldSkip ) { cursor . continue ( ) return } } if ( ! filter || filter ( cursor . record , cursor . primaryKey , cursor . key ) ) { if ( nextItems . length === pageSize ) { finalize ( true , cursor . key , cursor . primaryKey ) return } else { nextItems . push ( cursor . record ) } } cursor . continue ( ) } ) . then ( ( ) => finalize ( false , null , null ) ) . catch ( error => reject ( error ) ) function finalize ( hasNextPage , nextKey , nextPrimaryKey ) { resolve ( new RecordList ( nextItems , storageFactory , nextKey , nextPrimaryKey , cursorDirection , unique , filter , pageSize , hasNextPage ) ) } } ) } 
function executeEventListeners ( listeners , ... parameters ) { listeners . forEach ( ( listener ) => { try { listener . apply ( null , parameters ) } catch ( error ) { console . error ( "An event listener threw an error" , error ) } } ) } 
function resolve ( instance , newState , value ) { if ( instance [ FIELDS . state ] !== STATE . PENDING ) { return } instance [ FIELDS . state ] = newState instance [ FIELDS . value ] = value let listeners if ( newState === STATE . RESOLVED ) { listeners = instance [ FIELDS . fulfillListeners ] } else { listeners = instance [ FIELDS . errorListeners ] } for ( let listener of listeners ) { listener ( ) } } 
function runQuery ( cursorFactory , filter , comparator , offset , limit , callback ) { let records = [ ] let recordIndex = - 1 return cursorFactory ( ( cursor ) => { if ( ! filter && offset && ( ( recordIndex + 1 ) < offset ) ) { recordIndex = offset - 1 cursor . advance ( offset ) return } let primaryKey = cursor . primaryKey if ( filter && ! filter ( cursor . record , primaryKey ) ) { cursor . continue ( ) return } if ( comparator ) { insertSorted ( records , cursor . record , primaryKey , comparator ) if ( offset || limit ) { if ( records . length > ( offset + limit ) ) { records . pop ( ) } } cursor . continue ( ) return } recordIndex ++ if ( recordIndex < offset ) { cursor . continue ( ) return } callback ( cursor . record , primaryKey ) if ( ! limit || ( ( recordIndex + 1 ) < ( offset + limit ) ) ) { cursor . continue ( ) } } ) . then ( ( ) => { if ( ! comparator ) { return } records = records . slice ( offset ) for ( let { record , primaryKey } of records ) { callback ( record , primaryKey ) } } ) } 
function insertSorted ( records , record , primaryKey , comparator ) { let index = findInsertIndex ( records , record , comparator ) records . splice ( index , 0 , { record , primaryKey } ) } 
function findInsertIndex ( records , record , comparator ) { if ( ! records . length ) { return 0 } if ( records . length === 1 ) { let comparison = comparator ( records [ 0 ] . record , record ) return ( comparison > 0 ) ? 0 : 1 } let comparison = comparator ( records [ 0 ] . record , record ) if ( comparison > 0 ) { return 0 } let bottom = 1 let top = records . length - 1 while ( bottom <= top ) { let pivotIndex = Math . floor ( ( bottom + top ) / 2 ) let comparison = comparator ( records [ pivotIndex ] . record , record ) if ( comparison > 0 ) { let previousElement = records [ pivotIndex - 1 ] . record if ( comparator ( previousElement , record ) <= 0 ) { return pivotIndex } top = pivotIndex - 1 } else { bottom = pivotIndex + 1 } } return records . length } 
function prepareQuery ( thisStorage , filter , order ) { order = normalizeKeyPath ( order ) let expectedSortingDirection = order [ 0 ] . charAt ( 0 ) === "!" let canSortingBeOptimized canSortingBeOptimized = canOptimizeSorting ( expectedSortingDirection , order ) let storages = new Map ( ) storages . set ( normalizeKeyPath ( thisStorage . keyPath ) , { storage : thisStorage , score : 1 
function prepareSortingOptimization ( storages , simplifiedOrderFieldPaths ) { let idb = idbProvider ( ) for ( let [ keyPath , storageAndScore ] of storages ) { let keyPathSlice = keyPath . slice ( 0 , simplifiedOrderFieldPaths . length ) if ( idb . cmp ( keyPathSlice , simplifiedOrderFieldPaths ) === 0 ) { storageAndScore . score += 4 
function prepareFilteringOptimization ( storages , filter ) { if ( filter instanceof Function ) { for ( let [ keyPath , storageAndScore ] of storages ) { storageAndScore . filter = filter } return } for ( let [ keyPath , storageAndScore ] of storages ) { let normalizedFilter = normalizeFilter ( filter , keyPath ) if ( normalizedFilter instanceof Function ) { let isOptimizableFilter = ( filter instanceof Object ) && ! ( filter instanceof Date ) && ! ( filter instanceof Array ) && ! ( filter instanceof IDBKeyRange ) if ( isOptimizableFilter ) { let partialOptimization = partiallyOptimizeFilter ( filter , keyPath ) storageAndScore . keyRange = partialOptimization . keyRange storageAndScore . filter = partialOptimization . filter if ( partialOptimization . score ) { storageAndScore . score += 1 + partialOptimization . score } } else { storageAndScore . filter = normalizedFilter } } else { storageAndScore . keyRange = normalizedFilter storageAndScore . score += 2 } } } 
function chooseStorageForQuery ( storages , order , simplifiedOrderFieldPaths , canSortingBeOptimized , expectedSortingDirection ) { let sortedStorages = Array . from ( storages . values ( ) ) sortedStorages . sort ( ( storage1 , storage2 ) => { return storage2 . score - storage1 . score } ) let chosenStorageDetails = sortedStorages [ 0 ] let chosenStorage = chosenStorageDetails . storage let chosenStorageKeyPath = normalizeKeyPath ( chosenStorage . keyPath ) let storageKeyPathSlice = chosenStorageKeyPath . slice ( 0 , simplifiedOrderFieldPaths . length ) let optimizeSorting = canSortingBeOptimized && ( idbProvider ( ) . cmp ( storageKeyPathSlice , simplifiedOrderFieldPaths ) === 0 ) return { storage : chosenStorage , direction : optimizeSorting ? ( CursorDirection [ expectedSortingDirection ? "PREVIOUS" : "NEXT" ] ) : CursorDirection . NEXT , comparator : optimizeSorting ? null : compileOrderingFieldPaths ( order ) , keyRange : chosenStorageDetails . keyRange , filter : chosenStorageDetails . filter } } 
function canOptimizeSorting ( expectedSortingDirection , order ) { for ( let orderingFieldPath of order ) { if ( ( orderingFieldPath . charAt ( 0 ) === "!" ) !== expectedSortingDirection ) { return false } } return true } 
function prepareOrderingSpecificationForQuery ( order , keyPath ) { if ( order === null ) { order = CursorDirection . NEXT } let isCursorDirection = ( ( typeof order === "string" ) && ( CURSOR_DIRECTIONS . indexOf ( order . toUpperCase ( ) ) > - 1 ) ) || ( CURSOR_DIRECTIONS . indexOf ( order ) > - 1 ) if ( isCursorDirection && ( typeof order === "string" ) ) { order = CursorDirection [ order . toUpperCase ( ) ] || CursorDirection . PREVIOUS } if ( order instanceof CursorDirection ) { keyPath = normalizeKeyPath ( keyPath ) if ( order === CursorDirection . NEXT ) { return keyPath } else { return keyPath . map ( fieldPath => ` ${ fieldPath } ` ) } } return order } 
function openConnection ( databaseName , sortedSchemaDescriptors ) { let version = sortedSchemaDescriptors . slice ( ) . pop ( ) . version let request = NativeDBAccessor . indexedDB . open ( databaseName , version ) return new Promise ( ( resolve , reject ) => { let wasBlocked = false let upgradeTriggered = false let migrationPromiseResolver , migrationPromiseRejector let migrationPromise = new Promise ( ( resolve , reject ) => { migrationPromiseResolver = resolve migrationPromiseRejector = reject } ) 
function handleConnectionError ( event , error , wasBlocked , upgradeTriggered , reject , migrationPromiseRejector ) { if ( wasBlocked || upgradeTriggered ) { event . preventDefault ( ) return } reject ( request . error ) migrationPromiseRejector ( request . error ) } 
function upgradeDatabaseSchema ( databaseName , event , migrationPromise , database , transaction , sortedSchemaDescriptors , migrationPromiseResolver , migrationPromiseRejector ) { executeMigrationListeners ( databaseName , event . oldVersion , event . newVersion , migrationPromise ) let migrator = new DatabaseMigrator ( database , transaction , sortedSchemaDescriptors , event . oldVersion ) return PromiseSync . resolve ( ) . then ( ( ) => { return migrator . executeMigration ( ) } ) . then ( ( ) => { migrationPromiseResolver ( ) } ) . catch ( ( error ) => { migrationPromiseRejector ( error ) throw error } ) } 
function executeMigrationListeners ( databaseName , oldVersion , newVersion , completionPromise ) { for ( let listener of migrationListeners ) { try { listener ( databaseName , oldVersion , newVersion , completionPromise ) } catch ( e ) { console . warn ( "A schema migration event listener threw an error" , e ) ; } } } 
function partiallyOptimizeKeyPathMatchingFilter ( filter , keyPath ) { let keyRange = convertFieldMapToKeyRange ( filter , keyPath ) if ( ! keyRange ) { 
function splitFilteringObject ( filter , filterFieldPaths , storageKeyPath ) { let fieldsToOptimize = { } let fieldsToCompile = { } filterFieldPaths . forEach ( ( fieldPath ) => { let value = getFieldValue ( filter , fieldPath ) if ( storageKeyPath . indexOf ( fieldPath ) > - 1 ) { setFieldValue ( fieldsToOptimize , fieldPath , value ) } else { setFieldValue ( fieldsToCompile , fieldPath , value ) } } ) return { fieldsToOptimize , fieldsToCompile } } 
function compileFieldGetter ( fieldPath ) { let fields = fieldPath . split ( "." ) return ( record ) => { let value = record for ( let field of fields ) { if ( ! ( value instanceof Object ) || ! value . hasOwnProperty ( field ) ) { return undefined } value = value [ field ] } return value } } 
function convertFieldMapToKeyRange ( filter , keyPaths ) { let isOtherFormOfFilter = ! ( filter instanceof Object ) || ( filter instanceof Function ) || ( filter instanceof Array ) || ( filter instanceof Date ) || ( filter instanceof IDBKeyRange ) if ( isOtherFormOfFilter ) { return null } if ( ! ( keyPaths instanceof Array ) ) { keyPaths = [ keyPaths ] } let fieldPaths = getFieldPaths ( filter ) if ( ! fieldPaths ) { return null } let isKeyFilter = ( fieldPaths . length === keyPaths . length ) && fieldPaths . every ( path => keyPaths . indexOf ( path ) > - 1 ) if ( ! isKeyFilter ) { return null } if ( keyPaths . length === 1 ) { return IDBKeyRange . only ( getFieldValue ( filter , keyPaths [ 0 ] ) ) } return new IDBKeyRange . only ( keyPaths . map ( ( keyPath ) => { getFieldValue ( filter , keyPath ) } ) ) } 
function getFieldPaths ( object , stopOnKeyRange = true ) { let fieldPaths = [ ] fieldPaths . containsKeyRange = false generateFieldPaths ( object , [ ] ) return fieldPaths function generateFieldPaths ( object , parts ) { Object . keys ( object ) . some ( ( fieldName ) => { let value = object [ fieldName ] if ( stopOnKeyRange && ( value instanceof IDBKeyRange ) ) { fieldPaths = null return true } let isTerminalValue = ! ( value instanceof Object ) || ( value instanceof Date ) || ( value instanceof Array ) || ( value instanceof IDBKeyRange ) let fieldPath = parts . slice ( ) fieldPath . push ( fieldName ) if ( isTerminalValue ) { fieldPaths . push ( fieldPath . join ( "." ) ) } else { generateFieldPaths ( value , fieldPath ) } } ) } } 
function setFieldValue ( object , fieldPath , value ) { let parts = fieldPath . split ( "." ) let done = [ ] let currentObject = object while ( parts . length ) { let field = parts . shift ( ) if ( ! parts . length ) { if ( currentObject . hasOwnProperty ( field ) ) { throw new Error ( ` ${ fieldPath } ` ) } currentObject [ field ] = value break } if ( ! currentObject . hasOwnProperty ( field ) ) { currentObject [ field ] = { } } if ( ! ( currentObject [ field ] instanceof Object ) ) { throw new Error ( ` ${ fieldPath } ` + ` ${ done . join ( "." ) } ` ) } currentObject = currentObject [ field ] done . push ( field ) } } 
function getFieldValue ( object , fieldPath ) { if ( ! fieldPath ) { return object } let currentObject = object fieldPath . split ( "." ) . forEach ( ( fieldName ) => { if ( ! currentObject . hasOwnProperty ( fieldName ) ) { throw new Error ( ` ${ fieldPath } ` + "provided object" ) } currentObject = currentObject [ fieldName ] } ) return currentObject } 
function upgradeSchema ( nativeDatabase , nativeTransaction , descriptors ) { let objectStoreNames = Array . from ( nativeDatabase . objectStoreNames ) let newObjectStoreNames = descriptors . map ( ( objectStore ) => { return objectStore . name } ) objectStoreNames . forEach ( ( objectStoreName ) => { if ( newObjectStoreNames . indexOf ( objectStoreName ) === - 1 ) { nativeDatabase . deleteObjectStore ( objectStoreName ) } } ) descriptors . forEach ( ( objectStoreDescriptor ) => { let objectStoreName = objectStoreDescriptor . name let nativeObjectStore = objectStoreNames . indexOf ( objectStoreName ) > - 1 ? nativeTransaction . objectStore ( objectStoreName ) : null let objectStoreMigrator = new ObjectStoreMigrator ( nativeDatabase , nativeObjectStore , objectStoreDescriptor ) objectStoreMigrator . executeMigration ( ) } ) } 
function MousePosition ( ) { return signal ( function ( next ) { document . addEventListener ( "mousemove" , function ( event ) { next ( getXY ( event ) ) } ) } , new Point ( 0 , 0 ) ) } 
function rect ( width , height , pos ) { return new Shape ( [ { x : 0 - width / 2 , y : 0 - height / 2 } , { x : 0 - width / 2 , y : height / 2 } , { x : width / 2 , y : height / 2 } , { x : width / 2 , y : 0 - height / 2 } ] , pos ) } 
function container ( width , height , position , elem ) { return new Element ( new ContainerElement ( position , elem ) , width , height ) } 
function mainSection ( state ) { var todos = state . todos var route = state . route return h ( "section.main" , { hidden : todos . length === 0 } , [ toggleAllPool . change ( h ( "input#toggle-all.toggle-all" , { type : "checkbox" , checked : todos . every ( function ( todo ) { return todo . completed } ) } ) ) , h ( "label" , { htmlFor : "toggle-all" } , "Mark all as complete" ) , h ( "ul.todo-list" , todos . filter ( function ( todo ) { return route === "completed" && todo . completed || route === "active" && ! todo . completed || route === "all" } ) . map ( todoItem ) ) ] ) } 
function Client ( ) { EventEmitter . call ( this ) ; this . debug = true ; 
function signal ( generator , defaultValue ) { var value = defaultValue var listeners = [ ] setTimeout ( function ( ) { generator ( set ) } , 0 ) return observable function observable ( listener ) { if ( isGet ( listener ) ) { return value } else if ( isSet ( listener ) ) { throw new Error ( "read-only" ) } else { listeners . push ( listener ) } } function set ( v ) { value = v for ( var i = 0 ; i < listeners . length ; i ++ ) { var listener = listeners [ i ] listener ( value ) } } } 
function getOutDom ( hmail ) { 
function Light ( constr ) { this . client = constr . client ; this . ipAddress = constr . ipAddress ; this . serialNumber = constr . serialNumber ; this . productId = constr . productId ; 
function KeyboardArrows ( ) { var validKeys = [ 37 , 38 , 39 , 40 ] return signal ( function ( next ) { var down = { } document . addEventListener ( "keyup" , function onup ( ev ) { if ( ev . which in KEYS ) { var key = KEYS [ ev . which ] down [ key ] = false next ( getState ( ) ) } } ) document . addEventListener ( "keydown" , function ondown ( ev ) { if ( ev . which in KEYS ) { var key = KEYS [ ev . which ] down [ key ] = true next ( getState ( ) ) } } ) function getState ( ) { var x = 0 , y = 0 if ( down . up ) { y = 1 } else if ( down . down ) { y = - 1 } if ( down . left ) { x = - 1 } else if ( down . right ) { x = 1 } return { x : x , y : y } } } , { x : 0 , y : 0 } ) } 
function fps ( desiredFps ) { var msPerFrame = 1000 / desiredFps return signal ( function ( next ) { var prev = Date . now ( ) setTimeout ( tick , msPerFrame ) function tick ( ) { var curr = Date . now ( ) var diff = curr - prev prev = curr next ( diff ) setTimeout ( tick , msPerFrame ) } } , 0 ) } 
function EventPool ( name ) { var storage = TransformStorage ( name ) var events = { } var _next var nextTick = function ( value , elem ) { process . nextTick ( function ( ) { _next ( value , elem ) } ) } return { signal : signal ( function ( next ) { handleSubmit ( next ) handleChange ( next ) Object . keys ( events ) . forEach ( function ( event ) { handleEvent ( event , next ) } ) _next = next } ) , submit : function ( elem , transform ) { return storage . set ( "submit" , elem , transform ) } , change : function ( elem , transform ) { return storage . set ( "change" , elem , transform ) } , on : function ( elem , event , transform ) { if ( ! events [ event ] ) { events [ event ] = true if ( _next ) { handleEvent ( event , _next ) } } return storage . set ( event , elem , transform ) } } function handleSubmit ( next ) { document . addEventListener ( "keypress" , function ( ev ) { var target = ev . target var fn = storage . get ( "submit" , target ) var validEvent = fn && target . type === "text" && ev . keyCode === ENTER && ! ev . shiftKey if ( ! validEvent ) { return } var item = fn ( target . value , target ) nextTick ( item ) } ) document . addEventListener ( "click" , function ( ev ) { var target = ev . target var fn = storage . get ( "submit" , target ) if ( ! fn || target . tagName !== "BUTTON" ) { return } nextTick ( fn ( ) , target ) } ) } function handleChange ( next ) { document . addEventListener ( "keypress" , function ( ev ) { var target = ev . target var fn = storage . get ( "change" , target ) if ( ! fn || target . type !== "text" ) { return } nextTick ( fn ( target . value ) , target ) } ) document . addEventListener ( "change" , function ( ev ) { var target = ev . target var fn = storage . get ( "change" , target ) if ( ! fn || target . type !== "checkbox" ) { return } nextTick ( fn ( target . checked ) , target ) } ) } function handleEvent ( event , next ) { document . addEventListener ( event , function ( ev ) { var target = ev . target var fn = storage . get ( event , target ) if ( fn ) { nextTick ( fn ( target . value , target ) ) } } , true ) } } 
function plainText ( content ) { var textSize = getTextSize ( content ) return new Element ( new TextElement ( "left" , content ) , textSize . width , textSize . height ) } 
function WindowDimensions ( ) { return signal ( function ( next ) { window . addEventListener ( "resize" , function ( e ) { next ( { width : window . innerWidth , height : window . innerHeight } ) } ) } , { width : window . innerWidth , height : window . innerHeight } ) } 
function ( value ) { var valueType = typeof value ; var output = "" ; if ( value === null || value === undefined ) { output += this . decorateWithSpan ( 'null' , 'null' ) ; } else if ( value && value . constructor === Array ) { output += this . arrayToHTML ( value ) ; } else if ( valueType === 'object' ) { output += this . objectToHTML ( value ) ; } else if ( valueType === 'number' ) { output += this . decorateWithSpan ( value , 'num' ) ; } else if ( valueType === 'string' ) { if ( / ^(http|https):\/\/[^\s]+$ / . test ( value ) ) { output += '<a href="' + value + '">' + this . htmlEncode ( value ) + '</a>' ; } else { output += this . decorateWithSpan ( '"' + value + '"' , 'string' ) ; } } else if ( valueType === 'boolean' ) { output += this . decorateWithSpan ( value , 'bool' ) ; } return output ; } 
function ( json ) { var output = '[<ul class="array collapsible">' ; var hasContents = false ; for ( var prop in json ) { hasContents = true ; output += '<li>' ; output += this . valueToHTML ( json [ prop ] ) ; output += '</li>' ; } output += '</ul>]' ; if ( ! hasContents ) { output = "[ ]" ; } return output ; } 
function ( error , data , uri ) { 
function collapse ( evt ) { var collapser = evt . target ; var target = collapser . parentNode . getElementsByClassName ( 'collapsible' ) ; if ( ! target . length ) { return } target = target [ 0 ] ; if ( target . style . display === 'none' ) { var ellipsis = target . parentNode . getElementsByClassName ( 'ellipsis' ) [ 0 ] target . parentNode . removeChild ( ellipsis ) ; target . style . display = '' ; collapser . innerHTML = '-' ; } else { target . style . display = 'none' ; var ellipsis = document . createElement ( 'span' ) ; ellipsis . className = 'ellipsis' ; ellipsis . innerHTML = ' &hellip; ' ; target . parentNode . insertBefore ( ellipsis , target ) ; collapser . innerHTML = '+' ; } } 
function flow ( direction , elements ) { var widths = elements . map ( widthOf ) var heights = elements . map ( heightOf ) var width = direction === "left" ? sum ( widths ) : direction === "right" ? sum ( widths ) : maximum ( widths ) var height = direction === "down" ? sum ( heights ) : direction === "right" ? sum ( heights ) : maximum ( heights ) return new Element ( new FlowElement ( direction , elements ) , width , height ) } 
function collage ( width , height , forms ) { return new Element ( new CollageElement ( forms , width , height ) , width , height ) } 
function HtmlElement ( tagName , special , general , children ) { this . tagName = tagName this . specialProperties = special this . generalProperties = general this . children = children this . cl = null 
function createLexer ( g ) { function Token ( tag , text , index , subMatches , end , pos ) { this . tag = tag ; this . text = text ; this . index = index ; this . subMatches = subMatches ; this . end = end ; this . pos = pos ; } Token . prototype . toString = function ( ) { return this . text ; } ; function emptyFunc ( ) { } function tofn ( f ) { if ( typeof f == 'function' ) return f ; return function ( ) { return f ; } ; } function buildScanner ( a ) { var n = 1 ; var b = [ ] ; var matchIndexes = [ 1 ] ; var fa = [ ] ; for ( var i = 0 ; i < a . length ; ++ i ) { matchIndexes . push ( n += RegExp ( '|' + a [ i ] [ 0 ] . source ) . exec ( '' ) . length ) ; fa . push ( a [ i ] [ 1 ] ? tofn ( a [ i ] [ 1 ] ) : emptyFunc ) ; b . push ( '(' + a [ i ] [ 0 ] . source + ')' ) ; } var re = RegExp ( b . join ( '|' ) + '|' , 'g' ) ; return [ re , matchIndexes , fa ] ; } var endTag = g . $ || '$' ; var scanner = { } ; for ( var i in g ) { if ( i . charAt ( 0 ) != '$' ) scanner [ i ] = buildScanner ( g [ i ] ) ; } return Lexer ; function Lexer ( s ) { /// <param name="s" type="String"></param> var Length = s . length ; var i = 0 ; var stateStack = [ '' ] ; var obj = { text : '' , index : 0 , source : s , pushState : function ( s ) { stateStack . push ( s ) ; } , popState : function ( ) { stateStack . pop ( ) ; } , retract : function ( n ) { i -= n ; } } ; var currentPos = new Position ( 1 , 1 ) ; function scan ( ) { var st = stateStack [ stateStack . length - 1 ] ; var rule = scanner [ st ] ; var re = rule [ 0 ] ; re . lastIndex = i ; var t = re . exec ( s ) ; if ( t [ 0 ] == '' ) { if ( i < Length ) { throw Error ( 'lexer error: ' + currentPos + '\n' + s . slice ( i , i + 50 ) ) ; } return new Token ( endTag , '' , i , null , i , currentPos ) ; } obj . index = i ; i = re . lastIndex ; var idx = rule [ 1 ] ; for ( var j = 0 ; j < idx . length ; ++ j ) if ( t [ idx [ j ] ] ) { var tag = rule [ 2 ] [ j ] . apply ( obj , t . slice ( idx [ j ] , idx [ j + 1 ] ) ) ; //if (tag == null) return null; return new Token ( tag , t [ 0 ] , obj . index , t . slice ( idx [ j ] + 1 , idx [ j + 1 ] ) , i , currentPos ) ; } } var re_newLine = / \r\n?|\n / g ; var re_lastLine = / [^\r\n\u2028\u2029]*$ / ; return { scan : function ( ) { do { var t = scan ( ) ; var _row = currentPos . row ; var _col = currentPos . col ; var ms = t . text . match ( re_newLine ) ; var h = ms ? ms . length : 0 ; _row += h ; if ( h == 0 ) _col += t . text . length ; else _col = re_lastLine . exec ( t . text ) [ 0 ] . length + 1 ; currentPos = new Position ( _row , _col ) ; if ( t . tag != null ) { return t ; } } while ( true ) ; } , GetCurrentPosition : function ( ) { return currentPos ; } , getPos : function ( i ) { return getPos ( s , i ) ; } } ; } } 
function codegen_js_tran ( prog , encodeName , defaultEncode , ignoreWhitespace ) { /// <param name="prog" type="Array">AST</param> /// <param name="encodeName" type="String"></param> /// <param name="defaultEncode" type="Boolean"></param> /// <returns type="String" /> var i_tmake = 0 ; function TMake ( ) { return '_' + ( i_tmake ++ ) ; } function emit ( s ) { body . push ( s ) ; } function nodeWithPos ( node , pos ) { node . pos = pos ; return node ; } function stmtGen ( a ) { switch ( a [ 0 ] ) { case 'if' : emit ( 'if(' ) ; emit ( exprGen ( a [ 1 ] ) ) ; emit ( '){' ) ; stmtsGen ( a [ 2 ] ) ; emit ( '}' ) ; if ( a [ 3 ] ) { emit ( 'else{' ) ; stmtsGen ( a [ 3 ] ) ; emit ( '}' ) ; } break ; case 'each' : var keyName = a [ 3 ] ? encodeCommonName ( a [ 3 ] ) : TMake ( ) ; var tmpExpr = exprGen ( a [ 1 ] ) ; var tmpStr = joinCode ( tmpExpr ) ; if ( / ^\w+$ / . test ( tmpStr ) ) { var listName = tmpStr ; } else { listName = TMake ( ) ; emit ( 'var ' + listName + ' = ' ) ; emit ( tmpExpr ) ; emit ( ';' ) ; } if ( a [ 5 ] ) { emit ( 'for(var ' + keyName + '=0;' + keyName + '<' ) ; //listName + '.length' emit ( exprGen ( [ '.' , nodeWithPos ( [ 't' , listName ] , a [ 1 ] . pos ) , 'length' ] ) ) ; emit ( ';' + keyName + '++){' ) ; } else emit ( 'for(var ' + keyName + ' in ' + listName + ') {' ) ; emit ( 'var ' + a [ 4 ] + ' = ' ) ; //listName + '[' + keyName + ']' emit ( exprGen ( [ '[]' , nodeWithPos ( [ 't' , listName ] , a [ 1 ] . pos ) , [ 't' , keyName ] ] ) ) ; emit ( ';' ) ; stmtsGen ( a [ 2 ] ) ; emit ( '}' ) ; break ; case 'set' : if ( typeof a [ 1 ] == 'string' ) emit ( 'var ' + encodeCommonName ( a [ 1 ] ) + '=' ) ; else { emit ( exprGen ( a [ 1 ] ) ) ; emit ( '=' ) ; } emit ( exprGen ( a [ 2 ] ) ) ; emit ( ';' ) ; break ; case 'eval' : var tmpExpr = exprGen ( a [ 1 ] ) ; var tmpStr = joinCode ( tmpExpr ) ; if ( / ^\w+$ / . test ( tmpStr ) ) var tName = tmpStr ; else { tName = '_t' ; emit ( '_t = ' ) ; emit ( tmpExpr ) ; emit ( ';' ) ; } emit ( 'if(' + tName + ' !=null)_s += ' + ( ( defaultEncode ? ! a [ 2 ] : a [ 2 ] ) ? encodeName + '(' + tName + ')' : tName ) + ';' ) ; break ; case 'text' : if ( ignoreWhitespace ) { if ( / ^\s+$ / . test ( a [ 1 ] ) ) break ; } emit ( '_s += ' + quote ( a [ 1 ] ) + ';' ) ; break ; case 'inc' : //stmtsGen(a[2][1]); break ; case 'script' : scripts . push ( a [ 1 ] ) ; break ; default : throw Error ( 'unknown stmt: ' + a [ 0 ] ) ; } } function stmtsGen ( a ) { for ( var i = 0 ; i < a . length ; ++ i ) stmtGen ( a [ i ] ) ; } function joinCode ( a ) { if ( typeof a == 'string' ) return a ; if ( a instanceof Array ) { var r = [ ] ; for ( var i = 0 ; i < a . length ; ++ i ) { r . push ( joinCode ( a [ i ] ) ) ; } return r . join ( '' ) ; } throw new Error ( "unknown type" ) ; } function exprToStr ( x , check ) { var t = exprGen ( x ) ; if ( check && ! check ( x [ 0 ] ) ) t = [ '(' , t , ')' ] ; return t ; } function exprGen ( x ) { return nodeWithPos ( exprGen_original ( x ) , x . pos ) ; } function exprGen_original ( x ) { switch ( x [ 0 ] ) { case 't' : return x [ 1 ] ; // case 'id' : return encodeCommonName ( x [ 1 ] ) ; case 'lit' : return ( typeof x [ 1 ] == 'string' ) ? quote ( x [ 1 ] ) : String ( x [ 1 ] ) ; case 'array' : var tmp = [ '[' ] ; for ( var i = 0 ; i < x [ 1 ] . length ; ++ i ) { if ( i > 0 ) tmp . push ( "," ) ; tmp . push ( exprGen ( x [ 1 ] [ i ] ) ) ; } tmp . push ( ']' ) ; return tmp ; case 'object' : var tmp = [ '{' ] ; for ( var i = 0 ; i < x [ 1 ] . length ; ++ i ) { if ( i > 0 ) tmp . push ( "," ) ; tmp . push ( quote ( x [ 1 ] [ i ] [ 1 ] ) ) ; tmp . push ( ':' ) ; tmp . push ( exprGen ( x [ 1 ] [ i ] [ 2 ] ) ) ; } tmp . push ( '}' ) ; return tmp ; case 'null' : return [ 'null' ] ; case '.' : return [ exprToStr ( x [ 1 ] , isMember ) , '.' , x [ 2 ] ] ; case '[]' : return [ exprToStr ( x [ 1 ] , isMember ) , '[' , exprGen ( x [ 2 ] ) , ']' ] ; case '()' : var a = [ exprToStr ( x [ 1 ] , isMember ) , '(' ] ; if ( x [ 2 ] ) { for ( var i = 0 ; i < x [ 2 ] . length ; ++ i ) { if ( i > 0 ) a . push ( ',' ) ; a . push ( exprGen ( x [ 2 ] [ i ] ) ) ; } } a . push ( ')' ) ; return a ; case '!' : return [ '!' , exprToStr ( x [ 1 ] , isUnary ) ] ; case 'u-' : return [ '- ' , exprToStr ( x [ 1 ] , isUnary ) ] ; case '*' : case '/' : case '%' : return [ exprToStr ( x [ 1 ] , isMul ) , x [ 0 ] , exprToStr ( x [ 2 ] , isUnary ) ] ; case '+' : case '-' : return [ exprToStr ( x [ 1 ] , isAdd ) , x [ 0 ] , ' ' , exprToStr ( x [ 2 ] , isMul ) ] ; case '<' : case '>' : case '<=' : case '>=' : return [ exprToStr ( x [ 1 ] , isRel ) , x [ 0 ] , exprToStr ( x [ 2 ] , isAdd ) ] ; case '==' : case '!=' : case '===' : case '!==' : return [ exprToStr ( x [ 1 ] , isEquality ) , x [ 0 ] , exprToStr ( x [ 2 ] , isRel ) ] ; case '&&' : return [ exprToStr ( x [ 1 ] , isLogicalAnd ) , '&&' , exprToStr ( x [ 2 ] , isEquality ) ] ; case '||' : return [ exprToStr ( x [ 1 ] , isLogicalOr ) , '||' , exprToStr ( x [ 2 ] , isLogicalAnd ) ] ; case 'cond' : return [ exprToStr ( x [ 1 ] , isLogicalOr ) , '?' , exprToStr ( x [ 2 ] , isCond ) , ':' , exprToStr ( x [ 3 ] , isCond ) ] ; default : throw Error ( "unknown expr: " + x [ 0 ] ) ; } } var body = [ ] ; var scripts = [ ] ; stmtsGen ( prog [ 1 ] ) ; var posLog = [ ] ; var jsStr = '' ; function joinJsStr ( a ) { if ( typeof a == 'string' ) jsStr += a ; if ( a instanceof Array ) { if ( a . pos ) { posLog . push ( [ jsStr . length , a . pos ] ) ; } for ( var i = 0 ; i < a . length ; ++ i ) { joinJsStr ( a [ i ] ) ; } } } joinJsStr ( body ) ; if ( scripts . length ) { jsStr += scripts . join ( ';' ) ; } //alert(posLog.join('\n')); var strObj = new String ( jsStr ) ; strObj . posLog = posLog ; return strObj ; } 
function codegen_php_tran ( prog , defaultEncode ) { /// <param name="prog" type="Array">AST</param> /// <param name="defaultEncode" type="Boolean"></param> /// <returns type="String" /> //  function encodeId ( s ) { return '$crox_' + encodeCommonName ( s ) ; } function emit ( t ) { s += t ; } function compileEval ( stmt ) { var t = walkExpr ( stmt [ 1 ] ) ; emit ( 'crox_echo(' + t + ', ' + ( defaultEncode ? ! stmt [ 2 ] : stmt [ 2 ] ) + ');' ) ; } function compileContent ( stmt ) { var t = stmt [ 1 ] ; if ( / <\?(?:php)?|\?> / . test ( t ) ) emit ( 'echo ' + phpQuote ( stmt [ 1 ] ) + ';' ) ; else { emit ( '?>' + t + '<?php ' ) ; } } function compileIf ( stmt ) { emit ( 'if(' + walkExpr ( stmt [ 1 ] ) + '){' ) ; compileStmts ( stmt [ 2 ] ) ; emit ( '}' ) ; if ( stmt [ 3 ] ) { emit ( 'else{' ) ; compileStmts ( stmt [ 3 ] ) ; emit ( '}' ) ; } } function compileEach ( stmt ) { emit ( 'foreach(' + walkExpr ( stmt [ 1 ] ) + ' as ' + ( stmt [ 3 ] ? encodeId ( stmt [ 3 ] ) + '=>' : '' ) + encodeId ( stmt [ 4 ] ) + ')' ) ; emit ( '{' ) ; compileStmts ( stmt [ 2 ] ) ; emit ( '}' ) ; } function compileSet ( stmt ) { emit ( encodeId ( stmt [ 1 ] ) + ' = ' + walkExpr ( stmt [ 2 ] ) + ';' ) ; } function compileStmt ( a ) { switch ( a [ 0 ] ) { case 'if' : compileIf ( a ) ; break ; case 'each' : compileEach ( a ) ; break ; case 'set' : compileSet ( a ) ; break ; case 'eval' : compileEval ( a ) ; break ; case 'text' : compileContent ( a ) ; break ; case 'inc' : emit ( "include '" + changeExt ( a [ 1 ] , 'php' ) + "';" ) ; break ; default : throw Error ( 'unknown stmt: ' + a [ 0 ] ) ; } } function compileStmts ( a ) { for ( var i = 0 ; i < a . length ; ++ i ) compileStmt ( a [ i ] ) ; } function exprToStr ( x , check ) { var t = walkExpr ( x ) ; if ( check && ! check ( x [ 0 ] ) ) t = '(' + t + ')' ; return t ; } function walkExpr ( x ) { switch ( x [ 0 ] ) { case 'id' : return encodeId ( x [ 1 ] ) ; case 'lit' : if ( typeof x [ 1 ] == 'string' ) return phpQuote ( x [ 1 ] ) ; return String ( x [ 1 ] ) ; case '.' : return exprToStr ( x [ 1 ] , isMember ) + "->" + x [ 2 ] ; case '[]' : return exprToStr ( x [ 1 ] , isMember ) + '[' + walkExpr ( x [ 2 ] ) + ']' ; case '!' : return '!crox_ToBoolean(' + exprToStr ( x [ 1 ] , isUnary ) + ')' ; case 'u-' : return '- ' + exprToStr ( x [ 1 ] , isUnary ) ; case '*' : case '/' : case '%' : return exprToStr ( x [ 1 ] , isMul ) + x [ 0 ] + exprToStr ( x [ 2 ] , isUnary ) ; case '+' : return 'crox_plus(' + exprToStr ( x [ 1 ] , null ) + ', ' + exprToStr ( x [ 2 ] , null ) + ')' ; case '-' : return exprToStr ( x [ 1 ] , isAdd ) + '- ' + exprToStr ( x [ 2 ] , isMul ) ; case '<' : case '>' : case '<=' : case '>=' : return exprToStr ( x [ 1 ] , isRel ) + x [ 0 ] + exprToStr ( x [ 2 ] , isAdd ) ; case '==' : case '!=' : case '===' : case '!==' : return exprToStr ( x [ 1 ] , isEquality ) + x [ 0 ] + exprToStr ( x [ 2 ] , isRel ) ; case '&&' : return 'crox_logical_and(' + exprToStr ( x [ 1 ] , null ) + ', ' + exprToStr ( x [ 2 ] , null ) + ')' ; case '||' : return 'crox_logical_or(' + exprToStr ( x [ 1 ] , null ) + ', ' + exprToStr ( x [ 2 ] , null ) + ')' ; default : throw Error ( "unknown expr: " + x [ 0 ] ) ; } } var s = "" ; compileStmts ( prog [ 1 ] ) ; if ( s . slice ( 0 , 2 ) == '?>' ) s = s . slice ( 2 ) ; else s = '<?php ' + s ; if ( s . slice ( - 6 ) == '<?php ' ) s = s . slice ( 0 , - 6 ) ; else s += '?>' ; return s ; } 
function codegen_vm_tran ( prog ) { /// <param name="prog" type="Array">AST</param> /// <returns type="String" /> //  function encodeId ( s ) { return '$crox_' + encodeCommonName ( s ) ; } function isName ( s ) { return / ^$\w+$ / . test ( s ) ; } function emit ( s ) { body += s ; } var i_each = 0 ; function stmtGen ( a ) { switch ( a [ 0 ] ) { case 'if' : emit ( '#if(' + exprGen ( a [ 1 ] ) + ')' ) ; stmtsGen ( a [ 2 ] ) ; if ( a [ 3 ] ) { emit ( '#{else}' ) ; stmtsGen ( a [ 3 ] ) ; } emit ( '#{end}' ) ; break ; case 'each' : ++ i_each ; var sExpr = exprGen ( a [ 1 ] ) ; if ( isName ( sExpr ) ) var listName = sExpr ; else { listName = '$list' + ( i_each == 1 ? '' : i_each ) ; emit ( '#set (' + listName + ' = ' + sExpr + ')' ) ; } if ( a [ 5 ] ) { //array emit ( '#foreach(' + encodeId ( a [ 4 ] ) + ' in ' + listName + ')' ) ; if ( a [ 3 ] ) { emit ( '#set(' + encodeId ( a [ 3 ] ) + ' = $velocityCount - 1)' ) ; } } else { //object if ( a [ 3 ] ) { emit ( '#foreach(' + encodeId ( a [ 3 ] ) + ' in ' + listName + '.keySet())' ) ; emit ( '#set(' + encodeId ( a [ 4 ] ) + ' =' + listName + '.get(' + encodeId ( a [ 3 ] ) + '))' ) ; } else { emit ( '#foreach(' + encodeId ( a [ 4 ] ) + ' in ' + listName + ')' ) ; } } stmtsGen ( a [ 2 ] ) ; emit ( '#{end}' ) ; -- i_each ; break ; case 'set' : emit ( '#set (' + encodeId ( a [ 1 ] ) + '=' + exprGen ( a [ 2 ] ) + ')' ) ; break ; case 'eval' : var s = exprGen ( a [ 1 ] ) ; if ( isName ( s ) ) emit ( '$!{' + s . slice ( 1 ) + '}' ) ; else { emit ( '#set($t = ' + s + ')$!{t}' ) ; } break ; case 'text' : emit ( a [ 1 ] . replace ( / \$ / g , '$${dollar}' ) . replace ( / # / g , '$${sharp}' ) ) ; break ; case 'inc' : emit ( "#parse('" + changeExt ( a [ 1 ] , 'vm' ) + "')" ) ; break ; default : throw Error ( 'unknown stmt: ' + a [ 0 ] ) ; } } function stmtsGen ( a ) { for ( var i = 0 ; i < a . length ; ++ i ) stmtGen ( a [ i ] ) ; } function exprToStr ( x , check ) { var t = exprGen ( x ) ; if ( check && ! check ( x [ 0 ] ) ) t = '(' + t + ')' ; return t ; } function exprGen ( x ) { switch ( x [ 0 ] ) { case 'id' : return encodeId ( x [ 1 ] ) ; case 'lit' : if ( typeof x [ 1 ] == 'string' ) return vmQuote ( x [ 1 ] ) ; return String ( x [ 1 ] ) ; case '.' : return exprToStr ( x [ 1 ] , isMember ) + '.' + x [ 2 ] ; case '[]' : return exprToStr ( x [ 1 ] , isMember ) + '[' + exprGen ( x [ 2 ] ) + ']' ; case '!' : return '!' + exprToStr ( x [ 1 ] , isUnary ) ; case 'u-' : if ( x [ 1 ] [ 0 ] == 'u-' ) throw Error ( ""); return '-' + exprToStr ( x [ 1 ] , isUnary ) ; case '*' : case '/' : case '%' : return exprToStr ( x [ 1 ] , isMul ) + x [ 0 ] + exprToStr ( x [ 2 ] , isUnary ) ; case '+' : case '-' : return exprToStr ( x [ 1 ] , isAdd ) + x [ 0 ] + ' ' + exprToStr ( x [ 2 ] , isMul ) ; case '<' : case '>' : case '<=' : case '>=' : return exprToStr ( x [ 1 ] , isRel ) + x [ 0 ] + exprToStr ( x [ 2 ] , isAdd ) ; case '==' : case '!=' : case '===' : case '!==' : return exprToStr ( x [ 1 ] , isEquality ) + x [ 0 ] . slice ( 0 , 2 ) + exprToStr ( x [ 2 ] , isRel ) ; case '&&' : return exprToStr ( x [ 1 ] , isLogicalAnd ) + '&&' + exprToStr ( x [ 2 ] , isEquality ) ; case '||' : return exprToStr ( x [ 1 ] , isLogicalOr ) + '||' + exprToStr ( x [ 2 ] , isLogicalAnd ) ; default : throw Error ( "unknown expr: " + x [ 0 ] ) ; } } function vmQuote ( s ) { /// <param name="s" type="String"></param> if ( s . indexOf ( "'" ) == - 1 ) return "'" + s + "'" ; var a = s . split ( "'" ) ; return "('" + a . join ( "'+\"'\"+'" ) + "')" ; } var body = "#set($dollar='$')#set($sharp='#')" ; stmtsGen ( prog [ 1 ] ) ; return body ; } 
function write ( chunk , encoding , callback ) { if ( typeof encoding === 'function' ) { callback = encoding encoding = null } if ( ended ) { throw new Error ( 'Did not expect `write` after `end`' ) } chunks . push ( ( chunk || '' ) . toString ( encoding || 'utf8' ) ) if ( callback ) { callback ( ) } 
function end ( ) { write . apply ( null , arguments ) ended = true processor . process ( chunks . join ( '' ) , done ) return true function done ( err , file ) { var messages = file ? file . messages : [ ] var length = messages . length var index = - 1 chunks = null 
function pipe ( dest , options ) { var settings = options || { } var onend = once ( onended ) emitter . on ( 'data' , ondata ) emitter . on ( 'error' , onerror ) emitter . on ( 'end' , cleanup ) emitter . on ( 'close' , cleanup ) 
function cleanup ( ) { emitter . removeListener ( 'data' , ondata ) emitter . removeListener ( 'end' , onend ) emitter . removeListener ( 'error' , onerror ) emitter . removeListener ( 'end' , cleanup ) emitter . removeListener ( 'close' , cleanup ) dest . removeListener ( 'error' , onerror ) dest . removeListener ( 'close' , cleanup ) } 
function onerror ( err ) { var handlers = emitter . _events . error cleanup ( ) 
function rm ( names ) { console . log ( ) ; for ( const name of names ) { const bplate = path . join ( os . homedir ( ) , '.snap' , name ) ; if ( fs . pathExistsSync ( bplate ) ) { fs . removeSync ( bplate ) ; console . log ( ` ${ chalk . green ( 'Success:' ) } ${ chalk . redBright ( name ) } ` ) ; } else { console . error ( ` ${ chalk . red ( 'Error:' ) } ${ chalk . yellow ( name ) } ` ) ; } } console . log ( ) ; } 
function save ( name , src = path . resolve ( ) , options ) { 
function clean ( root , name ) { const blacklist = [ '.git' , 'node_modules' ] ; for ( const item of blacklist ) { const pathToItem = path . join ( root , item ) ; if ( fs . pathExistsSync ( pathToItem ) ) { fs . removeSync ( pathToItem ) ; console . log ( ` ${ chalk . dim . redBright ( item ) } ${ chalk . yellow ( name ) } ` ) ; } } } 
function ls ( ) { const vault = path . join ( os . homedir ( ) , '.snap' ) ; const list = shell . ls ( vault ) ; if ( ! list . length ) { console . log ( "\nIt seems you don't have anything saved..." ) ; console . log ( ` ${ chalk . yellow ( 'snap save' ) } ` ) ; console . log ( ` ${ chalk . yellow ( 'snap save -h' ) } \n ` ) ; return ; } console . log ( '\nThe following boilerplates have been saved...' ) ; console . log ( ` ${ chalk . yellow ( 'snap <boilerplate-name> <project-directory>' ) } ` ) ; for ( const bplate of list ) { console . log ( ` bp late}` ) ; } console . log ( ) ; } 
function snap ( bplateName , projectDir , options ) { 
function show ( name ) { const root = path . join ( os . homedir ( ) , '.snap' , name ) ; if ( ! fs . pathExistsSync ( root ) ) { console . log ( ` \n ${ chalk . red ( 'Error:' ) } ${ chalk . yellow ( name ) } \n ` ) ; return ; } const tree = walk ( root , 0 ) ; console . log ( ) ; printTree ( tree ) ; console . log ( ) ; } 
function AnimationScaleInRight ( init ) { let buildStyleInterpolator = init ; return Object . assign ( { } , { ... NavigatorSceneConfigs . PushFromRight , animationInterpolators : { into : buildStyleInterpolator ( { ... CenterScaleRightIn } ) , out : buildStyleInterpolator ( { ... CenterScaleLeftOut } ) } } ) ; } 
function AnimationScaleInRightDown ( init ) { let buildStyleInterpolator = init ; return Object . assign ( { } , { ... NavigatorSceneConfigs . PushFromRight , animationInterpolators : { into : buildStyleInterpolator ( { ... DownScaleIn } ) , out : buildStyleInterpolator ( { ... DownScaleOut } ) } } ) ; } 
function AnimationScaleInRightUp ( init ) { let buildStyleInterpolator = init ; return Object . assign ( { } , { ... NavigatorSceneConfigs . PushFromRight , animationInterpolators : { into : buildStyleInterpolator ( { ... UpScaleIn } ) , out : buildStyleInterpolator ( { ... UpScaleOut } ) } } ) ; } 
function AnimationRotateInLeft ( init ) { let buildStyleInterpolator = init ; return Object . assign ( { } , { ... NavigatorSceneConfigs . FadeAndroid , animationInterpolators : { into : buildStyleInterpolator ( { ... RightRotateInDown } ) , out : buildStyleInterpolator ( { ... LeftRotateOutDown } ) } } ) ; } 
function CustomAnimation ( init ) { let buildStyleInterpolator = init ; return ( LeftRightIn , UpDowmOut , Gestures , Base = { springFriction : 26 , springTension : 200 , defaultTransitionVelocity : 1.5 } ) => { return Object . assign ( { } , NavigatorSceneConfigs . FadeAndroid , { animationInterpolators : { into : buildStyleInterpolator ( { ... CheckParams ( LeftRightIn ) } ) , out : buildStyleInterpolator ( { ... CheckParams ( UpDowmOut ) } ) } , gestures : Gestures ? Gestures : { pop : { ... BaseLeftToRightGesture , direction : "left-to-right" , fullDistance : Width } } , ... Base 
function socketConnection ( socket ) { const cookies = getCookies ( socket . handshake . headers . cookie ) ; socket . session_start = Date . now ( ) ; socket . blurred = 0 ; socket . blurring = Date . now ( ) ; socket . req_id = cookies . na_req ; socket . session_id = cookies . na_session ; 
function socketResponse ( socket ) { 
function getSession ( req , res , cb ) { const now = new Date ( ) ; const cookies = getCookies ( req . headers . cookie ) ; 
function userSession ( ) { 
function setCookies ( req , res , session , cb ) { const now = new Date ( ) ; 
function sessionData ( req , res , session , cb ) { const now = new Date ( ) ; if ( session . continued ) return cb ( null , req , res , session ) ; async . parallelLimit ( [ getIp , getLocation , getSystem ] , 2 , function ( err ) { cb ( err , this . req , this . res , this . session ) ; if ( opts . log_all ) log . timer ( 'sessionData' , now ) ; } . bind ( { req : req , res : res , session : session } ) ) ; 
function getLocation ( cb ) { if ( ! geo_lookup ) return cb ( null ) ; const loc = geo_lookup . get ( session . ip ) ; if ( ! session . geo ) session . geo = { } ; if ( loc ) { try { if ( loc . city ) session . geo . city = loc . city . names . en ; if ( loc . subdivisions ) session . geo . state = loc . subdivisions [ 0 ] . iso_code ; if ( loc . country ) session . geo . country = loc . country . iso_code ; if ( loc . continent ) session . geo . continent = loc . continent . code ; if ( loc . location ) session . geo . time_zone = loc . location . time_zone ; } catch ( e ) { log . error ( 'geoIP error:' , e ) ; } } cb ( null ) } 
function getSystem ( cb ) { var agent = useragent . parse ( req . headers [ 'user-agent' ] ) ; var os = agent . os ; if ( ! session . system ) session . system = { } ; if ( ! session . system . browser ) session . system . browser = { } ; if ( ! session . system . os ) session . system . os = { } ; session . system . browser . name = agent . family ; session . system . browser . version = agent . major + '.' + agent . minor + '.' + agent . patch ; session . system . os . name = os . family ; session . system . os . version = os . major + '.' + os . minor + '.' + os . patch ; cb ( null ) } 
function newRequest ( req , res , session , cb ) { const now = new Date ( ) ; const request = { _id : ` ${ crypto . randomBytes ( 16 ) . toString ( 'hex' ) } ${ Date . now ( ) } ` , host : req . hostname , url : req . url , method : req . method , referrer : req . get ( 'Referrer' ) || req . get ( 'Referer' ) } ; 
function logRequest ( req , res , session , request , cb ) { const now = new Date ( ) ; if ( opts . log ) { onHeaders ( res , log_start . bind ( res ) ) ; onFinished ( res , req_log . bind ( { req : request , ses : session } ) ) ; } cb ( null , session , request ) ; if ( opts . log_all ) log . timer ( 'logRequest' , now ) ; 
function nano_time ( start ) { let t = conv ( process . hrtime ( ) ) - conv ( start ) ; 
function sessionSave ( session , request , cb ) { const now = new Date ( ) ; if ( ! session . continued ) { session . reqs = [ request ] ; Update . session ( session , { $set : session } , ( err , session ) => { if ( err ) return cb ( 'db session save error' ) ; if ( opts . log_all ) log . session ( session , 'session active [ new ]' ) ; cb ( null , session ) ; if ( opts . log_all ) log . timer ( 'sessionSave 1' , now ) ; } ) } else { 
function Identify ( name ) { Update . session ( this , { $set : { name : name } } , ( err ) => { if ( err ) log . error ( 'session.associate: name save error' , err ) ; } ) ; } 
function getCookies ( src ) { let cookies = cookie . parse ( src || '' ) ; for ( let k in cookies ) { if ( k . indexOf ( 'na_' ) === 0 ) { try { cookies [ k ] = AES . decrypt ( cookies [ k ] ) ; } catch ( err ) { log . error ( 'getCookies error' , err ) ; delete cookies [ k ] ; } } } return cookies ; } 
function sessions ( options , cb ) { if ( ! cb ) { cb = options ; options = { is_bot : false } ; } var n = 32 ; Session . find ( options ) . sort ( { date : 'desc' } ) . limit ( n ) . exec ( function ( err , results ) { if ( err ) log . error ( 'Sessions query error:' , err ) ; cb ( err , results ) } ) ; } 
function ( packet ) { this . updatePayload = function ( packet ) { this . p_previous = this . p ; this . p = packet . payload ; this . changed = this . p_previous != this . p ; this . retained = packet . retain ; this . lastChange = this . currentChange ; this . currentChange = new Date ( ) ; } ; this . changedFromTo = function ( from , to ) { return this . changed && this . p_previous == from && this . p == to ; } ; this . changedTo = function ( to ) { return this . changed && this . p == to ; } ; this . changedFrom = function ( from ) { return this . changed && this . p_previous == from ; } ; this . t = packet . topic ; this . updatePayload ( packet ) ; this . currentChange = new Date ( ) ; this . lastChange = undefined ; 
function ( ) { this . date = new Date ( ) ; this . getHours = function ( ) { return this . date . getHours ( ) ; } ; this . getMinutes = function ( ) { return this . date . getMinutes ( ) ; } ; this . hoursIsBetween = function ( a , b ) { if ( a <= b ) return this . date . getHours ( ) >= a && this . date . getHours ( ) <= b ; else return this . date . getHours ( ) >= a || this . date . getHours ( ) <= b ; } ; this . step = function ( ) { this . date = new Date ( ) ; this . isMorning = this . hoursIsBetween ( 6 , 11 ) ; this . isNoon = this . hoursIsBetween ( 12 , 14 ) ; this . isAfternoon = this . hoursIsBetween ( 15 , 17 ) ; this . isEvening = this . hoursIsBetween ( 18 , 23 ) ; this . isNight = this . hoursIsBetween ( 0 , 5 ) ; return this ; } ; } 
function NoolsFire ( n ) { RED . nodes . createNode ( this , n ) ; var node = this ; node . name = n . name ; node . topic = n . topic ; node . session = RED . nodes . getNode ( n . session ) . session ; node . messages = RED . nodes . getNode ( n . session ) . messages ; RED . nodes . getNode ( n . session ) . on ( "publish" , function ( msg ) { if ( ! node . topic || node . topic === msg . topic ) { node . send ( msg ) ; } } ) ; node . session . on ( "fire" , function ( name , rule ) { node . send ( [ null , { topic : node . topic , payload : name , facts : node . session . getFacts ( ) , name : name } ] ) ; } ) ; } 
function NoolsFlowNode ( n ) { RED . nodes . createNode ( this , n ) ; var node = this ; 
function distance ( f1_, 1_, f _, f 2 ) { return 2 * asin ( sqrt ( pow ( sin ( ( f1_ 2_) / 2 , 2 + cos ( f1_) os( f 2_) * p w(s i n(( f 1 _ - 2 ) / 2 , 2 ) ) ) ; } 
function course ( pos1 , pos2 ) { var f1_ os1[ 0 ] , f1_ os1[ 1 ] , f2_ os2[ 0 ] , f2_ os2[ 1 ] ; var d = distance ( f1_, 1_, f _, f 2 ), a , o u se = { ; if ( sin ( f2_ 1_) < 0 { a = acos ( ( sin ( f2_) in( f 1_) * c s(d ) ) / ( i n(d ) * c s(f 1 _))) ; } else { a = 2 *  cos( ( s in( f 2_) - s n(f 1 _) * o (d) ) / s n (d) * o (f1 _ ))); } course . d = d ; course . a = a ; return course ; } 
function midpoint ( pos1 , pos2 ) { var Bx = Math . cos ( pos2 . ) ath. c os( p os2.  - p s1. ) ; var By = Math . cos ( pos2 . ) ath. s in( p os2.  - p s1. ) ; return { : tan2( s in( p os1.  ) + s n(p o s2. ) , sqrt ( ( cos ( pos1 . ) x) c os( p os1.  ) + B ) + B * B )) , : os1.  + a an2(B y , c s(p o s1. ) + x } ; } 
function interpolate ( f1_, 1_, f _, f 2 , d, u f { for ( var i = 1 ; i < d ; i += 1 ) { let f = i / d ,  istance( f 1_, f _, f 2 , f2 _ ); let A = sin ( ( 1 - f ) * ) in(  ), B = sin ( f * ) in(  ); let x = A * cos ( f1_) os( f 1_) + B * c s(f 2 _) * o (f2 _ ), z = A * cos ( f1_) in( f 1_) + B * c s(f 2 _) * i (f2 _ ), y = A * sin ( f1_) in( f 2_); let  tan2( y , qrt( p ow( x , ) ow( z , ) ) ) ,  tan2( z , ) ; buf [ 2 * ( i - 1 ) + 0 ] = ; buf [ 2 * ( i - 1 ) + 1 ] = ; } } 
function centroid ( buf , b , ... p ) { var n = p . length / 2 ; var sum_x = 0 , sum_z = 0 , sum_y = 0 ; for ( let i = 0 ; i < n ; i += 1 ) { let i_ [ 2 ] , i_ [ 2 ] ; sum_x += cos ( i_) os( i _); sum_z += cos ( i_) in( i _); sum_y += sin ( i_) ; } var x = sum_x / n , z = sum_z / n , y = sum_y / n ; var r = sqrt ( x * x + z * z + y * y ) ; var  sin( y ) ,  tan2( z , ) ; buf [ b + 0 ] = ; buf [ b + 1 ] = ; } 
function populate ( ) { var d = this . _divisions , max_x = 2 * d - 1 , buf = new Float64Array ( ( d - 1 ) * 2 ) ; this . _positions = new Float64Array ( ( 5 * 2 * d * d + 2 ) * 2 ) ; 
function ( req , cb ) { req = request . normalizeRequest ( req ) ; var page ; try { page = this . createPageForRequest ( req ) ; } catch ( err ) { if ( cb ) return cb ( err ) else throw err ; } var needData = typeof page . fetchData === 'function' && ! this . state . request . data ; if ( request . isEqual ( this . state . request , req ) && ! needData ) return ; fetchDataForRequest ( this , page , req , function ( err , req ) { if ( err ) { if ( cb ) return cb ( err ) else throw err ; } this . setState ( { request : req , page : page } ) ; } . bind ( this ) ) ; } 
function create ( format , options ) { const ogrFormat = ogrFormats [ format ] 
function csvParams ( cmd , options ) { cmd . push ( '-lco' , 'WRITE_BOM=YES' ) const hasPointGeom = options . geometry === 'POINT' const fields = options . fields . join ( '|' ) . toLowerCase ( ) . split ( '|' ) const hasXY = fields . indexOf ( 'x' ) > - 1 && fields . indexOf ( 'y' ) > - 1 if ( hasPointGeom && ! hasXY ) cmd = cmd . concat ( [ '-lco' , 'GEOMETRY=AS_XY' ] ) return cmd } 
function shapefileParams ( cmd , options ) { 
function barycenterVerticesAndFaces ( sphere , options , done ) { var n = sphere . _Fields . length , positions = new Float32Array ( n * 3 ) , indices = sphere . _interfieldTriangles , colors = new Float32Array ( indices . length * 3 ) ; for ( let f = 0 ; f < sphere . _Fields . length ; f += 1 ) { let field = sphere . _Fields [ f ] , f_ phere. _ positions[ 2 ] , f_ phere. _ positions[ 2 ] , color = options . colorFn . call ( field ) ; positions [ f * 3 + 0 ] = cos ( f_) os( f _); / x positions [ f * 3 + 2 ] = cos ( f_) in( f _); / z positions [ f * 3 + 1 ] = sin ( f_) ; / y colors [ f * 3 + 0 ] = color . r ; colors [ f * 3 + 1 ] = color . g ; colors [ f * 3 + 2 ] = color . b ; } 
function fieldVerticesAndFaces ( sphere , options , done ) { 
function _fieldGeometry ( ) { const ifi = this . _parent . _interfieldIndices , ifc = this . _parent . _interfieldCentroids , i = this . _i ; var max_ I nfinity, min_ nfinity, max_ I nfinity, min_ nfinity, mid_ his. _ parent. _ positions[ 2 ] , vertices = [ ] ; for ( let v = 0 ; v < this . _adjacentFields . length ; v += 1 ) { let  fc[ 2 fi[ 6 ] ] ,  fc[ 2 fi[ 6 ] ] ; max_ ax( m ax_,  ; min_ in( m in_,  ; max_ ax( m ax_,  ; min_ in( m in_,  ; vertices . push ( [ , ]) ; } if ( i === 0 ) { max_ / 2 } if ( i === 1 ) { min_ / - ; } if ( i < 2 ) { min_  ; max_ ; vertices = [ [ min_, ax_], [ max_, ax_], [ max_, in_], [ min_, in_] ] ; } else if ( max_ & in_ < 0 & ( i d_ < - | id  >  )) { 
function _populateSelectionGrid ( bmp , geo , w , h ) { var w_rect =  , h_rect =  ; var min_x = floor ( geo . min_ _rect ) , max_x = ceil ( geo . max_ _rect ) , min_y = floor ( geo . min_ _rect ) , max_y = ceil ( geo . max_ _rect ) ; for ( let x = min_x ; x <= max_x ; x += 1 ) { for ( let y = min_y ; y <= max_y ; y += 1 ) { bmp . write ( x % w , y , inside ( [ x * w_rect - , _rect / 2 , geo . vertices ) ) ; } } return { min_x , max_x , min_y , max_y } ; } 
function fromRaster ( data , width , height , depth , map , done ) { var sphere = this ; populateInterfieldData . call ( sphere ) ; var bmp = new Bitmap ( width , height ) ; sphere . _Fields . forEach ( function ( field ) { var geo = _fieldGeometry . call ( field ) , selection = _populateSelectionGrid ( bmp , geo , width , height ) ; var valSums = [ ] , weightSum = 0 ; for ( let z = 0 ; z < depth ; z += 1 ) { valSums [ z ] = 0 ; } for ( let x = selection . min_x ; x < selection . max_x ; x += 1 ) { for ( let y = selection . min_y ; y < selection . max_y ; y += 1 ) { let w = _testPoints ( bmp , x , y ) / 4 ; for ( let z = 0 ; z < depth ; z += 1 ) { valSums [ z ] += data [ ( height - y - 1 ) * width * depth + ( width - x - 1 ) * depth + z ] * w ; } weightSum += w ; } } if ( weightSum <= 0 ) debugger ; 
function tethys ( selector , context ) { var nodes = [ ] ; 
function ( events , fn ) { events = events . split ( / \s*\,\s* / ) ; return this . each ( function ( el ) { fn = fn . bind ( el ) ; events . forEach ( function ( event ) { el . addEventListener ( event , fn ) ; } ) ; } ) ; } 
function ( key , value ) { var format = function ( key ) { return key . replace ( / (-([a-z])) / g , function ( s , s1 , s2 ) { return s2 . toUpperCase ( ) ; } ) ; } ; return keyValue . call ( this , arguments , function ( el ) { return el . style [ format ( key ) ] ; } , function ( el , key , attrs ) { el . style [ format ( key ) ] = attrs [ key ] + '' ; } ) ; } 
function ( key , value ) { return keyValue . call ( this , arguments , function ( el ) { return el . getAttribute ( key ) ; } , function ( el , key , attrs ) { el . setAttribute ( key , attrs [ key ] + '' ) ; } ) ; } 
function ( cls ) { var has = false , reg = new RegExp ( '\\b' + cls + '\\b' ) ; this . each ( function ( el ) { has = has || ! ! el . className . match ( reg ) ; } ) ; return has ; } 
function ( ) { return this . each ( function ( el ) { if ( el . style . display === 'none' ) { el . style . display = el . getAttribute ( 'o-d' ) || '' ; } ; } ) ; } 
function ( ) { return this . each ( function ( el ) { if ( el . style . display !== 'none' ) { el . setAttribute ( 'o-d' , el . style . display ) ; el . style . display = 'none' ; } ; } ) ; } 
function ( ) { return this . each ( function ( el ) { var e = $ ( el ) ; e . css ( "display" ) == "none" ? e . show ( ) : e . hide ( ) ; } ) ; } 
function ( child ) { var children = tethys ( child ) ; return this . each ( function ( el ) { children . each ( function ( child , i ) { el . appendChild ( child ) ; } ) ; } ) ; } 
function ( selector ) { var nodes = [ ] ; this . each ( function ( el ) { tethys ( selector , el ) . each ( function ( node ) { nodes . push ( node ) ; } ) ; } ) ; return tethys ( nodes ) ; } 
function watcherFn ( schemaFilepath , watchInterval , reinitBabelRelayPlugin , prevMtime ) { try { let stats ; try { stats = fs . statSync ( schemaFilepath ) ; } catch ( e ) { 
function initBabelRelayPlugin ( pluginOptions , babel , ref ) { const verbose = ! ! pluginOptions . verbose ; const schemaFilepath = pluginOptions . schema || '' ; let schema ; try { schema = fs . readFileSync ( schemaFilepath , 'utf8' ) ; } catch ( e ) { schema = null ; log ( 'Cannot load GraphQL Schema from file \'' + schemaFilepath + '\': ' + e ) ; } if ( schema ) { if ( verbose ) { log ( 'GraphQL Schema loaded successfully from \'' + schemaFilepath + '\'' ) ; } ref . babelRelayPlugin = require ( 'babel-plugin-relay' ) ( babel ) ; } else { 
function Tap ( el ) { this . el = typeof el === 'object' ? el : document . getElementById ( el ) ; this . moved = false ; 
function ( ) { var doc = document . documentElement ; this . el = $ ( tpl ) ; this . el . hide ( ) . css ( { width : doc . clientWidth + 'px' , height : doc . clientHeight + 'px' } ) ; bindTapEvent ( this . el . find ( '.as-cover' ) [ 0 ] , this . hide . bind ( this ) ) ; $ ( 'body' ) . append ( this . el ) ; return this ; } 
function ( buttons ) { var buttonContainer = this . el . find ( '.as-buttons' ) ; 
function OpcParseStream ( options ) { WritableStream . call ( this ) ; options = options || { } ; this . _pushback = null ; this . dataFormat = options . dataFormat || OpcParseStream . DataFormat . BUFFER ; this . channel = ~ ~ options . channel || 0 ; this . systemId = ~ ~ options . systemId || 0xffff ; } 
function AkamaiPurge ( username , password , objects , options ) { var auth = { } , requestBody = { } , requestOptions ; 
function ( ) { 
function AkamaiQueueLength ( username , password ) { var requestOptions , auth = { } ; auth . username = username ; auth . password = password ; requestOptions = { uri : constants . AKAMAI_API_QUEUE , method : 'GET' , auth : auth , json : true } ; return AkamaiRequest ( requestOptions ) ; } 
function Mock ( mount , options ) { 
function AkamaiStatus ( username , password , progressUri ) { var requestOptions , auth = { } ; auth . username = username ; auth . password = password ; requestOptions = { uri : constants . AKAMAI_API_BASE + progressUri , method : 'GET' , auth : auth , json : true } ; return AkamaiRequest ( requestOptions ) . then ( function ( response ) { 
function AkamaiRequest ( requestOptions ) { 
function dean_addEvent ( element , type , handler ) { if ( element . addEventListener ) { element . addEventListener ( type , handler , false ) ; } else { 
function forEach ( object , block , context ) { if ( object ) { let resolve = Object ; 
function ( target , source ) { var skeys = _ . keys ( source ) ; _ . each ( skeys , function ( skey ) { if ( ! target [ skey ] ) { target [ skey ] = source [ skey ] ; } } ) ; return target ; } 
function ( origin , target , plan , mode , out , completeCb ) { var c ; var container ; var containerDef ; out . initProgress ( plan . length , '--> deploying plan...' ) ; var currProgress = 0 ; var prnt ; function tick ( command , c ) { currProgress += 1 ; out . progress ( command + ' ' + c . id + ' ' + ( c . type || '' ) ) ; } logger . info ( 'deploying plan' ) ; async . eachSeries ( plan , function ( step , cb ) { c = target . topology . containers [ step . id ] || origin . topology . containers [ step . id ] ; container = _ . cloneDeep ( c ) ; prnt = target . topology . containers [ step . parent ] || origin . topology . containers [ step . parent ] ; containerDef = _ . find ( target . containerDefinitions , function ( cdef ) { return cdef . id === container . containerDefinitionId ; } ) ; if ( ! containerDef ) { containerDef = _ . find ( origin . containerDefinitions , function ( cdef ) { return cdef . id === container . containerDefinitionId ; } ) ; } if ( container . specific && origin . topology . containers [ step . id ] && origin . topology . containers [ step . id ] . specific ) { container . specific = merge ( container . specific , origin . topology . containers [ step . id ] . specific ) ; } logger . info ( 'calling: ' + step . cmd ) ; 
function createObject ( proto , args ) { var instance = Object . create ( proto ) ; if ( instance . $meta . constructors ) { instance . $meta . constructors . forEach ( function ( constructor ) { constructor . apply ( instance , args ) ; } ) ; } return instance ; } 
function merge ( destination , source ) { for ( var property in source ) { if ( source . hasOwnProperty ( property ) ) { mergeProperty ( destination , source , property ) ; } } return destination ; } 
function mergeProperty ( destination , source , property ) { if ( source [ property ] instanceof Array ) { mergeAsArray ( destination , source , property ) ; } else if ( isPrimitive ( source [ property ] ) || ! isLiteral ( source [ property ] ) ) { overrideIfNotExists ( destination , source , property ) ; } else { mergeAsObject ( destination , source , property ) ; } } 
function mergeAsArray ( destination , source , property ) { destination [ property ] = source [ property ] . concat ( destination [ property ] || [ ] ) ; } 
function mergeAsObject ( destination , source , property ) { destination [ property ] = destination [ property ] || { } ; merge ( destination [ property ] , source [ property ] ) ; } 
function mix ( destination , source ) { for ( var property in source ) { if ( property . substr ( 0 , 2 ) !== "__" && ! ( property in destination ) ) { destination [ property ] = source [ property ] ; } } return destination ; } 
function mixin ( instance , mixins ) { mixins . forEach ( function ( Mixin ) { mix ( instance , Mixin ) ; } ) ; return instance ; } 
function Coined ( options ) { var self = this , dbType , dbDir , dbPath ; if ( ! ( this instanceof Coined ) ) { return new Coined ( options ) ; } EventEmitter . call ( this ) ; options = options || { } ; options . db = options . db || { } ; dbType = options . db . type || 'tiny' ; dbDir = dbType === 'level' ? '.coined.level' : '.coined' ; dbPath = dbType === 'level' ? path . resolve ( process . env . HOME , dbDir ) : path . resolve ( process . env . HOME , dbDir , 'db' ) ; options . db . type = options . db . type || dbType ; options . db . path = options . db . path || dbPath ; if ( options . db . clear ) { cleanup ( options . db . path ) ; } if ( options . db . type === 'level' ) { mkdirp ( options . db . path ) ; this . db = require ( 'levelup' ) ( options . db . path , { db : require ( 'leveldown' ) , valueEncoding : 'json' } ) ; } else if ( options . db . type === 'tiny' ) { mkdirp ( path . resolve ( options . db . path , '..' ) ) ; this . db = require ( 'tiny' ) . json ( { file : options . db . path , saveIndex : false , initialCache : false } ) ; } else { throw new Error ( 'Invalid DB type.' ) ; } this . options = options ; this . socketIndex = 0 ; this . crypto = options . crypto ; this . compressed = options . compressed != null ? options . compressed : true ; this . walletPath = options . walletPath || options . wallet || process . env . HOME + '/.coined/wallet.json' ; this . addr = null ; this . dust = 5460 ; this . fee = 10000 ; mkdirp ( path . dirname ( this . walletPath ) ) ; this . account = null ; this . accounts = [ ] ; this . aaccounts = { } ; this . laccounts = { } ; this . recipients = { } ; if ( options . noPreload ) { this . _clearPreload ( ) ; } this . pool = options . pool || bcoin . pool ( { size : options . size , createConnection : function ( ) { if ( self . socketIndex >= seeds . length ) { self . socketIndex = 0 ; } if ( seeds . length > 3000 ) { seeds = seeds . slice ( 0 , 1500 ) ; self . socketIndex = 0 ; } var addr = seeds [ self . socketIndex ++ ] , parts = addr . split ( ':' ) , host = parts [ 0 ] , port = + parts [ 1 ] || network . port , socket ; socket = net . connect ( port , host ) ; socket . on ( 'connect' , function ( ) { var peers = [ ] . concat ( self . pool . peers . pending , self . pool . peers . block , self . pool . peers . load ) . filter ( Boolean ) ; for ( var i = 0 ; i < peers . length ; i ++ ) { var peer = peers [ i ] ; if ( peer . socket !== socket ) { continue ; } if ( peer . version ) { return self . emit ( 'peer' , peer , socket ) ; } return peer . parser . on ( 'packet' , function callee ( payload ) { if ( payload . cmd !== 'version' ) return ; peer . removeListener ( 'packet' , callee ) ; return setImmediate ( function ( ) { self . emit ( 'peer' , peer , socket ) ; } ) ; } ) ; } self . _log ( 'Connected to %s:%d' , host , port ) ; } ) ; return socket ; } , storage : this . db , startHeight : options . startHeight , fullNode : options . fullNode 
function mkdirp ( dir , made ) { var mode = 0777 & ( ~ process . umask ( ) ) ; if ( ! made ) made = null ; dir = path . resolve ( dir ) ; try { fs . mkdirSync ( dir , mode ) ; made = made || dir ; } catch ( err0 ) { switch ( err0 . code ) { case 'ENOENT' : made = mkdirp ( path . dirname ( dir ) , made ) ; mkdirp ( dir , made ) ; break ; default : var stat ; try { stat = fs . statSync ( dir ) ; } catch ( err1 ) { throw err0 ; } if ( ! stat . isDirectory ( ) ) throw err0 ; break ; } } return made ; } 
function ( obj ) { if ( _ . isArray ( obj ) ) { for ( var i = 0 ; i < obj . length ; i ++ ) { obj [ i ] = walker ( obj [ i ] ) ; } } else if ( _ . isPlainObject ( obj ) ) { var newObj = { } ; for ( var k in obj ) { if ( ! obj . hasOwnProperty ( k ) ) continue ; var include = true ; if ( options . renameFields [ k ] ) { newObj [ options . renameFields [ k ] ] = obj [ k ] ; include = false ; } for ( var rf in options . removeFields ) { if ( _ . isRegExp ( options . removeFields [ rf ] ) ) { if ( options . removeFields [ rf ] . test ( k ) ) include = false ; } else { 
function fileext ( type , path ) { if ( ! path ) path = type , type = false ; var file_arr = path . match ( / ([^:\\/]*?)(?:\.([^ :\\/.]*))$ / ) var fileext = file_arr [ 2 ] ; var name = file_arr [ 1 ] ; var new_name = '' switch ( type ) { case "min" : new_name = name + '.min.' + fileext ; break ; case "map" : new_name = name + '.min.map' ; break ; case "gz" : new_name = name + '.min.gz' ; break ; default : new_name = file_arr [ 0 ] ; } return new_name ; } 
function format_number ( size , precision ) { var decimal , factor ; if ( precision == null ) precision = 1 ; factor = Math . pow ( 10 , precision ) ; decimal = Math . round ( size * factor ) % factor ; return parseInt ( size ) + "." + decimal ; } 
function report_size ( file ) { return echo ( "  " + c c.x t erm(1 6 1)( f i le) " " + ( o rmat_number(f s ize(f i le) / 1 24)) + " KiB"); } 
function ( identifier , target , cb ) { logger . info ( 'get head system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } _sr . getHead ( systemId , target , cb ) ; } 
function ( identifier , target , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , function ( err , target ) { if ( err ) { return cb ( err ) ; } logger . info ( { systemId : systemId , target : target } , 'get deployed system' ) ; _sr . getDeployedRevision ( systemId , target , cb ) ; } ) ; } 
function ( user , name , namespace , cwd , cb ) { logger . info ( 'create system name: ' + name + ', namespace: ' + namespace + ', cwd: ' + cwd ) ; _sr . createSystem ( user , namespace , name , cwd , cb ) ; } 
function ( user , path , cwd , cb ) { logger . info ( 'link system: ' + path + ', ' + cwd ) ; _sr . linkSystem ( user , path , cwd , cb ) ; } 
function ( user , identifier , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { return cb ( new Error ( ERR_NOSYSID ) ) ; } logger . info ( 'unlink system: ' + systemId ) ; _sr . unlinkSystem ( user , systemId , cb ) ; } 
function ( identifier , revisionId , out , cb ) { logger . info ( 'list containers: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; var containers = { } ; if ( ! systemId ) { return cb ( new Error ( ERR_NOSYSID ) ) ; } _builder . loadTargets ( systemId , revisionId , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _ . each ( targets , function ( target ) { _ . each ( target . containerDefinitions , function ( cdef ) { containers [ cdef . id ] = cdef ; } ) ; } ) ; cb ( null , _ . values ( containers ) ) ; } ) ; } 
function ( user , identifier , containerIdentifier , revision , target , out , cb ) { var containerDef ; var systemId ; systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } var systemRoot = _sr . repoPath ( systemId ) ; out . initProgress ( 9 , '--> finding container' ) ; fetchTarget ( systemId , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . loadMatchingTargets ( systemId , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } _builder . findContainer ( systemId , revision , targets , containerIdentifier , function ( err , containerDefId , targets ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } if ( ! containerDefId ) { out . stdout ( ERR_NOCDEF ) ; logger . error ( ERR_NOCDEF ) ; return cb ( ERR_NOCDEF ) ; } async . eachSeries ( _ . values ( targets ) , function ( json , cb ) { var root = buildSys ( json ) ; containerDef = root . containerDefByDefId ( containerDefId ) ; json . repoPath = systemRoot ; if ( ! containerDef . specific || ! containerDef . specific . repositoryUrl ) { return _builder . build ( user , systemId , targets , json , containerDef , target , out , cb ) ; } _synchrotron . synch ( json , containerDef , out , function ( err ) { if ( err ) { out . stdout ( err ) ; logger . error ( err ) ; return cb ( err ) ; } _builder . build ( user , systemId , targets , json , containerDef , target , out , cb ) ; } ) ; } , cb ) ; } ) ; } ) ; } ) ; } 
function ( user , systemName , revision , target , out , cb ) { var systemId = _sr . findSystem ( systemName ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } logger . info ( { systemId : systemId , revision : revision } , 'building all containers' ) ; fetchTarget ( systemId , target , revision , function ( err , target ) { if ( err ) { return cb ( err ) ; } _builder . loadMatchingTargets ( systemId , revision , target , function ( err , targets ) { if ( err ) { return cb ( err ) ; } out . stdout ( '--> building all containers for ' + targets [ Object . keys ( targets ) [ 0 ] ] . name + ' revision ' + revision + ' target ' + target ) ; var containers = _ . chain ( targets ) . filter ( function ( value , key ) { return target === 'alltargets' || key === target ; } ) . map ( function ( target ) { return _ . map ( target . containerDefinitions , function ( cdef ) { return { id : cdef . id , target : target . topology . name , type : cdef . type } ; } ) ; } ) . flatten ( ) . reduce ( function ( acc , cont ) { var notPresent = ! _ . find ( acc , function ( found ) { return found . id === cont . id && found . type === cont . type ; } ) ; if ( notPresent ) { acc . push ( cont ) ; } return acc ; } , [ ] ) . value ( ) ; async . eachSeries ( containers , function ( cont , next ) { buildContainer ( user , systemId , cont . id , revision , cont . target , out , function ( err ) { if ( err ) { out . stderr ( err ) ; } 
function ( systemId , target , revision , cb ) { if ( target === 'alltargets' ) { cb ( null , target ) ; } else { _sr . getDeployedRevisionId ( systemId , target , function ( err , deployedRevId ) { if ( typeof revision === 'function' ) { cb = revision ; if ( ! err ) { revision = deployedRevId ; } else { revision = 'latest' ; } } _builder . loadTargets ( systemId , revision , function ( err , targets ) { if ( err ) { return cb ( err ) ; } var candidates = Object . keys ( targets ) . filter ( function ( candidate ) { return candidate . indexOf ( target ) >= 0 ; } ) ; if ( candidates . length === 0 || candidates . length > 1 ) { logger . error ( ERR_NOTARGET ) ; return cb ( new Error ( ERR_NOTARGET ) ) ; } else { target = candidates [ 0 ] ; } cb ( null , target ) ; } ) ; } ) ; } } 
function ( user , identifier , revisionIdentifier , target , mode , out , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , revisionIdentifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . findRevision ( systemId , revisionIdentifier , function ( err , revisionId ) { if ( err ) { out . stdout ( ERR_NOREV ) ; logger . error ( ERR_NOREV ) ; return cb ( ERR_NOREV ) ; } logger . info ( { systemId : systemId , revisionId : revisionId , environment : target } , 'deploy revision' ) ; if ( ! mode ) { mode = 'live' ; } if ( ! revisionId ) { return cb ( new Error ( 'revisionId is needed to deploy' ) ) ; } return createAnalyzeAndDeployTask ( user , systemId , revisionId , target , mode , out , cb ) ; } ) ; } ) ; } 
function ( user , identifier , revisionIdentifier , target , out , cb ) { logger . info ( 'preview revision: ' + identifier + ', ' + revisionIdentifier + ' ' + target ) ; deployRevision ( user , identifier , revisionIdentifier , target , 'preview' , out , function ( err ) { cb ( err , { plan : out . getPlan ( ) , ops : out . operations ( ) } ) ; } ) ; } 
function ( identifier , cb ) { logger . info ( 'list revisions: ' + identifier ) ; if ( ! identifier ) { return cb ( new Error ( 'no identifier' ) ) ; } var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { return cb ( new Error ( 'system not found' ) ) ; } _sr . listRevisions ( systemId , function ( err , revisions ) { cb ( err , _ . first ( revisions , 20 ) ) ; 
function ( identifier , revisionIdentifier , target , cb ) { logger . info ( 'get revision: ' + identifier + ', ' + revisionIdentifier ) ; var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } fetchTarget ( systemId , target , revisionIdentifier , function ( err , target ) { if ( err ) { return cb ( err ) ; } _sr . findRevision ( systemId , revisionIdentifier , function ( err , revisionId ) { if ( err ) { return cb ( err ) ; } _sr . getRevision ( systemId , revisionId , target , cb ) ; } ) ; } ) ; } 
function ( identifier , cb ) { var systemId = _sr . findSystem ( identifier ) ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } _sr . getTimeline ( systemId , function ( err , timeline ) { cb ( err , { entries : timeline } ) ; } ) ; } 
function ( user , identifier , comment , out , cb ) { logger . info ( 'compile system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; var system ; if ( ! systemId ) { logger . error ( ERR_NOSYSID ) ; return cb ( new Error ( ERR_NOSYSID ) ) ; } var repoPath = _sr . repoPath ( systemId ) ; _compiler . compile ( systemId , repoPath , out , function ( err , systems ) { if ( err ) { return cb ( err ) ; } async . eachSeries ( _ . keys ( systems ) , function ( key , next ) { system = systems [ key ] ; _sr . writeFile ( system . id , key + '.json' , JSON . stringify ( system , null , 2 ) , next ) ; } , function ( err ) { cb ( err ) ; } ) ; } ) ; } 
function ( user , identifier , comment , out , cb ) { logger . info ( 'commit system: ' + identifier ) ; var systemId = _sr . findSystem ( identifier ) ; _sr . commitRevision ( user , systemId , comment , function ( err , revisionId ) { _sr . getDeployedTargets ( systemId , function ( err , targets ) { if ( targets ) { async . eachSeries ( targets , function ( target , next ) { if ( target . commit === 'edits' ) { _sr . markDeployedRevision ( user , systemId , revisionId , target . env , function ( ) { next ( ) ; } ) ; } else { next ( ) ; } } , function ( ) { cb ( err , revisionId ) ; } ) ; } else { cb ( err , revisionId ) ; } } ) ; } ) ; } 
function ( src , destination ) { grunt . verbose . writeln ( "Adding entries to be coffeeified/browserified: " + src ) ; var browserifyInstance = browserify ( src ) ; return { dest : destination , instance : browserifyInstance } ; } 
function finalizeBuild ( sourceReport ) { 
function injectCode ( ) { var fullpath = path . join ( rootpath , "app.js" ) ; var source = fs . readFileSync ( fullpath , 'utf8' ) ; var test = / \/\/ALLOY-RESOLVER / . test ( source ) ; logger . trace ( "CODE INJECTED ALREADY: " + test ) ; if ( ! test ) { source = source . replace ( / (var\s+Alloy[^;]+;) / g , "$1\n//ALLOY-RESOLVER\nvar process=require('/process');\nAlloy.resolve=new (require('/resolver'))().resolve;\n" ) ; fs . writeFileSync ( fullpath , source ) ; } } 
function fixFiles ( ) { logger . trace ( "inside fixFiles()" ) ; _ . each ( registry . files , function ( file ) { var fullpath = path . join ( rootpath , file ) ; var basepath = path . posix . dirname ( file ) ; var basefile = path . posix . resolve ( file ) ; var source = fs . readFileSync ( fullpath , 'utf8' ) ; logger . trace ( "fixing file: " + fullpath ) ; var requireRegex = / (require)\s*\(((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*)\) / g ; var staticRequireRegex = / (require)(?:\(\s*['"])([^'"]+)(?:['"]\s*\)) / g ; source = source . replace ( requireRegex , function ( $1 , $2 , $3 ) { var requestedModule = $2 ; if ( staticRequireRegex . test ( $1 ) ) { var staticRequireSource = $1 ; staticRequireSource = staticRequireSource . replace ( staticRequireRegex , function ( $1 , $2 , $3 ) { var resolved_path = resolver . resolve ( $3 , basepath ) ; return 'require("' + resolved_path + '")' ; } ) ; return staticRequireSource ; } else { return 'require(Alloy.resolve(' + $3 + ', "' + basepath + '"))' ; } } ) ; fs . writeFileSync ( fullpath , source , { mode : 0o755 } ) ; } ) ; } 
function replaceBackSlashes ( input ) { var isExtendedLengthPath = / ^\\\\\?\\ / . test ( input ) ; var hasNonAscii = / [^\x00-\x80]+ / . test ( input ) ; if ( isExtendedLengthPath || hasNonAscii ) { return input ; } return input . replace ( / \\ / g , '/' ) ; } 
function findFiles ( rootpath , patterns ) { logger . trace ( "inside findFiles()" ) ; var patterns = patterns || [ '**' ] ; if ( _ . isString ( patterns ) ) { patterns = [ patterns ] ; } var files = _ . map ( wrench . readdirSyncRecursive ( rootpath ) , function ( filename ) { return path . posix . sep + replaceBackSlashes ( filename ) ; } ) ; var matchedFiles = match ( files , patterns , { nocase : true , matchBase : true , dot : true , } ) ; return _ . filter ( matchedFiles , function ( file ) { return ! fs . statSync ( path . join ( rootpath , file ) ) . isDirectory ( ) ; } ) || [ ] ; } 
function match ( list , patterns , options ) { list = list || [ ] ; patterns = patterns || [ ] ; if ( _ . isString ( patterns ) ) { patterns = [ patterns ] ; } if ( list . length === 0 || patterns . length === 0 ) { return [ ] ; } options = options || { } ; return patterns . reduce ( function ( ret , pattern ) { var process = _ . union if ( pattern [ 0 ] === '!' ) { pattern = pattern . slice ( 1 ) ; process = _ . difference ; } return process ( ret , minimatch . match ( list , pattern , options ) ) ; } , [ ] ) ; } 
function loadFiles ( ) { logger . trace ( "inside loadFiles()" ) ; var allfiles = findFiles ( rootpath , includes ) ; var filepaths = _ . filter ( allfiles , function ( filepath ) { return ! / .+(package\.json) / . test ( filepath ) ; } ) ; _ . forEach ( filepaths , function ( filepath ) { registry . files . push ( filepath ) ; } ) ; var packagepaths = _ . filter ( allfiles , function ( filepath ) { return ( / .+(package\.json) / . test ( filepath ) ) ; } ) ; _ . forEach ( packagepaths , function ( filepath ) { var content = fs . readFileSync ( path . posix . join ( rootpath , filepath ) , 'utf8' ) ; var json = JSON . parse ( content ) ; if ( json . main ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : path . posix . resolve ( path . posix . join ( path . posix . dirname ( filepath ) , json . main ) ) } ) ; } } ) ; var indexpaths = _ . filter ( allfiles , function ( filepath ) { return ( / .+(index\.js) / . test ( filepath ) ) ; } ) ; _ . forEach ( indexpaths , function ( filepath ) { var existingdir = _ . find ( registry . directories , function ( dir ) { return dir . id === path . posix . dirname ( filepath ) ; } ) ; if ( ! existingdir ) { registry . directories . push ( { id : path . posix . dirname ( filepath ) , path : filepath } ) ; } } ) ; return registry ; } 
function writeRegistry ( ) { logger . trace ( "inside writeRegistry()" ) ; var filepath = path . join ( rootpath , "resolver.js" ) ; var content = fs . readFileSync ( filepath , 'utf8' ) ; var regex = / (var\s+registry\s+=\s+)[^;]*(;) / g ; var modified = content . replace ( regex , "$1" + JSON . stringify ( registry ) + "$2" ) ; fs . writeFileSync ( filepath , modified ) ; } 
function getFirstLetter ( text ) { var matches = text . match ( firstLetterRegex ) ; if ( null === matches ) { return '' ; } 
function setTheme ( theme ) { const navigationOptions = getNavigationOptions ( theme ) const contentOffset = theme . defaultValues . colors . headerOpacity < 1 ? ( theme . systemValues . isIOS ? theme . systemValues . statusBarHeight : 0 ) + theme . systemValues . navigationBarHeight : 0 return { type : CONSTANTS . theme . setTheme , theme , navigationOptions , 
function themeReducer ( state = initialState , action ) { switch ( action . type ) { case CONSTANTS . theme . setTheme : return { ... state , theme : action . theme , navigationOptions : action . navigationOptions , contentOffset : action . contentOffset , } default : return state } } 
function uri ( val ) { var parts , scheme , authority , path ; if ( ! isString ( val ) ) { return false ; } 
function build ( mode , system , cdef , out , cb ) { _containers . getHandler ( system , cdef . type , function ( err , container ) { if ( err ) { return cb ( err ) ; } if ( ! container ) { err = new Error ( 'no matching container available for type: ' + cdef . type ) ; logger . error ( err . message ) ; return cb ( err ) ; } if ( container . build ) { out . progress ( '--> executing container specific build for ' + cdef . id ) ; logger . info ( { containerDefinition : cdef . id } , 'executing container specific build' ) ; container . build ( mode , system , cdef , out , function ( err , specific ) { if ( err ) { logger . error ( err ) ; out . stdout ( err ) ; return cb ( err ) ; } out . progress ( '--> ' + cdef . id + ' built' ) ; logger . info ( { containerDefinition : cdef . id } , 'built' ) ; cb ( err ) ; } ) ; } else { out . progress ( '--> no need to build ' + cdef . id ) ; cb ( null , { } ) ; } } ) ; } 
function findContainer ( systemId , revision , targets , containerIdentifier , cb ) { var cdefId ; var types = [ ] ; async . filter ( _ . keys ( targets ) , function ( key , next ) { _sr . findContainer ( systemId , revision , containerIdentifier , key , function ( err , containerDefId , cdef ) { var def ; if ( ! err && containerDefId ) { cdefId = containerDefId ; def = _ . find ( targets [ key ] . containerDefinitions , function ( def ) { return def . id === cdefId ; } ) ; if ( types . indexOf ( def . type ) < 0 ) { types . push ( def . type ) ; return next ( true ) ; } } next ( false ) ; } ) ; } , function ( keys ) { var result = keys . reduce ( function ( acc , key ) { acc [ key ] = targets [ key ] ; return acc ; } , { } ) ; cb ( null , cdefId , result ) ; } ) ; } 
function mergeEmoji ( child , index , parent ) { var siblings = parent . children var value = toString ( child ) var siblingIndex var node var nodes var subvalue var left var right var leftMatch var rightMatch var start var pos var end var replace var startIndex var nextSibling var nextNextSibling var possibleEmoji var maxSiblingIndex var loopIndex var lastSibling var lastSiblingIndex if ( child . type === 'WordNode' ) { if ( own . call ( unicodes , value ) ) { node = { type : EMOTICON_NODE , value : value } if ( child . position ) { node . position = child . position } siblings [ index ] = node } else { node = siblings [ index - 1 ] if ( node && own . call ( unicodes , toString ( node ) + value ) ) { node . type = EMOTICON_NODE node . value = toString ( node ) + value if ( child . position && node . position ) { node . position . end = child . position . end } siblings . splice ( index , 1 ) return index } } } else if ( own . call ( unicodes , value ) ) { child . type = EMOTICON_NODE startIndex = index + 1 nextSibling = siblings [ startIndex ] if ( ! nextSibling ) { return } if ( nextSibling . type === 'WordNode' ) { if ( ! isVarianceSelector ( nextSibling ) ) { return } possibleEmoji = value + toString ( nextSibling ) maxSiblingIndex = siblings . length loopIndex = startIndex + 1 while ( loopIndex < maxSiblingIndex && loopIndex - startIndex < 5 && siblings [ loopIndex ] . type !== 'WordNode' ) { possibleEmoji += toString ( siblings [ loopIndex ] ) loopIndex ++ } lastSibling = siblings [ loopIndex ] if ( lastSibling && lastSibling . type === 'WordNode' ) { possibleEmoji += toString ( lastSibling ) } if ( own . call ( unicodes , possibleEmoji ) ) { child . value = possibleEmoji if ( child . position && lastSibling . position ) { child . position . end = lastSibling . position . end } siblings . splice ( index + 1 , loopIndex - index ) return index + 1 } } else if ( nextSibling . type === 'SymbolNode' ) { possibleEmoji = value + toString ( nextSibling ) maxSiblingIndex = siblings . length loopIndex = startIndex + 1 while ( loopIndex < maxSiblingIndex && loopIndex - startIndex < 5 && ( siblings [ loopIndex ] . type === 'SymbolNode' || ( siblings [ loopIndex ] . type === 'WordNode' && isVarianceSelector ( siblings [ loopIndex ] ) ) ) ) { possibleEmoji += toString ( siblings [ loopIndex ] ) loopIndex ++ } if ( own . call ( unicodes , possibleEmoji ) ) { child . value = possibleEmoji lastSiblingIndex = loopIndex - 1 lastSibling = siblings [ lastSiblingIndex ] if ( child . position && lastSibling . position ) { child . position . end = lastSibling . position . end } siblings . splice ( index + 1 , lastSiblingIndex - index ) return index + 1 } } } else if ( child . type === 'SymbolNode' ) { nextSibling = siblings [ index + 1 ] nextNextSibling = siblings [ index + 2 ] if ( ! nextSibling || ! nextNextSibling ) { return } if ( ( nextSibling . type === 'SymbolNode' || nextSibling . type === 'WordNode' ) && nextNextSibling && nextNextSibling . type === 'SymbolNode' ) { possibleEmoji = value + toString ( nextSibling ) + toString ( nextNextSibling ) if ( own . call ( unicodes , possibleEmoji ) ) { child . type = EMOTICON_NODE child . value = possibleEmoji if ( child . position && nextNextSibling . position ) { child . position . end = nextNextSibling . position . end } siblings . splice ( index + 1 , 2 ) return index + 1 } } } else if ( value . charAt ( 0 ) === ':' ) { nodes = [ ] siblingIndex = index subvalue = value left = null right = null leftMatch = null rightMatch = null if ( subvalue . length === 1 ) { rightMatch = child } else { end = child . position && child . position . end start = end && child . position . start pos = end && { line : start . line , column : start . column + 1 , offset : start . offset + 1 } rightMatch = { type : 'PunctuationNode' , value : ':' } right = { type : 'PunctuationNode' , value : subvalue . slice ( 1 ) } if ( end ) { rightMatch . position = { start : start , end : pos } right . position = { start : pos , end : end } } } while ( siblingIndex -- ) { if ( index - siblingIndex > MAX_GEMOJI_PART_COUNT ) { return } node = siblings [ siblingIndex ] subvalue = toString ( node ) if ( subvalue . charAt ( subvalue . length - 1 ) === ':' ) { leftMatch = node break } if ( node . children ) { nodes = nodes . concat ( node . children . concat ( ) . reverse ( ) ) } else { nodes . push ( node ) } if ( siblingIndex === 0 ) { return } } if ( ! leftMatch ) { return } subvalue = toString ( leftMatch ) if ( subvalue . length !== 1 ) { end = leftMatch . position && leftMatch . position . end start = end && leftMatch . position . start pos = end && { line : end . line , column : end . column - 1 , offset : end . offset - 1 } left = { type : 'PunctuationNode' , value : subvalue . slice ( 0 , - 1 ) } leftMatch = { type : 'PunctuationNode' , value : ':' } if ( end ) { left . position = { start : start , end : pos } leftMatch . position = { start : pos , end : end } } } nodes . push ( leftMatch ) nodes . reverse ( ) . push ( rightMatch ) value = toString ( nodes ) if ( shortcodes . indexOf ( value ) === - 1 ) { return } replace = [ siblingIndex , index - siblingIndex + 1 ] if ( left ) { replace . push ( left ) } child . type = EMOTICON_NODE child . value = value if ( child . position && leftMatch . position ) { child . position . start = leftMatch . position . start } if ( child . position && rightMatch . position ) { child . position . end = rightMatch . position . end } replace . push ( child ) if ( right ) { replace . push ( right ) } ; [ ] . splice . apply ( siblings , replace ) return siblingIndex + 3 } } 
function getStartRow ( id ) { let r ; for ( let j in TblId ) { if ( TblId [ j ] === id ) r = StartRow [ j ] ; } return r ; } 
function getChildElms ( n ) { if ( n . nodeType == 1 ) { let enfants = n . childNodes ; for ( let i = 0 ; i < enfants . length ; i ++ ) { let child = enfants [ i ] ; if ( child . nodeType == 3 ) n . removeChild ( child ) ; } return n ; } } 
function getFilters ( id ) { SearchFlt = [ ] ; let t = document . getElementById ( id ) ; let tr = t . getElementsByTagName ( "tr" ) [ 0 ] ; let inp = tr . getElementsByTagName ( "input" ) ; for ( let i = 0 ; i < inp . length ; i ++ ) SearchFlt . push ( inp [ i ] . getAttribute ( "id" ) ) ; return SearchFlt ; } 
function getCellsNb ( id , nrow ) { let t = document . getElementById ( id ) ; let tr ; if ( nrow == undefined ) tr = t . getElementsByTagName ( "tr" ) [ 0 ] ; else tr = t . getElementsByTagName ( "tr" ) [ nrow ] ; let n = getChildElms ( tr ) ; return n . childNodes . length ; } 
function ( url , db ) { this . server = new Drowsy . Server ( url ) ; this . db = this . server . database ( db ) ; * Group model */ this . Group = this . db . Document ( 'groups' ) . extend ( { addGroup : function ( group ) { var groups = _ . clone ( this . get ( 'groups' ) ) ; groups . push ( group ) ; this . set ( 'groups' , _ . uniq ( group ) ) ; } } ) ; this . Groups = this . db . Collection ( 'groups' ) . extend ( { model : this . Group } ) ; * Model for Cohorts */ this . Cohort = this . db . Document ( 'cohorts' ) . extend ( { addDiscussion : function ( discussionId ) { var discussions = _ . clone ( this . get ( 'discussions' ) ) ; * Model for Discussions */ this . Discussion = this . db . Document ( 'discussions' ) . extend ( { } ) ; this . Discussions = this . db . Collection ( 'discussions' ) . extend ( { model : this . Discussion } ) ; } 
function normalizeStringPosix ( path , allowAboveRoot ) { var res = '' ; var lastSlash = - 1 ; var dots = 0 ; var code ; for ( var i = 0 ; i <= path . length ; ++ i ) { if ( i < path . length ) code = path . charCodeAt ( i ) ; else if ( code === 47 ) break ; else code = 47 ; if ( code === 47 ) { if ( lastSlash === i - 1 || dots === 1 ) { 
function resolve ( ) { var resolvedDevice = '' ; var resolvedTail = '' ; var resolvedAbsolute = false ; for ( var i = arguments . length - 1 ; i >= - 1 ; i -- ) { var path ; if ( i >= 0 ) { path = arguments [ i ] ; } else if ( ! resolvedDevice ) { path = process . cwd ( ) ; } else { 
function relative ( from , to ) { assertPath ( from ) ; assertPath ( to ) ; if ( from === to ) return '' ; var fromOrig = win32 . resolve ( from ) ; var toOrig = win32 . resolve ( to ) ; if ( fromOrig === toOrig ) return '' ; from = fromOrig . toLowerCase ( ) ; to = toOrig . toLowerCase ( ) ; if ( from === to ) return '' ; 
function resolve ( ) { var resolvedPath = '' ; var resolvedAbsolute = false ; var cwd ; for ( var i = arguments . length - 1 ; i >= - 1 && ! resolvedAbsolute ; i -- ) { var path ; if ( i >= 0 ) path = arguments [ i ] ; else { if ( cwd === undefined ) cwd = process . cwd ( ) ; path = cwd ; } assertPath ( path ) ; 
function ( options ) { var defaults = { 'method' : 'get' , 'data' : null , 'needleRetry' : null , 'rule' : { 'second' : 1 } } ; if ( ! options ) { return defaults ; } return R . merge ( defaults , options ) ; } 
function AddRow ( id , n ) { var t = document . getElementById ( id ) ; var fltrow = t . insertRow ( 0 ) ; var inpclass = "flt" ; for ( var i = 0 ; i < n ; i ++ ) { var fltcell = fltrow . insertCell ( i ) ; var inp = document . createElement ( "input" ) ; inp . setAttribute ( "id" , "flt" + i + "_" + id ) ; inp . setAttribute ( "type" , "text" ) ; inp . setAttribute ( "class" , i == n - 1 ? "flt_s" : "flt" ) ; inp . setAttribute ( 'placeholder' , 'Filter' ) ; inp . addEventListener ( 'keyup' , Filter ) ; fltcell . appendChild ( inp ) ; } } 
function getCellText ( n ) { var s = "" ; var enfants = n . childNodes ; for ( var i = 0 ; i < enfants . length ; i ++ ) { var child = enfants [ i ] ; if ( child . nodeType == 3 ) s += child . data ; else s += getCellText ( child ) ; } return s . toLowerCase ( ) ; } 
function setFilterGrid ( id , ref_row ) { if ( typeof window === 'undefined' || typeof document === 'undefined' ) return ; var tbl = document . getElementById ( id ) ; if ( tbl && tbl . nodeName . toLowerCase ( ) === "table" ) { TblId . push ( id ) ; ref_row = ref_row === undefined ? StartRow . push ( 2 ) : StartRow . push ( ref_row + 2 ) ; 
function Filter ( e ) { if ( typeof document === 'undefined' ) return ; var id = e . target . getAttribute ( "id" ) . split ( "_" ) [ 1 ] ; var SearchFlt = getFilters ( id ) ; var t = document . getElementById ( id ) ; var SearchArgs = [ ] ; var ncells = getCellsNb ( id ) ; for ( var i in SearchFlt ) { SearchArgs . push ( document . getElementById ( SearchFlt [ i ] ) . value . toLowerCase ( ) ) ; } var start_row = getStartRow ( id ) ; var row = t . getElementsByTagName ( "tr" ) ; for ( var k = start_row ; k < row . length ; k ++ ) { if ( row [ k ] . style . display === "none" ) row [ k ] . style . display = "" ; var cell = getChildElms ( row [ k ] ) . childNodes ; var nchilds = cell . length ; var isRowValid = true ; if ( nchilds === ncells ) { 
function setAppConsts ( ) { var mergedConstants = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : ( 0 , _seamlessImmutable2 . default ) ( appConsts ) ; 
function splitTo ( ) { let to = arguments . length <= 0 || arguments [ 0 ] === undefined ? '' : arguments [ 0 ] ; if ( / # / . test ( to ) ) { return to . split ( '#' ) ; } return [ ] ; } 
function parseArgs ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } const l = args . length ; const last = args [ l - 1 ] ; let cb , opts , paths ; if ( _lodash2 . default . isFunction ( last ) ) { cb = last ; args . pop ( ) ; 
function ( cb ) { fse . readFile ( systemsJsonPath , 'utf8' , function ( err , data ) { if ( err ) { if ( err . code !== 'ENOENT' ) { return cb ( err ) ; } fse . mkdirpSync ( sysRepoPath ) ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( blank , null , 2 ) , 'utf8' ) ; return git . createRepository ( sysRepoPath , 'system' , 'system@nfd.com' , function ( err_ ) { _systems = blank ; cb ( err_ ) ; } ) ; } _systems = JSON . parse ( data ) ; cb ( ) ; } ) ; } 
function ( user , namespace , name , repoName , repoPath , systemId , cb ) { if ( ! _systems [ systemId ] ) { _systems [ systemId ] = { name : name , namespace : namespace , repoName : repoName , repoPath : repoPath } ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( _systems , null , 2 ) , 'utf8' ) ; git . commit ( sysRepoPath , 'registered system: ' + repoPath , user . name , user . email , cb ) ; } else { cb ( null ) ; } } 
function ( user , systemId , cb ) { if ( ! _systems [ systemId ] ) { return cb ( ) ; } var newSystems = _ . clone ( _systems ) ; delete newSystems [ systemId ] ; fse . writeFileSync ( systemsJsonPath , JSON . stringify ( newSystems , null , 2 ) , 'utf8' ) ; _systems = newSystems ; git . commit ( sysRepoPath , 'unregistered system: ' + systemId , user . name , user . email , cb ) ; } 
function ( identifier ) { identifier = identifier . replace ( / [.+] / g , function ( match ) { return '\\' + match ; } ) ; var re = new RegExp ( '^' + identifier + '.*' , [ 'i' ] ) ; var systemId ; systemId = _ . find ( _ . keys ( _systems ) , function ( system ) { return system === identifier ; } ) ; if ( ! systemId ) { systemId = _ . find ( _ . keys ( _systems ) , function ( system ) { return re . test ( system ) ; } ) ; } if ( ! systemId ) { systemId = _ . find ( _ . keys ( _systems ) , function ( system ) { return re . test ( _systems [ system ] . name ) ; } ) ; } return systemId ; } 
function ( ) { var domWrapper ; this . _children = [ ] ; this . _createRootHtml ( ) ; domWrapper = utils . html . parseHTML ( this . html ) ; if ( domWrapper . childNodes . length > 1 ) { throw new Error ( "Component should have only one root element" ) ; } this . root = domWrapper . firstChild ; this . processInstance ( ) ; } 
function ( ) { var i , elements , element , value ; if ( this . _root ) { ( this . $meta . domProcessors || [ ] ) . forEach ( function ( processor ) { elements = this . _root . querySelectorAll ( "[" + processor . attribute + "]" ) ; for ( i = 0 ; i < elements . length ; i ++ ) { element = elements [ i ] ; value = element . getAttribute ( processor . attribute ) ; processor . process ( this , element , value ) ; } } , this ) ; } } 
function ( child ) { this . _validateChild ( child ) ; if ( child . parent ) { child . parent . remove ( child ) ; } child . parent = this ; this . _children . push ( child ) ; this . root . appendChild ( child . root ) ; if ( this . __fastinject__ ) { this . __fastinject__ ( child ) ; } 
function ( child ) { var index = this . _children . indexOf ( child ) ; if ( index !== - 1 ) { this . _children . splice ( index , 1 ) ; child . root . parentNode . removeChild ( child . root ) ; child . destroy ( ) ; } } 
function ( child , element , root ) { this . _children . push ( child ) ; ( root || this . root ) . insertBefore ( child . root , element ) ; ( root || this . root ) . removeChild ( element ) ; } 
function ( repoPath , doc , done ) { generify ( path . join ( __dirname , 'template' ) , repoPath , { name : doc . name , namespace : doc . namespace , id : doc . id } , done ) ; } 
function ( repoPath ) { var sys ; if ( fse . existsSync ( path . join ( repoPath , 'system.js' ) ) ) { 
function ( user , systemId , entryType , details , cb ) { var file = path . join ( options . timelinesRoot , findSystem ( systemId ) ) ; if ( typeof details === 'function' ) { cb = details ; details = { } ; } else if ( ! details ) { details = { } ; } var entry = { v : 0 , user : user , ts : new Date ( ) , type : entryType , details : details } ; fs . writeFile ( file , JSON . stringify ( entry ) + '\n' , { flag : 'a' } , function ( ) { 
function ( user , systemId , message , cb ) { logger . info ( 'committing revision: ' + systemId + ', ' + message ) ; var repoPath = _meta . repoPath ( systemId ) ; git . commit ( repoPath , message , user . name , user . email , cb ) ; } 
function ( user , namespace , name , cwd , cb ) { var repoName = name ; var doc = _ . extend ( { } , blank ) ; var repoPath = path . join ( cwd , repoName ) ; doc . name = name ; doc . namespace = namespace ; doc . id = uuid . v4 ( ) ; if ( ! fse . existsSync ( repoPath ) ) { fse . mkdirpSync ( repoPath ) ; initNscaleFiles ( repoPath , doc , function ( ) { git . createRepository ( repoPath , user . name , user . email , function ( err ) { if ( err ) { return cb ( err ) ; } _meta . register ( user , namespace , name , repoName , cwd + '/' + repoName , doc . id , function ( err ) { writeTimeline ( user , doc . id , 'create' , 'system created' , function ( ) { 
function ( user , path_ , cwd , cb ) { var repoPath = path . resolve ( cwd , path_ ) ; var sys ; var validationError = validateSystem ( repoPath ) ; if ( validationError ) { return cb ( validationError ) ; } sys = require ( repoPath + '/system.js' ) ; delete require . cache [ repoPath + '/system.js' ] ; _meta . register ( user , sys . namespace , sys . name , path . basename ( repoPath ) , repoPath , sys . id , function ( err ) { writeTimeline ( user , sys . id , 'link' , 'system linked' , function ( ) { cb ( err , { id : sys . id , err : err } ) ; } ) ; } ) ; } 
function ( user , systemId , cb ) { writeTimeline ( user , systemId , 'system unlinked' , function ( ) { 
function ( systemId , fileName , contents , cb ) { var repoPath = _meta . repoPath ( systemId ) ; fse . writeFile ( path . join ( repoPath , fileName ) , contents , 'utf8' , cb ) ; } 
function ( systemId , target , cb ) { listRevisions ( systemId , function ( err , revs ) { if ( err ) { return cb ( err ) ; } getRevision ( systemId , revs [ 0 ] . id , target , cb ) ; } ) ; } 
function ( systemId , cb ) { listRevisions ( systemId , function ( err , revs ) { cb ( err , revs && revs [ 0 ] && revs [ 0 ] . id ) ; } ) ; } 
function ( systemId , cb ) { listRevisions ( systemId , function ( err , revs ) { if ( revs [ 0 ] . id === EDITS ) { cb ( err , revs && revs [ 1 ] && revs [ 1 ] . id ) ; } else { cb ( err , revs && revs [ 0 ] && revs [ 0 ] . id ) ; } } ) ; } 
function ( systemId , revisionId , target , cb ) { var repoPath = _meta . repoPath ( systemId ) ; git . getFileRevision ( repoPath , revisionId , target + '.json' , function ( err , rev ) { if ( err ) { return cb ( err ) ; } var s ; try { s = JSON . parse ( rev ) ; } catch ( e ) { return cb ( new Error ( 'invalid system definition: ' + e . message ) , null ) ; } cb ( err , s ) ; } ) ; } 
function ( systemId , revisionId , target , cb ) { if ( revisionId === EDITS ) { _getOnDiskVersion ( systemId , revisionId , target , cb ) ; } else { findRevision ( systemId , revisionId , function ( err , rev ) { if ( err ) { return cb ( err ) ; } if ( rev === EDITS ) { _getOnDiskVersion ( systemId , revisionId , target , cb ) ; } else { _getRevision ( systemId , rev , target , cb ) ; } } ) ; } } 
function ( user , systemId , revisionId , env , cb ) { var repoPath = _meta . repoPath ( systemId ) ; var removeTag ; var addTag ; var revId ; getComittedHeadRevisionId ( systemId , function ( err , comittedHeadId ) { if ( revisionId === EDITS ) { removeTag = baseTag + env ; addTag = editsTag + env ; revId = comittedHeadId ; } else { addTag = baseTag + env ; removeTag = editsTag + env ; revId = revisionId ; } ngit . Repository . open ( repoPath , function ( err , repo ) { if ( err ) { return cb ( err ) ; } ngit . Reference . remove ( repo , removeTag ) ; repo . getCommit ( revId , function ( err , commit ) { if ( err ) { return cb ( err ) ; } var now = Math . round ( Date . now ( ) / 1000 ) ; var author = ngit . Signature . create ( user . name , user . email , now , 0 ) ; ngit . Reference . create ( repo , addTag , commit , 1 , author , 'Tagged ' + addTag ) . then ( function ( ) { writeTimeline ( user , systemId , 'deployed revision' , revisionId , function ( ) { cb ( ) ; } ) ; } ) . catch ( cb ) ; } ) ; } ) ; } ) ; } 
function ( systemId , env , cb ) { var repoPath = _meta . repoPath ( systemId ) ; var tagName = baseTag + env ; var editsTagName = editsTag + env ; ngit . Repository . open ( repoPath , function ( err , repo ) { if ( err ) { return cb ( err ) ; } ngit . Reference . nameToId ( repo , tagName , function ( err , head ) { if ( err && ( ! err . message || err . message . indexOf ( 'not found' ) === - 1 ) ) { return cb ( err ) ; } if ( head ) { cb ( null , head . toString ( ) ) ; } else { ngit . Reference . nameToId ( repo , editsTagName , function ( err ) { if ( err ) { return cb ( err ) ; } cb ( null , EDITS ) ; } ) ; } } ) ; } ) ; } 
function ( systemId , cb ) { var repoPath = _meta . repoPath ( systemId ) ; getDeployedTargets ( systemId , function ( err , targets ) { if ( err ) { return cb ( err ) ; } git . listRevisions ( repoPath , function ( err , revisions ) { revisions . forEach ( function ( revision ) { var deployedTo = _ . find ( targets , function ( target ) { return target . commit === revision . id ; } ) ; if ( deployedTo ) { revision . deployedTo = deployedTo . env ; } } ) ; cb ( err , revisions ) ; } ) ; } ) ; } 
function ( systemId , identifier , cb ) { var re = new RegExp ( '^' + identifier + '.*' , [ 'i' ] ) ; var revision ; if ( identifier !== 'head' && identifier !== 'latest' ) { listRevisions ( systemId , function ( err , revisions ) { revision = _ . find ( revisions , function ( revision ) { return re . test ( revision . id ) ; } ) ; if ( revision ) { cb ( err , revision . id ) ; } else { cb ( new Error ( 'revision not found' ) ) ; } } ) ; } else { getHeadRevisionId ( systemId , cb ) ; } } 
function ( app , parentAddon ) { this . _super . included ( app ) ; var target = ( parentAddon || app ) ; target . import ( target . bowerDirectory + '/emojify/dist/js/emojify.js' ) ; if ( _emojiConfig . mode === 'sprites' ) { var destSpriteDir = 'images/sprites' ; var spritePath = '/emojify/dist/images/sprites/' ; target . import ( target . bowerDirectory + spritePath + 'emojify.png' , { destDir : destSpriteDir } ) ; target . import ( target . bowerDirectory + spritePath + 'emojify@2x.png' , { destDir : destSpriteDir } ) ; } } 
function ( environment , baseConfig ) { if ( 'emoji' in baseConfig ) { if ( ! baseConfig . emoji ) { _emojiConfig = false ; } else { Object . keys ( _defaultEmojiConfig ) . forEach ( function ( key ) { _emojiConfig [ key ] = baseConfig . emoji . hasOwnProperty ( key ) ? baseConfig . emoji [ key ] : _defaultEmojiConfig [ key ] ; } ) ; } } else { _emojiConfig = _defaultEmojiConfig ; } if ( environment === 'development' ) { return { emoji : _emojiConfig , contentSecurityPolicy : { 'script-src' : "'self' 'unsafe-eval' 'unsafe-inline'" } } ; } return { emoji : _emojiConfig } ; } 
function ( ) { var emojiDataURIPath = path . join ( this . app . bowerDirectory , 'emojify/dist/css/data-uri/emojify.css' ) , emojiSpritesPath = path . join ( this . app . bowerDirectory , 'emojify/dist/css/sprites/emojify.css' ) ; if ( _emojiConfig . mode === 'data-uri' ) { this . app . import ( emojiDataURIPath ) ; } else { this . app . import ( emojiSpritesPath ) ; } } 
function ( analyzed ) { var containers = analyzed . topology . containers ; var targets = [ ] ; _ . each ( containers , function ( c ) { if ( c . containerDefinitionId . indexOf ( '__proxy' ) === 0 ) { var cdef = _ . find ( analyzed . containerDefinitions , function ( cdef ) { return cdef . id === c . containerDefinitionId ; } ) ; targets . push ( { containerDef : cdef , container : c } ) ; } } ) ; return targets ; } 
function ( cls ) { if ( this . collection ) { return this . collection ; } cls = ( cls ) ? this . superclass ( cls ) : this ; while ( cls ) { if ( cls . collection ) { this . collection = cls . collection ; return cls . collection ; } } return false ; } 
function ( model , relation , options ) { var type = ! _ . isString ( relation . type ) ? relation . type : Backbone [ relation . type ] || this . getObjectByName ( relation . type ) ; if ( type && type . prototype instanceof Backbone . Relation ) { new type ( model , relation , options ) ; 
function ( modelType ) { _ . find ( this . _subModels , function ( subModelDef ) { return _ . find ( subModelDef . subModels || [ ] , function ( subModelTypeName , typeValue ) { var subModelType = this . getObjectByName ( subModelTypeName ) ; if ( modelType === subModelType ) { 
function ( relation ) { var exists = _ . any ( this . _reverseRelations , function ( rel ) { return _ . all ( relation || [ ] , function ( val , key ) { return val === rel [ key ] ; } ) ; } ) ; if ( ! exists && relation . model && relation . type ) { this . _reverseRelations . push ( relation ) ; this . _addRelation ( relation . model , relation ) ; this . retroFitRelation ( relation ) ; } } 
function ( relation ) { var exists = _ . any ( this . _orphanRelations , function ( rel ) { return _ . all ( relation || [ ] , function ( val , key ) { return val === rel [ key ] ; } ) ; } ) ; if ( ! exists && relation . model && relation . type ) { this . _orphanRelations . push ( relation ) ; } } 
function ( ) { 
function ( relation ) { var coll = this . getCollection ( relation . model , false ) ; coll && coll . each ( function ( model ) { if ( ! ( model instanceof relation . model ) ) { return ; } new relation . type ( model , relation ) ; } , this ) ; } 
function ( type , create ) { if ( type instanceof Backbone . RelationalModel ) { type = type . constructor ; } var rootModel = type ; while ( rootModel . _superModel ) { rootModel = rootModel . _superModel ; } var coll = _ . find ( this . _collections , function ( item ) { return item . model === rootModel ; } ) ; if ( ! coll && create !== false ) { coll = this . _createCollection ( rootModel ) ; } return coll ; } 
function ( name ) { var parts = name . split ( '.' ) , type = null ; _ . find ( this . _modelScopes , function ( scope ) { type = _ . reduce ( parts || [ ] , function ( memo , val ) { return memo ? memo [ val ] : undefined ; } , scope ) ; if ( type && type !== scope ) { return true ; } } , this ) ; return type ; } 
function ( type , item ) { var id = _ . isString ( item ) || _ . isNumber ( item ) ? item : null ; if ( id === null ) { if ( item instanceof Backbone . RelationalModel ) { id = item . id ; } else if ( _ . isObject ( item ) ) { id = item [ type . prototype . idAttribute ] ; } } 
function ( type , item ) { var id = this . resolveIdForItem ( type , item ) ; var coll = this . getCollection ( type ) ; 
function ( model ) { var coll = this . getCollection ( model ) ; if ( coll ) { var modelColl = model . collection ; coll . add ( model ) ; this . listenTo ( model , 'destroy' , this . unregister , this ) ; this . listenTo ( model , 'relational:unregister' , this . unregister , this ) ; model . collection = modelColl ; } } 
function ( model , id ) { var coll = this . getCollection ( model ) , duplicate = coll && coll . get ( id ) ; if ( duplicate && model !== duplicate ) { if ( Backbone . Relational . showWarnings && typeof console !== 'undefined' ) { console . warn ( 'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o' , duplicate , model ) ; } throw new Error ( "Cannot instantiate more than one Backbone.RelationalModel with the same id per type!" ) ; } } 
function ( model , collection , options ) { this . stopListening ( model ) ; var coll = this . getCollection ( model ) ; coll && coll . remove ( model , options ) ; } 
function ( ) { var i = this . instance , k = this . key , m = this . model , rm = this . relatedModel , warn = Backbone . Relational . showWarnings && typeof console !== 'undefined' ; if ( ! m || ! k || ! rm ) { warn && console . warn ( 'Relation=%o: missing model, key or relatedModel (%o, %o, %o).' , this , m , k , rm ) ; return false ; } 
function ( related ) { this . related = related ; this . instance . acquire ( ) ; this . instance . attributes [ this . key ] = related ; this . instance . release ( ) ; } 
function ( relation ) { return relation . instance instanceof this . relatedModel && this . reverseRelation . key === relation . key && this . key === relation . reverseRelation . key ; } 
function ( model ) { var reverseRelations = [ ] ; 
function ( ) { this . stopListening ( ) ; if ( this instanceof Backbone . HasOne ) { this . setRelated ( null ) ; } else if ( this instanceof Backbone . HasMany ) { this . setRelated ( this . _prepareCollection ( ) ) ; } _ . each ( this . getReverseRelations ( ) , function ( relation ) { relation . removeRelated ( this . instance ) ; } , this ) ; } 
function ( options ) { var related = null ; options = _ . defaults ( { parse : this . options . parse } , options ) ; if ( this . keyContents instanceof this . relatedModel ) { related = this . keyContents ; } else if ( this . keyContents || this . keyContents === 0 ) { 
function ( keyContents ) { this . keyContents = keyContents ; this . keyId = Backbone . Relational . store . resolveIdForItem ( this . relatedModel , this . keyContents ) ; } 
function ( model , attr , options ) { 
function ( model , coll , options ) { if ( ( this . keyId || this . keyId === 0 ) && model . id === this . keyId ) { 
function ( collection ) { if ( this . related ) { this . stopListening ( this . related ) ; } if ( ! collection || ! ( collection instanceof Backbone . Collection ) ) { var options = _ . isFunction ( this . options . collectionOptions ) ? this . options . collectionOptions ( this . instance ) : this . options . collectionOptions ; collection = new this . collectionType ( null , options ) ; } collection . model = this . relatedModel ; if ( this . options . collectionKey ) { var key = this . options . collectionKey === true ? this . options . reverseRelation . key : this . options . collectionKey ; if ( collection [ key ] && collection [ key ] !== this . instance ) { if ( Backbone . Relational . showWarnings && typeof console !== 'undefined' ) { console . warn ( 'Relation=%o; collectionKey=%s already exists on collection=%o' , this , key , this . options . collectionKey ) ; } } else if ( key ) { collection [ key ] = this . instance ; } } this . listenTo ( collection , 'relational:add' , this . handleAddition ) . listenTo ( collection , 'relational:remove' , this . handleRemoval ) . listenTo ( collection , 'relational:reset' , this . handleReset ) ; return collection ; } 
function ( options ) { var related = null ; options = _ . defaults ( { parse : this . options . parse } , options ) ; 
function ( keyContents ) { this . keyContents = keyContents instanceof Backbone . Collection ? keyContents : null ; this . keyIds = [ ] ; if ( ! this . keyContents && ( keyContents || keyContents === 0 ) ) { 
function ( model , attr , options ) { options = options ? _ . clone ( options ) : { } ; this . setKeyContents ( attr ) ; this . changed = false ; var related = this . findRelated ( options ) ; this . setRelated ( related ) ; if ( ! options . silent ) { var dit = this ; Backbone . Relational . eventQueue . add ( function ( ) { 
function ( model , coll , options ) { 
function ( eventName ) { if ( eventName . length > 5 && eventName . indexOf ( 'change' ) === 0 ) { var dit = this , args = arguments ; Backbone . Relational . eventQueue . add ( function ( ) { if ( ! dit . _isInitialized ) { return ; } 
function ( options ) { this . acquire ( ) ; 
function ( options ) { if ( this . _isInitialized && ! this . isLocked ( ) ) { _ . each ( this . _relations , function ( rel ) { 
function ( key , options , refresh ) { 
function ( options ) { 
function ( type , attributes ) { if ( type . _subModels && type . prototype . subModelTypeAttribute in attributes ) { var subModelTypeAttribute = attributes [ type . prototype . subModelTypeAttribute ] ; var subModelType = type . _subModels [ subModelTypeAttribute ] ; if ( subModelType ) { return subModelType ; } else { 
function ( attributes , options ) { options || ( options = { } ) ; var parsedAttributes = ( _ . isObject ( attributes ) && options . parse && this . prototype . parse ) ? this . prototype . parse ( _ . clone ( attributes ) ) : attributes ; 
function ( attributes , options ) { options || ( options = { } ) ; options . create = false ; return this . findOrCreate ( attributes , options ) ; } 
function XtallatX ( superClass ) { return class extends superClass { constructor ( ) { super ( ... arguments ) ; this . _evCount = { } ; } static get observedAttributes ( ) { return [ disabled ] ; } get disabled ( ) { return this . _disabled ; } set disabled ( val ) { this . attr ( disabled , val , '' ) ; } attr ( name , val , trueVal ) { const v = val ? 'set' : 'remove' ; * Turn number into string with even and odd values easy to query via css. * @param n */ to$ ( n ) { const mod = n % 2 ; return ( n - mod ) / 2 + '-' + mod ; } incAttr ( name ) { const ec = this . _evCount ; if ( name in ec ) { ec [ name ] ++ ; } else { ec [ name ] = 0 ; } this . attr ( 'data-' + name , this . to$ ( ec [ name ] ) ) ; } attributeChangedCallback ( name , oldVal , newVal ) { switch ( name ) { case disabled : this . _disabled = newVal !== null ; break ; } } de ( name , detail , asIs = false ) { const eventName = name + ( asIs ? '' : '-changed' ) ; const newEvent = new CustomEvent ( eventName , { detail : detail , bubbles : true , composed : false , } ) ; this . dispatchEvent ( newEvent ) ; this . incAttr ( eventName ) ; return newEvent ; } _upgradeProperties ( props ) { props . forEach ( prop => { if ( this . hasOwnProperty ( prop ) ) { let value = this [ prop ] ; delete this [ prop ] ; this [ prop ] = value ; } } ) ; } } ; } 
function ( re ) { var arr = [ ] , tag ; for ( tag in register ) { if ( re . test ( tag ) ) arr . push ( tag ) ; } return arr ; } 
function ( Class , tag ) { tag = tag . toLowerCase ( ) ; if ( ! ( tag in register ) ) { register [ Class ] = ( register [ Class ] || [ ] ) . concat ( tag ) ; register [ tag ] = ( register [ tag . toUpperCase ( ) ] = Class ) ; } } 
function normalizePath ( path ) { path = '/' + path path = resolve ( normalize ( path ) ) path = path . replace ( / (%[a-f0-9]{2}) / g , $1 => $1 . toUpperCase ( ) ) if ( path === '' ) path = '/' return path } 
function parseArgs ( ... args ) { const l = args . length const last = args [ l - 1 ] let cb , opts , paths if ( _ . isFunction ( last ) ) { cb = last args . pop ( ) ; 
function sort_numeric ( a , b ) { var aa = void 0 , bb = void 0 ; aa = parseFloat ( a [ 0 ] . replace ( / [^0-9.-] / g , '' ) ) ; if ( isNaN ( aa ) ) aa = 0 ; bb = parseFloat ( b [ 0 ] . replace ( / [^0-9.-] / g , '' ) ) ; if ( isNaN ( bb ) ) bb = 0 ; return aa - bb ; } 
function Bitmap ( imageOrUri ) { this . DisplayObject_constructor ( ) ; * The source image to display. This can be a CanvasImageSource * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image. * If the latter, a new Image instance with the URL as its src will be used. * @property image * @type CanvasImageSource | Object **/ if ( typeof imageOrUri == "string" ) { this . image = document . createElement ( "img" ) ; this . image . src = imageOrUri ; } else { this . image = imageOrUri ; } this . sourceRect = null ; * Docced in superclass. */ this . _webGLRenderStyle = createjs . DisplayObject . _StageGL_BITMAP ; } 
function BlurFilter ( blurX , blurY , quality ) { this . Filter_constructor ( ) ; * Horizontal blur radius in pixels * @property blurX * @default 0 * @type Number **/ this . _blurX = blurX ; this . _blurXTable = [ ] ; this . _blurY = blurY ; this . _blurYTable = [ ] ; this . _quality ; this . FRAG_SHADER_TEMPLATE = ( "uniform float xWeight[{{blurX}}];" + "uniform float yWeight[{{blurY}}];" + "uniform vec2 textureOffset;" + "void main(void) {" + "vec4 color = vec4(0.0);" + "float xAdj = ({{blurX}}.0-1.0)/2.0;" + "float yAdj = ({{blurY}}.0-1.0)/2.0;" + "vec2 sampleOffset;" + "for(int i=0; i<{{blurX}}; i++) {" + "for(int j=0; j<{{blurY}}; j++) {" + "sampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));" + "color += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);" + "}" + "}" + "gl_FragColor = color.rgba;" + "}" ) ; 
function convert_to_alloy_path ( resolved_path ) { var parsed_path = path . posix . parse ( resolved_path ) ; return path . posix . join ( parsed_path . dir , parsed_path . name ) ; } 
function load_as_file ( request , startpath ) { var module_path ; var resolved_path = path . posix . resolve ( startpath , request ) ; _ . includes ( registry . files , resolved_path ) && ( module_path = resolved_path ) ; if ( module_path ) { 
function load_as_directory ( request , startpath ) { var resolved_path = path . posix . resolve ( startpath , request ) ; var module_path = _ . find ( registry . directories , function ( item ) { return item . id === resolved_path ; } ) ; if ( module_path ) { return module_path . path ; } } 
function load_node_modules ( request , startpath ) { var resolved_path ; var nodepaths = node_modules_paths ( startpath ) ; _ . forEach ( nodepaths , function ( nodepath ) { resolved_path = load_as_file ( request , nodepath ) ; return ! resolved_path ; } ) ; if ( resolved_path ) { return resolved_path ; } _ . forEach ( nodepaths , function ( nodepath ) { resolved_path = load_as_directory ( request , nodepath ) ; return ! resolved_path ; } ) ; return resolved_path ; } 
function canonicalize ( value , stack ) { var canonicalizedObj ; var prop ; var type = getType ( value ) ; function withStack ( value , fn ) { stack . push ( value ) ; fn ( ) ; stack . pop ( ) ; } stack = stack || [ ] ; if ( stack . indexOf ( value ) !== - 1 ) { return '[Circular]' ; } switch ( type ) { case 'undefined' : case 'buffer' : case 'null' : canonicalizedObj = value ; break ; case 'array' : withStack ( value , function ( ) { canonicalizedObj = value . map ( function ( item ) { return canonicalize ( item , stack ) ; } ) ; } ) ; break ; case 'function' : for ( prop in value ) { canonicalizedObj = { } ; break ; } if ( ! canonicalizedObj ) { canonicalizedObj = emptyRepresentation ( value , type ) ; break ; } case 'object' : canonicalizedObj = canonicalizedObj || { } ; withStack ( value , function ( ) { Object . keys ( value ) . sort ( ) . forEach ( function ( key ) { canonicalizedObj [ key ] = canonicalize ( value [ key ] , stack ) ; } ) ; } ) ; break ; case 'date' : case 'number' : case 'regexp' : case 'boolean' : canonicalizedObj = value ; break ; default : canonicalizedObj = value . toString ( ) ; } return canonicalizedObj ; } 
function emptyRepresentation ( value , type ) { type = type || getType ( value ) ; switch ( type ) { case 'function' : return '[Function]' ; case 'object' : return '{}' ; case 'array' : return '[]' ; default : return value . toString ( ) ; } } 
function createDynodeOptions ( dynamoAsPromisedOptions , key , extraDynodeOptions ) { var dynodeOptions = _ . clone ( extraDynodeOptions || { } ) ; 
function ( doc , first , last ) { var f = doc . WordPos [ first ] ; var l ; if ( last == doc . WordPos . length - 1 ) 
function parseConditionals ( js ) { var lines = js . split ( '\n' ) , len = lines . length , buffer = true , browser = false , buf = [ ] , line , cond ; for ( var i = 0 ; i < len ; ++ i ) { line = lines [ i ] ; if ( / ^ *\/\/ *if *(node|browser) / gm . exec ( line ) ) { cond = RegExp . $1 ; buffer = browser = 'browser' == cond ; } else if ( / ^ *\/\/ *end / . test ( line ) ) { buffer = true ; browser = false ; } else if ( browser ) { buf . push ( line . replace ( / ^( *)\/\/ / , '$1' ) ) ; } else if ( buffer ) { buf . push ( line ) ; } } return buf . join ( '\n' ) ; } 
function compile ( ) { var buf = '' ; buf += '(function() {\n' ; buf += '\n// CommonJS require()\n\n' ; buf += browser . require + '\n\n' ; buf += 'require.modules = {};\n\n' ; buf += 'require.resolve = ' + browser . resolve + ';\n\n' ; buf += 'require.register = ' + browser . register + ';\n\n' ; buf += 'require.relative = ' + browser . relative + ';\n\n' ; args . forEach ( function ( file ) { var js = files [ file ] ; file = file . replace ( 'lib/' , '' ) ; buf += '\nrequire.register("' + file + '", function(module, exports, require){\n' ; buf += js ; buf += '\n}); // module: ' + file + '\n' ; } ) ; buf += '\nwindow.kiwi = require("kiwi");\n' ; buf += '})();\n' ; fs . writeFile ( 'kiwi.js' , buf , function ( err ) { if ( err ) throw err ; console . log ( ' \033[90m create : \033[0m\033[36m%s\033[0m' , 'kiwi.js' ) ; console . log ( ) ; } ) ; } 
function splitDots ( list ) { var result = [ ] ; list . forEach ( function ( x ) { if ( typeof x === 'string' ) { x . split ( '.' ) . forEach ( function ( part ) { result . push ( part ) ; } ) ; } else { result . push ( x ) ; } } ) ; return result ; } 
function fp ( ) { var args = Array . prototype . slice . call ( arguments , 0 ) ; if ( args . length ) { if ( ! args . every ( isStringOrFunction ) ) { var signature = args . map ( humanizeArgument ) . join ( '\n\t' ) ; throw new Error ( 'Invalid arguments to functional pipeline - not a string or function\n\t' + signature ) ; } var fns = splitDots ( args ) ; return function ( d ) { var originalObject = d ; fns . forEach ( function ( fn ) { if ( typeof fn === 'string' ) { if ( typeof d [ fn ] === 'function' ) { d = d [ fn ] . call ( d , d ) ; } else if ( typeof d [ fn ] !== 'undefined' ) { d = d [ fn ] ; } else { var signature = args . map ( humanizeArgument ) . join ( '\n\t' ) ; throw new Error ( 'Cannot use property ' + fn + ' from object ' + JSON . stringify ( d , null , 2 ) + '\npipeline\n\t' + signature + '\noriginal object\n' + JSON . stringify ( originalObject , null , 2 ) ) ; } } else if ( typeof fn === 'function' ) { d = fn ( d ) ; } else { throw new Error ( 'Cannot apply ' + JSON . stringify ( fn , null , 2 ) + ' to value ' + d + ' not a property name or a function' ) ; } } ) ; return d ; } ; } } 
function VATPeriod ( effectiveFrom , superReduced , reduced , standard , parking ) { this . _effectiveFrom = effectiveFrom ; this . _superReduced = superReduced ; this . _reduced = reduced ; this . _standard = standard ; this . _parking = parking ; } 
function loadFilters ( loadedFiles ) { loadedFiles = loadedFiles || frame . files . requireDir ( __dirname + '/filters/' ) ; for ( var file in loadedFiles ) { var fileFilters = loadedFiles [ file ] ; for ( var filter in fileFilters ) { filters [ filter ] = fileFilters [ filter ] ; } } } 
function ( tickRate ) { events . EventEmitter . call ( this ) ; 
function onProcessed ( err , processed ) { if ( err ) return callback ( err ) ; _this . _tokenize ( processed , onTokenized ) ; } 
function onTokenized ( err , tokenized ) { if ( err ) return callback ( err ) ; tokenized . compile ( _this , onCompiled ) ; } 
function onCompiled ( err , compiled ) { if ( err ) return callback ( err ) ; var func ; try { func = new Function ( "$template" , "$tools" , "_" , "$data" , "$helpers" , "$callback" , compiled ) ; } catch ( err ) { return callback ( err ) ; } func . $helpers = _this . helpers ; callback ( null , func ) ; } 
function BaseToken ( root , parent , options ) { this . parent = parent ; this . children = [ ] ; this . tag = null ; this . tagType = null ; this . options = options ; this . root = root ; } 
function LiteralToken ( literal , root , parent , options ) { LiteralToken . _superclass . call ( this , root , parent , options ) ; this . literal = literal ; } 
function BlockToken ( tag , tagType , root , parent , children , options ) { BlockToken . _superclass . call ( this , root , parent , options ) ; this . tag = tag ; this . tagType = tagType ; if ( ! children ) children = [ ] ; this . children = children ; this . intermediate = [ ] ; } 
function IntermediateToken ( tag , tagType , root , parent , children , options ) { IntermediateToken . _superclass . call ( this , tag , tagType , root , parent , children , options ) ; } 
function createIfCondition ( condition , strict ) { var compiled ; if ( strict ) { compiled = 'if(' + condition + ')' ; } else { compiled = 'try {' + '__tmp = ' + condition + '} catch(__err) {' + 'if(__err instanceof ReferenceError) {' + '__tmp = false;' + '} else {' + 'throw __err;' + '}' + '}' + 'if(__tmp)' ; } return compiled ; } 
function VATCountry ( name , code , countryCode , periods , date ) { this . _name = name ; this . _code = code ; this . _countryCode = countryCode ; this . _periods = periods ; this . setDate ( date ) ; } 
function compileTokenArray ( tokens , compiler , callback ) { var acc = [ ] ; var index = 0 ; function compileOne ( token , next ) { token . compile ( compiler , function onCompiled ( err , compiled ) { if ( err ) return next ( err ) ; acc . push ( compiled ) ; next ( null , compiled ) ; } ) ; index ++ ; } function done ( err ) { if ( err ) return callback ( err ) ; callback ( null , acc ) ; } asyncForEach ( tokens , compileOne , done ) ; } 
function Template ( str , options ) { 
function ( fn , rate ) { var allowed = true ; return function ( ) { if ( allowed ) { allowed = false ; fn . apply ( null , [ ] . slice . call ( arguments , 0 ) ) ; setTimeout ( function ( ) { allowed = true ; } , rate ) ; } } } 
function get_data ( callback ) { var data ; try { data = program . data ? JSON . parse ( program . data ) : { } ; callback ( data ) ; } catch ( err ) { fs . readFile ( program . data , function ( err , str ) { str = '' + str ; if ( ! err ) { try { data = JSON . parse ( str ) ; callback ( data ) ; } catch ( err ) { data = eval ( str ) ; callback ( data ) ; } } } ) ; } return data ; } 
function ispunct ( ch ) { ch = ch . charCodeAt ( 0 ) ; return ( ch >= 0x21 && ch <= 0x2F ) || ( ch >= 0x3a && ch <= 0x40 ) || ( ch >= 0x5B && ch <= 0x60 ) || ( ch >= 0x7F ) ; } 
function ( str ) { var inhash = 0 ; var charcount = 0 ; var char ; if ( str . length == 0 ) return 1 ; 
function secureWebhookEndpoints ( ) { var authenticationMiddleware = require ( __dirname + '/middleware/slack_authentication.js' ) ; 
function postForm ( url , formData , cb , multipart ) { cb = cb || noop ; bot . logger . info ( '** API CALL: ' + url ) ; var params = { url : url , headers : { 'User-Agent' : bot . userAgent ( ) , } } ; if ( multipart === true ) { params . formData = formData ; } else { params . form = formData ; } request . post ( params , function ( error , response , body ) { bot . logger . debug ( 'Got response' , error , body ) ; if ( error ) { return cb ( error ) ; } if ( response . statusCode == 200 ) { var json ; try { json = JSON . parse ( body ) ; } catch ( parseError ) { return cb ( parseError ) ; } return cb ( ( json . ok ? null : json . error ) , json ) ; } else if ( response . statusCode == 429 ) { return cb ( new Error ( 'Rate limit exceeded' ) ) ; } else { return cb ( new Error ( 'Invalid response' ) ) ; } } ) ; } 
function Botkit ( configuration ) { var botkit = { events : { } , * conversation will be not be ended and should be taken care by callback */ this . timeOutHandler = null ; this . collectResponse = function ( key , value ) { this . responses [ key ] = value ; } ; this . capture = function ( response , cb ) { var that = this ; var capture_key = this . sent [ this . sent . length - 1 ] . text ; botkit . middleware . capture . run ( that . task . bot , response , that , function ( err , bot , response , convo ) { if ( response . text ) { response . text = response . text . trim ( ) ; } else { response . text = '' ; } if ( that . capture_options . key != undefined ) { capture_key = that . capture_options . key ; } * active includes both ACTIVE and ENDING * in order to allow the timeout end scripts to play out **/ this . isActive = function ( ) { return ( this . status == 'active' || this . status == 'ending' ) ; } ; this . deactivate = function ( ) { this . status = 'inactive' ; } ; this . say = function ( message ) { this . addMessage ( message ) ; } ; this . sayFirst = function ( message ) { if ( typeof ( message ) == 'string' ) { message = { text : message , channel : this . source_message . channel , } ; } else { message . channel = this . source_message . channel ; } this . messages . unshift ( message ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for' , event ) ; var events = event . split ( / \, / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e ++ ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res === false ) { return ; } } } else { } } ; * hears_regexp - default string matcher uses regular expressions * * @param {array} tests patterns to match * @param {object} message message object with various fields * @return {boolean} whether or not a pattern was matched */ botkit . hears_regexp = function ( tests , message ) { for ( var t = 0 ; t < tests . length ; t ++ ) { if ( message . text ) { * changeEars - change the default matching function * * @param {function} new_test a function that accepts (tests, message) and returns a boolean */ botkit . changeEars = function ( new_test ) { botkit . hears_test = new_test ; } ; botkit . hears = function ( keywords , events , middleware_or_cb , cb ) { * Define a default worker bot. This function should be customized outside * of Botkit and passed in as a parameter by the developer **/ botkit . worker = function ( botkit , config ) { this . botkit = botkit ; this . config = config ; this . say = function ( message , cb ) { botkit . logger . debug ( 'SAY:' , message ) ; } ; this . replyWithQuestion = function ( message , question , cb ) { botkit . startConversation ( message , function ( convo ) { convo . ask ( question , cb ) ; } ) ; } ; this . reply = function ( src , resp ) { botkit . logger . debug ( 'REPLY:' , resp ) ; } ; this . findConversation = function ( message , cb ) { botkit . logger . debug ( 'DEFAULT FIND CONVO' ) ; cb ( null ) ; } ; } ; botkit . userAgent = function ( ) { if ( ! botkit . my_user_agent ) { * for node's http module. Developers can specify a hostname or IP * address to override this. **/ if ( ! botkit . config . hostname ) { botkit . config . hostname = '0.0.0.0' ; } if ( ! configuration . logLevel ) { if ( configuration . debug ) { configuration . logLevel = 'debug' ; } else if ( configuration . log === false ) { configuration . logLevel = 'error' ; } else { configuration . logLevel = 'info' ; } } if ( configuration . logger ) { botkit . logger = configuration . logger ; } else { botkit . logger = logging ( 'abbott-framework:botkit:CoreBot' ) ; } // botkit.log = function () { // botkit.logger.info.apply(botkit.log, arguments); // }; // Object.keys(LogLevels).forEach(function (level) { // botkit.log[level] = botkit.logger.log.bind(botkit.logger, level); // }); // botkit.debug = botkit.logger.debug; // if (!botkit.config.disable_startup_messages) { // console.log('Initializing Botkit v' + botkit.version()); // } if ( configuration . storage ) { if ( configuration . storage . teams && configuration . storage . teams . get && configuration . storage . teams . save && configuration . storage . users && configuration . storage . users . get && configuration . storage . users . save && configuration . storage . channels && configuration . storage . channels . get && configuration . storage . channels . save ) { botkit . logger . debug ( '** Using custom storage system.' ) ; botkit . storage = configuration . storage ; } else { throw new Error ( 'Storage object does not have all required methods!' ) ; } // } else if (configuration.json_file_store) { // botkit.logger.debug('** Using simple storage. Saving data to ' + configuration.json_file_store); // botkit.storage = simple_storage({ // path: configuration.json_file_store // }); } else { botkit . logger . debug ( '** No persistent storage method specified! Data may be lost when process shuts down.' ) ; } 
function Conversation ( task , message ) { this . messages = [ ] ; this . sent = [ ] ; this . transcript = [ ] ; this . context = { user : message . user , channel : message . channel , bot : task . bot , } ; this . events = { } ; this . vars = { } ; this . threads = { } ; this . thread = null ; this . status = 'new' ; this . task = task ; this . source_message = message ; this . handler = null ; this . responses = { } ; this . capture_options = { } ; this . startTime = new Date ( ) ; this . lastActive = new Date ( ) ; this . timeOutHandler = null ; this . collectResponse = function ( key , value ) { this . responses [ key ] = value ; } ; this . capture = function ( response , cb ) { var that = this ; var capture_key = this . sent [ this . sent . length - 1 ] . text ; botkit . middleware . capture . run ( that . task . bot , response , that , function ( err , bot , response , convo ) { if ( response . text ) { response . text = response . text . trim ( ) ; } else { response . text = '' ; } if ( that . capture_options . key != undefined ) { capture_key = that . capture_options . key ; } * active includes both ACTIVE and ENDING * in order to allow the timeout end scripts to play out **/ this . isActive = function ( ) { return ( this . status == 'active' || this . status == 'ending' ) ; } ; this . deactivate = function ( ) { this . status = 'inactive' ; } ; this . say = function ( message ) { this . addMessage ( message ) ; } ; this . sayFirst = function ( message ) { if ( typeof ( message ) == 'string' ) { message = { text : message , channel : this . source_message . channel , } ; } else { message . channel = this . source_message . channel ; } this . messages . unshift ( message ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for' , event ) ; var events = event . split ( / \, / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e ++ ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res === false ) { return ; } } } else { } } ; 
function Task ( bot , message , botkit ) { this . convos = [ ] ; this . botkit = botkit ; this . bot = bot ; this . events = { } ; this . source_message = message ; this . status = 'active' ; this . startTime = new Date ( ) ; this . isActive = function ( ) { return this . status == 'active' ; } ; this . createConversation = function ( message ) { var convo = new Conversation ( this , message ) ; convo . id = botkit . convoCount ++ ; this . convos . push ( convo ) ; return convo ; } ; this . startConversation = function ( message ) { var convo = this . createConversation ( message ) ; botkit . logger . debug ( '> [Start] ' , convo . id , ' Conversation with ' , message . user , 'in' , message . channel ) ; convo . activate ( ) ; return convo ; } ; this . conversationEnded = function ( convo ) { botkit . logger . debug ( '> [End] ' , convo . id , ' Conversation with ' , convo . source_message . user , 'in' , convo . source_message . channel ) ; this . trigger ( 'conversationEnded' , [ convo ] ) ; this . botkit . trigger ( 'conversationEnded' , [ bot , convo ] ) ; convo . trigger ( 'end' , [ convo ] ) ; var actives = 0 ; for ( var c = 0 ; c < this . convos . length ; c ++ ) { if ( this . convos [ c ] . isActive ( ) ) { actives ++ ; } } if ( actives == 0 ) { this . taskEnded ( ) ; } } ; this . endImmediately = function ( reason ) { for ( var c = 0 ; c < this . convos . length ; c ++ ) { if ( this . convos [ c ] . isActive ( ) ) { this . convos [ c ] . stop ( reason || 'stopped' ) ; } } } ; this . taskEnded = function ( ) { botkit . logger . debug ( '[End] ' , this . id , ' Task for ' , this . source_message . user , 'in' , this . source_message . channel ) ; this . status = 'completed' ; this . trigger ( 'end' , [ this ] ) ; } ; this . on = function ( event , cb ) { botkit . logger . debug ( 'Setting up a handler for' , event ) ; var events = event . split ( / \, / g ) ; for ( var e in events ) { if ( ! this . events [ events [ e ] ] ) { this . events [ events [ e ] ] = [ ] ; } this . events [ events [ e ] ] . push ( cb ) ; } return this ; } ; this . trigger = function ( event , data ) { if ( this . events [ event ] ) { for ( var e = 0 ; e < this . events [ event ] . length ; e ++ ) { var res = this . events [ event ] [ e ] . apply ( this , data ) ; if ( res === false ) { return ; } } } } ; this . getResponsesByUser = function ( ) { var users = { } ; 
function verifyRequest ( req , res , buf , encoding ) { var expected = req . headers [ 'x-hub-signature' ] ; var calculated = getSignature ( buf ) ; if ( expected !== calculated ) { throw new Error ( 'Invalid signature on incoming request' ) ; } else { 
function Route ( pattern , Handler , observe , router ) { this . pattern = pattern ; this . map = parsePattern ( pattern ) ; this . regExp = patternToRegExp ( pattern ) ; this . strictRegExp = patternToStrictRegExp ( pattern ) ; this . isComponent = ! ! Handler . extend ; this . Handler = Handler ; this . observe = assign ( { qs : [ ] , hash : [ ] , state : [ ] } , observe ) ; this . allObserved = this . observe . qs . concat ( this . observe . hash , this . observe . state ) ; this . router = router || { } ; this . view = null ; } 
function getCookie ( cookies , name ) { var match = String ( cookies ) . match ( new RegExp ( name + '=([^;]+)' ) ) ; if ( match ) { return match [ 1 ] ; } return false ; } 
function appendOptions ( options , fromOptions ) { function pushOption ( optionName , optionValue ) { var valueDefined = optionValue !== null && optionValue !== undefined ; if ( optionName . length === 1 ) { 
function request_kissmetrics_client ( pathname , query_params , callback ) { var query_string = [ '_k=' , this . key , '&' ] . join ( '' ) , uri , v ; query_params [ '_t' ] = ( query_params [ '_d' ] ? query_params [ '_t' ] : Date . now ( ) ) ; for ( var k in query_params ) { v = query_params [ k ] ; if ( query_string !== '' ) { query_string += '&' ; } query_string += [ k , v ] . join ( '=' ) ; } uri = encodeURI ( [ 'http' , ':' , '//' , this . host , ':' , this . port , pathname , '?' , query_string ] . join ( '' ) ) ; 
function set_kissmetrics_client ( person , properties , callback ) { var query_params = new Object ( properties ) ; query_params [ '_p' ] = person ; this . request ( '/s' , query_params , callback ) ; } 
function alias_kissmetrics_client ( person , aliases , callback ) { var aliases = ( Array . isArray ( aliases ) ? aliases : [ aliases ] ) , that = this ; async . forEach ( aliases , function ( alias , callback ) { var query_params = { } ; query_params [ '_p' ] = person ; query_params [ '_n' ] = alias ; that . request ( '/a' , query_params , callback ) ; } , callback ) ; } 
function record_kissmetrics_client ( ) { var args = Array . prototype . slice . call ( arguments ) , callback = args . pop ( ) , person = args . shift ( ) , event = args . shift ( ) , properties = args . shift ( ) || { } , query_params = new Object ( properties ) ; query_params [ '_p' ] = person ; query_params [ '_n' ] = event ; this . request ( '/e' , query_params , callback ) ; } 
function kissmetrics_client ( options ) { var options = options || { } ; this . host = options . host || DEFAULT_TRACKER_SERVER ; this . port = options . port || DEFAULT_TRACKER_PORT ; this . key = options . key ; } 
function notifyPatternObservers ( ractive , registeredKeypath , actualKeypath , isParentOfChangedKeypath , isTopLevelCall ) { var i , patternObserver , children , child , key , childActualKeypath , potentialWildcardMatches , cascade ; 
function getStarMap ( num ) { var ones = '' , max , binary , starMap , mapper , i ; if ( ! starMaps [ num ] ) { starMap = [ ] ; while ( ones . length < num ) { ones += 1 ; } max = parseInt ( ones , 2 ) ; mapper = function ( digit ) { return digit === '1' ; } ; for ( i = 0 ; i <= max ; i += 1 ) { binary = i . toString ( 2 ) ; while ( binary . length < num ) { binary = '0' + binary ; } starMap [ i ] = Array . prototype . map . call ( binary , mapper ) ; } starMaps [ num ] = starMap ; } return starMaps [ num ] ; } 
function ( keypath , root ) { var i = queue . length , animation ; while ( i -- ) { animation = queue [ i ] ; if ( animation . root === root && animation . keypath === keypath ) { animation . stop ( ) ; } } } 
function ( ) { if ( ! this . selfUpdating ) { this . deferred = true ; } var i = this . refs . length ; while ( i -- ) { this . refs [ i ] . update ( ) ; } if ( this . deferred ) { this . update ( ) ; this . deferred = false ; } } 
function ( ) { var i ; if ( this . custom ) { this . custom . teardown ( ) ; } else { this . node . removeEventListener ( this . name , genericHandler , false ) ; } i = this . proxies . length ; while ( i -- ) { this . proxies [ i ] . teardown ( ) ; } } 
function ( options ) { var easing ; this . duration = options . duration ; this . step = options . step ; this . complete = options . complete ; 
function getRefs ( token , refs ) { var i , list ; if ( token . t === types . REFERENCE ) { if ( refs . indexOf ( token . n ) === - 1 ) { refs . unshift ( token . n ) ; } } list = token . o || token . m ; if ( list ) { if ( isObject ( list ) ) { getRefs ( list , refs ) ; } else { i = list . length ; while ( i -- ) { getRefs ( list [ i ] , refs ) ; } } } if ( token . x ) { getRefs ( token . x , refs ) ; } if ( token . r ) { getRefs ( token . r , refs ) ; } if ( token . v ) { getRefs ( token . v , refs ) ; } } 
function assign ( object , source ) { for ( var i = 1 , c = arguments . length ; i < c ; i ++ ) { for ( var x in arguments [ i ] ) { if ( arguments [ i ] . hasOwnProperty ( x ) && arguments [ i ] [ x ] !== undefined ) { object [ x ] = arguments [ i ] [ x ] ; } } } return object ; } 
function joinPaths ( parts ) { return Array . prototype . slice . call ( arguments ) . join ( '/' ) . replace ( / \/+ / g , '/' ) ; } 
function parents ( el , name ) { while ( el && el . nodeName . toLowerCase ( ) !== name ) { el = el . parentNode ; } return el && el . nodeName . toLowerCase ( ) === name ? el : null ; } 
function parseHash ( hash , keys ) { try { var parsed = compact ( JSON . parse ( decodeURIComponent ( hash . substr ( 2 ) ) ) ) ; return keys ? pick ( parsed , keys ) : parsed ; } catch ( e ) { return { } ; } } 
function parseUri ( uri ) { var parts = uri . match ( / ^(?:([\w+.-]+):\/\/([^/]+))?([^?#]*)?(\?[^#]*)?(#.*)? / ) ; return { protocol : parts [ 1 ] || '' , host : parts [ 2 ] || '' , path : parts [ 3 ] || '' , qs : parts [ 4 ] || '' , hash : parts [ 5 ] || '' } ; } 
function parseQS ( qs , keys ) { var index = qs . indexOf ( '?' ) ; var parsed = { } ; if ( index !== - 1 ) { var pairs = qs . substr ( index + 1 ) . split ( '&' ) ; var pair = [ ] ; for ( var i = 0 , c = pairs . length ; i < c ; i ++ ) { pair = pairs [ i ] . split ( '=' ) ; if ( ( ! isEmpty ( pair [ 1 ] ) ) && ( ! isEmpty ( parseJSON ( pair [ 1 ] ) ) ) ) { parsed [ decodeForm ( decodeURIComponent ( pair [ 0 ] ) ) ] = parseJSON ( decodeForm ( decodeURIComponent ( pair [ 1 ] ) ) ) ; } } } return keys ? pick ( parsed , keys ) : parsed ; } 
function pick ( object , keys ) { var data = { } ; if ( typeof keys === 'function' ) { for ( var x in object ) { if ( object . hasOwnProperty ( x ) && keys ( object [ x ] , x ) ) { data [ x ] = object [ x ] ; } } } else { for ( var i = 0 , c = keys . length ; i < c ; i ++ ) { data [ keys [ i ] ] = object [ keys [ i ] ] ; } } return data ; } 
function scrollTo ( id ) { var el = document . getElementById ( id ) ; if ( el ) { window . scrollBy ( 0 , el . getBoundingClientRect ( ) . top ) ; } else { window . scrollTo ( 0 , 0 ) ; } } 
function stringifyHash ( data ) { data = compact ( data ) ; return ! isEmpty ( data ) ? '#!' + encodeURIComponent ( stringify ( data ) ) : '' ; } 
function stringifyQS ( data ) { var qs = '' ; for ( var x in data ) { if ( data . hasOwnProperty ( x ) && ! isEmpty ( data [ x ] ) ) { qs += '&' + encodeURIComponent ( x ) + '=' + encodeURIComponent ( stringify ( data [ x ] ) ) ; } } return qs ? '?' + qs . substr ( 1 ) : '' ; } 
function Router ( options ) { this . globals = options . globals || [ ] ; this . basePath = options . basePath || '' ; this . el = options . el ; this . data = options . data || function ( ) { return { } ; } ; this . history = options . history || history ; this . strictMode = ! ! options . strictMode ; this . reloadOnClick = options . reloadOnClick ; this . linksWatcher = null ; this . stateWatcher = null ; this . route = null ; this . routes = [ ] ; this . uri = { } ; } 
function shouldDispatch ( oldUri , newUri , route ) { return oldUri . path !== newUri . path || oldUri . qs !== newUri . qs || ( decodeURIComponent ( oldUri . hash ) !== decodeURIComponent ( newUri . hash ) && ( ! route || route . observe . hash . length ) ) ; } 
function DockerCmdManager ( dockerdescPath ) { dockerdescPath = dockerdescPath || './dockerdesc.json' ; if ( ! fs . existsSync ( dockerdescPath ) ) { throw new Error ( util . format ( 'The path "%s" does not exists.' , dockerdescPath ) ) ; } this . dockerdescDir = path . dirname ( dockerdescPath ) ; var dockerdescPathStat = fs . statSync ( dockerdescPath ) ; if ( dockerdescPathStat . isDirectory ( ) ) { this . dockerdescDir = dockerdescPath ; dockerdescPath = path . join ( dockerdescPath , 'dockerdesc.json' ) ; } var dockerdescContent = fs . readFileSync ( dockerdescPath ) ; try { this . dockerdesc = JSON . parse ( dockerdescContent ) ; } catch ( err ) { throw new Error ( 'Problem in the dockerdesc.json file format.\n' + err . stack ) ; } } 
function dd ( object , _context , _key , _root , _rootPath ) { _root = _root || object ; _rootPath = _rootPath || [ ] ; var drill = function ( key ) { var nextObject = ( object && object . hasOwnProperty ( key ) && object [ key ] || undefined ) ; return dd ( nextObject , object , key , _root , _rootPath . concat ( key ) ) ; } ; drill . val = object ; drill . exists = object !== undefined ; drill . set = function ( value ) { if ( _rootPath . length === 0 ) { return ; } var contextIterator = _root ; for ( var depth = 0 ; depth < _rootPath . length ; depth ++ ) { var key = _rootPath [ depth ] ; var isFinalDepth = ( depth === _rootPath . length - 1 ) ; if ( ! isFinalDepth ) { contextIterator [ key ] = ( contextIterator . hasOwnProperty ( key ) && typeof contextIterator [ key ] === 'object' ? contextIterator [ key ] : { } ) ; contextIterator = contextIterator [ key ] ; } else { _context = contextIterator ; _key = key ; } } _context [ _key ] = value ; drill . val = value ; drill . exists = value !== undefined ; return value ; } ; drill . update = function ( value ) { if ( drill . exists ) { _context [ _key ] = value ; drill . val = value ; return value ; } } ; drill . invoke = isFunction ( object ) ? Function . prototype . bind . call ( object , _context ) : function ( ) { } ; return drill ; } 
function ( option , req , res ) { this . params = { 'req' : req , 'res' : res } ; this . option = option ; this . features = { } ; 
function printTasks ( tasks , verbose ) { tasks = tasks . filterHidden ( verbose ) . sort ( ) ; var results = [ 'Usage: gulp [task] [task2] ...' , '' , 'Tasks: ' ] ; var fieldTaskLen = tasks . getLongestNameLength ( ) ; tasks . forEach ( function ( task ) { var comment = task . comment || { } ; var lines = comment . lines || [ ] ; results . push ( formatColumn ( task . name , fieldTaskLen ) + ( lines [ 0 ] || '' ) ) ; for ( var i = 1 ; i < lines . length ; i ++ ) { results . push ( formatColumn ( '' , fieldTaskLen ) + ' ' + lines [ i ] ) ; } } ) ; return results . join ( '\n' ) ; } 
function formatColumn ( text , width , offsetLeft , offsetRight ) { offsetLeft = undefined !== offsetLeft ? offsetLeft : 3 ; offsetRight = undefined !== offsetRight ? offsetRight : 3 ; return new Array ( offsetLeft + 1 ) . join ( ' ' ) + text + new Array ( Math . max ( width - text . length , 0 ) + 1 ) . join ( ' ' ) + new Array ( offsetRight + 1 ) . join ( ' ' ) ; } 
function inheritGulp ( ) { function TaskDoc ( ) { this . taskList = new TaskList ( ) ; gulp . Gulp . call ( this ) ; } TaskDoc . prototype = gulp ; return new TaskDoc ( ) ; } 
function where ( fn ) { if ( typeof fn != 'function' ) { throw new Error ( 'where(param) expected param should be a function' ) ; } var fnBody = fn . toString ( ) . replace ( / \s*function[^\(]*[\(][^\)]*[\)][^\{]*{ / , '' ) . replace ( / [\}]$ / , '' ) ; var values = parseFnBody ( fnBody ) ; var labels = values [ 0 ] ; var fnTest = new Function ( labels . toString ( ) , fnBody ) ; var failedCount = 0 ; var trace = '\n [' + labels . join ( PAD ) + '] : ' ; var currentSpec = jasmine . getEnv ( ) . currentSpec || { result : { } } ; var result = currentSpec . result || currentSpec . results_ ; var item , message ; for ( var i = 1 ; i < values . length ; ++ i ) { message = MESSAGE ; fnTest . apply ( currentSpec , values [ i ] ) ; * jasmine 2.x.x. */ if ( failedCount < result . failedExpectations . length ) { failedCount += 1 ; item = result . failedExpectations [ failedCount - 1 ] ; message = item . message ; item . message = trace + '\n [' + values [ i ] . join ( PAD ) + '] (' + message + ')' ; } } else if ( result . items_ ) { item = result . items_ [ result . items_ . length - 1 ] ; if ( item && ! item . passed_ ) { failedCount += 1 ; message = item . message ; item . message = trace + '\n [' + values [ i ] . join ( PAD ) + '] (' + message + ')' ; } } } 
function parseFnBody ( fnBody ) { var fs = fnBody . toString ( ) ; var table = fs . match ( / \/(\*){3,3}[^\*]+(\*){3,3}\/ / ) ; var data = table [ 0 ] . replace ( / [\/\*]*[\r]*[\*\/]* / g , '' ) . split ( '\n' ) ; var rows = [ ] ; var row , size ; for ( var i = 0 ; i < data . length ; i ++ ) { row = data [ i ] . replace ( / \b[\s*] / , '' ) . replace ( / (\s)*\b / , '' ) ; if ( row . match ( / \S+ / ) ) { row = row . replace ( / \s+ / g , '' ) ; 
function shouldNotHaveDuplicateLabels ( row ) { for ( var label , visited = { } , j = 0 ; j < row . length ; j += 1 ) { label = row [ j ] ; if ( visited [ label ] ) { throw new Error ( 'where-data table contains duplicate label \'' + label + '\' in [' + row . join ( ', ' ) + ']' ) ; } visited [ label ] = 1 ; } } 
function convertNumerics ( row ) { for ( var t , i = 0 ; i < row . length ; i += 1 ) { t = parseFloat ( row [ i ] . replace ( / \'|\"|\, / g , '' ) ) ; isNaN ( t ) || ( row [ i ] = t ) ; } } 
function _log ( level ) { return function ( ) { var meta = null ; var args = arguments ; if ( arguments . length === 0 ) { 
function getPath ( obj , path , defaultValue ) { var pointer = obj ; path . split ( '.' ) . every ( function ( slice ) { if ( pointer [ slice ] ) { pointer = pointer [ slice ] ; return true ; } else { pointer = defaultValue ; return false ; } } ) ; return pointer ; } 
function isPromise ( item ) { if ( ! item ) return false ; return ( ( util . types && util . types . isPromise && util . types . isPromise ( item ) ) || ( item . constructor && item . constructor . name == 'Promise' ) || ( ! item instanceof objectInstance && item . then && typeof item . then == 'function' ) ) ; } 
function hasCallback ( fn ) { var fnString = fn . toString ( ) ; 
function parallel ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'function' , function ( callback ) { self . _struct . push ( { type : 'parallelArray' , payload : [ callback ] } ) ; } ) . ifForm ( 'string function' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'parallelArray' , payload : payload } ) ; } ) . ifForm ( 'array' , function ( tasks ) { self . _struct . push ( { type : 'parallelArray' , payload : tasks } ) ; } ) . ifForm ( 'object' , function ( tasks ) { self . _struct . push ( { type : 'parallelObject' , payload : tasks } ) ; } ) 
function race ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'array' , function ( tasks ) { self . _struct . push ( { type : 'race' , payload : tasks } ) ; } ) . ifForm ( 'string array' , function ( id , tasks ) { self . _struct . push ( { type : 'race' , id : arguments [ 0 ] , payload : arguments [ 1 ] } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .parallel(): ' + form ) ; } ) return self ; } 
function forEach ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'array function' , function ( tasks , callback ) { self . _struct . push ( { type : 'forEachArray' , payload : tasks , callback : callback } ) ; } ) . ifForm ( 'object function' , function ( tasks , callback ) { self . _struct . push ( { type : 'forEachObject' , payload : tasks , callback : callback } ) ; } ) . ifForm ( 'string function' , function ( tasks , callback ) { self . _struct . push ( { type : 'forEachLateBound' , payload : tasks , callback : callback } ) ; } ) . ifForm ( 'number function' , function ( max , callback ) { self . _struct . push ( { type : 'forEachRange' , min : 1 , max : max , callback : callback } ) ; } ) . ifForm ( 'number number function' , function ( min , max , callback ) { self . _struct . push ( { type : 'forEachRange' , min : min , max : max , callback : callback } ) ; } ) . ifForm ( 'string array function' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'mapArray' , output : output , payload : tasks , callback : callback } ) ; } ) . ifForm ( 'string object function' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'mapObject' , output : output , payload : tasks , callback : callback } ) ; } ) . ifForm ( 'string string function' , function ( output , tasks , callback ) { self . _struct . push ( { type : 'mapLateBound' , output : output , payload : tasks , callback : callback } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .forEach(): ' + form ) ; } ) ; return self ; } 
function deferAdd ( id , task , parentChain ) { var self = this ; parentChain . waitingOn = ( parentChain . waitingOn || 0 ) + 1 ; if ( ! parentChain . waitingOnIds ) parentChain . waitingOnIds = [ ] ; parentChain . waitingOnIds . push ( id ) ; self . _deferred . push ( { id : id || null , prereq : parentChain . prereq || [ ] , payload : function ( next ) { self . _context . _id = id ; run ( self . _options . context , task , function ( err , value ) { 
function defer ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'function' , function ( callback ) { self . _struct . push ( { type : 'deferArray' , payload : [ callback ] } ) ; } ) . ifForm ( 'string function' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'deferObject' , payload : payload } ) ; } ) . ifForm ( 'array' , function ( tasks ) { self . _struct . push ( { type : 'deferArray' , payload : tasks } ) ; } ) . ifForm ( 'object' , function ( tasks ) { self . _struct . push ( { type : 'deferObject' , payload : tasks } ) ; } ) . ifForm ( 'array function' , function ( preReqs , callback ) { self . _struct . push ( { type : 'deferArray' , prereq : preReqs , payload : [ callback ] } ) ; } ) . ifForm ( 'string string function' , function ( preReq , id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'deferObject' , prereq : [ preReq ] , payload : payload } ) ; } ) . ifForm ( 'array string function' , function ( preReqs , id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'deferObject' , prereq : preReqs , payload : payload } ) ; } ) . ifForm ( 'string array function' , function ( id , preReqs , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'deferObject' , prereq : preReqs , payload : payload } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .defer():' + form ) ; } ) ; return self ; } 
function await ( ) { var payload = [ ] ; 
function timeout ( newTimeout ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { self . _struct . push ( { type : 'timeout' , delay : false } ) ; } ) . ifForm ( 'boolean' , function ( setTimeout ) { if ( setTimeout ) throw new Error ( 'When calling .timeout(Boolean) only False is accepted to disable the timeout' ) ; self . _struct . push ( { type : 'timeout' , delay : false } ) ; } ) . ifForm ( 'number' , function ( delay ) { self . _struct . push ( { type : 'timeout' , delay : delay } ) ; } ) . ifForm ( 'function' , function ( callback ) { self . _struct . push ( { type : 'timeout' , callback : callback } ) ; } ) . ifForm ( 'number function' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout' , delay : delay , callback : callback } ) ; } ) . ifForm ( 'function number' , function ( delay , callback ) { self . _struct . push ( { type : 'timeout' , delay : delay , callback : callback } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .timeout():' + form ) ; } ) ; return self ; } 
function _timeoutHandler ( ) { var currentTaskIndex = this . _struct . findIndex ( function ( task ) { return ! task . completed } ) ; if ( ! currentTaskIndex < 0 ) { console . log ( 'Async-Chainable timeout on unknown task' ) ; console . log ( 'Full structure:' , this . _struct ) ; } else { console . log ( 'Async-Chainable timeout: Task #' , currentTaskIndex + 1 , '(' + this . _struct [ currentTaskIndex ] . type + ')' , 'elapsed timeout of' , this . _options . timeout + 'ms' ) ; } this . fire ( 'timeout' ) ; } 
function set ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'string scalar|array|object|date|regexp|null' , function ( id , value ) { var payload = { } ; payload [ id ] = value ; self . _struct . push ( { type : 'set' , payload : payload } ) ; } ) . ifForm ( 'object' , function ( obj ) { self . _struct . push ( { type : 'set' , payload : obj } ) ; } ) . ifForm ( 'function' , function ( callback ) { self . _struct . push ( { type : 'seriesArray' , payload : [ callback ] } ) ; } ) . ifForm ( 'string function' , function ( id , callback ) { var payload = { } ; payload [ id ] = callback ; self . _struct . push ( { type : 'seriesObject' , payload : payload } ) ; } ) . ifForm ( [ 'string' , 'string undefined' ] , function ( id ) { var payload = { } ; payload [ id ] = undefined ; self . _struct . push ( { type : 'set' , payload : payload } ) ; } ) . ifFormElse ( function ( form ) { throw new Error ( 'Unknown call style for .set():' + form ) ; } ) ; return self ; } 
function _set ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'string scalar|array|object|date|regexp|null' , function ( id , value ) { self . _setRaw ( id , value ) ; } ) . ifForm ( 'object' , function ( obj ) { for ( var key in obj ) self . _setRaw ( key , obj [ key ] ) ; } ) . ifForm ( 'string function' , function ( id , callback ) { self . _setRaw ( id , callback . call ( this ) ) ; } ) . ifForm ( 'function' , function ( callback ) { 
function _finalize ( err ) { 
function _execute ( err ) { var self = this ; if ( err ) return this . _finalize ( err ) ; 
function runArray ( tasks , limit , callback ) { var self = this ; var nextTaskOffset = 0 ; var running = 0 ; var err ; 
function ( taskErr , taskResult ) { if ( taskErr ) err = taskErr ; -- running ; if ( err && ! running ) { resetTimeout ( false ) ; callback ( err ) ; } else if ( err ) { 
function run ( context , fn , finish , args ) { 
function runWhile ( iter , limit , callback ) { var index = 0 ; var hasExited = false ; var err ; var running = 0 ; if ( ! Number . isFinite ( limit ) ) limit = 10 ; var invoke = function ( ) { iter . call ( this . _context , function ( taskErr , taskResult ) { if ( taskErr ) err = taskErr ; if ( taskErr || ! taskResult ) hasExited = true ; -- running ; if ( err && ! running ) { callback ( err , res ) ; } else if ( running <= 0 && hasExited ) { callback ( err ) ; } else if ( ! hasExited ) { setTimeout ( invoke ) ; } } , index ++ ) ; } ; for ( var i = 0 ; i < limit ; i ++ ) { running ++ ; setTimeout ( invoke ) ; } return this ; } 
function reset ( ) { this . _struct = [ ] ; this . _structPointer = 0 ; var reAttachContext = ( this . _options . context == this . _context ) ; 
function hook ( ) { var self = this ; argy ( arguments ) . ifForm ( '' , function ( ) { } ) . ifForm ( 'string function' , function ( hook , callback ) { 
function hybrid ( fn , cb ) { if ( typeof cb === 'function' ) { 
function tag ( name ) { if ( ! this . comment || ! this . comment . tags ) { return null ; } for ( var i = 0 ; i < this . comment . tags . length ; i ++ ) { var tagObj = this . comment . tags [ i ] ; if ( tagObj . name === name ) { return tagObj . value ; } } return null ; } 
function FixedValueHistory ( maxLength , initial ) { if ( ! ( this instanceof FixedValueHistory ) ) return new FixedValueHistory ( maxLength , initial ) if ( ! isNumber ( maxLength ) || maxLength == 0 ) { throw new Error ( "maxLength must be a positive number." ) } this . maxLength = Math . floor ( + maxLength ) if ( initial != null ) { this . push ( initial ) } } 
function ( path , maxAge , cronTime , options ) { this . job = null ; this . path = path ; this . maxAge = maxAge ; this . cronTime = cronTime ; this . options = util . _extend ( { } , defaultOptions ) ; if ( typeof options === 'object' && options !== null ) { this . options = util . _extend ( this . options , options ) ; } if ( this . options . start === true ) { this . start ( ) ; } } 
function checkPattern ( file , blackList , whiteList ) { if ( util . isRegExp ( blackList ) && blackList . test ( file ) ) { return false ; } if ( util . isRegExp ( whiteList ) ) { if ( whiteList . test ( file ) ) { return true ; } return false ; } return true ; } 
function createGetterSetter ( propName ) { function gs ( element , value ) { 
function Seven ( _a ) { var _b = _a === void 0 ? { } : _a , height = _b . height , width = _b . width , _c = _b . angle , angle = _c === void 0 ? 10 : _c , _d = _b . ratioLtoW , ratioLtoW = _d === void 0 ? 4 : _d , _e = _b . ratioLtoS , ratioLtoS = _e === void 0 ? 32 : _e , _f = _b . digit , digit = _f === void 0 ? Digit . BLANK : _f ; this . _horizontalSegmentGeometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _verticalSegmentGeometry = [ { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } , { x : 0 , y : 0 } ] ; this . _translations = [ { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _verticalSegmentGeometry } , { x : 0 , y : 0 , a : this . _horizontalSegmentGeometry } ] ; this . segments = [ new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) , new Segment ( ) ] ; this . _angleDegree = angle ; this . digit = digit ; this . _ratioLtoW = ratioLtoW ; this . _ratioLtoS = ratioLtoS ; this . _height = this . _width = 100 ; 
function FriendsOfFriends ( mongoose , options ) { debug ( 'mongoose' , mongoose ) ; debug ( 'options' , options ) ; if ( ! ( this instanceof FriendsOfFriends ) ) { return new FriendsOfFriends ( mongoose , options ) ; } var friendship = require ( './friendship' ) , plugin = require ( './plugin' ) ; var defaults = { personModelName : 'Person' , friendshipModelName : 'Friendship' , friendshipCollectionName : undefined , } ; this . options = utils . extend ( defaults , options ) ; this . Friendship = friendship ( mongoose , this . options ) ; this . plugin = plugin ( mongoose ) ; } 
function totalRx ( opts ) { if ( opts ) { opts . iface = opts . iface || 'lo' ; opts . units = opts . units || 'bytes' ; } else { opts = { iface : 'lo' , units : 'bytes' , } ; } var total = parseInt ( _parseProcNetDev ( ) [ opts . iface ] . bytes . receive ) ; var converted = _bytesTo ( total , opts . units ) ; return converted ; } 
function _parseProcNetDev ( ) { var buf = fs . readFileSync ( '/proc/net/dev' ) ; var lines = buf . toString ( ) . trim ( ) . split ( '\n' ) ; var sections = lines . shift ( ) . split ( '|' ) ; var columns = lines . shift ( ) . trim ( ) . split ( '|' ) ; var s ; var l ; var c ; var p = 0 ; var map = { } ; var keys = [ ] ; for ( var i = 0 ; i < sections . length ; ++ i ) { s = sections [ i ] . trim ( ) ; l = sections [ i ] . length ; c = columns [ i ] . trim ( ) . split ( / \s+ / g ) ; while ( c . length ) { map [ keys . length ] = s ; keys . push ( c . shift ( ) ) ; } p += s . length + 1 ; } var retObj = { } ; lines . forEach ( function ( l ) { l = l . trim ( ) . split ( / \s+ / g ) ; var o = { } ; var iface ; for ( var i = 0 ; i < l . length ; ++ i ) { var s = map [ i ] ; 
function onChange ( event ) { try { if ( remove ( ) ) { return ; } resolve ( Array . from ( input . files ) ) ; 
function RemoveObserver_init ( ref , node ) { let self = Self . get ( node ) ; if ( ! self ) { self = new RemoveObserverPrivate ( node ) ; Self . set ( node , self ) ; } Self . set ( ref , self ) ; } 
function ( done ) { async . series ( [ function ( next ) { var child = child_process . exec ( 'jsdoc -c jsdoc.conf.json lib/' ) ; child . stdout . on ( 'data' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data' , function ( data ) { console . log ( 'stderr: ' + data ) ; var err = new Error ( 'error spawning: ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close' , function ( code ) { if ( code === 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning:' , cmd ) ) ; } } ) ; } , function ( next ) { var cmd = util . format ( 'cp -r doc/%s/%s/* doc/' , package . name , package . version ) ; var child = child_process . exec ( cmd ) ; child . stdout . on ( 'data' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data' , function ( data ) { console . log ( 'stderr: ' + data ) ; var err = new Error ( 'error spawning: ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close' , function ( code ) { if ( code === 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning jsdoc' ) ) ; } } ) ; } , function ( next ) { var cmd = 'rm -rf doc/' + package . name + '/' ; var child = child_process . exec ( cmd ) ; child . stdout . on ( 'data' , function ( data ) { console . log ( data ) ; } ) ; child . stderr . on ( 'data' , function ( data ) { console . log ( 'stderr: ' + data ) ; var err = new Error ( 'error spawning: ' , cmd ) ; console . log ( err ) ; next ( err ) ; } ) ; child . on ( 'close' , function ( code ) { console . log ( 'child process exited with code ' + code ) ; if ( code === 0 ) { next ( ) ; } else { next ( new Error ( 'error spawning jsdoc' ) ) ; } } ) ; } ] , function ( err , results ) { if ( err ) done ( err ) ; else done ( ) ; } ) ; } 
function ( done ) { console . log ( 'generating markdown docs...' ) ; var tasks = { } , taskNames = [ 'index' , 'friendship' , 'plugin' , 'relationships' ] ; 
function parsePropertyChains ( expr ) { var parsedExpr = '' , chain ; 
function parseFunction ( link , index , expr ) { var call = getFunctionCall ( expr ) ; 
function parseBrackets ( link , index , expr ) { var call = getFunctionCall ( expr ) ; var insideBrackets = call . slice ( 1 , - 1 ) ; var evaledLink = parsePart ( link , index ) ; index += 1 ; link = '[~~insideBrackets~~]' ; if ( expr . charAt ( propertyRegex . lastIndex ) === '.' ) { link = parsePart ( link , index ) ; } else { link = '_ref' + currentReference + link ; } link = evaledLink + link ; var ref = currentReference ; link = link . replace ( '~~insideBrackets~~' , parsePropertyChains ( insideBrackets ) ) ; currentReference = ref ; return link ; } 
function getFunctionCall ( expr ) { var startIndex = propertyRegex . lastIndex ; var open = expr . charAt ( startIndex - 1 ) ; var close = parens [ open ] ; var endIndex = startIndex - 1 ; var parenCount = 1 ; while ( endIndex ++ < expr . length ) { var ch = expr . charAt ( endIndex ) ; if ( ch === open ) parenCount ++ ; else if ( ch === close ) parenCount -- ; if ( parenCount === 0 ) break ; } currentIndex = propertyRegex . lastIndex = endIndex + 1 ; return open + expr . slice ( startIndex , endIndex ) + close ; } 
function addReferences ( expr ) { if ( referenceCount ) { var refs = [ ] ; for ( var i = 1 ; i <= referenceCount ; i ++ ) { refs . push ( '_ref' + i ) ; } expr = 'var ' + refs . join ( ', ' ) + ';\n' + expr ; } return expr ; } 
function ( fn ) { var pending var hasNext function next ( ) { setTimeout ( function ( ) { if ( pending === false ) return pending = false if ( hasNext ) { hasNext = false fn ( next ) } } , 50 ) 
function assert ( t , m ) { if ( ! t ) { var err = new AssertionError ( m ) if ( Error . captureStackTrace ) Error . captureStackTrace ( err , assert ) throw err } } 
function bindArguments ( func ) { function binder ( ) { return func . apply ( this , args . concat ( slice . call ( arguments ) ) ) ; } var args = slice . call ( arguments , 1 ) ; return binder ; } 
function getRouteIndexFromPatternId ( pattern : string | number ) : number { const pat = transitiveNetwork . patterns . find ( p => p . pattern_id === String ( pattern ) ) if ( ! pat ) return - 1 return transitiveNetwork . routes . findIndex ( r => r . route_id === pat . route_id ) } 
function getCommonPaths ( { getRouteIndexFromPatternId , log , origin , paths } : { getRouteIndexFromPatternId : ( string | number ) => number , log : Function , origin : Origin , paths : Array < PathDescriptor > } ) : Array < StopPatternStops > { paths . sort ( byStopIdAndPathIndex ) const pathCounts = paths . reduce ( countCommonPaths , [ ] ) pathCounts . sort ( byCount ) log ( ` ${ pathCounts . length } ` ) if ( pathCounts . length > MAX_TRANSITIVE_PATHS ) { log ( ` ${ pathCounts . length - MAX_TRANSITIVE_PATHS } ${ pathCounts [ MAX_TRANSITIVE_PATHS ] . count } ${ paths . length } ` ) } let allStopPatternStopSets = pathCounts . slice ( 0 , MAX_TRANSITIVE_PATHS ) . map ( ( p ) => p . path ) . filter ( uniquePathIds ) 
function clusterJourneys ( { journeys , log , patterns , stops } : { journeys : Array < Journey > , log : Function , patterns : Array < Pattern > , stops : Array < Stop > } ) { 
function getClusterDissimilarity ( c1 : Array < Journey > , c2 : Array < Journey > , { patterns , stops } : { patterns : Array < Pattern > , stops : Array < Stop > } ) : number { let dissimilarity = 0 for ( const j1 of c1 ) { for ( const j2 of c2 ) { 
function segmentDissimilarity ( s1 : Segment , s2 : Segment , { patterns , stops } : { patterns : Array < Pattern > , stops : Array < Stop > } ) : number { const pat1 = patterns . find ( ( p ) => p . pattern_id === s1 . pattern_id ) const pat2 = patterns . find ( ( p ) => p . pattern_id === s2 . pattern_id ) if ( ! pat1 || ! pat2 ) return Infinity const s1f = s1 . from_stop_index const s1t = s1 . to_stop_index const s2f = s2 . from_stop_index const s2t = s2 . to_stop_index if ( s1f == null || s1t == null || s2f == null || s2t == null ) return Infinity function findStop ( id : string ) : ? Stop { return stops . find ( ( stop ) => stop . stop_id === id ) } const from1 = findStop ( pat1 . stops [ s1f ] . stop_id ) const to1 = findStop ( pat1 . stops [ s1t ] . stop_id ) const from2 = findStop ( pat2 . stops [ s2f ] . stop_id ) const to2 = findStop ( pat2 . stops [ s2t ] . stop_id ) if ( ! from1 || ! from2 || ! to1 || ! to2 ) return Infinity const d1 = stopDistance ( from1 , from2 ) const d2 = stopDistance ( to1 , to2 ) return Math . max ( d1 , d2 ) } 
function stopDistance ( s1 : Stop , s2 : Stop ) : number { const cosLat = Math . cos ( s1 . stop_lat * Math . PI / 180 ) return Math . pow ( s1 . stop_lat - s2 . stop_lat , 2 ) + Math . pow ( s1 . stop_lon * cosLat - s2 . stop_lon * cosLat , 2 ) } 
function getExceptions ( ) { const openers = [ ] ; const closers = [ ] ; if ( options . braceException ) { openers . push ( '{' ) ; closers . push ( '}' ) ; } if ( options . bracketException ) { openers . push ( '[' ) ; closers . push ( ']' ) ; } if ( options . parenException ) { openers . push ( '(' ) ; closers . push ( ')' ) ; } if ( options . empty ) { openers . push ( ')' ) ; closers . push ( '(' ) ; } return { openers , closers } ; } 
function shouldOpenerHaveSpace ( left , right ) { if ( sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { if ( astUtils . isClosingParenToken ( right ) ) { return false ; } return ! isOpenerException ( right ) ; } return isOpenerException ( right ) ; } 
function shouldCloserHaveSpace ( left , right ) { if ( astUtils . isOpeningParenToken ( left ) ) { return false ; } if ( sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return ! isCloserException ( left ) ; } return isCloserException ( left ) ; } 
function shouldOpenerRejectSpace ( left , right ) { if ( right . type === 'Line' ) { return false ; } if ( ! astUtils . isTokenOnSameLine ( left , right ) ) { return false ; } if ( ! sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return isOpenerException ( right ) ; } return ! isOpenerException ( right ) ; } 
function shouldCloserRejectSpace ( left , right ) { if ( astUtils . isOpeningParenToken ( left ) ) { return false ; } if ( ! astUtils . isTokenOnSameLine ( left , right ) ) { return false ; } if ( ! sourceCode . isSpaceBetweenTokens ( left , right ) ) { return false ; } if ( ALWAYS ) { return isCloserException ( left ) ; } return ! isCloserException ( left ) ; } 
function defineConfigurable ( obj , key , val ) { Object . defineProperty ( obj , key , { configurable : true , enumerable : false , writable : true , value : val } ) ; } 
function ToInteger ( argument ) { var number = + argument ; if ( number !== number ) { return 0 ; } if ( number === 0 || number === Infinity || number === - Infinity ) { return number ; } return ( number >= 0 ? 1 : - 1 ) * Math . floor ( Math . abs ( number ) ) ; } 
function ToLength ( argument ) { var len = ToInteger ( argument ) ; return len <= 0 ? 0 : Math . min ( len , Math . pow ( 2 , 53 ) - 1 ) ; } 
function SameValue ( x , y ) { if ( typeof x !== typeof y ) { return false ; } if ( Type ( x ) === 'undefined' ) { return true ; } if ( Type ( x ) === 'number' ) { if ( x !== x && y !== y ) { return true ; } if ( x === 0 ) { return 1 / x === 1 / y ; } } return x === y ; } 
function IteratorNext ( iterator , value ) { var result = iterator . next ( value ) ; if ( Type ( result ) !== 'object' ) { throw TypeError ( ) ; } return result ; } 
function IteratorStep ( iterator ) { var result = IteratorNext ( iterator ) ; return IteratorComplete ( result ) === true ? false : result ; } 
function CreateIterResultObject ( value , done ) { if ( Type ( done ) !== 'boolean' ) { throw TypeError ( ) ; } return { value : value , done : done } ; } 
function EnqueueTask ( task , args ) { if ( typeof setImmediate === 'function' ) { setImmediate ( function ( ) { task . apply ( null , args ) ; } ) ; } else { setTimeout ( function ( ) { task . apply ( null , args ) ; } , 0 ) ; } } 
function CreateArrayIterator ( array , kind ) { var O = ToObject ( array ) , iterator = Object . create ( ArrayIteratorPrototype ) ; defineInternal ( iterator , '[[IteratedObject]]' , O ) ; defineInternal ( iterator , '[[ArrayIteratorNextIndex]]' , 0 ) ; defineInternal ( iterator , '[[ArrayIteratorKind]]' , kind ) ; return iterator ; } 
function IfAbruptRejectPromise ( value , capability ) { try { capability [ '[[Reject]]' ] . call ( undefined , [ value ] ) ; } catch ( e ) { return e ; } return capability ; } 
function PromiseResolve ( ) { return function F ( resolution ) { var promise = F [ '[[Promise]]' ] , reactions ; if ( Type ( promise ) !== 'object' ) { throw TypeError ( ) ; } if ( promise [ '[[PromiseStatus]]' ] !== 'unresolved' ) { return undefined ; } reactions = promise [ '[[PromiseResolveReactions]]' ] ; defineInternal ( promise , '[[PromiseResult]]' , resolution ) ; defineInternal ( promise , '[[PromiseResolveReactions]]' , undefined ) ; defineInternal ( promise , '[[PromiseRejectReactions]]' , undefined ) ; defineInternal ( promise , '[[PromiseStatus]]' , 'has-resolution' ) ; return TriggerPromiseReactions ( reactions , resolution ) ; } ; } 
function NewPromiseCapability ( C ) { var promise ; if ( ! IsConstructor ( C ) ) { throw TypeError ( ) ; } try { promise = Object . create ( C . prototype ) ; } catch ( e ) { return e ; } return CreatePromiseCapabilityRecord ( promise , C ) ; } 
function CreatePromiseCapabilityRecord ( promise , constructor ) { var promiseCapability = { } , executor , constructorResult ; defineInternal ( promiseCapability , '[[Promise]]' , promise ) ; defineInternal ( promiseCapability , '[[Resolve]]' , undefined ) ; defineInternal ( promiseCapability , '[[Reject]]' , undefined ) ; executor = new GetCapabilitiesExecutor ( ) ; defineInternal ( executor , '[[Capability]]' , promiseCapability ) ; try { constructorResult = constructor . call ( promise , executor ) ; } catch ( e ) { return e ; } if ( ! IsCallable ( promiseCapability [ '[[Resolve]]' ] ) ) { throw TypeError ( ) ; } if ( ! IsCallable ( promiseCapability [ '[[Reject]]' ] ) ) { throw TypeError ( ) ; } if ( typeof constructorResult === 'object' && ! SameValue ( promise , constructorResult ) ) { throw TypeError ( ) ; } return promiseCapability ; } 
function GetCapabilitiesExecutor ( ) { return function F ( resolve , reject ) { var promiseCapability = F [ '[[Capability]]' ] ; if ( Type ( promiseCapability [ '[[Resolve]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } if ( Type ( promiseCapability [ '[[Reject]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } defineInternal ( promiseCapability , '[[Resolve]]' , resolve ) ; defineInternal ( promiseCapability , '[[Reject]]' , reject ) ; } ; } 
function TriggerPromiseReactions ( reactions , argument ) { reactions . forEach ( function ( reaction ) { EnqueueTask ( PromiseReactionTask , [ reaction , argument ] ) ; } ) ; } 
function UpdatePromiseFromPotentialThenable ( x , promiseCapability ) { var then , rejectResult , thenCallResult ; if ( Type ( x ) !== 'object' ) { return 'not a thenable' ; } try { then = x . then ; } catch ( e ) { rejectResult = promiseCapability [ '[[Reject]]' ] . call ( undefined , e ) ; return null ; } if ( ! IsCallable ( then ) ) { return 'not a thenable' ; } try { thenCallResult = then . call ( x , promiseCapability [ '[[Resolve]]' ] , promiseCapability [ '[[Reject]]' ] ) ; } catch ( e ) { rejectResult = promiseCapability [ '[[Reject]]' ] . call ( undefined , e ) ; return null ; } return null ; } 
function PromiseReactionTask ( reaction , argument ) { var promiseCapability = reaction [ '[[Capabilities]]' ] , handler = reaction [ '[[Handler]]' ] , handlerResult , selfResolutionError , updateResult ; try { handlerResult = handler . call ( undefined , argument ) ; } catch ( e ) { return promiseCapability [ '[[Reject]]' ] . call ( undefined , e ) ; } if ( SameValue ( handlerResult , promiseCapability [ '[[Promise]]' ] ) ) { selfResolutionError = TypeError ( ) ; return promiseCapability [ '[[Reject]]' ] . call ( undefined , selfResolutionError ) ; } updateResult = UpdatePromiseFromPotentialThenable ( handlerResult , promiseCapability ) ; if ( updateResult === 'not a thenable' ) { return promiseCapability [ '[[Resolve]]' ] . call ( undefined , handlerResult ) ; } return undefined ; } 
function Promise ( executor ) { var promise = this ; if ( ! IsCallable ( executor ) ) { throw TypeError ( 'Invalid executor' ) ; } if ( Type ( promise ) !== 'object' ) { throw TypeError ( 'Invalid promise' ) ; } if ( Type ( promise [ '[[PromiseStatus]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } defineInternal ( this , '[[PromiseConstructor]]' , Promise ) ; return InitializePromise ( promise , executor ) ; } 
function InitializePromise ( promise , executor ) { var resolve , reject , completion , status ; if ( Type ( promise [ '[[PromiseStatus]]' ] ) !== 'undefined' ) { throw TypeError ( ) ; } if ( ! IsCallable ( executor ) ) { throw TypeError ( ) ; } defineInternal ( promise , '[[PromiseStatus]]' , 'unresolved' ) ; defineInternal ( promise , '[[PromiseResolveReactions]]' , [ ] ) ; defineInternal ( promise , '[[PromiseRejectReactions]]' , [ ] ) ; resolve = CreateResolveFunction ( promise ) ; reject = CreateRejectFunction ( promise ) ; try { completion = executor . call ( undefined , resolve , reject ) ; } catch ( e ) { try { status = reject . call ( undefined , e ) ; } catch ( e ) { return e ; } } return promise ; } 
function PromiseResolutionHandlerFunction ( ) { return function F ( x ) { var promise = F [ '[[Promise]]' ] , fulfillmentHandler = F [ '[[FulfillmentHandler]]' ] , rejectionHandler = F [ '[[RejectionHandler]]' ] , selfResolutionError , C , promiseCapability , updateResult ; if ( SameValue ( x , promise ) ) { selfResolutionError = TypeError ( ) ; return rejectionHandler . call ( undefined , selfResolutionError ) ; } C = promise [ '[[PromiseConstructor]]' ] ; try { promiseCapability = NewPromiseCapability ( C ) ; } catch ( e ) { return e ; } try { updateResult = UpdatePromiseFromPotentialThenable ( x , promiseCapability ) ; } catch ( e ) { return e ; } if ( updateResult !== 'not a thenable' ) { return promiseCapability [ '[[Promise]]' ] . then ( fulfillmentHandler , rejectionHandler ) ; } return fulfillmentHandler . call ( undefined , x ) ; } ; } 
function ( target , sequence , t ) { 
function ( e ) { var el = e . target , attr , type = e . type , key = type . indexOf ( 'key' ) === 0 ? e . which || e . keyCode || '' : '' , special = _ . special [ type + key ] ; if ( el && special ) { type = special ( e , el , el . nodeName . toLowerCase ( ) ) ; if ( ! type ) { return ; } 
function ( el , sequence ) { if ( typeof el === "string" ) { sequence = el ; el = document ; } return _ . all ( el , sequence || _ . attr ( el , 'click' ) ) ; } 
function reportNoBeginningSpace ( node , token , tokenAfter ) { context . report ( { node : node , loc : token . loc . start , message : 'There should be no space after \'' + token . value + '\'' , fix : function ( fixer ) { return fixer . removeRange ( [ token . range [ 1 ] , tokenAfter . range [ 0 ] ] ) ; } } ) ; } 
function reportNoEndingSpace ( node , token , tokenBefore ) { context . report ( { node : node , loc : token . loc . start , message : 'There should be no space before \'' + token . value + '\'' , fix : function ( fixer ) { return fixer . removeRange ( [ tokenBefore . range [ 1 ] , token . range [ 0 ] ] ) ; } } ) ; } 
function reportRequiredBeginningSpace ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required after \'' + token . value + '\'' , fix : function ( fixer ) { return fixer . insertTextAfter ( token , ' ' ) ; } } ) ; } 
function reportRequiredEndingSpace ( node , token ) { context . report ( { node : node , loc : token . loc . start , message : 'A space is required before \'' + token . value + '\'' , fix : function ( fixer ) { return fixer . insertTextBefore ( token , ' ' ) ; } } ) ; } 
function generateDestinationLonLat ( { lat , lon } ) { const latOffset = ( getDistance ( ) / LAT_DEGREE ) * getSign ( ) const lonOffset = ( getDistance ( ) / ( LAT_DEGREE * Math . cos ( lat ) ) ) * getSign ( ) return { lat : lat + latOffset , lon : lon + lonOffset } } 
function ( keyParts , hash ) { for ( var i = 0 ; i < keyParts . length - 1 ; ++ i ) { hash = getValue ( keyParts [ i ] , hash ) ; if ( typeof ( hash ) === 'undefined' ) { return undefined ; } } var lastKeyPartIndex = keyParts . length - 1 ; return getValue ( keyParts [ lastKeyPartIndex ] , hash ) } 
function gitAuthors ( cb ) { return exec ( 'git log --pretty="%an <%ae>"' , function ( er , stdout , stderr ) { if ( er || stderr ) throw new Error ( er || stderr ) return cb ( null , stdout . split ( '\n' ) . reverse ( ) ) } ) } 
function lookupGithubLogin ( p , print , callback ) { var apiURI = 'https://api.github.com/search/users?q=' var options = { json : true , headers : { 'user-agent' : pkg . name + '/' + pkg . version } } if ( process . env . OAUTH_TOKEN ) { options . headers [ 'Authorization' ] = 'token ' + process . env . OAUTH_TOKEN . trim ( ) } function cb ( err , p ) { callback ( err , p ) } if ( print ) process . stdout . write ( '.' ) request ( apiURI + encodeURIComponent ( p . email + ' in:email type:user' ) , options , onEmail ) function onEmail ( err , data ) { rateLimitExceeded = rateLimitExceeded || data . body . message if ( ! err && data . body . items && data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } request ( apiURI + encodeURIComponent ( p . name + ' in:fullname type:user' ) , options , onName ) } function onName ( err , data ) { rateLimitExceeded = rateLimitExceeded || data . body . message if ( ! err && data . body . items && data . body . items [ 0 ] ) { p . login = data . body . items [ 0 ] . login return cb ( err , p ) } cb ( err , p ) } } 
function _unpackOutput ( message ) { if ( message . charAt ( 0 ) != keyczar_util . VERSION_BYTE ) { throw new Error ( 'Unsupported version byte: ' + message . charCodeAt ( 0 ) ) ; } var keyhash = message . substr ( 1 , keyczar_util . KEYHASH_LENGTH ) ; message = message . substr ( 1 + keyczar_util . KEYHASH_LENGTH ) ; return { keyhash : keyhash , message : message } ; } 
function _rsaHash ( publicKey ) { var md = forge . md . sha1 . create ( ) ; 
function _makeRsaKey ( rsaKey ) { var key = { keyhash : _rsaHash ( rsaKey ) , size : rsaKey . n . bitLength ( ) } ; key . encrypt = function ( plaintext ) { 
function ( ) { if ( ! result ) { var exec = grunt . config . get ( 'exec' ) ; for ( var key in exec ) { exec [ key ] . cmd = nvmUse + ' && ' + exec [ key ] . cmd ; } grunt . config . set ( 'exec' , exec ) ; } } 
function ( callback ) { var command = '. ' + nvmPath ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( stderr . indexOf ( 'No such file or directory' ) !== - 1 ) { if ( nvmPath === home + '/.nvm/nvm.sh' ) { nvmPath = home + '/nvm/nvm.sh' ; nvmInit = '. ' + nvmPath + ' && ' ; checkNVM ( callback ) ; } else { grunt [ options . errorLevel ] ( 'Expected node ' + expected + ', but found v' + actual + '\nNVM does not appear to be installed.\nPlease install (https://github.com/creationix/nvm#installation), or update the NVM path.' ) ; } } else { callback ( ) ; } } ) ; } 
function ( packages ) { var thisPackage ; if ( packages . length ) { thisPackage = packages . pop ( ) ; var command = nvmUse + ' && npm ls -g ' + thisPackage ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } if ( stdout . indexOf ( ' (empty)') !== 1) npmInstall ( thisPackage , function ( ) { checkPackages ( packages ) ; } ) ; } else { checkPackages ( packages ) ; } } ) ; } else { done ( ) ; } } 
function ( thisPackage , callback ) { var command = nvmUse + ' && npm install -g ' + thisPackage ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } grunt . verbose . writeln ( stdout ) ; grunt . log . oklns ( 'Installed ' + thisPackage ) ; callback ( ) ; } ) ; } 
function ( ) { prompt . start ( ) ; var prop = { name : 'yesno' , message : 'You do not have any node versions installed that satisfy this project\'s requirements (' . white + expected . yellow + '). Would you like to install the latest compatible version? (y/n)' . white , validator : / y[es]*|n[o]? / , required : true , warning : 'Must respond yes or no' } ; prompt . get ( prop , function ( err , result ) { result = result . yesno . toLowerCase ( ) ; if ( result === 'yes' || result === 'y' ) { nvmInstall ( ) ; } else { grunt [ options . errorLevel ] ( 'Expected node v' + expected + ', but found ' + actual ) ; } } ) ; } 
function ( ) { nvmLs ( 'remote' , function ( ) { bestMatch = semver . maxSatisfying ( remotes , expected ) ; nvmUse = nvmInit + 'nvm use ' + bestMatch ; var command = nvmInit + 'nvm install ' + bestMatch ; childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { if ( err ) { throw err ; } var nodeVersion = stdout . split ( ' ' ) [ 3 ] ; grunt . log . ok ( 'Installed node v' + bestMatch ) ; printVersion ( nodeVersion ) ; extendExec ( ) ; checkPackages ( options . globals ) ; } ) ; } ) ; } 
function ( loc , callback ) { var command = nvmInit + 'nvm ls' ; if ( loc === 'remote' ) { command += '-remote' ; } childProcess . exec ( command , cmdOpts , function ( err , stdout , stderr ) { var data = stripColorCodes ( stdout . toString ( ) ) . replace ( / \s+ / g , '|' ) , available = data . split ( '|' ) ; for ( var i = 0 ; i < available . length ; i ++ ) { 
function ( ) { 
function EachSubject ( subject , elements , elementName , opt_noIndex ) { ProxyBase . call ( this ) ; this . elementSubjects = [ ] ; for ( var i = 0 ; i < elements . length ; ++ i ) { var es = subjectFactory . newSubject ( subject . failureStrategy , elements [ i ] ) ; es . named ( elementName + ( opt_noIndex ? '' : ( ' ' + i ) ) + ' of ' + subject . describe ( ) ) ; es . failureMessage = subject . failureMessage ; this . elementSubjects . push ( es ) ; } } 
function EventualSubject ( subject , promise ) { DeferredSubject . call ( this ) ; this . subject = subject ; var self = this ; this . promise = promise . then ( function ( value ) { 
function PromiseSubject ( failureStrategy , value ) { Subject . call ( this , failureStrategy , value ) ; 
function firstDiff ( exp , act ) { var i ; for ( i = 0 ; i < exp . length && i < act . length ; ++ i ) { if ( exp [ i ] != act [ i ] ) { break ; } } return i ; } 
function compare ( exp , act , opt_path , opt_deep , opt_results ) { var path = opt_path || '' ; var i , j , strExp , strAct ; if ( sameValue ( exp , act ) ) { return true ; } var et = type ( exp ) ; var at = type ( act ) ; if ( et !== at || et === 'number' || at === 'boolean' || et === 'undefined' || exp === null || act === null ) { if ( opt_results ) { opt_results . push ( inequality ( exp , act , path ) ) ; } return false ; } else if ( et === 'object' ) { 
function defaultDestRewriter ( pathObj : Object , innerPath : string , options : Object ) { let fileName = pathObj . base ; if ( options . fileSuffix ) { fileName . replace ( options . fileSuffix , '.svg' ) ; } else { fileName = fileName . replace ( '.svg' , '.js' ) ; } fileName = fileName . replace ( / (^.)|(_)(.) / g , ( match , p1 , p2 , p3 ) => ( p1 || p3 ) . toUpperCase ( ) ) ; return path . join ( innerPath , fileName ) ; } 
function get ( store , key , options ) { if ( key === '' || key == null ) { return store . _data ; } return doGet ( store , key , options ) ; } 
function doGet ( store , key , options = { } ) { 
function resolveReferences ( store , value , depth ) { if ( -- depth < 0 ) { return value ; } if ( Array . isArray ( value ) ) { const n = value . length ; const v = new Array ( n ) ; let item ; for ( let i = n - 1 ; i >= 0 ; i -- ) { item = value [ i ] ; v [ i ] = resolveReferences ( store , store . _isRefValue ( item ) ? property . get ( store . _data , store . _parseRefKey ( item ) ) : item , depth ) ; } value = v ; } else if ( isPlainObject ( value ) ) { const v = { } ; let item ; for ( const prop in value ) { item = value [ prop ] ; v [ prop ] = resolveReferences ( store , store . _isRefValue ( item ) ? property . get ( store . _data , store . _parseRefKey ( item ) ) : item , depth ) ; } value = v ; } return value ; } 
function formatString ( value , options ) { var opts = options || { } ; var result = value . replace ( / [\0-\37] / g , function ( ch ) { switch ( ch ) { case '\n' : return '\\n' ; case '\r' : return '\\r' ; case '\t' : return '\\t' ; case '\b' : return '\\b' ; case '\v' : return '\\v' ; case '\f' : return '\\f' ; default : return '\\' + ch . charCodeAt ( 0 ) . toString ( 8 ) ; } } ) ; if ( opts . clip && result . length > opts . clip ) { result = result . slice ( 0 , Math . max ( 0 , opts . clip - 3 ) ) + '...' ; } return '"' + result + '"' ; } 
function base ( ) { const args = [ config . path_base ] . concat ( [ ] . slice . call ( arguments ) ) ; return path . resolve . apply ( path , args ) ; } 
function KeyValue ( subject , key ) { this . subject = subject ; this . key = key ; this . format = subject . format ; this . value = subject . value . get ( key ) ; } 
function formatObject ( value , options ) { if ( value === undefined ) { return 'undefined' ; } if ( value === null ) { return 'null' ; } if ( typeof ( value ) == 'object' ) { if ( value instanceof RegExp || value instanceof Date ) { return value + '' ; } var opts = options || { } ; var innerOpts = Object . assign ( { } , opts , { clip : false } ) ; 
function _exportPublicKey ( key ) { var t = key . metadata . type ; var p = key . metadata . purpose ; if ( ! ( t == keyczar . TYPE_RSA_PRIVATE && ( p == keyczar . PURPOSE_DECRYPT_ENCRYPT || p == keyczar . PURPOSE_SIGN_VERIFY ) ) ) { throw new Error ( 'Unsupported key type/purpose:' + t + '/' + p ) ; } var publicPurpose = keyczar . PURPOSE_ENCRYPT ; if ( p == keyczar . PURPOSE_SIGN_VERIFY ) { publicPurpose = keyczar . PURPOSE_VERIFY ; } var metadata = { name : key . metadata . name , purpose : publicPurpose , type : keyczar . TYPE_RSA_PUBLIC , encrypted : false , 
function _getPrimaryVersion ( metadata ) { var primaryVersion = null ; for ( var i = 0 ; i < metadata . versions . length ; i ++ ) { if ( metadata . versions [ i ] . status == STATUS_PRIMARY ) { if ( primaryVersion !== null ) { throw new Error ( 'Invalid key: multiple primary keys' ) ; } primaryVersion = metadata . versions [ i ] . versionNumber ; } } if ( primaryVersion === null ) { throw new Error ( 'No primary key' ) ; } return primaryVersion ; } 
function _makeKeyczar ( data , password ) { var instance = { } ; instance . metadata = JSON . parse ( data . meta ) ; if ( instance . metadata . encrypted !== false ) { if ( ! password ) { throw new Error ( 'Key is encrypted; you must provide the password' ) ; } if ( password . length === 0 ) { throw new Error ( 'Must supply a password length > 0' ) ; } } else if ( password ) { throw new Error ( 'Key is not encrypted but password provided' ) ; } var primaryVersion = _getPrimaryVersion ( instance . metadata ) ; var primaryKeyString = data [ String ( primaryVersion ) ] ; if ( instance . metadata . encrypted ) { primaryKeyString = _decryptKey ( primaryKeyString , password ) ; } var t = instance . metadata . type ; var p = instance . metadata . purpose ; if ( t == keyczar . TYPE_RSA_PRIVATE ) { instance . primary = keyczar_util . privateKeyFromKeyczar ( primaryKeyString ) ; instance . exportPublicKey = function ( ) { return _exportPublicKey ( instance ) ; } ; } else if ( t == keyczar . TYPE_RSA_PUBLIC ) { instance . primary = keyczar_util . publicKeyFromKeyczar ( primaryKeyString ) ; } else if ( t == keyczar . TYPE_AES && p == keyczar . PURPOSE_DECRYPT_ENCRYPT ) { instance . primary = keyczar_util . aesFromKeyczar ( primaryKeyString ) ; } else { throw new Error ( 'Unsupported key type: ' + t ) ; } if ( p == keyczar . PURPOSE_ENCRYPT || p == keyczar . PURPOSE_DECRYPT_ENCRYPT ) { 
function kebabDestRewriter ( pathObj : Object , innerPath : string , options : Object ) { let fileName = pathObj . base ; if ( options . fileSuffix ) { fileName . replace ( options . fileSuffix , '.svg' ) ; } else { fileName = fileName . replace ( '.svg' , '.js' ) ; } fileName = fileName . replace ( / _ / g , '-' ) ; return path . join ( innerPath , fileName ) ; } 
function set ( store , key , value , options ) { return doSet ( store , key , value , Object . assign ( { } , DEFAULT_OPTIONS , options ) ) ; } 
function doSet ( store , key , value , options ) { if ( ! key || typeof key !== 'string' ) { return false ; } 
function formatMap ( value , options ) { return 'Map(' + registry . format ( Array . from ( value . entries ( ) ) , options ) + ')' ; } 
function fetch ( store , key , url , options ) { options = Object . assign ( { } , DEFAULT_LOAD_OPTIONS , options ) ; options . cacheControl = parseCacheControl ( options . cacheControl ) ; if ( ! key ) { return Promise . resolve ( { body : undefined , duration : 0 , headers : { } , key , status : 400 } ) ; } return doFetch ( store , key , url , options ) ; } 
function doFetch ( store , key , url , options ) { const { cacheControl , rejectOnError } = options ; const value = get ( store , key ) ; const isMissing = ! value ; let isExpired = hasExpired ( value && value [ store . EXPIRY_KEY ] , false ) ; store . debug ( 'fetch %s from %s' , key , url ) ; 
function load ( store , key , url , options ) { const { cacheControl , rejectOnError , retry , timeout } = options ; options . id = key ; store . debug ( 'load %s from %s' , key , url ) ; return agent . get ( url , options ) . timeout ( timeout ) . retry ( retry ) . then ( res => { 
function parseCacheControl ( cacheControlString ) { let maxAge = 0 ; let staleIfError = 0 ; if ( cacheControlString && typeof cacheControlString === 'string' ) { let match ; while ( ( match = RE_CACHE_CONTROL . exec ( cacheControlString ) ) ) { if ( match [ 1 ] ) { maxAge = parseInt ( match [ 1 ] , 10 ) * 1000 ; } else if ( match [ 2 ] ) { staleIfError = parseInt ( match [ 2 ] , 10 ) * 1000 ; } } } return { maxAge , staleIfError } ; } 
function mergeCacheControl ( cacheControl , defaultCacheControl ) { if ( cacheControl == null ) { return Object . assign ( { } , defaultCacheControl ) ; } return { maxAge : 'maxAge' in cacheControl ? cacheControl . maxAge : defaultCacheControl . maxAge , staleIfError : 'staleIfError' in cacheControl ? cacheControl . staleIfError : defaultCacheControl . staleIfError } ; } 
function generateExpiry ( headers = { } , defaultCacheControl ) { const cacheControl = mergeCacheControl ( parseCacheControl ( headers [ 'cache-control' ] ) , defaultCacheControl ) ; const now = Date . now ( ) ; let expires = now ; if ( headers . expires ) { expires = typeof headers . expires === 'string' ? Number ( new Date ( headers . expires ) ) : headers . expires ; } if ( now >= expires ) { expires = now + cacheControl . maxAge ; } return { expires , expiresIfError : expires + cacheControl . staleIfError } ; } 
function generateResponseHeaders ( expiry = { } , defaultCacheControl , isError ) { const now = Date . now ( ) ; let maxAge ; if ( isError ) { maxAge = expiry && expiry . expiresIfError > now && expiry . expiresIfError - now < defaultCacheControl . maxAge ? Math . ceil ( ( expiry . expiresIfError - now ) / 1000 ) : defaultCacheControl . maxAge / 1000 ; } else { 
function hasExpired ( expiry , isError ) { if ( ! expiry ) { return true ; } 
function formatSet ( value , options ) { return 'Set(' + registry . format ( Array . from ( value . values ( ) ) , options ) + ')' ; } 
function formatArray ( value , options ) { var opts = options || { } ; var innerOpts = Object . assign ( { } , opts , { clip : false } ) ; var parts = [ '[' ] ; var length = 2 ; 
function _init ( client , uri , options ) { Promise . init . call ( this ) this . client = client this . uri = uri this . options = options return this } 
function _timeout ( delay ) { this . clearTimer ( ) this . timer = setTimeout ( function ( ) { this . flush ( 'timeouted' , 'failed' ) . fail ( 'timeouted' ) this . forget ( ) } . bind ( this ) , delay * 1000 ) return this } 
function request ( uri , options ) { var client , promise , method , serialise_body_p , mime options = options || { } options . headers = options . headers || { } method = ( options . method || 'GET' ) . toUpperCase ( ) uri = build_uri ( uri , options . query , options . body ) options . headers [ 'X-Requested-With' ] = 'XMLHttpRequest' serialise_body_p = object_p ( options . body ) if ( serialise_body_p ) { mime = options . headers [ 'Content-Type' ] || 'application/x-www-form-urlencoded' options . body = serialise_for_type ( mime , options . body ) options . headers [ 'Content-Type' ] = mime } client = make_xhr ( ) promise = PromiseP . make ( client , uri , options ) setup_listeners ( ) setTimeout ( function ( ) { client . open ( method , uri , true , options . username , options . password ) setup_headers ( options . headers || { } ) client . send ( options . body ) } ) active . push ( promise ) return promise 
function build_uri ( uri , query , body ) { uri = build_query_string ( uri , query ) return method == 'GET' ? build_query_string ( uri , body ) : uri } 
function setup_headers ( headers ) { keys ( headers ) . forEach ( function ( key ) { client . setRequestHeader ( key , headers [ key ] ) } ) } 
function setup_listeners ( ) { client . onerror = make_error_handler ( 'errored' ) client . onabort = make_error_handler ( 'forgotten' ) client . ontimeout = make_error_handler ( 'timeouted' ) client . onloadstart = function ( ev ) { promise . fire ( 'load:start' , ev ) } client . onprogress = function ( ev ) { promise . fire ( 'load:progress' , ev ) } client . onloadend = function ( ev ) { promise . fire ( 'load:end' , ev ) } client . onload = function ( ev ) { promise . fire ( 'load:success' , ev ) } client . onreadystatechange = function ( ) { var response , status , state state = client . readyState promise . fire ( 'state:' + state_map [ state ] ) if ( state == 4 ) { var binding_state = success . test ( status ) ? 'ok' : error . test ( status ) ? 'failed' : 'any' response = client . responseText status = normalise_status ( client . status ) active . splice ( active . indexOf ( promise ) , 1 ) promise . flush ( 'status:' + status ) . flush ( 'status:' + status_type ( status ) ) status == 0 ? raise ( 'errored' ) : success . test ( status ) ? promise . bind ( response , status ) : error . test ( status ) ? promise . fail ( response , status ) : promise . done ( [ response , status ] ) } } } 
function request_with_method ( method ) { return function ( uri , options ) { options = options || { } options . method = method . toUpperCase ( ) return request ( uri , options ) } } 
function isLinkWorking ( link , options ) { options = Object . assign ( { checkConnectivity : false , followRedirect : true , timeout : 15000 , retries : 3 , agent : null , } , options ) ; const gotOptions = { timeout : options . timeout , followRedirect : options . followRedirect , retries : options . retries , agent : options . agent , headers : { 'user-agent' : ` ${ pkg . version } ` , } , } ; return tryHead ( link , gotOptions ) . catch ( ( ) => tryGet ( link , options , gotOptions ) ) ; } 
function FieldValue ( subject , name , value ) { this . subject = subject ; this . name = name ; this . value = subject . value [ name ] ; this . format = subject . format ; } 
function Sapi ( key , opts ) { opts = opts || { } ; function _authRequire ( result , cb ) { 
function LeakError ( opts , src , file ) { Error . call ( this ) ; this . message = 'global leak detected: ' + opts . variable ; this . line = opts . line - 1 ; this . column = opts . column ; this . annotated = '\n' + ( file || '(anonymous file)' ) + ':' + this . line + '\n' + src . split ( '\n' ) [ this . line ] + '\n' + Array ( this . column + 1 ) . join ( ' ' ) + '^' + '\n' + 'LeakError: ' + this . message ; } 
function Strategy ( options , verify ) { options = options || { } ; this . serverURL = options . serverURL || 'https://account.lab.fiware.org' ; this . isLegacy = options . isLegacy === true ? options . isLegacy : false ; if ( this . serverURL . endsWith ( '/' ) ) { this . serverURL = this . serverURL . slice ( 0 , - 1 ) ; } options . authorizationURL = this . serverURL + '/oauth2/authorize' ; options . tokenURL = this . serverURL + '/oauth2/token' ; 
function reset ( store , data ) { store . debug ( 'reset' ) ; store . _data = data ; store . changed = true ; } 
function serialise ( key , data , config ) { if ( isPlainObject ( data ) ) { const obj = { } ; for ( const prop in data ) { const keyChain = key ? ` ${ key } ${ prop } ` : prop ; const value = data [ prop ] ; if ( config [ keyChain ] !== false ) { if ( isPlainObject ( value ) ) { obj [ prop ] = serialise ( keyChain , value , config ) ; } else if ( value != null && typeof value === 'object' && 'toJSON' in value ) { obj [ prop ] = value . toJSON ( ) ; } else { obj [ prop ] = value ; } } } return obj ; } return config [ key ] !== false ? data : null ; } 
function explode ( store , data ) { if ( isPlainObject ( data ) ) { const obj = { } ; for ( const prop in data ) { obj [ prop ] = explode ( store , data [ prop ] ) ; } return obj ; } else if ( Array . isArray ( data ) ) { return data . map ( value => explode ( store , value ) ) ; } else if ( store . _isRefValue ( data ) ) { return explode ( store , store . get ( store . _parseRefKey ( data ) ) ) ; } return data ; } 
function serialise ( data ) { return keys ( data || { } ) . map ( encode_pair ) . filter ( Boolean ) . join ( '&' ) function encode_pair ( key ) { return data [ key ] != null ? encode ( key ) + '=' + encode ( data [ key ] ) : null } } 
function Subject ( failureStrategy , value ) { this . failureStrategy = failureStrategy ; this . value = value ; this . name = null ; this . format = format ; this . failureMessage = null ; } 
function ( json ) { 
function fsGenerator ( configs ) { var deferred = Q . defer ( ) ; var dirName = "" ; var destDir = "" ; var tmpDir = "" ; var refSrcDir = "" ; var destFolderDir = "" ; var dirType = "" ; var tempFolderName = "" ; var contentReplaceRegx = new RegExp ( "" , 'g' ) ; var replaceContentLength = 0 ; var ignoreExtentions = [ ] ; var ignoreFolders = [ ] ; var init = function ( ) { for ( var fls in configs ) { dirName = utils . folderName ( configs [ fls ] [ 'input' ] , configs [ fls ] [ 'folderName' ] ) ; dirType = configs [ fls ] [ 'type' ] ; destFolderDir = path . join ( configs [ fls ] [ 'destinationSourcePath' ] , dirName ) ; destDir = configs [ fls ] [ 'destinationSourcePath' ] ; tmpDir = configs [ fls ] [ 'tempFolderPath' ] ; tempFolderName = utils . getBaseFolderName ( tmpDir ) ; refSrcDir = configs [ fls ] [ 'refrenceSourcePath' ] ; ignoreExtentions = configs [ fls ] [ 'ignoreExts' ] || [ ] ; ignoreFolders = configs [ fls ] [ 'ignoreFolders' ] || [ ] ; contentReplaceRegx = new RegExp ( utils . regxContent ( configs [ fls ] [ 'replaceContent' ] ) , 'g' ) ; if ( configs [ fls ] [ 'replaceContent' ] ) { replaceContentLength = Object . keys ( configs [ fls ] [ 'replaceContent' ] ) . length ; } console . log ( ':::~~' + fls + ':::~~' ) ; folderSync ( configs [ fls ] ) ; } } ; var folderSync = function ( fls ) { if ( fs . existsSync ( destFolderDir ) ) { console . log ( ':::~~' + dirName + ' exists, please pick another name or delete previous to create new~~:::' ) deferred . reject ( fls . type + ' exists, please pick another name.' ) ; } else { console . log ( ':::~~' + dirName + ' does not exists, creating new~~:::' ) ; if ( ! fs . existsSync ( destFolderDir ) ) { fse . ensureDirSync ( destFolderDir ) ; console . log ( ':::~~Created new directory:' + fls . type + "/" + dirName + '~~:::' ) ; } * Copy refrence directory in temporary directory */ var copyRefToTemp = function ( ) { fse . emptyDirSync ( tmpDir ) ; fse . copySync ( refSrcDir , tmpDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to temp directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to temp directory' ) ; } console . log ( ':::~~ temp directory created~~:::' ) ; } ) ; } ; var updateTempSubDirNames = function ( fls ) { fs . readdirSync ( tmpDir ) . map ( function ( dir ) { var tempFolderPath = path . join ( tmpDir , dir ) ; if ( fs . statSync ( tempFolderPath ) . isDirectory ( ) ) { * Process nested folders in temp directory recently copied * @param {*} tempFolderPath */ var nestedDirectory = function ( tempFolderPath , fls ) { fs . readdirSync ( tempFolderPath ) . map ( function ( dir ) { var newTempFolderPath = path . join ( tempFolderPath , dir ) ; if ( fs . statSync ( newTempFolderPath ) . isDirectory ( ) ) { nestedDirectory ( newTempFolderPath , fls ) ; } else { processTempFolder ( newTempFolderPath , fls ) ; } } ) ; } var processTempFolder = function ( oldPath , fls ) { console . log ( ":::~~processing your temp folder and file~~:::" + oldPath ) ; var parsedPath = updateFileNamePath ( path . parse ( oldPath ) , fls ) ; var newPath = path . format ( parsedPath ) ; var firstFolderName = utils . getFirstFolderName ( oldPath , tempFolderName ) ; fs . renameSync ( oldPath , newPath ) ; if ( replaceContentLength > 0 && ignoreExtentions . indexOf ( parsedPath . ext ) < 0 && ignoreFolders . indexOf ( firstFolderName ) < 0 ) { console . log ( ":::~~writing your temp file~~:::" + newPath ) ; var oldContent = fs . readFileSync ( newPath , 'utf8' ) ; var newContent = updateFileContent ( oldContent , fls . replaceContent , fls ) ; fs . writeFileSync ( newPath , newContent ) ; } else { console . log ( ":::~~skipping writing of your temp file~~:::" + newPath ) ; } } var updateFileNamePath = function ( parsedPath , fls ) { * get array of folders from base temp path * @param {*} parsedPath */ var getNestedFolderName = function ( parsedPath ) { var tempPathArray = tmpDir . split ( "\\" ) ; var parsedPathArray = parsedPath . dir . split ( "\\" ) ; if ( parseInt ( tempPathArray . length ) === parseInt ( parsedPathArray . length ) ) { return "base" ; } else if ( parseInt ( tempPathArray . length ) < parseInt ( parsedPathArray . length ) ) { var folderNameArray = [ ] ; for ( var i in parsedPathArray ) { if ( i > parseInt ( tempPathArray . length ) - 1 ) { folderNameArray . push ( parsedPathArray [ i ] ) ; } } return folderNameArray ; } } var updateFileContent = function ( oldContent , replaceConfig , fls ) { var newContent = oldContent . replace ( contentReplaceRegx , function ( e ) { for ( var cont in replaceConfig ) { var contRegex = new RegExp ( cont , 'g' ) ; if ( e . match ( contRegex ) ) { var replaceValue = utils . getReplacableContent ( fls . input , replaceConfig [ cont ] ) ; return replaceValue ; } } } ) ; return newContent ; } ; var copyTempToDest = function ( ) { fse . emptyDirSync ( destFolderDir ) ; fse . copySync ( tmpDir , destFolderDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to destination directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to destination directory' ) ; } console . log ( ':::~~ destination directory created:' + dirName + '~~:::' ) ; } ) ; fse . emptyDirSync ( tmpDir ) ; console . log ( ':::~~Created new ' + dirType + " / " + dirName + ':::~~' ) ; } ; init ( configs ) ; } 
function ( ) { for ( var fls in configs ) { dirName = utils . folderName ( configs [ fls ] [ 'input' ] , configs [ fls ] [ 'folderName' ] ) ; dirType = configs [ fls ] [ 'type' ] ; destFolderDir = path . join ( configs [ fls ] [ 'destinationSourcePath' ] , dirName ) ; destDir = configs [ fls ] [ 'destinationSourcePath' ] ; tmpDir = configs [ fls ] [ 'tempFolderPath' ] ; tempFolderName = utils . getBaseFolderName ( tmpDir ) ; refSrcDir = configs [ fls ] [ 'refrenceSourcePath' ] ; ignoreExtentions = configs [ fls ] [ 'ignoreExts' ] || [ ] ; ignoreFolders = configs [ fls ] [ 'ignoreFolders' ] || [ ] ; contentReplaceRegx = new RegExp ( utils . regxContent ( configs [ fls ] [ 'replaceContent' ] ) , 'g' ) ; if ( configs [ fls ] [ 'replaceContent' ] ) { replaceContentLength = Object . keys ( configs [ fls ] [ 'replaceContent' ] ) . length ; } console . log ( ':::~~' + fls + ':::~~' ) ; folderSync ( configs [ fls ] ) ; } } 
function ( fls ) { if ( fs . existsSync ( destFolderDir ) ) { console . log ( ':::~~' + dirName + ' exists, please pick another name or delete previous to create new~~:::' ) deferred . reject ( fls . type + ' exists, please pick another name.' ) ; } else { console . log ( ':::~~' + dirName + ' does not exists, creating new~~:::' ) ; if ( ! fs . existsSync ( destFolderDir ) ) { fse . ensureDirSync ( destFolderDir ) ; console . log ( ':::~~Created new directory:' + fls . type + "/" + dirName + '~~:::' ) ; } 
function ( ) { fse . emptyDirSync ( tmpDir ) ; fse . copySync ( refSrcDir , tmpDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to temp directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to temp directory' ) ; } console . log ( ':::~~ temp directory created~~:::' ) ; } ) ; } 
function ( oldPath , fls ) { console . log ( ":::~~processing your temp folder and file~~:::" + oldPath ) ; var parsedPath = updateFileNamePath ( path . parse ( oldPath ) , fls ) ; var newPath = path . format ( parsedPath ) ; var firstFolderName = utils . getFirstFolderName ( oldPath , tempFolderName ) ; fs . renameSync ( oldPath , newPath ) ; if ( replaceContentLength > 0 && ignoreExtentions . indexOf ( parsedPath . ext ) < 0 && ignoreFolders . indexOf ( firstFolderName ) < 0 ) { console . log ( ":::~~writing your temp file~~:::" + newPath ) ; var oldContent = fs . readFileSync ( newPath , 'utf8' ) ; var newContent = updateFileContent ( oldContent , fls . replaceContent , fls ) ; fs . writeFileSync ( newPath , newContent ) ; } else { console . log ( ":::~~skipping writing of your temp file~~:::" + newPath ) ; } } 
function ( parsedPath , fls ) { 
function ( parsedPath ) { var tempPathArray = tmpDir . split ( "\\" ) ; var parsedPathArray = parsedPath . dir . split ( "\\" ) ; if ( parseInt ( tempPathArray . length ) === parseInt ( parsedPathArray . length ) ) { return "base" ; } else if ( parseInt ( tempPathArray . length ) < parseInt ( parsedPathArray . length ) ) { var folderNameArray = [ ] ; for ( var i in parsedPathArray ) { if ( i > parseInt ( tempPathArray . length ) - 1 ) { folderNameArray . push ( parsedPathArray [ i ] ) ; } } return folderNameArray ; } } 
function ( oldContent , replaceConfig , fls ) { var newContent = oldContent . replace ( contentReplaceRegx , function ( e ) { for ( var cont in replaceConfig ) { var contRegex = new RegExp ( cont , 'g' ) ; if ( e . match ( contRegex ) ) { var replaceValue = utils . getReplacableContent ( fls . input , replaceConfig [ cont ] ) ; return replaceValue ; } } } ) ; return newContent ; } 
function ( ) { fse . emptyDirSync ( destFolderDir ) ; fse . copySync ( tmpDir , destFolderDir , { overwrite : true } , err => { if ( err ) { console . log ( ':::~~error in copying to destination directory:' + err + '~~:::' ) ; fse . removeSync ( destFolderDir ) ; fse . emptyDirSync ( tmpDir ) ; deferred . reject ( 'Error in copying to destination directory' ) ; } console . log ( ':::~~ destination directory created:' + dirName + '~~:::' ) ; } ) ; fse . emptyDirSync ( tmpDir ) ; console . log ( ':::~~Created new ' + dirType + " / " + dirName + ':::~~' ) ; } 
function scan ( text ) { let sr = SReader . create ( text ) ; let tokens = [ ] ; while ( ! sr . isDone ( ) ) { tokens . push ( readNext ( sr ) ) ; } return tokens ; } 
function readNext ( sr ) { if ( sr . accept ( "<!" ) ) { return readComment ( sr ) ; } if ( sr . accept ( "<" ) ) { return readTag ( sr ) ; } return readText ( sr ) ; } 
function readText ( sr ) { let start = sr . getPos ( ) ; let value = sr . expectRE ( RE_TEXT ) ; return { type : "text" , start , value } ; } 
function readComment ( sr ) { let start = sr . getPos ( ) - 2 ; sr . expect ( "--" ) ; if ( ! sr . goto ( "-->" ) ) { throw Tools . syntaxError ( "Unterminated comment" , start ) ; } sr . expect ( "-->" ) ; return { type : "comment" , start } ; } 
function readTag ( sr ) { let start = sr . getPos ( ) - 1 ; let name ; if ( sr . accept ( "/" ) ) { name = sr . expectRE ( RE_TAG_NAME ) ; sr . expect ( ">" ) ; return { type : "tag_2" , start , name } ; } name = sr . expectRE ( RE_TAG_NAME ) ; let props = { } ; while ( true ) { sr . acceptRE ( RE_WS ) ; if ( sr . accept ( ">" ) ) { return { type : "tag_1" , start , name , props } ; } if ( sr . accept ( "/" ) ) { sr . expect ( ">" ) ; return { type : "tag_0" , start , name , props } ; } let pName = sr . expectRE ( RE_PROP_NAME ) ; sr . acceptRE ( RE_WS ) ; sr . expect ( "=" ) ; sr . acceptRE ( RE_WS ) ; sr . expect ( '"' ) ; let pValue = sr . expectRE ( RE_PROP_VALUE ) ; sr . expect ( '"' ) ; props [ pName ] = pValue ; } } 
function KeystoneClient ( url , options ) { options = options || { } ; if ( options . username ) { if ( ! options . password && ! options . apiKey ) { throw new Error ( 'If username is provided you also need to provide password or apiKey' ) ; } } this . _url = url ; this . _username = options . username ; this . _apiKey = options . apiKey ; this . _password = options . password ; this . _extraArgs = options . extraArgs || { } ; this . _cacheTokenFor = options . cacheTokenFor || DEFAULT_CACHE_TOKEN_FOR ; this . _token = null ; this . _tokenExpires = null ; this . _refreshTokenCompletions = [ ] ; this . _tokenUpdated = 0 ; this . _tenantId = null ; this . _serviceCatalog = [ ] ; } 
function packNode ( node ) { if ( node . type === "#" ) { return node . text ; } let item = [ node . type ] ; let hasProps = ( Object . keys ( node . props ) . length !== 0 ) ; if ( hasProps ) { item . push ( node . props ) ; } if ( node . children . length === 0 ) { return item ; } if ( ! hasProps ) { item . push ( 0 ) ; } node . children . forEach ( child => item . push ( packNode ( child ) ) ) ; return item ; } 
function unpackNode ( item ) { if ( ! Array . isArray ( item ) ) { return { type : "#" , text : item } ; } let node = { type : item [ 0 ] , props : item [ 1 ] || { } , children : [ ] } ; for ( let i = 2 ; i < item . length ; i ++ ) { node . children . push ( unpackNode ( item [ i ] ) ) ; } return node ; } 
function findAllParents ( p ) { var lastParent = p [ 0 ] ; var lastParentsParent = parents [ lastParent ] ; if ( lastParentsParent === undefined ) { return p ; } else { p . unshift ( lastParentsParent ) ; return findAllParents ( p ) ; } } 
function findDirectChildren ( className ) { var children = [ ] ; for ( var longname in parents ) { if ( parents [ longname ] === className ) { children . push ( longname ) ; } } return children ; } 
function makeHierarchyList ( classes ) { if ( classes . length === 0 ) { return '' ; } else { var className = classes . shift ( ) ; return '<ul><li>' + linkTo ( className ) + ' ' + makeHierarchyList ( classes ) + '</li></ul>' } } 
function makeChildrenList ( classes ) { var list = '<ul>' ; classes . forEach ( function ( className ) { list += '<li>' + linkTo ( className ) + '</li>' ; } ) list += '</ul>' ; return list ; } 
function ( e ) { var doclet = e . doclet ; if ( doclet . kind === 'class' && doclet . augments !== undefined && doclet . augments . length > 0 ) { parents [ doclet . longname ] = doclet . augments [ 0 ] ; } } 
function transform ( opts ) { var contents = opts . contents ; var index = opts . index ; var $ = cheerio . load ( contents ) ; $ ( 'link[href]' ) . each ( function ( ) { var el$ = $ ( this ) ; var href = el$ . attr ( 'href' ) ; var newHref = index . resolveLocalUrl ( href ) ; if ( href && href !== newHref ) { el$ . attr ( { 'data-appcache-href' : href , href : newHref } ) ; } } ) ; return $ . html ( ) ; } 
function ( json ) { 
function gotOption ( option ) { if ( map [ option ] ) { option = map [ option ] var name = option [ 0 ] 
function ( json ) { 
function Writer ( options ) { this . options = _ . defaults ( options || { } , { template : '' , data : _ . identity } ) ; Writable . call ( this , { objectMode : true } ) ; this . _commits = [ ] ; } 
function ( json ) { 
function parse_issues ( body ) { var issues = null ; var content = body . match ( / \s+(?:issues|closes)(?:,?\s#([^,\n]+))+ / i ) ; if ( content ) { issues = content [ 0 ] . match ( / #([^,\n\s]+) / g ) . map ( function ( issue ) { return issue . slice ( 1 ) ; } ) ; } return issues ; } 
function ( json ) { 
function getAllPathsAndOptionallySlice ( paths , state , slice = Immutable . List ( ) ) { let gotPaths = Immutable . List ( ) ; gotPaths = gotPaths . withMutations ( ( mutable ) => { paths . forEach ( ( gen ) => { if ( state . hasIn ( gen ) ) { let got = state . getIn ( gen ) ; if ( Immutable . List . isList ( got ) ) { if ( slice . size > 0 ) { mutable . push ( ... got . slice ( ... slice ) ) } else { mutable . push ( ... got ) } } else { mutable . push ( got ) ; } } } ) } ) ; return gotPaths ; } 
function ( json ) { 
function ( json ) { 
function execute ( template , data ) { let result = [ ] ; template . forEach ( node => executeNode ( node , data , result ) ) ; return result ; } 
function executeNode ( node , data , result ) { if ( node . type === "#" ) { executeText ( node , data , result ) ; return ; } if ( node . props . each ) { executeEach ( node , data , result ) ; return ; } if ( node . props . if ) { executeIf ( node , data , result ) ; return ; } if ( node . props . fi ) { executeFi ( node , data , result ) ; return ; } let props = { } ; Object . keys ( node . props ) . forEach ( key => { if ( key !== "each" && key !== "if" && key !== "fi" ) { props [ key ] = Extender . processProp ( node . props [ key ] , data ) ; } } ) ; let children = [ ] ; node . children . forEach ( child => executeNode ( child , data , children ) ) ; result . push ( { type : node . type , props , children } ) ; } 
function executeText ( node , data , result ) { result . push ( { type : "#" , text : Extender . processText ( node . text , data ) } ) ; } 
function executeEach ( node , data , result ) { let each = Extender . processEach ( node . props . each , data ) ; if ( ! each ) { return ; } let nextNode = { type : node . type , props : Object . assign ( { } , node . props ) , children : node . children } ; nextNode . props . each = null ; let nextData = Object . assign ( { } , data ) ; each . items . forEach ( item => { nextData [ each . item ] = item ; executeNode ( nextNode , nextData , result ) ; } ) ; } 
function executeFi ( node , data , result ) { if ( Extender . processExpr ( node . props . fi , data ) ) { return ; } let nextNode = { type : node . type , props : Object . assign ( { } , node . props ) , children : node . children } ; nextNode . props . fi = null ; executeNode ( nextNode , data , result ) ; } 
function GracefulExpress ( options ) { options = options || { } ; this . server = null ; this . graceful = null ; var startFile = process . mainModule . filename ; this . _setOption ( 'inProcessTest' , options , / mocha$ / . test ( startFile ) ) ; this . reaperPollInterval = options . reaperPollInterval || 500 ; util . verifyType ( 'number' , this , 'reaperPollInterval' ) ; this . shuttingDown = false ; this . _serverClosed = false ; this . _responses = [ ] ; this . _sockets = [ ] ; this . _activeSockets = [ ] ; 
function ( json ) { 
function invokeCallback ( cb , invokeMethod , valueOrReason , promise , type ) { var cbValue , cbError , errorThrown ; try { cbValue = cb [ invokeMethod ] ( null , valueOrReason ) ; } catch ( err ) { errorThrown = true , cbError = err ; } 
function ( key ) { var tmp = window . document . cookie . match ( ( new RegExp ( key + '=[^;]+($|;)' , 'gi' ) ) ) ; if ( ! tmp || ! tmp [ 0 ] ) { return null ; } else { return window . unescape ( tmp [ 0 ] . substring ( key . length + 1 , tmp [ 0 ] . length ) . replace ( ';' , '' ) ) || null ; } } 
function ( key , value , options ) { var cookie = [ key + '=' + window . escape ( value ) ] , seconds , minutes , days , months , years , expiryDate , addDays ; 
function ( name , info ) { if ( triggerPluginErrors ) { 
function ( coreArgs ) { var obj = { } , i ; 
function ( name , func , pluginName ) { if ( pluginName !== undefined ) { currentPluginName = pluginName ; } var eventCurrentPluginName = currentPluginName , 
function ( eve ) { capEve = eve . type . substring ( 0 , 1 ) . toUpperCase ( ) + eve . type . substring ( 1 ) ; coreObj [ 'on' + capEve ] = makeEvent ( eve . type ) ; pubsub . addEventType ( eve ) ; } 
function ( name ) { var i ; for ( i = 0 ; i < plugins . length ; i += 1 ) { if ( plugins [ i ] . name === name ) { return plugins [ i ] ; } } return false ; } 
function ( name , pluginObj ) { var hasPlugin = ! ! ( getPlugin ( name ) ) , i , j ; currentPluginName = name ; if ( ! hasPlugin ) { plugins . push ( { name : name , obj : pluginObj } ) ; setupPlugin ( plugins [ plugins . length - 1 ] ) ; } else { if ( pluginOverride ) { for ( i = 0 ; i < plugins . length ; i += 1 ) { if ( plugins [ i ] . name === name ) { 
function ( plugin , config ) { var i , pc = pluginConfig [ "*" ] ; config = ( config !== undefined ) ? config : pluginConfig [ plugin . name ] ; 
function ( json ) { 
function ( repo ) { return p . spawn ( 'git' , [ 'remote' , 'show' , program . remote ] , CHILD_IGNORE ) . then ( function ( ) { } , function ( e ) { return p . spawn ( 'git' , [ 'remote' , 'add' , program . remote , 'git@github.com:' + repo ] ) ; } ) ; } 
function ( repo , branchname ) { return ensureRemote ( repo ) . then ( function ( ) { return p . spawn ( 'git' , [ 'push' , program . remote , 'HEAD:refs/heads/' + branchname ] , CHILD_IGNORE ) ; } ) ; } 
function transform ( opts ) { var contents = opts . contents ; var filePath = opts . filePath ; var lastScript$ ; var $ = cheerio . load ( contents ) ; if ( path . basename ( filePath ) === 'index.html' ) { lastScript$ = findLastScript ( $ ) ; if ( lastScript$ ) { lastScript$ . after ( '<script src="require.load.js"></script>' ) ; } else { $ ( 'body' ) . append ( '<script src="require.load.js"></script>' ) ; } } return $ . html ( ) ; } 
function transform ( opts ) { var contents = opts . contents ; var filePath = opts . filePath ; var index = opts . index ; 
function _filterToShape ( mutable , obj , shape , path = [ ] , fullObj = null ) { if ( fullObj === null ) { fullObj = obj ; } 
function recordSpeed ( child , speed ) { child . runCount += sampleSize if ( passCount > 1 ) { var square = Math . pow ( speed - child . speed , 2 ) child . variance += ( square - child . variance ) / ( passCount - 1 ) } child . speed += ( speed - child . speed ) / passCount } 
function nextChild ( ) { child = children [ childIndex ++ ] if ( child ) { fn = child . fn runIndex = 0 var runFn = / ^function.*?\([^\s\)] / . test ( fn . toString ( ) ) ? runAsync : runSync start = process . hrtime ( ) runFn ( ) } else { calculateStats ( ) } } 
function runSync ( ) { for ( runIndex = 0 ; runIndex < sampleSize ; runIndex ++ ) { fn . call ( child ) } setTimeout ( finishChild , 0 ) } 
function runAsync ( ) { if ( runIndex ++ < sampleSize ) { fn . call ( child , function ( ) { setTimeout ( runAsync , 0 ) } ) } else { setTimeout ( finishChild , 0 ) } } 
function fileToReadable ( file ) { class VFileReadable extends stream . Readable { _read ( ) { this . push ( file ) ; this . push ( null ) ; } } return new VFileReadable ( { objectMode : true } ) ; } 
function transformDOMText ( opts ) { return new Promise ( ( resolve , reject ) => { var file = new VFile ( { path : opts . filePath , contents : new Buffer ( opts . getText ( opts . el$ ) , 'utf8' ) 
function transform ( opts ) { var contents = opts . contents ; var $ = cheerio . load ( contents ) ; var cssTransforms = opts . fetcher . transforms . css . map ( ( tf ) => tf ( { fetcher : opts . fetcher , index : opts . index } ) ) ; 
function ( json ) { 
function instance ( state , methods ) { let api = { } ; Object . keys ( methods ) . forEach ( key => { api [ key ] = methods [ key ] . bind ( null , state ) ; } ) ; return api ; } 
function syntaxError ( message , pos ) { let err = Error ( message ) ; err . name = "SyntaxError" ; err . pos = pos ; return err ; } 
function watch ( dir ) { if ( ! ignoreDir . test ( dir ) && ! map [ dir ] ) { fs . lstat ( dir , function ( e , stat ) { if ( ! e ) { if ( stat . isSymbolicLink ( ) ) { var source = dir fs . readlink ( source , function ( e , link ) { if ( ! e ) { var dest = link if ( dest [ 0 ] !== '/' ) { while ( dest . substr ( 0 , 3 ) === '../' ) { dest = dest . substr ( 3 ) source = source . replace ( / \/[^\/]+$ / , '' ) } if ( dest . substr ( 0 , 2 ) === './' ) { dest = dest . substr ( 2 ) } dest = source + '/' + dest } watch ( dest ) } } ) } else if ( stat . isDirectory ( ) ) { addDir ( dir , stat ) } else { dir = dirname ( dir ) map [ dir ] = Math . max ( map [ dir ] , stat . mtime . getTime ( ) ) } } } ) } } 
function addDir ( dir , stat ) { var mtime = stat . mtime . getTime ( ) if ( ! map [ dir ] && list . length <= maxListSize ) { map [ dir ] = mtime list . push ( dir ) clearTimeout ( sortList . timer ) sortList . timer = setTimeout ( sortList , checkInterval ) fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . forEach ( function ( file ) { watch ( dir + '/' + file ) } ) } } ) } } 
function startWatches ( ) { list . forEach ( function ( dir , i ) { if ( i < maxFsWatches ) { try { fs . watch ( dir , function ( op , file ) { notify ( dir + '/' + file ) } ) } catch ( e ) { 
function checkDir ( ) { var n = indexes [ i ] if ( i > 44 ) { indexes [ i ] = ( indexes [ i ] + 5 ) % list . length } i = ( i + 1 ) % indexes . length var dir = list [ n ] if ( dir ) { fs . stat ( dir , function ( e , stat ) { if ( ! e && ( stat . mtime > okToNotifyAfter ) ) { fs . readdir ( dir , function ( e , files ) { if ( ! e ) { files . forEach ( function ( file ) { var path = dir + '/' + file fs . stat ( path , function ( e , stat ) { if ( ! e && ( stat . mtime > okToNotifyAfter ) ) { notify ( path ) } } ) } ) } } ) } } ) } } 
function notify ( path ) { var now = Date . now ( ) if ( ( now > okToNotifyAfter ) && ! ignoreFile . test ( path ) ) { process . send ( path ) okToNotifyAfter = now + notifyInterval sortList ( ) } } 
function Graceful ( options ) { options = options || { } ; this . shuttingDown = false ; this . _checks = [ ] ; this . _sending = false ; this . pollInterval = options . pollInterval || 250 ; localUtil . verifyType ( 'number' , this , 'pollInterval' ) ; this . timeout = options . timeout || 5 * 1000 ; localUtil . verifyType ( 'number' , this , 'timeout' ) ; this . messenger = options . messenger || require ( 'thehelp-last-ditch' ) ; localUtil . verifyType ( 'function' , this , 'messenger' ) ; this . log = options . log || logShim ( 'thehelp-cluster:graceful' ) ; localUtil . verifyLog ( this . log ) ; var _this = this ; this . addCheck ( function areWeSending ( ) { return _this . _sending === false ; } ) ; this . _process = options . _process || process ; this . _cluster = options . _cluster || cluster ; this . _logPrefix = localUtil . getLogPrefix ( ) ; this . _setupListeners ( ) ; if ( Graceful . instance ) { this . log . warn ( 'More than one Graceful instance created in this process. ' + 'There are now duplicate process-level wireups!' ) ; } Graceful . instance = this ; } 
function decorateFn ( fn ) { fn . returns = function ( value ) { fn . _returns = value return fn } return fn } 
function MockDate ( value ) { 
function moveTime ( ) { if ( mock . time . _SPEED ) { 
function getScheduler ( isInterval ) { return function ( fn , time ) { schedules . push ( { id : ++ schedules . id , fn : fn , time : Date . now ( ) + time , interval : isInterval ? time : false } ) } } 
function getUnscheduler ( ) { 
function runSchedules ( ) { 
function Startup ( options ) { options = options || { } ; this . _logPrefix = util . getLogPrefix ( ) ; this . worker = options . worker ; if ( ! this . worker ) { throw new Error ( 'Need to provide a worker callback!' ) ; } util . verifyType ( 'function' , this , 'worker' ) ; this . _stats = options . stats || new StatsD ( { prefix : process . env . THEHELP_APP_NAME + '.' } ) ; this . log = options . log || logShim ( 'thehelp-cluster:startup' ) ; util . verifyLog ( this . log ) ; this . masterOptions = options . masterOptions ; this . master = options . master || this . _defaultMasterStart . bind ( this ) ; util . verifyType ( 'function' , this , 'master' ) ; this . graceful = options . graceful || Graceful . instance ; 
function startGc ( db , options ) { this . options = options || { } var freqMs = options . gcFreqMs || 60000 var maxVersions = options . gcMaxVersions var maxAge = options . gcMaxAge var backup = options . gcBackup var callback = options . gcCallback if ( maxAge || maxVersions ) { maxAge = maxAge || Math . pow ( 2 , 53 ) maxVersion = maxVersions || Math . pow ( 2 , 53 ) function filter ( record ) { if ( record . version != null ) { if ( Date . now ( ) - record . version > maxAge ) return true } if ( record . key != this . currentKey ) { this . currentKey = record . key this . currentCount = 0 } return this . currentCount ++ >= maxVersions } this . scanner = gc ( db , filter , backup ) return looseInterval ( scanner . run . bind ( scanner ) , freqMs , callback ) } } 
function pipeTransforms ( stream , transforms ) { var head , rest ; if ( ! Array . isArray ( transforms ) || ! transforms . length ) { return stream ; } head = transforms [ 0 ] ; rest = transforms . slice ( 1 ) ; 
function streamify ( opts , transform ) { return through2 . obj ( 
function ( entry ) { var parsed = url . parse ( entry , true , true ) ; return ! parsed . protocol || values . FETCH_PROTOCOLS . indexOf ( parsed . protocol ) !== - 1 ; } 
function ( json ) { 
function ( json ) { 
function ( json ) { 
function forceInRange ( value , min , max ) { if ( value > max ) { return max ; } else if ( value < min ) { return min ; } else { return value ; } } 
function insertIntoList ( item , position , list ) { var before = list . slice ( 0 , position ) ; var after = list . slice ( position ) ; return before . push ( item ) . concat ( after ) } 
function parse ( tokens ) { let tr = TReader . create ( prepareTokens ( tokens ) ) ; let nodes = [ ] ; while ( true ) { if ( tr . accept ( "$" ) ) { return nodes ; } if ( tr . accept ( "text" ) ) { nodes . push ( parseText ( tr ) ) ; } else if ( tr . accept ( "tag_0" ) ) { nodes . push ( parseTag0 ( tr ) ) ; } else { tr . expect ( "tag_1" ) ; nodes . push ( parseTag1 ( tr ) ) ; } } } 
function prepareTokens ( tokens ) { let result = [ ] ; let lastToken = null ; tokens . forEach ( token => { let newToken = null ; if ( token . type === "text" ) { let value = token . value . replace ( GRE_WS , " " ) . trim ( ) ; if ( value !== "" ) { if ( lastToken && lastToken . type === "text" ) { lastToken . value += value ; } else { newToken = { type : "text" , start : token . start , value } ; } } } else if ( token . type !== "comment" ) { newToken = token ; } if ( newToken ) { result . push ( newToken ) ; lastToken = newToken ; } } ) ; result . push ( { type : "$" } ) ; return result ; } 
function parseTag1 ( tr ) { let startToken = tr . getToken ( ) ; let node = initTagNode ( startToken ) ; while ( true ) { if ( tr . accept ( "text" ) ) { node . children . push ( parseText ( tr ) ) ; } else if ( tr . accept ( "tag_0" ) ) { node . children . push ( parseTag0 ( tr ) ) ; } else if ( tr . accept ( "tag_1" ) ) { node . children . push ( parseTag1 ( tr ) ) ; } else if ( tr . accept ( "tag_2" ) ) { let token = tr . getToken ( ) ; if ( token . name !== startToken . name ) { let msg = ` ${ token . name } ` ; throw Tools . syntaxError ( msg , token . start ) ; } return node ; } else { let msg = ` ${ startToken . name } ` ; throw Tools . syntaxError ( msg , startToken . start ) ; } } } 
function initTagNode ( token ) { validateProps ( token ) ; return { type : token . name , props : token . props , children : [ ] } ; } 
function validateProps ( token ) { Object . keys ( token . props ) . forEach ( key => { if ( ! validateProp ( key , token . props [ key ] ) ) { throw Tools . syntaxError ( ` ${ key } ` , token ) ; } } ) ; } 
function validateProp ( key , value ) { switch ( key ) { case "each" : return Extender . validateEach ( value ) ; case "if" : case "fi" : return Extender . validateExpr ( value ) ; default : return true ; } } 
function processProp ( value , data ) { return RE_EXPR . test ( value ) ? processExpr ( value , data ) : processText ( value , data ) ; } 
function processText ( value , data ) { return value . replace ( GRE_EXPR , m => { let res = processExpr ( m , data ) ; return Tools . isVoid ( res ) ? "" : res + "" ; } ) . replace ( GRE_WS , " " ) . trim ( ) ; } 
function processExpr ( value , data ) { if ( value === "true" ) { return true ; } if ( value === "false" ) { return false ; } let m = value . match ( RE_EXPR ) ; if ( ! m ) { return null ; } return m [ 1 ] ? processPath ( m [ 1 ] , data ) : parseFloat ( m [ 2 ] ) ; } 
function processEach ( value , data ) { let m = value . match ( RE_EACH ) ; if ( ! m ) { return null ; } let items = processPath ( m [ 2 ] , data ) ; if ( ! Array . isArray ( items ) ) { items = [ ] ; } return { item : m [ 1 ] , items } ; } 
function processPathArray ( path , data ) { if ( ! data ) { return null ; } let value = data [ path [ 0 ] ] ; return path . length > 1 ? processPathArray ( path . slice ( 1 ) , value ) : value ; } 
function Event ( name , attributes ) { this . _name = name ; this . _stopped = false ; this . _attrs = { } ; if ( attributes ) { this . setAttributes ( attributes ) ; } } 
function readUInt64BE ( buf , offset ) { if ( offset ) { buf = buf . slice ( offset , offset + 8 ) ; } 
function create ( text ) { return Tools . instance ( { text , pos : 0 } , { isDone , getPos , expect , accept , expectRE , acceptRE , goto } ) ; } 
function expectRE ( $ , regexp ) { let str = acceptRE ( $ , regexp ) ; if ( str === null ) { throw Tools . syntaxError ( "Unexpected character" , $ . pos ) ; } return str ; } 
function accept ( $ , str ) { if ( ! $ . text . startsWith ( str , $ . pos ) ) { return false ; } $ . pos += str . length ; return true ; } 
function acceptRE ( $ , regexp ) { let m = $ . text . substr ( $ . pos ) . match ( regexp ) ; if ( ! m ) { return null ; } let str = m [ 0 ] ; $ . pos += str . length ; return str ; } 
function goto ( $ , str ) { let index = $ . text . indexOf ( "-->" , $ . pos ) ; if ( index === - 1 ) { return false ; } $ . pos = index ; return true ; } 
function transform ( opts ) { var contents = opts . contents ; var $ = cheerio . load ( contents ) ; $ ( 'html' ) . removeAttr ( 'manifest' ) ; 
function ( json ) { 
function ( json ) { 
function expect ( $ , type ) { if ( ! accept ( $ , type ) ) { let token = $ . tokens [ $ . pos ] ; throw Tools . syntaxError ( "Unexpected token" , token . start ) ; } } 
function accept ( $ , type ) { let token = $ . tokens [ $ . pos ] ; if ( token . type !== type ) { return false ; } $ . pos ++ ; return true ; } 
function Master ( options ) { options = options || { } ; this . _workers = { } ; this . shuttingDown = false ; this . spinTimeout = options . spinTimeout || 10 * 1000 ; util . verifyType ( 'number' , this , 'spinTimeout' ) ; this . delayStart = options . delayStart || 60 * 1000 ; util . verifyType ( 'number' , this , 'delayStart' ) ; this . pollInterval = options . pollInterval || 500 ; util . verifyType ( 'number' , this , 'pollInterval' ) ; this . killTimeout = options . killTimeout || 7000 ; util . verifyType ( 'number' , this , 'killTimeout' ) ; this . numberWorkers = options . numberWorkers || parseInt ( process . env . THEHELP_NUMBER_WORKERS , 10 ) || 1 ; util . verifyType ( 'number' , this , 'numberWorkers' ) ; this . setGraceful ( options . graceful || Graceful . instance ) ; this . log = options . log || logShim ( 'thehelp-cluster:master' ) ; util . verifyLog ( options . log ) ; this . _cluster = options . _cluster || cluster ; this . _cluster . on ( 'disconnect' , this . _restartWorker . bind ( this ) ) ; if ( Master . instance ) { this . log . warn ( 'More than one Master instance created in this process. ' + 'You\'ll have more worker processes than you signed up for!' ) ; } Master . instance = this ; } 
function ( json ) { 
function Topic ( name , options , emitter ) { this . name = name ; this . subscribers = [ ] ; this . queue = [ ] ; this . publishedEvents = { } ; this . options = options || { } ; this . emitter = emitter ; } 
function PubSub ( name , options ) { EventEmitter . call ( this ) ; this . name = name ; this . topics = { } ; this . options = options || { strict : true } ; } 
function asyncForEach ( array , iterator , done ) { if ( array . length === 0 ) { 
function readdirAsync ( dir , options , callback , internalOptions ) { if ( typeof options === 'function' ) { callback = options ; options = undefined ; } return maybe ( callback , new Promise ( ( ( resolve , reject ) => { let results = [ ] ; internalOptions . facade = asyncFacade ; let reader = new DirectoryReader ( dir , options , internalOptions ) ; let stream = reader . stream ; stream . on ( 'error' , err => { reject ( err ) ; stream . pause ( ) ; } ) ; stream . on ( 'data' , result => { results . push ( result ) ; } ) ; stream . on ( 'end' , ( ) => { resolve ( results ) ; } ) ; } ) ) ) ; } 
function safeCall ( fn , args ) { 
function callOnce ( fn ) { let fulfilled = false ; return function onceWrapper ( err ) { if ( ! fulfilled ) { fulfilled = true ; return fn . apply ( this , arguments ) ; } else if ( err ) { 
function readdirAsyncStat ( dir , options , callback ) { return readdirAsync ( dir , options , callback , { stats : true } ) ; } 
function normalizeOptions ( options , internalOptions ) { if ( options === null || options === undefined ) { options = { } ; } else if ( typeof options !== 'object' ) { throw new TypeError ( 'options must be an object' ) ; } let recurseDepth , recurseFn , recurseRegExp , recurseGlob , deep = options . deep ; if ( deep === null || deep === undefined ) { recurseDepth = 0 ; } else if ( typeof deep === 'boolean' ) { recurseDepth = deep ? Infinity : 0 ; } else if ( typeof deep === 'number' ) { if ( deep < 0 || isNaN ( deep ) ) { throw new Error ( 'options.deep must be a positive number' ) ; } else if ( Math . floor ( deep ) !== deep ) { throw new Error ( 'options.deep must be an integer' ) ; } else { recurseDepth = deep ; } } else if ( typeof deep === 'function' ) { recurseDepth = Infinity ; recurseFn = deep ; } else if ( deep instanceof RegExp ) { recurseDepth = Infinity ; recurseRegExp = deep ; } else if ( typeof deep === 'string' && deep . length > 0 ) { recurseDepth = Infinity ; recurseGlob = globToRegExp ( deep , { extended : true , globstar : true } ) ; } else { throw new TypeError ( 'options.deep must be a boolean, number, function, regular expression, or glob pattern' ) ; } let filterFn , filterRegExp , filterGlob , filter = options . filter ; if ( filter !== null && filter !== undefined ) { if ( typeof filter === 'function' ) { filterFn = filter ; } else if ( filter instanceof RegExp ) { filterRegExp = filter ; } else if ( typeof filter === 'string' && filter . length > 0 ) { filterGlob = globToRegExp ( filter , { extended : true , globstar : true } ) ; } else { throw new TypeError ( 'options.filter must be a function, regular expression, or glob pattern' ) ; } } let sep = options . sep ; if ( sep === null || sep === undefined ) { sep = path . sep ; } else if ( typeof sep !== 'string' ) { throw new TypeError ( 'options.sep must be a string' ) ; } let basePath = options . basePath ; if ( basePath === null || basePath === undefined ) { basePath = '' ; } else if ( typeof basePath === 'string' ) { 
function stat ( fs , path , callback ) { let isSymLink = false ; call . safe ( fs . lstat , path , ( err , lstats ) => { if ( err ) { 
function symlinkStat ( fs , path , lstats , callback ) { call . safe ( fs . stat , path , ( err , stats ) => { if ( err ) { 
function readdirStream ( dir , options , internalOptions ) { internalOptions . facade = streamFacade ; let reader = new DirectoryReader ( dir , options , internalOptions ) ; return reader . stream ; } 
function syncForEach ( array , iterator , done ) { array . forEach ( item => { iterator ( item , ( ) => { 
function readdirSync ( dir , options , internalOptions ) { internalOptions . facade = syncFacade ; let reader = new DirectoryReader ( dir , options , internalOptions ) ; let stream = reader . stream ; let results = [ ] ; let data = stream . read ( ) ; while ( data !== null ) { results . push ( data ) ; data = stream . read ( ) ; } return results ; } 
function stat ( path , opts ) { return new Promise ( ( resolve , reject ) => { statProvider . async ( path , optionsManager . prepare ( opts ) , ( err , stats ) => err ? reject ( err ) : resolve ( stats ) ) ; } ) ; } 
function uniqNoSet ( arr ) { var ret = [ ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ret . indexOf ( arr [ i ] ) === - 1 ) { ret . push ( arr [ i ] ) ; } } return ret ; } 
function uniqSetWithForEach ( arr ) { var ret = [ ] ; ( new Set ( arr ) ) . forEach ( function ( el ) { ret . push ( el ) ; } ) ; return ret ; } 
function doesForEachActuallyWork ( ) { var ret = false ; ( new Set ( [ true ] ) ) . forEach ( function ( el ) { ret = el ; } ) ; return ret === true ; } 
function Base ( config , options ) { if ( ! ( this instanceof Base ) ) { return new Base ( config , options ) ; } Cache . call ( this , config ) ; this . is ( 'base' ) ; this . initBase ( config , options ) ; } 
function braces ( pattern , options ) { var key = utils . createKey ( String ( pattern ) , options ) ; var arr = [ ] ; var disabled = options && options . cache === false ; if ( ! disabled && cache . hasOwnProperty ( key ) ) { return cache [ key ] ; } if ( Array . isArray ( pattern ) ) { for ( var i = 0 ; i < pattern . length ; i ++ ) { arr . push . apply ( arr , braces . create ( pattern [ i ] , options ) ) ; } } else { arr = braces . create ( pattern , options ) ; } if ( options && options . nodupes === true ) { arr = unique ( arr ) ; } if ( ! disabled ) { cache [ key ] = arr ; } return arr ; } 
function memoize ( type , pattern , options , fn ) { var key = utils . createKey ( type + ':' + pattern , options ) ; var disabled = options && options . cache === false ; if ( disabled ) { braces . clearCache ( ) ; return fn ( pattern , options ) ; } if ( cache . hasOwnProperty ( key ) ) { return cache [ key ] ; } var res = fn ( pattern , options ) ; cache [ key ] = res ; return res ; } 
function multiply ( queue , n , options ) { return utils . flatten ( utils . repeat ( utils . arrayify ( queue ) , n ) ) ; } 
function isOptimized ( node , options ) { if ( node . parent . isOptimized ) return true ; return isType ( node . parent , 'brace' ) && ! isEscaped ( node . parent ) && options . expand !== true ; } 
function noInner ( node , type ) { if ( node . parent . queue . length === 1 ) { return true ; } var nodes = node . parent . nodes ; return nodes . length === 3 && isType ( nodes [ 0 ] , 'brace.open' ) && ! isType ( nodes [ 1 ] , 'text' ) && isType ( nodes [ 2 ] , 'brace.close' ) ; } 
function concatNodes ( pos , node , parent , options ) { node . orig = node . val ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; var isEscaped = false ; if ( node . val . length > 1 ) { var a = node . val . charAt ( 0 ) ; var b = node . val . slice ( - 1 ) ; isEscaped = ( a === '"' && b === '"' ) || ( a === "'" && b === "'" ) || ( a === '`' && b === '`' ) ; } if ( isEscaped && options . unescape !== false ) { node . val = node . val . slice ( 1 , node . val . length - 1 ) ; node . escaped = true ; } if ( node . match ) { var match = node . match [ 1 ] ; if ( ! match || match . indexOf ( '}' ) === - 1 ) { match = node . match [ 0 ] ; } 
function enable ( namespaces ) { exports . save ( namespaces ) ; exports . names = [ ] ; exports . skips = [ ] ; var i ; var split = ( typeof namespaces === 'string' ? namespaces : '' ) . split ( / [\s,]+ / ) ; var len = split . length ; for ( i = 0 ; i < len ; i ++ ) { if ( ! split [ i ] ) continue ; 
function brackets ( pattern , options ) { debug ( 'initializing from <%s>' , __filename ) ; var res = brackets . create ( pattern , options ) ; return res . output ; } 
function parsers ( brackets ) { brackets . state = brackets . state || { } ; brackets . parser . sets . bracket = brackets . parser . sets . bracket || [ ] ; brackets . parser . capture ( 'escape' , function ( ) { if ( this . isInside ( 'bracket' ) ) return ; var pos = this . position ( ) ; var m = this . match ( / ^\\(.) / ) ; if ( ! m ) return ; return pos ( { type : 'escape' , val : m [ 0 ] } ) ; } ) . capture ( 'text' , function ( ) { if ( this . isInside ( 'bracket' ) ) return ; var pos = this . position ( ) ; var m = this . match ( not ) ; if ( ! m || ! m [ 0 ] ) return ; return pos ( { type : 'text' , val : m [ 0 ] } ) ; } ) . capture ( 'posix' , function ( ) { var pos = this . position ( ) ; var m = this . match ( / ^\[:(.*?):\](?=.*\]) / ) ; if ( ! m ) return ; var inside = this . isInside ( 'bracket' ) ; if ( inside ) { brackets . posix ++ ; } return pos ( { type : 'posix' , insideBracket : inside , inner : m [ 1 ] , val : m [ 0 ] } ) ; } ) . capture ( 'bracket' , function ( ) { } ) . capture ( 'bracket.open' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( / ^\[(?=.*\]) / ) ; if ( ! m ) return ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; if ( parsed . slice ( - 1 ) === '\\' && ! this . isInside ( 'bracket' ) ) { last . val = last . val . slice ( 0 , last . val . length - 1 ) ; return pos ( { type : 'escape' , val : m [ 0 ] } ) ; } var open = pos ( { type : 'bracket.open' , val : m [ 0 ] } ) ; if ( last . type === 'bracket.open' || this . isInside ( 'bracket' ) ) { open . val = '\\' + open . val ; open . type = 'bracket.inner' ; open . escaped = true ; return open ; } var node = pos ( { type : 'bracket' , nodes : [ open ] } ) ; define ( node , 'parent' , prev ) ; define ( open , 'parent' , node ) ; this . push ( 'bracket' , node ) ; prev . nodes . push ( node ) ; } ) . capture ( 'bracket.inner' , function ( ) { if ( ! this . isInside ( 'bracket' ) ) return ; var pos = this . position ( ) ; var m = this . match ( not ) ; if ( ! m || ! m [ 0 ] ) return ; var next = this . input . charAt ( 0 ) ; var val = m [ 0 ] ; var node = pos ( { type : 'bracket.inner' , val : val } ) ; if ( val === '\\\\' ) { return node ; } var first = val . charAt ( 0 ) ; var last = val . slice ( - 1 ) ; if ( first === '!' ) { val = '^' + val . slice ( 1 ) ; } if ( last === '\\' || ( val === '^' && next === ']' ) ) { val += this . input [ 0 ] ; this . consume ( 1 ) ; } node . val = val ; return node ; } ) . capture ( 'bracket.close' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( / ^\] / ) ; if ( ! m ) return ; var prev = this . prev ( ) ; var last = utils . last ( prev . nodes ) ; if ( parsed . slice ( - 1 ) === '\\' && ! this . isInside ( 'bracket' ) ) { last . val = last . val . slice ( 0 , last . val . length - 1 ) ; return pos ( { type : 'escape' , val : m [ 0 ] } ) ; } var node = pos ( { type : 'bracket.close' , rest : this . input , val : m [ 0 ] } ) ; if ( last . type === 'bracket.open' ) { node . type = 'bracket.inner' ; node . escaped = true ; return node ; } var bracket = this . pop ( 'bracket' ) ; if ( ! this . isType ( bracket , 'bracket' ) ) { if ( this . options . strict ) { throw new Error ( 'missing opening "["' ) ; } node . type = 'bracket.inner' ; node . escaped = true ; return node ; } bracket . nodes . push ( node ) ; define ( node , 'parent' , bracket ) ; } ) ; } 
function fillRange ( a , b , step , options , fn ) { if ( a == null || b == null ) { throw new Error ( 'fill-range expects the first and second args to be strings.' ) ; } if ( typeof step === 'function' ) { fn = step ; options = { } ; step = null ; } if ( typeof options === 'function' ) { fn = options ; options = { } ; } if ( isObject ( step ) ) { options = step ; step = '' ; } var expand , regex = false , sep = '' ; var opts = options || { } ; if ( typeof opts . silent === 'undefined' ) { opts . silent = true ; } step = step || opts . step ; 
function wrap ( arr , sep , opts ) { if ( sep === '~' ) { sep = '-' ; } var str = arr . join ( sep ) ; var pre = opts && opts . regexPrefix ; 
function isCharClass ( a , b , step , isNum , isDescending ) { if ( isDescending ) { return false ; } if ( isNum ) { return a <= 9 && b <= 9 ; } if ( a < b ) { return step === 1 ; } return false ; } 
function shouldExpand ( a , b , num , isNum , padding , opts ) { if ( isNum && ( a > 9 || b > 9 ) ) { return false ; } return ! padding && num === 1 && a < b ; } 
function detectSeparator ( a , b , step , isNum , isDescending ) { var isChar = isCharClass ( a , b , step , isNum , isDescending ) ; if ( ! isChar ) { return '|' ; } return '~' ; } 
function formatPadding ( ch , pad ) { var res = pad ? pad + ch : ch ; if ( pad && ch . toString ( ) . charAt ( 0 ) === '-' ) { res = '-' + pad + ch . toString ( ) . substr ( 1 ) ; } return res . toString ( ) ; } 
function isInvalidChar ( str ) { var ch = toStr ( str ) ; return ch === '\\' || ch === '[' || ch === ']' || ch === '^' || ch === '(' || ch === ')' || ch === '`' ; } 
function isPadded ( origA , origB ) { if ( hasZeros ( origA ) || hasZeros ( origB ) ) { var alen = length ( origA ) ; var blen = length ( origB ) ; var len = alen >= blen ? alen : blen ; return function ( a ) { return repeatStr ( '0' , len - length ( a ) ) ; } ; } return false ; } 
function Extglob ( options ) { this . options = extend ( { source : 'extglob' } , options ) ; this . snapdragon = this . options . snapdragon || new Snapdragon ( this . options ) ; this . snapdragon . patterns = this . snapdragon . patterns || { } ; this . compiler = this . snapdragon . compiler ; this . parser = this . snapdragon . parser ; compilers ( this . snapdragon ) ; parsers ( this . snapdragon ) ; define ( this . snapdragon , 'parse' , function ( str , options ) { var parsed = Snapdragon . prototype . parse . apply ( this , arguments ) ; parsed . input = str ; * Decorate `.parse` method */ define ( this , 'parse' , function ( ast , options ) { return this . snapdragon . parse . apply ( this . snapdragon , arguments ) ; } ) ; define ( this , 'compile' , function ( ast , options ) { return this . snapdragon . compile . apply ( this . snapdragon , arguments ) ; } ) ; } 
function micromatch ( list , patterns , options ) { patterns = utils . arrayify ( patterns ) ; list = utils . arrayify ( list ) ; var len = patterns . length ; if ( list . length === 0 || len === 0 ) { return [ ] ; } if ( len === 1 ) { return micromatch . match ( list , patterns [ 0 ] , options ) ; } var omit = [ ] ; var keep = [ ] ; var idx = - 1 ; while ( ++ idx < len ) { var pattern = patterns [ idx ] ; if ( typeof pattern === 'string' && pattern . charCodeAt ( 0 ) === 33 ) { omit . push . apply ( omit , micromatch . match ( list , pattern . slice ( 1 ) , options ) ) ; } else { keep . push . apply ( keep , micromatch . match ( list , pattern , options ) ) ; } } var matches = utils . diff ( keep , omit ) ; if ( ! options || options . nodupes !== false ) { return utils . unique ( matches ) ; } return matches ; } 
function memoize ( type , pattern , options , fn ) { var key = utils . createKey ( type + '=' + pattern , options ) ; if ( options && options . cache === false ) { return fn ( pattern , options ) ; } if ( cache . has ( type , key ) ) { return cache . get ( type , key ) ; } var val = fn ( pattern , options ) ; cache . set ( type , key , val ) ; return val ; } 
function visit ( node , fn ) { return node . nodes ? mapVisit ( node . nodes , fn ) : fn ( node ) ; } 
function mapVisit ( nodes , fn ) { var len = nodes . length ; var idx = - 1 ; while ( ++ idx < len ) { visit ( nodes [ idx ] , fn ) ; } } 
function textRegex ( pattern ) { var notStr = regexNot . create ( pattern , { contains : true , strictClose : false } ) ; var prefix = '(?:[\\^]|\\\\|' ; return toRegex ( prefix + notStr + ')' , { strictClose : false } ) ; } 
function sync ( source , opts ) { var works = getWorks ( source , reader_sync_1 . default , opts ) ; return arrayUtils . flatten ( works ) ; } 
function async ( source , opts ) { var works = getWorks ( source , reader_async_1 . default , opts ) ; return Promise . all ( works ) . then ( arrayUtils . flatten ) ; } 
function stream ( source , opts ) { var works = getWorks ( source , reader_stream_1 . default , opts ) ; return merge2 ( works ) ; } 
function generateTasks ( source , opts ) { var patterns = [ ] . concat ( source ) ; var options = optionsManager . prepare ( opts ) ; return taskManager . generate ( patterns , options ) ; } 
function getWorks ( source , _Reader , opts ) { var patterns = [ ] . concat ( source ) ; var options = optionsManager . prepare ( opts ) ; var tasks = taskManager . generate ( patterns , options ) ; var reader = new _Reader ( options ) ; return tasks . map ( reader . read , reader ) ; } 
function generate ( patterns , options ) { var unixPatterns = patterns . map ( patternUtils . unixifyPattern ) ; var unixIgnore = options . ignore . map ( patternUtils . unixifyPattern ) ; var positivePatterns = getPositivePatterns ( unixPatterns ) ; var negativePatterns = getNegativePatternsAsPositive ( unixPatterns , unixIgnore ) ; var staticPatterns = positivePatterns . filter ( patternUtils . isStaticPattern ) ; var dynamicPatterns = positivePatterns . filter ( patternUtils . isDynamicPattern ) ; var staticTasks = convertPatternsToTasks ( staticPatterns , negativePatterns , false ) ; var dynamicTasks = convertPatternsToTasks ( dynamicPatterns , negativePatterns , true ) ; return staticTasks . concat ( dynamicTasks ) ; } 
function convertPatternsToTasks ( positive , negative , dynamic ) { var positivePatternsGroup = groupPatternsByBaseDirectory ( positive ) ; var negativePatternsGroup = groupPatternsByBaseDirectory ( negative ) ; 
function getNegativePatternsAsPositive ( patterns , ignore ) { var negative = patternUtils . getNegativePatterns ( patterns ) . concat ( ignore ) ; var positive = negative . map ( patternUtils . convertToPositivePattern ) ; return positive ; } 
function groupPatternsByBaseDirectory ( patterns ) { return patterns . reduce ( function ( collection , pattern ) { var base = patternUtils . getBaseDirectory ( pattern ) ; if ( base in collection ) { collection [ base ] . push ( pattern ) ; } else { collection [ base ] = [ pattern ] ; } return collection ; } , { } ) ; } 
function convertPatternGroupsToTasks ( positive , negative , dynamic ) { var globalNegative = '.' in negative ? negative [ '.' ] : [ ] ; return Object . keys ( positive ) . map ( function ( base ) { var localNegative = findLocalNegativePatterns ( base , negative ) ; var fullNegative = localNegative . concat ( globalNegative ) ; return convertPatternGroupToTask ( base , positive [ base ] , fullNegative , dynamic ) ; } ) ; } 
function findLocalNegativePatterns ( positiveBase , negative ) { return Object . keys ( negative ) . reduce ( function ( collection , base ) { if ( base . startsWith ( positiveBase ) ) { collection . push . apply ( collection , __spread ( negative [ base ] ) ) ; } return collection ; } , [ ] ) ; } 
function convertPatternGroupToTask ( base , positive , negative , dynamic ) { return { base : base , dynamic : dynamic , patterns : [ ] . concat ( positive , negative . map ( patternUtils . convertToNegativePattern ) ) , positive : positive , negative : negative } ; } 
function isAffectDepthOfReadingPattern ( pattern ) { var basename = path . basename ( pattern ) ; return endsWithSlashGlobStar ( pattern ) || isStaticPattern ( basename ) ; } 
function matchAny ( entry , patternsRe ) { try { for ( var patternsRe_1 = __values ( patternsRe ) , patternsRe_1_1 = patternsRe_1 . next ( ) ; ! patternsRe_1_1 . done ; patternsRe_1_1 = patternsRe_1 . next ( ) ) { var regexp = patternsRe_1_1 . value ; if ( regexp . test ( entry ) ) { return true ; } } } catch ( e_1_1 ) { e_1 = { error : e_1_1 } ; } finally { try { if ( patternsRe_1_1 && ! patternsRe_1_1 . done && ( _a = patternsRe_1 . return ) ) _a . call ( patternsRe_1 ) ; } finally { if ( e_1 ) throw e_1 . error ; } } return false ; var e_1 , _a ; } 
function ( ) { removeNotFoundFiles ( ) ; var entries = normalizedEntries ; var keys = Object . keys ( entries ) ; if ( keys . length === 0 ) { return ; } keys . forEach ( function ( entryName ) { var cacheEntry = entries [ entryName ] ; try { var stat = fs . statSync ( cacheEntry . key ) ; var meta = assign ( cacheEntry . meta , { size : stat . size , mtime : stat . mtime . getTime ( ) } ) ; cache . setKey ( entryName , meta ) ; } catch ( err ) { 
function fillRange ( start , stop , step , options ) { if ( typeof start === 'undefined' ) { return [ ] ; } if ( typeof stop === 'undefined' || start === stop ) { 
function ( docId , cacheDir ) { var me = this ; me . _visited = { } ; me . _persisted = { } ; me . _pathToFile = cacheDir ? path . resolve ( cacheDir , docId ) : path . resolve ( __dirname , './.cache/' , docId ) ; if ( fs . existsSync ( me . _pathToFile ) ) { me . _persisted = utils . tryParse ( me . _pathToFile , { } ) ; } } 
function ( pathToFile ) { var me = this ; var dir = path . dirname ( pathToFile ) ; var fName = path . basename ( pathToFile ) ; me . load ( fName , dir ) ; } 
function ( ) { var me = this ; var obj = { } ; var keys = Object . keys ( me . _visited ) ; 
function ( noPrune ) { var me = this ; ( ! noPrune ) && me . _prune ( ) ; writeJSON ( me . _pathToFile , me . _persisted ) ; } 
function ( docId , cacheDir ) { var obj = Object . create ( cache ) ; obj . load ( docId , cacheDir ) ; return obj ; } 
function ( docId , cacheDir ) { var filePath = cacheDir ? path . resolve ( cacheDir , docId ) : path . resolve ( __dirname , './.cache/' , docId ) ; return del ( filePath , { force : true } ) . length > 0 ; } 
function ( cacheName , key , val ) { var cache = this . cache ( cacheName ) ; cache . set ( key , val ) ; return cache ; } 
function ( name , key ) { var cache = this . cache ( name ) ; if ( typeof key === 'string' ) { return cache . get ( key ) ; } return cache ; } 
function LOOP ( ) { 
function ignoreMap ( pattern ) { var gmatcher = null if ( pattern . slice ( - 3 ) === '/**' ) { var gpattern = pattern . replace ( / (\/\*\*)+$ / , '' ) gmatcher = new Minimatch ( gpattern , { dot : true } ) } return { matcher : new Minimatch ( pattern , { dot : true } ) , gmatcher : gmatcher } } 
function makeAbs ( self , f ) { var abs = f if ( f . charAt ( 0 ) === '/' ) { abs = path . join ( self . root , f ) } else if ( isAbsolute ( f ) || f === '' ) { abs = f } else if ( self . changedCwd ) { abs = path . resolve ( self . cwd , f ) } else { abs = path . resolve ( f ) } if ( process . platform === 'win32' ) abs = abs . replace ( / \\ / g , '/' ) return abs } 
function isIgnored ( self , path ) { if ( ! self . ignore . length ) return false return self . ignore . some ( function ( item ) { return item . matcher . match ( path ) || ! ! ( item . gmatcher && item . gmatcher . match ( path ) ) } ) } 
function isBuffer ( val ) { return val . constructor && typeof val . constructor . isBuffer === 'function' && val . constructor . isBuffer ( val ) ; } 
function micromatch ( files , patterns , opts ) { if ( ! files || ! patterns ) return [ ] ; opts = opts || { } ; if ( typeof opts . cache === 'undefined' ) { opts . cache = true ; } if ( ! Array . isArray ( patterns ) ) { return match ( files , patterns , opts ) ; } var len = patterns . length , i = 0 ; var omit = [ ] , keep = [ ] ; while ( len -- ) { var glob = patterns [ i ++ ] ; if ( typeof glob === 'string' && glob . charCodeAt ( 0 ) === 33 ) { omit . push . apply ( omit , match ( files , glob . slice ( 1 ) , opts ) ) ; } else { keep . push . apply ( keep , match ( files , glob , opts ) ) ; } } return utils . diff ( keep , omit ) ; } 
function match ( files , pattern , opts ) { if ( utils . typeOf ( files ) !== 'string' && ! Array . isArray ( files ) ) { throw new Error ( msg ( 'match' , 'files' , 'a string or array' ) ) ; } files = utils . arrayify ( files ) ; opts = opts || { } ; var negate = opts . negate || false ; var orig = pattern ; if ( typeof pattern === 'string' ) { negate = pattern . charAt ( 0 ) === '!' ; if ( negate ) { pattern = pattern . slice ( 1 ) ; } 
function filter ( patterns , opts ) { if ( ! Array . isArray ( patterns ) && typeof patterns !== 'string' ) { throw new TypeError ( msg ( 'filter' , 'patterns' , 'a string or array' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length , i = 0 ; var patternMatchers = Array ( len ) ; while ( i < len ) { patternMatchers [ i ] = matcher ( patterns [ i ++ ] , opts ) ; } return function ( fp ) { if ( fp == null ) return [ ] ; var len = patternMatchers . length , i = 0 ; var res = true ; fp = utils . unixify ( fp , opts ) ; while ( i < len ) { var fn = patternMatchers [ i ++ ] ; if ( ! fn ( fp ) ) { res = false ; break ; } } return res ; } ; } 
function isMatch ( fp , pattern , opts ) { if ( typeof fp !== 'string' ) { throw new TypeError ( msg ( 'isMatch' , 'filepath' , 'a string' ) ) ; } fp = utils . unixify ( fp , opts ) ; if ( utils . typeOf ( pattern ) === 'object' ) { return matcher ( fp , pattern ) ; } return matcher ( pattern , opts ) ( fp ) ; } 
function contains ( fp , pattern , opts ) { if ( typeof fp !== 'string' ) { throw new TypeError ( msg ( 'contains' , 'pattern' , 'a string' ) ) ; } opts = opts || { } ; opts . contains = ( pattern !== '' ) ; fp = utils . unixify ( fp , opts ) ; if ( opts . contains && ! utils . isGlob ( pattern ) ) { return fp . indexOf ( pattern ) !== - 1 ; } return matcher ( pattern , opts ) ( fp ) ; } 
function any ( fp , patterns , opts ) { if ( ! Array . isArray ( patterns ) && typeof patterns !== 'string' ) { throw new TypeError ( msg ( 'any' , 'patterns' , 'a string or array' ) ) ; } patterns = utils . arrayify ( patterns ) ; var len = patterns . length ; fp = utils . unixify ( fp , opts ) ; while ( len -- ) { var isMatch = matcher ( patterns [ len ] , opts ) ; if ( isMatch ( fp ) ) { return true ; } } return false ; } 
function matchKeys ( obj , glob , options ) { if ( utils . typeOf ( obj ) !== 'object' ) { throw new TypeError ( msg ( 'matchKeys' , 'first argument' , 'an object' ) ) ; } var fn = matcher ( glob , options ) ; var res = { } ; for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) && fn ( key ) ) { res [ key ] = obj [ key ] ; } } return res ; } 
function matcher ( pattern , opts ) { 
function toRegex ( glob , options ) { 
function wrapGlob ( glob , opts ) { var prefix = ( opts && ! opts . contains ) ? '^' : '' ; var after = ( opts && ! opts . contains ) ? '$' : '' ; glob = ( '(?:' + glob + ')' + after ) ; if ( opts && opts . negate ) { return prefix + ( '(?!^' + glob + ').*$' ) ; } return prefix + glob ; } 
function makeRe ( glob , opts ) { if ( utils . typeOf ( glob ) !== 'string' ) { throw new Error ( msg ( 'makeRe' , 'glob' , 'a string' ) ) ; } return utils . cache ( toRegex , glob , opts ) ; } 
function expand ( pattern , options ) { if ( typeof pattern !== 'string' ) { throw new TypeError ( 'micromatch.expand(): argument should be a string.' ) ; } var glob = new Glob ( pattern , options || { } ) ; var opts = glob . options ; if ( ! utils . isGlob ( pattern ) ) { glob . pattern = glob . pattern . replace ( / ([\/.]) / g , '\\$1' ) ; return glob ; } glob . pattern = glob . pattern . replace ( / (\+)(?!\() / g , '\\$1' ) ; glob . pattern = glob . pattern . split ( '$' ) . join ( '\\$' ) ; if ( typeof opts . braces !== 'boolean' && typeof opts . nobraces !== 'boolean' ) { opts . braces = true ; } if ( glob . pattern === '.*' ) { return { pattern : '\\.' + star , tokens : tok , options : opts } ; } if ( glob . pattern === '*' ) { return { pattern : oneStar ( opts . dot ) , tokens : tok , options : opts } ; } * Extended globs */ 
function collapse ( str , ch ) { var res = str . split ( ch ) ; var isFirst = res [ 0 ] === '' ; var isLast = res [ res . length - 1 ] === '' ; res = res . filter ( Boolean ) ; if ( isFirst ) res . unshift ( '' ) ; if ( isLast ) res . push ( '' ) ; return res . join ( ch ) ; } 
function negateSlash ( str ) { return str . replace ( / \[\^([^\]]*?)\] / g , function ( match , inner ) { if ( inner . indexOf ( '/' ) === - 1 ) { inner = '\\/' + inner ; } return '[^' + inner + ']' ; } ) ; } 
function balance ( str , a , b ) { var aarr = str . split ( a ) ; var alen = aarr . join ( '' ) . length ; var blen = str . split ( b ) . join ( '' ) . length ; if ( alen !== blen ) { str = aarr . join ( '\\' + a ) ; return str . split ( b ) . join ( '\\' + b ) ; } return str ; } 
function braces ( str , arr , options ) { if ( str === '' ) { return [ ] ; } if ( ! Array . isArray ( arr ) ) { options = arr ; arr = [ ] ; } var opts = options || { } ; arr = arr || [ ] ; if ( typeof opts . nodupes === 'undefined' ) { opts . nodupes = true ; } var fn = opts . fn ; var es6 ; if ( typeof opts === 'function' ) { fn = opts ; opts = { } ; } if ( ! ( patternRe instanceof RegExp ) ) { patternRe = patternRegex ( ) ; } var matches = str . match ( patternRe ) || [ ] ; var m = matches [ 0 ] ; switch ( m ) { case '\\,' : return escapeCommas ( str , arr , opts ) ; case '\\.' : return escapeDots ( str , arr , opts ) ; case '\/.' : return escapePaths ( str , arr , opts ) ; case ' ' : return splitWhitespace ( str ) ; case '{,}' : return exponential ( str , opts , braces ) ; case '{}' : return emptyBraces ( str , arr , opts ) ; case '\\{' : case '\\}' : return escapeBraces ( str , arr , opts ) ; case '${' : if ( ! / \{[^{]+\{ / . test ( str ) ) { return arr . concat ( str ) ; } else { es6 = true ; str = tokens . before ( str , es6Regex ( ) ) ; } } if ( ! ( braceRe instanceof RegExp ) ) { braceRe = braceRegex ( ) ; } var match = braceRe . exec ( str ) ; if ( match == null ) { return [ str ] ; } var outter = match [ 1 ] ; var inner = match [ 2 ] ; if ( inner === '' ) { return [ str ] ; } var segs , segsLength ; if ( inner . indexOf ( '..' ) !== - 1 ) { segs = expand ( inner , opts , fn ) || inner . split ( ',' ) ; segsLength = segs . length ; } else if ( inner [ 0 ] === '"' || inner [ 0 ] === '\'' ) { return arr . concat ( str . split ( / ['"] / ) . join ( '' ) ) ; } else { segs = inner . split ( ',' ) ; if ( opts . makeRe ) { return braces ( str . replace ( outter , wrap ( segs , '|' ) ) , opts ) ; } segsLength = segs . length ; if ( segsLength === 1 && opts . bash ) { segs [ 0 ] = wrap ( segs [ 0 ] , '\\' ) ; } } var len = segs . length ; var i = 0 , val ; while ( len -- ) { var path = segs [ i ++ ] ; if ( / (\.[^.\/]) / . test ( path ) ) { if ( segsLength > 1 ) { return segs ; } else { return [ str ] ; } } val = splice ( str , outter , path ) ; if ( / \{[^{}]+?\} / . test ( val ) ) { arr = braces ( val , arr , opts ) ; } else if ( val !== '' ) { if ( opts . nodupes && arr . indexOf ( val ) !== - 1 ) { continue ; } arr . push ( es6 ? tokens . after ( val ) : val ) ; } } if ( opts . strict ) { return filter ( arr , filterEmpty ) ; } return arr ; } 
function exponential ( str , options , fn ) { if ( typeof options === 'function' ) { fn = options ; options = null ; } var opts = options || { } ; var esc = '__ESC_EXP__' ; var exp = 0 ; var res ; var parts = str . split ( '{,}' ) ; if ( opts . nodupes ) { return fn ( parts . join ( '' ) , opts ) ; } exp = parts . length - 1 ; res = fn ( parts . join ( esc ) , opts ) ; var len = res . length ; var arr = [ ] ; var i = 0 ; while ( len -- ) { var ele = res [ i ++ ] ; var idx = ele . indexOf ( esc ) ; if ( idx === - 1 ) { arr . push ( ele ) ; } else { ele = ele . split ( '__ESC_EXP__' ) . join ( '' ) ; if ( ! ! ele && opts . nodupes !== false ) { arr . push ( ele ) ; } else { var num = Math . pow ( 2 , exp ) ; arr . push . apply ( arr , repeat ( ele , num ) ) ; } } } return arr ; } 
function wrap ( val , ch ) { if ( ch === '|' ) { return '(' + val . join ( ch ) + ')' ; } if ( ch === ',' ) { return '{' + val . join ( ch ) + '}' ; } if ( ch === '-' ) { return '[' + val . join ( ch ) + ']' ; } if ( ch === '\\' ) { return '\\{' + val + '\\}' ; } } 
function emptyBraces ( str , arr , opts ) { return braces ( str . split ( '{}' ) . join ( '\\{\\}' ) , arr , opts ) ; } 
function splitWhitespace ( str ) { var segs = str . split ( ' ' ) ; var len = segs . length ; var res = [ ] ; var i = 0 ; while ( len -- ) { res . push . apply ( res , braces ( segs [ i ++ ] ) ) ; } return res ; } 
function escapeBraces ( str , arr , opts ) { if ( ! / \{[^{]+\{ / . test ( str ) ) { return arr . concat ( str . split ( '\\' ) . join ( '' ) ) ; } else { str = str . split ( '\\{' ) . join ( '__LT_BRACE__' ) ; str = str . split ( '\\}' ) . join ( '__RT_BRACE__' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { ele = ele . split ( '__LT_BRACE__' ) . join ( '{' ) ; return ele . split ( '__RT_BRACE__' ) . join ( '}' ) ; } ) ; } } 
function escapePaths ( str , arr , opts ) { str = str . split ( '\/.' ) . join ( '__ESC_PATH__' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { return ele . split ( '__ESC_PATH__' ) . join ( '\/.' ) ; } ) ; } 
function escapeCommas ( str , arr , opts ) { if ( ! / \w, / . test ( str ) ) { return arr . concat ( str . split ( '\\' ) . join ( '' ) ) ; } else { str = str . split ( '\\,' ) . join ( '__ESC_COMMA__' ) ; return map ( braces ( str , arr , opts ) , function ( ele ) { return ele . split ( '__ESC_COMMA__' ) . join ( ',' ) ; } ) ; } } 
function splice ( str , token , replacement ) { var i = str . indexOf ( token ) ; return str . substr ( 0 , i ) + replacement + str . substr ( i + token . length ) ; } 
function filter ( arr , cb ) { if ( arr == null ) return [ ] ; if ( typeof cb !== 'function' ) { throw new TypeError ( 'braces: filter expects a callback function.' ) ; } var len = arr . length ; var res = arr . slice ( ) ; var i = 0 ; while ( len -- ) { if ( ! cb ( arr [ len ] , i ++ ) ) { res . splice ( len , 1 ) ; } } return res ; } 
function extglob ( str , opts ) { opts = opts || { } ; var o = { } , i = 0 ; 
function wrap ( inner , prefix , esc ) { if ( esc ) inner = escape ( inner ) ; switch ( prefix ) { case '!' : return '(?!' + inner + ')[^/]' + ( esc ? '%%%~' : '*?' ) ; case '@' : return '(?:' + inner + ')' ; case '+' : return '(?:' + inner + ')+' ; case '*' : return '(?:' + inner + ')' + ( esc ? '%%' : '*' ) case '?' : return '(?:' + inner + '|)' ; default : return inner ; } } 
function toRegex ( pattern , contains , isNegated ) { var prefix = contains ? '^' : '' ; var after = contains ? '$' : '' ; pattern = ( '(?:' + pattern + ')' + after ) ; if ( isNegated ) { pattern = prefix + negate ( pattern ) ; } return new RegExp ( prefix + pattern ) ; } 
function copy ( val , key ) { if ( key === '__proto__' ) { return ; } var obj = this [ key ] ; if ( isObject ( val ) && isObject ( obj ) ) { mixinDeep ( obj , val ) ; } else { this [ key ] = val ; } } 
function advanceTo ( input , endChar ) { var ch = input . charAt ( 0 ) ; var tok = { len : 1 , val : '' , esc : '' } ; var idx = 0 ; function advance ( ) { if ( ch !== '\\' ) { tok . esc += '\\' + ch ; tok . val += ch ; } ch = input . charAt ( ++ idx ) ; tok . len ++ ; if ( ch === '\\' ) { advance ( ) ; advance ( ) ; } } while ( ch && ch !== endChar ) { advance ( ) ; } return tok ; } 
function createTextRegex ( pattern ) { if ( cached ) return cached ; var opts = { contains : true , strictClose : false } ; var not = regexNot . create ( pattern , opts ) ; var re = toRegex ( '^(?:[*]\\((?=.)|' + not + ')' , opts ) ; return ( cached = re ) ; } 
function postcss ( ) { for ( var _len = arguments . length , plugins = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { plugins [ _key ] = arguments [ _key ] ; } if ( plugins . length === 1 && Array . isArray ( plugins [ 0 ] ) ) { plugins = plugins [ 0 ] ; } return new _processor2 . default ( plugins ) ; } 
function BasicSourceMapConsumer ( aSourceMap , aSourceMapURL ) { var sourceMap = aSourceMap ; if ( typeof aSourceMap === 'string' ) { sourceMap = util . parseSourceMapInput ( aSourceMap ) ; } var version = util . getArg ( sourceMap , 'version' ) ; var sources = util . getArg ( sourceMap , 'sources' ) ; 
function compareByOriginalPositions ( mappingA , mappingB , onlyCompareOriginal ) { var cmp = strcmp ( mappingA . source , mappingB . source ) ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalLine - mappingB . originalLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalColumn - mappingB . originalColumn ; if ( cmp !== 0 || onlyCompareOriginal ) { return cmp ; } cmp = mappingA . generatedColumn - mappingB . generatedColumn ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . generatedLine - mappingB . generatedLine ; if ( cmp !== 0 ) { return cmp ; } return strcmp ( mappingA . name , mappingB . name ) ; } 
function compareByGeneratedPositionsDeflated ( mappingA , mappingB , onlyCompareGenerated ) { var cmp = mappingA . generatedLine - mappingB . generatedLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . generatedColumn - mappingB . generatedColumn ; if ( cmp !== 0 || onlyCompareGenerated ) { return cmp ; } cmp = strcmp ( mappingA . source , mappingB . source ) ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalLine - mappingB . originalLine ; if ( cmp !== 0 ) { return cmp ; } cmp = mappingA . originalColumn - mappingB . originalColumn ; if ( cmp !== 0 ) { return cmp ; } return strcmp ( mappingA . name , mappingB . name ) ; } 
function computeSourceURL ( sourceRoot , sourceURL , sourceMapURL ) { sourceURL = sourceURL || '' ; if ( sourceRoot ) { 
function CorkedRequest ( state ) { var _this = this ; this . next = null ; this . entry = null ; this . finish = function ( ) { onCorkedFinish ( _this , state ) ; } ; } 
function clearBuffer ( stream , state ) { state . bufferProcessing = true ; var entry = state . bufferedRequest ; if ( stream . _writev && entry && entry . next ) { 
function destroy ( err , cb ) { var _this = this ; var readableDestroyed = this . _readableState && this . _readableState . destroyed ; var writableDestroyed = this . _writableState && this . _writableState . destroyed ; if ( readableDestroyed || writableDestroyed ) { if ( cb ) { cb ( err ) ; } else if ( err && ( ! this . _writableState || ! this . _writableState . errorEmitted ) ) { pna . nextTick ( emitErrorNT , this , err ) ; } return this ; } 
function Node ( val , type , parent ) { if ( typeof type !== 'string' ) { parent = type ; type = null ; } define ( this , 'parent' , parent ) ; define ( this , 'isNode' , true ) ; define ( this , 'expect' , null ) ; if ( typeof type !== 'string' && isObject ( val ) ) { lazyKeys ( ) ; var keys = Object . keys ( val ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { var key = keys [ i ] ; if ( ownNames . indexOf ( key ) === - 1 ) { this [ key ] = val [ key ] ; } } } else { this . type = type ; this . val = val ; } } 
function append ( compiler , val , node ) { if ( typeof compiler . append !== 'function' ) { return compiler . emit ( val , node ) ; } return compiler . append ( val , node ) ; } 
function Snapdragon ( options ) { Base . call ( this , null , options ) ; this . options = utils . extend ( { source : 'string' } , this . options ) ; this . compiler = new Compiler ( this . options ) ; this . parser = new Parser ( this . options ) ; Object . defineProperty ( this , 'compilers' , { get : function ( ) { return this . compiler . compilers ; } } ) ; Object . defineProperty ( this , 'parsers' , { get : function ( ) { return this . parser . parsers ; } } ) ; Object . defineProperty ( this , 'regex' , { get : function ( ) { return this . parser . regex ; } } ) ; } 
function Compiler ( options , state ) { debug ( 'initializing' , __filename ) ; this . options = utils . extend ( { source : 'string' } , options ) ; this . state = state || { } ; this . compilers = { } ; this . output = '' ; this . set ( 'eos' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; this . set ( 'noop' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; this . set ( 'bos' , function ( node ) { return this . emit ( node . val , node ) ; } ) ; use ( this ) ; } 
function ( msg , node ) { var pos = node . position || { start : { column : 0 } } ; var message = this . options . source + ' column:' + pos . start . column + ': ' + msg ; var err = new Error ( message ) ; err . reason = msg ; err . column = pos . start . column ; err . source = this . pattern ; if ( this . options . silent ) { this . errors . push ( err ) ; } else { throw err ; } } 
function ( node , nodes , i ) { var fn = this . compilers [ node . type ] ; this . idx = i ; if ( typeof fn !== 'function' ) { throw this . error ( 'compiler "' + node . type + '" is not registered' , node ) ; } return fn . call ( this , node , nodes , i ) ; } 
function ( nodes ) { if ( ! Array . isArray ( nodes ) ) { throw new TypeError ( 'expected an array' ) ; } var len = nodes . length ; var idx = - 1 ; while ( ++ idx < len ) { this . visit ( nodes [ idx ] , nodes , idx ) ; } return this ; } 
function ( ast , options ) { var opts = utils . extend ( { } , this . options , options ) ; this . ast = ast ; this . parsingErrors = this . ast . errors ; this . output = '' ; 
function Parser ( options ) { debug ( 'initializing' , __filename ) ; this . options = utils . extend ( { source : 'string' } , options ) ; this . init ( this . options ) ; use ( this ) ; } 
function ( ) { var start = { line : this . line , column : this . column } ; var self = this ; return function ( node ) { define ( node , 'position' , new Position ( start , self ) ) ; return node ; } ; } 
function ( type , fn ) { if ( this . types . indexOf ( type ) === - 1 ) { this . types . push ( type ) ; } this . parsers [ type ] = fn . bind ( this ) ; return this ; } 
function ( type , token ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . count ++ ; this . stack . push ( token ) ; return this . sets [ type ] . push ( token ) ; } 
function ( type ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . count -- ; this . stack . pop ( ) ; return this . sets [ type ] . pop ( ) ; } 
function ( n ) { return this . stack . length > 0 ? utils . last ( this . stack , n ) : utils . last ( this . nodes , n ) ; } 
function ( str , len ) { var lines = str . match ( / \n / g ) ; if ( lines ) this . line += lines . length ; var i = str . lastIndexOf ( '\n' ) ; this . column = ~ i ? len - i : this . column + len ; this . parsed += str ; this . consume ( len ) ; } 
function ( type , regex ) { if ( typeof regex === 'function' ) { return this . set . apply ( this , arguments ) ; } this . regex . set ( type , regex ) ; this . set ( type , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( regex ) ; if ( ! m || ! m [ 0 ] ) return ; var prev = this . prev ( ) ; var node = pos ( { type : type , val : m [ 0 ] , parsed : parsed , rest : this . input } ) ; if ( m [ 1 ] ) { node . inner = m [ 1 ] ; } define ( node , 'inside' , this . stack . length > 0 ) ; define ( node , 'parent' , prev ) ; prev . nodes . push ( node ) ; } . bind ( this ) ) ; return this ; } 
function ( type , openRegex , closeRegex , fn ) { this . sets [ type ] = this . sets [ type ] || [ ] ; this . set ( type + '.open' , function ( ) { var parsed = this . parsed ; var pos = this . position ( ) ; var m = this . match ( openRegex ) ; if ( ! m || ! m [ 0 ] ) return ; var val = m [ 0 ] ; this . setCount ++ ; this . specialChars = true ; var open = pos ( { type : type + '.open' , val : val , rest : this . input } ) ; if ( typeof m [ 1 ] !== 'undefined' ) { open . inner = m [ 1 ] ; } var prev = this . prev ( ) ; var node = pos ( { type : type , nodes : [ open ] } ) ; define ( node , 'rest' , this . input ) ; define ( node , 'parsed' , parsed ) ; define ( node , 'prefix' , m [ 1 ] ) ; define ( node , 'parent' , prev ) ; define ( open , 'parent' , node ) ; if ( typeof fn === 'function' ) { fn . call ( this , open , node ) ; } this . push ( type , node ) ; prev . nodes . push ( node ) ; } ) ; this . set ( type + '.close' , function ( ) { var pos = this . position ( ) ; var m = this . match ( closeRegex ) ; if ( ! m || ! m [ 0 ] ) return ; var parent = this . pop ( type ) ; var node = pos ( { type : type + '.close' , rest : this . input , suffix : m [ 1 ] , val : m [ 0 ] } ) ; if ( ! this . isType ( parent , type ) ) { if ( this . options . strict ) { throw new Error ( 'missing opening "' + type + '"' ) ; } this . setCount -- ; node . escaped = true ; return node ; } if ( node . suffix === '\\' ) { parent . escaped = true ; node . escaped = true ; } parent . nodes . push ( node ) ; define ( node , 'parent' , parent ) ; } ) ; return this ; } 
function ( ) { var pos = this . position ( ) ; if ( this . input ) return ; var prev = this . prev ( ) ; while ( prev . type !== 'root' && ! prev . visited ) { if ( this . options . strict === true ) { throw new SyntaxError ( 'invalid syntax:' + util . inspect ( prev , null , 2 ) ) ; } if ( ! hasDelims ( prev ) ) { prev . parent . escaped = true ; prev . escaped = true ; } visit ( prev , function ( node ) { if ( ! hasDelims ( node . parent ) ) { node . parent . escaped = true ; node . escaped = true ; } } ) ; prev = prev . parent ; } var tok = pos ( { type : 'eos' , val : this . append || '' } ) ; define ( tok , 'parent' , this . ast ) ; return tok ; } 
function ( ) { var parsed = this . parsed ; var len = this . types . length ; var idx = - 1 ; var tok ; while ( ++ idx < len ) { if ( ( tok = this . parsers [ this . types [ idx ] ] . call ( this ) ) ) { define ( tok , 'rest' , this . input ) ; define ( tok , 'parsed' , parsed ) ; this . last = tok ; return tok ; } } } 
function ( input ) { if ( typeof input !== 'string' ) { throw new TypeError ( 'expected a string' ) ; } this . init ( this . options ) ; this . orig = input ; this . input = input ; var self = this ; function parse ( ) { 
function visit ( node , fn ) { if ( ! node . visited ) { define ( node , 'visited' , true ) ; return node . nodes ? mapVisit ( node . nodes , fn ) : fn ( node ) ; } return node ; } 
function mixin ( compiler ) { define ( compiler , '_comment' , compiler . comment ) ; compiler . map = new utils . SourceMap . SourceMapGenerator ( ) ; compiler . position = { line : 1 , column : 1 } ; compiler . content = { } ; compiler . files = { } ; for ( var key in exports ) { define ( compiler , key , exports [ key ] ) ; } } 
function utf8End ( buf ) { var r = buf && buf . length ? this . write ( buf ) : '' ; if ( this . lastNeed ) return r + '\ufffd' ; return r ; } 
function rangeToPattern ( start , stop , options ) { if ( start === stop ) { return { pattern : String ( start ) , digits : [ ] } ; } var zipped = zip ( String ( start ) , String ( stop ) ) ; var len = zipped . length , i = - 1 ; var pattern = '' ; var digits = 0 ; while ( ++ i < len ) { var numbers = zipped [ i ] ; var startDigit = numbers [ 0 ] ; var stopDigit = numbers [ 1 ] ; if ( startDigit === stopDigit ) { pattern += startDigit ; } else if ( startDigit !== '0' || stopDigit !== '9' ) { pattern += toCharacterClass ( startDigit , stopDigit ) ; } else { digits += 1 ; } } if ( digits ) { pattern += options . shorthand ? '\\d' : '[0-9]' ; } return { pattern : pattern , digits : [ digits ] } ; } 
function zip ( a , b ) { var arr = [ ] ; for ( var ch in a ) arr . push ( [ a [ ch ] , b [ ch ] ] ) ; return arr ; } 
function use ( type , fn , options ) { var offset = 1 ; if ( typeof type === 'string' || Array . isArray ( type ) ) { fn = wrap ( type , fn ) ; offset ++ ; } else { options = fn ; fn = type ; } if ( typeof fn !== 'function' ) { throw new TypeError ( 'expected a function' ) ; } var self = this || app ; var fns = self [ prop ] ; var args = [ ] . slice . call ( arguments , offset ) ; args . unshift ( self ) ; if ( typeof opts . hook === 'function' ) { opts . hook . apply ( self , args ) ; } var val = fn . apply ( self , args ) ; if ( typeof val === 'function' && fns . indexOf ( val ) === - 1 ) { fns . push ( val ) ; } return self ; } 
function wrap ( type , fn ) { return function plugin ( ) { return this . type === type ? fn . apply ( this , arguments ) : plugin ; } ; } 
function processArguments ( ) { var arg ; for ( var i = 2 ; i < process . argv . length ; ++ i ) { arg = process . argv [ i ] ; if ( arg === "-l" || arg === "-log" ) enableLog = true ; else if ( arg === "-m" || arg === "--minify" ) enableMinify = true ; else if ( arg === "-f" || arg === "--folder" ) inputIsFolder = true ; else if ( arg === "-s" || arg === "--silent" ) enableSilent = true ; else if ( arg === "-i" || arg === "--input" ) input = process . argv [ ++ i ] ; else if ( arg === "-o" || arg === "--output" ) output = process . argv [ ++ i ] ; else if ( arg === "-e" || arg === "--ensure" ) includeInq = true ; else if ( arg === "-d" || arg === "--define" ) definitions = process . argv [ ++ i ] . split ( ' ' ) ; else console . error ( "[WARNING] Unknown compiler flag: " + arg ) ; } if ( ! output ) output = input + ( inputIsFolder ? "" : ".js" ) ; return ! ! input ; } 
function tryInit ( ) { var temp , i , files ; if ( ! processors . length ) { var processorsPath = path . resolve ( __dirname , "processor" ) ; files = fs . readdirSync ( processorsPath ) ; for ( i = 0 ; i < files . length ; ++ i ) { temp = require ( path . resolve ( processorsPath , files [ i ] ) ) ; processors . push ( temp ) ; processorsNamed [ temp . name ] = temp ; } } if ( ! complexExpressions . length ) { var expressionsPath = path . resolve ( __dirname , "combination" ) ; files = fs . readdirSync ( expressionsPath ) ; for ( i = 0 ; i < files . length ; ++ i ) { temp = require ( path . resolve ( expressionsPath , files [ i ] ) ) ; complexExpressions [ temp . name ] = temp . value ; } } } 
function CalEvent ( name , startDate , endDate , description , location , uid ) { if ( startDate instanceof Date ) { this . startDate = startDate ; } else { return null ; } if ( endDate instanceof Date ) { this . endDate = endDate ; } else { return null ; } this . uid = uid == null ? ( util . guid ( ) + '@node-cal-event.js' ) : uid ; this . summary = name ; this . location = location ; this . description = description ; } 
function ask ( questions ) { "use strict" ; let answers = { } ; let i = 0 ; return new Promise ( function ( resolve , reject ) { function askQuestion ( item ) { let key = item . key ; let msg = item . msg ; let fn = fnList [ item . fn ] ; if ( ! key ) { throw new Error ( 'A value for `key` must be defined for question ' + i ) ; } if ( ! msg ) { throw new Error ( 'A value for `msg` must be defined for question ' + i ) ; } if ( ! fn ) { throw new Error ( 'A value for `fn` must be "prompt", "confirm", or "multiline" for question ' + i ) ; } if ( fn ) { fn ( msg , key , answers ) . then ( function ( ) { next ( ) ; } ) ; } } function next ( ) { if ( i < questions . length ) { var question = questions [ i ] ; i ++ ; askQuestion ( question ) ; } else { resolve ( answers ) ; } } next ( ) ; } ) ; } 
function promiseFn ( msg , key , answers , fn ) { "use strict" ; answers = answers || { } ; return fn ( msg ) . then ( function ( resp ) { answers [ key ] = resp ; return answers ; } ) ; } 
function httpMiddleware ( req , res , arr , done ) { done = done || noop assert . ok ( isReq ( req ) , 'is incoming message' ) assert . ok ( isRes ( res ) , 'is server response' ) assert . ok ( Array . isArray ( arr ) , 'is array' ) assert . equal ( typeof done , 'function' , 'is function' ) mapLimit ( arr , 1 , iterator , done ) function iterator ( fn , next ) { next = dezalgo ( next ) if ( fn . length === 3 ) return fn ( req , res , next ) fn ( req , res ) next ( ) } } 
function memoize ( fun ) { 
function generateDetachTasks ( planner , origin , opts ) { _ . forIn ( origin . topology . containers , function ( container ) { var stopSubTask = { cmd : 'stop' , id : container . id , parent : container . containedBy } ; var removeSubTask = { cmd : 'remove' , id : container . id , parent : container . containedBy } ; var unlinkSubTask = { cmd : 'unlink' , id : container . id , parent : container . containedBy } ; var detachOp = { preconditions : containerStatus ( container , 'running' ) , subTasks : [ unlinkSubTask , stopSubTask , removeSubTask ] } ; var unlinkPreconditions = containerStatus ( container , 'running' ) ; var stopPrecondition = containerStatus ( container , 'started' ) ; var removePrecondition = containerStatus ( container , 'added' ) ; container . contains . forEach ( function ( contained ) { var status = containerStatus ( { id : contained } , 'started' ) ; stopPrecondition = _ . merge ( stopPrecondition , status ) ; detachOp . subTasks . splice ( 1 , 0 , { cmd : 'detach' , id : contained } ) ; } ) ; if ( opts . mode === 'safe' ) { allParentsIds ( origin , container ) . forEach ( function ( id ) { detachOp . subTasks . unshift ( { cmd : 'unlink' , id : id , parent : origin . topology . containers [ id ] . containedBy } ) ; detachOp . subTasks . push ( { cmd : 'link' , id : id , parent : origin . topology . containers [ id ] . containedBy } ) ; } ) ; } planner . addTask ( { cmd : 'detach' , id : container . id } , { preconditions : containerStatus ( container , 'detached' ) , subTasks : [ { cmd : 'nop' } ] } ) ; planner . addTask ( { cmd : 'detach' , id : container . id } , detachOp ) ; planner . addTask ( unlinkSubTask , { preconditions : unlinkPreconditions , effects : containerStatus ( container , { running : false } ) } ) ; planner . addTask ( unlinkSubTask , { preconditions : containerStatus ( container , { running : false } ) , subTasks : [ { cmd : 'nop' } ] } ) ; planner . addTask ( stopSubTask , { preconditions : containerStatus ( container , 'started' ) , effects : containerStatus ( container , 'added' ) } ) ; planner . addTask ( stopSubTask , { preconditions : containerStatus ( container , { running : false , started : false } ) , subTasks : [ { cmd : 'nop' } ] } ) ; planner . addTask ( removeSubTask , { preconditions : removePrecondition , effects : containerStatus ( container , 'detached' ) } ) ; planner . addTask ( removeSubTask , { preconditions : containerStatus ( container , 'detached' ) , subTasks : [ { cmd : 'nop' } ] } ) ; } ) ; } 
function keyblade ( obj , opts ) { opts = Object . assign ( { message : _defaultMessage , logBeforeThrow : true , ignore : [ ] } , opts ) opts . ignore = ( opts . ignore && Array . isArray ( opts . ignore ) ) ? opts . ignore : [ ] return new Proxy ( obj , { get ( target , propKey , receiver ) { const useGetter = Reflect . has ( target , propKey , receiver ) || _isReserved ( propKey , opts . ignore ) if ( useGetter ) { return Reflect . get ( target , propKey , receiver ) } 
function pcorr ( ) { var args , nArgs , len , deltas , delta , means , stdevs , C , cov , corr , arr , N , r , A , B , sum , val , sigma , i , j , n ; args = Array . prototype . slice . call ( arguments ) ; nArgs = args . length ; if ( ! nArgs ) { throw new Error ( 'pcorr()::insufficient input arguments. Must provide array arguments.' ) ; } for ( i = 0 ; i < nArgs ; i ++ ) { if ( ! Array . isArray ( args [ i ] ) ) { throw new TypeError ( 'pcorr()::invalid input argument. Must provide array arguments.' ) ; } } if ( Array . isArray ( args [ 0 ] [ 0 ] ) ) { 
function subRegister ( obj , name ) { var res ; res = isPrimitive ( obj [ name ] ) ? { } : obj [ name ] ; return obj [ name ] = mixable ( res ) . mixin ( proto , 'register' , 'extend' ) ; } 
function registerMod ( leaf , dir , name ) { var modPath ; try { modPath = require . resolve ( dir ) ; } catch ( _error ) { } if ( modPath == null ) { return false ; } 
function registerDir ( leaf , dir , name ) { var files ; try { files = fs . readdirSync ( dir ) ; } catch ( _error ) { } if ( files == null ) { return false ; } if ( name != null ) { leaf = subRegister ( leaf , name ) ; } for ( var i = 0 , len = files . length ; i < len ; i ++ ) { name = files [ i ] ; leaf . register ( dir , name ) ; } return true ; } 
function register ( root ) { var leaf = this ; 
function applyMiddleware ( socket , req , done ) { 
function generateConfigureTasks ( planner , origin , dest , opts ) { _ . forIn ( dest . topology . containers , function ( container ) { var addSubTask = { cmd : 'add' , id : container . id , parent : container . containedBy } ; var startSubTask = { cmd : 'start' , id : container . id , parent : container . containedBy } ; var linkSubTask = { cmd : 'link' , id : container . id , parent : container . containedBy } ; var configureOp = { preconditions : containerStatus ( container , 'detached' ) , subTasks : [ addSubTask , startSubTask , linkSubTask ] } ; var configureNop = { preconditions : containerStatus ( container , 'started' ) , subTasks : [ { cmd : 'nop' } ] } ; var addPreconditions = containerStatus ( container , 'detached' ) ; var linkPreconditions = containerStatus ( container , { started : true , running : false } ) ; var oldContainer = origin . topology . containers [ container . id ] ; if ( oldContainer ) { 
function allParentsIds ( context , container , parents ) { var isLeaf = parents === undefined ; parents = parents || [ ] ; 
function containerStatus ( original , status , parent ) { var state = { topology : { containers : { } } } ; var container = { id : original . id } ; if ( parent === null ) { 
function ( opt ) { EventEmitter . call ( this ) ; opt = opt || { } ; 
async function lstatFiles ( dirPath , dirContent ) { const readFiles = dirContent . map ( async ( relativePath ) => { const path = join ( dirPath , relativePath ) const ls = await makePromise ( lstat , path ) return { lstat : ls , path , relativePath , } } ) const res = await Promise . all ( readFiles ) return res } 
async function readDirStructure ( dirPath ) { if ( ! dirPath ) { throw new Error ( 'Please specify a path to the directory' ) } const ls = await makePromise ( lstat , dirPath ) if ( ! ls . isDirectory ( ) ) { const err = new Error ( 'Path is not a directory' ) err . code = 'ENOTDIR' throw err } const dir = ( await makePromise ( readdir , dirPath ) ) const lsr = await lstatFiles ( dirPath , dir ) const directories = lsr . filter ( isDirectory ) 
function parsePolicies ( input ) { var type = typeof input ; if ( type === 'object' ) { for ( var i in input ) { input [ i ] = this . parsePolicies ( input [ i ] ) ; } return input ; } if ( type === 'string' ) { var parsedString = esprima . parse ( input ) . body [ 0 ] . expression ; return this . parseEsprima ( parsedString ) ; } return input ; } 
function parseEsprima ( input , fromFactory ) { var type = input . type ; if ( type === esprimaType . value ) { return input . value ; } if ( type === esprimaType . policy ) { var policyName = input . name ; if ( fromFactory ) { return require ( sails . config . paths . policies + '/' + policyName ) ; } return policyName ; } if ( type === esprimaType . factory ) { var factoryName = input . callee . name ; try { var factory = require ( sails . config . paths . policyFactories + '/' + factoryName ) ; } catch ( e ) { return require ( sails . config . paths . policies + '/' + factoryName ) ; } var args = input . arguments . map ( function ( arg ) { return this . parseEsprima ( arg , true ) ; } , this ) ; return factory . apply ( this , args ) ; } throw new Error ( 'esprima type unhandled: ' + type ) ; } 
function propertyNameToAttribute ( name ) { var result = name . replace ( / ([A-Z]) / g , function ( match , letter ) { return '-' + letter . toLowerCase ( ) ; } ) ; return 'data-' + result ; } 
function generateCommands ( origin , dest ) { var destCmds = _ . chain ( dest . topology . containers ) . values ( ) . filter ( function ( container ) { return container . containedBy === container . id || ! container . containedBy ; } ) . map ( function ( container ) { return { cmd : 'configure' , id : container . id } ; } ) . value ( ) ; var originCmds = _ . chain ( origin . topology . containers ) . values ( ) . map ( function ( container ) { if ( ! dest . topology . containers [ container . id ] ) { return { cmd : 'detach' , id : container . id } ; } return null ; } ) . filter ( function ( container ) { return container !== null ; } ) . value ( ) ; return destCmds . concat ( originCmds ) ; } 
function class_1 ( ) { var args = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i ++ ) { args [ _i ] = arguments [ _i ] ; } var _this = _super . apply ( this , args [ 0 ] . injector . args ( Class ) ) || this ; var params = args [ 0 ] ; _this . _injector = params . injector ; _this . _store = params . store ; _this . _aggregates = params . aggregates ; _this . _viewHandlers = params . viewHandlers ; _this . _logger = _this . _injector . get ( Logger ) ; return _this ; } 
function _param ( req , key , _default ) { var src = req . params [ key ] ; if ( src === undefined ) { src = req . body [ key ] ; } if ( src === undefined ) { src = req . query [ key ] ; } if ( src === undefined ) { src = _default ; } return src ; } 
function Limon ( input , options ) { if ( ! ( this instanceof Limon ) ) { return new Limon ( input , options ) } lazy . use ( this , { fn : function ( app , opts ) { app . options = lazy . utils . extend ( app . options , opts ) } } ) this . defaults ( input , options ) this . use ( lazy . plugin . prevNext ( ) ) } 
function colLetterToNumber ( letters ) { var number = 0 , i = 0 ; for ( i = 0 ; i < letters . length ; i += 1 ) { 
function planner ( origin , dest , opts ) { var tasks = new TaskPlanner ( ) ; var cmds = generateCommands ( origin , dest ) ; var state = _ . cloneDeep ( origin ) ; var result ; opts = xtend ( defaults , opts ) ; assert ( opts . mode === 'quick' || opts . mode === 'safe' , 'unknown mode' ) ; tasks . addTask ( { cmd : 'nop' } , { } ) ; generateDetachTasks ( tasks , origin , opts ) ; generateDetachTasks ( tasks , dest , opts ) ; 
function replaceBlocks ( file , blocks ) { blocks . forEach ( block => { const index = file . search ( block [ 0 ] ) ; if ( index > - 1 ) { 
function linkUnlinkFilter ( list ) { var skipNext ; var needsFiltering = true ; function doFilter ( cmd , i , cmds ) { if ( skipNext ) { skipNext = false ; return false ; } if ( ! cmds [ i + 1 ] ) { return true ; } if ( cmds [ i + 1 ] . id !== cmd . id ) { return true ; } var unlinkLink = ( cmd . cmd === 'unlink' && cmds [ i + 1 ] . cmd === 'link' ) ; var linkUnlink = ( cmd . cmd === 'link' && cmds [ i + 1 ] . cmd === 'unlink' ) ; if ( linkUnlink || unlinkLink ) { needsFiltering = true ; skipNext = true ; return false ; } return true ; } while ( needsFiltering ) { needsFiltering = false ; skipNext = false ; list = list . filter ( doFilter ) ; } return list ; } 
function ( branchName ) { var storyId = extractStoryId ( branchName ) , commandString ; argv . message = '"' + getHumanReadableStoryId ( storyId ) + ' - ' + argv . message + '"' ; commandString = compileCommandString ( 'git' ) ; return executeCommand ( commandString ) . fail ( function ( failure ) { if ( ! sjl . empty ( failure ) ) { log ( failure ) ; } } ) ; } 
function ( ) { return new Promise ( function ( resolve , reject ) { board . on ( 'ready' , function ( ) { var strip = new pixel . Strip ( { data : 6 , length : 12 , board : this , controller : "FIRMATA" } ) ; strip . on ( 'ready' , function ( ) { resolve ( strip ) ; } ) ; } ) ; } ) ; } 
function ( strip ) { if ( ! strip ) { console . log ( messagingTexts . noStrip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messagingTexts . wrongStrip ) ; } pattern . reset ( strip , interval ) ; interval = pattern . domino ( strip , 'white' ) ; } 
function ( strip ) { if ( ! strip ) { console . log ( messagingTexts . noStrip ) ; } if ( ! ( strip instanceof pixel . Strip ) ) { console . log ( messagingTexts . wrongStrip ) ; } pattern . reset ( strip , interval ) ; setTimeout ( function ( ) { pattern . flash ( strip , 'green' , 2 ) ; } , 10 ) ; } 
function cloneAnyNode ( element , deep ) { switch ( element . nodeType ) { case _Node2 [ 'default' ] . DOCUMENT_FRAGMENT_NODE : return cloneDocumentFragment ( element , deep ) ; case _Node2 [ 'default' ] . ELEMENT_NODE : return cloneElementNode ( element , deep ) ; case _Node2 [ 'default' ] . TEXT_NODE : return cloneTextNode ( element ) ; default : throw new _DOMException2 [ 'default' ] ( _DOMException2 [ 'default' ] . DATA_CLONE_ERR ) ; } } 
function tryInit ( ) { if ( ! processors . length ) { var processorsPath = path . resolve ( __dirname , "processor" ) ; var files = fs . readdirSync ( processorsPath ) ; for ( var i = 0 ; i < files . length ; ++ i ) { var processor = require ( path . resolve ( processorsPath , files [ i ] ) ) ; 
function cloneAnyNode ( element , deep ) { switch ( element . nodeType ) { case Node . DOCUMENT_FRAGMENT_NODE : return cloneDocumentFragment ( element , deep ) ; case Node . ELEMENT_NODE : return cloneElementNode ( element , deep ) ; case Node . TEXT_NODE : return cloneTextNode ( element ) ; default : throw new DOMException ( DOMException . DATA_CLONE_ERR ) ; } } 
function class_1 ( ) { var args = [ ] ; for ( var _i = 0 ; _i < arguments . length ; _i ++ ) { args [ _i ] = arguments [ _i ] ; } var _this = _super . apply ( this , args [ 0 ] . injector . args ( Class ) ) || this ; var params = args [ 0 ] ; _this . _injector = params . injector ; _this . _store = params . store ; _this . _transports = params . transports ; _this . _aggregate = params . aggregate ; _this . _logger = _this . _injector . get ( Logger ) ; return _this ; } 
function processRules ( element , rules ) { if ( rules . type === 'selectors' ) { return processSelectors ( element , rules . selectors ) ; } else if ( rules . type === 'ruleSet' ) { return processRule ( element , rules . rule ) ; } } 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( ! options . venue_id ) throw new Error ( 'venue_id required to make subvenue api calls' ) return ngin . Venue . urlRoot ( ) + '/' + options . venue_id + '/subvenues' } 
function fetchConfig ( filename ) { var data ; filename = path . resolve ( filename ) ; try { data = fs . readFileSync ( filename , 'utf-8' ) ; } catch ( e ) { console . error ( 'Config read error: ' + e ) ; process . exit ( 2 ) ; } try { data = JSON . parse ( data ) ; } catch ( e ) { console . error ( 'Config parse error: ' + e ) ; process . exit ( 2 ) ; } return { filename : filename , path : path . dirname ( filename ) , data : data } ; } 
function Router ( routes ) { this . _routes = [ ] ; this . _not_found = null ; this . _not_found_path = '/404' ; if ( arguments . length === 1 ) { this . addRoutes ( routes ) ; } } 
function Hmif ( config , status , log ) { if ( ! ( this instanceof Hmif ) ) return new Hmif ( config , status , log ) ; if ( ! log ) { log = { } ; log . debug = log . info = log . warn = log . error = log . setLevel = function ( ) { } ; } var that = this ; this . status = status ; this . status . homematic = { interfaces : { } } ; if ( ! config ) return ; this . config = config ; log . info ( pkg . name + ' ' + pkg . version + ' starting' ) ; this . _iface = { } ; this . _values = { } ; this . _paramsetDescriptions = pjson . load ( 'paramsetDescriptions.json' ) || { } ; this . _names = { } ; var xmlrpcServer ; var binrpcServer ; function meta ( params ) { var iface = params [ 0 ] ; var address = params [ 1 ] ; var datapoint = params [ 2 ] ; var value = params [ 3 ] ; var dev = that . _iface [ iface ] . devices [ address ] ; var ident = paramsetIdent ( dev , 'VALUES' ) ; var desc = that . _paramsetDescriptions [ ident ] [ datapoint ] ; var meta = { } ; if ( address . indexOf ( ':' ) !== - 1 ) { meta . channelName = that . _names [ address ] ; meta . deviceName = that . _names [ address . replace ( / :[0-9]+$ / , '' ) ] ; } else { meta . deviceName = that . _names [ address . replace ( / :[0-9]+$ / , '' ) ] ; } if ( desc . TYPE === 'ENUM' ) meta . enumValue = desc . VALUE_LIST [ value ] ; return meta ; } function paramsetIdent ( dev , paramset ) { var ident = '' ; if ( dev . PARENT_TYPE ) ident = ident + dev . PARENT_TYPE + '/' ; ident = ident + dev . TYPE ; if ( dev . SUBTYPE ) ident = ident + '/' + dev . SUBTYPE ; ident = ident + '/' + dev . VERSION + '/' + paramset ; return ident ; } function getParamsetDescriptions ( iface ) { var calls = [ ] ; var requests = [ ] ; Object . keys ( that . _iface [ iface ] . devices ) . forEach ( function ( address ) { var dev = that . _iface [ iface ] . devices [ address ] ; dev . PARAMSETS . forEach ( function ( paramset ) { var ident = paramsetIdent ( dev , paramset ) ; if ( ( ! that . _paramsetDescriptions [ ident ] ) && ( requests . indexOf ( ident ) === - 1 ) ) { requests . push ( ident ) ; calls . push ( function ( cb ) { log . debug ( 'getParamsetDescription' , ident ) ; that . _iface [ iface ] . rpc . methodCall ( 'getParamsetDescription' , [ dev . ADDRESS , paramset ] , function ( err , res ) { if ( ! err ) { that . _paramsetDescriptions [ ident ] = res ; } else { log . error ( err ) ; } cb ( ) ; } ) ; } ) ; } } ) } ) ; async . series ( calls , function ( ) { log . debug ( 'getParamsetDescriptions' , iface , 'done' ) ; pjson . save ( 'paramsetDescriptions.json' , that . _paramsetDescriptions ) ; } ) ; } this . methods = { 'system.multicall' : function multicall ( err , params , callback ) { log . debug ( 'rpc < system.multicall' , err , '(' + params [ 0 ] . length + ')' ) ; var res = [ ] ; params [ 0 ] . forEach ( function ( c ) { that . methods . event ( null , c . params ) ; res . push ( '' ) ; } ) ; log . debug ( 're >' , null , res ) ; callback ( null , res ) ; } , 'system.listMethods' : function listMethods ( err , params , callback ) { log . debug ( 'rpc < system.listMethods' , err , params ) ; log . debug ( 're >' , null , JSON . stringify ( Object . keys ( that . methods ) ) ) ; callback ( null , Object . keys ( that . methods ) ) ; } , 'event' : function event ( err , params , callback ) { log . debug ( 'rpc < event' , err , params ) ; that . _iface [ params [ 0 ] ] . lastEvent = ( new Date ( ) ) . getTime ( ) ; if ( params [ 1 ] === 'CENTRAL' && params [ 2 ] === 'PONG' ) return ; if ( ! that . _values [ params [ 0 ] ] [ params [ 1 ] ] ) { that . _values [ params [ 0 ] ] [ params [ 1 ] ] = { } ; } if ( params [ 3 ] !== that . _values [ params [ 0 ] ] [ params [ 1 ] ] [ params [ 2 ] ] ) { log . debug ( 'rpc < change' , err , params , that . _names [ params [ 1 ] ] ) ; 
function create ( parent , baseUrl , params , callback ) { parent . getClient ( ) . post ( baseUrl , params , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( null , new this ( parent , definition ) ) ; } . bind ( this ) ) ; } 
function register ( type , lang , handler ) { if ( Array . isArray ( lang ) ) { lang . forEach ( ( v ) => store [ type ] . langs [ v ] = handler ) ; return ; } store [ type ] . langs [ lang ] = handler ; } 
function loader ( module , filePath ) { let content = fs . readFileSync ( filePath , 'utf8' ) ; let moduleId = ` ${ hash ( filePath ) } ` ; let vueTemplate = '' ; let vueComponent = compiler . parseComponent ( stripBom ( content ) ) ; let script = vueComponent . script ; let styles = vueComponent . styles ; let template = vueComponent . template ; let scoped = styles . some ( ( { attrs } ) => attrs . scoped ) ; [ ] . concat ( script , template , styles ) . forEach ( ( tag , index ) => { if ( tag ) { let type = tag . type ; let content = tag . content ; let lang = tag . attrs . lang || store [ type ] . defaults ; let handler = store [ type ] . langs [ lang ] ; if ( handler ) { content = handler ( content , filePath , index , module ) ; } switch ( type ) { case 'style' : if ( browserEnv ) { if ( tag . attrs . scoped ) { let ast = css . parse ( content ) ; ast . stylesheet . rules . forEach ( ( rule ) => { rule . selectors = rule . selectors . map ( ( selector ) => { let [ patterns ] = cssWhat ( selector ) ; let index = patterns . length - 1 ; for ( ; index >= 0 ; index -- ) { let { type } = patterns [ index ] ; if ( type !== 'pseudo' && type !== 'pseudo-element' ) { break ; } } patterns . splice ( index + 1 , 0 , { value : '' , name : moduleId , action : 'exists' , type : 'attribute' , ignoreCase : false , } ) ; return cssWhat . stringify ( [ patterns ] ) ; } ) ; } ) ; content = css . stringify ( ast ) ; } let style = document . createElement ( 'style' ) ; style . innerHTML = content ; store . style . exports . call ( module . exports , style , { index , styles , filePath , } ) ; } break ; case 'script' : module . _compile ( content , filePath ) ; break ; case 'template' : if ( browserEnv ) { if ( scoped ) { let div = document . createElement ( 'div' ) ; div . innerHTML = content ; let root = div . firstElementChild ; let walk = function walk ( element , handler ) { handler ( element ) ; let children = element . children || [ ] ; [ ] . forEach . call ( children , ( child ) => { walk ( child , handler ) ; } ) ; } ; walk ( root , ( element ) => { element . setAttribute ( moduleId , '' ) ; } ) ; content = div . innerHTML ; } } vueTemplate = content ; break ; } } } ) ; module . exports . vueComponent = vueComponent ; module . exports . template = vueTemplate ; } 
function WMURL_isValid ( url , 
function _parseQuery ( _ , key , value ) { var encodedKey = global [ "encodeURIComponent" ] ( key ) , encodedValue = global [ "encodeURIComponent" ] ( value ) ; if ( rv [ encodedKey ] ) { if ( Array . isArray ( rv [ encodedKey ] ) ) { rv [ encodedKey ] . push ( encodedValue ) ; } else { rv [ encodedKey ] = [ rv [ encodedKey ] , encodedValue ] ; } } else { rv [ encodedKey ] = encodedValue ; } return "" ; } 
function ( kind , promisesDfd ) { return function ( ) { 
function ( set , args ) { 
function ( kind , args ) { var bucket = this [ kind + 's' ] ; for ( var i = 0 ; i < bucket . length ; i ++ ) { callSet . call ( this , bucket [ i ] , args ) ; } } 
function ( ) { var dfd = this ; 
function ( kind ) { return function ( ) { if ( this . state === 'pending' ) { if ( kind !== 'progress' ) { this [ kind + 'Args' ] = arguments ; this . state = this . promise . state = kind ; } callSets . call ( this , kind , arguments ) ; } return this ; } ; } 
function ( ) { this . dones = [ ] ; this . doneArgs = [ ] ; this . fails = [ ] ; this . failArgs = [ ] ; this . pendings = [ ] ; this . pendingArgs = [ ] ; this . state = 'pending' ; 
function ( performer ) { 
function toposort ( dependencies ) { var sorted = [ ] , visited = { } ; function visit ( key ) { if ( ! visited [ key ] ) { visited [ key ] = true ; if ( ! dependencies [ key ] ) { throw new Error ( 'A dependency is given which is not defined' + key ) ; } dependencies [ key ] . dependencies . forEach ( visit ) ; sorted . push ( key ) ; } } for ( var key in dependencies ) { visit ( key ) ; } return sorted ; } 
function ( schema ) { this . _decoders = decoders ; this . _encoders = encoders ; this . _schemas = { } ; 
function ( selector , properties , value ) { let rule = postcss . rule ( { selector : selector } ) let decls = _ . map ( properties , function ( property ) { return postcss . decl ( { prop : property , value : value } ) } ) rule . append ( decls ) return rule } 
function ( breakpoints , spacingScale ) { return _ . map ( breakpoints , function ( breakpointValue , breakpointKey ) { let mediaQuery = postcss . atRule ( { name : 'media' , params : breakpointValue , } ) let rules = _ . flatMap ( spacingScale , function ( scaleValue , scaleKey ) { return _ . map ( helpers , function ( helperValues , helperKey ) { return makeFunctionalRule ( ` ${ breakpointKey } ${ helperKey } ${ scaleKey } ` , helperValues , scaleValue ) } ) } ) return mediaQuery . append ( rules ) } ) } 
function _assertDataType ( type , val ) { var dataType ; if ( val === UNDEFINED ) { dataType = OBJECT_UNDEFINED ; } else if ( val === NULL ) { dataType = OBJECT_NULL ; } else { dataType = _toString . call ( val ) ; } var lowerCaseType = dataType . replace ( DATA_TYPE_REPLACE_REX , '' ) . toLowerCase ( ) ; return lowerCaseType === type ; } 
function branchMatching ( value , branches ) { var i = branches . length while ( i -- ) if ( equal ( value , branches [ i ] . condition ) ) return branches [ i ] return { condition : null , code : null } } 
function method ( dispatch ) { var branches = [ ] var baseline = function ( a ) { throw noBranchFor ( a ) } var dispatchTable = new DispatchTable ( ) dispatch = dispatch || identity return makeMethod ( function ( ) { var value = dispatch . apply ( null , arguments ) var branch = dispatchTable . getBranch ( value ) . code || branchMatching ( value , branches ) . code || baseline return branch . apply ( null , arguments ) } ) 
function makeMethod ( f ) { f . when = when f . fallback = fallback f . remove = remove f . clone = clone return f } 
function when ( condition , f ) { if ( branchMatching ( condition , branches ) . code ) throw ambiguousBranch ( condition ) branches . push ( { condition : condition , code : f } ) dispatchTable . add ( condition , f ) return this } 
function remove ( condition ) { branches = branches . filter ( function ( a ) { return ! equal ( condition , a . condition ) } ) return this } 
function destroy ( callback ) { this . getClient ( ) . destroy ( this . definition . _links . self . href , function ( err , definition , response ) { if ( err ) return callback ( err ) ; callback ( ) ; } . bind ( this ) ) ; } 
function load_config ( ) { let config = { } ; if ( fs . existsSync ( pgrunner_config_file ) ) { config = JSON . parse ( fs . readFileSync ( pgrunner_config_file , { 'encoding' : 'utf8' } ) ) ; if ( argv . v ) { debug . log ( 'Loaded from ' , pgrunner_config_file ) ; } } if ( ! is . array ( config . servers ) ) { config . servers = [ ] ; } return config ; } 
function save_config ( config ) { fs . writeFileSync ( pgrunner_config_file , JSON . stringify ( config , null , 2 ) , { 'encoding' : 'utf8' } ) ; if ( argv . v ) { debug . log ( 'Saved to ' , pgrunner_config_file ) ; } } 
function strip_argv ( a ) { let o = { } ; return Object . keys ( a ) . filter ( k => k !== '_' ) . map ( k => { o [ k ] = a [ k ] ; } ) ; } 
function strip_server_opts ( old_opts ) { debug . assert ( old_opts ) . is ( 'object' ) ; let opts = { } ; [ 'pgconfig' , 'host' , 'port' , 'user' , 'database' ] . forEach ( key => { if ( old_opts [ key ] !== undefined ) { opts [ key ] = old_opts [ key ] ; } } ) ; return opts ; } 
function get_server_opts ( opts ) { debug . assert ( opts ) . is ( 'object' ) ; debug . assert ( opts . settings ) . is ( 'object' ) ; return { 'dbconfig' : opts . dbconfig , 'host' : opts . settings . host , 'port' : opts . settings . port , 'user' : opts . settings . user , 'database' : opts . settings . database } ; } 
function _isJSON ( val ) { if ( ! _isString ( val ) ) { return false ; } try { 
function custom ( fn ) { return function ( req , res , next ) { fn ( req , function ( result ) { if ( result === true ) { return next ( ) ; } next ( new ErrorUnauthorized ( 'Authentication Failed' ) ) ; } ) ; } ; } 
function http_basic ( username , password ) { return function ( req , res , next ) { var credentials = basic_auth ( req ) ; if ( credentials !== undefined ) { if ( credentials . name && credentials . name === username ) { if ( credentials . pass && credentials . pass === password ) { return next ( ) ; } } } res . set ( 'WWW-Authenticate' , 'Basic' ) ; next ( new ErrorUnauthorized ( 'Authentication Failed' ) ) ; } ; } 
function getResources ( domains ) { return store . getResources ( ) . then ( rsrcs => { return rsrcs . filter ( e => domains . includes ( e . domain ) ) ; } ) ; } 
function BaseController ( context ) { Object . defineProperties ( this , { body : { enumerable : true , get ( ) { return context . body ; } , set ( val ) { context . body = val ; } , } , context : { enumerable : true , get ( ) { return context ; } , } , response : { enumerable : true , get ( ) { return context . response ; } , } , request : { enumerable : true , get ( ) { return context . request ; } , } , query : { enumerable : true , get ( ) { return context . query ; } , } , } ) ; } 
function packRanges ( fromIndex , toIndex , bucketThreshold , sparseIterationThreshold , getOwnPropertyNamesThreshold ) { var ownPropertyNames = null ; var consecutiveRange = ( toIndex - fromIndex >= sparseIterationThreshold ) && ArrayBuffer . isView ( this ) ; var skipGetOwnPropertyNames = consecutiveRange && ( toIndex - fromIndex >= getOwnPropertyNamesThreshold ) ; function * arrayIndexes ( object ) { if ( toIndex - fromIndex < sparseIterationThreshold ) { for ( var i = fromIndex ; i <= toIndex ; ++ i ) { if ( i in object ) yield i ; } } else { ownPropertyNames = ownPropertyNames || Object . getOwnPropertyNames ( object ) ; for ( var i = 0 ; i < ownPropertyNames . length ; ++ i ) { var name = ownPropertyNames [ i ] ; var index = name >>> 0 ; if ( ( "" + index ) === name && fromIndex <= index && index <= toIndex ) yield index ; } } } var count = 0 ; if ( consecutiveRange ) { count = toIndex - fromIndex + 1 ; } else { for ( var i of arrayIndexes ( this ) ) ++ count ; } var bucketSize = count ; if ( count <= bucketThreshold ) bucketSize = count ; else bucketSize = Math . pow ( bucketThreshold , Math . ceil ( Math . log ( count ) / Math . log ( bucketThreshold ) ) - 1 ) ; var ranges = [ ] ; if ( consecutiveRange ) { for ( var i = fromIndex ; i <= toIndex ; i += bucketSize ) { var groupStart = i ; var groupEnd = groupStart + bucketSize - 1 ; if ( groupEnd > toIndex ) groupEnd = toIndex ; ranges . push ( [ groupStart , groupEnd , groupEnd - groupStart + 1 ] ) ; } } else { count = 0 ; var groupStart = - 1 ; var groupEnd = 0 ; for ( var i of arrayIndexes ( this ) ) { if ( groupStart === - 1 ) groupStart = i ; groupEnd = i ; if ( ++ count === bucketSize ) { ranges . push ( [ groupStart , groupEnd , count ] ) ; count = 0 ; groupStart = - 1 ; } } if ( count > 0 ) ranges . push ( [ groupStart , groupEnd , count ] ) ; } return { ranges : ranges , skipGetOwnPropertyNames : skipGetOwnPropertyNames } ; } 
function urlFormat ( obj ) { 
function writelnColor ( ) { for ( var i = 0 ; i < arguments . length ; i = i + 2 ) grunt . log . write ( arguments [ i ] [ arguments [ i + 1 ] ] ) ; grunt . log . writeln ( '' ) ; } 
function rayVsCircle ( ray , circle ) { var rayStart = new Vec2 ( ray . start ) ; if ( circleContainsPoint ( circle . position , circle . radius , ray . start ) ) { return rayStart ; } var intersections = rayLineVsCircle ( ray , circle ) ; if ( intersections . length ) { return rayStart . nearest ( intersections . filter ( within ( ray ) ) ) ; } else { return null ; } } 
function rayLineVsCircle ( ray , circle ) { var rayLine = new Line2 ( ray . start . x , ray . start . y , ray . end . x , ray . end . y ) ; return rayLine . intersectCircle ( circle . position , circle . radius ) ; } 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( typeof options !== 'object' && ( ! options . tournament_id || ! options . flight_id ) ) throw new Error ( 'tournament_id or flight_id required to make tibreak preference api calls' ) var url = '' if ( options . tournament_id ) { url += ngin . Tournament . urlRoot ( ) + '/' + options . tournament_id } else if ( options . flight_id ) { url += ngin . Flight . urlRoot ( ) + '/' + options . flight_id } return url + TiebreakPreference . urlRoot ( ) } 
function ( options , callback ) { var url = scopeUrl ( options , this ) return Super . fetch . call ( this , url , options , callback ) } 
function ( module , debug ) { this . debug = debug || false ; this . jsonrpc = "2.0" ; 
function _getParamNames ( func ) { var funStr = func . toString ( ) ; return funStr . slice ( funStr . indexOf ( '(' ) + 1 , funStr . indexOf ( ')' ) ) . match ( / ([^\s,]+) / g ) ; } 
function _getChangedProperties ( ) { var retVal = { } , key ; for ( key in this . _changed ) { retVal [ key ] = this . _changed [ key ] ; } return retVal ; } 
function update ( properties , callback ) { if ( typeof properties == 'function' ) { callback = properties ; properties = { } ; } var key , changed ; var exceptions = [ 'addresses_update_action' , 'emails_update_action' , 'phone_numbers_update_action' ] ; for ( key in properties ) { if ( 'set' + inflection . camelize ( key ) in this ) { this [ 'set' + inflection . camelize ( key ) ] ( properties [ key ] ) ; } else if ( exceptions . indexOf ( key ) != - 1 ) { this . _changed [ key ] = properties [ key ] ; } } changed = this . _getChangedProperties ( ) ; this . getClient ( ) . patch ( this . definition . _links . self . href , changed , function ( err , definition , response ) { if ( err ) return callback ( err ) ; this . definition = definition ; this . _setup ( ) ; callback ( null , this ) ; } . bind ( this ) ) ; } 
function DataType_Uint8Array_clone ( source , 
function byClass ( c ) { c = classnames ( c ) if ( / ^\. / . test ( c ) ) { throw new Error ( 'No need to "." on start' ) } return bySelector ( ` ${ c } ` ) } 
function publish ( symbolSet ) { publish . conf = { 
function subtemplate ( template , data ) { try { return new JSDOC . JsPlate ( publish . conf . templatesDir + template ) . process ( data ) ; } catch ( e ) { print ( e . message ) ; quit ( ) ; } } 
function makeSignature ( params ) { if ( ! params ) return "()" ; var signature = "(" + params . filter ( function ( $ ) { return ! / \w+\.\w+ / . test ( $ . name ) ; } ) . map ( function ( $ ) { var name = $ . isOptional ? '[' + $ . name + ']' : $ . name ; return name ; } ) . join ( ", " ) + ")" ; return signature ; } 
function resolveLinks ( str , from ) { str = str . replace ( / \{@link ([^}]+)\} / gi , function ( match , symbolName ) { symbolName = symbolName . trim ( ) ; var index = symbolName . indexOf ( ' ' ) ; if ( index > 0 ) { var label = symbolName . substring ( index + 1 ) ; symbolName = symbolName . substring ( 0 , index ) ; return new Link ( ) . toSymbol ( symbolName ) . withText ( label ) ; } else { return new Link ( ) . toSymbol ( symbolName ) ; } } ) ; return str ; } 
function formatQuery ( options ) { var requiredParams if ( options && typeof options !== 'function' ) { options . query = requiredParams = _ . pick ( _ . extend ( { } , options , options . query ) , 'tournament_id' , 'league_id' , 'flight_id' , 'division_id' ) } if ( _ . isEmpty ( requiredParams ) ) throw new Error ( 'tournament_id, league_id, flight_id or division_id are required.' ) } 
function approach ( index , x , onAxis ) { while ( 0 <= x && x <= 1 ) { candidateHSVA [ index ] = x ; WebInspector . Color . hsva2rgba ( candidateHSVA , candidateRGBA ) ; WebInspector . Color . blendColors ( candidateRGBA , bgRGBA , blendedRGBA ) ; var fgLuminance = WebInspector . Color . luminance ( blendedRGBA ) ; var dLuminance = fgLuminance - desiredLuminance ; if ( Math . abs ( dLuminance ) < ( onAxis ? epsilon / 10 : epsilon ) ) return x ; else x += ( index === V ? - dLuminance : dLuminance ) ; } return null ; } 
function colorControlInput ( id ) { const data = { id : id , column : d3form . optionData ( ` ${ id } ` ) } ; const preset = d3form . optionData ( ` ${ id } ` ) ; if ( preset . scale . scale === 'ordinal' ) { data . scale = preset . scale ; return data ; } data . scale = { scale : d3form . value ( ` ${ id } ` ) , domain : [ d3form . value ( ` ${ id } ` ) , d3form . value ( ` ${ id } ` ) ] , unknown : '#696969' } ; const range = [ d3form . value ( ` ${ id } ` ) ] ; if ( d3form . checked ( ` ${ id } ` ) ) { range . push ( d3form . value ( ` ${ id } ` ) ) ; } range . push ( d3form . value ( ` ${ id } ` ) ) ; data . scale . range = range ; return data ; } 
function updateNodeColor ( data ) { d3 . selectAll ( '.node' ) . select ( '.node-symbol' ) . style ( 'fill' , d => d3scale . scaleFunction ( data . scale ) ( d [ data . column . key ] ) ) ; } 
function mainControlBox ( ) { d3 . select ( '#show-struct' ) . on ( 'change' , function ( ) { const data = nodeContentInput ( ) ; d3 . select ( '#main-control' ) . datum ( data ) ; updateNodeStructure ( data ) ; } ) . dispatch ( 'change' ) ; } 
function bootstrap ( ) { 
function centerGraph ( newScale , duration , delay ) { if ( typeof delay === 'function' ) { delay = delay . call ( this ) ; } delay = typeof delay === 'number' ? delay : 0 ; setTimeout ( function ( ) { if ( typeof newScale === 'function' ) { newScale = newScale . call ( this ) ; } if ( typeof duration === 'function' ) { duration = duration . call ( this ) ; } newScale = typeof newScale === 'number' ? newScale : zoom . scale ( ) ; duration = typeof duration === 'number' ? duration : 200 ; if ( typeof newScale !== 'number' ) { throw new TypeError ( "centerGraph error: 'newScale' is not a 'number'." ) ; } if ( typeof duration !== 'number' ) { throw new TypeError ( "centerGraph error: 'duration' is not a 'number'." ) ; } var bounds = graph . node ( ) . getBBox ( ) ; var centerSVGX = ( graphWidth * newScale / 2 ) ; var centerSVGY = ( graphHeight * newScale / 2 ) ; var centerGraphX = ( bounds . x * newScale ) + ( bounds . width * newScale / 2 ) ; var centerGraphY = ( bounds . y * newScale ) + ( bounds . height * newScale / 2 ) ; 
function detectAllNodesFixed ( ) { if ( data ) { var currentNodesFixed = data . allNodesFixed ; var allNodesFixed = true ; data . nodes . forEach ( function ( node ) { if ( ! node . fixed ) { allNodesFixed = false ; } } ) ; data . allNodesFixed = allNodesFixed ; if ( currentNodesFixed !== allNodesFixed ) { updateMenuUI ( ) ; } 
function fadeRelatedNodes ( targetNode , selected , nodes , links ) { var opacity = selected ? 0.1 : 1 ; var elm = findElementByNode ( 'circle' , targetNode ) ; 
function findElementByNode ( prefix , node ) { var selector = '.' + formatClassName ( prefix , node ) ; return graph . select ( selector ) ; } 
function getElementCoords ( element ) { var ctm = element . getCTM ( ) ; return { x : ctm . e + element . getAttribute ( 'cx' ) * ctm . a , y : ctm . f + element . getAttribute ( 'cy' ) * ctm . d } ; } 
function getSVG ( elementType ) { var returnVal ; var svgElement ; var cached ; switch ( elementType ) { case 'circle' : case 'g' : case 'path' : case 'text' : returnVal = function ( data ) { svgElement = svgElementMap [ elementType ] . pop ( ) ; cached = svgElement != null ; svgElement = svgElement != null ? svgElement : document . createElementNS ( 'http://www.w3.org/2000/svg' , elementType ) ; 
function hideNodeContextMenu ( event ) { 
function isConnected ( targetNode , otherNode ) { return targetNode . index === otherNode . index || linkedByIndex [ targetNode . index + ',' + otherNode . index ] ; } 
function onControlDepsClicked ( ) { 
function onControlLevelChanged ( ) { appOptions . currentLevel = parseInt ( this . value ) ; $ ( '.control-level input' ) . val ( appOptions . currentLevel ) ; $ ( '.control-level label' ) . html ( appOptions . currentLevel ) ; 
function onControlMenuClicked ( ) { switch ( $ ( this ) . data ( 'action' ) ) { case 'toggleFreezeAllNodes' : setNodesFixed ( ! data . allNodesFixed ) ; break ; case 'showFullNames' : appOptions . showFullNames = ! appOptions . showFullNames ; updateAll ( { redrawOnly : true } ) ; break ; case 'showTableView' : appOptions . showTableView = ! appOptions . showTableView ; $ ( '.control-table' ) . toggleClass ( 'hidden' , ! appOptions . showTableView ) ; updateTableUIExtent ( ) ; break ; case 'maxDepthSticky' : appOptions . maxDepthSticky = ! appOptions . maxDepthSticky ; break ; } 
function onControlTableRowContextClick ( node , event ) { event . preventDefault ( ) ; 
function onControlTableRowMouseOver ( nodes , links , node , enter ) { 
function onControlZoomClicked ( ) { var newScale = 1 ; var scalePercentile = 0.20 ; 
function onNodeContextMenuClick ( ) { 
function onNodeContextClick ( targetNode , coords ) { 
function onNodeMouseDown ( nodes , links , targetNode ) { hideNodeContextMenu ( ) ; 
function onNodeMouseOverOut ( nodes , links , enter , targetNode ) { 
function onResize ( ) { 
function onTick ( ) { nodes . attr ( 'cx' , function ( node ) { return node . x ; } ) . attr ( 'cy' , function ( node ) { return node . y ; } ) . attr ( 'transform' , function ( node ) { return 'translate(' + node . x + ',' + node . y + ')' ; } ) ; 
function onZoomChanged ( ) { var newScale = Math . max ( d3 . event . scale , minScaleExtent ) ; zoom . scale ( newScale ) ; graph . attr ( 'transform' , 'translate(' + d3 . event . translate + ')' + ' scale(' + newScale + ')' ) ; } 
function recycleGraph ( ) { var childNodes = graph . selectAll ( 'g > *' ) . remove ( ) ; if ( ! Array . isArray ( childNodes ) && ! Array . isArray ( childNodes [ '0' ] ) ) { return ; } 
function renderGraph ( options ) { options = typeof options === 'object' ? options : { } ; options . redrawOnly = typeof options . redrawOnly === 'boolean' ? options . redrawOnly : false ; 
function reverseGraphLinks ( ) { for ( var key in dataPackageMap ) { var graphData = dataPackageMap [ key ] ; graphData . links . forEach ( function ( link ) { var linkSource = link . source ; link . source = link . target ; link . target = linkSource ; } ) ; } } 
function setNodesFixed ( fixed ) { 
function updateGraphData ( ) { 
function updateMenuUI ( ) { if ( data ) { $ ( '.control-menu li[data-action=toggleFreezeAllNodes]' ) . html ( data . allNodesFixed ? 'Unfreeze nodes' : 'Freeze nodes' ) ; } appMenuToggleOptions . forEach ( function ( key ) { var icon = appOptions [ key ] ? 'check_box' : 'check_box_outline_blank' ; $ ( '.control-menu li[data-action=' + key + '] i' ) . html ( icon ) ; } ) ; } 
function updateTableUI ( ) { var table = $ ( '.control-table tbody' ) ; table . off ( 'mouseenter' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'mouseleave' , 'tr' , onControlTableRowMouseOver ) ; table . off ( 'contextmenu' , 'tr' , onControlTableRowContextClick ) ; table . empty ( ) ; if ( data ) { data . nodes . forEach ( function ( node ) { var nd = node . packageData ; var name = appOptions . showFullNames ? nd . actualPackageName : nd . packageName ; var isAliased = nd . isAlias ? ' isAliased' : '' ; var tr = $ ( '<tr>' + '<td class="mdl-data-table__cell--non-numeric' + isAliased + '">' + name + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . jspmType + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + nd . version + '</td>' + '<td class="mdl-data-table__cell--non-numeric">' + node . minLevel + '</td>' + '</tr>' ) ; table . append ( tr ) ; tr . on ( 'mouseenter' , onControlTableRowMouseOver . bind ( this , nodes , links , node , true ) ) ; tr . on ( 'mouseleave' , onControlTableRowMouseOver . bind ( this , nodes , links , node , false ) ) ; tr . on ( 'contextmenu' , onControlTableRowContextClick . bind ( this , node ) ) ; } ) ; 
function updateTableUIExtent ( ) { var tableDiv = $ ( '.control-table-inner' ) ; var nodeTable = $ ( '#nodeTable' ) ; var tableHeight = nodeTable . height ( ) ; var offset = tableDiv . offset ( ) ; var maxTableHeight = window . innerHeight - offset . top - 20 ; tableDiv . css ( 'max-height' , maxTableHeight ) ; nodeTable . css ( 'margin-right' , tableHeight > maxTableHeight ? '10px' : '0px' ) ; } 
function zoomFit ( ) { var bounds = graph . node ( ) . getBBox ( ) ; var parent = graph . node ( ) . parentElement ; var fullWidth = parent . clientWidth , fullHeight = parent . clientHeight ; var width = bounds . width , height = bounds . height ; if ( width === 0 || height === 0 ) { return 1 ; } 
function getWindowWidth ( ) { if ( window . innerWidth ) { return window . innerWidth ; } else if ( document . documentElement . clientWidth ) { return document . documentElement . clientWidth ; } else if ( document . body . clientWidth ) { return document . body . clientWidth ; } else { return 0 ; } } 
function ( cssScreen , cssHandheld , mobileMaxWidth ) { // Set config values if ( typeof ( cssScreen ) != "undefined" ) { config . cssScreen = cssScreen ; } if ( typeof ( cssHandheld ) != "undefined" ) { config . cssHandheld = cssHandheld ; } if ( typeof ( mobileMaxWidth ) != "undefined" ) { config . mobileMaxWidth = mobileMaxWidth ; } // Check if CSS is loaded var cssloadCheckNode = document . createElement ( 'div' ) ; cssloadCheckNode . className = config . testDivClass ; document . getElementsByTagName ( "body" ) [ 0 ] . appendChild ( cssloadCheckNode ) ; if ( cssloadCheckNode . offsetWidth != 100 && noMediaQuery == false ) { noMediaQuery = true ; } cssloadCheckNode . parentNode . removeChild ( cssloadCheckNode ) if ( noMediaQuery == true ) { // Browser does not support Media Queries, so JavaScript will supply a fallback var cssHref = "" ; // Determines what CSS file to load if ( getWindowWidth ( ) <= config . mobileMaxWidth ) { cssHref = config . cssHandheld ; newCssMediaType = "handheld" ; } else { cssHref = config . cssScreen ; newCssMediaType = "screen" ; } // Add CSS link to <head> of page if ( cssHref != "" && currentCssMediaType != newCssMediaType ) { var currentCssLinks = document . styleSheets for ( var i = 0 ; i < currentCssLinks . length ; i ++ ) { for ( var ii = 0 ; ii < currentCssLinks [ i ] . media . length ; ii ++ ) { if ( typeof ( currentCssLinks [ i ] . media ) == "object" ) { if ( currentCssLinks [ i ] . media . item ( ii ) == "fallback" ) { currentCssLinks [ i ] . ownerNode . parentNode . removeChild ( currentCssLinks [ i ] . ownerNode ) i -- break ; } } else { if ( currentCssLinks [ i ] . media . indexOf ( "fallback" ) >= 0 ) { currentCssLinks [ i ] . owningElement . parentNode . removeChild ( currentCssLinks [ i ] . owningElement ) i -- break ; } } } } if ( typeof ( cssHref ) == "object" ) { for ( var i = 0 ; i < cssHref . length ; i ++ ) { addCssLink ( cssHref [ i ] ) } } else { addCssLink ( cssHref ) } currentCssMediaType = newCssMediaType ; } // Check screen size again if user resizes window addEvent ( window , wbos . CssTools . MediaQueryFallBack . LoadCssDelayed , 'onresize' ) } } 
function gulpRebound ( options ) { options || ( options = { } ) ; 
function clearFile ( obj ) { if ( Utils . tools . isArray ( obj ) ) obj . forEach ( _clearFile ) ; else _clearFile ( obj ) ; return Utils ; } 
function Item ( source , file ) { this . source = source ; this . file = file ; this . dirname = path . dirname ( this . file ) ; this . basename = path . basename ( this . file , '.yml' ) ; this . relPath = path . relative ( this . source , this . dirname ) ; this . yaml = yaml . load ( fs . readFileSync ( this . file , 'utf8' ) ) ; this [ "package" ] = path . dirname ( this . relPath ) ; this . module = path . basename ( this . relPath ) ; } 
function do_success ( req , res , msg ) { res . writeHead ( 200 , { 'Content-Type' : ( ( typeof msg === 'string' ) ? 'text/plain' : 'application/json' ) } ) ; msg = ( typeof msg === 'string' ) ? msg : helpers . stringify ( msg ) ; res . end ( msg ) ; } 
function do_failure ( req , res , opts ) { opts = opts || { } ; var obj = { 'type' : opts . type || 'error' , 'code' : opts . code || 501 , 'desc' : opts . desc || ( '' + opts ) } ; res . writeHead ( obj . code , { 'Content-Type' : 'application/json' } ) ; res . end ( helpers . stringify ( obj ) + '\n' ) ; } 
function do_create_req ( config , routes ) { routes = routes || { } ; var version = routes . version || { } ; if ( version && ( typeof version === 'object' ) ) { } else { version = { 'self' : routes . version || config . pkg . version } ; } if ( ! version . api ) { version . api = api_config . pkg . version ; } routes . version = version ; var router = new RequestRouter ( routes ) ; var req_counter = 0 ; function do_req ( req , res ) { req_counter += 1 ; return router . resolve ( req , res ) ; } 
function do_create_server ( config , do_req ) { var http = require ( 'http' ) ; if ( config . host ) { http . createServer ( do_req ) . listen ( config . port , config . host ) ; 
function setup_server ( config , opts ) { config . _def ( 'port' , 3000 ) ; var req_handler = do_create_req ( config , opts ) ; var server = do_create_server ( config , function ( req , res ) { req_handler ( req , res ) . then ( function ( obj ) { if ( obj === api . replySent ) { 
function ( element , ev , fn ) { if ( element . addEventListener ) element . addEventListener ( ev , fn , false ) ; else element . attachEvent ( "on" + ev , fn ) ; } 
function ( ) { if ( this . visible ( ) ) return ; this . _bodyElement = document . body ; this . _bodyElement . addEventListener ( "mousedown" , this . _maybeHideBound , true ) ; this . _overlay = new WebInspector . SuggestBox . Overlay ( ) ; this . _overlay . setContentElement ( this . _container ) ; } 
function Reply ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Reply . super_ . apply ( this , arguments ) ; } 
function WMURL_decode ( source ) { 
function serveGitFile ( repo , tree , parts , res , next ) { 
function buildAndStart ( ) { if ( / ^https?:\/\/ / . test ( Program . file ) ) { var url = Program . file . replace ( / ^(https?:\/\/)([^/:]+)(?=:\d+|\/) / , function ( m , a , b ) { if ( ! / \d+\.\d+\.\d+\.\d+ / . test ( a ) ) { return a + Hosts . findRealHost ( b ) ; } else { return m ; } } ) ; Config . entryBundleUrl = url ; startServerAndLaunchDevtool ( ) ; } else { var filePath = Path . resolve ( Program . file ) ; var ext = Path . extname ( filePath ) ; if ( ! Fs . existsSync ( filePath ) ) { console . error ( filePath + ': No such file or directory' ) ; return Exit ( 0 ) ; } if ( ext == '.ju' || ext == '.vue' ) { console . log ( 'building...' ) ; console . time ( 'Build completed!' ) ; buildFileAndWatchIt ( Program . mode , filePath ) . then ( function ( ) { console . timeEnd ( 'Build completed!' ) ; startServerAndLaunchDevtool ( Program . file ) ; } , function ( err ) { if ( err ) { console . log ( err , err . stack ) ; } Exit ( 0 ) ; } ) } else if ( ext == '.js' ) { buildFileAndWatchIt ( 'copy' , filePath ) . then ( function ( ) { startServerAndLaunchDevtool ( Program . file ) ; } ) } else if ( ! ext ) { 
function randomUniqueId ( ) { 
function moveToNextCallback ( alreadyNew , valueChanged , section ) { if ( ! moveDirection ) return ; 
function processFileList ( files , base , settings , state ) { for ( var i = 0 ; i < files . length ; i ++ ) { var modulePath = path . join ( base , files [ i ] ) ; var stats = fs . statSync ( modulePath ) ; if ( stats . isFile ( ) ) { 
function packageModule ( global , name , api ) { if ( global . define && global . define . amd ) { define ( [ ] , api ) ; } else if ( typeof exports !== "undefined" ) { module . exports = api ; } else { global [ name ] = api ; } } 
function frameworkEventListeners ( ) { var errorLines = [ ] ; var eventListeners = [ ] ; var internalHandlers = [ ] ; var fetchers = [ jQueryFetcher ] ; try { if ( self . devtoolsFrameworkEventListeners && isArrayLike ( self . devtoolsFrameworkEventListeners ) ) fetchers = fetchers . concat ( self . devtoolsFrameworkEventListeners ) ; } catch ( e ) { errorLines . push ( "devtoolsFrameworkEventListeners call produced error: " + toString ( e ) ) ; } for ( var i = 0 ; i < fetchers . length ; ++ i ) { try { var fetcherResult = fetchers [ i ] ( this ) ; if ( fetcherResult . eventListeners && isArrayLike ( fetcherResult . eventListeners ) ) { eventListeners = eventListeners . concat ( fetcherResult . eventListeners . map ( checkEventListener ) . filter ( nonEmptyObject ) ) ; } if ( fetcherResult . internalHandlers && isArrayLike ( fetcherResult . internalHandlers ) ) internalHandlers = internalHandlers . concat ( fetcherResult . internalHandlers . map ( checkInternalHandler ) . filter ( nonEmptyObject ) ) ; } catch ( e ) { errorLines . push ( "fetcher call produced error: " + toString ( e ) ) ; } } var result = { eventListeners : eventListeners } ; if ( internalHandlers . length ) result . internalHandlers = internalHandlers ; if ( errorLines . length ) { var errorString = "Framework Event Listeners API Errors:\n\t" + errorLines . join ( "\n\t" ) ; errorString = errorString . substr ( 0 , errorString . length - 1 ) ; result . errorString = errorString ; } return result ; function isArrayLike ( obj ) { if ( ! obj || typeof obj !== "object" ) return false ; try { if ( typeof obj . splice === "function" ) { var len = obj . length ; return typeof len === "number" && ( len >>> 0 === len && ( len > 0 || 1 / len > 0 ) ) ; } } catch ( e ) { } return false ; } function checkEventListener ( eventListener ) { try { var errorString = "" ; if ( ! eventListener ) errorString += "empty event listener, " ; var type = eventListener . type ; if ( ! type || ( typeof type !== "string" ) ) errorString += "event listener's type isn't string or empty, " ; var useCapture = eventListener . useCapture ; if ( typeof useCapture !== "boolean" ) errorString += "event listener's useCapture isn't boolean or undefined, " ; var passive = eventListener . passive ; if ( typeof passive !== "boolean" ) errorString += "event listener's passive isn't boolean or undefined, " ; var handler = eventListener . handler ; if ( ! handler || ( typeof handler !== "function" ) ) errorString += "event listener's handler isn't a function or empty, " ; var remove = eventListener . remove ; if ( remove && ( typeof remove !== "function" ) ) errorString += "event listener's remove isn't a function, " ; if ( ! errorString ) { return { type : type , useCapture : useCapture , passive : passive , handler : handler , remove : remove } ; } else { errorLines . push ( errorString . substr ( 0 , errorString . length - 2 ) ) ; return null ; } } catch ( e ) { errorLines . push ( toString ( e ) ) ; return null ; } } function checkInternalHandler ( handler ) { if ( handler && ( typeof handler === "function" ) ) return handler ; errorLines . push ( "internal handler isn't a function or empty" ) ; return null ; } function toString ( obj ) { try { return "" + obj ; } catch ( e ) { return "<error>" ; } } function nonEmptyObject ( obj ) { return ! ! obj ; } function jQueryFetcher ( node ) { if ( ! node || ! ( node instanceof Node ) ) return { eventListeners : [ ] } ; var jQuery = ( window [ "jQuery" ] ) ; if ( ! jQuery || ! jQuery . fn ) return { eventListeners : [ ] } ; var jQueryFunction = ( jQuery ) ; var data = jQuery . _data || jQuery . data ; var eventListeners = [ ] ; var internalHandlers = [ ] ; if ( typeof data === "function" ) { var events = data ( node , "events" ) ; for ( var type in events ) { for ( var key in events [ type ] ) { var frameworkListener = events [ type ] [ key ] ; if ( typeof frameworkListener === "object" || typeof frameworkListener === "function" ) { var listener = { handler : frameworkListener . handler || frameworkListener , useCapture : true , passive : false , type : type } ; listener . remove = jQueryRemove . bind ( node , frameworkListener . selector ) ; eventListeners . push ( listener ) ; } } } var nodeData = data ( node ) ; if ( nodeData && typeof nodeData . handle === "function" ) internalHandlers . push ( nodeData . handle ) ; } var entry = jQueryFunction ( node ) [ 0 ] ; if ( entry ) { var entryEvents = entry [ "$events" ] ; for ( var type in entryEvents ) { var events = entryEvents [ type ] ; for ( var key in events ) { if ( typeof events [ key ] === "function" ) { var listener = { handler : events [ key ] , useCapture : true , passive : false , type : type } ; * @param {string} selector * @param {string} type * @param {function()} handler * @this {?Object} */ function jQueryRemove ( selector , type , handler ) { if ( ! this || ! ( this instanceof Node ) ) return ; var node = ( this ) ; var jQuery = ( window [ "jQuery" ] ) ; if ( ! jQuery || ! jQuery . fn ) return ; var jQueryFunction = ( jQuery ) ; jQueryFunction ( node ) . off ( type , selector , handler ) ; } } 
function proxify ( api ) { if ( ! api || typeof api !== "object" ) throw new TypeError ( "Only objects can be proxified." ) ; if ( typeof api . route !== "function" || typeof api . close !== "function" ) throw new TypeError ( "Only objects that offer an owe Api interface can be proxified." ) ; const passthroughSet = api [ passthrough ] ; const proxy = new Proxy ( target , { get ( target , property ) { if ( typeof property === "symbol" || passthroughSet && passthroughSet . has ( property ) && property in api ) return typeof api [ property ] === "function" ? api [ property ] . bind ( api ) : api [ property ] ; return proxify ( api . route ( property ) ) ; } , apply ( target , context , args ) { return api . close ( args [ 0 ] ) ; } , deleteProperty ( ) { return false ; } } ) ; proxyMap . set ( proxy , api ) ; return proxy ; } 
function Ebus ( p ) { "use strict" ; this . debug = false ; this . yields = false ; this . handlers = { } ; if ( p ) { this . priorities = p ; } else { this . priorities = { } ; } } 
function ApiClient ( config ) { var self = this this . config = _ . extend ( { } , config , { client : this } ) config . headers = _ . extend ( { } , config . headers , { Accept : 'application/json' } ) this . auth = config . auth models . sync = require ( './sync' ) models . Model = require ( './modelbase' ) models . NginModel = require ( './nginModel' ) 
function getFirstIndexOf ( value , array ) { error_if_not_primitive_or_array_1 . errorIfNotPrimitiveOrArray ( value ) ; if ( isArray_notArray_1 . isArray ( value ) ) { return getFirstIndexOfArray_1 . getFirstIndexOfArray ( value , array ) ; } else { 
function ( type , obj ) { return obj !== null && obj !== undefined && obj . constructor . prototype === type . prototype ; } 
function breakRoleList ( matcher , list ) { const pieces = [ ] const roleBreaker = XRegExp ( ` \\ ${ matcher . roleMatcher } \\ ` ) for ( let m = list . match ( roleBreaker ) ; m !== null ; m = list . match ( roleBreaker ) ) { const [ consumed , matched ] = m pieces . push ( matched ) list = list . substring ( consumed . length ) } const altFinder = XRegExp ( ` \\ \\ \\ ${ matcher . roleMatcher } ` ) const altMatch = list . match ( altFinder ) if ( altMatch ) { pieces . push ( altMatch [ 2 ] ) } 
function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season_id ) throw new Error ( 'season_id required to make division instance api calls' ) return ngin . Season . urlRoot ( ) + '/' + options . season_id + Division . urlRoot ( ) } 
function process ( ast , scope ) { ast . scope = scope ; ast . names = [ ] ; ast . scopes = [ ] ; var varWalker = function ( token , scope ) { scope . declarations . push ( { type : 'var' , name : token . id . name , parent : this . top ( 1 ) , loc : token . loc . start } ) ; scope . put ( token . id . name , { type : 'var' , token : token . init , loc : token . loc . start } ) ; } ; return walker . walk ( ast , { VariableDeclarator : varWalker , FunctionDeclaration : fnWalker , FunctionExpression : fnWalker , ArrowFunctionExpression : fnWalker , ExpressionStatement : function ( token ) { if ( token . directive && token . directive . toLowerCase ( ) === 'use strict' ) scope . strict = true ; } , CatchClause : function ( token , scope ) { var newScope = new Scope ( 'catch' , scope ) ; scope . put ( token . param . name , { type : 'catch' , token : null } ) ; token . body . scope = newScope ; this . scopes . push ( scope ) ; } , Identifier : function ( token , scope ) { var parent = this . top ( 1 ) ; 
function Scope ( type , parentScope , thisObject ) { this . type = type || 'unknown' ; this . thisObject = thisObject || utils . createIdentifier ( 'undefined' ) ; this . subscopes = [ ] ; this . names = { } ; this . declarations = [ ] ; if ( parentScope ) { this . parent = parentScope ; this . root = parentScope . root ; this . strict = parentScope . strict ; parentScope . subscopes . push ( this ) ; } else { this . root = this ; } this . put ( 'this' , { type : 'readonly' , token : this . thisObject } ) ; } 
function Customer ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Customer . super_ . apply ( this , arguments ) ; } 
function copy ( obj ) { return Object . getOwnPropertyNames ( obj || { } ) . reduce ( ( a , c ) => { a [ c ] = obj [ c ] ; return a ; } , { } ) ; } 
function formatWith ( options ) { options = Object . assign ( { } , DEFAULTS , options ) ; return ( message , ... args ) => { return _formatter ( options , message , ... args ) ; } ; } 
function ( obj ) { var that = { } ; that . obj = obj ; var method ; var con ; if ( typeof window !== 'undefined' ) { window . console = window . console || { } ; con = window . console ; } else { con = console || { } ; } if ( ! con [ 'debug' ] ) { con . debug = con . log ; } 
function ( sourceDir , destFile , opts ) { opts = opts || { archive_path : '/' } ; return new Promise ( function ( resolve , reject ) { try { var archive = archiver . create ( 'zip' , { zlib : { level : 9 } } ) ; var output = fs . createWriteStream ( destFile ) ; output . on ( 'finish' , function ( ) { resolve ( destFile ) ; } ) ; archive . pipe ( output ) ; archive . directory ( sourceDir , opts . archive_path ) ; archive . finalize ( ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function ( sourceFile , destDir ) { return new Promise ( function ( resolve , reject ) { var zip = new AdmZip ( sourceFile ) ; try { zip . extractAllTo ( destDir ) ; resolve ( destDir ) ; } catch ( err ) { reject ( err ) ; } } ) ; } 
function ( sourceDir , destFile , opts ) { opts = opts || { archive_path : '/' } ; return new Promise ( function ( resolve , reject ) { 
function ( sourceFile , destDir ) { return new Promise ( function ( resolve , reject ) { 
function _isNegativeNumber ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . NEGATIVE_NUMBER_REX . test ( val ) ; } return REGEX_ENUM . NEGATIVE_NUMBER_REX . test ( val ) ; } 
async function make ( dir ) { try { await makePromise ( mkdir , dir ) } catch ( err ) { if ( err . code == 'ENOENT' ) { const parentDir = dirname ( dir ) await make ( parentDir ) await make ( dir ) } else if ( err . code != 'EEXIST' ) { 
function fabricator ( stack , options ) { options = options || { } ; 
function read ( filepath , options ) { if ( 'string' !== is ( filepath ) ) return fabricator ( filepath , options ) ; if ( options . source ) filepath = path . resolve ( options . source , filepath ) ; 
function iterator ( traverse , obj , options ) { return function reduce ( stack , entity ) { var base = obj ? obj [ entity ] : entity , name = options . name || entity ; 
function js ( file ) { var type = is ( file ) ; return 'function' === type || 'string' === type && path . extname ( file ) === '.js' ; } 
function empty ( value ) { if ( ! value ) return true ; switch ( is ( value ) ) { case "object" : return ! Object . keys ( value ) . length ; case "array" : return ! value . length ; default : return ! value ; } } 
function init ( constructor , name , options ) { constructor = ( 'string' === is ( constructor ) ) ? require ( constructor ) : constructor ; 
function click ( e ) { var op = 'remove' ; if ( this . className === 'menuLink' ) { op = document . body . classList . contains ( 'menu-open' ) ? 'remove' : 'add' ; e . preventDefault ( ) ; } document . body . classList [ op ] ( 'menu-open' ) ; } 
function ShellStream ( args ) { if ( this instanceof ShellStream === false ) { return new ShellStream ( args ) ; } this . _command = args ; this . _events = [ ] ; var self = this ; 
function read ( path , options , callback ) { var str = readCache [ path ] ; var cached = options . cache && str && ( 'string' === typeof str ) ; 
function ( name , specs ) { this . name = name ; this . id = 0 ; this . properties = specs . properties || [ ] ; this . extends = specs . extends || null ; this . depends = specs . depends || null ; this . factory = specs . factory || "new" ; this . init = specs . init || "default" ; this . frequent = false ; this . keepUsedProperties = false ; this . initProperties = true ; this . initConstructorArgs = [ ] ; this . propCustomAssign = { } ; this . propAssign = "" ; this . propCustomGet = { } ; this . propGet = "" ; this . postInit = specs . postInit || "" ; this . embed = specs . embed || [ ] ; if ( this . postInit ) this . postInit += "\n" ; 
function ( o ) { 
function ( instVar , prefix ) { var code = "[" , getCode = "" , prop = "" , defaultGet = "$inst.$prop" ; if ( this . defaultGet ) defaultGet = defaultGet ; for ( var i = 0 , l = this . properties . length ; i < l ; ++ i ) { prop = this . properties [ i ] ; if ( i > 0 ) code += "," ; if ( this . propCustomGet [ prop ] ) { getCode = this . propCustomGet [ prop ] . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } else { getCode = defaultGet . replace ( / \$inst / g , instVar ) . replace ( / \$prop / g , prop ) ; } 
function ( ) { var props = this . properties . slice ( ) . sort ( ) ; return 'init' + crypto . createHash ( 'md5' ) . update ( props . join ( "," ) ) . digest ( "hex" ) ; } 
function ( instVar , valVar , pageszVar , offsetVar , prefix , indent ) { var code = "" , usedProps = { } , defaultAssign = "$inst.$prop = $value" , replaceVariableMacro = ( function ( s , v ) { var i = this . properties . indexOf ( v ) ; if ( i >= 0 ) { usedProps [ v ] = true ; } else { throw "Macro " + s + " refers to a property not part of property table!" ; } } ) . bind ( this ) ; 
function bufferMode ( contents , options , callback ) { ProfileCompiler ( contents . toString ( 'utf-8' ) , options , function ( err , encBuf , decBuf ) { if ( err ) { callback ( err ) ; return ; } 
function streamMode ( contents , options , callback ) { toArray ( contents , function ( err , chunks ) { if ( err ) { callback ( err ) ; return ; } bufferMode ( Buffer . concat ( chunks ) , options , function ( err , encBuf , decBuf ) { if ( err ) { callback ( err ) ; return ; } var encStream = new Readable ( ) ; encStream . push ( encBuf ) ; encStream . push ( null ) ; var decStream = new Readable ( ) ; decStream . push ( decBuf ) ; decStream . push ( null ) ; 
function ( err , encContents , decContents ) { 
function journal ( ) { 'use strict' ; var fs = require ( 'fs' ) ; 
function logCreationEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . creationEvents [ id ] ) { eventList . creationEvents [ id ] = [ ] ; } eventList . creationEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } } 
function logExecutionEvent ( id , type , message , time ) { if ( logMode === 'l' ) { if ( ! eventList . executionEvents [ id ] ) { eventList . executionEvents [ id ] = [ ] ; } eventList . executionEvents [ id ] . push ( { 'type' : type , 'event' : message , "timestamp" : time } ) ; } else if ( logMode === 'v' ) { console . log ( type + ': Agent ' + id + ' ' + message + ' on ' + time ) ; } } 
function report ( logFile ) { var defaultLogFile = ( new Date ( ) ) . toJSON ( ) + '.log' ; var data = JSON . stringify ( eventList , null , 3 ) ; if ( logFile ) { fs . writeFile ( logFile , data , function ( err ) { if ( err ) { console . log ( '\nCould not write log to file "' + logFile + '"\n' + err ) ; fs . writeFile ( defaultLogFile , data , function ( err ) { if ( err ) { console . log ( 'Could not write log file: ' + err ) ; } else { console . log ( 'Log was written on default file "' + defaultLogFile + '"' ) ; } } ) ; } } ) ; } else { fs . writeFile ( defaultLogFile , data , function ( err ) { if ( err ) { console . log ( 'Could not write log file: ' + err ) ; } } ) ; } } 
function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . teamcenter_team_id ) throw new Error ( 'teamcenter_team_id required to make TeamCenterContact instance api calls' ) if ( ! options . teamcenter_member_id ) throw new Error ( 'teamcenter_member_id require to make TeamCenterContact instance api calls' ) return ngin . TeamCenterTeam . urlRoot ( ) + '/' + options . teamcenter_team_id + ngin . TeamCenterMember . urlRoot ( ) + '/' + options . teamcenter_member_id + TeamCenterContact . urlRoot ( ) } 
function installObjectObserve ( ) { var properties = [ "advancedSearchConfig" , "auditsPanelSplitViewState" , "auditsSidebarWidth" , "blockedURLs" , "breakpoints" , "cacheDisabled" , "colorFormat" , "consoleHistory" , "consoleTimestampsEnabled" , "cpuProfilerView" , "cssSourceMapsEnabled" , "currentDockState" , "customColorPalette" , "customDevicePresets" , "customEmulatedDeviceList" , "customFormatters" , "customUserAgent" , "databaseTableViewVisibleColumns" , "dataGrid-cookiesTable" , "dataGrid-DOMStorageItemsView" , "debuggerSidebarHidden" , "disableDataSaverInfobar" , "disablePausedStateOverlay" , "domBreakpoints" , "domWordWrap" , "elementsPanelSplitViewState" , "elementsSidebarWidth" , "emulation.deviceHeight" , "emulation.deviceModeValue" , "emulation.deviceOrientationOverride" , "emulation.deviceScale" , "emulation.deviceScaleFactor" , "emulation.deviceUA" , "emulation.deviceWidth" , "emulation.geolocationOverride" , "emulation.showDeviceMode" , "emulation.showRulers" , "enableAsyncStackTraces" , "eventListenerBreakpoints" , "fileMappingEntries" , "fileSystemMapping" , "FileSystemViewSidebarWidth" , "fileSystemViewSplitViewState" , "filterBar-consoleView" , "filterBar-networkPanel" , "filterBar-promisePane" , "filterBar-timelinePanel" , "frameViewerHideChromeWindow" , "heapSnapshotRetainersViewSize" , "heapSnapshotSplitViewState" , "hideCollectedPromises" , "hideNetworkMessages" , "highlightNodeOnHoverInOverlay" , "highResolutionCpuProfiling" , "inlineVariableValues" , "Inspector.drawerSplitView" , "Inspector.drawerSplitViewState" , "InspectorView.panelOrder" , "InspectorView.screencastSplitView" , "InspectorView.screencastSplitViewState" , "InspectorView.splitView" , "InspectorView.splitViewState" , "javaScriptDisabled" , "jsSourceMapsEnabled" , "lastActivePanel" , "lastDockState" , "lastSelectedSourcesSidebarPaneTab" , "lastSnippetEvaluationIndex" , "layerDetailsSplitView" , "layerDetailsSplitViewState" , "layersPanelSplitViewState" , "layersShowInternalLayers" , "layersSidebarWidth" , "messageLevelFilters" , "messageURLFilters" , "monitoringXHREnabled" , "navigatorGroupByFolder" , "navigatorHidden" , "networkColorCodeResourceTypes" , "networkConditions" , "networkConditionsCustomProfiles" , "networkHideDataURL" , "networkLogColumnsVisibility" , "networkLogLargeRows" , "networkLogShowOverview" , "networkPanelSplitViewState" , "networkRecordFilmStripSetting" , "networkResourceTypeFilters" , "networkShowPrimaryLoadWaterfall" , "networkSidebarWidth" , "openLinkHandler" , "pauseOnCaughtException" , "pauseOnExceptionEnabled" , "preserveConsoleLog" , "prettyPrintInfobarDisabled" , "previouslyViewedFiles" , "profilesPanelSplitViewState" , "profilesSidebarWidth" , "promiseStatusFilters" , "recordAllocationStacks" , "requestHeaderFilterSetting" , "request-info-formData-category-expanded" , "request-info-general-category-expanded" , "request-info-queryString-category-expanded" , "request-info-requestHeaders-category-expanded" , "request-info-requestPayload-category-expanded" , "request-info-responseHeaders-category-expanded" , "resources" , "resourcesLastSelectedItem" , "resourcesPanelSplitViewState" , "resourcesSidebarWidth" , "resourceViewTab" , "savedURLs" , "screencastEnabled" , "scriptsPanelNavigatorSidebarWidth" , "searchInContentScripts" , "selectedAuditCategories" , "selectedColorPalette" , "selectedProfileType" , "shortcutPanelSwitch" , "showAdvancedHeapSnapshotProperties" , "showEventListenersForAncestors" , "showFrameowkrListeners" , "showHeaSnapshotObjectsHiddenProperties" , "showInheritedComputedStyleProperties" , "showMediaQueryInspector" , "showNativeFunctionsInJSProfile" , "showUAShadowDOM" , "showWhitespacesInEditor" , "sidebarPosition" , "skipContentScripts" , "skipStackFramesPattern" , "sourceMapInfobarDisabled" , "sourcesPanelDebuggerSidebarSplitViewState" , "sourcesPanelNavigatorSplitViewState" , "sourcesPanelSplitSidebarRatio" , "sourcesPanelSplitViewState" , "sourcesSidebarWidth" , "standardEmulatedDeviceList" , "StylesPaneSplitRatio" , "stylesPaneSplitViewState" , "textEditorAutocompletion" , "textEditorAutoDetectIndent" , "textEditorBracketMatching" , "textEditorIndent" , "timelineCaptureFilmStrip" , "timelineCaptureLayersAndPictures" , "timelineCaptureMemory" , "timelineCaptureNetwork" , "timeline-details" , "timelineEnableJSSampling" , "timelineOverviewMode" , "timelinePanelDetailsSplitViewState" , "timelinePanelRecorsSplitViewState" , "timelinePanelTimelineStackSplitViewState" , "timelinePerspective" , "timeline-split" , "timelineTreeGroupBy" , "timeline-view" , "timelineViewMode" , "uiTheme" , "watchExpressions" , "WebInspector.Drawer.lastSelectedView" , "WebInspector.Drawer.showOnLoad" , "workspaceExcludedFolders" , "workspaceFolderExcludePattern" , "workspaceInfobarDisabled" , "workspaceMappingInfobarDisabled" , "xhrBreakpoints" ] ; function settingRemove ( ) { this . _storage [ this . _name ] = undefined ; } function objectObserve ( object , observer ) { if ( window [ "WebInspector" ] ) { var settingPrototype = window [ "WebInspector" ] [ "Setting" ] [ "prototype" ] ; if ( typeof settingPrototype [ "remove" ] === "function" ) settingPrototype [ "remove" ] = settingRemove ; } var changedProperties = new Set ( ) ; var scheduled = false ; function scheduleObserver ( ) { if ( ! scheduled ) { scheduled = true ; setImmediate ( callObserver ) ; } } function callObserver ( ) { scheduled = false ; var changes = [ ] ; changedProperties . forEach ( function ( name ) { changes . push ( { name : name } ) ; } ) ; changedProperties . clear ( ) ; observer . call ( null , changes ) ; } var storage = new Map ( ) ; function defineProperty ( property ) { if ( property in object ) { storage . set ( property , object [ property ] ) ; delete object [ property ] ; } Object . defineProperty ( object , property , { get : function ( ) { return storage . get ( property ) ; } , set : function ( value ) { storage . set ( property , value ) ; changedProperties . add ( property ) ; scheduleObserver ( ) ; } } ) ; } for ( var i = 0 ; i < properties . length ; ++ i ) defineProperty ( properties [ i ] ) ; } window . Object . observe = objectObserve ; } 
function ArticleTranslation ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } ArticleTranslation . super_ . apply ( this , arguments ) ; } 
function ( list , options ) { 
function require ( p , root ) { 
function MacroAction ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } MacroAction . super_ . apply ( this , arguments ) ; } 
function map ( obj , source , target , isRecursive = true ) { 
function ( visit , onFail , opts ) { var fail = onFail ? onFail : utils . ret ( false ) , config = opts || { compact : true } ; return function ( list ) { var p = Promise . resolve ( false ) , results = [ ] ; list . forEach ( function ( l , i ) { p = p . then ( visit . bind ( null , l ) ) . catch ( function ( err ) { return fail ( err , l ) ; } ) . then ( function ( result ) { results . push ( result ) ; if ( config . onProgress ) config . onProgress ( list . length , i + 1 , l ) ; } ) ; } ) ; return p . then ( function ( ) { return config . compact ? results . filter ( Boolean ) : results ; } ) ; } ; } 
function ( module , fn ) { var hasModule = typeof module !== 'function' , f = hasModule ? module [ fn ] : module , mod = hasModule ? module : null ; return function ( ) { var args = [ ] , i = arguments . length - 1 ; while ( i >= 0 && typeof arguments [ i ] === 'undefined' ) { -- i ; } while ( i >= 0 ) { args . unshift ( arguments [ i ] ) ; -- i ; } return new Promise ( function ( resolve , reject ) { try { resolve ( f . apply ( mod , args ) ) ; } catch ( err ) { reject ( err ) ; } } ) ; } ; } 
function ( module , opts ) { var config = opts || { } , isValid = config . isValid || function ( f , fn , mod ) { return typeof f === 'function' && fn [ 0 ] !== '_' && fn [ 0 ] . toUpperCase ( ) !== fn [ 0 ] && ! fn . endsWith ( 'Sync' ) ; } ; return utils . mapObject ( module , function ( f , fn , mod ) { return utils . promisify ( mod , fn ) ; } , isValid ) ; } 
function resource ( object , data ) { if ( data === undefined ) return resourceMap . get ( object ) || { } ; if ( ! object || typeof object !== "object" && typeof object !== "function" || resourceMap . has ( object ) ) throw new TypeError ( "Could not transform given object into a resource." ) ; if ( ! data || typeof data !== "object" ) throw new TypeError ( "Resource data has to be an object." ) ; resourceMap . set ( object , data ) ; return object ; } 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( typeof options !== 'object' && ! options . flight_id ) throw new Error ( 'flight_id required to make flight defaults api calls' ) return ngin . Flight . urlRoot ( ) + '/' + options . flight_id + FlightStage . urlRoot ( ) } 
function ( ) { console . warn ( 'Code is using deprecated teams_advancing, switch to teamsAdvancing' ) var where = ( new Error ( ) . stack || '' ) . split ( '\n' , 3 ) [ 2 ] if ( where ) console . warn ( where ) this . teamsAdvancing . apply ( this , arguments ) } 
function getIndexOfPrimitive ( primitive , array , startingPosition ) { if ( startingPosition === void 0 ) { startingPosition = 0 ; } errorIfNotPrimitive_1 . errorIfNotPrimitive ( primitive ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( array ) ; errorIfNotInteger_1 . errorIfNotInteger ( startingPosition ) ; return array . indexOf ( primitive , startingPosition ) ; } 
function loads ( xhr , ee ) { var onreadystatechange , onprogress , ontimeout , onabort , onerror , onload , timer ; onerror = xhr . onerror = one ( function onerror ( evt ) { var status = statuscode ( xhr ) , err = fail ( new Error ( 'Network request failed' ) , status ) ; ee . emit ( 'error' , err ) ; ee . emit ( 'end' , err , status ) ; } ) ; onabort = xhr . onabort = function onabort ( evt ) { onerror ( evt ) ; } ; onreadystatechange = xhr . onreadystatechange = function change ( evt ) { var target = evt . target ; if ( 4 === target . readyState ) return onload ( evt ) ; } ; ontimeout = xhr . ontimeout = one ( function timeout ( evt ) { ee . emit ( 'timeout' , evt ) ; * IE needs have it's `onprogress` function assigned to a unique function. So, * no touchy touchy here! * * @param {Event} evt Triggered progress event. * @api private */ onprogress = xhr . onprogress = function progress ( evt ) { var status = statuscode ( xhr ) , data ; ee . emit ( 'progress' , evt , status ) ; if ( xhr . readyState >= 3 && status . code === 200 && ( data = response ( xhr ) ) ) { ee . emit ( 'stream' , data , status ) ; } } ; /** * Handle load events an potential data events for when there was no streaming * data. * * @param {Event} evt Triggered load event. * @api private */ onload = xhr . onload = one ( function load ( evt ) { var status = statuscode ( xhr ) , data = response ( xhr ) ; if ( status . code < 100 || status . code > 599 ) return onerror ( evt ) ; // // There is a bug in FireFox's XHR2 implementation where status code 204 
function sheetifyNest ( filename , source , opts , done ) { var processor = postcss ( [ nest ( opts ) ] ) processor . process ( source ) . then ( function ( res ) { done ( null , res . css ) } ) . catch ( done ) } 
function Cache ( key , opt ) { if ( ! ( this instanceof Cache ) ) return new Cache ( key , opt ) ; if ( key ) this . setToken ( key ) ; this . config = _ . defaults ( opt || { } , { protocol : 'https' , fragment : '_escaped_fragment_' , service : 'service.cache.watch' , path : '/' , sender : { method : 'get' , headers : { 'User-Agent' : 'CacheWatch Client' } , } , auth : 'x-cache-watch' , lengths : 150 , useragent : pack . config . useragent , url : pack . config . extencion } ) ; var that = this ; that . watch = function CacheWatch ( req , res , next ) { var query = querystring . parse ( url . parse ( req . url ) . query ) ; if ( that . isNot ( req , query ) || ! that . key ) return next ( ) ; that . get ( that . createUrl ( req , query ) , function ( err , resp , body ) { if ( err || that . res ( resp ) ) return next ( ) ; res . setHeader ( 'CacheWatch' , Cache . version ) ; res . setHeader ( 'last-modified' , resp . headers [ 'last-modified' ] ) ; res . setHeader ( 'content-type' , resp . headers [ 'content-type' ] ) ; res . send ( body ) ; } ) ; } ; } 
function addWithDependencies ( allFiles , newFile , dependencies , currentFiles , cycleCheck ) { if ( cycleCheck . indexOf ( newFile ) >= 0 ) { throw new Error ( 'Dependency cycle found ' + JSON . stringify ( cycleCheck ) ) } cycleCheck . push ( newFile ) try { 
function orderFiles ( allFiles , dependencies ) { var result = [ ] allFiles . forEach ( function ( newFile ) { addWithDependencies ( allFiles , newFile , dependencies , result , [ ] ) } ) return result } 
function batchForms ( batch , form , merkle ) { 
function parseJSON ( input , callback ) { var error var result try { result = JSON . parse ( input ) } catch ( e ) { error = e } callback ( error , result ) } 
function createFile ( filePath , fileContent ) { var folderPath = filePath . split ( '/' ) ; folderPath . pop ( ) ; folderPath = folderPath . join ( '/' ) ; if ( ! Utils . exist ( folderPath ) ) createFolder ( folderPath ) ; fs . writeFileSync ( filePath , fileContent ) ; Utils . log ( 'Created file: ' + filePath ) ; return Utils ; } 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) var route = [ ] if ( options . season_id ) route . push ( 'seasons' , options . season_id ) if ( options . flight_stage_id ) route . push ( 'flight_stages' , options . flight_stage_id ) else if ( options . division_id ) route . push ( 'divisions' , options . division_id ) else if ( options . pool_id ) route . push ( 'pools' , options . pool_id ) route . push ( 'standings' ) var base = config . urls && config . urls . sports || config . url return Url . resolve ( base , route . join ( '/' ) ) } 
function formatNum ( value , type ) { const conv = { scientific : ".3e" , si : ".3s" , rounded : ".3r" } ; if ( type === 'raw' ) return value ; if ( value === undefined || value === null || Number . isNaN ( value ) ) return '' ; return value == parseFloat ( value ) ? d3 . format ( conv [ type ] ) ( value ) : value ; } 
function ReconnectingWebSocket ( url , opts ) { if ( ! ( this instanceof ReconnectingWebSocket ) ) { throw new TypeError ( 'Cannot call a constructor as a function' ) ; } opts = opts || { } ; var self = this ; function getOpt ( name , def ) { return opts . hasOwnProperty ( name ) ? opts [ name ] : def ; } var timeout = getOpt ( 'timeout' , 100 ) ; var maxRetries = getOpt ( 'maxRetries' , 5 ) ; var curRetries = 0 ; 
function getFirstIndexOfArray ( arrayToSearchFor , arrayToSearchInside ) { errorIfNotArray_1 . errorIfNotArray ( arrayToSearchFor ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( arrayToSearchInside ) ; return arrayToSearchInside . findIndex ( function ( value ) { return ( isArray_notArray_1 . isArray ( value ) && arrays_match_1 . arraysMatch ( value , arrayToSearchFor ) ) ; } ) ; } 
function _isPositiveInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . POSITIVE_INTEGER_REX . test ( val ) ; } return REGEX_ENUM . POSITIVE_INTEGER_REX . test ( val ) ; } 
function client ( protocol ) { if ( ! protocol || typeof protocol !== "object" ) throw new TypeError ( "owe ClientApi protocols have to be objects." ) ; if ( typeof protocol . closer !== "function" ) throw new TypeError ( "owe ClientApi proctols have to offer a closer function." ) ; if ( protocol . init && typeof protocol . init !== "function" ) throw new TypeError ( "owe ClientApi protocols have to offer an init function." ) ; let connected = false ; const observers = new Set ( ) ; protocol = Object . assign ( { get connected ( ) { return connected ; } , set connected ( value ) { if ( typeof value !== "boolean" ) throw new TypeError ( "Protocol connection state has to be boolean." ) ; if ( value === connected ) return ; connected = value ; for ( const observer of observers ) observer ( connected ) ; } , observe ( observer ) { if ( typeof observer !== "function" ) throw new TypeError ( "Protocol connection state observers have to be functions." ) ; observers . add ( observer ) ; } , unobserve ( observer ) { observers . delete ( observer ) ; } } , protocol ) ; if ( protocol . init ) protocol . init ( ) ; return new ClientApi ( protocol ) ; } 
function writePath ( parentDir , path , data ) { let files = path . split ( '/' ) ; let file = files . shift ( ) ; 
function ( mainFiles ) { for ( var i = 0 ; i < mainFiles . length ; i ++ ) { 
function descendantRoles ( roles , fieldName , allDescendants ) { return roles . map ( role => allDescendants . get ( role ) ) . filter ( descendants => ! ! descendants ) . map ( descendants => descendants . get ( fieldName ) ) . filter ( fieldRoles => ! ! fieldRoles ) } 
function mapOfMaps ( ) { const m = new Map ( ) m . getOrCreate = function ( key ) { if ( ! this . has ( key ) ) this . set ( key , mapOfMaps ( ) ) return this . get ( key ) } return m } 
function mapOfArrays ( ) { const m = new Map ( ) m . getOrCreate = function ( key ) { if ( ! this . has ( key ) ) this . set ( key , [ ] ) return this . get ( key ) } return m } 
function ( ) { this . objects = { } ; this . index = [ ] ; this . _objTree = [ ] ; this . _objList = [ ] ; this . _properties = { } ; this . _propID = 0 ; this . _decodeIndex = [ ] ; this . _objFreq = [ ] ; this . _objInfeq = [ ] ; this . shortNames = true ; this . indent = "\t" ; this . hasEmbed = false ; } 
function ( po ) { this . objects [ po . name ] = po ; if ( po . extends ) { this . _objTree . push ( [ po . extends , po . name ] ) ; } else if ( po . depends ) { this . _objTree . push ( [ po . depends , po . name ] ) ; } else { this . _objList . push ( po . name ) ; } } 
function ( index_offset , size , depth , prefix , testVar , callback ) { if ( size == 0 ) return prefix + this . indent + "/* No items */\n" ; var code = "" ; genChunk = ( function ( s , e , d , pf ) { if ( d === 0 ) { code += pf + "switch (" + testVar + ") {\n" ; for ( var i = s ; i < e ; ++ i ) { code += pf + this . indent + "case " + ( index_offset + i ) + ": return " + callback ( i ) ; } code += pf + "}\n" ; } else { 
function ( name ) { var id = this . _properties [ name ] ; if ( id === undefined ) { if ( this . shortNames ) { id = this . _properties [ name ] = 'p' + ( this . _propID ++ ) . toString ( ) } else { id = this . _properties [ name ] = 'p' + name [ 0 ] . toUpperCase ( ) + name . substr ( 1 ) . toLowerCase ( ) . replace ( / [,\.\- \_] / g , '_' ) } } } 
function ( ) { 
function ( ) { var pn = Object . keys ( this . _properties ) ; var code = "var " ; for ( var i = 0 , l = pn . length ; i < l ; ++ i ) { if ( i !== 0 ) code += ",\n" ; code += this . indent + this . _properties [ pn [ i ] ] + " = '" + pn [ i ] + "'" ; } code += ";\n" ; return code ; } 
function ( ) { var code = "" ; 
function ( prefix ) { var code = "function( id ) {\n" ; code += prefix + this . indent + "if (id < " + MAX_FREQ_ITEMS + ") {\n" ; code += this . generateDnCif ( 0 , this . _objFreq . length , 3 , prefix + this . indent , 'id' , ( function ( i ) { return "factory_" + this . _objFreq [ i ] . safeName + ";\n" } ) . bind ( this ) ) ; code += prefix + this . indent + "} else {\n" ; code += this . generateDnCif ( MAX_FREQ_ITEMS , this . _objInfeq . length , 3 , prefix + this . indent , 'id' , ( function ( i ) { return "factory_" + this . _objInfeq [ i ] . safeName + ";\n" } ) . bind ( this ) ) ; code += prefix + this . indent + "}\n" ; code += prefix + "}\n" ; return code ; } 
function ( prefix ) { var code = "function( inst ) {\n" ; for ( var i = 0 , l = this . index . length ; i < l ; ++ i ) { var o = this . index [ i ] ; if ( i === 0 ) code += prefix + this . indent + "if" ; else code += prefix + this . indent + "} else if" ; code += " (inst instanceof " + o . name + ") {\n" ; code += prefix + this . indent + this . indent + "return [" + o . id + ", getter_" + o . safeName + "];\n" ; } code += prefix + this . indent + "}\n" ; code += prefix + "}\n" return code ; } 
function ( ) { var code = "" ; 
function Client ( options ) { options = options || { } ; this . isClient = true ; this . subdomain = options . subdomain ; this . endpoint = options . endpoint ; if ( ! this . subdomain && ! this . endpoint ) throw new Error ( 'No subdomain was specified.' ) ; 
function _isPositiveNumber ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . POSITIVE_NUMBER_REX . test ( val ) ; } return REGEX_ENUM . POSITIVE_NUMBER_REX . test ( val ) ; } 
function scopeUrl ( options , inst ) { options = _ . extend ( { } , inst , options ) if ( ! options . season_id && ! options . team_id && ! ( options . flight_stage_id && options . flight_id ) ) throw new Error ( 'flight_stage_id+flight_id, season_id and/or team_id required to make team instance api calls' ) if ( options . flight_stage_id && options . flight_id ) { var url = ngin . Flight . urlRoot ( ) + '/' + options . flight_id + '/flight_stages/' + options . flight_stage_id + '/teams' return options . team_id ? url + '/' + options . team_id : url } else if ( options . season_id ) { var url = ngin . Season . urlRoot ( ) + '/' + options . season_id + '/teams' return options . team_id ? url + '/' + options . team_id : url } else { return ngin . Team . urlRoot ( ) + '/' + options . team_id + ngin . TeamInstance . urlRoot ( ) } } 
function Imagesloader ( opts ) { var self = { } ; var opts = opts || { } ; var imageloader = Imageloader ( ) ; var imgs = [ ] ; var srcs = [ ] ; var def ; function load ( images ) { def = Deferred ( ) ; srcs = convertImagesToSrc ( images ) ; for ( var i = 0 ; i < srcs . length ; i ++ ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { imageLoaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn\'t be loaded' ) ; } ) ; } ; return def . promise ; } /** * Image loaded checker * @param {img} img The loaded image */ function imageLoaded ( img ) { /** Notify the promise */ def . notify ( "notify" ) ; /** Add the image to the imgs array */ imgs . push ( img ) ; /** If the imgs array size is the same as the src's */ if ( imgs . length == srcs . length ) { sortImages ( ) ; def . resolve ( imgs ) ; } } function convertImagesToSrc ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i ++ ) { if ( typeof imgs [ i ] == 'object' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; } function sortImages ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i ++ ) { for ( var j = 0 ; j < imgs . length ; j ++ ) { var str = imgs [ j ] . src . toString ( ) ; var reg = new RegExp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; } self . load = load ; return self ; } 
function load ( images ) { def = Deferred ( ) ; srcs = convertImagesToSrc ( images ) ; for ( var i = 0 ; i < srcs . length ; i ++ ) { imageloader . load ( srcs [ i ] ) . success ( function ( img ) { imageLoaded ( img ) ; } ) . error ( function ( msg ) { def . reject ( msg + ' couldn\'t be loaded' ) ; } ) ; } ; return def . promise ; } 
function imageLoaded ( img ) { def . notify ( "notify" ) ; imgs . push ( img ) ; if ( imgs . length == srcs . length ) { sortImages ( ) ; def . resolve ( imgs ) ; } } 
function convertImagesToSrc ( imgs ) { var src = [ ] ; for ( var i = 0 ; i < imgs . length ; i ++ ) { if ( typeof imgs [ i ] == 'object' ) { src . push ( imgs [ i ] . src ) ; } } ; return src . length ? src : imgs ; } 
function sortImages ( ) { var arr = [ ] ; for ( var i = 0 ; i < srcs . length ; i ++ ) { for ( var j = 0 ; j < imgs . length ; j ++ ) { var str = imgs [ j ] . src . toString ( ) ; var reg = new RegExp ( srcs [ i ] ) if ( str . match ( reg ) ) arr . push ( imgs [ j ] ) ; } ; } ; imgs = arr ; } 
function builder ( envList , envName ) { if ( envList == null ) { envList = DEFAULT_ENV_LIST ; } if ( envName == null ) { envName = DEFAULT_ENV_NAME ; } if ( ! Array . isArray ( envList ) ) { throw new Error ( 'envList must be an array' ) ; } if ( typeof envName !== 'string' ) { throw new Error ( 'envName must be a string' ) ; } * . */ 
function DataType_Array_toString ( source ) { 
function agent ( agency , jn ) { 'use strict' ; 
function validateId ( id ) { if ( id && id . trim ( ) && / ^[a-zA-Z0-9_]+$ / . test ( id ) ) { if ( agency . isIdInUse ( id ) ) { err . name = 'DuplicateIdError' ; err . message = 'duplication (use a different id)' ; return err ; } else { return id ; } } else { err . name = 'ValidateIdError' ; err . message = 'failed id validation (please use alphanumeric characters and underscore)' ; return err ; } } 
function arrayGetUniques ( arr ) { var a = [ ] ; for ( var i = 0 , l = arr . length ; i < l ; i ++ ) { if ( a . indexOf ( arr [ i ] ) === - 1 && arr [ i ] !== '' ) a . push ( arr [ i ] ) ; } return a ; } 
function parseExpression ( expr ) { var parentList = [ ] ; var parsedTokenizedExpression = [ ] ; var parsedExpression = '' ; var testInvalidChar ; if ( expr && expr . trim ( ) ) { parsedExpression = expr . replace ( / \040 / g , '' ) ; testInvalidChar = / [^a-zA-Z0-9_&|!()_] / . test ( parsedExpression ) ; 
function setFunction ( f ) { if ( canExecute ) { if ( Object . getPrototypeOf ( f ) === Function . prototype ) { func = f ; jn . logCreationEvent ( id , 'INFO' , 'function definition completed' , ( new Date ( ) ) . toJSON ( ) ) ; } else { setCanExecute ( false ) ; jn . logCreationEvent ( id , 'ERROR' , 'function definition failed' , ( new Date ( ) ) . toJSON ( ) ) ; } } } 
function setCallback ( cb ) { if ( canExecute ) { if ( Object . getPrototypeOf ( cb ) === Function . prototype ) { callback = cb ; jn . logCreationEvent ( id , 'INFO' , 'callback definition completed' , ( new Date ( ) ) . toJSON ( ) ) ; } else { setCanExecute ( false ) ; jn . logCreationEvent ( id , 'ERROR' , 'callback definition failed' , ( new Date ( ) ) . toJSON ( ) ) ; } } } 
function getValueOfAgent ( dep ) { var len = dependencies . length ; for ( var i = 0 ; i < len ; i ++ ) { if ( dep === dependencies [ i ] ) { return agency . getAgentValue ( dep ) ; } } jn . logExecutionEvent ( id , 'INFO' , 'could not get value of agent ' + dep + ' (not a dependency)' , ( new Date ( ) ) . toJSON ( ) ) ; return null ; } 
function execute ( ) { var res ; var functionInterface = { getValueOfAgent : getValueOfAgent } ; if ( func ) { setWaitingExec ( true ) ; setTimeout ( function ( ) { var errorOnExecution = false ; jn . logExecutionEvent ( id , 'INFO' , 'began function execution' , ( new Date ( ) ) . toJSON ( ) ) ; try { res = func ( functionInterface ) ; setResult ( res ) ; if ( callback ) { callback ( null , res ) ; } jn . logExecutionEvent ( id , 'INFO' , 'function executed whitout errors' , ( new Date ( ) ) . toJSON ( ) ) ; } catch ( err ) { errorOnExecution = true ; setResult ( err ) ; jn . logExecutionEvent ( id , 'ERROR' , 'failed to execute function: ' + err . message , ( new Date ( ) ) . toJSON ( ) ) ; if ( callback ) { callback ( err ) ; } } setExecuted ( true ) ; setWaitingExec ( false ) ; if ( haltsExecution && errorOnExecution ) { jn . logExecutionEvent ( id , 'ERROR' , 'error on execution halted agency execution' , ( new Date ( ) ) . toJSON ( ) ) ; agency . report ( ) ; } else { agency . runAgents ( ) ; } } , 0 ) ; } else { jn . logExecutionEvent ( id , 'INFO' , 'does not have a defined function' , ( new Date ( ) ) . toJSON ( ) ) ; } } 
function Case ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Case . super_ . apply ( this , arguments ) ; } 
function ( panelName ) { if ( this . _currentPanelLocked ) { if ( this . _currentPanel !== this . _panels [ panelName ] ) return Promise . reject ( new Error ( "Current panel locked" ) ) ; return Promise . resolve ( this . _currentPanel ) ; } this . _panelForShowPromise = this . panel ( panelName ) ; return this . _panelForShowPromise . then ( setCurrentPanelIfNecessary . bind ( this , this . _panelForShowPromise ) ) ; function setCurrentPanelIfNecessary ( panelPromise , panel ) { if ( this . _panelForShowPromise !== panelPromise ) return null ; this . setCurrentPanel ( panel ) ; return panel ; } } 
function Resource ( parent , definition ) { this . parent = parent ; this . definition = definition ; 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) var url = config . urls && config . urls . sports || config . url url = ngin . Season . urlRoot ( ) + '/' + options . season_id + '/teams/' + options . team_id + '/rosters' if ( options . id ) url += '/' + options . id return url } 
function ( ctx ) { var DMYRegex = / ^([0-9]{1,2})[\.\-\/]([0-9]{1,2})[\.\-\/]([0-9]{4,4})\s([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}) / gi ; var regexmatch = DMYRegex . exec ( ctx . value ) ; if ( ! regexmatch || regexmatch . length !== 7 ) { return console . log ( 'valdiation error -- not DMY' , ctx ) ; } var datetime = [ [ regexmatch [ 3 ] , regexmatch [ 2 ] , regexmatch [ 1 ] ] . join ( '-' ) , [ regexmatch [ 4 ] , regexmatch [ 5 ] , regexmatch [ 6 ] ] . join ( ':' ) ] . join ( ' ' ) ; var date = new Date ( datetime ) ; ctx . value = date . getTime ( ) ; return ctx ; } 
function ( result ) { var body = JSON . parse ( result . body ) ; 
function getIndexesOfArray ( arrayToSearchFor , arrayToSearchInside ) { errorIfNotArray_1 . errorIfNotArray ( arrayToSearchFor ) ; error_if_not_populated_array_1 . errorIfNotPopulatedArray ( arrayToSearchInside ) ; var indexes = [ ] ; arrayToSearchInside . filter ( function ( value , index ) { if ( isArray_notArray_1 . isArray ( value ) && arrays_match_1 . arraysMatch ( value , arrayToSearchFor ) ) { indexes . push ( index ) ; return true ; } else return false ; } ) ; return indexes ; } 
function _isZero ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( _isNumber ( val ) ) { return val - 0 === 0 ; } if ( opts . isStrict !== true ) { return _isRealNumber ( val ) && val - 0 === 0 ; } return false ; } 
function containerSlug ( language_slug , project_slug , resource_slug ) { if ( ! language_slug || ! project_slug || ! resource_slug ) throw new Error ( 'Invalid resource container slug parameters' ) ; return language_slug + '_' + project_slug + '_' + resource_slug ; } 
function Container ( container_directory , package_json ) { let config_yaml = { } ; let toc_yaml = { } ; assert ( container_directory , 'resource-container: missing container_directory' ) ; assert . equal ( typeof container_directory , 'string' , 'resource-container: container_directory should be a string' ) ; try { let configFile = path . join ( container_directory , content_dir , 'config.yml' ) ; if ( fileUtils . fileExists ( configFile ) ) config_yaml = YAML . parse ( fs . readFileSync ( configFile , { encoding : 'utf8' } ) ) ; } catch ( err ) { console . warn ( err ) ; } try { let tocFile = path . join ( container_directory , content_dir , 'toc.yml' ) ; if ( fileUtils . fileExists ( tocFile ) ) toc_yaml = YAML . parse ( fs . readFileSync ( tocFile , { encoding : 'utf8' } ) ) ; } catch ( err ) { console . warn ( err ) ; } assert ( package_json , 'resource-container: missing package json' ) ; assert ( package_json . language , 'resource-container: missing language' ) ; assert ( package_json . project , 'resource-container: missing project' ) ; assert ( package_json . resource , 'resource-container: missing resource' ) ; assert ( package_json . resource . type , 'resource-container: missing resource type' ) ; return { get language ( ) { return package_json . language ; } , get project ( ) { return package_json . project ; } , get resource ( ) { return package_json . resource ; } , chapters : function ( ) { let dir = path . join ( container_directory , content_dir ) ; return fs . readdirSync ( dir ) . filter ( function ( file ) { try { return fs . statSync ( file ) . isDirectory ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } , chunks : function ( chapterSlug ) { let dir = path . join ( container_directory , content_dir , chapterSlug ) ; return fs . readdirSync ( dir ) . filter ( function ( file ) { try { return fs . statSync ( file ) . isFile ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } , readChunk : function ( chapterSlug , chunkSlug ) { let file = path . join ( container_directory , content_dir , chapterSlug , chunkSlug + '.' + this . chunkExt ) ; return fs . readFileSync ( file , { encoding : 'utf8' } ) ; } , get chunkExt ( ) { switch ( package_json [ 'content_mime_type' ] ) { case 'text/usx' : return 'usx' ; case 'text/usfm' : return 'usfm' ; case 'text/markdown' : return 'md' ; default : return 'txt' ; } } , get path ( ) { return container_directory ; } , get slug ( ) { return containerSlug ( package_json . language . slug , package_json . project . slug , package_json . resource . slug ) ; } , get type ( ) { return package_json . resource . type ; } , get info ( ) { return package_json ; } , get config ( ) { return config_yaml ; } , get toc ( ) { return toc_yaml ; } } ; } 
function ( ) { let dir = path . join ( container_directory , content_dir ) ; return fs . readdirSync ( dir ) . filter ( function ( file ) { try { return fs . statSync ( file ) . isDirectory ( ) ; } catch ( err ) { console . log ( err ) ; return false ; } } ) ; } 
function ( chapterSlug , chunkSlug ) { let file = path . join ( container_directory , content_dir , chapterSlug , chunkSlug + '.' + this . chunkExt ) ; return fs . readFileSync ( file , { encoding : 'utf8' } ) ; } 
function makeContainer ( container_directory , opts ) { return new Promise ( function ( resolve , reject ) { if ( fileUtils . fileExists ( container_directory ) ) { reject ( new Error ( 'Container already exists' ) ) ; return ; } let package_json = { } ; 
function openContainer ( container_archive , container_directory , opts ) { opts = opts || { compression_method : 'tar' } ; if ( fileUtils . fileExists ( container_directory ) ) { return loadContainer ( container_directory ) ; } if ( ! fileUtils . fileExists ( container_archive ) ) return Promise . reject ( new Error ( 'Missing resource container' ) ) ; if ( opts . compression_method === 'zip' ) { return compressionUtils . unzip ( container_archive , container_directory ) . then ( function ( dir ) { return loadContainer ( dir ) ; } ) ; } else { return compressionUtils . untar ( container_archive , container_directory ) . then ( function ( dir ) { return loadContainer ( dir ) ; } ) ; } } 
function closeContainer ( container_directory , opts ) { opts = opts || { compression_method : 'tar' , clean : true } ; if ( ! fileUtils . fileExists ( container_directory ) ) return Promise . reject ( new Error ( 'Missing resource container' ) ) ; var container_archive = container_directory + '.' + spec . file_ext ; var compressPromise = Promise . resolve ( container_archive ) ; 
function localizeChapterTitle ( language_slug , chapter_number ) { var translations = { 'ar' : ' %', 'en' : 'Chapter %' , 'ru' : ' %', 'hu' : '%. fejezet' , 'sr-Latin' : ' %', 'default' : 'Chapter %' } ; var title = translations [ language_slug ] ; if ( ! title ) title = translations [ 'default' ] ; var num = parseInt ( chapter_number ) ; if ( isNaN ( num ) ) num = chapter_number ; return title . replace ( '%' , num ) ; } 
function normalizeSlug ( slug ) { if ( typeof slug !== 'string' ) throw new Error ( 'slug must be a string' ) ; if ( slug === '' ) throw new Error ( 'slug cannot be an empty string' ) ; if ( isNaN ( Number ( slug ) ) ) return slug ; slug = slug . replace ( / ^(0+) / , '' ) . trim ( ) ; while ( slug . length < 2 ) { slug = '0' + slug ; } return slug ; } 
function inspectContainer ( container_path , opts ) { return new Promise ( function ( resolve , reject ) { if ( path . extname ( container_path ) !== '.' + spec . file_ext ) { reject ( new Error ( 'Invalid resource container file extension' ) ) ; return ; } try { resolve ( fs . statSync ( container_path ) . isFile ( ) ) ; } catch ( err ) { reject ( new Error ( 'The resource container does not exist at' , container_path ) ) ; } } ) . then ( function ( isFile ) { if ( isFile ) { 
function scopeUrl ( options , inst , action ) { var opts = _ . extend ( { } , inst , options ) if ( ! opts . id && ! opts . tournament_id && ! opts . league_id && ! opts . season_id ) throw new Error ( 'id, season_id, tournament_id or league_id required to make survey api calls' ) return Survey . urlRoot ( ) + '/' + action + ( opts . id ? '/' + opts . id : '' ) + '.json' } 
function ( ) { var headerTableColumns = this . _headerTableColumnGroup . children ; 
function UserPreference ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } UserPreference . super_ . apply ( this , arguments ) ; } 
function ( room , sockets ) { 
function ( Crafty , socket ) { 
function ( Crafty , socket ) { 
function Server ( sockets ) { return { createInstance : function ( room ) { return createInstance ( room , sockets ) ; } , addClient : addClient , removeClient : removeClient } ; } 
function ( immediateFN , connectFN , disconnectFN , port ) { var app = require ( 'express' ) ( ) , server = require ( 'http' ) . createServer ( app ) , io = require ( 'socket.io' ) . listen ( server ) , path = require ( 'path' ) , browserify = require ( 'browserify-middleware' ) ; io . set ( 'log level' , 2 ) ; server . listen ( port || process . env . PORT || 80 ) ; var browserifyOptions = { } ; browserifyOptions [ path . join ( __dirname + '/npm_crafty.client.js' ) ] = { expose : 'npm_crafty' } ; app . get ( '/npm_crafty.js' , browserify ( [ browserifyOptions ] ) ) ; app . get ( '/crafty_client.js' , function ( req , res ) { res . sendfile ( path . join ( __dirname + '/crafty_client.js' ) ) ; } ) ; io . sockets . on ( 'connection' , function ( socket ) { console . log ( "Connected " , socket . id ) ; connectFN ( socket ) ; socket . on ( 'disconnect' , function ( arg ) { console . log ( "Disconnected " , socket . id ) ; disconnectFN ( socket ) ; } ) ; } ) ; process . nextTick ( immediateFN ) ; var _server = new Server ( io . sockets ) ; _server . app = app ; _server . server = server ; _server . io = io ; return _server ; } 
function _create ( crud , schema , data ) { if ( data . _id ) delete data . _id ; 
function replace ( format , data ) { return format . replace ( / {(\w+)} / g , ( m , name ) => ( data [ name ] ? data [ name ] : '' ) ) ; } 
function highlight ( code , lang ) { const g = Prism . languages [ lang ] ; if ( g ) { return Prism . highlight ( code , g , lang ) ; } return code ; } 
function getUpdater ( errorFn ) { errorFn = errorFn || new Function ( ) ; return updater ; function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( testDocTag ) . map ( getAnnotatedNode ) . concat ( inferAngular ( ast ) ) * Get the node that is annotated by the comment or throw if not present. * @throws {Error} Where comment does not annotate a node * @param {object} comment The comment node */ function getAnnotatedNode ( comment ) { 
function updater ( file , ast ) { if ( ast . comments ) { ast . comments . filter ( testDocTag ) . map ( getAnnotatedNode ) . concat ( inferAngular ( ast ) ) 
function getAnnotatedNode ( comment ) { 
function locationStr ( runtime , line ) { var loc ; loc = 'line: ' + ( line !== undefined ? line : runtime . lineNumber ) ; if ( runtime . file ) { loc += ' -- file: ' + runtime . file ; } return loc ; } 
function _isTelephone ( val , locale ) { var key = _isString ( locale ) ? locale : LOCALE_ENUM . ZHCN ; var rex = REGEX_ENUM . TELEPHONE_REX [ key ] ; if ( ! rex ) { return false ; } if ( ! _isString ( val ) ) { return false ; } return rex . test ( val ) ; } 
function Macro ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } this . destroy = destroyMixin ; Macro . super_ . apply ( this , arguments ) ; } 
function quickSort ( a , l , h , k , c ) { const s = [ ] ; let t = 0 ; s [ t ++ ] = l ; s [ t ++ ] = h ; while ( t > 0 ) { h = s [ -- t ] ; l = s [ -- t ] ; if ( h - l > k ) { const p = partition ( a , l , h , c ) ; if ( p > l ) { s [ t ++ ] = l ; s [ t ++ ] = p ; } if ( p + 1 < h ) { s [ t ++ ] = p + 1 ; s [ t ++ ] = h ; } } } } 
function pivot ( a , l , h , c ) { const p = ( l + ( ( h - l ) / 2 ) ) | 0 ; if ( c ( a [ h ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ h ] ] = [ a [ h ] , a [ l ] ] ; } if ( c ( a [ p ] , a [ l ] ) < 0 ) { [ a [ l ] , a [ p ] ] = [ a [ p ] , a [ l ] ] ; } if ( c ( a [ h ] , a [ p ] ) < 0 ) { [ a [ h ] , a [ p ] ] = [ a [ p ] , a [ h ] ] ; } return p ; } 
function partition ( a , l , h , c ) { const p = a [ pivot ( a , l , h , c ) ] ; let i = l - 1 ; let j = h + 1 ; for ( ; ; ) { do { i ++ ; } while ( c ( a [ i ] , p ) < 0 ) ; do { j -- ; } while ( c ( a [ j ] , p ) > 0 ) ; if ( i < j ) { [ a [ i ] , a [ j ] ] = [ a [ j ] , a [ i ] ] ; } else { return j ; } } } 
function insertionSort ( a , l , h , c ) { for ( let i = l + 1 ; i <= h ; i ++ ) { const x = a [ i ] ; let j = i - 1 ; while ( j >= 0 && c ( a [ j ] , x ) > 0 ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = x ; } } 
function search ( parent , baseUrl , callback ) { var resource = new ( getResource ( 'page' ) ) ( parent , { _links : { self : { href : baseUrl , 'class' : 'page' } } } ) ; if ( typeof callback == 'function' ) return resource . exec ( callback ) ; return resource ; } 
function createPipeStream ( cmd ) { var proc ; var command ; if ( Array . isArray ( cmd ) ) { 
function PipeStream ( self ) { 
function wrapMethods ( self ) { var methods = [ 'on' ] ; var childObjects = [ 'stdin' , 'stdout' , 'stderr' ] ; 
function addFunctions ( self ) { 
function connectEvents ( self ) { if ( self . stdout ) { self . stdout . on ( 'data' , function ( d ) { self . emit ( 'data' , d ) ; } ) ; self . stderr . on ( 'data' , function ( d ) { self . emit ( 'error' , d ) ; } ) ; } } 
function addEventHandlers ( self ) { self . on ( 'error' , function ( d ) { var fn = self . _error ; self . _cleanUp ( ) ; if ( fn ) { fn ( 'pipeline[' + self . _nr + ']:"' + self . _command + '" failed with: ' + d . toString ( ) ) ; } } ) ; } 
function _resolve ( routes , path , req , res ) { return Q . fcall ( function ( ) { path = path || [ ] ; var obj = routes ; 
function do_parse_url ( url ) { var s = require ( 'url' ) . parse ( url ) . pathname . replace ( / [^a-zA-Z0-9_\-\+\.]+ / g , "/" ) . replace ( / ^\/+ / , "" ) ; if ( s . length === 0 ) { return [ ] ; } return s . split ( "/" ) ; } 
function link ( definition ) { var key , link , newResource , Resource ; if ( '_links' in definition ) { for ( key in definition . _links ) { if ( key === 'self' ) continue ; link = definition . _links [ key ] ; key = key . charAt ( 0 ) + inflection . camelize ( key ) . slice ( 1 ) ; 
function _buildFunction ( resource ) { return function ( callback ) { if ( typeof callback == 'function' ) { if ( resource !== null ) return resource . exec . call ( resource , callback ) ; else return callback ( null , null ) ; } return resource ; } } 
function _isNegativeInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . NEGATIVE_INTEGER_REX . test ( val ) ; } return REGEX_ENUM . NEGATIVE_INTEGER_REX . test ( val ) ; } 
function generateSignature ( secretKey , method , contentMd5 , contentType , date , canonicalizedHeaders , canonicalizedResource ) { var hmac = _crypto2 . default . createHmac ( SHA256 , secretKey ) ; var headers = canonicalizedHeaders . map ( function ( header ) { return header . toLowerCase ( ) ; } ) . sort ( ) . join ( '\n' ) ; var data = method + '\n' + contentMd5 + '\n' + contentType + '\n' + date + '\n' ; if ( headers && headers . length ) { data += headers + '\n' ; } data += canonicalizedResource ; hmac . update ( data ) ; return hmac . digest ( ENCODING ) ; } 
function getObject ( host , accessKey , secretKey , bucket , objectKey ) { var expires = arguments . length <= 5 || arguments [ 5 ] === undefined ? 0 : arguments [ 5 ] ; var opts = arguments . length <= 6 || arguments [ 6 ] === undefined ? { } : arguments [ 6 ] ; var date = utcDate ( ) ; if ( opts . versionId ) url += '?versionId=' + opts . versionId ; var resource = genResource ( bucket , objectKey , ( 0 , _lodash . pick ) ( opts , [ 'versionId' ] ) ) ; var signature = encodeURIComponent ( generateSignature ( secretKey , 'GET' , '' , '' , expires , [ ] , resource ) ) ; var url = pub ? 'http://' + bucket + '.' + host + '/' + objectKey : 'http://' + host + '/' + bucket + '/' + objectKey + '?NOSAccessKeyId=' + accessKey + '&Expires=' + expires + '&Signature=' + signature ; var headers = { Date : date } ; if ( opts . range ) headers . Range = opts . range ; if ( opts . modifiedSince ) headers [ 'If-Modified-Since' ] = opts . modifiedSince ; headers [ 'url' ] = url ; return nosRequest ( { method : 'get' , headers : headers , uri : url } ) ; } 
function getMeta ( host , accessKey , secretKey , bucket , objectKey ) { var expires = arguments . length <= 5 || arguments [ 5 ] === undefined ? 0 : arguments [ 5 ] ; var opts = arguments . length <= 6 || arguments [ 6 ] === undefined ? { } : arguments [ 6 ] ; var date = utcDate ( ) ; if ( opts . versionId ) url += '?versionId=' + opts . versionId ; var resource = genResource ( bucket , objectKey , ( 0 , _lodash . pick ) ( opts , [ 'versionId' ] ) ) ; var authorization = authorize ( accessKey , secretKey , 'HEAD' , '' , '' , date , [ ] , resource ) ; var signature = ( 0 , _urlencode2 . default ) ( generateSignature ( secretKey , 'HEAD' , '' , '' , date , [ ] , resource ) ) ; var url = pub ? 'http://' + bucket + '.' + host + '/' + objectKey : 'http://' + host + '/' + bucket + '/' + objectKey + '?NOSAccessKeyId=' + accessKey + '&Expires=' + expires + '&Signature=' + signature ; var headers = { Date : date } ; if ( opts . modifiedSince ) headers [ 'If-Modified-Since' ] = opts . modifiedSince ; headers [ 'url' ] = url ; return nosRequest ( { method : 'head' , uri : url , headers : headers } ) . then ( function ( res ) { var contentType = res [ 'content-type' ] ; var lastModified = res [ 'last-modified' ] ; var etag = res [ 'etag' ] ; var requestId = res [ 'x-nos-request-id' ] ; return { contentType : contentType , lastModified : lastModified , etag : etag , requestId : requestId } ; } ) ; } 
function upload ( host , accessKey , secretKey , bucket , objectKey , file ) { var nosHeader = arguments . length <= 6 || arguments [ 6 ] === undefined ? { } : arguments [ 6 ] ; nosHeader [ 'x-nos-storage-class' ] = nosHeader [ 'x-nos-storage-class' ] || 'standard' ; var date = utcDate ( ) ; var content = _fs2 . default . readFileSync ( file ) ; var contentLength = content . length ; var contentMd5 = ( 0 , _md2 . default ) ( content ) ; var resource = genResource ( bucket , objectKey ) ; var canonicalizedHeaders = Object . keys ( nosHeader ) . map ( function ( key ) { return key + ':' + nosHeader [ key ] ; } ) ; var authorization = authorize ( accessKey , secretKey , 'PUT' , contentMd5 , '' , date , canonicalizedHeaders , resource ) ; var url = 'http://' + bucket + '.' + host + '/' + objectKey ; var headers = ( 0 , _lodash . assign ) ( { Date : date , 'Content-Length' : contentLength , 'Content-MD5' : contentMd5 , Authorization : authorization , 'url' : url } , nosHeader ) ; return nosRequest ( { method : 'put' , uri : url , body : content , headers : headers } ) ; } 
function _isUnNegativeInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . UN_NEGATIVE_INTEGER_REX . test ( val ) ; } return REGEX_ENUM . UN_NEGATIVE_INTEGER_REX . test ( val ) ; } 
function getFileList ( ) { var result = [ ] , fileNameList = [ 'da.md' , 'en.md' ] , cwd , fileName ; for ( var i = 0 ; i < dirList . length ; i ++ ) { cwd = paths . temp_dist + dirList [ i ] ; for ( var f in fileNameList ) { fileName = fileNameList [ f ] ; if ( grunt . file . isFile ( cwd + '/' + fileName ) ) result . push ( { cwd : cwd , src : fileName } ) ; } } return result ; } 
function ( mixins , options ) { 
function ( base , wrapped ) { return function ( ) { var args = [ ] . slice . call ( arguments , 0 ) ; return wrapped . apply ( this , [ _ . bind ( base , this ) ] . concat ( args ) ) ; } ; } 
function ( base , before ) { return Advice . around ( base , function ( ) { var args = [ ] . slice . call ( arguments , 0 ) , orig = args . shift ( ) , beforeFn ; beforeFn = ( typeof before == 'function' ) ? before : before . obj [ before . fnName ] ; beforeFn . apply ( this , args ) ; return ( orig ) . apply ( this , args ) ; } ) ; } 
function ( base , after ) { return Advice . around ( base , function ( ) { var args = [ ] . slice . call ( arguments , 0 ) , orig = args . shift ( ) , afterFn ; 
function ( base , key , value ) { var extBase = base ; if ( typeof extBase == 'function' ) extBase = base . prototype ; if ( _ . isString ( key ) ) { var temp = key ; key = { } ; key [ temp ] = value ; } _ . extend ( extBase , key ) ; return base ; } 
function ( base , obj ) { var extBase = base ; if ( typeof extBase == 'function' ) extBase = base . prototype ; _ . each ( obj , function ( val , key ) { extBase [ key ] = _ . extend ( _ . clone ( Advice . findVal ( extBase , key ) ) || { } , val ) ; } ) ; return base ; } 
function ( obj , name ) { while ( ! obj [ name ] && obj . prototype ) obj = obj . prototype ; return obj [ name ] ; } 
function ( obj ) { var addApi = function ( ) { 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( options && options . flight_id ) { var route = ngin . Flight . urlRoot ( ) + '/' + options . flight_id + StandingsPreference . urlRoot ( ) } else if ( options && ( options . division_id && options . game_type ) ) { var route = ngin . Division . urlRoot ( ) + '/' + options . division_id + StandingsPreference . urlRoot ( ) + '/' + options . game_type } else { throw new Error ( 'flight_id or division_id and game_type required to make standings preference api calls' ) } var base = config . urls && config . urls . sports || config . url return Url . resolve ( base , route ) } 
function expose ( obj , val ) { if ( arguments . length === 1 ) { if ( obj instanceof Error ) Object . defineProperty ( obj , "message" , { enumerable : true , value : obj . message } ) ; val = obj ; } return resource ( obj , { expose : val } ) ; } 
function getApiKey ( ) { if ( isLocal ( ) && pkg . apiKey ) { log . trace ( 'using apiKey in fhconfig' ) ; return pkg . apiKey ; } else { log . trace ( 'using api key in FH_APP_API_KEY env var' ) ; return env ( 'FH_APP_API_KEY' ) . asString ( ) ; } } 
function strMapToObj ( strMap ) { const obj = { } for ( const [ k , v ] of strMap ) { 
function getResource ( name ) { if ( name in resources ) return resources [ name ] ; try { return resources [ name ] = require ( '../resource/' + name ) ; } catch ( err ) { return resources [ name ] = require ( '../resource' ) ; } } 
function _isPlainObject ( val ) { if ( ! _isObject ( val ) ) { return false ; } var proto = Object . getPrototypeOf ( val ) ; if ( proto === null ) { return true ; } var ctor = proto . constructor ; return _isFunction ( ctor ) ; } 
function stringify ( obj , replacer , space ) { if ( typeof replacer === 'string' || typeof replacer === 'number' ) { 
function buildNav ( members , opts ) { var nav = '' , seen = { } , list = { Modules : 'modules' , Externals : 'externals' , Classes : 'classes' , Events : 'events' , Namespaces : 'namespaces' , Mixins : 'mixins' } , hasClassList = false , classNav = '' , globalNav = '' ; nav += '<h2><a href="index.html">' + ( opts . indexName || 'Index' ) + '</a></h2>' ; for ( var name in list ) { if ( members [ list [ name ] ] . length ) { nav += '<div class="nav-' + list [ name ] + '">' ; nav += '<h3>' + name + '</h3><ul>' ; members [ list [ name ] ] . forEach ( function ( m ) { if ( ! hasOwnProp . call ( seen , m . longname ) ) { nav += '<li title="' + m . longname + '">' + linkto ( m . longname , m . name ) + '</li>' ; } seen [ m . longname ] = true ; var funcs = find ( { kind : 'function' , memberof : m . longname === 'Global' ? { isUndefined : true } : m . longname } ) ; if ( funcs . length ) { nav += '<div class="navinner nav-methods"><h4>Methods</h4><ul>' ; funcs . forEach ( function ( f ) { if ( ! hasOwnProp . call ( seen , f . longname ) ) { nav += '<li title="' + f . longname + '">' + linkto ( f . longname , f . name ) + '</li>' ; } seen [ m . longname ] = true ; } ) ; nav += '</ul></div>' ; } } ) ; nav += '</ul>' ; } } if ( members . tutorials . length ) { nav += '<h3>Tutorials</h3><ul>' ; members . tutorials . forEach ( function ( t ) { nav += '<li>' + tutoriallink ( t . name ) + '</li>' ; } ) ; nav += '</ul>' ; } if ( members . globals . length ) { members . globals . forEach ( function ( g ) { if ( g . kind !== 'typedef' && ! hasOwnProp . call ( seen , g . longname ) ) { globalNav += '<li title="' + g . longname + '">' + linkto ( g . longname , g . name ) + '</li>' ; } seen [ g . longname ] = true ; } ) ; if ( ! globalNav ) { 
function WMURL_encode ( source ) { 
function updateSubscribers ( ) { lastUpdate = Date . now ( ) ; updateRequested = false ; var accessMap = new immutable . Map ( ) ; for ( var path of dirtyState ) { accessMap = setIn ( accessMap , path , true ) ; } dirtyState . clear ( ) ; for ( var subscriber of subscribers . values ( ) ) { var needsUpdate = false ; for ( path of subscriber . accessed ) { if ( accessMap . getIn ( path ) ) { needsUpdate = true ; break ; } } if ( needsUpdate ) { updateSubscriber ( subscriber ) ; } } } 
function updateSubscriber ( subscriber ) { stateAccessed . clear ( ) ; subscriber . fn ( ) ; subscriber . accessed = Array . from ( stateAccessed ) ; } 
function setIn ( o , path , value ) { if ( path . length ) { var key = path [ 0 ] ; var rest = path . slice ( 1 ) ; if ( typeof key === 'number' && ! ( o instanceof immutable . List ) ) { o = new immutable . List ( ) ; } else if ( ! ( o instanceof immutable . Map ) ) { o = new immutable . Map ( ) ; } return o . set ( key , setIn ( o . get ( path [ 0 ] ) , path . slice ( 1 ) , value ) ) ; } else { return immutable . fromJS ( value ) ; } } 
function toJS ( o ) { if ( typeof o === 'object' && o !== null && typeof o . toJS === 'function' ) { o = o . toJS ( ) ; } return o ; } 
function toPath ( arr ) { if ( typeof arr === 'string' ) { arr = arr . split ( '.' ) ; } else if ( ! Array . isArray ( arr ) ) { arr = [ arr ] ; } return arr ; } 
function signMsg ( msg , key , alg ) { var signer = crypto . createSign ( alg ) ; signer . update ( msg ) ; return signer . sign ( key ) ; } 
function hashMsg ( msg , alg ) { var hash = crypto . createHash ( alg ) ; hash . update ( msg ) ; return hash . digest ( ) ; } 
function decryptAPIMResponse ( body , private_key ) { if ( ! body . key || ! body . cipher ) { throw new Error ( 'bad handshake response from APIm' ) ; } var key = crypto . privateDecrypt ( { key : private_key , padding : constants . RSA_PKCS1_PADDING } , new Buffer ( body . key , 'base64' ) ) ; var iv = new Buffer ( 16 ) ; iv . fill ( 0 ) ; var decipher = crypto . createDecipheriv ( 'aes-256-cbc' , key , iv ) ; var plainText = decipher . update ( body . cipher , 'base64' , 'utf8' ) ; plainText += decipher . final ( 'utf8' ) ; log . debug ( 'handshake response payload:' , plainText ) ; return JSON . parse ( plainText ) ; } 
function addSignatureHeaders ( body , headers , keyId , key ) { if ( ! headers ) { headers = { } ; } if ( ! headers . date ) { headers . date = ( new Date ( ) ) . toUTCString ( ) ; } if ( ! headers . digest ) { headers . digest = 'SHA256=' + hashMsg ( JSON . stringify ( body ) , 'sha256' ) . toString ( 'base64' ) ; } var combine = function ( names , headers ) { var parts = [ ] ; names . forEach ( function ( e ) { parts . push ( e + ': ' + headers [ e ] ) ; } ) ; return parts . join ( '\n' ) ; } ; headers . authorization = 'Signature ' + 'keyId="' + keyId + '", ' + 'headers="date digest", ' + 'algorithm="rsa-sha256", ' + 'signature="' + signMsg ( combine ( [ 'date' , 'digest' ] , headers ) , key , 'RSA-SHA256' ) . toString ( 'base64' ) + '"' ; return headers ; } 
function OZWManager ( ) { this . ozw = new OZW ( { Logging : true , 
function copyORIGINALToBowerJson ( ) { if ( grunt . file . exists ( ORIGINALFileName ) ) { grunt . file . copy ( ORIGINALFileName , 'bower.json' ) ; grunt . file . delete ( ORIGINALFileName ) ; } } 
function eachDependencies ( packageFunc , options ) { var bwr = common . readJSONFile ( 'bower.json' ) ; _eachDependencies ( bwr . name , bwr , packageFunc , options , [ ] , true , common . readJSONFile ( '.bower.json' ) ) ; } 
function _eachDependencies ( packageName , bowerJson , packageFunc , options , packageList , firstLevel , dotBowerJson ) { bowerJson = bowerJson || { } ; dotBowerJson = dotBowerJson || { } ; var dependenciesPackageName , dependencies = bowerJson . dependencies || dotBowerJson . dependencies || { } ; packageFunc ( packageName , bowerJson , options , firstLevel , dotBowerJson ) ; 
async function waitVariableToBe ( variableExpression , value , timeout ) { return await this . waitUntil ( async ( ) => { const result = await this . execute ( ` ${ variableExpression } ${ JSON . stringify ( value ) } ` ) return result . value } , timeout , ` \` ${ variableExpression } \` \` ${ JSON . stringify ( value ) } \` ` ) } 
async function waitAttributeToBe ( selector , key , value , timeout ) { return await this . waitUntil ( async ( ) => { const got = await this . element ( selector ) . getAttribute ( key ) return [ ] . concat ( value ) . some ( ( value ) => got === value || String ( got ) === String ( value ) ) } , timeout , ` ${ key } \` ${ selector } \` \` ${ JSON . stringify ( value ) } \` ` ) } 
function ( view ) { this . unmount ( ) ; this . currentView = view ; var renderReturnsView = this . currentView . render ( ) ; if ( renderReturnsView ) { $ ( SpecialK . mainContainer ) . empty ( ) . append ( renderReturnsView . el ) . fadeIn ( 'slow' ) ; } } 
function ( ) { if ( ! this . currentView ) return false ; $ ( SpecialK . container ) . hide ( ) ; this . currentView . unbind ( ) ; this . currentView . remove ( ) ; this . currentView = null ; return true ; } 
function checkValue ( val , expectedType , name ) { if ( typeof val !== expectedType ) { throw new Error ( name + ' must return ' + expectedType ) ; } return Utils ; } 
function mergeAll ( safe , obj ) { let args = toArray ( arguments ) . slice ( 2 ) ; for ( let i = 0 ; i < args . length ; i ++ ) { obj = merge ( obj , args [ i ] , safe ) ; } return obj ; } 
function callIf ( condition , func ) { return ( condition ? func . apply ( undefined , Array . prototype . slice . call ( arguments , 2 ) ) : undefined ) ; } 
function ( reserved_spaces , object_type ) { v . required ( reserved_spaces , "reserved_spaces" ) ; v . required ( object_type , "object_type" ) ; return { fromByteBuffer ( b ) { return b . readVarint32 ( ) ; } , appendByteBuffer ( b , object ) { v . required ( object ) ; if ( object . resolve !== undefined ) { object = object . resolve ; } 
function quality ( str ) { var parts = str . split ( / *; * / ) , val = parts [ 0 ] ; var q = parts [ 1 ] ? parseFloat ( parts [ 1 ] . split ( / *= * / ) [ 1 ] ) : 1 ; return { value : val , quality : q } ; } 
function cast ( x , type ) { var ctor , len , d , i ; if ( ! arrayLike ( x ) ) { throw new TypeError ( 'invalid input argument. First argument must be an array-like object. Value: `' + x + '`.' ) ; } if ( typeof type === 'string' ) { ctor = getCtor ( type ) ; } else { ctor = getCtor ( dtype ( typeName ( type ) ) ) ; } if ( ctor === null ) { throw new Error ( 'invalid input argument. Unrecognized/unsupported type to which to cast. Value: `' + type + '`.' ) ; } len = x . length ; 
function parse_by_content_type ( type , body ) { if ( type === 'application/json' ) { return JSON . parse ( body ) ; } if ( type === 'text/plain' ) { return '' + body ; } throw new Error ( "Unknown Content-Type " + type + " -- don't know how to parse!" ) ; } 
function _resolveFilter ( req ) { function __isReqObject ( req ) { return ! ! req . url ; } function __hasQueryString ( req ) { return __isReqObject ( req ) && ( Object . keys ( req . query || { } ) . length > 0 ) ; } function __hasRouteParams ( req ) { return __isReqObject ( req ) && ( Object . keys ( req . params || { } ) . length > 0 ) ; } function __hasODATA ( req ) { return __isReqObject ( req ) && ( Object . keys ( req . odata || { } ) . length > 0 ) ; } if ( ! req ) { return { type : "none" , filter : null } ; } else if ( __hasODATA ( req ) ) { return { type : "odata" , filter : req . odata } ; } else if ( __hasQueryString ( req ) ) { return { type : "queryString" , filter : req . query } ; } else if ( __hasRouteParams ( req ) ) { return { type : "routeParams" , filter : req . params } ; } else { if ( __isReqObject ( req ) ) { return req ; } else { if ( typeof ( req ) === "object" ) { return { type : "plainObject" , filter : req } ; } else { return { type : "routeParams" , filter : { "id" : req } } ; } } } } 
function getBrightness ( hex ) { var r = parseInt ( hex . substr ( 2 + 0 * 2 , 2 ) , 16 ) , g = parseInt ( hex . substr ( 2 + 1 * 2 , 2 ) , 16 ) , b = parseInt ( hex . substr ( 2 + 2 * 2 , 2 ) , 16 ) ; function lin2log ( n ) { return n <= 0.0031308 ? n * 12.92 : 1.055 * Math . pow ( n , 1 / 2.4 ) - 0.055 ; } function log2lin ( n ) { return n <= 0.04045 ? n / 12.92 : Math . pow ( ( ( n + 0.055 ) / 1.055 ) , 2.4 ) ; } r = log2lin ( r / 255 ) ; g = log2lin ( g / 255 ) ; b = log2lin ( b / 255 ) ; return lin2log ( 0.2126 * r + 0.7152 * g + 0.0722 * b ) * 100 ; } 
function Route ( args ) { this . name = args . name ; this . method = args . method ; var pattern = args . pattern ; this . pattern = RoutePattern . fromString ( pattern ) ; } 
function Telepathy ( options ) { 'use strict' ; options = options || { } ; if ( typeof options == 'string' ) options = { secret : options } ; var _secret = options . secret || '' ; delete options . secret ; this . user = options . user || '' ; this . alphabet = options . alphabet || Telepathy . alphabet . base62 ; this . length = options . length || 10 ; this . domain = options . domain || '' ; this . algorithm = options . algorithm || 'SHA256' ; this . setSecret = function ( secret ) { _secret = secret || '' ; } ; this . password = function ( options ) { return this . _password ( _secret , options ) ; } ; } 
function readFile ( filename , isJSON , stripComments , defaultContents ) { if ( grunt . file . exists ( filename ) ) { var contents = grunt . file . read ( filename ) ; if ( isJSON || stripComments ) contents = stripJsonComments ( contents ) ; return isJSON ? JSON . parse ( contents ) : contents ; } else return defaultContents ; } 
function readJSONFile ( filename , defaultContents ) { return readFile ( filename , true , true , defaultContents === null ? { } : defaultContents ) ; } 
function writeJSONFile ( fileName , contents ) { var obj = JSON . parse ( JSON . stringify ( contents ) ) ; grunt . file . write ( fileName , JSON . stringify ( obj , null , 4 ) ) ; } 
function writeFile ( fileName , isJSON , contents ) { if ( isJSON ) contents = JSON . stringify ( contents ) ; grunt . file . write ( fileName , contents ) ; } 
function updateOptions ( options , defaultOptions ) { for ( var id in defaultOptions ) if ( defaultOptions . hasOwnProperty ( id ) && ( ! options . hasOwnProperty ( id ) ) || ( options [ id ] === '' ) || ( options [ id ] === null ) ) options [ id ] = defaultOptions [ id ] ; } 
function merge ( ) { var result = { } ; for ( var i = 0 ; i < arguments . length ; i ++ ) for ( var key in arguments [ i ] ) if ( arguments [ i ] . hasOwnProperty ( key ) ) result [ key ] = arguments [ i ] [ key ] ; return result ; } 
function runCmd ( cmd , useCmdOutput ) { if ( ! useCmdOutput ) grunt . log . writeln ( cmd [ 'grey' ] ) ; var shell = require ( 'shelljs' ) , result = shell . exec ( cmd , { silent : ! useCmdOutput } ) ; if ( result . code === 0 ) { if ( ! useCmdOutput ) grunt . log . writeln ( result . stdout [ 'white' ] ) ; } else { if ( ! useCmdOutput ) { grunt . log . writeln ( ) ; grunt . log . writeln ( result . stderr [ 'yellow' ] ) ; } grunt . fail . warn ( '"' + cmd + '" failed.' ) ; } return result ; } 
function createTransition ( glsl ) { 
function command_exists ( paths , name ) { if ( is . string ( paths ) ) { paths = paths . split ( ':' ) ; } debug . assert ( paths ) . is ( 'array' ) ; return paths . some ( dir => fs . existsSync ( PATH . join ( dir , name ) ) ) ; } 
function spawnProcess ( command , args , { env = { } } = { } ) { return Async . Promise ( ( resolve , reject ) => { 
function ( ) { if ( this . _uncommittedIsTop ) this . _data . pop ( ) ; 
function completeAssign ( target ) { for ( var index = 1 ; index < arguments . length ; index ++ ) { var source = arguments [ index ] ; 
function _isInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . INTEGER_REX . test ( val ) ; } return REGEX_ENUM . INTEGER_REX . test ( val ) ; } 
function ( Template ) { return [ Template . language . tag ( 'set' ) , Template . language . tag ( 'setalist' ) , Template . language . tag ( 'setahash' ) , Template . language . tag ( 'addtolist' ) , Template . language . tag ( 'setaregex' ) ] ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'set' ) : return new Set ( Template , expression ) ; case Template . language . tag ( 'setalist' ) : return new SetList ( Template , expression ) ; case Template . language . tag ( 'setahash' ) : return new SetHash ( Template , expression ) ; case Template . language . tag ( 'addtolist' ) : return new AddToList ( Template , expression ) ; case Template . language . tag ( 'setaregex' ) : return new SetARegEx ( Template , expression ) ; default : return { skip : true } ; } } 
function ( Template , expression ) { this . needs = { } ; expression = expression . split ( ' ' ) ; if ( expression . length < 4 ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Set tag has bad syntax' ) ; return ; } var temp = Noodles . Utilities . parseType ( Template , expression [ 1 ] ) ; if ( temp . type !== "object" ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Set tag has bad syntax, the variable must be an identifier or object' ) ; return ; } this . key = temp ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; this . value = Noodles . Utilities . parseType ( Template , expression [ 3 ] ) ; this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . value . needs ) ; } 
function ( Template , expression ) { this . needs = { } ; var reListSplit = new RegExp ( '^' + Template . language . tag ( 'setalist' ) + '\\s+([^=]+)\\s*=\\s*(.+)' ) , obj , list , item ; if ( ! reListSplit . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setalist tag has bad syntax' ) ; return ; } expression = reListSplit . exec ( expression ) obj = Noodles . Utilities . parseType ( Template , expression [ 1 ] ) ; if ( obj . type !== "object" ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setalist tag has bad syntax, the variable must be an identifier or object' ) ; return ; } this . key = obj ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; list = expression [ 2 ] . split ( ',' ) ; for ( var i = 0 , l = list . length ; i < l ; i ++ ) { list [ i ] = Noodles . Utilities . parseType ( Template , list [ i ] . trim ( ) ) ; this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , list [ i ] . needs ) ; } this . value = list ; } 
function ( Template , expression ) { this . needs = { } ; var reHashSplit = new RegExp ( '^' + Template . language . tag ( 'setahash' ) + '\\s+([^=]+)\\s*=\\s*(.+)' ) , hashObject = { } , obj , hash , value ; if ( ! reHashSplit . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setahash tag has bad syntax' ) ; return ; } expression = reHashSplit . exec ( expression ) obj = Noodles . Utilities . parseType ( Template , expression [ 1 ] ) ; if ( obj . type !== "object" ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Setahash tag has bad syntax, the variable must be an identifier or object' ) ; return ; } this . key = obj ; if ( this . key . order . length > 1 ) { this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . key . needs ) ; } else { this . sets = { } ; this . sets [ this . key . order [ 0 ] ] = true ; } this . modifies = { } ; this . modifies [ this . key . order [ 0 ] ] = true ; hash = expression [ 2 ] . split ( ',' ) ; for ( var i = 0 , l = hash . length ; i < l ; i ++ ) { hash [ i ] = hash [ i ] . split ( ':' ) ; value = hash [ i ] [ 0 ] . trim ( ) . toLowerCase ( ) ; hashObject [ value ] = Noodles . Utilities . parseType ( Template , hash [ i ] [ 1 ] . trim ( ) ) this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , hashObject [ value ] . needs ) ; } this . value = hashObject ; } 
function ( Template , expression ) { this . needs = { } ; var reAddToList = new RegExp ( '^' + Template . language . tag ( 'addtolist' ) + '\\s+([^=]+)\\s+to\\s+(.+)' ) ; if ( ! reAddToList . test ( expression ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Addtolist tag has bad syntax' ) ; return ; } expression = reAddToList . exec ( expression ) this . value = Noodles . Utilities . parseType ( Template , expression [ 1 ] ) ; this . list = Noodles . Utilities . parseType ( Template , expression [ 2 ] ) ; if ( this . list . type !== "object" ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Addtolist tag has bad syntax, the list must be an identifier or object' ) ; return ; } this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . value . needs ) ; this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . list . needs ) ; this . modifies = { } ; this . modifies [ this . list . order [ 0 ] ] = true ; } 
function ( Template , expression ) { this . needs = { } ; expression = expression . split ( / \s+ / ) ; this . name = Noodles . Utilities . parseType ( Template , expression [ 0 ] ) ; if ( this . name . type !== "object" ) { Noodles . Utilities . warning ( Template , 'SetARegEx tag has bad syntax, the name must be an identifier' ) ; this . skip = true ; return ; } this . value = Noodles . Utilities . parseType ( Template , expression [ 2 ] ) ; this . options = typeof expression [ 3 ] === "string" && expression [ 3 ] . length > 0 ? expression [ 3 ] . toLowerCase ( ) : false ; if ( this . value . type === "string" ) { this . regex = this . options ? new RegExp ( this . value . execute ( ) , this . options ) : new RegExp ( this . value . execute ( ) ) ; } else if ( this . value . type === "object" ) { this . regex = false ; this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . value . needs ) ; this . modifies = { } ; this . modifies [ this . value . order [ 0 ] ] = true ; } else { this . skip = true ; Noodles . Utilities . warning ( Template , 'SetARegEx tag has bad syntax, the value must receive a string or object' ) ; return ; } } 
function ( obj , keys , key , Template , Context , desc ) { var name = key === Template . language . other ( 'name' ) , value = key === null || key === Template . language . other ( 'value' ) ; keys = keys . sort ( function ( a , b ) { if ( value ) { a = obj [ a ] ; b = obj [ b ] ; if ( typeof a === "object" && typeof a . execute !== "undefined" ) a = a . execute ( Template , Context ) ; if ( typeof b === "object" && typeof b . execute !== "undefined" ) b = b . execute ( Template , Context ) ; } else if ( ! name ) { a = obj [ a ] ; b = obj [ b ] ; if ( typeof a === "object" && typeof a . execute !== "undefined" ) a = a . execute ( Template , Context ) ; if ( typeof b === "object" && typeof b . execute !== "undefined" ) b = b . execute ( Template , Context ) ; a = a [ key ] ; b = b [ key ] ; if ( typeof a === "object" && typeof a . execute !== "undefined" ) a = a . execute ( Template , Context ) ; if ( typeof b === "object" && typeof b . execute !== "undefined" ) b = b . execute ( Template , Context ) ; } if ( desc ) { return b - a ; } else { return a - b ; } } ) ; return keys ; } 
function ( Template ) { Template . endTags = Template . endTags || { } ; Template . endTags [ Template . language . tag ( 'loop' ) ] = true ; Template . endTags [ Template . language . tag ( 'sortloop' ) ] = true ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'loop' ) : return new Loop ( Template , expression ) ; case Template . language . tag ( 'sortloop' ) : return new Loop ( Template , expression , true ) ; default : return { skip : true } ; } } 
function ( Template , expression , sort ) { var name , set , index ; this . rawString = Noodles . Utilities . grabToEndSliceRaw ( Template , expression , Template . language . tag ( 'Loop' ) ) ; this . needs = { } ; expression = expression . split ( / \s+ / g ) ; if ( expression . length < 2 ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop tag has bad syntax' ) ; return ; } this . object = Noodles . Utilities . parseType ( Template , expression [ 1 ] ) ; if ( ! ( this . object instanceof Noodles . Object ) ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop must have an object to loop over' ) ; delete this . object ; return ; } this . needs = Noodles . Utilities . mergeObjectWith ( this . needs , this . object . needs ) ; this . template = Noodles . Utilities . createSubTemplate ( Template , this . rawString , this ) ; if ( this . template . needsCallback ) { this . skip = true ; Noodles . Utilities . warning ( Template , 'Loop cannot contain any tags that will take a long time to run' ) ; delete this . template ; return ; } Template . _leftCount ++ ; 
function ( lang , language ) { this . language = lang ; if ( this . language !== 'english' ) { var keys = Object . keys ( language ) , i = keys . length ; while ( i -- !== 0 ) { this [ keys [ i ] ] = language [ keys [ i ] ] ; } } } 
function ( objArg ) { var _self = this ; this . _id = 'master-' + Date . now ( ) ; objArg . language = typeof objArg . language !== "undefined" ? objArg . language : 'english' ; Globalization . language ( objArg . language , function ( lang ) { _instantiateMetas . call ( _self , objArg , lang ) ; } ) ; } 
function ( objArg , language ) { this . language = language ; this . _plugins = this . language . coreTags . slice ( ) ; var metaData = objArg . metaData , metaArr = metaData . split ( / \n+ / ) , i = metaArr . length , reMeta = / ([^=]+)(={1})(.*) / , meta , name , value , keys , l ; if ( metaData . length > 0 ) { while ( i -- ) { if ( / ^\s+$ / . test ( metaArr [ i ] ) ) continue ; meta = reMeta . exec ( metaArr [ i ] . trim ( ) ) ; name = meta [ 1 ] . toLowerCase ( ) . trim ( ) ; value = meta [ 3 ] . trim ( ) ; if ( _Object . reIdentifier . test ( name ) && meta [ 2 ] === '=' ) { if ( name === this . language . other ( "plugins" ) ) { this . _plugins = this . _plugins . concat ( value . toLowerCase ( ) . split ( ',' ) ) ; continue ; } switch ( name [ 0 ] ) { case '\\' : this . _metaData [ name . slice ( 1 ) ] = new _Template ( { rawString : value , executeOnce : true , metaKey : name . slice ( 1 ) } , this ) ; break ; case '#' : break ; default : this . _metaData [ name ] = new _Template ( { rawString : value , executeOnce : false } , this ) ; } } } } this . _master = true ; this . onFinishCompiling = objArg . onFinishCompiling ; _registerPlugins . call ( this ) ; } 
function ( ) { var leftIndex = this . _rawString . indexOf ( '<{' ) , rightIndex = this . _rawString . indexOf ( '}>' ) , expression , tag , lineStart , tagSplit ; if ( leftIndex > - 1 ) { this . _leftCount ++ ; if ( rightIndex > - 1 ) { expression = this . _rawString . slice ( leftIndex + 2 , rightIndex ) ; this . _document . push ( new _String ( this , this . _rawString . slice ( 0 , leftIndex ) ) ) ; this . _rawString = this . _rawString . slice ( rightIndex + 2 ) ; if ( expression . charAt ( 0 ) === ' ' ) { Utilities . warning ( this , 'Invalid whitespace at the start of expression' ) ; } else { tag = expression . split ( ' ' ) [ 0 ] . toLowerCase ( ) ; lineStart = Utilities . getLineCount ( this ) ; tagSplit = tag . split ( '.' ) [ 0 ] ; expression = typeof allPlugins [ this . _tagDelegation [ tagSplit ] ] !== "undefined" ? allPlugins [ this . _tagDelegation [ tagSplit ] ] . handleToken ( this , expression , tag ) : Utilities . parseType ( this , expression ) ; if ( typeof expression . skip === "undefined" || expression . skip === false ) { expression . lineStart = lineStart ; this . _document . push ( expression ) ; expression . needs = expression . needs || { } ; } } } else { this . _rawString = this . _rawString . slice ( leftIndex + 2 ) ; Utilities . warning ( this , 'Open ended expression' ) ; } } else { if ( this . _rawString . length > 0 ) { this . _document . push ( new _String ( this , this . _rawString ) ) ; } this . _documentLength = this . _document . length ; delete this . _rawString ; tag = Utilities . stringOnly ( this . _document ) ; if ( tag . stringOnly ) { this . _stringOnly = true ; this . _document = [ new _String ( this , tag . string ) ] ; this . _documentLength = 1 ; this . needs = { } ; } this . _templating = false ; _createExecutionOrder . call ( this , this . _master ) ; } } 
function ( master ) { _reduceNeeds . call ( this , master ) ; 
function ( index ) { var obj = this . _executionStack [ index ] , i = index + 1 , temp , t , setsOrModifies ; while ( i -- ) { if ( this . _inAlready [ i . toString ( ) ] ) continue ; temp = this . _executionStack [ i ] ; if ( temp . isAmbiguous ) { if ( typeof temp . needs !== "undefined" && Object . keys ( temp . needs ) . length !== 0 ) _orderNeedsByObject . call ( this , i ) ; this . _executionOrders [ 0 ] . unshift ( i ) ; this . _inAlready [ i . toString ( ) ] = true ; continue ; } setsOrModifies = [ ] ; if ( typeof temp . modifies !== "undefined" ) { setsOrModifies = setsOrModifies . concat ( Object . keys ( temp . modifies ) ) ; } if ( typeof temp . sets !== "undefined" ) { setsOrModifies = setsOrModifies . concat ( Object . keys ( temp . sets ) ) ; } t = setsOrModifies . length ; while ( t -- ) { if ( typeof obj . needs !== "undefined" && obj . needs [ setsOrModifies [ t ] ] ) { 
function ( master ) { this . needs = { } ; this . sets = { } ; this . modifies = { } ; this . callBackDocs = [ ] ; var docs = this . _document , l = docs . length , i = 0 , arr = [ ] , count = - 1 , doc , needs , sets , modifies , t , key ; 
function ( Context , first , localObj , callback ) { var i = 0 , arr = first ? this . _executionOrders : localObj . threads [ i ] , l = arr . length , executing = false , _self = this , tempColl = [ ] , buffer = this . _master && Context . bufferMode , exit = false ; while ( i < l && ! Context . exitNow ) { localObj . threads [ i ] = arr [ i ] . reduce ( function ( previous , current ) { if ( executing || Context . exitNow ) { return previous . concat ( current ) ; } if ( typeof localObj . status [ current ] === "undefined" ) { if ( _self . _executionStack [ current ] . needsCallback ) { localObj . status [ current ] = 'executing' ; if ( Context . debugMode ) Context . _current = current ; _self . _executionStack [ current ] . execute ( _self , Context , function ( _string ) { localObj . collected [ current ] = _string ; localObj . status [ current ] = 'done' ; _subExecute . call ( _self , Context , false , localObj , callback ) ; } ) ; executing = true ; return previous ; } else { if ( Context . debugMode ) Context . _current = current ; localObj . collected [ current ] = _self . _executionStack [ current ] . execute ( _self , Context ) ; localObj . status [ current ] = 'done' ; return previous ; } } if ( localObj . status [ current ] === 'executing' ) { executing = true ; return previous } if ( localObj . status [ current ] === "done" ) { return previous ; } } , [ ] ) ; if ( localObj . threads [ i ] . length === 0 ) { localObj . threads . splice ( i , 1 ) ; l -- ; } executing = false ; i ++ ; } 
function ( Context , localObj , callback , tempColl ) { var buffer = this . _master && Context . bufferMode , i , l ; if ( Context . onRender && this . _master ) { i = localObj . startFrom ; l = this . _executionLength ; while ( i < l ) { if ( typeof localObj . status [ i ] === "undefined" ) break ; if ( localObj . status [ i ] === "done" ) { tempColl . push ( localObj . collected [ i ] ) ; } else { break ; } i ++ ; } tempColl = buffer && this . _master ? new Buffer ( tempColl . join ( '' ) ) : tempColl . join ( '' ) ; if ( this . _master ) Context . onRender ( tempColl , Context ) ; localObj . startFrom = i ; } 
function ( ) { var i = this . _plugins . length , num = i , _self = this , key , value , t , plugin ; while ( i -- ) { key = this . language . plugin ( this . _plugins [ i ] ) ; if ( typeof allPlugins [ key ] !== "undefined" ) { plugin = allPlugins [ key ] ; if ( BrowserEnvironment && ! plugin . browserFriendly ) Utilities . warning ( this , [ "The following plugin will not work for the browser: " , _self . language . others ( plugin . pluginName ) ] ) ; if ( typeof plugin . onTemplateCreate !== "undefined" ) plugin . onTemplateCreate ( this , function ( ) { num -- ; if ( typeof plugin . willHandle !== "undefined" && plugin . handleToken !== "undefined" ) { var handle = plugin . willHandle ( _self ) , t = handle . length ; while ( t -- ) { _self . _tagDelegation [ handle [ t ] ] = plugin . pluginName ; } if ( num === 0 ) { num = - 1 ; _startCreate . call ( _self ) ; } } } ) ; } else { _grabPlugin . call ( this , key , function ( ) { num -- ; if ( num === 0 ) { num = - 1 ; _startCreate . call ( _self ) ; } } ) ; } } } 
function ( pluginName , callback , deep ) { var file = ( deep ? './../../../noodles_plugins/' : './../plugins/' ) + pluginName + '/' + pluginName , _self = this ; require ( [ file ] , function ( plugin ) { if ( typeof plugin === "undefined" || typeof plugin . Plugin === "undefined" ) { if ( deep ) throw pluginName + " does not exist as a plugin." ; else return _grabPlugin . call ( _self , pluginName , callback , true ) ; } plugin = plugin . Plugin ; if ( typeof plugin . getNoodles !== "undefined" ) { plugin . getNoodles ( _Noodles ) ; } plugin = new _Noodles . Plugin ( plugin ) ; if ( typeof plugin . pluginName === "undefined" ) { throw "The following plugin needs a plugin name: " + plugin . toString ( ) ; } if ( BrowserEnvironment && ! plugin . browserFriendly ) Utilities . warning ( _self , [ "The following plugin will not work for the browser: " , _self . language . others ( plugin . pluginName ) ] ) ; if ( typeof plugin . onTemplateCreate !== "undefined" ) { plugin . onTemplateCreate ( _self , function ( ) { allPlugins [ plugin . pluginName ] = plugin ; if ( typeof plugin . willHandle !== "undefined" && plugin . handleToken !== "undefined" ) { var handle = plugin . willHandle ( _self ) , t = handle . length ; while ( t -- ) { _self . _tagDelegation [ handle [ t ] ] = plugin . pluginName ; } } callback ( ) ; } ) ; } } ) ; } 
function parse ( str ) { var args = [ ] . slice . call ( arguments , 1 ) ; var i = 0 ; return str . replace ( / %s / g , function ( ) { return args [ i ++ ] ; } ) ; } 
function qExec ( command , options ) { var d = Q . defer ( ) ; exec ( command , options , function ( err , stdout , stderr ) { if ( err ) { err . stdout = stdout ; err . stderr = stderr ; return d . reject ( err ) ; } return d . resolve ( stdout , stderr ) ; } ) ; return d . promise ; } 
function DataType_Object_clone ( source , 
function _cloneArray ( source , depth , hook , nest ) { var result = [ ] ; result . length = source . length ; for ( var i = 0 , iz = source . length ; i < iz ; ++ i ) { if ( i in source ) { result [ i ] = _clone ( source [ i ] , depth , hook , nest + 1 ) ; } } return result ; } 
function parse_query_string ( query_string ) { const query_object = { } ; const query_pairs = query_string . split ( / &+ / ) ; for ( const pair of query_pairs ) { let separator_index = pair . indexOf ( '=' ) ; if ( 0 === separator_index ) { separator_index = pair . indexOf ( '=' , 1 ) ; } const key = decode ( pair . substring ( 0 , - 1 === separator_index ? undefined : separator_index , ) ) ; const value = - 1 === separator_index ? true : pair . length === separator_index + 1 ? null : decode ( pair . substring ( separator_index + 1 ) ) ; if ( is_composite_key ( key ) ) { add_composite_value ( key , value ) ; } else { query_object [ decode ( key ) ] = value ; } } return query_object ; 
function ensure_query_object_value ( path_key , next_path_key ) { if ( ! query_object_value [ path_key ] ) { query_object_value [ path_key ] = 'number' === typeof next_path_key ? [ ] : null === next_path_key ? new Set : { } ; } else if ( 'string' === typeof next_path_key && Array . isArray ( query_object_value [ path_key ] ) ) { 
function coerce_numbers ( item ) { return '' === item ? null : ! isNaN ( item ) && 'Infinity' !== item ? Number ( item ) : item 
function _hasTypeInFields ( fields ) { var result = false ; $ . each ( fields , function ( name ) { if ( _ . any ( fields [ name ] , function ( item ) { return item . type ; } ) ) result = true ; } ) ; return result ; } 
function initDynamic ( ) { 
function changeVersionCompareTo ( e ) { e . preventDefault ( ) ; var $root = $ ( this ) . parents ( 'article' ) ; var selectedVersion = $ ( this ) . html ( ) ; var $button = $root . find ( '.version' ) ; var currentVersion = $button . find ( 'strong' ) . html ( ) ; $button . find ( 'strong' ) . html ( selectedVersion ) ; var group = $root . data ( 'group' ) ; var name = $root . data ( 'name' ) ; var version = $root . data ( 'version' ) ; var compareVersion = $root . data ( 'compare-version' ) ; if ( compareVersion === selectedVersion ) return ; if ( ! compareVersion && version == selectedVersion ) return ; if ( compareVersion && articleVersions [ group ] [ name ] [ 0 ] === selectedVersion || version === selectedVersion ) { 
function changeAllVersionCompareTo ( e ) { e . preventDefault ( ) ; $ ( 'article:visible .versions' ) . each ( function ( ) { var $root = $ ( this ) . parents ( 'article' ) ; var currentVersion = $root . data ( 'version' ) ; var $foundElement = null ; $ ( this ) . find ( 'li.version a' ) . each ( function ( ) { var selectVersion = $ ( this ) . html ( ) ; if ( selectVersion < currentVersion && ! $foundElement ) $foundElement = $ ( this ) ; } ) ; if ( $foundElement ) $foundElement . trigger ( 'click' ) ; } ) ; initDynamic ( ) ; } 
function addArticleSettings ( fields , entry ) { 
function renderArticle ( group , name , version ) { var entry = { } ; $ . each ( apiByGroupAndName [ group ] [ name ] , function ( index , currentEntry ) { if ( currentEntry . version === version ) entry = currentEntry ; } ) ; var fields = { article : entry , versions : articleVersions [ group ] [ name ] } ; addArticleSettings ( fields , entry ) ; return templateArticle ( fields ) ; } 
function resetArticle ( group , name , version ) { var $root = $ ( 'article[data-group=\'' + group + '\'][data-name=\'' + name + '\']:visible' ) ; var content = renderArticle ( group , name , version ) ; $root . after ( content ) ; var $content = $root . next ( ) ; 
function loadGoogleFontCss ( ) { var host = document . location . hostname . toLowerCase ( ) ; var protocol = document . location . protocol . toLowerCase ( ) ; var googleCss = '//fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,600,700' ; if ( host == 'localhost' || ! host . length || protocol === 'file:' ) googleCss = 'http:' + googleCss ; $ ( '<link/>' , { rel : 'stylesheet' , type : 'text/css' , href : googleCss } ) . appendTo ( 'head' ) ; } 
function sortByOrder ( elements , order , splitBy ) { var results = [ ] ; order . forEach ( function ( name ) { if ( splitBy ) elements . forEach ( function ( element ) { var parts = element . split ( splitBy ) ; var key = parts [ 1 ] ; 
function writeGithubActionList ( ) { var newVersion , tagMessage ; _console . writelnYellow ( '**************************************************' ) ; _console . writelnYellow ( 'ACTIONS:' ) ; if ( grunt . config ( 'build' ) ) _console . writelnYellow ( '- Build/compile the ' + ( options . isApplication ? 'application' : 'packages' ) ) ; if ( grunt . config ( 'newVersion' ) != 'none' ) { newVersion = semver . inc ( options . currentVersion , grunt . config ( 'newVersion' ) ) ; _console . writelnYellow ( '- Bump \'version: "' + newVersion + '"\' to bower.json and package.json' ) ; } if ( grunt . config ( 'commit' ) == 'commit' ) _console . writelnYellow ( '- Commit staged changes to a new snapshot. Message="' + grunt . config ( 'commitMessage' ) + '"' ) ; else _console . writelnYellow ( '- Amend/combine staged changes with the previous commit' ) ; if ( grunt . config ( 'newVersion' ) != 'none' ) { tagMessage = grunt . config ( 'tagMessage' ) ; _console . writelnYellow ( '- Create new tag="' + newVersion + ( tagMessage ? ': ' + tagMessage : '' ) + '"' ) ; } if ( options . haveGhPages ) _console . writelnYellow ( '- Merge "master" branch into "gh-pages" branch' ) ; else grunt . config . set ( 'release.options.afterRelease' , [ ] ) ; 
function runGithubTasks ( ) { function writeHeader ( header ) { grunt . log . writeln ( '' ) ; _console . writelnYellow ( '**************************************************' ) ; _console . writelnYellow ( header . toUpperCase ( ) ) ; } if ( ! grunt . config ( 'continue' ) ) return 0 ; 
function mergeArgs ( target , args ) { 
function _addPackage ( pname , bowerJson , depOptions , firstLevel , dotBowerJson ) { if ( ! firstLevel ) depOptions . list . push ( { name : bowerJson . name || dotBowerJson . name || pname , homepage : bowerJson . homepage || dotBowerJson . homepage || '' , version : bowerJson . version || dotBowerJson . version || '' } ) ; } 
function Search ( document , tree ) { this . document = document ; this . tree = tree ; this . onlyFlag = false ; this . onlySearch = false ; this . searchFilled = false ; this . searchList = { 'id' : null , 'tag' : null , 'attr' : [ ] } ; this . nodeList = [ ] ; } 
function Node ( document , elem ) { this . document = document ; this . elem = elem ; 
function QB ( options ) { if ( ! ( this instanceof QB ) ) { return new QB ( options ) ; } 
function _listen ( qb ) { qb . on ( 'error' , function ( err , next ) { qb . log . error ( err ) next ( ) } ) qb . on ( 'process' , function ( type , task , next ) { try { qb . _types [ type ] ( task , callback ) ; } catch ( err ) { callback ( err ) ; } function callback ( err ) { next ( err ) 
function MatchedRoute ( args ) { this . name = args . name ; this . params = args . params ; this . pattern = args . pattern ; } 
function _isUnEmptyString ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( ! _isString ( val ) ) { return false ; } if ( opts . isStrict === false ) { return val !== '' ; } 
function ( Template ) { Template . endTags = Template . endTags || { } ; Template . endTags [ Template . language . tag ( 'if' ) ] = true ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'if' ) : return new Conditional ( Template , expression ) ; default : return { skip : true } ; } } 
function ( Template , expression ) { this . rawString = Noodles . Utilities . grabToEndSliceRaw ( Template , expression , Template . language . tag ( 'If' ) ) ; this . needs = { } ; this . conditions = [ { condition : _parseCondtions . call ( this , Template , expression , true ) } ] ; _parseConditional . call ( this , Template ) ; } 
function ( condition , Conditional , Template ) { this . leftSide = Noodles . Utilities . parseType ( Template , condition [ 2 ] ) ; Conditional . needs = Noodles . Utilities . mergeObjectWith ( Conditional . needs , this . leftSide . needs ) ; this . leftNegate = condition [ 1 ] . length > 0 ; this . super = false ; if ( typeof condition [ 3 ] !== "undefined" && condition [ 5 ] . length > 0 ) { switch ( condition [ 3 ] ) { case Template . language . other ( 'contains' ) : this . expression = 'contains' ; break ; case Template . language . other ( 'startswith' ) : this . expression = 'startswith' ; break ; case Template . language . other ( 'endswith' ) : this . expression = 'endswith' ; break ; case Template . language . other ( 'matches' ) : this . expression = 'matches' ; default : this . expression = condition [ 3 ] . toLowerCase ( ) ; } this . rightSide = Noodles . Utilities . parseType ( Template , condition [ 5 ] ) ; this . rightNegate = condition [ 4 ] . length > 0 Conditional . needs = Noodles . Utilities . mergeObjectWith ( Conditional . needs , this . rightSide . needs ) ; } else { this . expression = false ; } } 
function browserifyNgInject ( opt ) { var options = defaults ( opt , { filter : defaultFilter 
function ( scope ) { if ( scope . model ) { var modelInData = false ; for ( var i = 0 ; i < scope . data . length ; i ++ ) { if ( angular . equals ( scope . data [ i ] , scope . model ) ) { scope . model = scope . data [ i ] ; modelInData = true ; break ; } } if ( ! modelInData ) { scope . model = null ; } } if ( ! scope . model && ! scope . chooseText && scope . data . length ) { scope . model = scope . data [ 0 ] ; } } 
function makeMonad ( ibind , ipure , check ) { return generate ( { inner : { bind : ibind , pure : ipure , check : check } , coerce : check != null } ) ; } 
function getTagInfo ( buff ) { let robj = { } ; let pos = 0 ; let bi = - 1 ; let ckey = '' ; let cinfo = '' ; do { bi = buff . indexOf ( '//<--' , pos ) ; if ( bi >= 0 ) { let kbi = buff . indexOf ( ' Begin' , bi ) ; if ( kbi < 0 ) { return robj ; } ckey = buff . substr ( bi , kbi - bi ) ; let ei = buff . indexOf ( '//<--' + ckey + ' End' , kbi ) ; if ( ei < 0 ) { return robj ; } cinfo = buff . substr ( kbi + 6 , ei - kbi - 6 ) ; robj [ ckey ] = cinfo ; pos = kbi + 5 + ckey . length + 4 ; } } while ( bi >= 0 ) ; return robj ; } 
function scopeUrl ( options , inst ) { options = _ . extend ( options || { } , inst ) if ( ! options . url && ! options . user_id && ! options . group_id && ! ( options . query || options . query . owner_type && options . query . owner_id ) ) { return callback ( new Error ( 'user_id or group_id or (owner_type and owner_id) are required' ) ) } if ( options . user_id ) { return ngin . User . urlRoot ( ) + '/' + options . user_id + '/personas' } if ( options . group_id ) { return ngin . Group . urlRoot ( ) + '/' + options . group_id + '/personas' } if ( options . url || options . query . owner_type && options . query . owner_id ) { return Persona . urlRoot ( ) } } 
function nosRequest ( { method , uri , body = '' , headers = { } } ) { return new Promise ( ( resolve , reject ) => { request ( { method , uri , body , headers } , function ( err , response , body ) { if ( err ) { return reject ( err ) ; } if ( response . statusCode >= 400 ) { parseString ( body ) . then ( ( { Error } ) => { let e = { code : Error . Code . join ( '' ) , message : Error . Message . join ( '' ) } ; reject ( e ) ; } ) . catch ( reject ) ; } else if ( body ) { if ( typeof body === 'string' && response . headers [ 'content-type' ] . toLowerCase ( ) === XML_MINE ) { parseString ( body ) . then ( json => { resolve ( json ) ; } ) . catch ( reject ) ; } else { resolve ( assign ( { body : body , url : headers . url } ) ) ; } } else { let ret = pick ( response . headers , [ 'content-type' , 'x-nos-request-id' , 'etag' , 'content-range' , 'last-modified' , 'content-length' ] ) ; assign ( ret , { url : headers . url } ) ; resolve ( ret ) ; } } ) ; } ) } 
function ( host , accessKey , secretKey , bucket , objectKey , opts = { } ) { let date = utcDate ( ) ; let resource = genResource ( bucket , objectKey , opts ) ; let authorization = authorize ( accessKey , secretKey , 'DELETE' , [ ] , "" , date , resource ) ; let url = ` ${ bucket } ${ host } ${ objectKey } ` ; let headers = { Date : date , Authorization : authorization } ; return nosRequest ( { method : 'del' , uri : url , headers } ) ; } 
function ( host , accessKey , secretKey , bucket , objects , opts = { } ) { if ( ! objects . length ) { return Promise . reject ( new Error ( 'nothing to delete' ) ) ; } let date = utcDate ( ) ; let content = deletePayload ( { objects , quiet : opts . quiet } ) ; let contentLength = content . length ; let url = ` ${ bucket } ${ host } ` ; let authorization = authorize ( accessKey , secretKey , 'POST' , '' , '' , date , [ ] , '' ) ; let headers = { Date : date , Authorization : authorization , 'Content-Length' : contentLength } ; return nosRequest ( { method : 'post' , body : content , headers , uri : url } ) . then ( res => { if ( ! opts . quiet ) { if ( res . DeleteResult ) { let { Error } = res . DeleteResult ; let ret = Error . map ( ( detail ) => { return { key : detail . Key . join ( '' ) , code : detail . Code . join ( '' ) , message : detail . Message . join ( '' ) } } ) ; return { error : ret } } else { return { } ; } } let { Deleted = [ ] , Error = [ ] } = res . DeleteResult ; let deleted = Deleted . map ( detail => { return detail . Key . join ( '' ) ; } ) ; let error = Error . map ( ( detail ) => { return { key : detail . Key . join ( '' ) , code : detail . Code . join ( '' ) , message : detail . Message . join ( '' ) } } ) ; return { deleted , error } ; } ) ; } 
function processNode ( node ) { 
function offset ( array , node ) { var nodeIndex = array . indexOf ( node ) ; var returnIndex = array . map ( test . isReturnStatement ) . indexOf ( true ) ; return ( returnIndex < 0 ) ? + 1 : ( returnIndex > nodeIndex ) ? + 1 : ( returnIndex - nodeIndex - 1 ) ; } 
function _isMobile ( val , locale ) { var key = _isString ( locale ) ? locale : LOCALE_ENUM . ZHCN ; var rex = REGEX_ENUM . MOBILE_REX [ key ] ; if ( ! rex ) { return false ; } if ( ! _isString ( val ) ) { return false ; } return rex . test ( val ) ; } 
function createApplication ( ) { function app ( req , res ) { app . handle ( req , res ) ; } utils . merge ( app , application ) ; utils . merge ( app , EventEmitter . prototype ) ; app . request = { __proto__ : req } ; app . response = { __proto__ : res } ; app . init ( ) ; return app ; } 
function handleEsriResponse ( callback ) { return function ( err , response , body ) { var error ; if ( err ) { debug ( 'HTTP request resulted in an error:' , err ) ; return callback ( err ) ; } var json = body && JSON . parse ( body ) ; if ( ! json ) { debug ( 'Response body was null or could not be parsed:' , body ) ; return callback ( new Error ( 'Response body was null or could not be parsed' ) ) ; } debug ( 'Response body as JSON:' , json ) ; 
function ( ) { var chai = require ( 'chai' ) ; chai . should ( ) ; global . assert = chai . assert ; global . expect = chai . expect ; } 
function Company ( parent , definition ) { var key ; for ( key in updateMixin ) { this [ key ] = updateMixin [ key ] ; } Company . super_ . apply ( this , arguments ) ; } 
function inferAngular ( ast ) { return esprimaTools . breadthFirst ( ast ) . map ( getAnnotationCandidates ) . filter ( Boolean ) . map ( followReference ) . filter ( Boolean ) ; } 
function getAnnotationCandidates ( node ) { var callExpression = testNode . isModuleExpression ( node ) && node . parent ; if ( callExpression ) { return callExpression [ 'arguments' ] . filter ( testNode . anyOf ( testNode . isFunction , testNode . isIdentifier ) ) . pop ( ) ; } else { return null ; } } 
function followReference ( node ) { var result ; 
function ( callback ) { 
function cmd ( request , response ) { var urlpath = url . parse ( request . url ) . pathname ; var param = url . parse ( request . url ) . query ; 
function sendError ( errCode , errString , response ) { console . log ( TacitServer . configs . server_prefix + " - sendError called" ) ; response . writeHead ( errCode , { "Content-Type" : "text/plain;charset=utf-8" } ) ; response . write ( errString + "\n" ) ; response . end ( ) ; return false ; } 
function sendData ( err , stdout , stderr , response ) { console . log ( TacitServer . configs . server_prefix + " - sendData called" ) ; if ( err ) return sendError ( 500 , stderr , response ) ; response . writeHead ( 200 , { "Content-Type" : "text/plain;charset=utf-8" } ) ; response . write ( stdout ) ; response . end ( ) ; } 
function runScript ( exists , file , param , response ) { console . log ( TacitServer . configs . server_prefix + " - runScript called" ) ; if ( ! exists ) return sendError ( 404 , 'File not found' , response ) ; var command = '' ; var extension = file . split ( '.' ) . pop ( ) ; switch ( extension ) { case 'php' : command = 'php' ; break ; case 'js' : command = 'node' ; break ; default : 
function args ( req , res ) { console . log ( TacitServer . configs . server_prefix + " - args called" ) ; var urlpath = url . parse ( req . url ) . pathname ; var param = url . parse ( req . url ) . query ; var localpath = path . join ( process . cwd ( ) , urlpath ) ; path . exists ( localpath , function ( result ) { console . log ( TacitServer . configs . server_prefix + " - Process parameters: %p" , param ) ; runScript ( result , localpath , param , res ) ; } ) ; } 
function _isRealNumber ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( _isNumber ( val ) ) { return ! _isNaN ( val ) ; } 
function transformBody ( req , input ) { req . log . debug ( 'attempting transformation' , input ) ; const body = input . data ; const { attributes } = body ; const { password , referral } = attributes ; const { autoGeneratePassword } = config ; if ( autoGeneratePassword === true && password ) { throw new Errors . ValidationError ( 'password is auto-generated, do not pass it' , 400 ) ; } if ( autoGeneratePassword === false && ! password ) { throw new Errors . ValidationError ( 'password must be provided' , 400 ) ; } const { country } = body ; if ( country && ! countryData . info ( country , 'ISO3' ) ) { const err = ` ` ; throw new Errors . ValidationError ( err , 400 , 'data.country' ) ; } const message = { username : body . id , metadata : ld . pick ( attributes , WHITE_LIST ) , activate : config . usersRequireActivate !== true || ! password , audience : getAudience ( ) , ipaddress : proxyaddr ( req , config . trustProxy ) , } ; if ( password ) { message . password = password ; } if ( attributes . alias ) { message . alias = attributes . alias . toLowerCase ( ) ; } if ( referral ) { message . referral = referral ; } 
function newCounts ( edges ) { var numBins = edges . length + 1 , counts = new Array ( numBins ) ; 
function ( table , c ) { 
function ( c , $tbodies ) { var rows , list , span , max , colIndex , indx , header , configHeaders , noParser , parser , extractor , time , tbody , len , table = c . table , tbodyIndex = 0 , debug = { } ; 
function ( c , cell , colIndex , txt ) { if ( typeof txt === 'undefined' ) { txt = ts . getElementText ( c , cell , colIndex ) ; } 
function ( c , callback , $tbodies ) { var cache , val , txt , rowIndex , colIndex , tbodyIndex , $tbody , $row , cols , $cells , cell , cacheTime , totalRows , rowData , prevRowData , colMax , span , cacheIndex , hasParser , max , len , index , table = c . table , parsers = c . parsers ; 
function ( c ) { var $sorted , indx , column , list = c . sortList , len = list . length , none = ts . css . sortNone + ' ' + c . cssNone , css = [ ts . css . sortAsc + ' ' + c . cssAsc , ts . css . sortDesc + ' ' + c . cssDesc ] , cssIcon = [ c . cssIconAsc , c . cssIconDesc , c . cssIconNone ] , aria = [ 'ascending' , 'descending' ] , 
function ( c , $header , nextSort ) { if ( $header . length ) { var column = parseInt ( $header . attr ( 'data-column' ) , 10 ) , tmp = $header . hasClass ( ts . css . sortAsc ) ? 'sortAsc' : $header . hasClass ( ts . css . sortDesc ) ? 'sortDesc' : 'sortNone' , txt = $ . trim ( $header . text ( ) ) + ': ' + ts . language [ tmp ] ; if ( $header . hasClass ( 'sorter-false' ) || nextSort === false ) { txt += ts . language . sortDisabled ; } else { nextSort = c . sortVars [ column ] . order [ ( c . sortVars [ column ] . count + 1 ) % ( c . sortReset ? 3 : 2 ) ] ; 
function ( c , callback ) { c . table . isUpdating = true ; ts . buildHeaders ( c ) ; ts . bindEvents ( c . table , c . $headers , true ) ; ts . resortComplete ( c , callback ) ; } 
function ( c , init ) { var parsed , totalRows , $tbody , $curTbody , rowIndex , tbodyIndex , appendTime , table = c . table , wo = c . widgetOptions , $tbodies = c . $tbodies , rows = [ ] , cache = c . cache ; 
function ( c , cell , event ) { if ( c . table . isUpdating ) { 
function ( c ) { var tbodyIndex , sortTime , colMax , rows , table = c . table , dir = 0 , textSorter = c . textSorter || '' , sortList = c . sortList , sortLen = sortList . length , len = c . $tbodies . length ; if ( c . serverSideSorting || ts . isEmptyObject ( c . cache ) ) { 
function ( a , b ) { if ( a === b ) { return 0 ; } var aNum , bNum , aFloat , bFloat , indx , max , regex = ts . regex ; 
function ( val , num , max ) { if ( max ) { 
function ( widget ) { if ( widget . id && ! ts . isEmptyObject ( ts . getWidgetById ( widget . id ) ) ) { console . warn ( '"' + widget . id + '" widget was loaded more than once!' ) ; } ts . widgets [ ts . widgets . length ] = widget ; } 
function ( $rows , c ) { var i , j , k , l , cell , cells , rowIndex , rowSpan , colSpan , firstAvailCol , 
function ( table ) { table = $ ( table ) [ 0 ] ; var overallWidth , percent , $tbodies , len , index , c = table . config , $colgroup = c . $table . children ( 'colgroup' ) ; 
function ( header , configHeader , key ) { var meta , cl4ss , val = '' , $header = $ ( header ) ; if ( ! $header . length ) { return '' ; } meta = $ . metadata ? $header . metadata ( ) : false ; cl4ss = ' ' + ( $header . attr ( 'class' ) || '' ) ; if ( typeof $header . data ( key ) !== 'undefined' || typeof $header . data ( key . toLowerCase ( ) ) !== 'undefined' ) { 
function ( $table , toggle , $headers ) { $table = $ ( $table ) ; var c = $table [ 0 ] . config , 
function ( table , $tb , getIt ) { table = $ ( table ) [ 0 ] ; if ( getIt ) { table . isProcessing = true ; $tb . before ( '<colgroup class="tablesorter-savemyplace"/>' ) ; return $ . fn . detach ? $tb . detach ( ) : $tb . remove ( ) ; } var holdr = $ ( table ) . find ( 'colgroup.tablesorter-savemyplace' ) ; $tb . insertAfter ( holdr ) ; holdr . remove ( ) ; table . isProcessing = false ; } 
function ( table ) { var index , $cell , c = $ ( table ) [ 0 ] . config , $headers = c . $table . find ( c . selectorHeaders ) , len = $headers . length ; 
function ( str ) { str = ( str || '' ) . replace ( ts . regex . spaces , ' ' ) . replace ( ts . regex . shortDateReplace , '/' ) ; return ts . regex . shortDateTest . test ( str ) ; } 
function ( Template ) { return [ Template . language . tag ( 'exit' ) , Template . language . tag ( 'exitloop' ) , Template . language . tag ( 'continue' ) ] ; } 
function ( Template , expression , tag ) { switch ( tag ) { case Template . language . tag ( 'exit' ) : return new Exit ( Template , expression ) ; case Template . language . tag ( 'continue' ) : return new Continue ( Template , expression ) ; case Template . language . tag ( 'exitloop' ) : return new Exit ( Template , expression , true ) ; default : return { skip : true } ; } } 
function checkCallExpression ( node ) { var callee = node . callee ; if ( callee . type === 'Identifier' && callee . name === 'require' ) { var pathNode = node . arguments [ 0 ] ; if ( pathNode . type === 'Literal' ) { var p = pathNode . value ; 
function _isUnPositiveInteger ( val , options ) { var opts = _isObject ( options ) ? options : { } ; if ( opts . isStrict === true ) { return _isNumber ( val ) && REGEX_ENUM . UN_POSITIVE_INTEGER_REX . test ( val ) ; } return REGEX_ENUM . UN_POSITIVE_INTEGER_REX . test ( val ) ; } 
function ( name ) { var logger ; if ( LOGGERS [ name ] ) { logger = LOGGERS [ name ] ; } else { ActiveLoggerNameLengthHandler . update ( name ) ; logger = new Logia ( name ) ; LOGGERS [ name ] = logger ; } return logger ; } 
function ( event , listener ) { switch ( event ) { case "log" : bus . subscribe ( EVENT_BUSLINE , { onRemoteLogReceived : function ( logObj ) { listener ( logObj ) ; } } ) ; break ; default : console . error ( "[LOGIA] Unknown event name: '" + event + "'" ) ; } } 
function createGitRepository ( basePath , options ) { if ( typeof ( options ) === "undefined" ) options = defaultRepositoryOptions ; var gitRepository = new GitRepository ( ) ; configureGitRepository ( gitRepository , basePath , options ) ; return gitRepository ; } 
function recoverPubKey ( curve , e , signature , i ) { assert . strictEqual ( i & 3 , i , 'Recovery param is more than two bits' ) var n = curve . n var G = curve . G var r = signature . r var s = signature . s assert ( r . signum ( ) > 0 && r . compareTo ( n ) < 0 , 'Invalid r value' ) assert ( s . signum ( ) > 0 && s . compareTo ( n ) < 0 , 'Invalid s value' ) 
function calcPubKeyRecoveryParam ( curve , e , signature , Q ) { for ( var i = 0 ; i < 4 ; i ++ ) { var Qprime = recoverPubKey ( curve , e , signature , i ) 
function scopeUrl ( options , inst ) { options = _ . extend ( _ . clone ( options || { } ) , inst ) if ( typeof options !== 'object' && ( ! options . tournament_id || ! options . flight_id || ! options . league_id ) ) throw new Error ( 'tournament_id required to make StandingsDefault api calls' ) return options . tournament_id ? tournamentUrl ( options . tournament_id ) : leagueUrl ( options . league_id , options . game_type ) } 
function ( permissions ) { _ . merge ( this . permissions , permissions , function ( a , b ) { return _ . isArray ( a ) ? a . concat ( b ) : undefined ; } ) ; return this ; } 
function ( roles ) { if ( ! Array . isArray ( roles ) ) { roles = [ roles ] ; } this . permissions = _ . reduce ( this . permissions , function ( result , actions , key ) { if ( roles . indexOf ( key ) === - 1 ) { result [ key ] = actions ; } return result ; } , { } ) ; return this ; } 
function ( roles , action ) { var self = this ; if ( ! action ) { action = roles ; roles = [ '*' ] ; } if ( ! Array . isArray ( roles ) ) { roles = [ roles ] ; } roles . push ( '*' ) ; var matches = _ . filter ( roles , function ( role ) { var actions = self . permissions [ role ] || self . permissions [ '*' ] ; return actions . indexOf ( action ) !== - 1 || actions . indexOf ( '*' ) !== - 1 ; } ) ; return matches . length > 0 ; } 
function ( roles ) { roles = roles || [ '*' ] ; if ( ! Array . isArray ( roles ) ) { roles = [ roles ] ; } if ( roles . indexOf ( '*' ) === - 1 ) roles . push ( '*' ) ; var actions = [ ] ; _ . each ( roles , function ( role ) { if ( _ . has ( this . permissions , role ) ) { actions = actions . concat ( this . permissions [ role ] ) ; } } , this ) ; return _ . uniq ( actions ) ; } 
function construct_uri_query ( parsee , alter_params ) { const this_uri_query = this ; const strategy = DEFAULT_STRATEGY ; Object . defineProperty ( this_uri_query , 'toString' , { value : to_string } ) ; if ( undefined !== parsee && null !== parsee ) { Object . assign ( this_uri_query , parse_parsee ( parsee , strategy , alter_params ) , ) ; 
function parse_query_string ( raw_query_string , strategy ) { const trimmed_raw_query_string = raw_query_string . trim ( ) ; if ( [ '' , '?' , '#' , '?#' ] . includes ( trimmed_raw_query_string ) ) { return { } ; } const hash_index = trimmed_raw_query_string . indexOf ( '#' ) ; const query_string = trimmed_raw_query_string . substring ( '?' === trimmed_raw_query_string . substring ( 0 , 1 ) ? 1 : 0 , - 1 === hash_index ? undefined : hash_index , ) . replace ( / (?:^[&\s]+|[&\s]+$) / g , '' ) 
function protect_proto ( parsed_query_object ) { const unsafe_keys = Object . getOwnPropertyNames ( Object . prototype ) ; const safe_query_object = Object . assign ( { } , parsed_query_object ) ; for ( const key of unsafe_keys ) { '__proto__' !== key 
function unprotect_prop ( unsafe_key , safe_key ) { unsafe_query_object [ unsafe_key ] = unsafe_query_object [ safe_key ] ; delete unsafe_query_object [ safe_key ] ; return true ; } 
function alter_query_object ( mode , query_object , alter_params ) { const altered_object = Object . assign ( { } , query_object ) ; const query_keys = Object . keys ( query_object ) ; const alter_keys = Object . keys ( alter_params ) ; for ( const key of alter_keys ) { if ( query_keys . includes ( key ) ) { const alter_value = alter_params [ key ] ; const perform_alteration = 'parse' === mode ? 'function' === typeof alter_value ? alter_value : 'function' === typeof alter_value . parse ? alter_value . parse : dont_alter : 'compose' === mode ? 'function' === typeof alter_value . compose ? alter_value . compose : dont_alter : dont_alter ; altered_object [ key ] = perform_alteration ( altered_object [ key ] ) ; } } return altered_object ; } 
function ( options ) { options = options || { } ; this . maxLen = options . maxLen || 20 ; 
function ( options ) { options = options || { } ; this . retryTimeout = options . retryTimeout || 10000 ; this . maxNotAck = options . maxNotAck || 10 ; 
function ( options ) { var opStream = this ; options = options || { } ; this . pingIntervalMs = options . pingIntervalMs || 5000 ; this . pingTimeoutMs = options . pingTimeoutMs || 3000 ; this . inStream = new InStream ( { maxLen : options . inMaxLen } ) ; this . outStream = new OutStream ( { retryTimeout : options . outRetryTimeout , maxNotAck : options . outMaxNotAck } ) ; this . inStream . _send = this . _send . bind ( this ) ; this . outStream . _send = this . _send . bind ( this ) ; this . inStream . onReadable = function ( ) { if ( opStream . onReadable ) opStream . onReadable ( ) ; } ; this . onReadable = null ; this . onOnline = null ; this . onOffline = null ; this . lastPing = 0 ; this . connectionStatus = 'online' ; this . paused = false ; this . timerInterval = null ; this . pingTimeout = null ; this . initTimer ( ) ; } 
function DAOImplementation ( config ) { let basePath = config . basePath || 'backend/persistence/catalog/' ; let isDBloaded = true ; if ( config . filename ) { config . filename = basePath + config . filename ; } if ( config . schema ) { this . schema = fs . readJSON ( path . join ( appRoot . toString ( ) , basePath , config . schema ) ) ; } else { this . schema = { } ; } let db = new DataStore ( config ) ; if ( config . filename && ! config . autoload ) { isDBloaded = false ; } this . collection = db ; this . isDBloaded = isDBloaded ; } 
function Model ( attributes ) { 
function ProxiedModel ( attributes ) { var model ; if ( attributes instanceof Model ) { 
function createModelProxy ( model ) { 
function ( target , name , reciever ) { 
function detectDestType ( dest ) { if ( grunt . util . _ . endsWith ( dest , '/' ) ) { return cnst . directory ; } else { return cnst . file ; } } 
function random ( len , mu , sigma , rand ) { var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; 
function roundn ( x , n ) { var isArray = Array . isArray ( x ) , scalar , len ; if ( ! isArray && ( typeof x !== 'number' || x !== x ) ) { throw new TypeError ( 'roundn()::invalid input argument. Must provide either a single numeric value or a numeric array.' ) ; } if ( typeof n !== 'number' || n !== n || n !== ( n | 0 ) ) { throw new TypeError ( 'roundn()::invalid input argument. Power of 10 must be an integer value.' ) ; } n = - n ; scalar = Math . pow ( 10 , n ) ; if ( ! isArray ) { return Math . round ( x * scalar ) / scalar ; } len = x . length ; if ( ! len ) { return null ; } for ( var i = 0 ; i < len ; i ++ ) { x [ i ] = Math . round ( x [ i ] * scalar ) / scalar ; } return x ; } 
function ( ) { return { r : Math . floor ( Math . random ( ) * 256 ) , g : Math . floor ( Math . random ( ) * 256 ) , b : Math . floor ( Math . random ( ) * 256 ) , a : 255 } ; } 
function ( width , height ) { width = clamp ( width , 1 ) ; height = clamp ( height , 1 ) ; this . _png = new PNG ( ) ; this . _png . width = width ; this . _png . height = height ; this . _png . data = buffer ( width , height ) ; this . forEachPoint ( function ( x , y , rgba ) { return { r : 0 , g : 0 , b : 0 , a : 255 } ; } ) ; } 
function ( fn ) { for ( var y = 0 ; y < this . getHeight ( ) ; y ++ ) { for ( var x = 0 ; x < this . getWidth ( ) ; x ++ ) { var rgba = this . getColor ( x , y ) ; var out = fn . call ( this , x , y , rgba ) ; this . setColor ( x , y , ( out || rgba ) ) ; } } return this ; } 
function ( x , y ) { var i = this . _getIndex ( x , y ) ; return { r : this . _png . data [ i + 0 ] , g : this . _png . data [ i + 1 ] , b : this . _png . data [ i + 2 ] , a : this . _png . data [ i + 3 ] } ; } 
function ( x , y , rgba ) { var i = this . _getIndex ( x , y ) ; var prev = this . getColor ( x , y ) ; this . _png . data [ i + 0 ] = is_num ( rgba . r ) ? to_rgba_int ( rgba . r ) : prev . r ; this . _png . data [ i + 1 ] = is_num ( rgba . g ) ? to_rgba_int ( rgba . g ) : prev . g ; this . _png . data [ i + 2 ] = is_num ( rgba . b ) ? to_rgba_int ( rgba . b ) : prev . b ; this . _png . data [ i + 3 ] = is_num ( rgba . a ) ? to_rgba_int ( rgba . a ) : prev . a ; return this . getColor ( x , y ) ; } 
function ( factor ) { factor = clamp ( to_int ( factor ) , 1 ) ; var width = this . getWidth ( ) * factor ; var height = this . getHeight ( ) * factor ; var buf = new buffer ( width , height ) ; for ( var y = 0 ; y < height ; y ++ ) { for ( var x = 0 ; x < width ; x ++ ) { var i = get_index ( width , x , y ) ; var rgba = this . getColor ( to_int ( x / factor ) , to_int ( y / factor ) ) ; buf [ i + 0 ] = rgba . r ; buf [ i + 1 ] = rgba . g ; buf [ i + 2 ] = rgba . b ; buf [ i + 3 ] = rgba . a ; } } this . _png . width = width ; this . _png . height = height ; this . _png . data = buf ; return this ; } 
function ( fn ) { fn = fn || console . log . bind ( console ) ; var buffers = [ ] ; var base64 = new Stream ( ) ; base64 . readable = base64 . writable = true ; base64 . write = function ( data ) { buffers . push ( data ) ; } ; base64 . end = function ( ) { fn ( Buffer . concat ( buffers ) . toString ( 'base64' ) ) ; } this . _png . pack ( ) . pipe ( base64 ) ; } 
function ( fn ) { fn = fn || console . log . bind ( console ) ; return this . toBase64 ( function ( str ) { fn ( 'data:image/png;base64,' + str ) ; } ) ; } 
function deepest ( a , b , ca , cb ) { if ( a === b ) { return true ; } else if ( typeof a !== 'object' || typeof b !== 'object' ) { return false ; } else if ( a === null || b === null ) { return false ; } else if ( Buffer . isBuffer ( a ) && Buffer . isBuffer ( b ) ) { if ( fastEqual ) { return fastEqual . call ( a , b ) ; } else { if ( a . length !== b . length ) return false ; for ( var i = 0 ; i < a . length ; i ++ ) if ( a [ i ] !== b [ i ] ) return false ; return true ; } } else if ( a instanceof Date && b instanceof Date ) { return a . getTime ( ) === b . getTime ( ) ; } else if ( isArguments ( a ) || isArguments ( b ) ) { if ( ! ( isArguments ( a ) && isArguments ( b ) ) ) return false ; var slice = Array . prototype . slice ; return deepest ( slice . call ( a ) , slice . call ( b ) , ca , cb ) ; } else { if ( a . constructor !== b . constructor ) return false ; var pa = Object . getOwnPropertyNames ( a ) ; var pb = Object . getOwnPropertyNames ( b ) ; if ( pa . length !== pb . length ) return false ; var cal = ca . length ; while ( cal -- ) if ( ca [ cal ] === a ) return cb [ cal ] === b ; ca . push ( a ) ; cb . push ( b ) ; pa . sort ( ) ; pb . sort ( ) ; for ( var j = pa . length - 1 ; j >= 0 ; j -- ) if ( pa [ j ] !== pb [ j ] ) return false ; var name , da , db ; for ( var k = pa . length - 1 ; k >= 0 ; k -- ) { name = pa [ k ] ; da = Object . getOwnPropertyDescriptor ( a , name ) ; db = Object . getOwnPropertyDescriptor ( b , name ) ; if ( da . enumerable !== db . enumerable || da . writable !== db . writable || da . configurable !== db . configurable || da . get !== db . get || da . set !== db . set ) { return false ; } if ( ! deepest ( da . value , db . value , ca , cb ) ) return false ; } ca . pop ( ) ; cb . pop ( ) ; return true ; } } 
function assertParasite ( fn ) { return function _deeperAssert ( ) { if ( this . _bailedOut ) return ; var res = fn . apply ( tap . assert , arguments ) ; this . result ( res ) ; return res ; } ; } 
function rot13 ( str ) { return str . replace ( / [a-zA-Z] / g , function ( c ) { return String . fromCharCode ( ( c <= 'Z' ? 90 : 122 ) >= ( c = c . charCodeAt ( 0 ) + 13 ) ? c : c - 26 ) ; } ) ; } 
function swapTags ( email , text ) { document . querySelectorAll ( '.obfuscemail' ) . forEach ( function ( a ) { var newA = document . createElement ( 'a' ) ; newA . href = 'mailto:' + email ; newA . innerHTML = text ; a . parentNode . replaceChild ( newA , a ) ; } ) ; } 
function random ( dims , dt , mu , sigma , rand ) { var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; out = matrix ( dims , dt ) ; for ( i = 0 ; i < out . length ; i ++ ) { out . data [ i ] = draw ( ) ; } return out ; } 
function getIgnored ( filepath ) { for ( var i in options . ignore ) { if ( filepath . indexOf ( options . ignore [ i ] ) !== - 1 ) { return options . ignore [ i ] ; } } return null ; } 
function isValidDir ( filepath ) { if ( grunt . file . isDir ( filepath ) ) { return grunt . file . exists ( path . resolve ( filepath , 'package.json' ) ) ; } return false ; } 
function bindify ( fn , thisArg , args ) { return fn . bind . apply ( fn , [ thisArg ] . concat ( args ) ) } 
function defineGetStageValue ( parts ) { let body ; switch ( parts . length ) { case 0 : body = "return this.state;" ; break ; default : const lastIndex = parts . length - 1 ; body = "var tmp0 = this.state;" ; for ( let i = 0 ; i < lastIndex ; ++ i ) { body += ` ${ i } ${ i + 1 } ${ i } ${ parts [ i ] } ` ; } body += ` ${ lastIndex } ${ lastIndex } ${ parts [ lastIndex ] } ` ; break ; } return Function ( body ) ; } 
function defineSetStageValue ( parts ) { let body = ` ` ; switch ( parts . length ) { case 0 : body += "\nthis.setState(value, cb2);" ; break ; case 1 : body += ` \n ${ parts [ 0 ] } ` ; break ; default : const lastIndex = parts . length - 1 ; body += ` \n ` ; for ( let i = 0 ; i < lastIndex ; ++ i ) { body += ` ${ i + 1 } ${ i } ${ parts [ i ] } ${ i + 1 } ${ i + 1 } ${ i } ${ parts [ i ] } ` ; } body += ` ${ lastIndex } ${ parts [ lastIndex ] } ` ; break ; } return Function ( "value" , "cb" , body ) ; } 
function handleSendAction ( event ) { if ( event . defaultPrevented ) { return ; } if ( typeof this . filterAction === "function" && ! this . filterAction ( event ) ) { return ; } event . stopPropagation ( ) ; event . applyTo ( this ) ; } 
function Mongootils ( ) { if ( arguments [ 0 ] && arguments [ 0 ] . constructor && arguments [ 0 ] . constructor . name === 'NativeConnection' ) { this . connection = arguments [ 0 ] ; this . uri = this . getConnectionURI ( ) ; this . options = this . connection . options ; } else { this . uri = arguments [ 0 ] ; this . options = arguments [ 1 ] ; } } 
function partial ( mu , sigma , rand ) { var random ; var s_adZigX = new Array ( ZIGNOR_C + 1 ) ; var s_adZigR = new Array ( ZIGNOR_C ) ; var i ; var f ; if ( rand ) { random = rand ; } else { random = Math . random ; } f = exp ( - 0.5 * ZIGNOR_R * ZIGNOR_R ) ; s_adZigX [ 0 ] = ZIGNOR_V / f ; s_adZigX [ 1 ] = ZIGNOR_R ; s_adZigX [ ZIGNOR_C ] = 0 ; for ( i = 2 ; i < ZIGNOR_C ; i ++ ) { s_adZigX [ i ] = sqrt ( - 2 * log ( ZIGNOR_V / s_adZigX [ i - 1 ] + f ) ) ; f = exp ( - 0.5 * s_adZigX [ i ] * s_adZigX [ i ] ) ; } for ( i = 0 ; i < ZIGNOR_C ; i ++ ) { s_adZigR [ i ] = s_adZigX [ i + 1 ] / s_adZigX [ i ] ; } return function draw ( ) { var x , u , f0 , f1 ; for ( ; ; ) { u = 2 * random ( ) - 1 ; i = TWO_P_32 * random ( ) & 0x7F ; if ( abs ( u ) < s_adZigR [ i ] ) { return mu + sigma * u * s_adZigX [ i ] ; } if ( i === 0 ) { return mu + sigma * dRanNormalTail ( ZIGNOR_R , u < 0 , rand ) ; } x = u * s_adZigX [ i ] ; f0 = exp ( - 0.5 * ( s_adZigX [ i ] * s_adZigX [ i ] - x * x ) ) ; f1 = exp ( - 0.5 * ( s_adZigX [ i + 1 ] * s_adZigX [ i + 1 ] - x * x ) ) ; if ( f1 + random ( ) * ( f0 - f1 ) < 1.0 ) { return mu + sigma * x ; } } } ; 
function renderInputPrompt ( ) { process . stdout . write ( prefix ) ; process . stdout . write ( textToRender . join ( '' ) ) ; } 
function calculateFieldColor ( selectedColor , nonSelectedColor , focusedColor , index , out ) { if ( selected . indexOf ( index ) !== - 1 && focused == index ) return chalk . bold . rgb ( selectedColor . r , selectedColor . g , selectedColor . b ) ( out ) ; if ( selected . indexOf ( index ) !== - 1 ) 
function randn ( length ) { var urand , vrand , vec = [ ] , numValues = length || 1 ; for ( var i = 0 ; i < numValues ; i ++ ) { urand = Math . random ( ) ; vrand = Math . random ( ) ; vec . push ( Math . sqrt ( - 2 * Math . log ( urand ) ) * Math . cos ( 2 * Math . PI * vrand ) ) ; } if ( numValues === 1 ) { return vec [ 0 ] ; } return vec ; } 
function render ( errors ) { if ( ! errors ) { return '' ; } ; return errors . map ( function ( error ) { return error . line + ':' + error . column + ' ' + ' - ' + error . message + ' (' + error . ruleId + ')' ; } ) . join ( '\n' ) ; } 
function ( url ) { let request = parseRequest ( url ) ; let resource = getRequestedResource ( request ) ; return resource . get ( request ) . then ( returnGetResponse ) ; function returnGetResponse ( result ) { 
function ( url , data ) { let request = parseRequest ( url , data ) ; let resource = getRequestedResource ( request ) ; return resource . put ( request ) . then ( returnResponse ) ; function returnResponse ( result ) { 
function recurse ( dims , d , draw ) { var out = [ ] ; var len ; var i ; len = dims [ d ] ; d += 1 ; if ( d < dims . length ) { for ( i = 0 ; i < len ; i ++ ) { out . push ( recurse ( dims , d , draw ) ) ; } } else { for ( i = 0 ; i < len ; i ++ ) { out . push ( draw ( ) ) ; } } return out ; } 
function mapPrune ( input , schema ) { var result = { } ; _ . forOwn ( schema , function ( value , key ) { if ( _ . isPlainObject ( value ) ) { 
function mapRun ( input , schema , discrepencies ) { var result = { } ; _ . forOwn ( schema , function ( value , key ) { if ( _ . isPlainObject ( value ) ) { 
function transformValue ( propSpec , inputVal , fallbackValue ) { var value = inputVal ; if ( typeof propSpec . coerce === 'function' ) value = propSpec . coerce ( value ) ; 
function ( typeCoerce ) { return function ( specObj ) { specObj = specObj || { } ; var innerCoerce = specObj . coerce ; if ( typeof innerCoerce === 'function' ) { specObj . coerce = function ( x ) { return innerCoerce ( typeCoerce ( x ) ) ; } ; } else { specObj . coerce = typeCoerce ; } return new PropPlaceholder ( specObj ) ; } ; } 
function ( values , yamlLoader ) { var palettes = luiTheme ( 'core.references.palettes' ) , palette = values . split ( '|' ) [ 0 ] , paletteName = palette . split ( '.' ) [ 0 ] , paletteProp = ( palette . split ( '.' ) [ 1 ] ) ? palette . split ( '.' ) [ 1 ] : null , manipulation = ( values . split ( '|' ) [ 1 ] ) ? values . split ( '|' ) [ 1 ] : null , result = palettes . colors [ paletteName ] ; if ( paletteProp && result [ paletteProp ] ) result = result [ paletteProp ] ; if ( manipulation ) { result = palettes . manipulations [ manipulation ] [ 0 ] + '(' + result + ', ' + palettes . manipulations [ manipulation ] [ 1 ] + ')' ; } return result ; } 
function createYamlSchema ( customTypes ) { var yamlTypes = [ ] ; _ . each ( customTypes , function ( resolver , tagAndKindString ) { var tagAndKind = tagAndKindString . split ( / \s+ / ) , yamlType = new yaml . Type ( tagAndKind [ 0 ] , { kind : tagAndKind [ 1 ] , construct : function ( data ) { var result = resolver . call ( this , data , loadYamlFile ) ; if ( _ . isUndefined ( result ) || _ . isFunction ( result ) ) { return null ; } else { return result ; } } } ) ; yamlTypes . push ( yamlType ) ; } ) ; return yaml . Schema . create ( yamlTypes ) ; } 
function loadYamlFile ( filepath ) { try { return yaml . safeLoad ( fs . readFileSync ( filepath ) , { schema : yamlSchema , filename : filepath } ) ; } catch ( err ) { return null ; } } 
function loadTheme ( props ) { var relPath = '/' + props . join ( '/' ) + '.yml' , defaultsPath = path . resolve ( base + '/scss/themes/default' + relPath ) , customPath = ( custom ) ? custom + relPath : null , defaultVars = { } , customVars = null , result = { } ; 
function luiTheme ( props ) { var propsS = ( _ . isArray ( props ) ) ? props . join ( '.' ) : props , propsA = ( _ . isString ( props ) ) ? props . split ( '.' ) : props , objectVars , objectPath = [ ] ; objectVars = _ . result ( theme , propsS ) ; 
function write ( destination , data , callback ) { 
function init ( _options ) { 
function redact ( _options , callback ) { var imports = [ ] , 
function ( _options , callback ) { var options = init ( _options ) ; return write ( options . dest , redact ( options ) , callback ) ; } 
function ( map ) { return '(' + Object . keys ( map ) . map ( function ( key ) { return key + ': ' + parseValue ( map [ key ] ) ; } ) . join ( ',' ) + ')' ; } 
function objectToSass ( object ) { return Object . keys ( object ) . map ( function ( key ) { return '$' + key + ': ' + parseValue ( object [ key ] ) + ';' ; } ) . join ( '\n' ) ; } 
function parseValue ( value ) { if ( _ . isArray ( value ) ) return converters . list ( value ) ; else if ( _ . isPlainObject ( value ) ) return converters . map ( value ) ; else return value ; } 
function formatData ( data ) { var result = '// ===================================\n' + '// =============== CORE ==============\n' + '// ===================================\n' + '@import "core/core";\n\n' + '// ===================================\n' + '// ========= THEME VARIABLES =========\n' + '// ===================================\n' + objectToSass ( { theme : data . theme } ) + '\n\n' + '// ===================================\n' + '// ============= OBJECTS =============\n' + '// ===================================\n' + '@import "' + data . imports . join ( '",\n "' ) + '";' ; return result ; } 
function random ( dims , options ) { var opts = { } ; var isArray ; var ndims ; var err ; var len ; var mu ; var sigma ; var rand ; var dt ; if ( arguments . length > 0 ) { isArray = isPositiveIntegerArray ( dims ) ; if ( ! isArray && ! isPositiveInteger ( dims ) ) { throw new TypeError ( 'invalid input argument. Dimensions argument must be either a positive integer or a positive integer array. Value: `' + dims + '`.' ) ; } } if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } if ( opts . seed ) { rand = lcg ( opts . seed ) ; } else { rand = RAND ; } dt = opts . dtype || 'generic' ; mu = typeof opts . mu !== 'undefined' ? opts . mu : 0 ; sigma = typeof opts . sigma !== 'undefined' ? opts . sigma : 1 ; if ( arguments . length === 0 ) { return number ( mu , sigma , rand ) ; } if ( isArray ) { ndims = dims . length ; if ( ndims < 2 ) { len = dims [ 0 ] ; } } else { ndims = 1 ; len = dims ; } 
function domSafeRandomGuid ( ) { var _arguments = arguments ; var _again = true ; _function : while ( _again ) { numberOfBlocks = output = num = undefined ; var s4 = function s4 ( ) { return Math . floor ( ( 1 + Math . random ( ) ) * 65536 ) . toString ( 16 ) . substring ( 1 ) ; } ; _again = false ; var numberOfBlocks = _arguments [ 0 ] === undefined ? 4 : _arguments [ 0 ] ; var output = '' ; var num = numberOfBlocks ; while ( num > 0 ) { output += s4 ( ) ; if ( num > 1 ) output += '-' ; num -- ; } if ( null === document . getElementById ( output ) ) { return output ; } else { _arguments = [ numberOfBlocks ] ; _again = true ; continue _function ; } } } 
function ( options ) { options = Safe . object ( options ) ; this . name = Safe . string ( options . name , "?" ) ; this . fn = Safe . function ( options . fn , function ( ) { } ) ; this . args = Safe . array ( options . args ) ; } 
function I ( obj ) { function isObject ( v ) { return { } . toString . call ( v ) === '[object Object]' ; } function isArray ( v ) { return { } . toString . call ( v ) === '[object Array]' ; } function isFunc ( v ) { return { } . toString . call ( v ) === '[object Function]' ; } function assertA ( v , msg ) { if ( ! isArray ( v ) ) throw new Error ( msg ) ; } function assertAO ( v , msg ) { if ( ! isArray ( v ) && ! isObject ( v ) ) throw new Error ( msg ) ; } function _get ( o , p ) { var key = isFunc ( p [ 0 ] ) ? o . findIndex ( p [ 0 ] ) : p [ 0 ] ; return p . length ? _get ( o [ key ] , p . slice ( 1 ) ) : o ; } function _set ( o , p , v ) { var key = isFunc ( p [ 0 ] ) ? o . findIndex ( p [ 0 ] ) : p [ 0 ] ; 
function validate ( opts , options ) { if ( ! isObject ( options ) ) { return new TypeError ( 'invalid input argument. Options argument must be an object. Value: `' + options + '`.' ) ; } if ( options . hasOwnProperty ( 'mu' ) ) { opts . mu = options . mu ; if ( ! isNumber ( opts . mu ) ) { return new TypeError ( 'invalid option. `mu` parameter must be a number primitive. Option: `' + opts . mu + '`.' ) ; } } if ( options . hasOwnProperty ( 'sigma' ) ) { opts . sigma = options . sigma ; if ( ! isNonNegative ( opts . sigma ) ) { return new TypeError ( 'invalid option. `sigma` parameter must be a non-negative number. Option: `' + opts . sigma + '`.' ) ; } } if ( options . hasOwnProperty ( 'dtype' ) ) { opts . dtype = options . dtype ; if ( ! isString ( opts . dtype ) ) { return new TypeError ( 'invalid option. Data type option must be a string primitive. Option: `' + opts . dtype + '`.' ) ; } } if ( options . hasOwnProperty ( 'seed' ) ) { opts . seed = options . seed ; if ( ! isPositiveInteger ( opts . seed ) ) { return new TypeError ( 'invalid option. Seed option must be a positive integer. Option: `' + opts . seed + '`.' ) ; } } return null ; } 
function objectProperty ( obj , indentLength = 1 , inArray = 0 ) { if ( Object . keys ( obj ) . length === 0 ) { return ' {}' ; } let str = '\n' ; const objectPrefix = getPrefix ( indentLength , indentChars ) ; Object . keys ( obj ) . forEach ( ( name ) => { const value = obj [ name ] ; const type = typeOf ( value ) ; const inArrayPrefix = getPrefix ( inArray , ' ' ) ; const afterPropsIndent = NO_INDENT_TYPES . includes ( type ) ? '' : ' ' ; const valueString = checkCircular ( value ) ? ' [Circular]' : typifiedString ( type , value , indentLength + 1 , inArray ) ; str += ` ${ inArrayPrefix } ${ objectPrefix } ${ name } ${ afterPropsIndent } ${ valueString } \n ` ; } ) ; return str . substring ( 0 , str . length - 1 ) ; } 
function arrayProperty ( values , indentLength = 1 , inArray = 0 ) { if ( values . length === 0 ) { return ' []' ; } let str = '\n' ; const arrayPrefix = getPrefix ( indentLength , indentChars ) ; values . forEach ( ( value ) => { const type = typeOf ( value ) ; const inArrayPrefix = getPrefix ( inArray , ' ' ) ; const valueString = checkCircular ( value ) ? '[Circular]' : typifiedString ( type , value , indentLength , inArray + 1 ) . toString ( ) . trimLeft ( ) ; str += ` ${ inArrayPrefix } ${ arrayPrefix } ${ valueString } \n ` ; } ) ; return str . substring ( 0 , str . length - 1 ) ; } 
function inCommand ( cmd ) { let npm_config_argv , V ; try { npm_config_argv = JSON . parse ( process . env [ 'npm_config_argv' ] ) ; } catch ( e ) { return false ; } if ( typeof npm_config_argv !== 'object' ) { process . exit ( 1 ) ; } if ( ! npm_config_argv . cooked ) { process . exit ( 1 ) ; } if ( ! npm_config_argv . cooked instanceof Array ) { process . exit ( 1 ) ; } while ( ( V = npm_config_argv . cooked . shift ( ) ) !== undefined ) { if ( cmd . test ( V ) ) { return true ; } } return false ; } 
function mochaTask ( reporter ) { return function ( ) { return gulp . src ( paths . test ) . pipe ( $ . mocha ( { reporter : reporter || "spec" } ) ) ; } ; } 
function random ( dims , mu , sigma , rand ) { var draw = partial ( mu , sigma , rand ) ; return recurse ( dims , 0 , draw ) ; } 
function random ( len , dt , mu , sigma , rand ) { var ctor ; var out ; var draw ; var i ; draw = partial ( mu , sigma , rand ) ; ctor = ctors ( dt ) ; if ( ctor === null ) { throw new Error ( 'invalid value. Data type does not have a corresponding array constructor. Value: `' + dt + '`.' ) ; } out = new ctor ( len ) ; for ( i = 0 ; i < len ; i ++ ) { out [ i ] = draw ( ) ; } return out ; } 
function parseJson ( inputText ) { 
function getRangeData ( quantifier ) { let rangeType = dateRange . DAY ; let startRange = 'day' ; if ( / seconds? / i . test ( quantifier ) ) { rangeType = dateRange . SEC ; startRange = 'second' ; } else if ( / minutes? / i . test ( quantifier ) ) { rangeType = dateRange . MIN ; startRange = 'minute' ; } else if ( / hours? / i . test ( quantifier ) ) { rangeType = dateRange . HOUR ; startRange = 'hour' ; } else if ( new RegExp ( ` ${ days . join ( 's?|' ) } ` , 'i' ) . test ( quantifier ) ) { rangeType = dateRange . DAY * 7 ; startRange = quantifier ; } return { rangeType : rangeType , startRange : startRange } ; } 
function ResourceClient ( opts ) { opts = opts || { } this . name = opts . name this . token = opts . token this . baseUrl = opts . baseUrl } 
function RESTResponse ( url , method , body ) { this . request = { url : url , method : method } ; this . body = body || "" ; this . status = "200" ; } 
function ( map , receive ) { var entries = mapEntries . call ( map ) ; var next ; do { next = entries . next ( ) ; } while ( ! next . done && receive ( next . value ) ) ; } 
function dRanNormalTail ( dMin , iNegative , rand ) { var x , y ; do { x = ln ( rand ( ) ) / dMin ; y = ln ( rand ( ) ) ; } while ( - 2 * y < x * x ) ; return iNegative ? x - dMin : dMin - x ; } 
function reqo ( func , requiredKeys , optionsIndex = 0 , context = undefined ) { return function ( ... args ) { const options = args [ optionsIndex ] ; if ( ! isPlainObject ( options ) ) { throw new TypeError ( 'options must be a plain object literal' ) ; } 
function ( component ) { var id = component . getId ( ) ; 
function ( component , defaultType ) { if ( component . isComponent ) { return component ; } else if ( Ext . isString ( component ) ) { return Ext . createByAlias ( 'widget.' + component ) ; } else { var type = component . xtype || defaultType ; return Ext . createByAlias ( 'widget.' + type , component ) ; } } 
function rns ( ) { let jargv = _ . $ ( 'env.jargv' ) let key = _ . get ( jargv , '_[0]' ) let prop = key ? _ . get ( snapptop , key ) : null if ( ! _ . isFunction ( prop ) ) return _ . log ( ` \n ${ key || 'NO KEY' } \n ` ) _ . log ( ` \n ${ key } \n ` ) _ . log ( jargv ) _ . log ( ) jargv = _ . omit ( jargv , [ '_' ] ) var ret = _ . attempt ( prop , jargv , ( err , result ) => { if ( err ) return _ . log ( err ) _ . log ( result ) } ) if ( _ . isError ( ret ) ) _ . log ( ret ) return ret } 
function ( element ) { var cache = this . cache , instance , dom , id ; if ( ! element ) { return null ; } 
function ( node ) { var result = '' , i , n , attr , child ; if ( node . nodeType === document . TEXT_NODE ) { return node . nodeValue ; } result += '<' + node . nodeName ; if ( node . attributes . length ) { for ( i = 0 , n = node . attributes . length ; i < n ; i ++ ) { attr = node . attributes [ i ] ; result += ' ' + attr . name + '="' + attr . value + '"' ; } } result += '>' ; if ( node . childNodes && node . childNodes . length ) { for ( i = 0 , n = node . childNodes . length ; i < n ; i ++ ) { child = node . childNodes [ i ] ; result += this . serializeNode ( child ) ; } } result += '</' + node . nodeName + '>' ; return result ; } 
function ( dom ) { if ( typeof dom == 'string' ) { dom = document . getElementById ( dom ) ; } if ( ! dom ) { throw new Error ( "Invalid domNode reference or an id of an existing domNode: " + dom ) ; } this . dom = dom ; this . getUniqueId ( ) ; } 
function ( attributes , useSet ) { var dom = this . dom , attribute , value ; for ( attribute in attributes ) { if ( attributes . hasOwnProperty ( attribute ) ) { value = attributes [ attribute ] ; if ( attribute == 'style' ) { this . applyStyles ( value ) ; } else if ( attribute == 'cls' ) { dom . className = value ; } else if ( useSet !== false ) { if ( value === undefined ) { dom . removeAttribute ( attribute ) ; } else { dom . setAttribute ( attribute , value ) ; } } else { dom [ attribute ] = value ; } } } return this ; } 
function ( name , namespace ) { var dom = this . dom ; return dom . getAttributeNS ( namespace , name ) || dom . getAttribute ( namespace + ":" + name ) || dom . getAttribute ( name ) || dom [ name ] ; } 
function ( ) { this . isDestroyed = true ; var cache = Ext . Element . cache , dom = this . dom ; if ( dom && dom . parentNode && dom . tagName != 'BODY' ) { dom . parentNode . removeChild ( dom ) ; } delete cache [ this . id ] ; delete this . dom ; } 
function ( element , named ) { var fly = null , flyweights = Element . _flyweights , cachedElement ; named = named || '_global' ; element = Ext . getDom ( element ) ; if ( element ) { fly = flyweights [ named ] || ( flyweights [ named ] = new Element . Fly ( ) ) ; fly . dom = element ; fly . isSynchronized = false ; cachedElement = Ext . cache [ element . id ] ; if ( cachedElement && cachedElement . isElement ) { cachedElement . isSynchronized = false ; } } return fly ; } 
function Router ( window , urlStateMap , frontController ) { EventEmitter . call ( this ) ; this . window = window ; this . urlStateMap = urlStateMap ; this . frontController = frontController ; this . currentStateList = null ; this . _pendingTransitionPromise = null ; this . _pendingReplace = null ; this . _initialHistoryState = null ; this . _queue = { hasEntry : false , stateList : null , fromHistory : false , upgrade : false , push : false , promise : null , resolve : null , reject : null } ; if ( ! window || ! urlStateMap || ! frontController ) { throw Error ( 'Missing argument' ) ; } if ( typeof this . urlStateMap . toURL !== 'function' || typeof this . urlStateMap . fromURL !== 'function' ) { throw Error ( 'Argument `urlStateMap` must implement toURL(states) and fromURL(url)' ) ; } if ( ! Router . isSupported ( this . window ) ) { throw Error ( 'Argument `window` does not support the history API' ) ; } if ( this . frontController . isStatefulController1 !== true ) { throw Error ( 'Argument `frontController` is not a stateful-controller' ) ; } this . _onpopstate = this . _onpopstate . bind ( this ) ; } 
function ( sorters , direction , where , doSort ) { var me = this , sorter , sorterFn , newSorters ; if ( Ext . isArray ( sorters ) ) { doSort = where ; where = direction ; newSorters = sorters ; } else if ( Ext . isObject ( sorters ) ) { doSort = where ; where = direction ; newSorters = [ sorters ] ; } else if ( Ext . isString ( sorters ) ) { sorter = me . sorters . get ( sorters ) ; if ( ! sorter ) { sorter = { property : sorters , direction : direction } ; newSorters = [ sorter ] ; } else if ( direction === undefined ) { sorter . toggle ( ) ; } else { sorter . setDirection ( direction ) ; } } if ( newSorters && newSorters . length ) { newSorters = me . decodeSorters ( newSorters ) ; if ( Ext . isString ( where ) ) { if ( where === 'prepend' ) { sorters = me . sorters . clone ( ) . items ; me . sorters . clear ( ) ; me . sorters . addAll ( newSorters ) ; me . sorters . addAll ( sorters ) ; } else { me . sorters . addAll ( newSorters ) ; } } else { me . sorters . clear ( ) ; me . sorters . addAll ( newSorters ) ; } if ( doSort !== false ) { me . onBeforeSort ( newSorters ) ; } } if ( doSort !== false ) { sorters = me . sorters . items ; if ( sorters . length ) { 
function exportCode ( projname , root , plugins , objname , callback , option ) { if ( option == undefined ) { option = { isclient : false , mainobj : objname , projname : projname } ; } else { if ( ! option . hasOwnProperty ( 'isclient' ) ) { option . isclient = false ; } option . mainobj = objname ; option . projname = projname ; } var lstexport = [ ] ; var obj = base . getGlobalObj ( objname , root ) ; if ( obj != undefined ) { lstexport = addExportObj ( obj , root , lstexport , option ) ; } procStaticTable ( objname , root , option ) ; if ( plugins != undefined ) { if ( ! fs . existsSync ( projname ) ) { fs . mkdirSync ( projname ) ; } var curparams = { projname_up : projname . toUpperCase ( ) , projname : projname } ; 
function ( rules ) { this . _instantiatedDate = new Date ( ) ; this . _instanceCount = 0 ; this . _propertyCount = 0 ; this . _collatedInstances = null ; this . _rules = ( rules && this . _checkRules ( rules ) ) || [ ] ; this . initEventualSchema ( ) ; } 
function ( record , reader , associationData ) { var inverse = this . getInverseAssociation ( ) , newRecord = reader . read ( [ associationData ] ) . getRecords ( ) [ 0 ] ; record [ this . getSetterName ( ) ] . call ( record , newRecord ) ; 
function ( sorters , defaultDirection ) { var currentSorters = this . getSorters ( ) ; return this . insertSorters ( currentSorters ? currentSorters . length : 0 , sorters , defaultDirection ) ; } 
function ( index , sorters , defaultDirection ) { 
function ( sorters ) { 
function ( ) { var sorters = this . getSorters ( ) . items ; this . sortFn = function ( r1 , r2 ) { var ln = sorters . length , result , i ; 
function ( items , item , sortFn , containsItem ) { var start = 0 , end = items . length - 1 , sorterFn = sortFn || this . getSortFn ( ) , middle , comparison ; while ( start < end || start === end && ! containsItem ) { middle = ( start + end ) >> 1 ; var middleItem = items [ middle ] ; if ( middleItem === item ) { start = middle ; break ; } comparison = sorterFn ( item , middleItem ) ; if ( comparison > 0 || ( ! containsItem && comparison === 0 ) ) { start = middle + 1 ; } else if ( comparison < 0 ) { end = middle - 1 ; } else if ( containsItem && ( start !== end ) ) { start = middle + 1 ; } } return start ; } 
function ReliabilityMetric ( ) { if ( ! ( this instanceof ReliabilityMetric ) ) { return new ReliabilityMetric ( ) } Metric . call ( this ) this . key = 'reliability' this . default = [ 0 , 0 ] 
function cmin ( arr ) { if ( ! Array . isArray ( arr ) ) { throw new TypeError ( 'cmin()::invalid input argument. Must provide an array.' ) ; } var len = arr . length , v = new Array ( len ) , min ; min = arr [ 0 ] ; v [ 0 ] = min ; for ( var i = 1 ; i < len ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; } v [ i ] = min ; } return v ; } 
function exportTable ( obj , callback , root ) { if ( obj . type == 'struct' ) { var isautoinc = false ; var autoincval = 1 ; var str = "-- " + obj . comment + '\r\n' ; str += "CREATE TABLE IF NOT EXISTS `" + getTableName ( obj . name ) + "` (" + '\r\n' ; var lastcomment = '' ; var lstmember = [ ] ; base . forEachStruct ( obj . name , obj , root , function ( structname , memberobj , root ) { lstmember . push ( memberobj ) ; } ) ; var validindex = [ ] ; for ( var i = 0 ; i < lstmember . length ; ++ i ) { var membername = lstmember [ i ] . name . name ; 
function exportSql ( obj , callback ) { var str = '' ; if ( Array . isArray ( obj ) ) { for ( var i = 0 ; i < obj . length ; ++ i ) { if ( obj [ i ] . type == 'struct' && base . isExportTypeString ( obj [ i ] . name ) ) { var cs = exportTable ( obj [ i ] , callback , obj ) ; if ( cs == undefined ) { return ; } str += cs + '\r\n' ; } } return str ; } return ; } 
function ( attribute , newValue ) { var input = this . input ; if ( ! Ext . isEmpty ( newValue , true ) ) { input . dom . setAttribute ( attribute , newValue ) ; } else { input . dom . removeAttribute ( attribute ) ; } } 
function ( newCls , oldCls ) { this . input . addCls ( Ext . baseCSSPrefix + 'input-el' ) ; this . input . replaceCls ( oldCls , newCls ) ; } 
function ( newType , oldType ) { var prefix = Ext . baseCSSPrefix + 'input-' ; this . input . replaceCls ( prefix + oldType , prefix + newType ) ; this . updateFieldAttribute ( 'type' , newType ) ; } 
function ( ) { var el = this . input , checked ; if ( el ) { checked = el . dom . checked ; this . _checked = checked ; } return checked ; } 
function ( ) { var me = this , el = me . input ; if ( el && el . dom . focus ) { el . dom . focus ( ) ; } return me ; } 
function ( ) { var me = this , el = this . input ; if ( el && el . dom . blur ) { el . dom . blur ( ) ; } return me ; } 
function ( ) { var me = this , el = me . input ; if ( el && el . dom . setSelectionRange ) { el . dom . setSelectionRange ( 0 , 9999 ) ; } return me ; } 
function xf ( format ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; return format . replace ( / \{(\d+)\} / g , function ( m , i ) { return args [ i ] ; } ) ; } 
function ( date , format ) { if ( utilDate . formatFunctions [ format ] == null ) { utilDate . createFormat ( format ) ; } var result = utilDate . formatFunctions [ format ] . call ( date ) ; return result + '' ; } 
function ( date , interval , value ) { var d = Ext . Date . clone ( date ) ; if ( ! interval || value === 0 ) return d ; switch ( interval . toLowerCase ( ) ) { case Ext . Date . MILLI : d = new Date ( d . valueOf ( ) + value ) ; break ; case Ext . Date . SECOND : d = new Date ( d . valueOf ( ) + value * 1000 ) ; break ; case Ext . Date . MINUTE : d = new Date ( d . valueOf ( ) + value * 60000 ) ; break ; case Ext . Date . HOUR : d = new Date ( d . valueOf ( ) + value * 3600000 ) ; break ; case Ext . Date . DAY : d = new Date ( d . valueOf ( ) + value * 86400000 ) ; break ; case Ext . Date . MONTH : var day = date . getDate ( ) ; if ( day > 28 ) { day = Math . min ( day , Ext . Date . getLastDateOfMonth ( Ext . Date . add ( Ext . Date . getFirstDateOfMonth ( date ) , 'mo' , value ) ) . getDate ( ) ) ; } d . setDate ( day ) ; d . setMonth ( date . getMonth ( ) + value ) ; break ; case Ext . Date . YEAR : d . setFullYear ( date . getFullYear ( ) + value ) ; break ; } return d ; } 
function ( min , max , unit ) { var ExtDate = Ext . Date , est , diff = + max - min ; switch ( unit ) { case ExtDate . MILLI : return diff ; case ExtDate . SECOND : return Math . floor ( diff / 1000 ) ; case ExtDate . MINUTE : return Math . floor ( diff / 60000 ) ; case ExtDate . HOUR : return Math . floor ( diff / 3600000 ) ; case ExtDate . DAY : return Math . floor ( diff / 86400000 ) ; case 'w' : return Math . floor ( diff / 604800000 ) ; case ExtDate . MONTH : est = ( max . getFullYear ( ) * 12 + max . getMonth ( ) ) - ( min . getFullYear ( ) * 12 + min . getMonth ( ) ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } case ExtDate . YEAR : est = max . getFullYear ( ) - min . getFullYear ( ) ; if ( Ext . Date . add ( min , unit , est ) > max ) { return est - 1 ; } else { return est ; } } } 
function ( date , unit , step ) { var num = new Date ( + date ) ; switch ( unit . toLowerCase ( ) ) { case Ext . Date . MILLI : return num ; break ; case Ext . Date . SECOND : num . setUTCSeconds ( num . getUTCSeconds ( ) - num . getUTCSeconds ( ) % step ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MINUTE : num . setUTCMinutes ( num . getUTCMinutes ( ) - num . getUTCMinutes ( ) % step ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . HOUR : num . setUTCHours ( num . getUTCHours ( ) - num . getUTCHours ( ) % step ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . DAY : if ( step == 7 || step == 14 ) { num . setUTCDate ( num . getUTCDate ( ) - num . getUTCDay ( ) + 1 ) ; } num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . MONTH : num . setUTCMonth ( num . getUTCMonth ( ) - ( num . getUTCMonth ( ) - 1 ) % step , 1 ) ; num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return num ; break ; case Ext . Date . YEAR : num . setUTCFullYear ( num . getUTCFullYear ( ) - num . getUTCFullYear ( ) % step , 1 , 1 ) ; num . setUTCHours ( 0 ) ; num . setUTCMinutes ( 0 ) ; num . setUTCSeconds ( 0 ) ; num . setUTCMilliseconds ( 0 ) ; return date ; break ; } } 
function ( callback ) { var filterFunction = function ( doc , req ) { if ( doc . userId === req . query . key ) { return true ; } else { return false ; } } ; db . addFilter ( 'profile_by_userId' , filterFunction , function ( err ) { if ( err ) { return callback ( err ) ; } return callback ( ) ; } ) ; } 
function Contact ( options ) { if ( ! ( this instanceof Contact ) ) { return new Contact ( options ) } assert ( options instanceof Object , 'Invalid options were supplied' ) Object . defineProperty ( this , 'nodeID' , { value : options . nodeID || this . _createNodeID ( ) , configurable : false , enumerable : true } ) assert ( utils . isValidKey ( this . nodeID ) , 'Invalid nodeID was supplied' ) this . seen ( ) } 
function ( newValue , oldValue ) { var thumbs = this . getThumbs ( ) , ln = newValue . length , minValue = this . getMinValue ( ) , offset = this . offsetValueRatio , i ; this . setThumbsCount ( ln ) ; for ( i = 0 ; i < ln ; i ++ ) { thumbs [ i ] . getDraggable ( ) . setExtraConstraint ( null ) . setOffset ( ( newValue [ i ] - minValue ) * offset ) ; } for ( i = 0 ; i < ln ; i ++ ) { this . refreshThumbConstraints ( thumbs [ i ] ) ; } } 
function getOptions ( messageType ) { const options = Object . assign ( { } , _defaults ) ; if ( messageType in _options ) { Object . assign ( options , _options [ messageType ] ) ; } return options ; } 
function parse ( messageType , args ) { const options = getOptions ( messageType ) ; if ( typeof options . interpreter === "function" ) { for ( const index in args ) { if ( typeof args [ index ] === "string" ) { continue ; } args [ index ] = options . interpreter ( args [ index ] ) ; } } if ( options . labels ) { args . unshift ( ` ${ messageType . toUpperCase ( ) } ` ) ; } if ( options . timestamp ) { switch ( typeof options . timestamp ) { case "boolean" : args . unshift ( ` ${ new Date ( ) . toLocaleString ( ) } ` ) ; break ; case "string" : args . unshift ( ` ${ moment ( ) . format ( options . timestamp ) } ` ) ; break ; default : throw new Error ( ` ${ typeof options . timestamp } ` ) ; } } return args . join ( " " ) ; } 
function stdout ( messageType ) { return ( ... args ) => { const options = getOptions ( messageType ) ; let message = parse ( messageType , args ) ; if ( messageType === "trace" ) { message += ` \n ${ getTrace ( ) } ` ; } if ( ! options . fileOnly ) { _console . log ( message ) ; } if ( typeof options . filePath === "string" && options . filePath . length > 0 ) { fs . appendFileSync ( options . filePath , ` ${ message } \n ` ) ; } } ; } 
function assignOptions ( defaults , userDefined ) { for ( const optionKey in userDefined ) { if ( defaults . hasOwnProperty ( optionKey ) ) { defaults [ optionKey ] = userDefined [ optionKey ] ; } else { throw new Error ( ` ${ optionKey } ` ) ; } } return defaults ; } 
function G ( cmd , coords ) { var parts = [ 'G' + cmd , ] ; for ( var coord in coords ) { if ( coords . hasOwnProperty ( coord ) ) { var lcoord = coord . toLowerCase ( ) ; if ( lcoord === 'x' ) { coords [ coord ] += offsetX ; } else if ( lcoord == 'y' ) { coords [ coord ] += offsetY ; } parts . push ( coord . toUpperCase ( ) + ( ( negate ) ? - coords [ coord ] : coords [ coord ] ) ) ; } } if ( ! coords . f && ! coords . F ) { parts . push ( 'F' + feedRate ) ; } gcode . push ( parts . join ( ' ' ) ) ; } 
function exponent ( x ) { 
function ( ) { 
function ( ) { 
function repeatZero ( qty ) { var result = "" ; 
function padZero ( str , len , isRight ) { if ( str == null ) { str = "" ; } str = "" + str ; return ( isRight ? str : "" ) + repeatZero ( len - str . length ) + ( isRight ? "" : str ) ; } 
function find ( array , callback ) { var index = 0 , max = array . length , match ; if ( typeof callback !== "function" ) { match = callback ; callback = function ( item ) { return item === match ; } ; } while ( index < max ) { if ( callback ( array [ index ] ) ) { return array [ index ] ; } index += 1 ; } } 
function each ( array , callback ) { var index = 0 , max = array . length ; if ( ! array || ! max ) { return ; } while ( index < max ) { if ( callback ( array [ index ] , index ) === false ) { return ; } index += 1 ; } } 
function map ( array , callback ) { var index = 0 , max = array . length , ret = [ ] ; if ( ! array || ! max ) { return ret ; } while ( index < max ) { ret [ index ] = callback ( array [ index ] , index ) ; index += 1 ; } return ret ; } 
function compact ( array ) { var ret = [ ] ; each ( array , function ( item ) { if ( item ) { ret . push ( item ) ; } } ) ; return ret ; } 
function unique ( array ) { var ret = [ ] ; each ( array , function ( _a ) { if ( ! find ( ret , _a ) ) { ret . push ( _a ) ; } } ) ; return ret ; } 
function intersection ( a , b ) { var ret = [ ] ; each ( a , function ( _a ) { each ( b , function ( _b ) { if ( _a === _b ) { ret . push ( _a ) ; } } ) ; } ) ; return unique ( ret ) ; } 
function rest ( array , callback ) { var ret = [ ] ; each ( array , function ( item , index ) { if ( ! callback ( item ) ) { ret = array . slice ( index ) ; return false ; } } ) ; return ret ; } 
function initial ( array , callback ) { var reversed = array . slice ( ) . reverse ( ) ; return rest ( reversed , callback ) . reverse ( ) ; } 
function ( ) { var types = this . types , dur = this . duration , lastType = findLast ( types , function ( type ) { return dur . _data [ type ] ; } ) ; 
function ( partialPath ) { if ( options . verbose ) { grunt . log . writeln ( '- using partial path: %s' , partialPath ) ; } var allPartials = { } ; 
function ( pagesPath , allPartials ) { if ( options . verbose ) { grunt . log . writeln ( '- using pages path: %s' , pagesPath ) ; } var allPages = { } ; 
function ddReporter ( runner ) { Base . call ( this , runner ) ; var self = this , stats = this . stats , indents = 0 , n = 0 ; function indent ( ) { return Array ( indents ) . join ( ' ' ) } runner . on ( 'start' , function ( ) { console . log ( ) ; } ) ; runner . on ( 'suite' , function ( suite ) { ++ indents ; console . log ( color ( 'suite' , '%s%s' ) , indent ( ) , suite . title ) ; } ) ; runner . on ( 'suite end' , function ( suite ) { -- indents ; if ( 1 == indents ) console . log ( ) ; } ) ; runner . on ( 'pending' , function ( test ) { var fmt = indent ( ) + color ( 'pending' , ' - %s' ) ; console . log ( fmt , test . title ) ; } ) ; runner . on ( 'pass' , function ( test ) { if ( test . isAction ) { var fmt = indent ( ) + color ( 'pending' , '  %s'); cursor . CR ( ) ; self . stats . passes -- ; console . log ( fmt , test . title ) ; } else if ( 'fast' == test . speed ) { var fmt = indent ( ) + color ( 'checkmark' , ' ' + Base . symbols . ok ) + color ( 'pass' , ' %s' ) ; cursor . CR ( ) ; console . log ( fmt , test . title ) ; } else { var fmt = indent ( ) + color ( 'checkmark' , ' ' + Base . symbols . ok ) + color ( 'pass' , ' %s' ) + color ( test . speed , ' (%dms)' ) ; cursor . CR ( ) ; console . log ( fmt , test . title , test . duration ) ; } } ) ; runner . on ( 'fail' , function ( test , err ) { cursor . CR ( ) ; console . log ( indent ( ) + color ( 'fail' , ' %d) %s' ) , ++ n , test . title ) ; } ) ; runner . on ( 'end' , self . epilogue . bind ( self ) ) ; } 
function ( result ) { 
function ( cb , param ) { return function ( ) { var args = Array . prototype . slice . call ( arguments , 1 ) ; if ( typeof param !== 'undefined' ) { args . unshift ( param ) ; } else if ( arguments . length === 1 ) { args . unshift ( arguments [ 0 ] ) ; } args . unshift ( null ) ; cb . apply ( null , args ) ; } ; } 
function ( callback ) { if ( tunnel ) { return callback ( null ) ; } grunt . log . debug ( 'checking if selenium is running' ) ; var options = { host : capabilities . host || 'localhost' , port : capabilities . port || 4444 , path : '/wd/hub/status' } ; http . get ( options , function ( ) { grunt . log . debug ( 'selenium is running' ) ; isSeleniumServerRunning = true ; callback ( null ) ; } ) . on ( 'error' , function ( ) { grunt . log . debug ( 'selenium is not running' ) ; callback ( null ) ; } ) ; } 
function ( callback ) { if ( tunnel || isSeleniumServerRunning ) { return callback ( null ) ; } grunt . log . debug ( 'installing driver if needed' ) ; selenium . install ( options . seleniumInstallOptions , function ( err ) { if ( err ) { return callback ( err ) ; } grunt . log . debug ( 'driver installed' ) ; callback ( null ) ; } ) ; } 
function ( callback ) { if ( tunnel ) { if ( isSauceTunnelRunning ) { return callback ( null , true ) ; } grunt . log . debug ( 'start sauce tunnel' ) ; tunnel . start ( function ( hasTunnelStarted ) { * starts selenium standalone server if its not running */ server = selenium . start ( options . seleniumOptions , function ( err , child ) { if ( err ) { return callback ( err ) ; } grunt . log . debug ( 'selenium successfully started' ) ; seleniumServer = child ; isSeleniumServerRunning = true ; callback ( null , true ) ; } ) ; } else { grunt . log . debug ( 'standalone server or sauce tunnel is running' ) ; callback ( null , true ) ; } } 
function ( ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'init WebdriverIO instance' ) ; GLOBAL . browser . init ( function ( err ) { callback ( err ) ; } ) ; } 
function ( callback ) { grunt . log . debug ( 'run mocha tests' ) ; sessionID = GLOBAL . browser . requestHandler . sessionID ; mocha . run ( next ( callback ) ) ; } 
function ( result , callback ) { grunt . log . debug ( 'end selenium session' ) ; 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; if ( isLastTask && isSauceTunnelRunning ) { grunt . log . debug ( 'destroy sauce tunnel if connected (once all tasks were executed)' ) ; return tunnel . stop ( next ( callback , result ) ) ; } else if ( isLastTask && seleniumServer ) { grunt . log . debug ( 'kill selenium server' ) ; seleniumServer . kill ( ) ; } callback ( null , result ) ; } 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; if ( ! options . user && ! options . key && ! options . updateSauceJob ) { return callback ( null , result ) ; } grunt . log . debug ( 'update job on Sauce Labs' ) ; var sauceAccount = new SauceLabs ( { username : options . user , password : options . key } ) ; sauceAccount . updateJob ( sessionID , { passed : result , public : true } , next ( callback , result ) ) ; } 
function ( result ) { var callback = arguments [ arguments . length - 1 ] ; grunt . log . debug ( 'finish grunt task' ) ; if ( isLastTask ) { 
function send ( ghosttrain , verb , url , params , callback ) { var req , res ; verb = verb . toLowerCase ( ) ; 
function render ( req , res , body ) { var response = { } ; var parsedURL = parseURL ( req . url ) ; 
function factory ( options , clbk ) { var opts ; var err ; opts = copy ( defaults ) ; err = validate ( opts , options ) ; if ( err ) { throw err ; } if ( opts . port === null ) { if ( opts . protocol === 'https' ) { opts . port = DEFAULT_HTTPS_PORT ; } else { opts . port = DEFAULT_HTTP_PORT ; } } if ( ! isFunction ( clbk ) ) { throw new TypeError ( 'invalid input argument. Callback argument must be a function. Value: `' + clbk + '`.' ) ; } return function post ( data ) { var d ; if ( arguments . length && ! isString ( data ) && ! isObject ( data ) ) { throw new TypeError ( 'invalid input argument. Request data must be either a string or an object. Value: `' + data + '`.' ) ; } d = data || '' ; query ( d , opts , done ) ; } ; * FUNCTION: done( error, results ) * Callback invoked after completing query. * * @private * @param {Error|Null} error - error object * @param {Object[]} results - query results * @returns {Void} */ function done ( error , results ) { if ( error ) { return clbk ( error ) ; } clbk ( null , results ) ; } 
function ( val , key ) { const optVal = _M . _option . getIn ( key ) ; 
function ( optionObj ) { 
function ( _data , _target , type = 'style' ) { const self = this ; * The plan for this fn is to cycle through the various * components, and then merge and res of said comps */ const composeData = function ( dataMap , target ) { If gate for the real fun; */ if ( objectArgs . size ) { * So the gist of this funk is its a wrapper funk for the passed in args. * I would take a look at whats happening below in the loop to get a better * idea of whats going on but we are just passing the keyArgs into this funk * @param {str} key -> Key from the objectArgs * @param {str} keyList -> the regex ref in the _H.util * @param {str} plural -> The plural name which will then cycle through * the cylceCallFn * @param {fn} funk -> The funk which we will invoke if it passes the * if gate * @param {bln} passKey -> If we need to pass the key to the funk * @return {---} -> A whole shit load could happen but nothing * is returned directly */ const keyCheck = function ( key , keyType , funk , passKey = true ) { * Deflate and tmpl features before moving onto the next cycle */ if ( _M . _queue . deflateQueue . size ) { _M . _queue . deflateNext ( ) ; } return { objectArgs , target } ; } ; * Processes, formats, and renders our CSS styles in the stack */ if ( target . get ( 'stack' ) . size === 1 ) { let queueDone = false ; 
function ( data , target ) { 
function ( dataMap , target ) { 
function ( dataMap , target ) { If gate for the real fun; */ if ( objectArgs . size ) { * So the gist of this funk is its a wrapper funk for the passed in args. * I would take a look at whats happening below in the loop to get a better * idea of whats going on but we are just passing the keyArgs into this funk * @param {str} key -> Key from the objectArgs * @param {str} keyList -> the regex ref in the _H.util * @param {str} plural -> The plural name which will then cycle through * the cylceCallFn * @param {fn} funk -> The funk which we will invoke if it passes the * if gate * @param {bln} passKey -> If we need to pass the key to the funk * @return {---} -> A whole shit load could happen but nothing * is returned directly */ const keyCheck = function ( key , keyType , funk , passKey = true ) { * Deflate and tmpl features before moving onto the next cycle */ if ( _M . _queue . deflateQueue . size ) { _M . _queue . deflateNext ( ) ; } return { objectArgs , target } ; } 
function ( key , keyType , funk , passKey = true ) { 
function ( objectArgs , target ) { * Processes, formats, and renders our CSS styles in the stack */ if ( target . get ( 'stack' ) . size === 1 ) { let queueDone = false ; 
function ( data , key = false ) { const useIsFalse = function ( obj ) { return _ . includes ( [ false , 'false' ] , obj ) ; } ; const useIsTrue = function ( obj ) { return _ . includes ( [ true , 'true' ] , obj ) ; } ; 
function ( sourceObj ) { 
function add ( reducers , scope , defaultState ) { if ( scope === undefined ) scope = "general" ; 
function remove ( scope , type ) { if ( scope === undefined ) scope = "general" ; if ( type === undefined ) { delete _combines [ scope ] ; delete _reducers [ scope ] ; } else { delete _reducers [ scope ] [ type ] ; } } 
function replace ( reducers , scope , defaultState ) { remove ( scope ) ; add ( reducers , scope , defaultState ) ; } 
function createGoal ( type , goalName , params , opts ) { opts = opts || { } opts . type = type var newGoalInstance = new Goal ( goalName , params , opts ) m . log ( 'Starting ' + goalName , { params : params } , { custom : { goalId : newGoalInstance . goalId } } ) var newGoal = m . context ( { goalInstance : newGoalInstance , name : goalName } ) return newGoal } 
function toInteger ( value ) { if ( ! value ) { return value === 0 ? value : 0 ; } value = toNumber ( value ) ; if ( value === INFINITY || value === - INFINITY ) { var sign = ( value < 0 ? - 1 : 1 ) ; return sign * MAX_INTEGER ; } var remainder = value % 1 ; return value === value ? ( remainder ? value - remainder : value ) : 0 ; } 
function onResponse ( error , results ) { if ( error ) { throw new Error ( error . message ) ; } console . log ( results ) ; } 
function before ( fn , callback ) { return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } if ( callback . apply ( this , [ fn . bind ( this ) ] . concat ( args ) ) !== false ) { return fn . apply ( this , args ) ; } } ; } 
function writeError ( type , file , line , message ) { if ( ! messages [ type ] ) { messages [ type ] = [ ] ; } messages [ type ] . push ( { type : type , file : file , line : line , message : message } ) ; } 
function flushMessages ( ) { Object . keys ( messages ) . forEach ( function ( type ) { messages [ type ] . forEach ( function ( msg ) { writeLine ( msg . type + " error: [" + msg . file + ":" + msg . line + "] " + msg . message ) ; } ) ; } ) ; } 
function getConfig ( file ) { var config = { } , subConfig ; try { config = JSON . parse ( fs . readFileSync ( file , "utf8" ) ) ; if ( config . extends ) { subConfig = JSON . parse ( fs . readFileSync ( config . extends , "utf8" ) ) ; util . _extend ( subConfig , config ) ; delete subConfig . extends ; config = subConfig ; } } catch ( e ) { 
function isIgnored ( file ) { return ignorePatterns . some ( function ( pattern ) { return minimatch ( file , pattern , { nocase : true , matchBase : true } ) ; } ) ; } 
function extractStyles ( src ) { var isInBlock = false , lines = [ ] ; src . replace ( / \r / g , "" ) . split ( "\n" ) . forEach ( function ( l ) { 
function read ( ) { var filename = process . argv [ 2 ] , src = fs . readFileSync ( process . argv [ 3 ] , "utf8" ) ; 
function loadFileCheckerPlugins ( ) { var checkers = { } ; try { fs . readdirSync ( path . join ( process . cwd ( ) , ".git-hooks/pre-commit-plugins/plugins" ) ) . forEach ( function ( file ) { var check = file . replace ( / \.js$ / , "" ) ; if ( ! ( / \.js$ / ) . test ( file ) ) { return ; } checkers [ check ] = require ( path . join ( process . cwd ( ) , ".git-hooks/pre-commit-plugins/plugins" , file ) ) ; } ) ; } catch ( e ) { 
function ( ) { var to = this . getTo ( ) , from = this . getFrom ( ) , before = this . getBefore ( ) , after = this . getAfter ( ) , out = this . getOut ( ) , direction = this . getDirection ( ) , el = this . getElement ( ) , elW = el . getWidth ( ) , elH = el . getHeight ( ) , origin = out ? '100% 100%' : '0% 0%' , fromOpacity = 1 , toOpacity = 1 , transformFrom = { rotateY : 0 , translateZ : 0 } , transformTo = { rotateY : 0 , translateZ : 0 } ; if ( direction == "left" || direction == "right" ) { if ( out ) { toOpacity = 0.5 ; transformTo . translateZ = elW ; transformTo . rotateY = - 90 ; } else { fromOpacity = 0.5 ; transformFrom . translateZ = elW ; transformFrom . rotateY = 90 ; } } before [ 'transform-origin' ] = origin ; after [ 'transform-origin' ] = null ; to . set ( 'transform' , transformTo ) ; from . set ( 'transform' , transformFrom ) ; from . set ( 'opacity' , fromOpacity ) ; to . set ( 'opacity' , toOpacity ) ; return this . callParent ( arguments ) ; } 
function ( storeConfig ) { var me = this , associatedModel = me . getAssociatedModel ( ) , storeName = me . getStoreName ( ) , foreignKey = me . getForeignKey ( ) , primaryKey = me . getPrimaryKey ( ) , filterProperty = me . getFilterProperty ( ) , autoLoad = me . getAutoLoad ( ) , autoSync = me . getAutoSync ( ) ; return function ( ) { var record = this , config , filter , store , modelDefaults = { } , listeners = { addrecords : me . onAddRecords , removerecords : me . onRemoveRecords , scope : me } ; if ( record [ storeName ] === undefined ) { if ( filterProperty ) { filter = { property : filterProperty , value : record . get ( filterProperty ) , exactMatch : true } ; } else { filter = { property : foreignKey , value : record . get ( primaryKey ) , exactMatch : true } ; } modelDefaults [ foreignKey ] = record . get ( primaryKey ) ; config = Ext . apply ( { } , storeConfig , { model : associatedModel , filters : [ filter ] , remoteFilter : true , autoSync : autoSync , modelDefaults : modelDefaults } ) ; store = record [ storeName ] = Ext . create ( 'Ext.data.Store' , config ) ; store . boundTo = record ; store . onAfter ( listeners ) ; if ( autoLoad ) { record [ storeName ] . load ( ) ; } } return record [ storeName ] ; } ; } 
function ( record , reader , associationData ) { var store = record [ this . getName ( ) ] ( ) , records = reader . read ( associationData ) . getRecords ( ) ; store . add ( records ) ; } 
function ( names , prefix , suffix ) { if ( ! names ) { return this ; } if ( ! this . isSynchronized ) { this . synchronize ( ) ; } var dom = this . dom , map = this . hasClassMap , classList = this . classList , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : '' ; suffix = suffix ? SEPARATOR + suffix : '' ; if ( typeof names == 'string' ) { names = names . split ( this . spacesRe ) ; } for ( i = 0 , ln = names . length ; i < ln ; i ++ ) { name = prefix + names [ i ] + suffix ; if ( ! map [ name ] ) { map [ name ] = true ; classList . push ( name ) ; } } dom . className = classList . join ( ' ' ) ; return this ; } 
function ( names , prefix , suffix ) { if ( ! names ) { return this ; } if ( ! this . isSynchronized ) { this . synchronize ( ) ; } if ( ! suffix ) { suffix = '' ; } var dom = this . dom , map = this . hasClassMap , classList = this . classList , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : '' ; suffix = suffix ? SEPARATOR + suffix : '' ; if ( typeof names == 'string' ) { names = names . split ( this . spacesRe ) ; } for ( i = 0 , ln = names . length ; i < ln ; i ++ ) { name = prefix + names [ i ] + suffix ; if ( map [ name ] ) { delete map [ name ] ; Ext . Array . remove ( classList , name ) ; } } dom . className = classList . join ( ' ' ) ; return this ; } 
function ( oldName , newName , prefix , suffix ) { if ( ! oldName && ! newName ) { return this ; } oldName = oldName || [ ] ; newName = newName || [ ] ; if ( ! this . isSynchronized ) { this . synchronize ( ) ; } if ( ! suffix ) { suffix = '' ; } var dom = this . dom , map = this . hasClassMap , classList = this . classList , SEPARATOR = this . SEPARATOR , i , ln , name ; prefix = prefix ? prefix + SEPARATOR : '' ; suffix = suffix ? SEPARATOR + suffix : '' ; if ( typeof oldName == 'string' ) { oldName = oldName . split ( this . spacesRe ) ; } if ( typeof newName == 'string' ) { newName = newName . split ( this . spacesRe ) ; } for ( i = 0 , ln = oldName . length ; i < ln ; i ++ ) { name = prefix + oldName [ i ] + suffix ; if ( map [ name ] ) { delete map [ name ] ; Ext . Array . remove ( classList , name ) ; } } for ( i = 0 , ln = newName . length ; i < ln ; i ++ ) { name = prefix + newName [ i ] + suffix ; if ( ! map [ name ] ) { map [ name ] = true ; classList . push ( name ) ; } } dom . className = classList . join ( ' ' ) ; return this ; } 
function ( className ) { var map = this . hasClassMap , i , ln , name ; if ( typeof className == 'string' ) { className = className . split ( this . spacesRe ) ; } for ( i = 0 , ln = className . length ; i < ln ; i ++ ) { name = className [ i ] ; if ( ! map [ name ] ) { map [ name ] = true ; } } this . classList = className . slice ( ) ; this . dom . className = className . join ( ' ' ) ; } 
function ( className , force ) { if ( typeof force !== 'boolean' ) { force = ! this . hasCls ( className ) ; } return ( force ) ? this . addCls ( className ) : this . removeCls ( className ) ; } 
function ( width , height ) { if ( Ext . isObject ( width ) ) { 
function ( visible ) { var mode = this . getVisibilityMode ( ) , method = visible ? 'removeCls' : 'addCls' ; switch ( mode ) { case this . VISIBILITY : this . removeCls ( [ 'x-hidden-display' , 'x-hidden-offsets' ] ) ; this [ method ] ( 'x-hidden-visibility' ) ; break ; case this . DISPLAY : this . removeCls ( [ 'x-hidden-visibility' , 'x-hidden-offsets' ] ) ; this [ method ] ( 'x-hidden-display' ) ; break ; case this . OFFSETS : this . removeCls ( [ 'x-hidden-visibility' , 'x-hidden-display' ] ) ; this [ method ] ( 'x-hidden-offsets' ) ; break ; } return this ; } 
function ( prop ) { var me = this , dom = me . dom , hook = me . styleHooks [ prop ] , cs , result ; if ( dom == document ) { return null ; } if ( ! hook ) { me . styleHooks [ prop ] = hook = { name : Ext . dom . Element . normalize ( prop ) } ; } if ( hook . get ) { return hook . get ( dom , me ) ; } cs = window . getComputedStyle ( dom , '' ) ; 
function ( prop , value ) { var me = this , dom = me . dom , hooks = me . styleHooks , style = dom . style , valueFrom = Ext . valueFrom , name , hook ; 
function ( side ) { var me = this , hash = { t : "top" , l : "left" , r : "right" , b : "bottom" } , o = { } , key ; if ( ! side ) { for ( key in me . margins ) { o [ hash [ key ] ] = parseFloat ( me . getStyle ( me . margins [ key ] ) ) || 0 ; } return o ; } else { return me . addStyles . call ( me , side , me . margins ) ; } } 
function ( ) { 
function ( prop ) { 
function ( className ) { 
function getAllKeys ( forValue , inObject ) { var keys = [ ] for ( let key of Object . keys ( inObject ) ) { if ( inObject [ key ] === forValue ) { keys . push ( key ) } } return keys } 
function printCounter ( indicator ) { counter ++ ; process . stdout . write ( indicator ) ; if ( counter === filesLength || counter % lineLength === 0 ) { process . stdout . write ( lineSpacing . slice ( - 1 * ( ( lineLength - counter ) % lineLength ) ) + " " ) ; process . stdout . write ( String ( " " + counter ) . slice ( - 3 ) + " / " + String ( " " + filesLength ) . slice ( - 3 ) ) ; process . stdout . write ( "\n" ) ; } } 
function ( config ) { var defaultClass = Ext . fx . animation . Abstract , type ; if ( typeof config == 'string' ) { type = config ; config = { } ; } else if ( config && config . type ) { type = config . type ; } if ( type ) { if ( Ext . browser . is . AndroidStock2 ) { if ( type == 'pop' ) { type = 'fade' ; } if ( type == 'popIn' ) { type = 'fadeIn' ; } if ( type == 'popOut' ) { type = 'fadeOut' ; } } defaultClass = Ext . ClassManager . getByAlias ( 'animation.' + type ) ; 
function encode ( string ) { function hex ( code ) { var hex_code = code . toString ( 16 ) . toUpperCase ( ) ; if ( hex_code . length < 2 ) { hex_code = 0 + hex_code ; } return '%' + hex_code ; } string = string + '' ; var reserved_chars = / [ :\/?#\[\]@!$&'()*+,;=<>"{}|\\`\^%\r\n\u0080-\uffff] / ; var str_len = string . length ; var i ; var string_arr = string . split ( '' ) ; var c ; for ( i = 0 ; i < str_len ; i += 1 ) { if ( c = string_arr [ i ] . match ( reserved_chars ) ) { c = c [ 0 ] . charCodeAt ( 0 ) ; if ( c < 128 ) { string_arr [ i ] = hex ( c ) ; } else if ( c < 2048 ) { string_arr [ i ] = hex ( 192 + ( c >> 6 ) ) + hex ( 128 + ( c & 63 ) ) ; } else if ( c < 65536 ) { string_arr [ i ] = hex ( 224 + ( c >> 12 ) ) + hex ( 128 + ( ( c >> 6 ) & 63 ) ) + hex ( 128 + ( c & 63 ) ) ; } else if ( c < 2097152 ) { string_arr [ i ] = hex ( 240 + ( c >> 18 ) ) + hex ( 128 + ( ( c >> 12 ) & 63 ) ) + hex ( 128 + ( ( c >> 6 ) & 63 ) ) + hex ( 128 + ( c & 63 ) ) ; } } } return string_arr . join ( '' ) ; } 
function decode ( string ) { return string . replace ( / %[a-fA-F0-9]{2} / ig , function ( match ) { return String . fromCharCode ( parseInt ( match . replace ( '%' , '' ) , 16 ) ) ; } ) ; } 
function getNonce ( key_length ) { function rand ( ) { return Math . floor ( Math . random ( ) * chars . length ) ; } key_length = key_length || 64 ; var key_bytes = key_length / 8 ; var value = '' ; var key_iter = key_bytes / 4 ; var key_remainder = key_bytes % 4 ; var i ; var chars = [ '20' , '21' , '22' , '23' , '24' , '25' , '26' , '27' , '28' , '29' , '2A' , '2B' , '2C' , '2D' , '2E' , '2F' , '30' , '31' , '32' , '33' , '34' , '35' , '36' , '37' , '38' , '39' , '3A' , '3B' , '3C' , '3D' , '3E' , '3F' , '40' , '41' , '42' , '43' , '44' , '45' , '46' , '47' , '48' , '49' , '4A' , '4B' , '4C' , '4D' , '4E' , '4F' , '50' , '51' , '52' , '53' , '54' , '55' , '56' , '57' , '58' , '59' , '5A' , '5B' , '5C' , '5D' , '5E' , '5F' , '60' , '61' , '62' , '63' , '64' , '65' , '66' , '67' , '68' , '69' , '6A' , '6B' , '6C' , '6D' , '6E' , '6F' , '70' , '71' , '72' , '73' , '74' , '75' , '76' , '77' , '78' , '79' , '7A' , '7B' , '7C' , '7D' , '7E' ] ; for ( i = 0 ; i < key_iter ; i += 1 ) { value += chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] + chars [ rand ( ) ] ; } 
function toHeaderString ( params , realm ) { var arr = [ ] ; var i ; for ( i in params ) { if ( typeof params [ i ] !== 'object' && params [ i ] !== '' && params [ i ] !== undefined ) { arr . push ( encode ( i ) + '="' + encode ( params [ i ] ) + '"' ) ; } } arr . sort ( ) ; if ( realm ) { arr . unshift ( 'realm="' + encode ( realm ) + '"' ) ; } return arr . join ( ', ' ) ; } 
function toSignatureBaseString ( method , url , header_params , query_params ) { var arr = [ ] ; var i ; for ( i in header_params ) { if ( header_params [ i ] !== undefined && header_params [ i ] !== '' ) { arr . push ( [ encode ( i ) , encode ( header_params [ i ] + '' ) ] ) ; } } for ( i in query_params ) { if ( query_params [ i ] !== undefined && query_params [ i ] !== '' ) { arr . push ( [ encode ( i ) , encode ( query_params [ i ] + '' ) ] ) ; } } arr = arr . sort ( function lexicalSort ( a , b ) { if ( a [ 0 ] < b [ 0 ] ) { return - 1 ; } else if ( a [ 0 ] > b [ 0 ] ) { return 1 ; } else { if ( a [ 1 ] < b [ 1 ] ) { return - 1 ; } else if ( a [ 1 ] > b [ 1 ] ) { return 1 ; } else { return 0 ; } } } ) . map ( function ( el ) { return el . join ( "=" ) ; } ) ; return [ method , encode ( url ) , encode ( arr . join ( '&' ) ) ] . join ( '&' ) ; } 
function ( method , url , async , user , password ) { var xhr = this . request ; xhr . method = method . toUpperCase ( ) ; xhr . url = Url . parse ( url , true ) ; xhr . async = async ; xhr . user = password ; xhr . open ( xhr . method , xhr . url , xhr . async , xhr . user , xhr . password ) ; } 
function ( application_secret , token_secret , signature_base ) { var passphrase ; var signature ; application_secret = encode ( application_secret ) ; token_secret = encode ( token_secret || '' ) ; passphrase = application_secret + '&' + token_secret ; signature = Cryptography . hmac ( Cryptography . SHA1 , passphrase , signature_base ) ; return btoa ( signature ) ; } 
function ( fileName , tmpL , idx , indexColumn ) { var self = this ; var fNameList = tmpL . splice ( 0 , 1 ) [ 0 ] ; var fTypeList = tmpL . splice ( 0 , 1 ) [ 0 ] ; if ( indexColumn != undefined ) { idx = fNameList [ indexColumn ] ; } var fieldsName = { } ; fNameList . forEach ( function ( value , index ) { fieldsName [ value ] = index ; } ) ; self . data = { } ; tmpL . forEach ( function ( item ) { var obj = { } ; for ( var k in fieldsName ) { 
function ( config ) { if ( typeof config == "string" ) { config = { title : config } ; } var minHeight = '1.3em' ; if ( Ext . theme . is . Cupertino ) { minHeight = '1.5em' } else if ( Ext . filterPlatform ( 'blackberry' ) || Ext . filterPlatform ( 'ie10' ) ) { minHeight = '2.6em' ; } Ext . applyIf ( config , { docked : 'top' , minHeight : minHeight , ui : Ext . filterPlatform ( 'blackberry' ) ? 'light' : 'dark' , cls : this . getBaseCls ( ) + '-title' } ) ; if ( Ext . theme . is . Tizen ) { Ext . applyIf ( config , { centered : false } ) ; } return Ext . factory ( config , Ext . Toolbar , this . getTitle ( ) ) ; } 
function ( newButtons ) { var me = this ; 
function ( initialConfig ) { Ext . util . InputBlocker . blockInputs ( ) ; 
function ( title , message , fn , scope ) { return this . show ( { title : title || null , message : message || null , buttons : Ext . MessageBox . YESNO , promptConfig : false , scope : scope , fn : function ( ) { if ( fn ) { fn . apply ( scope , arguments ) ; } } } ) ; } 
function ( title , message , fn , scope , multiLine , value , prompt ) { return this . show ( { title : title || null , message : message || null , buttons : Ext . MessageBox . OKCANCEL , scope : scope , prompt : prompt || true , multiLine : multiLine , value : value , fn : function ( ) { if ( fn ) { fn . apply ( scope , arguments ) ; } } } ) ; } 
function ( newComponent ) { this . callParent ( arguments ) ; var cls = this . getCls ( ) ; if ( newComponent ) { this . spinDownButton = Ext . Element . create ( { cls : cls + '-button ' + cls + '-button-down' , html : '-' } ) ; this . spinUpButton = Ext . Element . create ( { cls : cls + '-button ' + cls + '-button-up' , html : '+' } ) ; this . downRepeater = this . createRepeater ( this . spinDownButton , this . onSpinDown ) ; this . upRepeater = this . createRepeater ( this . spinUpButton , this . onSpinUp ) ; } } 
function ( val , type ) { var ret ; 
function ( config ) { if ( config ) { if ( Ext . isBoolean ( config ) ) { config = { } ; } if ( typeof config == "string" ) { config = { text : config } ; } Ext . applyIf ( config , { ui : 'action' , align : 'right' , text : 'Done' } ) ; } return Ext . factory ( config , 'Ext.Button' , this . getDoneButton ( ) ) ; } 
function ( config ) { if ( config ) { if ( Ext . isBoolean ( config ) ) { config = { } ; } if ( typeof config == "string" ) { config = { text : config } ; } Ext . applyIf ( config , { align : 'left' , text : 'Cancel' } ) ; } return Ext . factory ( config , 'Ext.Button' , this . getCancelButton ( ) ) ; } 
function ( newSlots ) { var bcss = Ext . baseCSSPrefix , innerItems ; this . removeAll ( ) ; if ( newSlots ) { this . add ( newSlots ) ; } innerItems = this . getInnerItems ( ) ; if ( innerItems . length > 0 ) { innerItems [ 0 ] . addCls ( bcss + 'first' ) ; innerItems [ innerItems . length - 1 ] . addCls ( bcss + 'last' ) ; } this . updateUseTitles ( this . getUseTitles ( ) ) ; } 
function ( values , animated ) { var me = this , slots = me . getInnerItems ( ) , ln = slots . length , key , slot , loopSlot , i , value ; if ( ! values ) { values = { } ; for ( i = 0 ; i < ln ; i ++ ) { 
function ( useDom ) { var values = { } , items = this . getItems ( ) . items , ln = items . length , item , i ; if ( useDom ) { for ( i = 0 ; i < ln ; i ++ ) { item = items [ i ] ; if ( item && item . isSlot ) { values [ item . getName ( ) ] = item . getValue ( useDom ) ; } } this . _values = values ; } return this . _values ; } 
function behatRunner ( data , callback ) { var spawn = require ( 'child_process' ) . spawn , behat = spawn ( data . cmd , data . args ) , stderr = '' , stdout = '' , options = data . options || { } ; if ( typeof options . failOnUndefined === 'undefined' ) { options . failOnUndefined = false ; } if ( typeof options . failOnFailed === 'undefined' ) { options . failOnFailed = true ; } behat . stdout . on ( 'data' , function ( data ) { stdout += data ; } ) ; behat . stderr . on ( 'data' , function ( data ) { stderr += data ; } ) ; behat . on ( 'exit' , function ( code ) { if ( code === 127 ) { grunt . log . errorlns ( 'In order for this task to work properly, Behat must be ' + 'installed and in the system PATH (if you can run "behat" at' + ' the command line, this task should work). Unfortunately, ' + 'Behat cannot be installed automatically via npm or grunt. ' + 'See the Behat installation instructions: ' + 'http://docs.behat.org/quick_intro.html#installation' ) ; grunt . warn ( 'Behat not found.' , code ) ; } else { if ( options . failOnUndefined && hasUndefinedSteps ( stdout ) ) { grunt . verbose . writeln ( stdout ) ; stderr = 'Undefined Steps' ; if ( options . output ) { stderr = stdout ; } } if ( options . failOnFailed && hasFailedSteps ( stdout ) ) { grunt . verbose . writeln ( stdout ) ; stderr = 'Failed Steps' ; if ( options . output ) { stderr = stdout ; } } if ( stderr === '' && options . output ) { grunt . log . write ( stdout ) ; } } callback ( stderr , stdout ) ; } ) ; } 
function addTranslation ( translations , locale ) { if ( typeof translations !== 'object' ) { return ; } 
function ( ) { var me = this , pressedButtons = [ ] , ln , i , item , items ; 
function ( button ) { if ( ! this . getAllowToggle ( ) ) { return ; } var me = this , pressedButtons = me . getPressedButtons ( ) || [ ] , buttons = [ ] , alreadyPressed ; if ( ! me . getDisabled ( ) && ! button . getDisabled ( ) ) { 
function ( newButtons , oldButtons ) { var me = this , items = me . getItems ( ) , pressedCls = me . getPressedCls ( ) , events = [ ] , item , button , ln , i , e ; 
function ( ) { var me = this , store = me . getStore ( ) , value = me . getValue ( ) ; 
function ( newOptions ) { var store = this . getStore ( ) ; if ( ! store ) { this . setStore ( true ) ; store = this . _store ; } if ( ! newOptions ) { store . clearData ( ) ; } else { store . setData ( newOptions ) ; this . onStoreDataChanged ( store ) ; } return this ; } 
function ( store ) { var initialConfig = this . getInitialConfig ( ) , value = this . getValue ( ) ; if ( value || value == 0 ) { this . updateValue ( this . applyValue ( value ) ) ; } if ( this . getValue ( ) === null ) { if ( initialConfig . hasOwnProperty ( 'value' ) ) { this . setValue ( initialConfig . value ) ; } if ( this . getValue ( ) === null && this . getAutoSelect ( ) ) { if ( store . getCount ( ) > 0 ) { this . setValue ( store . getAt ( 0 ) ) ; } } } } 
function ( ) { var me = this , record ; if ( me . getAutoSelect ( ) ) { var store = me . getStore ( ) ; record = ( me . originalValue ) ? me . originalValue : store . getAt ( 0 ) ; } else { var usePicker = me . getUsePicker ( ) , picker = usePicker ? me . picker : me . listPanel ; if ( picker ) { picker = picker . child ( usePicker ? 'pickerslot' : 'dataview' ) ; picker . deselectAll ( ) ; } record = null ; } me . setValue ( record ) ; return me ; } 
function generateSqlSchema ( dbDialect , metadata , prefix = undefined ) { check . assert . nonEmptyString ( dbDialect ) check . assert . object ( metadata ) check . assert . maybe . string ( prefix ) if ( ! Dialects . isSupported ( dbDialect ) ) { throw new Error ( ` ${ dbDialect } ` ) } prefix = prefix || '' const sqlSerializer = new SqlSerializer ( dbDialect ) const orderedEntities = getEntitiesOrderedByRelations ( metadata ) let queries = [ ] _ . forEach ( orderedEntities , ( entityName ) => { const entity = metadata [ entityName ] const tableName = pgEscape . ident ( ` ${ prefix } ${ entityName } ` ) let createQueries = [ ] _ . forOwn ( entity . fields , ( field , fieldName ) => { const columnName = pgEscape . ident ( fieldName ) let columnQuery = '' columnQuery += columnName let columnConstraints = [ ] const columnType = SqlSerializer . resolveType ( field . type ) columnQuery += ` ${ columnType } ` if ( field . enum ) { const enumValues = field . enum . map ( ( value ) => sqlSerializer . serializeValue ( field . type , value ) ) . join ( ', ' ) const expression = columnType . match ( / (\[\d*\])+ / g ) ? ` ${ enumValues } ` : ` ${ enumValues } ` columnConstraints . push ( ` ${ columnName } ${ expression } ` ) } 
function getGlobalObj ( str , root ) { for ( var i = 0 ; i < root . length ; ++ i ) { if ( root [ i ] . name == str ) { return root [ i ] ; } } return undefined ; } 
function forEachStruct ( structname , obj , root , callback , noexline ) { if ( noexline == undefined ) { noexline = false ; } for ( var i = 0 ; i < obj . val . length ; ++ i ) { if ( noexline && obj . val [ i ] . name . name . indexOf ( '_' ) == 0 ) { continue ; } if ( obj . val [ i ] . hasOwnProperty ( 'type2' ) && obj . val [ i ] . type2 == 'expand' ) { if ( ! obj . val [ i ] . hasOwnProperty ( 'expand' ) ) { forEachStruct ( structname , getGlobalObj ( obj . val [ i ] . type , root ) , root , callback ) ; } else { var expandobj = getGlobalObj ( obj . val [ i ] . expand , root ) ; for ( var eoi = 0 ; eoi < expandobj . val . length ; ++ eoi ) { callback ( structname , { name : { name : getEnumMemberRealName ( expandobj . val [ eoi ] . name , expandobj . name ) } , type : obj . val [ i ] . type , comment : expandobj . val [ eoi ] . comment } , root ) ; } } } else { if ( obj . name != structname && obj . val [ i ] . hasOwnProperty ( 'type2' ) && obj . val [ i ] . type2 == 'primary' ) { callback ( structname , { name : obj . val [ i ] . name , val : obj . val [ i ] . val , type : obj . val [ i ] . type , type2 : 'unique' } , root ) ; } else { callback ( structname , obj . val [ i ] , root ) ; } } } } 
function getStructMemberType ( membername , structname , root ) { var obj = getGlobalObj ( structname , root ) ; if ( obj != undefined ) { if ( obj . type == 'message' || obj . type == 'struct' || obj . type == 'static' ) { for ( var i = 0 ; i < obj . val . length ; ++ i ) { if ( obj . val [ i ] . name . name == membername ) { return obj . val [ i ] . type ; } } } } return undefined ; } 
function getMember ( obj , name , root ) { var ii = str . indexOf ( '.' ) ; if ( ii < 0 ) { var curobj = undefined ; forEachStruct ( obj . name , obj , root , function ( structname , cobj , root ) { if ( name == cobj . name . name ) { curobj = cobj ; } } ) ; return curobj ; } if ( ii == 0 ) { return ; } var curtype = undefined ; var cur = str . slice ( 0 , ii ) ; forEachStruct ( obj . name , obj , root , function ( structname , cobj , root ) { if ( cur == cobj . name . name ) { curtype = cobj . type ; } } ) ; if ( curtype != undefined ) { return getMember ( getGlobalObj ( curtype , root ) , str . slice ( ii + 1 ) , root ) ; } return ; } 
function setInMessage ( obj , root ) { obj . inmessage = true ; if ( obj . type == 'static' || obj . type == 'struct' || obj . type == 'message' ) { for ( var i = 0 ; i < obj . val . length ; ++ i ) { var cval = obj . val [ i ] ; if ( cval . hasOwnProperty ( 'type2' ) && 'expand' == cval . type2 ) { continue ; } var mytype = getRealType ( cval . type , root ) ; if ( isBaseType ( mytype ) ) { continue ; } setInMessage ( getGlobalObj ( mytype , root ) , root ) ; } } } 
function procInMessage ( root ) { for ( var i = 0 ; i < root . length ; ++ i ) { if ( 'message' == root [ i ] . type ) { setInMessage ( root [ i ] , root ) ; } } return root ; } 
function getVer ( root ) { let cur = getGlobalObj ( 'VER' , root ) ; if ( cur == undefined ) { return '' ; } return cur . val . val ; } 
function RPC ( contact , options ) { assert ( this instanceof RPC , 'Invalid instance supplied' ) assert ( contact instanceof Contact , 'Invalid contact was supplied' ) events . EventEmitter . call ( this ) options = options || { } if ( options . replyto ) { assert ( options . replyto instanceof Contact , 'Invalid contact was supplied' ) } this . _hooks = { before : { } , after : { } } this . _pendingCalls = { } this . _contact = options . replyto || contact this . _log = options && options . logger this . readyState = 0 this . open ( ) } 
function ( el , q ) { var root , is , i , ln ; if ( typeof el == "string" ) { el = document . getElementById ( el ) ; } if ( Ext . isArray ( el ) ) { is = true ; ln = el . length ; for ( i = 0 ; i < ln ; i ++ ) { if ( ! this . is ( el [ i ] , q ) ) { is = false ; break ; } } } else { root = el . parentNode ; if ( ! root ) { root = document . createDocumentFragment ( ) ; root . appendChild ( el ) ; is = this . select ( q , root ) . indexOf ( el ) !== - 1 ; root . removeChild ( el ) ; root = null ; } else { is = this . select ( q , root ) . indexOf ( el ) !== - 1 ; } } return is ; } 
function Channel ( id , exchange ) { var self = this ; events . EventEmitter . call ( this ) ; this . id = id ; this . exchange = exchange ; this . exchange . on ( this . id , function ( message ) { self . emit ( 'message' , message ) ; } ) ; this . setMaxListeners ( 0 ) ; } 
function AvailabilityMetric ( ) { if ( ! ( this instanceof AvailabilityMetric ) ) { return new AvailabilityMetric ( ) } Metric . call ( this ) this . key = 'availability' this . default = [ 0 , 0 ] 
function includeHelpers ( func ) { 
function jam ( func , context ) { ensureFunc ( func , 'function' ) ; var steps = [ ] ; 
function continuable ( func , context ) { ensureFunc ( func , 'function' ) ; if ( context ) { 
function extractDescription ( d ) { if ( ! d ) return ; if ( d === "ERROR: No README data found!" ) return ; 
function addComment ( type , value , start , end , loc ) { var comment ; assert ( typeof start === 'number' , 'Comment must have valid position' ) ; 
function scanPunctuator ( ) { var start = index , code = source . charCodeAt ( index ) , code2 , ch1 = source [ index ] , ch2 , ch3 , ch4 ; if ( state . inJSXTag || state . inJSXChild ) { 
function expectKeyword ( keyword , contextual ) { var token = lex ( ) ; if ( token . type !== ( contextual ? Token . Identifier : Token . Keyword ) || token . value !== keyword ) { throwUnexpected ( token ) ; } } 
function parseArrayInitialiser ( ) { var elements = [ ] , blocks = [ ] , filter = null , tmp , possiblecomprehension = true , marker = markerCreate ( ) ; expect ( '[' ) ; while ( ! match ( ']' ) ) { if ( lookahead . value === 'for' && lookahead . type === Token . Keyword ) { if ( ! possiblecomprehension ) { throwError ( { } , Messages . ComprehensionError ) ; } matchKeyword ( 'for' ) ; tmp = parseForStatement ( { ignoreBody : true } ) ; tmp . of = tmp . type === Syntax . ForOfStatement ; tmp . type = Syntax . ComprehensionBlock ; if ( tmp . left . kind ) { 
function parsePropertyFunction ( options ) { var previousStrict , previousYieldAllowed , previousAwaitAllowed , params , defaults , body , marker = markerCreate ( ) ; previousStrict = strict ; previousYieldAllowed = state . yieldAllowed ; state . yieldAllowed = options . generator ; previousAwaitAllowed = state . awaitAllowed ; state . awaitAllowed = options . async ; params = options . params || [ ] ; defaults = options . defaults || [ ] ; body = parseConciseBody ( ) ; if ( options . name && strict && isRestrictedWord ( params [ 0 ] . name ) ) { throwErrorTolerant ( options . name , Messages . StrictParamName ) ; } strict = previousStrict ; state . yieldAllowed = previousYieldAllowed ; state . awaitAllowed = previousAwaitAllowed ; return markerApply ( marker , delegate . createFunctionExpression ( null , params , defaults , body , options . rest || null , options . generator , body . type !== Syntax . BlockStatement , options . async , options . returnType , options . typeParameters ) ) ; } 
function parsePostfixExpression ( ) { var marker = markerCreate ( ) , expr = parseLeftHandSideExpressionAllowCall ( ) , token ; if ( lookahead . type !== Token . Punctuator ) { return expr ; } if ( ( match ( '++' ) || match ( '--' ) ) && ! peekLineTerminator ( ) ) { 
function parseUnaryExpression ( ) { var marker , token , expr ; if ( lookahead . type !== Token . Punctuator && lookahead . type !== Token . Keyword ) { return parsePostfixExpression ( ) ; } if ( match ( '++' ) || match ( '--' ) ) { marker = markerCreate ( ) ; token = lex ( ) ; expr = parseUnaryExpression ( ) ; 
function reinterpretAsAssignmentBindingPattern ( expr ) { var i , len , property , element ; if ( expr . type === Syntax . ObjectExpression ) { expr . type = Syntax . ObjectPattern ; for ( i = 0 , len = expr . properties . length ; i < len ; i += 1 ) { property = expr . properties [ i ] ; if ( property . type === Syntax . SpreadProperty ) { if ( i < len - 1 ) { throwError ( { } , Messages . PropertyAfterSpreadProperty ) ; } reinterpretAsAssignmentBindingPattern ( property . argument ) ; } else { if ( property . kind !== 'init' ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } reinterpretAsAssignmentBindingPattern ( property . value ) ; } } } else if ( expr . type === Syntax . ArrayExpression ) { expr . type = Syntax . ArrayPattern ; for ( i = 0 , len = expr . elements . length ; i < len ; i += 1 ) { element = expr . elements [ i ] ; if ( element ) { reinterpretAsAssignmentBindingPattern ( element ) ; } } } else if ( expr . type === Syntax . Identifier ) { if ( isRestrictedWord ( expr . name ) ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } } else if ( expr . type === Syntax . SpreadElement ) { reinterpretAsAssignmentBindingPattern ( expr . argument ) ; if ( expr . argument . type === Syntax . ObjectPattern ) { throwError ( { } , Messages . ObjectPatternAsSpread ) ; } } else { if ( expr . type !== Syntax . MemberExpression && expr . type !== Syntax . CallExpression && expr . type !== Syntax . NewExpression ) { throwError ( { } , Messages . InvalidLHSInAssignment ) ; } } } 
function parseExpressionStatement ( ) { var marker = markerCreate ( ) , expr = parseExpression ( ) ; consumeSemicolon ( ) ; return markerApply ( marker , delegate . createExpressionStatement ( expr ) ) ; } 
function parseReturnStatement ( ) { var argument = null , marker = markerCreate ( ) ; expectKeyword ( 'return' ) ; if ( ! state . inFunctionBody ) { throwErrorTolerant ( { } , Messages . IllegalReturn ) ; } 
function parseStatement ( ) { var type = lookahead . type , marker , expr , labeledBody ; if ( type === Token . EOF ) { throwUnexpected ( lookahead ) ; } if ( type === Token . Punctuator ) { switch ( lookahead . value ) { case ';' : return parseEmptyStatement ( ) ; case '{' : return parseBlock ( ) ; case '(' : return parseExpressionStatement ( ) ; default : break ; } } if ( type === Token . Keyword ) { switch ( lookahead . value ) { case 'break' : return parseBreakStatement ( ) ; case 'continue' : return parseContinueStatement ( ) ; case 'debugger' : return parseDebuggerStatement ( ) ; case 'do' : return parseDoWhileStatement ( ) ; case 'for' : return parseForStatement ( ) ; case 'function' : return parseFunctionDeclaration ( ) ; case 'class' : return parseClassDeclaration ( ) ; case 'if' : return parseIfStatement ( ) ; case 'return' : return parseReturnStatement ( ) ; case 'switch' : return parseSwitchStatement ( ) ; case 'throw' : return parseThrowStatement ( ) ; case 'try' : return parseTryStatement ( ) ; case 'var' : return parseVariableStatement ( ) ; case 'while' : return parseWhileStatement ( ) ; case 'with' : return parseWithStatement ( ) ; default : break ; } } if ( matchAsyncFuncExprOrDecl ( ) ) { return parseFunctionDeclaration ( ) ; } marker = markerCreate ( ) ; expr = parseExpression ( ) ; 
function parseSourceElement ( ) { var token ; if ( lookahead . type === Token . Keyword ) { switch ( lookahead . value ) { case 'const' : case 'let' : return parseConstLetDeclaration ( lookahead . value ) ; case 'function' : return parseFunctionDeclaration ( ) ; case 'export' : throwErrorTolerant ( { } , Messages . IllegalExportDeclaration ) ; return parseExportDeclaration ( ) ; case 'import' : throwErrorTolerant ( { } , Messages . IllegalImportDeclaration ) ; return parseImportDeclaration ( ) ; case 'interface' : if ( lookahead2 ( ) . type === Token . Identifier ) { return parseInterface ( ) ; } return parseStatement ( ) ; default : return parseStatement ( ) ; } } if ( matchContextualKeyword ( 'type' ) && lookahead2 ( ) . type === Token . Identifier ) { return parseTypeAlias ( ) ; } if ( matchContextualKeyword ( 'interface' ) && lookahead2 ( ) . type === Token . Identifier ) { return parseInterface ( ) ; } if ( matchContextualKeyword ( 'declare' ) ) { token = lookahead2 ( ) ; if ( token . type === Token . Keyword ) { switch ( token . value ) { case 'class' : return parseDeclareClass ( ) ; case 'function' : return parseDeclareFunction ( ) ; case 'var' : return parseDeclareVariable ( ) ; } } else if ( token . type === Token . Identifier && token . value === 'module' ) { return parseDeclareModule ( ) ; } } if ( lookahead . type !== Token . EOF ) { return parseStatement ( ) ; } } 
function advanceJSXChild ( ) { var ch = source . charCodeAt ( index ) ; 
function extend ( object , properties ) { var entry , result = { } ; for ( entry in object ) { if ( object . hasOwnProperty ( entry ) ) { result [ entry ] = object [ entry ] ; } } for ( entry in properties ) { if ( properties . hasOwnProperty ( entry ) ) { result [ entry ] = properties [ entry ] ; } } return result ; } 
function resolve ( value , key ) { 
function clone ( parent , circular , depth , prototype ) { var filter ; if ( typeof circular === 'object' ) { depth = circular . depth ; prototype = circular . prototype ; filter = circular . filter ; circular = circular . circular } 
function makeAbs ( self , f ) { var abs = f if ( f . charAt ( 0 ) === '/' ) { abs = path . join ( self . root , f ) } else if ( isAbsolute ( f ) || f === '' ) { abs = f } else if ( self . changedCwd ) { abs = path . resolve ( self . cwd , f ) } else { abs = path . resolve ( f ) } return abs } 
function isPlainObject ( value ) { var Ctor ; 
function reflowText ( text , width , gfm ) { 
function isAbsolute ( fp ) { if ( typeof fp !== 'string' ) { throw new TypeError ( 'isAbsolute expects a string.' ) ; } if ( ! isWindows ( ) && isAbsolute . posix ( fp ) ) { return true ; } return isAbsolute . win32 ( fp ) ; } 
function repeat ( str , num ) { if ( typeof str !== 'string' ) { throw new TypeError ( 'repeat-string expects a string.' ) ; } if ( num === 1 ) return str ; if ( num === 2 ) return str + str ; var max = str . length * num ; if ( cache !== str || typeof cache === 'undefined' ) { cache = str ; res = '' ; } while ( max > res . length && num > 0 ) { if ( num & 1 ) { res += str ; } num >>= 1 ; if ( ! num ) break ; str += str ; } return res . substr ( 0 , max ) ; } 
function uniqSet ( arr ) { var seen = new Set ( ) ; return arr . filter ( function ( el ) { if ( ! seen . has ( el ) ) { seen . add ( el ) ; return true ; } } ) ; } 
function ( data , options ) { var handler = new DomHandler ( options ) ; new Parser ( handler , options ) . end ( data ) ; return handler . dom ; } 
function error ( msg , _continue ) { if ( state . error === null ) state . error = '' ; state . error += state . currentCmd + ': ' + msg + '\n' ; if ( msg . length > 0 ) log ( state . error ) ; if ( config . fatal ) process . exit ( 1 ) ; if ( ! _continue ) throw '' ; } 
function parseOptions ( str , map ) { if ( ! map ) error ( 'parseOptions() internal error: no map given' ) ; 
function expand ( list ) { var expanded = [ ] ; list . forEach ( function ( listEl ) { 
function unlinkSync ( file ) { try { fs . unlinkSync ( file ) ; } catch ( e ) { 
function randomFileName ( ) { function randomHash ( count ) { if ( count === 1 ) return parseInt ( 16 * Math . random ( ) , 10 ) . toString ( 16 ) ; else { var hash = '' ; for ( var i = 0 ; i < count ; i ++ ) hash += randomHash ( 1 ) ; return hash ; } } return 'shelljs_' + randomHash ( 20 ) ; } 
function extend ( target ) { var sources = [ ] . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( var key in source ) target [ key ] = source [ key ] ; } ) ; return target ; } 
function wrap ( cmd , fn , options ) { return function ( ) { var retValue = null ; state . currentCmd = cmd ; state . error = null ; try { var args = [ ] . slice . call ( arguments , 0 ) ; if ( options && options . notUnix ) { retValue = fn . apply ( this , args ) ; } else { if ( args . length === 0 || typeof args [ 0 ] !== 'string' || args [ 0 ] [ 0 ] !== '-' ) args . unshift ( '' ) ; 
function pushFile ( file , query ) { 
function writeableDir ( dir ) { if ( ! dir || ! fs . existsSync ( dir ) ) return false ; if ( ! fs . statSync ( dir ) . isDirectory ( ) ) return false ; var testFile = dir + '/' + common . randomFileName ( ) ; try { fs . writeFileSync ( testFile , ' ' ) ; common . unlinkSync ( testFile ) ; return dir ; } catch ( e ) { return false ; } } 
function copyFileSync ( srcFile , destFile ) { if ( ! fs . existsSync ( srcFile ) ) common . error ( 'copyFileSync: no such file or directory: ' + srcFile ) ; var BUF_LENGTH = 64 * 1024 , buf = new Buffer ( BUF_LENGTH ) , bytesRead = BUF_LENGTH , pos = 0 , fdr = null , fdw = null ; try { fdr = fs . openSync ( srcFile , 'r' ) ; } catch ( e ) { common . error ( 'copyFileSync: could not read src file (' + srcFile + ')' ) ; } try { fdw = fs . openSync ( destFile , 'w' ) ; } catch ( e ) { common . error ( 'copyFileSync: could not write to dest file (code=' + e . code + '):' + destFile ) ; } while ( bytesRead === BUF_LENGTH ) { bytesRead = fs . readSync ( fdr , buf , 0 , BUF_LENGTH , pos ) ; fs . writeSync ( fdw , buf , 0 , bytesRead ) ; pos += bytesRead ; } fs . closeSync ( fdr ) ; fs . closeSync ( fdw ) ; fs . chmodSync ( destFile , fs . statSync ( srcFile ) . mode ) ; } 
function cpdirSyncRecursive ( sourceDir , destDir , opts ) { if ( ! opts ) opts = { } ; var checkDir = fs . statSync ( sourceDir ) ; try { fs . mkdirSync ( destDir , checkDir . mode ) ; } catch ( e ) { 
function mkdirSyncRecursive ( dir ) { var baseDir = path . dirname ( dir ) ; 
function splitPath ( p ) { for ( i = 1 ; i < 2 ; i ++ ) { } if ( ! p ) return [ ] ; if ( common . platform === 'win' ) return p . split ( ';' ) ; else return p . split ( ':' ) ; } 
function execSync ( cmd , opts ) { var tempDir = _tempDir ( ) ; var stdoutFile = path . resolve ( tempDir + '/' + common . randomFileName ( ) ) , codeFile = path . resolve ( tempDir + '/' + common . randomFileName ( ) ) , scriptFile = path . resolve ( tempDir + '/' + common . randomFileName ( ) ) , sleepFile = path . resolve ( tempDir + '/' + common . randomFileName ( ) ) ; var options = common . extend ( { silent : common . config . silent } , opts ) ; var previousStdoutContent = '' ; 
function updateStdout ( ) { if ( options . silent || ! fs . existsSync ( stdoutFile ) ) return ; var stdoutContent = fs . readFileSync ( stdoutFile , 'utf8' ) ; 
function execAsync ( cmd , opts , callback ) { var output = '' ; var options = common . extend ( { silent : common . config . silent } , opts ) ; var c = child . exec ( cmd , { env : process . env , maxBuffer : 20 * 1024 * 1024 } , function ( err ) { if ( callback ) callback ( err ? err . code : 0 , output ) ; } ) ; c . stdout . on ( 'data' , function ( data ) { output += data ; if ( ! options . silent ) process . stdout . write ( data ) ; } ) ; c . stderr . on ( 'data' , function ( data ) { output += data ; if ( ! options . silent ) process . stdout . write ( data ) ; } ) ; return c ; } 
function formatArgs ( ) { var args = arguments ; var useColors = this . useColors ; var name = this . namespace ; if ( useColors ) { var c = this . color ; args [ 0 ] = ' \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m' + args [ 0 ] + '\u001b[3' + c + 'm' + ' +' + exports . humanize ( this . diff ) + '\u001b[0m' ; } else { args [ 0 ] = new Date ( ) . toUTCString ( ) + ' ' + name + ' ' + args [ 0 ] ; } return args ; } 
function GNTP ( type , opts ) { opts = opts || { } ; this . type = type ; this . host = opts . host || 'localhost' ; this . port = opts . port || 23053 ; this . request = 'GNTP/1.0 ' + type + ' NONE' + nl ; this . resources = [ ] ; this . attempts = 0 ; this . maxAttempts = 5 ; } 
function Growly ( ) { this . appname = 'Growly' ; this . notifications = undefined ; this . labels = undefined ; this . count = 0 ; this . registered = false ; this . host = undefined ; this . port = undefined ; } 
function Command ( name ) { this . commands = [ ] ; this . options = [ ] ; this . _execs = [ ] ; this . _allowUnknownOption = false ; this . _args = [ ] ; this . _name = name ; } 
function uniq ( array , isSorted , iteratee , thisArg ) { var length = array ? array . length : 0 ; if ( ! length ) { return [ ] ; } if ( isSorted != null && typeof isSorted != 'boolean' ) { thisArg = iteratee ; iteratee = isIterateeCall ( array , isSorted , thisArg ) ? undefined : isSorted ; isSorted = false ; } iteratee = iteratee == null ? iteratee : baseCallback ( iteratee , thisArg , 3 ) ; return ( isSorted ) ? sortedUniq ( array , iteratee ) : baseUniq ( array , iteratee ) ; } 
function baseDifference ( array , values ) { var length = array ? array . length : 0 , result = [ ] ; if ( ! length ) { return result ; } var index = - 1 , indexOf = baseIndexOf , isCommon = true , cache = ( isCommon && values . length >= LARGE_ARRAY_SIZE ) ? createCache ( values ) : null , valuesLength = values . length ; if ( cache ) { indexOf = cacheIndexOf ; isCommon = false ; values = cache ; } outer : while ( ++ index < length ) { var value = array [ index ] ; if ( isCommon && value === value ) { var valuesIndex = valuesLength ; while ( valuesIndex -- ) { if ( values [ valuesIndex ] === value ) { continue outer ; } } result . push ( value ) ; } else if ( indexOf ( values , value , 0 ) < 0 ) { result . push ( value ) ; } } return result ; } 
function AssertionError ( message , _props , ssf ) { var extend = exclude ( 'name' , 'message' , 'stack' , 'constructor' , 'toJSON' ) , props = extend ( _props || { } ) ; 
function ( ) { var ch1 = this . peek ( ) ; var ch2 , ch3 , ch4 ; switch ( ch1 ) { 
function ( ) { var index = 0 ; var value = "" ; var length = this . input . length ; var char = this . peek ( index ) ; var bad ; var isAllowedDigit = isDecimalDigit ; var base = 10 ; var isLegacy = false ; function isDecimalDigit ( str ) { return ( / ^[0-9]$ / ) . test ( str ) ; } function isOctalDigit ( str ) { return ( / ^[0-7]$ / ) . test ( str ) ; } function isBinaryDigit ( str ) { return ( / ^[01]$ / ) . test ( str ) ; } function isHexDigit ( str ) { return ( / ^[0-9a-fA-F]$ / ) . test ( str ) ; } function isIdentifierStart ( ch ) { return ( ch === "$" ) || ( ch === "_" ) || ( ch === "\\" ) || ( ch >= "a" && ch <= "z" ) || ( ch >= "A" && ch <= "Z" ) ; } 
function ( checks ) { var allowNewLine = false ; var jump = 1 ; this . skip ( ) ; var char = this . peek ( ) ; switch ( char ) { case "'" : this . triggerAsync ( "warning" , { code : "W114" , line : this . line , character : this . char , data : [ "\\'" ] } , checks , function ( ) { return state . jsonMode ; } ) ; break ; case "b" : char = "\\b" ; break ; case "f" : char = "\\f" ; break ; case "n" : char = "\\n" ; break ; case "r" : char = "\\r" ; break ; case "t" : char = "\\t" ; break ; case "0" : char = "\\0" ; 
function ( checks ) { var tokenType ; var value = "" ; var ch ; var startLine = this . line ; var startChar = this . char ; var depth = this . templateStarts . length ; if ( ! state . option . esnext ) { 
function ( checks ) { var quote = this . peek ( ) ; 
function addlabel ( name , opts ) { var type = opts . type ; var token = opts . token ; var isblockscoped = opts . isblockscoped ; 
function peek ( p ) { var i = p || 0 , j = 0 , t ; while ( j <= i ) { t = lookahead [ j ] ; if ( ! t ) { t = lookahead [ j ] = lex . token ( ) ; } j += 1 ; } 
function isTypoTypeof ( left , right , state ) { var values ; if ( state . option . notypeof ) return false ; if ( ! left || ! right ) return false ; values = state . inESNext ( ) ? typeofValues . es6 : typeofValues . es3 ; if ( right . type === "(identifier)" && right . value === "typeof" && left . type === "(string)" ) return ! _ . contains ( values , left . value ) ; return false ; } 
function identifier ( fnparam , prop ) { var i = optionalidentifier ( fnparam , prop , false ) ; if ( i ) { return i ; } 
function destructuringAssignOrJsonValue ( ) { 
function ( ) { var CompArray = function ( ) { this . mode = "use" ; this . variables = [ ] ; } ; var _carrays = [ ] ; var _current ; function declare ( v ) { var l = _current . variables . filter ( function ( elt ) { 
function ( s , o , g ) { var i , k , x , reIgnoreStr , reIgnore ; var optionKeys ; var newOptionObj = { } ; var newIgnoredObj = { } ; o = _ . clone ( o ) ; state . reset ( ) ; if ( o && o . scope ) { JSHINT . scope = o . scope ; } else { JSHINT . errors = [ ] ; JSHINT . undefs = [ ] ; JSHINT . internals = [ ] ; JSHINT . blacklist = { } ; JSHINT . scope = "(main)" ; } predefined = Object . create ( null ) ; combine ( predefined , vars . ecmaIdentifiers [ 3 ] ) ; combine ( predefined , vars . reservedVars ) ; combine ( predefined , g || { } ) ; declared = Object . create ( null ) ; exported = Object . create ( null ) ; function each ( obj , cb ) { if ( ! obj ) return ; if ( ! Array . isArray ( obj ) && typeof obj === "object" ) obj = Object . keys ( obj ) ; obj . forEach ( cb ) ; } if ( o ) { each ( o . predef || null , function ( item ) { var slice , prop ; if ( item [ 0 ] === "-" ) { slice = item . slice ( 1 ) ; JSHINT . blacklist [ slice ] = slice ; 
function rename ( filepath , transformer ) { var result ; var fileObj = parse ( filepath ) ; if ( ! transformer ) { result = stringify ( fileObj ) ; debug ( 'transform to %s with no transformer' , result ) ; return result ; } var transformed = util . isFunction ( transformer ) ? transformer ( fileObj ) : transformer ; 
function parseLegacy ( ext , content , fileName , customTags , withInlineFiles ) { return parse ( { ext : ext , content : content , fileName : fileName , customTags : customTags , withInlineFiles : withInlineFiles } ) ; } 
function parsePath ( path ) { var str = path . replace ( / ([^\\])\[ / g , '$1.[' ) , parts = str . match ( / (\\\.|[^.]+?)+ / g ) ; return parts . map ( function ( value ) { var re = / ^\[(\d+)\]$ / , mArr = re . exec ( value ) ; if ( mArr ) return { i : parseFloat ( mArr [ 1 ] ) } ; else return { p : value . replace ( / \\([.\[\]]) / g , '$1' ) } ; } ) ; } 
function assertKeys ( keys ) { var obj = flag ( this , 'object' ) , str , ok = true , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments' ; switch ( _ . type ( keys ) ) { case "array" : if ( arguments . length > 1 ) throw ( new Error ( mixedArgsMsg ) ) ; break ; case "object" : if ( arguments . length > 1 ) throw ( new Error ( mixedArgsMsg ) ) ; keys = Object . keys ( keys ) ; break ; default : keys = Array . prototype . slice . call ( arguments ) ; } if ( ! keys . length ) throw new Error ( 'keys required' ) ; var actual = Object . keys ( obj ) , expected = keys , len = keys . length , any = flag ( this , 'any' ) , all = flag ( this , 'all' ) ; if ( ! any && ! all ) { all = true ; } 
function assertThrows ( constructor , errMsg , msg ) { if ( msg ) flag ( this , 'message' , msg ) ; var obj = flag ( this , 'object' ) ; new Assertion ( obj , msg ) . is . a ( 'function' ) ; var thrown = false , desiredError = null , name = null , thrownError = null ; if ( arguments . length === 0 ) { errMsg = null ; constructor = null ; } else if ( constructor && ( constructor instanceof RegExp || 'string' === typeof constructor ) ) { errMsg = constructor ; constructor = null ; } else if ( constructor && constructor instanceof Error ) { desiredError = constructor ; constructor = null ; errMsg = null ; } else if ( typeof constructor === 'function' ) { name = constructor . prototype . name || constructor . name ; if ( name === 'Error' && constructor !== Error ) { name = ( new constructor ( ) ) . name ; } } else { constructor = null ; } try { obj ( ) ; } catch ( err ) { 
function respondTo ( method , msg ) { if ( msg ) flag ( this , 'message' , msg ) ; var obj = flag ( this , 'object' ) , itself = flag ( this , 'itself' ) , context = ( 'function' === _ . type ( obj ) && ! itself ) ? obj . prototype [ method ] : obj [ method ] ; this . assert ( 'function' === typeof context , 'expected #{this} to respond to ' + _ . inspect ( method ) , 'expected #{this} to not respond to ' + _ . inspect ( method ) ) ; } 
function assertChanges ( object , prop , msg ) { if ( msg ) flag ( this , 'message' , msg ) ; var fn = flag ( this , 'object' ) ; new Assertion ( object , msg ) . to . have . property ( prop ) ; new Assertion ( fn ) . is . a ( 'function' ) ; var initial = object [ prop ] ; fn ( ) ; this . assert ( initial !== object [ prop ] , 'expected .' + prop + ' to change' , 'expected .' + prop + ' to not change' ) ; } 
function shouldGetter ( ) { if ( this instanceof String || this instanceof Number || this instanceof Boolean ) { return new Assertion ( this . valueOf ( ) , null , shouldGetter ) ; } return new Assertion ( this , null , shouldGetter ) ; } 
function functionThrows ( fn , context , args , value ) { try { fn . apply ( context , args ) ; } catch ( error ) { if ( value == null ) return true ; if ( _isFunction2 [ 'default' ] ( value ) && error instanceof value ) return true ; var message = error . message || error ; if ( typeof message === 'string' ) { if ( _isRegexp2 [ 'default' ] ( value ) && value . test ( error . message ) ) return true ; if ( typeof value === 'string' && message . indexOf ( value ) !== - 1 ) return true ; } } return false ; } 
function isA ( object , value ) { if ( _isFunction2 [ 'default' ] ( value ) ) return object instanceof value ; if ( value === 'array' ) return Array . isArray ( object ) ; return typeof object === value ; } 
function ( bin , opt ) { cmd = bin ; if ( opt . testing !== 'undefined' ) { opt . dryRun = opt . testing ; } if ( typeof opt . testSuite === 'undefined' ) { opt . testSuite = '' ; } if ( typeof opt . verbose === 'undefined' ) { opt . verbose = '' ; } if ( typeof opt . dryRun === 'undefined' ) { opt . dryRun = false ; } if ( typeof opt . silent === 'undefined' ) { opt . silent = false ; } if ( typeof opt . testing === 'undefined' ) { opt . testing = false ; } if ( typeof opt . debug === 'undefined' ) { opt . debug = false ; } if ( typeof opt . testClass === 'undefined' ) { opt . testClass = '' ; } if ( typeof opt . clear === 'undefined' ) { opt . clear = false ; } if ( typeof opt . flags === 'undefined' ) { opt . flags = '' ; } if ( typeof opt . notify === 'undefined' ) { opt . notify = false ; } if ( typeof opt . noInteraction === 'undefined' ) { opt . noInteraction = true ; } if ( typeof opt . noAnsi === 'undefined' ) { opt . noAnsi = false ; } if ( typeof opt . quiet === 'undefined' ) { opt . quiet = false ; } if ( typeof opt . formatter === 'undefined' ) { opt . formatter = '' ; } cmd = opt . clear ? 'clear && ' + cmd : cmd ; 
function eatNargs ( i , key , args ) { var toEat = checkAllAliases ( key , opts . narg ) if ( args . length - ( i + 1 ) < toEat ) error = Error ( __ ( 'Not enough arguments following: %s' , key ) ) for ( var ii = i + 1 ; ii < ( toEat + i + 1 ) ; ii ++ ) { setArg ( key , args [ ii ] ) } return ( i + toEat ) } 
function eatArray ( i , key , args ) { for ( var ii = i + 1 ; ii < args . length ; ii ++ ) { if ( / ^- / . test ( args [ ii ] ) ) break i = ii setArg ( key , args [ ii ] ) } return i } 
function setConfig ( argv ) { var configLookup = { } 
function extendAliases ( obj ) { Object . keys ( obj || { } ) . forEach ( function ( key ) { aliases [ key ] = [ ] . concat ( opts . alias [ key ] || [ ] ) 
function checkAllAliases ( key , flag ) { var isSet = false var toCheck = [ ] . concat ( aliases [ key ] || [ ] , key ) toCheck . forEach ( function ( key ) { if ( flag [ key ] ) isSet = flag [ key ] } ) return isSet } 
function guessType ( key , flags ) { var type = 'boolean' if ( flags . strings && flags . strings [ key ] ) type = 'string' else if ( flags . arrays && flags . arrays [ key ] ) type = 'array' return type } 
function maxWidth ( table ) { var width = 0 
function normalizeAliases ( ) { var demanded = yargs . getDemanded ( ) var options = yargs . getOptions ( ) ; ( Object . keys ( options . alias ) || [ ] ) . forEach ( function ( key ) { options . alias [ key ] . forEach ( function ( alias ) { 
function defaultString ( value , defaultDescription ) { var string = '[' + __ ( 'default:' ) + ' ' if ( value === undefined && ! defaultDescription ) return null if ( defaultDescription ) { string += defaultDescription } else { switch ( typeof value ) { case 'string' : string += JSON . stringify ( value ) break case 'object' : string += JSON . stringify ( value ) break default : string += value } } return string + ']' } 
function sigletonify ( inst ) { Object . keys ( inst ) . forEach ( function ( key ) { if ( key === 'argv' ) { Argv . __defineGetter__ ( key , inst . __lookupGetter__ ( key ) ) } else { Argv [ key ] = typeof inst [ key ] === 'function' ? inst [ key ] . bind ( inst ) : inst [ key ] } } ) } 
function find_attr_value ( attrForms , attrName ) { var attrVal ; var attrPos = - 1 ; if ( attrForms && Array . isArray ( attrForms ) ) { attrKey = attrForms . find ( function ( form , i ) { attrPos = i ; return ( i % 2 === 1 ) && form . value === attrName ; } ) if ( attrKey && attrPos + 1 < attrForms . length ) { attrVal = attrForms [ attrPos + 1 ] ; } } return attrVal ; } 
function ( options ) { options = options || { } if ( this . passports && this . passports . every ( t => t instanceof app . orm [ 'Passport' ] ) && options . reload !== true ) { return Promise . resolve ( this ) } else { return this . getPassports ( { transaction : options . transaction || null } ) . then ( passports => { passports = passports || [ ] this . passports = passports this . setDataValue ( 'passports' , passports ) this . set ( 'passports' , passports ) return this } ) } } 
function ( cls , overrides ) { if ( cls . $isClass ) { return cls . override ( overrides ) ; } else { Ext . apply ( cls . prototype , overrides ) ; } } 
function ( value ) { if ( value === null ) { return 'null' ; } var type = typeof value ; if ( type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean' ) { return type ; } var typeToString = toString . call ( value ) ; switch ( typeToString ) { case '[object Array]' : return 'array' ; case '[object Date]' : return 'date' ; case '[object Boolean]' : return 'boolean' ; case '[object Number]' : return 'number' ; case '[object RegExp]' : return 'regexp' ; } if ( type === 'function' ) { return 'function' ; } if ( type === 'object' ) { if ( value . nodeType !== undefined ) { if ( value . nodeType === 3 ) { return ( / \S / ) . test ( value . nodeValue ) ? 'textnode' : 'whitespace' ; } else { return 'element' ; } } return 'object' ; } 
function write ( path , str ) { fs . writeFileSync ( path , str ) ; console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; } 
function mkdir ( path , silent ) { if ( ! exists ( path ) ) { fs . mkdirSync ( path , 0755 ) ; if ( ! silent ) console . log ( terminal . cyan ( pad ( 'create : ' ) ) + path ) ; } } 
function isEmptyDirectory ( path ) { var files ; try { files = fs . readdirSync ( path ) ; if ( files . length > 0 ) { return false ; } } catch ( err ) { if ( err . code ) { terminal . abort ( 'Error: ' , err ) ; } else { throw e ; } } return true ; } 
function ( config , callback , scope ) { 
function ( selector , maxDepth , returnEl ) { if ( arguments . length === 0 ) { return this . delegatedTarget ; } return selector ? Ext . fly ( this . target ) . findParent ( selector , maxDepth , returnEl ) : ( returnEl ? Ext . get ( this . target ) : this . target ) ; } 
function ( action , silent ) { action = Ext . factory ( action , Ext . app . Action ) ; this . getActions ( ) . push ( action ) ; var url = action . getUrl ( ) ; if ( this . getUpdateUrl ( ) ) { 
function ( ) { var actions = this . getActions ( ) , previousAction = actions [ actions . length - 2 ] ; if ( previousAction ) { actions . pop ( ) ; previousAction . getController ( ) . getApplication ( ) . redirectTo ( previousAction . getUrl ( ) ) ; } else { actions [ actions . length - 1 ] . getController ( ) . getApplication ( ) . redirectTo ( '' ) ; } } 
function strformat ( string , dict ) { var formatted = string ; for ( var prop in dict ) { var regexp = new RegExp ( '\\{' + prop + '\\}' , 'gi' ) ; formatted = formatted . replace ( regexp , dict [ prop ] ) ; } return formatted ; } 
function GrelRequest ( grel ) { var authString ; if ( grel . token ) { authString = grel . token + ':' ; } else { authString = grel . user + ':' + grel . password ; } this . headers = { 'Authorization' : 'Basic ' + new Buffer ( authString ) . toString ( 'base64' ) , 'Accept' : 'application/vnd.github.manifold-preview' , 'User-Agent' : 'Grel' } ; this . grel = grel ; this . content = null ; } 
function handleResponse ( res , data , callback ) { 
function splitHeader ( content ) { 
function ( x , y , animation ) { if ( this . isDestroyed ) { return this ; } 
function ( animation ) { var size = this . getSize ( ) , cntSize = this . getContainerSize ( ) ; return this . scrollTo ( size . x - cntSize . x , size . y - cntSize . y , animation ) ; } 
function ( x , y , animation ) { var position = this . position ; x = ( typeof x == 'number' ) ? x + position . x : null ; y = ( typeof y == 'number' ) ? y + position . y : null ; return this . scrollTo ( x , y , animation ) ; } 
function ( config ) { var element ; this . extraConstraint = { } ; this . initialConfig = config ; this . offset = { x : 0 , y : 0 } ; this . listeners = { dragstart : 'onDragStart' , drag : 'onDrag' , dragend : 'onDragEnd' , resize : 'onElementResize' , touchstart : 'onPress' , touchend : 'onRelease' , scope : this } ; if ( config && config . element ) { element = config . element ; delete config . element ; this . setElement ( element ) ; } return this ; } 
function addActions ( actions ) { if ( typeof actions === 'string' ) { add ( actions ) ; } else if ( Array . isArray ( actions ) ) { actions . forEach ( addActions ) ; } else if ( typeof actions === 'object' ) { for ( var type in actions ) { add ( type , actions [ type ] ) ; } } } 
function indexspace ( str , len ) { var x1 , x2 , tmp , inc , arr ; if ( ! isString ( str ) || ! re . test ( str ) ) { throw new Error ( 'indexspace()::invalid input argument. Invalid subsequence syntax. Please consult documentation. Value: `' + str + '`.' ) ; } if ( ! isNonNegativeInteger ( len ) ) { throw new TypeError ( 'indexspace()::invalid input argument. Reference array length must be a nonnegative integer. Value: `' + len + '`.' ) ; } if ( ! len ) { return [ ] ; } str = str . split ( ':' ) ; x1 = str [ 0 ] ; x2 = str [ 1 ] ; if ( str . length === 2 ) { inc = 1 ; } else { inc = parseInt ( str [ 2 ] , 10 ) ; } 
function ( element , eventName , fn , scope , options ) { 
function ( element , eventName , fn , scope ) { 
function ( fn , scope , options ) { 
function ( pattern , count , sep ) { for ( var buf = [ ] , i = count ; i -- ; ) { buf . push ( pattern ) ; } return buf . join ( sep || '' ) ; } 
function ( config ) { var options = new FileUploadOptions ( ) ; options . fileKey = config . fileKey || "file" ; options . fileName = this . path . substr ( this . path . lastIndexOf ( '/' ) + 1 ) ; options . mimeType = config . mimeType || "image/jpeg" ; options . params = config . params || { } ; options . headers = config . headers || { } ; options . chunkMode = config . chunkMode || true ; var fileTransfer = new FileTransfer ( ) ; fileTransfer . upload ( this . path , encodeURI ( config . url ) , config . success , config . failure , options , config . trustAllHosts || false ) ; return fileTransfer ; } 
function ( config ) { var fileTransfer = new FileTransfer ( ) ; fileTransfer . download ( encodeURI ( config . source ) , this . path , config . success , config . failure , config . trustAllHosts || false , config . options || { } ) ; return fileTransfer ; } 
function ( property , value , anyMatch , caseSensitive ) { 
function ( key , item ) { var me = this , filtered = this . filtered , sorted = this . sorted , all = this . all , items = this . items , keys = this . keys , indices = this . indices , filterable = this . mixins . filterable , currentLength = items . length , index = currentLength ; if ( arguments . length == 1 ) { item = key ; key = me . getKey ( item ) ; } if ( typeof key != 'undefined' && key !== null ) { if ( typeof me . map [ key ] != 'undefined' ) { return me . replace ( key , item ) ; } me . map [ key ] = item ; } all . push ( item ) ; if ( filtered && this . getAutoFilter ( ) && filterable . isFiltered . call ( me , item ) ) { return null ; } me . length ++ ; if ( sorted && this . getAutoSort ( ) ) { index = this . findInsertionIndex ( items , item ) ; } if ( index !== currentLength ) { this . dirtyIndices = true ; Ext . Array . splice ( keys , index , 0 , key ) ; Ext . Array . splice ( items , index , 0 , item ) ; } else { indices [ key ] = currentLength ; keys . push ( key ) ; items . push ( item ) ; } return item ; } 
function ( oldKey , item ) { var me = this , sorted = me . sorted , presorted = me . presorted , filtered = me . filtered , filterable = me . mixins . filterable , items = me . items , keys = me . keys , all = me . all , map = me . map , returnItem = null , oldItemsLn = items . length , subjectToOptimize = false , oldItem , index , newKey ; if ( arguments . length == 1 ) { item = oldKey ; oldKey = newKey = me . getKey ( item ) ; subjectToOptimize = true ; } else { newKey = me . getKey ( item ) ; } oldItem = map [ oldKey ] ; if ( typeof oldKey == 'undefined' || oldKey === null || typeof oldItem == 'undefined' ) { return me . add ( newKey , item ) ; } me . map [ newKey ] = item ; if ( newKey !== oldKey ) { delete me . map [ oldKey ] ; } if ( sorted && me . getAutoSort ( ) ) { if ( ! subjectToOptimize ) { Ext . Array . remove ( items , oldItem ) ; Ext . Array . remove ( keys , oldKey ) ; } else { var itemsFrom = items . indexOf ( oldItem ) ; } if ( ! presorted ) { Ext . Array . remove ( all , oldItem ) ; all . push ( item ) ; me . dirtyIndices = true ; } else { var allTo = this . findInsertionIndex ( all , item , undefined , true ) , allFrom = all . indexOf ( item ) ; if ( allTo !== allFrom ) { move ( all , allFrom , allTo ) ; me . dirtyIndices = true ; } } if ( filtered && me . getAutoFilter ( ) ) { 
function ( addItems ) { var me = this , filtered = me . filtered , sorted = me . sorted , all = me . all , items = me . items , keys = me . keys , map = me . map , autoFilter = me . getAutoFilter ( ) , autoSort = me . getAutoSort ( ) , newKeys = [ ] , newItems = [ ] , filterable = me . mixins . filterable , addedItems = [ ] , ln , key , i , item ; if ( Ext . isObject ( addItems ) ) { for ( key in addItems ) { if ( addItems . hasOwnProperty ( key ) ) { newItems . push ( items [ key ] ) ; newKeys . push ( key ) ; } } } else { newItems = addItems ; ln = addItems . length ; for ( i = 0 ; i < ln ; i ++ ) { newKeys . push ( me . getKey ( addItems [ i ] ) ) ; } } for ( i = 0 ; i < ln ; i ++ ) { key = newKeys [ i ] ; item = newItems [ i ] ; if ( typeof key != 'undefined' && key !== null ) { if ( typeof map [ key ] != 'undefined' ) { me . replace ( key , item ) ; continue ; } map [ key ] = item ; } all . push ( item ) ; if ( filtered && autoFilter && filterable . isFiltered . call ( me , item ) ) { continue ; } me . length ++ ; keys . push ( key ) ; items . push ( item ) ; addedItems . push ( item ) ; } if ( addedItems . length ) { me . dirtyIndices = true ; if ( sorted && autoSort ) { me . sort ( ) ; } return addedItems ; } return null ; } 
function ( fn , scope ) { var keys = this . keys , items = this . items , ln = keys . length , i ; for ( i = 0 ; i < ln ; i ++ ) { fn . call ( scope || window , keys [ i ] , items [ i ] , i , ln ) ; } } 
function ( fn , scope ) { var me = this , newCollection = new this . self ( ) , keys = me . keys , items = me . all , length = items . length , i ; newCollection . getKey = me . getKey ; for ( i = 0 ; i < length ; i ++ ) { if ( fn . call ( scope || me , items [ i ] , me . getKey ( items [ i ] ) ) ) { newCollection . add ( keys [ i ] , items [ i ] ) ; } } return newCollection ; } 
function ( index , key , item ) { var me = this , sorted = this . sorted , map = this . map , filtered = this . filtered ; if ( arguments . length == 2 ) { item = key ; key = me . getKey ( item ) ; } if ( index >= me . length || ( sorted && me . getAutoSort ( ) ) ) { return me . add ( key , item ) ; } if ( typeof key != 'undefined' && key !== null ) { if ( typeof map [ key ] != 'undefined' ) { me . replace ( key , item ) ; return false ; } map [ key ] = item ; } this . all . push ( item ) ; if ( filtered && this . getAutoFilter ( ) && this . mixins . filterable . isFiltered . call ( me , item ) ) { return null ; } me . length ++ ; Ext . Array . splice ( me . items , index , 0 , item ) ; Ext . Array . splice ( me . keys , index , 0 , key ) ; me . dirtyIndices = true ; return item ; } 
function ( item ) { var index = this . items . indexOf ( item ) ; if ( index === - 1 ) { Ext . Array . remove ( this . all , item ) ; if ( typeof this . getKey == 'function' ) { var key = this . getKey ( item ) ; if ( key !== undefined ) { delete this . map [ key ] ; } } return item ; } return this . removeAt ( this . items . indexOf ( item ) ) ; } 
function ( items ) { if ( items ) { var ln = items . length , i ; for ( i = 0 ; i < ln ; i ++ ) { this . remove ( items [ i ] ) ; } } return this ; } 
function ( index ) { var me = this , items = me . items , keys = me . keys , all = me . all , item , key ; if ( index < me . length && index >= 0 ) { item = items [ index ] ; key = keys [ index ] ; if ( typeof key != 'undefined' ) { delete me . map [ key ] ; } Ext . Array . erase ( items , index , 1 ) ; Ext . Array . erase ( keys , index , 1 ) ; Ext . Array . remove ( all , item ) ; delete me . indices [ key ] ; me . length -- ; this . dirtyIndices = true ; return item ; } return false ; } 
function ( item ) { if ( this . dirtyIndices ) { this . updateIndices ( ) ; } var index = item ? this . indices [ this . getKey ( item ) ] : - 1 ; return ( index === undefined ) ? - 1 : index ; } 
function ( key ) { var me = this , fromMap = me . map [ key ] , item ; if ( fromMap !== undefined ) { item = fromMap ; } else if ( typeof key == 'number' ) { item = me . items [ key ] ; } return typeof item != 'function' || me . getAllowFunctions ( ) ? item : null ; 
function ( item ) { var key = this . getKey ( item ) ; if ( key ) { return this . containsKey ( key ) ; } else { return Ext . Array . contains ( this . items , item ) ; } } 
function ( ) { var me = this ; me . length = 0 ; me . items . length = 0 ; me . keys . length = 0 ; me . all . length = 0 ; me . dirtyIndices = true ; me . indices = { } ; me . map = { } ; } 
function ( start , end ) { var me = this , items = me . items , range = [ ] , i ; if ( items . length < 1 ) { return range ; } start = start || 0 ; end = Math . min ( typeof end == 'undefined' ? me . length - 1 : end , me . length - 1 ) ; if ( start <= end ) { for ( i = start ; i <= end ; i ++ ) { range [ range . length ] = items [ i ] ; } } else { for ( i = start ; i >= end ; i -- ) { range [ range . length ] = items [ i ] ; } } return range ; } 
function ( fn , scope , start ) { var me = this , keys = me . keys , items = me . items , i = start || 0 , ln = items . length ; for ( ; i < ln ; i ++ ) { if ( fn . call ( scope || me , items [ i ] , keys [ i ] ) ) { return i ; } } return - 1 ; } 
function ( ) { var me = this , copy = new this . self ( ) , keys = me . keys , items = me . items , i = 0 , ln = items . length ; for ( ; i < ln ; i ++ ) { copy . add ( keys [ i ] , items [ i ] ) ; } copy . getKey = me . getKey ; return copy ; } 
function ( newMonthText , oldMonthText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; 
function ( newDayText , oldDayText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; 
function ( yearText ) { var innerItems = this . getInnerItems , ln = innerItems . length , item , i ; 
function ( ) { var me = this , slotOrder = me . getSlotOrder ( ) , yearsFrom = me . getYearFrom ( ) , yearsTo = me . getYearTo ( ) , years = [ ] , days = [ ] , months = [ ] , reverse = yearsFrom > yearsTo , ln , i , daysInMonth ; while ( yearsFrom ) { years . push ( { text : yearsFrom , value : yearsFrom } ) ; if ( yearsFrom === yearsTo ) { break ; } if ( reverse ) { yearsFrom -- ; } else { yearsFrom ++ ; } } daysInMonth = me . getDaysInMonth ( 1 , new Date ( ) . getFullYear ( ) ) ; for ( i = 0 ; i < daysInMonth ; i ++ ) { days . push ( { text : i + 1 , value : i + 1 } ) ; } for ( i = 0 , ln = Ext . Date . monthNames . length ; i < ln ; i ++ ) { months . push ( { text : Ext . Date . monthNames [ i ] , value : i + 1 } ) ; } var slots = [ ] ; slotOrder . forEach ( function ( item ) { slots . push ( me . createSlot ( item , days , months , years ) ) ; } ) ; me . setSlots ( slots ) ; } 
function ( name , days , months , years ) { switch ( name ) { case 'year' : return { name : 'year' , align : 'center' , data : years , title : this . getYearText ( ) , flex : 3 } ; case 'month' : return { name : name , align : 'right' , data : months , title : this . getMonthText ( ) , flex : 4 } ; case 'day' : return { name : 'day' , align : 'center' , data : days , title : this . getDayText ( ) , flex : 2 } ; } } 
function ( contact , options ) { this . messaging = options . messaging kademlia . RPC . call ( this , contact , options ) } 
function ( user ) { if ( user ) { if ( ! ! ~ this . roles . indexOf ( '*' ) ) { return true ; } else { for ( var userRoleIndex in user . roles ) { for ( var roleIndex in this . roles ) { if ( this . roles [ roleIndex ] === user . roles [ userRoleIndex ] ) { return true ; } } } } } else { return this . isPublic ; } return false ; } 
function ( oldLeft , oldTitle , reverse ) { var me = this , barElement = me . element , newLeftElement = me . leftBox . element , titleElement = me . titleComponent . element , minOffset = Math . min ( barElement . getWidth ( ) / 3 , 200 ) , newLeftWidth = newLeftElement . getWidth ( ) , barX = barElement . getX ( ) , barWidth = barElement . getWidth ( ) , titleX = titleElement . getX ( ) , titleLeft = titleElement . getLeft ( ) , titleWidth = titleElement . getWidth ( ) , oldLeftX = oldLeft . x , oldLeftWidth = oldLeft . width , oldLeftLeft = oldLeft . left , useLeft = Ext . browser . is . AndroidStock2 && ! this . getAndroid2Transforms ( ) , newOffset , oldOffset , leftAnims , titleAnims , omega , theta ; theta = barX - oldLeftX - oldLeftWidth ; if ( reverse ) { newOffset = theta ; oldOffset = Math . min ( titleX - oldLeftWidth , minOffset ) ; } else { oldOffset = theta ; newOffset = Math . min ( titleX - barX , minOffset ) ; } if ( useLeft ) { leftAnims = { element : { from : { left : newOffset , opacity : 1 } , to : { left : 0 , opacity : 1 } } } ; } else { leftAnims = { element : { from : { transform : { translateX : newOffset } , opacity : 0 } , to : { transform : { translateX : 0 } , opacity : 1 } } , ghost : { to : { transform : { translateX : oldOffset } , opacity : 0 } } } ; } theta = barX - titleX + newLeftWidth ; if ( ( oldLeftLeft + titleWidth ) > titleX ) { omega = barX - titleX - titleWidth ; } if ( reverse ) { titleElement . setLeft ( 0 ) ; oldOffset = barX + barWidth - titleX - titleWidth ; if ( omega !== undefined ) { newOffset = omega ; } else { newOffset = theta ; } } else { newOffset = barX + barWidth - titleX - titleWidth ; if ( omega !== undefined ) { oldOffset = omega ; } else { oldOffset = theta ; } newOffset = Math . max ( titleLeft , newOffset ) ; } if ( useLeft ) { titleAnims = { element : { from : { left : newOffset , opacity : 1 } , to : { left : titleLeft , opacity : 1 } } } ; } else { titleAnims = { element : { from : { transform : { translateX : newOffset } , opacity : 0 } , to : { transform : { translateX : titleLeft } , opacity : 1 } } , ghost : { to : { transform : { translateX : oldOffset } , opacity : 0 } } } ; } return { left : leftAnims , title : titleAnims , titleLeft : titleLeft } ; } 
function ( element , config , callback ) { var me = this , animation ; 
function ( ) { var text = this . backButtonStack [ this . backButtonStack . length - 2 ] , useTitleForBackButtonText = this . getUseTitleForBackButtonText ( ) ; if ( ! useTitleForBackButtonText ) { if ( text ) { text = this . getDefaultBackButtonText ( ) ; } } return text ; } 
function ( hidden ) { if ( ! hidden ) { this . element . setStyle ( { position : 'relative' , top : 'auto' , left : 'auto' , width : 'auto' } ) ; } else { this . element . setStyle ( { position : 'absolute' , top : '-1000px' , left : '-1000px' , width : this . element . getWidth ( ) + 'px' } ) ; } } 
function ( element ) { var ghost , x , y , left , width ; ghost = element . dom . cloneNode ( true ) ; ghost . id = element . id + '-proxy' ; 
function plugin ( options ) { options = options || { } ; options . key = options . key || 'untemplatized' ; return function ( files , metalsmith , done ) { setImmediate ( done ) ; Object . keys ( files ) . forEach ( function ( file ) { debug ( 'checking file: %s' , file ) ; var data = files [ file ] ; var contents = data . contents . toString ( ) . replace ( / ^\n+ / g , '' ) ; debug ( 'storing untemplatized content: %s' , file ) ; data [ options . key ] = new Buffer ( contents ) ; } ) ; } ; } 
function LatencyMetric ( ) { if ( ! ( this instanceof LatencyMetric ) ) { return new LatencyMetric ( ) } Metric . call ( this ) this . key = 'latency' this . default = [ 0 ] this . hooks = [ { trigger : 'before' , event : 'send' , handler : this . _start } , { trigger : 'before' , event : 'receive' , handler : this . _stop } ] this . _tests = { } setInterval ( this . _expireTimeouts . bind ( this ) , LatencyMetric . TEST_TIMEOUT ) } 
function decodeResult ( contentType , dataType , result ) { if ( dataType == 'json' ) { try { result = JSON . parse ( result ) ; return result ; } catch ( e ) { } } if ( contentType && contentType . indexOf ( 'application/json' ) == 0 ) { try { result = JSON . parse ( result ) ; } catch ( e ) { } } 
function defaultMapFn ( data ) { return Object . keys ( data ) . slice ( 0 , this . headers . length ) . map ( function ( key ) { return data [ key ] } ) } 
function scheduleJob ( trigger , jobFunc , jobData ) { const job = Job . createJob ( trigger , jobFunc , jobData ) ; const excuteTime = job . excuteTime ( ) ; const id = job . id ; map [ id ] = job ; const element = { id : id , time : excuteTime } ; const curJob = queue . peek ( ) ; if ( ! curJob || excuteTime < curJob . time ) { queue . offer ( element ) ; setTimer ( job ) ; return job . id ; } queue . offer ( element ) ; return job . id ; } 
function ( members ) { var member , name ; 
function ( members ) { var prototype = this . prototype , names = [ ] , name , member ; 
function ( members ) { var me = this , enumerables = Ext . enumerables , target = me . prototype , cloneFunction = Ext . Function . clone , currentConfig = target . config , name , index , member , statics , names , previous , newConfig , prop ; if ( arguments . length === 2 ) { name = members ; members = { } ; members [ name ] = arguments [ 1 ] ; enumerables = null ; } do { names = [ ] ; 
function ( name , mixinClass ) { var mixin = mixinClass . prototype , prototype = this . prototype , key ; if ( typeof mixin . onClassMixedIn != 'undefined' ) { mixin . onClassMixedIn . call ( mixinClass , this ) ; } if ( ! prototype . hasOwnProperty ( 'mixins' ) ) { if ( 'mixins' in prototype ) { prototype . mixins = Ext . Object . chain ( prototype . mixins ) ; } else { prototype . mixins = { } ; } } for ( key in mixin ) { if ( key === 'mixins' ) { Ext . merge ( prototype . mixins , mixin [ key ] ) ; } else if ( typeof prototype [ key ] == 'undefined' && key != 'mixinId' && key != 'config' ) { prototype [ key ] = mixin [ key ] ; } } 
function ( args ) { var callOverriddenFn = this . callOverridden || this . prototype . callOverridden , method = callOverriddenFn . caller , previousMethod = method && method . $previous ; if ( ! previousMethod ) { return method . $return ; } return previousMethod . apply ( this , args || noArgs ) ; } 
function ( instanceConfig ) { 
function defineType ( type , validator ) { var typeDef ; var regKey ; if ( type instanceof Function ) { validator = _customValidator ( type ) ; type = type . name ; 
function undefineType ( type ) { var validator ; var typeDef = parseTypeDef ( type ) ; var regKey = typeDef . name . toLocaleLowerCase ( ) ; if ( primitives [ regKey ] ) { throw TypeException ( 'Cannot undefine primitive type `{{type}}`' , null , null , { type : typeDef . name } ) ; } validator = registry [ regKey ] && registry [ regKey ] . validator ; delete registry [ regKey ] ; return validator || false ; } 
function checkType ( type , value , previous , attributeName ) { var typeDef = parseTypeDef ( type ) ; var regKey = typeDef . name . toLocaleLowerCase ( ) ; validator = primitives [ regKey ] || ( registry [ regKey ] && registry [ regKey ] . validator ) ; if ( ! validator ) { throw TypeException ( 'Unknown type `{{type}}`' , null , [ attributeName ] , { type : typeDef . name } ) ; } else if ( typeDef . indexes ) { return arrayValidation ( typeDef , 0 , value , previous , attributeName , validator ) ; } return validator ( value , previous , attributeName ) ; } 
function getDefinedNames ( ) { return Object . keys ( primitives ) . concat ( Object . keys ( registry ) . map ( function ( type ) { return registry [ type ] . type ; } ) ) ; } 
function arrayValidation ( typeDef , index , value , previous , attributeName , validator ) { var indexInc ; var i ; var ilen ; if ( value === null || value === undefined || typeDef . indexes . length <= index ) { 
function ( comment ) { const isLicense = comment . toLowerCase ( ) . includes ( "license" ) || comment . toLowerCase ( ) . includes ( "copyright" ) ; if ( isLicense === false ) { return false ; } if ( lastLicense !== comment ) { lastLicense = comment ; return true ; } else { return false ; } } 
function ctor ( k , v ) { if ( k && _ . isString ( k ) && k . indexOf ( 'paths.' ) === 0 ) return get . apply ( null , _ . toArray ( arguments ) ) return v ? set ( k , v ) : get ( k ) } 
function get ( k ) { if ( ! k ) return _SETTINGS let v = _ . get ( _SETTINGS , k ) if ( ! v ) return if ( _ . isString ( k ) && k . indexOf ( 'paths.' ) !== 0 ) return v let args = _ . drop ( _ . toArray ( arguments ) ) let argsLength = args . unshift ( v ) return path . join . apply ( path , args ) } 
function set ( k , v ) { let curr = get ( k ) if ( curr && _ . isPlainObject ( curr ) && _ . isPlainObject ( v ) ) v = _ . mcopy ( curr , v ) if ( k ) _ . set ( _SETTINGS , k , v ) if ( ! k ) _SETTINGS = v return get ( k ) } 
function load ( src ) { if ( ! src || ! _ . isString ( src ) ) return let file = _ . attempt ( require , src ) if ( ! file || _ . isError ( file ) || ! _ . isPlainObject ( file ) ) return return _ . merge ( _SETTINGS , file ) } 
function SipFakeStack ( config ) { if ( ! config . server ) { throw '(SipFakeStack) You need at least to specify a valid IPv4/6 target' ; } this . server = config . server || null ; this . port = config . port || 5060 ; this . transport = config . transport || 'UDP' ; 
function ( size , units ) { 
function ( box ) { if ( typeof box != 'string' ) { box = box . toString ( ) ; } var parts = box . split ( ' ' ) , ln = parts . length ; if ( ln == 1 ) { parts [ 1 ] = parts [ 2 ] = parts [ 3 ] = parts [ 0 ] ; } else if ( ln == 2 ) { parts [ 2 ] = parts [ 0 ] ; parts [ 3 ] = parts [ 1 ] ; } else if ( ln == 3 ) { parts [ 3 ] = parts [ 1 ] ; } return { top : parts [ 0 ] || 0 , right : parts [ 1 ] || 0 , bottom : parts [ 2 ] || 0 , left : parts [ 3 ] || 0 } ; } 
function ( box , units ) { var me = this ; box = me . parseBox ( box ) ; return me . addUnits ( box . top , units ) + ' ' + me . addUnits ( box . right , units ) + ' ' + me . addUnits ( box . bottom , units ) + ' ' + me . addUnits ( box . left , units ) ; } 
function ( form ) { var fElements = form . elements || ( document . forms [ form ] || Ext . getDom ( form ) ) . elements , hasSubmit = false , encoder = encodeURIComponent , name , data = '' , type , hasValue ; Ext . each ( fElements , function ( element ) { name = element . name ; type = element . type ; if ( ! element . disabled && name ) { if ( / select-(one|multiple) / i . test ( type ) ) { Ext . each ( element . options , function ( opt ) { if ( opt . selected ) { hasValue = opt . hasAttribute ? opt . hasAttribute ( 'value' ) : opt . getAttributeNode ( 'value' ) . specified ; data += Ext . String . format ( "{0}={1}&" , encoder ( name ) , encoder ( hasValue ? opt . value : opt . text ) ) ; } } ) ; } else if ( ! ( / file|undefined|reset|button / i . test ( type ) ) ) { if ( ! ( / radio|checkbox / i . test ( type ) && ! element . checked ) && ! ( type == 'submit' && hasSubmit ) ) { data += encoder ( name ) + '=' + encoder ( element . value ) + '&' ; hasSubmit = / submit / i . test ( type ) ; } } } } ) ; return data . substr ( 0 , data . length - 1 ) ; } 
function ( ) { 
function ( ) { 
function ( el , config ) { config = config || { } ; Ext . apply ( this , config ) ; this . addEvents ( 'sortstart' , 'sortend' , 'sortchange' 
function ( ) { this . el . on ( this . startEventName , this . onStart , this , { delegate : this . itemSelector , holdThreshold : this . getDelay ( ) } ) ; this . disabled = false ; } 
function msum ( arr , W , options ) { var copy = true , clbk , len , sum , dropVal , out , i ; if ( ! isArray ( arr ) ) { throw new TypeError ( 'msum()::invalid input argument. Must provide an array. Value: `' + arr + '`.' ) ; } if ( ! isPositiveInteger ( W ) ) { throw new TypeError ( 'msum()::invalid input argument. Window must be a positive integer. Value: `' + W + '`.' ) ; } if ( arguments . length > 2 ) { if ( ! isObject ( options ) ) { throw new TypeError ( 'msum()::invalid input argument. Options must be an object. Value: `' + options + '`.' ) ; } if ( options . hasOwnProperty ( 'accessor' ) ) { clbk = options . accessor ; if ( ! isFunction ( clbk ) ) { throw new TypeError ( 'msum()::invalid option. Accessor option must be a function. Value: `' + clbk + '`.' ) ; } } if ( options . hasOwnProperty ( 'copy' ) ) { copy = options . copy ; if ( ! isBoolean ( copy ) ) { throw new TypeError ( 'msum()::invalid option. Copy option must be a boolean primitive. Value: `' + copy + '`.' ) ; } } } if ( W > arr . length ) { throw new Error ( 'msum()::invalid input argument. Window cannot exceed the array length.' ) ; } len = arr . length ; sum = 0 ; if ( copy && ! clbk ) { 
function Request ( ghosttrain , route , url , options ) { 
function _compareMaps ( a , b , options ) { debug ( a , b ) ; let alength = a . size === undefined ? a . length : a . size ; let blength = b . size === undefined ? b . length : b . size ; if ( alength === 0 && blength === 0 ) return ops . NOP ; 
function compare ( a , b , options ) { debug ( 'compare %j,%j options: %j' , a , b , options ) ; options = Options . addDefaults ( options ) ; debug ( 'compare - options %j' , options ) ; if ( a === b ) return ops . NOP ; if ( b === undefined ) return ops . DEL ; if ( a === undefined ) return new ops . Rpl ( b ) ; if ( typeof a === 'object' && typeof b === 'object' ) { if ( utils . isArrayLike ( a ) && utils . isArrayLike ( b ) ) { if ( options . map ) { return _compareMaps ( a , b , options ) ; } else { return _compareArrays ( a , b , options ) ; } } else if ( a instanceof Map && b instanceof Map ) { return _compareMaps ( a , b , options ) ; } else if ( a . constructor === b . constructor ) { 
function fromJSON ( object ) { if ( object instanceof ops . Op ) return object ; 
function ( sorterFn ) { var me = this , items = me . items , keys = me . keys , length = items . length , temp = [ ] , i ; 
function ( mapping ) { var me = this , items = me . items , index = 0 , length = items . length , order = [ ] , remaining = [ ] , oldIndex ; me . suspendEvents ( ) ; 
function transpose ( mat , options ) { var strides , shape , opts , ctor , err , tmp , d ; if ( ! isMatrixLike ( mat ) ) { throw new TypeError ( 'transpose()::invalid input argument. First argument must be a matrix. Value: `' + mat + '`.' ) ; } opts = { } ; if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } else { opts . copy = true ; } if ( opts . copy ) { 
function Queue ( q ) { events . EventEmitter . call ( this ) ; var self = this ; this . q = q && q . process ? q : kue . createQueue ( ) ; this . q . process ( 'message' , function ( message , done ) { self . emit ( 'message' , message ) ; done ( ) ; } ) ; } 
function apply ( func , args , self ) { return ( typeof func === 'function' ) ? func . apply ( self , array ( args ) ) : func } 
function detectDeviceClass ( ) { var body = document . body ; if ( isMobile . any ( ) ) { body . classList . add ( 'mobile' ) ; } if ( isMobile . Android ( ) ) { body . classList . add ( 'android' ) ; } if ( isTablet . any ( ) ) { body . classList . add ( 'tablet' ) ; } } 
function detectWindowWidth ( ) { var mobileWidth = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 730 ; var isMobileWidth = window . innerWidth < mobileWidth ; var body = document . body ; if ( isMobileWidth ) { body . classList . add ( 'is-mobile-width' ) ; } else { body . classList . remove ( 'is-mobile-width' ) ; } } 
function ( config , callback , scope ) { var changed = false ; if ( config ) { config . config_id = 'csv' ; Ext . data . CSV . superclass . constructor . call ( this , config ) ; if ( config . v ) { this . v = [ ] ; this . do_add ( config . v ) ; } } if ( this . v === undefined ) { this . v = [ ] ; changed = true ; } this . writeAndCallback ( changed , callback , scope ) ; } 
function addVirtualRef ( schema , node , path ) { if ( _ . isArray ( node ) && isRef ( _ . first ( node ) ) ) { schema . virtual ( path + 'P' ) . get ( function ( ) { if ( ! this [ path ] || ! this [ path ] . length ) return Promise . resolve ( [ ] ) ; var model = this . constructor . db . model ( _ . first ( node ) . ref ) ; return findAsync . call ( model , { $or : _ . map ( this [ path ] , function ( id ) { return { _id : id } ; } ) } ) ; } ) ; } else if ( isRef ( node ) ) { schema . virtual ( path + 'P' ) . get ( function ( ) { var model = this . constructor . db . model ( node . ref ) ; return findByIdAsync . call ( model , this [ path ] ) ; } ) ; } } 
function createTopic ( options ) { var max = Number . MAX_VALUE , duplicates = false ; if ( ! options . hasOwnProperty ( 'max' ) ) { options . max = max ; } else { max = options . max ; } if ( ! options . hasOwnProperty ( 'duplicates' ) ) { options . duplicates = duplicates ; } else { duplicates = options . duplicates ; } if ( ! isInteger ( max ) || max < 0 ) { throw new TypeError ( 'createTopic()::invalid option. Max subscribers must be an integer greater than or equal to 0.' ) ; } if ( typeof duplicates !== 'boolean' ) { throw new TypeError ( 'createTopic()::invalid option. Duplicates flag must be a boolean.' ) ; } return { 'subscribers' : [ ] , 'options' : options } ; } 
function loadModule ( data , name ) { if ( typeof data !== 'object' ) { return ; } 
function ( data ) { if ( data && jQuery . trim ( data ) ) { 
function ( elems , fn , key , value , chainable , emptyGet , raw ) { var i = 0 , length = elems . length , bulk = key == null ; 
function ( iteratee , events , name , callback , opts ) { var i = 0 , names ; if ( name && typeof name === 'object' ) { 
function ( array , insert , at ) { at = Math . min ( Math . max ( at , 0 ) , array . length ) ; var tail = Array ( array . length - at ) ; var length = insert . length ; for ( var i = 0 ; i < tail . length ; i ++ ) tail [ i ] = array [ i + at ] ; for ( i = 0 ; i < length ; i ++ ) array [ i + at ] = insert [ i ] ; for ( i = 0 ; i < tail . length ; i ++ ) array [ i + length + at ] = tail [ i ] ; } 
function ( models , options ) { options = _ . extend ( { } , options ) ; var singular = ! _ . isArray ( models ) ; models = singular ? [ models ] : _ . clone ( models ) ; var removed = this . _removeModels ( models , options ) ; if ( ! options . silent && removed ) this . trigger ( 'update' , this , options ) ; return singular ? removed [ 0 ] : removed ; } 
function ( models , options ) { var removed = [ ] ; for ( var i = 0 ; i < models . length ; i ++ ) { var model = this . get ( models [ i ] ) ; if ( ! model ) continue ; var index = this . indexOf ( model ) ; this . models . splice ( index , 1 ) ; this . length -- ; if ( ! options . silent ) { options . index = index ; model . trigger ( 'remove' , model , this , options ) ; } removed . push ( model ) ; this . _removeReference ( model , options ) ; } return removed . length ? removed : false ; } 
function ( ) { var path = this . decodeFragment ( this . location . pathname ) ; var root = path . slice ( 0 , this . root . length - 1 ) + '/' ; return root === this . root ; } 
function ( ) { if ( ! performanceTimelineRequiresSort ) { return ; } 
function getTemplateData ( templateProp , view , viewOptions ) { var data ; if ( templateProp && _ . isString ( templateProp ) ) { data = templateCache [ templateProp ] ; if ( ! data ) data = _createTemplateCache ( templateProp , view , viewOptions ) ; if ( data . invalid ) data = undefined ; if ( data ) data = _copyCacheEntry ( data ) ; } return data ; } 
function getViewTemplateData ( view , viewOptions ) { var data , meta = view . declarativeViews . meta ; if ( ! meta . processed ) { if ( view . template && _ . isString ( view . template ) ) { meta . originalTemplateProp = view . template ; data = getTemplateData ( view . template , view , viewOptions ) ; meta . processed = true ; meta . inGlobalCache = true ; if ( data ) events . trigger ( "cacheEntry:view:process" , _copyCacheEntry ( data ) , meta . originalTemplateProp , view , viewOptions ) ; } else { data = undefined ; meta . processed = true ; meta . inGlobalCache = false ; } } else { data = meta . inGlobalCache ? getTemplateData ( meta . originalTemplateProp , view , viewOptions ) : undefined ; } if ( data ) events . trigger ( "cacheEntry:view:fetch" , data , meta . originalTemplateProp , view , viewOptions ) ; return data ; } 
function clearCache ( fromMarionette ) { templateCache = { } ; if ( ! fromMarionette && Backbone . Marionette && Backbone . Marionette . TemplateCache ) Backbone . Marionette . TemplateCache . clear ( ) ; } 
function clearCachedTemplate ( templateProp ) { var fromMarionette = false , args = _ . toArray ( arguments ) , lastArg = _ . last ( args ) ; 
function clearViewTemplateCache ( view ) { var meta = view . declarativeViews . meta ; if ( meta . processed ) { if ( meta . inGlobalCache ) _clearCachedTemplate ( meta . originalTemplateProp ) ; } else if ( view . template && _ . isString ( view . template ) ) { _clearCachedTemplate ( view . template ) ; } } 
function loadTemplate ( templateProperty ) { var $template ; try { $template = $ ( templateProperty ) ; 
function _wrapRawTemplate ( templateString ) { var $wrapper = $ ( "<script />" ) . attr ( "type" , "text/x-template" ) . text ( templateString ) , elDataAttributes = _getEmbeddedElAttributes ( templateString ) ; if ( elDataAttributes ) $wrapper . attr ( elDataAttributes ) ; return $wrapper ; } 
function _getEmbeddedElAttributes ( templateString ) { var elDataAttributes = { } , elDefinitionMatch = rxElDefinitionComment . exec ( templateString ) , elDefinitionComment = elDefinitionMatch && elDefinitionMatch [ 0 ] ; if ( elDefinitionComment ) { _ . each ( rxRegisteredDataAttributes , function ( rxAttributeMatcher , attributeName ) { var match = rxAttributeMatcher . exec ( elDefinitionComment ) , attributeValue = match && match [ 2 ] ; if ( attributeValue ) elDataAttributes [ attributeName ] = attributeValue ; } ) ; } return _ . size ( elDataAttributes ) ? elDataAttributes : undefined ; } 
function _copyCacheEntry ( cacheEntry ) { var copy = _ . clone ( cacheEntry ) ; if ( _ . isObject ( copy . attributes ) ) copy . attributes = _ . clone ( copy . attributes ) ; return copy ; } 
function _createTemplateCache ( templateProp , view , viewOptions ) { var $template , data , html , customLoader = Backbone . DeclarativeViews . custom . loadTemplate , defaultLoader = Backbone . DeclarativeViews . defaults . loadTemplate , modifiedDefaultLoader = defaultLoader !== loadTemplate , cacheId = templateProp ; 
function _tryCompileTemplate ( html , $template ) { var compiled , customCompiler = Backbone . DeclarativeViews . custom . compiler ; if ( customCompiler ) { if ( customCompiler && ! _ . isFunction ( customCompiler ) ) throw new CustomizationError ( "Invalid custom template compiler set in Backbone.DeclarativeViews.custom.compiler: compiler is not a function" ) ; try { compiled = customCompiler ( html , $template ) ; } catch ( err ) { throw new CompilerError ( 'An error occurred while compiling the template. The compiler had been passed the HTML string "' + html + ( $template ? '" as the first argument, and the corresponding template node, wrapped in a jQuery object, as the second argument.' : '" as the only argument.' ) + "\nOriginal error thrown by the compiler:\n" + err . message ) ; } } return compiled ; } 
function _registerDataAttribute ( name , options ) { var existingNames = _getRegisteredDataAttributeNames ( ) , fullName = "data-" + name , type = options && options . isJSON ? "json" : "primitives" , names = registeredDataAttributes [ type ] ; if ( name . indexOf ( "data-" ) === 0 ) throw new CustomizationError ( 'registerDataAttribute(): Illegal attribute name "' + name + '", must be registered without "data-" prefix' ) ; if ( name === "html" || name === "compiled" ) throw new CustomizationError ( 'registerDataAttribute(): Cannot register attribute name "' + name + '" because it is reserved' ) ; if ( _ . contains ( existingNames , name ) ) throw new CustomizationError ( 'registerDataAttribute(): Cannot register attribute name "' + name + '" because it has already been registered' ) ; 
function _updateJQueryDataCache ( $elem ) { var add = { } , remove = [ ] ; if ( $ . hasData ( $elem [ 0 ] ) ) { 
function _registerCacheAlias ( namespaceObject , instanceCachePropertyName ) { namespaceObject . getCachedTemplate = Backbone . DeclarativeViews . getCachedTemplate ; namespaceObject . clearCachedTemplate = Backbone . DeclarativeViews . clearCachedTemplate ; namespaceObject . clearCache = Backbone . DeclarativeViews . clearCache ; namespaceObject . custom = Backbone . DeclarativeViews . custom ; if ( instanceCachePropertyName ) { instanceCacheAliases . push ( instanceCachePropertyName ) ; instanceCacheAliases = _ . unique ( instanceCacheAliases ) ; } } 
function _isDeclarativeViewsErrorType ( error ) { return error instanceof GenericError || error instanceof TemplateError || error instanceof CompilerError || error instanceof CustomizationError || error instanceof ConfigurationError ; } 
function joinMarionette ( ) { if ( Backbone . Marionette && Backbone . Marionette . TemplateCache && ! isMarionetteInitialized ) { originalClearCache = Backbone . Marionette . TemplateCache . clear ; 
function createCustomErrorType ( name ) { function CustomError ( message ) { this . message = message ; if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , this . constructor ) ; } else { this . stack = ( new Error ( ) ) . stack ; } } CustomError . prototype = new Error ( ) ; CustomError . prototype . name = name ; CustomError . prototype . constructor = CustomError ; return CustomError ; } 
function ( name ) { var config = this . _wreqrHandlers [ name ] ; if ( ! config ) { return ; } return function ( ) { return config . callback . apply ( config . context , arguments ) ; } ; } 
function ( name ) { name = arguments [ 0 ] ; var args = _ . rest ( arguments ) ; if ( this . hasHandler ( name ) ) { this . getHandler ( name ) . apply ( this , args ) ; } else { this . storage . addCommand ( name , args ) ; } } 
function ( type , hash , context ) { if ( ! hash ) { return ; } context = context || this ; var method = type === "vent" ? "on" : "setHandler" ; _ . each ( hash , function ( fn , eventName ) { this [ type ] [ method ] ( eventName , _ . bind ( fn , context ) ) ; } , this ) ; } 
function triggerDOMRefresh ( ) { if ( view . _isShown && view . _isRendered && Marionette . isNodeAttached ( view . el ) ) { Marionette . triggerMethodOn ( view , 'dom:refresh' , view ) ; } } 
function iterateEvents ( target , entity , bindings , functionCallback , stringCallback ) { if ( ! entity || ! bindings ) { return ; } 
function ( callback , contextOverride ) { var promise = _ . result ( this . _deferred , 'promise' ) ; this . _callbacks . push ( { cb : callback , ctx : contextOverride } ) ; promise . then ( function ( args ) { if ( contextOverride ) { args . context = contextOverride ; } callback . call ( args . context , args . options ) ; } ) ; } 
function ( view , options ) { if ( ! this . _ensureElement ( ) ) { return ; } this . _ensureViewIsIntact ( view ) ; Marionette . MonitorDOMRefresh ( view ) ; var showOptions = options || { } ; var isDifferentView = view !== this . currentView ; var preventDestroy = ! ! showOptions . preventDestroy ; var forceShow = ! ! showOptions . forceShow ; 
function ( options ) { var view = this . currentView ; var emptyOptions = options || { } ; var preventDestroy = ! ! emptyOptions . preventDestroy ; 
function ( ) { var view = this . currentView ; if ( view . isDestroyed ) { return ; } if ( ! view . supportsDestroyLifecycle ) { Marionette . triggerMethodOn ( view , 'before:destroy' , view ) ; } if ( view . destroy ) { view . destroy ( ) ; } else { view . remove ( ) ; 
function ( regionConfig , DefaultRegionClass ) { if ( _ . isString ( regionConfig ) ) { return this . _buildRegionFromSelector ( regionConfig , DefaultRegionClass ) ; } if ( regionConfig . selector || regionConfig . el || regionConfig . regionClass ) { return this . _buildRegionFromObject ( regionConfig , DefaultRegionClass ) ; } if ( _ . isFunction ( regionConfig ) ) { return this . _buildRegionFromRegionClass ( regionConfig ) ; } throw new Marionette . Error ( { message : 'Improper region configuration type.' , url : 'marionette.region.html#region-configuration-types' } ) ; } 
function ( regionConfig , DefaultRegionClass ) { var RegionClass = regionConfig . regionClass || DefaultRegionClass ; var options = _ . omit ( regionConfig , 'selector' , 'regionClass' ) ; if ( regionConfig . selector && ! options . el ) { options . el = regionConfig . selector ; } return new RegionClass ( options ) ; } 
function ( regionDefinitions , defaults ) { regionDefinitions = Marionette . _getValue ( regionDefinitions , this , arguments ) ; return _ . reduce ( regionDefinitions , function ( regions , definition , name ) { if ( _ . isString ( definition ) ) { definition = { selector : definition } ; } if ( definition . selector ) { definition = _ . defaults ( { } , definition , defaults ) ; } regions [ name ] = this . addRegion ( name , definition ) ; return regions ; } , { } , this ) ; } 
function ( name , definition ) { var region ; if ( definition instanceof Marionette . Region ) { region = definition ; } else { region = Marionette . Region . buildRegion ( definition , Marionette . Region ) ; } this . triggerMethod ( 'before:add:region' , name , region ) ; region . _parent = this ; this . _store ( name , region ) ; this . triggerMethod ( 'add:region' , name , region ) ; return region ; } 
function ( ) { var regions = this . getRegions ( ) ; _ . each ( this . _regions , function ( region , name ) { this . _remove ( name , region ) ; } , this ) ; return regions ; } 
function ( name , region ) { this . triggerMethod ( 'before:remove:region' , name , region ) ; region . empty ( ) ; region . stopListening ( ) ; delete region . _parent ; delete this . _regions [ name ] ; this . length -- ; this . triggerMethod ( 'remove:region' , name , region ) ; } 
function ( templateId , options ) { var cachedTemplate = this . templateCaches [ templateId ] ; if ( ! cachedTemplate ) { cachedTemplate = new Marionette . TemplateCache ( templateId ) ; this . templateCaches [ templateId ] = cachedTemplate ; } return cachedTemplate . load ( options ) ; } 
function ( ) { var i ; var args = _ . toArray ( arguments ) ; var length = args . length ; if ( length > 0 ) { for ( i = 0 ; i < length ; i ++ ) { delete this . templateCaches [ args [ i ] ] ; } } else { this . templateCaches = { } ; } } 
function ( options ) { 
function ( templateId , options ) { var $template = Backbone . $ ( templateId ) ; if ( ! $template . length ) { throw new Marionette . Error ( { name : 'NoTemplateError' , message : 'Could not find template: "' + templateId + '"' } ) ; } return $template . html ( ) ; } 
function ( template , data ) { if ( ! template ) { throw new Marionette . Error ( { name : 'TemplateNotFoundError' , message : 'Cannot render the template since its false, null or undefined.' } ) ; } var templateFunc = _ . isFunction ( template ) ? template : Marionette . TemplateCache . get ( template ) ; return templateFunc ( data ) ; } 
function ( target ) { target = target || { } ; var templateHelpers = this . getOption ( 'templateHelpers' ) ; templateHelpers = Marionette . _getValue ( templateHelpers , this ) ; return _ . extend ( target , templateHelpers ) ; } 
function ( hash ) { var uiBindings = _ . result ( this , '_uiBindings' ) ; return Marionette . normalizeUIKeys ( hash , uiBindings || _ . result ( this , 'ui' ) ) ; } 
function ( hash , properties ) { var ui = _ . result ( this , 'ui' ) ; var uiBindings = _ . result ( this , '_uiBindings' ) ; return Marionette . normalizeUIValues ( hash , uiBindings || ui , properties ) ; } 
function ( ) { if ( ! this . triggers ) { return ; } 
function ( events ) { this . _delegateDOMEvents ( events ) ; this . bindEntityEvents ( this . model , this . getOption ( 'modelEvents' ) ) ; this . bindEntityEvents ( this . collection , this . getOption ( 'collectionEvents' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . bindEntityEvents ( this . model , behavior . getOption ( 'modelEvents' ) ) ; behavior . bindEntityEvents ( this . collection , behavior . getOption ( 'collectionEvents' ) ) ; } , this ) ; return this ; } 
function ( eventsArg ) { var events = Marionette . _getValue ( eventsArg || this . events , this ) ; 
function ( ) { Backbone . View . prototype . undelegateEvents . apply ( this , arguments ) ; this . unbindEntityEvents ( this . model , this . getOption ( 'modelEvents' ) ) ; this . unbindEntityEvents ( this . collection , this . getOption ( 'collectionEvents' ) ) ; _ . each ( this . _behaviors , function ( behavior ) { behavior . unbindEntityEvents ( this . model , behavior . getOption ( 'modelEvents' ) ) ; behavior . unbindEntityEvents ( this . collection , behavior . getOption ( 'collectionEvents' ) ) ; } , this ) ; return this ; } 
function ( ) { if ( this . isDestroyed ) { return this ; } var args = _ . toArray ( arguments ) ; this . triggerMethod . apply ( this , [ 'before:destroy' ] . concat ( args ) ) ; 
function ( ) { if ( ! this . ui ) { return ; } 
function ( triggerDef ) { var options = _ . defaults ( { } , triggerDef , { preventDefault : true , stopPropagation : true } ) ; var eventName = _ . isObject ( triggerDef ) ? options . event : triggerDef ; return function ( e ) { if ( e ) { if ( e . preventDefault && options . preventDefault ) { e . preventDefault ( ) ; } if ( e . stopPropagation && options . stopPropagation ) { e . stopPropagation ( ) ; } } var args = { view : this , model : this . model , collection : this . collection } ; this . triggerMethod ( eventName , args ) ; } ; } 
function ( ) { var ret = Marionette . _triggerMethod ( this , arguments ) ; this . _triggerEventOnBehaviors ( arguments ) ; this . _triggerEventOnParentLayout ( arguments [ 0 ] , _ . rest ( arguments ) ) ; return ret ; } 
function ( ) { var children = this . _getImmediateChildren ( ) ; if ( ! children . length ) { return children ; } return _ . reduce ( children , function ( memo , view ) { if ( ! view . _getNestedViews ) { return memo ; } return memo . concat ( view . _getNestedViews ( ) ) ; } , children ) ; } 
function ( ) { var parent = this . _parent ; while ( parent ) { if ( parent instanceof Marionette . LayoutView ) { return parent ; } parent = parent . _parent ; } } 
function ( ) { if ( ! this . model && ! this . collection ) { return { } ; } var args = [ this . model || this . collection ] ; if ( arguments . length ) { args . push . apply ( args , arguments ) ; } if ( this . model ) { return this . serializeModel . apply ( this , args ) ; } else { return { items : this . serializeCollection . apply ( this , args ) } ; } } 
function ( ) { var template = this . getTemplate ( ) ; 
function ( options ) { this . once ( 'render' , this . _initialEvents ) ; this . _initChildViewStorage ( ) ; Marionette . View . apply ( this , arguments ) ; this . on ( { 'before:show' : this . _onBeforeShowCalled , 'show' : this . _onShowCalled , 'before:attach' : this . _onBeforeAttachCalled , 'attach' : this . _onAttachCalled } ) ; this . initRenderBuffer ( ) ; } 
function ( ) { if ( this . collection ) { this . listenTo ( this . collection , 'add' , this . _onCollectionAdd ) ; this . listenTo ( this . collection , 'remove' , this . _onCollectionRemove ) ; this . listenTo ( this . collection , 'reset' , this . render ) ; if ( this . getOption ( 'sort' ) ) { this . listenTo ( this . collection , 'sort' , this . _sortViews ) ; } } } 
function ( child , collection , opts ) { 
function ( ) { var children = this . children ; var models = this . _filteredSortedModels ( ) ; if ( ! models . length && this . _showingEmptyView ) { return this ; } var anyModelsAdded = _ . some ( models , function ( model ) { return ! children . findByModel ( model ) ; } ) ; 
function ( ) { var models = this . _filteredSortedModels ( ) ; 
function ( ) { this . destroyEmptyView ( ) ; this . destroyChildren ( { checkEmpty : false } ) ; if ( this . isEmpty ( this . collection ) ) { this . showEmptyView ( ) ; } else { this . triggerMethod ( 'before:render:collection' , this ) ; this . startBuffering ( ) ; this . showCollection ( ) ; this . endBuffering ( ) ; this . triggerMethod ( 'render:collection' , this ) ; 
function ( ) { var ChildView ; var models = this . _filteredSortedModels ( ) ; _ . each ( models , function ( child , index ) { ChildView = this . getChildView ( child ) ; this . addChild ( child , ChildView , index ) ; } , this ) ; } 
function ( addedAt ) { var viewComparator = this . getViewComparator ( ) ; var models = this . collection . models ; addedAt = Math . min ( Math . max ( addedAt , 0 ) , models . length - 1 ) ; if ( viewComparator ) { var addedModel ; 
function ( ) { var EmptyView = this . getEmptyView ( ) ; if ( EmptyView && ! this . _showingEmptyView ) { this . triggerMethod ( 'before:render:empty' ) ; this . _showingEmptyView = true ; var model = new Backbone . Model ( ) ; this . addEmptyView ( model , EmptyView ) ; this . triggerMethod ( 'render:empty' ) ; } } 
function ( child , EmptyView ) { 
function ( child , ChildView , index ) { var childViewOptions = this . getOption ( 'childViewOptions' ) ; childViewOptions = Marionette . _getValue ( childViewOptions , this , [ child , index ] ) ; var view = this . buildChildView ( child , ChildView , childViewOptions ) ; 
function ( view , increment , index ) { if ( ! this . getOption ( 'sort' ) ) { return ; } if ( increment ) { 
function ( view , index ) { 
function ( view , index ) { if ( ! view . supportsRenderLifecycle ) { Marionette . triggerMethodOn ( view , 'before:render' , view ) ; } view . render ( ) ; if ( ! view . supportsRenderLifecycle ) { Marionette . triggerMethodOn ( view , 'render' , view ) ; } this . attachHtml ( this , view , index ) ; return view ; } 
function ( child , ChildViewClass , childViewOptions ) { var options = _ . extend ( { model : child } , childViewOptions ) ; var childView = new ChildViewClass ( options ) ; Marionette . MonitorDOMRefresh ( childView ) ; return childView ; } 
function ( view ) { if ( ! view ) { return view ; } this . triggerMethod ( 'before:remove:child' , view ) ; if ( ! view . supportsDestroyLifecycle ) { Marionette . triggerMethodOn ( view , 'before:destroy' , view ) ; } 
function ( ) { var elBuffer = document . createDocumentFragment ( ) ; _ . each ( this . _bufferedChildren , function ( b ) { elBuffer . appendChild ( b . el ) ; } ) ; return elBuffer ; } 
function ( collectionView , childView , index ) { if ( collectionView . isBuffering ) { 
function ( childView , index ) { var currentView ; var findPosition = this . getOption ( 'sort' ) && ( index < this . children . length - 1 ) ; if ( findPosition ) { 
function ( ) { if ( this . isDestroyed ) { return this ; } this . triggerMethod ( 'before:destroy:collection' ) ; this . destroyChildren ( { checkEmpty : false } ) ; this . triggerMethod ( 'destroy:collection' ) ; return Marionette . View . prototype . destroy . apply ( this , arguments ) ; } 
function ( options ) { var destroyOptions = options || { } ; var shouldCheckEmpty = true ; var childViews = this . children . map ( _ . identity ) ; if ( ! _ . isUndefined ( destroyOptions . checkEmpty ) ) { shouldCheckEmpty = destroyOptions . checkEmpty ; } this . children . each ( this . removeChildView , this ) ; if ( shouldCheckEmpty ) { this . checkEmpty ( ) ; } return childViews ; } 
function ( child , index ) { var filter = this . getOption ( 'filter' ) ; return ! _ . isFunction ( filter ) || filter . call ( this , child , index , this . collection ) ; } 
function ( view ) { var prefix = this . getOption ( 'childViewEventPrefix' ) ; 
function ( ) { 
function ( ) { var data = { } ; if ( this . model ) { data = _ . partial ( this . serializeModel , this . model ) . apply ( this , arguments ) ; } return data ; } 
function ( ) { this . _ensureViewIsIntact ( ) ; this . _isRendering = true ; this . resetChildViewContainer ( ) ; this . triggerMethod ( 'before:render' , this ) ; this . _renderTemplate ( ) ; this . _renderChildren ( ) ; this . _isRendering = false ; this . isRendered = true ; this . triggerMethod ( 'render' , this ) ; return this ; } 
function ( ) { var data = { } ; data = this . serializeData ( ) ; data = this . mixinTemplateHelpers ( data ) ; this . triggerMethod ( 'before:render:template' ) ; var template = this . getTemplate ( ) ; var html = Marionette . Renderer . render ( template , data , this ) ; this . attachElContent ( html ) ; 
function ( containerView , childView ) { if ( ! ! containerView . $childViewContainer ) { return containerView . $childViewContainer ; } var container ; var childViewContainer = Marionette . getOption ( containerView , 'childViewContainer' ) ; if ( childViewContainer ) { var selector = Marionette . _getValue ( childViewContainer , containerView ) ; if ( selector . charAt ( 0 ) === '@' && containerView . ui ) { container = containerView . ui [ selector . substr ( 4 ) ] ; } else { container = containerView . $ ( selector ) ; } if ( container . length <= 0 ) { throw new Marionette . Error ( { name : 'ChildViewContainerMissingError' , message : 'The specified "childViewContainer" was not found: ' + containerView . childViewContainer } ) ; } } else { container = containerView . $el ; } containerView . $childViewContainer = container ; return container ; } 
function ( options ) { options = options || { } ; this . _firstRender = true ; this . _initializeRegions ( options ) ; Marionette . ItemView . call ( this , options ) ; } 
function ( ) { this . _ensureViewIsIntact ( ) ; if ( this . _firstRender ) { 
function ( ) { if ( this . isDestroyed ) { return this ; } 
function ( regions ) { var defaults = { regionClass : this . getOption ( 'regionClass' ) , parentEl : _ . partial ( _ . result , this , 'el' ) } ; return this . regionManager . addRegions ( regions , defaults ) ; } 
function ( options ) { var regions ; this . _initRegionManager ( ) ; regions = Marionette . _getValue ( this . regions , this , [ options ] ) || { } ; 
function ( ) { this . regionManager = this . getRegionManager ( ) ; this . regionManager . _parent = this ; this . listenTo ( this . regionManager , 'before:add:region' , function ( name ) { this . triggerMethod ( 'before:add:region' , name ) ; } ) ; this . listenTo ( this . regionManager , 'add:region' , function ( name , region ) { this [ name ] = region ; this . triggerMethod ( 'add:region' , name , region ) ; } ) ; this . listenTo ( this . regionManager , 'before:remove:region' , function ( name ) { this . triggerMethod ( 'before:remove:region' , name ) ; } ) ; this . listenTo ( this . regionManager , 'remove:region' , function ( name , region ) { delete this [ name ] ; this . triggerMethod ( 'remove:region' , name , region ) ; } ) ; } 
function ( options , key ) { if ( options . behaviorClass ) { return options . behaviorClass ; } 
function ( view , behaviors ) { return _ . chain ( behaviors ) . map ( function ( options , key ) { var BehaviorClass = Behaviors . getBehaviorClass ( options , key ) ; var behavior = new BehaviorClass ( options , view ) ; var nestedBehaviors = Behaviors . parseBehaviors ( view , _ . result ( behavior , 'behaviors' ) ) ; return [ behavior ] . concat ( nestedBehaviors ) ; } ) . flatten ( ) . value ( ) ; } 
function ( view , behaviors , methodNames ) { _ . each ( methodNames , function ( methodName ) { view [ methodName ] = _ . partial ( methods [ methodName ] , view [ methodName ] , behaviors ) ; } ) ; } 
function ( behavior , i ) { var triggersHash = _ . clone ( _ . result ( behavior , 'triggers' ) ) || { } ; triggersHash = Marionette . normalizeUIKeys ( triggersHash , getBehaviorsUI ( behavior ) ) ; _ . each ( triggersHash , _ . bind ( this . _setHandlerForBehavior , this , behavior , i ) ) ; } 
function ( behavior , i , eventName , trigger ) { 
function ( routeName , routeArgs ) { 
function ( moduleNames , moduleDefinition ) { 
function ( options ) { var regions = _ . isFunction ( this . regions ) ? this . regions ( options ) : this . regions || { } ; this . _initRegionManager ( ) ; 
function ( ) { this . _regionManager = this . getRegionManager ( ) ; this . _regionManager . _parent = this ; this . listenTo ( this . _regionManager , 'before:add:region' , function ( ) { Marionette . _triggerMethod ( this , 'before:add:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'add:region' , function ( name , region ) { this [ name ] = region ; Marionette . _triggerMethod ( this , 'add:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'before:remove:region' , function ( ) { Marionette . _triggerMethod ( this , 'before:remove:region' , arguments ) ; } ) ; this . listenTo ( this . _regionManager , 'remove:region' , function ( name ) { delete this [ name ] ; Marionette . _triggerMethod ( this , 'remove:region' , arguments ) ; } ) ; } 
function ( ) { this . channelName = _ . result ( this , 'channelName' ) || 'global' ; this . channel = _ . result ( this , 'channel' ) || Backbone . Wreqr . radio . channel ( this . channelName ) ; this . vent = _ . result ( this , 'vent' ) || this . channel . vent ; this . commands = _ . result ( this , 'commands' ) || this . channel . commands ; this . reqres = _ . result ( this , 'reqres' ) || this . channel . reqres ; } 
function ( ) { 
function ( definition , customArgs ) { 
function ( app , moduleNames , moduleDefinition ) { var module = app ; 
function ( moduleDefinition ) { var ModuleClass = Marionette . Module ; if ( ! moduleDefinition ) { return ModuleClass ; } 
function ( parentModule , module , def , args ) { var fn = this . _getDefine ( def ) ; var startWithParent = this . _getStartWithParent ( def , module ) ; if ( fn ) { module . addDefinition ( fn , args ) ; } this . _addStartWithParent ( parentModule , module , startWithParent ) ; } 
function _sigName ( src ) { if ( ! _ . isFunction ( src ) ) return '' let ret = _ . trim ( _ . replace ( src . toString ( ) , 'function' , '' ) ) ret = ret . substr ( 0 , ret . indexOf ( '(' ) ) return ret || '' } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem#requestFileSystem: You must specify a `success` callback.' ) ; return null ; } var me = this ; var successCallback = function ( fs ) { var fileSystem = Ext . create ( 'Ext.device.filesystem.FileSystem' , fs ) ; config . success . call ( config . scope || me , fileSystem ) ; } ; window . requestFileSystem ( config . type , config . size , successCallback , config . failure || Ext . emptyFn ) ; } 
function ( ) { var components = this . path . split ( '/' ) ; for ( var i = components . length - 1 ; i >= 0 ; -- i ) { if ( components [ i ] . length > 0 ) { return components [ i ] ; } } return '/' ; } 
function ( config ) { if ( config . parent == null ) { Ext . Logger . error ( 'Ext.device.filesystem.Entry#moveTo: You must specify a new `parent` of the entry.' ) ; return null ; } var me = this ; this . getEntry ( { options : config . options || { } , success : function ( sourceEntry ) { config . parent . getEntry ( { options : config . options || { } , success : function ( destinationEntry ) { if ( config . copy ) { sourceEntry . copyTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } else { sourceEntry . moveTo ( destinationEntry , config . newName , function ( entry ) { config . success . call ( config . scope || me , entry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entry . fullPath , me . fileSystem ) ) ; } , config . failure ) ; } } , failure : config . failure } ) ; } , failure : config . failure } ) ; } 
function ( config ) { this . getEntry ( { success : function ( entry ) { if ( config . recursively && this . directory ) { entry . removeRecursively ( config . success , config . failure ) } else { entry . remove ( config . success , config . failure ) } } , failure : config . failure } ) } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem.Entry#getParent: You must specify a `success` callback.' ) ; return null ; } var me = this ; this . getEntry ( { options : config . options || { } , success : function ( entry ) { entry . getParent ( function ( parentEntry ) { config . success . call ( config . scope || me , parentEntry . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , parentEntry . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , parentEntry . fullPath , me . fileSystem ) ) } , config . failure ) } , failure : config . failure } ) } 
function ( config ) { var me = this ; var callback = config . success ; if ( ( config . options && config . options . create ) && this . path ) { var folders = this . path . split ( "/" ) ; if ( folders [ 0 ] == '.' || folders [ 0 ] == '' ) { folders = folders . slice ( 1 ) ; } var recursiveCreation = function ( dirEntry ) { if ( folders . length ) { dirEntry . getDirectory ( folders . shift ( ) , config . options , recursiveCreation , config . failure ) ; } else { callback ( dirEntry ) ; } } ; recursiveCreation ( this . fileSystem . fs . root ) ; } else { this . fileSystem . fs . root . getDirectory ( this . path , config . options , function ( directory ) { config . success . call ( config . scope || me , directory ) ; } , config . failure ) ; } } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem.DirectoryEntry#readEntries: You must specify a `success` callback.' ) ; return null ; } var me = this ; this . getEntry ( { success : function ( dirEntry ) { var directoryReader = dirEntry . createReader ( ) ; directoryReader . readEntries ( function ( entryInfos ) { var entries = [ ] , i = 0 , len = entryInfos . length ; for ( ; i < len ; i ++ ) { entryInfo = entryInfos [ i ] ; entries [ i ] = entryInfo . isDirectory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entryInfo . fullPath , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entryInfo . fullPath , me . fileSystem ) ; } config . success . call ( config . scope || this , entries ) ; } , function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } ) ; } , failure : config . failure } ) ; } 
function ( config ) { if ( config . path == null ) { Ext . Logger . error ( 'Ext.device.filesystem.DirectoryEntry#getFile: You must specify a `path` of the file.' ) ; return null ; } var me = this ; var fullPath = this . path + config . path ; var directoryEntry = Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , fullPath , this . fileSystem ) ; directoryEntry . getEntry ( { success : function ( ) { config . success . call ( config . scope || me , directoryEntry ) ; } , options : config . options || { } , failure : config . failure } ) } 
function ( config ) { var me = this ; var originalConfig = Ext . applyIf ( { } , config ) ; if ( this . fileSystem ) { var failure = function ( evt ) { if ( ( config . options && config . options . create ) && Ext . isString ( this . path ) ) { var folders = this . path . split ( "/" ) ; if ( folders [ 0 ] == '.' || folders [ 0 ] == '' ) { folders = folders . slice ( 1 ) ; } if ( folders . length > 1 && ! config . recursive === true ) { folders . pop ( ) ; var dirEntry = Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , folders . join ( "/" ) , me . fileSystem ) ; dirEntry . getEntry ( { options : config . options , success : function ( ) { originalConfig . recursive = true ; me . getEntry ( originalConfig ) ; } , failure : config . failure } ) ; } else { if ( config . failure ) { config . failure . call ( config . scope || me , evt ) ; } } } else { if ( config . failure ) { config . failure . call ( config . scope || me , evt ) ; } } } ; this . fileSystem . fs . root . getFile ( this . path , config . options || null , function ( fileEntry ) { fileEntry . file ( function ( file ) { me . length = file . size ; originalConfig . success . call ( config . scope || me , fileEntry ) ; } , function ( error ) { failure . call ( config . scope || me , error ) ; } ) ; } , function ( error ) { failure . call ( config . scope || me , error ) ; } ) ; } else { config . failure ( { code : - 1 , message : "FileSystem not Initialized" } ) ; } } 
function ( config ) { if ( config . offset == null ) { Ext . Logger . error ( 'Ext.device.filesystem.FileEntry#seek: You must specify an `offset` in the file.' ) ; return null ; } this . offset = config . offset || 0 ; if ( config . success ) { config . success . call ( config . scope || this ) ; } } 
function ( config ) { var me = this ; this . getEntry ( { success : function ( fileEntry ) { fileEntry . file ( function ( file ) { if ( Ext . isNumber ( config . length ) ) { if ( Ext . isFunction ( file . slice ) ) { file = file . slice ( me . offset , config . length ) ; } else { if ( config . failure ) { config . failure . call ( config . scope || me , { code : - 2 , message : "File missing slice functionality" } ) ; } return ; } } var reader = new FileReader ( ) ; reader . onloadend = function ( evt ) { config . success . call ( config . scope || me , evt . target . result ) ; } ; reader . onerror = function ( error ) { config . failure . call ( config . scope || me , error ) ; } ; if ( config . reader ) { reader = Ext . applyIf ( reader , config . reader ) ; } config . encoding = config . encoding || "UTF8" ; switch ( config . type ) { default : case "text" : reader . readAsText ( file , config . encoding ) ; break ; case "dataURL" : reader . readAsDataURL ( file ) ; break ; case "binaryString" : reader . readAsBinaryString ( file ) ; break ; case "arrayBuffer" : reader . readAsArrayBuffer ( file ) ; break ; } } , function ( error ) { config . failure . call ( config . scope || me , error ) } ) ; } , failure : function ( error ) { config . failure . call ( config . scope || me , error ) } } ) } 
function ( config ) { if ( config . size == null ) { Ext . Logger . error ( 'Ext.device.filesystem.FileEntry#write: You must specify a `size` of the file.' ) ; return null ; } var me = this ; 
function ( obj ) { const keys = _ . sortBy ( _ . keys ( obj ) , function ( key ) { return key ; } ) ; return _ . zipObject ( keys , _ . map ( keys , function ( key ) { return obj [ key ] ; } ) ) ; } 
function ( err ) { if ( err ) return done ( err ) ; var ret ; if ( typeof leave == 'function' ) { try { ret = leave . call ( this , child , parent ) ; } catch ( err ) { return done ( err ) ; } } done ( null , ret ) ; } 
function MultiKeyCache ( options ) { options = options || { } ; var self = this ; var dispose = options . dispose ; options . dispose = function ( key , value ) { self . _dispose ( key ) ; if ( dispose ) { dispose ( key , value ) ; } } ; this . cache = new LRU ( options ) ; this . _keyMap = { } ; } 
function curry ( len , f ) { for ( var _len = arguments . length , initArgs = Array ( _len > 2 ? _len - 2 : 0 ) , _key = 2 ; _key < _len ; _key ++ ) { initArgs [ _key - 2 ] = arguments [ _key ] ; } var _ref = function ( ) { switch ( true ) { case _extractHiddenClass ( len ) === 'Function' : var args = f == null ? [ ] : [ f ] . concat ( initArgs ) ; return [ len , len . length , args ] ; case _extractHiddenClass ( len ) === 'Number' : return [ f , len , initArgs ] ; default : throw new TypeError ( 'Unrecognized arguments ' + len + ' and ' + f + ' to function curry.' ) ; } } ( ) , _ref2 = _slicedToArray ( _ref , 3 ) , fn = _ref2 [ 0 ] , arity = _ref2 [ 1 ] , fnArgs = _ref2 [ 2 ] ; if ( ! fn ) { return function ( fn ) { for ( var _len2 = arguments . length , args = Array ( _len2 > 1 ? _len2 - 1 : 0 ) , _key2 = 1 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 - 1 ] = arguments [ _key2 ] ; } return curry . apply ( this , [ arity , fn ] . concat ( args ) ) ; } ; } var helper = function helper ( args ) { return function ( ) { for ( var _len3 = arguments . length , rest = Array ( _len3 ) , _key3 = 0 ; _key3 < _len3 ; _key3 ++ ) { rest [ _key3 ] = arguments [ _key3 ] ; } return currier . call ( this , arity , fn , [ ] . concat ( _toConsumableArray ( args ) , rest ) ) ; } ; } ; var currier = function currier ( length , f , args ) { if ( args . length >= length ) { 
function debounce ( n , immed , f ) { var _ref3 = function ( ) { switch ( _extractHiddenClass ( immed ) ) { case 'Boolean' : return [ f , immed ] ; case 'Function' : return [ immed , false ] ; default : throw new TypeError ( 'Unrecognized arguments ' + immed + ' and ' + f + ' to function debounce.' ) ; } } ( ) , _ref4 = _slicedToArray ( _ref3 , 2 ) , fn = _ref4 [ 0 ] , now = _ref4 [ 1 ] ; var timer = null ; return function ( ) { var _this = this ; for ( var _len4 = arguments . length , args = Array ( _len4 ) , _key4 = 0 ; _key4 < _len4 ; _key4 ++ ) { args [ _key4 ] = arguments [ _key4 ] ; } if ( timer === null && now ) { fn . apply ( this , args ) ; } clearTimeout ( timer ) ; timer = setTimeout ( function ( ) { return fn . apply ( _this , args ) ; } , n ) ; return timer ; } ; } 
function pipe ( ) { for ( var _len6 = arguments . length , fs = Array ( _len6 ) , _key6 = 0 ; _key6 < _len6 ; _key6 ++ ) { fs [ _key6 ] = arguments [ _key6 ] ; } return function ( ) { var _this3 = this ; var first = fs . shift ( ) ; for ( var _len7 = arguments . length , args = Array ( _len7 ) , _key7 = 0 ; _key7 < _len7 ; _key7 ++ ) { args [ _key7 ] = arguments [ _key7 ] ; } return fs . reduce ( function ( acc , f ) { return f . call ( _this3 , acc ) ; } , first . apply ( this , args ) ) ; } ; } 
function denodeify ( fn ) { var length = fn . length > 0 ? fn . length - 1 : 0 ; var f = function f ( ) { var _this4 = this ; for ( var _len8 = arguments . length , args = Array ( _len8 ) , _key8 = 0 ; _key8 < _len8 ; _key8 ++ ) { args [ _key8 ] = arguments [ _key8 ] ; } return new Promise ( function ( resolve , reject ) { fn . apply ( _this4 , [ ] . concat ( args , [ function ( err ) { for ( var _len9 = arguments . length , rest = Array ( _len9 > 1 ? _len9 - 1 : 0 ) , _key9 = 1 ; _key9 < _len9 ; _key9 ++ ) { rest [ _key9 - 1 ] = arguments [ _key9 ] ; } if ( err ) { reject ( err ) ; } var result = void 0 ; switch ( rest . length ) { case 0 : result = true ; break ; case 1 : result = rest [ 0 ] ; break ; default : result = rest ; break ; } resolve ( result ) ; } ] ) ) ; } ) ; } ; return length ? curry ( length , f ) : f ; } 
function trampoline ( fn ) { return curry ( fn . length , function ( ) { for ( var _len10 = arguments . length , args = Array ( _len10 ) , _key10 = 0 ; _key10 < _len10 ; _key10 ++ ) { args [ _key10 ] = arguments [ _key10 ] ; } var result = fn . apply ( this , args ) ; while ( _extractHiddenClass ( result ) === 'Function' ) { result = result ( ) ; } return result ; } ) ; } 
function ( options , listeners ) { var me = this , params = options . params , useBatch = me . getBatchActions ( ) , model = me . getModel ( ) , batch , records ; if ( options . operations === undefined ) { 
function createRawHtml ( createTemplateFn , templateLanguage , elCommentConfig , dataAttributes ) { 
function createComplexTemplate ( templateLanguage , options ) { var t = getTemplateLanguageConstructs ( templateLanguage ) , indent = options && options . indentation || "" , insert = options && options . insertion || "" , lines = [ '<!-- top-level comment (single line) -->' , '<!--' , ' top-level' , ' comment' , ' (multi-line)' , '-->' , t . if , '<p>This is a %%paragraph' , 'Some random %%text&& with different line breaks.<br><br/><br />' , t . else , '<h1 class="header">This is a %%header&&</h1> ' , t . endIf , t . if , '</p>' , t . endIf , insert , 'Some top-level %%text&&, not wrapped in a tag.<br><br/><br />' , '<!-- comment containing a <div> tag -->' , "<" + "script>alert( 'foo' );</" + "script>" , '<p class="significantWhitespaceExpected">' , ' some text </p>' , '<%%tagName&& %%attrs&&>lorem ipsum</%%tagName&&>' , '<p><h1>Invalid nesting</h1></p>' , t . partial , '<dl class="%%dl_class&&">' , ' ' + t . loop , ' <dt class="dtclass">%%dd_name&&</dt>' , ' <dd class="ddclass">%%dd_content&&</dd>' , ' ' + t . endLoop , '</dl>' ] , innerContent = _ . map ( lines , function ( line ) { return indent + line ; } ) . join ( "\n" ) ; return innerContent . replace ( / %% / g , t . startDelimiter ) . replace ( / && / g , t . endDelimiter ) ; } 
function getTemplateLanguageConstructs ( templateLanguage ) { var constructs ; switch ( templateLanguage . toLowerCase ( ) ) { case "handlebars" : constructs = { startDelimiter : "{{" , endDelimiter : "}}" , if : "{{#if isActive}}" , else : "{{else}}" , endIf : "{{/if}}" , loop : "{{#each looped as |value index|}}" , endLoop : "{{/each}}" , partial : '{{> userMessage tagName="h2" }}' } ; break ; case "ejs" : constructs = { startDelimiter : "<%= " , endDelimiter : " %>" , if : "<% if (isActive) { %>" , else : "<% } else { %>" , endIf : "<% } %>" , loop : "<% looped.forEach(function(item) { %>" , endLoop : "<% }); %>" , partial : "<%- include('user/show', {user: user}); %>" } ; break ; case "es6" : constructs = { startDelimiter : "${" , endDelimiter : "}" , if : "" , else : "" , endIf : "" , loop : "" , endLoop : "" , partial : "" } ; break ; default : throw new Error ( 'Unsupported template language "' + templateLanguage + '"' ) ; } return constructs ; } 
function defineModel ( modelType , options ) { var primaryAttributes ; var attributes ; var prototype ; var staticProto ; var ModelConstructor ; var typeName ; var namespace ; if ( types . isValidType ( modelType ) . indexes ) { throw ModelException ( 'Model type cannot be an array `{{type}}`' , null , null , { type : String ( modelType ) } ) ; } else if ( models [ modelType ] ) { throw ModelException ( 'Model already defined `{{type}}`' , null , null , { type : String ( modelType ) } ) ; } options = options || { } ; primaryAttributes = [ ] ; namespace = _getNamespace ( modelType ) ; typeName = _getTypeName ( modelType ) ; attributes = _prepareAttributes ( options . attributes || { } , primaryAttributes ) ; prototype = _preparePrototype ( options . methods || { } , primaryAttributes , modelType , namespace , typeName ) ; staticProto = _prepareStaticProto ( options . staticMethods || { } , primaryAttributes , options . attributes , prototype . _type ) ; ModelConstructor = Function ( 'Model, events, attributes' , 'return function ' + typeName + 'Model(data) { ' + 'if (!(this instanceof ' + typeName + 'Model)){' + 'return new ' + typeName + 'Model(data);' + '}' + ( attributes ? 'Object.defineProperties(this, attributes);' : '' ) + 'events.emit("create", data);' + 'Model.call(this, data);' + ' }' ) ( Model , events , attributes ) ; util . inherits ( ModelConstructor , Model ) ; Object . defineProperties ( ModelConstructor . prototype , prototype ) ; Object . defineProperties ( ModelConstructor , staticProto ) ; if ( ! types . isDefined ( modelType ) ) { types . define ( modelType , options . typeValidator || _modelTypeValidator ( ModelConstructor ) ) ; } 
function Model ( data ) { var attributes = this . __proto__ . constructor . attributes ; var i , ilen ; var dirty = false ; Object . defineProperties ( this , { _id : { configurable : false , enumerable : true , writable : false , value : ++ uniqueId } , _isDirty : { configurable : false , enumerable : true , get : function isDirty ( ) { return dirty ; } , set : function isDirty ( d ) { dirty = d ; if ( ! d && this . _previousData ) { this . _previousData = undefined ; } } } , _isNew : { configurable : false , enumerable : true , get : function isNewModel ( ) { var newModel = false ; var attrValue ; if ( this . _primaryAttributes ) { for ( i = 0 , ilen = this . _primaryAttributes . length ; i < ilen && ! newModel ; ++ i ) { attrValue = this [ this . _primaryAttributes [ i ] ] ; if ( ( attrValue === undefined ) || ( attrValue === null ) ) { newModel = true ; } } } return newModel ; } } } ) ; if ( attributes ) { Object . defineProperties ( this , attributes ) ; Object . defineProperty ( this , '_data' , { configurable : false , enumerable : false , writable : false , value : _defaultData ( attributes ) } ) ; } if ( Array . isArray ( data ) ) { for ( i = 0 , ilen = data . length ; i < ilen ; ++ i ) { if ( this . _primaryAttributes [ i ] ) { this [ this . _primaryAttributes [ i ] ] = data [ i ] ; } } } else if ( data ) { this . fromJSON ( data ) ; } this . _isDirty = false ; 
function Point ( masterApikey , feedID , streamID ) { this . masterApiKey = masterApikey ; this . feedID = feedID . toString ( ) ; this . streamID = streamID . toString ( ) ; } 
function ( value , len , word ) { if ( value && value . length > len ) { if ( word ) { var vs = value . substr ( 0 , len - 2 ) , index = Math . max ( vs . lastIndexOf ( ' ' ) , vs . lastIndexOf ( '.' ) , vs . lastIndexOf ( '!' ) , vs . lastIndexOf ( '?' ) ) ; if ( index != - 1 && index >= ( len - 15 ) ) { return vs . substr ( 0 , index ) + "..." ; } } return value . substr ( 0 , len - 3 ) + "..." ; } return value ; } 
function ( val , size , ch ) { var result = String ( val ) ; ch = ch || " " ; while ( result . length < size ) { result = ch + result ; } return result ; } 
function ( format ) { var args = Ext . toArray ( arguments , 1 ) ; return format . replace ( Ext . util . Format . formatRe , function ( m , i ) { return args [ i ] ; } ) ; } 
function ( value ) { return ! value ? value : String ( value ) . replace ( / & / g , "&amp;" ) . replace ( / > / g , "&gt;" ) . replace ( / < / g , "&lt;" ) . replace ( / " / g , "&quot;" ) ; } 
function ( value , format ) { var date = value ; if ( ! value ) { return "" ; } if ( ! Ext . isDate ( value ) ) { date = new Date ( Date . parse ( value ) ) ; if ( isNaN ( date ) ) { * This code is modified from the following source: <https: *  2011 Colin Snover <http: * Released under MIT license. */ var potentialUndefinedKeys = [ 1 , 4 , 5 , 6 , 7 , 10 , 11 ] ; var dateParsed , minutesOffset = 0 ; 
function ( tabBar , newTab ) { var oldActiveItem = this . getActiveItem ( ) , newActiveItem ; this . setActiveItem ( tabBar . indexOf ( newTab ) ) ; newActiveItem = this . getActiveItem ( ) ; return this . forcedChange || oldActiveItem !== newActiveItem ; } 
function ( config ) { if ( config === true ) { config = { } ; } if ( config ) { Ext . applyIf ( config , { ui : this . getUi ( ) , docked : this . getTabBarPosition ( ) } ) ; } return Ext . factory ( config , Ext . tab . Bar , this . getTabBar ( ) ) ; } 
function ( point1 , point2 ) { var Point = Ext . util . Point ; this . point1 = Point . from ( point1 ) ; this . point2 = Point . from ( point2 ) ; } 
function ( lineSegment ) { var point1 = this . point1 , point2 = this . point2 , point3 = lineSegment . point1 , point4 = lineSegment . point2 , x1 = point1 . x , x2 = point2 . x , x3 = point3 . x , x4 = point4 . x , y1 = point1 . y , y2 = point2 . y , y3 = point3 . y , y4 = point4 . y , d = ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 ) , xi , yi ; if ( d == 0 ) { return null ; } xi = ( ( x3 - x4 ) * ( x1 * y2 - y1 * x2 ) - ( x1 - x2 ) * ( x3 * y4 - y3 * x4 ) ) / d ; yi = ( ( y3 - y4 ) * ( x1 * y2 - y1 * x2 ) - ( y1 - y2 ) * ( x3 * y4 - y3 * x4 ) ) / d ; if ( xi < Math . min ( x1 , x2 ) || xi > Math . max ( x1 , x2 ) || xi < Math . min ( x3 , x4 ) || xi > Math . max ( x3 , x4 ) || yi < Math . min ( y1 , y2 ) || yi > Math . max ( y1 , y2 ) || yi < Math . min ( y3 , y4 ) || yi > Math . max ( y3 , y4 ) ) { return null ; } return new Ext . util . Point ( xi , yi ) ; } 
function functionName ( fcn ) { var name ; if ( ! isFunction ( fcn ) ) { throw new TypeError ( 'invalid input argument. Must provide a function. Value: `' + fcn + '`.' ) ; } if ( isString ( fcn . name ) ) { name = fcn . name ; } else { name = RE . exec ( fcn . toString ( ) ) [ 1 ] ; } return ( name === '' ) ? 'anonymous' : name ; } 
function ( ) { 
function SteroidsSocket ( options ) { var finalTarget ; if ( options . target && net . isIPv6 ( options . target ) ) { finalTarget = normalize6 ( options . target ) ; } else { finalTarget = options . target ; } this . target = finalTarget ; this . port = options . port || 80 ; this . transport = options . transport || 'TCP' ; this . lport = options . lport || null ; this . timeout = options . timeout || 8000 ; this . allowHalfOpen = options . allowHalfOpen || null ; this . wsProto = options . wsProto || 'sip' ; this . wsPath = options . wsPath || null ; 
function timeoutCb ( ) { if ( ! received ) { self . emit ( 'error' , { type : 'socket: timeout' , data : 'Connection problem: No response' } ) ; } 
function realWidth ( str ) { if ( str == null ) return 0 ; str = stripANSI ( str ) ; return str . length + ( stripEmoji ( str ) . match ( / [^\x00-\xff] / g ) || [ ] ) . length ; } 
function PC ( source , config ) { if ( source == null ) return ; this . config = { prefix : '' , suffix : '' , placeholder : ' ' , columnSeparation : ' ' , rowSeparation : "\n" , rowSplitSymbol : "\n" , columnSplitSymbol : "\t" } ; this . _STATS = { originalSource : source , source : null , formatted : null , rows : 0 , columns : 0 , maxWidth : [ ] , width : [ ] , align : [ ] } ; this . params ( config ) ; this . parseSource ( ) ; this . AnalyticAlignment ( ) ; this . format ( ) ; } 
function ( source , destination ) { gulp . src ( source ) . pipe ( conflict ( destination ) ) . pipe ( gulp . dest ( destination ) ) ; } 
function ( source , destination , context , opts ) { if ( ! opts ) opts = { force : true } ; this . mkdirP ( destination ) ; var files = fs . readdirSync ( source ) ; for ( var i = 0 ; i < files . length ; i ++ ) { var sourceFile = path . join ( source , files [ i ] ) ; var destinationFile = path . join ( destination , files [ i ] ) ; if ( this . isDirectory ( sourceFile ) ) { this . templateDirSync ( sourceFile , destinationFile , context , opts ) ; } else { if ( fs . existsSync ( destinationFile ) && ! opts . force ) { console . log ( 'skipping existing file: ' + files [ i ] ) ; } else { this . templateFileSync ( sourceFile , destinationFile , context ) ; } } } } 
function ( source , destination , context ) { 
function ( source , destination ) { if ( ! fs . existsSync ( destination ) ) mkdir ( '-p' , destination ) ; cp ( '-R' , source , destination ) ; } 
function ( tracker , propList ) { var trackingData = tracker [ trackingKeyName ] ; propList . forEach ( function ( name ) { Object . defineProperty ( tracker , name , { enumerable : true , configurable : true , get : function ( ) { return trackingData . object [ name ] ; } , set : function ( x ) { trackingData . actions . push ( { key : name , set : x , } ) ; trackingData . object [ name ] = x ; } , } ) ; } ) ; } 
function ( tracker , methodList ) { var trackingData = tracker [ trackingKeyName ] ; methodList . forEach ( function ( name ) { tracker [ name ] = function ( ) { var context = this ; var argsArray = Array . prototype . slice . call ( arguments ) ; 
function ( object ) { var propList = [ ] ; var methodList = [ ] ; for ( var k in object ) { if ( typeof object [ k ] === "function" ) { methodList . push ( k ) ; } else { propList . push ( k ) ; } } return { propList : propList , methodList : methodList , } ; } 
function ( config , callback , scope ) { 
function ( content ) { content = trim ( content ) ; if ( this . mounted ) { invoke ( this , [ Constants . BLOCK , 'setMountedContent' ] , content ) ; } else { dom . contentNode ( this ) . innerHTML = content ; this . upgrade ( ) ; } } 
function ( ) { const props = dom . attrs . toObject ( this ) ; const xprops = this . xprops ; const eprops = get ( xtag , [ 'tags' , this [ Constants . TAGNAME ] , 'accessors' ] , { } ) ; for ( let prop in eprops ) { if ( xprops . hasOwnProperty ( prop ) && eprops . hasOwnProperty ( prop ) && ! BLOCK_COMMON_ACCESSORS . hasOwnProperty ( prop ) ) { props [ prop ] = this [ prop ] ; } } dom . attrs . typeConversion ( props , xprops ) ; return props ; } 
function ( deep ) { 
function blockInit ( node ) { if ( ! node [ Constants . TAGNAME ] ) { node [ Constants . INSERTED ] = false ; node [ Constants . TAGNAME ] = node . tagName . toLowerCase ( ) ; node [ Constants . TMPL ] = { } ; node [ Constants . UID ] = uniqueId ( ) ; return true ; } return false ; } 
function blockCreate ( node ) { if ( node . hasChildNodes ( ) ) { Array . prototype . forEach . call ( node . querySelectorAll ( 'script[type="text/x-template"][ref],template[ref]' ) , tmplCompileIterator , node ) ; } node [ Constants . BLOCK ] = new XBElement ( node ) ; } 
function mergeCustomizer ( objValue , srcValue , key ) { if ( isArray ( objValue ) ) { return objValue . concat ( srcValue ) ; } if ( key === 'lifecycle' ) { return mergeWith ( objValue , srcValue , lifecycleCustomizer ) ; } if ( key === 'events' ) { return mergeWith ( objValue , srcValue , eventsCustomizer ) ; } if ( key === 'accessors' ) { return mergeWith ( objValue , srcValue , accessorsCustomizer ) ; } if ( key === 'methods' ) { checkOverriddenMethods ( objValue , srcValue ) ; } } 
function accessorsCustomizer ( objValue , srcValue ) { const objSetter = get ( objValue , 'set' ) ; const srcSetter = get ( srcValue , 'set' ) ; return merge ( { } , objValue , srcValue , { set : wrap ( objSetter , wrap ( srcSetter , wrapperFunction ) ) } ) ; } 
function wrapperEvents ( srcFunc , objFunc , ... args ) { const event = ( args [ 0 ] instanceof Event ) && args [ 0 ] ; const isStopped = event ? ( ) => event . immediatePropagationStopped : stubFalse ; if ( ! isStopped ( ) && isFunction ( objFunc ) ) { objFunc . apply ( this , args ) ; } if ( ! isStopped ( ) && isFunction ( srcFunc ) ) { srcFunc . apply ( this , args ) ; } } 
function accessorsIterator ( options , name , accessors ) { const optionsSetter = get ( options , 'set' ) ; const updateSetter = wrap ( name , wrapperAccessorsSetUpdate ) ; accessors [ name ] = merge ( { } , options , { set : wrap ( optionsSetter , wrap ( updateSetter , wrapperFunction ) ) } ) ; } 
function wrapperAccessorsSetUpdate ( accessorName , nextValue , prevValue ) { if ( nextValue !== prevValue && this . xprops . hasOwnProperty ( accessorName ) && this . mounted ) { this [ Constants . BLOCK ] . update ( ) ; } } 
function lifecycleRemoved ( ) { this [ Constants . INSERTED ] = false ; const block = this [ Constants . BLOCK ] ; if ( block ) { block . destroy ( ) ; this [ Constants . BLOCK ] = undefined ; } } 
function lifecycleInserted ( ) { if ( this [ Constants . INSERTED ] ) { return ; } blockInit ( this ) ; this [ Constants . INSERTED ] = true ; const isScriptContent = Boolean ( this . querySelector ( 'script' ) ) ; 
function ( obj , removeProp ) { var newObj = { } ; for ( var prop in obj ) { if ( ! obj . hasOwnProperty ( prop ) || prop === removeProp ) { continue ; } newObj [ prop ] = obj [ prop ] ; } return newObj ; } 
function readFileContent ( conn , filepath ) { var validateInputArg = function ( ) { if ( filepath === null || filepath . length === 0 ) { throw { "success" : false , "value" : null , "error" : new Error ( "a filepath value is required" ) } ; } else { return true ; } } ; var readRemoteFileContent = function ( ) { 
function Client ( options ) { var self = this ; options = options || { } ; this . mid = 0 ; this . callbacks = { } ; this . socket = new net . Socket ( options ) ; replier . _migrate_events ( [ 'connect' , 'error' , 'end' , 'timeout' , 'close' , 'drain' ] , this . socket , this ) ; this . socket . on ( 'data' , function ( data ) { dealStream ( data , function ( msg ) { self . emit ( 'data' , msg ) ; self . _dealServerData ( msg ) ; } ) ; } ) ; } 
function dataAttributesToProperties ( dataAttributesHash ) { var transformed = { } ; $ . each ( dataAttributesHash , function ( key , value ) { 
function propertiesToDataAttributes ( attributesHash ) { var transformed = { } ; $ . each ( attributesHash , function ( key , value ) { 
function attributesHashToString ( attributesHash , options ) { var reduce = options && options . reverse ? _ . reduceRight : _ . reduce , separator = options && options . multiline ? "\n" : " " , spacing = options && options . extrSpace || "" , defaultQuote = options && options . preferSingleQuotes ? "'" : '"' ; return reduce ( attributesHash , function ( attrString , value , key ) { var quote = value . indexOf ( '"' ) !== - 1 ? "'" : value . indexOf ( "'" ) !== - 1 ? '"' : defaultQuote ; return attrString + key + spacing + "=" + spacing + quote + value + quote + separator ; } , "" ) ; } 
function toDashedProperties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ toDashed ( key ) ] = value ; } ) ; return transformed ; } 
function toCamelCasedProperties ( hash ) { var transformed = { } ; _ . each ( hash , function ( value , key ) { transformed [ toCamelCase ( key ) ] = value ; } ) ; return transformed ; } 
function dashedKeyAlternatives ( hash ) { var keys = _ . keys ( toDashedProperties ( hash ) ) ; return _ . filter ( keys , function ( key ) { return key . search ( / [^-]-[a-z] / ) !== - 1 ; } ) ; } 
function combine ( hashA , hashB , hashN ) { var hashes = _ . toArray ( arguments ) ; return _ . extend . apply ( undefined , [ { } ] . concat ( hashes ) ) ; } 
function ( selector , root ) { var selectors = selector . split ( ',' ) , length = selectors . length , i = 0 , results = [ ] , noDupResults = [ ] , dupMatcher = { } , query , resultsLn , cmp ; for ( ; i < length ; i ++ ) { selector = Ext . String . trim ( selectors [ i ] ) ; query = this . parse ( selector ) ; 
function ( component , selector ) { if ( ! selector ) { return true ; } var query = this . cache [ selector ] ; if ( ! query ) { this . cache [ selector ] = query = this . parse ( selector ) ; } return query . is ( component ) ; } 
function md5 ( buffer ) { var hash = crypto . createHash ( 'md5' ) ; return hash . update ( buffer ) . digest ( 'hex' ) . slice ( 0 , 10 ) ; } 
function cleanQuery ( url ) { var query = path . extname ( url ) . split ( '?' ) [ 1 ] ; if ( query && query . length > 0 ) { return url . substr ( 0 , url . length - ( query . length + 1 ) ) ; } return url ; } 
function createPattern ( pattern , flags ) { pattern = pattern . replace ( / [\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|] / g , "\\$&" ) ; return flags ? new RegExp ( pattern , flags ) : new RegExp ( pattern ) ; } 
function walkDependencies ( file , rules ) { var directory = path . dirname ( file . path ) ; var content = file . contents . toString ( ) ; var list = [ ] ; 
function uniqueDependencies ( dependencies ) { var result = [ ] ; var map = { } ; dependencies . forEach ( function ( dependency ) { if ( ! map [ dependency . absolute ] ) { result . push ( dependency ) ; map [ dependency . absolute ] = 1 ; } } ) ; return result ; } 
function correctDependencies ( file , dependencies , correct ) { if ( ! correct ) { return ; } for ( var i = dependencies . length - 1 ; i >= 0 ; i -- ) { correct ( file , dependencies [ i ] ) ; } } 
function filterDependencies ( file , dependencies , filter ) { for ( var i = dependencies . length - 1 ; i >= 0 ; i -- ) { var dependency = dependencies [ i ] ; 
function renameDependencies ( file , dependencies , rename ) { var srcContent = file . contents . toString ( ) ; var destContent = srcContent ; 
function getRecursiveHash ( dependency , hashMap , dependencyMap ) { 
function htmlDependencies ( file , instance , options ) { var dependencies = walkDependencies ( file , instance . htmlRules ) ; correctDependencies ( file , dependencies , instance . correctDependency ) ; filterDependencies ( file , dependencies , instance . filterDependency ) ; if ( options . process ) { options . process ( file , dependencies ) ; } if ( options . rename ) { renameDependencies ( file , dependencies , function ( dependency ) { return options . rename ( file , dependency , instance . hashMap , instance . dependencyMap ) ; } ) ; } } 
function cssDependencies ( file , instance , options ) { var dependencies = walkDependencies ( file , instance . cssRules ) ; correctDependencies ( file , dependencies , instance . correctDependency ) ; filterDependencies ( file , dependencies , instance . filterDependency ) ; if ( options . process ) { options . process ( file , dependencies ) ; } if ( options . rename ) { renameDependencies ( file , dependencies , function ( dependency ) { return options . rename ( file , dependency , instance . hashMap , instance . dependencyMap ) ; } ) ; } } 
function amdDependencies ( file , instance , options ) { var dependencies = [ ] ; var config = instance . getAmdConfig ( file ) ; var fileInfo = parseFile ( file . path , file . contents . toString ( ) , config ) ; fileInfo . modules . forEach ( function ( module ) { var resources = parseFactoryResources ( module . factory ) ; [ 
function getIterator ( file ) { var iterator ; switch ( path . extname ( file . path ) . toLowerCase ( ) ) { 
function ( handler ) { var me = this ; return es . map ( function ( file , callback ) { var done = function ( ) { callback ( null , file ) ; } ; if ( file . contents ) { handler ( file , done ) ; } else { done ( ) ; } } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { htmlDependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { cssDependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; return me . custom ( function ( file , callback ) { amdDependencies ( file , me , options ) ; callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var filter = options && options . filter ; return me . custom ( function ( file , callback ) { if ( ! filter || ! filter ( file ) ) { var filePath = file . path ; var hash = me . hashMap [ filePath ] ; hash = md5 ( file . contents ) ; me . hashMap [ filePath ] = hash ; } callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var filter = options && options . filter ; return me . custom ( function ( file , callback ) { if ( ! filter || ! filter ( file ) ) { var iterator = getIterator ( file ) ; if ( iterator ) { iterator ( file , me , { process : function ( file , dependencies ) { if ( dependencies . length > 0 ) { me . dependencyMap [ file . path ] = uniqueDependencies ( dependencies ) . map ( function ( dependency ) { return dependency . absolute ; } ) ; } } } ) ; } } callback ( ) ; } ) ; } 
function ( options ) { var me = this ; var hashMap = me . hashMap ; var dependencyMap = me . dependencyMap ; var filter ; var replace ; if ( options ) { filter = options . filter ; replace = options . replace ; } return me . custom ( function ( file , callback ) { if ( ! filter || ! filter ( file ) ) { var iterator = getIterator ( file ) ; if ( iterator ) { iterator ( file , me , { process : function ( file , dependencies ) { if ( replace ) { var srcContent = file . contents . toString ( ) ; var destContent = replace ( file , srcContent ) ; if ( destContent && destContent !== srcContent ) { file . contents = new Buffer ( destContent ) ; } } } , rename : function ( file , dependency ) { var prefix = './' ; 
function ( options ) { var me = this ; var filter = options && options . filter ; var hashMap = me . hashMap ; var dependencyMap = me . dependencyMap ; return me . custom ( function ( file , callback ) { if ( ! filter || ! filter ( file ) ) { var hash = me . getFileHash ( file . path , hashMap , dependencyMap , true ) ; var filePath = me . renameFile ( file , hash ) ; if ( filePath ) { file . path = filePath ; } } callback ( ) ; } ) ; } 
function ( filePath , hashMap , dependencyMap , cache ) { var me = this ; var recursiveHashMap = me . recursiveHashMap ; var hash = recursiveHashMap [ filePath ] ; if ( ! cache || ! hash ) { hash = getRecursiveHash ( filePath , hashMap , dependencyMap ) ; } if ( cache ) { recursiveHashMap [ filePath ] = hash ; } return hash ; } 
function ( ) { var me = this ; return me . custom ( function ( file , callback ) { amdDeploy ( { file : file . path , content : file . contents . toString ( ) , config : me . getAmdConfig ( file ) , callback : function ( code ) { file . contents = new Buffer ( code ) ; callback ( ) ; } } ) ; } ) ; } 
function ( file , match , literal ) { 
function plugin ( suite ) { 
function post ( data , opts , clbk ) { if ( arguments . length === 2 ) { 
function RouterDecorator ( Router ) { function TelemetryRouter ( options ) { if ( ! ( this instanceof TelemetryRouter ) ) { return new TelemetryRouter ( options ) } Router . call ( this , options ) } inherits ( TelemetryRouter , Router ) TelemetryRouter . prototype . getNearestContacts = function ( key , limit , id , cb ) { var self = this var callback = function ( err , shortlist ) { if ( ! err ) { self . _log . debug ( 'sorting shortlist based on telemetry score' ) var profiles = { } each ( shortlist , function ( contact , iteratorCallback ) { var profileCallback = function ( err , profile ) { profiles [ contact . nodeID ] = profile iteratorCallback ( err ) } self . _rpc . telemetry . getProfile ( contact , profileCallback ) } , function ( err ) { if ( err ) { cb ( null , shortlist ) } else { shortlist . sort ( self . _compare . bind ( self , profiles ) ) cb ( null , shortlist ) } } ) } else { cb ( err , null ) } } Router . prototype . getNearestContacts . call ( this , key , limit , id , callback ) } TelemetryRouter . prototype . _compare = function ( profiles , cA , cB ) { var profileA = profiles [ cA . nodeID ] var profileB = profiles [ cB . nodeID ] var scoresA = { } var scoresB = { } this . _rpc . _telopts . metrics . forEach ( function ( Metric ) { var m = new Metric ( ) scoresA [ m . key ] = Metric . score ( m . getMetric ( profileA ) ) scoresB [ m . key ] = Metric . score ( m . getMetric ( profileB ) ) } ) var resultA = TelemetryRouter . getSuccessProbability ( scoresA ) var resultB = TelemetryRouter . getSuccessProbability ( scoresB ) this . _log . debug ( 'success probability is %d% vs %d%' , ( resultA * 100 ) . toFixed ( 3 ) , ( resultB * 100 ) . toFixed ( 3 ) ) * Uses a profile scorecard to calculate the probability of success * #getSuccessProbability * @param {Object} score * @returns {Number} */ TelemetryRouter . getSuccessProbability = function ( score ) { return ( score . reliability + score . availability + score . latency ) / 3 } return TelemetryRouter } 
function partial ( a , b , c ) { var pInflection = ( c - a ) / ( b - a ) , fact1 = ( b - a ) * ( c - a ) , fact2 = ( b - a ) * ( b - c ) ; return function quantile ( p ) { if ( p !== p || p < 0 || p > 1 ) { return NaN ; } if ( p < pInflection ) { return a + sqrt ( fact1 * p ) ; } if ( p > pInflection ) { return b - sqrt ( fact2 * ( 1 - p ) ) ; } 
function ( config ) { if ( config . name == null ) { Ext . Logger . error ( 'Ext.device.SQLite#openDatabase: You must specify a `name` of the database.' ) ; return null ; } if ( config . version == null ) { Ext . Logger . error ( 'Ext.device.SQLite#openDatabase: You must specify a `version` of the database.' ) ; return null ; } if ( config . displayName == null ) { Ext . Logger . error ( 'Ext.device.SQLite#openDatabase: You must specify a `displayName` of the database.' ) ; return null ; } if ( config . estimatedSize == null ) { Ext . Logger . error ( 'Ext.device.SQLite#openDatabase: You must specify a `estimatedSize` of the database.' ) ; return null ; } var database = null ; var result = Ext . device . Communicator . send ( { command : 'SQLite#openDatabase' , sync : true , name : config . name , version : config . version , displayName : config . displayName , estimatedSize : config . estimatedSize , callbacks : { 
function ( config ) { if ( config . oldVersion == null ) { Ext . Logger . error ( 'Ext.device.SQLite#changeVersion: You must specify an `oldVersion` of the database.' ) ; return null ; } if ( config . newVersion == null ) { Ext . Logger . error ( 'Ext.device.SQLite#changeVersion: You must specify a `newVersion` of the database.' ) ; return null ; } this . transaction ( Ext . apply ( config , { preflight : function ( ) { return config . oldVersion == this . getVersion ( ) ? null : 'Unable to change version: version mismatch' ; } , postflight : function ( ) { var result = Ext . device . Communicator . send ( { command : 'SQLite#setVersion' , sync : true , databaseId : this . id , version : config . newVersion } ) ; if ( result ) { this . version = config . newVersion ; } } } ) ) ; } 
function ( config ) { if ( ! this . active ) { Ext . Logger . error ( 'Ext.device.sqlite.SQLTransaction#executeSql: An attempt was made to use a SQLTransaction that is no longer usable.' ) ; return null ; } if ( config . sqlStatement == null ) { Ext . Logger . error ( 'Ext.device.sqlite.SQLTransaction#executeSql: You must specify a `sqlStatement` for the transaction.' ) ; return null ; } this . statements . push ( { sqlStatement : config . sqlStatement , arguments : config . arguments , callback : config . callback , failure : config . failure , scope : config . scope } ) ; } 
function ( index ) { if ( index < this . getLength ( ) ) { var item = { } ; var row = this . rows [ index ] ; this . names . forEach ( function ( name , index ) { item [ name ] = row [ index ] ; } ) ; return item ; } return null ; } 
function Logger ( name , options ) { this . name = name ; this . _enabled = _defaults ( options , 'enabled' ) ; this . _stream = _defaults ( options , 'stream' ) ; this . _level = _defaults ( options , 'level' ) ; var logger = this ; _loggers [ name ] = this ; Object . keys ( levels ) . forEach ( function ( level ) { logger [ level ] = function ( ) { return logger . write ( levels [ level ] , arguments ) ; } ; } ) ; } 
function createPayload ( name , level , data ) { return { date : getDate ( ) , level : level , name : name , data : data } ; } 
function Message ( spec ) { if ( ! ( this instanceof Message ) ) { return new Message ( spec ) } this . jsonrpc = '2.0' if ( Message . isRequest ( spec ) ) { this . id = spec . id || Message . createID ( ) this . method = spec . method this . params = spec . params } else if ( Message . isResponse ( spec ) ) { this . id = spec . id this . result = merge ( { } , spec . result ) if ( spec . error ) { this . error = { code : - 32603 , message : spec . error . message } } } else { throw new Error ( 'Invalid message specification' ) } } 
function __ENFORCETYPE ( a , ... types ) { if ( env . application_env !== "development" ) return ; let hasError = false ; let expecting ; let got ; let i = 0 ; types . map ( ( t , index ) => { if ( a [ index ] === null ) { hasError = true ; expecting = t ; got = "null" ; i = index ; return ; } switch ( t ) { case "mixed" : break ; case "jsx" : if ( ! React . isValidElement ( a [ index ] ) ) { hasError = true ; expecting = "jsx" ; got = typeof a [ index ] ; i = index ; } case "array" : if ( ! Array . isArray ( a [ index ] ) ) { hasError = true ; expecting = "array" ; got = typeof a [ index ] ; i = index ; } break ; case "object" : if ( typeof a [ index ] !== 'object' || Array . isArray ( a [ index ] ) || a [ index ] === null ) { hasError = true ; expecting = "object" ; i = index ; if ( a [ index ] === null ) { got = 'null' ; } else { got = Array . isArray ( a [ index ] ) ? "array" : typeof a [ index ] ; } } default : if ( typeof a [ index ] !== t ) { hasError = true ; { expecting = t ; got = typeof a [ index ] ; } i = index ; } } } ) ; if ( hasError ) { let err = new Error ( ) ; console . error ( ` ${ i + 1 } ${ expecting } ${ got } ` , err . stack ) ; } } 
function parseXMP ( data ) { return new Promise ( function ( resolve , reject ) { var parserstrict = true ; var parser = sax . parser ( parserstrict ) ; var nodepath = [ ] ; var currentnode = null ; var outdata = { } ; parser . onerror = function ( err ) { reject ( { error : MediaExt . ERROR . PARSEXML , internalerror : err } ) } ; parser . onopentag = function ( node ) { nodepath . push ( node . name ) ; if ( node . attributes ) { for ( var att in node . attributes ) { if ( ! node . attributes . hasOwnProperty ( att ) ) continue ; var value = node . attributes [ att ] ; nodepath . push ( att ) ; setOutdata ( nodepath , value , outdata ) ; nodepath . pop ( ) ; } } currentnode = node ; } parser . onclosetag = function ( node ) { nodepath . pop ( ) ; currentnode = null ; } parser . ontext = function ( value ) { setOutdata ( nodepath , value , outdata ) ; } parser . onend = function ( data ) { resolve ( outdata ) } ; parser . write ( data ) . close ( ) ; } ) ; } 
function assign ( parent , val , keyOpts ) { var target = parent , keyParts = keyOpts . val . toString ( ) . split ( '.' ) ; keyParts . forEach ( function ( keyPart , idx ) { if ( keyParts . length === idx + 1 ) { if ( val !== undefined ) { if ( Array . isArray ( val ) && Array . isArray ( target [ keyPart ] ) ) { val = target [ keyPart ] . concat ( val ) ; } if ( ! ( ( Array . isArray ( val ) && ! val . length ) || ( typeof val === 'object' && ! Object . keys ( val || { } ) . length ) ) ) { target [ keyPart ] = val ; } } } else if ( ! ( keyPart in target ) ) { target [ keyPart ] = { } ; } } ) ; } 
function ( token ) { var filter = { val : '' , opts : [ ] , type : 'filter' } token . filters . push ( filter ) ; return filter ; } 
function ( node1 , node2 ) { 
function ( root ) { var node = this . getNode ( ) , recursive = this . getRecursive ( ) , added = [ ] , child = root ; if ( ! root . childNodes . length || ( ! recursive && root !== node ) ) { return added ; } if ( ! recursive ) { return root . childNodes ; } while ( child ) { if ( child . _added ) { delete child . _added ; if ( child === root ) { break ; } else { child = child . nextSibling || child . parentNode ; } } else { if ( child !== root ) { added . push ( child ) ; } if ( child . firstChild ) { child . _added = true ; child = child . firstChild ; } else { child = child . nextSibling || child . parentNode ; } } } return added ; } 
function ( config ) { var me = this ; config = Ext . device . filesystem . Abstract . prototype . requestFileSystem ( config ) ; var successCallback = function ( fs ) { var fileSystem = Ext . create ( 'Ext.device.filesystem.FileSystem' , fs ) ; config . success . call ( config . scope || me , fileSystem ) ; } ; if ( config . type == window . PERSISTENT ) { if ( navigator . webkitPersistentStorage ) { navigator . webkitPersistentStorage . requestQuota ( config . size , function ( grantedBytes ) { window . webkitRequestFileSystem ( config . type , grantedBytes , successCallback , config . failure ) ; } ) } else { window . webkitStorageInfo . requestQuota ( window . PERSISTENT , config . size , function ( grantedBytes ) { window . webkitRequestFileSystem ( config . type , grantedBytes , successCallback , config . failure ) ; } ) } } else { window . webkitRequestFileSystem ( config . type , config . size , successCallback , config . failure ) ; } } 
function PubSub ( pub , sub ) { events . EventEmitter . call ( this ) ; var self = this ; 
function ( operation , callback , scope ) { var me = this , writer = me . getWriter ( ) , request = me . buildRequest ( operation ) ; request . setConfig ( { headers : me . getHeaders ( ) , timeout : me . getTimeout ( ) , method : me . getMethod ( request ) , callback : me . createRequestCallback ( request , operation , callback , scope ) , scope : me , proxy : me , useDefaultXhrHeader : me . getUseDefaultXhrHeader ( ) } ) ; if ( operation . getWithCredentials ( ) || me . getWithCredentials ( ) ) { request . setWithCredentials ( true ) ; request . setUsername ( me . getUsername ( ) ) ; request . setPassword ( me . getPassword ( ) ) ; } 
function ( err ) { var output ; try { var fieldName = err . err . substring ( err . err . lastIndexOf ( '.$' ) + 2 , err . err . lastIndexOf ( '_1' ) ) ; output = fieldName . charAt ( 0 ) . toUpperCase ( ) + fieldName . slice ( 1 ) + ' already exists' ; } catch ( ex ) { output = 'Unique field already exists' ; } return output ; } 
function ( newMessage ) { var cls = Ext . baseCSSPrefix + 'has-message' ; if ( newMessage ) { this . addCls ( cls ) ; } else { this . removeCls ( cls ) ; } this . messageElement . setHtml ( newMessage ) ; } 
function isPromise ( val , Promize ) { return val instanceof Promize || ( val !== null && typeof val === 'object' && typeof val . then === 'function' && typeof val . catch === 'function' ) } 
function acquire ( src , err ) { let mod = _ . attempt ( require , src ) return mod ? _ . isError ( mod ) ? _ . isBoolean ( err ) && err ? mod : null : null : mod } 
function acopy ( ) { let zargs = _ . toArray ( arguments ) zargs . unshift ( { } ) return _ . assign . apply ( _ , zargs ) } 
function mcopy ( ) { let zargs = _ . toArray ( arguments ) zargs . unshift ( { } ) return _ . merge . apply ( _ , zargs ) } 
function ( project ) { var current = process . cwd ( ) ; console . log ( '\nCreating folder "' + project + '"...' ) ; 
function browserifyTask ( ) { 
function prewatch ( theOptions ) { if ( config . watch ) { return _ . defaults ( theOptions , watchify . args ) ; } return theOptions ; } 
function ( index , filters ) { 
function ( filters ) { 
function ( ) { var filters = this . getFilters ( ) . items ; this . filterFn = function ( item ) { var isMatch = true , length = filters . length , i ; for ( i = 0 ; i < length ; i ++ ) { var filter = filters [ i ] , fn = filter . getFilterFn ( ) , scope = filter . getScope ( ) || this ; isMatch = isMatch && fn . call ( scope , item ) ; } return isMatch ; } ; this . dirtyFilterFn = false ; return this . filterFn ; } 
function mergeCustomizer ( objValue , srcValue , key ) { if ( isArray ( objValue ) ) { return objValue . concat ( srcValue ) ; } if ( METHODS_INHERITANCE . indexOf ( key ) !== - 1 ) { return wrap ( objValue , wrap ( srcValue , wrapperFunction ) ) ; } if ( METHODS_MERGE_RESULT . indexOf ( key ) !== - 1 ) { return wrap ( objValue , wrap ( srcValue , wrapperMergeResult ) ) ; } if ( key === 'shouldComponentUpdate' ) { return wrap ( objValue , wrap ( srcValue , wrapperOrResult ) ) ; } if ( key === 'statics' ) { checkOverriddenMethods ( objValue , srcValue ) ; } if ( key === 'render' && objValue && srcValue ) { throw new Error ( 'The "render" method you can override' ) ; } if ( key === 'displayName' && objValue && srcValue ) { throw new Error ( 'The "displayName" property can not be redefined' ) ; } if ( isFunction ( objValue ) && isFunction ( srcValue ) ) { throw new Error ( ` ${ key } ` ) ; } } 
function wrapperMergeResult ( srcFunc , objFunc , ... args ) { let resultObjFunction = { } ; let resultSrcFunction = { } ; if ( isFunction ( objFunc ) ) { resultObjFunction = objFunc . apply ( this , args ) ; } if ( isFunction ( srcFunc ) ) { resultSrcFunction = srcFunc . apply ( this , args ) ; } return merge ( { } , resultObjFunction , resultSrcFunction ) ; } 
function wrapperOrResult ( srcFunc , objFunc , ... args ) { let resultObjFunction = false ; let resultSrcFunction = false ; if ( isFunction ( objFunc ) ) { resultObjFunction = objFunc . apply ( this , args ) ; } if ( isFunction ( srcFunc ) ) { resultSrcFunction = srcFunc . apply ( this , args ) ; } return resultObjFunction || resultSrcFunction ; } 
function ( instance ) { this . _model = instance . _model ; this . _instance = instance ; this . id = instance . id ; this . eachAttribute = function ( cb ) { return this . _model . eachAttribute ( cb ) ; } ; this . eachRelationship = function ( cb ) { return this . _model . eachRelationship ( cb ) ; } this . attr = function ( name ) { return this . _instance [ name ] ; } ; this . belongsTo = function ( name , opts ) { return ( opts . id ? this . _instance [ name ] . id : new Snapshot ( this . _instance [ name ] ) ) ; } ; } 
function ( val ) { var trimmed = val . trim ( ) ; if ( trimmed . indexOf ( "'" ) === 0 && trimmed . lastIndexOf ( "'" ) === ( trimmed . length - 1 ) ) return '"' + trimmed . substring ( 1 , trimmed . length - 1 ) + '"' ; return val ; } 
function ( typeName , obj ) { this . type = typeName ; if ( typeof obj !== 'undefined' ) for ( var key in obj ) this [ key ] = obj [ key ] ; } 
function ( ) { var idStr = '' + sforce . db . id ++ ; return sforce . db . _idTemplate . substring ( 0 , 18 - idStr . length ) + idStr ; } 
function ( select ) { var chars = new antlr4 . InputStream ( input ) ; var lexer = new SelectLexer ( chars ) ; var tokens = new antlr4 . CommonTokenStream ( lexer ) ; var parser = new SelectParser ( tokens ) ; parser . buildParseTrees = true ; return parser . select ( ) ; } 
function ( obj ) { var schema = sforce . db . schema ; var objDesc = schema [ obj . type ] ; if ( typeof objDesc === 'undefined' ) throw 'No type exists by the name: ' + obj . type ; for ( var key in obj ) { if ( { Id : false , type : true } [ key ] ) continue ; var fieldDesc = null ; for ( var i = 0 ; i < objDesc . fields . length ; i ++ ) { var fd = objDesc . fields [ i ] ; if ( fd . name === key ) { fieldDesc = fd ; break ; } } if ( fieldDesc == null ) throw 'No field exists by the name: ' + key + 'in the type: ' + obj . type ; } } 
function ( type , fields ) { for ( var i = 0 ; i < fields . length ; i ++ ) sforce . db . validateField ( type , fields [ i ] ) ; } 
function ( type , field ) { var objDesc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < objDesc . fields . length ; i ++ ) if ( objDesc . fields [ i ] . name === field ) return ; throw 'No field exists by the name: ' + field + 'in the type: ' + type ; } 
function ( type , rel ) { var objDesc = sforce . db . schema [ type ] ; for ( var i = 0 ; i < objDesc . childRelationships . length ; i ++ ) if ( objDesc . childRelationships [ i ] . relationshipName === rel ) return ; throw 'No child relationship exists by the name: ' + rel + 'in the type: ' + type ; } 
function ( type ) { var sos = sforce . db . sobjects ; if ( typeof sos [ type ] !== 'object' ) sos [ type ] = { } ; return sos [ type ] ; } 
function ( objAry , success , err ) { var result = [ ] ; for ( var i = 0 ; i < objAry . length ; i ++ ) { var obj = objAry [ i ] ; try { sforce . db . validateSobject ( obj ) ; obj = _extend ( { } , obj ) ; var objs = sforce . db . getSobjects ( obj . type ) ; obj . Id = ( ( ! sforce . db . useGivenIds || typeof obj . Id === 'undefined' ) ? sforce . db . newId ( ) : obj . Id ) ; objs [ obj . Id ] = obj ; result . push ( { success : 'true' , id : obj . Id } ) ; } catch ( e ) { result . push ( { success : 'false' , id : obj . Id } ) ; } } if ( success ) success ( result ) ; return result ; } 
function ( idAry , success , err ) { var result = [ ] ; for ( var i = 0 ; i < idAry . length ; i ++ ) { var found = false ; var Id = idAry [ i ] ; for ( var type in this . schema ) { var allOfType = sforce . db . getSobjects ( type ) ; if ( Id in allOfType ) { delete allOfType [ Id ] ; found = true ; result . push ( { success : 'true' , id : Id } ) ; break ; } } if ( ! found ) result . push ( { success : 'false' , id : Id } ) ; } if ( success ) success ( result ) ; return result ; } 
function ( select , success , err ) { try { var chars = new antlr4 . InputStream ( select ) ; var lexer = new SelectLexer ( chars ) ; var tokens = new antlr4 . CommonTokenStream ( lexer ) ; var parser = new SelectParser ( tokens ) ; parser . buildParseTrees = true ; var tree = parser . select ( ) ; console . log ( tree . toStringTree ( ) ) ; var listener = new QueryBuilderListener ( sforce . db ) ; antlr4 . tree . ParseTreeWalker . DEFAULT . walk ( listener , tree ) ; var result = listener . query . getResult ( ) ; if ( success ) success ( result ) ; return result ; } catch ( e ) { if ( err ) err ( e ) ; return e ; } } 
function ( resultAry , isRoot ) { if ( resultAry . length == 0 ) { if ( isRoot ) return { done : 'true' , queryLocator : null , size : 0 , } ; return null ; } var records = null ; if ( resultAry . length == 1 ) records = resultAry [ 0 ] ; else records = resultAry ; return { done : 'true' , queryLocator : null , records : records , size : resultAry . length , } ; } 
function ( obj ) { var result = { type : this . type } ; this . db . validateFields ( this . type , this . fields ) ; for ( var i = 0 ; i < this . fields . length ; i ++ ) { var fName = this . fields [ i ] ; result [ fName ] = obj [ fName ] ; } for ( var i = 0 ; i < this . subqueries . length ; i ++ ) { var sq = this . subqueries [ i ] ; result [ sq . relationship ] = sq . getResult ( obj ) ; } return result } 
function ( ) { var all = this . db . getSobjects ( this . type ) ; var result = [ ] ; for ( var Id in all ) { var obj = all [ Id ] ; if ( ! this . condition || this . condition . matches ( obj ) ) result . push ( this . _createResultObj ( obj ) ) ; } return this . db . wrapResult ( result , true ) ; } 
function ( obj ) { var result = { type : obj . type } ; this . getDb ( ) . validateFields ( obj . type , this . fields ) ; for ( var i = 0 ; i < this . fields . length ; i ++ ) { var fName = this . fields [ i ] ; result [ fName ] = obj [ fName ] ; } return result } 
function ( parentObj ) { this . getDb ( ) . validateRelationship ( this . getType ( ) , this . relationship ) var objDesc = this . getDb ( ) . schema [ this . getType ( ) ] ; var relDesc = null ; for ( var i = 0 ; i < objDesc . childRelationships . length ; i ++ ) if ( this . relationship === objDesc . childRelationships [ i ] . relationshipName ) relDesc = objDesc . childRelationships [ i ] ; if ( relDesc == null ) throw 'No child relationship by the name: ' + this . relationship + ' exists in the type: ' + this . getType ( ) ; var relObjDesc = this . getDb ( ) . schema [ relDesc . childSObject ] ; var all = this . getDb ( ) . getSobjects ( relDesc . childSObject ) ; var result = [ ] ; for ( var key in all ) { var obj = all [ key ] ; if ( obj [ relDesc . field ] === parentObj . Id && ( ! this . condition || this . condition . matches ( obj ) ) ) result . push ( this . _createResultObj ( obj ) ) ; } return this . getDb ( ) . wrapResult ( result ) ; } 
function ( obj ) { var matches = this . sequence [ 0 ] . matches ( obj ) ; for ( var i = 1 ; i < this . sequence . length ; i += 2 ) { if ( this . sequence [ i ] === '&' ) matches = matches && this . sequence [ i + 1 ] . matches ( obj ) ; else matches = matches || this . sequence [ i + 1 ] . matches ( obj ) ; } return matches ; } 
function addContents ( $ , contents ) { console . log ( 'addContents' , contents ) ; var body = document . getElementsByTagName ( 'BODY' ) ; if ( ! body ) return ; var $body = $ ( body [ 0 ] ) , contentsStyle = [ 'position:fixed;right:1em;top:1em;' , 'padding:0.5em;min-width:120px;' , 'font-size:90%;line-height:18px;' , 'border:1px solid #aaa;background: #F9F9F9;' ] . join ( '' ) , html = [ ] , order = [ ] , hash = [ ] ; for ( var i = 0 ; i < contents . length ; ++ i ) { order [ i ] = 0 ; hash [ i ] = '' ; } function indexOf ( tag ) { for ( var i = 0 ; i < contents . length && contents [ i ] . toLowerCase ( ) !== tag ; ++ i ) ; return i ; } $ ( contents . join ( ',' ) ) . each ( function ( i , obj ) { var index = indexOf ( obj . tagName . toLowerCase ( ) ) ; order [ index ] ++ ; hash [ index ] = $ ( obj ) . text ( ) ; for ( var j = index + 1 ; j < contents . length ; ++ j ) { 
function addTop ( $ , top ) { console . log ( 'addTop' , top ) ; $ ( top . join ( ',' ) ) . each ( function ( i , obj ) { 
function ( ) { var actions = this . getActions ( ) , namespace = this . getNamespace ( ) , action , cls , methods , i , ln , method ; for ( action in actions ) { if ( actions . hasOwnProperty ( action ) ) { cls = namespace [ action ] ; if ( ! cls ) { cls = namespace [ action ] = { } ; } methods = actions [ action ] ; for ( i = 0 , ln = methods . length ; i < ln ; ++ i ) { method = Ext . create ( 'Ext.direct.RemotingMethod' , methods [ i ] ) ; cls [ method . getName ( ) ] = this . createHandler ( action , method ) ; } } } } 
function ( transaction , event ) { var success = ! ! event . getStatus ( ) , functionName = success ? 'success' : 'failure' , callback = transaction && transaction . getCallback ( ) , result ; if ( callback ) { 
function ( options , success , response ) { var me = this , i = 0 , ln , events , event , transaction , transactions ; if ( success ) { events = me . createEvents ( response ) ; for ( ln = events . length ; i < ln ; ++ i ) { event = events [ i ] ; transaction = me . getTransaction ( event ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction ) { me . runCallback ( transaction , event , true ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } else { transactions = [ ] . concat ( options . transaction ) ; for ( ln = transactions . length ; i < ln ; ++ i ) { transaction = me . getTransaction ( transactions [ i ] ) ; if ( transaction && transaction . getRetryCount ( ) < me . getMaxRetries ( ) ) { transaction . retry ( ) ; } else { event = Ext . create ( 'Ext.direct.ExceptionEvent' , { data : null , transaction : transaction , code : Ext . direct . Manager . exceptions . TRANSPORT , message : 'Unable to connect to the server.' , xhr : response } ) ; me . fireEvent ( 'data' , me , event ) ; if ( transaction ) { me . runCallback ( transaction , event , false ) ; Ext . direct . Manager . removeTransaction ( transaction ) ; } } } } } 
function ( options ) { return options && options . getTid ? Ext . direct . Manager . getTransaction ( options . getTid ( ) ) : null ; } 
function ( action , method , args ) { var me = this , callData = method . getCallData ( args ) , data = callData . data , callback = callData . callback , scope = callData . scope , transaction ; transaction = Ext . create ( 'Ext.direct.Transaction' , { provider : me , args : args , action : action , method : method . getName ( ) , data : data , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback } ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; me . queueTransaction ( transaction ) ; me . fireEvent ( 'call' , me , transaction , method ) ; } } 
function ( transaction ) { return { action : transaction . getAction ( ) , method : transaction . getMethod ( ) , data : transaction . getData ( ) , type : 'rpc' , tid : transaction . getId ( ) } ; } 
function ( transaction ) { var me = this , enableBuffer = me . getEnableBuffer ( ) ; if ( transaction . getForm ( ) ) { me . sendFormRequest ( transaction ) ; return ; } me . callBuffer . push ( transaction ) ; if ( enableBuffer ) { if ( ! me . callTask ) { me . callTask = Ext . create ( 'Ext.util.DelayedTask' , me . combineAndSend , me ) ; } me . callTask . delay ( Ext . isNumber ( enableBuffer ) ? enableBuffer : 10 ) ; } else { me . combineAndSend ( ) ; } } 
function ( ) { var buffer = this . callBuffer , ln = buffer . length ; if ( ln > 0 ) { this . sendRequest ( ln == 1 ? buffer [ 0 ] : buffer ) ; this . callBuffer = [ ] ; } } 
function ( action , method , form , callback , scope ) { var me = this , transaction , isUpload , params ; transaction = new Ext . direct . Transaction ( { provider : me , action : action , method : method . getName ( ) , args : [ form , callback , scope ] , callback : scope && Ext . isFunction ( callback ) ? Ext . Function . bind ( callback , scope ) : callback , isForm : true } ) ; if ( me . fireEvent ( 'beforecall' , me , transaction , method ) !== false ) { Ext . direct . Manager . addTransaction ( transaction ) ; isUpload = String ( form . getAttribute ( 'enctype' ) ) . toLowerCase ( ) == 'multipart/form-data' ; params = { extTID : transaction . id , extAction : action , extMethod : method . getName ( ) , extType : 'rpc' , extUpload : String ( isUpload ) } ; 
function ( transaction ) { var me = this ; Ext . Ajax . request ( { url : me . getUrl ( ) , params : transaction . params , callback : me . onData , scope : me , form : transaction . form , isUpload : transaction . isUpload , transaction : transaction } ) ; } 
function inlineBlockFix ( decl ) { var origRule = decl . parent ; origRule . append ( { prop : '*display' , value : 'inline' } , { prop : '*zoom' , value : '1' } ) ; } 
function ( target , eventName ) { if ( ! this . handles ( eventName ) ) { return false ; } var match = target . match ( this . idOrClassSelectorRegex ) , subscribers = this . getSubscribers ( eventName ) , type , value ; if ( match !== null ) { type = match [ 1 ] ; value = match [ 2 ] ; if ( type === '#' ) { return subscribers . id . hasOwnProperty ( value ) ; } else { return subscribers . className . hasOwnProperty ( value ) ; } } else { return ( subscribers . selector . hasOwnProperty ( target ) && Ext . Array . indexOf ( subscribers . selector , target ) !== - 1 ) ; } return false ; } 
function stubPlainTextFiles ( resourceRoots , destination ) { _ . forEach ( resourceRoots , function ( resource ) { 
function userPreferencesDirectory ( configDirectory ) { var home = platform . userHomeDirectory ( ) ; var webStormPreferences = io . maximisePath ( home , / ^\.WebStorm\s*[.\d]+$ / , 'config' ) || 
function writeProjectViewTemplate ( rootPath ) { var context = { rootPath : rootPath } ; var templateSource = path . join ( String ( __dirname ) , 'template' , 'projectView.xml' ) ; var toolTemplate = fs . readFileSync ( templateSource ) ; return io . templateSync ( toolTemplate , context ) ; } 
function resolveJetbrainsExe ( jetbrainsDirectory ) { var exists = false ; var webstormInstallPaths = io . resolveDirMatches ( jetbrainsDirectory , / ^WebStorm\s*[.\d]+$ / ) ; 
function ( key , data ) { if ( data . n && data . e ) { if ( data . d && data . p && data . q && data . dmp1 && data . dmq1 && data . coeff ) { module . exports . privateImport ( key , data ) ; return true ; } else { module . exports . publicImport ( key , data ) ; return true ; } } return false ; } 
function Route ( method , path , callback , options ) { this . path = path ; this . method = method ; this . callback = callback ; this . regexp = utils . pathRegexp ( path , this . keys = [ ] , options . sensitive , options . strict ) ; } 
function tree2archy ( node ) { var dependencies = mout . object . values ( node . dependencies ) ; var version = ! node . missing ? node . pkgMeta . _release || node . pkgMeta . version : null ; var label = node . endpoint . name + ( version ? '#' + version : '' ) ; var update ; if ( node . root ) { label += ' ' + node . canonicalDir ; } 
function TransportDecorator ( Transport ) { function TelemetryTransport ( contact , options ) { if ( ! ( this instanceof TelemetryTransport ) ) { return new TelemetryTransport ( contact , options ) } assert . ok ( options , 'Missing required options parameter' ) this . _telopts = options . telemetry this . telemetry = new Persistence ( this . _telopts . storage ) Transport . call ( this , contact , options ) } inherits ( TelemetryTransport , Transport ) TelemetryTransport . DEFAULT_METRICS = [ metrics . Latency , metrics . Availability , metrics . Reliability , metrics . Throughput ] TelemetryTransport . prototype . _open = function ( callback ) { var self = this var metrics = this . _telopts . metrics if ( ! metrics || metrics . length === 0 ) { this . _telopts . metrics = TelemetryTransport . DEFAULT_METRICS } this . _telopts . metrics . forEach ( function ( Metric ) { var metric = new Metric ( ) metric . hooks . forEach ( function ( hook ) { self [ hook . trigger ] ( hook . event , hook . handler ( metric , self . telemetry ) ) } ) } ) return Transport . prototype . _open . call ( this , callback ) } return TelemetryTransport } 
function Router ( options ) { if ( ! ( this instanceof Router ) ) { return new Router ( options ) } this . _log = options . logger this . _rpc = options . transport this . _self = this . _rpc . _contact this . _validator = options . validator this . _routingTable = new RoutingTable ( options . storage , this . _rpc ) } 
function getRandomArrValue ( arr , min = 0 , max = arr . length - 1 ) { return arr [ getRandomInt ( min , max ) ] ; } 
function random ( number = 1 ) { if ( 1 > number ) { throw Error ( ` ${ number } ` ) ; } if ( number === 1 ) { return getRandomArrValue ( dinosaurs ) ; } else { const l = dinosaurs . length - 1 ; return new Array ( number ) . fill ( ) . map ( ( ) => getRandomArrValue ( dinosaurs , 0 , l ) ) ; } } 
function ( config ) { var me = this ; if ( ! config . received ) { Ext . Logger . error ( 'Failed to pass a received callback. This is required.' ) ; } if ( config . type == null ) { Ext . Logger . error ( 'Failed to pass a type. This is required.' ) ; } return { success : function ( token ) { me . onSuccess ( token , config . success , config . scope || me ) ; } , failure : function ( error ) { me . onFailure ( error , config . failure , config . scope || me ) ; } , received : function ( notifications ) { me . onReceived ( notifications , config . received , config . scope || me ) ; } , type : config . type } ; } 
function ( request ) { var me = this , operation = request . getOperation ( ) , records = operation . getRecords ( ) || [ ] , record = records [ 0 ] , model = me . getModel ( ) , idProperty = model . getIdProperty ( ) , format = me . getFormat ( ) , url = me . getUrl ( request ) , params = request . getParams ( ) || { } , id = ( record && ! record . phantom ) ? record . getId ( ) : params [ idProperty ] ; if ( me . getAppendId ( ) && id ) { if ( ! url . match ( / \/$ / ) ) { url += '/' ; } url += id ; delete params [ idProperty ] ; } if ( format ) { if ( ! url . match ( / \.$ / ) ) { url += '.' ; } url += format ; } request . setUrl ( url ) ; return me . callParent ( [ request ] ) ; } 
function Response ( ghosttrain , callback ) { this . charset = '' ; this . headers = { } ; this . statusCode = 200 ; this . app = ghosttrain ; this . _callback = callback ; } 
function ( ) { var body ; var app = this . app ; 
function ( ) { var data ; if ( arguments . length === 2 ) { this . status ( arguments [ 0 ] ) ; data = arguments [ 1 ] ; } else { data = arguments [ 0 ] ; } if ( ! this . get ( 'Content-Type' ) ) this . contentType ( 'application/json' ) ; return this . send ( data ) ; } 
function ( field , value ) { if ( arguments . length === 2 ) this . headers [ field ] = value ; else { for ( var prop in field ) this . headers [ prop ] = field [ prop ] ; } return this ; } 
function ( body ) { var type = this . get ( 'Content-Type' ) ; if ( type === 'application/json' ) this . _callback ( JSON . parse ( body || '{}' ) ) ; else this . _callback ( body ) ; } 
function ( args ) { 
function ( expected , args , minimum ) { var shiftedArgs = [ ] ; var curArg = args . length - 1 ; var remainingOptionalArgs = expected . length - minimum ; var optionalIndiceSegments = [ ] ; var optionalIndiceSegment = [ ] ; var availableArgsSegments = [ ] ; var availableArgsSegment = [ ] ; 
function ( ) { availableArgsSegment . unshift ( curArg ) ; curArg -- ; remainingOptionalArgs -- ; if ( curArg < 0 || remainingOptionalArgs < 0 ) { throw Error ( getExpectedVsRecieved_ ( expected , args ) ) ; } } 
function ( expected , expectedIndex , actual , actualIndex ) { 
function ( expected , expectedIndex , value ) { var i = expectedIndex + 1 ; var matchingOptionals = 0 ; var inBetweenOptionals = 0 ; var tmpInBetween = 0 ; while ( i < expected . length && isOptionalType ( expected [ i ] ) ) { if ( isOfType ( value , expected [ i ] ) ) { matchingOptionals ++ ; inBetweenOptionals += tmpInBetween ; tmpInBetween = 0 ; } else { tmpInBetween ++ ; } i ++ ; } return matchingOptionals + inBetweenOptionals ; } 
function ( expected , expectedIndex , value ) { var i = expectedIndex - 1 ; var matchingRequires = 0 while ( i >= 0 ) { if ( ! isOptionalType ( expected [ i ] ) && isOfType ( value , expected [ i ] ) ) { matchingRequires ++ ; } i -- ; } return matchingRequires ; } 
function ( expected , actual ) { var argNames = [ ] ; var expectedNames = [ ] ; for ( var i = 0 ; i < actual . length ; i ++ ) { argNames . push ( getNameForValue ( actual [ i ] ) ) ; } ; for ( var i = 0 ; i < expected . length ; i ++ ) { expectedNames . push ( getNameForType ( expected [ i ] ) ) ; } ; return 'Expected arguments to be (' + expectedNames . join ( ', ' ) + ') but received (' + argNames . join ( ', ' ) + ') instead.' ; } 
function ( value , type ) { if ( ! isValidType ( type ) ) { throw Error ( 'Invalid type supplied.' ) ; } if ( ! isOfType ( value , type ) ) { argName = getNameForValue ( value ) ; typeName = getNameForType ( type ) ; throw Error ( 'Expected ' + argName + ' to be an instance of ' + typeName + '.' ) ; } } 
function ( type ) { if ( type === null ) return true ; if ( type === undefined ) return true ; if ( type instanceof AnyType ) return true ; if ( type instanceof Array ) { 
function ( value ) { if ( value === undefined ) return 'undefined' ; if ( value === null ) return 'null' ; 
function ( type ) { if ( type === undefined ) return 'undefined' ; if ( type === null ) return 'null' ; 
function ( operation , callback , scope ) { 
function ( request ) { var me = this , url = me . callParent ( arguments ) , params = Ext . apply ( { } , request . getParams ( ) ) , filters = params . filters , filter , i , value ; delete params . filters ; if ( me . getAutoAppendParams ( ) ) { url = Ext . urlAppend ( url , Ext . Object . toQueryString ( params ) ) ; } if ( filters && filters . length ) { for ( i = 0 ; i < filters . length ; i ++ ) { filter = filters [ i ] ; value = filter . getValue ( ) ; if ( value ) { url = Ext . urlAppend ( url , filter . getProperty ( ) + "=" + value ) ; } } } return url ; } 
function getStateFromOptions ( options , propertyName ) { propertyName = propertyName || 'state' ; const stateName = options [ propertyName ] || options . resource . defaultState ; let stateObj = options . resource . states [ stateName ] || { validate : false } ; stateObj . name = stateName ; return stateObj ; } 
function validate ( resource , doc , doValidate ) { return new Promise ( ( resolve , reject ) => { if ( doValidate !== true ) { return resolve ( ) ; } if ( resource . validate ( doc ) ) { return resolve ( ) ; } else { debug ( 'model have %d error(s)' , resource . validate . errors . length ) ; return reject ( resource . validate . errors ) ; } } ) ; } 
function prune ( str , max , nice , suf ) { max = max || 140 nice = _ . isBoolean ( nice ) ? nice : false if ( ! str || max <= 0 || str . length <= max ) return str suf = suf || "..." str = str . substr ( 0 , max ) return nice ? str . substr ( 0 , Math . min ( str . length , str . lastIndexOf ( " " ) ) ) + suf : str } 
function attemptRender ( reporter , filename , src , resolve , reject , globals ) { globals = globals || { } ; less . render ( src , { 
function validateArray ( indexes ) { var valid = false ; if ( typeof indexes === 'string' ) { if ( indexes . match ( TYPE_ARRAY_REGEX ) ) { valid = true ; } } return valid ; } 
function addRoutes ( pies , pie , routes , app ) { 
function loadRoute ( app , method , route , piePath , fn , middleware ) { var middlewares = [ ] ; 
function generateUUID ( ) { let dat = new Date ( ) . getTime ( ) ; return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx' . replace ( / [xy] / g , ( cha ) => { const ran = ( dat + ( Math . random ( ) * 16 ) ) % 16 | 0 ; dat = Math . floor ( dat / 16 ) ; return ( cha === 'x' ? ran : ran & 0x3 | 0x8 ) . toString ( 16 ) ; } ) ; } 
function randomString ( length , charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' ) { let str = '' , isAllNumeric = false , isNegative = false , useCharSet = charSet ; if ( + length ) { if ( ! isString ( charSet ) ) { if ( isNumber ( charSet ) ) { if ( + charSet ) { isAllNumeric = true ; isNegative = + charSet < 0 ; useCharSet = ` ${ Math . abs ( + charSet ) } ` ; } else { useCharSet = ALPHANUMERIC_CHARS ; } } else { useCharSet = ALPHANUMERIC_CHARS ; } } const generateChar = function gc ( len ) { return Math . round ( Math . random ( ) * ( len - 1 ) ) ; } . bind ( null , useCharSet . length ) ; str = Array ( + length ) . fill ( ) . map ( ( v , index ) => { const newChar = generateChar ( ) ; if ( ! index && isAllNumeric && ! newChar ) { return useCharSet . charAt ( newChar + 1 ) ; } return useCharSet . charAt ( newChar ) ; } ) . join ( '' ) ; } if ( isAllNumeric ) { return isNegative ? - + str : + str ; } return str ; } 
function toUint ( str ) { const string = window . btoa ( unescape ( encodeURIComponent ( str ) ) ) , chars = string . split ( '' ) , len = chars . length , uintArray = [ ] ; Array ( len ) . fill ( ) . forEach ( ( val , i ) => uintArray . push ( chars [ i ] . charCodeAt ( 0 ) ) ) ; return new Uint8Array ( uintArray ) ; } 
function toArrayBuffer ( str ) { const len = isString ( str ) ? str . length : 0 , buf = new ArrayBuffer ( len ) , view = new Uint8Array ( buf ) ; Array ( len ) . fill ( ) . forEach ( ( val , i ) => ( view [ i ] = str . charCodeAt ( i ) & 0xFF ) ) ; return view ; } 
function ( key , data ) { 
function ( toolbar , item ) { item . on ( { scope : this , show : this . refreshBackButtonContainer , hide : this . refreshBackButtonContainer } ) ; this . refreshBackButtonContainer ( ) ; } 
function ( toolbar , item ) { item . un ( { scope : this , show : this . refreshBackButtonContainer , hide : this . refreshBackButtonContainer } ) ; this . refreshBackButtonContainer ( ) ; } 
function ( ) { if ( ! this . $backButtonContainer ) { return ; } var i = 0 , backButtonContainer = this . $backButtonContainer , items = backButtonContainer . items , item ; for ( ; i < items . length ; i ++ ) { item = items . get ( i ) ; if ( ! item . isHidden ( ) ) { this . $backButtonContainer . show ( ) ; return ; } } this . $backButtonContainer . hide ( ) ; } 
function ( message , priority , callerId ) { if ( ! this . getEnabled ( ) ) { return this ; } var statics = Logger , priorities = statics . priorities , priorityValue = priorities [ priority ] , caller = this . log . caller , callerDisplayName = '' , writers = this . getWriters ( ) , event , i , originalCaller ; if ( ! priority ) { priority = 'info' ; } if ( priorities [ this . getMinPriority ( ) ] > priorityValue ) { return this ; } if ( ! callerId ) { callerId = 1 ; } if ( Ext . isArray ( message ) ) { message = message . join ( " " ) ; } else { message = String ( message ) ; } if ( typeof callerId == 'number' ) { i = callerId ; do { i -- ; caller = caller . caller ; if ( ! caller ) { break ; } if ( ! originalCaller ) { originalCaller = caller . caller ; } if ( i <= 0 && caller . displayName ) { break ; } } while ( caller !== originalCaller ) ; callerDisplayName = Ext . getDisplayName ( caller ) ; } else { caller = caller . caller ; callerDisplayName = Ext . getDisplayName ( callerId ) + '#' + caller . $name ; } event = { time : Ext . Date . now ( ) , priority : priorityValue , priorityName : priority , message : message , caller : caller , callerDisplayName : callerDisplayName } ; for ( i in writers ) { if ( writers . hasOwnProperty ( i ) ) { writers [ i ] . write ( Ext . merge ( { } , event ) ) ; } } return this ; } 
function writeTemplateFileSync ( source , context , destination ) { var templateContent = fs . readFileSync ( source , 'utf8' ) ; var templateResult ; try { templateResult = _ . template ( templateContent , context ) ; } catch ( error ) { console . error ( 'templateFileSync() error with source' , source , ' and ' , destination ) ; console . error ( error ) ; } fs . writeFileSync ( destination , templateResult ) ; } 
function templateSync ( content , context ) { var templateResult ; try { templateResult = _ . template ( content , context ) ; } catch ( error ) { console . error ( 'templateSync() error with source' , content , 'or content' , context ) ; console . error ( error ) ; } return templateResult ; } 
function copyFileSync ( source , destination ) { if ( validateFileSync ( source ) ) { fs . writeFileSync ( destination , fs . readFileSync ( source ) ) ; } } 
function copyFilesMatchSync ( match , source , destination ) { fs . readdirSync ( source ) . forEach ( function eachTemplate ( filename ) { var sourceFile = path . join ( source , filename ) ; var destinationFile = path . join ( destination , filename ) ; if ( match . test ( path . basename ( filename ) ) ) { fs . writeFileSync ( destinationFile , fs . readFileSync ( sourceFile ) ) ; } } ) ; } 
function replaceMatchFilesSync ( match , source , destination ) { unlinkFilesMatchSync ( match , destination ) ; copyFilesMatchSync ( match , source , destination ) ; } 
function unlinkFilesMatchSync ( match , location ) { fs . readdirSync ( location ) . forEach ( function eachTemplate ( filename ) { if ( match . test ( path . basename ( filename ) ) ) { var filePath = path . join ( location , filename ) ; if ( validateFileSync ( filePath ) ) { fs . unlinkSync ( filePath ) ; } } } ) ; } 
function validateDirectorySync ( path , errorMessage ) { errorMessage = errorMessage || 'Error validateDirectorySync() the directory path is not valid ' + path ; var isValid = existsDirectorySync ( path ) ; if ( ! isValid ) { console . error ( errorMessage ) ; } return isValid ; } 
function validateFileSync ( path , errorMessage ) { errorMessage = errorMessage || 'Error validateFileSync() the file path is not valid ' + path ; var isValid = existsFileSync ( path ) ; if ( ! isValid ) { console . error ( errorMessage ) ; } return isValid ; } 
function subDirectoriesWithFile ( base , filename ) { var result = [ ] ; if ( fs . existsSync ( base ) && fs . statSync ( base ) . isDirectory ( ) ) { if ( fs . existsSync ( path . join ( base , filename ) ) ) { result . push ( base ) ; } fs . readdirSync ( base ) . forEach ( function ( subdir ) { result . push . apply ( result , subDirectoriesWithFile ( path . join ( base , subdir ) , filename ) ) ; } ) ; } return result ; } 
function maximisePath ( ) { 
function resolveDirMatches ( directory , match ) { if ( validateDirectorySync ( directory ) ) { return fs . readdirSync ( directory ) . filter ( function eachDirectoryItem ( item ) { var resolved = path . resolve ( path . join ( directory , item ) ) ; return match . test ( item ) && fs . statSync ( resolved ) . isDirectory ( ) ; } ) . sort ( compareHigher ) ; } else { return [ ] ; } } 
function compareHigher ( a , b ) { var numA = parseFloat ( / [\d\.]+$ / . exec ( a ) [ 0 ] ) ; var numB = parseFloat ( / [\d\.]+$ / . exec ( b ) [ 0 ] ) ; if ( isNaN ( numA ) || ( numB > numA ) ) { return + 1 ; } else if ( isNaN ( numB ) || ( numA > numB ) ) { return - 1 ; } else { return 0 ; } } 
function reduceDirectories ( ) { return Array . prototype . slice . call ( arguments ) . map ( function ( candidate ) { return path . normalize ( candidate ) ; } ) . filter ( function ( candidate ) { return fs . existsSync ( candidate ) && fs . statSync ( candidate ) . isDirectory ( ) ; } ) . shift ( ) ; } 
function ( menu , config ) { var me = this ; config = config || { } ; 
function ( side ) { var menus = this . getMenus ( ) || { } , menu = menus [ side ] ; if ( menu ) this . hideMenu ( side ) ; delete menus [ side ] ; this . setMenus ( menus ) ; } 
function ( side ) { var menus = this . getMenus ( ) , menu = menus [ side ] , before , after , viewportBefore , viewportAfter ; if ( ! menu || menu . isAnimating ) { return ; } this . hideOtherMenus ( side ) ; before = { translateX : 0 , translateY : 0 } ; after = { translateX : 0 , translateY : 0 } ; viewportBefore = { translateX : 0 , translateY : 0 } ; viewportAfter = { translateX : 0 , translateY : 0 } ; if ( menu . $reveal ) { Ext . getBody ( ) . insertFirst ( menu . element ) ; } else { Ext . Viewport . add ( menu ) ; } menu . show ( ) ; menu . addCls ( 'x-' + side ) ; var size = ( side == 'left' || side == 'right' ) ? menu . element . getWidth ( ) : menu . element . getHeight ( ) ; if ( side == 'left' ) { before . translateX = - size ; viewportAfter . translateX = size ; } else if ( side == 'right' ) { before . translateX = size ; viewportAfter . translateX = - size ; } else if ( side == 'top' ) { before . translateY = - size ; viewportAfter . translateY = size ; } else if ( side == 'bottom' ) { before . translateY = size ; viewportAfter . translateY = - size ; } if ( menu . $reveal ) { if ( Ext . browser . getPreferredTranslationMethod ( ) != 'scrollposition' ) { menu . translate ( 0 , 0 ) ; } } else { menu . translate ( before . translateX , before . translateY ) ; } if ( menu . $cover ) { menu . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; } , this , { single : true } ) ; menu . translate ( after . translateX , after . translateY , { preserveEndState : true , duration : 200 } ) ; } else { this . translate ( viewportBefore . translateX , viewportBefore . translateY ) ; this . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; } , this , { single : true } ) ; this . translate ( viewportAfter . translateX , viewportAfter . translateY , { preserveEndState : true , duration : 200 } ) ; } 
function ( side , animate ) { var menus = this . getMenus ( ) , menu = menus [ side ] , after , viewportAfter , size ; animate = ( animate === false ) ? false : true ; if ( ! menu || ( menu . isHidden ( ) || menu . isAnimating ) ) { return ; } after = { translateX : 0 , translateY : 0 } ; viewportAfter = { translateX : 0 , translateY : 0 } ; size = ( side == 'left' || side == 'right' ) ? menu . element . getWidth ( ) : menu . element . getHeight ( ) ; if ( side == 'left' ) { after . translateX = - size ; } else if ( side == 'right' ) { after . translateX = size ; } else if ( side == 'top' ) { after . translateY = - size ; } else if ( side == 'bottom' ) { after . translateY = size ; } if ( menu . $cover ) { if ( animate ) { menu . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; menu . hide ( ) ; } , this , { single : true } ) ; menu . translate ( after . translateX , after . translateY , { preserveEndState : true , duration : 200 } ) ; } else { menu . translate ( after . translateX , after . translateY ) ; menu . hide ( ) } } else { if ( animate ) { this . getTranslatable ( ) . on ( 'animationend' , function ( ) { menu . isAnimating = false ; menu . hide ( ) ; } , this , { single : true } ) ; this . translate ( viewportAfter . translateX , viewportAfter . translateY , { preserveEndState : true , duration : 200 } ) ; } else { this . translate ( viewportAfter . translateX , viewportAfter . translateY ) ; menu . hide ( ) ; } } } 
function ( side , animation ) { var menus = this . getMenus ( ) ; for ( var menu in menus ) { if ( side != menu ) { this . hideMenu ( menu , animation ) ; } } } 
function ( side ) { var menus = this . getMenus ( ) , menu ; if ( menus [ side ] ) { menu = menus [ side ] ; if ( menu . isHidden ( ) ) { this . showMenu ( side ) ; } else { this . hideMenu ( side ) ; } } } 
function timer ( options ) { if ( _ . isFunction ( options ) ) { options = { out : options } ; } options = options || { } ; this . _out = options . out || _ . stderr ; this . _times = { } ; } 
function init ( adapter , config ) { if ( ! fs ) { var Adapter = require ( './adapters/' + adapter ) ; fs = new Adapter ( config ) ; } } 
function getHierarchy ( cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':hierarchy' ] ) ; } ) ; } 
function getBackends ( cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':backends' ] ) ; } ) ; } 
function getBackendConfig ( backend , cb ) { getConfig ( function ( err , config ) { if ( err ) { cb ( err ) ; return ; } cb ( null , config [ ':' + backend ] ) ; } ) ; } 
function getFile ( backend , file , cb ) { getBackendConfig ( backend , function ( err , config ) { file = [ config [ ':datadir' ] , '/' , file ] . join ( '' ) ; fs . readFile ( file , cb ) ; } ) ; } 
function saveFile ( backend , file , data , cb ) { cb = typeof ( cb ) === 'function' ? cb : function ( ) { } ; getBackendConfig ( backend , function ( err , config ) { var datadir = config [ ':datadir' ] ; file = path . join ( datadir , file ) ; fs . writeFile ( file , data , cb ) ; } ) ; } 
function getOverrides ( backend , file , cb ) { async . parallel ( [ function hierarchy ( cb ) { getHierarchy ( cb ) ; } , function backendConfig ( cb ) { getBackendConfig ( backend , cb ) ; } ] , function ( err , results ) { var hierarchy , datadir , filename , tasks , pos , searchHierarchy , tasks ; hierarchy = results [ 0 ] ; datadir = results [ 1 ] [ ':datadir' ] ; filename = file . remove ( '.' + backend ) ; tasks = [ ] ; 
function ( me , e ) { 
function parse ( session , file ) { if ( ! this . match ( file ) ) { return ; } var fn = util . require ( file ) ; fn ( session . suite , session ) ; } 
function pdf ( x , options ) { var opts = { } , ctor , err , out , dt , d ; if ( arguments . length > 1 ) { err = validate ( opts , options ) ; if ( err ) { throw err ; } } opts . mu = typeof opts . mu !== 'undefined' ? opts . mu : 0 ; opts . sigma = typeof opts . sigma !== 'undefined' ? opts . sigma : 1 ; if ( isNumber ( x ) ) { return pdf1 ( x , opts . mu , opts . sigma ) ; } if ( isMatrixLike ( x ) ) { if ( opts . copy !== false ) { dt = opts . dtype || 'float64' ; ctor = ctors ( dt ) ; if ( ctor === null ) { throw new Error ( 'pdf()::invalid option. Data type option does not have a corresponding array constructor. Option: `' + dt + '`.' ) ; } 
function done ( result , callback ) { if ( ! _ . isFunction ( callback ) ) return process . nextTick ( function ( ) { callback ( null , result ) } ) } 
function fail ( err , callback ) { if ( ! _ . isFunction ( callback ) ) return let uError = new Error ( 'Unknown Error' ) err = err ? _ . isError ( err ) ? err : _ . isString ( err ) ? new Error ( err ) : uError : uError process . nextTick ( function ( ) { callback ( err ) } ) } 
function cb ( callback ) { callback = _ . isArguments ( callback ) ? acb ( callback ) : callback return function ( err , result ) { if ( err ) return fail ( err , callback ) done ( result , callback ) } } 
function acb ( args ) { args = _ . toArray ( args ) return _ . find ( _ . reverse ( args ) , function ( arg ) { return _ . isFunction ( arg ) } ) || function ( ) { } } 
function ( data ) { var fieldsCollection = this . getModel ( ) . getFields ( ) ; if ( fieldsCollection . isDirty ) { this . buildExtractors ( true ) ; delete fieldsCollection . isDirty ; } if ( this . rootAccessor ) { return this . rootAccessor . call ( this , data ) ; } else { return data ; } } 
function arrIncludes ( arr , values ) { if ( ! Array . isArray ( values ) ) { return inArray ( arr , values ) } var len = values . length ; var i = - 1 ; while ( i ++ < len ) { var j = inArray ( arr , values [ i ] ) ; if ( j ) { return j } } return false } 
function functionArguments ( fn ) { if ( typeof fn !== 'function' ) { throw new TypeError ( 'function-arguments expect a function' ) } if ( fn . length === 0 ) { return [ ] } 
function isAsyncFunction ( fn , names , strict ) { if ( typeof fn !== 'function' ) { throw new TypeError ( 'is-async-function expect a function' ) } strict = typeof names === 'boolean' ? names : strict ; strict = typeof strict === 'boolean' ? strict : true ; names = typeof names === 'boolean' ? null : names ; names = Array . isArray ( names ) ? names : index ( names ) ; names = names . length ? names : index$8 ; var idx = index$6 ( names , index$10 ( fn ) ) ; return strict ? Boolean ( idx ) : idx } 
function redolent ( fn , opts ) { if ( typeof fn !== 'function' ) { throw new TypeError ( 'redolent: expect `fn` to be a function' ) } opts = index$2 ( { context : this , Promise : Promize } , opts ) ; opts . Promise = register ( opts ) ; 
function isPromise ( val , Promize$$1 ) { return val instanceof Promize$$1 || ( val !== null && typeof val === 'object' && typeof val . then === 'function' && typeof val . catch === 'function' ) } 
function all ( src ) { let ret = { } _ . forIn ( exports , ( v , k ) => { if ( ! _ . isFunction ( v ) || _ . includes ( ALL_EXCLUDE_KEYS , k ) ) return ret [ k ] = _ . attempt ( v , src ) } ) return ret } 
function clean ( src ) { let pidx = src . indexOf ( 'http' ) if ( pidx > 0 ) src = src . substr ( pidx ) return src ? pidx >= 0 || src . indexOf ( '//' ) >= 0 ? src : '/' + src : '' } 
function jquery ( src ) { src = clean ( src ) ; let params = { } let match = null if ( ! url || ! _ . isString ( src ) ) return params while ( match = REGX_QUERY_OBJECT . exec ( src ) ) { params [ match [ 1 ] ] = match [ 2 ] } return params } 
function validate ( opts , options ) { if ( ! isObject ( options ) ) { return new TypeError ( 'transpose()::invalid input argument. Options argument must be an object. Value: `' + options + '`.' ) ; } if ( options . hasOwnProperty ( 'copy' ) ) { opts . copy = options . copy ; if ( ! isBoolean ( opts . copy ) ) { return new TypeError ( 'transpose()::invalid option. Copy option must be a boolean primitive. Option: `' + opts . copy + '`.' ) ; } } return null ; } 
function ( el , options ) { events . EventEmitter . call ( this ) ; this . el = el ; this . options = extend ( { } , this . options ) ; extend ( this . options , options ) ; this . showTab = this . _show ; this . _init ( ) ; } 
function toURI ( obj , dontEncode ) { const arr = [ ] ; let paramVal ; if ( isObject ( obj ) && ! isArray ( obj ) ) { Object . keys ( obj ) . forEach ( ( val ) => { if ( isArray ( obj [ val ] ) ) { paramVal = ` ${ obj [ val ] . join ( ',' ) } ` ; } else { paramVal = obj [ val ] ; } if ( dontEncode ) { arr . push ( ` ${ val } ${ paramVal } ` ) ; } else { arr . push ( ` ${ encodeURIComponent ( val ) } ${ encodeURIComponent ( paramVal ) } ` ) ; } } ) ; } return arr . join ( '&' ) ; } 
function toParam ( obj , dontEncode ) { const arr = [ ] ; let vals ; if ( isObject ( obj ) && ! isArray ( obj ) ) { Object . keys ( obj ) . forEach ( ( val ) => { if ( isArray ( obj [ val ] ) ) { vals = ` ${ obj [ val ] . map ( v => ( isNaN ( v ) ? ` ${ v } ` : v ) ) . join ( ',' ) } ` ; } else { vals = isNaN ( obj [ val ] ) ? ` ${ obj [ val ] } ` : obj [ val ] ; } arr . push ( ` ${ val } ${ vals } ` ) ; } ) ; if ( dontEncode ) { return ` ${ arr . join ( ',' ) } ` ; } return encodeURIComponent ( ` ${ arr . join ( ',' ) } ` ) ; } return '' ; } 
function ( config ) { var defaultConfig = Ext . device . geolocation . Abstract . prototype . config ; config = Ext . applyIf ( config , { maximumAge : defaultConfig . maximumAge , frequency : defaultConfig . frequency , allowHighAccuracy : defaultConfig . allowHighAccuracy , timeout : defaultConfig . timeout } ) ; 
function ( anchor , local , size ) { 
function ( el , position , offsets , local ) { 
function ( key , obj ) { var me = this , myObj = obj , myKey = key , old ; if ( arguments . length == 1 ) { myObj = myKey ; myKey = me . getKey ( myObj ) ; } if ( typeof myKey != 'undefined' && myKey !== null ) { old = me . map [ myKey ] ; if ( typeof old != 'undefined' ) { return me . replace ( myKey , myObj ) ; } me . map [ myKey ] = myObj ; } me . length ++ ; me . items . push ( myObj ) ; me . keys . push ( myKey ) ; me . fireEvent ( 'add' , me . length - 1 , myObj , myKey ) ; return myObj ; } 
function ( key , o ) { var me = this , old , index ; if ( arguments . length == 1 ) { o = arguments [ 0 ] ; key = me . getKey ( o ) ; } old = me . map [ key ] ; if ( typeof key == 'undefined' || key === null || typeof old == 'undefined' ) { return me . add ( key , o ) ; } index = me . indexOfKey ( key ) ; me . items [ index ] = o ; me . map [ key ] = o ; me . fireEvent ( 'replace' , key , old , o ) ; return o ; } 
function ( objs ) { var me = this , i = 0 , args , len , key ; if ( arguments . length > 1 || Ext . isArray ( objs ) ) { args = arguments . length > 1 ? arguments : objs ; for ( len = args . length ; i < len ; i ++ ) { me . add ( args [ i ] ) ; } } else { for ( key in objs ) { if ( objs . hasOwnProperty ( key ) ) { if ( me . allowFunctions || typeof objs [ key ] != 'function' ) { me . add ( key , objs [ key ] ) ; } } } } } 
function ( fn , scope ) { var items = [ ] . concat ( this . items ) , 
function ( index , key , obj ) { var me = this , myKey = key , myObj = obj ; if ( arguments . length == 2 ) { myObj = myKey ; myKey = me . getKey ( myObj ) ; } if ( me . containsKey ( myKey ) ) { me . suspendEvents ( ) ; me . removeAtKey ( myKey ) ; me . resumeEvents ( ) ; } if ( index >= me . length ) { return me . add ( myKey , myObj ) ; } me . length ++ ; Ext . Array . splice ( me . items , index , 0 , myObj ) ; if ( typeof myKey != 'undefined' && myKey !== null ) { me . map [ myKey ] = myObj ; } Ext . Array . splice ( me . keys , index , 0 , myKey ) ; me . fireEvent ( 'add' , index , myObj , myKey ) ; return myObj ; } 
function ( ) { var me = this ; me . length = 0 ; me . items = [ ] ; me . keys = [ ] ; me . map = { } ; me . fireEvent ( 'clear' ) ; } 
function ( property , value , anyMatch , caseSensitive ) { var filters = [ ] , filterFn ; 
function create_user ( options ) { options = options || { } ; var success = options . success || function ( ) { terminal . exit ( '\nUser created!\n\n' ) ; } , error = options . error || function ( err ) { terminal . abort ( 'Failed to created user' , err ) ; } ; program . prompt ( 'username: ' , function ( username ) { program . password ( 'password: ' , '*' , function ( password ) { program . password ( 'confirm password: ' , '*' , function ( password2 ) { if ( password != password2 ) { terminal . abort ( 'Password do not match, bailing out.' ) ; } program . prompt ( 'email: ' , function ( email ) { var body = { username : username , password : password , email : email } , db = require ( 'captain-core/lib/db' ) ; db . users . create ( body , function ( err ) { if ( err ) { error ( err ) ; } else { success ( ) ; } } ) ; } ) ; } ) ; } ) ; } ) ; } 
function syncdb ( ) { function _syncdb ( drop ) { var db = require ( 'captain-core/lib/db' ) ; db . syncDB ( { complete : function ( err ) { if ( err ) { terminal . abort ( 'Failed syncing' , err ) ; } else { terminal . exit ( '\nAll done\n\n' ) ; } } , progress : function ( script , file ) { console . log ( 'Executing:' , file ) ; if ( program . verbose ) { console . log ( '========\n%s\n' , script ) ; } } , drop : drop } ) ; } if ( program . drop ) { if ( ! program . force ) { program . prompt ( 'This will drop all databases, are you sure you want to proceed? (y/N): ' , function ( answer ) { if ( ! ! answer . match ( / y|yes|arrr / i ) ) { fn ( true ) ; } else { terminal . exit ( 'Exiting.' ) ; } } ) ; } else { _syncdb ( true ) ; } } else { _syncdb ( false ) ; } } 
function load_data ( filename ) { var files = [ ] , db = require ( 'captain-core/lib/db' ) ; if ( filename === true ) { program . help ( ) ; } if ( helpers . isDirectory ( filename ) ) { fs . readdirSync ( filename ) . forEach ( function ( file ) { files . push ( join ( filename , file ) ) ; } ) ; } else { files . push ( filename ) ; } async . series ( files . map ( db . load ) , function ( err ) { if ( err ) { terminal . abort ( 'Failed loading data' , err ) ; } else { terminal . exit ( '\nAll done.\n\n' ) ; } } ) ; } 
function init ( target ) { function create_project ( name , uri ) { console . log ( ) ; console . log ( terminal . cyan ( 'Creating project: ' ) + name ) ; console . log ( ) ; 
function themes ( ) { var themes = fs . readdirSync ( join ( PROJECT_ROOT , 'themes' ) ) ; console . log ( terminal . cyan ( 'Available themes:' ) ) ; console . log ( themes . map ( helpers . pad ) . join ( helpers . EOL ) ) ; } 
function theme ( target ) { if ( target === true ) { program . help ( ) ; } if ( helpers . isCaptainProject ( ) ) { helpers . copyR ( [ join ( 'themes' , target ) ] , '.' ) ; } else { terminal . abort ( 'Not a Captain project' ) ; } } 
function run ( ) { process . env [ 'NODE_PATH' ] = resolve ( PROJECT_ROOT , '..' ) ; helpers . countUsers ( function ( err , count ) { if ( err ) { throw err ; } if ( count > 0 ) { _run ( ) ; } else { terminal . abort ( 'You need to create at least one user with `captain create_user`' ) ; } } ) ; function _run ( ) { 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem#requestFileSystem: You must specify a `success` callback.' ) ; return null ; } Ext . device . Communicator . send ( { command : 'FileSystem#requestFileSystem' , callbacks : { success : function ( id ) { var fileSystem = Ext . create ( 'Ext.device.filesystem.FileSystem' , id ) ; config . success . call ( config . scope || this , fileSystem ) ; } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; } 
function ( config ) { Ext . device . Communicator . send ( { command : 'FileSystem#remove' , path : this . path , fileSystemId : this . fileSystem . id , recursively : config . recursively , callbacks : { success : function ( ) { if ( config . success ) { config . success . call ( config . scope || this ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'Ext.device.filesystem.DirectoryEntry#readEntries: You must specify a `success` callback.' ) ; return null ; } var me = this ; Ext . device . Communicator . send ( { command : 'FileSystem#readEntries' , path : this . path , fileSystemId : this . fileSystem . id , callbacks : { success : function ( entryInfos ) { var entries = entryInfos . map ( function ( entryInfo ) { return entryInfo . directory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , entryInfo . path , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , entryInfo . path , me . fileSystem ) ; } ) ; config . success . call ( config . scope || this , entries ) ; } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; } 
function ( config ) { if ( config . path == null ) { Ext . Logger . error ( 'Ext.device.filesystem.DirectoryEntry#getFile: You must specify a `path` of the file.' ) ; return null ; } if ( config . options == null ) { config . options = { } ; } var me = this ; Ext . device . Communicator . send ( { command : 'FileSystem#getEntry' , path : this . path , fileSystemId : this . fileSystem . id , newPath : config . path , directory : config . directory , create : config . options . create , exclusive : config . options . exclusive , callbacks : { success : function ( path ) { if ( config . success ) { var entry = config . directory ? Ext . create ( 'Ext.device.filesystem.DirectoryEntry' , path , me . fileSystem ) : Ext . create ( 'Ext.device.filesystem.FileEntry' , path , me . fileSystem ) ; config . success . call ( config . scope || this , entry ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; } 
function ( config ) { var me = this ; Ext . device . Communicator . send ( { command : 'FileSystem#read' , path : this . path , fileSystemId : this . fileSystem . id , offset : this . offset , length : config . length , callbacks : { success : function ( result ) { me . offset = result . offset ; if ( config . success ) { config . success . call ( config . scope || this , result . data ) ; } } , failure : function ( error ) { if ( config . failure ) { config . failure . call ( config . scope || this , error ) ; } } } , scope : config . scope || this } ) ; } 
function toHaveText ( ) { return { compare : function compare ( element , text ) { var regexp = text instanceof RegExp ? text : new RegExp ( text , 'ig' ) ; var pass = element . getDOMNode ( ) . textContent . match ( regexp ) ; var message = pass ? 'Text "' + text + '" is found within an element' : 'Text "' + text + '" is not found within an element' ; return { pass : pass , message : message } ; } } ; } 
function ( ) { var me = this , container = me . container , baseCls = me . getBaseCls ( ) , scrollable , scrollViewElement , pinnedHeader ; Ext . apply ( me , { listItems : [ ] , headerItems : [ ] , updatedItems : [ ] , headerMap : [ ] , scrollDockItems : { top : [ ] , bottom : [ ] } } ) ; 
function ( ) { var me = this , container = me . container , scrollViewElement = me . scrollViewElement , indexBar = me . getIndexBar ( ) , triggerEvent = me . getTriggerEvent ( ) , triggerCtEvent = me . getTriggerCtEvent ( ) ; if ( indexBar ) { scrollViewElement . appendChild ( indexBar . renderElement ) ; } if ( triggerEvent ) { me . on ( triggerEvent , me . onItemTrigger , me ) ; } if ( triggerCtEvent ) { me . on ( triggerCtEvent , me . onContainerTrigger , me ) ; } container . element . on ( { delegate : '.' + me . getBaseCls ( ) + '-disclosure' , tap : 'handleItemDisclosure' , scope : me } ) ; container . element . on ( { resize : 'onContainerResize' , scope : me } ) ; 
function ( index ) { var listItems = this . listItems , ln = listItems . length , i , listItem ; for ( i = 0 ; i < ln ; i ++ ) { listItem = listItems [ i ] ; if ( listItem . $dataIndex == index ) { return listItem ; } } } 
function ( me , index , target , record , e ) { if ( ! ( this . getPreventSelectionOnDisclose ( ) && Ext . fly ( e . target ) . hasCls ( this . getBaseCls ( ) + '-disclosure' ) ) ) { this . callParent ( arguments ) ; } } 
function notify ( arg1 , arg2 , arg3 ) { var argsLength = arguments . length ; return new P ( function ( resolve , reject ) { var filesCsv = null ; var requestUrl = null ; var host = null ; var port = null ; var files = null ; if ( argsLength === 3 ) { host = arg1 ; port = arg2 ; files = arg3 ; } else if ( argsLength === 2 ) { host = DEFAULT_HOST ; port = arg1 ; files = arg2 ; } else if ( argsLength === 1 ) { host = DEFAULT_HOST ; port = DEFAULT_PORT ; files = arg1 ; } requestUrl = 'http://' + host + ':' + port + '/changed?files=' ; if ( host == null || port == null || files == null ) { return reject ( new Error ( 'host, port and files are all required fields!' ) ) ; } 
function ( name , value ) { if ( Ext . isObject ( name ) && arguments . length === 1 ) { Ext . merge ( this . config , name ) ; } else { this . config [ name ] = ( Ext . isObject ( value ) ) ? Ext . merge ( this . config [ name ] , value ) : value ; } setPathCount += 1 ; return this ; } 
function ( className ) { var path = '' , paths = this . config . paths , prefix = this . getPrefix ( className ) ; if ( prefix . length > 0 ) { if ( prefix === className ) { return paths [ prefix ] ; } path = paths [ prefix ] ; className = className . substring ( prefix . length + 1 ) ; } if ( path . length > 0 ) { path += '/' ; } return path . replace ( / \/\.\/ / g , '/' ) + className . replace ( / \. / g , "/" ) + '.js' ; } 
function ( excludes ) { var me = this ; return { require : function ( expressions , fn , scope ) { return me . require ( expressions , fn , scope , excludes ) ; } , syncRequire : function ( expressions , fn , scope ) { return me . syncRequire ( expressions , fn , scope , excludes ) ; } } ; } 
function ( url , onLoad , onError , scope , charset ) { var script = document . createElement ( 'script' ) , me = this , onLoadFn = function ( ) { me . cleanupScriptElement ( script ) ; onLoad . call ( scope ) ; } , onErrorFn = function ( ) { me . cleanupScriptElement ( script ) ; onError . call ( scope ) ; } ; script . type = 'text/javascript' ; script . src = url ; script . onload = onLoadFn ; script . onerror = onErrorFn ; script . onreadystatechange = function ( ) { if ( this . readyState === 'loaded' || this . readyState === 'complete' ) { onLoadFn ( ) ; } } ; if ( charset ) { script . charset = charset ; } this . documentHead . appendChild ( script ) ; return script ; } 
function ( url , onLoad , onError , scope , synchronous ) { var me = this , isFileLoaded = this . isFileLoaded , scriptElements = this . scriptElements , noCacheUrl = url + ( this . getConfig ( 'disableCaching' ) ? ( '?' + this . getConfig ( 'disableCachingParam' ) + '=' + Ext . Date . now ( ) ) : '' ) , xhr , status , content , onScriptError ; if ( isFileLoaded [ url ] ) { return this ; } scope = scope || this ; this . isLoading = true ; if ( ! synchronous ) { onScriptError = function ( ) { 
function ( ) { var syncModeEnabled = this . syncModeEnabled ; if ( ! syncModeEnabled ) { this . syncModeEnabled = true ; } this . require . apply ( this , arguments ) ; if ( ! syncModeEnabled ) { this . syncModeEnabled = false ; } this . refreshQueue ( ) ; } 
function ( expressions , fn , scope , excludes ) { var excluded = { } , included = { } , queue = this . queue , classNameToFilePathMap = this . classNameToFilePathMap , isClassFileLoaded = this . isClassFileLoaded , excludedClassNames = [ ] , possibleClassNames = [ ] , classNames = [ ] , references = [ ] , callback , syncModeEnabled , filePath , expression , exclude , className , possibleClassName , i , j , ln , subLn ; if ( excludes ) { excludes = arrayFrom ( excludes ) ; for ( i = 0 , ln = excludes . length ; i < ln ; i ++ ) { exclude = excludes [ i ] ; if ( typeof exclude == 'string' && exclude . length > 0 ) { excludedClassNames = Manager . getNamesByExpression ( exclude ) ; for ( j = 0 , subLn = excludedClassNames . length ; j < subLn ; j ++ ) { excluded [ excludedClassNames [ j ] ] = true ; } } } } expressions = arrayFrom ( expressions ) ; if ( fn ) { if ( fn . length > 0 ) { callback = function ( ) { var classes = [ ] , i , ln , name ; for ( i = 0 , ln = references . length ; i < ln ; i ++ ) { name = references [ i ] ; classes . push ( Manager . get ( name ) ) ; } return fn . apply ( this , classes ) ; } ; } else { callback = fn ; } } else { callback = Ext . emptyFn ; } scope = scope || Ext . global ; for ( i = 0 , ln = expressions . length ; i < ln ; i ++ ) { expression = expressions [ i ] ; if ( typeof expression == 'string' && expression . length > 0 ) { possibleClassNames = Manager . getNamesByExpression ( expression ) ; subLn = possibleClassNames . length ; for ( j = 0 ; j < subLn ; j ++ ) { possibleClassName = possibleClassNames [ j ] ; if ( excluded [ possibleClassName ] !== true ) { references . push ( possibleClassName ) ; if ( ! Manager . isCreated ( possibleClassName ) && ! included [ possibleClassName ] ) { included [ possibleClassName ] = true ; classNames . push ( possibleClassName ) ; } } } } } 
async function ( fname , attrs ) { let partialDirs ; if ( typeof module . exports . configuration . partialDirs === 'undefined' || ! module . exports . configuration . partialDirs || module . exports . configuration . partialDirs . length <= 0 ) { partialDirs = [ __dirname ] ; } else { partialDirs = module . exports . configuration . partialDirs ; } var partialFound = await globfs . findAsync ( partialDirs , fname ) ; if ( ! partialFound ) throw new Error ( ` ${ fname } ${ util . inspect ( partialDirs ) } ` ) ; try { const t = literal(partialText); return t(attrs); } catch (e) { throw new Error(`Literal rendering of ${fname} failed because of ${e}`); } } */ else if ( / \.html$ / i . test ( partialFname ) ) { 
function ( record ) { var me = this , fields = record . getFields ( ) , idProperty = record . getIdProperty ( ) , uniqueIdStrategy = me . getUniqueIdStrategy ( ) , data = { } , name , value ; fields . each ( function ( field ) { if ( field . getPersist ( ) ) { name = field . getName ( ) ; if ( name === idProperty && ! uniqueIdStrategy ) { return ; } value = record . get ( name ) ; if ( field . getType ( ) . type == 'date' ) { value = me . writeDate ( field , value ) ; } data [ name ] = value ; } } , me ) ; return data ; } 
function ( provider ) { var me = this , args = Ext . toArray ( arguments ) , i = 0 , ln ; if ( args . length > 1 ) { for ( ln = args . length ; i < ln ; ++ i ) { me . addProvider ( args [ i ] ) ; } return ; } 
function ( provider ) { var me = this , providers = me . providers ; provider = provider . isProvider ? provider : providers . get ( provider ) ; if ( provider ) { provider . un ( 'data' , me . onProviderData , me ) ; providers . remove ( provider ) ; return provider ; } return null ; } 
function ( fn ) { if ( Ext . isString ( fn ) ) { var parts = fn . split ( '.' ) , i = 0 , ln = parts . length , current = window ; while ( current && i < ln ) { current = current [ parts [ i ] ] ; ++ i ; } fn = Ext . isFunction ( current ) ? current : null ; } return fn || null ; } 
function ( config ) { config = config || { } ; Ext . applyIf ( config , { application : this } ) ; this . initConfig ( config ) ; 
function ( action , addToHistory ) { action = action || { } ; Ext . applyIf ( action , { application : this } ) ; action = Ext . factory ( action , Ext . app . Action ) ; if ( action ) { var profile = this . getCurrentProfile ( ) , profileNS = profile ? profile . getNamespace ( ) : undefined , controller = this . getController ( action . getController ( ) , profileNS ) ; if ( controller ) { if ( addToHistory !== false ) { this . getHistory ( ) . add ( action , true ) ; } controller . execute ( action ) ; } } } 
function ( url ) { if ( Ext . data && Ext . data . Model && url instanceof Ext . data . Model ) { var record = url ; url = record . toUrl ( ) ; } var decoded = this . getRouter ( ) . recognize ( url ) ; if ( decoded ) { decoded . url = url ; if ( record ) { decoded . data = { } ; decoded . data . record = record ; } return this . dispatch ( decoded ) ; } } 
function ( name , profileName ) { var instances = this . getControllerInstances ( ) , appName = this . getName ( ) , format = Ext . String . format , topLevelName ; if ( name instanceof Ext . app . Controller ) { return name ; } if ( instances [ name ] ) { return instances [ name ] ; } else { topLevelName = format ( "{0}.controller.{1}" , appName , name ) ; profileName = format ( "{0}.controller.{1}.{2}" , appName , profileName , name ) ; return instances [ profileName ] || instances [ topLevelName ] ; } } 
function ( masked ) { var isVisible = true , currentMask ; if ( masked === false ) { masked = true ; isVisible = false ; } currentMask = Ext . factory ( masked , Ext . Mask , this . getMasked ( ) ) ; if ( currentMask ) { this . add ( currentMask ) ; currentMask . setHidden ( ! isVisible ) ; } return currentMask ; } 
function ( ) { delete this . onItemAdd ; if ( this . innerHtmlElement && ! this . getHtml ( ) ) { this . innerHtmlElement . destroy ( ) ; delete this . innerHtmlElement ; } this . on ( 'innerstatechange' , 'onItemInnerStateChange' , this , { delegate : '> component' } ) ; return this . onItemAdd . apply ( this , arguments ) ; } 
function ( ) { var layout = this . layout ; if ( ! layout ) { layout = this . link ( '_layout' , this . link ( 'layout' , Ext . factory ( this . _layout || 'default' , Ext . layout . Default , null , 'layout' ) ) ) ; layout . setContainer ( this ) ; } return layout ; } 
function ( newItems ) { var me = this , i , ln , item , newActiveItem ; if ( Ext . isArray ( newItems ) ) { for ( i = 0 , ln = newItems . length ; i < ln ; i ++ ) { item = me . factoryItem ( newItems [ i ] ) ; this . doAdd ( item ) ; if ( ! newActiveItem && ! this . getActiveItem ( ) && this . innerItems . length > 0 && item . isInnerItem ( ) ) { newActiveItem = item ; } } } else { item = me . factoryItem ( newItems ) ; this . doAdd ( item ) ; if ( ! newActiveItem && ! this . getActiveItem ( ) && this . innerItems . length > 0 && item . isInnerItem ( ) ) { newActiveItem = item ; } } if ( newActiveItem ) { this . setActiveItem ( newActiveItem ) ; } return item ; } 
function ( item , destroy ) { var me = this , index = me . indexOf ( item ) , innerItems = me . getInnerItems ( ) ; if ( destroy === undefined ) { destroy = me . getAutoDestroy ( ) ; } if ( index !== - 1 ) { if ( ! me . removingAll && innerItems . length > 1 && item === me . getActiveItem ( ) ) { me . on ( { activeitemchange : 'doRemove' , scope : me , single : true , order : 'after' , args : [ item , index , destroy ] } ) ; me . doResetActiveItem ( innerItems . indexOf ( item ) ) ; } else { me . doRemove ( item , index , destroy ) ; if ( innerItems . length === 0 ) { me . setActiveItem ( null ) ; } } } return me ; } 
function ( destroy , everything ) { var items = this . items , ln = items . length , i = 0 , item ; if ( typeof destroy != 'boolean' ) { destroy = this . getAutoDestroy ( ) ; } everything = Boolean ( everything ) ; 
function ( index , item ) { var me = this , i ; 
function ( ) { var items = this . getItems ( ) . items , dockedItems = [ ] , ln = items . length , item , i ; for ( i = 0 ; i < ln ; i ++ ) { item = items [ i ] ; if ( item . isDocked ( ) ) { dockedItems . push ( item ) ; } } return dockedItems ; } 
function ( activeItem , animation ) { var layout = this . getLayout ( ) , defaultAnimation ; if ( this . activeItemAnimation ) { this . activeItemAnimation . destroy ( ) ; } this . activeItemAnimation = animation = new Ext . fx . layout . Card ( animation ) ; if ( animation && layout . isCard ) { animation . setLayout ( layout ) ; defaultAnimation = layout . getAnimation ( ) ; if ( defaultAnimation ) { defaultAnimation . disable ( ) ; } animation . on ( 'animationend' , function ( ) { if ( defaultAnimation ) { defaultAnimation . enable ( ) ; } animation . destroy ( ) ; } , this ) ; } return this . setActiveItem ( activeItem ) ; } 
function ( deep ) { var items = this . getItems ( ) . items . slice ( ) , ln = items . length , i , item ; if ( deep ) { for ( i = 0 ; i < ln ; i ++ ) { item = items [ i ] ; if ( item . getRefItems ) { items = items . concat ( item . getRefItems ( true ) ) ; } } } return items ; } 
function ( component ) { if ( Ext . isObject ( component ) ) { component = component . getItemId ( ) ; } return this . getItems ( ) . get ( component ) ; } 
function ( component ) { if ( Ext . isObject ( component ) ) { component = component . getItemId ( ) ; } var dockedItems = this . getDockedItems ( ) , ln = dockedItems . length , item , i ; if ( Ext . isNumber ( component ) ) { return dockedItems [ component ] ; } for ( i = 0 ; i < ln ; i ++ ) { item = dockedItems [ i ] ; if ( item . id == component ) { return item ; } } return false ; } 
function ( ) { var me = this , modal = me . getModal ( ) ; if ( modal ) { modal . destroy ( ) ; } me . removeAll ( true , true ) ; me . unlink ( '_scrollable' ) ; Ext . destroy ( me . items ) ; me . callSuper ( ) ; } 
function exportProtobuf ( pkgname , obj , callback ) { var lstexport = [ ] ; var lstreq = [ ] ; var lstres = [ ] ; if ( Array . isArray ( obj ) ) { var str = 'package ' + pkgname + ';\r\n\r\n' ; for ( var i = 0 ; i < obj . length ; ++ i ) { if ( obj [ i ] . type == 'message' ) { if ( base . isResMsg ( obj [ i ] . name ) ) { lstres . push ( { name : obj [ i ] . name , comment : obj [ i ] . comment } ) ; } else if ( base . isReqMsg ( obj [ i ] . name ) ) { lstreq . push ( { name : obj [ i ] . name , comment : obj [ i ] . comment } ) ; } } } str += exportEnumMsgID ( lstreq , base . getGlobalObj ( 'REQ_MSGID_BEGIN' , obj ) . val . val , lstres , base . getGlobalObj ( 'RES_MSGID_BEGIN' , obj ) . val . val ) ; for ( var i = 0 ; i < obj . length ; ++ i ) { if ( obj [ i ] . type == 'message' ) { lstexport = exportMember ( obj [ i ] , lstexport , obj ) ; } } for ( var i = 0 ; i < lstexport . length ; ++ i ) { var co = base . getGlobalObj ( lstexport [ i ] , obj ) ; if ( co . type == 'enum' ) { var cs = exportEnum ( co , callback , obj ) ; if ( cs == undefined ) { return ; } str += cs + '\r\n' ; } else { var cs = exportMsg ( co , callback , obj ) ; if ( cs == undefined ) { return ; } str += cs + '\r\n' ; } } for ( var i = 0 ; i < obj . length ; ++ i ) { if ( obj [ i ] . type == 'message' ) { var cs = exportMsg ( obj [ i ] , callback , obj ) ; if ( cs == undefined ) { return ; } str += cs + '\r\n' ; } } return str ; } return undefined ; } 
function ( e ) { var srcElement = e . srcElement . nodeName . toUpperCase ( ) , selectableElements = [ 'INPUT' , 'TEXTAREA' ] ; if ( selectableElements . indexOf ( srcElement ) == - 1 ) { return false ; } } 
function ( number , min , max ) { number = parseFloat ( number ) ; if ( ! isNaN ( min ) ) { number = Math . max ( number , min ) ; } if ( ! isNaN ( max ) ) { number = Math . min ( number , max ) ; } return number ; } 
function ( value , increment , minValue , maxValue ) { var newValue = value , m ; if ( ! ( increment && value ) ) { return value ; } m = value % increment ; if ( m !== 0 ) { newValue -= m ; if ( m * 2 >= increment ) { newValue += increment ; } else if ( m * 2 < - increment ) { newValue -= increment ; } } return Ext . Number . constrain ( newValue , minValue , maxValue ) ; } 
function ( value , precision ) { if ( isToFixedBroken ) { precision = precision || 0 ; var pow = Math . pow ( 10 , precision ) ; return ( Math . round ( value * pow ) / pow ) . toFixed ( precision ) ; } return value . toFixed ( precision ) ; } 
function _extend ( target , source ) { var keys = Object . keys ( source ) ; for ( var i = 0 ; i < keys . length ; i ++ ) { target [ keys [ i ] ] = source [ keys [ i ] ] ; } return target ; } 
function logger ( req , res , next ) { if ( req . url . substr ( 0 , 2 ) === "/r" ) { console . log ( req . method , decodeURIComponent ( req . url ) , req . body ? JSON . stringify ( req . body ) : "" ) ; } next ( ) ; } 
function typeConvert ( obj , onlyDate ) { var i , res ; if ( typeof obj === "object" ) { for ( i in obj ) { if ( obj . hasOwnProperty ( i ) ) { obj [ i ] = typeConvert ( obj [ i ] , onlyDate ) ; } } } else if ( typeof obj === "string" ) { if ( ! onlyDate && obj . match ( / ^([0-9.]+|true|false|undefined|null)$ / ) ) { obj = eval ( obj ) ; } else { res = obj . match ( / ^"?(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)"?$ / ) ; if ( res ) { obj = new Date ( res [ 1 ] ) ; } } } return obj ; } 
function typeConvertMiddleware ( req , res , next ) { typeConvert ( req . params ) ; typeConvert ( req . body , true ) ; next ( ) ; } 
function StoreManager ( options ) { var stores = { } ; this . get = function ( name ) { if ( ! stores [ name ] ) { stores [ name ] = options . store ( name ) ; } return stores [ name ] ; } ; } 
function createServer ( options ) { var server , stores ; 
function defineRoute ( method , route , handler ) { server [ method ] ( route , function ( req , res ) { var store = stores . get ( req . params . resource ) ; delete req . params . resource ; handler ( req , store , function ( error , docs ) { if ( error ) { res . status ( 500 ) ; res . end ( error ) ; } else if ( ! docs ) { res . status ( 404 ) ; res . end ( "Not found" ) ; } else { res . json ( docs ) ; } } ) ; } ) ; } 
function routeURL ( ) { var prefix = options . prefix || "" , args = [ "/" + prefix , ":resource" ] . concat ( Array . prototype . slice . call ( arguments ) ) ; return path . join . apply ( path , args ) ; } 
function createPasswordHash ( object ) { if ( ! object ) return object ; var password = object . password ; if ( password ) { delete object . password ; object . passwordSalt = sha1 ( Math . random ( ) . toString ( ) ) ; object . passwordHash = sha1 ( "restify-magic" + object . passwordSalt + password ) ; } return object ; } 
function ( json , typeSpecification , array ) { var keys , current = json , nested = [ ] , nestedKeys = [ ] , levels = [ ] , query = 'COLUMN_CREATE(' , root = true , curNest = '' , curItem , item = 0 , level = 0 ; while ( current ) { keys = Object . keys ( current ) ; var len = keys . length ; var _l ; var deepestLevel = 1 ; for ( var i = 0 ; i < len ; ++ i ) { if ( ( _l = current [ keys [ i ] ] ) === null || _l === undefined ) { continue ; } if ( typeof ( _l ) === 'object' ) { 
function ( record ) { if ( ! record . isNode ) { * @event append * Fires when a new child node is appended. * @param {Ext.data.NodeInterface} this This node. * @param {Ext.data.NodeInterface} node The newly appended node. * @param {Number} index The index of the newly appended node. */ "append" , "remove" , "move" , "insert" , "beforeappend" , "beforeremove" , "beforemove" , "beforeinsert" , "expand" , "collapse" , "beforeexpand" , "beforecollapse" , "sort" , 'load' ] ) ; } return record ; } 
function ( node ) { if ( Ext . isObject ( node ) && ! node . isModel ) { node = Ext . data . ModelManager . create ( node , this . modelName ) ; } 
function ( silent ) { var me = this , parentNode = me . parentNode , isFirst = ( ! parentNode ? true : parentNode . firstChild == me ) , isLast = ( ! parentNode ? true : parentNode . lastChild == me ) , depth = 0 , parent = me , children = me . childNodes , ln = children . length , i ; while ( parent . parentNode ) { ++ depth ; parent = parent . parentNode ; } me . beginEdit ( ) ; me . set ( { isFirst : isFirst , isLast : isLast , depth : depth , index : parentNode ? parentNode . indexOf ( me ) : 0 , parentId : parentNode ? parentNode . getId ( ) : null } ) ; me . endEdit ( silent ) ; if ( silent ) { me . commit ( silent ) ; } for ( i = 0 ; i < ln ; i ++ ) { children [ i ] . updateInfo ( silent ) ; } } 
function ( node , suppressEvents , suppressNodeUpdate ) { var me = this , i , ln , index , oldParent , ps ; 
function ( node , destroy , suppressEvents , suppressNodeUpdate ) { var me = this , index = me . indexOf ( node ) ; if ( index == - 1 || ( suppressEvents !== true && me . fireEvent ( "beforeremove" , me , node ) === false ) ) { return false ; } 
function ( newId , deep ) { var me = this , result = me . callOverridden ( arguments ) , len = me . childNodes ? me . childNodes . length : 0 , i ; 
function ( destroy ) { var me = this ; 
function ( silent ) { var me = this , options = me . destroyOptions ; if ( silent === true ) { me . clear ( true ) ; Ext . each ( me . childNodes , function ( n ) { n . destroy ( true ) ; } ) ; me . childNodes = null ; delete me . destroyOptions ; me . callOverridden ( [ options ] ) ; } else { me . destroyOptions = silent ; 
function ( node , refNode , suppressEvents ) { var me = this , index = me . indexOf ( refNode ) , oldParent = node . parentNode , refIndex = index , ps ; if ( ! refNode ) { 
function ( destroy , suppressEvents ) { var parentNode = this . parentNode ; if ( parentNode ) { parentNode . removeChild ( this , destroy , suppressEvents , true ) ; } return this ; } 
function ( destroy , suppressEvents ) { var cn = this . childNodes , n ; while ( ( n = cn [ 0 ] ) ) { this . removeChild ( n , destroy , suppressEvents ) ; } return this ; } 
function ( sortFn , recursive , suppressEvent ) { var cs = this . childNodes , ln = cs . length , i , n ; if ( ln > 0 ) { Ext . Array . sort ( cs , sortFn ) ; for ( i = 0 ; i < ln ; i ++ ) { n = cs [ i ] ; n . previousSibling = cs [ i - 1 ] ; n . nextSibling = cs [ i + 1 ] ; if ( i === 0 ) { this . setFirstChild ( n ) ; } if ( i == ln - 1 ) { this . setLastChild ( n ) ; } n . updateInfo ( suppressEvent ) ; if ( recursive && ! n . isLeaf ( ) ) { n . sort ( sortFn , true , true ) ; } } this . notifyStores ( 'afterEdit' , [ 'sorted' ] , { sorted : 'sorted' } ) ; if ( suppressEvent !== true ) { this . fireEvent ( 'sort' , this , cs ) ; } } } 
function ( recursive , callback , scope ) { var me = this ; if ( ! me . isLeaf ( ) ) { if ( me . isLoading ( ) ) { me . on ( 'expand' , function ( ) { me . expand ( recursive , callback , scope ) ; } , me , { single : true } ) ; } else { if ( ! me . isExpanded ( ) ) { 
function ( recursive , callback , scope ) { var me = this ; 
function ( ) { if ( head . open === 0 && head . next ) { 
function ( nextTargetFn , fnOpt ) { tail . next = { fns : [ nextTargetFn ] , opts : [ fnOpt ] } ; tail = tail . next ; dispatch ( ) ; return controller ; } 
function Deployor ( options ) { this . options = _assign ( { } , Deployor . defaults , options ) 
function ( ) { var mask = Ext . getBody ( ) . createChild ( { cls : Ext . baseCSSPrefix + 'mask ' + Ext . baseCSSPrefix + 'mask-transparent' } ) ; setTimeout ( function ( ) { mask . destroy ( ) ; } , 0 ) ; } 
function ( el , prefix ) { if ( el && el . id ) { return el . id ; } el = Ext . getDom ( el ) || { } ; if ( el === document || el === document . documentElement ) { el . id = 'ext-app' ; } else if ( el === document . body ) { el . id = 'ext-body' ; } else if ( el === window ) { el . id = 'ext-window' ; } el . id = el . id || ( ( prefix || 'ext-' ) + ( ++ Ext . idSeed ) ) ; return el . id ; } 
function ( ) { if ( ! Ext . documentBodyElement ) { if ( ! document . body ) { throw new Error ( "[Ext.getBody] document.body does not exist at this point" ) ; } Ext . documentBodyElement = Ext . get ( document . body ) ; } return Ext . documentBodyElement ; } 
function ( ) { if ( ! Ext . documentHeadElement ) { Ext . documentHeadElement = Ext . get ( document . head || document . getElementsByTagName ( 'head' ) [ 0 ] ) ; } return Ext . documentHeadElement ; } 
function ( dest , source , names , usePrototypeKeys ) { if ( typeof names == 'string' ) { names = names . split ( / [,;\s] / ) ; } Ext . each ( names , function ( name ) { if ( usePrototypeKeys || source . hasOwnProperty ( name ) ) { dest [ name ] = source [ name ] ; } } , this ) ; return dest ; } 
function ( ) { var args = arguments , ln = args . length , i , item ; for ( i = 0 ; i < ln ; i ++ ) { item = args [ i ] ; if ( item ) { if ( Ext . isArray ( item ) ) { this . destroy . apply ( this , item ) ; } else if ( Ext . isFunction ( item . destroy ) ) { item . destroy ( ) ; } } } } 
function ( el ) { if ( ! el || ! document ) { return null ; } return el . dom ? el . dom : ( typeof el == 'string' ? document . getElementById ( el ) : el ) ; } 
function ( node ) { if ( node && node . parentNode && node . tagName != 'BODY' ) { Ext . get ( node ) . clearListeners ( ) ; node . parentNode . removeChild ( node ) ; delete Ext . cache [ node . id ] ; } } 
function ( config ) { var defaultSetupConfig = Ext . defaultSetupConfig , emptyFn = Ext . emptyFn , onReady = config . onReady || emptyFn , onUpdated = config . onUpdated || emptyFn , scope = config . scope , requires = Ext . Array . from ( config . requires ) , extOnReady = Ext . onReady , head = Ext . getHead ( ) , callback , viewport , precomposed ; Ext . setup = function ( ) { throw new Error ( "Ext.setup has already been called before" ) ; } ; delete config . requires ; delete config . onReady ; delete config . onUpdated ; delete config . scope ; Ext . require ( [ 'Ext.event.Dispatcher' ] ) ; callback = function ( ) { var listeners = Ext . setupListeners , ln = listeners . length , i , listener ; delete Ext . setupListeners ; Ext . isSetup = true ; for ( i = 0 ; i < ln ; i ++ ) { listener = listeners [ i ] ; listener . fn . call ( listener . scope ) ; } Ext . onReady = extOnReady ; Ext . onReady ( onReady , scope ) ; } ; Ext . onUpdated = onUpdated ; Ext . onReady = function ( fn , scope ) { var origin = onReady ; onReady = function ( ) { origin ( ) ; Ext . onReady ( fn , scope ) ; } ; } ; config = Ext . merge ( { } , defaultSetupConfig , config ) ; Ext . onDocumentReady ( function ( ) { Ext . factoryConfig ( config , function ( data ) { Ext . event . Dispatcher . getInstance ( ) . setPublishers ( data . eventPublishers ) ; if ( data . logger ) { Ext . Logger = data . logger ; } if ( data . animator ) { Ext . Animator = data . animator ; } if ( data . viewport ) { Ext . Viewport = viewport = data . viewport ; if ( ! scope ) { scope = viewport ; } Ext . require ( requires , function ( ) { Ext . Viewport . on ( 'ready' , callback , null , { single : true } ) ; } ) ; } else { Ext . require ( requires , callback ) ; } } ) ; if ( ! Ext . microloaded && navigator . userAgent . match ( / IEMobile\/10\.0 / ) ) { var msViewportStyle = document . createElement ( "style" ) ; msViewportStyle . appendChild ( document . createTextNode ( "@media screen and (orientation: portrait) {" + "@-ms-viewport {width: 320px !important;}" + "}" + "@media screen and (orientation: landscape) {" + "@-ms-viewport {width: 560px !important;}" + "}" ) ) ; head . appendChild ( msViewportStyle ) ; } } ) ; function addMeta ( name , content ) { var meta = document . createElement ( 'meta' ) ; meta . setAttribute ( 'name' , name ) ; meta . setAttribute ( 'content' , content ) ; head . append ( meta ) ; } function addIcon ( href , sizes , precomposed ) { var link = document . createElement ( 'link' ) ; link . setAttribute ( 'rel' , 'apple-touch-icon' + ( precomposed ? '-precomposed' : '' ) ) ; link . setAttribute ( 'href' , href ) ; if ( sizes ) { link . setAttribute ( 'sizes' , sizes ) ; } head . append ( link ) ; } function addStartupImage ( href , media ) { var link = document . createElement ( 'link' ) ; link . setAttribute ( 'rel' , 'apple-touch-startup-image' ) ; link . setAttribute ( 'href' , href ) ; if ( media ) { link . setAttribute ( 'media' , media ) ; } head . append ( link ) ; } var icon = config . icon , isIconPrecomposed = Boolean ( config . isIconPrecomposed ) , startupImage = config . startupImage || { } , statusBarStyle = config . statusBarStyle || 'black' , devicePixelRatio = window . devicePixelRatio || 1 ; if ( navigator . standalone ) { addMeta ( 'viewport' , 'width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0' ) ; } else { addMeta ( 'viewport' , 'initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, minimum-ui' ) ; } addMeta ( 'apple-mobile-web-app-capable' , 'yes' ) ; addMeta ( 'apple-touch-fullscreen' , 'yes' ) ; if ( Ext . browser . is . ie ) { addMeta ( 'msapplication-tap-highlight' , 'no' ) ; } 
function ( config ) { var appName = config . name , onReady , scope , requires ; if ( ! config ) { config = { } ; } if ( ! Ext . Loader . config . paths [ appName ] ) { Ext . Loader . setPath ( appName , config . appFolder || 'app' ) ; } requires = Ext . Array . from ( config . requires ) ; config . requires = [ 'Ext.app.Application' ] ; onReady = config . onReady ; scope = config . scope ; config . onReady = function ( ) { config . requires = requires ; new Ext . app . Application ( config ) ; if ( onReady ) { onReady . call ( scope ) ; } } ; Ext . setup ( config ) ; } 
function ( config , classReference , instance , aliasNamespace ) { var manager = Ext . ClassManager , newInstance ; 
function ( ) { var map = Ext . ComponentManager . all . map , leaks = [ ] , parent ; Ext . Object . each ( map , function ( id , component ) { while ( ( parent = component . getParent ( ) ) && map . hasOwnProperty ( parent . getId ( ) ) ) { component = parent ; } if ( leaks . indexOf ( component ) === - 1 ) { leaks . push ( component ) ; } } ) ; console . log ( leaks ) ; } 
function addAction ( name , fn ) { if ( typeof name === "object" && fn == null ) { _ . each ( name , function ( fn , n ) { this . addAction ( n , fn ) ; } , this ) ; return this ; } if ( typeof name !== "string" || name === "" ) throw new Error ( "Expecting non-empty string for action name." ) ; if ( typeof fn !== "function" ) throw new Error ( "Expecting function for action." ) ; if ( this . _actions == null ) this . _actions = { } ; if ( this . _actions [ name ] == null ) this . _actions [ name ] = [ ] ; if ( ! ~ this . _actions [ name ] . indexOf ( fn ) ) this . _actions [ name ] . push ( fn ) ; return this ; } 
function ( options ) { this . options = options ; this . headers = { 'User-Agent' : 'request/grunt-github-release-asset' } ; var authStr ; if ( options . credentials ) { if ( options . credentials . token ) { authStr = options . credentials . token + ':' + '' ; } else if ( options . credentials . username && options . credentials . password ) { authStr = options . credentials . username + ':' + options . credentials . password ; } } if ( ! authStr ) { throw new Error ( 'Please supply a token or username & password to authorize yourself.' ) ; } this . headers [ 'Authorization' ] = 'Basic ' + ( new Buffer ( authStr ) . toString ( 'base64' ) ) try { this . repoPath = options . repo . split ( ':' ) [ 1 ] . split ( '.' ) . slice ( 0 , - 1 ) . join ( '.' ) . toLowerCase ( ) ; } catch ( err ) { throw new Error ( 'Repository url isn\'t provided or isn\'t valid.' ) ; } } 
function map ( fn , list ) { var end = list . length var idx = - 1 var out = [ ] while ( ++ idx < end ) { out . push ( ( typeof fn === 'string' ) ? selectn ( fn , list [ idx ] ) : fn ( list [ idx ] ) ) } return out } 
function isfinite ( arr ) { if ( ! Array . isArray ( arr ) ) { throw new TypeError ( 'isfinite()::invalid input argument. Must provide an array.' ) ; } var len = arr . length , out = new Array ( len ) , val ; for ( var i = 0 ; i < len ; i ++ ) { out [ i ] = 0 ; val = arr [ i ] ; if ( typeof val === 'number' && val === val && val < pinf && val > ninf ) { out [ i ] = 1 ; } } return out ; } 
function exec ( options , callback ) { return cmd ( _ . assign ( options , { type : 'exec' } ) , _ . cb ( callback ) ) } 
function execFile ( options , callback ) { return cmd ( _ . assign ( options , { type : 'execFile' } ) , _ . cb ( callback ) ) } 
function cmd ( options , callback ) { let opts = _ . merge ( { } , DEFAULTS , options ) let { cmd = '' , type = '' , args = [ ] , switches = { } } = opts type = type && _ . isString ( type ) && _ . includes ( [ 'exec' , 'execFile' ] , type ) ? type : 'exec' args = args && _ . isArray ( args ) ? args : [ ] switches = switches && _ . isPlainObject ( switches ) ? _ . merge ( switches , _ . omit ( JARGV || { } , [ '_' ] ) ) || { } : { } let method = _ . get ( cproc , type ) if ( ! cmd || ! _ . isString ( cmd ) ) return _ . fail ( 'Invalid cmd' , callback ) if ( ! _ . isFunction ( method ) ) return _ . fail ( 'Invalid type' , callback ) _ . forIn ( switches , ( v , k ) => { if ( ! v && ! k ) return let arg = v && k ? ` ${ k } ${ v } ` : ` ${ k || v } ` if ( arg ) args . push ( arg ) } ) args = _ . compact ( args ) let isExec = type === 'exec' _ . assign ( opts , { args : args } ) opts = _ . omit ( opts , [ 'type' , 'switches' ] ) 
function _handleChild ( child , callback ) { if ( ! child ) return _ . fail ( 'Invalid child process' , callback ) if ( _ . isError ( child ) ) return _ . fail ( child , callback ) let stdout = '' let stderr = '' child . stdout . on ( 'data' , function ( data ) { stdout += data } ) child . stderr . on ( 'data' , function ( data ) { stderr += data } ) child . on ( 'close' , function ( code ) { return _ . done ( stdout || stderr , callback ) } ) child . on ( 'disconnect' , function ( err ) { } ) child . on ( 'error' , function ( err ) { } ) child . on ( 'exit' , function ( code , signal ) { } ) child . on ( 'message' , function ( message , sendHandle ) { } ) return child } 
function query ( data , options , clbk ) { var opts ; * FUNCTION: done( error, response, data ) * Callback invoked after completing request. * * @private * @param {Error|Null} error - error object * @param {Object} response - HTTP response object * @param {Object} data - response data * @returns {Void} */ function done ( error , response , data ) { if ( error ) { return clbk ( error ) ; } debug ( 'Request successfully completed.' ) ; clbk ( null , data ) ; } 
function done ( error , response , data ) { if ( error ) { return clbk ( error ) ; } debug ( 'Request successfully completed.' ) ; clbk ( null , data ) ; } 
function getDigest ( cfg ) { var ha1 , ha2 , response ; ha1 = crypto . createHash ( 'md5' ) . update ( cfg . fromExt + ':' + cfg . realm + ':' + cfg . pass ) . digest ( 'hex' ) ; ha2 = crypto . createHash ( 'md5' ) . update ( cfg . meth + ':' + cfg . authUri ) . digest ( 'hex' ) ; 
function ( property , obj , newProperty ) { if ( config . hasOwnProperty ( property ) ) { if ( obj ) { config [ obj ] = config [ obj ] || { } ; config [ obj ] [ ( newProperty ) ? newProperty : property ] = config [ obj ] [ ( newProperty ) ? newProperty : property ] || config [ property ] ; } else { config [ newProperty ] = config [ property ] ; } delete config [ property ] ; 
function Store ( name , items ) { if ( ! name ) { throw new Error ( 'Please give the store a name!' ) ; } this . name = name ; this . items = items || { } ; this . type = 'object' ; this . setType ( ) ; return this ; } 
function node ( content , type , name , indent ) { this . type = type ; if ( name ) this . name = name ; this . content = content ; if ( indent ) { this . indent = indent ; 
function f ( arr ) { if ( arr ) { var merged = [ ] ; return merged . concat . apply ( merged , arr ) . join ( "" ) } } 
function configureStore ( onComplete ) { 
function ( el , config ) { var me = this ; config = config || { } ; Ext . apply ( me , config ) ; me . el = Ext . get ( el ) ; me . callParent ( ) ; me . mixins . observable . constructor . call ( me ) ; if ( ! me . disabled ) { me . enable ( ) ; } me . el . addCls ( me . baseCls ) ; } 
function ( ) { if ( ! this . mgr ) { this . mgr = Ext . util . Observable . observe ( Ext . util . Draggable ) ; } this . mgr . on ( { dragstart : this . onDragStart , scope : this } ) ; this . disabled = false ; } 
function ns ( rootpath , src ) { return _ . compact ( src . replace ( rootpath , '' ) . split ( path . sep ) ) . join ( '.' ) } 
function nspath ( ) { let src = _ . join ( _ . filter ( _ . toArray ( arguments ) , function ( arg ) { return arg && _ . isString ( arg ) } ) , '.' ) if ( ! src ) return '' return _ . replace ( src , REGX_DOTS , '/' ) } 
function diff ( rootpath , src ) { return _ . isString ( rootpath ) && _ . isString ( src ) ? src . replace ( rootpath , '' ) . split ( path . sep ) . join ( '/' ) : '' } 
function rel ( root , src , sep ) { if ( ! root || ! _ . isString ( root ) || ! src || ! _ . isString ( src ) ) return let root_split = root . split ( path . sep ) , src_split = src . split ( path . sep ) return _ . join ( _ . difference ( src_split , root_split ) , sep || '/' ) } 
function rebase ( root , src , dest ) { let relp = rel ( root , src ) return relp ? path . join ( dest , relp ) : '' } 
function ( parent , name , type ) { if ( JavaScriptCompiler . RESERVED_WORDS [ name ] || name . indexOf ( '-' ) !== - 1 || ! isNaN ( name ) ) { return parent + "['" + name + "']" ; } else if ( / ^[0-9]+$ / . test ( name ) ) { return parent + "[" + name + "]" ; } else { return parent + "." + name ; } } 
function ( environment , options ) { this . environment = environment ; this . options = options || { } ; this . preamble ( ) ; this . stackSlot = 0 ; this . stackVars = [ ] ; this . registers = { list : [ ] } ; this . compileChildren ( environment , options ) ; Handlebars . log ( Handlebars . logger . DEBUG , environment . disassemble ( ) + "\n\n" ) ; var opcodes = environment . opcodes , opcode , name , declareName , declareVal ; this . i = 0 ; for ( l = opcodes . length ; this . i < l ; this . i ++ ) { opcode = this . nextOpcode ( 0 ) ; if ( opcode [ 0 ] === 'DECLARE' ) { this . i = this . i + 2 ; this [ opcode [ 1 ] ] = opcode [ 2 ] ; } else { this . i = this . i + opcode [ 1 ] . length ; this [ opcode [ 0 ] ] . apply ( this , opcode [ 1 ] ) ; } } return this . createFunction ( ) ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _handlebarsRuntime = __webpack_require__ ( 2 ) ; var _handlebarsRuntime2 = _interopRequireDefault ( _handlebarsRuntime ) ; 
function ( module , exports ) { "use strict" ; exports [ "default" ] = function ( obj ) { return obj && obj . __esModule ? obj : { "default" : obj } ; } ; exports . __esModule = true ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireWildcard = __webpack_require__ ( 3 ) [ 'default' ] ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _handlebarsBase = __webpack_require__ ( 4 ) ; var base = _interopRequireWildcard ( _handlebarsBase ) ; 
function ( module , exports ) { "use strict" ; exports [ "default" ] = function ( obj ) { if ( obj && obj . __esModule ) { return obj ; } else { var newObj = { } ; if ( obj != null ) { for ( var key in obj ) { if ( Object . prototype . hasOwnProperty . call ( obj , key ) ) newObj [ key ] = obj [ key ] ; } } newObj [ "default" ] = obj ; return newObj ; } } ; exports . __esModule = true ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . HandlebarsEnvironment = HandlebarsEnvironment ; var _utils = __webpack_require__ ( 5 ) ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; var _helpers = __webpack_require__ ( 7 ) ; var _decorators = __webpack_require__ ( 15 ) ; var _logger = __webpack_require__ ( 17 ) ; var _logger2 = _interopRequireDefault ( _logger ) ; var VERSION = '4.0.5' ; exports . VERSION = VERSION ; var COMPILER_REVISION = 7 ; exports . COMPILER_REVISION = COMPILER_REVISION ; var REVISION_CHANGES = { 1 : '<= 1.0.rc.2' , 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . registerDefaultHelpers = registerDefaultHelpers ; var _helpersBlockHelperMissing = __webpack_require__ ( 8 ) ; var _helpersBlockHelperMissing2 = _interopRequireDefault ( _helpersBlockHelperMissing ) ; var _helpersEach = __webpack_require__ ( 9 ) ; var _helpersEach2 = _interopRequireDefault ( _helpersEach ) ; var _helpersHelperMissing = __webpack_require__ ( 10 ) ; var _helpersHelperMissing2 = _interopRequireDefault ( _helpersHelperMissing ) ; var _helpersIf = __webpack_require__ ( 11 ) ; var _helpersIf2 = _interopRequireDefault ( _helpersIf ) ; var _helpersLog = __webpack_require__ ( 12 ) ; var _helpersLog2 = _interopRequireDefault ( _helpersLog ) ; var _helpersLookup = __webpack_require__ ( 13 ) ; var _helpersLookup2 = _interopRequireDefault ( _helpersLookup ) ; var _helpersWith = __webpack_require__ ( 14 ) ; var _helpersWith2 = _interopRequireDefault ( _helpersWith ) ; function registerDefaultHelpers ( instance ) { _helpersBlockHelperMissing2 [ 'default' ] ( instance ) ; _helpersEach2 [ 'default' ] ( instance ) ; _helpersHelperMissing2 [ 'default' ] ( instance ) ; _helpersIf2 [ 'default' ] ( instance ) ; _helpersLog2 [ 'default' ] ( instance ) ; _helpersLookup2 [ 'default' ] ( instance ) ; _helpersWith2 [ 'default' ] ( instance ) ; } } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'blockHelperMissing' , function ( context , options ) { var inverse = options . inverse , fn = options . fn ; if ( context === true ) { return fn ( this ) ; } else if ( context === false || context == null ) { return inverse ( this ) ; } else if ( _utils . isArray ( context ) ) { if ( context . length > 0 ) { if ( options . ids ) { options . ids = [ options . name ] ; } return instance . helpers . each ( context , options ) ; } else { return inverse ( this ) ; } } else { if ( options . data && options . ids ) { var data = _utils . createFrame ( options . data ) ; data . contextPath = _utils . appendContextPath ( options . data . contextPath , options . name ) ; options = { data : data } ; } return fn ( context , options ) ; } } ) ; } ; module . exports = exports [ 'default' ] ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'each' , function ( context , options ) { if ( ! options ) { throw new _exception2 [ 'default' ] ( 'Must pass iterator to #each' ) ; } var fn = options . fn , inverse = options . inverse , i = 0 , ret = '' , data = undefined , contextPath = undefined ; if ( options . data && options . ids ) { contextPath = _utils . appendContextPath ( options . data . contextPath , options . ids [ 0 ] ) + '.' ; } if ( _utils . isFunction ( context ) ) { context = context . call ( this ) ; } if ( options . data ) { data = _utils . createFrame ( options . data ) ; } function execIteration ( field , index , last ) { if ( data ) { data . key = field ; data . index = index ; data . first = index === 0 ; data . last = ! ! last ; if ( contextPath ) { data . contextPath = contextPath + field ; } } ret = ret + fn ( context [ field ] , { data : data , blockParams : _utils . blockParams ( [ context [ field ] , field ] , [ contextPath + field , null ] ) } ) ; } if ( context && typeof context === 'object' ) { if ( _utils . isArray ( context ) ) { for ( var j = context . length ; i < j ; i ++ ) { if ( i in context ) { execIteration ( i , i , i === context . length - 1 ) ; } } } else { var priorKey = undefined ; for ( var key in context ) { if ( context . hasOwnProperty ( key ) ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'helperMissing' , function ( ) { if ( arguments . length === 1 ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'if' , function ( conditional , options ) { if ( _utils . isFunction ( conditional ) ) { conditional = conditional . call ( this ) ; } 
function ( module , exports ) { 'use strict' ; exports . __esModule = true ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'log' , function ( ) { var args = [ undefined ] , options = arguments [ arguments . length - 1 ] ; for ( var i = 0 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } var level = 1 ; if ( options . hash . level != null ) { level = options . hash . level ; } else if ( options . data && options . data . level != null ) { level = options . data . level ; } args [ 0 ] = level ; instance . log . apply ( instance , args ) ; } ) ; } ; module . exports = exports [ 'default' ] ; } 
function ( module , exports ) { 'use strict' ; exports . __esModule = true ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'lookup' , function ( obj , field ) { return obj && obj [ field ] ; } ) ; } ; module . exports = exports [ 'default' ] ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; exports [ 'default' ] = function ( instance ) { instance . registerHelper ( 'with' , function ( context , options ) { if ( _utils . isFunction ( context ) ) { context = context . call ( this ) ; } var fn = options . fn ; if ( ! _utils . isEmpty ( context ) ) { var data = options . data ; if ( options . data && options . ids ) { data = _utils . createFrame ( options . data ) ; data . contextPath = _utils . appendContextPath ( options . data . contextPath , options . ids [ 0 ] ) ; } return fn ( context , { data : data , blockParams : _utils . blockParams ( [ context ] , [ data && data . contextPath ] ) } ) ; } else { return options . inverse ( this ) ; } } ) ; } ; module . exports = exports [ 'default' ] ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . registerDefaultDecorators = registerDefaultDecorators ; var _decoratorsInline = __webpack_require__ ( 16 ) ; var _decoratorsInline2 = _interopRequireDefault ( _decoratorsInline ) ; function registerDefaultDecorators ( instance ) { _decoratorsInline2 [ 'default' ] ( instance ) ; } } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; exports [ 'default' ] = function ( instance ) { instance . registerDecorator ( 'inline' , function ( fn , props , container , options ) { var ret = fn ; if ( ! props . partials ) { props . partials = { } ; ret = function ( context , options ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; var logger = { methodMap : [ 'debug' , 'info' , 'warn' , 'error' ] , level : 'info' , 
function lookupLevel ( level ) { if ( typeof level === 'string' ) { var levelMap = _utils . indexOf ( logger . methodMap , level . toLowerCase ( ) ) ; if ( levelMap >= 0 ) { level = levelMap ; } else { level = parseInt ( level , 10 ) ; } } return level ; } 
function log ( level ) { level = logger . lookupLevel ( level ) ; if ( typeof console !== 'undefined' && logger . lookupLevel ( logger . level ) <= level ) { var method = logger . methodMap [ level ] ; if ( ! console [ method ] ) { 
function ( module , exports ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireWildcard = __webpack_require__ ( 3 ) [ 'default' ] ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . checkRevision = checkRevision ; exports . template = template ; exports . wrapProgram = wrapProgram ; exports . resolvePartial = resolvePartial ; exports . invokePartial = invokePartial ; exports . noop = noop ; var _utils = __webpack_require__ ( 5 ) ; var Utils = _interopRequireWildcard ( _utils ) ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; var _base = __webpack_require__ ( 4 ) ; function checkRevision ( compilerInfo ) { var compilerRevision = compilerInfo && compilerInfo [ 0 ] || 1 , currentRevision = _base . COMPILER_REVISION ; if ( compilerRevision !== currentRevision ) { if ( compilerRevision < currentRevision ) { var runtimeVersions = _base . REVISION_CHANGES [ currentRevision ] , compilerVersions = _base . REVISION_CHANGES [ compilerRevision ] ; throw new _exception2 [ 'default' ] ( 'Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').' ) ; } else { 
function ( module , exports ) { ( function ( global ) { 'use strict' ; exports . __esModule = true ; exports [ 'default' ] = function ( Handlebars ) { var root = typeof global !== 'undefined' ? global : window , $Handlebars = root . Handlebars ; Handlebars . noConflict = function ( ) { if ( root . Handlebars === Handlebars ) { root . Handlebars = $Handlebars ; } return Handlebars ; } ; } ; module . exports = exports [ 'default' ] ; } . call ( exports , ( function ( ) { return this ; } ( ) ) ) ) } 
function ( module , exports ) { 'use strict' ; exports . __esModule = true ; var AST = { 
function helperExpression ( node ) { return node . type === 'SubExpression' || ( node . type === 'MustacheStatement' || node . type === 'BlockStatement' ) && ! ! ( node . params && node . params . length || node . hash ) ; } 
function simpleId ( path ) { return path . parts . length === 1 && ! AST . helpers . scopedId ( path ) && ! path . depth ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; var _interopRequireWildcard = __webpack_require__ ( 3 ) [ 'default' ] ; exports . __esModule = true ; exports . parse = parse ; var _parser = __webpack_require__ ( 23 ) ; var _parser2 = _interopRequireDefault ( _parser ) ; var _whitespaceControl = __webpack_require__ ( 24 ) ; var _whitespaceControl2 = _interopRequireDefault ( _whitespaceControl ) ; var _helpers = __webpack_require__ ( 26 ) ; var Helpers = _interopRequireWildcard ( _helpers ) ; var _utils = __webpack_require__ ( 5 ) ; exports . parser = _parser2 [ 'default' ] ; var yy = { } ; _utils . extend ( yy , Helpers ) ; function parse ( input , options ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _visitor = __webpack_require__ ( 25 ) ; var _visitor2 = _interopRequireDefault ( _visitor ) ; function WhitespaceControl ( ) { var options = arguments . length <= 0 || arguments [ 0 ] === undefined ? { } : arguments [ 0 ] ; this . options = options ; } WhitespaceControl . prototype = new _visitor2 [ 'default' ] ( ) ; WhitespaceControl . prototype . Program = function ( program ) { var doStandalone = ! this . options . ignoreStandalone ; var isRoot = ! this . isRootSeen ; this . isRootSeen = true ; var body = program . body ; for ( var i = 0 , l = body . length ; i < l ; i ++ ) { var current = body [ i ] , strip = this . accept ( current ) ; if ( ! strip ) { continue ; } var _isPrevWhitespace = isPrevWhitespace ( body , i , isRoot ) , _isNextWhitespace = isNextWhitespace ( body , i , isRoot ) , openStandalone = strip . openStandalone && _isPrevWhitespace , closeStandalone = strip . closeStandalone && _isNextWhitespace , inlineStandalone = strip . inlineStandalone && _isPrevWhitespace && _isNextWhitespace ; if ( strip . close ) { omitRight ( body , i , true ) ; } if ( strip . open ) { omitLeft ( body , i , true ) ; } if ( doStandalone && inlineStandalone ) { omitRight ( body , i ) ; if ( omitLeft ( body , i ) ) { 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; function Visitor ( ) { this . parents = [ ] ; } Visitor . prototype = { constructor : Visitor , mutating : false , 
function acceptKey ( node , name ) { var value = this . accept ( node [ name ] ) ; if ( this . mutating ) { 
function acceptRequired ( node , name ) { this . acceptKey ( node , name ) ; if ( ! node [ name ] ) { throw new _exception2 [ 'default' ] ( node . type + ' requires ' + name ) ; } } 
function acceptArray ( array ) { for ( var i = 0 , l = array . length ; i < l ; i ++ ) { this . acceptKey ( array , i ) ; if ( ! array [ i ] ) { array . splice ( i , 1 ) ; i -- ; l -- ; } } } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . SourceLocation = SourceLocation ; exports . id = id ; exports . stripFlags = stripFlags ; exports . stripComment = stripComment ; exports . preparePath = preparePath ; exports . prepareMustache = prepareMustache ; exports . prepareRawBlock = prepareRawBlock ; exports . prepareBlock = prepareBlock ; exports . prepareProgram = prepareProgram ; exports . preparePartialBlock = preparePartialBlock ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; function validateClose ( open , close ) { close = close . path ? close . path . original : close ; if ( open . path . original !== close ) { var errorNode = { loc : open . path . loc } ; throw new _exception2 [ 'default' ] ( open . path . original + " doesn't match " + close , errorNode ) ; } } function SourceLocation ( source , locInfo ) { this . source = source ; this . start = { line : locInfo . first_line , column : locInfo . first_column } ; this . end = { line : locInfo . last_line , column : locInfo . last_column } ; } function id ( token ) { if ( / ^\[.*\]$ / . test ( token ) ) { return token . substr ( 1 , token . length - 2 ) ; } else { return token ; } } function stripFlags ( open , close ) { return { open : open . charAt ( 2 ) === '~' , close : close . charAt ( close . length - 3 ) === '~' } ; } function stripComment ( comment ) { return comment . replace ( / ^\{\{~?\!-?-? / , '' ) . replace ( / -?-?~?\}\}$ / , '' ) ; } function preparePath ( data , parts , loc ) { loc = this . locInfo ( loc ) ; var original = data ? '@' : '' , dig = [ ] , depth = 0 , depthString = '' ; for ( var i = 0 , l = parts . length ; i < l ; i ++ ) { var part = parts [ i ] . part , 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; exports . Compiler = Compiler ; exports . precompile = precompile ; exports . compile = compile ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; var _utils = __webpack_require__ ( 5 ) ; var _ast = __webpack_require__ ( 21 ) ; var _ast2 = _interopRequireDefault ( _ast ) ; var slice = [ ] . slice ; function Compiler ( ) { } 
function opcode ( name ) { this . opcodes . push ( { opcode : name , args : slice . call ( arguments , 1 ) , loc : this . sourceNode [ 0 ] . loc } ) ; } 
function ret ( context , execOptions ) { if ( ! compiled ) { compiled = compileInput ( ) ; } return compiled . call ( this , context , execOptions ) ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; var _interopRequireDefault = __webpack_require__ ( 1 ) [ 'default' ] ; exports . __esModule = true ; var _base = __webpack_require__ ( 4 ) ; var _exception = __webpack_require__ ( 6 ) ; var _exception2 = _interopRequireDefault ( _exception ) ; var _utils = __webpack_require__ ( 5 ) ; var _codeGen = __webpack_require__ ( 29 ) ; var _codeGen2 = _interopRequireDefault ( _codeGen ) ; function Literal ( value ) { this . value = value ; } function JavaScriptCompiler ( ) { } JavaScriptCompiler . prototype = { 
function nameLookup ( parent , name ) { if ( JavaScriptCompiler . isValidJavaScriptVariableName ( name ) ) { return [ parent , '.' , name ] ; } else { return [ parent , '[' , JSON . stringify ( name ) , ']' ] ; } } 
function blockValue ( name ) { var blockHelperMissing = this . aliasable ( 'helpers.blockHelperMissing' ) , params = [ this . contextName ( 0 ) ] ; this . setupHelperArgs ( name , 0 , params ) ; var blockName = this . popStack ( ) ; params . splice ( 1 , 0 , blockName ) ; this . push ( this . source . functionCall ( blockHelperMissing , 'call' , params ) ) ; } 
function ambiguousBlockValue ( ) { 
function appendContent ( content ) { if ( this . pendingContent ) { content = this . pendingContent + content ; } else { this . pendingLocation = this . source . currentLocation ; } this . pendingContent = content ; } 
function append ( ) { if ( this . isInline ( ) ) { this . replaceStack ( function ( current ) { return [ ' != null ? ' , current , ' : ""' ] ; } ) ; this . pushSource ( this . appendToBuffer ( this . popStack ( ) ) ) ; } else { var local = this . popStack ( ) ; this . pushSource ( [ 'if (' , local , ' != null) { ' , this . appendToBuffer ( local , undefined , true ) , ' }' ] ) ; if ( this . environment . isSimple ) { this . pushSource ( [ 'else { ' , this . appendToBuffer ( "''" , undefined , true ) , ' }' ] ) ; } } } 
function lookupOnContext ( parts , falsy , strict , scoped ) { var i = 0 ; if ( ! scoped && this . options . compat && ! this . lastContext ) { 
function lookupBlockParam ( blockParamId , parts ) { this . useBlockParams = true ; this . push ( [ 'blockParams[' , blockParamId [ 0 ] , '][' , blockParamId [ 1 ] , ']' ] ) ; this . resolvePath ( 'context' , parts , 1 ) ; } 
function pushStringParam ( string , type ) { this . pushContext ( ) ; this . pushString ( type ) ; 
function registerDecorator ( paramSize , name ) { var foundDecorator = this . nameLookup ( 'decorators' , name , 'decorator' ) , options = this . setupHelperArgs ( name , paramSize ) ; this . decorators . push ( [ 'fn = ' , this . decorators . functionCall ( foundDecorator , '' , [ 'fn' , 'props' , 'container' , options ] ) , ' || fn;' ] ) ; } 
function invokeHelper ( paramSize , name , isSimple ) { var nonHelper = this . popStack ( ) , helper = this . setupHelper ( paramSize , name ) , simple = isSimple ? [ helper . name , ' || ' ] : '' ; var lookup = [ '(' ] . concat ( simple , nonHelper ) ; if ( ! this . options . strict ) { lookup . push ( ' || ' , this . aliasable ( 'helpers.helperMissing' ) ) ; } lookup . push ( ')' ) ; this . push ( this . source . functionCall ( lookup , 'call' , helper . callParams ) ) ; } 
function invokeKnownHelper ( paramSize , name ) { var helper = this . setupHelper ( paramSize , name ) ; this . push ( this . source . functionCall ( helper . name , 'call' , helper . callParams ) ) ; } 
function assignToHash ( key ) { var value = this . popStack ( ) , context = undefined , type = undefined , id = undefined ; if ( this . trackIds ) { id = this . popStack ( ) ; } if ( this . stringParams ) { type = this . popStack ( ) ; context = this . popStack ( ) ; } var hash = this . hash ; if ( context ) { hash . contexts [ key ] = context ; } if ( type ) { hash . types [ key ] = type ; } if ( id ) { hash . ids [ key ] = id ; } hash . values [ key ] = value ; } 
function ( module , exports , __webpack_require__ ) { 'use strict' ; exports . __esModule = true ; var _utils = __webpack_require__ ( 5 ) ; var SourceNode = undefined ; try { if ( false ) { 
function reduceChildListMutation ( mutationContent , record ) { const isAdded = Boolean ( record . addedNodes . length ) ; const isNext = Boolean ( record . nextSibling ) ; const isPrev = Boolean ( record . previousSibling ) ; const isRemoved = Boolean ( record . removedNodes . length ) ; 
function Node ( options ) { if ( ! ( this instanceof Node ) ) { return new Node ( options ) } events . EventEmitter . call ( this ) this . _setStorageAdapter ( options . storage ) this . _log = options . logger this . _rpc = options . transport this . _self = this . _rpc . _contact this . _validator = options . validator this . _router = options . router || new Router ( { logger : this . _log , transport : this . _rpc , validator : this . _validateKeyValuePair . bind ( this ) } ) this . _bindRouterEventHandlers ( ) this . _bindRPCMessageHandlers ( ) this . _startReplicationInterval ( ) this . _startExpirationInterval ( ) this . _log . info ( 'node created' , { nodeID : this . _self . nodeID } ) } 
function ( ) { var deferred ; deferred = Q . defer ( ) ; if ( running . length < limit ) { running . push ( deferred ) ; deferred . resolve ( ) ; } else { queue . push ( deferred ) ; } return deferred . promise ; } 
function ( ) { var next ; running . pop ( ) ; if ( queue . length > 0 && running . length < limit ) { switch ( type ) { case "lifo" : next = queue . pop ( ) ; break ; default : next = queue . shift ( ) ; } running . push ( next ) ; return next . resolve ( ) ; } } 
function ( ) { var promise ; while ( promise = queue . pop ( ) ) { promise . reject ( "flush" ) ; } while ( promise = running . pop ( ) ) { promise . reject ( "flush" ) ; } } 
function ( record ) { var me = this ; me . _record = record ; if ( record && record . data ) { me . setValues ( record . data ) ; } return this ; } 
function ( options , e ) { options = options || { } ; var me = this , formValues = me . getValues ( me . getStandardSubmit ( ) || ! options . submitDisabled ) , form = me . element . dom || { } ; if ( this . getEnableSubmissionForm ( ) ) { form = this . createSubmissionForm ( form , formValues ) ; } options = Ext . apply ( { url : me . getUrl ( ) || form . action , submit : false , form : form , method : me . getMethod ( ) || form . method || 'post' , autoAbort : false , params : null , waitMsg : null , headers : null , success : null , failure : null } , options || { } ) ; return me . fireAction ( 'beforesubmit' , [ me , formValues , options , e ] , 'doBeforeSubmit' , null , null , 'after' ) ; } 
function ( options ) { options = options || { } ; var me = this , api = me . getApi ( ) , url = me . getUrl ( ) || options . url , waitMsg = options . waitMsg , successFn = function ( response , data ) { me . setValues ( data . data ) ; if ( Ext . isFunction ( options . success ) ) { options . success . call ( options . scope || me , me , response , data ) ; } me . fireEvent ( 'load' , me , response ) ; } , failureFn = function ( response , data ) { if ( Ext . isFunction ( options . failure ) ) { options . failure . call ( scope , me , response , data ) ; } me . fireEvent ( 'exception' , me , response ) ; } , load , method , args ; if ( options . waitMsg ) { if ( typeof waitMsg === 'string' ) { waitMsg = { xtype : 'loadmask' , message : waitMsg } ; } me . setMasked ( waitMsg ) ; } if ( api ) { load = api . load ; if ( typeof load === 'string' ) { load = Ext . direct . Manager . parseMethod ( load ) ; if ( load ) { api . load = load ; } } if ( load ) { method = load . directCfg . method ; args = method . getArgs ( me . getParams ( options . params ) , me . getParamOrder ( ) , me . getParamsAsHash ( ) ) ; args . push ( function ( data , response , success ) { me . setMasked ( false ) ; if ( success ) { successFn ( response , data ) ; } else { failureFn ( response , data ) ; } } , me ) ; return load . apply ( window , args ) ; } } else if ( url ) { return Ext . Ajax . request ( { url : url , timeout : ( options . timeout || this . getTimeout ( ) ) * 1000 , method : options . method || 'GET' , autoAbort : options . autoAbort , headers : Ext . apply ( { 'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8' } , options . headers || { } ) , callback : function ( callbackOptions , success , response ) { var responseText = response . responseText , statusResult = Ext . Ajax . parseStatus ( response . status , response ) ; me . setMasked ( false ) ; if ( success ) { if ( statusResult && responseText . length == 0 ) { success = true ; } else { response = Ext . decode ( responseText ) ; success = ! ! response . success ; } if ( success ) { successFn ( response , responseText ) ; } else { failureFn ( response , responseText ) ; } } else { failureFn ( response , responseText ) ; } } } ) ; } } 
function ( values ) { var fields = this . getFields ( ) , me = this , name , field , value , ln , i , f ; values = values || { } ; for ( name in values ) { if ( values . hasOwnProperty ( name ) ) { field = fields [ name ] ; value = values [ name ] ; if ( field ) { 
function ( enabled , all ) { var fields = this . getFields ( ) , values = { } , isArray = Ext . isArray , field , value , addValue , bucket , name , ln , i ; 
function ( byName ) { var fields = { } , itemName ; var getFieldsFrom = function ( item ) { if ( item . isField ) { itemName = item . getName ( ) ; if ( ( byName && itemName == byName ) || typeof byName == 'undefined' ) { if ( fields . hasOwnProperty ( itemName ) ) { if ( ! Ext . isArray ( fields [ itemName ] ) ) { fields [ itemName ] = [ fields [ itemName ] ] ; } fields [ itemName ] . push ( item ) ; } else { fields [ itemName ] = item ; } } } if ( item . isContainer ) { item . items . each ( getFieldsFrom ) ; } } ; this . getItems ( ) . each ( getFieldsFrom ) ; return ( byName ) ? ( fields [ byName ] || [ ] ) : fields ; } 
function ( ) { var fields = [ ] ; var getFieldsFrom = function ( item ) { if ( item . isField ) { fields . push ( item ) ; } if ( item . isContainer ) { item . items . each ( getFieldsFrom ) ; } } ; this . items . each ( getFieldsFrom ) ; return fields ; } 
function ( cfg , target ) { 
function ( ) { var fields = this . getFieldsArray ( ) , ln = fields . length , field , i ; for ( i = 0 ; i < ln ; i ++ ) { field = fields [ i ] ; if ( field . isFocused ) { return field ; } } return null ; } 
function Bucket ( index , routingTable ) { if ( ! ( this instanceof Bucket ) ) { return new Bucket ( ) } assert ( _ . isNumber ( index ) && index >= 0 && index <= constants . B ) this . index = index this . contacts = [ ] this . _cache = { } this . _routingTable = routingTable } 
function staticMove ( source : string , dest : string , assets : Array < string > ) : Promise { assets . forEach ( folder => { fs . copy ( path . join ( source , folder ) , path . join ( dest , folder ) ) ; } ) ; return Promise . resolve ( ) ; } 
function scss ( source : string , dest : string ) : Promise { return new Promise ( ( resolve , reject ) => { sass . render ( { file : source , outFile : dest , outputStyle : 'compressed' , } , ( err , result ) => { if ( err ) reject ( err ) ; fs . ensureFile ( dest ) . then ( fs . writeFile ( dest , result . css ) ) . then ( resolve ) . catch ( reject ) ; } , ) ; } ) ; } 
function ( axis , scrollerPosition ) { if ( ! this . isAxisEnabled ( axis ) ) { return this ; } var scroller = this . getScroller ( ) , scrollerMaxPosition = scroller . getMaxPosition ( ) [ axis ] , scrollerContainerSize = scroller . getContainerSize ( ) [ axis ] , value ; if ( scrollerMaxPosition === 0 ) { value = scrollerPosition / scrollerContainerSize ; if ( scrollerPosition >= 0 ) { value += 1 ; } } else { if ( scrollerPosition > scrollerMaxPosition ) { value = 1 + ( ( scrollerPosition - scrollerMaxPosition ) / scrollerContainerSize ) ; } else if ( scrollerPosition < 0 ) { value = scrollerPosition / scrollerContainerSize ; } else { value = scrollerPosition / scrollerMaxPosition ; } } this . getIndicators ( ) [ axis ] . setValue ( value ) ; } 
function ( e ) { var changedTouches = e . changedTouches , touch = ( changedTouches && changedTouches . length > 0 ) ? changedTouches [ 0 ] : e ; return this . fromTouch ( touch ) ; } 
function ( point , threshold ) { if ( typeof threshold == 'number' ) { threshold = { x : threshold } ; threshold . y = threshold . x ; } var x = point . x , y = point . y , thresholdX = threshold . x , thresholdY = threshold . y ; return ( this . x <= x + thresholdX && this . x >= x - thresholdX && this . y <= y + thresholdY && this . y >= y - thresholdY ) ; } 
function ( point ) { if ( typeof point != 'object' ) { point = { x : 0 , y : 0 } ; } return ( Math . round ( this . x ) === Math . round ( point . x ) && Math . round ( this . y ) === Math . round ( point . y ) ) ; } 
function sshExecSingleCommand ( cnxParams , cmd , fnOutput ) { var result = { "command" : cmd , "success" : true , "error" : null , "value" : null } ; return Q . promise ( function ( resolve , reject ) { var sshClient = new SSHClient ( ) ; sshClient . on ( 'ready' , function ( ) { 
function sshCommandParallel ( connection , commands , fnOutput ) { var commandList = commands . map ( function ( command ) { return sshExecSingleCommand ( connection , command , fnOutput ) ; } ) ; return Q . allSettled ( commandList ) . then ( function ( results ) { return results . map ( function ( result ) { if ( result . state === "rejected" ) { return result . reason ; } else { return result . value ; } } ) ; } ) ; } 
function sshCommandSequence ( connection , commands , fnOutput ) { var allResults = [ ] ; var successHandler = function ( nextPromise ) { return function ( result ) { if ( result !== true ) { 
function replaceRefs ( parsed , options ) { var topLevel = topLevelDeclsAndRefs ( parsed ) , refsToReplace = topLevel . refs . filter ( ref => shouldRefBeCaptured ( ref , topLevel , options ) ) , locallyIgnored = [ ] ; const replaced = ReplaceVisitor . run ( parsed , ( node , path ) => { 
function generateUniqueName ( declaredNames , hint ) { var unique = hint , n = 1 ; while ( declaredNames . indexOf ( unique ) > - 1 ) { if ( n > 1000 ) throw new Error ( "Endless loop searching for unique variable " + unique ) ; unique = unique . replace ( / _[0-9]+$|$ / , "_" + ( ++ n ) ) ; } return unique ; } 
function additionalIgnoredDecls ( parsed , options ) { var topLevel = topLevelDeclsAndRefs ( parsed ) , ignoreDecls = [ ] ; for ( var i = 0 ; i < topLevel . scope . varDecls . length ; i ++ ) { var decl = topLevel . scope . varDecls [ i ] , path = Path ( topLevel . scope . varDeclPaths [ i ] ) , parent = path . slice ( 0 , - 1 ) . get ( parsed ) ; if ( parent . type === "ForStatement" || parent . type === "ForInStatement" || parent . type === "ForOfStatement" || parent . type === "ExportNamedDeclaration" ) ignoreDecls . push ( ... decl . declarations ) } return topLevel . scope . catches . map ( ea => ea . name ) . concat ( ignoreDecls . map ( ea => ea . id . name ) ) ; } 
function replaceClassDecls ( parsed , options ) { if ( options . classToFunction ) return classToFunctionTransform ( parsed , options . classToFunction ) ; var topLevel = topLevelDeclsAndRefs ( parsed ) ; if ( ! topLevel . classDecls . length ) return parsed ; for ( var i = parsed . body . length - 1 ; i >= 0 ; i -- ) { var stmt = parsed . body [ i ] ; if ( stmt . id && topLevel . classDecls . includes ( stmt ) ) parsed . body . splice ( i + 1 , 0 , assignExpr ( options . captureObj , stmt . id , stmt . id , false ) ) ; } return parsed ; } 
function varDeclOrAssignment ( parsed , declarator , kind ) { var topLevel = topLevelDeclsAndRefs ( parsed ) , name = declarator . id . name return topLevel . declaredNames . indexOf ( name ) > - 1 ? 
function Item ( key , value , publisher , timestamp ) { if ( ! ( this instanceof Item ) ) { return new Item ( key , value , publisher , timestamp ) } assert ( typeof key === 'string' , 'Invalid key supplied' ) assert ( utils . isValidKey ( publisher ) , 'Invalid publisher nodeID supplied' ) if ( timestamp ) { assert ( typeof timestamp === 'number' , 'Invalid timestamp supplied' ) assert ( Date . now ( ) >= timestamp , 'Timestamp cannot be in the future' ) } this . key = key this . value = value this . publisher = publisher this . timestamp = timestamp || Date . now ( ) } 
function ( ) { function onLoginResponse ( res ) { if ( res . statusCode === 302 && res . headers [ 'location' ] . indexOf ( 'login.do' ) === - 1 ) { console . log ( 'login success' ) ; } else { throw new Error ( 'Login error' ) ; } } request . post ( process . env . ONEAPM_LOGIN_URL ) . form ( { encode : true , username : process . env . ONEAPM_USERNAME , strong : true , password : base64 ( process . env . ONEAPM_PASSWORD ) , } ) . on ( 'response' , onLoginResponse ) ; } 
function on ( top ) { top = typeof top === 'string' ? document . querySelector ( top ) : top ; var h = handle . bind ( this , top ) ; h . once = once . bind ( this , top ) ; return h ; } 
function handle ( top , element , type , fn , capture ) { if ( ! element || ! ( typeof element === 'string' || typeof element . length === 'number' || typeof element . addEventListener === 'function' ) ) { throw new TypeError ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( element ) ) ; } if ( typeof type !== 'string' ) throw new TypeError ( 'Event type must be a string, e.g. "click", not ' + inspect ( type ) ) ; if ( typeof fn !== 'function' ) throw new TypeError ( '`fn` (the function to call when the event is triggered) must be a function, not ' + inspect ( fn ) ) ; if ( capture !== undefined && capture !== false && capture !== true ) { throw new TypeError ( '`capture` must be `undefined` (defaults to `false`), `false` or `true`, not ' + inspect ( capture ) ) ; } if ( typeof element === 'string' ) { return handleElement ( top , type , function ( body , e ) { var target = findMatch ( body , e . target , element ) ; e . delegateTarget = target ; if ( target ) fn ( target , e ) ; } , capture ) ; } else if ( typeof element . addEventListener !== 'function' && typeof element . length === 'number' ) { return handleElements ( element , type , fn , capture ) ; } else { return handleElement ( element , type , fn , capture ) ; } } 
function handleElements ( elements , type , fn , capture ) { if ( ! elements || typeof elements . length !== 'number' ) throw new TypeError ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( elements ) ) ; if ( typeof type !== 'string' ) throw new TypeError ( 'Event type must be a string, e.g. "click", not ' + inspect ( type ) ) ; if ( typeof fn !== 'function' ) throw new TypeError ( '`fn` (the function to call when the event is triggered) must be a function, not ' + inspect ( fn ) ) ; if ( capture !== undefined && capture !== false && capture !== true ) { throw new TypeError ( '`capture` must be `undefined` (defaults to `false`), `false` or `true`, not ' + inspect ( capture ) ) ; } var handles = [ ] ; for ( var i = 0 ; i < elements . length ; i ++ ) { handles . push ( handleElement ( elements [ i ] , type , fn , capture ) ) ; } return function dispose ( ) { for ( var i = 0 ; i < handles . length ; i ++ ) { handles [ i ] ( ) ; } } ; } 
function handleElement ( element , type , fn , capture ) { if ( ! element || typeof element . addEventListener !== 'function' ) throw new TypeError ( 'Cannot bind event ' + inspect ( type ) + ' to ' + inspect ( element ) ) ; if ( typeof type !== 'string' ) throw new TypeError ( 'Event type must be a string, e.g. "click", not ' + inspect ( type ) ) ; if ( typeof fn !== 'function' ) throw new TypeError ( '`fn` (the function to call when the event is triggered) must be a function, not ' + inspect ( fn ) ) ; if ( capture !== undefined && capture !== false && capture !== true ) { throw new TypeError ( '`capture` must be `undefined` (defaults to `false`), `false` or `true`, not ' + inspect ( capture ) ) ; } function onEvent ( e ) { e . delegateTarget = element ; return fn ( element , e ) ; } element . addEventListener ( type , onEvent , capture || false ) ; return element . removeEventListener . bind ( element , type , onEvent , capture || false ) ; } 
function findMatch ( top , bottom , selector ) { while ( bottom != top && bottom ) { if ( matches ( bottom , selector ) ) return bottom ; bottom = bottom . parentElement ; } if ( bottom && matches ( bottom , selector ) ) return bottom ; return null ; } 
function CropAndResize ( arg , opt ) { this . boxInit = new Box ( ) ; this . editor = new Editor ( arg ) ; this . mask = new JSYG ( '<rect>' ) [ 0 ] ; this . selection = new JSYG ( '<rect>' ) [ 0 ] ; this . pattern = new JSYG ( '<pattern>' ) [ 0 ] ; if ( arg ) this . setNode ( arg ) ; if ( opt ) this . enable ( opt ) ; } 
function ( width , height ) { var box = this . selection . getBBox ( ) ; return JSYG ( this . node ) . toCanvas ( ) . then ( function ( canvas ) { var maxWidth = canvas . getAttribute ( "width" ) , maxHeight = canvas . getAttribute ( "height" ) , x = Math . max ( 0 , box . x ) , y = Math . max ( 0 , box . y ) , boxWidth = Math . min ( maxWidth , box . width ) , boxHeight = Math . min ( maxHeight , box . height ) ; canvas = new Canvas ( canvas ) ; canvas = canvas . crop ( x , y , boxWidth , boxHeight ) ; if ( width != null || height != null ) canvas = canvas . resize ( width , height ) ; return canvas [ 0 ] ; } ) ; } 
function ( opt ) { this . disable ( ) ; if ( opt ) this . set ( opt ) ; var jNode = new JSYG ( this . node ) , dim = jNode . getDim ( ) , color = jNode . fill ( ) , svg = jNode . offsetParent ( ) , id = 'idpattern' + JSYG . rand ( 0 , 5000 ) , g , rect , selection ; if ( ! color || color == 'transparent' || color == 'none' ) color = 'white' ; if ( dim . width < this . boxInit . width ) this . boxInit . width = dim . width ; if ( dim . height < this . boxInit . height ) this . boxInit . height = dim . height ; rect = new JSYG ( '<rect>' ) . fill ( color ) ; g = new JSYG ( '<g>' ) . append ( rect ) ; new JSYG ( this . pattern ) . attr ( { id : id , patternUnits : 'userSpaceOnUse' } ) . append ( g ) . appendTo ( svg ) ; new JSYG ( this . mask ) . css ( 'fill-opacity' , 0.5 ) . appendTo ( svg ) ; if ( this . keepRatio ) this . boxInit . height = dim . height * this . boxInit . width / dim . width ; selection = new JSYG ( this . selection ) . attr ( this . boxInit ) . attr ( 'fill' , "url(#" + id + ")" ) . appendTo ( svg ) ; this . editor . target ( selection ) ; this . editor . displayShadow = false ; new JSYG ( this . editor . pathBox ) . css ( 'fill-opacity' , 0 ) ; this . editor . ctrlsDrag . enable ( { bounds : 0 } ) ; this . editor . ctrlsResize . enable ( { keepRatio : this . keepRatio , bounds : 0 } ) ; this . editor . show ( ) ; this . enabled = true ; this . update ( ) ; return this ; } 
function ( ) { this . editor . hide ( ) ; new JSYG ( this . pattern ) . remove ( ) ; new JSYG ( this . mask ) . remove ( ) ; new JSYG ( this . selection ) . remove ( ) ; this . enabled = false ; return this ; } 
function postinstall ( ) { var json = Readers . getBowerJSON ( ) ; if ( ! json . scripts || ! json . scripts . postinstall ) return ; 
function ( pie ) { var current = process . cwd ( ) ; 
function reqo ( func , requiredKeys ) { var optionsIndex = arguments [ 2 ] === undefined ? 0 : arguments [ 2 ] ; var context = arguments [ 3 ] === undefined ? undefined : arguments [ 3 ] ; return function ( ) { for ( var _len = arguments . length , args = Array ( _len ) , _key = 0 ; _key < _len ; _key ++ ) { args [ _key ] = arguments [ _key ] ; } var options = args [ optionsIndex ] ; if ( ! ( 0 , _lodash . isPlainObject ) ( options ) ) { throw new TypeError ( 'options must be a plain object literal' ) ; } 
function Strategy ( options , verify ) { options = options || { } ; if ( options . statusnet === undefined ) { throw new Error ( "A StatusNet instance is required (e.g. identi.ca)" ) ; } this . prefix = "https://" + options . statusnet + "/api" ; options . requestTokenURL = options . requestTokenURL || this . prefix + '/oauth/request_token' ; options . accessTokenURL = options . accessTokenURL || this . prefix + '/oauth/access_token' ; options . userAuthorizationURL = options . userAuthorizationURL || this . prefix + '/oauth/authorize' ; options . sessionKey = options . sessionKey || 'oauth:' + options . statusnet ; OAuthStrategy . call ( this , options , verify ) ; this . name = options . statusnet ; } 
function without ( toRemove ) { return function ( prev , curr ) { if ( ! Array . isArray ( prev ) ) { prev = ! testValue ( prev , toRemove ) ? [ prev ] : [ ] } if ( ! testValue ( curr , toRemove ) ) prev . push ( curr ) return prev } } 
function initDhtmlxToolbar ( container ) { var impl = null ; if ( Util . isNode ( container ) ) { impl = new dhtmlXToolbarObject ( container , SKIN ) ; } else if ( container . type === OBJECT_TYPE . LAYOUT_CELL || container . type === OBJECT_TYPE . ACCORDION_CELL || container . type === OBJECT_TYPE . LAYOUT || container . type === OBJECT_TYPE . WINDOW || container . type === OBJECT_TYPE . TAB ) { impl = container . impl . attachToolbar ( ) ; impl . setSkin ( SKIN ) ; } else { throw new Error ( 'initDhtmlxToolbar: container is not valid.' ) ; } return impl ; } 
function ( data , track ) { if ( track !== false ) data = $track ( data , track ) ; this . data = data ; this . _dep . changed ( ) ; return this ; } 
function ( ) { var models = [ this ] , model = this ; while ( model . parent ) { models . unshift ( model = model . parent ) ; } return models } 
function ( index ) { if ( ! _ . isNumber ( index ) || isNaN ( index ) ) index = 0 ; if ( index < 0 ) return this . getAllModels ( ) [ ~ index ] ; var model = this ; while ( index && model ) { model = model . parent ; index -- ; } return model ; } 
function ( fn ) { var index = 0 , model = this ; while ( model != null ) { if ( fn . call ( this , model , index ++ ) ) return model ; model = model . parent ; } } 
function ( path ) { if ( typeof path === "string" ) path = parse ( path , { startRule : "path" } ) ; if ( ! _ . isObject ( path ) ) throw new Error ( "Expecting string or object for path." ) ; var self = this ; this . _dep . depend ( ) ; return _ . reduce ( path . parts , function ( target , part ) { target = self . _get ( target , part . key ) ; _ . each ( part . children , function ( k ) { if ( _ . isObject ( k ) ) k = self . get ( k ) ; target = self . _get ( target , k ) ; } ) ; return target ; } , this . data ) ; } 
function ( paths ) { var self = this ; if ( typeof paths === "string" ) paths = parse ( paths , { startRule : "pathQuery" } ) ; if ( ! _ . isArray ( paths ) ) paths = paths != null ? [ paths ] : [ ] ; if ( ! paths . length ) { var model = this . findModel ( function ( m ) { return ! _ . isUndefined ( m . data ) ; } ) ; if ( model == null ) return ; var val = model . data ; if ( _ . isFunction ( val ) ) val = val . call ( this , null ) ; return val ; } return _ . reduce ( paths , function ( result , path , index ) { var model = self , scope = true , val ; if ( path . type === "root" ) { model = self . getRootModel ( ) ; } else if ( path . type === "parent" ) { model = self . getModelAtOffset ( path . distance ) ; scope = false ; } else if ( path . type === "all" ) { scope = false ; } if ( model == null ) return ; while ( _ . isUndefined ( val ) && model != null ) { val = model . getLocal ( path ) ; model = model . parent ; if ( scope ) break ; } if ( _ . isFunction ( val ) ) { val = val . call ( self , index === 0 ? null : result ) ; } return val ; } , void 0 ) ; } 
function deepQuery ( root , currentDir , lastKey , cb ) { if ( ! lastKey ) { 
function ( done ) { crypto . randomBytes ( 20 , function ( err , buffer ) { var token = buffer . toString ( 'hex' ) ; done ( err , token ) ; } ) ; } 
function ( token , done ) { if ( req . body . username ) { User . findOne ( { username : req . body . username } , '-salt -password' , function ( err , user ) { if ( ! user ) { return res . status ( 400 ) . send ( { message : 'No account with that username has been found' } ) ; } else if ( user . provider !== 'local' ) { return res . status ( 400 ) . send ( { message : 'It seems like you signed up using your ' + user . provider + ' account' } ) ; } else { user . resetPasswordToken = token ; user . resetPasswordExpires = Date . now ( ) + 3600000 ; 
function ( emailHTML , user , done ) { var smtpTransport = nodemailer . createTransport ( config . mailer . options ) ; var mailOptions = { to : user . email , from : config . mailer . from , subject : 'Your password has been changed' , html : emailHTML } ; smtpTransport . sendMail ( mailOptions , function ( err ) { done ( err , 'done' ) ; } ) ; } 
function sortIssues ( issues ) { var sorted ; 
function deduplicateCollaborators ( collaborators ) { var foundLogins = [ ] ; return _ . filter ( collaborators , function ( collaborator ) { var duplicate = false , login = collaborator . login ; if ( foundLogins . indexOf ( login ) > - 1 ) { duplicate = true ; } else { foundLogins . push ( login ) ; } return ! duplicate ; } ) ; } 
function extractSuperIssueSubTaskNumbers ( superIssue ) { var matches = superIssue . body . match ( markdownTasksRegex ) , subTaskIds = [ ] ; _ . each ( matches , function ( line ) { var match = line . match ( subtaskRegex ) ; if ( match ) { subTaskIds . push ( parseInt ( match [ 3 ] ) ) ; } } ) ; return subTaskIds ; } 
function formatIssues ( format , issues ) { var formattedIssues , partition , superIssues , singletonIssues , removedSubtasks = [ ] ; if ( format == 'network' ) { formattedIssues = { supers : [ ] , singletons : [ ] , all : issues } ; partition = _ . partition ( issues , function ( issue ) { return _ . find ( issue . labels , function ( label ) { return label . name == 'super' ; } ) ; } ) ; superIssues = partition . shift ( ) ; singletonIssues = partition . shift ( ) ; _ . each ( superIssues , function ( superIssue ) { var subTaskNumbers = extractSuperIssueSubTaskNumbers ( superIssue ) ; superIssue . subtasks = _ . filter ( singletonIssues , function ( issue ) { var isSubtask = _ . contains ( subTaskNumbers , issue . number ) ; if ( isSubtask ) { removedSubtasks . push ( issue . number ) ; } return isSubtask ; } ) ; } ) ; formattedIssues . supers = superIssues ; _ . each ( singletonIssues , function ( issue ) { if ( ! _ . contains ( removedSubtasks , issue . number ) ) { formattedIssues . singletons . push ( issue ) ; } } ) ; } else { formattedIssues = issues ; } return formattedIssues ; } 
function mergeIssuesAndPrs ( issues , prs ) { _ . each ( issues , function ( issue ) { var targetPr , targetPrIndex = _ . findIndex ( prs , function ( pr ) { return pr && pr . number == issue . number ; } ) ; if ( targetPrIndex > - 1 ) { targetPr = prs [ targetPrIndex ] ; prs [ targetPrIndex ] = _ . merge ( targetPr , issue ) ; } } ) ; return prs ; } 
function Sprinter ( username , password , repoSlugs , cache ) { if ( ! username ) { throw new Error ( 'Missing username.' ) ; } if ( ! password ) { throw new Error ( 'Missing password.' ) ; } if ( ! repoSlugs ) { throw new Error ( 'Missing repositories.' ) ; } this . username = username ; this . password = password ; 
function getFetchByStateCallback ( callback ) { return function ( err , data ) { if ( err ) { asyncErrors . push ( err ) ; } callback ( null , data ) ; } ; } 
function listAvailables ( forceRefresh ) { forceRefresh && ( adaptersCache = [ ] ) ; if ( adaptersCache . length ) { return adaptersCache ; } adaptersCache = fs . readdirSync ( __dirname ) . filter ( function ( fileOrDirName ) { return isDir ( __dirname + '/' + fileOrDirName ) ; } ) ; return adaptersCache ; } 
function readConfig ( adapterName , path ) { var adapter = getAdapterInstance ( adapterName ) ; return adapter . configLoader ( normalizeAdapterConfigPath ( adapter , path ) ) ; } 
function writeConfig ( adapterName , path , config ) { var adapter = getAdapterInstance ( adapterName ) ; return adapter . configWriter ( normalizeAdapterConfigPath ( adapter , path ) , config ) ; } 
function handleFiles ( files ) { files . forEach ( function ( f ) { f . src . filter ( srcExists ) . map ( function ( filepath ) { var pathInfo = getPathInfo ( filepath , f . dest ) , context = getContext ( f . context , pathInfo ) ; renderFile ( pathInfo . outfile , filepath , context ) ; } ) ; } ) ; } 
function handleI18nFiles ( files ) { options . locales . forEach ( function ( locale ) { grunt . registerTask ( 'swigtemplatesSubtask-' + locale , function ( ) { var done = this . async ( ) ; var translatorFactory = options . translateFunction ( locale ) ; Q . when ( translatorFactory , function ( translator ) { doTranslations ( files , locale , translator ) } ) . done ( done ) ; } ) ; grunt . task . run ( 'swigtemplatesSubtask-' + locale ) ; } ) ; } 
function doTranslations ( files , locale , translator ) { files . forEach ( function ( f ) { f . src . filter ( srcExists ) . map ( function ( filepath ) { var pathInfo = getPathInfo ( filepath , f . dest ) , context = getContext ( f . context , pathInfo ) ; if ( locale !== options . defaultLocale ) { pathInfo . outfile = path . join ( f . dest , locale , pathInfo . outfilePath , pathInfo . outfileName ) ; } context . locale = locale ; options . locals [ options . translateFunctionName ] = function ( ) { var args = Array . prototype . slice . call ( arguments ) ; return translator ( args ) ; } ; swig . setDefaults ( { locals : options . locals } ) ; renderFile ( pathInfo . outfile , filepath , context ) ; } ) ; } ) ; } 
function renderFile ( outfile , filepath , context ) { grunt . file . write ( outfile , swig . renderFile ( filepath , context ) ) ; grunt . log . ok ( 'File "' + outfile + '" created.' ) ; } 
function getPathInfo ( filepath , dest ) { var outfileName = path . basename ( filepath , '.swig' ) , dirName = path . dirname ( filepath ) , outfilePath = path . normalize ( path . relative ( options . templatesDir , dirName ) ) , outfile = path . join ( dest , outfilePath , outfileName ) ; return { outfileName : outfileName , dirName : dirName , outfilePath : outfilePath , outfile : outfile } ; } 
function getContext ( context , pathInfo ) { var globalContext , templateContext ; try { globalContext = grunt . file . readJSON ( path . join ( options . templatesDir , "global.json" ) ) ; } catch ( err ) { globalContext = { } ; } try { templateContext = grunt . file . readJSON ( path . join ( pathInfo . dirName , pathInfo . outfileName ) + ".json" ) ; } catch ( err ) { templateContext = { } ; } return _ . extend ( { } , globalContext , templateContext , options . defaultContext , context ) ; } 
function Lru ( options ) { if ( options === undefined ) { options = { } } this . size = 0 ; this . maxSize = options . maxSize ; this . delCallback = options . delCallback ; this . hashEnabled = options . hashEnabled === undefined ? true : options . hashEnabled ; 
function render ( url ) { return async page => { try { const template = ` ${ page . template || 'schedule' } ` ; 
async function generateMenu ( ) { try { const files = await fs . readdir ( source ) ; const filter = files . filter ( file => file . substring ( 0 , file . lastIndexOf ( '.' ) ) !== 'index' ) ; const menu = filter . map ( file => ( { title : file . substring ( 0 , file . lastIndexOf ( '.' ) ) , url : file . substring ( 0 , file . lastIndexOf ( '.' ) ) , } ) ) ; menu . unshift ( { title : 'Home' , url : '' } ) ; return menu ; } catch ( err ) { throw err ; } } 
function isNamedFunction ( node ) { if ( node . id ) return true ; const { parent } = node ; const { type } = parent ; const namedFunction = type === 'MethodDefinition' || type === 'Property' && ( parent . kind === 'get' || parent . kind === 'set' || parent . method ) ; return namedFunction ; } 
function getConfigForFunction ( node ) { if ( isNamedFunction ( node ) ) return 'never' ; if ( node . type === 'ArrowFunctionExpression' ) { 
function checkFunction ( node ) { const functionConfig = getConfigForFunction ( node ) ; if ( functionConfig === 'ignore' ) return ; const rightToken = sourceCode . getFirstToken ( node , astUtils . isOpeningParenToken ) ; const leftToken = sourceCode . getTokenBefore ( rightToken ) ; const text = sourceCode . text . slice ( leftToken . range [ 1 ] , rightToken . range [ 0 ] ) . replace ( / \/\*[^]*?\*\/ / g , '' ) ; if ( astUtils . LINEBREAK_MATCHER . test ( text ) ) return ; const hasSpacing = / \s / . test ( text ) ; if ( hasSpacing && functionConfig === 'never' ) { const report = { node , loc : leftToken . loc . end , message : 'Unexpected space before function parentheses.' , fix : fixer => fixer . removeRange ( [ leftToken . range [ 1 ] , rightToken . range [ 0 ] ] ) , } ; context . report ( report ) ; } else if ( ! hasSpacing && functionConfig === 'always' ) { const report = { node , loc : leftToken . loc . end , message : 'Missing space before function parentheses.' , fix : fixer => fixer . insertTextAfter ( leftToken , ' ' ) , } ; context . report ( report ) ; } } 
function ( config ) { var me = this ; 
function checkStructMember ( structname , obj , callback , root ) { var membername = obj . name . name ; if ( ! isVarString ( membername ) ) { callback ( false , structname + '.' + membername + ': The first letter should be lowercase.' ) ; return false ; } if ( ! base . isType ( obj . type , root ) ) { callback ( false , structname + '.' + membername + ': ' + obj . type + ' not defined.' ) ; return false ; } if ( obj . type == 'time' ) { if ( obj . hasOwnProperty ( 'val' ) ) { if ( typeof ( obj . val ) == 'object' ) { if ( obj . val . type == 'NULL' ) { return true ; } else if ( obj . val . type == 'time' && obj . val . val == 'NOW' ) { return true ; } } callback ( false , structname + '.' + membername + ': default is not NULL or NOW.' ) ; return false ; } } else if ( obj . type == 'int' ) { if ( obj . hasOwnProperty ( 'val' ) ) { if ( typeof ( obj . val ) == 'object' ) { if ( obj . val . type == 'int' && obj . val . val == 'AUTOINC' ) { if ( obj . type2 != 'primary' ) { callback ( false , structname + '.' + membername + ': AUTOINC is primary.' ) ; return false ; } } } } } if ( obj . type2 == 'expand' ) { if ( obj . hasOwnProperty ( 'expand' ) ) { if ( ! base . isEnum ( obj . expand , root ) ) { callback ( false , structname + '.' + membername + ': expand need enum!.' ) ; return false ; } } else { var cobj = base . getGlobalObj ( obj . type , root ) ; if ( cobj == undefined ) { callback ( false , structname + '.' + membername + ': expand fail!.' ) ; return false ; } var structobj = base . getGlobalObj ( structname , root ) ; for ( var i = 0 ; i < cobj . val . length ; ++ i ) { if ( base . hasMemberEx ( cobj . val [ i ] . name . name , obj . type , structobj , root ) ) { callback ( false , structname + '.' + membername + '.' + cobj . val [ i ] . name . name + ': expand err(duplication of name).' ) ; return false ; } } } } if ( obj . type2 == 'repeated' ) { if ( obj . hasOwnProperty ( 'memberkey' ) ) { if ( ! ( base . isStruct ( obj . type , root ) || base . isStatic ( obj . type , root ) ) ) { callback ( false , structname + '.' + membername + ': repeated object must be struct.' ) ; return false ; } if ( ! base . hasMember2 ( obj . memberkey , base . getGlobalObj ( obj . type , root ) , root ) ) { callback ( false , structname + '.' + membername + ': repeated key(' + obj . memberkey + ') not defined in ' + obj . type + '.' ) ; return false ; } } } return true ; } 
function checkStruct ( obj , callback , root ) { if ( obj . type == 'struct' || obj . type == 'static' || obj . type == 'message' ) { if ( ! isTypeString ( obj . name ) ) { callback ( false , 'struct ' + obj . name + ': The first letter should be capitalized.' ) ; return false ; } for ( var i = 0 ; i < obj . val . length ; ++ i ) { if ( base . countMember ( obj . val [ i ] . name . name , obj , root ) > 1 ) { callback ( false , 'struct ' + obj . name + '.' + obj . val [ i ] . name . name + ': duplication of name.' ) ; return false ; } if ( ! checkStructMember ( obj . name , obj . val [ i ] , callback , root ) ) { return false ; } if ( obj . type == 'message' ) { if ( obj . val [ i ] . name . name . indexOf ( '_' ) == 0 ) { callback ( false , 'message ' + obj . name + '.' + obj . val [ i ] . name . name + ": can't begin with an underscore(_)." ) ; return false ; } } } } return true ; } 
function checkEnumMember ( enumname , enumarr , obj , callback ) { if ( ! isEnumString ( obj . name ) ) { callback ( false , enumname + '.' + obj . name + ': All letters should be capitalized.' ) ; return false ; } if ( obj . type != 'int' ) { callback ( false , enumname + '.' + obj . name + ': This member is not int.' ) ; return false ; } if ( obj . name . indexOf ( enumname + '_' ) != 0 ) { callback ( false , enumname + '.' + obj . name + ': This member is begin ' + enumname + '_.' ) ; return false ; } if ( enumarr . indexOf ( obj . val ) >= 0 ) { callback ( false , enumname + '.' + obj . name + ': This member\'s val is used.' ) ; return false ; } return true ; } 
function checkEnum ( obj , callback ) { if ( obj . type == 'enum' ) { if ( ! isEnumString ( obj . name ) ) { callback ( false , 'enum ' + obj . name + ': All letters should be capitalized.' ) ; return false ; } var enumarr = [ ] ; for ( var i = 0 ; i < obj . val . length ; ++ i ) { if ( ! checkEnumMember ( obj . name , enumarr , obj . val [ i ] , callback ) ) { return false ; } enumarr . push ( obj . val [ i ] . val ) ; } } return true ; } 
function checkType ( obj , callback , root ) { if ( obj . type == 'type' ) { if ( ! isTypeString ( obj . name ) ) { callback ( false , 'global type ' + obj . name + ': The first letter should be capitalized.' ) ; return false ; } if ( ! base . isType ( obj . name , root ) ) { callback ( false , 'global type ' + obj . name + ': ' + obj . name + ' not defined.' ) ; return false ; } } return true ; } 
function checkGrammar ( obj , callback ) { let hasver = false ; if ( Array . isArray ( obj ) ) { for ( var i = 0 ; i < obj . length ; ++ i ) { var nums = base . countGlobalObj ( obj [ i ] . name , obj ) ; if ( nums > 1 ) { callback ( false , obj [ i ] . name + ': duplication of name' ) ; return false ; } if ( obj [ i ] . name == 'VER' ) { hasver = true ; } if ( obj [ i ] . type == 'struct' || obj [ i ] . type == 'static' || obj [ i ] . type == 'message' ) { checkStruct ( obj [ i ] , callback , obj ) ; } else if ( obj [ i ] . type == 'enum' ) { checkEnum ( obj [ i ] , callback ) ; } else if ( obj [ i ] . type == 'type' ) { checkType ( obj [ i ] , callback , obj ) ; } } if ( ! hasver ) { callback ( false , 'no VER!' ) ; return false ; } return true ; } callback ( false , 'empty file!' ) ; return false ; } 
function bindEventMap ( eventMap , eventEmitter ) { var eventNames = Object . keys ( eventMap ) ; eventNames . map ( function ( eventName ) { eventEmitter . on ( eventName , eventMap [ eventName ] ) ; } ) ; } 
function ( delay , newFn , newScope , newArgs ) { var me = this ; 
function ( operation ) { var me = this , params = Ext . applyIf ( operation . getParams ( ) || { } , me . getExtraParams ( ) || { } ) , request ; 
function ( success , operation , request , response , callback , scope ) { var me = this , action = operation . getAction ( ) , reader , resultSet ; if ( success === true ) { reader = me . getReader ( ) ; try { resultSet = reader . process ( me . getResponseResult ( response ) ) ; } catch ( e ) { operation . setException ( e . message ) ; me . fireEvent ( 'exception' , me , response , operation ) ; return ; } * @event exception * Fires when the server returns an exception * @param {Ext.data.proxy.Proxy} this * @param {Object} response The response from the AJAX request * @param {Ext.data.Operation} operation The operation that triggered request */ me . fireEvent ( 'exception' , this , response , operation ) ; } 
function ( operation , response ) { if ( Ext . isObject ( response ) ) { operation . setException ( { status : response . status , statusText : response . statusText } ) ; } } 
function ( sorters ) { var min = [ ] , length = sorters . length , i = 0 ; for ( ; i < length ; i ++ ) { min [ i ] = { property : sorters [ i ] . getProperty ( ) , direction : sorters [ i ] . getDirection ( ) } ; } return this . applyEncoding ( min ) ; } 
function ( filters ) { var min = [ ] , length = filters . length , i = 0 ; for ( ; i < length ; i ++ ) { min [ i ] = { property : filters [ i ] . getProperty ( ) , value : filters [ i ] . getValue ( ) } ; } return this . applyEncoding ( min ) ; } 
function ( request ) { var me = this , url = me . getUrl ( request ) ; 
function hasTAB ( excelobj , tabname ) { for ( let ii = 0 ; ii < excelobj . length ; ++ ii ) { if ( excelobj [ ii ] . name == tabname ) { return true ; } } return false ; } 
function mergeExcel ( src1 , src2 ) { if ( src1 == undefined ) { return src2 ; } if ( src1 [ 0 ] . name != src2 [ 0 ] . name ) { return src2 ; } if ( src1 [ 0 ] . data . length <= 2 ) { return src2 ; } let dest = [ ] ; dest . push ( { name : src2 [ 0 ] . name , data : [ ] } ) ; for ( let ii = 0 ; ii < src1 [ 0 ] . data . length ; ++ ii ) { dest [ 0 ] . data . push ( [ ] ) ; } for ( let ii = 0 ; ii < src2 [ 0 ] . data [ 1 ] . length ; ++ ii ) { let sf = findField ( src1 [ 0 ] . data , src2 [ 0 ] . data [ 1 ] [ ii ] ) ; if ( sf != - 1 ) { let cn = src1 [ 0 ] . data . length - 2 ; dest [ 0 ] . data [ 0 ] . push ( src2 [ 0 ] . data [ 0 ] [ ii ] ) ; dest [ 0 ] . data [ 1 ] . push ( src2 [ 0 ] . data [ 1 ] [ ii ] ) ; for ( let jj = 0 ; jj < cn ; ++ jj ) { dest [ 0 ] . data [ jj + 2 ] . push ( src1 [ 0 ] . data [ jj + 2 ] [ sf ] ) ; } } else { let cn = src1 [ 0 ] . data . length - 2 ; dest [ 0 ] . data [ 0 ] . push ( src2 [ 0 ] . data [ 0 ] [ ii ] ) ; dest [ 0 ] . data [ 1 ] . push ( src2 [ 0 ] . data [ 1 ] [ ii ] ) ; for ( let jj = 0 ; jj < cn ; ++ jj ) { dest [ 0 ] . data [ jj + 2 ] . push ( '' ) ; } } } for ( let ii = 1 ; ii < src2 . length ; ++ ii ) { dest . push ( src2 [ ii ] ) ; } return dest ; } 
function ( newDateFormat , oldDateFormat ) { var value = this . getValue ( ) ; if ( newDateFormat != oldDateFormat && Ext . isDate ( value ) ) { this . getComponent ( ) . setValue ( Ext . Date . format ( value , newDateFormat || Ext . util . Format . defaultDateFormat ) ) ; } } 
function ( format ) { var value = this . getValue ( ) ; return ( Ext . isDate ( value ) ) ? Ext . Date . format ( value , format || this . getDateFormat ( ) || Ext . util . Format . defaultDateFormat ) : value ; } 
function ( picker , value ) { var me = this , oldValue = me . getValue ( ) ; me . setValue ( value ) ; me . fireEvent ( 'select' , me , value ) ; me . onChange ( me , value , oldValue ) ; } 
function ( ) { var me = this , picker = me . getPicker ( ) ; if ( me . getDestroyPickerOnHide ( ) && picker ) { picker . destroy ( ) ; me . _picker = me . getInitialConfig ( ) . picker || true ; } } 
function debug ( gt ) { var args = arrayify ( arguments ) ; args . splice ( 0 , 1 ) ; 
function findRoute ( ghosttrain , verb , url ) { 
function clone ( obj ) { var newObj = { } ; 
function requestURL ( url ) { var parsedURL = url . pathname ? url : parseURL ( url , true ) ; return parsedURL . pathname + ( parsedURL . search || '' ) ; } 
function addRoute ( verb ) { return function ( path , fn ) { 
function pathRegexp ( path , keys , sensitive , strict ) { if ( Object . prototype . toString . call ( path ) == '[object RegExp]' ) return path ; if ( Array . isArray ( path ) ) path = '(' + path . join ( '|' ) + ')' ; path = path . concat ( strict ? '' : '/?' ) . replace ( / \/\( / g , '(?:/' ) . replace ( / (\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)? / g , function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash || '' ; return '' + ( optional ? '' : slash ) + '(?:' + ( optional ? slash : '' ) + ( format || '' ) + ( capture || ( format && '([^/.]+?)' || '([^/]+?)' ) ) + ')' + ( optional || '' ) + ( star ? '(/*)?' : '' ) ; } ) . replace ( / ([\/.]) / g , '\\$1' ) . replace ( / \* / g , '(.*)' ) ; return new RegExp ( '^' + path + '$' , sensitive ? '' : 'i' ) ; } 
function ImpulseBin ( ) { this . settings = { adapter : 'commander' , quietOption : 'quiet' , requiredOptionTmpl : '--%s is required' , verboseOption : 'verbose' , verboseLogName : '[verbose]' , stdoutLogName : '[stdout]' , stderrLogName : '[stderr]' } ; this . console = require ( 'long-con' ) . create ( ) ; 
function ( config ) { var me = this , currentConfig = me . config , id ; me . onInitializedListeners = [ ] ; me . initialConfig = config ; if ( config !== undefined && 'id' in config ) { id = config . id ; } else if ( 'id' in currentConfig ) { id = currentConfig . id ; } else { id = me . getId ( ) ; } me . id = id ; me . setId ( id ) ; Ext . ComponentManager . register ( me ) ; me . initElement ( ) ; me . initConfig ( me . initialConfig ) ; me . refreshSizeState = me . doRefreshSizeState ; me . refreshFloating = me . doRefreshFloating ; if ( me . refreshSizeStateOnInitialized ) { me . refreshSizeState ( ) ; } if ( me . refreshFloatingOnInitialized ) { me . refreshFloating ( ) ; } me . initialize ( ) ; me . triggerInitialized ( ) ; if ( me . config . fullscreen ) { me . fireEvent ( 'fullscreen' , me ) ; } me . fireEvent ( 'initialize' , me ) ; } 
function ( cls , prefix , suffix ) { var oldCls = this . getCls ( ) , newCls = ( oldCls ) ? oldCls . slice ( ) : [ ] , ln , i , cachedCls ; prefix = prefix || '' ; suffix = suffix || '' ; if ( typeof cls == "string" ) { cls = [ cls ] ; } ln = cls . length ; 
function ( cls , prefix , suffix ) { var oldCls = this . getCls ( ) , newCls = ( oldCls ) ? oldCls . slice ( ) : [ ] , ln , i ; prefix = prefix || '' ; suffix = suffix || '' ; if ( typeof cls == "string" ) { newCls = Ext . Array . remove ( newCls , prefix + cls + suffix ) ; } else { ln = cls . length ; for ( i = 0 ; i < ln ; i ++ ) { newCls = Ext . Array . remove ( newCls , prefix + cls [ i ] + suffix ) ; } } this . setCls ( newCls ) ; } 
function ( oldCls , newCls , prefix , suffix ) { 
function ( className , force ) { var oldCls = this . getCls ( ) , newCls = ( oldCls ) ? oldCls . slice ( ) : [ ] ; if ( force || newCls . indexOf ( className ) == - 1 ) { newCls . push ( className ) ; } else { Ext . Array . remove ( newCls , className ) ; } this . setCls ( newCls ) ; return this ; } 
function ( newHtmlCls , oldHtmlCls ) { var innerHtmlElement = this . innerHtmlElement , innerElement = this . innerElement ; if ( this . getStyleHtmlContent ( ) && oldHtmlCls ) { if ( innerHtmlElement ) { innerHtmlElement . replaceCls ( oldHtmlCls , newHtmlCls ) ; } else { innerElement . replaceCls ( oldHtmlCls , newHtmlCls ) ; } } } 
function ( animation ) { this . setCurrentAlignmentInfo ( null ) ; if ( ! this . getHidden ( ) ) { if ( animation === undefined || ( animation && animation . isComponent ) ) { animation = this . getHideAnimation ( ) ; } if ( animation ) { if ( animation === true ) { animation = 'fadeOut' ; } this . onBefore ( { hiddenchange : 'animateFn' , scope : this , single : true , args : [ animation ] } ) ; } this . setHidden ( true ) ; } return this ; } 
function ( animation ) { if ( this . activeAnimation ) { this . activeAnimation . on ( { animationend : function ( ) { this . show ( animation ) ; } , scope : this , single : true } ) ; return this ; } var hidden = this . getHidden ( ) ; if ( hidden || hidden === null ) { if ( animation === true ) { animation = 'fadeIn' ; } else if ( animation === undefined || ( animation && animation . isComponent ) ) { animation = this . getShowAnimation ( ) ; } if ( animation ) { this . beforeShowAnimation ( ) ; this . onBefore ( { hiddenchange : 'animateFn' , scope : this , single : true , args : [ animation ] } ) ; } this . setHidden ( false ) ; } return this ; } 
function ( width , height ) { if ( width != undefined ) { this . setWidth ( width ) ; } if ( height != undefined ) { this . setHeight ( height ) ; } } 
function ( component , alignment ) { var me = this , viewport = Ext . Viewport , parent = me . getParent ( ) ; me . setVisibility ( false ) ; if ( parent !== viewport ) { viewport . add ( me ) ; } me . show ( ) ; me . on ( { hide : 'onShowByErased' , destroy : 'onShowByErased' , single : true , scope : me } ) ; viewport . on ( 'resize' , 'alignTo' , me , { args : [ component , alignment ] } ) ; me . alignTo ( component , alignment ) ; me . setVisibility ( true ) ; } 
function ( component , alignment ) { var alignToElement = component . isComponent ? component . renderElement : component , alignToBox = alignToElement . getPageBox ( ) , element = this . renderElement , box = element . getPageBox ( ) , stats = { alignToBox : alignToBox , alignment : alignment , top : alignToBox . top , left : alignToBox . left , alignToWidth : alignToBox . width , alignToHeight : alignToBox . height , width : box . width , height : box . height } , currentAlignmentInfo = this . getCurrentAlignmentInfo ( ) , isAligned = true ; if ( ! Ext . isEmpty ( currentAlignmentInfo ) ) { Ext . Object . each ( stats , function ( key , value ) { if ( ! Ext . isObject ( value ) && currentAlignmentInfo [ key ] != value ) { isAligned = false ; return false ; } return true ; } ) ; } else { isAligned = false ; } return { isAligned : isAligned , stats : stats } ; } 
function ( alignmentInfo ) { this . $currentAlignmentInfo = Ext . isEmpty ( alignmentInfo ) ? null : Ext . merge ( { } , alignmentInfo . stats ? alignmentInfo . stats : alignmentInfo ) ; } 
function ( selector ) { var result = this . parent ; if ( selector ) { for ( ; result ; result = result . parent ) { if ( Ext . ComponentQuery . is ( result , selector ) ) { return result ; } } } return result ; } 
function ( ) { this . destroy = Ext . emptyFn ; var parent = this . getParent ( ) , referenceList = this . referenceList , i , ln , reference ; this . isDestroying = true ; Ext . destroy ( this . getTranslatable ( ) , this . getPlugins ( ) ) ; 
function ( from , to ) { var me = this , items = me . getViewItems ( ) , i = to - from , item ; for ( ; i >= 0 ; i -- ) { item = items [ from + i ] ; Ext . get ( item ) . destroy ( ) ; } if ( me . getViewItems ( ) . length == 0 ) { this . dataview . showEmptyText ( ) ; } } 
function ( records ) { var me = this , dataview = me . dataview , store = dataview . getStore ( ) , ln = records . length , i , record ; if ( ln ) { dataview . hideEmptyText ( ) ; } for ( i = 0 ; i < ln ; i ++ ) { records [ i ] . _tmpIndex = store . indexOf ( records [ i ] ) ; } Ext . Array . sort ( records , function ( record1 , record2 ) { return record1 . _tmpIndex > record2 . _tmpIndex ? 1 : - 1 ; } ) ; for ( i = 0 ; i < ln ; i ++ ) { record = records [ i ] ; me . addListItem ( record . _tmpIndex , record ) ; delete record . _tmpIndex ; } } 
function ( list , index , target , record , e ) { var me = this , store = list . getStore ( ) , node = store . getAt ( index ) ; me . fireEvent ( 'itemtap' , this , list , index , target , record , e ) ; if ( node . isLeaf ( ) ) { me . fireEvent ( 'leafitemtap' , this , list , index , target , record , e ) ; me . goToLeaf ( node ) ; } else { this . goToNode ( node ) ; } } 
function ( ) { var me = this , node = me . getLastNode ( ) , detailCard = me . getDetailCard ( ) , detailCardActive = detailCard && me . getActiveItem ( ) == detailCard , lastActiveList = me . getLastActiveList ( ) ; this . fireAction ( 'back' , [ this , node , lastActiveList , detailCardActive ] , 'doBack' ) ; } 
function ( node ) { if ( ! node ) { return ; } var me = this , activeItem = me . getActiveItem ( ) , detailCard = me . getDetailCard ( ) , detailCardActive = detailCard && me . getActiveItem ( ) == detailCard , reverse = me . goToNodeReverseAnimation ( node ) , firstList = me . firstList , secondList = me . secondList , layout = me . getLayout ( ) , animation = ( layout ) ? layout . getAnimation ( ) : null , list ; 
function ( node ) { if ( ! node . isLeaf ( ) ) { throw new Error ( 'goToLeaf: passed a node which is not a leaf.' ) ; } var me = this , card = me . getDetailCard ( node ) , container = me . getDetailContainer ( ) , sharedContainer = container == this , layout = me . getLayout ( ) , animation = ( layout ) ? layout . getAnimation ( ) : false ; if ( card ) { if ( container . getItems ( ) . indexOf ( card ) === - 1 ) { container . add ( card ) ; } if ( sharedContainer ) { if ( me . getActiveItem ( ) instanceof Ext . dataview . List ) { me . setLastActiveList ( me . getActiveItem ( ) ) ; } me . setLastNode ( node ) ; } if ( animation ) { animation . setReverse ( false ) ; } container . setActiveItem ( card ) ; me . syncToolbar ( ) ; } } 
function hoistFunctions ( program ) { var functions = [ ] ; var body = [ ] ; for ( let line of program . body ) { if ( line . type === 'ExportDefaultDeclaration' ) { if ( line . declaration . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type === 'ExportNamedDeclaration' ) { if ( ! ! line . declaration && line . declaration . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } continue ; } if ( line . type === 'FunctionDeclaration' ) { functions . push ( line ) ; } else { body . push ( line ) ; } } return makeProgram ( [ ... functions , ... body ] ) ; } 
function getAST ( load ) { if ( load . ast ) { return load . ast ; } else { if ( load . source ) { const opts = Object . assign ( { sourceFile : load . sourceFile } , parseOpts ) ; return acorn . parse ( load . source , opts ) ; } else { throw new Error ( 'Cannot get AST!' ) ; } } } 
function ( date ) { return date . replace ( 'ledna' , '1.' ) . replace ( 'nora', 2.') . replace ( 'bezna', 3.') . replace ( 'dubna' , '4.' ) . replace ( 'kvtna', 5.') . replace ( 'ervna', 6.') . replace ( 'ervence', 7.') . replace ( 'srpna' , '8.' ) . replace ( 'z', ' 9 ') . replace ( 'jna', ' 0.') . replace ( 'listopadu' , '11.' ) . replace ( 'prosince' , '12.' ) . replace ( / \s / g , '' ) ; } 
function parseVehicleID ( $ , item ) { let fields = $ ( item ) . find ( 'td' ) ; let id = $ ( fields [ 1 ] ) . find ( 'a' ) . attr ( 'href' ) . replace ( 'Detail.aspx?id=' , '' ) ; return id ; } 
function formatDetails ( details ) { let result = { results : details , count : details . length , time : new Date ( ) . toISOString ( ) } ; return result ; } 
function getByID ( id ) { var url = ` ${ APP_BASE_URL } ${ id } ` ; return request ( url ) . then ( function ( body ) { let $ = cheerio . load ( body ) ; let info = { url : url , id : id } ; $ ( 'table#searchTableResults tr' ) . each ( ( i , item ) => { let span = $ ( item ) . find ( 'span' ) ; let key = $ ( span ) . attr ( 'id' ) . replace ( 'ctl00_Application_lbl' , '' ) . toLowerCase ( ) ; let value = $ ( span ) . text ( ) . trim ( ) ; info [ translations [ key ] || key ] = value ; } ) ; info . stolendate = getStandardizedDateStr ( info . stolendate ) ; return info ; } ) ; } 
function ( searchQuery ) { return request ( constructSearchUrl ( searchQuery ) ) . then ( function ( body ) { let $ = cheerio . load ( body ) ; let rows = $ ( 'table#celacr tr' ) ; let promises = rows . filter ( idx => idx >= 1 ) 
function ( config ) { if ( ! config . callback ) { Ext . Logger . error ( 'You must specify a `callback` for `#canMakePayments` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#canMakePayments' , callbacks : { callback : function ( flag ) { config . callback . call ( config . scope || this , flag ) ; } } , scope : config . scope || this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#getProducts` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#getProducts` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#getProducts' , productInfos : JSON . stringify ( config . productInfos ) , callbacks : { success : function ( products ) { var store = Ext . create ( 'Ext.data.Store' , { model : 'Ext.device.Purchases.Product' , data : products } ) ; config . success . call ( config . scope || this , store ) ; } , failure : config . failure } , scope : config . scope || this } ) ; } 
function ( config ) { if ( ! config . callback ) { Ext . Logger . error ( 'You must specify a `callback` for `#getPurchases` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#getPurchases' , callbacks : { callback : function ( purchases ) { var ln = purchases . length , i ; for ( i = 0 ; i < ln ; i ++ ) { purchases [ i ] . state = 'charged' ; } var store = Ext . create ( 'Ext.data.Store' , { model : 'Ext.device.purchases.Purchase' , data : purchases } ) ; config . callback . call ( config . scope || this , store ) ; } } , scope : config . scope || this } ) ; } 
function ( config ) { if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#purchase` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#purchase` to work.' ) ; return false ; } Ext . device . Communicator . send ( { command : 'Purchase#purchase' , identifier : this . get ( 'productIdentifier' ) , callbacks : { success : config . success , failure : config . failure } , scope : config . scope || this } ) ; } 
function ( config ) { var me = this ; if ( ! config . success ) { Ext . Logger . error ( 'You must specify a `success` callback for `#complete` to work.' ) ; return false ; } if ( ! config . failure ) { Ext . Logger . error ( 'You must specify a `failure` callback for `#complete` to work.' ) ; return false ; } if ( this . get ( 'state' ) != 'charged' ) { config . failure . call ( config . scope || this , 'purchase is not charged' ) ; } Ext . device . Communicator . send ( { command : 'Purchase#complete' , identifier : me . get ( 'transactionIdentifier' ) , callbacks : { success : function ( ) { me . set ( 'state' , 'completed' ) ; config . success . call ( config . scope || this ) ; } , failure : function ( ) { me . set ( 'state' , 'charged' ) ; config . failure . call ( config . scope || this ) ; } } , scope : config . scope || this } ) ; } 
function ( operation , callback , scope ) { var me = this , reader = me . getReader ( ) ; if ( operation . process ( 'read' , reader . process ( me . getData ( ) ) ) === false ) { this . fireEvent ( 'exception' , this , null , operation ) ; } Ext . callback ( callback , scope || me , [ operation ] ) ; } 
function pdf ( x , mu , sigma ) { if ( sigma === 0 ) { return x === mu ? Number . POSITIVE_INFINITY : 0 ; } var s2 = pow ( sigma , 2 ) , A = 1 / ( sqrt ( 2 * s2 * PI ) ) , B = - 1 / ( 2 * s2 ) ; return A * exp ( B * pow ( x - mu , 2 ) ) ; } 
function requireAllEnum ( dir ) { if ( ! fs . existsSync ( dir ) ) { return ; } log . verbose ( ` ` ) ; var files = fs . readdirSync ( dir ) . filter ( ( file ) => ( ( file . startsWith ( "E" ) && file . endsWith ( ".js" ) ) ) ) ; for ( var file of files ) { var fileName = file . substring ( 0 , file . lastIndexOf ( ".js" ) ) ; global [ fileName ] = require ( path . resolve ( dir , file ) ) ; log . verbose ( ` ${ file } ` ) ; } } 
function requireAllInterceptor ( dir ) { if ( ! fs . existsSync ( dir ) ) { return ; } log . verbose ( ` ` ) ; global [ 'BaseInterceptorHandler' ] = require ( path . resolve ( dir , 'BaseInterceptorHandler' ) ) ; log . verbose ( ` ` ) ; } 
function ( key ) { this . key = key ; this . keyType = key . split ( " " ) [ 0 ] ; this . rawkey = key . split ( " " ) [ 1 ] ; try { this . keyComment = key . split ( " " ) [ 2 ] ; } catch ( err ) { this . keyComment = null ; } this . byteArray = this . _stringToBytes ( atob ( this . rawkey ) ) ; this . slicedArray = [ ] ; this . wordLength = 4 ; this . _load ( ) ; } 
function ( sourceFunc , boundFunc , context , callingContext , args ) { if ( ! ( callingContext instanceof boundFunc ) ) return sourceFunc . apply ( context , args ) ; Ctor . prototype = sourceFunc . prototype ; var self = new Ctor ; Ctor . prototype = null ; var result = sourceFunc . apply ( self , args ) ; if ( _ . isObject ( result ) ) return result ; return self ; } 
function ( e ) { var me = this , oldChecked = me . _checked , newChecked = me . getChecked ( ) ; 
function ( ) { var values = [ ] ; this . getSameGroupFields ( ) . forEach ( function ( field ) { if ( field . getChecked ( ) ) { values . push ( field . getValue ( ) ) ; } } ) ; return values ; } 
function ( values ) { this . getSameGroupFields ( ) . forEach ( function ( field ) { field . setChecked ( ( values . indexOf ( field . getValue ( ) ) !== - 1 ) ) ; } ) ; return this ; } 
function ( e ) { var me = this ; if ( e . target != me . element . dom ) { return ; } if ( me . getDeselectOnContainerClick ( ) && me . getStore ( ) ) { me . deselectAll ( ) ; } } 
function ( record , suppressEvent ) { var me = this ; if ( suppressEvent ) { me . doItemSelect ( me , record ) ; } else { me . fireAction ( 'select' , [ me , record ] , 'doItemSelect' ) ; } } 
function ( record , suppressEvent ) { var me = this ; if ( me . container && ! me . isDestroyed ) { if ( suppressEvent ) { me . doItemDeselect ( me , record ) ; } else { me . fireAction ( 'deselect' , [ me , record , suppressEvent ] , 'doItemDeselect' ) ; } } } 
function ( ) { var me = this , container = me . container ; if ( ! me . getStore ( ) ) { if ( ! me . hasLoadedStore && ! me . getDeferEmptyText ( ) ) { me . showEmptyText ( ) ; } return ; } if ( container ) { me . fireAction ( 'refresh' , [ me ] , 'doRefresh' ) ; } } 
function Strategy ( options , verify ) { options = options || { } ; options . clientID = options . clientID || { } ; options . clientSecret = options . clientSecret || { } ; options . grant_type = "password" ; options . skipUserProfile = true ; options . authorizationURL = options . authorizationURL || 'https://winkapi.quirky.com/oauth2/token' ; options . tokenURL = options . tokenURL || 'https://winkapi.quirky.com/oauth2/token' ; OAuth2Strategy . call ( this , options , verify ) ; this . name = 'wink' ; } 
function processParams ( paramsString ) { var individualParams = paramsString . split ( "&" ) , resultObject = { } ; individualParams . forEach ( function ( item ) { var itemParts = item . split ( "=" ) , paramName = itemParts [ 0 ] , paramValue = decodeURIComponent ( itemParts [ 1 ] || "" ) ; var paramObject = { } ; paramObject [ paramName ] = paramValue ; $ . extend ( resultObject , paramObject ) ; } ) ; return resultObject ; } 
function ( config ) { if ( ! this . _store ) { this . _store = [ { first : 'Robert' , last : 'Dougan' , emails : { work : 'rob@sencha.com' } } , { first : 'Jamie' , last : 'Avins' , emails : { work : 'jamie@sencha.com' } } ] ; } config . success . call ( config . scope || this , this . _store ) ; } 
function ( config ) { config . callback . call ( config . scope || this , config . label . toUpperCase ( ) , config . label ) ; } 
function Collection ( options ) { if ( ! ( this instanceof Collection ) ) { return new Collection ( options ) ; } options = options || { } ; if ( options instanceof Array ) { this . modelType = undefined ; this . items = options ; } else { this . modelType = options . modelType ; this . items = options . items || [ ] ; if ( ! ( this . items instanceof Array ) ) { throw new CollectionException ( 'Items must be an array' ) ; } } } 
function find ( filter ) { var item ; var i ; var ilen ; var keys ; var key ; var k ; var klen ; var found ; if ( filter instanceof Function ) { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; if ( filter ( item , i ) ) { return item ; } } } else if ( filter !== null && filter !== undefined ) { if ( typeof filter === 'object' ) { keys = Object . keys ( filter ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = true ; for ( k = 0 ; k < klen && found ; ++ k ) { key = keys [ k ] ; if ( filter [ key ] !== item [ key ] ) { found = false ; } } if ( found ) { return item ; } } } else if ( this . modelType ) { keys = Object . keys ( this . modelType . attributes ) ; klen = keys . length ; for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; for ( k = 0 ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } else { for ( i = 0 , ilen = this . items . length ; i < ilen ; ++ i ) { item = this . items [ i ] ; found = false ; keys = Object . keys ( item ) ; for ( k = 0 , klen = keys . length ; k < klen && ! found ; ++ k ) { key = keys [ k ] ; if ( filter === item [ key ] ) { found = true ; } } if ( found ) { return item ; } } } } return undefined ; } 
function ( context , grunt ) { this . context = context ; this . grunt = grunt ; 
